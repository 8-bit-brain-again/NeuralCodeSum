public function getAuthentication ( $ repositoryName ) { if ( isset ( $ this -> authentications [ $ repositoryName ] ) ) { return $ this -> authentications [ $ repositoryName ] ; } return array ( 'username' => null , 'password' => null ) ; } 
public function setAuthentication ( $ repositoryName , $ username , $ password = null ) { $ this -> authentications [ $ repositoryName ] = array ( 'username' => $ username , 'password' => $ password ) ; } 
protected function checkAndSetAuthentication ( $ repositoryName , $ username , $ password = null ) { if ( $ this -> hasAuthentication ( $ repositoryName ) ) { $ auth = $ this -> getAuthentication ( $ repositoryName ) ; if ( $ auth [ 'username' ] === $ username && $ auth [ 'password' ] === $ password ) { return ; } $ this -> writeError ( sprintf ( "<warning>Warning: You should avoid overwriting already defined auth settings for %s.</warning>" , $ repositoryName ) ) ; } $ this -> setAuthentication ( $ repositoryName , $ username , $ password ) ; } 
public function loadConfiguration ( Config $ config ) { $ bitbucketOauth = $ config -> get ( 'bitbucket-oauth' ) ? : array ( ) ; $ githubOauth = $ config -> get ( 'github-oauth' ) ? : array ( ) ; $ gitlabOauth = $ config -> get ( 'gitlab-oauth' ) ? : array ( ) ; $ gitlabToken = $ config -> get ( 'gitlab-token' ) ? : array ( ) ; $ httpBasic = $ config -> get ( 'http-basic' ) ? : array ( ) ; 
public function log ( $ level , $ message , array $ context = array ( ) ) { if ( in_array ( $ level , array ( LogLevel :: EMERGENCY , LogLevel :: ALERT , LogLevel :: CRITICAL , LogLevel :: ERROR ) ) ) { $ this -> writeError ( '<error>' . $ message . '</error>' , true , self :: NORMAL ) ; } elseif ( $ level === LogLevel :: WARNING ) { $ this -> writeError ( '<warning>' . $ message . '</warning>' , true , self :: NORMAL ) ; } elseif ( $ level === LogLevel :: NOTICE ) { $ this -> writeError ( '<info>' . $ message . '</info>' , true , self :: VERBOSE ) ; } elseif ( $ level === LogLevel :: INFO ) { $ this -> writeError ( '<info>' . $ message . '</info>' , true , self :: VERY_VERBOSE ) ; } else { $ this -> writeError ( $ message , true , self :: DEBUG ) ; } } 
public function findRecommendedRequireVersion ( PackageInterface $ package ) { $ version = $ package -> getVersion ( ) ; if ( ! $ package -> isDev ( ) ) { return $ this -> transformVersion ( $ version , $ package -> getPrettyVersion ( ) , $ package -> getStability ( ) ) ; } $ loader = new ArrayLoader ( $ this -> getParser ( ) ) ; $ dumper = new ArrayDumper ( ) ; $ extra = $ loader -> getBranchAlias ( $ dumper -> dump ( $ package ) ) ; if ( $ extra ) { $ extra = preg_replace ( '{^(\d+\.\d+\.\d+)(\.9999999)-dev$}' , '$1.0' , $ extra , - 1 , $ count ) ; if ( $ count ) { $ extra = str_replace ( '.9999999' , '.0' , $ extra ) ; return $ this -> transformVersion ( $ extra , $ extra , 'dev' ) ; } } return $ package -> getPrettyVersion ( ) ; } 
public function initialize ( ) { if ( ! preg_match ( self :: URL_REGEX , $ this -> url , $ match ) ) { throw new \ InvalidArgumentException ( 'The URL provided is invalid. It must be the HTTP URL of a GitLab project.' ) ; } $ guessedDomain = ! empty ( $ match [ 'domain' ] ) ? $ match [ 'domain' ] : $ match [ 'domain2' ] ; $ configuredDomains = $ this -> config -> get ( 'gitlab-domains' ) ; $ urlParts = explode ( '/' , $ match [ 'parts' ] ) ; $ this -> scheme = ! empty ( $ match [ 'scheme' ] ) ? $ match [ 'scheme' ] : ( isset ( $ this -> repoConfig [ 'secure-http' ] ) && $ this -> repoConfig [ 'secure-http' ] === false ? 'http' : 'https' ) ; $ this -> originUrl = $ this -> determineOrigin ( $ configuredDomains , $ guessedDomain , $ urlParts ) ; if ( ! empty ( $ match [ 'port' ] ) && true === is_numeric ( $ match [ 'port' ] ) ) { 
public function getChangeDate ( $ identifier ) { if ( $ this -> gitDriver ) { return $ this -> gitDriver -> getChangeDate ( $ identifier ) ; } if ( isset ( $ this -> commits [ $ identifier ] ) ) { return new \ DateTime ( $ this -> commits [ $ identifier ] [ 'committed_date' ] ) ; } return new \ DateTime ( ) ; } 
public function getSource ( $ identifier ) { if ( $ this -> gitDriver ) { return $ this -> gitDriver -> getSource ( $ identifier ) ; } return array ( 'type' => 'git' , 'url' => $ this -> getRepositoryUrl ( ) , 'reference' => $ identifier ) ; } 
public function getBranches ( ) { if ( $ this -> gitDriver ) { return $ this -> gitDriver -> getBranches ( ) ; } if ( ! $ this -> branches ) { $ this -> branches = $ this -> getReferences ( 'branches' ) ; } return $ this -> branches ; } 
public function getTags ( ) { if ( $ this -> gitDriver ) { return $ this -> gitDriver -> getTags ( ) ; } if ( ! $ this -> tags ) { $ this -> tags = $ this -> getReferences ( 'tags' ) ; } return $ this -> tags ; } 
private function urlEncodeAll ( $ string ) { $ encoded = '' ; for ( $ i = 0 ; isset ( $ string [ $ i ] ) ; $ i ++ ) { $ character = $ string [ $ i ] ; if ( ! ctype_alnum ( $ character ) && ! in_array ( $ character , array ( '-' , '_' ) , true ) ) { $ character = '%' . sprintf ( '%02X' , ord ( $ character ) ) ; } $ encoded .= $ character ; } return $ encoded ; } 
protected function getReferences ( $ type ) { $ perPage = 100 ; $ resource = $ this -> getApiUrl ( ) . '/repository/' . $ type . '?per_page=' . $ perPage ; $ references = array ( ) ; do { $ data = JsonFile :: parseJson ( $ this -> getContents ( $ resource ) , $ resource ) ; foreach ( $ data as $ datum ) { $ references [ $ datum [ 'name' ] ] = $ datum [ 'commit' ] [ 'id' ] ; 
public static function supports ( IOInterface $ io , Config $ config , $ url , $ deep = false ) { if ( ! preg_match ( self :: URL_REGEX , $ url , $ match ) ) { return false ; } $ scheme = ! empty ( $ match [ 'scheme' ] ) ? $ match [ 'scheme' ] : null ; $ guessedDomain = ! empty ( $ match [ 'domain' ] ) ? $ match [ 'domain' ] : $ match [ 'domain2' ] ; $ urlParts = explode ( '/' , $ match [ 'parts' ] ) ; if ( false === self :: determineOrigin ( ( array ) $ config -> get ( 'gitlab-domains' ) , $ guessedDomain , $ urlParts ) ) { return false ; } if ( 'https' === $ scheme && ! extension_loaded ( 'openssl' ) ) { $ io -> writeError ( 'Skipping GitLab driver for ' . $ url . ' because the OpenSSL PHP extension is missing.' , true , IOInterface :: VERBOSE ) ; return false ; } return true ; } 
public function getRootIdentifier ( ) { if ( $ this -> fallbackDriver ) { return $ this -> fallbackDriver -> getRootIdentifier ( ) ; } if ( null === $ this -> rootIdentifier ) { if ( ! $ this -> getRepoData ( ) ) { return $ this -> fallbackDriver -> getRootIdentifier ( ) ; } if ( $ this -> vcsType !== 'git' ) { throw new \ RuntimeException ( $ this -> url . ' does not appear to be a git repository, use ' . $ this -> cloneHttpsUrl . ' if this is a mercurial bitbucket repository' ) ; } $ mainBranchData = $ this -> getMainBranchData ( ) ; $ this -> rootIdentifier = ! empty ( $ mainBranchData [ 'name' ] ) ? $ mainBranchData [ 'name' ] : 'master' ; } return $ this -> rootIdentifier ; } 
public function doDownload ( PackageInterface $ package , $ path , $ url ) { 
protected function getCommitLogs ( $ fromReference , $ toReference , $ path ) { $ command = sprintf ( 'fossil timeline -t ci -W 0 -n 0 before %s' , ProcessExecutor :: escape ( $ toReference ) ) ; if ( 0 !== $ this -> process -> execute ( $ command , $ output , realpath ( $ path ) ) ) { throw new \ RuntimeException ( 'Failed to execute ' . $ command . "\n\n" . $ this -> process -> getErrorOutput ( ) ) ; } $ log = '' ; $ match = '/\d\d:\d\d:\d\d\s+\[' . $ toReference . '\]/' ; foreach ( $ this -> process -> splitLines ( $ output ) as $ line ) { if ( preg_match ( $ match , $ line ) ) { break ; } $ log .= $ line ; } return $ log ; } 
public function doDownload ( PackageInterface $ package , $ path , $ url ) { $ ref = $ package -> getSourceReference ( ) ; $ label = $ this -> getLabelFromSourceReference ( $ ref ) ; $ this -> io -> writeError ( 'Cloning ' . $ ref ) ; $ this -> initPerforce ( $ package , $ path , $ url ) ; $ this -> perforce -> setStream ( $ ref ) ; $ this -> perforce -> p4Login ( ) ; $ this -> perforce -> writeP4ClientSpec ( ) ; $ this -> perforce -> connectClient ( ) ; $ this -> perforce -> syncCodeBase ( $ label ) ; $ this -> perforce -> cleanupClientSpec ( ) ; } 
public function doUpdate ( PackageInterface $ initial , PackageInterface $ target , $ path , $ url ) { $ this -> doDownload ( $ target , $ path , $ url ) ; } 
public function buildDependencyInfo ( $ depArray ) { if ( ! is_array ( $ depArray ) ) { return new DependencyInfo ( array ( ) , array ( ) ) ; } if ( ! $ this -> isHash ( $ depArray ) ) { return new DependencyInfo ( $ this -> buildDependency10Info ( $ depArray ) , array ( ) ) ; } return $ this -> buildDependency20Info ( $ depArray ) ; } 
private function buildDependency10Info ( $ depArray ) { static $ dep10toOperatorMap = array ( 'has' => '==' , 'eq' => '==' , 'ge' => '>=' , 'gt' => '>' , 'le' => '<=' , 'lt' => '<' , 'not' => '!=' ) ; $ result = array ( ) ; foreach ( $ depArray as $ depItem ) { if ( empty ( $ depItem [ 'rel' ] ) || ! array_key_exists ( $ depItem [ 'rel' ] , $ dep10toOperatorMap ) ) { 
private function buildDependency20Info ( $ depArray ) { $ result = array ( ) ; $ optionals = array ( ) ; $ defaultOptionals = array ( ) ; foreach ( $ depArray as $ depType => $ depTypeGroup ) { if ( ! is_array ( $ depTypeGroup ) ) { continue ; } if ( 'required' == $ depType || 'optional' == $ depType ) { foreach ( $ depTypeGroup as $ depItemType => $ depItem ) { switch ( $ depItemType ) { case 'php' : $ result [ ] = new DependencyConstraint ( $ depType , $ this -> parse20VersionConstraint ( $ depItem ) , 'php' , '' ) ; break ; case 'package' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'extension' : $ deps = $ this -> buildDepExtensionConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'subpackage' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , 'replaces' ) ; $ defaultOptionals += $ deps ; break ; case 'os' : case 'pearinstaller' : break ; default : break ; } } } elseif ( 'group' == $ depType ) { if ( $ this -> isHash ( $ depTypeGroup ) ) { $ depTypeGroup = array ( $ depTypeGroup ) ; } foreach ( $ depTypeGroup as $ depItem ) { $ groupName = $ depItem [ 'attribs' ] [ 'name' ] ; if ( ! isset ( $ optionals [ $ groupName ] ) ) { $ optionals [ $ groupName ] = array ( ) ; } if ( isset ( $ depItem [ 'subpackage' ] ) ) { $ optionals [ $ groupName ] += $ this -> buildDepPackageConstraints ( $ depItem [ 'subpackage' ] , 'replaces' ) ; } else { $ result += $ this -> buildDepPackageConstraints ( $ depItem [ 'package' ] , 'optional' ) ; } } } } if ( count ( $ defaultOptionals ) > 0 ) { $ optionals [ '*' ] = $ defaultOptionals ; } return new DependencyInfo ( $ result , $ optionals ) ; } 
private function buildDepExtensionConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { $ depChannelName = 'ext' ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; } 
private function buildDepPackageConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { if ( ! array_key_exists ( 'channel' , $ subDepItem ) ) { $ subDepItem [ 'channel' ] = $ subDepItem [ 'uri' ] ; } $ depChannelName = $ subDepItem [ 'channel' ] ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; if ( isset ( $ subDepItem [ 'conflicts' ] ) ) { $ depType = 'conflicts' ; } $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; } 
private function parse20VersionConstraint ( array $ data ) { static $ dep20toOperatorMap = array ( 'has' => '==' , 'min' => '>=' , 'max' => '<=' , 'exclude' => '!=' ) ; $ versions = array ( ) ; $ values = array_intersect_key ( $ data , $ dep20toOperatorMap ) ; if ( 0 == count ( $ values ) ) { return '*' ; } if ( isset ( $ values [ 'min' ] ) && isset ( $ values [ 'exclude' ] ) && $ data [ 'min' ] == $ data [ 'exclude' ] ) { $ versions [ ] = '>' . $ this -> parseVersion ( $ values [ 'min' ] ) ; } elseif ( isset ( $ values [ 'max' ] ) && isset ( $ values [ 'exclude' ] ) && $ data [ 'max' ] == $ data [ 'exclude' ] ) { $ versions [ ] = '<' . $ this -> parseVersion ( $ values [ 'max' ] ) ; } else { foreach ( $ values as $ op => $ version ) { if ( 'exclude' == $ op && is_array ( $ version ) ) { foreach ( $ version as $ versionPart ) { $ versions [ ] = $ dep20toOperatorMap [ $ op ] . $ this -> parseVersion ( $ versionPart ) ; } } else { $ versions [ ] = $ dep20toOperatorMap [ $ op ] . $ this -> parseVersion ( $ version ) ; } } } return implode ( ',' , $ versions ) ; } 
private function parseVersion ( $ version ) { if ( preg_match ( '{^v?(\d{1,3})(\.\d+)?(\.\d+)?(\.\d+)?}i' , $ version , $ matches ) ) { $ version = $ matches [ 1 ] . ( ! empty ( $ matches [ 2 ] ) ? $ matches [ 2 ] : '.0' ) . ( ! empty ( $ matches [ 3 ] ) ? $ matches [ 3 ] : '.0' ) . ( ! empty ( $ matches [ 4 ] ) ? $ matches [ 4 ] : '.0' ) ; return $ version ; } return null ; } 
public function fix ( $ packageName , ConstraintInterface $ constraint = null ) { $ this -> addJob ( $ packageName , 'install' , $ constraint , true ) ; } 
public function authorizeOAuth ( $ originUrl ) { if ( ! in_array ( $ originUrl , $ this -> config -> get ( 'gitlab-domains' ) , true ) ) { return false ; } 
private function movePluginsToFront ( array $ operations ) { $ pluginsNoDeps = array ( ) ; $ pluginsWithDeps = array ( ) ; $ pluginRequires = array ( ) ; foreach ( array_reverse ( $ operations , true ) as $ idx => $ op ) { if ( $ op instanceof InstallOperation ) { $ package = $ op -> getPackage ( ) ; } elseif ( $ op instanceof UpdateOperation ) { $ package = $ op -> getTargetPackage ( ) ; } else { continue ; } 
private function moveUninstallsToFront ( array $ operations ) { $ uninstOps = array ( ) ; foreach ( $ operations as $ idx => $ op ) { if ( $ op instanceof UninstallOperation ) { $ uninstOps [ ] = $ op ; unset ( $ operations [ $ idx ] ) ; } } return array_merge ( $ uninstOps , $ operations ) ; } 
private function getCurrentPackages ( $ installedRepo ) { if ( $ this -> locker -> isLocked ( ) ) { try { return $ this -> locker -> getLockedRepository ( true ) -> getPackages ( ) ; } catch ( \ RuntimeException $ e ) { 
private function mockLocalRepositories ( RepositoryManager $ rm ) { $ packages = array ( ) ; foreach ( $ rm -> getLocalRepository ( ) -> getPackages ( ) as $ package ) { $ packages [ ( string ) $ package ] = clone $ package ; } foreach ( $ packages as $ key => $ package ) { if ( $ package instanceof AliasPackage ) { $ alias = ( string ) $ package -> getAliasOf ( ) ; $ packages [ $ key ] = new AliasPackage ( $ packages [ $ alias ] , $ package -> getVersion ( ) , $ package -> getPrettyVersion ( ) ) ; } } $ rm -> setLocalRepository ( new InstalledArrayRepository ( $ packages ) ) ; } 
public static function create ( IOInterface $ io , Composer $ composer ) { return new static ( $ io , $ composer -> getConfig ( ) , $ composer -> getPackage ( ) , $ composer -> getDownloadManager ( ) , $ composer -> getRepositoryManager ( ) , $ composer -> getLocker ( ) , $ composer -> getInstallationManager ( ) , $ composer -> getEventDispatcher ( ) , $ composer -> getAutoloadGenerator ( ) ) ; } 
public function setOptimizeAutoloader ( $ optimizeAutoloader = false ) { $ this -> optimizeAutoloader = ( bool ) $ optimizeAutoloader ; if ( ! $ this -> optimizeAutoloader ) { 
public function setClassMapAuthoritative ( $ classMapAuthoritative = false ) { $ this -> classMapAuthoritative = ( bool ) $ classMapAuthoritative ; if ( $ this -> classMapAuthoritative ) { 
public function copyTo ( $ file , $ target ) { if ( $ this -> enabled ) { $ file = preg_replace ( '{[^' . $ this -> whitelist . ']}i' , '-' , $ file ) ; if ( file_exists ( $ this -> root . $ file ) ) { try { touch ( $ this -> root . $ file , filemtime ( $ this -> root . $ file ) , time ( ) ) ; } catch ( \ ErrorException $ e ) { 
public function getSource ( $ identifier ) { $ source = array ( 'type' => 'perforce' , 'url' => $ this -> repoConfig [ 'url' ] , 'reference' => $ identifier , 'p4user' => $ this -> perforce -> getUser ( ) , ) ; return $ source ; } 
public function hasComposerFile ( $ identifier ) { $ composerInfo = $ this -> perforce -> getComposerInformation ( '//' . $ this -> depot . '/' . $ identifier ) ; $ composerInfoIdentifier = $ identifier ; return ! empty ( $ composerInfo ) ; } 
public static function supports ( IOInterface $ io , Config $ config , $ url , $ deep = false ) { if ( $ deep || preg_match ( '#\b(perforce|p4)\b#i' , $ url ) ) { return Perforce :: checkServerExists ( $ url , new ProcessExecutor ( $ io ) ) ; } return false ; } 
public function getSourceUrls ( ) { return $ this -> getUrls ( $ this -> sourceUrl , $ this -> sourceMirrors , $ this -> sourceReference , $ this -> sourceType , 'source' ) ; } 
public function getDistUrls ( ) { return $ this -> getUrls ( $ this -> distUrl , $ this -> distMirrors , $ this -> distReference , $ this -> distType , 'dist' ) ; } 
public function replaceVersion ( $ version , $ prettyVersion ) { $ this -> version = $ version ; $ this -> prettyVersion = $ prettyVersion ; $ this -> stability = VersionParser :: parseStability ( $ version ) ; $ this -> dev = $ this -> stability === 'dev' ; } 
public static function getContentHash ( $ composerFileContents ) { $ content = json_decode ( $ composerFileContents , true ) ; $ relevantKeys = array ( 'name' , 'version' , 'require' , 'require-dev' , 'conflict' , 'replace' , 'provide' , 'minimum-stability' , 'prefer-stable' , 'repositories' , 'extra' , ) ; $ relevantContent = array ( ) ; foreach ( array_intersect ( $ relevantKeys , array_keys ( $ content ) ) as $ key ) { $ relevantContent [ $ key ] = $ content [ $ key ] ; } if ( isset ( $ content [ 'config' ] [ 'platform' ] ) ) { $ relevantContent [ 'config' ] [ 'platform' ] = $ content [ 'config' ] [ 'platform' ] ; } ksort ( $ relevantContent ) ; return md5 ( json_encode ( $ relevantContent ) ) ; } 
public function isLocked ( ) { if ( ! $ this -> lockFile -> exists ( ) ) { return false ; } $ data = $ this -> getLockData ( ) ; return isset ( $ data [ 'packages' ] ) ; } 
public function getLockedRepository ( $ withDevReqs = false ) { $ lockData = $ this -> getLockData ( ) ; $ packages = new ArrayRepository ( ) ; $ lockedPackages = $ lockData [ 'packages' ] ; if ( $ withDevReqs ) { if ( isset ( $ lockData [ 'packages-dev' ] ) ) { $ lockedPackages = array_merge ( $ lockedPackages , $ lockData [ 'packages-dev' ] ) ; } else { throw new \ RuntimeException ( 'The lock file does not contain require-dev information, run install with the --no-dev option or run update to install those packages.' ) ; } } if ( empty ( $ lockedPackages ) ) { return $ packages ; } if ( isset ( $ lockedPackages [ 0 ] [ 'name' ] ) ) { foreach ( $ lockedPackages as $ info ) { $ packages -> addPackage ( $ this -> loader -> load ( $ info ) ) ; } return $ packages ; } throw new \ RuntimeException ( 'Your composer.lock was created before 2012-09-15, and is not supported anymore. Run "composer update" to generate a new one.' ) ; } 
private function getPackageTime ( PackageInterface $ package ) { if ( ! function_exists ( 'proc_open' ) ) { return null ; } $ path = realpath ( $ this -> installationManager -> getInstallPath ( $ package ) ) ; $ sourceType = $ package -> getSourceType ( ) ; $ datetime = null ; if ( $ path && in_array ( $ sourceType , array ( 'git' , 'hg' ) ) ) { $ sourceRef = $ package -> getSourceReference ( ) ? : $ package -> getDistReference ( ) ; switch ( $ sourceType ) { case 'git' : GitUtil :: cleanEnv ( ) ; if ( 0 === $ this -> process -> execute ( 'git log -n1 --pretty=%ct ' . ProcessExecutor :: escape ( $ sourceRef ) , $ output , $ path ) && preg_match ( '{^\s*\d+\s*$}' , $ output ) ) { $ datetime = new \ DateTime ( '@' . trim ( $ output ) , new \ DateTimeZone ( 'UTC' ) ) ; } break ; case 'hg' : if ( 0 === $ this -> process -> execute ( 'hg log --template "{date|hgdate}" -r ' . ProcessExecutor :: escape ( $ sourceRef ) , $ output , $ path ) && preg_match ( '{^\s*(\d+)\s*}' , $ output , $ match ) ) { $ datetime = new \ DateTime ( '@' . $ match [ 1 ] , new \ DateTimeZone ( 'UTC' ) ) ; } break ; } } return $ datetime ? $ datetime -> format ( DATE_RFC3339 ) : null ; } 
protected function formatPackagesUnique ( $ pool , array $ packages ) { $ prepared = array ( ) ; foreach ( $ packages as $ package ) { if ( ! is_object ( $ package ) ) { $ package = $ pool -> literalToPackage ( $ package ) ; } $ prepared [ $ package -> getName ( ) ] [ 'name' ] = $ package -> getPrettyName ( ) ; $ prepared [ $ package -> getName ( ) ] [ 'versions' ] [ $ package -> getVersion ( ) ] = $ package -> getPrettyVersion ( ) ; } foreach ( $ prepared as $ name => $ package ) { $ prepared [ $ name ] = $ package [ 'name' ] . '[' . implode ( ', ' , $ package [ 'versions' ] ) . ']' ; } return implode ( ', ' , $ prepared ) ; } 
public function install ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { $ extra = $ package -> getExtra ( ) ; if ( empty ( $ extra [ 'class' ] ) ) { throw new \ UnexpectedValueException ( 'Error while installing ' . $ package -> getPrettyName ( ) . ', composer-plugin packages should have a class defined in their extra key to be usable.' ) ; } parent :: install ( $ repo , $ package ) ; try { $ this -> composer -> getPluginManager ( ) -> registerPackage ( $ package , true ) ; } catch ( \ Exception $ e ) { 
public function update ( InstalledRepositoryInterface $ repo , PackageInterface $ initial , PackageInterface $ target ) { $ extra = $ target -> getExtra ( ) ; if ( empty ( $ extra [ 'class' ] ) ) { throw new \ UnexpectedValueException ( 'Error while installing ' . $ target -> getPrettyName ( ) . ', composer-plugin packages should have a class defined in their extra key to be usable.' ) ; } parent :: update ( $ repo , $ initial , $ target ) ; $ this -> composer -> getPluginManager ( ) -> registerPackage ( $ target , true ) ; } 
public function initialize ( ) { preg_match ( '#^https?://bitbucket\.org/([^/]+)/([^/]+?)(\.git|/?)$#' , $ this -> url , $ match ) ; $ this -> owner = $ match [ 1 ] ; $ this -> repository = $ match [ 2 ] ; $ this -> originUrl = 'bitbucket.org' ; $ this -> cache = new Cache ( $ this -> io , implode ( '/' , array ( $ this -> config -> get ( 'cache-repo-dir' ) , $ this -> originUrl , $ this -> owner , $ this -> repository , ) ) ) ; } 
protected function getRepoData ( ) { $ resource = sprintf ( 'https://api.bitbucket.org/2.0/repositories/%s/%s?%s' , $ this -> owner , $ this -> repository , http_build_query ( array ( 'fields' => '-project,-owner' ) , null , '&' ) ) ; $ repoData = JsonFile :: parseJson ( $ this -> getContentsWithOAuthCredentials ( $ resource , true ) , $ resource ) ; if ( $ this -> fallbackDriver ) { return false ; } $ this -> parseCloneUrls ( $ repoData [ 'links' ] [ 'clone' ] ) ; $ this -> hasIssues = ! empty ( $ repoData [ 'has_issues' ] ) ; $ this -> branchesUrl = $ repoData [ 'links' ] [ 'branches' ] [ 'href' ] ; $ this -> tagsUrl = $ repoData [ 'links' ] [ 'tags' ] [ 'href' ] ; $ this -> homeUrl = $ repoData [ 'links' ] [ 'html' ] [ 'href' ] ; $ this -> website = $ repoData [ 'website' ] ; $ this -> vcsType = $ repoData [ 'scm' ] ; return true ; } 
public function getFileContent ( $ file , $ identifier ) { if ( $ this -> fallbackDriver ) { return $ this -> fallbackDriver -> getFileContent ( $ file , $ identifier ) ; } if ( strpos ( $ identifier , '/' ) !== false ) { $ branches = $ this -> getBranches ( ) ; if ( isset ( $ branches [ $ identifier ] ) ) { $ identifier = $ branches [ $ identifier ] ; } } $ resource = sprintf ( 'https://api.bitbucket.org/2.0/repositories/%s/%s/src/%s/%s' , $ this -> owner , $ this -> repository , $ identifier , $ file ) ; return $ this -> getContentsWithOAuthCredentials ( $ resource ) ; } 
public function getChangeDate ( $ identifier ) { if ( $ this -> fallbackDriver ) { return $ this -> fallbackDriver -> getChangeDate ( $ identifier ) ; } $ resource = sprintf ( 'https://api.bitbucket.org/2.0/repositories/%s/%s/commit/%s?fields=date' , $ this -> owner , $ this -> repository , $ identifier ) ; $ commit = JsonFile :: parseJson ( $ this -> getContentsWithOAuthCredentials ( $ resource ) , $ resource ) ; return new \ DateTime ( $ commit [ 'date' ] ) ; } 
public function getSource ( $ identifier ) { if ( $ this -> fallbackDriver ) { return $ this -> fallbackDriver -> getSource ( $ identifier ) ; } return array ( 'type' => $ this -> vcsType , 'url' => $ this -> getUrl ( ) , 'reference' => $ identifier ) ; } 
public function getDist ( $ identifier ) { if ( $ this -> fallbackDriver ) { return $ this -> fallbackDriver -> getDist ( $ identifier ) ; } $ url = sprintf ( 'https://bitbucket.org/%s/%s/get/%s.zip' , $ this -> owner , $ this -> repository , $ identifier ) ; return array ( 'type' => 'zip' , 'url' => $ url , 'reference' => $ identifier , 'shasum' => '' ) ; } 
public function getTags ( ) { if ( $ this -> fallbackDriver ) { return $ this -> fallbackDriver -> getTags ( ) ; } if ( null === $ this -> tags ) { $ this -> tags = array ( ) ; $ resource = sprintf ( '%s?%s' , $ this -> tagsUrl , http_build_query ( array ( 'pagelen' => 100 , 'fields' => 'values.name,values.target.hash,next' , 'sort' => '-target.date' , ) , null , '&' ) ) ; $ hasNext = true ; while ( $ hasNext ) { $ tagsData = JsonFile :: parseJson ( $ this -> getContentsWithOAuthCredentials ( $ resource ) , $ resource ) ; foreach ( $ tagsData [ 'values' ] as $ data ) { $ this -> tags [ $ data [ 'name' ] ] = $ data [ 'target' ] [ 'hash' ] ; } if ( empty ( $ tagsData [ 'next' ] ) ) { $ hasNext = false ; } else { $ resource = $ tagsData [ 'next' ] ; } } if ( $ this -> vcsType === 'hg' ) { unset ( $ this -> tags [ 'tip' ] ) ; } } return $ this -> tags ; } 
protected function getContentsWithOAuthCredentials ( $ url , $ fetchingRepoData = false ) { try { return parent :: getContents ( $ url ) ; } catch ( TransportException $ e ) { $ bitbucketUtil = new Bitbucket ( $ this -> io , $ this -> config , $ this -> process , $ this -> remoteFilesystem ) ; if ( 403 === $ e -> getCode ( ) || ( 401 === $ e -> getCode ( ) && strpos ( $ e -> getMessage ( ) , 'Could not authenticate against' ) === 0 ) ) { if ( ! $ this -> io -> hasAuthentication ( $ this -> originUrl ) && $ bitbucketUtil -> authorizeOAuth ( $ this -> originUrl ) ) { return parent :: getContents ( $ url ) ; } if ( ! $ this -> io -> isInteractive ( ) && $ fetchingRepoData ) { return $ this -> attemptCloneFallback ( ) ; } } throw $ e ; } } 
private function makeAssertionRuleDecisions ( ) { $ decisionStart = count ( $ this -> decisions ) - 1 ; $ rulesCount = count ( $ this -> rules ) ; for ( $ ruleIndex = 0 ; $ ruleIndex < $ rulesCount ; $ ruleIndex ++ ) { $ rule = $ this -> rules -> ruleById [ $ ruleIndex ] ; if ( ! $ rule -> isAssertion ( ) || $ rule -> isDisabled ( ) ) { continue ; } $ literals = $ rule -> getLiterals ( ) ; $ literal = $ literals [ 0 ] ; if ( ! $ this -> decisions -> decided ( $ literal ) ) { $ this -> decisions -> decide ( $ literal , 1 , $ rule ) ; continue ; } if ( $ this -> decisions -> satisfy ( $ literal ) ) { continue ; } 
protected function propagate ( $ level ) { while ( $ this -> decisions -> validOffset ( $ this -> propagateIndex ) ) { $ decision = $ this -> decisions -> atOffset ( $ this -> propagateIndex ) ; $ conflict = $ this -> watchGraph -> propagateLiteral ( $ decision [ Decisions :: DECISION_LITERAL ] , $ level , $ this -> decisions ) ; $ this -> propagateIndex ++ ; if ( $ conflict ) { return $ conflict ; } } return null ; } 
private function revert ( $ level ) { while ( ! $ this -> decisions -> isEmpty ( ) ) { $ literal = $ this -> decisions -> lastLiteral ( ) ; if ( $ this -> decisions -> undecided ( $ literal ) ) { break ; } $ decisionLevel = $ this -> decisions -> decisionLevel ( $ literal ) ; if ( $ decisionLevel <= $ level ) { break ; } $ this -> decisions -> revertLast ( ) ; $ this -> propagateIndex = count ( $ this -> decisions ) ; } while ( ! empty ( $ this -> branches ) && $ this -> branches [ count ( $ this -> branches ) - 1 ] [ self :: BRANCH_LEVEL ] >= $ level ) { array_pop ( $ this -> branches ) ; } } 
private function enableDisableLearnedRules ( ) { foreach ( $ this -> rules -> getIteratorFor ( RuleSet :: TYPE_LEARNED ) as $ rule ) { $ why = $ this -> learnedWhy [ spl_object_hash ( $ rule ) ] ; $ problemRules = $ this -> learnedPool [ $ why ] ; $ foundDisabled = false ; foreach ( $ problemRules as $ problemRule ) { if ( $ problemRule -> isDisabled ( ) ) { $ foundDisabled = true ; break ; } } if ( $ foundDisabled && $ rule -> isEnabled ( ) ) { $ rule -> disable ( ) ; } elseif ( ! $ foundDisabled && $ rule -> isDisabled ( ) ) { $ rule -> enable ( ) ; } } } 
private function getUrlMatches ( ) { $ flags = GLOB_MARK | GLOB_ONLYDIR ; if ( defined ( 'GLOB_BRACE' ) ) { $ flags |= GLOB_BRACE ; } elseif ( strpos ( $ this -> url , '{' ) !== false || strpos ( $ this -> url , '}' ) !== false ) { throw new \ RuntimeException ( 'The operating system does not support GLOB_BRACE which is required for the url ' . $ this -> url ) ; } 
public function search ( $ query , $ mode = 0 , $ type = null ) { $ regex = '{(?:' . implode ( '|' , preg_split ( '{\s+}' , $ query ) ) . ')}i' ; $ matches = array ( ) ; foreach ( $ this -> getPackages ( ) as $ package ) { $ name = $ package -> getName ( ) ; if ( isset ( $ matches [ $ name ] ) ) { continue ; } if ( preg_match ( $ regex , $ name ) || ( $ mode === self :: SEARCH_FULLTEXT && $ package instanceof CompletePackageInterface && preg_match ( $ regex , implode ( ' ' , ( array ) $ package -> getKeywords ( ) ) . ' ' . $ package -> getDescription ( ) ) ) ) { if ( null !== $ type && $ package -> getType ( ) !== $ type ) { continue ; } $ matches [ $ name ] = array ( 'name' => $ package -> getPrettyName ( ) , 'description' => $ package instanceof CompletePackageInterface ? $ package -> getDescription ( ) : null , ) ; } } return array_values ( $ matches ) ; } 
public function hasPackage ( PackageInterface $ package ) { $ packageId = $ package -> getUniqueName ( ) ; foreach ( $ this -> getPackages ( ) as $ repoPackage ) { if ( $ packageId === $ repoPackage -> getUniqueName ( ) ) { return true ; } } return false ; } 
public function addPackage ( PackageInterface $ package ) { if ( null === $ this -> packages ) { $ this -> initialize ( ) ; } $ package -> setRepository ( $ this ) ; $ this -> packages [ ] = $ package ; if ( $ package instanceof AliasPackage ) { $ aliasedPackage = $ package -> getAliasOf ( ) ; if ( null === $ aliasedPackage -> getRepository ( ) ) { $ this -> addPackage ( $ aliasedPackage ) ; } } } 
public function removePackage ( PackageInterface $ package ) { $ packageId = $ package -> getUniqueName ( ) ; foreach ( $ this -> getPackages ( ) as $ key => $ repoPackage ) { if ( $ packageId === $ repoPackage -> getUniqueName ( ) ) { array_splice ( $ this -> packages , $ key , 1 ) ; return ; } } } 
public function copy ( $ originUrl , $ fileUrl , $ fileName , $ progress = true , $ options = array ( ) ) { return $ this -> get ( $ originUrl , $ fileUrl , $ options , $ fileName , $ progress ) ; } 
public function getContents ( $ originUrl , $ fileUrl , $ progress = true , $ options = array ( ) ) { return $ this -> get ( $ originUrl , $ fileUrl , $ options , null , $ progress ) ; } 
protected function get ( $ originUrl , $ fileUrl , $ additionalOptions = array ( ) , $ fileName = null , $ progress = true ) { if ( strpos ( $ originUrl , '.github.com' ) === ( strlen ( $ originUrl ) - 11 ) ) { $ originUrl = 'github.com' ; } 
protected function getRemoteContents ( $ originUrl , $ fileUrl , $ context , array & $ responseHeaders = null ) { try { $ e = null ; $ result = file_get_contents ( $ fileUrl , false , $ context ) ; } catch ( \ Throwable $ e ) { } catch ( \ Exception $ e ) { } $ responseHeaders = isset ( $ http_response_header ) ? $ http_response_header : array ( ) ; if ( null !== $ e ) { throw $ e ; } return $ result ; } 
private function getTlsDefaults ( array $ options ) { $ ciphers = implode ( ':' , array ( 'ECDHE-RSA-AES128-GCM-SHA256' , 'ECDHE-ECDSA-AES128-GCM-SHA256' , 'ECDHE-RSA-AES256-GCM-SHA384' , 'ECDHE-ECDSA-AES256-GCM-SHA384' , 'DHE-RSA-AES128-GCM-SHA256' , 'DHE-DSS-AES128-GCM-SHA256' , 'kEDH+AESGCM' , 'ECDHE-RSA-AES128-SHA256' , 'ECDHE-ECDSA-AES128-SHA256' , 'ECDHE-RSA-AES128-SHA' , 'ECDHE-ECDSA-AES128-SHA' , 'ECDHE-RSA-AES256-SHA384' , 'ECDHE-ECDSA-AES256-SHA384' , 'ECDHE-RSA-AES256-SHA' , 'ECDHE-ECDSA-AES256-SHA' , 'DHE-RSA-AES128-SHA256' , 'DHE-RSA-AES128-SHA' , 'DHE-DSS-AES128-SHA256' , 'DHE-RSA-AES256-SHA256' , 'DHE-DSS-AES256-SHA' , 'DHE-RSA-AES256-SHA' , 'AES128-GCM-SHA256' , 'AES256-GCM-SHA384' , 'AES128-SHA256' , 'AES256-SHA256' , 'AES128-SHA' , 'AES256-SHA' , 'AES' , 'CAMELLIA' , 'DES-CBC3-SHA' , '!aNULL' , '!eNULL' , '!EXPORT' , '!DES' , '!RC4' , '!MD5' , '!PSK' , '!aECDH' , '!EDH-DSS-DES-CBC3-SHA' , '!EDH-RSA-DES-CBC3-SHA' , '!KRB5-DES-CBC3-SHA' , ) ) ; $ defaults = array ( 'ssl' => array ( 'ciphers' => $ ciphers , 'verify_peer' => true , 'verify_depth' => 7 , 'SNI_enabled' => true , 'capture_peer_cert' => true , ) , ) ; if ( isset ( $ options [ 'ssl' ] ) ) { $ defaults [ 'ssl' ] = array_replace_recursive ( $ defaults [ 'ssl' ] , $ options [ 'ssl' ] ) ; } $ caBundleLogger = $ this -> io instanceof LoggerInterface ? $ this -> io : null ; if ( ! isset ( $ defaults [ 'ssl' ] [ 'cafile' ] ) && ! isset ( $ defaults [ 'ssl' ] [ 'capath' ] ) ) { $ result = CaBundle :: getSystemCaRootBundlePath ( $ caBundleLogger ) ; if ( is_dir ( $ result ) ) { $ defaults [ 'ssl' ] [ 'capath' ] = $ result ; } else { $ defaults [ 'ssl' ] [ 'cafile' ] = $ result ; } } if ( isset ( $ defaults [ 'ssl' ] [ 'cafile' ] ) && ( ! is_readable ( $ defaults [ 'ssl' ] [ 'cafile' ] ) || ! CaBundle :: validateCaFile ( $ defaults [ 'ssl' ] [ 'cafile' ] , $ caBundleLogger ) ) ) { throw new TransportException ( 'The configured cafile was not valid or could not be read.' ) ; } if ( isset ( $ defaults [ 'ssl' ] [ 'capath' ] ) && ( ! is_dir ( $ defaults [ 'ssl' ] [ 'capath' ] ) || ! is_readable ( $ defaults [ 'ssl' ] [ 'capath' ] ) ) ) { throw new TransportException ( 'The configured capath was not valid or could not be read.' ) ; } if ( PHP_VERSION_ID >= 50413 ) { $ defaults [ 'ssl' ] [ 'disable_compression' ] = true ; } return $ defaults ; } 
private function isPublicBitBucketDownload ( $ urlToBitBucketFile ) { $ domain = parse_url ( $ urlToBitBucketFile , PHP_URL_HOST ) ; if ( strpos ( $ domain , 'bitbucket.org' ) === false ) { 
public function write ( ) { $ data = array ( ) ; $ dumper = new ArrayDumper ( ) ; foreach ( $ this -> getCanonicalPackages ( ) as $ package ) { $ data [ ] = $ dumper -> dump ( $ package ) ; } usort ( $ data , function ( $ a , $ b ) { return strcmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; $ this -> file -> write ( $ data ) ; } 
public function write ( $ messages , $ newline = true , $ verbosity = self :: NORMAL ) { $ this -> doWrite ( $ messages , $ newline , false , $ verbosity ) ; } 
public function writeError ( $ messages , $ newline = true , $ verbosity = self :: NORMAL ) { $ this -> doWrite ( $ messages , $ newline , true , $ verbosity ) ; } 
public function overwrite ( $ messages , $ newline = true , $ size = null , $ verbosity = self :: NORMAL ) { $ this -> doOverwrite ( $ messages , $ newline , $ size , false , $ verbosity ) ; } 
public function overwriteError ( $ messages , $ newline = true , $ size = null , $ verbosity = self :: NORMAL ) { $ this -> doOverwrite ( $ messages , $ newline , $ size , true , $ verbosity ) ; } 
public function ask ( $ question , $ default = null ) { $ helper = $ this -> helperSet -> get ( 'question' ) ; $ question = new Question ( $ question , $ default ) ; return $ helper -> ask ( $ this -> input , $ this -> getErrorOutput ( ) , $ question ) ; } 
public function askConfirmation ( $ question , $ default = true ) { $ helper = $ this -> helperSet -> get ( 'question' ) ; $ question = new StrictConfirmationQuestion ( $ question , $ default ) ; return $ helper -> ask ( $ this -> input , $ this -> getErrorOutput ( ) , $ question ) ; } 
public function askAndHideAnswer ( $ question ) { $ helper = $ this -> helperSet -> get ( 'question' ) ; $ question = new Question ( $ question ) ; $ question -> setHidden ( true ) ; return $ helper -> ask ( $ this -> input , $ this -> getErrorOutput ( ) , $ question ) ; } 
public function select ( $ question , $ choices , $ default , $ attempts = false , $ errorMessage = 'Value "%s" is invalid' , $ multiselect = false ) { $ helper = $ this -> helperSet -> get ( 'question' ) ; $ question = new ChoiceQuestion ( $ question , $ choices , $ default ) ; $ question -> setMaxAttempts ( $ attempts ? : null ) ; 
public function run ( InputInterface $ input = null , OutputInterface $ output = null ) { if ( null === $ output ) { $ output = Factory :: createOutput ( ) ; } return parent :: run ( $ input , $ output ) ; } 
private function hintCommonErrors ( $ exception ) { $ io = $ this -> getIO ( ) ; Silencer :: suppress ( ) ; try { $ composer = $ this -> getComposer ( false , true ) ; if ( $ composer ) { $ config = $ composer -> getConfig ( ) ; $ minSpaceFree = 1024 * 1024 ; if ( ( ( $ df = disk_free_space ( $ dir = $ config -> get ( 'home' ) ) ) !== false && $ df < $ minSpaceFree ) || ( ( $ df = disk_free_space ( $ dir = $ config -> get ( 'vendor-dir' ) ) ) !== false && $ df < $ minSpaceFree ) || ( ( $ df = disk_free_space ( $ dir = sys_get_temp_dir ( ) ) ) !== false && $ df < $ minSpaceFree ) ) { $ io -> writeError ( '<error>The disk hosting ' . $ dir . ' is full, this may be the cause of the following exception</error>' , true , IOInterface :: QUIET ) ; } } } catch ( \ Exception $ e ) { } Silencer :: restore ( ) ; if ( Platform :: isWindows ( ) && false !== strpos ( $ exception -> getMessage ( ) , 'The system cannot find the path specified' ) ) { $ io -> writeError ( '<error>The following exception may be caused by a stale entry in your cmd.exe AutoRun</error>' , true , IOInterface :: QUIET ) ; $ io -> writeError ( '<error>Check https://getcomposer.org/doc/articles/troubleshooting.md#-the-system-cannot-find-the-path-specified-windows- for details</error>' , true , IOInterface :: QUIET ) ; } if ( false !== strpos ( $ exception -> getMessage ( ) , 'fork failed - Cannot allocate memory' ) ) { $ io -> writeError ( '<error>The following exception is caused by a lack of memory or swap, or not having swap configured</error>' , true , IOInterface :: QUIET ) ; $ io -> writeError ( '<error>Check https://getcomposer.org/doc/articles/troubleshooting.md#proc-open-fork-failed-errors for details</error>' , true , IOInterface :: QUIET ) ; } } 
protected function getDefaultInputDefinition ( ) { $ definition = parent :: getDefaultInputDefinition ( ) ; $ definition -> addOption ( new InputOption ( '--profile' , null , InputOption :: VALUE_NONE , 'Display timing and memory usage information' ) ) ; $ definition -> addOption ( new InputOption ( '--no-plugins' , null , InputOption :: VALUE_NONE , 'Whether to disable plugins.' ) ) ; $ definition -> addOption ( new InputOption ( '--working-dir' , '-d' , InputOption :: VALUE_REQUIRED , 'If specified, use the given directory as working directory.' ) ) ; $ definition -> addOption ( new InputOption ( '--no-cache' , null , InputOption :: VALUE_NONE , 'Prevent use of the cache' ) ) ; return $ definition ; } 
public static function handle ( $ level , $ message , $ file , $ line ) { 
public static function register ( IOInterface $ io = null ) { set_error_handler ( array ( __CLASS__ , 'handle' ) ) ; error_reporting ( E_ALL | E_STRICT ) ; self :: $ io = $ io ; } 
private function filterRequiredPackages ( RepositoryInterface $ repo , PackageInterface $ package , $ bucket = array ( ) ) { $ requires = array_keys ( $ package -> getRequires ( ) ) ; $ packageListNames = array_keys ( $ bucket ) ; $ packages = array_filter ( $ repo -> getPackages ( ) , function ( $ package ) use ( $ requires , $ packageListNames ) { return in_array ( $ package -> getName ( ) , $ requires ) && ! in_array ( $ package -> getName ( ) , $ packageListNames ) ; } ) ; $ bucket = $ this -> appendPackages ( $ packages , $ bucket ) ; foreach ( $ packages as $ package ) { $ bucket = $ this -> filterRequiredPackages ( $ repo , $ package , $ bucket ) ; } return $ bucket ; } 
public function appendPackages ( array $ packages , array $ bucket ) { foreach ( $ packages as $ package ) { $ bucket [ $ package -> getName ( ) ] = $ package ; } return $ bucket ; } 
public function parseHgIgnoreLine ( $ line ) { if ( preg_match ( '#^syntax\s*:\s*(glob|regexp)$#' , $ line , $ matches ) ) { if ( $ matches [ 1 ] === 'glob' ) { $ this -> patternMode = self :: HG_IGNORE_GLOB ; } else { $ this -> patternMode = self :: HG_IGNORE_REGEX ; } return null ; } if ( $ this -> patternMode == self :: HG_IGNORE_GLOB ) { return $ this -> patternFromGlob ( $ line ) ; } return $ this -> patternFromRegex ( $ line ) ; } 
protected function patternFromGlob ( $ line ) { $ pattern = '#' . substr ( Finder \ Glob :: toRegex ( $ line ) , 2 , - 1 ) . '#' ; $ pattern = str_replace ( '[^/]*' , '.*' , $ pattern ) ; return array ( $ pattern , false , true ) ; } 
public function getDependents ( $ needle , $ constraint = null , $ invert = false , $ recurse = true , $ packagesFound = null ) { $ needles = array_map ( 'strtolower' , ( array ) $ needle ) ; $ results = array ( ) ; 
public function addRule ( Rule $ rule ) { $ this -> addReason ( spl_object_hash ( $ rule ) , array ( 'rule' => $ rule , 'job' => $ rule -> getJob ( ) , ) ) ; } 
public function getPrettyString ( array $ installedMap = array ( ) ) { $ reasons = call_user_func_array ( 'array_merge' , array_reverse ( $ this -> reasons ) ) ; if ( count ( $ reasons ) === 1 ) { reset ( $ reasons ) ; $ reason = current ( $ reasons ) ; $ job = $ reason [ 'job' ] ; $ packageName = $ job [ 'packageName' ] ; $ constraint = $ job [ 'constraint' ] ; if ( isset ( $ constraint ) ) { $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; } else { $ packages = array ( ) ; } if ( $ job && $ job [ 'cmd' ] === 'install' && empty ( $ packages ) ) { 
protected function addReason ( $ id , $ reason ) { if ( ! isset ( $ this -> reasonSeen [ $ id ] ) ) { $ this -> reasonSeen [ $ id ] = true ; $ this -> reasons [ $ this -> section ] [ ] = $ reason ; } } 
protected function jobToText ( $ job ) { $ packageName = $ job [ 'packageName' ] ; $ constraint = $ job [ 'constraint' ] ; switch ( $ job [ 'cmd' ] ) { case 'install' : $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; if ( ! $ packages ) { return 'No package found to satisfy install request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) ; } return 'Installation request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . ' -> satisfiable by ' . $ this -> getPackageList ( $ packages ) . '.' ; case 'update' : return 'Update request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '.' ; case 'remove' : return 'Removal request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '' ; } if ( isset ( $ constraint ) ) { $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; } else { $ packages = array ( ) ; } return 'Job(cmd=' . $ job [ 'cmd' ] . ', target=' . $ packageName . ', packages=[' . $ this -> getPackageList ( $ packages ) . '])' ; } 
protected function printVersions ( CompletePackageInterface $ package , array $ versions , RepositoryInterface $ installedRepo ) { uasort ( $ versions , 'version_compare' ) ; $ versions = array_keys ( array_reverse ( $ versions ) ) ; 
protected function printLinks ( CompletePackageInterface $ package , $ linkType , $ title = null ) { $ title = $ title ? : $ linkType ; $ io = $ this -> getIO ( ) ; if ( $ links = $ package -> { 'get' . ucfirst ( $ linkType ) } ( ) ) { $ io -> write ( "\n<info>" . $ title . "</info>" ) ; foreach ( $ links as $ link ) { $ io -> write ( $ link -> getTarget ( ) . ' <comment>' . $ link -> getPrettyConstraint ( ) . '</comment>' ) ; } } } 
protected function printLicenses ( CompletePackageInterface $ package ) { $ spdxLicenses = new SpdxLicenses ( ) ; $ licenses = $ package -> getLicense ( ) ; $ io = $ this -> getIO ( ) ; foreach ( $ licenses as $ licenseId ) { $ license = $ spdxLicenses -> getLicenseByIdentifier ( $ licenseId ) ; 
protected function initStyles ( OutputInterface $ output ) { $ this -> colors = array ( 'green' , 'yellow' , 'cyan' , 'magenta' , 'blue' , ) ; foreach ( $ this -> colors as $ color ) { $ style = new OutputFormatterStyle ( $ color ) ; $ output -> getFormatter ( ) -> setStyle ( $ color , $ style ) ; } } 
protected function displayPackageTree ( array $ arrayTree ) { $ io = $ this -> getIO ( ) ; foreach ( $ arrayTree as $ package ) { $ io -> write ( sprintf ( '<info>%s</info>' , $ package [ 'name' ] ) , false ) ; $ io -> write ( ' ' . $ package [ 'version' ] , false ) ; $ io -> write ( ' ' . strtok ( $ package [ 'description' ] , "\r\n" ) ) ; if ( isset ( $ package [ 'requires' ] ) ) { $ requires = $ package [ 'requires' ] ; $ treeBar = '├'; $ j = 0 ; $ total = count ( $ requires ) ; foreach ( $ requires as $ require ) { $ requireName = $ require [ 'name' ] ; $ j ++ ; if ( $ j === $ total ) { $ treeBar = '└'; } $ level = 1 ; $ color = $ this -> colors [ $ level ] ; $ info = sprintf ( '%s──<%s>%s</%s> %s', $ treeBar , $ color , $ requireName , $ color , $ require [ 'version' ] ) ; $ this -> writeTreeLine ( $ info ) ; $ treeBar = str_replace ( '└', ' ', $ r eeBar); $ packagesInTree = array ( $ package [ 'name' ] , $ requireName ) ; $ this -> displayTree ( $ require , $ packagesInTree , $ treeBar , $ level + 1 ) ; } } } } 
protected function generatePackageTree ( PackageInterface $ package , RepositoryInterface $ installedRepo , RepositoryInterface $ distantRepos ) { $ requires = $ package -> getRequires ( ) ; ksort ( $ requires ) ; $ children = array ( ) ; foreach ( $ requires as $ requireName => $ require ) { $ packagesInTree = array ( $ package -> getName ( ) , $ requireName ) ; $ treeChildDesc = array ( 'name' => $ requireName , 'version' => $ require -> getPrettyConstraint ( ) , ) ; $ deepChildren = $ this -> addTree ( $ requireName , $ require , $ installedRepo , $ distantRepos , $ packagesInTree ) ; if ( $ deepChildren ) { $ treeChildDesc [ 'requires' ] = $ deepChildren ; } $ children [ ] = $ treeChildDesc ; } $ tree = array ( 'name' => $ package -> getPrettyName ( ) , 'version' => $ package -> getPrettyVersion ( ) , 'description' => $ package -> getDescription ( ) , ) ; if ( $ children ) { $ tree [ 'requires' ] = $ children ; } return $ tree ; } 
protected function displayTree ( $ package , array $ packagesInTree , $ previousTreeBar = '├', $ level = 1 ) { $ previousTreeBar = str_replace ( '├', ' ', $p r v iousTreeBar); if ( isset ( $ package [ 'requires' ] ) ) { $ requires = $ package [ 'requires' ] ; $ treeBar = $ previousTreeBar . ' ├'; $ i = 0 ; $ total = count ( $ requires ) ; foreach ( $ requires as $ require ) { $ currentTree = $ packagesInTree ; $ i ++ ; if ( $ i === $ total ) { $ treeBar = $ previousTreeBar . ' └'; } $ colorIdent = $ level % count ( $ this -> colors ) ; $ color = $ this -> colors [ $ colorIdent ] ; $ circularWarn = in_array ( $ require [ 'name' ] , $ currentTree , true ) ? '(circular dependency aborted here)' : '' ; $ info = rtrim ( sprintf ( '%s──<%s>%s</%s> %s %s', $ treeBar , $ color , $ require [ 'name' ] , $ color , $ require [ 'version' ] , $ circularWarn ) ) ; $ this -> writeTreeLine ( $ info ) ; $ treeBar = str_replace ( '└', ' ', $ r eeBar); $ currentTree [ ] = $ require [ 'name' ] ; $ this -> displayTree ( $ require , $ currentTree , $ treeBar , $ level + 1 ) ; } } } 
protected function addTree ( $ name , $ package , RepositoryInterface $ installedRepo , RepositoryInterface $ distantRepos , array $ packagesInTree ) { $ children = array ( ) ; list ( $ package , $ versions ) = $ this -> getPackage ( $ installedRepo , $ distantRepos , $ name , $ package -> getPrettyConstraint ( ) === 'self.version' ? $ package -> getConstraint ( ) : $ package -> getPrettyConstraint ( ) ) ; if ( is_object ( $ package ) ) { $ requires = $ package -> getRequires ( ) ; ksort ( $ requires ) ; foreach ( $ requires as $ requireName => $ require ) { $ currentTree = $ packagesInTree ; $ treeChildDesc = array ( 'name' => $ requireName , 'version' => $ require -> getPrettyConstraint ( ) , ) ; if ( ! in_array ( $ requireName , $ currentTree , true ) ) { $ currentTree [ ] = $ requireName ; $ deepChildren = $ this -> addTree ( $ requireName , $ require , $ installedRepo , $ distantRepos , $ currentTree ) ; if ( $ deepChildren ) { $ treeChildDesc [ 'requires' ] = $ deepChildren ; } } $ children [ ] = $ treeChildDesc ; } } return $ children ; } 
public function initialize ( ) { preg_match ( '#^(?:(?:https?|git)://([^/]+)/|git@([^:]+):)([^/]+)/(.+?)(?:\.git|/)?$#' , $ this -> url , $ match ) ; $ this -> owner = $ match [ 3 ] ; $ this -> repository = $ match [ 4 ] ; $ this -> originUrl = ! empty ( $ match [ 1 ] ) ? $ match [ 1 ] : $ match [ 2 ] ; if ( $ this -> originUrl === 'www.github.com' ) { $ this -> originUrl = 'github.com' ; } $ this -> cache = new Cache ( $ this -> io , $ this -> config -> get ( 'cache-repo-dir' ) . '/' . $ this -> originUrl . '/' . $ this -> owner . '/' . $ this -> repository ) ; if ( $ this -> config -> get ( 'use-github-api' ) === false || ( isset ( $ this -> repoConfig [ 'no-api' ] ) && $ this -> repoConfig [ 'no-api' ] ) ) { $ this -> setupGitDriver ( $ this -> url ) ; return ; } $ this -> fetchRootIdentifier ( ) ; } 
public function getUrl ( ) { if ( $ this -> gitDriver ) { return $ this -> gitDriver -> getUrl ( ) ; } return 'https://' . $ this -> originUrl . '/' . $ this -> owner . '/' . $ this -> repository . '.git' ; } 
public function getDist ( $ identifier ) { $ url = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository . '/zipball/' . $ identifier ; return array ( 'type' => 'zip' , 'url' => $ url , 'reference' => $ identifier , 'shasum' => '' ) ; } 
public function getComposerInformation ( $ identifier ) { if ( $ this -> gitDriver ) { return $ this -> gitDriver -> getComposerInformation ( $ identifier ) ; } if ( ! isset ( $ this -> infoCache [ $ identifier ] ) ) { if ( $ this -> shouldCache ( $ identifier ) && $ res = $ this -> cache -> read ( $ identifier ) ) { return $ this -> infoCache [ $ identifier ] = JsonFile :: parseJson ( $ res ) ; } $ composer = $ this -> getBaseComposerInformation ( $ identifier ) ; if ( $ composer ) { 
public function getFileContent ( $ file , $ identifier ) { if ( $ this -> gitDriver ) { return $ this -> gitDriver -> getFileContent ( $ file , $ identifier ) ; } $ resource = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository . '/contents/' . $ file . '?ref=' . urlencode ( $ identifier ) ; $ resource = JsonFile :: parseJson ( $ this -> getContents ( $ resource ) ) ; if ( empty ( $ resource [ 'content' ] ) || $ resource [ 'encoding' ] !== 'base64' || ! ( $ content = base64_decode ( $ resource [ 'content' ] ) ) ) { throw new \ RuntimeException ( 'Could not retrieve ' . $ file . ' for ' . $ identifier ) ; } return $ content ; } 
public function getChangeDate ( $ identifier ) { if ( $ this -> gitDriver ) { return $ this -> gitDriver -> getChangeDate ( $ identifier ) ; } $ resource = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository . '/commits/' . urlencode ( $ identifier ) ; $ commit = JsonFile :: parseJson ( $ this -> getContents ( $ resource ) , $ resource ) ; return new \ DateTime ( $ commit [ 'commit' ] [ 'committer' ] [ 'date' ] ) ; } 
public function getTags ( ) { if ( $ this -> gitDriver ) { return $ this -> gitDriver -> getTags ( ) ; } if ( null === $ this -> tags ) { $ this -> tags = array ( ) ; $ resource = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository . '/tags?per_page=100' ; do { $ tagsData = JsonFile :: parseJson ( $ this -> getContents ( $ resource ) , $ resource ) ; foreach ( $ tagsData as $ tag ) { $ this -> tags [ $ tag [ 'name' ] ] = $ tag [ 'commit' ] [ 'sha' ] ; } $ resource = $ this -> getNextPage ( ) ; } while ( $ resource ) ; } return $ this -> tags ; } 
public function getBranches ( ) { if ( $ this -> gitDriver ) { return $ this -> gitDriver -> getBranches ( ) ; } if ( null === $ this -> branches ) { $ this -> branches = array ( ) ; $ resource = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository . '/git/refs/heads?per_page=100' ; $ branchBlacklist = array ( 'gh-pages' ) ; do { $ branchData = JsonFile :: parseJson ( $ this -> getContents ( $ resource ) , $ resource ) ; foreach ( $ branchData as $ branch ) { $ name = substr ( $ branch [ 'ref' ] , 11 ) ; if ( ! in_array ( $ name , $ branchBlacklist ) ) { $ this -> branches [ $ name ] = $ branch [ 'object' ] [ 'sha' ] ; } } $ resource = $ this -> getNextPage ( ) ; } while ( $ resource ) ; } return $ this -> branches ; } 
public static function supports ( IOInterface $ io , Config $ config , $ url , $ deep = false ) { if ( ! preg_match ( '#^((?:https?|git)://([^/]+)/|git@([^:]+):)([^/]+)/(.+?)(?:\.git|/)?$#' , $ url , $ matches ) ) { return false ; } $ originUrl = ! empty ( $ matches [ 2 ] ) ? $ matches [ 2 ] : $ matches [ 3 ] ; if ( ! in_array ( preg_replace ( '{^www\.}i' , '' , $ originUrl ) , $ config -> get ( 'github-domains' ) ) ) { return false ; } if ( ! extension_loaded ( 'openssl' ) ) { $ io -> writeError ( 'Skipping GitHub driver for ' . $ url . ' because the OpenSSL PHP extension is missing.' , true , IOInterface :: VERBOSE ) ; return false ; } return true ; } 
protected function fetchRootIdentifier ( ) { if ( $ this -> repoData ) { return ; } $ repoDataUrl = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository ; $ this -> repoData = JsonFile :: parseJson ( $ this -> getContents ( $ repoDataUrl , true ) , $ repoDataUrl ) ; if ( null === $ this -> repoData && null !== $ this -> gitDriver ) { return ; } $ this -> owner = $ this -> repoData [ 'owner' ] [ 'login' ] ; $ this -> repository = $ this -> repoData [ 'name' ] ; $ this -> isPrivate = ! empty ( $ this -> repoData [ 'private' ] ) ; if ( isset ( $ this -> repoData [ 'default_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'default_branch' ] ; } elseif ( isset ( $ this -> repoData [ 'master_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'master_branch' ] ; } else { $ this -> rootIdentifier = 'master' ; } $ this -> hasIssues = ! empty ( $ this -> repoData [ 'has_issues' ] ) ; } 
private function readPackages ( $ baseUrl ) { $ result = array ( ) ; $ xmlPath = '/p/packages.xml' ; $ xml = $ this -> requestXml ( $ baseUrl , $ xmlPath ) ; $ xml -> registerXPathNamespace ( 'ns' , self :: ALL_PACKAGES_NS ) ; foreach ( $ xml -> xpath ( 'ns:p' ) as $ node ) { $ packageName = ( string ) $ node ; $ packageInfo = $ this -> readPackage ( $ baseUrl , $ packageName ) ; $ result [ ] = $ packageInfo ; } return $ result ; } 
private function readPackage ( $ baseUrl , $ packageName ) { $ xmlPath = '/p/' . strtolower ( $ packageName ) . '/info.xml' ; $ xml = $ this -> requestXml ( $ baseUrl , $ xmlPath ) ; $ xml -> registerXPathNamespace ( 'ns' , self :: PACKAGE_INFO_NS ) ; $ channelName = ( string ) $ xml -> c ; $ packageName = ( string ) $ xml -> n ; $ license = ( string ) $ xml -> l ; $ shortDescription = ( string ) $ xml -> s ; $ description = ( string ) $ xml -> d ; return new PackageInfo ( $ channelName , $ packageName , $ license , $ shortDescription , $ description , $ this -> readPackageReleases ( $ baseUrl , $ packageName ) ) ; } 
private function readPackageReleases ( $ baseUrl , $ packageName ) { $ result = array ( ) ; try { $ xmlPath = '/r/' . strtolower ( $ packageName ) . '/allreleases.xml' ; $ xml = $ this -> requestXml ( $ baseUrl , $ xmlPath ) ; $ xml -> registerXPathNamespace ( 'ns' , self :: ALL_RELEASES_NS ) ; foreach ( $ xml -> xpath ( 'ns:r' ) as $ node ) { $ releaseVersion = ( string ) $ node -> v ; $ releaseStability = ( string ) $ node -> s ; try { $ result [ $ releaseVersion ] = new ReleaseInfo ( $ releaseStability , $ this -> readPackageReleaseDependencies ( $ baseUrl , $ packageName , $ releaseVersion ) ) ; } catch ( TransportException $ exception ) { if ( $ exception -> getCode ( ) != 404 ) { throw $ exception ; } } } } catch ( TransportException $ exception ) { if ( $ exception -> getCode ( ) != 404 ) { throw $ exception ; } } return $ result ; } 
private function readPackageReleaseDependencies ( $ baseUrl , $ packageName , $ version ) { $ dependencyReader = new PackageDependencyParser ( ) ; $ depthPath = '/r/' . strtolower ( $ packageName ) . '/deps.' . $ version . '.txt' ; $ content = $ this -> requestContent ( $ baseUrl , $ depthPath ) ; $ dependencyArray = unserialize ( $ content ) ; return $ dependencyReader -> buildDependencyInfo ( $ dependencyArray ) ; } 
public static function checkCertificateHost ( $ certificate , $ hostname , & $ cn = null ) { $ names = self :: getCertificateNames ( $ certificate ) ; if ( empty ( $ names ) ) { return false ; } $ combinedNames = array_merge ( $ names [ 'san' ] , array ( $ names [ 'cn' ] ) ) ; $ hostname = strtolower ( $ hostname ) ; foreach ( $ combinedNames as $ certName ) { $ matcher = self :: certNameMatcher ( $ certName ) ; if ( $ matcher && $ matcher ( $ hostname ) ) { $ cn = $ names [ 'cn' ] ; return true ; } } return false ; } 
public static function getCertificateNames ( $ certificate ) { if ( is_array ( $ certificate ) ) { $ info = $ certificate ; } elseif ( CaBundle :: isOpensslParseSafe ( ) ) { $ info = openssl_x509_parse ( $ certificate , false ) ; } if ( ! isset ( $ info [ 'subject' ] [ 'commonName' ] ) ) { return null ; } $ commonName = strtolower ( $ info [ 'subject' ] [ 'commonName' ] ) ; $ subjectAltNames = array ( ) ; if ( isset ( $ info [ 'extensions' ] [ 'subjectAltName' ] ) ) { $ subjectAltNames = preg_split ( '{\s*,\s*}' , $ info [ 'extensions' ] [ 'subjectAltName' ] ) ; $ subjectAltNames = array_filter ( array_map ( function ( $ name ) { if ( 0 === strpos ( $ name , 'DNS:' ) ) { return strtolower ( ltrim ( substr ( $ name , 4 ) ) ) ; } return null ; } , $ subjectAltNames ) ) ; $ subjectAltNames = array_values ( $ subjectAltNames ) ; } return array ( 'cn' => $ commonName , 'san' => $ subjectAltNames , ) ; } 
public function install ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { $ this -> io -> writeError ( " - Installing <info>" . $ package -> getName ( ) . "</info> (<comment>" . $ package -> getFullPrettyVersion ( ) . "</comment>)" ) ; $ repo -> addPackage ( clone $ package ) ; } 
public function update ( InstalledRepositoryInterface $ repo , PackageInterface $ initial , PackageInterface $ target ) { if ( ! $ repo -> hasPackage ( $ initial ) ) { throw new \ InvalidArgumentException ( 'Package is not installed: ' . $ initial ) ; } $ name = $ target -> getName ( ) ; $ from = $ initial -> getFullPrettyVersion ( ) ; $ to = $ target -> getFullPrettyVersion ( ) ; $ actionName = VersionParser :: isUpgrade ( $ initial -> getVersion ( ) , $ target -> getVersion ( ) ) ? 'Updating' : 'Downgrading' ; $ this -> io -> writeError ( " - " . $ actionName . " <info>" . $ name . "</info> (<comment>" . $ from . "</comment> => <comment>" . $ to . "</comment>)" ) ; $ repo -> removePackage ( $ initial ) ; $ repo -> addPackage ( clone $ target ) ; } 
public function uninstall ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( ! $ repo -> hasPackage ( $ package ) ) { throw new \ InvalidArgumentException ( 'Package is not installed: ' . $ package ) ; } $ this -> io -> writeError ( " - Removing <info>" . $ package -> getName ( ) . "</info> (<comment>" . $ package -> getFullPrettyVersion ( ) . "</comment>)" ) ; $ repo -> removePackage ( $ package ) ; } 
public function initialize ( ) { if ( Filesystem :: isLocalPath ( $ this -> url ) ) { $ this -> url = preg_replace ( '{[\\/]\.git/?$}' , '' , $ this -> url ) ; $ this -> repoDir = $ this -> url ; $ cacheUrl = realpath ( $ this -> url ) ; } else { if ( ! Cache :: isUsable ( $ this -> config -> get ( 'cache-vcs-dir' ) ) ) { throw new \ RuntimeException ( 'GitDriver requires a usable cache directory, and it looks like you set it to be disabled' ) ; } $ this -> repoDir = $ this -> config -> get ( 'cache-vcs-dir' ) . '/' . preg_replace ( '{[^a-z0-9.]}i' , '-' , $ this -> url ) . '/' ; GitUtil :: cleanEnv ( ) ; $ fs = new Filesystem ( ) ; $ fs -> ensureDirectoryExists ( dirname ( $ this -> repoDir ) ) ; if ( ! is_writable ( dirname ( $ this -> repoDir ) ) ) { throw new \ RuntimeException ( 'Can not clone ' . $ this -> url . ' to access package information. The "' . dirname ( $ this -> repoDir ) . '" directory is not writable by the current user.' ) ; } if ( preg_match ( '{^ssh://[^@]+@[^:]+:[^0-9]+}' , $ this -> url ) ) { throw new \ InvalidArgumentException ( 'The source URL ' . $ this -> url . ' is invalid, ssh URLs should have a port number after ":".' . "\n" . 'Use ssh://git@example.com:22/path or just git@example.com:path if you do not want to provide a password or custom port.' ) ; } $ gitUtil = new GitUtil ( $ this -> io , $ this -> config , $ this -> process , $ fs ) ; if ( ! $ gitUtil -> syncMirror ( $ this -> url , $ this -> repoDir ) ) { $ this -> io -> writeError ( '<error>Failed to update ' . $ this -> url . ', package information from this repository may be outdated</error>' ) ; } $ cacheUrl = $ this -> url ; } $ this -> getTags ( ) ; $ this -> getBranches ( ) ; $ this -> cache = new Cache ( $ this -> io , $ this -> config -> get ( 'cache-repo-dir' ) . '/' . preg_replace ( '{[^a-z0-9.]}i' , '-' , $ cacheUrl ) ) ; } 
public function getRootIdentifier ( ) { if ( null === $ this -> rootIdentifier ) { $ this -> rootIdentifier = 'master' ; 
public function getFileContent ( $ file , $ identifier ) { $ resource = sprintf ( '%s:%s' , ProcessExecutor :: escape ( $ identifier ) , ProcessExecutor :: escape ( $ file ) ) ; $ this -> process -> execute ( sprintf ( 'git show %s' , $ resource ) , $ content , $ this -> repoDir ) ; if ( ! trim ( $ content ) ) { return null ; } return $ content ; } 
public function getBranches ( ) { if ( null === $ this -> branches ) { $ branches = array ( ) ; $ this -> process -> execute ( 'git branch --no-color --no-abbrev -v' , $ output , $ this -> repoDir ) ; foreach ( $ this -> process -> splitLines ( $ output ) as $ branch ) { if ( $ branch && ! preg_match ( '{^ *[^/]+/HEAD }' , $ branch ) ) { if ( preg_match ( '{^(?:\* )? *(\S+) *([a-f0-9]+)(?: .*)?$}' , $ branch , $ match ) ) { $ branches [ $ match [ 1 ] ] = $ match [ 2 ] ; } } } $ this -> branches = $ branches ; } return $ this -> branches ; } 
private function readChannelPackages ( $ baseUrl ) { $ result = array ( ) ; $ xml = $ this -> requestXml ( $ baseUrl , "/c/categories.xml" ) ; $ xml -> registerXPathNamespace ( 'ns' , self :: ALL_CATEGORIES_NS ) ; foreach ( $ xml -> xpath ( 'ns:c' ) as $ node ) { $ categoryName = ( string ) $ node ; $ categoryPackages = $ this -> readCategoryPackages ( $ baseUrl , $ categoryName ) ; $ result = array_merge ( $ result , $ categoryPackages ) ; } return $ result ; } 
private function readCategoryPackages ( $ baseUrl , $ categoryName ) { $ result = array ( ) ; $ categoryPath = '/c/' . urlencode ( $ categoryName ) . '/packagesinfo.xml' ; $ xml = $ this -> requestXml ( $ baseUrl , $ categoryPath ) ; $ xml -> registerXPathNamespace ( 'ns' , self :: CATEGORY_PACKAGES_INFO_NS ) ; foreach ( $ xml -> xpath ( 'ns:pi' ) as $ node ) { $ packageInfo = $ this -> parsePackage ( $ node ) ; $ result [ ] = $ packageInfo ; } return $ result ; } 
private function parsePackage ( $ packageInfo ) { $ packageInfo -> registerXPathNamespace ( 'ns' , self :: CATEGORY_PACKAGES_INFO_NS ) ; $ channelName = ( string ) $ packageInfo -> p -> c ; $ packageName = ( string ) $ packageInfo -> p -> n ; $ license = ( string ) $ packageInfo -> p -> l ; $ shortDescription = ( string ) $ packageInfo -> p -> s ; $ description = ( string ) $ packageInfo -> p -> d ; $ dependencies = array ( ) ; foreach ( $ packageInfo -> xpath ( 'ns:deps' ) as $ node ) { $ dependencyVersion = ( string ) $ node -> v ; $ dependencyArray = unserialize ( ( string ) $ node -> d ) ; $ dependencyInfo = $ this -> dependencyReader -> buildDependencyInfo ( $ dependencyArray ) ; $ dependencies [ $ dependencyVersion ] = $ dependencyInfo ; } $ releases = array ( ) ; $ releasesInfo = $ packageInfo -> xpath ( 'ns:a/ns:r' ) ; if ( $ releasesInfo ) { foreach ( $ releasesInfo as $ node ) { $ releaseVersion = ( string ) $ node -> v ; $ releaseStability = ( string ) $ node -> s ; $ releases [ $ releaseVersion ] = new ReleaseInfo ( $ releaseStability , isset ( $ dependencies [ $ releaseVersion ] ) ? $ dependencies [ $ releaseVersion ] : new DependencyInfo ( array ( ) , array ( ) ) ) ; } } return new PackageInfo ( $ channelName , $ packageName , $ license , $ shortDescription , $ description , $ releases ) ; } 
public function dispatchScript ( $ eventName , $ devMode = false , $ additionalArgs = array ( ) , $ flags = array ( ) ) { return $ this -> doDispatch ( new Script \ Event ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ additionalArgs , $ flags ) ) ; } 
public function dispatchPackageEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations , OperationInterface $ operation ) { return $ this -> doDispatch ( new PackageEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations , $ operation ) ) ; } 
public function dispatchInstallerEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations = array ( ) ) { return $ this -> doDispatch ( new InstallerEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations ) ) ; } 
protected function doDispatch ( Event $ event ) { $ pathStr = 'PATH' ; if ( ! isset ( $ _SERVER [ $ pathStr ] ) && isset ( $ _SERVER [ 'Path' ] ) ) { $ pathStr = 'Path' ; } 
public function addSubscriber ( EventSubscriberInterface $ subscriber ) { foreach ( $ subscriber -> getSubscribedEvents ( ) as $ eventName => $ params ) { if ( is_string ( $ params ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params ) ) ; } elseif ( is_string ( $ params [ 0 ] ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params [ 0 ] ) , isset ( $ params [ 1 ] ) ? $ params [ 1 ] : 0 ) ; } else { foreach ( $ params as $ listener ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ listener [ 0 ] ) , isset ( $ listener [ 1 ] ) ? $ listener [ 1 ] : 0 ) ; } } } } 
protected function getListeners ( Event $ event ) { $ scriptListeners = $ this -> getScriptListeners ( $ event ) ; if ( ! isset ( $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] ) ) { $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] = array ( ) ; } krsort ( $ this -> listeners [ $ event -> getName ( ) ] ) ; $ listeners = $ this -> listeners ; $ listeners [ $ event -> getName ( ) ] [ 0 ] = array_merge ( $ listeners [ $ event -> getName ( ) ] [ 0 ] , $ scriptListeners ) ; return call_user_func_array ( 'array_merge' , $ listeners [ $ event -> getName ( ) ] ) ; } 
protected function getScriptListeners ( Event $ event ) { $ package = $ this -> composer -> getPackage ( ) ; $ scripts = $ package -> getScripts ( ) ; if ( empty ( $ scripts [ $ event -> getName ( ) ] ) ) { return array ( ) ; } if ( $ this -> loader ) { $ this -> loader -> unregister ( ) ; } $ generator = $ this -> composer -> getAutoloadGenerator ( ) ; if ( $ event instanceof ScriptEvent ) { $ generator -> setDevMode ( $ event -> isDevMode ( ) ) ; } $ packages = $ this -> composer -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getCanonicalPackages ( ) ; $ packageMap = $ generator -> buildPackageMap ( $ this -> composer -> getInstallationManager ( ) , $ package , $ packages ) ; $ map = $ generator -> parseAutoloads ( $ packageMap , $ package ) ; $ this -> loader = $ generator -> createLoader ( $ map ) ; $ this -> loader -> register ( ) ; return $ scripts [ $ event -> getName ( ) ] ; } 
protected function pushEvent ( Event $ event ) { $ eventName = $ event -> getName ( ) ; if ( in_array ( $ eventName , $ this -> eventStack ) ) { throw new \ RuntimeException ( sprintf ( "Circular call to script handler '%s' detected" , $ eventName ) ) ; } return array_push ( $ this -> eventStack , $ eventName ) ; } 
public function hasPackage ( PackageInterface $ package ) { foreach ( $ this -> repositories as $ repository ) { if ( $ repository -> hasPackage ( $ package ) ) { return true ; } } return false ; } 
public function findPackages ( $ name , $ constraint = null ) { $ packages = array ( ) ; foreach ( $ this -> repositories as $ repository ) { $ packages [ ] = $ repository -> findPackages ( $ name , $ constraint ) ; } return $ packages ? call_user_func_array ( 'array_merge' , $ packages ) : array ( ) ; } 
public function search ( $ query , $ mode = 0 , $ type = null ) { $ matches = array ( ) ; foreach ( $ this -> repositories as $ repository ) { $ matches [ ] = $ repository -> search ( $ query , $ mode , $ type ) ; } return $ matches ? call_user_func_array ( 'array_merge' , $ matches ) : array ( ) ; } 
public function addRepository ( RepositoryInterface $ repository ) { if ( $ repository instanceof self ) { foreach ( $ repository -> getRepositories ( ) as $ repo ) { $ this -> addRepository ( $ repo ) ; } } else { $ this -> repositories [ ] = $ repository ; } } 
public function setOutputProgress ( $ outputProgress ) { foreach ( $ this -> downloaders as $ downloader ) { $ downloader -> setOutputProgress ( $ outputProgress ) ; } return $ this ; } 
public function setDownloader ( $ type , DownloaderInterface $ downloader ) { $ type = strtolower ( $ type ) ; $ this -> downloaders [ $ type ] = $ downloader ; return $ this ; } 
public function getDownloader ( $ type ) { $ type = strtolower ( $ type ) ; if ( ! isset ( $ this -> downloaders [ $ type ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Unknown downloader type: %s. Available types: %s.' , $ type , implode ( ', ' , array_keys ( $ this -> downloaders ) ) ) ) ; } return $ this -> downloaders [ $ type ] ; } 
public function download ( PackageInterface $ package , $ targetDir , $ preferSource = null ) { $ preferSource = null !== $ preferSource ? $ preferSource : $ this -> preferSource ; $ sourceType = $ package -> getSourceType ( ) ; $ distType = $ package -> getDistType ( ) ; $ sources = array ( ) ; if ( $ sourceType ) { $ sources [ ] = 'source' ; } if ( $ distType ) { $ sources [ ] = 'dist' ; } if ( empty ( $ sources ) ) { throw new \ InvalidArgumentException ( 'Package ' . $ package . ' must have a source or dist specified' ) ; } if ( ! $ preferSource && ( $ this -> preferDist || 'dist' === $ this -> resolvePackageInstallPreference ( $ package ) ) ) { $ sources = array_reverse ( $ sources ) ; } $ this -> filesystem -> ensureDirectoryExists ( $ targetDir ) ; foreach ( $ sources as $ i => $ source ) { if ( isset ( $ e ) ) { $ this -> io -> writeError ( ' <warning>Now trying to download from ' . $ source . '</warning>' ) ; } $ package -> setInstallationSource ( $ source ) ; try { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> download ( $ package , $ targetDir ) ; } break ; } catch ( \ RuntimeException $ e ) { if ( $ i === count ( $ sources ) - 1 ) { throw $ e ; } $ this -> io -> writeError ( ' <warning>Failed to download ' . $ package -> getPrettyName ( ) . ' from ' . $ source . ': ' . $ e -> getMessage ( ) . '</warning>' ) ; } } } 
public function update ( PackageInterface $ initial , PackageInterface $ target , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ initial ) ; if ( ! $ downloader ) { return ; } $ installationSource = $ initial -> getInstallationSource ( ) ; if ( 'dist' === $ installationSource ) { $ initialType = $ initial -> getDistType ( ) ; $ targetType = $ target -> getDistType ( ) ; } else { $ initialType = $ initial -> getSourceType ( ) ; $ targetType = $ target -> getSourceType ( ) ; } 
public function remove ( PackageInterface $ package , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> remove ( $ package , $ targetDir ) ; } } 
protected function resolvePackageInstallPreference ( PackageInterface $ package ) { foreach ( $ this -> packagePreferences as $ pattern => $ preference ) { $ pattern = '{^' . str_replace ( '\\*' , '.*' , preg_quote ( $ pattern ) ) . '$}i' ; if ( preg_match ( $ pattern , $ package -> getName ( ) ) ) { if ( 'dist' === $ preference || ( ! $ package -> isDev ( ) && 'auto' === $ preference ) ) { return 'dist' ; } return 'source' ; } } return $ package -> isDev ( ) ? 'source' : 'dist' ; } 
public function addPackage ( $ source , $ target , $ reason ) { $ this -> suggestedPackages [ ] = array ( 'source' => $ source , 'target' => $ target , 'reason' => $ reason , ) ; return $ this ; } 
public function addSuggestionsFromPackage ( PackageInterface $ package ) { $ source = $ package -> getPrettyName ( ) ; foreach ( $ package -> getSuggests ( ) as $ target => $ reason ) { $ this -> addPackage ( $ source , $ target , $ reason ) ; } return $ this ; } 
public function isDirEmpty ( $ dir ) { $ finder = Finder :: create ( ) -> ignoreVCS ( false ) -> ignoreDotFiles ( false ) -> depth ( 0 ) -> in ( $ dir ) ; return count ( $ finder ) === 0 ; } 
public function removeDirectory ( $ directory ) { if ( $ this -> isSymlinkedDirectory ( $ directory ) ) { return $ this -> unlinkSymlinkedDirectory ( $ directory ) ; } if ( $ this -> isJunction ( $ directory ) ) { return $ this -> removeJunction ( $ directory ) ; } if ( is_link ( $ directory ) ) { return unlink ( $ directory ) ; } if ( ! file_exists ( $ directory ) || ! is_dir ( $ directory ) ) { return true ; } if ( preg_match ( '{^(?:[a-z]:)?[/\\\\]+$}i' , $ directory ) ) { throw new \ RuntimeException ( 'Aborting an attempted deletion of ' . $ directory . ', this was probably not intended, if it is a real use case please report it.' ) ; } if ( ! function_exists ( 'proc_open' ) ) { return $ this -> removeDirectoryPhp ( $ directory ) ; } if ( Platform :: isWindows ( ) ) { $ cmd = sprintf ( 'rmdir /S /Q %s' , ProcessExecutor :: escape ( realpath ( $ directory ) ) ) ; } else { $ cmd = sprintf ( 'rm -rf %s' , ProcessExecutor :: escape ( $ directory ) ) ; } $ result = $ this -> getProcess ( ) -> execute ( $ cmd , $ output ) === 0 ; 
public function unlink ( $ path ) { $ unlinked = @ $ this -> unlinkImplementation ( $ path ) ; if ( ! $ unlinked ) { 
public function rmdir ( $ path ) { $ deleted = @ rmdir ( $ path ) ; if ( ! $ deleted ) { 
public function copyThenRemove ( $ source , $ target ) { $ this -> copy ( $ source , $ target ) ; if ( ! is_dir ( $ source ) ) { $ this -> unlink ( $ source ) ; return ; } $ this -> removeDirectoryPhp ( $ source ) ; } 
public function size ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new \ RuntimeException ( "$path does not exist." ) ; } if ( is_dir ( $ path ) ) { return $ this -> directorySize ( $ path ) ; } return filesize ( $ path ) ; } 
public function normalizePath ( $ path ) { $ parts = array ( ) ; $ path = strtr ( $ path , '\\' , '/' ) ; $ prefix = '' ; $ absolute = false ; 
private function unlinkImplementation ( $ path ) { if ( Platform :: isWindows ( ) && is_dir ( $ path ) && is_link ( $ path ) ) { return rmdir ( $ path ) ; } return unlink ( $ path ) ; } 
public function relativeSymlink ( $ target , $ link ) { $ cwd = getcwd ( ) ; $ relativePath = $ this -> findShortestPath ( $ link , $ target ) ; chdir ( dirname ( $ link ) ) ; $ result = @ symlink ( $ relativePath , $ link ) ; chdir ( $ cwd ) ; return $ result ; } 
public function isSymlinkedDirectory ( $ directory ) { if ( ! is_dir ( $ directory ) ) { return false ; } $ resolved = $ this -> resolveSymlinkedDirectorySymlink ( $ directory ) ; return is_link ( $ resolved ) ; } 
private function resolveSymlinkedDirectorySymlink ( $ pathname ) { if ( ! is_dir ( $ pathname ) ) { return $ pathname ; } $ resolved = rtrim ( $ pathname , '/' ) ; if ( ! strlen ( $ resolved ) ) { return $ pathname ; } return $ resolved ; } 
public function junction ( $ target , $ junction ) { if ( ! Platform :: isWindows ( ) ) { throw new \ LogicException ( sprintf ( 'Function %s is not available on non-Windows platform' , __CLASS__ ) ) ; } if ( ! is_dir ( $ target ) ) { throw new IOException ( sprintf ( 'Cannot junction to "%s" as it is not a directory.' , $ target ) , 0 , null , $ target ) ; } $ cmd = sprintf ( 'mklink /J %s %s' , ProcessExecutor :: escape ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) ) , ProcessExecutor :: escape ( realpath ( $ target ) ) ) ; if ( $ this -> getProcess ( ) -> execute ( $ cmd , $ output ) !== 0 ) { throw new IOException ( sprintf ( 'Failed to create junction to "%s" at "%s".' , $ target , $ junction ) , 0 , null , $ target ) ; } clearstatcache ( true , $ junction ) ; } 
public function removeJunction ( $ junction ) { if ( ! Platform :: isWindows ( ) ) { return false ; } $ junction = rtrim ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) , DIRECTORY_SEPARATOR ) ; if ( ! $ this -> isJunction ( $ junction ) ) { throw new IOException ( sprintf ( '%s is not a junction and thus cannot be removed as one' , $ junction ) ) ; } return $ this -> rmdir ( $ junction ) ; } 
public function getBranchAlias ( array $ config ) { if ( ( 'dev-' !== substr ( $ config [ 'version' ] , 0 , 4 ) && '-dev' !== substr ( $ config [ 'version' ] , - 4 ) ) || ! isset ( $ config [ 'extra' ] [ 'branch-alias' ] ) || ! is_array ( $ config [ 'extra' ] [ 'branch-alias' ] ) ) { return ; } foreach ( $ config [ 'extra' ] [ 'branch-alias' ] as $ sourceBranch => $ targetBranch ) { 
protected function validatePackage ( PackageInterface $ package ) { $ autoload = $ package -> getAutoload ( ) ; if ( ! empty ( $ autoload [ 'psr-4' ] ) && null !== $ package -> getTargetDir ( ) ) { $ name = $ package -> getName ( ) ; $ package -> getTargetDir ( ) ; throw new \ InvalidArgumentException ( "PSR-4 autoloading is incompatible with the target-dir property, remove the target-dir in package '$name'." ) ; } if ( ! empty ( $ autoload [ 'psr-4' ] ) ) { foreach ( $ autoload [ 'psr-4' ] as $ namespace => $ dirs ) { if ( $ namespace !== '' && '\\' !== substr ( $ namespace , - 1 ) ) { throw new \ InvalidArgumentException ( "psr-4 namespaces must end with a namespace separator, '$namespace' does not, use '$namespace\\'." ) ; } } } } 
public function createLoader ( array $ autoloads ) { $ loader = new ClassLoader ( ) ; if ( isset ( $ autoloads [ 'psr-0' ] ) ) { foreach ( $ autoloads [ 'psr-0' ] as $ namespace => $ path ) { $ loader -> add ( $ namespace , $ path ) ; } } if ( isset ( $ autoloads [ 'psr-4' ] ) ) { foreach ( $ autoloads [ 'psr-4' ] as $ namespace => $ path ) { $ loader -> addPsr4 ( $ namespace , $ path ) ; } } if ( isset ( $ autoloads [ 'classmap' ] ) ) { $ blacklist = null ; if ( ! empty ( $ autoloads [ 'exclude-from-classmap' ] ) ) { $ blacklist = '{(' . implode ( '|' , $ autoloads [ 'exclude-from-classmap' ] ) . ')}' ; } foreach ( $ autoloads [ 'classmap' ] as $ dir ) { try { $ loader -> addClassMap ( $ this -> generateClassMap ( $ dir , $ blacklist , null , false ) ) ; } catch ( \ RuntimeException $ e ) { $ this -> io -> writeError ( '<warning>' . $ e -> getMessage ( ) . '</warning>' ) ; } } } return $ loader ; } 
protected function filterPackageMap ( array $ packageMap , PackageInterface $ mainPackage ) { $ packages = array ( ) ; $ include = array ( ) ; foreach ( $ packageMap as $ item ) { $ package = $ item [ 0 ] ; $ name = $ package -> getName ( ) ; $ packages [ $ name ] = $ package ; } $ add = function ( PackageInterface $ package ) use ( & $ add , $ packages , & $ include ) { foreach ( $ package -> getRequires ( ) as $ link ) { $ target = $ link -> getTarget ( ) ; if ( ! isset ( $ include [ $ target ] ) ) { $ include [ $ target ] = true ; if ( isset ( $ packages [ $ target ] ) ) { $ add ( $ packages [ $ target ] ) ; } } } } ; $ add ( $ mainPackage ) ; return array_filter ( $ packageMap , function ( $ item ) use ( $ include ) { $ package = $ item [ 0 ] ; foreach ( $ package -> getNames ( ) as $ name ) { if ( isset ( $ include [ $ name ] ) ) { return true ; } } return false ; } ) ; } 
protected function safeCopy ( $ source , $ target ) { $ source = fopen ( $ source , 'r' ) ; $ target = fopen ( $ target , 'w+' ) ; stream_copy_to_stream ( $ source , $ target ) ; fclose ( $ source ) ; fclose ( $ target ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { return parent :: doExecute ( $ input , $ output , true ) ; } 
public function getComposerInformation ( $ identifier ) { if ( ! isset ( $ this -> infoCache [ $ identifier ] ) ) { if ( $ this -> shouldCache ( $ identifier ) && $ res = $ this -> cache -> read ( $ identifier ) ) { return $ this -> infoCache [ $ identifier ] = JsonFile :: parseJson ( $ res ) ; } $ composer = $ this -> getBaseComposerInformation ( $ identifier ) ; if ( $ this -> shouldCache ( $ identifier ) ) { $ this -> cache -> write ( $ identifier , json_encode ( $ composer ) ) ; } $ this -> infoCache [ $ identifier ] = $ composer ; } return $ this -> infoCache [ $ identifier ] ; } 
protected function getContents ( $ url ) { $ options = isset ( $ this -> repoConfig [ 'options' ] ) ? $ this -> repoConfig [ 'options' ] : array ( ) ; return $ this -> remoteFilesystem -> getContents ( $ this -> originUrl , $ url , false , $ options ) ; } 
public function authorizeOAuth ( $ originUrl ) { if ( $ originUrl !== 'bitbucket.org' ) { return false ; } 
public function authorizeOAuthInteractively ( $ originUrl , $ message = null ) { if ( $ message ) { $ this -> io -> writeError ( $ message ) ; } $ url = 'https://confluence.atlassian.com/bitbucket/oauth-on-bitbucket-cloud-238027431.html' ; $ this -> io -> writeError ( sprintf ( 'Follow the instructions on %s' , $ url ) ) ; $ this -> io -> writeError ( sprintf ( 'to create a consumer. It will be stored in "%s" for future use by Composer.' , $ this -> config -> getAuthConfigSource ( ) -> getName ( ) ) ) ; $ this -> io -> writeError ( 'Ensure you enter a "Callback URL" (http://example.com is fine) or it will not be possible to create an Access Token (this callback url will not be used by composer)' ) ; $ consumerKey = trim ( $ this -> io -> askAndHideAnswer ( 'Consumer Key (hidden): ' ) ) ; if ( ! $ consumerKey ) { $ this -> io -> writeError ( '<warning>No consumer key given, aborting.</warning>' ) ; $ this -> io -> writeError ( 'You can also add it manually later by using "composer config --global --auth bitbucket-oauth.bitbucket.org <consumer-key> <consumer-secret>"' ) ; return false ; } $ consumerSecret = trim ( $ this -> io -> askAndHideAnswer ( 'Consumer Secret (hidden): ' ) ) ; if ( ! $ consumerSecret ) { $ this -> io -> writeError ( '<warning>No consumer secret given, aborting.</warning>' ) ; $ this -> io -> writeError ( 'You can also add it manually later by using "composer config --global --auth bitbucket-oauth.bitbucket.org <consumer-key> <consumer-secret>"' ) ; return false ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return false ; } 
public function requestToken ( $ originUrl , $ consumerKey , $ consumerSecret ) { if ( ! empty ( $ this -> token ) || $ this -> getTokenFromConfig ( $ originUrl ) ) { return $ this -> token [ 'access_token' ] ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return '' ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; return $ this -> token [ 'access_token' ] ; } 
private function storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) { $ this -> config -> getConfigSource ( ) -> removeConfigSetting ( 'bitbucket-oauth.' . $ originUrl ) ; $ time = null === $ this -> time ? time ( ) : $ this -> time ; $ consumer = array ( "consumer-key" => $ consumerKey , "consumer-secret" => $ consumerSecret , "access-token" => $ this -> token [ 'access_token' ] , "access-token-expiration" => $ time + $ this -> token [ 'expires_in' ] , ) ; $ this -> config -> getAuthConfigSource ( ) -> addConfigSetting ( 'bitbucket-oauth.' . $ originUrl , $ consumer ) ; } 
protected function initialize ( InputInterface $ input , OutputInterface $ output ) { 
public function seek ( $ offset ) { $ this -> rewind ( ) ; for ( $ i = 0 ; $ i < $ offset ; $ i ++ , $ this -> next ( ) ) ; } 
public function remove ( ) { $ offset = $ this -> key ( ) ; $ this -> offsetUnset ( $ offset ) ; $ this -> seek ( $ offset ) ; } 
public function validate ( $ file , $ arrayLoaderValidationFlags = ValidatingArrayLoader :: CHECK_ALL ) { $ errors = array ( ) ; $ publishErrors = array ( ) ; $ warnings = array ( ) ; 
protected function configure ( ) { $ this -> setDefinition ( array ( new InputArgument ( self :: ARGUMENT_PACKAGE , InputArgument :: REQUIRED , 'Package to inspect' ) , new InputArgument ( self :: ARGUMENT_CONSTRAINT , InputArgument :: OPTIONAL , 'Optional version constraint' , '*' ) , new InputOption ( self :: OPTION_RECURSIVE , 'r' , InputOption :: VALUE_NONE , 'Recursively resolves up to the root package' ) , new InputOption ( self :: OPTION_TREE , 't' , InputOption :: VALUE_NONE , 'Prints the results as a nested tree' ) , ) ) ; } 
protected function printTree ( $ results , $ prefix = '' , $ level = 1 ) { $ count = count ( $ results ) ; $ idx = 0 ; foreach ( $ results as $ result ) { list ( $ package , $ link , $ children ) = $ result ; $ color = $ this -> colors [ $ level % count ( $ this -> colors ) ] ; $ prevColor = $ this -> colors [ ( $ level - 1 ) % count ( $ this -> colors ) ] ; $ isLast = ( ++ $ idx == $ count ) ; $ versionText = ( strpos ( $ package -> getPrettyVersion ( ) , 'No version set' ) === 0 ) ? '' : $ package -> getPrettyVersion ( ) ; $ packageText = rtrim ( sprintf ( '<%s>%s</%1$s> %s' , $ color , $ package -> getPrettyName ( ) , $ versionText ) ) ; $ linkText = sprintf ( '%s <%s>%s</%2$s> %s' , $ link -> getDescription ( ) , $ prevColor , $ link -> getTarget ( ) , $ link -> getPrettyConstraint ( ) ) ; $ circularWarn = $ children === false ? '(circular dependency aborted here)' : '' ; $ this -> writeTreeLine ( rtrim ( sprintf ( "%s%s%s (%s) %s" , $ prefix , $ isLast ? '└──' : '├─ ' $packageTe x , $linkText, c ircularW a n ))); if ( $ children ) { $ this -> printTree ( $ children , $ prefix . ( $ isLast ? ' ' : '│ '), $ e vel + 1 ; } } } 
public function findPackage ( $ name , $ constraint ) { foreach ( $ this -> repositories as $ repository ) { if ( $ package = $ repository -> findPackage ( $ name , $ constraint ) ) { return $ package ; } } return null ; } 
public function createRepository ( $ type , $ config , $ name = null ) { if ( ! isset ( $ this -> repositoryClasses [ $ type ] ) ) { throw new \ InvalidArgumentException ( 'Repository type is not registered: ' . $ type ) ; } if ( isset ( $ config [ 'packagist' ] ) && false === $ config [ 'packagist' ] ) { $ this -> io -> writeError ( '<warning>Repository "' . $ name . '" (' . json_encode ( $ config ) . ') has a packagist key which should be in its own repository definition</warning>' ) ; } $ class = $ this -> repositoryClasses [ $ type ] ; $ reflMethod = new \ ReflectionMethod ( $ class , '__construct' ) ; $ params = $ reflMethod -> getParameters ( ) ; if ( isset ( $ params [ 4 ] ) && $ params [ 4 ] -> getClass ( ) && $ params [ 4 ] -> getClass ( ) -> getName ( ) === 'Composer\Util\RemoteFilesystem' ) { return new $ class ( $ config , $ this -> io , $ this -> config , $ this -> eventDispatcher , $ this -> rfs ) ; } return new $ class ( $ config , $ this -> io , $ this -> config , $ this -> eventDispatcher ) ; } 
public static function suppress ( $ mask = null ) { if ( ! isset ( $ mask ) ) { $ mask = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_DEPRECATED | E_USER_DEPRECATED | E_STRICT ; } $ old = error_reporting ( ) ; self :: $ stack [ ] = $ old ; error_reporting ( $ old & ~ $ mask ) ; return $ old ; } 
public static function call ( $ callable ) { try { self :: suppress ( ) ; $ result = call_user_func_array ( $ callable , array_slice ( func_get_args ( ) , 1 ) ) ; self :: restore ( ) ; return $ result ; } catch ( \ Exception $ e ) { 
public function extractTo ( $ target , array $ roles = array ( 'php' => '/' , 'script' => '/bin' ) , $ vars = array ( ) ) { $ extractionPath = $ target . '/tarball' ; try { $ archive = new \ PharData ( $ this -> file ) ; $ archive -> extractTo ( $ extractionPath , null , true ) ; if ( ! is_file ( $ this -> combine ( $ extractionPath , '/package.xml' ) ) ) { throw new \ RuntimeException ( 'Invalid PEAR package. It must contain package.xml file.' ) ; } $ fileCopyActions = $ this -> buildCopyActions ( $ extractionPath , $ roles , $ vars ) ; $ this -> copyFiles ( $ fileCopyActions , $ extractionPath , $ target , $ roles , $ vars ) ; $ this -> filesystem -> removeDirectory ( $ extractionPath ) ; } catch ( \ Exception $ exception ) { throw new \ UnexpectedValueException ( sprintf ( 'Failed to extract PEAR package %s to %s. Reason: %s' , $ this -> file , $ target , $ exception -> getMessage ( ) ) , 0 , $ exception ) ; } } 
private function copyFiles ( $ files , $ source , $ target , $ roles , $ vars ) { foreach ( $ files as $ file ) { $ from = $ this -> combine ( $ source , $ file [ 'from' ] ) ; $ to = $ this -> combine ( $ target , $ roles [ $ file [ 'role' ] ] ) ; $ to = $ this -> combine ( $ to , $ file [ 'to' ] ) ; $ tasks = $ file [ 'tasks' ] ; $ this -> copyFile ( $ from , $ to , $ tasks , $ vars ) ; } } 
public static function expandPath ( $ path ) { if ( preg_match ( '#^~[\\/]#' , $ path ) ) { return self :: getUserDirectory ( ) . substr ( $ path , 1 ) ; } return preg_replace_callback ( '#^(\$|(?P<percent>%))(?P<var>\w++)(?(percent)%)(?P<path>.*)#' , function ( $ matches ) { 
public function download ( PackageInterface $ package , $ path , $ output = true ) { $ temporaryDir = $ this -> config -> get ( 'vendor-dir' ) . '/composer/' . substr ( md5 ( uniqid ( '' , true ) ) , 0 , 8 ) ; $ retries = 3 ; while ( $ retries -- ) { $ fileName = parent :: download ( $ package , $ path , $ output ) ; if ( $ output ) { $ this -> io -> writeError ( ' Extracting archive' , false , IOInterface :: VERBOSE ) ; } try { $ this -> filesystem -> ensureDirectoryExists ( $ temporaryDir ) ; try { $ this -> extract ( $ fileName , $ temporaryDir ) ; } catch ( \ Exception $ e ) { 
protected function getFileName ( PackageInterface $ package , $ path ) { return rtrim ( $ path . '/' . md5 ( $ path . spl_object_hash ( $ package ) ) . '.' . pathinfo ( parse_url ( $ package -> getDistUrl ( ) , PHP_URL_PATH ) , PATHINFO_EXTENSION ) , '.' ) ; } 
public function download ( PackageInterface $ package , $ path ) { if ( ! $ package -> getSourceReference ( ) ) { throw new \ InvalidArgumentException ( 'Package ' . $ package -> getPrettyName ( ) . ' is missing reference information' ) ; } $ this -> io -> writeError ( " - Installing <info>" . $ package -> getName ( ) . "</info> (<comment>" . $ package -> getFullPrettyVersion ( ) . "</comment>): " , false ) ; $ this -> filesystem -> emptyDirectory ( $ path ) ; $ urls = $ package -> getSourceUrls ( ) ; while ( $ url = array_shift ( $ urls ) ) { try { if ( Filesystem :: isLocalPath ( $ url ) ) { 
public function remove ( PackageInterface $ package , $ path ) { $ this -> io -> writeError ( " - Removing <info>" . $ package -> getName ( ) . "</info> (<comment>" . $ package -> getPrettyVersion ( ) . "</comment>)" ) ; $ this -> cleanChanges ( $ package , $ path , false ) ; if ( ! $ this -> filesystem -> removeDirectory ( $ path ) ) { throw new \ RuntimeException ( 'Could not completely delete ' . $ path . ', aborting.' ) ; } } 
public function getVcsReference ( PackageInterface $ package , $ path ) { $ parser = new VersionParser ; $ guesser = new VersionGuesser ( $ this -> config , $ this -> process , $ parser ) ; $ dumper = new ArrayDumper ; $ packageConfig = $ dumper -> dump ( $ package ) ; if ( $ packageVersion = $ guesser -> guessVersion ( $ packageConfig , $ path ) ) { return $ packageVersion [ 'commit' ] ; } } 
public function getRootIdentifier ( ) { if ( null === $ this -> rootIdentifier ) { $ this -> process -> execute ( sprintf ( 'hg tip --template "{node}"' ) , $ output , $ this -> repoDir ) ; $ output = $ this -> process -> splitLines ( $ output ) ; $ this -> rootIdentifier = $ output [ 0 ] ; } return $ this -> rootIdentifier ; } 
public function getChangeDate ( $ identifier ) { $ this -> process -> execute ( sprintf ( 'hg log --template "{date|rfc3339date}" -r %s' , ProcessExecutor :: escape ( $ identifier ) ) , $ output , $ this -> repoDir ) ; return new \ DateTime ( trim ( $ output ) , new \ DateTimeZone ( 'UTC' ) ) ; } 
public function getTags ( ) { if ( null === $ this -> tags ) { $ tags = array ( ) ; $ this -> process -> execute ( 'hg tags' , $ output , $ this -> repoDir ) ; foreach ( $ this -> process -> splitLines ( $ output ) as $ tag ) { if ( $ tag && preg_match ( '(^([^\s]+)\s+\d+:(.*)$)' , $ tag , $ match ) ) { $ tags [ $ match [ 1 ] ] = $ match [ 2 ] ; } } unset ( $ tags [ 'tip' ] ) ; $ this -> tags = $ tags ; } return $ this -> tags ; } 
public function install ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { $ installPath = $ this -> installPath ; if ( file_exists ( $ installPath ) && ! $ this -> filesystem -> isDirEmpty ( $ installPath ) ) { throw new \ InvalidArgumentException ( "Project directory $installPath is not empty." ) ; } if ( ! is_dir ( $ installPath ) ) { mkdir ( $ installPath , 0777 , true ) ; } $ this -> downloadManager -> download ( $ package , $ installPath ) ; } 
public function getPackageFilename ( PackageInterface $ package ) { $ nameParts = array ( preg_replace ( '#[^a-z0-9-_]#i' , '-' , $ package -> getName ( ) ) ) ; if ( preg_match ( '{^[a-f0-9]{40}$}' , $ package -> getDistReference ( ) ) ) { array_push ( $ nameParts , $ package -> getDistReference ( ) , $ package -> getDistType ( ) ) ; } else { array_push ( $ nameParts , $ package -> getPrettyVersion ( ) , $ package -> getDistReference ( ) ) ; } if ( $ package -> getSourceReference ( ) ) { $ nameParts [ ] = substr ( sha1 ( $ package -> getSourceReference ( ) ) , 0 , 6 ) ; } $ name = implode ( '-' , array_filter ( $ nameParts , function ( $ p ) { return ! empty ( $ p ) ; } ) ) ; return str_replace ( '/' , '-' , $ name ) ; } 
public function archive ( PackageInterface $ package , $ format , $ targetDir , $ fileName = null , $ ignoreFilters = false ) { if ( empty ( $ format ) ) { throw new \ InvalidArgumentException ( 'Format must be specified' ) ; } 
private function getDefaultNormalizer ( ) { $ default = $ this -> getDefault ( ) ; $ trueRegex = $ this -> trueAnswerRegex ; $ falseRegex = $ this -> falseAnswerRegex ; return function ( $ answer ) use ( $ default , $ trueRegex , $ falseRegex ) { if ( is_bool ( $ answer ) ) { return $ answer ; } if ( empty ( $ answer ) && ! empty ( $ default ) ) { return $ default ; } if ( preg_match ( $ trueRegex , $ answer ) ) { return true ; } if ( preg_match ( $ falseRegex , $ answer ) ) { return false ; } return null ; } ; } 
public function archive ( $ sources , $ target , $ format , array $ excludes = array ( ) , $ ignoreFilters = false ) { $ fs = new Filesystem ( ) ; $ sources = $ fs -> normalizePath ( $ sources ) ; $ zip = new ZipArchive ( ) ; $ res = $ zip -> open ( $ target , ZipArchive :: CREATE ) ; if ( $ res === true ) { $ files = new ArchivableFilesFinder ( $ sources , $ excludes , $ ignoreFilters ) ; foreach ( $ files as $ file ) { $ filepath = strtr ( $ file -> getPath ( ) . "/" . $ file -> getFilename ( ) , '\\' , '/' ) ; $ localname = str_replace ( $ sources . '/' , '' , $ filepath ) ; if ( $ file -> isDir ( ) ) { $ zip -> addEmptyDir ( $ localname ) ; } else { $ zip -> addFile ( $ filepath , $ localname ) ; } } if ( $ zip -> close ( ) ) { return $ target ; } } $ message = sprintf ( "Could not create archive '%s' from '%s': %s" , $ target , $ sources , $ zip -> getStatusString ( ) ) ; throw new \ RuntimeException ( $ message ) ; } 
public function equals ( Rule $ rule ) { 
public function write ( array $ hash , $ options = 448 ) { $ dir = dirname ( $ this -> path ) ; if ( ! is_dir ( $ dir ) ) { if ( file_exists ( $ dir ) ) { throw new \ UnexpectedValueException ( $ dir . ' exists and is not a directory.' ) ; } if ( ! @ mkdir ( $ dir , 0777 , true ) ) { throw new \ UnexpectedValueException ( $ dir . ' does not exist and could not be created.' ) ; } } $ retries = 3 ; while ( $ retries -- ) { try { file_put_contents ( $ this -> path , static :: encode ( $ hash , $ options ) . ( $ options & self :: JSON_PRETTY_PRINT ? "\n" : '' ) ) ; break ; } catch ( \ Exception $ e ) { if ( $ retries ) { usleep ( 500000 ) ; continue ; } throw $ e ; } } } 
public static function encode ( $ data , $ options = 448 ) { if ( PHP_VERSION_ID >= 50400 ) { $ json = json_encode ( $ data , $ options ) ; if ( false === $ json ) { self :: throwEncodeError ( json_last_error ( ) ) ; } 
private static function throwEncodeError ( $ code ) { switch ( $ code ) { case JSON_ERROR_DEPTH : $ msg = 'Maximum stack depth exceeded' ; break ; case JSON_ERROR_STATE_MISMATCH : $ msg = 'Underflow or the modes mismatch' ; break ; case JSON_ERROR_CTRL_CHAR : $ msg = 'Unexpected control character found' ; break ; case JSON_ERROR_UTF8 : $ msg = 'Malformed UTF-8 characters, possibly incorrectly encoded' ; break ; default : $ msg = 'Unknown error' ; } throw new \ RuntimeException ( 'JSON encoding failed: ' . $ msg ) ; } 
public static function parseJson ( $ json , $ file = null ) { if ( null === $ json ) { return ; } $ data = json_decode ( $ json , true ) ; if ( null === $ data && JSON_ERROR_NONE !== json_last_error ( ) ) { self :: validateSyntax ( $ json , $ file ) ; } return $ data ; } 
protected static function validateSyntax ( $ json , $ file = null ) { $ parser = new JsonParser ( ) ; $ result = $ parser -> lint ( $ json ) ; if ( null === $ result ) { if ( defined ( 'JSON_ERROR_UTF8' ) && JSON_ERROR_UTF8 === json_last_error ( ) ) { throw new \ UnexpectedValueException ( '"' . $ file . '" is not UTF-8, could not parse as JSON' ) ; } return true ; } throw new ParsingException ( '"' . $ file . '" does not contain valid JSON' . "\n" . $ result -> getMessage ( ) , $ result -> getDetails ( ) ) ; } 
public function compile ( $ pharFile = 'composer.phar' ) { if ( file_exists ( $ pharFile ) ) { unlink ( $ pharFile ) ; } $ process = new Process ( 'git log --pretty="%H" -n1 HEAD' , __DIR__ ) ; if ( $ process -> run ( ) != 0 ) { throw new \ RuntimeException ( 'Can\'t run git log. You must ensure to run compile from composer git repository clone and that git binary is available.' ) ; } $ this -> version = trim ( $ process -> getOutput ( ) ) ; $ process = new Process ( 'git log -n1 --pretty=%ci HEAD' , __DIR__ ) ; if ( $ process -> run ( ) != 0 ) { throw new \ RuntimeException ( 'Can\'t run git log. You must ensure to run compile from composer git repository clone and that git binary is available.' ) ; } $ this -> versionDate = new \ DateTime ( trim ( $ process -> getOutput ( ) ) ) ; $ this -> versionDate -> setTimezone ( new \ DateTimeZone ( 'UTC' ) ) ; $ process = new Process ( 'git describe --tags --exact-match HEAD' ) ; if ( $ process -> run ( ) == 0 ) { $ this -> version = trim ( $ process -> getOutput ( ) ) ; } else { 
public function getNames ( ) { $ names = array ( $ this -> getName ( ) => true , ) ; foreach ( $ this -> getProvides ( ) as $ link ) { $ names [ $ link -> getTarget ( ) ] = true ; } foreach ( $ this -> getReplaces ( ) as $ link ) { $ names [ $ link -> getTarget ( ) ] = true ; } return array_keys ( $ names ) ; } 
public function setRepository ( RepositoryInterface $ repository ) { if ( $ this -> repository && $ repository !== $ this -> repository ) { throw new \ LogicException ( 'A package can only be added to one repository' ) ; } $ this -> repository = $ repository ; } 
public function getFullPrettyVersion ( $ truncate = true ) { if ( ! $ this -> isDev ( ) || ! in_array ( $ this -> getSourceType ( ) , array ( 'hg' , 'git' ) ) ) { return $ this -> getPrettyVersion ( ) ; } 
public static function packageNameToRegexp ( $ whiteListedPattern , $ wrap = '{^%s$}i' ) { $ cleanedWhiteListedPattern = str_replace ( '\\*' , '.*' , preg_quote ( $ whiteListedPattern ) ) ; return sprintf ( $ wrap , $ cleanedWhiteListedPattern ) ; } 
public function filter ( $ relativePath , $ exclude ) { foreach ( $ this -> excludePatterns as $ patternData ) { list ( $ pattern , $ negate , $ stripLeadingSlash ) = $ patternData ; if ( $ stripLeadingSlash ) { $ path = substr ( $ relativePath , 1 ) ; } else { $ path = $ relativePath ; } if ( preg_match ( $ pattern , $ path ) ) { $ exclude = ! $ negate ; } } return $ exclude ; } 
protected function generatePatterns ( $ rules ) { $ patterns = array ( ) ; foreach ( $ rules as $ rule ) { $ patterns [ ] = $ this -> generatePattern ( $ rule ) ; } return $ patterns ; } 
protected function generatePattern ( $ rule ) { $ negate = false ; $ pattern = '{' ; if ( strlen ( $ rule ) && $ rule [ 0 ] === '!' ) { $ negate = true ; $ rule = substr ( $ rule , 1 ) ; } if ( strlen ( $ rule ) && $ rule [ 0 ] === '/' ) { $ pattern .= '^/' ; $ rule = substr ( $ rule , 1 ) ; } elseif ( strlen ( $ rule ) - 1 === strpos ( $ rule , '/' ) ) { $ pattern .= '/' ; $ rule = substr ( $ rule , 0 , - 1 ) ; } elseif ( false === strpos ( $ rule , '/' ) ) { $ pattern .= '/' ; } 
protected function configure ( ) { $ this -> setName ( 'init' ) -> setDescription ( 'Creates a basic composer.json file in current directory.' ) -> setDefinition ( array ( new InputOption ( 'name' , null , InputOption :: VALUE_REQUIRED , 'Name of the package' ) , new InputOption ( 'description' , null , InputOption :: VALUE_REQUIRED , 'Description of package' ) , new InputOption ( 'author' , null , InputOption :: VALUE_REQUIRED , 'Author name of package' ) , <<<EOT The <info>init</info> command creates a basic composer.json file in the current directory. <info>php composer.phar init</info> Read more at https: EOT ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ io = $ this -> getIO ( ) ; $ whitelist = array ( 'name' , 'description' , 'author' , 'type' , 'homepage' , 'require' , 'require-dev' , 'stability' , 'license' ) ; $ options = array_filter ( array_intersect_key ( $ input -> getOptions ( ) , array_flip ( $ whitelist ) ) ) ; if ( isset ( $ options [ 'author' ] ) ) { $ options [ 'authors' ] = $ this -> formatAuthors ( $ options [ 'author' ] ) ; unset ( $ options [ 'author' ] ) ; } $ repositories = $ input -> getOption ( 'repository' ) ; if ( $ repositories ) { $ config = Factory :: createConfig ( $ io ) ; foreach ( $ repositories as $ repo ) { $ options [ 'repositories' ] [ ] = RepositoryFactory :: configFromString ( $ io , $ config , $ repo ) ; } } if ( isset ( $ options [ 'stability' ] ) ) { $ options [ 'minimum-stability' ] = $ options [ 'stability' ] ; unset ( $ options [ 'stability' ] ) ; } $ options [ 'require' ] = isset ( $ options [ 'require' ] ) ? $ this -> formatRequirements ( $ options [ 'require' ] ) : new \ stdClass ; if ( array ( ) === $ options [ 'require' ] ) { $ options [ 'require' ] = new \ stdClass ; } if ( isset ( $ options [ 'require-dev' ] ) ) { $ options [ 'require-dev' ] = $ this -> formatRequirements ( $ options [ 'require-dev' ] ) ; if ( array ( ) === $ options [ 'require-dev' ] ) { $ options [ 'require-dev' ] = new \ stdClass ; } } $ file = new JsonFile ( Factory :: getComposerFile ( ) ) ; $ json = $ file -> encode ( $ options ) ; if ( $ input -> isInteractive ( ) ) { $ io -> writeError ( array ( '' , $ json , '' ) ) ; if ( ! $ io -> askConfirmation ( 'Do you confirm generation [<comment>yes</comment>]? ' , true ) ) { $ io -> writeError ( '<error>Command aborted</error>' ) ; return 1 ; } } $ file -> write ( $ options ) ; if ( $ input -> isInteractive ( ) && is_dir ( '.git' ) ) { $ ignoreFile = realpath ( '.gitignore' ) ; if ( false === $ ignoreFile ) { $ ignoreFile = realpath ( '.' ) . '/.gitignore' ; } if ( ! $ this -> hasVendorIgnore ( $ ignoreFile ) ) { $ question = 'Would you like the <info>vendor</info> directory added to your <info>.gitignore</info> [<comment>yes</comment>]? ' ; if ( $ io -> askConfirmation ( $ question , true ) ) { $ this -> addVendorIgnore ( $ ignoreFile ) ; } } } $ question = 'Would you like to install dependencies now [<comment>yes</comment>]? ' ; if ( $ input -> isInteractive ( ) && $ this -> hasDependencies ( $ options ) && $ io -> askConfirmation ( $ question , true ) ) { $ this -> installDependencies ( $ output ) ; } } 
protected function hasVendorIgnore ( $ ignoreFile , $ vendor = 'vendor' ) { if ( ! file_exists ( $ ignoreFile ) ) { return false ; } $ pattern = sprintf ( '{^/?%s(/\*?)?$}' , preg_quote ( $ vendor ) ) ; $ lines = file ( $ ignoreFile , FILE_IGNORE_NEW_LINES ) ; foreach ( $ lines as $ line ) { if ( preg_match ( $ pattern , $ line ) ) { return true ; } } return false ; } 
private function findBestVersionAndNameForPackage ( InputInterface $ input , $ name , $ phpVersion , $ preferredStability = 'stable' , $ requiredVersion = null , $ minimumStability = null ) { 
public function install ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( ! $ repo -> hasPackage ( $ package ) ) { $ repo -> addPackage ( clone $ package ) ; } } 
public function update ( InstalledRepositoryInterface $ repo , PackageInterface $ initial , PackageInterface $ target ) { if ( ! $ repo -> hasPackage ( $ initial ) ) { throw new \ InvalidArgumentException ( 'Package is not installed: ' . $ initial ) ; } $ repo -> removePackage ( $ initial ) ; if ( ! $ repo -> hasPackage ( $ target ) ) { $ repo -> addPackage ( clone $ target ) ; } } 
public function uninstall ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( ! $ repo -> hasPackage ( $ package ) ) { throw new \ InvalidArgumentException ( 'Package is not installed: ' . $ package ) ; } $ repo -> removePackage ( $ package ) ; } 
public function getInstallPath ( PackageInterface $ package ) { $ targetDir = $ package -> getTargetDir ( ) ; return $ package -> getPrettyName ( ) . ( $ targetDir ? '/' . $ targetDir : '' ) ; } 
public function read ( $ url ) { $ xml = $ this -> requestXml ( $ url , "/channel.xml" ) ; $ channelName = ( string ) $ xml -> name ; $ channelAlias = ( string ) $ xml -> suggestedalias ; $ supportedVersions = array_keys ( $ this -> readerMap ) ; $ selectedRestVersion = $ this -> selectRestVersion ( $ xml , $ supportedVersions ) ; if ( ! $ selectedRestVersion ) { throw new \ UnexpectedValueException ( sprintf ( 'PEAR repository %s does not supports any of %s protocols.' , $ url , implode ( ', ' , $ supportedVersions ) ) ) ; } $ reader = $ this -> readerMap [ $ selectedRestVersion [ 'version' ] ] ; $ packageDefinitions = $ reader -> read ( $ selectedRestVersion [ 'baseUrl' ] ) ; return new ChannelInfo ( $ channelName , $ channelAlias , $ packageDefinitions ) ; } 
private function selectRestVersion ( $ channelXml , $ supportedVersions ) { $ channelXml -> registerXPathNamespace ( 'ns' , self :: CHANNEL_NS ) ; foreach ( $ supportedVersions as $ version ) { $ xpathTest = "ns:servers/ns:*/ns:rest/ns:baseurl[@type='{$version}']" ; $ testResult = $ channelXml -> xpath ( $ xpathTest ) ; foreach ( $ testResult as $ result ) { 
public function add ( $ prefix , $ paths , $ prepend = false ) { if ( ! $ prefix ) { if ( $ prepend ) { $ this -> fallbackDirsPsr0 = array_merge ( ( array ) $ paths , $ this -> fallbackDirsPsr0 ) ; } else { $ this -> fallbackDirsPsr0 = array_merge ( $ this -> fallbackDirsPsr0 , ( array ) $ paths ) ; } return ; } $ first = $ prefix [ 0 ] ; if ( ! isset ( $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] ) ) { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = ( array ) $ paths ; return ; } if ( $ prepend ) { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = array_merge ( ( array ) $ paths , $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] ) ; } else { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = array_merge ( $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] , ( array ) $ paths ) ; } } 
public function addPsr4 ( $ prefix , $ paths , $ prepend = false ) { if ( ! $ prefix ) { 
public function set ( $ prefix , $ paths ) { if ( ! $ prefix ) { $ this -> fallbackDirsPsr0 = ( array ) $ paths ; } else { $ this -> prefixesPsr0 [ $ prefix [ 0 ] ] [ $ prefix ] = ( array ) $ paths ; } } 
public function setPsr4 ( $ prefix , $ paths ) { if ( ! $ prefix ) { $ this -> fallbackDirsPsr4 = ( array ) $ paths ; } else { $ length = strlen ( $ prefix ) ; if ( '\\' !== $ prefix [ $ length - 1 ] ) { throw new \ InvalidArgumentException ( "A non-empty PSR-4 prefix must end with a namespace separator." ) ; } $ this -> prefixLengthsPsr4 [ $ prefix [ 0 ] ] [ $ prefix ] = $ length ; $ this -> prefixDirsPsr4 [ $ prefix ] = ( array ) $ paths ; } } 
public function setApcuPrefix ( $ apcuPrefix ) { $ this -> apcuPrefix = function_exists ( 'apcu_fetch' ) && filter_var ( ini_get ( 'apc.enabled' ) , FILTER_VALIDATE_BOOLEAN ) ? $ apcuPrefix : null ; } 
public function findFile ( $ class ) { 
private function checkHttpProxyFullUriRequestParam ( ) { $ result = $ this -> checkConnectivity ( ) ; if ( $ result !== true ) { return $ result ; } $ url = 'http://repo.packagist.org/packages.json' ; try { $ this -> rfs -> getContents ( 'packagist.org' , $ url , false ) ; } catch ( TransportException $ e ) { try { $ this -> rfs -> getContents ( 'packagist.org' , $ url , false , array ( 'http' => array ( 'request_fulluri' => false ) ) ) ; } catch ( TransportException $ e ) { return 'Unable to assess the situation, maybe packagist.org is down (' . $ e -> getMessage ( ) . ')' ; } return 'It seems there is a problem with your proxy server, try setting the "HTTP_PROXY_REQUEST_FULLURI" and "HTTPS_PROXY_REQUEST_FULLURI" environment variables to "false"' ; } return true ; } 
private function checkHttpsProxyFullUriRequestParam ( ) { $ result = $ this -> checkConnectivity ( ) ; if ( $ result !== true ) { return $ result ; } if ( ! extension_loaded ( 'openssl' ) ) { return 'You need the openssl extension installed for this check' ; } $ url = 'https://api.github.com/repos/Seldaek/jsonlint/zipball/1.0.0' ; try { $ this -> rfs -> getContents ( 'github.com' , $ url , false ) ; } catch ( TransportException $ e ) { try { $ this -> rfs -> getContents ( 'github.com' , $ url , false , array ( 'http' => array ( 'request_fulluri' => false ) ) ) ; } catch ( TransportException $ e ) { return 'Unable to assess the situation, maybe github is down (' . $ e -> getMessage ( ) . ')' ; } return 'It seems there is a problem with your proxy server, try setting the "HTTPS_PROXY_REQUEST_FULLURI" environment variable to "false"' ; } return true ; } 
protected function pruneToHighestPriorityOrInstalled ( Pool $ pool , array $ installedMap , array $ literals ) { $ selected = array ( ) ; $ priority = null ; foreach ( $ literals as $ literal ) { $ package = $ pool -> literalToPackage ( $ literal ) ; if ( isset ( $ installedMap [ $ package -> id ] ) ) { $ selected [ ] = $ literal ; continue ; } if ( null === $ priority ) { $ priority = $ this -> getPriority ( $ pool , $ package ) ; } if ( $ this -> getPriority ( $ pool , $ package ) != $ priority ) { break ; } $ selected [ ] = $ literal ; } return $ selected ; } 
protected function pruneRemoteAliases ( Pool $ pool , array $ literals ) { $ hasLocalAlias = false ; foreach ( $ literals as $ literal ) { $ package = $ pool -> literalToPackage ( $ literal ) ; if ( $ package instanceof AliasPackage && $ package -> isRootPackageAlias ( ) ) { $ hasLocalAlias = true ; break ; } } if ( ! $ hasLocalAlias ) { return $ literals ; } $ selected = array ( ) ; foreach ( $ literals as $ literal ) { $ package = $ pool -> literalToPackage ( $ literal ) ; if ( $ package instanceof AliasPackage && $ package -> isRootPackageAlias ( ) ) { $ selected [ ] = $ literal ; } } return $ selected ; } 
public function isRateLimited ( array $ headers ) { foreach ( $ headers as $ header ) { if ( preg_match ( '{^X-RateLimit-Remaining: *0$}i' , trim ( $ header ) ) ) { return true ; } } return false ; } 
public function watch2OnHighest ( Decisions $ decisions ) { $ literals = $ this -> rule -> getLiterals ( ) ; 
public function moveWatch ( $ from , $ to ) { if ( $ this -> watch1 == $ from ) { $ this -> watch1 = $ to ; } else { $ this -> watch2 = $ to ; } } 
public function merge ( $ config ) { 
public function get ( $ key , $ flags = 0 ) { switch ( $ key ) { case 'vendor-dir' : case 'bin-dir' : case 'process-timeout' : case 'data-dir' : case 'cache-dir' : case 'cache-files-dir' : case 'cache-repo-dir' : case 'cache-vcs-dir' : case 'cafile' : case 'capath' : 
public function prohibitUrlByConfig ( $ url , IOInterface $ io = null ) { 
private function addExtension ( $ name , $ prettyVersion ) { $ extraDescription = null ; try { $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } catch ( \ UnexpectedValueException $ e ) { $ extraDescription = ' (actual version: ' . $ prettyVersion . ')' ; if ( preg_match ( '{^(\d+\.\d+\.\d+(?:\.\d+)?)}' , $ prettyVersion , $ match ) ) { $ prettyVersion = $ match [ 1 ] ; } else { $ prettyVersion = '0' ; } $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } $ packageName = $ this -> buildPackageName ( $ name ) ; $ ext = new CompletePackage ( $ packageName , $ version , $ prettyVersion ) ; $ ext -> setDescription ( 'The ' . $ name . ' PHP extension' . $ extraDescription ) ; $ this -> addPackage ( $ ext ) ; } 
public function setDevRequires ( array $ devRequire ) { $ this -> devRequires = $ this -> replaceSelfVersionDependencies ( $ devRequire , 'devRequires' ) ; $ this -> aliasOf -> setDevRequires ( $ devRequire ) ; } 
public function setConflicts ( array $ conflicts ) { $ this -> conflicts = $ this -> replaceSelfVersionDependencies ( $ conflicts , 'conflicts' ) ; $ this -> aliasOf -> setConflicts ( $ conflicts ) ; } 
public function setProvides ( array $ provides ) { $ this -> provides = $ this -> replaceSelfVersionDependencies ( $ provides , 'provides' ) ; $ this -> aliasOf -> setProvides ( $ provides ) ; } 
public function setReplaces ( array $ replaces ) { $ this -> replaces = $ this -> replaceSelfVersionDependencies ( $ replaces , 'replaces' ) ; $ this -> aliasOf -> setReplaces ( $ replaces ) ; } 
protected function extract ( $ file , $ path ) { * https: * https: * http: */ } 
public static function supports ( IOInterface $ io , Config $ config , $ url , $ deep = false ) { if ( ! preg_match ( '#^https?://bitbucket\.org/([^/]+)/([^/]+)/?$#' , $ url ) ) { return false ; } if ( ! extension_loaded ( 'openssl' ) ) { $ io -> writeError ( 'Skipping Bitbucket hg driver for ' . $ url . ' because the OpenSSL PHP extension is missing.' , true , IOInterface :: VERBOSE ) ; return false ; } return true ; } 
protected function setupFallbackDriver ( $ url ) { $ this -> fallbackDriver = new HgDriver ( array ( 'url' => $ url ) , $ this -> io , $ this -> config , $ this -> process , $ this -> remoteFilesystem ) ; $ this -> fallbackDriver -> initialize ( ) ; } 
public function parseConstraints ( $ constraints ) { if ( ! isset ( self :: $ constraints [ $ constraints ] ) ) { self :: $ constraints [ $ constraints ] = parent :: parseConstraints ( $ constraints ) ; } return self :: $ constraints [ $ constraints ] ; } 
public function getVersion ( ) { if ( isset ( self :: $ version ) ) { return self :: $ version ; } if ( 0 !== $ this -> process -> execute ( 'git --version' , $ output ) ) { return ; } if ( preg_match ( '/^git version (\d+(?:\.\d+)+)/m' , $ output , $ matches ) ) { return self :: $ version = $ matches [ 1 ] ; } } 
public function archive ( $ sources , $ target , $ format , array $ excludes = array ( ) , $ ignoreFilters = false ) { $ sources = realpath ( $ sources ) ; 
public function loadInstalledPlugins ( ) { if ( $ this -> disablePlugins ) { return ; } $ repo = $ this -> composer -> getRepositoryManager ( ) -> getLocalRepository ( ) ; $ globalRepo = $ this -> globalComposer ? $ this -> globalComposer -> getRepositoryManager ( ) -> getLocalRepository ( ) : null ; if ( $ repo ) { $ this -> loadRepository ( $ repo ) ; } if ( $ globalRepo ) { $ this -> loadRepository ( $ globalRepo ) ; } } 
public function addPlugin ( PluginInterface $ plugin ) { $ this -> io -> writeError ( 'Loading plugin ' . get_class ( $ plugin ) , true , IOInterface :: DEBUG ) ; $ this -> plugins [ ] = $ plugin ; $ plugin -> activate ( $ this -> composer , $ this -> io ) ; if ( $ plugin instanceof EventSubscriberInterface ) { $ this -> composer -> getEventDispatcher ( ) -> addSubscriber ( $ plugin ) ; } } 
private function collectDependencies ( Pool $ pool , array $ collected , PackageInterface $ package ) { $ requires = array_merge ( $ package -> getRequires ( ) , $ package -> getDevRequires ( ) ) ; foreach ( $ requires as $ requireLink ) { $ requiredPackage = $ this -> lookupInstalledPackage ( $ pool , $ requireLink ) ; if ( $ requiredPackage && ! isset ( $ collected [ $ requiredPackage -> getName ( ) ] ) ) { $ collected [ $ requiredPackage -> getName ( ) ] = $ requiredPackage ; $ collected = $ this -> collectDependencies ( $ pool , $ collected , $ requiredPackage ) ; } } return $ collected ; } 
private function getInstallPath ( PackageInterface $ package , $ global = false ) { if ( ! $ global ) { return $ this -> composer -> getInstallationManager ( ) -> getInstallPath ( $ package ) ; } return $ this -> globalComposer -> getInstallationManager ( ) -> getInstallPath ( $ package ) ; } 
private function openBrowser ( $ url ) { $ url = ProcessExecutor :: escape ( $ url ) ; $ process = new ProcessExecutor ( $ this -> getIO ( ) ) ; if ( Platform :: isWindows ( ) ) { return $ process -> execute ( 'start "web" explorer "' . $ url . '"' , $ output ) ; } $ linux = $ process -> execute ( 'which xdg-open' , $ output ) ; $ osx = $ process -> execute ( 'which open' , $ output ) ; if ( 0 === $ linux ) { $ process -> execute ( 'xdg-open ' . $ url , $ output ) ; } elseif ( 0 === $ osx ) { $ process -> execute ( 'open ' . $ url , $ output ) ; } else { $ this -> getIO ( ) -> writeError ( 'No suitable browser opening command found, open yourself: ' . $ url ) ; } } 
private function initializeRepos ( ) { $ composer = $ this -> getComposer ( false ) ; if ( $ composer ) { return array_merge ( array ( new ArrayRepository ( array ( $ composer -> getPackage ( ) ) ) ) , 
protected function getFileName ( PackageInterface $ package , $ path ) { return $ path . '/' . pathinfo ( parse_url ( $ package -> getDistUrl ( ) , PHP_URL_PATH ) , PATHINFO_BASENAME ) ; } 
public function doDownload ( PackageInterface $ package , $ path , $ url ) { $ hgUtils = new HgUtils ( $ this -> io , $ this -> config , $ this -> process ) ; $ cloneCommand = function ( $ url ) use ( $ path ) { return sprintf ( 'hg clone %s %s' , ProcessExecutor :: escape ( $ url ) , ProcessExecutor :: escape ( $ path ) ) ; } ; $ hgUtils -> runCommand ( $ cloneCommand , $ url , $ path ) ; $ ref = ProcessExecutor :: escape ( $ package -> getSourceReference ( ) ) ; $ command = sprintf ( 'hg up %s' , $ ref ) ; if ( 0 !== $ this -> process -> execute ( $ command , $ ignoredOutput , realpath ( $ path ) ) ) { throw new \ RuntimeException ( 'Failed to execute ' . $ command . "\n\n" . $ this -> process -> getErrorOutput ( ) ) ; } } 
public function doUpdate ( PackageInterface $ initial , PackageInterface $ target , $ path , $ url ) { $ hgUtils = new HgUtils ( $ this -> io , $ this -> config , $ this -> process ) ; $ ref = $ target -> getSourceReference ( ) ; $ this -> io -> writeError ( " Updating to " . $ target -> getSourceReference ( ) ) ; if ( ! $ this -> hasMetadataRepository ( $ path ) ) { throw new \ RuntimeException ( 'The .hg directory is missing from ' . $ path . ', see https://getcomposer.org/commit-deps for more information' ) ; } $ command = function ( $ url ) use ( $ ref ) { return sprintf ( 'hg pull %s && hg up %s' , ProcessExecutor :: escape ( $ url ) , ProcessExecutor :: escape ( $ ref ) ) ; } ; $ hgUtils -> runCommand ( $ command , $ url , $ path ) ; } 
public function getLocalChanges ( PackageInterface $ package , $ path ) { if ( ! is_dir ( $ path . '/.hg' ) ) { return null ; } $ this -> process -> execute ( 'hg st' , $ output , realpath ( $ path ) ) ; return trim ( $ output ) ? : null ; } 
protected function getCommitLogs ( $ fromReference , $ toReference , $ path ) { $ command = sprintf ( 'hg log -r %s:%s --style compact' , ProcessExecutor :: escape ( $ fromReference ) , ProcessExecutor :: escape ( $ toReference ) ) ; if ( 0 !== $ this -> process -> execute ( $ command , $ output , realpath ( $ path ) ) ) { throw new \ RuntimeException ( 'Failed to execute ' . $ command . "\n\n" . $ this -> process -> getErrorOutput ( ) ) ; } return $ output ; } 
public function execute ( $ command , $ url , $ cwd = null , $ path = null , $ verbose = false ) { 
public function executeLocal ( $ command , $ path , $ cwd = null , $ verbose = false ) { 
protected function getCommand ( $ cmd , $ url , $ path = null ) { $ cmd = sprintf ( '%s %s%s %s' , $ cmd , '--non-interactive ' , $ this -> getCredentialString ( ) , ProcessExecutor :: escape ( $ url ) ) ; if ( $ path ) { $ cmd .= ' ' . ProcessExecutor :: escape ( $ path ) ; } return $ cmd ; } 
protected function getCredentialString ( ) { if ( ! $ this -> hasAuth ( ) ) { return '' ; } return sprintf ( ' %s--username %s --password %s ' , $ this -> getAuthCache ( ) , ProcessExecutor :: escape ( $ this -> getUsername ( ) ) , ProcessExecutor :: escape ( $ this -> getPassword ( ) ) ) ; } 
protected function getPassword ( ) { if ( $ this -> credentials === null ) { throw new \ LogicException ( "No svn auth detected." ) ; } return isset ( $ this -> credentials [ 'password' ] ) ? $ this -> credentials [ 'password' ] : '' ; } 
protected function hasAuth ( ) { if ( null !== $ this -> hasAuth ) { return $ this -> hasAuth ; } if ( false === $ this -> createAuthFromConfig ( ) ) { $ this -> createAuthFromUrl ( ) ; } return $ this -> hasAuth ; } 
private function createAuthFromConfig ( ) { if ( ! $ this -> config -> has ( 'http-basic' ) ) { return $ this -> hasAuth = false ; } $ authConfig = $ this -> config -> get ( 'http-basic' ) ; $ host = parse_url ( $ this -> url , PHP_URL_HOST ) ; if ( isset ( $ authConfig [ $ host ] ) ) { $ this -> credentials [ 'username' ] = $ authConfig [ $ host ] [ 'username' ] ; $ this -> credentials [ 'password' ] = $ authConfig [ $ host ] [ 'password' ] ; return $ this -> hasAuth = true ; } return $ this -> hasAuth = false ; } 
private function createAuthFromUrl ( ) { $ uri = parse_url ( $ this -> url ) ; if ( empty ( $ uri [ 'user' ] ) ) { return $ this -> hasAuth = false ; } $ this -> credentials [ 'username' ] = $ uri [ 'user' ] ; if ( ! empty ( $ uri [ 'pass' ] ) ) { $ this -> credentials [ 'password' ] = $ uri [ 'pass' ] ; } return $ this -> hasAuth = true ; } 
public function binaryVersion ( ) { if ( ! self :: $ version ) { if ( 0 === $ this -> process -> execute ( 'svn --version' , $ output ) ) { if ( preg_match ( '{(\d+(?:\.\d+)+)}' , $ output , $ match ) ) { self :: $ version = $ match [ 1 ] ; } } } return self :: $ version ; } 
public function extract ( $ file , $ path ) { 
protected function getErrorMessage ( $ retval , $ file ) { switch ( $ retval ) { case ZipArchive :: ER_EXISTS : return sprintf ( "File '%s' already exists." , $ file ) ; case ZipArchive :: ER_INCONS : return sprintf ( "Zip archive '%s' is inconsistent." , $ file ) ; case ZipArchive :: ER_INVAL : return sprintf ( "Invalid argument (%s)" , $ file ) ; case ZipArchive :: ER_MEMORY : return sprintf ( "Malloc failure (%s)" , $ file ) ; case ZipArchive :: ER_NOENT : return sprintf ( "No such zip file: '%s'" , $ file ) ; case ZipArchive :: ER_NOZIP : return sprintf ( "'%s' is not a zip archive." , $ file ) ; case ZipArchive :: ER_OPEN : return sprintf ( "Can't open zip file: %s" , $ file ) ; case ZipArchive :: ER_READ : return sprintf ( "Zip read error (%s)" , $ file ) ; case ZipArchive :: ER_SEEK : return sprintf ( "Zip seek error (%s)" , $ file ) ; default : return sprintf ( "'%s' is not a valid zip archive, got error code: %s" , $ file , $ retval ) ; } } 
protected function initialize ( ) { parent :: initialize ( ) ; $ loader = new ValidatingArrayLoader ( new ArrayLoader ( null , true ) , false ) ; foreach ( $ this -> config as $ package ) { try { $ package = $ loader -> load ( $ package ) ; } catch ( \ Exception $ e ) { throw new InvalidRepositoryException ( 'A repository of type "package" contains an invalid package definition: ' . $ e -> getMessage ( ) . "\n\nInvalid package definition:\n" . json_encode ( $ package ) ) ; } $ this -> addPackage ( $ package ) ; } } 
protected function reapplyChanges ( $ path ) { $ path = $ this -> normalizePath ( $ path ) ; if ( $ this -> hasStashedChanges ) { $ this -> hasStashedChanges = false ; $ this -> io -> writeError ( ' <info>Re-applying stashed changes</info>' ) ; if ( 0 !== $ this -> process -> execute ( 'git stash pop' , $ output , $ path ) ) { throw new \ RuntimeException ( "Failed to apply stashed changes:\n\n" . $ this -> process -> getErrorOutput ( ) ) ; } } $ this -> hasDiscardedChanges = false ; } 
protected function updateToCommit ( $ path , $ reference , $ branch , $ date ) { $ force = $ this -> hasDiscardedChanges || $ this -> hasStashedChanges ? '-f ' : '' ; 
public function doDownload ( PackageInterface $ package , $ path , $ url ) { SvnUtil :: cleanEnv ( ) ; $ ref = $ package -> getSourceReference ( ) ; $ repo = $ package -> getRepository ( ) ; if ( $ repo instanceof VcsRepository ) { $ repoConfig = $ repo -> getRepoConfig ( ) ; if ( array_key_exists ( 'svn-cache-credentials' , $ repoConfig ) ) { $ this -> cacheCredentials = ( bool ) $ repoConfig [ 'svn-cache-credentials' ] ; } } $ this -> io -> writeError ( " Checking out " . $ package -> getSourceReference ( ) ) ; $ this -> execute ( $ url , "svn co" , sprintf ( "%s/%s" , $ url , $ ref ) , null , $ path ) ; } 
public function doUpdate ( PackageInterface $ initial , PackageInterface $ target , $ path , $ url ) { SvnUtil :: cleanEnv ( ) ; $ ref = $ target -> getSourceReference ( ) ; if ( ! $ this -> hasMetadataRepository ( $ path ) ) { throw new \ RuntimeException ( 'The .svn directory is missing from ' . $ path . ', see https://getcomposer.org/commit-deps for more information' ) ; } $ util = new SvnUtil ( $ url , $ this -> io , $ this -> config ) ; $ flags = "" ; if ( version_compare ( $ util -> binaryVersion ( ) , '1.7.0' , '>=' ) ) { $ flags .= ' --ignore-ancestry' ; } $ this -> io -> writeError ( " Checking out " . $ ref ) ; $ this -> execute ( $ url , "svn switch" . $ flags , sprintf ( "%s/%s" , $ url , $ ref ) , $ path ) ; } 
public function getLocalChanges ( PackageInterface $ package , $ path ) { if ( ! $ this -> hasMetadataRepository ( $ path ) ) { return null ; } $ this -> process -> execute ( 'svn status --ignore-externals' , $ output , $ path ) ; return preg_match ( '{^ *[^X ] +}m' , $ output ) ? $ output : null ; } 
protected function execute ( $ baseUrl , $ command , $ url , $ cwd = null , $ path = null ) { $ util = new SvnUtil ( $ baseUrl , $ this -> io , $ this -> config ) ; $ util -> setCacheCredentials ( $ this -> cacheCredentials ) ; try { return $ util -> execute ( $ command , $ url , $ cwd , $ path , $ this -> io -> isVerbose ( ) ) ; } catch ( \ RuntimeException $ e ) { throw new \ RuntimeException ( 'Package could not be downloaded, ' . $ e -> getMessage ( ) ) ; } } 
protected function getCommitLogs ( $ fromReference , $ toReference , $ path ) { if ( preg_match ( '{.*@(\d+)$}' , $ fromReference ) && preg_match ( '{.*@(\d+)$}' , $ toReference ) ) { 
public function whatProvides ( $ name , ConstraintInterface $ constraint = null , $ mustMatchName = false , $ bypassFilters = false ) { if ( $ bypassFilters ) { return $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , true ) ; } $ key = ( ( int ) $ mustMatchName ) . $ constraint ; if ( isset ( $ this -> providerCache [ $ name ] [ $ key ] ) ) { return $ this -> providerCache [ $ name ] [ $ key ] ; } return $ this -> providerCache [ $ name ] [ $ key ] = $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , $ bypassFilters ) ; } 
protected function createRemoveRule ( PackageInterface $ package , $ reason , $ job ) { return new GenericRule ( array ( - $ package -> id ) , $ reason , $ job [ 'packageName' ] , $ job ) ; } 
public static function getMessage ( ) { $ paths = self :: getAll ( ) ; if ( empty ( $ paths [ 0 ] ) ) { array_shift ( $ paths ) ; } $ ini = array_shift ( $ paths ) ; if ( empty ( $ ini ) ) { return 'A php.ini file does not exist. You will have to create one.' ; } if ( ! empty ( $ paths ) ) { return 'Your command-line PHP is using multiple ini files. Run `php --ini` to show them.' ; } return 'The php.ini used by your command-line PHP is: ' . $ ini ; } 
public function update ( InstalledRepositoryInterface $ repo , PackageInterface $ initial , PackageInterface $ target ) { $ this -> uninstall ( $ repo , $ initial ) ; $ this -> install ( $ repo , $ target ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { return parent :: doExecute ( $ input , $ output , false ) ; } 
public function isInstalled ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( ! $ repo -> hasPackage ( $ package ) ) { return false ; } $ installPath = $ this -> getInstallPath ( $ package ) ; if ( is_readable ( $ installPath ) ) { return true ; } return ( Platform :: isWindows ( ) && $ this -> filesystem -> isJunction ( $ installPath ) ) || is_link ( $ installPath ) ; } 
public function uninstall ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( ! $ repo -> hasPackage ( $ package ) ) { throw new \ InvalidArgumentException ( 'Package is not installed: ' . $ package ) ; } $ this -> removeCode ( $ package ) ; $ this -> binaryInstaller -> removeBinaries ( $ package ) ; $ repo -> removePackage ( $ package ) ; $ downloadPath = $ this -> getPackageBasePath ( $ package ) ; if ( strpos ( $ package -> getName ( ) , '/' ) ) { $ packageVendorDir = dirname ( $ downloadPath ) ; if ( is_dir ( $ packageVendorDir ) && $ this -> filesystem -> isDirEmpty ( $ packageVendorDir ) ) { Silencer :: call ( 'rmdir' , $ packageVendorDir ) ; } } } 
public function getInstallPath ( PackageInterface $ package ) { $ this -> initializeVendorDir ( ) ; $ basePath = ( $ this -> vendorDir ? $ this -> vendorDir . '/' : '' ) . $ package -> getPrettyName ( ) ; $ targetDir = $ package -> getTargetDir ( ) ; return $ basePath . ( $ targetDir ? '/' . $ targetDir : '' ) ; } 
public function ensureBinariesPresence ( PackageInterface $ package ) { $ this -> binaryInstaller -> installBinaries ( $ package , $ this -> getInstallPath ( $ package ) , false ) ; } 
protected function getPackageBasePath ( PackageInterface $ package ) { $ installPath = $ this -> getInstallPath ( $ package ) ; $ targetDir = $ package -> getTargetDir ( ) ; if ( $ targetDir ) { return preg_replace ( '{/*' . str_replace ( '/' , '/+' , preg_quote ( $ targetDir ) ) . '/?$}' , '' , $ installPath ) ; } return $ installPath ; } 
public function addRepository ( $ name , $ config ) { $ this -> manipulateJson ( 'addRepository' , $ name , $ config , function ( & $ config , $ repo , $ repoConfig ) { 
public function addConfigSetting ( $ name , $ value ) { $ authConfig = $ this -> authConfig ; $ this -> manipulateJson ( 'addConfigSetting' , $ name , $ value , function ( & $ config , $ key , $ val ) use ( $ authConfig ) { if ( preg_match ( '{^(bitbucket-oauth|github-oauth|gitlab-oauth|gitlab-token|http-basic|platform)\.}' , $ key ) ) { list ( $ key , $ host ) = explode ( '.' , $ key , 2 ) ; if ( $ authConfig ) { $ config [ $ key ] [ $ host ] = $ val ; } else { $ config [ 'config' ] [ $ key ] [ $ host ] = $ val ; } } else { $ config [ 'config' ] [ $ key ] = $ val ; } } ) ; } 
public function removeConfigSetting ( $ name ) { $ authConfig = $ this -> authConfig ; $ this -> manipulateJson ( 'removeConfigSetting' , $ name , function ( & $ config , $ key ) use ( $ authConfig ) { if ( preg_match ( '{^(bitbucket-oauth|github-oauth|gitlab-oauth|gitlab-token|http-basic|platform)\.}' , $ key ) ) { list ( $ key , $ host ) = explode ( '.' , $ key , 2 ) ; if ( $ authConfig ) { unset ( $ config [ $ key ] [ $ host ] ) ; } else { unset ( $ config [ 'config' ] [ $ key ] [ $ host ] ) ; } } else { unset ( $ config [ 'config' ] [ $ key ] ) ; } } ) ; } 
public function addProperty ( $ name , $ value ) { $ this -> manipulateJson ( 'addProperty' , $ name , $ value , function ( & $ config , $ key , $ val ) { if ( substr ( $ key , 0 , 6 ) === 'extra.' || substr ( $ key , 0 , 8 ) === 'scripts.' ) { $ bits = explode ( '.' , $ key ) ; $ last = array_pop ( $ bits ) ; $ arr = & $ config [ reset ( $ bits ) ] ; foreach ( $ bits as $ bit ) { if ( ! isset ( $ arr [ $ bit ] ) ) { $ arr [ $ bit ] = array ( ) ; } $ arr = & $ arr [ $ bit ] ; } $ arr [ $ last ] = $ val ; } else { $ config [ $ key ] = $ val ; } } ) ; } 
public function addLink ( $ type , $ name , $ value ) { $ this -> manipulateJson ( 'addLink' , $ type , $ name , $ value , function ( & $ config , $ type , $ name , $ value ) { $ config [ $ type ] [ $ name ] = $ value ; } ) ; } 
public function removeLink ( $ type , $ name ) { $ this -> manipulateJson ( 'removeSubNode' , $ type , $ name , function ( & $ config , $ type , $ name ) { unset ( $ config [ $ type ] [ $ name ] ) ; if ( 0 === count ( $ config [ $ type ] ) ) { unset ( $ config [ $ type ] ) ; } } ) ; } 
public function findPackage ( $ name , $ constraint ) { if ( ! $ this -> hasProviders ( ) ) { return parent :: findPackage ( $ name , $ constraint ) ; } $ name = strtolower ( $ name ) ; if ( ! $ constraint instanceof ConstraintInterface ) { $ versionParser = new VersionParser ( ) ; $ constraint = $ versionParser -> parseConstraints ( $ constraint ) ; } foreach ( $ this -> getProviderNames ( ) as $ providerName ) { if ( $ name === $ providerName ) { $ packages = $ this -> whatProvides ( new Pool ( 'dev' ) , $ providerName ) ; foreach ( $ packages as $ package ) { if ( $ name === $ package -> getName ( ) ) { $ pkgConstraint = new Constraint ( '==' , $ package -> getVersion ( ) ) ; if ( $ constraint -> matches ( $ pkgConstraint ) ) { return $ package ; } } } break ; } } } 
protected function initialize ( ) { parent :: initialize ( ) ; $ repoData = $ this -> loadDataFromServer ( ) ; foreach ( $ repoData as $ package ) { $ this -> addPackage ( $ this -> createPackage ( $ package , 'Composer\Package\CompletePackage' ) ) ; } } 
protected function requestContent ( $ origin , $ path ) { $ url = rtrim ( $ origin , '/' ) . '/' . ltrim ( $ path , '/' ) ; $ content = $ this -> rfs -> getContents ( $ origin , $ url , false ) ; if ( ! $ content ) { throw new \ UnexpectedValueException ( 'The PEAR channel at ' . $ url . ' did not respond.' ) ; } return str_replace ( 'http://pear.php.net/rest/' , 'https://pear.php.net/rest/' , $ content ) ; } 
protected function requestXml ( $ origin , $ path ) { 
public function initialize ( ) { 
protected function updateLocalRepo ( ) { $ fs = new Filesystem ( ) ; $ fs -> ensureDirectoryExists ( $ this -> checkoutDir ) ; if ( ! is_writable ( dirname ( $ this -> checkoutDir ) ) ) { throw new \ RuntimeException ( 'Can not clone ' . $ this -> url . ' to access package information. The "' . $ this -> checkoutDir . '" directory is not writable by the current user.' ) ; } 
public function getFileContent ( $ file , $ identifier ) { $ command = sprintf ( 'fossil cat -r %s %s' , ProcessExecutor :: escape ( $ identifier ) , ProcessExecutor :: escape ( $ file ) ) ; $ this -> process -> execute ( $ command , $ content , $ this -> checkoutDir ) ; if ( ! trim ( $ content ) ) { return null ; } return $ content ; } 
public function getChangeDate ( $ identifier ) { $ this -> process -> execute ( 'fossil finfo -b -n 1 composer.json' , $ output , $ this -> checkoutDir ) ; list ( $ ckout , $ date , $ message ) = explode ( ' ' , trim ( $ output ) , 3 ) ; return new \ DateTime ( $ date , new \ DateTimeZone ( 'UTC' ) ) ; } 
public function getTags ( ) { if ( null === $ this -> tags ) { $ tags = array ( ) ; $ this -> process -> execute ( 'fossil tag list' , $ output , $ this -> checkoutDir ) ; foreach ( $ this -> process -> splitLines ( $ output ) as $ tag ) { $ tags [ $ tag ] = $ tag ; } $ this -> tags = $ tags ; } return $ this -> tags ; } 
public function getBranches ( ) { if ( null === $ this -> branches ) { $ branches = array ( ) ; $ bookmarks = array ( ) ; $ this -> process -> execute ( 'fossil branch list' , $ output , $ this -> checkoutDir ) ; foreach ( $ this -> process -> splitLines ( $ output ) as $ branch ) { $ branch = trim ( preg_replace ( '/^\*/' , '' , trim ( $ branch ) ) ) ; $ branches [ $ branch ] = $ branch ; } $ this -> branches = $ branches ; } return $ this -> branches ; } 
public function removeInstaller ( InstallerInterface $ installer ) { if ( false !== ( $ key = array_search ( $ installer , $ this -> installers , true ) ) ) { array_splice ( $ this -> installers , $ key , 1 ) ; $ this -> cache = array ( ) ; } } 
public function disablePlugins ( ) { foreach ( $ this -> installers as $ i => $ installer ) { if ( ! $ installer instanceof PluginInstaller ) { continue ; } unset ( $ this -> installers [ $ i ] ) ; } } 
public function getInstaller ( $ type ) { $ type = strtolower ( $ type ) ; if ( isset ( $ this -> cache [ $ type ] ) ) { return $ this -> cache [ $ type ] ; } foreach ( $ this -> installers as $ installer ) { if ( $ installer -> supports ( $ type ) ) { return $ this -> cache [ $ type ] = $ installer ; } } throw new \ InvalidArgumentException ( 'Unknown installer type: ' . $ type ) ; } 
public function isPackageInstalled ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( $ package instanceof AliasPackage ) { return $ repo -> hasPackage ( $ package ) && $ this -> isPackageInstalled ( $ repo , $ package -> getAliasOf ( ) ) ; } return $ this -> getInstaller ( $ package -> getType ( ) ) -> isInstalled ( $ repo , $ package ) ; } 
public function ensureBinariesPresence ( PackageInterface $ package ) { try { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; } catch ( \ InvalidArgumentException $ e ) { 
public function execute ( RepositoryInterface $ repo , OperationInterface $ operation ) { $ method = $ operation -> getJobType ( ) ; $ this -> $ method ( $ repo , $ operation ) ; } 
public function install ( RepositoryInterface $ repo , InstallOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; $ installer -> install ( $ repo , $ package ) ; $ this -> markForNotification ( $ package ) ; } 
public function update ( RepositoryInterface $ repo , UpdateOperation $ operation ) { $ initial = $ operation -> getInitialPackage ( ) ; $ target = $ operation -> getTargetPackage ( ) ; $ initialType = $ initial -> getType ( ) ; $ targetType = $ target -> getType ( ) ; if ( $ initialType === $ targetType ) { $ installer = $ this -> getInstaller ( $ initialType ) ; $ installer -> update ( $ repo , $ initial , $ target ) ; $ this -> markForNotification ( $ target ) ; } else { $ this -> getInstaller ( $ initialType ) -> uninstall ( $ repo , $ initial ) ; $ this -> getInstaller ( $ targetType ) -> install ( $ repo , $ target ) ; } } 
public function uninstall ( RepositoryInterface $ repo , UninstallOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; $ installer -> uninstall ( $ repo , $ package ) ; } 
public function markAliasInstalled ( RepositoryInterface $ repo , MarkAliasInstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; if ( ! $ repo -> hasPackage ( $ package ) ) { $ repo -> addPackage ( clone $ package ) ; } } 
public function markAliasUninstalled ( RepositoryInterface $ repo , MarkAliasUninstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ repo -> removePackage ( $ package ) ; } 
public function getInstallPath ( PackageInterface $ package ) { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; return $ installer -> getInstallPath ( $ package ) ; } 
private static function fixHttpHeaderField ( $ header ) { if ( ! is_array ( $ header ) ) { $ header = explode ( "\r\n" , $ header ) ; } uasort ( $ header , function ( $ el ) { return stripos ( $ el , 'content-type' ) === 0 ? 1 : - 1 ; } ) ; return $ header ; } 
public function initialize ( ) { $ this -> url = $ this -> baseUrl = rtrim ( self :: normalizeUrl ( $ this -> url ) , '/' ) ; SvnUtil :: cleanEnv ( ) ; if ( isset ( $ this -> repoConfig [ 'trunk-path' ] ) ) { $ this -> trunkPath = $ this -> repoConfig [ 'trunk-path' ] ; } if ( isset ( $ this -> repoConfig [ 'branches-path' ] ) ) { $ this -> branchesPath = $ this -> repoConfig [ 'branches-path' ] ; } if ( isset ( $ this -> repoConfig [ 'tags-path' ] ) ) { $ this -> tagsPath = $ this -> repoConfig [ 'tags-path' ] ; } if ( array_key_exists ( 'svn-cache-credentials' , $ this -> repoConfig ) ) { $ this -> cacheCredentials = ( bool ) $ this -> repoConfig [ 'svn-cache-credentials' ] ; } if ( isset ( $ this -> repoConfig [ 'package-path' ] ) ) { $ this -> packagePath = '/' . trim ( $ this -> repoConfig [ 'package-path' ] , '/' ) ; } if ( false !== ( $ pos = strrpos ( $ this -> url , '/' . $ this -> trunkPath ) ) ) { $ this -> baseUrl = substr ( $ this -> url , 0 , $ pos ) ; } $ this -> cache = new Cache ( $ this -> io , $ this -> config -> get ( 'cache-repo-dir' ) . '/' . preg_replace ( '{[^a-z0-9.]}i' , '-' , $ this -> baseUrl ) ) ; $ this -> getBranches ( ) ; $ this -> getTags ( ) ; } 
public function getComposerInformation ( $ identifier ) { if ( ! isset ( $ this -> infoCache [ $ identifier ] ) ) { if ( $ this -> shouldCache ( $ identifier ) && $ res = $ this -> cache -> read ( $ identifier . '.json' ) ) { return $ this -> infoCache [ $ identifier ] = JsonFile :: parseJson ( $ res ) ; } try { $ composer = $ this -> getBaseComposerInformation ( $ identifier ) ; } catch ( TransportException $ e ) { $ message = $ e -> getMessage ( ) ; if ( stripos ( $ message , 'path not found' ) === false && stripos ( $ message , 'svn: warning: W160013' ) === false ) { throw $ e ; } 
public function getChangeDate ( $ identifier ) { $ identifier = '/' . trim ( $ identifier , '/' ) . '/' ; preg_match ( '{^(.+?)(@\d+)?/$}' , $ identifier , $ match ) ; if ( ! empty ( $ match [ 2 ] ) ) { $ path = $ match [ 1 ] ; $ rev = $ match [ 2 ] ; } else { $ path = $ identifier ; $ rev = '' ; } $ output = $ this -> execute ( 'svn info' , $ this -> baseUrl . $ path . $ rev ) ; foreach ( $ this -> process -> splitLines ( $ output ) as $ line ) { if ( $ line && preg_match ( '{^Last Changed Date: ([^(]+)}' , $ line , $ match ) ) { return new \ DateTime ( $ match [ 1 ] , new \ DateTimeZone ( 'UTC' ) ) ; } } return null ; } 
public function getTags ( ) { if ( null === $ this -> tags ) { $ this -> tags = array ( ) ; if ( $ this -> tagsPath !== false ) { $ output = $ this -> execute ( 'svn ls --verbose' , $ this -> baseUrl . '/' . $ this -> tagsPath ) ; if ( $ output ) { foreach ( $ this -> process -> splitLines ( $ output ) as $ line ) { $ line = trim ( $ line ) ; if ( $ line && preg_match ( '{^\s*(\S+).*?(\S+)\s*$}' , $ line , $ match ) ) { if ( isset ( $ match [ 1 ] ) && isset ( $ match [ 2 ] ) && $ match [ 2 ] !== './' ) { $ this -> tags [ rtrim ( $ match [ 2 ] , '/' ) ] = $ this -> buildIdentifier ( '/' . $ this -> tagsPath . '/' . $ match [ 2 ] , $ match [ 1 ] ) ; } } } } } } return $ this -> tags ; } 
public function getBranches ( ) { if ( null === $ this -> branches ) { $ this -> branches = array ( ) ; if ( false === $ this -> trunkPath ) { $ trunkParent = $ this -> baseUrl . '/' ; } else { $ trunkParent = $ this -> baseUrl . '/' . $ this -> trunkPath ; } $ output = $ this -> execute ( 'svn ls --verbose' , $ trunkParent ) ; if ( $ output ) { foreach ( $ this -> process -> splitLines ( $ output ) as $ line ) { $ line = trim ( $ line ) ; if ( $ line && preg_match ( '{^\s*(\S+).*?(\S+)\s*$}' , $ line , $ match ) ) { if ( isset ( $ match [ 1 ] ) && isset ( $ match [ 2 ] ) && $ match [ 2 ] === './' ) { $ this -> branches [ 'trunk' ] = $ this -> buildIdentifier ( '/' . $ this -> trunkPath , $ match [ 1 ] ) ; $ this -> rootIdentifier = $ this -> branches [ 'trunk' ] ; break ; } } } } unset ( $ output ) ; if ( $ this -> branchesPath !== false ) { $ output = $ this -> execute ( 'svn ls --verbose' , $ this -> baseUrl . '/' . $ this -> branchesPath ) ; if ( $ output ) { foreach ( $ this -> process -> splitLines ( trim ( $ output ) ) as $ line ) { $ line = trim ( $ line ) ; if ( $ line && preg_match ( '{^\s*(\S+).*?(\S+)\s*$}' , $ line , $ match ) ) { if ( isset ( $ match [ 1 ] ) && isset ( $ match [ 2 ] ) && $ match [ 2 ] !== './' ) { $ this -> branches [ rtrim ( $ match [ 2 ] , '/' ) ] = $ this -> buildIdentifier ( '/' . $ this -> branchesPath . '/' . $ match [ 2 ] , $ match [ 1 ] ) ; } } } } } } return $ this -> branches ; } 
public static function supports ( IOInterface $ io , Config $ config , $ url , $ deep = false ) { $ url = self :: normalizeUrl ( $ url ) ; if ( preg_match ( '#(^svn://|^svn\+ssh://|svn\.)#i' , $ url ) ) { return true ; } 
protected static function normalizeUrl ( $ url ) { $ fs = new Filesystem ( ) ; if ( $ fs -> isAbsolutePath ( $ url ) ) { return 'file://' . strtr ( $ url , '\\' , '/' ) ; } return $ url ; } 
protected function execute ( $ command , $ url ) { if ( null === $ this -> util ) { $ this -> util = new SvnUtil ( $ this -> baseUrl , $ this -> io , $ this -> config , $ this -> process ) ; $ this -> util -> setCacheCredentials ( $ this -> cacheCredentials ) ; } try { return $ this -> util -> execute ( $ command , $ url ) ; } catch ( \ RuntimeException $ e ) { if ( null === $ this -> util -> binaryVersion ( ) ) { throw new \ RuntimeException ( 'Failed to load ' . $ this -> url . ', svn was not found, check that it is installed and in your PATH env.' . "\n\n" . $ this -> process -> getErrorOutput ( ) ) ; } throw new \ RuntimeException ( 'Repository ' . $ this -> url . ' could not be processed, ' . $ e -> getMessage ( ) ) ; } } 
public function insert ( RuleWatchNode $ node ) { if ( $ node -> getRule ( ) -> isAssertion ( ) ) { return ; } foreach ( array ( $ node -> watch1 , $ node -> watch2 ) as $ literal ) { if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { $ this -> watchChains [ $ literal ] = new RuleWatchChain ; } $ this -> watchChains [ $ literal ] -> unshift ( $ node ) ; } } 
public function propagateLiteral ( $ decidedLiteral , $ level , $ decisions ) { 
protected function moveWatch ( $ fromLiteral , $ toLiteral , $ node ) { if ( ! isset ( $ this -> watchChains [ $ toLiteral ] ) ) { $ this -> watchChains [ $ toLiteral ] = new RuleWatchChain ; } $ node -> moveWatch ( $ fromLiteral , $ toLiteral ) ; $ this -> watchChains [ $ fromLiteral ] -> remove ( ) ; $ this -> watchChains [ $ toLiteral ] -> unshift ( $ node ) ; } 
public function download ( PackageInterface $ package , $ path , $ output = true ) { if ( ! $ package -> getDistUrl ( ) ) { throw new \ InvalidArgumentException ( 'The given package is missing url information' ) ; } if ( $ output ) { $ this -> io -> writeError ( " - Installing <info>" . $ package -> getName ( ) . "</info> (<comment>" . $ package -> getFullPrettyVersion ( ) . "</comment>): " , false ) ; } $ urls = $ package -> getDistUrls ( ) ; while ( $ url = array_shift ( $ urls ) ) { try { $ fileName = $ this -> doDownload ( $ package , $ path , $ url ) ; break ; } catch ( \ Exception $ e ) { if ( $ this -> io -> isDebug ( ) ) { $ this -> io -> writeError ( '' ) ; $ this -> io -> writeError ( 'Failed: [' . get_class ( $ e ) . '] ' . $ e -> getCode ( ) . ': ' . $ e -> getMessage ( ) ) ; } elseif ( count ( $ urls ) ) { $ this -> io -> writeError ( '' ) ; $ this -> io -> writeError ( ' Failed, trying the next URL (' . $ e -> getCode ( ) . ': ' . $ e -> getMessage ( ) . ')' , false ) ; } if ( ! count ( $ urls ) ) { throw $ e ; } } } if ( $ output ) { $ this -> io -> writeError ( '' ) ; } return $ fileName ; } 
public function update ( PackageInterface $ initial , PackageInterface $ target , $ path ) { $ name = $ target -> getName ( ) ; $ from = $ initial -> getFullPrettyVersion ( ) ; $ to = $ target -> getFullPrettyVersion ( ) ; $ actionName = VersionParser :: isUpgrade ( $ initial -> getVersion ( ) , $ target -> getVersion ( ) ) ? 'Updating' : 'Downgrading' ; $ this -> io -> writeError ( " - " . $ actionName . " <info>" . $ name . "</info> (<comment>" . $ from . "</comment> => <comment>" . $ to . "</comment>): " , false ) ; $ this -> remove ( $ initial , $ path , false ) ; $ this -> download ( $ target , $ path , false ) ; $ this -> io -> writeError ( '' ) ; } 
public function remove ( PackageInterface $ package , $ path , $ output = true ) { if ( $ output ) { $ this -> io -> writeError ( " - Removing <info>" . $ package -> getName ( ) . "</info> (<comment>" . $ package -> getFullPrettyVersion ( ) . "</comment>)" ) ; } if ( ! $ this -> filesystem -> removeDirectory ( $ path ) ) { throw new \ RuntimeException ( 'Could not completely delete ' . $ path . ', aborting.' ) ; } } 
protected function processUrl ( PackageInterface $ package , $ url ) { if ( ! extension_loaded ( 'openssl' ) && 0 === strpos ( $ url , 'https:' ) ) { throw new \ RuntimeException ( 'You must enable the openssl extension to download files via https' ) ; } if ( $ package -> getDistReference ( ) ) { $ url = UrlUtil :: updateDistReference ( $ this -> config , $ url , $ package -> getDistReference ( ) ) ; } return $ url ; } 
public function getLocalChanges ( PackageInterface $ package , $ targetDir ) { $ prevIO = $ this -> io ; $ prevProgress = $ this -> outputProgress ; $ this -> io = new NullIO ; $ this -> io -> loadConfiguration ( $ this -> config ) ; $ this -> outputProgress = false ; $ e = null ; try { $ this -> download ( $ package , $ targetDir . '_compare' , false ) ; $ comparer = new Comparer ( ) ; $ comparer -> setSource ( $ targetDir . '_compare' ) ; $ comparer -> setUpdate ( $ targetDir ) ; $ comparer -> doCompare ( ) ; $ output = $ comparer -> getChanged ( true , true ) ; $ this -> filesystem -> removeDirectory ( $ targetDir . '_compare' ) ; } catch ( \ Exception $ e ) { } $ this -> io = $ prevIO ; $ this -> outputProgress = $ prevProgress ; if ( $ e ) { throw $ e ; } return trim ( $ output ) ; } 
public function begin ( $ isolationLevel = null ) { if ( $ this -> db === null ) { throw new InvalidConfigException ( 'Transaction::db must be set.' ) ; } $ this -> db -> open ( ) ; if ( $ this -> _level === 0 ) { if ( $ isolationLevel !== null ) { $ this -> db -> getSchema ( ) -> setTransactionIsolationLevel ( $ isolationLevel ) ; } Yii :: debug ( 'Begin transaction' . ( $ isolationLevel ? ' with isolation level ' . $ isolationLevel : '' ) , __METHOD__ ) ; $ this -> db -> trigger ( Connection :: EVENT_BEGIN_TRANSACTION ) ; $ this -> db -> pdo -> beginTransaction ( ) ; $ this -> _level = 1 ; return ; } $ schema = $ this -> db -> getSchema ( ) ; if ( $ schema -> supportsSavepoint ( ) ) { Yii :: debug ( 'Set savepoint ' . $ this -> _level , __METHOD__ ) ; $ schema -> createSavepoint ( 'LEVEL' . $ this -> _level ) ; } else { Yii :: info ( 'Transaction not started: nested transaction not supported' , __METHOD__ ) ; throw new NotSupportedException ( 'Transaction not started: nested transaction not supported.' ) ; } $ this -> _level ++ ; } 
public static function createValidator ( $ type , $ model , $ attributes , $ params = [ ] ) { $ params [ 'attributes' ] = $ attributes ; if ( $ type instanceof \ Closure || ( $ model -> hasMethod ( $ type ) && ! isset ( static :: $ builtInValidators [ $ type ] ) ) ) { 
public function init ( ) { parent :: init ( ) ; $ this -> attributes = ( array ) $ this -> attributes ; $ this -> on = ( array ) $ this -> on ; $ this -> except = ( array ) $ this -> except ; } 
public function getValidationAttributes ( $ attributes = null ) { if ( $ attributes === null ) { return $ this -> getAttributeNames ( ) ; } if ( is_string ( $ attributes ) ) { $ attributes = [ $ attributes ] ; } $ newAttributes = [ ] ; $ attributeNames = $ this -> getAttributeNames ( ) ; foreach ( $ attributes as $ attribute ) { if ( in_array ( $ attribute , $ attributeNames , true ) ) { $ newAttributes [ ] = $ attribute ; } } return $ newAttributes ; } 
public function isActive ( $ scenario ) { return ! in_array ( $ scenario , $ this -> except , true ) && ( empty ( $ this -> on ) || in_array ( $ scenario , $ this -> on , true ) ) ; } 
public function addError ( $ model , $ attribute , $ message , $ params = [ ] ) { $ params [ 'attribute' ] = $ model -> getAttributeLabel ( $ attribute ) ; if ( ! isset ( $ params [ 'value' ] ) ) { $ value = $ model -> $ attribute ; if ( is_array ( $ value ) ) { $ params [ 'value' ] = 'array()' ; } elseif ( is_object ( $ value ) && ! method_exists ( $ value , '__toString' ) ) { $ params [ 'value' ] = '(object)' ; } else { $ params [ 'value' ] = $ value ; } } $ model -> addError ( $ attribute , $ this -> formatMessage ( $ message , $ params ) ) ; } 
public function isEmpty ( $ value ) { if ( $ this -> isEmpty !== null ) { return call_user_func ( $ this -> isEmpty , $ value ) ; } return $ value === null || $ value === [ ] || $ value === '' ; } 
protected function formatMessage ( $ message , $ params ) { if ( Yii :: $ app !== null ) { return \ Yii :: $ app -> getI18n ( ) -> format ( $ message , $ params , Yii :: $ app -> language ) ; } $ placeholders = [ ] ; foreach ( ( array ) $ params as $ name => $ value ) { $ placeholders [ '{' . $ name . '}' ] = $ value ; } return ( $ placeholders === [ ] ) ? $ message : strtr ( $ message , $ placeholders ) ; } 
public function createCommand ( $ db = null ) { if ( $ db === null ) { $ db = Yii :: $ app -> getDb ( ) ; } list ( $ sql , $ params ) = $ db -> getQueryBuilder ( ) -> build ( $ this ) ; $ command = $ db -> createCommand ( $ sql , $ params ) ; $ this -> setCommandCache ( $ command ) ; return $ command ; } 
public function batch ( $ batchSize = 100 , $ db = null ) { return Yii :: createObject ( [ 'class' => BatchQueryResult :: className ( ) , 'query' => $ this , 'batchSize' => $ batchSize , 'db' => $ db , 'each' => false , ] ) ; } 
public function each ( $ batchSize = 100 , $ db = null ) { return Yii :: createObject ( [ 'class' => BatchQueryResult :: className ( ) , 'query' => $ this , 'batchSize' => $ batchSize , 'db' => $ db , 'each' => true , ] ) ; } 
public function all ( $ db = null ) { if ( $ this -> emulateExecution ) { return [ ] ; } $ rows = $ this -> createCommand ( $ db ) -> queryAll ( ) ; return $ this -> populate ( $ rows ) ; } 
public function populate ( $ rows ) { if ( $ this -> indexBy === null ) { return $ rows ; } $ result = [ ] ; foreach ( $ rows as $ row ) { $ result [ ArrayHelper :: getValue ( $ row , $ this -> indexBy ) ] = $ row ; } return $ result ; } 
public function one ( $ db = null ) { if ( $ this -> emulateExecution ) { return false ; } return $ this -> createCommand ( $ db ) -> queryOne ( ) ; } 
public function scalar ( $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } return $ this -> createCommand ( $ db ) -> queryScalar ( ) ; } 
public function exists ( $ db = null ) { if ( $ this -> emulateExecution ) { return false ; } $ command = $ this -> createCommand ( $ db ) ; $ params = $ command -> params ; $ command -> setSql ( $ command -> db -> getQueryBuilder ( ) -> selectExists ( $ command -> getSql ( ) ) ) ; $ command -> bindValues ( $ params ) ; return ( bool ) $ command -> queryScalar ( ) ; } 
public function getTablesUsedInFrom ( ) { if ( empty ( $ this -> from ) ) { return [ ] ; } if ( is_array ( $ this -> from ) ) { $ tableNames = $ this -> from ; } elseif ( is_string ( $ this -> from ) ) { $ tableNames = preg_split ( '/\s*,\s*/' , trim ( $ this -> from ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } elseif ( $ this -> from instanceof Expression ) { $ tableNames = [ $ this -> from ] ; } else { throw new InvalidConfigException ( gettype ( $ this -> from ) . ' in $from is not supported.' ) ; } return $ this -> cleanUpTableNames ( $ tableNames ) ; } 
protected function cleanUpTableNames ( $ tableNames ) { $ cleanedUpTableNames = [ ] ; foreach ( $ tableNames as $ alias => $ tableName ) { if ( is_string ( $ tableName ) && ! is_string ( $ alias ) ) { $ pattern = <<<PATTERN ~ ^ \s* ( (?:['"`\[]|{{) .*? (?:['"`\]]|}}) | \(.*?\) | .*? ) (?: (?: \s+ (?:as)? \s* ) ( (?:['"`\[]|{{) .*? (?:['"`\]]|}}) | .*? ) )? \s* $ ~iux PATTERN ; if ( preg_match ( $ pattern , $ tableName , $ matches ) ) { if ( isset ( $ matches [ 2 ] ) ) { list ( , $ tableName , $ alias ) = $ matches ; } else { $ tableName = $ alias = $ matches [ 1 ] ; } } } if ( $ tableName instanceof Expression ) { if ( ! is_string ( $ alias ) ) { throw new InvalidArgumentException ( 'To use Expression in from() method, pass it in array format with alias.' ) ; } $ cleanedUpTableNames [ $ this -> ensureNameQuoted ( $ alias ) ] = $ tableName ; } elseif ( $ tableName instanceof self ) { $ cleanedUpTableNames [ $ this -> ensureNameQuoted ( $ alias ) ] = $ tableName ; } else { $ cleanedUpTableNames [ $ this -> ensureNameQuoted ( $ alias ) ] = $ this -> ensureNameQuoted ( $ tableName ) ; } } return $ cleanedUpTableNames ; } 
private function ensureNameQuoted ( $ name ) { $ name = str_replace ( [ "'" , '"' , '`' , '[' , ']' ] , '' , $ name ) ; if ( $ name && ! preg_match ( '/^{{.*}}$/' , $ name ) ) { return '{{' . $ name . '}}' ; } return $ name ; } 
public function select ( $ columns , $ option = null ) { if ( $ columns instanceof ExpressionInterface ) { $ columns = [ $ columns ] ; } elseif ( ! is_array ( $ columns ) ) { $ columns = preg_split ( '/\s*,\s*/' , trim ( $ columns ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } 
public function addSelect ( $ columns ) { if ( $ columns instanceof ExpressionInterface ) { $ columns = [ $ columns ] ; } elseif ( ! is_array ( $ columns ) ) { $ columns = preg_split ( '/\s*,\s*/' , trim ( $ columns ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } $ columns = $ this -> getUniqueColumns ( $ columns ) ; if ( $ this -> select === null ) { $ this -> select = $ columns ; } else { $ this -> select = array_merge ( $ this -> select , $ columns ) ; } return $ this ; } 
protected function getUniqueColumns ( $ columns ) { $ unaliasedColumns = $ this -> getUnaliasedColumnsFromSelect ( ) ; $ result = [ ] ; foreach ( $ columns as $ columnAlias => $ columnDefinition ) { if ( ! $ columnDefinition instanceof Query ) { if ( is_string ( $ columnAlias ) ) { $ existsInSelect = isset ( $ this -> select [ $ columnAlias ] ) && $ this -> select [ $ columnAlias ] === $ columnDefinition ; if ( $ existsInSelect ) { continue ; } } elseif ( is_int ( $ columnAlias ) ) { $ existsInSelect = in_array ( $ columnDefinition , $ unaliasedColumns , true ) ; $ existsInResultSet = in_array ( $ columnDefinition , $ result , true ) ; if ( $ existsInSelect || $ existsInResultSet ) { continue ; } } } $ result [ $ columnAlias ] = $ columnDefinition ; } return $ result ; } 
public function from ( $ tables ) { if ( $ tables instanceof ExpressionInterface ) { $ tables = [ $ tables ] ; } if ( is_string ( $ tables ) ) { $ tables = preg_split ( '/\s*,\s*/' , trim ( $ tables ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } $ this -> from = $ tables ; return $ this ; } 
public function where ( $ condition , $ params = [ ] ) { $ this -> where = $ condition ; $ this -> addParams ( $ params ) ; return $ this ; } 
public function andWhere ( $ condition , $ params = [ ] ) { if ( $ this -> where === null ) { $ this -> where = $ condition ; } elseif ( is_array ( $ this -> where ) && isset ( $ this -> where [ 0 ] ) && strcasecmp ( $ this -> where [ 0 ] , 'and' ) === 0 ) { $ this -> where [ ] = $ condition ; } else { $ this -> where = [ 'and' , $ this -> where , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; } 
public function orWhere ( $ condition , $ params = [ ] ) { if ( $ this -> where === null ) { $ this -> where = $ condition ; } else { $ this -> where = [ 'or' , $ this -> where , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; } 
public function andFilterCompare ( $ name , $ value , $ defaultOperator = '=' ) { if ( preg_match ( '/^(<>|>=|>|<=|<|=)/' , $ value , $ matches ) ) { $ operator = $ matches [ 1 ] ; $ value = substr ( $ value , strlen ( $ operator ) ) ; } else { $ operator = $ defaultOperator ; } return $ this -> andFilterWhere ( [ $ operator , $ name , $ value ] ) ; } 
public function join ( $ type , $ table , $ on = '' , $ params = [ ] ) { $ this -> join [ ] = [ $ type , $ table , $ on ] ; return $ this -> addParams ( $ params ) ; } 
public function innerJoin ( $ table , $ on = '' , $ params = [ ] ) { $ this -> join [ ] = [ 'INNER JOIN' , $ table , $ on ] ; return $ this -> addParams ( $ params ) ; } 
public function leftJoin ( $ table , $ on = '' , $ params = [ ] ) { $ this -> join [ ] = [ 'LEFT JOIN' , $ table , $ on ] ; return $ this -> addParams ( $ params ) ; } 
public function rightJoin ( $ table , $ on = '' , $ params = [ ] ) { $ this -> join [ ] = [ 'RIGHT JOIN' , $ table , $ on ] ; return $ this -> addParams ( $ params ) ; } 
public function groupBy ( $ columns ) { if ( $ columns instanceof ExpressionInterface ) { $ columns = [ $ columns ] ; } elseif ( ! is_array ( $ columns ) ) { $ columns = preg_split ( '/\s*,\s*/' , trim ( $ columns ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } $ this -> groupBy = $ columns ; return $ this ; } 
public function addGroupBy ( $ columns ) { if ( $ columns instanceof ExpressionInterface ) { $ columns = [ $ columns ] ; } elseif ( ! is_array ( $ columns ) ) { $ columns = preg_split ( '/\s*,\s*/' , trim ( $ columns ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } if ( $ this -> groupBy === null ) { $ this -> groupBy = $ columns ; } else { $ this -> groupBy = array_merge ( $ this -> groupBy , $ columns ) ; } return $ this ; } 
public function having ( $ condition , $ params = [ ] ) { $ this -> having = $ condition ; $ this -> addParams ( $ params ) ; return $ this ; } 
public function andHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'and' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; } 
public function orHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'or' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; } 
public function filterHaving ( array $ condition ) { $ condition = $ this -> filterCondition ( $ condition ) ; if ( $ condition !== [ ] ) { $ this -> having ( $ condition ) ; } return $ this ; } 
public function andFilterHaving ( array $ condition ) { $ condition = $ this -> filterCondition ( $ condition ) ; if ( $ condition !== [ ] ) { $ this -> andHaving ( $ condition ) ; } return $ this ; } 
public function orFilterHaving ( array $ condition ) { $ condition = $ this -> filterCondition ( $ condition ) ; if ( $ condition !== [ ] ) { $ this -> orHaving ( $ condition ) ; } return $ this ; } 
public function addParams ( $ params ) { if ( ! empty ( $ params ) ) { if ( empty ( $ this -> params ) ) { $ this -> params = $ params ; } else { foreach ( $ params as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> params [ ] = $ value ; } else { $ this -> params [ $ name ] = $ value ; } } } } return $ this ; } 
public function cache ( $ duration = true , $ dependency = null ) { $ this -> queryCacheDuration = $ duration ; $ this -> queryCacheDependency = $ dependency ; return $ this ; } 
protected function setCommandCache ( $ command ) { if ( $ this -> queryCacheDuration !== null || $ this -> queryCacheDependency !== null ) { $ duration = $ this -> queryCacheDuration === true ? null : $ this -> queryCacheDuration ; $ command -> cache ( $ duration , $ this -> queryCacheDependency ) ; } return $ command ; } 
public static function create ( $ from ) { return new self ( [ 'where' => $ from -> where , 'limit' => $ from -> limit , 'offset' => $ from -> offset , 'orderBy' => $ from -> orderBy , 'indexBy' => $ from -> indexBy , 'select' => $ from -> select , 'selectOption' => $ from -> selectOption , 'distinct' => $ from -> distinct , 'from' => $ from -> from , 'groupBy' => $ from -> groupBy , 'join' => $ from -> join , 'having' => $ from -> having , 'union' => $ from -> union , 'params' => $ from -> params , ] ) ; } 
public static function serialize ( array $ links ) { foreach ( $ links as $ rel => $ link ) { if ( is_array ( $ link ) ) { foreach ( $ link as $ i => $ l ) { $ link [ $ i ] = $ l instanceof self ? array_filter ( ( array ) $ l ) : [ 'href' => $ l ] ; } $ links [ $ rel ] = $ link ; } elseif ( ! $ link instanceof self ) { $ links [ $ rel ] = [ 'href' => $ link ] ; } } return $ links ; } 
protected function getMessageFilePath ( $ language ) { $ messageFile = Yii :: getAlias ( $ this -> basePath ) . '/' . $ language . '/' . $ this -> catalog ; if ( $ this -> useMoFile ) { $ messageFile .= self :: MO_FILE_EXT ; } else { $ messageFile .= self :: PO_FILE_EXT ; } return $ messageFile ; } 
protected function loadMessagesFromFile ( $ messageFile , $ category ) { if ( is_file ( $ messageFile ) ) { if ( $ this -> useMoFile ) { $ gettextFile = new GettextMoFile ( [ 'useBigEndian' => $ this -> useBigEndian ] ) ; } else { $ gettextFile = new GettextPoFile ( ) ; } $ messages = $ gettextFile -> load ( $ messageFile , $ category ) ; if ( ! is_array ( $ messages ) ) { $ messages = [ ] ; } return $ messages ; } return null ; } 
protected static function loadMimeTypes ( $ magicFile ) { if ( $ magicFile === null ) { $ magicFile = static :: $ mimeMagicFile ; } $ magicFile = Yii :: getAlias ( $ magicFile ) ; if ( ! isset ( self :: $ _mimeTypes [ $ magicFile ] ) ) { self :: $ _mimeTypes [ $ magicFile ] = require $ magicFile ; } return self :: $ _mimeTypes [ $ magicFile ] ; } 
protected static function loadMimeAliases ( $ aliasesFile ) { if ( $ aliasesFile === null ) { $ aliasesFile = static :: $ mimeAliasesFile ; } $ aliasesFile = Yii :: getAlias ( $ aliasesFile ) ; if ( ! isset ( self :: $ _mimeAliases [ $ aliasesFile ] ) ) { self :: $ _mimeAliases [ $ aliasesFile ] = require $ aliasesFile ; } return self :: $ _mimeAliases [ $ aliasesFile ] ; } 
public static function copyDirectory ( $ src , $ dst , $ options = [ ] ) { $ src = static :: normalizePath ( $ src ) ; $ dst = static :: normalizePath ( $ dst ) ; if ( $ src === $ dst || strpos ( $ dst , $ src . DIRECTORY_SEPARATOR ) === 0 ) { throw new InvalidArgumentException ( 'Trying to copy a directory to itself or a subdirectory.' ) ; } $ dstExists = is_dir ( $ dst ) ; if ( ! $ dstExists && ( ! isset ( $ options [ 'copyEmptyDirectories' ] ) || $ options [ 'copyEmptyDirectories' ] ) ) { static :: createDirectory ( $ dst , isset ( $ options [ 'dirMode' ] ) ? $ options [ 'dirMode' ] : 0775 , true ) ; $ dstExists = true ; } $ handle = opendir ( $ src ) ; if ( $ handle === false ) { throw new InvalidArgumentException ( "Unable to open directory: $src" ) ; } if ( ! isset ( $ options [ 'basePath' ] ) ) { 
public static function removeDirectory ( $ dir , $ options = [ ] ) { if ( ! is_dir ( $ dir ) ) { return ; } if ( ! empty ( $ options [ 'traverseSymlinks' ] ) || ! is_link ( $ dir ) ) { if ( ! ( $ handle = opendir ( $ dir ) ) ) { return ; } while ( ( $ file = readdir ( $ handle ) ) !== false ) { if ( $ file === '.' || $ file === '..' ) { continue ; } $ path = $ dir . DIRECTORY_SEPARATOR . $ file ; if ( is_dir ( $ path ) ) { static :: removeDirectory ( $ path , $ options ) ; } else { static :: unlink ( $ path ) ; } } closedir ( $ handle ) ; } if ( is_link ( $ dir ) ) { static :: unlink ( $ dir ) ; } else { rmdir ( $ dir ) ; } } 
public static function unlink ( $ path ) { $ isWindows = DIRECTORY_SEPARATOR === '\\' ; if ( ! $ isWindows ) { return unlink ( $ path ) ; } if ( is_link ( $ path ) && is_dir ( $ path ) ) { return rmdir ( $ path ) ; } try { return unlink ( $ path ) ; } catch ( ErrorException $ e ) { 
public static function findFiles ( $ dir , $ options = [ ] ) { $ dir = self :: clearDir ( $ dir ) ; $ options = self :: setBasePath ( $ dir , $ options ) ; $ list = [ ] ; $ handle = self :: openDir ( $ dir ) ; while ( ( $ file = readdir ( $ handle ) ) !== false ) { if ( $ file === '.' || $ file === '..' ) { continue ; } $ path = $ dir . DIRECTORY_SEPARATOR . $ file ; if ( static :: filterPath ( $ path , $ options ) ) { if ( is_file ( $ path ) ) { $ list [ ] = $ path ; } elseif ( is_dir ( $ path ) && ( ! isset ( $ options [ 'recursive' ] ) || $ options [ 'recursive' ] ) ) { $ list = array_merge ( $ list , static :: findFiles ( $ path , $ options ) ) ; } } } closedir ( $ handle ) ; return $ list ; } 
public static function filterPath ( $ path , $ options ) { if ( isset ( $ options [ 'filter' ] ) ) { $ result = call_user_func ( $ options [ 'filter' ] , $ path ) ; if ( is_bool ( $ result ) ) { return $ result ; } } if ( empty ( $ options [ 'except' ] ) && empty ( $ options [ 'only' ] ) ) { return true ; } $ path = str_replace ( '\\' , '/' , $ path ) ; if ( ! empty ( $ options [ 'except' ] ) ) { if ( ( $ except = self :: lastExcludeMatchingFromList ( $ options [ 'basePath' ] , $ path , $ options [ 'except' ] ) ) !== null ) { return $ except [ 'flags' ] & self :: PATTERN_NEGATIVE ; } } if ( ! empty ( $ options [ 'only' ] ) && ! is_dir ( $ path ) ) { if ( ( $ except = self :: lastExcludeMatchingFromList ( $ options [ 'basePath' ] , $ path , $ options [ 'only' ] ) ) !== null ) { 
public static function createDirectory ( $ path , $ mode = 0775 , $ recursive = true ) { if ( is_dir ( $ path ) ) { return true ; } $ parentDir = dirname ( $ path ) ; 
private static function matchPathname ( $ path , $ basePath , $ pattern , $ firstWildcard , $ flags ) { 
private static function firstWildcardInPattern ( $ pattern ) { $ wildcards = [ '*' , '?' , '[' , '\\' ] ; $ wildcardSearch = function ( $ r , $ c ) use ( $ pattern ) { $ p = strpos ( $ pattern , $ c ) ; return $ r === false ? $ p : ( $ p === false ? $ r : min ( $ r , $ p ) ) ; } ; return array_reduce ( $ wildcards , $ wildcardSearch , false ) ; } 
public function beforeAction ( $ action ) { $ response = $ this -> response ? : Yii :: $ app -> getResponse ( ) ; try { $ identity = $ this -> authenticate ( $ this -> user ? : Yii :: $ app -> getUser ( ) , $ this -> request ? : Yii :: $ app -> getRequest ( ) , $ response ) ; } catch ( UnauthorizedHttpException $ e ) { if ( $ this -> isOptional ( $ action ) ) { return true ; } throw $ e ; } if ( $ identity !== null || $ this -> isOptional ( $ action ) ) { return true ; } $ this -> challenge ( $ response ) ; $ this -> handleFailure ( $ response ) ; return false ; } 
protected function isOptional ( $ action ) { $ id = $ this -> getActionId ( $ action ) ; foreach ( $ this -> optional as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { return true ; } } return false ; } 
public static function remove ( & $ array , $ key , $ default = null ) { if ( is_array ( $ array ) && ( isset ( $ array [ $ key ] ) || array_key_exists ( $ key , $ array ) ) ) { $ value = $ array [ $ key ] ; unset ( $ array [ $ key ] ) ; return $ value ; } return $ default ; } 
public static function removeValue ( & $ array , $ value ) { $ result = [ ] ; if ( is_array ( $ array ) ) { foreach ( $ array as $ key => $ val ) { if ( $ val === $ value ) { $ result [ $ key ] = $ val ; unset ( $ array [ $ key ] ) ; } } } return $ result ; } 
public static function index ( $ array , $ key , $ groups = [ ] ) { $ result = [ ] ; $ groups = ( array ) $ groups ; foreach ( $ array as $ element ) { $ lastArray = & $ result ; foreach ( $ groups as $ group ) { $ value = static :: getValue ( $ element , $ group ) ; if ( ! array_key_exists ( $ value , $ lastArray ) ) { $ lastArray [ $ value ] = [ ] ; } $ lastArray = & $ lastArray [ $ value ] ; } if ( $ key === null ) { if ( ! empty ( $ groups ) ) { $ lastArray [ ] = $ element ; } } else { $ value = static :: getValue ( $ element , $ key ) ; if ( $ value !== null ) { if ( is_float ( $ value ) ) { $ value = StringHelper :: floatToString ( $ value ) ; } $ lastArray [ $ value ] = $ element ; } } unset ( $ lastArray ) ; } return $ result ; } 
public static function multisort ( & $ array , $ key , $ direction = SORT_ASC , $ sortFlag = SORT_REGULAR ) { $ keys = is_array ( $ key ) ? $ key : [ $ key ] ; if ( empty ( $ keys ) || empty ( $ array ) ) { return ; } $ n = count ( $ keys ) ; if ( is_scalar ( $ direction ) ) { $ direction = array_fill ( 0 , $ n , $ direction ) ; } elseif ( count ( $ direction ) !== $ n ) { throw new InvalidArgumentException ( 'The length of $direction parameter must be the same as that of $keys.' ) ; } if ( is_scalar ( $ sortFlag ) ) { $ sortFlag = array_fill ( 0 , $ n , $ sortFlag ) ; } elseif ( count ( $ sortFlag ) !== $ n ) { throw new InvalidArgumentException ( 'The length of $sortFlag parameter must be the same as that of $keys.' ) ; } $ args = [ ] ; foreach ( $ keys as $ i => $ key ) { $ flag = $ sortFlag [ $ i ] ; $ args [ ] = static :: getColumn ( $ array , $ key ) ; $ args [ ] = $ direction [ $ i ] ; $ args [ ] = $ flag ; } 
public static function htmlDecode ( $ data , $ valuesOnly = true ) { $ d = [ ] ; foreach ( $ data as $ key => $ value ) { if ( ! $ valuesOnly && is_string ( $ key ) ) { $ key = htmlspecialchars_decode ( $ key , ENT_QUOTES ) ; } if ( is_string ( $ value ) ) { $ d [ $ key ] = htmlspecialchars_decode ( $ value , ENT_QUOTES ) ; } elseif ( is_array ( $ value ) ) { $ d [ $ key ] = static :: htmlDecode ( $ value ) ; } else { $ d [ $ key ] = $ value ; } } return $ d ; } 
public static function filter ( $ array , $ filters ) { $ result = [ ] ; $ forbiddenVars = [ ] ; foreach ( $ filters as $ var ) { $ keys = explode ( '.' , $ var ) ; $ globalKey = $ keys [ 0 ] ; $ localKey = isset ( $ keys [ 1 ] ) ? $ keys [ 1 ] : null ; if ( $ globalKey [ 0 ] === '!' ) { $ forbiddenVars [ ] = [ substr ( $ globalKey , 1 ) , $ localKey , ] ; continue ; } if ( ! array_key_exists ( $ globalKey , $ array ) ) { continue ; } if ( $ localKey === null ) { $ result [ $ globalKey ] = $ array [ $ globalKey ] ; continue ; } if ( ! isset ( $ array [ $ globalKey ] [ $ localKey ] ) ) { continue ; } if ( ! array_key_exists ( $ globalKey , $ result ) ) { $ result [ $ globalKey ] = [ ] ; } $ result [ $ globalKey ] [ $ localKey ] = $ array [ $ globalKey ] [ $ localKey ] ; } foreach ( $ forbiddenVars as $ var ) { list ( $ globalKey , $ localKey ) = $ var ; if ( array_key_exists ( $ globalKey , $ result ) ) { unset ( $ result [ $ globalKey ] [ $ localKey ] ) ; } } return $ result ; } 
public function build ( ExpressionInterface $ expression , array & $ params = [ ] ) { $ operand = $ expression -> getCondition ( ) ; if ( $ operand === '' ) { return '' ; } $ expession = $ this -> queryBuilder -> buildCondition ( $ operand , $ params ) ; return "{$this->getNegationOperator()} ($expession)" ; } 
public function init ( ) { parent :: init ( ) ; $ this -> basePath = Yii :: getAlias ( $ this -> basePath ) ; if ( ! is_dir ( $ this -> basePath ) ) { throw new InvalidConfigException ( "The directory does not exist: {$this->basePath}" ) ; } $ this -> basePath = realpath ( $ this -> basePath ) ; $ this -> baseUrl = rtrim ( Yii :: getAlias ( $ this -> baseUrl ) , '/' ) ; } 
protected function loadBundle ( $ name , $ config = [ ] , $ publish = true ) { if ( ! isset ( $ config [ 'class' ] ) ) { $ config [ 'class' ] = $ name ; } $ bundle = Yii :: createObject ( $ config ) ; if ( $ publish ) { $ bundle -> publish ( $ this ) ; } return $ bundle ; } 
protected function loadDummyBundle ( $ name ) { if ( ! isset ( $ this -> _dummyBundles [ $ name ] ) ) { $ this -> _dummyBundles [ $ name ] = $ this -> loadBundle ( $ name , [ 'sourcePath' => null , 'js' => [ ] , 'css' => [ ] , 'depends' => [ ] , ] ) ; } return $ this -> _dummyBundles [ $ name ] ; } 
public function getConverter ( ) { if ( $ this -> _converter === null ) { $ this -> _converter = Yii :: createObject ( AssetConverter :: className ( ) ) ; } elseif ( is_array ( $ this -> _converter ) || is_string ( $ this -> _converter ) ) { if ( is_array ( $ this -> _converter ) && ! isset ( $ this -> _converter [ 'class' ] ) ) { $ this -> _converter [ 'class' ] = AssetConverter :: className ( ) ; } $ this -> _converter = Yii :: createObject ( $ this -> _converter ) ; } return $ this -> _converter ; } 
public function publish ( $ path , $ options = [ ] ) { $ path = Yii :: getAlias ( $ path ) ; if ( isset ( $ this -> _published [ $ path ] ) ) { return $ this -> _published [ $ path ] ; } if ( ! is_string ( $ path ) || ( $ src = realpath ( $ path ) ) === false ) { throw new InvalidArgumentException ( "The file or directory to be published does not exist: $path" ) ; } if ( ! is_writable ( $ this -> basePath ) ) { throw new InvalidConfigException ( "The directory is not writable by the Web process: {$this->basePath}" ) ; } if ( is_file ( $ src ) ) { return $ this -> _published [ $ path ] = $ this -> publishFile ( $ src ) ; } return $ this -> _published [ $ path ] = $ this -> publishDirectory ( $ src , $ options ) ; } 
protected function publishFile ( $ src ) { $ dir = $ this -> hash ( $ src ) ; $ fileName = basename ( $ src ) ; $ dstDir = $ this -> basePath . DIRECTORY_SEPARATOR . $ dir ; $ dstFile = $ dstDir . DIRECTORY_SEPARATOR . $ fileName ; if ( ! is_dir ( $ dstDir ) ) { FileHelper :: createDirectory ( $ dstDir , $ this -> dirMode , true ) ; } if ( $ this -> linkAssets ) { if ( ! is_file ( $ dstFile ) ) { try { 
public function getPublishedUrl ( $ path ) { $ path = Yii :: getAlias ( $ path ) ; if ( isset ( $ this -> _published [ $ path ] ) ) { return $ this -> _published [ $ path ] [ 1 ] ; } if ( is_string ( $ path ) && ( $ path = realpath ( $ path ) ) !== false ) { return $ this -> baseUrl . '/' . $ this -> hash ( $ path ) . ( is_file ( $ path ) ? '/' . basename ( $ path ) : '' ) ; } return false ; } 
public function init ( ) { parent :: init ( ) ; $ this -> cache = $ this -> enabled ? Instance :: ensure ( $ this -> cache , 'yii\caching\CacheInterface' ) : null ; if ( $ this -> cache instanceof CacheInterface && $ this -> getCachedContent ( ) === false ) { $ this -> getView ( ) -> pushDynamicContent ( $ this ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; } } 
protected function renderInputHtml ( $ type ) { if ( $ this -> hasModel ( ) ) { return Html :: activeInput ( $ type , $ this -> model , $ this -> attribute , $ this -> options ) ; } return Html :: input ( $ type , $ this -> name , $ this -> value , $ this -> options ) ; } 
protected function renderStrike ( $ element ) { return Console :: ansiFormat ( $ this -> parseInline ( $ this -> renderAbsy ( $ element [ 1 ] ) ) , [ Console :: CROSSED_OUT ] ) ; } 
protected function fetchData ( ) { if ( $ this -> _dataReader === null ) { $ this -> _dataReader = $ this -> query -> createCommand ( $ this -> db ) -> query ( ) ; } $ rows = [ ] ; $ count = 0 ; while ( $ count ++ < $ this -> batchSize && ( $ row = $ this -> _dataReader -> read ( ) ) ) { $ rows [ ] = $ row ; } return $ this -> query -> populate ( $ rows ) ; } 
public function dropIndex ( $ name , $ table ) { $ schema = $ this -> db -> getSchema ( ) ; foreach ( $ schema -> getTableUniques ( $ table ) as $ unique ) { if ( $ unique -> name === $ name ) { return $ this -> dropUnique ( $ name , $ table ) ; } } return 'DROP INDEX ' . $ this -> db -> quoteTableName ( $ name ) . ' ON ' . $ this -> db -> quoteTableName ( $ table ) ; } 
private function getColumnDefinition ( $ table , $ column ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> db -> quoteTableName ( $ table ) ) -> queryOne ( ) ; if ( $ row === false ) { throw new Exception ( "Unable to find column '$column' in table '$table'." ) ; } if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } $ sql = preg_replace ( '/^[^(]+\((.*)\).*$/' , '\1' , $ sql ) ; $ sql = str_replace ( ', [' , ",\n[" , $ sql ) ; if ( preg_match_all ( '/^\s*\[(.*?)\]\s+(.*?),?$/m' , $ sql , $ matches ) ) { foreach ( $ matches [ 1 ] as $ i => $ c ) { if ( $ c === $ column ) { return $ matches [ 2 ] [ $ i ] ; } } } return null ; } 
protected function loadTableSchema ( $ name ) { $ table = new TableSchema ( ) ; $ table -> name = $ name ; $ table -> fullName = $ name ; if ( $ this -> findColumns ( $ table ) ) { $ this -> findConstraints ( $ table ) ; return $ table ; } return null ; } 
protected function loadTableForeignKeys ( $ tableName ) { $ foreignKeys = $ this -> db -> createCommand ( 'PRAGMA FOREIGN_KEY_LIST (' . $ this -> quoteValue ( $ tableName ) . ')' ) -> queryAll ( ) ; $ foreignKeys = $ this -> normalizePdoRowKeyCase ( $ foreignKeys , true ) ; $ foreignKeys = ArrayHelper :: index ( $ foreignKeys , null , 'table' ) ; ArrayHelper :: multisort ( $ foreignKeys , 'seq' , SORT_ASC , SORT_NUMERIC ) ; $ result = [ ] ; foreach ( $ foreignKeys as $ table => $ foreignKey ) { $ result [ ] = new ForeignKeyConstraint ( [ 'columnNames' => ArrayHelper :: getColumn ( $ foreignKey , 'from' ) , 'foreignTableName' => $ table , 'foreignColumnNames' => ArrayHelper :: getColumn ( $ foreignKey , 'to' ) , 'onDelete' => isset ( $ foreignKey [ 0 ] [ 'on_delete' ] ) ? $ foreignKey [ 0 ] [ 'on_delete' ] : null , 'onUpdate' => isset ( $ foreignKey [ 0 ] [ 'on_update' ] ) ? $ foreignKey [ 0 ] [ 'on_update' ] : null , ] ) ; } return $ result ; } 
protected function loadTableChecks ( $ tableName ) { $ sql = $ this -> db -> createCommand ( 'SELECT `sql` FROM `sqlite_master` WHERE name = :tableName' , [ ':tableName' => $ tableName , ] ) -> queryScalar ( ) ; $ code = ( new SqlTokenizer ( $ sql ) ) -> tokenize ( ) ; $ pattern = ( new SqlTokenizer ( 'any CREATE any TABLE any()' ) ) -> tokenize ( ) ; if ( ! $ code [ 0 ] -> matches ( $ pattern , 0 , $ firstMatchIndex , $ lastMatchIndex ) ) { return [ ] ; } $ createTableToken = $ code [ 0 ] [ $ lastMatchIndex - 1 ] ; $ result = [ ] ; $ offset = 0 ; while ( true ) { $ pattern = ( new SqlTokenizer ( 'any CHECK()' ) ) -> tokenize ( ) ; if ( ! $ createTableToken -> matches ( $ pattern , $ offset , $ firstMatchIndex , $ offset ) ) { break ; } $ checkSql = $ createTableToken [ $ offset - 1 ] -> getSql ( ) ; $ name = null ; $ pattern = ( new SqlTokenizer ( 'CONSTRAINT any' ) ) -> tokenize ( ) ; if ( isset ( $ createTableToken [ $ firstMatchIndex - 2 ] ) && $ createTableToken -> matches ( $ pattern , $ firstMatchIndex - 2 ) ) { $ name = $ createTableToken [ $ firstMatchIndex - 1 ] -> content ; } $ result [ ] = new CheckConstraint ( [ 'name' => $ name , 'expression' => $ checkSql , ] ) ; } return $ result ; } 
protected function findColumns ( $ table ) { $ sql = 'PRAGMA table_info(' . $ this -> quoteSimpleTableName ( $ table -> name ) . ')' ; $ columns = $ this -> db -> createCommand ( $ sql ) -> queryAll ( ) ; if ( empty ( $ columns ) ) { return false ; } foreach ( $ columns as $ info ) { $ column = $ this -> loadColumnSchema ( $ info ) ; $ table -> columns [ $ column -> name ] = $ column ; if ( $ column -> isPrimaryKey ) { $ table -> primaryKey [ ] = $ column -> name ; } } if ( count ( $ table -> primaryKey ) === 1 && ! strncasecmp ( $ table -> columns [ $ table -> primaryKey [ 0 ] ] -> dbType , 'int' , 3 ) ) { $ table -> sequenceName = '' ; $ table -> columns [ $ table -> primaryKey [ 0 ] ] -> autoIncrement = true ; } return true ; } 
protected function findConstraints ( $ table ) { $ sql = 'PRAGMA foreign_key_list(' . $ this -> quoteSimpleTableName ( $ table -> name ) . ')' ; $ keys = $ this -> db -> createCommand ( $ sql ) -> queryAll ( ) ; foreach ( $ keys as $ key ) { $ id = ( int ) $ key [ 'id' ] ; if ( ! isset ( $ table -> foreignKeys [ $ id ] ) ) { $ table -> foreignKeys [ $ id ] = [ $ key [ 'table' ] , $ key [ 'from' ] => $ key [ 'to' ] ] ; } else { 
public function findUniqueIndexes ( $ table ) { $ sql = 'PRAGMA index_list(' . $ this -> quoteSimpleTableName ( $ table -> name ) . ')' ; $ indexes = $ this -> db -> createCommand ( $ sql ) -> queryAll ( ) ; $ uniqueIndexes = [ ] ; foreach ( $ indexes as $ index ) { $ indexName = $ index [ 'name' ] ; $ indexInfo = $ this -> db -> createCommand ( 'PRAGMA index_info(' . $ this -> quoteValue ( $ index [ 'name' ] ) . ')' ) -> queryAll ( ) ; if ( $ index [ 'unique' ] ) { $ uniqueIndexes [ $ indexName ] = [ ] ; foreach ( $ indexInfo as $ row ) { $ uniqueIndexes [ $ indexName ] [ ] = $ row [ 'name' ] ; } } } return $ uniqueIndexes ; } 
protected function loadColumnSchema ( $ info ) { $ column = $ this -> createColumnSchema ( ) ; $ column -> name = $ info [ 'name' ] ; $ column -> allowNull = ! $ info [ 'notnull' ] ; $ column -> isPrimaryKey = $ info [ 'pk' ] != 0 ; $ column -> dbType = strtolower ( $ info [ 'type' ] ) ; $ column -> unsigned = strpos ( $ column -> dbType , 'unsigned' ) !== false ; $ column -> type = self :: TYPE_STRING ; if ( preg_match ( '/^(\w+)(?:\(([^\)]+)\))?/' , $ column -> dbType , $ matches ) ) { $ type = strtolower ( $ matches [ 1 ] ) ; if ( isset ( $ this -> typeMap [ $ type ] ) ) { $ column -> type = $ this -> typeMap [ $ type ] ; } if ( ! empty ( $ matches [ 2 ] ) ) { $ values = explode ( ',' , $ matches [ 2 ] ) ; $ column -> size = $ column -> precision = ( int ) $ values [ 0 ] ; if ( isset ( $ values [ 1 ] ) ) { $ column -> scale = ( int ) $ values [ 1 ] ; } if ( $ column -> size === 1 && ( $ type === 'tinyint' || $ type === 'bit' ) ) { $ column -> type = 'boolean' ; } elseif ( $ type === 'bit' ) { if ( $ column -> size > 32 ) { $ column -> type = 'bigint' ; } elseif ( $ column -> size === 32 ) { $ column -> type = 'integer' ; } } } } $ column -> phpType = $ this -> getColumnPhpType ( $ column ) ; if ( ! $ column -> isPrimaryKey ) { if ( $ info [ 'dflt_value' ] === 'null' || $ info [ 'dflt_value' ] === '' || $ info [ 'dflt_value' ] === null ) { $ column -> defaultValue = null ; } elseif ( $ column -> type === 'timestamp' && $ info [ 'dflt_value' ] === 'CURRENT_TIMESTAMP' ) { $ column -> defaultValue = new Expression ( 'CURRENT_TIMESTAMP' ) ; } else { $ value = trim ( $ info [ 'dflt_value' ] , "'\"" ) ; $ column -> defaultValue = $ column -> phpTypecast ( $ value ) ; } } return $ column ; } 
public function setTransactionIsolationLevel ( $ level ) { switch ( $ level ) { case Transaction :: SERIALIZABLE : $ this -> db -> createCommand ( 'PRAGMA read_uncommitted = False;' ) -> execute ( ) ; break ; case Transaction :: READ_UNCOMMITTED : $ this -> db -> createCommand ( 'PRAGMA read_uncommitted = True;' ) -> execute ( ) ; break ; default : throw new NotSupportedException ( get_class ( $ this ) . ' only supports transaction isolation levels READ UNCOMMITTED and SERIALIZABLE.' ) ; } } 
private function loadTableColumnsInfo ( $ tableName ) { $ tableColumns = $ this -> db -> createCommand ( 'PRAGMA TABLE_INFO (' . $ this -> quoteValue ( $ tableName ) . ')' ) -> queryAll ( ) ; $ tableColumns = $ this -> normalizePdoRowKeyCase ( $ tableColumns , true ) ; return ArrayHelper :: index ( $ tableColumns , 'cid' ) ; } 
private function loadTableConstraints ( $ tableName , $ returnType ) { $ indexes = $ this -> db -> createCommand ( 'PRAGMA INDEX_LIST (' . $ this -> quoteValue ( $ tableName ) . ')' ) -> queryAll ( ) ; $ indexes = $ this -> normalizePdoRowKeyCase ( $ indexes , true ) ; $ tableColumns = null ; if ( ! empty ( $ indexes ) && ! isset ( $ indexes [ 0 ] [ 'origin' ] ) ) { $ tableColumns = $ this -> loadTableColumnsInfo ( $ tableName ) ; } $ result = [ 'primaryKey' => null , 'indexes' => [ ] , 'uniques' => [ ] , ] ; foreach ( $ indexes as $ index ) { $ columns = $ this -> db -> createCommand ( 'PRAGMA INDEX_INFO (' . $ this -> quoteValue ( $ index [ 'name' ] ) . ')' ) -> queryAll ( ) ; $ columns = $ this -> normalizePdoRowKeyCase ( $ columns , true ) ; ArrayHelper :: multisort ( $ columns , 'seqno' , SORT_ASC , SORT_NUMERIC ) ; if ( $ tableColumns !== null ) { * Additional check for PK in case of INTEGER PRIMARY KEY with ROWID * See https: */ if ( $ tableColumns === null ) { $ tableColumns = $ this -> loadTableColumnsInfo ( $ tableName ) ; } foreach ( $ tableColumns as $ tableColumn ) { if ( $ tableColumn [ 'pk' ] > 0 ) { $ result [ 'primaryKey' ] = new Constraint ( [ 'columnNames' => [ $ tableColumn [ 'name' ] ] , ] ) ; break ; } } } foreach ( $ result as $ type => $ data ) { $ this -> setTableMetadata ( $ tableName , $ type , $ data ) ; } return $ result [ $ returnType ] ; } 
public function init ( ) { if ( $ this -> version === null ) { if ( isset ( $ _SERVER [ 'SERVER_PROTOCOL' ] ) && $ _SERVER [ 'SERVER_PROTOCOL' ] === 'HTTP/1.0' ) { $ this -> version = '1.0' ; } else { $ this -> version = '1.1' ; } } if ( $ this -> charset === null ) { $ this -> charset = Yii :: $ app -> charset ; } $ this -> formatters = array_merge ( $ this -> defaultFormatters ( ) , $ this -> formatters ) ; } 
public function setStatusCode ( $ value , $ text = null ) { if ( $ value === null ) { $ value = 200 ; } $ this -> _statusCode = ( int ) $ value ; if ( $ this -> getIsInvalid ( ) ) { throw new InvalidArgumentException ( "The HTTP status code is invalid: $value" ) ; } if ( $ text === null ) { $ this -> statusText = isset ( static :: $ httpStatuses [ $ this -> _statusCode ] ) ? static :: $ httpStatuses [ $ this -> _statusCode ] : '' ; } else { $ this -> statusText = $ text ; } return $ this ; } 
public function setStatusCodeByException ( $ e ) { if ( $ e instanceof HttpException ) { $ this -> setStatusCode ( $ e -> statusCode ) ; } else { $ this -> setStatusCode ( 500 ) ; } return $ this ; } 
public function send ( ) { if ( $ this -> isSent ) { return ; } $ this -> trigger ( self :: EVENT_BEFORE_SEND ) ; $ this -> prepare ( ) ; $ this -> trigger ( self :: EVENT_AFTER_PREPARE ) ; $ this -> sendHeaders ( ) ; $ this -> sendContent ( ) ; $ this -> trigger ( self :: EVENT_AFTER_SEND ) ; $ this -> isSent = true ; } 
public function clear ( ) { $ this -> _headers = null ; $ this -> _cookies = null ; $ this -> _statusCode = 200 ; $ this -> statusText = 'OK' ; $ this -> data = null ; $ this -> stream = null ; $ this -> content = null ; $ this -> isSent = false ; } 
public function sendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( ! isset ( $ options [ 'mimeType' ] ) ) { $ options [ 'mimeType' ] = FileHelper :: getMimeTypeByExtension ( $ filePath ) ; } if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } $ handle = fopen ( $ filePath , 'rb' ) ; $ this -> sendStreamAsFile ( $ handle , $ attachmentName , $ options ) ; return $ this ; } 
public function sendContentAsFile ( $ content , $ attachmentName , $ options = [ ] ) { $ headers = $ this -> getHeaders ( ) ; $ contentLength = StringHelper :: byteLength ( $ content ) ; $ range = $ this -> getHttpRange ( $ contentLength ) ; if ( $ range === false ) { $ headers -> set ( 'Content-Range' , "bytes */$contentLength" ) ; throw new RangeNotSatisfiableHttpException ( ) ; } list ( $ begin , $ end ) = $ range ; if ( $ begin != 0 || $ end != $ contentLength - 1 ) { $ this -> setStatusCode ( 206 ) ; $ headers -> set ( 'Content-Range' , "bytes $begin-$end/$contentLength" ) ; $ this -> content = StringHelper :: byteSubstr ( $ content , $ begin , $ end - $ begin + 1 ) ; } else { $ this -> setStatusCode ( 200 ) ; $ this -> content = $ content ; } $ mimeType = isset ( $ options [ 'mimeType' ] ) ? $ options [ 'mimeType' ] : 'application/octet-stream' ; $ this -> setDownloadHeaders ( $ attachmentName , $ mimeType , ! empty ( $ options [ 'inline' ] ) , $ end - $ begin + 1 ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; } 
public function sendStreamAsFile ( $ handle , $ attachmentName , $ options = [ ] ) { $ headers = $ this -> getHeaders ( ) ; if ( isset ( $ options [ 'fileSize' ] ) ) { $ fileSize = $ options [ 'fileSize' ] ; } else { fseek ( $ handle , 0 , SEEK_END ) ; $ fileSize = ftell ( $ handle ) ; } $ range = $ this -> getHttpRange ( $ fileSize ) ; if ( $ range === false ) { $ headers -> set ( 'Content-Range' , "bytes */$fileSize" ) ; throw new RangeNotSatisfiableHttpException ( ) ; } list ( $ begin , $ end ) = $ range ; if ( $ begin != 0 || $ end != $ fileSize - 1 ) { $ this -> setStatusCode ( 206 ) ; $ headers -> set ( 'Content-Range' , "bytes $begin-$end/$fileSize" ) ; } else { $ this -> setStatusCode ( 200 ) ; } $ mimeType = isset ( $ options [ 'mimeType' ] ) ? $ options [ 'mimeType' ] : 'application/octet-stream' ; $ this -> setDownloadHeaders ( $ attachmentName , $ mimeType , ! empty ( $ options [ 'inline' ] ) , $ end - $ begin + 1 ) ; $ this -> format = self :: FORMAT_RAW ; $ this -> stream = [ $ handle , $ begin , $ end ] ; return $ this ; } 
public function setDownloadHeaders ( $ attachmentName , $ mimeType = null , $ inline = false , $ contentLength = null ) { $ headers = $ this -> getHeaders ( ) ; $ disposition = $ inline ? 'inline' : 'attachment' ; $ headers -> setDefault ( 'Pragma' , 'public' ) -> setDefault ( 'Accept-Ranges' , 'bytes' ) -> setDefault ( 'Expires' , '0' ) -> setDefault ( 'Cache-Control' , 'must-revalidate, post-check=0, pre-check=0' ) -> setDefault ( 'Content-Disposition' , $ this -> getDispositionHeaderValue ( $ disposition , $ attachmentName ) ) ; if ( $ mimeType !== null ) { $ headers -> setDefault ( 'Content-Type' , $ mimeType ) ; } if ( $ contentLength !== null ) { $ headers -> setDefault ( 'Content-Length' , $ contentLength ) ; } return $ this ; } 
protected function getHttpRange ( $ fileSize ) { $ rangeHeader = Yii :: $ app -> getRequest ( ) -> getHeaders ( ) -> get ( 'Range' , '-' ) ; if ( $ rangeHeader === '-' ) { return [ 0 , $ fileSize - 1 ] ; } if ( ! preg_match ( '/^bytes=(\d*)-(\d*)$/' , $ rangeHeader , $ matches ) ) { return false ; } if ( $ matches [ 1 ] === '' ) { $ start = $ fileSize - $ matches [ 2 ] ; $ end = $ fileSize - 1 ; } elseif ( $ matches [ 2 ] !== '' ) { $ start = $ matches [ 1 ] ; $ end = $ matches [ 2 ] ; if ( $ end >= $ fileSize ) { $ end = $ fileSize - 1 ; } } else { $ start = $ matches [ 1 ] ; $ end = $ fileSize - 1 ; } if ( $ start < 0 || $ start > $ end ) { return false ; } return [ $ start , $ end ] ; } 
public function xSendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } if ( isset ( $ options [ 'mimeType' ] ) ) { $ mimeType = $ options [ 'mimeType' ] ; } elseif ( ( $ mimeType = FileHelper :: getMimeTypeByExtension ( $ filePath ) ) === null ) { $ mimeType = 'application/octet-stream' ; } if ( isset ( $ options [ 'xHeader' ] ) ) { $ xHeader = $ options [ 'xHeader' ] ; } else { $ xHeader = 'X-Sendfile' ; } $ disposition = empty ( $ options [ 'inline' ] ) ? 'attachment' : 'inline' ; $ this -> getHeaders ( ) -> setDefault ( $ xHeader , $ filePath ) -> setDefault ( 'Content-Type' , $ mimeType ) -> setDefault ( 'Content-Disposition' , $ this -> getDispositionHeaderValue ( $ disposition , $ attachmentName ) ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; } 
public function redirect ( $ url , $ statusCode = 302 , $ checkAjax = true ) { if ( is_array ( $ url ) && isset ( $ url [ 0 ] ) ) { 
protected function prepare ( ) { if ( $ this -> statusCode === 204 ) { $ this -> content = '' ; $ this -> stream = null ; return ; } if ( $ this -> stream !== null ) { return ; } if ( isset ( $ this -> formatters [ $ this -> format ] ) ) { $ formatter = $ this -> formatters [ $ this -> format ] ; if ( ! is_object ( $ formatter ) ) { $ this -> formatters [ $ this -> format ] = $ formatter = Yii :: createObject ( $ formatter ) ; } if ( $ formatter instanceof ResponseFormatterInterface ) { $ formatter -> format ( $ this ) ; } else { throw new InvalidConfigException ( "The '{$this->format}' response formatter is invalid. It must implement the ResponseFormatterInterface." ) ; } } elseif ( $ this -> format === self :: FORMAT_RAW ) { if ( $ this -> data !== null ) { $ this -> content = $ this -> data ; } } else { throw new InvalidConfigException ( "Unsupported response format: {$this->format}" ) ; } if ( is_array ( $ this -> content ) ) { throw new InvalidArgumentException ( 'Response content must not be an array.' ) ; } elseif ( is_object ( $ this -> content ) ) { if ( method_exists ( $ this -> content , '__toString' ) ) { $ this -> content = $ this -> content -> __toString ( ) ; } else { throw new InvalidArgumentException ( 'Response content must be a string or an object implementing __toString().' ) ; } } } 
public function getClientOptions ( $ model , $ attribute ) { $ options = [ 'pattern' => new JsExpression ( $ this -> pattern ) , 'fullPattern' => new JsExpression ( $ this -> fullPattern ) , 'allowName' => $ this -> allowName , 'message' => $ this -> formatMessage ( $ this -> message , [ 'attribute' => $ model -> getAttributeLabel ( $ attribute ) , ] ) , 'enableIDN' => ( bool ) $ this -> enableIDN , ] ; if ( $ this -> skipOnEmpty ) { $ options [ 'skipOnEmpty' ] = 1 ; } return $ options ; } 
private function checkTargetRelationExistence ( $ model , $ attribute ) { $ exists = false ; $ relationQuery = $ model -> { 'get' . ucfirst ( $ this -> targetRelation ) } ( ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ relationQuery ) ; } elseif ( $ this -> filter !== null ) { $ relationQuery -> andWhere ( $ this -> filter ) ; } if ( $ this -> forceMasterDb && method_exists ( $ model :: getDb ( ) , 'useMaster' ) ) { $ model :: getDb ( ) -> useMaster ( function ( ) use ( $ relationQuery , & $ exists ) { $ exists = $ relationQuery -> exists ( ) ; } ) ; } else { $ exists = $ relationQuery -> exists ( ) ; } if ( ! $ exists ) { $ this -> addError ( $ model , $ attribute , $ this -> message ) ; } } 
protected function validateValue ( $ value ) { if ( $ this -> targetClass === null ) { throw new InvalidConfigException ( 'The "targetClass" property must be set.' ) ; } if ( ! is_string ( $ this -> targetAttribute ) ) { throw new InvalidConfigException ( 'The "targetAttribute" property must be configured as a string.' ) ; } if ( is_array ( $ value ) && ! $ this -> allowArray ) { return [ $ this -> message , [ ] ] ; } $ query = $ this -> createQuery ( $ this -> targetClass , [ $ this -> targetAttribute => $ value ] ) ; return $ this -> valueExists ( $ this -> targetClass , $ query , $ value ) ? null : [ $ this -> message , [ ] ] ; } 
private function valueExists ( $ targetClass , $ query , $ value ) { $ db = $ targetClass :: getDb ( ) ; $ exists = false ; if ( $ this -> forceMasterDb && method_exists ( $ db , 'useMaster' ) ) { $ db -> useMaster ( function ( $ db ) use ( $ query , $ value , & $ exists ) { $ exists = $ this -> queryValueExists ( $ query , $ value ) ; } ) ; } else { $ exists = $ this -> queryValueExists ( $ query , $ value ) ; } return $ exists ; } 
private function queryValueExists ( $ query , $ value ) { if ( is_array ( $ value ) ) { return $ query -> count ( "DISTINCT [[$this->targetAttribute]]" ) == count ( $ value ) ; } return $ query -> exists ( ) ; } 
protected function createQuery ( $ targetClass , $ condition ) { $ query = $ targetClass :: find ( ) -> andWhere ( $ condition ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ query ) ; } elseif ( $ this -> filter !== null ) { $ query -> andWhere ( $ this -> filter ) ; } return $ query ; } 
public static function moveCursorTo ( $ column , $ row = null ) { if ( $ row === null ) { echo "\033[" . ( int ) $ column . 'G' ; } else { echo "\033[" . ( int ) $ row . ';' . ( int ) $ column . 'H' ; } } 
public static function ansiToHtml ( $ string , $ styleMap = [ ] ) { $ styleMap = [ 
public static function wrapText ( $ text , $ indent = 0 , $ refresh = false ) { $ size = static :: getScreenSize ( $ refresh ) ; if ( $ size === false || $ size [ 0 ] <= $ indent ) { return $ text ; } $ pad = str_repeat ( ' ' , $ indent ) ; $ lines = explode ( "\n" , wordwrap ( $ text , $ size [ 0 ] - $ indent , "\n" , true ) ) ; $ first = true ; foreach ( $ lines as $ i => $ line ) { if ( $ first ) { $ first = false ; continue ; } $ lines [ $ i ] = $ pad . $ line ; } return implode ( "\n" , $ lines ) ; } 
public static function stdin ( $ raw = false ) { return $ raw ? fgets ( \ STDIN ) : rtrim ( fgets ( \ STDIN ) , PHP_EOL ) ; } 
public static function confirm ( $ message , $ default = false ) { while ( true ) { static :: stdout ( $ message . ' (yes|no) [' . ( $ default ? 'yes' : 'no' ) . ']:' ) ; $ input = trim ( static :: stdin ( ) ) ; if ( empty ( $ input ) ) { return $ default ; } if ( ! strcasecmp ( $ input , 'y' ) || ! strcasecmp ( $ input , 'yes' ) ) { return true ; } if ( ! strcasecmp ( $ input , 'n' ) || ! strcasecmp ( $ input , 'no' ) ) { return false ; } } } 
public static function select ( $ prompt , $ options = [ ] ) { top : static :: stdout ( "$prompt [" . implode ( ',' , array_keys ( $ options ) ) . ',?]: ' ) ; $ input = static :: stdin ( ) ; if ( $ input === '?' ) { foreach ( $ options as $ key => $ value ) { static :: output ( " $key - $value" ) ; } static :: output ( ' ? - Show help' ) ; goto top ; } elseif ( ! array_key_exists ( $ input , $ options ) ) { goto top ; } return $ input ; } 
public static function startProgress ( $ done , $ total , $ prefix = '' , $ width = null ) { self :: $ _progressStart = time ( ) ; self :: $ _progressWidth = $ width ; self :: $ _progressPrefix = $ prefix ; self :: $ _progressEta = null ; self :: $ _progressEtaLastDone = 0 ; self :: $ _progressEtaLastUpdate = time ( ) ; static :: updateProgress ( $ done , $ total ) ; } 
private static function setETA ( $ done , $ total ) { if ( $ done > $ total || $ done == 0 ) { self :: $ _progressEta = null ; self :: $ _progressEtaLastUpdate = time ( ) ; return ; } if ( $ done < $ total && ( time ( ) - self :: $ _progressEtaLastUpdate > 1 && $ done > self :: $ _progressEtaLastDone ) ) { $ rate = ( time ( ) - ( self :: $ _progressEtaLastUpdate ? : self :: $ _progressStart ) ) / ( $ done - self :: $ _progressEtaLastDone ) ; self :: $ _progressEta = $ rate * ( $ total - $ done ) ; self :: $ _progressEtaLastUpdate = time ( ) ; self :: $ _progressEtaLastDone = $ done ; } } 
public static function endProgress ( $ remove = false , $ keepPrefix = true ) { if ( $ remove === false ) { static :: stdout ( PHP_EOL ) ; } else { if ( static :: streamSupportsAnsiColors ( STDOUT ) ) { static :: clearLine ( ) ; } static :: stdout ( "\r" . ( $ keepPrefix ? self :: $ _progressPrefix : '' ) . ( is_string ( $ remove ) ? $ remove : '' ) ) ; } flush ( ) ; self :: $ _progressStart = null ; self :: $ _progressWidth = null ; self :: $ _progressPrefix = '' ; self :: $ _progressEta = null ; self :: $ _progressEtaLastDone = 0 ; self :: $ _progressEtaLastUpdate = null ; } 
public static function errorSummary ( $ models , $ options = [ ] ) { $ showAllErrors = ArrayHelper :: remove ( $ options , 'showAllErrors' , false ) ; $ lines = self :: collectErrors ( $ models , $ showAllErrors ) ; return implode ( PHP_EOL , $ lines ) ; } 
private static function collectErrors ( $ models , $ showAllErrors ) { $ lines = [ ] ; if ( ! is_array ( $ models ) ) { $ models = [ $ models ] ; } foreach ( $ models as $ model ) { $ lines = array_unique ( array_merge ( $ lines , $ model -> getErrorSummary ( $ showAllErrors ) ) ) ; } return $ lines ; } 
public function format ( $ response ) { $ charset = $ this -> encoding === null ? $ response -> charset : $ this -> encoding ; if ( stripos ( $ this -> contentType , 'charset' ) === false ) { $ this -> contentType .= '; charset=' . $ charset ; } $ response -> getHeaders ( ) -> set ( 'Content-Type' , $ this -> contentType ) ; if ( $ response -> data !== null ) { $ dom = new DOMDocument ( $ this -> version , $ charset ) ; if ( ! empty ( $ this -> rootTag ) ) { $ root = new DOMElement ( $ this -> rootTag ) ; $ dom -> appendChild ( $ root ) ; $ this -> buildXml ( $ root , $ response -> data ) ; } else { $ this -> buildXml ( $ dom , $ response -> data ) ; } $ response -> content = $ dom -> saveXML ( ) ; } } 
protected function formatScalarValue ( $ value ) { if ( $ value === true ) { return 'true' ; } if ( $ value === false ) { return 'false' ; } if ( is_float ( $ value ) ) { return StringHelper :: floatToString ( $ value ) ; } return ( string ) $ value ; } 
protected function getValidXmlElementName ( $ name ) { if ( empty ( $ name ) || is_int ( $ name ) || ! $ this -> isValidXmlName ( $ name ) ) { return $ this -> itemTag ; } return $ name ; } 
public function init ( ) { parent :: init ( ) ; if ( empty ( $ this -> mask ) && empty ( $ this -> clientOptions [ 'alias' ] ) ) { throw new InvalidConfigException ( "Either the 'mask' property or the 'clientOptions[\"alias\"]' property must be set." ) ; } } 
protected function hashPluginOptions ( $ view ) { $ encOptions = empty ( $ this -> clientOptions ) ? '{}' : Json :: htmlEncode ( $ this -> clientOptions ) ; $ this -> _hashVar = self :: PLUGIN_NAME . '_' . hash ( 'crc32' , $ encOptions ) ; $ this -> options [ 'data-plugin-' . self :: PLUGIN_NAME ] = $ this -> _hashVar ; $ view -> registerJs ( "var {$this->_hashVar} = {$encOptions};" , View :: POS_HEAD ) ; } 
protected function initClientOptions ( ) { $ options = $ this -> clientOptions ; foreach ( $ options as $ key => $ value ) { if ( ! $ value instanceof JsExpression && in_array ( $ key , [ 'oncomplete' , 'onincomplete' , 'oncleared' , 'onKeyUp' , 'onKeyDown' , 'onBeforeMask' , 'onBeforePaste' , 'onUnMask' , 'isComplete' , 'determineActiveMasksetIndex' , ] , true ) ) { $ options [ $ key ] = new JsExpression ( $ value ) ; } } $ this -> clientOptions = $ options ; } 
public function registerClientScript ( ) { $ js = '' ; $ view = $ this -> getView ( ) ; $ this -> initClientOptions ( ) ; if ( ! empty ( $ this -> mask ) ) { $ this -> clientOptions [ 'mask' ] = $ this -> mask ; } $ this -> hashPluginOptions ( $ view ) ; if ( is_array ( $ this -> definitions ) && ! empty ( $ this -> definitions ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendDefinitions(' . Json :: htmlEncode ( $ this -> definitions ) . ');' ; } if ( is_array ( $ this -> aliases ) && ! empty ( $ this -> aliases ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendAliases(' . Json :: htmlEncode ( $ this -> aliases ) . ');' ; } $ id = $ this -> options [ 'id' ] ; $ js .= 'jQuery("#' . $ id . '").' . self :: PLUGIN_NAME . '(' . $ this -> _hashVar . ');' ; MaskedInputAsset :: register ( $ view ) ; $ view -> registerJs ( $ js ) ; } 
public function getParams ( ) { if ( $ this -> _params === null ) { if ( isset ( $ _SERVER [ 'argv' ] ) ) { $ this -> _params = $ _SERVER [ 'argv' ] ; array_shift ( $ this -> _params ) ; } else { $ this -> _params = [ ] ; } } return $ this -> _params ; } 
public function resolve ( ) { $ rawParams = $ this -> getParams ( ) ; $ endOfOptionsFound = false ; if ( isset ( $ rawParams [ 0 ] ) ) { $ route = array_shift ( $ rawParams ) ; if ( $ route === '--' ) { $ endOfOptionsFound = true ; $ route = array_shift ( $ rawParams ) ; } } else { $ route = '' ; } $ params = [ ] ; $ prevOption = null ; foreach ( $ rawParams as $ param ) { if ( $ endOfOptionsFound ) { $ params [ ] = $ param ; } elseif ( $ param === '--' ) { $ endOfOptionsFound = true ; } elseif ( preg_match ( '/^--([\w-]+)(?:=(.*))?$/' , $ param , $ matches ) ) { $ name = $ matches [ 1 ] ; if ( is_numeric ( substr ( $ name , 0 , 1 ) ) ) { throw new Exception ( 'Parameter "' . $ name . '" is not valid' ) ; } if ( $ name !== Application :: OPTION_APPCONFIG ) { $ params [ $ name ] = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : true ; $ prevOption = & $ params [ $ name ] ; } } elseif ( preg_match ( '/^-([\w-]+)(?:=(.*))?$/' , $ param , $ matches ) ) { $ name = $ matches [ 1 ] ; if ( is_numeric ( $ name ) ) { $ params [ ] = $ param ; } else { $ params [ '_aliases' ] [ $ name ] = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : true ; $ prevOption = & $ params [ '_aliases' ] [ $ name ] ; } } elseif ( $ prevOption === true ) { 
public function asNtext ( $ value ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return nl2br ( Html :: encode ( $ value ) ) ; } 
public function asHtml ( $ value , $ config = null ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return HtmlPurifier :: process ( $ value , $ config ) ; } 
public function asImage ( $ value , $ options = [ ] ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return Html :: img ( $ value , $ options ) ; } 
public function asUrl ( $ value , $ options = [ ] ) { if ( $ value === null ) { return $ this -> nullDisplay ; } $ url = $ value ; if ( strpos ( $ url , '://' ) === false ) { $ url = 'http://' . $ url ; } return Html :: a ( Html :: encode ( $ value ) , $ url , $ options ) ; } 
public function asBoolean ( $ value ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return $ value ? $ this -> booleanFormat [ 1 ] : $ this -> booleanFormat [ 0 ] ; } 
public function asDate ( $ value , $ format = null ) { if ( $ format === null ) { $ format = $ this -> dateFormat ; } return $ this -> formatDateTimeValue ( $ value , $ format , 'date' ) ; } 
public function asTime ( $ value , $ format = null ) { if ( $ format === null ) { $ format = $ this -> timeFormat ; } return $ this -> formatDateTimeValue ( $ value , $ format , 'time' ) ; } 
public function asRelativeTime ( $ value , $ referenceTime = null ) { if ( $ value === null ) { return $ this -> nullDisplay ; } if ( $ value instanceof DateInterval ) { $ interval = $ value ; } else { $ timestamp = $ this -> normalizeDatetimeValue ( $ value ) ; if ( $ timestamp === false ) { 
public function asDuration ( $ value , $ implodeString = ', ' , $ negativeSign = '-' ) { if ( $ value === null ) { return $ this -> nullDisplay ; } if ( $ value instanceof DateInterval ) { $ isNegative = $ value -> invert ; $ interval = $ value ; } elseif ( is_numeric ( $ value ) ) { $ isNegative = $ value < 0 ; $ zeroDateTime = ( new DateTime ( ) ) -> setTimestamp ( 0 ) ; $ valueDateTime = ( new DateTime ( ) ) -> setTimestamp ( abs ( $ value ) ) ; $ interval = $ valueDateTime -> diff ( $ zeroDateTime ) ; } elseif ( strncmp ( $ value , 'P-' , 2 ) === 0 ) { $ interval = new DateInterval ( 'P' . substr ( $ value , 2 ) ) ; $ isNegative = true ; } else { $ interval = new DateInterval ( $ value ) ; $ isNegative = $ interval -> invert ; } $ parts = [ ] ; if ( $ interval -> y > 0 ) { $ parts [ ] = Yii :: t ( 'yii' , '{delta, plural, =1{1 year} other{# years}}' , [ 'delta' => $ interval -> y ] , $ this -> locale ) ; } if ( $ interval -> m > 0 ) { $ parts [ ] = Yii :: t ( 'yii' , '{delta, plural, =1{1 month} other{# months}}' , [ 'delta' => $ interval -> m ] , $ this -> locale ) ; } if ( $ interval -> d > 0 ) { $ parts [ ] = Yii :: t ( 'yii' , '{delta, plural, =1{1 day} other{# days}}' , [ 'delta' => $ interval -> d ] , $ this -> locale ) ; } if ( $ interval -> h > 0 ) { $ parts [ ] = Yii :: t ( 'yii' , '{delta, plural, =1{1 hour} other{# hours}}' , [ 'delta' => $ interval -> h ] , $ this -> locale ) ; } if ( $ interval -> i > 0 ) { $ parts [ ] = Yii :: t ( 'yii' , '{delta, plural, =1{1 minute} other{# minutes}}' , [ 'delta' => $ interval -> i ] , $ this -> locale ) ; } if ( $ interval -> s > 0 ) { $ parts [ ] = Yii :: t ( 'yii' , '{delta, plural, =1{1 second} other{# seconds}}' , [ 'delta' => $ interval -> s ] , $ this -> locale ) ; } if ( $ interval -> s === 0 && empty ( $ parts ) ) { $ parts [ ] = Yii :: t ( 'yii' , '{delta, plural, =1{1 second} other{# seconds}}' , [ 'delta' => $ interval -> s ] , $ this -> locale ) ; $ isNegative = false ; } return empty ( $ parts ) ? $ this -> nullDisplay : ( ( $ isNegative ? $ negativeSign : '' ) . implode ( $ implodeString , $ parts ) ) ; } 
public function asLength ( $ value , $ decimals = null , $ numberOptions = [ ] , $ textOptions = [ ] ) { return $ this -> formatUnit ( self :: UNIT_LENGTH , self :: FORMAT_WIDTH_LONG , $ value , null , null , $ decimals , $ numberOptions , $ textOptions ) ; } 
public function asShortLength ( $ value , $ decimals = null , $ options = [ ] , $ textOptions = [ ] ) { return $ this -> formatUnit ( self :: UNIT_LENGTH , self :: FORMAT_WIDTH_SHORT , $ value , null , null , $ decimals , $ options , $ textOptions ) ; } 
public function asWeight ( $ value , $ decimals = null , $ options = [ ] , $ textOptions = [ ] ) { return $ this -> formatUnit ( self :: UNIT_WEIGHT , self :: FORMAT_WIDTH_LONG , $ value , null , null , $ decimals , $ options , $ textOptions ) ; } 
public function asShortWeight ( $ value , $ decimals = null , $ options = [ ] , $ textOptions = [ ] ) { return $ this -> formatUnit ( self :: UNIT_WEIGHT , self :: FORMAT_WIDTH_SHORT , $ value , null , null , $ decimals , $ options , $ textOptions ) ; } 
private function formatNumber ( $ value , $ decimals , $ maxPosition , $ formatBase , $ options , $ textOptions ) { $ value = $ this -> normalizeNumericValue ( $ value ) ; $ position = 0 ; if ( is_array ( $ formatBase ) ) { $ maxPosition = count ( $ formatBase ) - 1 ; } do { if ( is_array ( $ formatBase ) ) { if ( ! isset ( $ formatBase [ $ position + 1 ] ) ) { break ; } if ( abs ( $ value ) < $ formatBase [ $ position + 1 ] ) { break ; } } else { if ( abs ( $ value ) < $ formatBase ) { break ; } $ value /= $ formatBase ; } $ position ++ ; } while ( $ position < $ maxPosition + 1 ) ; if ( is_array ( $ formatBase ) && $ position !== 0 ) { $ value /= $ formatBase [ $ position ] ; } 
protected function normalizeNumericValue ( $ value ) { if ( empty ( $ value ) ) { return 0 ; } if ( is_string ( $ value ) && is_numeric ( $ value ) ) { $ value = ( float ) $ value ; } if ( ! is_numeric ( $ value ) ) { throw new InvalidArgumentException ( "'$value' is not a numeric value." ) ; } return $ value ; } 
protected function isNormalizedValueMispresented ( $ value , $ normalizedValue ) { if ( empty ( $ value ) ) { $ value = 0 ; } return ( string ) $ normalizedValue !== $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; } 
protected function normalizeNumericStringValue ( $ value ) { $ powerPosition = strrpos ( $ value , 'E' ) ; if ( $ powerPosition !== false ) { $ valuePart = substr ( $ value , 0 , $ powerPosition ) ; $ powerPart = substr ( $ value , $ powerPosition + 1 ) ; } else { $ powerPart = null ; $ valuePart = $ value ; } $ separatorPosition = strrpos ( $ valuePart , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ valuePart , 0 , $ separatorPosition ) ; $ fractionalPart = substr ( $ valuePart , $ separatorPosition + 1 ) ; } else { $ integerPart = $ valuePart ; $ fractionalPart = null ; } 
protected function asDecimalStringFallback ( $ value , $ decimals = 2 ) { if ( empty ( $ value ) ) { $ value = 0 ; } $ value = $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; $ separatorPosition = strrpos ( $ value , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ value , 0 , $ separatorPosition ) ; $ fractionalPart = substr ( $ value , $ separatorPosition + 1 ) ; } else { $ integerPart = $ value ; $ fractionalPart = null ; } $ decimalOutput = '' ; if ( $ decimals === null ) { $ decimals = 2 ; } $ carry = 0 ; if ( $ decimals > 0 ) { $ decimalSeparator = $ this -> decimalSeparator ; if ( $ this -> decimalSeparator === null ) { $ decimalSeparator = '.' ; } if ( $ fractionalPart === null ) { $ fractionalPart = str_repeat ( '0' , $ decimals ) ; } elseif ( strlen ( $ fractionalPart ) > $ decimals ) { $ cursor = $ decimals ; 
protected function asIntegerStringFallback ( $ value ) { if ( empty ( $ value ) ) { $ value = 0 ; } $ value = $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; $ separatorPosition = strrpos ( $ value , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ value , 0 , $ separatorPosition ) ; } else { $ integerPart = $ value ; } return $ this -> asDecimalStringFallback ( $ integerPart , 0 ) ; } 
protected function asPercentStringFallback ( $ value , $ decimals = null ) { if ( empty ( $ value ) ) { $ value = 0 ; } if ( $ decimals === null ) { $ decimals = 0 ; } $ value = $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; $ separatorPosition = strrpos ( $ value , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ value , 0 , $ separatorPosition ) ; $ fractionalPart = str_pad ( substr ( $ value , $ separatorPosition + 1 ) , 2 , '0' ) ; $ integerPart .= substr ( $ fractionalPart , 0 , 2 ) ; $ fractionalPart = substr ( $ fractionalPart , 2 ) ; if ( $ fractionalPart === '' ) { $ multipliedValue = $ integerPart ; } else { $ multipliedValue = $ integerPart . '.' . $ fractionalPart ; } } else { $ multipliedValue = $ value . '00' ; } return $ this -> asDecimalStringFallback ( $ multipliedValue , $ decimals ) . '%' ; } 
protected function asCurrencyStringFallback ( $ value , $ currency = null ) { if ( $ currency === null ) { if ( $ this -> currencyCode === null ) { throw new InvalidConfigException ( 'The default currency code for the formatter is not defined.' ) ; } $ currency = $ this -> currencyCode ; } return $ currency . ' ' . $ this -> asDecimalStringFallback ( $ value , 2 ) ; } 
public function getSchemaNames ( $ refresh = false ) { if ( $ this -> _schemaNames === null || $ refresh ) { $ this -> _schemaNames = $ this -> findSchemaNames ( ) ; } return $ this -> _schemaNames ; } 
public function getTableNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _tableNames [ $ schema ] ) || $ refresh ) { $ this -> _tableNames [ $ schema ] = $ this -> findTableNames ( $ schema ) ; } return $ this -> _tableNames [ $ schema ] ; } 
public function getPdoType ( $ data ) { static $ typeMap = [ 
public function getLastInsertID ( $ sequenceName = '' ) { if ( $ this -> db -> isActive ) { return $ this -> db -> pdo -> lastInsertId ( $ sequenceName === '' ? null : $ this -> quoteTableName ( $ sequenceName ) ) ; } throw new InvalidCallException ( 'DB Connection is not active.' ) ; } 
public function insert ( $ table , $ columns ) { $ command = $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) ; if ( ! $ command -> execute ( ) ) { return false ; } $ tableSchema = $ this -> getTableSchema ( $ table ) ; $ result = [ ] ; foreach ( $ tableSchema -> primaryKey as $ name ) { if ( $ tableSchema -> columns [ $ name ] -> autoIncrement ) { $ result [ $ name ] = $ this -> getLastInsertID ( $ tableSchema -> sequenceName ) ; break ; } $ result [ $ name ] = isset ( $ columns [ $ name ] ) ? $ columns [ $ name ] : $ tableSchema -> columns [ $ name ] -> defaultValue ; } return $ result ; } 
public function quoteValue ( $ str ) { if ( ! is_string ( $ str ) ) { return $ str ; } if ( ( $ value = $ this -> db -> getSlavePdo ( ) -> quote ( $ str ) ) !== false ) { return $ value ; } 
public function quoteSimpleTableName ( $ name ) { if ( is_string ( $ this -> tableQuoteCharacter ) ) { $ startingCharacter = $ endingCharacter = $ this -> tableQuoteCharacter ; } else { list ( $ startingCharacter , $ endingCharacter ) = $ this -> tableQuoteCharacter ; } return strpos ( $ name , $ startingCharacter ) !== false ? $ name : $ startingCharacter . $ name . $ endingCharacter ; } 
public function quoteSimpleColumnName ( $ name ) { if ( is_string ( $ this -> tableQuoteCharacter ) ) { $ startingCharacter = $ endingCharacter = $ this -> columnQuoteCharacter ; } else { list ( $ startingCharacter , $ endingCharacter ) = $ this -> columnQuoteCharacter ; } return $ name === '*' || strpos ( $ name , $ startingCharacter ) !== false ? $ name : $ startingCharacter . $ name . $ endingCharacter ; } 
public function unquoteSimpleTableName ( $ name ) { if ( is_string ( $ this -> tableQuoteCharacter ) ) { $ startingCharacter = $ this -> tableQuoteCharacter ; } else { $ startingCharacter = $ this -> tableQuoteCharacter [ 0 ] ; } return strpos ( $ name , $ startingCharacter ) === false ? $ name : substr ( $ name , 1 , - 1 ) ; } 
public function unquoteSimpleColumnName ( $ name ) { if ( is_string ( $ this -> columnQuoteCharacter ) ) { $ startingCharacter = $ this -> columnQuoteCharacter ; } else { $ startingCharacter = $ this -> columnQuoteCharacter [ 0 ] ; } return strpos ( $ name , $ startingCharacter ) === false ? $ name : substr ( $ name , 1 , - 1 ) ; } 
protected function getColumnPhpType ( $ column ) { static $ typeMap = [ 
public function getServerVersion ( ) { if ( $ this -> _serverVersion === null ) { $ this -> _serverVersion = $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_SERVER_VERSION ) ; } return $ this -> _serverVersion ; } 
protected function getCacheKey ( $ name ) { return [ __CLASS__ , $ this -> db -> dsn , $ this -> db -> username , $ this -> getRawTableName ( $ name ) , ] ; } 
protected function getCacheTag ( ) { return md5 ( serialize ( [ __CLASS__ , $ this -> db -> dsn , $ this -> db -> username , ] ) ) ; } 
protected function getSchemaMetadata ( $ schema , $ type , $ refresh ) { $ metadata = [ ] ; $ methodName = 'getTable' . ucfirst ( $ type ) ; foreach ( $ this -> getTableNames ( $ schema , $ refresh ) as $ name ) { if ( $ schema !== '' ) { $ name = $ schema . '.' . $ name ; } $ tableMetadata = $ this -> $ methodName ( $ name , $ refresh ) ; if ( $ tableMetadata !== null ) { $ metadata [ ] = $ tableMetadata ; } } return $ metadata ; } 
protected function setTableMetadata ( $ name , $ type , $ data ) { $ this -> _tableMetadata [ $ this -> getRawTableName ( $ name ) ] [ $ type ] = $ data ; } 
protected function normalizePdoRowKeyCase ( array $ row , $ multiple ) { if ( $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_CASE ) !== \ PDO :: CASE_UPPER ) { return $ row ; } if ( $ multiple ) { return array_map ( function ( array $ row ) { return array_change_key_case ( $ row , CASE_LOWER ) ; } , $ row ) ; } return array_change_key_case ( $ row , CASE_LOWER ) ; } 
private function loadTableMetadataFromCache ( $ cache , $ name ) { if ( $ cache === null ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } $ metadata = $ cache -> get ( $ this -> getCacheKey ( $ name ) ) ; if ( ! is_array ( $ metadata ) || ! isset ( $ metadata [ 'cacheVersion' ] ) || $ metadata [ 'cacheVersion' ] !== static :: SCHEMA_CACHE_VERSION ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } unset ( $ metadata [ 'cacheVersion' ] ) ; $ this -> _tableMetadata [ $ name ] = $ metadata ; } 
private function saveTableMetadataToCache ( $ cache , $ name ) { if ( $ cache === null ) { return ; } $ metadata = $ this -> _tableMetadata [ $ name ] ; $ metadata [ 'cacheVersion' ] = static :: SCHEMA_CACHE_VERSION ; $ cache -> set ( $ this -> getCacheKey ( $ name ) , $ metadata , $ this -> db -> schemaCacheDuration , new TagDependency ( [ 'tags' => $ this -> getCacheTag ( ) ] ) ) ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> model === null ) { throw new InvalidConfigException ( 'Please specify the "model" property.' ) ; } if ( $ this -> formatter === null ) { $ this -> formatter = Yii :: $ app -> getFormatter ( ) ; } elseif ( is_array ( $ this -> formatter ) ) { $ this -> formatter = Yii :: createObject ( $ this -> formatter ) ; } if ( ! $ this -> formatter instanceof Formatter ) { throw new InvalidConfigException ( 'The "formatter" property must be either a Format object or a configuration array.' ) ; } $ this -> normalizeAttributes ( ) ; if ( ! isset ( $ this -> options [ 'id' ] ) ) { $ this -> options [ 'id' ] = $ this -> getId ( ) ; } } 
public function run ( ) { $ rows = [ ] ; $ i = 0 ; foreach ( $ this -> attributes as $ attribute ) { $ rows [ ] = $ this -> renderAttribute ( $ attribute , $ i ++ ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'table' ) ; echo Html :: tag ( $ tag , implode ( "\n" , $ rows ) , $ options ) ; } 
protected function renderAttribute ( $ attribute , $ index ) { if ( is_string ( $ this -> template ) ) { $ captionOptions = Html :: renderTagAttributes ( ArrayHelper :: getValue ( $ attribute , 'captionOptions' , [ ] ) ) ; $ contentOptions = Html :: renderTagAttributes ( ArrayHelper :: getValue ( $ attribute , 'contentOptions' , [ ] ) ) ; return strtr ( $ this -> template , [ '{label}' => $ attribute [ 'label' ] , '{value}' => $ this -> formatter -> format ( $ attribute [ 'value' ] , $ attribute [ 'format' ] ) , '{captionOptions}' => $ captionOptions , '{contentOptions}' => $ contentOptions , ] ) ; } return call_user_func ( $ this -> template , $ attribute , $ index , $ this ) ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> options === null ) { $ this -> options = LOG_ODELAY | LOG_PID ; } } 
public function export ( ) { openlog ( $ this -> identity , $ this -> options , $ this -> facility ) ; foreach ( $ this -> messages as $ message ) { if ( syslog ( $ this -> _syslogLevels [ $ message [ 1 ] ] , $ this -> formatMessage ( $ message ) ) === false ) { throw new LogRuntimeException ( 'Unable to export log through system log!' ) ; } } closelog ( ) ; } 
public function getColumn ( $ name ) { return isset ( $ this -> columns [ $ name ] ) ? $ this -> columns [ $ name ] : null ; } 
public function fixPrimaryKey ( $ keys ) { $ keys = ( array ) $ keys ; $ this -> primaryKey = $ keys ; foreach ( $ this -> columns as $ column ) { $ column -> isPrimaryKey = false ; } foreach ( $ keys as $ key ) { if ( isset ( $ this -> columns [ $ key ] ) ) { $ this -> columns [ $ key ] -> isPrimaryKey = true ; } else { throw new InvalidArgumentException ( "Primary key '$key' cannot be found in table '{$this->name}'." ) ; } } } 
public function init ( ) { parent :: init ( ) ; register_shutdown_function ( [ $ this , 'close' ] ) ; if ( $ this -> getIsActive ( ) ) { Yii :: warning ( 'Session is already started' , __METHOD__ ) ; $ this -> updateFlashCounters ( ) ; } } 
public function destroy ( ) { if ( $ this -> getIsActive ( ) ) { $ sessionId = session_id ( ) ; $ this -> close ( ) ; $ this -> setId ( $ sessionId ) ; $ this -> open ( ) ; session_unset ( ) ; session_destroy ( ) ; $ this -> setId ( $ sessionId ) ; } } 
public function regenerateID ( $ deleteOldSession = false ) { if ( $ this -> getIsActive ( ) ) { 
public function setSavePath ( $ value ) { $ path = Yii :: getAlias ( $ value ) ; if ( is_dir ( $ path ) ) { session_save_path ( $ path ) ; } else { throw new InvalidArgumentException ( "Session save path is not a valid directory: $value" ) ; } } 
private function setCookieParamsInternal ( ) { $ data = $ this -> getCookieParams ( ) ; if ( isset ( $ data [ 'lifetime' ] , $ data [ 'path' ] , $ data [ 'domain' ] , $ data [ 'secure' ] , $ data [ 'httponly' ] ) ) { session_set_cookie_params ( $ data [ 'lifetime' ] , $ data [ 'path' ] , $ data [ 'domain' ] , $ data [ 'secure' ] , $ data [ 'httponly' ] ) ; } else { throw new InvalidArgumentException ( 'Please make sure cookieParams contains these elements: lifetime, path, domain, secure and httponly.' ) ; } } 
public function setUseCookies ( $ value ) { $ this -> freeze ( ) ; if ( $ value === false ) { ini_set ( 'session.use_cookies' , '0' ) ; ini_set ( 'session.use_only_cookies' , '0' ) ; } elseif ( $ value === true ) { ini_set ( 'session.use_cookies' , '1' ) ; ini_set ( 'session.use_only_cookies' , '1' ) ; } else { ini_set ( 'session.use_cookies' , '1' ) ; ini_set ( 'session.use_only_cookies' , '0' ) ; } $ this -> unfreeze ( ) ; } 
public function get ( $ key , $ defaultValue = null ) { $ this -> open ( ) ; return isset ( $ _SESSION [ $ key ] ) ? $ _SESSION [ $ key ] : $ defaultValue ; } 
protected function updateFlashCounters ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; if ( is_array ( $ counters ) ) { foreach ( $ counters as $ key => $ count ) { if ( $ count > 0 ) { unset ( $ counters [ $ key ] , $ _SESSION [ $ key ] ) ; } elseif ( $ count == 0 ) { $ counters [ $ key ] ++ ; } } $ _SESSION [ $ this -> flashParam ] = $ counters ; } else { 
public function removeFlash ( $ key ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; $ value = isset ( $ _SESSION [ $ key ] , $ counters [ $ key ] ) ? $ _SESSION [ $ key ] : null ; unset ( $ counters [ $ key ] , $ _SESSION [ $ key ] ) ; $ _SESSION [ $ this -> flashParam ] = $ counters ; return $ value ; } 
public function removeAllFlashes ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; foreach ( array_keys ( $ counters ) as $ key ) { unset ( $ _SESSION [ $ key ] ) ; } unset ( $ _SESSION [ $ this -> flashParam ] ) ; } 
public function offsetGet ( $ offset ) { $ this -> open ( ) ; return isset ( $ _SESSION [ $ offset ] ) ? $ _SESSION [ $ offset ] : null ; } 
protected function freeze ( ) { if ( $ this -> getIsActive ( ) ) { if ( isset ( $ _SESSION ) ) { $ this -> frozenSessionData = $ _SESSION ; } $ this -> close ( ) ; Yii :: info ( 'Session frozen' , __METHOD__ ) ; } } 
public static function begin ( $ config = [ ] ) { $ config [ 'class' ] = get_called_class ( ) ; $ widget = Yii :: createObject ( $ config ) ; self :: $ stack [ ] = $ widget ; return $ widget ; } 
public static function end ( ) { if ( ! empty ( self :: $ stack ) ) { $ widget = array_pop ( self :: $ stack ) ; if ( get_class ( $ widget ) === get_called_class ( ) ) { if ( $ widget -> beforeRun ( ) ) { $ result = $ widget -> run ( ) ; $ result = $ widget -> afterRun ( $ result ) ; echo $ result ; } return $ widget ; } throw new InvalidCallException ( 'Expecting end() of ' . get_class ( $ widget ) . ', found ' . get_called_class ( ) ) ; } throw new InvalidCallException ( 'Unexpected ' . get_called_class ( ) . '::end() call. A matching begin() is not found.' ) ; } 
public function getView ( ) { if ( $ this -> _view === null ) { $ this -> _view = Yii :: $ app -> getView ( ) ; } return $ this -> _view ; } 
public function beforeRun ( ) { $ event = new WidgetEvent ( ) ; $ this -> trigger ( self :: EVENT_BEFORE_RUN , $ event ) ; return $ event -> isValid ; } 
public function afterRun ( $ result ) { $ event = new WidgetEvent ( ) ; $ event -> result = $ result ; $ this -> trigger ( self :: EVENT_AFTER_RUN , $ event ) ; return $ event -> result ; } 
public static function fromArrayDefinition ( $ operator , $ operands ) { if ( ! isset ( $ operands [ 0 ] , $ operands [ 1 ] ) ) { throw new InvalidArgumentException ( "Operator '$operator' requires two operands." ) ; } return new static ( $ operands [ 0 ] , $ operator , $ operands [ 1 ] ) ; } 
public function getClientOptions ( $ model , $ attribute ) { $ label = $ model -> getAttributeLabel ( $ attribute ) ; $ options = [ 'pattern' => new JsExpression ( $ this -> integerOnly ? $ this -> integerPattern : $ this -> numberPattern ) , 'message' => $ this -> formatMessage ( $ this -> message , [ 'attribute' => $ label , ] ) , ] ; if ( $ this -> min !== null ) { 
public function init ( ) { parent :: init ( ) ; if ( is_array ( $ this -> theme ) ) { if ( ! isset ( $ this -> theme [ 'class' ] ) ) { $ this -> theme [ 'class' ] = 'yii\base\Theme' ; } $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } elseif ( is_string ( $ this -> theme ) ) { $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } } 
public function render ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; return $ this -> renderFile ( $ viewFile , $ params , $ context ) ; } 
protected function findViewFile ( $ view , $ context = null ) { if ( strncmp ( $ view , '@' , 1 ) === 0 ) { 
public function renderFile ( $ viewFile , $ params = [ ] , $ context = null ) { $ viewFile = $ requestedFile = Yii :: getAlias ( $ viewFile ) ; if ( $ this -> theme !== null ) { $ viewFile = $ this -> theme -> applyTo ( $ viewFile ) ; } if ( is_file ( $ viewFile ) ) { $ viewFile = FileHelper :: localize ( $ viewFile ) ; } else { throw new ViewNotFoundException ( "The view file does not exist: $viewFile" ) ; } $ oldContext = $ this -> context ; if ( $ context !== null ) { $ this -> context = $ context ; } $ output = '' ; $ this -> _viewFiles [ ] = [ 'resolved' => $ viewFile , 'requested' => $ requestedFile ] ; if ( $ this -> beforeRender ( $ viewFile , $ params ) ) { Yii :: debug ( "Rendering view file: $viewFile" , __METHOD__ ) ; $ ext = pathinfo ( $ viewFile , PATHINFO_EXTENSION ) ; if ( isset ( $ this -> renderers [ $ ext ] ) ) { if ( is_array ( $ this -> renderers [ $ ext ] ) || is_string ( $ this -> renderers [ $ ext ] ) ) { $ this -> renderers [ $ ext ] = Yii :: createObject ( $ this -> renderers [ $ ext ] ) ; } $ renderer = $ this -> renderers [ $ ext ] ; $ output = $ renderer -> render ( $ this , $ viewFile , $ params ) ; } else { $ output = $ this -> renderPhpFile ( $ viewFile , $ params ) ; } $ this -> afterRender ( $ viewFile , $ params , $ output ) ; } array_pop ( $ this -> _viewFiles ) ; $ this -> context = $ oldContext ; return $ output ; } 
public function beforeRender ( $ viewFile , $ params ) { $ event = new ViewEvent ( [ 'viewFile' => $ viewFile , 'params' => $ params , ] ) ; $ this -> trigger ( self :: EVENT_BEFORE_RENDER , $ event ) ; return $ event -> isValid ; } 
public function afterRender ( $ viewFile , $ params , & $ output ) { if ( $ this -> hasEventHandlers ( self :: EVENT_AFTER_RENDER ) ) { $ event = new ViewEvent ( [ 'viewFile' => $ viewFile , 'params' => $ params , 'output' => $ output , ] ) ; $ this -> trigger ( self :: EVENT_AFTER_RENDER , $ event ) ; $ output = $ event -> output ; } } 
public function renderDynamic ( $ statements ) { if ( ! empty ( $ this -> cacheStack ) ) { $ n = count ( $ this -> dynamicPlaceholders ) ; $ placeholder = "<![CDATA[YII-DYNAMIC-$n]]>" ; $ this -> addDynamicPlaceholder ( $ placeholder , $ statements ) ; return $ placeholder ; } return $ this -> evaluateDynamicContent ( $ statements ) ; } 
public function attach ( $ owner ) { parent :: attach ( $ owner ) ; if ( $ this -> attributeTypes === null ) { $ ownerClass = get_class ( $ this -> owner ) ; if ( ! isset ( self :: $ autoDetectedAttributeTypes [ $ ownerClass ] ) ) { self :: $ autoDetectedAttributeTypes [ $ ownerClass ] = $ this -> detectAttributeTypes ( ) ; } $ this -> attributeTypes = self :: $ autoDetectedAttributeTypes [ $ ownerClass ] ; } } 
public function typecastAttributes ( $ attributeNames = null ) { $ attributeTypes = [ ] ; if ( $ attributeNames === null ) { $ attributeTypes = $ this -> attributeTypes ; } else { foreach ( $ attributeNames as $ attribute ) { if ( ! isset ( $ this -> attributeTypes [ $ attribute ] ) ) { throw new InvalidArgumentException ( "There is no type mapping for '{$attribute}'." ) ; } $ attributeTypes [ $ attribute ] = $ this -> attributeTypes [ $ attribute ] ; } } foreach ( $ attributeTypes as $ attribute => $ type ) { $ value = $ this -> owner -> { $ attribute } ; if ( $ this -> skipOnNull && $ value === null ) { continue ; } $ this -> owner -> { $ attribute } = $ this -> typecastValue ( $ value , $ type ) ; } } 
protected function typecastValue ( $ value , $ type ) { if ( is_scalar ( $ type ) ) { if ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { $ value = $ value -> __toString ( ) ; } switch ( $ type ) { case self :: TYPE_INTEGER : return ( int ) $ value ; case self :: TYPE_FLOAT : return ( float ) $ value ; case self :: TYPE_BOOLEAN : return ( bool ) $ value ; case self :: TYPE_STRING : if ( is_float ( $ value ) ) { return StringHelper :: floatToString ( $ value ) ; } return ( string ) $ value ; default : throw new InvalidArgumentException ( "Unsupported type '{$type}'" ) ; } } return call_user_func ( $ type , $ value ) ; } 
public function events ( ) { $ events = [ ] ; if ( $ this -> typecastAfterValidate ) { $ events [ Model :: EVENT_AFTER_VALIDATE ] = 'afterValidate' ; } if ( $ this -> typecastBeforeSave ) { $ events [ BaseActiveRecord :: EVENT_BEFORE_INSERT ] = 'beforeSave' ; $ events [ BaseActiveRecord :: EVENT_BEFORE_UPDATE ] = 'beforeSave' ; } if ( $ this -> typecastAfterSave ) { $ events [ BaseActiveRecord :: EVENT_AFTER_INSERT ] = 'afterSave' ; $ events [ BaseActiveRecord :: EVENT_AFTER_UPDATE ] = 'afterSave' ; } if ( $ this -> typecastAfterFind ) { $ events [ BaseActiveRecord :: EVENT_AFTER_FIND ] = 'afterFind' ; } return $ events ; } 
public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } if ( $ model -> delete ( ) === false ) { throw new ServerErrorHttpException ( 'Failed to delete the object for unknown reason.' ) ; } Yii :: $ app -> getResponse ( ) -> setStatusCode ( 204 ) ; } 
public function init ( ) { $ this -> prefix = trim ( $ this -> prefix , '/' ) ; $ this -> routePrefix = $ this -> routePrefix === null ? $ this -> prefix : trim ( $ this -> routePrefix , '/' ) ; parent :: init ( ) ; } 
protected function createRules ( ) { $ rules = [ ] ; foreach ( $ this -> rules as $ key => $ rule ) { if ( ! is_array ( $ rule ) ) { $ verbs = 'GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS' ; $ verb = null ; if ( preg_match ( "/^((?:(?:$verbs),)*(?:$verbs))\\s+(.*)$/" , $ key , $ matches ) ) { $ verb = explode ( ',' , $ matches [ 1 ] ) ; $ key = $ matches [ 2 ] ; } $ rule = [ 'pattern' => ltrim ( $ this -> prefix . '/' . $ key , '/' ) , 'route' => ltrim ( $ this -> routePrefix . '/' . $ rule , '/' ) , 'verb' => $ verb ] ; } elseif ( isset ( $ rule [ 'pattern' ] , $ rule [ 'route' ] ) ) { $ rule [ 'pattern' ] = ltrim ( $ this -> prefix . '/' . $ rule [ 'pattern' ] , '/' ) ; $ rule [ 'route' ] = ltrim ( $ this -> routePrefix . '/' . $ rule [ 'route' ] , '/' ) ; } $ rule = Yii :: createObject ( array_merge ( $ this -> ruleConfig , $ rule ) ) ; if ( ! $ rule instanceof UrlRuleInterface ) { throw new InvalidConfigException ( 'URL rule class must implement UrlRuleInterface.' ) ; } $ rules [ ] = $ rule ; } return $ rules ; } 
public function createUrl ( $ manager , $ route , $ params ) { if ( $ this -> routePrefix === '' || strpos ( $ route , $ this -> routePrefix . '/' ) === 0 ) { return parent :: createUrl ( $ manager , $ route , $ params ) ; } $ this -> createStatus = UrlRule :: CREATE_STATUS_ROUTE_MISMATCH ; return false ; } 
public function init ( ) { parent :: init ( ) ; $ this -> db = Instance :: ensure ( $ this -> db , Connection :: className ( ) ) ; } 
public function regenerateID ( $ deleteOldSession = false ) { $ oldID = session_id ( ) ; 
public function close ( ) { if ( $ this -> getIsActive ( ) ) { 
public function readSession ( $ id ) { $ query = new Query ( ) ; $ query -> from ( $ this -> sessionTable ) -> where ( '[[expire]]>:expire AND [[id]]=:id' , [ ':expire' => time ( ) , ':id' => $ id ] ) ; if ( $ this -> readCallback !== null ) { $ fields = $ query -> one ( $ this -> db ) ; return $ fields === false ? '' : $ this -> extractData ( $ fields ) ; } $ data = $ query -> select ( [ 'data' ] ) -> scalar ( $ this -> db ) ; return $ data === false ? '' : $ data ; } 
public function writeSession ( $ id , $ data ) { 
public function destroySession ( $ id ) { $ this -> db -> createCommand ( ) -> delete ( $ this -> sessionTable , [ 'id' => $ id ] ) -> execute ( ) ; return true ; } 
public function gcSession ( $ maxLifetime ) { $ this -> db -> createCommand ( ) -> delete ( $ this -> sessionTable , '[[expire]]<:expire' , [ ':expire' => time ( ) ] ) -> execute ( ) ; return true ; } 
public function bindColumn ( $ column , & $ value , $ dataType = null ) { if ( $ dataType === null ) { $ this -> _statement -> bindColumn ( $ column , $ value ) ; } else { $ this -> _statement -> bindColumn ( $ column , $ value , $ dataType ) ; } } 
public function rewind ( ) { if ( $ this -> _index < 0 ) { $ this -> _row = $ this -> _statement -> fetch ( ) ; $ this -> _index = 0 ; } else { throw new InvalidCallException ( 'DataReader cannot rewind. It is a forward-only reader.' ) ; } } 
public function build ( ExpressionInterface $ expression , array & $ params = [ ] ) { $ operator = $ expression -> getOperator ( ) ; $ startColumn = $ this -> escapeColumnName ( $ expression -> getIntervalStartColumn ( ) , $ params ) ; $ endColumn = $ this -> escapeColumnName ( $ expression -> getIntervalEndColumn ( ) , $ params ) ; $ value = $ this -> createPlaceholder ( $ expression -> getValue ( ) , $ params ) ; return "$value $operator $startColumn AND $endColumn" ; } 
protected function escapeColumnName ( $ columnName , & $ params = [ ] ) { if ( $ columnName instanceof Query ) { list ( $ sql , $ params ) = $ this -> queryBuilder -> build ( $ columnName , $ params ) ; return "($sql)" ; } elseif ( $ columnName instanceof ExpressionInterface ) { return $ this -> queryBuilder -> buildExpression ( $ columnName , $ params ) ; } elseif ( strpos ( $ columnName , '(' ) === false ) { return $ this -> queryBuilder -> db -> quoteColumnName ( $ columnName ) ; } return $ columnName ; } 
protected function createPlaceholder ( $ value , & $ params ) { if ( $ value instanceof ExpressionInterface ) { return $ this -> queryBuilder -> buildExpression ( $ value , $ params ) ; } return $ this -> queryBuilder -> bindParam ( $ value , $ params ) ; } 
public function init ( ) { parent :: init ( ) ; foreach ( $ this -> targets as $ name => $ target ) { if ( ! $ target instanceof Target ) { $ this -> targets [ $ name ] = Yii :: createObject ( $ target ) ; } } } 
public function getLogger ( ) { if ( $ this -> _logger === null ) { $ this -> setLogger ( Yii :: getLogger ( ) ) ; } return $ this -> _logger ; } 
public function setLogger ( $ value ) { if ( is_string ( $ value ) || is_array ( $ value ) ) { $ value = Yii :: createObject ( $ value ) ; } $ this -> _logger = $ value ; $ this -> _logger -> dispatcher = $ this ; } 
public function dispatch ( $ messages , $ final ) { $ targetErrors = [ ] ; foreach ( $ this -> targets as $ target ) { if ( $ target -> enabled ) { try { $ target -> collect ( $ messages , $ final ) ; } catch ( \ Exception $ e ) { $ target -> enabled = false ; $ targetErrors [ ] = [ 'Unable to send log via ' . get_class ( $ target ) . ': ' . ErrorHandler :: convertExceptionToVerboseString ( $ e ) , Logger :: LEVEL_WARNING , __METHOD__ , microtime ( true ) , [ ] , ] ; } } } if ( ! empty ( $ targetErrors ) ) { $ this -> dispatch ( $ targetErrors , true ) ; } } 
protected function loadMessages ( $ category , $ language ) { if ( $ this -> enableCaching ) { $ key = [ __CLASS__ , $ category , $ language , ] ; $ messages = $ this -> cache -> get ( $ key ) ; if ( $ messages === false ) { $ messages = $ this -> loadMessagesFromDb ( $ category , $ language ) ; $ this -> cache -> set ( $ key , $ messages , $ this -> cachingDuration ) ; } return $ messages ; } return $ this -> loadMessagesFromDb ( $ category , $ language ) ; } 
protected function loadMessagesFromDb ( $ category , $ language ) { $ mainQuery = ( new Query ( ) ) -> select ( [ 'message' => 't1.message' , 'translation' => 't2.translation' ] ) -> from ( [ 't1' => $ this -> sourceMessageTable , 't2' => $ this -> messageTable ] ) -> where ( [ 't1.id' => new Expression ( '[[t2.id]]' ) , 't1.category' => $ category , 't2.language' => $ language , ] ) ; $ fallbackLanguage = substr ( $ language , 0 , 2 ) ; $ fallbackSourceLanguage = substr ( $ this -> sourceLanguage , 0 , 2 ) ; if ( $ fallbackLanguage !== $ language ) { $ mainQuery -> union ( $ this -> createFallbackQuery ( $ category , $ language , $ fallbackLanguage ) , true ) ; } elseif ( $ language === $ fallbackSourceLanguage ) { $ mainQuery -> union ( $ this -> createFallbackQuery ( $ category , $ language , $ fallbackSourceLanguage ) , true ) ; } $ messages = $ mainQuery -> createCommand ( $ this -> db ) -> queryAll ( ) ; return ArrayHelper :: map ( $ messages , 'message' , 'translation' ) ; } 
protected function createFallbackQuery ( $ category , $ language , $ fallbackLanguage ) { return ( new Query ( ) ) -> select ( [ 'message' => 't1.message' , 'translation' => 't2.translation' ] ) -> from ( [ 't1' => $ this -> sourceMessageTable , 't2' => $ this -> messageTable ] ) -> where ( [ 't1.id' => new Expression ( '[[t2.id]]' ) , 't1.category' => $ category , 't2.language' => $ fallbackLanguage , ] ) -> andWhere ( [ 'NOT IN' , 't2.id' , ( new Query ( ) ) -> select ( '[[id]]' ) -> from ( $ this -> messageTable ) -> where ( [ 'language' => $ language ] ) , ] ) ; } 
public function collect ( $ messages , $ final ) { $ this -> messages = array_merge ( $ this -> messages , static :: filterMessages ( $ messages , $ this -> getLevels ( ) , $ this -> categories , $ this -> except ) ) ; $ count = count ( $ this -> messages ) ; if ( $ count > 0 && ( $ final || $ this -> exportInterval > 0 && $ count >= $ this -> exportInterval ) ) { if ( ( $ context = $ this -> getContextMessage ( ) ) !== '' ) { $ this -> messages [ ] = [ $ context , Logger :: LEVEL_INFO , 'application' , YII_BEGIN_TIME ] ; } 
protected function getContextMessage ( ) { $ context = ArrayHelper :: filter ( $ GLOBALS , $ this -> logVars ) ; foreach ( $ this -> maskVars as $ var ) { if ( ArrayHelper :: getValue ( $ context , $ var ) !== null ) { ArrayHelper :: setValue ( $ context , $ var , '***' ) ; } } $ result = [ ] ; foreach ( $ context as $ key => $ value ) { $ result [ ] = "\${$key} = " . VarDumper :: dumpAsString ( $ value ) ; } return implode ( "\n\n" , $ result ) ; } 
public function formatMessage ( $ message ) { list ( $ text , $ level , $ category , $ timestamp ) = $ message ; $ level = Logger :: getLevelName ( $ level ) ; if ( ! is_string ( $ text ) ) { 
public function getMessagePrefix ( $ message ) { if ( $ this -> prefix !== null ) { return call_user_func ( $ this -> prefix , $ message ) ; } if ( Yii :: $ app === null ) { return '' ; } $ request = Yii :: $ app -> getRequest ( ) ; $ ip = $ request instanceof Request ? $ request -> getUserIP ( ) : '-' ; $ user = Yii :: $ app -> has ( 'user' , true ) ? Yii :: $ app -> get ( 'user' ) : null ; if ( $ user && ( $ identity = $ user -> getIdentity ( false ) ) ) { $ userID = $ identity -> getId ( ) ; } else { $ userID = '-' ; } $ session = Yii :: $ app -> has ( 'session' , true ) ? Yii :: $ app -> get ( 'session' ) : null ; $ sessionID = $ session && $ session -> getIsActive ( ) ? $ session -> getId ( ) : '-' ; return "[$ip][$userID][$sessionID]" ; } 
public function getEnabled ( ) { if ( is_callable ( $ this -> _enabled ) ) { return call_user_func ( $ this -> _enabled , $ this ) ; } return $ this -> _enabled ; } 
protected function getTime ( $ timestamp ) { $ parts = explode ( '.' , sprintf ( '%F' , $ timestamp ) ) ; return date ( 'Y-m-d H:i:s' , $ parts [ 0 ] ) . ( $ this -> microtime ? ( '.' . $ parts [ 1 ] ) : '' ) ; } 
protected function renderSeparator ( $ spanLeft , $ spanMid , $ spanMidMid , $ spanRight ) { $ separator = $ spanLeft ; foreach ( $ this -> _columnWidths as $ index => $ rowSize ) { if ( $ index !== 0 ) { $ separator .= $ spanMid ; } $ separator .= str_repeat ( $ spanMidMid , $ rowSize ) ; } $ separator .= $ spanRight . "\n" ; return $ separator ; } 
public function asJson ( $ data ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> format = Response :: FORMAT_JSON ; $ response -> data = $ data ; return $ response ; } 
public function asXml ( $ data ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> format = Response :: FORMAT_XML ; $ response -> data = $ data ; return $ response ; } 
public function bindActionParams ( $ action , $ params ) { if ( $ action instanceof InlineAction ) { $ method = new \ ReflectionMethod ( $ this , $ action -> actionMethod ) ; } else { $ method = new \ ReflectionMethod ( $ action , 'run' ) ; } $ args = [ ] ; $ missing = [ ] ; $ actionParams = [ ] ; foreach ( $ method -> getParameters ( ) as $ param ) { $ name = $ param -> getName ( ) ; if ( array_key_exists ( $ name , $ params ) ) { if ( $ param -> isArray ( ) ) { $ args [ ] = $ actionParams [ $ name ] = ( array ) $ params [ $ name ] ; } elseif ( ! is_array ( $ params [ $ name ] ) ) { $ args [ ] = $ actionParams [ $ name ] = $ params [ $ name ] ; } else { throw new BadRequestHttpException ( Yii :: t ( 'yii' , 'Invalid data received for parameter "{param}".' , [ 'param' => $ name , ] ) ) ; } unset ( $ params [ $ name ] ) ; } elseif ( $ param -> isDefaultValueAvailable ( ) ) { $ args [ ] = $ actionParams [ $ name ] = $ param -> getDefaultValue ( ) ; } else { $ missing [ ] = $ name ; } } if ( ! empty ( $ missing ) ) { throw new BadRequestHttpException ( Yii :: t ( 'yii' , 'Missing required parameters: {params}' , [ 'params' => implode ( ', ' , $ missing ) , ] ) ) ; } $ this -> actionParams = $ actionParams ; return $ args ; } 
public function beforeAction ( $ action ) { if ( parent :: beforeAction ( $ action ) ) { if ( $ this -> enableCsrfValidation && Yii :: $ app -> getErrorHandler ( ) -> exception === null && ! Yii :: $ app -> getRequest ( ) -> validateCsrfToken ( ) ) { throw new BadRequestHttpException ( Yii :: t ( 'yii' , 'Unable to verify your data submission.' ) ) ; } return true ; } return false ; } 
public function refresh ( $ anchor = '' ) { return Yii :: $ app -> getResponse ( ) -> redirect ( Yii :: $ app -> getRequest ( ) -> getUrl ( ) . $ anchor ) ; } 
public function attach ( $ owner ) { $ this -> owner = $ owner ; foreach ( $ this -> events ( ) as $ event => $ handler ) { $ owner -> on ( $ event , is_string ( $ handler ) ? [ $ this , $ handler ] : $ handler ) ; } } 
public function detach ( ) { if ( $ this -> owner ) { foreach ( $ this -> events ( ) as $ event => $ handler ) { $ this -> owner -> off ( $ event , is_string ( $ handler ) ? [ $ this , $ handler ] : $ handler ) ; } $ this -> owner = null ; } } 
public function init ( ) { if ( $ this -> pattern === null ) { throw new InvalidConfigException ( 'UrlRule::pattern must be set.' ) ; } if ( $ this -> route === null ) { throw new InvalidConfigException ( 'UrlRule::route must be set.' ) ; } if ( is_array ( $ this -> normalizer ) ) { $ normalizerConfig = array_merge ( [ 'class' => UrlNormalizer :: className ( ) ] , $ this -> normalizer ) ; $ this -> normalizer = Yii :: createObject ( $ normalizerConfig ) ; } if ( $ this -> normalizer !== null && $ this -> normalizer !== false && ! $ this -> normalizer instanceof UrlNormalizer ) { throw new InvalidConfigException ( 'Invalid config for UrlRule::normalizer.' ) ; } if ( $ this -> verb !== null ) { if ( is_array ( $ this -> verb ) ) { foreach ( $ this -> verb as $ i => $ verb ) { $ this -> verb [ $ i ] = strtoupper ( $ verb ) ; } } else { $ this -> verb = [ strtoupper ( $ this -> verb ) ] ; } } if ( $ this -> name === null ) { $ this -> name = $ this -> pattern ; } $ this -> preparePattern ( ) ; } 
private function preparePattern ( ) { $ this -> pattern = $ this -> trimSlashes ( $ this -> pattern ) ; $ this -> route = trim ( $ this -> route , '/' ) ; if ( $ this -> host !== null ) { $ this -> host = rtrim ( $ this -> host , '/' ) ; $ this -> pattern = rtrim ( $ this -> host . '/' . $ this -> pattern , '/' ) ; } elseif ( $ this -> pattern === '' ) { $ this -> _template = '' ; $ this -> pattern = '#^$#u' ; return ; } elseif ( ( $ pos = strpos ( $ this -> pattern , '://' ) ) !== false ) { if ( ( $ pos2 = strpos ( $ this -> pattern , '/' , $ pos + 3 ) ) !== false ) { $ this -> host = substr ( $ this -> pattern , 0 , $ pos2 ) ; } else { $ this -> host = $ this -> pattern ; } } elseif ( strncmp ( $ this -> pattern , '//' , 2 ) === 0 ) { if ( ( $ pos2 = strpos ( $ this -> pattern , '/' , 2 ) ) !== false ) { $ this -> host = substr ( $ this -> pattern , 0 , $ pos2 ) ; } else { $ this -> host = $ this -> pattern ; } } else { $ this -> pattern = '/' . $ this -> pattern . '/' ; } if ( strpos ( $ this -> route , '<' ) !== false && preg_match_all ( '/<([\w._-]+)>/' , $ this -> route , $ matches ) ) { foreach ( $ matches [ 1 ] as $ name ) { $ this -> _routeParams [ $ name ] = "<$name>" ; } } $ this -> translatePattern ( true ) ; } 
private function translatePattern ( $ allowAppendSlash ) { $ tr = [ '.' => '\\.' , '*' => '\\*' , '$' => '\\$' , '[' => '\\[' , ']' => '\\]' , '(' => '\\(' , ')' => '\\)' , ] ; $ tr2 = [ ] ; $ requiredPatternPart = $ this -> pattern ; $ oldOffset = 0 ; if ( preg_match_all ( '/<([\w._-]+):?([^>]+)?>/' , $ this -> pattern , $ matches , PREG_OFFSET_CAPTURE | PREG_SET_ORDER ) ) { $ appendSlash = false ; foreach ( $ matches as $ match ) { $ name = $ match [ 1 ] [ 0 ] ; $ pattern = isset ( $ match [ 2 ] [ 0 ] ) ? $ match [ 2 ] [ 0 ] : '[^\/]+' ; $ placeholder = 'a' . hash ( 'crc32b' , $ name ) ; 
public function parseRequest ( $ manager , $ request ) { if ( $ this -> mode === self :: CREATION_ONLY ) { return false ; } if ( ! empty ( $ this -> verb ) && ! in_array ( $ request -> getMethod ( ) , $ this -> verb , true ) ) { return false ; } $ suffix = ( string ) ( $ this -> suffix === null ? $ manager -> suffix : $ this -> suffix ) ; $ pathInfo = $ request -> getPathInfo ( ) ; $ normalized = false ; if ( $ this -> hasNormalizer ( $ manager ) ) { $ pathInfo = $ this -> getNormalizer ( $ manager ) -> normalizePathInfo ( $ pathInfo , $ suffix , $ normalized ) ; } if ( $ suffix !== '' && $ pathInfo !== '' ) { $ n = strlen ( $ suffix ) ; if ( substr_compare ( $ pathInfo , $ suffix , - $ n , $ n ) === 0 ) { $ pathInfo = substr ( $ pathInfo , 0 , - $ n ) ; if ( $ pathInfo === '' ) { 
public function createUrl ( $ manager , $ route , $ params ) { if ( $ this -> mode === self :: PARSING_ONLY ) { $ this -> createStatus = self :: CREATE_STATUS_PARSING_ONLY ; return false ; } $ tr = [ ] ; 
protected function substitutePlaceholderNames ( array $ matches ) { foreach ( $ this -> placeholders as $ placeholder => $ name ) { if ( isset ( $ matches [ $ placeholder ] ) ) { $ matches [ $ name ] = $ matches [ $ placeholder ] ; unset ( $ matches [ $ placeholder ] ) ; } } return $ matches ; } 
public function renderDataCell ( $ model , $ key , $ index ) { if ( $ this -> contentOptions instanceof Closure ) { $ options = call_user_func ( $ this -> contentOptions , $ model , $ key , $ index , $ this ) ; } else { $ options = $ this -> contentOptions ; } return Html :: tag ( 'td' , $ this -> renderDataCellContent ( $ model , $ key , $ index ) , $ options ) ; } 
protected function renderDataCellContent ( $ model , $ key , $ index ) { if ( $ this -> content !== null ) { return call_user_func ( $ this -> content , $ model , $ key , $ index , $ this ) ; } return $ this -> grid -> emptyCell ; } 
private function printHelpMessage ( ) { $ this -> stdout ( $ this -> getHelpSummary ( ) . "\n" ) ; $ helpCommand = Console :: ansiFormat ( 'yii help fixture' , [ Console :: FG_CYAN ] ) ; $ this -> stdout ( "Use $helpCommand to get usage info.\n" ) ; } 
public function notifyNothingToUnload ( $ foundFixtures , $ except ) { $ this -> stdout ( "Fixtures to unload could not be found according to given conditions:\n\n" , Console :: FG_RED ) ; $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n" , Console :: FG_GREEN ) ; if ( count ( $ foundFixtures ) ) { $ this -> stdout ( "\nFixtures found under the namespace:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ foundFixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be unloaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } } 
private function notifyUnloaded ( $ fixtures ) { $ this -> stdout ( "\nFixtures were successfully unloaded from namespace: " , Console :: FG_YELLOW ) ; $ this -> stdout ( Yii :: getAlias ( $ this -> namespace ) . "\"\n\n" , Console :: FG_GREEN ) ; $ this -> outputList ( $ fixtures ) ; } 
private function notifyNotFound ( $ fixtures ) { $ this -> stdout ( "Some fixtures were not found under path:\n" , Console :: BG_RED ) ; $ this -> stdout ( "\t" . $ this -> getFixturePath ( ) . "\n\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "Check that they have correct namespace \"{$this->namespace}\" \n" , Console :: BG_RED ) ; $ this -> outputList ( $ fixtures ) ; $ this -> stdout ( "\n" ) ; } 
private function confirmLoad ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be loaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be loaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } $ this -> stdout ( "\nBe aware that:\n" , Console :: BOLD ) ; $ this -> stdout ( "Applying leads to purging of certain data in the database!\n" , Console :: FG_RED ) ; return $ this -> confirm ( "\nLoad above fixtures?" ) ; } 
private function confirmUnload ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be unloaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be unloaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } return $ this -> confirm ( "\nUnload fixtures?" ) ; } 
private function outputList ( $ data ) { foreach ( $ data as $ index => $ item ) { $ this -> stdout ( "\t" . ( $ index + 1 ) . ". {$item}\n" , Console :: FG_GREEN ) ; } } 
private function findFixtures ( array $ fixtures = [ ] ) { $ fixturesPath = $ this -> getFixturePath ( ) ; $ filesToSearch = [ '*Fixture.php' ] ; $ findAll = ( $ fixtures === [ ] ) ; if ( ! $ findAll ) { $ filesToSearch = [ ] ; foreach ( $ fixtures as $ fileName ) { $ filesToSearch [ ] = $ fileName . 'Fixture.php' ; } } $ files = FileHelper :: findFiles ( $ fixturesPath , [ 'only' => $ filesToSearch ] ) ; $ foundFixtures = [ ] ; foreach ( $ files as $ fixture ) { $ foundFixtures [ ] = $ this -> getFixtureRelativeName ( $ fixture ) ; } return $ foundFixtures ; } 
private function getFixtureRelativeName ( $ fullFixturePath ) { $ fixturesPath = FileHelper :: normalizePath ( $ this -> getFixturePath ( ) ) ; $ fullFixturePath = FileHelper :: normalizePath ( $ fullFixturePath ) ; $ relativeName = substr ( $ fullFixturePath , strlen ( $ fixturesPath ) + 1 ) ; $ relativeDir = dirname ( $ relativeName ) === '.' ? '' : dirname ( $ relativeName ) . DIRECTORY_SEPARATOR ; return $ relativeDir . basename ( $ fullFixturePath , 'Fixture.php' ) ; } 
private function getFixturesConfig ( $ fixtures ) { $ config = [ ] ; foreach ( $ fixtures as $ fixture ) { $ isNamespaced = ( strpos ( $ fixture , '\\' ) !== false ) ; 
private function filterFixtures ( $ fixtures ) { $ filtered = [ 'apply' => [ ] , 'except' => [ ] , ] ; foreach ( $ fixtures as $ fixture ) { if ( mb_strpos ( $ fixture , '-' ) !== false ) { $ filtered [ 'except' ] [ ] = str_replace ( '-' , '' , $ fixture ) ; } else { $ filtered [ 'apply' ] [ ] = $ fixture ; } } return $ filtered ; } 
public function build ( ExpressionInterface $ expression , array & $ params = [ ] ) { if ( ! isset ( $ this -> escapingReplacements [ '\\' ] ) ) { $ this -> escapingReplacements [ '\\' ] = substr ( $ this -> queryBuilder -> db -> quoteValue ( '\\' ) , 1 , - 1 ) ; } return parent :: build ( $ expression , $ params ) ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> enableIDN && ! function_exists ( 'idn_to_ascii' ) ) { throw new InvalidConfigException ( 'In order to use IDN validation intl extension must be installed and enabled.' ) ; } if ( $ this -> message === null ) { $ this -> message = Yii :: t ( 'yii' , '{attribute} is not a valid URL.' ) ; } } 
public function validateAttribute ( $ model , $ attribute ) { $ value = $ model -> $ attribute ; $ result = $ this -> validateValue ( $ value ) ; if ( ! empty ( $ result ) ) { $ this -> addError ( $ model , $ attribute , $ result [ 0 ] , $ result [ 1 ] ) ; } elseif ( $ this -> defaultScheme !== null && strpos ( $ value , '://' ) === false ) { $ model -> $ attribute = $ this -> defaultScheme . '://' . $ value ; } } 
public function getClientOptions ( $ model , $ attribute ) { if ( strpos ( $ this -> pattern , '{schemes}' ) !== false ) { $ pattern = str_replace ( '{schemes}' , '(' . implode ( '|' , $ this -> validSchemes ) . ')' , $ this -> pattern ) ; } else { $ pattern = $ this -> pattern ; } $ options = [ 'pattern' => new JsExpression ( $ pattern ) , 'message' => $ this -> formatMessage ( $ this -> message , [ 'attribute' => $ model -> getAttributeLabel ( $ attribute ) , ] ) , 'enableIDN' => ( bool ) $ this -> enableIDN , ] ; if ( $ this -> skipOnEmpty ) { $ options [ 'skipOnEmpty' ] = 1 ; } if ( $ this -> defaultScheme !== null ) { $ options [ 'defaultScheme' ] = $ this -> defaultScheme ; } return $ options ; } 
protected function renderDataCellContent ( $ model , $ key , $ index ) { if ( $ this -> content !== null ) { return parent :: renderDataCellContent ( $ model , $ key , $ index ) ; } if ( $ this -> radioOptions instanceof Closure ) { $ options = call_user_func ( $ this -> radioOptions , $ model , $ key , $ index , $ this ) ; } else { $ options = $ this -> radioOptions ; if ( ! isset ( $ options [ 'value' ] ) ) { $ options [ 'value' ] = is_array ( $ key ) ? json_encode ( $ key , JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ) : $ key ; } } $ checked = isset ( $ options [ 'checked' ] ) ? $ options [ 'checked' ] : false ; return Html :: radio ( $ this -> name , $ checked , $ options ) ; } 
public function get ( $ name , $ default = null , $ first = true ) { $ name = strtolower ( $ name ) ; if ( isset ( $ this -> _headers [ $ name ] ) ) { return $ first ? reset ( $ this -> _headers [ $ name ] ) : $ this -> _headers [ $ name ] ; } return $ default ; } 
public function set ( $ name , $ value = '' ) { $ name = strtolower ( $ name ) ; $ this -> _headers [ $ name ] = ( array ) $ value ; return $ this ; } 
public function add ( $ name , $ value ) { $ name = strtolower ( $ name ) ; $ this -> _headers [ $ name ] [ ] = $ value ; return $ this ; } 
public function setDefault ( $ name , $ value ) { $ name = strtolower ( $ name ) ; if ( empty ( $ this -> _headers [ $ name ] ) ) { $ this -> _headers [ $ name ] [ ] = $ value ; } return $ this ; } 
public function remove ( $ name ) { $ name = strtolower ( $ name ) ; if ( isset ( $ this -> _headers [ $ name ] ) ) { $ value = $ this -> _headers [ $ name ] ; unset ( $ this -> _headers [ $ name ] ) ; return $ value ; } return null ; } 
public function negotiate ( ) { $ request = $ this -> request ? : Yii :: $ app -> getRequest ( ) ; $ response = $ this -> response ? : Yii :: $ app -> getResponse ( ) ; if ( ! empty ( $ this -> formats ) ) { if ( \ count ( $ this -> formats ) > 1 ) { $ response -> getHeaders ( ) -> add ( 'Vary' , 'Accept' ) ; } $ this -> negotiateContentType ( $ request , $ response ) ; } if ( ! empty ( $ this -> languages ) ) { if ( \ count ( $ this -> languages ) > 1 ) { $ response -> getHeaders ( ) -> add ( 'Vary' , 'Accept-Language' ) ; } Yii :: $ app -> language = $ this -> negotiateLanguage ( $ request ) ; } } 
protected function negotiateLanguage ( $ request ) { if ( ! empty ( $ this -> languageParam ) && ( $ language = $ request -> get ( $ this -> languageParam ) ) !== null ) { if ( is_array ( $ language ) ) { 
protected function isLanguageSupported ( $ requested , $ supported ) { $ supported = str_replace ( '_' , '-' , strtolower ( $ supported ) ) ; $ requested = str_replace ( '_' , '-' , strtolower ( $ requested ) ) ; return strpos ( $ requested . '-' , $ supported . '-' ) === 0 ; } 
protected static function findByCondition ( $ condition ) { $ query = static :: find ( ) ; if ( ! ArrayHelper :: isAssociative ( $ condition ) ) { 
public function __isset ( $ name ) { try { return $ this -> __get ( $ name ) !== null ; } catch ( \ Throwable $ t ) { return false ; } catch ( \ Exception $ e ) { return false ; } } 
protected function createRelationQuery ( $ class , $ link , $ multiple ) { $ query = $ class :: find ( ) ; $ query -> primaryModel = $ this ; $ query -> link = $ link ; $ query -> multiple = $ multiple ; return $ query ; } 
public function populateRelation ( $ name , $ records ) { foreach ( $ this -> _relationsDependencies as & $ relationNames ) { unset ( $ relationNames [ $ name ] ) ; } $ this -> _related [ $ name ] = $ records ; } 
public function hasAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) || in_array ( $ name , $ this -> attributes ( ) , true ) ; } 
public function getAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) ? $ this -> _attributes [ $ name ] : null ; } 
public function setAttribute ( $ name , $ value ) { if ( $ this -> hasAttribute ( $ name ) ) { if ( ! empty ( $ this -> _relationsDependencies [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _attributes ) || $ this -> _attributes [ $ name ] !== $ value ) ) { $ this -> resetDependentRelations ( $ name ) ; } $ this -> _attributes [ $ name ] = $ value ; } else { throw new InvalidArgumentException ( get_class ( $ this ) . ' has no attribute named "' . $ name . '".' ) ; } } 
public function getOldAttribute ( $ name ) { return isset ( $ this -> _oldAttributes [ $ name ] ) ? $ this -> _oldAttributes [ $ name ] : null ; } 
public function isAttributeChanged ( $ name , $ identical = true ) { if ( isset ( $ this -> _attributes [ $ name ] , $ this -> _oldAttributes [ $ name ] ) ) { if ( $ identical ) { return $ this -> _attributes [ $ name ] !== $ this -> _oldAttributes [ $ name ] ; } return $ this -> _attributes [ $ name ] != $ this -> _oldAttributes [ $ name ] ; } return isset ( $ this -> _attributes [ $ name ] ) || isset ( $ this -> _oldAttributes [ $ name ] ) ; } 
public function getDirtyAttributes ( $ names = null ) { if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } $ names = array_flip ( $ names ) ; $ attributes = [ ] ; if ( $ this -> _oldAttributes === null ) { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } else { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _oldAttributes ) || $ value !== $ this -> _oldAttributes [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } return $ attributes ; } 
public function updateAttributes ( $ attributes ) { $ attrs = [ ] ; foreach ( $ attributes as $ name => $ value ) { if ( is_int ( $ name ) ) { $ attrs [ ] = $ value ; } else { $ this -> $ name = $ value ; $ attrs [ ] = $ name ; } } $ values = $ this -> getDirtyAttributes ( $ attrs ) ; if ( empty ( $ values ) || $ this -> getIsNewRecord ( ) ) { return 0 ; } $ rows = static :: updateAll ( $ values , $ this -> getOldPrimaryKey ( true ) ) ; foreach ( $ values as $ name => $ value ) { $ this -> _oldAttributes [ $ name ] = $ this -> _attributes [ $ name ] ; } return $ rows ; } 
public function updateCounters ( $ counters ) { if ( static :: updateAllCounters ( $ counters , $ this -> getOldPrimaryKey ( true ) ) > 0 ) { foreach ( $ counters as $ name => $ value ) { if ( ! isset ( $ this -> _attributes [ $ name ] ) ) { $ this -> _attributes [ $ name ] = $ value ; } else { $ this -> _attributes [ $ name ] += $ value ; } $ this -> _oldAttributes [ $ name ] = $ this -> _attributes [ $ name ] ; } return true ; } return false ; } 
public function beforeSave ( $ insert ) { $ event = new ModelEvent ( ) ; $ this -> trigger ( $ insert ? self :: EVENT_BEFORE_INSERT : self :: EVENT_BEFORE_UPDATE , $ event ) ; return $ event -> isValid ; } 
protected function refreshInternal ( $ record ) { if ( $ record === null ) { return false ; } foreach ( $ this -> attributes ( ) as $ name ) { $ this -> _attributes [ $ name ] = isset ( $ record -> _attributes [ $ name ] ) ? $ record -> _attributes [ $ name ] : null ; } $ this -> _oldAttributes = $ record -> _oldAttributes ; $ this -> _related = [ ] ; $ this -> _relationsDependencies = [ ] ; $ this -> afterRefresh ( ) ; return true ; } 
public function equals ( $ record ) { if ( $ this -> getIsNewRecord ( ) || $ record -> getIsNewRecord ( ) ) { return false ; } return get_class ( $ this ) === get_class ( $ record ) && $ this -> getPrimaryKey ( ) === $ record -> getPrimaryKey ( ) ; } 
public function getPrimaryKey ( $ asArray = false ) { $ keys = $ this -> primaryKey ( ) ; if ( ! $ asArray && count ( $ keys ) === 1 ) { return isset ( $ this -> _attributes [ $ keys [ 0 ] ] ) ? $ this -> _attributes [ $ keys [ 0 ] ] : null ; } $ values = [ ] ; foreach ( $ keys as $ name ) { $ values [ $ name ] = isset ( $ this -> _attributes [ $ name ] ) ? $ this -> _attributes [ $ name ] : null ; } return $ values ; } 
public function getOldPrimaryKey ( $ asArray = false ) { $ keys = $ this -> primaryKey ( ) ; if ( empty ( $ keys ) ) { throw new Exception ( get_class ( $ this ) . ' does not have a primary key. You should either define a primary key for the corresponding table or override the primaryKey() method.' ) ; } if ( ! $ asArray && count ( $ keys ) === 1 ) { return isset ( $ this -> _oldAttributes [ $ keys [ 0 ] ] ) ? $ this -> _oldAttributes [ $ keys [ 0 ] ] : null ; } $ values = [ ] ; foreach ( $ keys as $ name ) { $ values [ $ name ] = isset ( $ this -> _oldAttributes [ $ name ] ) ? $ this -> _oldAttributes [ $ name ] : null ; } return $ values ; } 
public static function populateRecord ( $ record , $ row ) { $ columns = array_flip ( $ record -> attributes ( ) ) ; foreach ( $ row as $ name => $ value ) { if ( isset ( $ columns [ $ name ] ) ) { $ record -> _attributes [ $ name ] = $ value ; } elseif ( $ record -> canSetProperty ( $ name ) ) { $ record -> $ name = $ value ; } } $ record -> _oldAttributes = $ record -> _attributes ; $ record -> _related = [ ] ; $ record -> _relationsDependencies = [ ] ; } 
public function getRelation ( $ name , $ throwException = true ) { $ getter = 'get' . $ name ; try { 
public function link ( $ name , $ model , $ extraColumns = [ ] ) { $ relation = $ this -> getRelation ( $ name ) ; if ( $ relation -> via !== null ) { if ( $ this -> getIsNewRecord ( ) || $ model -> getIsNewRecord ( ) ) { throw new InvalidCallException ( 'Unable to link models: the models being linked cannot be newly created.' ) ; } if ( is_array ( $ relation -> via ) ) { list ( $ viaName , $ viaRelation ) = $ relation -> via ; $ viaClass = $ viaRelation -> modelClass ; 
public function unlink ( $ name , $ model , $ delete = false ) { $ relation = $ this -> getRelation ( $ name ) ; if ( $ relation -> via !== null ) { if ( is_array ( $ relation -> via ) ) { list ( $ viaName , $ viaRelation ) = $ relation -> via ; $ viaClass = $ viaRelation -> modelClass ; unset ( $ this -> _related [ $ viaName ] ) ; } else { $ viaRelation = $ relation -> via ; $ viaTable = reset ( $ relation -> via -> from ) ; } $ columns = [ ] ; foreach ( $ viaRelation -> link as $ a => $ b ) { $ columns [ $ a ] = $ this -> $ b ; } foreach ( $ relation -> link as $ a => $ b ) { $ columns [ $ b ] = $ model -> $ a ; } $ nulls = [ ] ; foreach ( array_keys ( $ columns ) as $ a ) { $ nulls [ $ a ] = null ; } if ( is_array ( $ relation -> via ) ) { if ( $ delete ) { $ viaClass :: deleteAll ( $ columns ) ; } else { $ viaClass :: updateAll ( $ nulls , $ columns ) ; } } else { $ command = static :: getDb ( ) -> createCommand ( ) ; if ( $ delete ) { $ command -> delete ( $ viaTable , $ columns ) -> execute ( ) ; } else { $ command -> update ( $ viaTable , $ nulls , $ columns ) -> execute ( ) ; } } } else { $ p1 = $ model -> isPrimaryKey ( array_keys ( $ relation -> link ) ) ; $ p2 = static :: isPrimaryKey ( array_values ( $ relation -> link ) ) ; if ( $ p2 ) { if ( $ delete ) { $ model -> delete ( ) ; } else { foreach ( $ relation -> link as $ a => $ b ) { $ model -> $ a = null ; } $ model -> save ( false ) ; } } elseif ( $ p1 ) { foreach ( $ relation -> link as $ a => $ b ) { if ( is_array ( $ this -> $ b ) ) { 
public function unlinkAll ( $ name , $ delete = false ) { $ relation = $ this -> getRelation ( $ name ) ; if ( $ relation -> via !== null ) { if ( is_array ( $ relation -> via ) ) { list ( $ viaName , $ viaRelation ) = $ relation -> via ; $ viaClass = $ viaRelation -> modelClass ; unset ( $ this -> _related [ $ viaName ] ) ; } else { $ viaRelation = $ relation -> via ; $ viaTable = reset ( $ relation -> via -> from ) ; } $ condition = [ ] ; $ nulls = [ ] ; foreach ( $ viaRelation -> link as $ a => $ b ) { $ nulls [ $ a ] = null ; $ condition [ $ a ] = $ this -> $ b ; } if ( ! empty ( $ viaRelation -> where ) ) { $ condition = [ 'and' , $ condition , $ viaRelation -> where ] ; } if ( ! empty ( $ viaRelation -> on ) ) { $ condition = [ 'and' , $ condition , $ viaRelation -> on ] ; } if ( is_array ( $ relation -> via ) ) { if ( $ delete ) { $ viaClass :: deleteAll ( $ condition ) ; } else { $ viaClass :: updateAll ( $ nulls , $ condition ) ; } } else { $ command = static :: getDb ( ) -> createCommand ( ) ; if ( $ delete ) { $ command -> delete ( $ viaTable , $ condition ) -> execute ( ) ; } else { $ command -> update ( $ viaTable , $ nulls , $ condition ) -> execute ( ) ; } } } else { $ relatedModel = $ relation -> modelClass ; if ( ! $ delete && count ( $ relation -> link ) === 1 && is_array ( $ this -> { $ b = reset ( $ relation -> link ) } ) ) { 
public static function isPrimaryKey ( $ keys ) { $ pks = static :: primaryKey ( ) ; if ( count ( $ keys ) === count ( $ pks ) ) { return count ( array_intersect ( $ keys , $ pks ) ) === count ( $ pks ) ; } return false ; } 
public function getAttributeLabel ( $ attribute ) { $ labels = $ this -> attributeLabels ( ) ; if ( isset ( $ labels [ $ attribute ] ) ) { return $ labels [ $ attribute ] ; } elseif ( strpos ( $ attribute , '.' ) ) { $ attributeParts = explode ( '.' , $ attribute ) ; $ neededAttribute = array_pop ( $ attributeParts ) ; $ relatedModel = $ this ; foreach ( $ attributeParts as $ relationName ) { if ( $ relatedModel -> isRelationPopulated ( $ relationName ) && $ relatedModel -> $ relationName instanceof self ) { $ relatedModel = $ relatedModel -> $ relationName ; } else { try { $ relation = $ relatedModel -> getRelation ( $ relationName ) ; } catch ( InvalidParamException $ e ) { return $ this -> generateAttributeLabel ( $ attribute ) ; } $ modelClass = $ relation -> modelClass ; $ relatedModel = $ modelClass :: instance ( ) ; } } $ labels = $ relatedModel -> attributeLabels ( ) ; if ( isset ( $ labels [ $ neededAttribute ] ) ) { return $ labels [ $ neededAttribute ] ; } } return $ this -> generateAttributeLabel ( $ attribute ) ; } 
public function getAttributeHint ( $ attribute ) { $ hints = $ this -> attributeHints ( ) ; if ( isset ( $ hints [ $ attribute ] ) ) { return $ hints [ $ attribute ] ; } elseif ( strpos ( $ attribute , '.' ) ) { $ attributeParts = explode ( '.' , $ attribute ) ; $ neededAttribute = array_pop ( $ attributeParts ) ; $ relatedModel = $ this ; foreach ( $ attributeParts as $ relationName ) { if ( $ relatedModel -> isRelationPopulated ( $ relationName ) && $ relatedModel -> $ relationName instanceof self ) { $ relatedModel = $ relatedModel -> $ relationName ; } else { try { $ relation = $ relatedModel -> getRelation ( $ relationName ) ; } catch ( InvalidParamException $ e ) { return '' ; } $ modelClass = $ relation -> modelClass ; $ relatedModel = $ modelClass :: instance ( ) ; } } $ hints = $ relatedModel -> attributeHints ( ) ; if ( isset ( $ hints [ $ neededAttribute ] ) ) { return $ hints [ $ neededAttribute ] ; } } return '' ; } 
public function offsetUnset ( $ offset ) { if ( property_exists ( $ this , $ offset ) ) { $ this -> $ offset = null ; } else { unset ( $ this -> $ offset ) ; } } 
private function resetDependentRelations ( $ attribute ) { foreach ( $ this -> _relationsDependencies [ $ attribute ] as $ relation ) { unset ( $ this -> _related [ $ relation ] ) ; } unset ( $ this -> _relationsDependencies [ $ attribute ] ) ; } 
private function setRelationDependencies ( $ name , $ relation , $ viaRelationName = null ) { if ( empty ( $ relation -> via ) && $ relation -> link ) { foreach ( $ relation -> link as $ attribute ) { $ this -> _relationsDependencies [ $ attribute ] [ $ name ] = $ name ; if ( $ viaRelationName !== null ) { $ this -> _relationsDependencies [ $ attribute ] [ ] = $ viaRelationName ; } } } elseif ( $ relation -> via instanceof ActiveQueryInterface ) { $ this -> setRelationDependencies ( $ name , $ relation -> via ) ; } elseif ( is_array ( $ relation -> via ) ) { list ( $ viaRelationName , $ viaQuery ) = $ relation -> via ; $ this -> setRelationDependencies ( $ name , $ viaQuery , $ viaRelationName ) ; } } 
public function validateAttribute ( $ model , $ attribute ) { if ( $ this -> maxFiles != 1 || $ this -> minFiles > 1 ) { $ rawFiles = $ model -> $ attribute ; if ( ! is_array ( $ rawFiles ) ) { $ this -> addError ( $ model , $ attribute , $ this -> uploadRequired ) ; return ; } $ files = $ this -> filterFiles ( $ rawFiles ) ; $ model -> $ attribute = $ files ; if ( empty ( $ files ) ) { $ this -> addError ( $ model , $ attribute , $ this -> uploadRequired ) ; return ; } $ filesCount = count ( $ files ) ; if ( $ this -> maxFiles && $ filesCount > $ this -> maxFiles ) { $ this -> addError ( $ model , $ attribute , $ this -> tooMany , [ 'limit' => $ this -> maxFiles ] ) ; } if ( $ this -> minFiles && $ this -> minFiles > $ filesCount ) { $ this -> addError ( $ model , $ attribute , $ this -> tooFew , [ 'limit' => $ this -> minFiles ] ) ; } foreach ( $ files as $ file ) { $ result = $ this -> validateValue ( $ file ) ; if ( ! empty ( $ result ) ) { $ this -> addError ( $ model , $ attribute , $ result [ 0 ] , $ result [ 1 ] ) ; } } } else { $ result = $ this -> validateValue ( $ model -> $ attribute ) ; if ( ! empty ( $ result ) ) { $ this -> addError ( $ model , $ attribute , $ result [ 0 ] , $ result [ 1 ] ) ; } } } 
protected function validateValue ( $ value ) { if ( ! $ value instanceof UploadedFile || $ value -> error == UPLOAD_ERR_NO_FILE ) { return [ $ this -> uploadRequired , [ ] ] ; } switch ( $ value -> error ) { case UPLOAD_ERR_OK : if ( $ this -> maxSize !== null && $ value -> size > $ this -> getSizeLimit ( ) ) { return [ $ this -> tooBig , [ 'file' => $ value -> name , 'limit' => $ this -> getSizeLimit ( ) , 'formattedLimit' => Yii :: $ app -> formatter -> asShortSize ( $ this -> getSizeLimit ( ) ) , ] , ] ; } elseif ( $ this -> minSize !== null && $ value -> size < $ this -> minSize ) { return [ $ this -> tooSmall , [ 'file' => $ value -> name , 'limit' => $ this -> minSize , 'formattedLimit' => Yii :: $ app -> formatter -> asShortSize ( $ this -> minSize ) , ] , ] ; } elseif ( ! empty ( $ this -> extensions ) && ! $ this -> validateExtension ( $ value ) ) { return [ $ this -> wrongExtension , [ 'file' => $ value -> name , 'extensions' => implode ( ', ' , $ this -> extensions ) ] ] ; } elseif ( ! empty ( $ this -> mimeTypes ) && ! $ this -> validateMimeType ( $ value ) ) { return [ $ this -> wrongMimeType , [ 'file' => $ value -> name , 'mimeTypes' => implode ( ', ' , $ this -> mimeTypes ) ] ] ; } return null ; case UPLOAD_ERR_INI_SIZE : case UPLOAD_ERR_FORM_SIZE : return [ $ this -> tooBig , [ 'file' => $ value -> name , 'limit' => $ this -> getSizeLimit ( ) , 'formattedLimit' => Yii :: $ app -> formatter -> asShortSize ( $ this -> getSizeLimit ( ) ) , ] ] ; case UPLOAD_ERR_PARTIAL : Yii :: warning ( 'File was only partially uploaded: ' . $ value -> name , __METHOD__ ) ; break ; case UPLOAD_ERR_NO_TMP_DIR : Yii :: warning ( 'Missing the temporary folder to store the uploaded file: ' . $ value -> name , __METHOD__ ) ; break ; case UPLOAD_ERR_CANT_WRITE : Yii :: warning ( 'Failed to write the uploaded file to disk: ' . $ value -> name , __METHOD__ ) ; break ; case UPLOAD_ERR_EXTENSION : Yii :: warning ( 'File upload was stopped by some PHP extension: ' . $ value -> name , __METHOD__ ) ; break ; default : break ; } return [ $ this -> message , [ ] ] ; } 
public function getSizeLimit ( ) { 
public function isEmpty ( $ value , $ trim = false ) { $ value = is_array ( $ value ) ? reset ( $ value ) : $ value ; return ! ( $ value instanceof UploadedFile ) || $ value -> error == UPLOAD_ERR_NO_FILE ; } 
private function sizeToBytes ( $ sizeStr ) { switch ( substr ( $ sizeStr , - 1 ) ) { case 'M' : case 'm' : return ( int ) $ sizeStr * 1048576 ; case 'K' : case 'k' : return ( int ) $ sizeStr * 1024 ; case 'G' : case 'g' : return ( int ) $ sizeStr * 1073741824 ; default : return ( int ) $ sizeStr ; } } 
protected function validateExtension ( $ file ) { $ extension = mb_strtolower ( $ file -> extension , 'UTF-8' ) ; if ( $ this -> checkExtensionByMimeType ) { $ mimeType = FileHelper :: getMimeType ( $ file -> tempName , null , false ) ; if ( $ mimeType === null ) { return false ; } $ extensionsByMimeType = FileHelper :: getExtensionsByMimeType ( $ mimeType ) ; if ( ! in_array ( $ extension , $ extensionsByMimeType , true ) ) { return false ; } } if ( ! in_array ( $ extension , $ this -> extensions , true ) ) { return false ; } return true ; } 
protected function validateMimeType ( $ file ) { $ fileMimeType = FileHelper :: getMimeType ( $ file -> tempName ) ; foreach ( $ this -> mimeTypes as $ mimeType ) { if ( $ mimeType === $ fileMimeType ) { return true ; } if ( strpos ( $ mimeType , '*' ) !== false && preg_match ( $ this -> buildMimeTypeRegexp ( $ mimeType ) , $ fileMimeType ) ) { return true ; } } return false ; } 
public function init ( ) { if ( empty ( $ this -> controller ) ) { throw new InvalidConfigException ( '"controller" must be set.' ) ; } $ controllers = [ ] ; foreach ( ( array ) $ this -> controller as $ urlName => $ controller ) { if ( is_int ( $ urlName ) ) { $ urlName = $ this -> pluralize ? Inflector :: pluralize ( $ controller ) : $ controller ; } $ controllers [ $ urlName ] = $ controller ; } $ this -> controller = $ controllers ; $ this -> prefix = trim ( $ this -> prefix , '/' ) ; parent :: init ( ) ; } 
protected function createRule ( $ pattern , $ prefix , $ action ) { $ verbs = 'GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS' ; if ( preg_match ( "/^((?:($verbs),)*($verbs))(?:\\s+(.*))?$/" , $ pattern , $ matches ) ) { $ verbs = explode ( ',' , $ matches [ 1 ] ) ; $ pattern = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : '' ; } else { $ verbs = [ ] ; } $ config = $ this -> ruleConfig ; $ config [ 'verb' ] = $ verbs ; $ config [ 'pattern' ] = rtrim ( $ prefix . '/' . strtr ( $ pattern , $ this -> tokens ) , '/' ) ; $ config [ 'route' ] = $ action ; if ( ! empty ( $ verbs ) && ! in_array ( 'GET' , $ verbs ) ) { $ config [ 'mode' ] = WebUrlRule :: PARSING_ONLY ; } $ config [ 'suffix' ] = $ this -> suffix ; return Yii :: createObject ( $ config ) ; } 
public function parseRequest ( $ manager , $ request ) { $ pathInfo = $ request -> getPathInfo ( ) ; foreach ( $ this -> rules as $ urlName => $ rules ) { if ( strpos ( $ pathInfo , $ urlName ) !== false ) { foreach ( $ rules as $ rule ) { $ result = $ rule -> parseRequest ( $ manager , $ request ) ; if ( YII_DEBUG ) { Yii :: debug ( [ 'rule' => method_exists ( $ rule , '__toString' ) ? $ rule -> __toString ( ) : get_class ( $ rule ) , 'match' => $ result !== false , 'parent' => self :: className ( ) , ] , __METHOD__ ) ; } if ( $ result !== false ) { return $ result ; } } } } return false ; } 
public function createUrl ( $ manager , $ route , $ params ) { $ this -> createStatus = WebUrlRule :: CREATE_STATUS_SUCCESS ; foreach ( $ this -> controller as $ urlName => $ controller ) { if ( strpos ( $ route , $ controller ) !== false ) { $ rules = $ this -> rules [ $ urlName ] ; $ url = $ this -> iterateRules ( $ rules , $ manager , $ route , $ params ) ; if ( $ url !== false ) { return $ url ; } } else { $ this -> createStatus |= WebUrlRule :: CREATE_STATUS_ROUTE_MISMATCH ; } } if ( $ this -> createStatus === WebUrlRule :: CREATE_STATUS_SUCCESS ) { 
public function afterAction ( $ action , $ result ) { $ result = parent :: afterAction ( $ action , $ result ) ; return $ this -> serializeData ( $ result ) ; } 
public function init ( ) { parent :: init ( ) ; if ( empty ( $ this -> message [ 'to' ] ) ) { throw new InvalidConfigException ( 'The "to" option must be set for EmailTarget::message.' ) ; } $ this -> mailer = Instance :: ensure ( $ this -> mailer , 'yii\mail\MailerInterface' ) ; } 
public function export ( ) { 
protected function composeMessage ( $ body ) { $ message = $ this -> mailer -> compose ( ) ; Yii :: configure ( $ message , $ this -> message ) ; $ message -> setTextBody ( $ body ) ; return $ message ; } 
protected function renderDataCellContent ( $ model , $ key , $ index ) { $ pagination = $ this -> grid -> dataProvider -> getPagination ( ) ; if ( $ pagination !== false ) { return $ pagination -> getOffset ( ) + $ index + 1 ; } return $ index + 1 ; } 
protected function typecastValue ( ArrayExpression $ expression , $ value ) { if ( $ value instanceof ExpressionInterface ) { return $ value ; } if ( in_array ( $ expression -> getType ( ) , [ Schema :: TYPE_JSON , Schema :: TYPE_JSONB ] , true ) ) { return new JsonExpression ( $ value ) ; } return $ value ; } 
public function build ( ExpressionInterface $ expression , array & $ params = [ ] ) { $ operator = $ expression -> getOperator ( ) ; $ query = $ expression -> getQuery ( ) ; $ sql = $ this -> queryBuilder -> buildExpression ( $ query , $ params ) ; return "$operator $sql" ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> message !== null ) { return ; } if ( is_array ( $ this -> targetAttribute ) && count ( $ this -> targetAttribute ) > 1 ) { 
public function validateAttribute ( $ model , $ attribute ) { $ targetClass = $ this -> getTargetClass ( $ model ) ; $ targetAttribute = $ this -> targetAttribute === null ? $ attribute : $ this -> targetAttribute ; $ rawConditions = $ this -> prepareConditions ( $ targetAttribute , $ model , $ attribute ) ; $ conditions = [ $ this -> targetAttributeJunction === 'or' ? 'or' : 'and' ] ; foreach ( $ rawConditions as $ key => $ value ) { if ( is_array ( $ value ) ) { $ this -> addError ( $ model , $ attribute , Yii :: t ( 'yii' , '{attribute} is invalid.' ) ) ; return ; } $ conditions [ ] = [ $ key => $ value ] ; } $ db = $ targetClass :: getDb ( ) ; $ modelExists = false ; if ( $ this -> forceMasterDb && method_exists ( $ db , 'useMaster' ) ) { $ db -> useMaster ( function ( ) use ( $ targetClass , $ conditions , $ model , & $ modelExists ) { $ modelExists = $ this -> modelExists ( $ targetClass , $ conditions , $ model ) ; } ) ; } else { $ modelExists = $ this -> modelExists ( $ targetClass , $ conditions , $ model ) ; } if ( $ modelExists ) { if ( is_array ( $ targetAttribute ) && count ( $ targetAttribute ) > 1 ) { $ this -> addComboNotUniqueError ( $ model , $ attribute ) ; } else { $ this -> addError ( $ model , $ attribute , $ this -> message ) ; } } } 
private function prepareQuery ( $ targetClass , $ conditions ) { $ query = $ targetClass :: find ( ) ; $ query -> andWhere ( $ conditions ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ query ) ; } elseif ( $ this -> filter !== null ) { $ query -> andWhere ( $ this -> filter ) ; } return $ query ; } 
private function prepareConditions ( $ targetAttribute , $ model , $ attribute ) { if ( is_array ( $ targetAttribute ) ) { $ conditions = [ ] ; foreach ( $ targetAttribute as $ k => $ v ) { $ conditions [ $ v ] = is_int ( $ k ) ? $ model -> $ v : $ model -> $ k ; } } else { $ conditions = [ $ targetAttribute => $ model -> $ attribute ] ; } $ targetModelClass = $ this -> getTargetClass ( $ model ) ; if ( ! is_subclass_of ( $ targetModelClass , 'yii\db\ActiveRecord' ) ) { return $ conditions ; } return $ this -> applyTableAlias ( $ targetModelClass :: find ( ) , $ conditions ) ; } 
private function addComboNotUniqueError ( $ model , $ attribute ) { $ attributeCombo = [ ] ; $ valueCombo = [ ] ; foreach ( $ this -> targetAttribute as $ key => $ value ) { if ( is_int ( $ key ) ) { $ attributeCombo [ ] = $ model -> getAttributeLabel ( $ value ) ; $ valueCombo [ ] = '"' . $ model -> $ value . '"' ; } else { $ attributeCombo [ ] = $ model -> getAttributeLabel ( $ key ) ; $ valueCombo [ ] = '"' . $ model -> $ key . '"' ; } } $ this -> addError ( $ model , $ attribute , $ this -> message , [ 'attributes' => Inflector :: sentence ( $ attributeCombo ) , 'values' => implode ( '-' , $ valueCombo ) , ] ) ; } 
private function applyTableAlias ( $ query , $ conditions , $ alias = null ) { if ( $ alias === null ) { $ alias = array_keys ( $ query -> getTablesUsedInFrom ( ) ) [ 0 ] ; } $ prefixedConditions = [ ] ; foreach ( $ conditions as $ columnName => $ columnValue ) { if ( strpos ( $ columnName , '(' ) === false ) { $ columnName = preg_replace ( '/^' . preg_quote ( $ alias ) . '\.(.*)$/' , '$1' , $ columnName ) ; if ( strpos ( $ columnName , '[[' ) === 0 ) { $ prefixedColumn = "{$alias}.{$columnName}" ; } else { $ prefixedColumn = "{$alias}.[[{$columnName}]]" ; } } else { 
public function run ( ) { try { $ this -> state = self :: STATE_BEFORE_REQUEST ; $ this -> trigger ( self :: EVENT_BEFORE_REQUEST ) ; $ this -> state = self :: STATE_HANDLING_REQUEST ; $ response = $ this -> handleRequest ( $ this -> getRequest ( ) ) ; $ this -> state = self :: STATE_AFTER_REQUEST ; $ this -> trigger ( self :: EVENT_AFTER_REQUEST ) ; $ this -> state = self :: STATE_SENDING_RESPONSE ; $ response -> send ( ) ; $ this -> state = self :: STATE_END ; return $ response -> exitStatus ; } catch ( ExitException $ e ) { $ this -> end ( $ e -> statusCode , isset ( $ response ) ? $ response : null ) ; return $ e -> statusCode ; } } 
public function setRuntimePath ( $ path ) { $ this -> _runtimePath = Yii :: getAlias ( $ path ) ; Yii :: setAlias ( '@runtime' , $ this -> _runtimePath ) ; } 
public function getVendorPath ( ) { if ( $ this -> _vendorPath === null ) { $ this -> setVendorPath ( $ this -> getBasePath ( ) . DIRECTORY_SEPARATOR . 'vendor' ) ; } return $ this -> _vendorPath ; } 
public function setVendorPath ( $ path ) { $ this -> _vendorPath = Yii :: getAlias ( $ path ) ; Yii :: setAlias ( '@vendor' , $ this -> _vendorPath ) ; Yii :: setAlias ( '@bower' , $ this -> _vendorPath . DIRECTORY_SEPARATOR . 'bower' ) ; Yii :: setAlias ( '@npm' , $ this -> _vendorPath . DIRECTORY_SEPARATOR . 'npm' ) ; } 
public function end ( $ status = 0 , $ response = null ) { if ( $ this -> state === self :: STATE_BEFORE_REQUEST || $ this -> state === self :: STATE_HANDLING_REQUEST ) { $ this -> state = self :: STATE_AFTER_REQUEST ; $ this -> trigger ( self :: EVENT_AFTER_REQUEST ) ; } if ( $ this -> state !== self :: STATE_SENDING_RESPONSE && $ this -> state !== self :: STATE_END ) { $ this -> state = self :: STATE_END ; $ response = $ response ? : $ this -> getResponse ( ) ; $ response -> send ( ) ; } if ( YII_ENV_TEST ) { throw new ExitException ( $ status ) ; } exit ( $ status ) ; } 
public function renderAjax ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; $ this -> beginPage ( ) ; $ this -> head ( ) ; $ this -> beginBody ( ) ; echo $ this -> renderFile ( $ viewFile , $ params , $ context ) ; $ this -> endBody ( ) ; $ this -> endPage ( true ) ; return ob_get_clean ( ) ; } 
public function clear ( ) { $ this -> metaTags = [ ] ; $ this -> linkTags = [ ] ; $ this -> css = [ ] ; $ this -> cssFiles = [ ] ; $ this -> js = [ ] ; $ this -> jsFiles = [ ] ; $ this -> assetBundles = [ ] ; } 
protected function registerAssetFiles ( $ name ) { if ( ! isset ( $ this -> assetBundles [ $ name ] ) ) { return ; } $ bundle = $ this -> assetBundles [ $ name ] ; if ( $ bundle ) { foreach ( $ bundle -> depends as $ dep ) { $ this -> registerAssetFiles ( $ dep ) ; } $ bundle -> registerAssetFiles ( $ this ) ; } unset ( $ this -> assetBundles [ $ name ] ) ; } 
public function registerAssetBundle ( $ name , $ position = null ) { if ( ! isset ( $ this -> assetBundles [ $ name ] ) ) { $ am = $ this -> getAssetManager ( ) ; $ bundle = $ am -> getBundle ( $ name ) ; $ this -> assetBundles [ $ name ] = false ; 
public function registerCssFile ( $ url , $ options = [ ] , $ key = null ) { $ url = Yii :: getAlias ( $ url ) ; $ key = $ key ? : $ url ; $ depends = ArrayHelper :: remove ( $ options , 'depends' , [ ] ) ; if ( empty ( $ depends ) ) { $ this -> cssFiles [ $ key ] = Html :: cssFile ( $ url , $ options ) ; } else { $ this -> getAssetManager ( ) -> bundles [ $ key ] = Yii :: createObject ( [ 'class' => AssetBundle :: className ( ) , 'baseUrl' => '' , 'css' => [ strncmp ( $ url , '//' , 2 ) === 0 ? $ url : ltrim ( $ url , '/' ) ] , 'cssOptions' => $ options , 'depends' => ( array ) $ depends , ] ) ; $ this -> registerAssetBundle ( $ key ) ; } } 
public function registerJs ( $ js , $ position = self :: POS_READY , $ key = null ) { $ key = $ key ? : md5 ( $ js ) ; $ this -> js [ $ position ] [ $ key ] = $ js ; if ( $ position === self :: POS_READY || $ position === self :: POS_LOAD ) { JqueryAsset :: register ( $ this ) ; } } 
public function registerJsFile ( $ url , $ options = [ ] , $ key = null ) { $ url = Yii :: getAlias ( $ url ) ; $ key = $ key ? : $ url ; $ depends = ArrayHelper :: remove ( $ options , 'depends' , [ ] ) ; if ( empty ( $ depends ) ) { $ position = ArrayHelper :: remove ( $ options , 'position' , self :: POS_END ) ; $ this -> jsFiles [ $ position ] [ $ key ] = Html :: jsFile ( $ url , $ options ) ; } else { $ this -> getAssetManager ( ) -> bundles [ $ key ] = Yii :: createObject ( [ 'class' => AssetBundle :: className ( ) , 'baseUrl' => '' , 'js' => [ strncmp ( $ url , '//' , 2 ) === 0 ? $ url : ltrim ( $ url , '/' ) ] , 'jsOptions' => $ options , 'depends' => ( array ) $ depends , ] ) ; $ this -> registerAssetBundle ( $ key ) ; } } 
protected function renderBodyEndHtml ( $ ajaxMode ) { $ lines = [ ] ; if ( ! empty ( $ this -> jsFiles [ self :: POS_END ] ) ) { $ lines [ ] = implode ( "\n" , $ this -> jsFiles [ self :: POS_END ] ) ; } if ( $ ajaxMode ) { $ scripts = [ ] ; if ( ! empty ( $ this -> js [ self :: POS_END ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_END ] ) ; } if ( ! empty ( $ this -> js [ self :: POS_READY ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_READY ] ) ; } if ( ! empty ( $ this -> js [ self :: POS_LOAD ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_LOAD ] ) ; } if ( ! empty ( $ scripts ) ) { $ lines [ ] = Html :: script ( implode ( "\n" , $ scripts ) ) ; } } else { if ( ! empty ( $ this -> js [ self :: POS_END ] ) ) { $ lines [ ] = Html :: script ( implode ( "\n" , $ this -> js [ self :: POS_END ] ) ) ; } if ( ! empty ( $ this -> js [ self :: POS_READY ] ) ) { $ js = "jQuery(function ($) {\n" . implode ( "\n" , $ this -> js [ self :: POS_READY ] ) . "\n});" ; $ lines [ ] = Html :: script ( $ js ) ; } if ( ! empty ( $ this -> js [ self :: POS_LOAD ] ) ) { $ js = "jQuery(window).on('load', function () {\n" . implode ( "\n" , $ this -> js [ self :: POS_LOAD ] ) . "\n});" ; $ lines [ ] = Html :: script ( $ js ) ; } } return empty ( $ lines ) ? '' : implode ( "\n" , $ lines ) ; } 
public function normalizeRoute ( $ route ) { if ( $ this -> action === null ) { return $ route ; } elseif ( $ this -> action === static :: ACTION_REDIRECT_PERMANENT || $ this -> action === static :: ACTION_REDIRECT_TEMPORARY ) { throw new UrlNormalizerRedirectException ( [ $ route [ 0 ] ] + $ route [ 1 ] , $ this -> action ) ; } elseif ( $ this -> action === static :: ACTION_NOT_FOUND ) { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'Page not found.' ) ) ; } elseif ( is_callable ( $ this -> action ) ) { return call_user_func ( $ this -> action , $ route , $ this ) ; } throw new InvalidConfigException ( 'Invalid normalizer action.' ) ; } 
public function normalizePathInfo ( $ pathInfo , $ suffix , & $ normalized = false ) { if ( empty ( $ pathInfo ) ) { return $ pathInfo ; } $ sourcePathInfo = $ pathInfo ; if ( $ this -> collapseSlashes ) { $ pathInfo = $ this -> collapseSlashes ( $ pathInfo ) ; } if ( $ this -> normalizeTrailingSlash === true ) { $ pathInfo = $ this -> normalizeTrailingSlash ( $ pathInfo , $ suffix ) ; } $ normalized = $ sourcePathInfo !== $ pathInfo ; return $ pathInfo ; } 
protected function normalizeTrailingSlash ( $ pathInfo , $ suffix ) { if ( substr ( $ suffix , - 1 ) === '/' && substr ( $ pathInfo , - 1 ) !== '/' ) { $ pathInfo .= '/' ; } elseif ( substr ( $ suffix , - 1 ) !== '/' && substr ( $ pathInfo , - 1 ) === '/' ) { $ pathInfo = rtrim ( $ pathInfo , '/' ) ; } return $ pathInfo ; } 
public static function pluralize ( $ word ) { if ( isset ( static :: $ specials [ $ word ] ) ) { return static :: $ specials [ $ word ] ; } foreach ( static :: $ plurals as $ rule => $ replacement ) { if ( preg_match ( $ rule , $ word ) ) { return preg_replace ( $ rule , $ replacement , $ word ) ; } } return $ word ; } 
public static function singularize ( $ word ) { $ result = array_search ( $ word , static :: $ specials , true ) ; if ( $ result !== false ) { return $ result ; } foreach ( static :: $ singulars as $ rule => $ replacement ) { if ( preg_match ( $ rule , $ word ) ) { return preg_replace ( $ rule , $ replacement , $ word ) ; } } return $ word ; } 
public static function titleize ( $ words , $ ucAll = false ) { $ words = static :: humanize ( static :: underscore ( $ words ) , $ ucAll ) ; return $ ucAll ? StringHelper :: mb_ucwords ( $ words , self :: encoding ( ) ) : StringHelper :: mb_ucfirst ( $ words , self :: encoding ( ) ) ; } 
public static function camel2words ( $ name , $ ucwords = true ) { $ label = mb_strtolower ( trim ( str_replace ( [ '-' , '_' , '.' , ] , ' ' , preg_replace ( '/(?<!\p{Lu})(\p{Lu})|(\p{Lu})(?=\p{Ll})/u' , ' \0' , $ name ) ) ) , self :: encoding ( ) ) ; return $ ucwords ? StringHelper :: mb_ucwords ( $ label , self :: encoding ( ) ) : $ label ; } 
public static function camel2id ( $ name , $ separator = '-' , $ strict = false ) { $ regex = $ strict ? '/\p{Lu}/u' : '/(?<!\p{Lu})\p{Lu}/u' ; if ( $ separator === '_' ) { return mb_strtolower ( trim ( preg_replace ( $ regex , '_\0' , $ name ) , '_' ) , self :: encoding ( ) ) ; } return mb_strtolower ( trim ( str_replace ( '_' , $ separator , preg_replace ( $ regex , $ separator . '\0' , $ name ) ) , $ separator ) , self :: encoding ( ) ) ; } 
public static function id2camel ( $ id , $ separator = '-' ) { return str_replace ( ' ' , '' , StringHelper :: mb_ucwords ( str_replace ( $ separator , ' ' , $ id ) , self :: encoding ( ) ) ) ; } 
public static function humanize ( $ word , $ ucAll = false ) { $ word = str_replace ( '_' , ' ' , preg_replace ( '/_id$/' , '' , $ word ) ) ; $ encoding = self :: encoding ( ) ; return $ ucAll ? StringHelper :: mb_ucwords ( $ word , $ encoding ) : StringHelper :: mb_ucfirst ( $ word , $ encoding ) ; } 
public static function variablize ( $ word ) { $ word = static :: camelize ( $ word ) ; return mb_strtolower ( mb_substr ( $ word , 0 , 1 , self :: encoding ( ) ) ) . mb_substr ( $ word , 1 , null , self :: encoding ( ) ) ; } 
public static function slug ( $ string , $ replacement = '-' , $ lowercase = true ) { $ parts = explode ( $ replacement , static :: transliterate ( $ string ) ) ; $ replaced = array_map ( function ( $ element ) use ( $ replacement ) { $ element = preg_replace ( '/[^a-zA-Z0-9=\s—–-]+/u', '' , $e l m ent); return preg_replace ( '/[=\s—–-]+/u', $r e l acement, $e l m ent); } , $ parts ) ; $ string = trim ( implode ( $ replacement , $ replaced ) , $ replacement ) ; return $ lowercase ? strtolower ( $ string ) : $ string ; } 
public static function sentence ( array $ words , $ twoWordsConnector = null , $ lastWordConnector = null , $ connector = ', ' ) { if ( $ twoWordsConnector === null ) { $ twoWordsConnector = Yii :: t ( 'yii' , ' and ' ) ; } if ( $ lastWordConnector === null ) { $ lastWordConnector = $ twoWordsConnector ; } switch ( count ( $ words ) ) { case 0 : return '' ; case 1 : return reset ( $ words ) ; case 2 : return implode ( $ twoWordsConnector , $ words ) ; default : return implode ( $ connector , array_slice ( $ words , 0 , - 1 ) ) . $ lastWordConnector . end ( $ words ) ; } } 
protected function acquireLock ( $ name , $ timeout = 0 ) { return $ this -> db -> useMaster ( function ( $ db ) use ( $ name , $ timeout ) { return ( bool ) $ db -> createCommand ( 'SELECT GET_LOCK(:name, :timeout)' , [ ':name' => $ this -> hashLockName ( $ name ) , ':timeout' => $ timeout ] ) -> queryScalar ( ) ; } ) ; } 
protected function releaseLock ( $ name ) { return $ this -> db -> useMaster ( function ( $ db ) use ( $ name ) { return ( bool ) $ db -> createCommand ( 'SELECT RELEASE_LOCK(:name)' , [ ':name' => $ this -> hashLockName ( $ name ) ] ) -> queryScalar ( ) ; } ) ; } 
public function send ( MailerInterface $ mailer = null ) { if ( $ mailer === null && $ this -> mailer === null ) { $ mailer = Yii :: $ app -> getMailer ( ) ; } elseif ( $ mailer === null ) { $ mailer = $ this -> mailer ; } return $ mailer -> send ( $ this ) ; } 
public static function instance ( $ refresh = false ) { $ className = get_called_class ( ) ; if ( $ refresh || ! isset ( self :: $ _instances [ $ className ] ) ) { self :: $ _instances [ $ className ] = Yii :: createObject ( $ className ) ; } return self :: $ _instances [ $ className ] ; } 
public function buildKey ( $ key ) { if ( is_string ( $ key ) ) { $ key = ctype_alnum ( $ key ) && StringHelper :: byteLength ( $ key ) <= 32 ? $ key : md5 ( $ key ) ; } else { if ( $ this -> _igbinaryAvailable ) { $ serializedKey = igbinary_serialize ( $ key ) ; } else { $ serializedKey = serialize ( $ key ) ; } $ key = md5 ( $ serializedKey ) ; } return $ this -> keyPrefix . $ key ; } 
public function get ( $ key ) { $ key = $ this -> buildKey ( $ key ) ; $ value = $ this -> getValue ( $ key ) ; if ( $ value === false || $ this -> serializer === false ) { return $ value ; } elseif ( $ this -> serializer === null ) { $ value = unserialize ( $ value ) ; } else { $ value = call_user_func ( $ this -> serializer [ 1 ] , $ value ) ; } if ( is_array ( $ value ) && ! ( $ value [ 1 ] instanceof Dependency && $ value [ 1 ] -> isChanged ( $ this ) ) ) { return $ value [ 0 ] ; } return false ; } 
public function exists ( $ key ) { $ key = $ this -> buildKey ( $ key ) ; $ value = $ this -> getValue ( $ key ) ; return $ value !== false ; } 
public function mset ( $ items , $ duration = 0 , $ dependency = null ) { return $ this -> multiSet ( $ items , $ duration , $ dependency ) ; } 
public function madd ( $ items , $ duration = 0 , $ dependency = null ) { return $ this -> multiAdd ( $ items , $ duration , $ dependency ) ; } 
public function add ( $ key , $ value , $ duration = 0 , $ dependency = null ) { if ( $ dependency !== null && $ this -> serializer !== false ) { $ dependency -> evaluateDependency ( $ this ) ; } if ( $ this -> serializer === null ) { $ value = serialize ( [ $ value , $ dependency ] ) ; } elseif ( $ this -> serializer !== false ) { $ value = call_user_func ( $ this -> serializer [ 0 ] , [ $ value , $ dependency ] ) ; } $ key = $ this -> buildKey ( $ key ) ; return $ this -> addValue ( $ key , $ value , $ duration ) ; } 
protected function getValues ( $ keys ) { $ results = [ ] ; foreach ( $ keys as $ key ) { $ results [ $ key ] = $ this -> getValue ( $ key ) ; } return $ results ; } 
protected function setValues ( $ data , $ duration ) { $ failedKeys = [ ] ; foreach ( $ data as $ key => $ value ) { if ( $ this -> setValue ( $ key , $ value , $ duration ) === false ) { $ failedKeys [ ] = $ key ; } } return $ failedKeys ; } 
protected function addValues ( $ data , $ duration ) { $ failedKeys = [ ] ; foreach ( $ data as $ key => $ value ) { if ( $ this -> addValue ( $ key , $ value , $ duration ) === false ) { $ failedKeys [ ] = $ key ; } } return $ failedKeys ; } 
public function getOrSet ( $ key , $ callable , $ duration = null , $ dependency = null ) { if ( ( $ value = $ this -> get ( $ key ) ) !== false ) { return $ value ; } $ value = call_user_func ( $ callable , $ this ) ; if ( ! $ this -> set ( $ key , $ value , $ duration , $ dependency ) ) { Yii :: warning ( 'Failed to set cache value for key ' . json_encode ( $ key ) , __METHOD__ ) ; } return $ value ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> defaultSchema === null ) { $ username = $ this -> db -> username ; if ( empty ( $ username ) ) { $ username = isset ( $ this -> db -> masters [ 0 ] [ 'username' ] ) ? $ this -> db -> masters [ 0 ] [ 'username' ] : '' ; } $ this -> defaultSchema = strtoupper ( $ username ) ; } } 
protected function resolveTableName ( $ name ) { $ resolvedName = new TableSchema ( ) ; $ parts = explode ( '.' , str_replace ( '"' , '' , $ name ) ) ; if ( isset ( $ parts [ 1 ] ) ) { $ resolvedName -> schemaName = $ parts [ 0 ] ; $ resolvedName -> name = $ parts [ 1 ] ; } else { $ resolvedName -> schemaName = $ this -> defaultSchema ; $ resolvedName -> name = $ name ; } $ resolvedName -> fullName = ( $ resolvedName -> schemaName !== $ this -> defaultSchema ? $ resolvedName -> schemaName . '.' : '' ) . $ resolvedName -> name ; return $ resolvedName ; } 
protected function findTableNames ( $ schema = '' ) { if ( $ schema === '' ) { $ sql = <<<'SQL' SELECT TABLE_NAME FROM USER_TABLES UNION ALL SELECT VIEW_NAME AS TABLE_NAME FROM USER_VIEWS UNION ALL SELECT MVIEW_NAME AS TABLE_NAME FROM USER_MVIEWS ORDER BY TABLE_NAME SQL ; $ command = $ this -> db -> createCommand ( $ sql ) ; } else { $ sql = <<<'SQL' SELECT OBJECT_NAME AS TABLE_NAME FROM ALL_OBJECTS WHERE OBJECT_TYPE IN ('TABLE', 'VIEW', 'MATERIALIZED VIEW') AND OWNER = :schema ORDER BY OBJECT_NAME SQL ; $ command = $ this -> db -> createCommand ( $ sql , [ ':schema' => $ schema ] ) ; } $ rows = $ command -> queryAll ( ) ; $ names = [ ] ; foreach ( $ rows as $ row ) { if ( $ this -> db -> slavePdo -> getAttribute ( \ PDO :: ATTR_CASE ) === \ PDO :: CASE_LOWER ) { $ row = array_change_key_case ( $ row , CASE_UPPER ) ; } $ names [ ] = $ row [ 'TABLE_NAME' ] ; } return $ names ; } 
protected function findColumns ( $ table ) { $ sql = <<<'SQL' SELECT A.COLUMN_NAME, A.DATA_TYPE, A.DATA_PRECISION, A.DATA_SCALE, ( CASE A.CHAR_USED WHEN 'C' THEN A.CHAR_LENGTH ELSE A.DATA_LENGTH END ) AS DATA_LENGTH, A.NULLABLE, A.DATA_DEFAULT, COM.COMMENTS AS COLUMN_COMMENT FROM ALL_TAB_COLUMNS A INNER JOIN ALL_OBJECTS B ON B.OWNER = A.OWNER AND LTRIM(B.OBJECT_NAME) = LTRIM(A.TABLE_NAME) LEFT JOIN ALL_COL_COMMENTS COM ON (A.OWNER = COM.OWNER AND A.TABLE_NAME = COM.TABLE_NAME AND A.COLUMN_NAME = COM.COLUMN_NAME) WHERE A.OWNER = :schemaName AND B.OBJECT_TYPE IN ('TABLE', 'VIEW', 'MATERIALIZED VIEW') AND B.OBJECT_NAME = :tableName ORDER BY A.COLUMN_ID SQL ; try { $ columns = $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ] ) -> queryAll ( ) ; } catch ( \ Exception $ e ) { return false ; } if ( empty ( $ columns ) ) { return false ; } foreach ( $ columns as $ column ) { if ( $ this -> db -> slavePdo -> getAttribute ( \ PDO :: ATTR_CASE ) === \ PDO :: CASE_LOWER ) { $ column = array_change_key_case ( $ column , CASE_UPPER ) ; } $ c = $ this -> createColumn ( $ column ) ; $ table -> columns [ $ c -> name ] = $ c ; } return true ; } 
protected function getTableSequenceName ( $ tableName ) { $ sequenceNameSql = <<<'SQL' SELECT UD.REFERENCED_NAME AS SEQUENCE_NAME FROM USER_DEPENDENCIES UD JOIN USER_TRIGGERS UT ON (UT.TRIGGER_NAME = UD.NAME) WHERE UT.TABLE_NAME = :tableName AND UD.TYPE = 'TRIGGER' AND UD.REFERENCED_TYPE = 'SEQUENCE' SQL ; $ sequenceName = $ this -> db -> createCommand ( $ sequenceNameSql , [ ':tableName' => $ tableName ] ) -> queryScalar ( ) ; return $ sequenceName === false ? null : $ sequenceName ; } 
public function getLastInsertID ( $ sequenceName = '' ) { if ( $ this -> db -> isActive ) { 
protected function createColumn ( $ column ) { $ c = $ this -> createColumnSchema ( ) ; $ c -> name = $ column [ 'COLUMN_NAME' ] ; $ c -> allowNull = $ column [ 'NULLABLE' ] === 'Y' ; $ c -> comment = $ column [ 'COLUMN_COMMENT' ] === null ? '' : $ column [ 'COLUMN_COMMENT' ] ; $ c -> isPrimaryKey = false ; $ this -> extractColumnType ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ this -> extractColumnSize ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ c -> phpType = $ this -> getColumnPhpType ( $ c ) ; if ( ! $ c -> isPrimaryKey ) { if ( stripos ( $ column [ 'DATA_DEFAULT' ] , 'timestamp' ) !== false ) { $ c -> defaultValue = null ; } else { $ defaultValue = $ column [ 'DATA_DEFAULT' ] ; if ( $ c -> type === 'timestamp' && $ defaultValue === 'CURRENT_TIMESTAMP' ) { $ c -> defaultValue = new Expression ( 'CURRENT_TIMESTAMP' ) ; } else { if ( $ defaultValue !== null ) { if ( ( $ len = strlen ( $ defaultValue ) ) > 2 && $ defaultValue [ 0 ] === "'" && $ defaultValue [ $ len - 1 ] === "'" ) { $ defaultValue = substr ( $ column [ 'DATA_DEFAULT' ] , 1 , - 1 ) ; } else { $ defaultValue = trim ( $ defaultValue ) ; } } $ c -> defaultValue = $ c -> phpTypecast ( $ defaultValue ) ; } } } return $ c ; } 
protected function findConstraints ( $ table ) { $ sql = <<<'SQL' SELECT D.CONSTRAINT_NAME, D.CONSTRAINT_TYPE, C.COLUMN_NAME, C.POSITION, D.R_CONSTRAINT_NAME, E.TABLE_NAME AS TABLE_REF, F.COLUMN_NAME AS COLUMN_REF, C.TABLE_NAME FROM ALL_CONS_COLUMNS C INNER JOIN ALL_CONSTRAINTS D ON D.OWNER = C.OWNER AND D.CONSTRAINT_NAME = C.CONSTRAINT_NAME LEFT JOIN ALL_CONSTRAINTS E ON E.OWNER = D.R_OWNER AND E.CONSTRAINT_NAME = D.R_CONSTRAINT_NAME LEFT JOIN ALL_CONS_COLUMNS F ON F.OWNER = E.OWNER AND F.CONSTRAINT_NAME = E.CONSTRAINT_NAME AND F.POSITION = C.POSITION WHERE C.OWNER = :schemaName AND C.TABLE_NAME = :tableName ORDER BY D.CONSTRAINT_NAME, C.POSITION SQL ; $ command = $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ] ) ; $ constraints = [ ] ; foreach ( $ command -> queryAll ( ) as $ row ) { if ( $ this -> db -> slavePdo -> getAttribute ( \ PDO :: ATTR_CASE ) === \ PDO :: CASE_LOWER ) { $ row = array_change_key_case ( $ row , CASE_UPPER ) ; } if ( $ row [ 'CONSTRAINT_TYPE' ] === 'P' ) { $ table -> columns [ $ row [ 'COLUMN_NAME' ] ] -> isPrimaryKey = true ; $ table -> primaryKey [ ] = $ row [ 'COLUMN_NAME' ] ; if ( empty ( $ table -> sequenceName ) ) { $ table -> sequenceName = $ this -> getTableSequenceName ( $ table -> name ) ; } } if ( $ row [ 'CONSTRAINT_TYPE' ] !== 'R' ) { 
public function findUniqueIndexes ( $ table ) { $ query = <<<'SQL' SELECT DIC.INDEX_NAME, DIC.COLUMN_NAME FROM ALL_INDEXES DI INNER JOIN ALL_IND_COLUMNS DIC ON DI.TABLE_NAME = DIC.TABLE_NAME AND DI.INDEX_NAME = DIC.INDEX_NAME WHERE DI.UNIQUENESS = 'UNIQUE' AND DIC.TABLE_OWNER = :schemaName AND DIC.TABLE_NAME = :tableName ORDER BY DIC.TABLE_NAME, DIC.INDEX_NAME, DIC.COLUMN_POSITION SQL ; $ result = [ ] ; $ command = $ this -> db -> createCommand ( $ query , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ] ) ; foreach ( $ command -> queryAll ( ) as $ row ) { $ result [ $ row [ 'INDEX_NAME' ] ] [ ] = $ row [ 'COLUMN_NAME' ] ; } return $ result ; } 
protected function extractColumnType ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> dbType = $ dbType ; if ( strpos ( $ dbType , 'FLOAT' ) !== false || strpos ( $ dbType , 'DOUBLE' ) !== false ) { $ column -> type = 'double' ; } elseif ( strpos ( $ dbType , 'NUMBER' ) !== false ) { if ( $ scale === null || $ scale > 0 ) { $ column -> type = 'decimal' ; } else { $ column -> type = 'integer' ; } } elseif ( strpos ( $ dbType , 'INTEGER' ) !== false ) { $ column -> type = 'integer' ; } elseif ( strpos ( $ dbType , 'BLOB' ) !== false ) { $ column -> type = 'binary' ; } elseif ( strpos ( $ dbType , 'CLOB' ) !== false ) { $ column -> type = 'text' ; } elseif ( strpos ( $ dbType , 'TIMESTAMP' ) !== false ) { $ column -> type = 'timestamp' ; } else { $ column -> type = 'string' ; } } 
protected function extractColumnSize ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> size = trim ( $ length ) === '' ? null : ( int ) $ length ; $ column -> precision = trim ( $ precision ) === '' ? null : ( int ) $ precision ; $ column -> scale = trim ( $ scale ) === '' ? null : ( int ) $ scale ; } 
public function insert ( $ table , $ columns ) { $ params = [ ] ; $ returnParams = [ ] ; $ sql = $ this -> db -> getQueryBuilder ( ) -> insert ( $ table , $ columns , $ params ) ; $ tableSchema = $ this -> getTableSchema ( $ table ) ; $ returnColumns = $ tableSchema -> primaryKey ; if ( ! empty ( $ returnColumns ) ) { $ columnSchemas = $ tableSchema -> columns ; $ returning = [ ] ; foreach ( ( array ) $ returnColumns as $ name ) { $ phName = QueryBuilder :: PARAM_PREFIX . ( count ( $ params ) + count ( $ returnParams ) ) ; $ returnParams [ $ phName ] = [ 'column' => $ name , 'value' => null , ] ; if ( ! isset ( $ columnSchemas [ $ name ] ) || $ columnSchemas [ $ name ] -> phpType !== 'integer' ) { $ returnParams [ $ phName ] [ 'dataType' ] = \ PDO :: PARAM_STR ; } else { $ returnParams [ $ phName ] [ 'dataType' ] = \ PDO :: PARAM_INT ; } $ returnParams [ $ phName ] [ 'size' ] = isset ( $ columnSchemas [ $ name ] -> size ) ? $ columnSchemas [ $ name ] -> size : - 1 ; $ returning [ ] = $ this -> quoteColumnName ( $ name ) ; } $ sql .= ' RETURNING ' . implode ( ', ' , $ returning ) . ' INTO ' . implode ( ', ' , array_keys ( $ returnParams ) ) ; } $ command = $ this -> db -> createCommand ( $ sql , $ params ) ; $ command -> prepare ( false ) ; foreach ( $ returnParams as $ name => & $ value ) { $ command -> pdoStatement -> bindParam ( $ name , $ value [ 'value' ] , $ value [ 'dataType' ] , $ value [ 'size' ] ) ; } if ( ! $ command -> execute ( ) ) { return false ; } $ result = [ ] ; foreach ( $ returnParams as $ value ) { $ result [ $ value [ 'column' ] ] = $ value [ 'value' ] ; } return $ result ; } 
public function next ( ) { do { $ this -> _key = next ( $ this -> _keys ) ; } while ( ! isset ( $ _SESSION [ $ this -> _key ] ) && $ this -> _key !== false ) ; } 
public function registerClientScript ( ) { $ id = $ this -> options [ 'id' ] ; $ options = Json :: htmlEncode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: htmlEncode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; ActiveFormAsset :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; } 
public function errorSummary ( $ models , $ options = [ ] ) { Html :: addCssClass ( $ options , $ this -> errorSummaryCssClass ) ; $ options [ 'encode' ] = $ this -> encodeErrorSummary ; return Html :: errorSummary ( $ models , $ options ) ; } 
public function field ( $ model , $ attribute , $ options = [ ] ) { $ config = $ this -> fieldConfig ; if ( $ config instanceof \ Closure ) { $ config = call_user_func ( $ config , $ model , $ attribute ) ; } if ( ! isset ( $ config [ 'class' ] ) ) { $ config [ 'class' ] = $ this -> fieldClass ; } return Yii :: createObject ( ArrayHelper :: merge ( $ config , $ options , [ 'model' => $ model , 'attribute' => $ attribute , 'form' => $ this , ] ) ) ; } 
public function beginField ( $ model , $ attribute , $ options = [ ] ) { $ field = $ this -> field ( $ model , $ attribute , $ options ) ; $ this -> _fields [ ] = $ field ; return $ field -> begin ( ) ; } 
public static function validate ( $ model , $ attributes = null ) { $ result = [ ] ; if ( $ attributes instanceof Model ) { 
public static function validateMultiple ( $ models , $ attributes = null ) { $ result = [ ] ; foreach ( $ models as $ i => $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , "[$i]" . $ attribute ) ] = $ errors ; } } return $ result ; } 
protected function renderSortLinks ( ) { $ attributes = empty ( $ this -> attributes ) ? array_keys ( $ this -> sort -> attributes ) : $ this -> attributes ; $ links = [ ] ; foreach ( $ attributes as $ name ) { $ links [ ] = $ this -> sort -> link ( $ name , $ this -> linkOptions ) ; } return Html :: ul ( $ links , array_merge ( $ this -> options , [ 'encode' => false ] ) ) ; } 
public static function encode ( $ content , $ doubleEncode = true ) { return htmlspecialchars ( $ content , ENT_QUOTES | ENT_SUBSTITUTE , Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' , $ doubleEncode ) ; } 
public static function cssFile ( $ url , $ options = [ ] ) { if ( ! isset ( $ options [ 'rel' ] ) ) { $ options [ 'rel' ] = 'stylesheet' ; } $ options [ 'href' ] = Url :: to ( $ url ) ; if ( isset ( $ options [ 'condition' ] ) ) { $ condition = $ options [ 'condition' ] ; unset ( $ options [ 'condition' ] ) ; return self :: wrapIntoCondition ( static :: tag ( 'link' , '' , $ options ) , $ condition ) ; } elseif ( isset ( $ options [ 'noscript' ] ) && $ options [ 'noscript' ] === true ) { unset ( $ options [ 'noscript' ] ) ; return '<noscript>' . static :: tag ( 'link' , '' , $ options ) . '</noscript>' ; } return static :: tag ( 'link' , '' , $ options ) ; } 
public static function jsFile ( $ url , $ options = [ ] ) { $ options [ 'src' ] = Url :: to ( $ url ) ; if ( isset ( $ options [ 'condition' ] ) ) { $ condition = $ options [ 'condition' ] ; unset ( $ options [ 'condition' ] ) ; return self :: wrapIntoCondition ( static :: tag ( 'script' , '' , $ options ) , $ condition ) ; } return static :: tag ( 'script' , '' , $ options ) ; } 
public static function a ( $ text , $ url = null , $ options = [ ] ) { if ( $ url !== null ) { $ options [ 'href' ] = Url :: to ( $ url ) ; } return static :: tag ( 'a' , $ text , $ options ) ; } 
public static function mailto ( $ text , $ email = null , $ options = [ ] ) { $ options [ 'href' ] = 'mailto:' . ( $ email === null ? $ text : $ email ) ; return static :: tag ( 'a' , $ text , $ options ) ; } 
public static function img ( $ src , $ options = [ ] ) { $ options [ 'src' ] = Url :: to ( $ src ) ; if ( isset ( $ options [ 'srcset' ] ) && is_array ( $ options [ 'srcset' ] ) ) { $ srcset = [ ] ; foreach ( $ options [ 'srcset' ] as $ descriptor => $ url ) { $ srcset [ ] = Url :: to ( $ url ) . ' ' . $ descriptor ; } $ options [ 'srcset' ] = implode ( ',' , $ srcset ) ; } if ( ! isset ( $ options [ 'alt' ] ) ) { $ options [ 'alt' ] = '' ; } return static :: tag ( 'img' , '' , $ options ) ; } 
public static function textarea ( $ name , $ value = '' , $ options = [ ] ) { $ options [ 'name' ] = $ name ; $ doubleEncode = ArrayHelper :: remove ( $ options , 'doubleEncode' , true ) ; return static :: tag ( 'textarea' , static :: encode ( $ value , $ doubleEncode ) , $ options ) ; } 
public static function dropDownList ( $ name , $ selection = null , $ items = [ ] , $ options = [ ] ) { if ( ! empty ( $ options [ 'multiple' ] ) ) { return static :: listBox ( $ name , $ selection , $ items , $ options ) ; } $ options [ 'name' ] = $ name ; unset ( $ options [ 'unselect' ] ) ; $ selectOptions = static :: renderSelectOptions ( $ selection , $ items , $ options ) ; return static :: tag ( 'select' , "\n" . $ selectOptions . "\n" , $ options ) ; } 
public static function ul ( $ items , $ options = [ ] ) { $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'ul' ) ; $ encode = ArrayHelper :: remove ( $ options , 'encode' , true ) ; $ formatter = ArrayHelper :: remove ( $ options , 'item' ) ; $ separator = ArrayHelper :: remove ( $ options , 'separator' , "\n" ) ; $ itemOptions = ArrayHelper :: remove ( $ options , 'itemOptions' , [ ] ) ; if ( empty ( $ items ) ) { return static :: tag ( $ tag , '' , $ options ) ; } $ results = [ ] ; foreach ( $ items as $ index => $ item ) { if ( $ formatter !== null ) { $ results [ ] = call_user_func ( $ formatter , $ item , $ index ) ; } else { $ results [ ] = static :: tag ( 'li' , $ encode ? static :: encode ( $ item ) : $ item , $ itemOptions ) ; } } return static :: tag ( $ tag , $ separator . implode ( $ separator , $ results ) . $ separator , $ options ) ; } 
public static function activeLabel ( $ model , $ attribute , $ options = [ ] ) { $ for = ArrayHelper :: remove ( $ options , 'for' , static :: getInputId ( $ model , $ attribute ) ) ; $ attribute = static :: getAttributeName ( $ attribute ) ; $ label = ArrayHelper :: remove ( $ options , 'label' , static :: encode ( $ model -> getAttributeLabel ( $ attribute ) ) ) ; return static :: label ( $ label , $ for , $ options ) ; } 
public static function errorSummary ( $ models , $ options = [ ] ) { $ header = isset ( $ options [ 'header' ] ) ? $ options [ 'header' ] : '<p>' . Yii :: t ( 'yii' , 'Please fix the following errors:' ) . '</p>' ; $ footer = ArrayHelper :: remove ( $ options , 'footer' , '' ) ; $ encode = ArrayHelper :: remove ( $ options , 'encode' , true ) ; $ showAllErrors = ArrayHelper :: remove ( $ options , 'showAllErrors' , false ) ; unset ( $ options [ 'header' ] ) ; $ lines = self :: collectErrors ( $ models , $ encode , $ showAllErrors ) ; if ( empty ( $ lines ) ) { 
private static function collectErrors ( $ models , $ encode , $ showAllErrors ) { $ lines = [ ] ; if ( ! is_array ( $ models ) ) { $ models = [ $ models ] ; } foreach ( $ models as $ model ) { $ lines = array_unique ( array_merge ( $ lines , $ model -> getErrorSummary ( $ showAllErrors ) ) ) ; } 
private static function normalizeMaxLength ( $ model , $ attribute , & $ options ) { if ( isset ( $ options [ 'maxlength' ] ) && $ options [ 'maxlength' ] === true ) { unset ( $ options [ 'maxlength' ] ) ; $ attrName = static :: getAttributeName ( $ attribute ) ; foreach ( $ model -> getActiveValidators ( $ attrName ) as $ validator ) { if ( $ validator instanceof StringValidator && $ validator -> max !== null ) { $ options [ 'maxlength' ] = $ validator -> max ; break ; } } } } 
protected static function setActivePlaceholder ( $ model , $ attribute , & $ options = [ ] ) { if ( isset ( $ options [ 'placeholder' ] ) && $ options [ 'placeholder' ] === true ) { $ attribute = static :: getAttributeName ( $ attribute ) ; $ options [ 'placeholder' ] = $ model -> getAttributeLabel ( $ attribute ) ; } } 
protected static function activeBooleanInput ( $ type , $ model , $ attribute , $ options = [ ] ) { $ name = isset ( $ options [ 'name' ] ) ? $ options [ 'name' ] : static :: getInputName ( $ model , $ attribute ) ; $ value = static :: getAttributeValue ( $ model , $ attribute ) ; if ( ! array_key_exists ( 'value' , $ options ) ) { $ options [ 'value' ] = '1' ; } if ( ! array_key_exists ( 'uncheck' , $ options ) ) { $ options [ 'uncheck' ] = '0' ; } elseif ( $ options [ 'uncheck' ] === false ) { unset ( $ options [ 'uncheck' ] ) ; } if ( ! array_key_exists ( 'label' , $ options ) ) { $ options [ 'label' ] = static :: encode ( $ model -> getAttributeLabel ( static :: getAttributeName ( $ attribute ) ) ) ; } elseif ( $ options [ 'label' ] === false ) { unset ( $ options [ 'label' ] ) ; } $ checked = "$value" === "{$options['value']}" ; if ( ! array_key_exists ( 'id' , $ options ) ) { $ options [ 'id' ] = static :: getInputId ( $ model , $ attribute ) ; } return static :: $ type ( $ name , $ checked , $ options ) ; } 
public static function activeListBox ( $ model , $ attribute , $ items , $ options = [ ] ) { return static :: activeListInput ( 'listBox' , $ model , $ attribute , $ items , $ options ) ; } 
public static function activeCheckboxList ( $ model , $ attribute , $ items , $ options = [ ] ) { return static :: activeListInput ( 'checkboxList' , $ model , $ attribute , $ items , $ options ) ; } 
public static function activeRadioList ( $ model , $ attribute , $ items , $ options = [ ] ) { return static :: activeListInput ( 'radioList' , $ model , $ attribute , $ items , $ options ) ; } 
public static function addCssClass ( & $ options , $ class ) { if ( isset ( $ options [ 'class' ] ) ) { if ( is_array ( $ options [ 'class' ] ) ) { $ options [ 'class' ] = self :: mergeCssClasses ( $ options [ 'class' ] , ( array ) $ class ) ; } else { $ classes = preg_split ( '/\s+/' , $ options [ 'class' ] , - 1 , PREG_SPLIT_NO_EMPTY ) ; $ options [ 'class' ] = implode ( ' ' , self :: mergeCssClasses ( $ classes , ( array ) $ class ) ) ; } } else { $ options [ 'class' ] = $ class ; } } 
private static function mergeCssClasses ( array $ existingClasses , array $ additionalClasses ) { foreach ( $ additionalClasses as $ key => $ class ) { if ( is_int ( $ key ) && ! in_array ( $ class , $ existingClasses ) ) { $ existingClasses [ ] = $ class ; } elseif ( ! isset ( $ existingClasses [ $ key ] ) ) { $ existingClasses [ $ key ] = $ class ; } } return array_unique ( $ existingClasses ) ; } 
public static function removeCssClass ( & $ options , $ class ) { if ( isset ( $ options [ 'class' ] ) ) { if ( is_array ( $ options [ 'class' ] ) ) { $ classes = array_diff ( $ options [ 'class' ] , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = $ classes ; } } else { $ classes = preg_split ( '/\s+/' , $ options [ 'class' ] , - 1 , PREG_SPLIT_NO_EMPTY ) ; $ classes = array_diff ( $ classes , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = implode ( ' ' , $ classes ) ; } } } } 
public static function cssStyleFromArray ( array $ style ) { $ result = '' ; foreach ( $ style as $ name => $ value ) { $ result .= "$name: $value; " ; } 
public static function cssStyleToArray ( $ style ) { $ result = [ ] ; foreach ( explode ( ';' , $ style ) as $ property ) { $ property = explode ( ':' , $ property ) ; if ( count ( $ property ) > 1 ) { $ result [ trim ( $ property [ 0 ] ) ] = trim ( $ property [ 1 ] ) ; } } return $ result ; } 
public static function getAttributeValue ( $ model , $ attribute ) { if ( ! preg_match ( static :: $ attributeRegex , $ attribute , $ matches ) ) { throw new InvalidArgumentException ( 'Attribute name must contain word characters only.' ) ; } $ attribute = $ matches [ 2 ] ; $ value = $ model -> $ attribute ; if ( $ matches [ 3 ] !== '' ) { foreach ( explode ( '][' , trim ( $ matches [ 3 ] , '[]' ) ) as $ id ) { if ( ( is_array ( $ value ) || $ value instanceof \ ArrayAccess ) && isset ( $ value [ $ id ] ) ) { $ value = $ value [ $ id ] ; } else { return null ; } } } 
public static function getInputName ( $ model , $ attribute ) { $ formName = $ model -> formName ( ) ; if ( ! preg_match ( static :: $ attributeRegex , $ attribute , $ matches ) ) { throw new InvalidArgumentException ( 'Attribute name must contain word characters only.' ) ; } $ prefix = $ matches [ 1 ] ; $ attribute = $ matches [ 2 ] ; $ suffix = $ matches [ 3 ] ; if ( $ formName === '' && $ prefix === '' ) { return $ attribute . $ suffix ; } elseif ( $ formName !== '' ) { return $ formName . $ prefix . "[$attribute]" . $ suffix ; } throw new InvalidArgumentException ( get_class ( $ model ) . '::formName() cannot be empty for tabular inputs.' ) ; } 
public static function getInputId ( $ model , $ attribute ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ name = mb_strtolower ( static :: getInputName ( $ model , $ attribute ) , $ charset ) ; return str_replace ( [ '[]' , '][' , '[' , ']' , ' ' , '.' ] , [ '' , '-' , '-' , '' , '-' , '-' ] , $ name ) ; } 
public static function escapeJsRegularExpression ( $ regexp ) { $ pattern = preg_replace ( '/\\\\x\{?([0-9a-fA-F]+)\}?/' , '\u$1' , $ regexp ) ; $ deliminator = substr ( $ pattern , 0 , 1 ) ; $ pos = strrpos ( $ pattern , $ deliminator , 1 ) ; $ flag = substr ( $ pattern , $ pos + 1 ) ; if ( $ deliminator !== '/' ) { $ pattern = '/' . str_replace ( '/' , '\\/' , substr ( $ pattern , 1 , $ pos - 1 ) ) . '/' ; } else { $ pattern = substr ( $ pattern , 0 , $ pos + 1 ) ; } if ( ! empty ( $ flag ) ) { $ pattern .= preg_replace ( '/[^igmu]/' , '' , $ flag ) ; } return $ pattern ; } 
protected function fallbackFormat ( $ pattern , $ args , $ locale ) { if ( ( $ tokens = self :: tokenizePattern ( $ pattern ) ) === false ) { $ this -> _errorCode = - 1 ; $ this -> _errorMessage = 'Message pattern is invalid.' ; return false ; } foreach ( $ tokens as $ i => $ token ) { if ( is_array ( $ token ) ) { if ( ( $ tokens [ $ i ] = $ this -> parseToken ( $ token , $ args , $ locale ) ) === false ) { $ this -> _errorCode = - 1 ; $ this -> _errorMessage = 'Message pattern is invalid.' ; return false ; } } } return implode ( '' , $ tokens ) ; } 
private static function tokenizePattern ( $ pattern ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ depth = 1 ; if ( ( $ start = $ pos = mb_strpos ( $ pattern , '{' , 0 , $ charset ) ) === false ) { return [ $ pattern ] ; } $ tokens = [ mb_substr ( $ pattern , 0 , $ pos , $ charset ) ] ; while ( true ) { $ open = mb_strpos ( $ pattern , '{' , $ pos + 1 , $ charset ) ; $ close = mb_strpos ( $ pattern , '}' , $ pos + 1 , $ charset ) ; if ( $ open === false && $ close === false ) { break ; } if ( $ open === false ) { $ open = mb_strlen ( $ pattern , $ charset ) ; } if ( $ close > $ open ) { $ depth ++ ; $ pos = $ open ; } else { $ depth -- ; $ pos = $ close ; } if ( $ depth === 0 ) { $ tokens [ ] = explode ( ',' , mb_substr ( $ pattern , $ start + 1 , $ pos - $ start - 1 , $ charset ) , 3 ) ; $ start = $ pos + 1 ; $ tokens [ ] = mb_substr ( $ pattern , $ start , $ open - $ start , $ charset ) ; $ start = $ open ; } if ( $ depth !== 0 && ( $ open === false || $ close === false ) ) { break ; } } if ( $ depth !== 0 ) { return false ; } return $ tokens ; } 
private function parseToken ( $ token , $ args , $ locale ) { selectStyle = (selector '{' message '}')+ */ if ( ! isset ( $ token [ 2 ] ) ) { return false ; } $ select = self :: tokenizePattern ( $ token [ 2 ] ) ; $ c = count ( $ select ) ; $ message = false ; for ( $ i = 0 ; $ i + 1 < $ c ; $ i ++ ) { if ( is_array ( $ select [ $ i ] ) || ! is_array ( $ select [ $ i + 1 ] ) ) { return false ; } $ selector = trim ( $ select [ $ i ++ ] ) ; if ( $ message === false && $ selector === 'other' || $ selector == $ arg ) { $ message = implode ( ',' , $ select [ $ i ] ) ; } } if ( $ message !== false ) { return $ this -> fallbackFormat ( $ message , $ args , $ locale ) ; } break ; case 'plural' : if ( ! isset ( $ token [ 2 ] ) ) { return false ; } $ plural = self :: tokenizePattern ( $ token [ 2 ] ) ; $ c = count ( $ plural ) ; $ message = false ; $ offset = 0 ; for ( $ i = 0 ; $ i + 1 < $ c ; $ i ++ ) { if ( is_array ( $ plural [ $ i ] ) || ! is_array ( $ plural [ $ i + 1 ] ) ) { return false ; } $ selector = trim ( $ plural [ $ i ++ ] ) ; if ( $ i == 1 && strncmp ( $ selector , 'offset:' , 7 ) === 0 ) { $ offset = ( int ) trim ( mb_substr ( $ selector , 7 , ( $ pos = mb_strpos ( str_replace ( [ "\n" , "\r" , "\t" ] , ' ' , $ selector ) , ' ' , 7 , $ charset ) ) - 7 , $ charset ) ) ; $ selector = trim ( mb_substr ( $ selector , $ pos + 1 , mb_strlen ( $ selector , $ charset ) , $ charset ) ) ; } if ( $ message === false && $ selector === 'other' || $ selector [ 0 ] === '=' && ( int ) mb_substr ( $ selector , 1 , mb_strlen ( $ selector , $ charset ) , $ charset ) === $ arg || $ selector === 'one' && $ arg - $ offset == 1 ) { $ message = implode ( ',' , str_replace ( '#' , $ arg - $ offset , $ plural [ $ i ] ) ) ; } } if ( $ message !== false ) { return $ this -> fallbackFormat ( $ message , $ args , $ locale ) ; } break ; } return false ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> id === null ) { if ( self :: $ counter > 0 ) { $ this -> id = 'dp-' . self :: $ counter ; } self :: $ counter ++ ; } } 
public function prepare ( $ forcePrepare = false ) { if ( $ forcePrepare || $ this -> _models === null ) { $ this -> _models = $ this -> prepareModels ( ) ; } if ( $ forcePrepare || $ this -> _keys === null ) { $ this -> _keys = $ this -> prepareKeys ( $ this -> _models ) ; } } 
public function getTotalCount ( ) { if ( $ this -> getPagination ( ) === false ) { return $ this -> getCount ( ) ; } elseif ( $ this -> _totalCount === null ) { $ this -> _totalCount = $ this -> prepareTotalCount ( ) ; } return $ this -> _totalCount ; } 
public function setSort ( $ value ) { if ( is_array ( $ value ) ) { $ config = [ 'class' => Sort :: className ( ) ] ; if ( $ this -> id !== null ) { $ config [ 'sortParam' ] = $ this -> id . '-sort' ; } $ this -> _sort = Yii :: createObject ( array_merge ( $ config , $ value ) ) ; } elseif ( $ value instanceof Sort || $ value === false ) { $ this -> _sort = $ value ; } else { throw new InvalidArgumentException ( 'Only Sort instance, configuration array or false is allowed.' ) ; } } 
public function refresh ( ) { $ this -> _totalCount = null ; $ this -> _models = null ; $ this -> _keys = null ; } 
protected function validateValue ( $ value ) { if ( $ this -> strict ) { $ valid = $ value === $ this -> trueValue || $ value === $ this -> falseValue ; } else { $ valid = $ value == $ this -> trueValue || $ value == $ this -> falseValue ; } if ( ! $ valid ) { return [ $ this -> message , [ 'true' => $ this -> trueValue === true ? 'true' : $ this -> trueValue , 'false' => $ this -> falseValue === false ? 'false' : $ this -> falseValue , ] ] ; } return null ; } 
public function getClientOptions ( $ model , $ attribute ) { $ options = [ 'trueValue' => $ this -> trueValue , 'falseValue' => $ this -> falseValue , 'message' => $ this -> formatMessage ( $ this -> message , [ 'attribute' => $ model -> getAttributeLabel ( $ attribute ) , 'true' => $ this -> trueValue === true ? 'true' : $ this -> trueValue , 'false' => $ this -> falseValue === false ? 'false' : $ this -> falseValue , ] ) , ] ; if ( $ this -> skipOnEmpty ) { $ options [ 'skipOnEmpty' ] = 1 ; } if ( $ this -> strict ) { $ options [ 'strict' ] = 1 ; } return $ options ; } 
protected function bootstrap ( ) { $ request = $ this -> getRequest ( ) ; Yii :: setAlias ( '@webroot' , dirname ( $ request -> getScriptFile ( ) ) ) ; Yii :: setAlias ( '@web' , $ request -> getBaseUrl ( ) ) ; parent :: bootstrap ( ) ; } 
public function handleRequest ( $ request ) { if ( empty ( $ this -> catchAll ) ) { try { list ( $ route , $ params ) = $ request -> resolve ( ) ; } catch ( UrlNormalizerRedirectException $ e ) { $ url = $ e -> url ; if ( is_array ( $ url ) ) { if ( isset ( $ url [ 0 ] ) ) { 
public function init ( ) { parent :: init ( ) ; if ( $ this -> enableCoreCommands ) { foreach ( $ this -> coreCommands ( ) as $ id => $ command ) { if ( ! isset ( $ this -> controllerMap [ $ id ] ) ) { $ this -> controllerMap [ $ id ] = $ command ; } } } 
public function runAction ( $ route , $ params = [ ] ) { try { $ res = parent :: runAction ( $ route , $ params ) ; return is_object ( $ res ) ? $ res : ( int ) $ res ; } catch ( InvalidRouteException $ e ) { throw new UnknownCommandException ( $ route , $ this , 0 , $ e ) ; } } 
public function readSession ( $ id ) { $ data = $ this -> cache -> get ( $ this -> calculateKey ( $ id ) ) ; return $ data === false ? '' : $ data ; } 
public function writeSession ( $ id , $ data ) { return $ this -> cache -> set ( $ this -> calculateKey ( $ id ) , $ data , $ this -> getTimeout ( ) ) ; } 
public function destroySession ( $ id ) { $ cacheId = $ this -> calculateKey ( $ id ) ; if ( $ this -> cache -> exists ( $ cacheId ) === false ) { return true ; } return $ this -> cache -> delete ( $ cacheId ) ; } 
public function up ( ) { $ authManager = $ this -> getAuthManager ( ) ; $ this -> db = $ authManager -> db ; $ this -> createIndex ( $ this -> index , $ authManager -> assignmentTable , $ this -> column ) ; } 
public function down ( ) { $ authManager = $ this -> getAuthManager ( ) ; $ this -> db = $ authManager -> db ; $ this -> dropIndex ( $ this -> index , $ authManager -> assignmentTable ) ; } 
function check ( $ requirements ) { if ( is_string ( $ requirements ) ) { $ requirements = require $ requirements ; } if ( ! is_array ( $ requirements ) ) { $ this -> usageError ( 'Requirements must be an array, "' . gettype ( $ requirements ) . '" has been given!' ) ; } if ( ! isset ( $ this -> result ) || ! is_array ( $ this -> result ) ) { $ this -> result = array ( 'summary' => array ( 'total' => 0 , 'errors' => 0 , 'warnings' => 0 , ) , 'requirements' => array ( ) , ) ; } foreach ( $ requirements as $ key => $ rawRequirement ) { $ requirement = $ this -> normalizeRequirement ( $ rawRequirement , $ key ) ; $ this -> result [ 'summary' ] [ 'total' ] ++ ; if ( ! $ requirement [ 'condition' ] ) { if ( $ requirement [ 'mandatory' ] ) { $ requirement [ 'error' ] = true ; $ requirement [ 'warning' ] = true ; $ this -> result [ 'summary' ] [ 'errors' ] ++ ; } else { $ requirement [ 'error' ] = false ; $ requirement [ 'warning' ] = true ; $ this -> result [ 'summary' ] [ 'warnings' ] ++ ; } } else { $ requirement [ 'error' ] = false ; $ requirement [ 'warning' ] = false ; } $ this -> result [ 'requirements' ] [ ] = $ requirement ; } return $ this ; } 
function checkPhpExtensionVersion ( $ extensionName , $ version , $ compare = '>=' ) { if ( ! extension_loaded ( $ extensionName ) ) { return false ; } $ extensionVersion = phpversion ( $ extensionName ) ; if ( empty ( $ extensionVersion ) ) { return false ; } if ( strncasecmp ( $ extensionVersion , 'PECL-' , 5 ) === 0 ) { $ extensionVersion = substr ( $ extensionVersion , 5 ) ; } return version_compare ( $ extensionVersion , $ version , $ compare ) ; } 
function checkPhpIniOn ( $ name ) { $ value = ini_get ( $ name ) ; if ( empty ( $ value ) ) { return false ; } return ( ( int ) $ value === 1 || strtolower ( $ value ) === 'on' ) ; } 
function checkPhpIniOff ( $ name ) { $ value = ini_get ( $ name ) ; if ( empty ( $ value ) ) { return true ; } return ( strtolower ( $ value ) === 'off' ) ; } 
function compareByteSize ( $ a , $ b , $ compare = '>=' ) { $ compareExpression = '(' . $ this -> getByteSize ( $ a ) . $ compare . $ this -> getByteSize ( $ b ) . ')' ; return $ this -> evaluateExpression ( $ compareExpression ) ; } 
function checkUploadMaxFileSize ( $ min = null , $ max = null ) { $ postMaxSize = ini_get ( 'post_max_size' ) ; $ uploadMaxFileSize = ini_get ( 'upload_max_filesize' ) ; if ( $ min !== null ) { $ minCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ min , '>=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ min , '>=' ) ; } else { $ minCheckResult = true ; } if ( $ max !== null ) { $ maxCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ max , '<=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ max , '<=' ) ; } else { $ maxCheckResult = true ; } return ( $ minCheckResult && $ maxCheckResult ) ; } 
function normalizeRequirement ( $ requirement , $ requirementKey = 0 ) { if ( ! is_array ( $ requirement ) ) { $ this -> usageError ( 'Requirement must be an array!' ) ; } if ( ! array_key_exists ( 'condition' , $ requirement ) ) { $ this -> usageError ( "Requirement '{$requirementKey}' has no condition!" ) ; } else { $ evalPrefix = 'eval:' ; if ( is_string ( $ requirement [ 'condition' ] ) && strpos ( $ requirement [ 'condition' ] , $ evalPrefix ) === 0 ) { $ expression = substr ( $ requirement [ 'condition' ] , strlen ( $ evalPrefix ) ) ; $ requirement [ 'condition' ] = $ this -> evaluateExpression ( $ expression ) ; } } if ( ! array_key_exists ( 'name' , $ requirement ) ) { $ requirement [ 'name' ] = is_numeric ( $ requirementKey ) ? 'Requirement #' . $ requirementKey : $ requirementKey ; } if ( ! array_key_exists ( 'mandatory' , $ requirement ) ) { if ( array_key_exists ( 'required' , $ requirement ) ) { $ requirement [ 'mandatory' ] = $ requirement [ 'required' ] ; } else { $ requirement [ 'mandatory' ] = false ; } } if ( ! array_key_exists ( 'by' , $ requirement ) ) { $ requirement [ 'by' ] = 'Unknown' ; } if ( ! array_key_exists ( 'memo' , $ requirement ) ) { $ requirement [ 'memo' ] = '' ; } return $ requirement ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> formatter === null ) { $ this -> formatter = Yii :: $ app -> getFormatter ( ) ; } elseif ( is_array ( $ this -> formatter ) ) { $ this -> formatter = Yii :: createObject ( $ this -> formatter ) ; } if ( ! $ this -> formatter instanceof Formatter ) { throw new InvalidConfigException ( 'The "formatter" property must be either a Format object or a configuration array.' ) ; } if ( ! isset ( $ this -> filterRowOptions [ 'id' ] ) ) { $ this -> filterRowOptions [ 'id' ] = $ this -> options [ 'id' ] . '-filters' ; } $ this -> initColumns ( ) ; } 
public function run ( ) { $ view = $ this -> getView ( ) ; GridViewAsset :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; $ options = Json :: htmlEncode ( array_merge ( $ this -> getClientOptions ( ) , [ 'filterOnFocusOut' => $ this -> filterOnFocusOut ] ) ) ; $ view -> registerJs ( "jQuery('#$id').yiiGridView($options);" ) ; parent :: run ( ) ; } 
public function renderErrors ( ) { if ( $ this -> filterModel instanceof Model && $ this -> filterModel -> hasErrors ( ) ) { return Html :: errorSummary ( $ this -> filterModel , $ this -> filterErrorSummaryOptions ) ; } return '' ; } 
protected function getClientOptions ( ) { $ filterUrl = isset ( $ this -> filterUrl ) ? $ this -> filterUrl : Yii :: $ app -> request -> url ; $ id = $ this -> filterRowOptions [ 'id' ] ; $ filterSelector = "#$id input, #$id select" ; if ( isset ( $ this -> filterSelector ) ) { $ filterSelector .= ', ' . $ this -> filterSelector ; } return [ 'filterUrl' => Url :: to ( $ filterUrl ) , 'filterSelector' => $ filterSelector , ] ; } 
public function renderItems ( ) { $ caption = $ this -> renderCaption ( ) ; $ columnGroup = $ this -> renderColumnGroup ( ) ; $ tableHeader = $ this -> showHeader ? $ this -> renderTableHeader ( ) : false ; $ tableBody = $ this -> renderTableBody ( ) ; $ tableFooter = false ; $ tableFooterAfterBody = false ; if ( $ this -> showFooter ) { if ( $ this -> placeFooterAfterBody ) { $ tableFooterAfterBody = $ this -> renderTableFooter ( ) ; } else { $ tableFooter = $ this -> renderTableFooter ( ) ; } } $ content = array_filter ( [ $ caption , $ columnGroup , $ tableHeader , $ tableFooter , $ tableBody , $ tableFooterAfterBody , ] ) ; return Html :: tag ( 'table' , implode ( "\n" , $ content ) , $ this -> tableOptions ) ; } 
public function renderCaption ( ) { if ( ! empty ( $ this -> caption ) ) { return Html :: tag ( 'caption' , $ this -> caption , $ this -> captionOptions ) ; } return false ; } 
public function renderColumnGroup ( ) { foreach ( $ this -> columns as $ column ) { if ( ! empty ( $ column -> options ) ) { $ cols = [ ] ; foreach ( $ this -> columns as $ col ) { $ cols [ ] = Html :: tag ( 'col' , '' , $ col -> options ) ; } return Html :: tag ( 'colgroup' , implode ( "\n" , $ cols ) ) ; } } return false ; } 
public function renderTableFooter ( ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFooterCell ( ) ; } $ content = Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> footerRowOptions ) ; if ( $ this -> filterPosition === self :: FILTER_POS_FOOTER ) { $ content .= $ this -> renderFilters ( ) ; } return "<tfoot>\n" . $ content . "\n</tfoot>" ; } 
public function renderFilters ( ) { if ( $ this -> filterModel !== null ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFilterCell ( ) ; } return Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> filterRowOptions ) ; } return '' ; } 
public function renderTableBody ( ) { $ models = array_values ( $ this -> dataProvider -> getModels ( ) ) ; $ keys = $ this -> dataProvider -> getKeys ( ) ; $ rows = [ ] ; foreach ( $ models as $ index => $ model ) { $ key = $ keys [ $ index ] ; if ( $ this -> beforeRow !== null ) { $ row = call_user_func ( $ this -> beforeRow , $ model , $ key , $ index , $ this ) ; if ( ! empty ( $ row ) ) { $ rows [ ] = $ row ; } } $ rows [ ] = $ this -> renderTableRow ( $ model , $ key , $ index ) ; if ( $ this -> afterRow !== null ) { $ row = call_user_func ( $ this -> afterRow , $ model , $ key , $ index , $ this ) ; if ( ! empty ( $ row ) ) { $ rows [ ] = $ row ; } } } if ( empty ( $ rows ) && $ this -> emptyText !== false ) { $ colspan = count ( $ this -> columns ) ; return "<tbody>\n<tr><td colspan=\"$colspan\">" . $ this -> renderEmpty ( ) . "</td></tr>\n</tbody>" ; } return "<tbody>\n" . implode ( "\n" , $ rows ) . "\n</tbody>" ; } 
protected function guessColumns ( ) { $ models = $ this -> dataProvider -> getModels ( ) ; $ model = reset ( $ models ) ; if ( is_array ( $ model ) || is_object ( $ model ) ) { foreach ( $ model as $ name => $ value ) { if ( $ value === null || is_scalar ( $ value ) || is_callable ( [ $ value , '__toString' ] ) ) { $ this -> columns [ ] = ( string ) $ name ; } } } } 
public function getViewNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _viewNames [ $ schema ] ) || $ refresh ) { $ this -> _viewNames [ $ schema ] = $ this -> findViewNames ( $ schema ) ; } return $ this -> _viewNames [ $ schema ] ; } 
protected function prepareTotalCount ( ) { if ( ! $ this -> query instanceof QueryInterface ) { throw new InvalidConfigException ( 'The "query" property must be an instance of a class that implements the QueryInterface e.g. yii\db\Query or its subclasses.' ) ; } $ query = clone $ this -> query ; return ( int ) $ query -> limit ( - 1 ) -> offset ( - 1 ) -> orderBy ( [ ] ) -> count ( '*' , $ this -> db ) ; } 
public function setSort ( $ value ) { parent :: setSort ( $ value ) ; if ( ( $ sort = $ this -> getSort ( ) ) !== false && $ this -> query instanceof ActiveQueryInterface ) { $ modelClass = $ this -> query -> modelClass ; $ model = $ modelClass :: instance ( ) ; if ( empty ( $ sort -> attributes ) ) { foreach ( $ model -> attributes ( ) as $ attribute ) { $ sort -> attributes [ $ attribute ] = [ 'asc' => [ $ attribute => SORT_ASC ] , 'desc' => [ $ attribute => SORT_DESC ] , 'label' => $ model -> getAttributeLabel ( $ attribute ) , ] ; } } else { foreach ( $ sort -> attributes as $ attribute => $ config ) { if ( ! isset ( $ config [ 'label' ] ) ) { $ sort -> attributes [ $ attribute ] [ 'label' ] = $ model -> getAttributeLabel ( $ attribute ) ; } } } } } 
public function andWhere ( $ condition ) { if ( $ this -> where === null ) { $ this -> where = $ condition ; } else { $ this -> where = [ 'and' , $ this -> where , $ condition ] ; } return $ this ; } 
public function orWhere ( $ condition ) { if ( $ this -> where === null ) { $ this -> where = $ condition ; } else { $ this -> where = [ 'or' , $ this -> where , $ condition ] ; } return $ this ; } 
public function filterWhere ( array $ condition ) { $ condition = $ this -> filterCondition ( $ condition ) ; if ( $ condition !== [ ] ) { $ this -> where ( $ condition ) ; } return $ this ; } 
public function andFilterWhere ( array $ condition ) { $ condition = $ this -> filterCondition ( $ condition ) ; if ( $ condition !== [ ] ) { $ this -> andWhere ( $ condition ) ; } return $ this ; } 
public function orFilterWhere ( array $ condition ) { $ condition = $ this -> filterCondition ( $ condition ) ; if ( $ condition !== [ ] ) { $ this -> orWhere ( $ condition ) ; } return $ this ; } 
protected function filterCondition ( $ condition ) { if ( ! is_array ( $ condition ) ) { return $ condition ; } if ( ! isset ( $ condition [ 0 ] ) ) { 
protected function isEmpty ( $ value ) { return $ value === '' || $ value === [ ] || $ value === null || is_string ( $ value ) && trim ( $ value ) === '' ; } 
public function addOrderBy ( $ columns ) { $ columns = $ this -> normalizeOrderBy ( $ columns ) ; if ( $ this -> orderBy === null ) { $ this -> orderBy = $ columns ; } else { $ this -> orderBy = array_merge ( $ this -> orderBy , $ columns ) ; } return $ this ; } 
public function isColorEnabled ( $ stream = \ STDOUT ) { return $ this -> color === null ? Console :: streamSupportsAnsiColors ( $ stream ) : $ this -> color ; } 
public function runAction ( $ id , $ params = [ ] ) { if ( ! empty ( $ params ) ) { 
public function bindActionParams ( $ action , $ params ) { if ( $ action instanceof InlineAction ) { $ method = new \ ReflectionMethod ( $ this , $ action -> actionMethod ) ; } else { $ method = new \ ReflectionMethod ( $ action , 'run' ) ; } $ args = array_values ( $ params ) ; $ missing = [ ] ; foreach ( $ method -> getParameters ( ) as $ i => $ param ) { if ( $ param -> isArray ( ) && isset ( $ args [ $ i ] ) ) { $ args [ $ i ] = $ args [ $ i ] === '' ? [ ] : preg_split ( '/\s*,\s*/' , $ args [ $ i ] ) ; } if ( ! isset ( $ args [ $ i ] ) ) { if ( $ param -> isDefaultValueAvailable ( ) ) { $ args [ $ i ] = $ param -> getDefaultValue ( ) ; } else { $ missing [ ] = $ param -> getName ( ) ; } } } if ( ! empty ( $ missing ) ) { throw new Exception ( Yii :: t ( 'yii' , 'Missing required arguments: {params}' , [ 'params' => implode ( ', ' , $ missing ) ] ) ) ; } return $ args ; } 
public function stderr ( $ string ) { if ( $ this -> isColorEnabled ( \ STDERR ) ) { $ args = func_get_args ( ) ; array_shift ( $ args ) ; $ string = Console :: ansiFormat ( $ string , $ args ) ; } return fwrite ( \ STDERR , $ string ) ; } 
public function getOptionValues ( $ actionID ) { 
public function getPassedOptionValues ( ) { $ properties = [ ] ; foreach ( $ this -> _passedOptions as $ property ) { $ properties [ $ property ] = $ this -> $ property ; } return $ properties ; } 
public function getActionArgsHelp ( $ action ) { $ method = $ this -> getActionMethodReflection ( $ action ) ; $ tags = $ this -> parseDocCommentTags ( $ method ) ; $ params = isset ( $ tags [ 'param' ] ) ? ( array ) $ tags [ 'param' ] : [ ] ; $ args = [ ] ; foreach ( $ method -> getParameters ( ) as $ i => $ reflection ) { if ( $ reflection -> getClass ( ) !== null ) { continue ; } $ name = $ reflection -> getName ( ) ; $ tag = isset ( $ params [ $ i ] ) ? $ params [ $ i ] : '' ; if ( preg_match ( '/^(\S+)\s+(\$\w+\s+)?(.*)/s' , $ tag , $ matches ) ) { $ type = $ matches [ 1 ] ; $ comment = $ matches [ 3 ] ; } else { $ type = null ; $ comment = $ tag ; } if ( $ reflection -> isDefaultValueAvailable ( ) ) { $ args [ $ name ] = [ 'required' => false , 'type' => $ type , 'default' => $ reflection -> getDefaultValue ( ) , 'comment' => $ comment , ] ; } else { $ args [ $ name ] = [ 'required' => true , 'type' => $ type , 'default' => null , 'comment' => $ comment , ] ; } } return $ args ; } 
protected function parseDocCommentDetail ( $ reflection ) { $ comment = strtr ( trim ( preg_replace ( '/^\s*\**( |\t)?/m' , '' , trim ( $ reflection -> getDocComment ( ) , '/' ) ) ) , "\r" , '' ) ; if ( preg_match ( '/^\s*@\w+/m' , $ comment , $ matches , PREG_OFFSET_CAPTURE ) ) { $ comment = trim ( substr ( $ comment , 0 , $ matches [ 0 ] [ 1 ] ) ) ; } if ( $ comment !== '' ) { return rtrim ( Console :: renderColoredString ( Console :: markdownToAnsi ( $ comment ) ) ) ; } return '' ; } 
public function parse ( $ rawBody , $ contentType ) { if ( ! $ this -> force ) { if ( ! empty ( $ _POST ) || ! empty ( $ _FILES ) ) { 
private function addValue ( & $ array , $ name , $ value ) { $ nameParts = preg_split ( '/\\]\\[|\\[/s' , $ name ) ; $ current = & $ array ; foreach ( $ nameParts as $ namePart ) { $ namePart = trim ( $ namePart , ']' ) ; if ( $ namePart === '' ) { $ current [ ] = [ ] ; $ keys = array_keys ( $ current ) ; $ lastKey = array_pop ( $ keys ) ; $ current = & $ current [ $ lastKey ] ; } else { if ( ! isset ( $ current [ $ namePart ] ) ) { $ current [ $ namePart ] = [ ] ; } $ current = & $ current [ $ namePart ] ; } } $ current = $ value ; } 
private function addFile ( & $ files , $ name , $ info ) { if ( strpos ( $ name , '[' ) === false ) { $ files [ $ name ] = $ info ; return ; } $ fileInfoAttributes = [ 'name' , 'type' , 'size' , 'error' , 'tmp_name' , 'tmp_resource' , ] ; $ nameParts = preg_split ( '/\\]\\[|\\[/s' , $ name ) ; $ baseName = array_shift ( $ nameParts ) ; if ( ! isset ( $ files [ $ baseName ] ) ) { $ files [ $ baseName ] = [ ] ; foreach ( $ fileInfoAttributes as $ attribute ) { $ files [ $ baseName ] [ $ attribute ] = [ ] ; } } else { foreach ( $ fileInfoAttributes as $ attribute ) { $ files [ $ baseName ] [ $ attribute ] = ( array ) $ files [ $ baseName ] [ $ attribute ] ; } } foreach ( $ fileInfoAttributes as $ attribute ) { if ( ! isset ( $ info [ $ attribute ] ) ) { continue ; } $ current = & $ files [ $ baseName ] [ $ attribute ] ; foreach ( $ nameParts as $ namePart ) { $ namePart = trim ( $ namePart , ']' ) ; if ( $ namePart === '' ) { $ current [ ] = [ ] ; $ keys = array_keys ( $ current ) ; $ lastKey = array_pop ( $ keys ) ; $ current = & $ current [ $ lastKey ] ; } else { if ( ! isset ( $ current [ $ namePart ] ) ) { $ current [ $ namePart ] = [ ] ; } $ current = & $ current [ $ namePart ] ; } } $ current = $ info [ $ attribute ] ; } } 
private function getByteSize ( $ verboseSize ) { if ( empty ( $ verboseSize ) ) { return 0 ; } if ( is_numeric ( $ verboseSize ) ) { return ( int ) $ verboseSize ; } $ sizeUnit = trim ( $ verboseSize , '0123456789' ) ; $ size = trim ( str_replace ( $ sizeUnit , '' , $ verboseSize ) ) ; if ( ! is_numeric ( $ size ) ) { return 0 ; } switch ( strtolower ( $ sizeUnit ) ) { case 'kb' : case 'k' : return $ size * 1024 ; case 'mb' : case 'm' : return $ size * 1024 * 1024 ; case 'gb' : case 'g' : return $ size * 1024 * 1024 * 1024 ; default : return 0 ; } } 
protected function renderException ( $ exception ) { if ( Yii :: $ app -> has ( 'response' ) ) { $ response = Yii :: $ app -> getResponse ( ) ; 
public function addTypeLinks ( $ code ) { if ( preg_match ( '/(.*?)::([^(]+)/' , $ code , $ matches ) ) { $ class = $ matches [ 1 ] ; $ method = $ matches [ 2 ] ; $ text = $ this -> htmlEncode ( $ class ) . '::' . $ this -> htmlEncode ( $ method ) ; } else { $ class = $ code ; $ method = null ; $ text = $ this -> htmlEncode ( $ class ) ; } $ url = null ; $ shouldGenerateLink = true ; if ( $ method !== null && substr_compare ( $ method , '{closure}' , - 9 ) !== 0 ) { $ reflection = new \ ReflectionClass ( $ class ) ; if ( $ reflection -> hasMethod ( $ method ) ) { $ reflectionMethod = $ reflection -> getMethod ( $ method ) ; $ shouldGenerateLink = $ reflectionMethod -> isPublic ( ) || $ reflectionMethod -> isProtected ( ) ; } else { $ shouldGenerateLink = false ; } } if ( $ shouldGenerateLink ) { $ url = $ this -> getTypeUrl ( $ class , $ method ) ; } if ( $ url === null ) { return $ text ; } return '<a href="' . $ url . '" target="_blank">' . $ text . '</a>' ; } 
public function renderCallStackItem ( $ file , $ line , $ class , $ method , $ args , $ index ) { $ lines = [ ] ; $ begin = $ end = 0 ; if ( $ file !== null && $ line !== null ) { $ line -- ; 
public function renderCallStack ( $ exception ) { $ out = '<ul>' ; $ out .= $ this -> renderCallStackItem ( $ exception -> getFile ( ) , $ exception -> getLine ( ) , null , null , [ ] , 1 ) ; for ( $ i = 0 , $ trace = $ exception -> getTrace ( ) , $ length = count ( $ trace ) ; $ i < $ length ; ++ $ i ) { $ file = ! empty ( $ trace [ $ i ] [ 'file' ] ) ? $ trace [ $ i ] [ 'file' ] : null ; $ line = ! empty ( $ trace [ $ i ] [ 'line' ] ) ? $ trace [ $ i ] [ 'line' ] : null ; $ class = ! empty ( $ trace [ $ i ] [ 'class' ] ) ? $ trace [ $ i ] [ 'class' ] : null ; $ function = null ; if ( ! empty ( $ trace [ $ i ] [ 'function' ] ) && $ trace [ $ i ] [ 'function' ] !== 'unknown' ) { $ function = $ trace [ $ i ] [ 'function' ] ; } $ args = ! empty ( $ trace [ $ i ] [ 'args' ] ) ? $ trace [ $ i ] [ 'args' ] : [ ] ; $ out .= $ this -> renderCallStackItem ( $ file , $ line , $ class , $ function , $ args , $ i + 2 ) ; } $ out .= '</ul>' ; return $ out ; } 
public function createServerInformationLink ( ) { $ serverUrls = [ 'http://httpd.apache.org/' => [ 'apache' ] , 'http://nginx.org/' => [ 'nginx' ] , 'http://lighttpd.net/' => [ 'lighttpd' ] , 'http://gwan.com/' => [ 'g-wan' , 'gwan' ] , 'http://iis.net/' => [ 'iis' , 'services' ] , 'https://secure.php.net/manual/en/features.commandline.webserver.php' => [ 'development' ] , ] ; if ( isset ( $ _SERVER [ 'SERVER_SOFTWARE' ] ) ) { foreach ( $ serverUrls as $ url => $ keywords ) { foreach ( $ keywords as $ keyword ) { if ( stripos ( $ _SERVER [ 'SERVER_SOFTWARE' ] , $ keyword ) !== false ) { return '<a href="' . $ url . '" target="_blank">' . $ this -> htmlEncode ( $ _SERVER [ 'SERVER_SOFTWARE' ] ) . '</a>' ; } } } } return '' ; } 
public function argumentsToString ( $ args ) { $ count = 0 ; $ isAssoc = $ args !== array_values ( $ args ) ; foreach ( $ args as $ key => $ value ) { $ count ++ ; if ( $ count >= 5 ) { if ( $ count > 5 ) { unset ( $ args [ $ key ] ) ; } else { $ args [ $ key ] = '...' ; } continue ; } if ( is_object ( $ value ) ) { $ args [ $ key ] = '<span class="title">' . $ this -> htmlEncode ( get_class ( $ value ) ) . '</span>' ; } elseif ( is_bool ( $ value ) ) { $ args [ $ key ] = '<span class="keyword">' . ( $ value ? 'true' : 'false' ) . '</span>' ; } elseif ( is_string ( $ value ) ) { $ fullValue = $ this -> htmlEncode ( $ value ) ; if ( mb_strlen ( $ value , 'UTF-8' ) > 32 ) { $ displayValue = $ this -> htmlEncode ( mb_substr ( $ value , 0 , 32 , 'UTF-8' ) ) . '...' ; $ args [ $ key ] = "<span class=\"string\" title=\"$fullValue\">'$displayValue'</span>" ; } else { $ args [ $ key ] = "<span class=\"string\">'$fullValue'</span>" ; } } elseif ( is_array ( $ value ) ) { $ args [ $ key ] = '[' . $ this -> argumentsToString ( $ value ) . ']' ; } elseif ( $ value === null ) { $ args [ $ key ] = '<span class="keyword">null</span>' ; } elseif ( is_resource ( $ value ) ) { $ args [ $ key ] = '<span class="keyword">resource</span>' ; } else { $ args [ $ key ] = '<span class="number">' . $ value . '</span>' ; } if ( is_string ( $ key ) ) { $ args [ $ key ] = '<span class="string">\'' . $ this -> htmlEncode ( $ key ) . "'</span> => $args[$key]" ; } elseif ( $ isAssoc ) { $ args [ $ key ] = "<span class=\"number\">$key</span> => $args[$key]" ; } } return implode ( ', ' , $ args ) ; } 
public function getExceptionName ( $ exception ) { if ( $ exception instanceof \ yii \ base \ Exception || $ exception instanceof \ yii \ base \ InvalidCallException || $ exception instanceof \ yii \ base \ InvalidParamException || $ exception instanceof \ yii \ base \ UnknownMethodException ) { return $ exception -> getName ( ) ; } return null ; } 
public function up ( ) { $ authManager = $ this -> getAuthManager ( ) ; $ this -> dropIndex ( 'auth_assignment_user_id_idx' , $ authManager -> assignmentTable ) ; $ this -> createIndex ( '{{%idx-auth_assignment-user_id}}' , $ authManager -> assignmentTable , 'user_id' ) ; $ this -> dropIndex ( 'idx-auth_item-type' , $ authManager -> itemTable ) ; $ this -> createIndex ( '{{%idx-auth_item-type}}' , $ authManager -> itemTable , 'type' ) ; } 
public function down ( ) { $ authManager = $ this -> getAuthManager ( ) ; $ this -> dropIndex ( '{{%idx-auth_assignment-user_id}}' , $ authManager -> assignmentTable ) ; $ this -> createIndex ( 'auth_assignment_user_id_idx' , $ authManager -> assignmentTable , 'user_id' ) ; $ this -> dropIndex ( '{{%idx-auth_item-type}}' , $ authManager -> itemTable ) ; $ this -> createIndex ( 'idx-auth_item-type' , $ authManager -> itemTable , 'type' ) ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> notImage === null ) { $ this -> notImage = Yii :: t ( 'yii' , 'The file "{file}" is not an image.' ) ; } if ( $ this -> underWidth === null ) { $ this -> underWidth = Yii :: t ( 'yii' , 'The image "{file}" is too small. The width cannot be smaller than {limit, number} {limit, plural, one{pixel} other{pixels}}.' ) ; } if ( $ this -> underHeight === null ) { $ this -> underHeight = Yii :: t ( 'yii' , 'The image "{file}" is too small. The height cannot be smaller than {limit, number} {limit, plural, one{pixel} other{pixels}}.' ) ; } if ( $ this -> overWidth === null ) { $ this -> overWidth = Yii :: t ( 'yii' , 'The image "{file}" is too large. The width cannot be larger than {limit, number} {limit, plural, one{pixel} other{pixels}}.' ) ; } if ( $ this -> overHeight === null ) { $ this -> overHeight = Yii :: t ( 'yii' , 'The image "{file}" is too large. The height cannot be larger than {limit, number} {limit, plural, one{pixel} other{pixels}}.' ) ; } } 
protected function validateValue ( $ value ) { $ result = parent :: validateValue ( $ value ) ; return empty ( $ result ) ? $ this -> validateImage ( $ value ) : $ result ; } 
protected function validateImage ( $ image ) { if ( false === ( $ imageInfo = getimagesize ( $ image -> tempName ) ) ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } list ( $ width , $ height ) = $ imageInfo ; if ( $ width == 0 || $ height == 0 ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } if ( $ this -> minWidth !== null && $ width < $ this -> minWidth ) { return [ $ this -> underWidth , [ 'file' => $ image -> name , 'limit' => $ this -> minWidth ] ] ; } if ( $ this -> minHeight !== null && $ height < $ this -> minHeight ) { return [ $ this -> underHeight , [ 'file' => $ image -> name , 'limit' => $ this -> minHeight ] ] ; } if ( $ this -> maxWidth !== null && $ width > $ this -> maxWidth ) { return [ $ this -> overWidth , [ 'file' => $ image -> name , 'limit' => $ this -> maxWidth ] ] ; } if ( $ this -> maxHeight !== null && $ height > $ this -> maxHeight ) { return [ $ this -> overHeight , [ 'file' => $ image -> name , 'limit' => $ this -> maxHeight ] ] ; } return null ; } 
public function getClientOptions ( $ model , $ attribute ) { $ options = parent :: getClientOptions ( $ model , $ attribute ) ; $ label = $ model -> getAttributeLabel ( $ attribute ) ; if ( $ this -> notImage !== null ) { $ options [ 'notImage' ] = $ this -> formatMessage ( $ this -> notImage , [ 'attribute' => $ label , ] ) ; } if ( $ this -> minWidth !== null ) { $ options [ 'minWidth' ] = $ this -> minWidth ; $ options [ 'underWidth' ] = $ this -> formatMessage ( $ this -> underWidth , [ 'attribute' => $ label , 'limit' => $ this -> minWidth , ] ) ; } if ( $ this -> maxWidth !== null ) { $ options [ 'maxWidth' ] = $ this -> maxWidth ; $ options [ 'overWidth' ] = $ this -> formatMessage ( $ this -> overWidth , [ 'attribute' => $ label , 'limit' => $ this -> maxWidth , ] ) ; } if ( $ this -> minHeight !== null ) { $ options [ 'minHeight' ] = $ this -> minHeight ; $ options [ 'underHeight' ] = $ this -> formatMessage ( $ this -> underHeight , [ 'attribute' => $ label , 'limit' => $ this -> minHeight , ] ) ; } if ( $ this -> maxHeight !== null ) { $ options [ 'maxHeight' ] = $ this -> maxHeight ; $ options [ 'overHeight' ] = $ this -> formatMessage ( $ this -> overHeight , [ 'attribute' => $ label , 'limit' => $ this -> maxHeight , ] ) ; } return $ options ; } 
protected function addValue ( $ key , $ value , $ duration ) { return zend_shm_cache_fetch ( $ key ) === null ? $ this -> setValue ( $ key , $ value , $ duration ) : false ; } 
public function init ( ) { $ attributes = [ ] ; foreach ( $ this -> attributes as $ name => $ attribute ) { if ( ! is_array ( $ attribute ) ) { $ attributes [ $ attribute ] = [ 'asc' => [ $ attribute => SORT_ASC ] , 'desc' => [ $ attribute => SORT_DESC ] , ] ; } elseif ( ! isset ( $ attribute [ 'asc' ] , $ attribute [ 'desc' ] ) ) { $ attributes [ $ name ] = array_merge ( [ 'asc' => [ $ name => SORT_ASC ] , 'desc' => [ $ name => SORT_DESC ] , ] , $ attribute ) ; } else { $ attributes [ $ name ] = $ attribute ; } } $ this -> attributes = $ attributes ; } 
public function getOrders ( $ recalculate = false ) { $ attributeOrders = $ this -> getAttributeOrders ( $ recalculate ) ; $ orders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ direction ) { $ definition = $ this -> attributes [ $ attribute ] ; $ columns = $ definition [ $ direction === SORT_ASC ? 'asc' : 'desc' ] ; if ( is_array ( $ columns ) || $ columns instanceof \ Traversable ) { foreach ( $ columns as $ name => $ dir ) { $ orders [ $ name ] = $ dir ; } } else { $ orders [ ] = $ columns ; } } return $ orders ; } 
public function getAttributeOrders ( $ recalculate = false ) { if ( $ this -> _attributeOrders === null || $ recalculate ) { $ this -> _attributeOrders = [ ] ; if ( ( $ params = $ this -> params ) === null ) { $ request = Yii :: $ app -> getRequest ( ) ; $ params = $ request instanceof Request ? $ request -> getQueryParams ( ) : [ ] ; } if ( isset ( $ params [ $ this -> sortParam ] ) ) { foreach ( $ this -> parseSortParam ( $ params [ $ this -> sortParam ] ) as $ attribute ) { $ descending = false ; if ( strncmp ( $ attribute , '-' , 1 ) === 0 ) { $ descending = true ; $ attribute = substr ( $ attribute , 1 ) ; } if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ descending ? SORT_DESC : SORT_ASC ; if ( ! $ this -> enableMultiSort ) { return $ this -> _attributeOrders ; } } } } if ( empty ( $ this -> _attributeOrders ) && is_array ( $ this -> defaultOrder ) ) { $ this -> _attributeOrders = $ this -> defaultOrder ; } } return $ this -> _attributeOrders ; } 
public function setAttributeOrders ( $ attributeOrders , $ validate = true ) { if ( $ attributeOrders === null || ! $ validate ) { $ this -> _attributeOrders = $ attributeOrders ; } else { $ this -> _attributeOrders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ order ) { if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ order ; if ( ! $ this -> enableMultiSort ) { break ; } } } } } 
public function getAttributeOrder ( $ attribute ) { $ orders = $ this -> getAttributeOrders ( ) ; return isset ( $ orders [ $ attribute ] ) ? $ orders [ $ attribute ] : null ; } 
public function link ( $ attribute , $ options = [ ] ) { if ( ( $ direction = $ this -> getAttributeOrder ( $ attribute ) ) !== null ) { $ class = $ direction === SORT_DESC ? 'desc' : 'asc' ; if ( isset ( $ options [ 'class' ] ) ) { $ options [ 'class' ] .= ' ' . $ class ; } else { $ options [ 'class' ] = $ class ; } } $ url = $ this -> createUrl ( $ attribute ) ; $ options [ 'data-sort' ] = $ this -> createSortParam ( $ attribute ) ; if ( isset ( $ options [ 'label' ] ) ) { $ label = $ options [ 'label' ] ; unset ( $ options [ 'label' ] ) ; } else { if ( isset ( $ this -> attributes [ $ attribute ] [ 'label' ] ) ) { $ label = $ this -> attributes [ $ attribute ] [ 'label' ] ; } else { $ label = Inflector :: camel2words ( $ attribute ) ; } } return Html :: a ( $ label , $ url , $ options ) ; } 
public function createUrl ( $ attribute , $ absolute = false ) { if ( ( $ params = $ this -> params ) === null ) { $ request = Yii :: $ app -> getRequest ( ) ; $ params = $ request instanceof Request ? $ request -> getQueryParams ( ) : [ ] ; } $ params [ $ this -> sortParam ] = $ this -> createSortParam ( $ attribute ) ; $ params [ 0 ] = $ this -> route === null ? Yii :: $ app -> controller -> getRoute ( ) : $ this -> route ; $ urlManager = $ this -> urlManager === null ? Yii :: $ app -> getUrlManager ( ) : $ this -> urlManager ; if ( $ absolute ) { return $ urlManager -> createAbsoluteUrl ( $ params ) ; } return $ urlManager -> createUrl ( $ params ) ; } 
public function loadDefaultValues ( $ skipIfSet = true ) { foreach ( static :: getTableSchema ( ) -> columns as $ column ) { if ( $ column -> defaultValue !== null && ( ! $ skipIfSet || $ this -> { $ column -> name } === null ) ) { $ this -> { $ column -> name } = $ column -> defaultValue ; } } return $ this ; } 
public static function findBySql ( $ sql , $ params = [ ] ) { $ query = static :: find ( ) ; $ query -> sql = $ sql ; return $ query -> params ( $ params ) ; } 
protected static function filterValidAliases ( Query $ query ) { $ tables = $ query -> getTablesUsedInFrom ( ) ; $ aliases = array_diff ( array_keys ( $ tables ) , $ tables ) ; return array_map ( function ( $ alias ) { return preg_replace ( '/{{([\w]+)}}/' , '$1' , $ alias ) ; } , array_values ( $ aliases ) ) ; } 
protected static function filterCondition ( array $ condition , array $ aliases = [ ] ) { $ result = [ ] ; $ db = static :: getDb ( ) ; $ columnNames = static :: filterValidColumnNames ( $ db , $ aliases ) ; foreach ( $ condition as $ key => $ value ) { if ( is_string ( $ key ) && ! in_array ( $ db -> quoteSql ( $ key ) , $ columnNames , true ) ) { throw new InvalidArgumentException ( 'Key "' . $ key . '" is not a column name and can not be used as a filter' ) ; } $ result [ $ key ] = is_array ( $ value ) ? array_values ( $ value ) : $ value ; } return $ result ; } 
protected static function filterValidColumnNames ( $ db , array $ aliases ) { $ columnNames = [ ] ; $ tableName = static :: tableName ( ) ; $ quotedTableName = $ db -> quoteTableName ( $ tableName ) ; foreach ( static :: getTableSchema ( ) -> getColumnNames ( ) as $ columnName ) { $ columnNames [ ] = $ columnName ; $ columnNames [ ] = $ db -> quoteColumnName ( $ columnName ) ; $ columnNames [ ] = "$tableName.$columnName" ; $ columnNames [ ] = $ db -> quoteSql ( "$quotedTableName.[[$columnName]]" ) ; foreach ( $ aliases as $ tableAlias ) { $ columnNames [ ] = "$tableAlias.$columnName" ; $ quotedTableAlias = $ db -> quoteTableName ( $ tableAlias ) ; $ columnNames [ ] = $ db -> quoteSql ( "$quotedTableAlias.[[$columnName]]" ) ; } } return $ columnNames ; } 
public function refresh ( ) { $ query = static :: find ( ) ; $ tableName = key ( $ query -> getTablesUsedInFrom ( ) ) ; $ pk = [ ] ; 
public static function updateAll ( $ attributes , $ condition = '' , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> update ( static :: tableName ( ) , $ attributes , $ condition , $ params ) ; return $ command -> execute ( ) ; } 
public static function updateAllCounters ( $ counters , $ condition = '' , $ params = [ ] ) { $ n = 0 ; foreach ( $ counters as $ name => $ value ) { $ counters [ $ name ] = new Expression ( "[[$name]]+:bp{$n}" , [ ":bp{$n}" => $ value ] ) ; $ n ++ ; } $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> update ( static :: tableName ( ) , $ counters , $ condition , $ params ) ; return $ command -> execute ( ) ; } 
public static function deleteAll ( $ condition = null , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> delete ( static :: tableName ( ) , $ condition , $ params ) ; return $ command -> execute ( ) ; } 
public static function getTableSchema ( ) { $ tableSchema = static :: getDb ( ) -> getSchema ( ) -> getTableSchema ( static :: tableName ( ) ) ; if ( $ tableSchema === null ) { throw new InvalidConfigException ( 'The table does not exist: ' . static :: tableName ( ) ) ; } return $ tableSchema ; } 
public static function populateRecord ( $ record , $ row ) { $ columns = static :: getTableSchema ( ) -> columns ; foreach ( $ row as $ name => $ value ) { if ( isset ( $ columns [ $ name ] ) ) { $ row [ $ name ] = $ columns [ $ name ] -> phpTypecast ( $ value ) ; } } parent :: populateRecord ( $ record , $ row ) ; } 
public function delete ( ) { if ( ! $ this -> isTransactional ( self :: OP_DELETE ) ) { return $ this -> deleteInternal ( ) ; } $ transaction = static :: getDb ( ) -> beginTransaction ( ) ; try { $ result = $ this -> deleteInternal ( ) ; if ( $ result === false ) { $ transaction -> rollBack ( ) ; } else { $ transaction -> commit ( ) ; } return $ result ; } catch ( \ Exception $ e ) { $ transaction -> rollBack ( ) ; throw $ e ; } catch ( \ Throwable $ e ) { $ transaction -> rollBack ( ) ; throw $ e ; } } 
protected function deleteInternal ( ) { if ( ! $ this -> beforeDelete ( ) ) { return false ; } 
public function equals ( $ record ) { if ( $ this -> isNewRecord || $ record -> isNewRecord ) { return false ; } return static :: tableName ( ) === $ record -> tableName ( ) && $ this -> getPrimaryKey ( ) === $ record -> getPrimaryKey ( ) ; } 
public function isTransactional ( $ operation ) { $ scenario = $ this -> getScenario ( ) ; $ transactions = $ this -> transactions ( ) ; return isset ( $ transactions [ $ scenario ] ) && ( $ transactions [ $ scenario ] & $ operation ) ; } 
protected function updateDynamicContent ( $ content , $ placeholders , $ isRestoredFromCache = false ) { if ( empty ( $ placeholders ) || ! is_array ( $ placeholders ) ) { return $ content ; } if ( count ( $ this -> getView ( ) -> getDynamicContents ( ) ) === 0 ) { 
public static function process ( $ markdown , $ flavor = null ) { $ parser = static :: getParser ( $ flavor ) ; return $ parser -> parse ( $ markdown ) ; } 
public static function processParagraph ( $ markdown , $ flavor = null ) { $ parser = static :: getParser ( $ flavor ) ; return $ parser -> parseParagraph ( $ markdown ) ; } 
public static function process ( $ content , $ config = null ) { $ configInstance = \ HTMLPurifier_Config :: create ( $ config instanceof \ Closure ? null : $ config ) ; $ configInstance -> autoFinalize = false ; $ purifier = \ HTMLPurifier :: instance ( $ configInstance ) ; $ purifier -> config -> set ( 'Cache.SerializerPath' , \ Yii :: $ app -> getRuntimePath ( ) ) ; $ purifier -> config -> set ( 'Cache.SerializerPermissions' , 0775 ) ; static :: configure ( $ configInstance ) ; if ( $ config instanceof \ Closure ) { call_user_func ( $ config , $ configInstance ) ; } return $ purifier -> purify ( $ content ) ; } 
public function beforeAction ( $ action ) { $ this -> request = $ this -> request ? : Yii :: $ app -> getRequest ( ) ; $ this -> response = $ this -> response ? : Yii :: $ app -> getResponse ( ) ; $ this -> overrideDefaultSettings ( $ action ) ; $ requestCorsHeaders = $ this -> extractHeaders ( ) ; $ responseCorsHeaders = $ this -> prepareHeaders ( $ requestCorsHeaders ) ; $ this -> addCorsHeaders ( $ this -> response , $ responseCorsHeaders ) ; if ( $ this -> request -> isOptions && $ this -> request -> headers -> has ( 'Access-Control-Request-Method' ) ) { 
public function overrideDefaultSettings ( $ action ) { if ( isset ( $ this -> actions [ $ action -> id ] ) ) { $ actionParams = $ this -> actions [ $ action -> id ] ; $ actionParamsKeys = array_keys ( $ actionParams ) ; foreach ( $ this -> cors as $ headerField => $ headerValue ) { if ( in_array ( $ headerField , $ actionParamsKeys ) ) { $ this -> cors [ $ headerField ] = $ actionParams [ $ headerField ] ; } } } } 
public function prepareHeaders ( $ requestHeaders ) { $ responseHeaders = [ ] ; 
public function addCorsHeaders ( $ response , $ headers ) { if ( empty ( $ headers ) === false ) { $ responseHeaders = $ response -> getHeaders ( ) ; foreach ( $ headers as $ field => $ value ) { $ responseHeaders -> set ( $ field , $ value ) ; } } } 
protected function filterHeaders ( HeaderCollection $ headerCollection ) { 
public function getMethod ( ) { if ( isset ( $ _POST [ $ this -> methodParam ] ) 
public function getIsFlash ( ) { $ userAgent = $ this -> headers -> get ( 'User-Agent' , '' ) ; return stripos ( $ userAgent , 'Shockwave' ) !== false || stripos ( $ userAgent , 'Flash' ) !== false ; } 
public function getBodyParams ( ) { if ( $ this -> _bodyParams === null ) { if ( isset ( $ _POST [ $ this -> methodParam ] ) ) { $ this -> _bodyParams = $ _POST ; unset ( $ this -> _bodyParams [ $ this -> methodParam ] ) ; return $ this -> _bodyParams ; } $ rawContentType = $ this -> getContentType ( ) ; if ( ( $ pos = strpos ( $ rawContentType , ';' ) ) !== false ) { 
public function getBodyParam ( $ name , $ defaultValue = null ) { $ params = $ this -> getBodyParams ( ) ; if ( is_object ( $ params ) ) { 
public function get ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getQueryParams ( ) ; } return $ this -> getQueryParam ( $ name , $ defaultValue ) ; } 
public function getHostInfo ( ) { if ( $ this -> _hostInfo === null ) { $ secure = $ this -> getIsSecureConnection ( ) ; $ http = $ secure ? 'https' : 'http' ; if ( $ this -> headers -> has ( 'X-Forwarded-Host' ) ) { $ this -> _hostInfo = $ http . '://' . trim ( explode ( ',' , $ this -> headers -> get ( 'X-Forwarded-Host' ) ) [ 0 ] ) ; } elseif ( $ this -> headers -> has ( 'Host' ) ) { $ this -> _hostInfo = $ http . '://' . $ this -> headers -> get ( 'Host' ) ; } elseif ( isset ( $ _SERVER [ 'SERVER_NAME' ] ) ) { $ this -> _hostInfo = $ http . '://' . $ _SERVER [ 'SERVER_NAME' ] ; $ port = $ secure ? $ this -> getSecurePort ( ) : $ this -> getPort ( ) ; if ( ( $ port !== 80 && ! $ secure ) || ( $ port !== 443 && $ secure ) ) { $ this -> _hostInfo .= ':' . $ port ; } } } return $ this -> _hostInfo ; } 
public function setHostInfo ( $ value ) { $ this -> _hostName = null ; $ this -> _hostInfo = $ value === null ? null : rtrim ( $ value , '/' ) ; } 
public function getHostName ( ) { if ( $ this -> _hostName === null ) { $ this -> _hostName = parse_url ( $ this -> getHostInfo ( ) , PHP_URL_HOST ) ; } return $ this -> _hostName ; } 
public function getBaseUrl ( ) { if ( $ this -> _baseUrl === null ) { $ this -> _baseUrl = rtrim ( dirname ( $ this -> getScriptUrl ( ) ) , '\\/' ) ; } return $ this -> _baseUrl ; } 
public function getScriptFile ( ) { if ( isset ( $ this -> _scriptFile ) ) { return $ this -> _scriptFile ; } if ( isset ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ) { return $ _SERVER [ 'SCRIPT_FILENAME' ] ; } throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } 
public function getPathInfo ( ) { if ( $ this -> _pathInfo === null ) { $ this -> _pathInfo = $ this -> resolvePathInfo ( ) ; } return $ this -> _pathInfo ; } 
private function utf8Encode ( $ s ) { $ s .= $ s ; $ len = \ strlen ( $ s ) ; for ( $ i = $ len >> 1 , $ j = 0 ; $ i < $ len ; ++ $ i , ++ $ j ) { switch ( true ) { case $ s [ $ i ] < "\x80" : $ s [ $ j ] = $ s [ $ i ] ; break ; case $ s [ $ i ] < "\xC0" : $ s [ $ j ] = "\xC2" ; $ s [ ++ $ j ] = $ s [ $ i ] ; break ; default : $ s [ $ j ] = "\xC3" ; $ s [ ++ $ j ] = \ chr ( \ ord ( $ s [ $ i ] ) - 64 ) ; break ; } } return substr ( $ s , 0 , $ j ) ; } 
public function getUrl ( ) { if ( $ this -> _url === null ) { $ this -> _url = $ this -> resolveRequestUri ( ) ; } return $ this -> _url ; } 
protected function resolveRequestUri ( ) { if ( $ this -> headers -> has ( 'X-Rewrite-Url' ) ) { 
public function getIsSecureConnection ( ) { if ( isset ( $ _SERVER [ 'HTTPS' ] ) && ( strcasecmp ( $ _SERVER [ 'HTTPS' ] , 'on' ) === 0 || $ _SERVER [ 'HTTPS' ] == 1 ) ) { return true ; } foreach ( $ this -> secureProtocolHeaders as $ header => $ values ) { if ( ( $ headerValue = $ this -> headers -> get ( $ header , null ) ) !== null ) { foreach ( $ values as $ value ) { if ( strcasecmp ( $ headerValue , $ value ) === 0 ) { return true ; } } } } return false ; } 
public function getPort ( ) { if ( $ this -> _port === null ) { $ serverPort = $ this -> getServerPort ( ) ; $ this -> _port = ! $ this -> getIsSecureConnection ( ) && $ serverPort !== null ? $ serverPort : 80 ; } return $ this -> _port ; } 
public function setPort ( $ value ) { if ( $ value != $ this -> _port ) { $ this -> _port = ( int ) $ value ; $ this -> _hostInfo = null ; } } 
public function getSecurePort ( ) { if ( $ this -> _securePort === null ) { $ serverPort = $ this -> getServerPort ( ) ; $ this -> _securePort = $ this -> getIsSecureConnection ( ) && $ serverPort !== null ? $ serverPort : 443 ; } return $ this -> _securePort ; } 
public function setSecurePort ( $ value ) { if ( $ value != $ this -> _securePort ) { $ this -> _securePort = ( int ) $ value ; $ this -> _hostInfo = null ; } } 
public function getAcceptableContentTypes ( ) { if ( $ this -> _contentTypes === null ) { if ( $ this -> headers -> get ( 'Accept' ) !== null ) { $ this -> _contentTypes = $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept' ) ) ; } else { $ this -> _contentTypes = [ ] ; } } return $ this -> _contentTypes ; } 
public function getAcceptableLanguages ( ) { if ( $ this -> _languages === null ) { if ( $ this -> headers -> has ( 'Accept-Language' ) ) { $ this -> _languages = array_keys ( $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept-Language' ) ) ) ; } else { $ this -> _languages = [ ] ; } } return $ this -> _languages ; } 
public function getETags ( ) { if ( $ this -> headers -> has ( 'If-None-Match' ) ) { return preg_split ( '/[\s,]+/' , str_replace ( '-gzip' , '' , $ this -> headers -> get ( 'If-None-Match' ) ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } return [ ] ; } 
public function getCookies ( ) { if ( $ this -> _cookies === null ) { $ this -> _cookies = new CookieCollection ( $ this -> loadCookies ( ) , [ 'readOnly' => true , ] ) ; } return $ this -> _cookies ; } 
protected function createCsrfCookie ( $ token ) { $ options = $ this -> csrfCookie ; return Yii :: createObject ( array_merge ( $ options , [ 'class' => 'yii\web\Cookie' , 'name' => $ this -> csrfParam , 'value' => $ token , ] ) ) ; } 
public function validateCsrfToken ( $ clientSuppliedToken = null ) { $ method = $ this -> getMethod ( ) ; 
private function validateCsrfTokenInternal ( $ clientSuppliedToken , $ trueToken ) { if ( ! is_string ( $ clientSuppliedToken ) ) { return false ; } $ security = Yii :: $ app -> security ; return $ security -> compareString ( $ security -> unmaskToken ( $ clientSuppliedToken ) , $ security -> unmaskToken ( $ trueToken ) ) ; } 
public function build ( ExpressionInterface $ expression , array & $ params = [ ] ) { $ value = $ expression -> getValue ( ) ; if ( $ value instanceof Query ) { list ( $ sql , $ params ) = $ this -> queryBuilder -> build ( $ value , $ params ) ; return "($sql)" ; } $ placeholder = static :: PARAM_PREFIX . count ( $ params ) ; $ params [ $ placeholder ] = Json :: encode ( $ value ) ; return "CAST($placeholder AS JSON)" ; } 
public function init ( ) { parent :: init ( ) ; if ( is_array ( $ this -> length ) ) { if ( isset ( $ this -> length [ 0 ] ) ) { $ this -> min = $ this -> length [ 0 ] ; } if ( isset ( $ this -> length [ 1 ] ) ) { $ this -> max = $ this -> length [ 1 ] ; } $ this -> length = null ; } if ( $ this -> encoding === null ) { $ this -> encoding = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; } if ( $ this -> message === null ) { $ this -> message = Yii :: t ( 'yii' , '{attribute} must be a string.' ) ; } if ( $ this -> min !== null && $ this -> tooShort === null ) { $ this -> tooShort = Yii :: t ( 'yii' , '{attribute} should contain at least {min, number} {min, plural, one{character} other{characters}}.' ) ; } if ( $ this -> max !== null && $ this -> tooLong === null ) { $ this -> tooLong = Yii :: t ( 'yii' , '{attribute} should contain at most {max, number} {max, plural, one{character} other{characters}}.' ) ; } if ( $ this -> length !== null && $ this -> notEqual === null ) { $ this -> notEqual = Yii :: t ( 'yii' , '{attribute} should contain {length, number} {length, plural, one{character} other{characters}}.' ) ; } } 
public function getClientOptions ( $ model , $ attribute ) { $ label = $ model -> getAttributeLabel ( $ attribute ) ; $ options = [ 'message' => $ this -> formatMessage ( $ this -> message , [ 'attribute' => $ label , ] ) , ] ; if ( $ this -> min !== null ) { $ options [ 'min' ] = $ this -> min ; $ options [ 'tooShort' ] = $ this -> formatMessage ( $ this -> tooShort , [ 'attribute' => $ label , 'min' => $ this -> min , ] ) ; } if ( $ this -> max !== null ) { $ options [ 'max' ] = $ this -> max ; $ options [ 'tooLong' ] = $ this -> formatMessage ( $ this -> tooLong , [ 'attribute' => $ label , 'max' => $ this -> max , ] ) ; } if ( $ this -> length !== null ) { $ options [ 'is' ] = $ this -> length ; $ options [ 'notEqual' ] = $ this -> formatMessage ( $ this -> notEqual , [ 'attribute' => $ label , 'length' => $ this -> length , ] ) ; } if ( $ this -> skipOnEmpty ) { $ options [ 'skipOnEmpty' ] = 1 ; } return $ options ; } 
public function run ( ) { $ block = ob_get_clean ( ) ; if ( $ this -> renderInPlace ) { echo $ block ; } $ this -> view -> blocks [ $ this -> getId ( ) ] = $ block ; } 
public function init ( ) { parent :: init ( ) ; if ( strncmp ( $ this -> db -> driverName , 'oci' , 3 ) !== 0 && strncmp ( $ this -> db -> driverName , 'odbc' , 4 ) !== 0 ) { throw new InvalidConfigException ( 'In order to use OracleMutex connection must be configured to use Oracle database.' ) ; } } 
protected function acquireLock ( $ name , $ timeout = 0 ) { $ lockStatus = null ; handle VARCHAR2(128); BEGIN DBMS_LOCK.ALLOCATE_UNIQUE(:name, handle); :lockStatus := DBMS_LOCK.REQUEST(handle, DBMS_LOCK.' . $ this -> lockMode . ', ' . $ timeout . ', ' . $ releaseOnCommit . '); END;' , [ ':name' => $ name ] ) -> bindParam ( ':lockStatus' , $ lockStatus , PDO :: PARAM_INT , 1 ) -> execute ( ) ; } ) ; return $ lockStatus === 0 || $ lockStatus === '0' ; } 
protected function releaseLock ( $ name ) { $ releaseStatus = null ; $ this -> db -> useMaster ( function ( $ db ) use ( $ name , & $ releaseStatus ) { $ db -> createCommand ( 'DECLARE handle VARCHAR2(128); BEGIN DBMS_LOCK.ALLOCATE_UNIQUE(:name, handle); :result := DBMS_LOCK.RELEASE(handle); END;' , [ ':name' => $ name ] ) -> bindParam ( ':result' , $ releaseStatus , PDO :: PARAM_INT , 1 ) -> execute ( ) ; } ) ; return $ releaseStatus === 0 || $ releaseStatus === '0' ; } 
public function begin ( ) { if ( $ this -> form -> enableClientScript ) { $ clientOptions = $ this -> getClientOptions ( ) ; if ( ! empty ( $ clientOptions ) ) { $ this -> form -> attributes [ ] = $ clientOptions ; } } $ inputID = $ this -> getInputId ( ) ; $ attribute = Html :: getAttributeName ( $ this -> attribute ) ; $ options = $ this -> options ; $ class = isset ( $ options [ 'class' ] ) ? ( array ) $ options [ 'class' ] : [ ] ; $ class [ ] = "field-$inputID" ; if ( $ this -> model -> isAttributeRequired ( $ attribute ) ) { $ class [ ] = $ this -> form -> requiredCssClass ; } $ options [ 'class' ] = implode ( ' ' , $ class ) ; if ( $ this -> form -> validationStateOn === ActiveForm :: VALIDATION_STATE_ON_CONTAINER ) { $ this -> addErrorClassIfNeeded ( $ options ) ; } $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'div' ) ; return Html :: beginTag ( $ tag , $ options ) ; } 
public function label ( $ label = null , $ options = [ ] ) { if ( $ label === false ) { $ this -> parts [ '{label}' ] = '' ; return $ this ; } $ options = array_merge ( $ this -> labelOptions , $ options ) ; if ( $ label !== null ) { $ options [ 'label' ] = $ label ; } if ( $ this -> _skipLabelFor ) { $ options [ 'for' ] = null ; } $ this -> parts [ '{label}' ] = Html :: activeLabel ( $ this -> model , $ this -> attribute , $ options ) ; return $ this ; } 
public function error ( $ options = [ ] ) { if ( $ options === false ) { $ this -> parts [ '{error}' ] = '' ; return $ this ; } $ options = array_merge ( $ this -> errorOptions , $ options ) ; $ this -> parts [ '{error}' ] = Html :: error ( $ this -> model , $ this -> attribute , $ options ) ; return $ this ; } 
public function hint ( $ content , $ options = [ ] ) { if ( $ content === false ) { $ this -> parts [ '{hint}' ] = '' ; return $ this ; } $ options = array_merge ( $ this -> hintOptions , $ options ) ; if ( $ content !== null ) { $ options [ 'hint' ] = $ content ; } $ this -> parts [ '{hint}' ] = Html :: activeHint ( $ this -> model , $ this -> attribute , $ options ) ; return $ this ; } 
public function input ( $ type , $ options = [ ] ) { $ options = array_merge ( $ this -> inputOptions , $ options ) ; if ( $ this -> form -> validationStateOn === ActiveForm :: VALIDATION_STATE_ON_INPUT ) { $ this -> addErrorClassIfNeeded ( $ options ) ; } $ this -> addAriaAttributes ( $ options ) ; $ this -> adjustLabelFor ( $ options ) ; $ this -> parts [ '{input}' ] = Html :: activeInput ( $ type , $ this -> model , $ this -> attribute , $ options ) ; return $ this ; } 
public function textInput ( $ options = [ ] ) { $ options = array_merge ( $ this -> inputOptions , $ options ) ; if ( $ this -> form -> validationStateOn === ActiveForm :: VALIDATION_STATE_ON_INPUT ) { $ this -> addErrorClassIfNeeded ( $ options ) ; } $ this -> addAriaAttributes ( $ options ) ; $ this -> adjustLabelFor ( $ options ) ; $ this -> parts [ '{input}' ] = Html :: activeTextInput ( $ this -> model , $ this -> attribute , $ options ) ; return $ this ; } 
public function hiddenInput ( $ options = [ ] ) { $ options = array_merge ( $ this -> inputOptions , $ options ) ; $ this -> adjustLabelFor ( $ options ) ; $ this -> parts [ '{input}' ] = Html :: activeHiddenInput ( $ this -> model , $ this -> attribute , $ options ) ; return $ this ; } 
public function passwordInput ( $ options = [ ] ) { $ options = array_merge ( $ this -> inputOptions , $ options ) ; if ( $ this -> form -> validationStateOn === ActiveForm :: VALIDATION_STATE_ON_INPUT ) { $ this -> addErrorClassIfNeeded ( $ options ) ; } $ this -> addAriaAttributes ( $ options ) ; $ this -> adjustLabelFor ( $ options ) ; $ this -> parts [ '{input}' ] = Html :: activePasswordInput ( $ this -> model , $ this -> attribute , $ options ) ; return $ this ; } 
public function fileInput ( $ options = [ ] ) { 
public function textarea ( $ options = [ ] ) { $ options = array_merge ( $ this -> inputOptions , $ options ) ; if ( $ this -> form -> validationStateOn === ActiveForm :: VALIDATION_STATE_ON_INPUT ) { $ this -> addErrorClassIfNeeded ( $ options ) ; } $ this -> addAriaAttributes ( $ options ) ; $ this -> adjustLabelFor ( $ options ) ; $ this -> parts [ '{input}' ] = Html :: activeTextarea ( $ this -> model , $ this -> attribute , $ options ) ; return $ this ; } 
public function radio ( $ options = [ ] , $ enclosedByLabel = true ) { if ( $ enclosedByLabel ) { $ this -> parts [ '{input}' ] = Html :: activeRadio ( $ this -> model , $ this -> attribute , $ options ) ; $ this -> parts [ '{label}' ] = '' ; } else { if ( isset ( $ options [ 'label' ] ) && ! isset ( $ this -> parts [ '{label}' ] ) ) { $ this -> parts [ '{label}' ] = $ options [ 'label' ] ; if ( ! empty ( $ options [ 'labelOptions' ] ) ) { $ this -> labelOptions = $ options [ 'labelOptions' ] ; } } unset ( $ options [ 'labelOptions' ] ) ; $ options [ 'label' ] = null ; $ this -> parts [ '{input}' ] = Html :: activeRadio ( $ this -> model , $ this -> attribute , $ options ) ; } if ( $ this -> form -> validationStateOn === ActiveForm :: VALIDATION_STATE_ON_INPUT ) { $ this -> addErrorClassIfNeeded ( $ options ) ; } $ this -> addAriaAttributes ( $ options ) ; $ this -> adjustLabelFor ( $ options ) ; return $ this ; } 
public function dropDownList ( $ items , $ options = [ ] ) { $ options = array_merge ( $ this -> inputOptions , $ options ) ; if ( $ this -> form -> validationStateOn === ActiveForm :: VALIDATION_STATE_ON_INPUT ) { $ this -> addErrorClassIfNeeded ( $ options ) ; } $ this -> addAriaAttributes ( $ options ) ; $ this -> adjustLabelFor ( $ options ) ; $ this -> parts [ '{input}' ] = Html :: activeDropDownList ( $ this -> model , $ this -> attribute , $ items , $ options ) ; return $ this ; } 
protected function adjustLabelFor ( $ options ) { if ( ! isset ( $ options [ 'id' ] ) ) { return ; } $ this -> _inputId = $ options [ 'id' ] ; if ( ! isset ( $ this -> labelOptions [ 'for' ] ) ) { $ this -> labelOptions [ 'for' ] = $ options [ 'id' ] ; } } 
protected function getClientOptions ( ) { $ attribute = Html :: getAttributeName ( $ this -> attribute ) ; if ( ! in_array ( $ attribute , $ this -> model -> activeAttributes ( ) , true ) ) { return [ ] ; } $ clientValidation = $ this -> isClientValidationEnabled ( ) ; $ ajaxValidation = $ this -> isAjaxValidationEnabled ( ) ; if ( $ clientValidation ) { $ validators = [ ] ; foreach ( $ this -> model -> getActiveValidators ( $ attribute ) as $ validator ) { $ js = $ validator -> clientValidateAttribute ( $ this -> model , $ attribute , $ this -> form -> getView ( ) ) ; if ( $ validator -> enableClientValidation && $ js != '' ) { if ( $ validator -> whenClient !== null ) { $ js = "if (({$validator->whenClient})(attribute, value)) { $js }" ; } $ validators [ ] = $ js ; } } } if ( ! $ ajaxValidation && ( ! $ clientValidation || empty ( $ validators ) ) ) { return [ ] ; } $ options = [ ] ; $ inputID = $ this -> getInputId ( ) ; $ options [ 'id' ] = Html :: getInputId ( $ this -> model , $ this -> attribute ) ; $ options [ 'name' ] = $ this -> attribute ; $ options [ 'container' ] = isset ( $ this -> selectors [ 'container' ] ) ? $ this -> selectors [ 'container' ] : ".field-$inputID" ; $ options [ 'input' ] = isset ( $ this -> selectors [ 'input' ] ) ? $ this -> selectors [ 'input' ] : "#$inputID" ; if ( isset ( $ this -> selectors [ 'error' ] ) ) { $ options [ 'error' ] = $ this -> selectors [ 'error' ] ; } elseif ( isset ( $ this -> errorOptions [ 'class' ] ) ) { $ options [ 'error' ] = '.' . implode ( '.' , preg_split ( '/\s+/' , $ this -> errorOptions [ 'class' ] , - 1 , PREG_SPLIT_NO_EMPTY ) ) ; } else { $ options [ 'error' ] = isset ( $ this -> errorOptions [ 'tag' ] ) ? $ this -> errorOptions [ 'tag' ] : 'span' ; } $ options [ 'encodeError' ] = ! isset ( $ this -> errorOptions [ 'encode' ] ) || $ this -> errorOptions [ 'encode' ] ; if ( $ ajaxValidation ) { $ options [ 'enableAjaxValidation' ] = true ; } foreach ( [ 'validateOnChange' , 'validateOnBlur' , 'validateOnType' , 'validationDelay' ] as $ name ) { $ options [ $ name ] = $ this -> $ name === null ? $ this -> form -> $ name : $ this -> $ name ; } if ( ! empty ( $ validators ) ) { $ options [ 'validate' ] = new JsExpression ( 'function (attribute, value, messages, deferred, $form) {' . implode ( '' , $ validators ) . '}' ) ; } if ( $ this -> addAriaAttributes === false ) { $ options [ 'updateAriaInvalid' ] = false ; } 
protected function addErrorClassIfNeeded ( & $ options ) { 
public static function getInstance ( ) { $ class = get_called_class ( ) ; return isset ( Yii :: $ app -> loadedModules [ $ class ] ) ? Yii :: $ app -> loadedModules [ $ class ] : null ; } 
public static function setInstance ( $ instance ) { if ( $ instance === null ) { unset ( Yii :: $ app -> loadedModules [ get_called_class ( ) ] ) ; } else { Yii :: $ app -> loadedModules [ get_class ( $ instance ) ] = $ instance ; } } 
public function init ( ) { if ( $ this -> controllerNamespace === null ) { $ class = get_class ( $ this ) ; if ( ( $ pos = strrpos ( $ class , '\\' ) ) !== false ) { $ this -> controllerNamespace = substr ( $ class , 0 , $ pos ) . '\\controllers' ; } } } 
public function getUniqueId ( ) { return $ this -> module ? ltrim ( $ this -> module -> getUniqueId ( ) . '/' . $ this -> id , '/' ) : $ this -> id ; } 
public function getBasePath ( ) { if ( $ this -> _basePath === null ) { $ class = new \ ReflectionClass ( $ this ) ; $ this -> _basePath = dirname ( $ class -> getFileName ( ) ) ; } return $ this -> _basePath ; } 
public function getVersion ( ) { if ( $ this -> _version === null ) { $ this -> _version = $ this -> defaultVersion ( ) ; } else { if ( ! is_scalar ( $ this -> _version ) ) { $ this -> _version = call_user_func ( $ this -> _version , $ this ) ; } } return $ this -> _version ; } 
public function setAliases ( $ aliases ) { foreach ( $ aliases as $ name => $ alias ) { Yii :: setAlias ( $ name , $ alias ) ; } } 
public function getModule ( $ id , $ load = true ) { if ( ( $ pos = strpos ( $ id , '/' ) ) !== false ) { 
public function setModule ( $ id , $ module ) { if ( $ module === null ) { unset ( $ this -> _modules [ $ id ] ) ; } else { $ this -> _modules [ $ id ] = $ module ; } } 
public function getModules ( $ loadedOnly = false ) { if ( $ loadedOnly ) { $ modules = [ ] ; foreach ( $ this -> _modules as $ module ) { if ( $ module instanceof self ) { $ modules [ ] = $ module ; } } return $ modules ; } return $ this -> _modules ; } 
public function setModules ( $ modules ) { foreach ( $ modules as $ id => $ module ) { $ this -> _modules [ $ id ] = $ module ; } } 
private function isIncorrectClassNameOrPrefix ( $ className , $ prefix ) { if ( ! preg_match ( '%^[a-z][a-z0-9\\-_]*$%' , $ className ) ) { return true ; } if ( $ prefix !== '' && ! preg_match ( '%^[a-z0-9_/]+$%i' , $ prefix ) ) { return true ; } return false ; } 
public function beforeAction ( $ action ) { $ event = new ActionEvent ( $ action ) ; $ this -> trigger ( self :: EVENT_BEFORE_ACTION , $ event ) ; return $ event -> isValid ; } 
public function afterAction ( $ action , $ result ) { $ event = new ActionEvent ( $ action ) ; $ event -> result = $ result ; $ this -> trigger ( self :: EVENT_AFTER_ACTION , $ event ) ; return $ event -> result ; } 
public function get ( $ id , $ throwException = true ) { if ( ! isset ( $ this -> module ) ) { return parent :: get ( $ id , $ throwException ) ; } $ component = parent :: get ( $ id , false ) ; if ( $ component === null ) { $ component = $ this -> module -> get ( $ id , $ throwException ) ; } return $ component ; } 
public function has ( $ id , $ checkInstance = false ) { return parent :: has ( $ id , $ checkInstance ) || ( isset ( $ this -> module ) && $ this -> module -> has ( $ id , $ checkInstance ) ) ; } 
public function authenticate ( $ user , $ request , $ response ) { list ( $ username , $ password ) = $ request -> getAuthCredentials ( ) ; if ( $ this -> auth ) { if ( $ username !== null || $ password !== null ) { $ identity = $ user -> getIdentity ( ) ? : call_user_func ( $ this -> auth , $ username , $ password ) ; if ( $ identity === null ) { $ this -> handleFailure ( $ response ) ; } elseif ( $ user -> getIdentity ( false ) !== $ identity ) { $ user -> switchIdentity ( $ identity ) ; } return $ identity ; } } elseif ( $ username !== null ) { $ identity = $ user -> loginByAccessToken ( $ username , get_class ( $ this ) ) ; if ( $ identity === null ) { $ this -> handleFailure ( $ response ) ; } return $ identity ; } return null ; } 
protected function validateValue ( $ value ) { if ( $ this -> compareValue === null ) { throw new InvalidConfigException ( 'CompareValidator::compareValue must be set.' ) ; } if ( ! $ this -> compareValues ( $ this -> operator , $ this -> type , $ value , $ this -> compareValue ) ) { return [ $ this -> message , [ 'compareAttribute' => $ this -> compareValue , 'compareValue' => $ this -> compareValue , 'compareValueOrAttribute' => $ this -> compareValue , ] ] ; } return null ; } 
protected function compareValues ( $ operator , $ type , $ value , $ compareValue ) { if ( $ type === self :: TYPE_NUMBER ) { $ value = ( float ) $ value ; $ compareValue = ( float ) $ compareValue ; } else { $ value = ( string ) $ value ; $ compareValue = ( string ) $ compareValue ; } switch ( $ operator ) { case '==' : return $ value == $ compareValue ; case '===' : return $ value === $ compareValue ; case '!=' : return $ value != $ compareValue ; case '!==' : return $ value !== $ compareValue ; case '>' : return $ value > $ compareValue ; case '>=' : return $ value >= $ compareValue ; case '<' : return $ value < $ compareValue ; case '<=' : return $ value <= $ compareValue ; default : return false ; } } 
public function __isset ( $ name ) { $ getter = 'get' . $ name ; if ( method_exists ( $ this , $ getter ) ) { return $ this -> $ getter ( ) !== null ; } 
public function hasProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { return $ this -> canGetProperty ( $ name , $ checkVars , $ checkBehaviors ) || $ this -> canSetProperty ( $ name , false , $ checkBehaviors ) ; } 
public function canGetProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { if ( method_exists ( $ this , 'get' . $ name ) || $ checkVars && property_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name , $ checkVars ) ) { return true ; } } } return false ; } 
public function hasMethod ( $ name , $ checkBehaviors = true ) { if ( method_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> hasMethod ( $ name ) ) { return true ; } } } return false ; } 
public function hasEventHandlers ( $ name ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( ! empty ( $ handlers ) && StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { return true ; } } return ! empty ( $ this -> _events [ $ name ] ) || Event :: hasHandlers ( $ this , $ name ) ; } 
public function off ( $ name , $ handler = null ) { $ this -> ensureBehaviors ( ) ; if ( empty ( $ this -> _events [ $ name ] ) && empty ( $ this -> _eventWildcards [ $ name ] ) ) { return false ; } if ( $ handler === null ) { unset ( $ this -> _events [ $ name ] , $ this -> _eventWildcards [ $ name ] ) ; return true ; } $ removed = false ; 
public function trigger ( $ name , Event $ event = null ) { $ this -> ensureBehaviors ( ) ; $ eventHandlers = [ ] ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ handlers ) ; } } if ( ! empty ( $ this -> _events [ $ name ] ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ this -> _events [ $ name ] ) ; } if ( ! empty ( $ eventHandlers ) ) { if ( $ event === null ) { $ event = new Event ( ) ; } if ( $ event -> sender === null ) { $ event -> sender = $ this ; } $ event -> handled = false ; $ event -> name = $ name ; foreach ( $ eventHandlers as $ handler ) { $ event -> data = $ handler [ 1 ] ; call_user_func ( $ handler [ 0 ] , $ event ) ; 
public function getBehavior ( $ name ) { $ this -> ensureBehaviors ( ) ; return isset ( $ this -> _behaviors [ $ name ] ) ? $ this -> _behaviors [ $ name ] : null ; } 
public function attachBehaviors ( $ behaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ behaviors as $ name => $ behavior ) { $ this -> attachBehaviorInternal ( $ name , $ behavior ) ; } } 
public function detachBehaviors ( ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ name => $ behavior ) { $ this -> detachBehavior ( $ name ) ; } } 
private function attachBehaviorInternal ( $ name , $ behavior ) { if ( ! ( $ behavior instanceof Behavior ) ) { $ behavior = Yii :: createObject ( $ behavior ) ; } if ( is_int ( $ name ) ) { $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ ] = $ behavior ; } else { if ( isset ( $ this -> _behaviors [ $ name ] ) ) { $ this -> _behaviors [ $ name ] -> detach ( ) ; } $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ $ name ] = $ behavior ; } return $ behavior ; } 
protected function typecast ( $ value ) { if ( $ value === '' && ! in_array ( $ this -> type , [ Schema :: TYPE_TEXT , Schema :: TYPE_STRING , Schema :: TYPE_BINARY , Schema :: TYPE_CHAR ] , true ) ) { return null ; } if ( $ value === null || gettype ( $ value ) === $ this -> phpType || $ value instanceof ExpressionInterface || $ value instanceof Query ) { return $ value ; } if ( is_array ( $ value ) && count ( $ value ) === 2 && isset ( $ value [ 1 ] ) && in_array ( $ value [ 1 ] , $ this -> getPdoParamTypes ( ) , true ) ) { return new PdoValue ( $ value [ 0 ] , $ value [ 1 ] ) ; } switch ( $ this -> phpType ) { case 'resource' : case 'string' : if ( is_resource ( $ value ) ) { return $ value ; } if ( is_float ( $ value ) ) { 
protected function registerLinkTags ( ) { $ view = $ this -> getView ( ) ; foreach ( $ this -> pagination -> getLinks ( ) as $ rel => $ href ) { $ view -> registerLinkTag ( [ 'rel' => $ rel , 'href' => $ href ] , $ rel ) ; } } 
protected function renderPageButtons ( ) { $ pageCount = $ this -> pagination -> getPageCount ( ) ; if ( $ pageCount < 2 && $ this -> hideOnSinglePage ) { return '' ; } $ buttons = [ ] ; $ currentPage = $ this -> pagination -> getPage ( ) ; 
protected function renderPageButton ( $ label , $ page , $ class , $ disabled , $ active ) { $ options = $ this -> linkContainerOptions ; $ linkWrapTag = ArrayHelper :: remove ( $ options , 'tag' , 'li' ) ; Html :: addCssClass ( $ options , empty ( $ class ) ? $ this -> pageCssClass : $ class ) ; if ( $ active ) { Html :: addCssClass ( $ options , $ this -> activePageCssClass ) ; } if ( $ disabled ) { Html :: addCssClass ( $ options , $ this -> disabledPageCssClass ) ; $ disabledItemOptions = $ this -> disabledListItemSubTagOptions ; $ tag = ArrayHelper :: remove ( $ disabledItemOptions , 'tag' , 'span' ) ; return Html :: tag ( $ linkWrapTag , Html :: tag ( $ tag , $ label , $ disabledItemOptions ) , $ options ) ; } $ linkOptions = $ this -> linkOptions ; $ linkOptions [ 'data-page' ] = $ page ; return Html :: tag ( $ linkWrapTag , Html :: a ( $ label , $ this -> pagination -> createUrl ( $ page ) , $ linkOptions ) , $ options ) ; } 
public function init ( ) { parent :: init ( ) ; $ this -> cachePath = Yii :: getAlias ( $ this -> cachePath ) ; if ( ! is_dir ( $ this -> cachePath ) ) { FileHelper :: createDirectory ( $ this -> cachePath , $ this -> dirMode , true ) ; } } 
public function exists ( $ key ) { $ cacheFile = $ this -> getCacheFile ( $ this -> buildKey ( $ key ) ) ; return @ filemtime ( $ cacheFile ) > time ( ) ; } 
protected function setValue ( $ key , $ value , $ duration ) { $ this -> gc ( ) ; $ cacheFile = $ this -> getCacheFile ( $ key ) ; if ( $ this -> directoryLevel > 0 ) { @ FileHelper :: createDirectory ( dirname ( $ cacheFile ) , $ this -> dirMode , true ) ; } 
protected function getCacheFile ( $ key ) { if ( $ this -> directoryLevel > 0 ) { $ base = $ this -> cachePath ; for ( $ i = 0 ; $ i < $ this -> directoryLevel ; ++ $ i ) { if ( ( $ prefix = substr ( $ key , $ i + $ i , 2 ) ) !== false ) { $ base .= DIRECTORY_SEPARATOR . $ prefix ; } } return $ base . DIRECTORY_SEPARATOR . $ key . $ this -> cacheFileSuffix ; } return $ this -> cachePath . DIRECTORY_SEPARATOR . $ key . $ this -> cacheFileSuffix ; } 
public static function encode ( $ value , $ options = 320 ) { $ expressions = [ ] ; $ value = static :: processData ( $ value , $ expressions , uniqid ( '' , true ) ) ; set_error_handler ( function ( ) { static :: handleJsonError ( JSON_ERROR_SYNTAX ) ; } , E_WARNING ) ; $ json = json_encode ( $ value , $ options ) ; restore_error_handler ( ) ; static :: handleJsonError ( json_last_error ( ) ) ; return $ expressions === [ ] ? $ json : strtr ( $ json , $ expressions ) ; } 
protected static function handleJsonError ( $ lastError ) { if ( $ lastError === JSON_ERROR_NONE ) { return ; } $ availableErrors = [ ] ; foreach ( static :: $ jsonErrorMessages as $ const => $ message ) { if ( defined ( $ const ) ) { $ availableErrors [ constant ( $ const ) ] = $ message ; } } if ( isset ( $ availableErrors [ $ lastError ] ) ) { throw new InvalidArgumentException ( $ availableErrors [ $ lastError ] , $ lastError ) ; } throw new InvalidArgumentException ( 'Unknown JSON encoding/decoding error.' ) ; } 
public static function errorSummary ( $ models , $ options = [ ] ) { $ showAllErrors = ArrayHelper :: remove ( $ options , 'showAllErrors' , false ) ; $ lines = self :: collectErrors ( $ models , $ showAllErrors ) ; return json_encode ( $ lines ) ; } 
public function init ( ) { parent :: init ( ) ; $ this -> expressionBuilders = array_merge ( $ this -> defaultExpressionBuilders ( ) , $ this -> expressionBuilders ) ; $ this -> conditionClasses = array_merge ( $ this -> defaultConditionClasses ( ) , $ this -> conditionClasses ) ; } 
public function buildExpression ( ExpressionInterface $ expression , & $ params = [ ] ) { $ builder = $ this -> getExpressionBuilder ( $ expression ) ; return $ builder -> build ( $ expression , $ params ) ; } 
public function getExpressionBuilder ( ExpressionInterface $ expression ) { $ className = get_class ( $ expression ) ; if ( ! isset ( $ this -> expressionBuilders [ $ className ] ) ) { foreach ( array_reverse ( $ this -> expressionBuilders ) as $ expressionClass => $ builderClass ) { if ( is_subclass_of ( $ expression , $ expressionClass ) ) { $ this -> expressionBuilders [ $ className ] = $ builderClass ; break ; } } if ( ! isset ( $ this -> expressionBuilders [ $ className ] ) ) { throw new InvalidArgumentException ( 'Expression of class ' . $ className . ' can not be built in ' . get_class ( $ this ) ) ; } } if ( $ this -> expressionBuilders [ $ className ] === __CLASS__ ) { return $ this ; } if ( ! is_object ( $ this -> expressionBuilders [ $ className ] ) ) { $ this -> expressionBuilders [ $ className ] = new $ this -> expressionBuilders [ $ className ] ( $ this ) ; } return $ this -> expressionBuilders [ $ className ] ; } 
public function insert ( $ table , $ columns , & $ params ) { list ( $ names , $ placeholders , $ values , $ params ) = $ this -> prepareInsertValues ( $ table , $ columns , $ params ) ; return 'INSERT INTO ' . $ this -> db -> quoteTableName ( $ table ) . ( ! empty ( $ names ) ? ' (' . implode ( ', ' , $ names ) . ')' : '' ) . ( ! empty ( $ placeholders ) ? ' VALUES (' . implode ( ', ' , $ placeholders ) . ')' : $ values ) ; } 
protected function prepareInsertSelectSubQuery ( $ columns , $ schema , $ params = [ ] ) { if ( ! is_array ( $ columns -> select ) || empty ( $ columns -> select ) || in_array ( '*' , $ columns -> select ) ) { throw new InvalidArgumentException ( 'Expected select query object with enumerated (named) parameters' ) ; } list ( $ values , $ params ) = $ this -> build ( $ columns , $ params ) ; $ names = [ ] ; $ values = ' ' . $ values ; foreach ( $ columns -> select as $ title => $ field ) { if ( is_string ( $ title ) ) { $ names [ ] = $ schema -> quoteColumnName ( $ title ) ; } elseif ( preg_match ( '/^(.*?)(?i:\s+as\s+|\s+)([\w\-_\.]+)$/' , $ field , $ matches ) ) { $ names [ ] = $ schema -> quoteColumnName ( $ matches [ 2 ] ) ; } else { $ names [ ] = $ schema -> quoteColumnName ( $ field ) ; } } return [ $ names , $ values , $ params ] ; } 
public function update ( $ table , $ columns , $ condition , & $ params ) { list ( $ lines , $ params ) = $ this -> prepareUpdateSets ( $ table , $ columns , $ params ) ; $ sql = 'UPDATE ' . $ this -> db -> quoteTableName ( $ table ) . ' SET ' . implode ( ', ' , $ lines ) ; $ where = $ this -> buildWhere ( $ condition , $ params ) ; return $ where === '' ? $ sql : $ sql . ' ' . $ where ; } 
public function delete ( $ table , $ condition , & $ params ) { $ sql = 'DELETE FROM ' . $ this -> db -> quoteTableName ( $ table ) ; $ where = $ this -> buildWhere ( $ condition , $ params ) ; return $ where === '' ? $ sql : $ sql . ' ' . $ where ; } 
public function dropPrimaryKey ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; } 
public function dropColumn ( $ table , $ column ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP COLUMN ' . $ this -> db -> quoteColumnName ( $ column ) ; } 
public function renameColumn ( $ table , $ oldName , $ newName ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' RENAME COLUMN ' . $ this -> db -> quoteColumnName ( $ oldName ) . ' TO ' . $ this -> db -> quoteColumnName ( $ newName ) ; } 
public function dropForeignKey ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; } 
public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { return ( $ unique ? 'CREATE UNIQUE INDEX ' : 'CREATE INDEX ' ) . $ this -> db -> quoteTableName ( $ name ) . ' ON ' . $ this -> db -> quoteTableName ( $ table ) . ' (' . $ this -> buildColumns ( $ columns ) . ')' ; } 
public function dropIndex ( $ name , $ table ) { return 'DROP INDEX ' . $ this -> db -> quoteTableName ( $ name ) . ' ON ' . $ this -> db -> quoteTableName ( $ table ) ; } 
public function dropUnique ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; } 
public function addCheck ( $ name , $ table , $ expression ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' ADD CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) . ' CHECK (' . $ this -> db -> quoteSql ( $ expression ) . ')' ; } 
public function dropCheck ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; } 
public function executeResetSequence ( $ table , $ value = null ) { $ this -> db -> createCommand ( ) -> resetSequence ( $ table , $ value ) -> execute ( ) ; } 
public function createView ( $ viewName , $ subQuery ) { if ( $ subQuery instanceof Query ) { list ( $ rawQuery , $ params ) = $ this -> build ( $ subQuery ) ; array_walk ( $ params , function ( & $ param ) { $ param = $ this -> db -> quoteValue ( $ param ) ; } ) ; $ subQuery = strtr ( $ rawQuery , $ params ) ; } return 'CREATE VIEW ' . $ this -> db -> quoteTableName ( $ viewName ) . ' AS ' . $ subQuery ; } 
public function getColumnType ( $ type ) { if ( $ type instanceof ColumnSchemaBuilder ) { $ type = $ type -> __toString ( ) ; } if ( isset ( $ this -> typeMap [ $ type ] ) ) { return $ this -> typeMap [ $ type ] ; } elseif ( preg_match ( '/^(\w+)\((.+?)\)(.*)$/' , $ type , $ matches ) ) { if ( isset ( $ this -> typeMap [ $ matches [ 1 ] ] ) ) { return preg_replace ( '/\(.+\)/' , '(' . $ matches [ 2 ] . ')' , $ this -> typeMap [ $ matches [ 1 ] ] ) . $ matches [ 3 ] ; } } elseif ( preg_match ( '/^(\w+)\s+/' , $ type , $ matches ) ) { if ( isset ( $ this -> typeMap [ $ matches [ 1 ] ] ) ) { return preg_replace ( '/^\w+/' , $ this -> typeMap [ $ matches [ 1 ] ] , $ type ) ; } } return $ type ; } 
private function quoteTableNames ( $ tables , & $ params ) { foreach ( $ tables as $ i => $ table ) { if ( $ table instanceof Query ) { list ( $ sql , $ params ) = $ this -> build ( $ table , $ params ) ; $ tables [ $ i ] = "($sql) " . $ this -> db -> quoteTableName ( $ i ) ; } elseif ( is_string ( $ i ) ) { if ( strpos ( $ table , '(' ) === false ) { $ table = $ this -> db -> quoteTableName ( $ table ) ; } $ tables [ $ i ] = "$table " . $ this -> db -> quoteTableName ( $ i ) ; } elseif ( strpos ( $ table , '(' ) === false ) { if ( preg_match ( '/^(.*?)(?i:\s+as|)\s+([^ ]+)$/' , $ table , $ matches ) ) { 
public function buildOrderByAndLimit ( $ sql , $ orderBy , $ limit , $ offset ) { $ orderBy = $ this -> buildOrderBy ( $ orderBy ) ; if ( $ orderBy !== '' ) { $ sql .= $ this -> separator . $ orderBy ; } $ limit = $ this -> buildLimit ( $ limit , $ offset ) ; if ( $ limit !== '' ) { $ sql .= $ this -> separator . $ limit ; } return $ sql ; } 
public function buildColumns ( $ columns ) { if ( ! is_array ( $ columns ) ) { if ( strpos ( $ columns , '(' ) !== false ) { return $ columns ; } $ rawColumns = $ columns ; $ columns = preg_split ( '/\s*,\s*/' , $ columns , - 1 , PREG_SPLIT_NO_EMPTY ) ; if ( $ columns === false ) { throw new InvalidArgumentException ( "$rawColumns is not valid columns." ) ; } } foreach ( $ columns as $ i => $ column ) { if ( $ column instanceof ExpressionInterface ) { $ columns [ $ i ] = $ this -> buildExpression ( $ column ) ; } elseif ( strpos ( $ column , '(' ) === false ) { $ columns [ $ i ] = $ this -> db -> quoteColumnName ( $ column ) ; } } return implode ( ', ' , $ columns ) ; } 
public function buildCondition ( $ condition , & $ params ) { if ( is_array ( $ condition ) ) { if ( empty ( $ condition ) ) { return '' ; } $ condition = $ this -> createConditionFromArray ( $ condition ) ; } if ( $ condition instanceof ExpressionInterface ) { return $ this -> buildExpression ( $ condition , $ params ) ; } return ( string ) $ condition ; } 
public function buildAndCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; } 
public function buildNotCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; } 
public function buildBetweenCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; } 
public function buildInCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; } 
public function buildLikeCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; } 
public function buildExistsCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; } 
public function buildSimpleCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; } 
public function bindParam ( $ value , & $ params ) { $ phName = self :: PARAM_PREFIX . count ( $ params ) ; $ params [ $ phName ] = $ value ; return $ phName ; } 
public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } return $ model ; } 
public function up ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeUp ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; } 
public function down ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeDown ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; } 
public function execute ( $ sql , $ params = [ ] ) { $ sqlOutput = $ sql ; if ( $ this -> maxSqlOutputLength !== null ) { $ sqlOutput = StringHelper :: truncate ( $ sql , $ this -> maxSqlOutputLength , '[... hidden]' ) ; } $ time = $ this -> beginCommand ( "execute SQL: $sqlOutput" ) ; $ this -> db -> createCommand ( $ sql ) -> bindValues ( $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function insert ( $ table , $ columns ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function batchInsert ( $ table , $ columns , $ rows ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> batchInsert ( $ table , $ columns , $ rows ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function upsert ( $ table , $ insertColumns , $ updateColumns = true , $ params = [ ] ) { $ time = $ this -> beginCommand ( "upsert into $table" ) ; $ this -> db -> createCommand ( ) -> upsert ( $ table , $ insertColumns , $ updateColumns , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "update $table" ) ; $ this -> db -> createCommand ( ) -> update ( $ table , $ columns , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "delete from $table" ) ; $ this -> db -> createCommand ( ) -> delete ( $ table , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function createTable ( $ table , $ columns , $ options = null ) { $ time = $ this -> beginCommand ( "create table $table" ) ; $ this -> db -> createCommand ( ) -> createTable ( $ table , $ columns , $ options ) -> execute ( ) ; foreach ( $ columns as $ column => $ type ) { if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } } $ this -> endCommand ( $ time ) ; } 
public function renameTable ( $ table , $ newName ) { $ time = $ this -> beginCommand ( "rename table $table to $newName" ) ; $ this -> db -> createCommand ( ) -> renameTable ( $ table , $ newName ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function dropColumn ( $ table , $ column ) { $ time = $ this -> beginCommand ( "drop column $column from table $table" ) ; $ this -> db -> createCommand ( ) -> dropColumn ( $ table , $ column ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function renameColumn ( $ table , $ name , $ newName ) { $ time = $ this -> beginCommand ( "rename column $name in table $table to $newName" ) ; $ this -> db -> createCommand ( ) -> renameColumn ( $ table , $ name , $ newName ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function alterColumn ( $ table , $ column , $ type ) { $ time = $ this -> beginCommand ( "alter column $column in table $table to $type" ) ; $ this -> db -> createCommand ( ) -> alterColumn ( $ table , $ column , $ type ) -> execute ( ) ; if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } $ this -> endCommand ( $ time ) ; } 
public function addPrimaryKey ( $ name , $ table , $ columns ) { $ time = $ this -> beginCommand ( "add primary key $name on $table (" . ( is_array ( $ columns ) ? implode ( ',' , $ columns ) : $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> addPrimaryKey ( $ name , $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete = null , $ update = null ) { $ time = $ this -> beginCommand ( "add foreign key $name: $table (" . implode ( ',' , ( array ) $ columns ) . ") references $refTable (" . implode ( ',' , ( array ) $ refColumns ) . ')' ) ; $ this -> db -> createCommand ( ) -> addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete , $ update ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ time = $ this -> beginCommand ( 'create' . ( $ unique ? ' unique' : '' ) . " index $name on $table (" . implode ( ',' , ( array ) $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function dropIndex ( $ name , $ table ) { $ time = $ this -> beginCommand ( "drop index $name on $table" ) ; $ this -> db -> createCommand ( ) -> dropIndex ( $ name , $ table ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function addCommentOnColumn ( $ table , $ column , $ comment ) { $ time = $ this -> beginCommand ( "add comment on column $column" ) ; $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ comment ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function addCommentOnTable ( $ table , $ comment ) { $ time = $ this -> beginCommand ( "add comment on table $table" ) ; $ this -> db -> createCommand ( ) -> addCommentOnTable ( $ table , $ comment ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public function dropCommentFromTable ( $ table ) { $ time = $ this -> beginCommand ( "drop comment from table $table" ) ; $ this -> db -> createCommand ( ) -> dropCommentFromTable ( $ table ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; } 
public static function getInstance ( $ model , $ attribute ) { $ name = Html :: getInputName ( $ model , $ attribute ) ; return static :: getInstanceByName ( $ name ) ; } 
public static function getInstances ( $ model , $ attribute ) { $ name = Html :: getInputName ( $ model , $ attribute ) ; return static :: getInstancesByName ( $ name ) ; } 
public static function getInstanceByName ( $ name ) { $ files = self :: loadFiles ( ) ; return isset ( $ files [ $ name ] ) ? new static ( $ files [ $ name ] ) : null ; } 
public static function getInstancesByName ( $ name ) { $ files = self :: loadFiles ( ) ; if ( isset ( $ files [ $ name ] ) ) { return [ new static ( $ files [ $ name ] ) ] ; } $ results = [ ] ; foreach ( $ files as $ key => $ file ) { if ( strpos ( $ key , "{$name}[" ) === 0 ) { $ results [ ] = new static ( $ file ) ; } } return $ results ; } 
public function saveAs ( $ file , $ deleteTempFile = true ) { if ( $ this -> error == UPLOAD_ERR_OK ) { if ( $ deleteTempFile ) { return move_uploaded_file ( $ this -> tempName , $ file ) ; } elseif ( is_uploaded_file ( $ this -> tempName ) ) { return copy ( $ this -> tempName , $ file ) ; } } return false ; } 
private static function loadFiles ( ) { if ( self :: $ _files === null ) { self :: $ _files = [ ] ; if ( isset ( $ _FILES ) && is_array ( $ _FILES ) ) { foreach ( $ _FILES as $ class => $ info ) { self :: loadFilesRecursive ( $ class , $ info [ 'name' ] , $ info [ 'tmp_name' ] , $ info [ 'type' ] , $ info [ 'size' ] , $ info [ 'error' ] ) ; } } } return self :: $ _files ; } 
private static function loadFilesRecursive ( $ key , $ names , $ tempNames , $ types , $ sizes , $ errors ) { if ( is_array ( $ names ) ) { foreach ( $ names as $ i => $ name ) { self :: loadFilesRecursive ( $ key . '[' . $ i . ']' , $ name , $ tempNames [ $ i ] , $ types [ $ i ] , $ sizes [ $ i ] , $ errors [ $ i ] ) ; } } elseif ( ( int ) $ errors !== UPLOAD_ERR_NO_FILE ) { self :: $ _files [ $ key ] = [ 'name' => $ names , 'tempName' => $ tempNames , 'type' => $ types , 'size' => $ sizes , 'error' => $ errors , ] ; } } 
protected function resolveTableName ( $ name ) { $ resolvedName = new TableSchema ( ) ; $ parts = explode ( '.' , str_replace ( [ '[' , ']' ] , '' , $ name ) ) ; $ partCount = count ( $ parts ) ; if ( $ partCount === 4 ) { 
protected function findTableNames ( $ schema = '' ) { if ( $ schema === '' ) { $ schema = $ this -> defaultSchema ; } $ sql = <<<'SQL' SELECT [t].[table_name] FROM [INFORMATION_SCHEMA].[TABLES] AS [t] WHERE [t].[table_schema] = :schema AND [t].[table_type] IN ('BASE TABLE', 'VIEW') ORDER BY [t].[table_name] SQL ; return $ this -> db -> createCommand ( $ sql , [ ':schema' => $ schema ] ) -> queryColumn ( ) ; } 
protected function loadTableSchema ( $ name ) { $ table = new TableSchema ( ) ; $ this -> resolveTableNames ( $ table , $ name ) ; $ this -> findPrimaryKeys ( $ table ) ; if ( $ this -> findColumns ( $ table ) ) { $ this -> findForeignKeys ( $ table ) ; return $ table ; } return null ; } 
protected function resolveTableNames ( $ table , $ name ) { $ parts = explode ( '.' , str_replace ( [ '[' , ']' ] , '' , $ name ) ) ; $ partCount = count ( $ parts ) ; if ( $ partCount === 4 ) { 
protected function loadColumnSchema ( $ info ) { $ column = $ this -> createColumnSchema ( ) ; $ column -> name = $ info [ 'column_name' ] ; $ column -> allowNull = $ info [ 'is_nullable' ] === 'YES' ; $ column -> dbType = $ info [ 'data_type' ] ; $ column -> enumValues = [ ] ; 
protected function findColumns ( $ table ) { $ columnsTableName = 'INFORMATION_SCHEMA.COLUMNS' ; $ whereSql = "[t1].[table_name] = '{$table->name}'" ; if ( $ table -> catalogName !== null ) { $ columnsTableName = "{$table->catalogName}.{$columnsTableName}" ; $ whereSql .= " AND [t1].[table_catalog] = '{$table->catalogName}'" ; } if ( $ table -> schemaName !== null ) { $ whereSql .= " AND [t1].[table_schema] = '{$table->schemaName}'" ; } $ columnsTableName = $ this -> quoteTableName ( $ columnsTableName ) ; $ sql = <<<SQL SELECT [t1].[column_name], [t1].[is_nullable], [t1].[data_type], [t1].[column_default], COLUMNPROPERTY(OBJECT_ID([t1].[table_schema] + '.' + [t1].[table_name]), [t1].[column_name], 'IsIdentity') AS is_identity, ( SELECT CONVERT(VARCHAR, [t2].[value]) FROM [sys].[extended_properties] AS [t2] WHERE [t2].[class] = 1 AND [t2].[class_desc] = 'OBJECT_OR_COLUMN' AND [t2].[name] = 'MS_Description' AND [t2].[major_id] = OBJECT_ID([t1].[TABLE_SCHEMA] + '.' + [t1].[table_name]) AND [t2].[minor_id] = COLUMNPROPERTY(OBJECT_ID([t1].[TABLE_SCHEMA] + '.' + [t1].[TABLE_NAME]), [t1].[COLUMN_NAME], 'ColumnID') ) as comment FROM {$columnsTableName} AS [t1] WHERE {$whereSql} SQL ; try { $ columns = $ this -> db -> createCommand ( $ sql ) -> queryAll ( ) ; if ( empty ( $ columns ) ) { return false ; } } catch ( \ Exception $ e ) { return false ; } foreach ( $ columns as $ column ) { $ column = $ this -> loadColumnSchema ( $ column ) ; foreach ( $ table -> primaryKey as $ primaryKey ) { if ( strcasecmp ( $ column -> name , $ primaryKey ) === 0 ) { $ column -> isPrimaryKey = true ; break ; } } if ( $ column -> isPrimaryKey && $ column -> autoIncrement ) { $ table -> sequenceName = '' ; } $ table -> columns [ $ column -> name ] = $ column ; } return true ; } 
protected function findTableConstraints ( $ table , $ type ) { $ keyColumnUsageTableName = 'INFORMATION_SCHEMA.KEY_COLUMN_USAGE' ; $ tableConstraintsTableName = 'INFORMATION_SCHEMA.TABLE_CONSTRAINTS' ; if ( $ table -> catalogName !== null ) { $ keyColumnUsageTableName = $ table -> catalogName . '.' . $ keyColumnUsageTableName ; $ tableConstraintsTableName = $ table -> catalogName . '.' . $ tableConstraintsTableName ; } $ keyColumnUsageTableName = $ this -> quoteTableName ( $ keyColumnUsageTableName ) ; $ tableConstraintsTableName = $ this -> quoteTableName ( $ tableConstraintsTableName ) ; $ sql = <<<SQL SELECT [kcu].[constraint_name] AS [index_name], [kcu].[column_name] AS [field_name] FROM {$keyColumnUsageTableName} AS [kcu] LEFT JOIN {$tableConstraintsTableName} AS [tc] ON [kcu].[table_schema] = [tc].[table_schema] AND [kcu].[table_name] = [tc].[table_name] AND [kcu].[constraint_name] = [tc].[constraint_name] WHERE [tc].[constraint_type] = :type AND [kcu].[table_name] = :tableName AND [kcu].[table_schema] = :schemaName SQL ; return $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ':type' => $ type , ] ) -> queryAll ( ) ; } 
protected function findPrimaryKeys ( $ table ) { $ result = [ ] ; foreach ( $ this -> findTableConstraints ( $ table , 'PRIMARY KEY' ) as $ row ) { $ result [ ] = $ row [ 'field_name' ] ; } $ table -> primaryKey = $ result ; } 
protected function findForeignKeys ( $ table ) { $ object = $ table -> name ; if ( $ table -> schemaName !== null ) { $ object = $ table -> schemaName . '.' . $ object ; } if ( $ table -> catalogName !== null ) { $ object = $ table -> catalogName . '.' . $ object ; } SELECT [fk].[name] AS [fk_name], [cp].[name] AS [fk_column_name], OBJECT_NAME([fk].[referenced_object_id]) AS [uq_table_name], [cr].[name] AS [uq_column_name] FROM [sys].[foreign_keys] AS [fk] INNER JOIN [sys].[foreign_key_columns] AS [fkc] ON [fk].[object_id] = [fkc].[constraint_object_id] INNER JOIN [sys].[columns] AS [cp] ON [fk].[parent_object_id] = [cp].[object_id] AND [fkc].[parent_column_id] = [cp].[column_id] INNER JOIN [sys].[columns] AS [cr] ON [fk].[referenced_object_id] = [cr].[object_id] AND [fkc].[referenced_column_id] = [cr].[column_id] WHERE [fk].[parent_object_id] = OBJECT_ID(:object) SQL ; $ rows = $ this -> db -> createCommand ( $ sql , [ ':object' => $ object , ] ) -> queryAll ( ) ; $ table -> foreignKeys = [ ] ; foreach ( $ rows as $ row ) { $ table -> foreignKeys [ $ row [ 'fk_name' ] ] = [ $ row [ 'uq_table_name' ] , $ row [ 'fk_column_name' ] => $ row [ 'uq_column_name' ] ] ; } } 
public function findUniqueIndexes ( $ table ) { $ result = [ ] ; foreach ( $ this -> findTableConstraints ( $ table , 'UNIQUE' ) as $ row ) { $ result [ $ row [ 'index_name' ] ] [ ] = $ row [ 'field_name' ] ; } return $ result ; } 
private function loadTableConstraints ( $ tableName , $ returnType ) { static $ sql = <<<'SQL' SELECT [o].[name] AS [name], COALESCE([ccol].[name], [dcol].[name], [fccol].[name], [kiccol].[name]) AS [column_name], RTRIM([o].[type]) AS [type], OBJECT_SCHEMA_NAME([f].[referenced_object_id]) AS [foreign_table_schema], OBJECT_NAME([f].[referenced_object_id]) AS [foreign_table_name], [ffccol].[name] AS [foreign_column_name], [f].[update_referential_action_desc] AS [on_update], [f].[delete_referential_action_desc] AS [on_delete], [c].[definition] AS [check_expr], [d].[definition] AS [default_expr] FROM (SELECT OBJECT_ID(:fullName) AS [object_id]) AS [t] INNER JOIN [sys].[objects] AS [o] ON [o].[parent_object_id] = [t].[object_id] AND [o].[type] IN ('PK', 'UQ', 'C', 'D', 'F') LEFT JOIN [sys].[check_constraints] AS [c] ON [c].[object_id] = [o].[object_id] LEFT JOIN [sys].[columns] AS [ccol] ON [ccol].[object_id] = [c].[parent_object_id] AND [ccol].[column_id] = [c].[parent_column_id] LEFT JOIN [sys].[default_constraints] AS [d] ON [d].[object_id] = [o].[object_id] LEFT JOIN [sys].[columns] AS [dcol] ON [dcol].[object_id] = [d].[parent_object_id] AND [dcol].[column_id] = [d].[parent_column_id] LEFT JOIN [sys].[key_constraints] AS [k] ON [k].[object_id] = [o].[object_id] LEFT JOIN [sys].[index_columns] AS [kic] ON [kic].[object_id] = [k].[parent_object_id] AND [kic].[index_id] = [k].[unique_index_id] LEFT JOIN [sys].[columns] AS [kiccol] ON [kiccol].[object_id] = [kic].[object_id] AND [kiccol].[column_id] = [kic].[column_id] LEFT JOIN [sys].[foreign_keys] AS [f] ON [f].[object_id] = [o].[object_id] LEFT JOIN [sys].[foreign_key_columns] AS [fc] ON [fc].[constraint_object_id] = [o].[object_id] LEFT JOIN [sys].[columns] AS [fccol] ON [fccol].[object_id] = [fc].[parent_object_id] AND [fccol].[column_id] = [fc].[parent_column_id] LEFT JOIN [sys].[columns] AS [ffccol] ON [ffccol].[object_id] = [fc].[referenced_object_id] AND [ffccol].[column_id] = [fc].[referenced_column_id] ORDER BY [kic].[key_ordinal] ASC, [fc].[constraint_column_id] ASC SQL ; $ resolvedName = $ this -> resolveTableName ( $ tableName ) ; $ constraints = $ this -> db -> createCommand ( $ sql , [ ':fullName' => $ resolvedName -> fullName , ] ) -> queryAll ( ) ; $ constraints = $ this -> normalizePdoRowKeyCase ( $ constraints , true ) ; $ constraints = ArrayHelper :: index ( $ constraints , null , [ 'type' , 'name' ] ) ; $ result = [ 'primaryKey' => null , 'foreignKeys' => [ ] , 'uniques' => [ ] , 'checks' => [ ] , 'defaults' => [ ] , ] ; foreach ( $ constraints as $ type => $ names ) { foreach ( $ names as $ name => $ constraint ) { switch ( $ type ) { case 'PK' : $ result [ 'primaryKey' ] = new Constraint ( [ 'name' => $ name , 'columnNames' => ArrayHelper :: getColumn ( $ constraint , 'column_name' ) , ] ) ; break ; case 'F' : $ result [ 'foreignKeys' ] [ ] = new ForeignKeyConstraint ( [ 'name' => $ name , 'columnNames' => ArrayHelper :: getColumn ( $ constraint , 'column_name' ) , 'foreignSchemaName' => $ constraint [ 0 ] [ 'foreign_table_schema' ] , 'foreignTableName' => $ constraint [ 0 ] [ 'foreign_table_name' ] , 'foreignColumnNames' => ArrayHelper :: getColumn ( $ constraint , 'foreign_column_name' ) , 'onDelete' => str_replace ( '_' , '' , $ constraint [ 0 ] [ 'on_delete' ] ) , 'onUpdate' => str_replace ( '_' , '' , $ constraint [ 0 ] [ 'on_update' ] ) , ] ) ; break ; case 'UQ' : $ result [ 'uniques' ] [ ] = new Constraint ( [ 'name' => $ name , 'columnNames' => ArrayHelper :: getColumn ( $ constraint , 'column_name' ) , ] ) ; break ; case 'C' : $ result [ 'checks' ] [ ] = new CheckConstraint ( [ 'name' => $ name , 'columnNames' => ArrayHelper :: getColumn ( $ constraint , 'column_name' ) , 'expression' => $ constraint [ 0 ] [ 'check_expr' ] , ] ) ; break ; case 'D' : $ result [ 'defaults' ] [ ] = new DefaultValueConstraint ( [ 'name' => $ name , 'columnNames' => ArrayHelper :: getColumn ( $ constraint , 'column_name' ) , 'value' => $ constraint [ 0 ] [ 'default_expr' ] , ] ) ; break ; } } } foreach ( $ result as $ type => $ data ) { $ this -> setTableMetadata ( $ tableName , $ type , $ data ) ; } return $ result [ $ returnType ] ; } 
protected function renderHeaderCellContent ( ) { if ( $ this -> header !== null || $ this -> label === null && $ this -> attribute === null ) { return parent :: renderHeaderCellContent ( ) ; } $ label = $ this -> getHeaderCellLabel ( ) ; if ( $ this -> encodeLabel ) { $ label = Html :: encode ( $ label ) ; } if ( $ this -> attribute !== null && $ this -> enableSorting && ( $ sort = $ this -> grid -> dataProvider -> getSort ( ) ) !== false && $ sort -> hasAttribute ( $ this -> attribute ) ) { return $ sort -> link ( $ this -> attribute , array_merge ( $ this -> sortLinkOptions , [ 'label' => $ label ] ) ) ; } return $ label ; } 
protected function getHeaderCellLabel ( ) { $ provider = $ this -> grid -> dataProvider ; if ( $ this -> label === null ) { if ( $ provider instanceof ActiveDataProvider && $ provider -> query instanceof ActiveQueryInterface ) { $ modelClass = $ provider -> query -> modelClass ; $ model = $ modelClass :: instance ( ) ; $ label = $ model -> getAttributeLabel ( $ this -> attribute ) ; } elseif ( $ provider instanceof ArrayDataProvider && $ provider -> modelClass !== null ) { $ modelClass = $ provider -> modelClass ; $ model = $ modelClass :: instance ( ) ; $ label = $ model -> getAttributeLabel ( $ this -> attribute ) ; } elseif ( $ this -> grid -> filterModel !== null && $ this -> grid -> filterModel instanceof Model ) { $ label = $ this -> grid -> filterModel -> getAttributeLabel ( $ this -> attribute ) ; } else { $ models = $ provider -> getModels ( ) ; if ( ( $ model = reset ( $ models ) ) instanceof Model ) { $ label = $ model -> getAttributeLabel ( $ this -> attribute ) ; } else { $ label = Inflector :: camel2words ( $ this -> attribute ) ; } } } else { $ label = $ this -> label ; } return $ label ; } 
protected function renderFilterCellContent ( ) { if ( is_string ( $ this -> filter ) ) { return $ this -> filter ; } $ model = $ this -> grid -> filterModel ; if ( $ this -> filter !== false && $ model instanceof Model && $ this -> attribute !== null && $ model -> isAttributeActive ( $ this -> attribute ) ) { if ( $ model -> hasErrors ( $ this -> attribute ) ) { Html :: addCssClass ( $ this -> filterOptions , 'has-error' ) ; $ error = ' ' . Html :: error ( $ model , $ this -> attribute , $ this -> grid -> filterErrorOptions ) ; } else { $ error = '' ; } if ( is_array ( $ this -> filter ) ) { $ options = array_merge ( [ 'prompt' => '' ] , $ this -> filterInputOptions ) ; return Html :: activeDropDownList ( $ model , $ this -> attribute , $ this -> filter , $ options ) . $ error ; } elseif ( $ this -> format === 'boolean' ) { $ options = array_merge ( [ 'prompt' => '' ] , $ this -> filterInputOptions ) ; return Html :: activeDropDownList ( $ model , $ this -> attribute , [ 1 => $ this -> grid -> formatter -> booleanFormat [ 1 ] , 0 => $ this -> grid -> formatter -> booleanFormat [ 0 ] , ] , $ options ) . $ error ; } return Html :: activeTextInput ( $ model , $ this -> attribute , $ this -> filterInputOptions ) . $ error ; } return parent :: renderFilterCellContent ( ) ; } 
protected function renderDataCellContent ( $ model , $ key , $ index ) { if ( $ this -> content === null ) { return $ this -> grid -> formatter -> format ( $ this -> getDataCellValue ( $ model , $ key , $ index ) , $ this -> format ) ; } return parent :: renderDataCellContent ( $ model , $ key , $ index ) ; } 
public function via ( $ relationName , callable $ callable = null ) { $ relation = $ this -> primaryModel -> getRelation ( $ relationName ) ; $ callableUsed = $ callable !== null ; $ this -> via = [ $ relationName , $ relation , $ callableUsed ] ; if ( $ callable !== null ) { call_user_func ( $ callable , $ relation ) ; } return $ this ; } 
public function findFor ( $ name , $ model ) { if ( method_exists ( $ model , 'get' . $ name ) ) { $ method = new \ ReflectionMethod ( $ model , 'get' . $ name ) ; $ realName = lcfirst ( substr ( $ method -> getName ( ) , 3 ) ) ; if ( $ realName !== $ name ) { throw new InvalidArgumentException ( 'Relation names are case sensitive. ' . get_class ( $ model ) . " has a relation named \"$realName\" instead of \"$name\"." ) ; } } return $ this -> multiple ? $ this -> all ( ) : $ this -> one ( ) ; } 
private function indexBuckets ( $ buckets , $ indexBy ) { $ result = [ ] ; foreach ( $ buckets as $ key => $ models ) { $ result [ $ key ] = [ ] ; foreach ( $ models as $ model ) { $ index = is_string ( $ indexBy ) ? $ model [ $ indexBy ] : call_user_func ( $ indexBy , $ model ) ; $ result [ $ key ] [ $ index ] = $ model ; } } return $ result ; } 
protected function findTableNames ( $ schema = '' ) { $ pdo = $ this -> db -> getSlavePdo ( ) ; $ tables = $ pdo -> cubrid_schema ( \ PDO :: CUBRID_SCH_TABLE ) ; $ tableNames = [ ] ; foreach ( $ tables as $ table ) { 
protected function loadTableSchema ( $ name ) { $ pdo = $ this -> db -> getSlavePdo ( ) ; $ tableInfo = $ pdo -> cubrid_schema ( \ PDO :: CUBRID_SCH_TABLE , $ name ) ; if ( ! isset ( $ tableInfo [ 0 ] [ 'NAME' ] ) ) { return null ; } $ table = new TableSchema ( ) ; $ table -> fullName = $ table -> name = $ tableInfo [ 0 ] [ 'NAME' ] ; $ sql = 'SHOW FULL COLUMNS FROM ' . $ this -> quoteSimpleTableName ( $ table -> name ) ; $ columns = $ this -> db -> createCommand ( $ sql ) -> queryAll ( ) ; foreach ( $ columns as $ info ) { $ column = $ this -> loadColumnSchema ( $ info ) ; $ table -> columns [ $ column -> name ] = $ column ; } $ primaryKeys = $ pdo -> cubrid_schema ( \ PDO :: CUBRID_SCH_PRIMARY_KEY , $ table -> name ) ; foreach ( $ primaryKeys as $ key ) { $ column = $ table -> columns [ $ key [ 'ATTR_NAME' ] ] ; $ column -> isPrimaryKey = true ; $ table -> primaryKey [ ] = $ column -> name ; if ( $ column -> autoIncrement ) { $ table -> sequenceName = '' ; } } $ foreignKeys = $ pdo -> cubrid_schema ( \ PDO :: CUBRID_SCH_IMPORTED_KEYS , $ table -> name ) ; foreach ( $ foreignKeys as $ key ) { if ( isset ( $ table -> foreignKeys [ $ key [ 'FK_NAME' ] ] ) ) { $ table -> foreignKeys [ $ key [ 'FK_NAME' ] ] [ $ key [ 'FKCOLUMN_NAME' ] ] = $ key [ 'PKCOLUMN_NAME' ] ; } else { $ table -> foreignKeys [ $ key [ 'FK_NAME' ] ] = [ $ key [ 'PKTABLE_NAME' ] , $ key [ 'FKCOLUMN_NAME' ] => $ key [ 'PKCOLUMN_NAME' ] , ] ; } } return $ table ; } 
protected function loadTablePrimaryKey ( $ tableName ) { $ primaryKey = $ this -> db -> getSlavePdo ( ) -> cubrid_schema ( \ PDO :: CUBRID_SCH_PRIMARY_KEY , $ tableName ) ; if ( empty ( $ primaryKey ) ) { return null ; } ArrayHelper :: multisort ( $ primaryKey , 'KEY_SEQ' , SORT_ASC , SORT_NUMERIC ) ; return new Constraint ( [ 'name' => $ primaryKey [ 0 ] [ 'KEY_NAME' ] , 'columnNames' => ArrayHelper :: getColumn ( $ primaryKey , 'ATTR_NAME' ) , ] ) ; } 
protected function loadTableForeignKeys ( $ tableName ) { static $ actionTypes = [ 0 => 'CASCADE' , 1 => 'RESTRICT' , 2 => 'NO ACTION' , 3 => 'SET NULL' , ] ; $ foreignKeys = $ this -> db -> getSlavePdo ( ) -> cubrid_schema ( \ PDO :: CUBRID_SCH_IMPORTED_KEYS , $ tableName ) ; $ foreignKeys = ArrayHelper :: index ( $ foreignKeys , null , 'FK_NAME' ) ; ArrayHelper :: multisort ( $ foreignKeys , 'KEY_SEQ' , SORT_ASC , SORT_NUMERIC ) ; $ result = [ ] ; foreach ( $ foreignKeys as $ name => $ foreignKey ) { $ result [ ] = new ForeignKeyConstraint ( [ 'name' => $ name , 'columnNames' => ArrayHelper :: getColumn ( $ foreignKey , 'FKCOLUMN_NAME' ) , 'foreignTableName' => $ foreignKey [ 0 ] [ 'PKTABLE_NAME' ] , 'foreignColumnNames' => ArrayHelper :: getColumn ( $ foreignKey , 'PKCOLUMN_NAME' ) , 'onDelete' => isset ( $ actionTypes [ $ foreignKey [ 0 ] [ 'DELETE_RULE' ] ] ) ? $ actionTypes [ $ foreignKey [ 0 ] [ 'DELETE_RULE' ] ] : null , 'onUpdate' => isset ( $ actionTypes [ $ foreignKey [ 0 ] [ 'UPDATE_RULE' ] ] ) ? $ actionTypes [ $ foreignKey [ 0 ] [ 'UPDATE_RULE' ] ] : null , ] ) ; } return $ result ; } 
public function setTransactionIsolationLevel ( $ level ) { 
private function loadTableConstraints ( $ tableName , $ returnType ) { $ constraints = $ this -> db -> getSlavePdo ( ) -> cubrid_schema ( \ PDO :: CUBRID_SCH_CONSTRAINT , $ tableName ) ; $ constraints = ArrayHelper :: index ( $ constraints , null , [ 'TYPE' , 'NAME' ] ) ; ArrayHelper :: multisort ( $ constraints , 'KEY_ORDER' , SORT_ASC , SORT_NUMERIC ) ; $ result = [ 'indexes' => [ ] , 'uniques' => [ ] , ] ; foreach ( $ constraints as $ type => $ names ) { foreach ( $ names as $ name => $ constraint ) { $ isUnique = in_array ( ( int ) $ type , [ 0 , 2 ] , true ) ; $ result [ 'indexes' ] [ ] = new IndexConstraint ( [ 'isPrimary' => ( bool ) $ constraint [ 0 ] [ 'PRIMARY_KEY' ] , 'isUnique' => $ isUnique , 'name' => $ name , 'columnNames' => ArrayHelper :: getColumn ( $ constraint , 'ATTR_NAME' ) , ] ) ; if ( $ isUnique ) { $ result [ 'uniques' ] [ ] = new Constraint ( [ 'name' => $ name , 'columnNames' => ArrayHelper :: getColumn ( $ constraint , 'ATTR_NAME' ) , ] ) ; } } } foreach ( $ result as $ type => $ data ) { $ this -> setTableMetadata ( $ tableName , $ type , $ data ) ; } return $ result [ $ returnType ] ; } 
protected function isWhitespace ( & $ length ) { static $ whitespaces = [ "\f" => true , "\n" => true , "\r" => true , "\t" => true , ' ' => true , ] ; $ length = 1 ; return isset ( $ whitespaces [ $ this -> substring ( $ length ) ] ) ; } 
protected function isComment ( & $ length ) { static $ comments = [ '--' => true , '/*' => true , ] ; $ length = 2 ; if ( ! isset ( $ comments [ $ this -> substring ( $ length ) ] ) ) { return false ; } if ( $ this -> substring ( $ length ) === '--' ) { $ length = $ this -> indexAfter ( "\n" ) - $ this -> offset ; } else { $ length = $ this -> indexAfter ( '*/' ) - $ this -> offset ; } return true ; } 
protected function isIdentifier ( & $ length , & $ content ) { static $ identifierDelimiters = [ '"' => '"' , '[' => ']' , '`' => '`' , ] ; if ( ! isset ( $ identifierDelimiters [ $ this -> substring ( 1 ) ] ) ) { return false ; } $ delimiter = $ identifierDelimiters [ $ this -> substring ( 1 ) ] ; $ offset = $ this -> offset ; while ( true ) { $ offset = $ this -> indexAfter ( $ delimiter , $ offset + 1 ) ; if ( $ delimiter === ']' || $ this -> substring ( 1 , true , $ offset ) !== $ delimiter ) { break ; } } $ length = $ offset - $ this -> offset ; $ content = $ this -> substring ( $ length - 2 , true , $ this -> offset + 1 ) ; if ( $ delimiter !== ']' ) { $ content = strtr ( $ content , [ "$delimiter$delimiter" => $ delimiter ] ) ; } return true ; } 
protected function isStringLiteral ( & $ length , & $ content ) { if ( $ this -> substring ( 1 ) !== "'" ) { return false ; } $ offset = $ this -> offset ; while ( true ) { $ offset = $ this -> indexAfter ( "'" , $ offset + 1 ) ; if ( $ this -> substring ( 1 , true , $ offset ) !== "'" ) { break ; } } $ length = $ offset - $ this -> offset ; $ content = strtr ( $ this -> substring ( $ length - 2 , true , $ this -> offset + 1 ) , [ "''" => "'" ] ) ; return true ; } 
protected function isKeyword ( $ string , & $ content ) { static $ keywords = [ 'ABORT' => true , 'ACTION' => true , 'ADD' => true , 'AFTER' => true , 'ALL' => true , 'ALTER' => true , 'ANALYZE' => true , 'AND' => true , 'AS' => true , 'ASC' => true , 'ATTACH' => true , 'AUTOINCREMENT' => true , 'BEFORE' => true , 'BEGIN' => true , 'BETWEEN' => true , 'BY' => true , 'CASCADE' => true , 'CASE' => true , 'CAST' => true , 'CHECK' => true , 'COLLATE' => true , 'COLUMN' => true , 'COMMIT' => true , 'CONFLICT' => true , 'CONSTRAINT' => true , 'CREATE' => true , 'CROSS' => true , 'CURRENT_DATE' => true , 'CURRENT_TIME' => true , 'CURRENT_TIMESTAMP' => true , 'DATABASE' => true , 'DEFAULT' => true , 'DEFERRABLE' => true , 'DEFERRED' => true , 'DELETE' => true , 'DESC' => true , 'DETACH' => true , 'DISTINCT' => true , 'DROP' => true , 'EACH' => true , 'ELSE' => true , 'END' => true , 'ESCAPE' => true , 'EXCEPT' => true , 'EXCLUSIVE' => true , 'EXISTS' => true , 'EXPLAIN' => true , 'FAIL' => true , 'FOR' => true , 'FOREIGN' => true , 'FROM' => true , 'FULL' => true , 'GLOB' => true , 'GROUP' => true , 'HAVING' => true , 'IF' => true , 'IGNORE' => true , 'IMMEDIATE' => true , 'IN' => true , 'INDEX' => true , 'INDEXED' => true , 'INITIALLY' => true , 'INNER' => true , 'INSERT' => true , 'INSTEAD' => true , 'INTERSECT' => true , 'INTO' => true , 'IS' => true , 'ISNULL' => true , 'JOIN' => true , 'KEY' => true , 'LEFT' => true , 'LIKE' => true , 'LIMIT' => true , 'MATCH' => true , 'NATURAL' => true , 'NO' => true , 'NOT' => true , 'NOTNULL' => true , 'NULL' => true , 'OF' => true , 'OFFSET' => true , 'ON' => true , 'OR' => true , 'ORDER' => true , 'OUTER' => true , 'PLAN' => true , 'PRAGMA' => true , 'PRIMARY' => true , 'QUERY' => true , 'RAISE' => true , 'RECURSIVE' => true , 'REFERENCES' => true , 'REGEXP' => true , 'REINDEX' => true , 'RELEASE' => true , 'RENAME' => true , 'REPLACE' => true , 'RESTRICT' => true , 'RIGHT' => true , 'ROLLBACK' => true , 'ROW' => true , 'SAVEPOINT' => true , 'SELECT' => true , 'SET' => true , 'TABLE' => true , 'TEMP' => true , 'TEMPORARY' => true , 'THEN' => true , 'TO' => true , 'TRANSACTION' => true , 'TRIGGER' => true , 'UNION' => true , 'UNIQUE' => true , 'UPDATE' => true , 'USING' => true , 'VACUUM' => true , 'VALUES' => true , 'VIEW' => true , 'VIRTUAL' => true , 'WHEN' => true , 'WHERE' => true , 'WITH' => true , 'WITHOUT' => true , ] ; $ string = mb_strtoupper ( $ string , 'UTF-8' ) ; if ( ! isset ( $ keywords [ $ string ] ) ) { return false ; } $ content = $ string ; return true ; } 
public function flush ( $ final = false ) { $ messages = $ this -> messages ; 
public function getProfiling ( $ categories = [ ] , $ excludeCategories = [ ] ) { $ timings = $ this -> calculateTimings ( $ this -> messages ) ; if ( empty ( $ categories ) && empty ( $ excludeCategories ) ) { return $ timings ; } foreach ( $ timings as $ i => $ timing ) { $ matched = empty ( $ categories ) ; foreach ( $ categories as $ category ) { $ prefix = rtrim ( $ category , '*' ) ; if ( ( $ timing [ 'category' ] === $ category || $ prefix !== $ category ) && strpos ( $ timing [ 'category' ] , $ prefix ) === 0 ) { $ matched = true ; break ; } } if ( $ matched ) { foreach ( $ excludeCategories as $ category ) { $ prefix = rtrim ( $ category , '*' ) ; foreach ( $ timings as $ i => $ timing ) { if ( ( $ timing [ 'category' ] === $ category || $ prefix !== $ category ) && strpos ( $ timing [ 'category' ] , $ prefix ) === 0 ) { $ matched = false ; break ; } } } } if ( ! $ matched ) { unset ( $ timings [ $ i ] ) ; } } return array_values ( $ timings ) ; } 
public function getDbProfiling ( ) { $ timings = $ this -> getProfiling ( [ 'yii\db\Command::query' , 'yii\db\Command::execute' ] ) ; $ count = count ( $ timings ) ; $ time = 0 ; foreach ( $ timings as $ timing ) { $ time += $ timing [ 'duration' ] ; } return [ $ count , $ time ] ; } 
public function calculateTimings ( $ messages ) { $ timings = [ ] ; $ stack = [ ] ; foreach ( $ messages as $ i => $ log ) { list ( $ token , $ level , $ category , $ timestamp , $ traces ) = $ log ; $ memory = isset ( $ log [ 5 ] ) ? $ log [ 5 ] : 0 ; $ log [ 6 ] = $ i ; $ hash = md5 ( json_encode ( $ token ) ) ; if ( $ level == self :: LEVEL_PROFILE_BEGIN ) { $ stack [ $ hash ] = $ log ; } elseif ( $ level == self :: LEVEL_PROFILE_END ) { if ( isset ( $ stack [ $ hash ] ) ) { $ timings [ $ stack [ $ hash ] [ 6 ] ] = [ 'info' => $ stack [ $ hash ] [ 0 ] , 'category' => $ stack [ $ hash ] [ 2 ] , 'timestamp' => $ stack [ $ hash ] [ 3 ] , 'trace' => $ stack [ $ hash ] [ 4 ] , 'level' => count ( $ stack ) - 1 , 'duration' => $ timestamp - $ stack [ $ hash ] [ 3 ] , 'memory' => $ memory , 'memoryDiff' => $ memory - ( isset ( $ stack [ $ hash ] [ 5 ] ) ? $ stack [ $ hash ] [ 5 ] : 0 ) , ] ; unset ( $ stack [ $ hash ] ) ; } } } ksort ( $ timings ) ; return array_values ( $ timings ) ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> pattern === null ) { throw new InvalidConfigException ( 'The "pattern" property must be set.' ) ; } if ( $ this -> message === null ) { $ this -> message = Yii :: t ( 'yii' , '{attribute} is invalid.' ) ; } } 
protected function validateValue ( $ value ) { $ valid = ! is_array ( $ value ) && ( ! $ this -> not && preg_match ( $ this -> pattern , $ value ) || $ this -> not && ! preg_match ( $ this -> pattern , $ value ) ) ; return $ valid ? null : [ $ this -> message , [ ] ] ; } 
public function getClientOptions ( $ model , $ attribute ) { $ pattern = Html :: escapeJsRegularExpression ( $ this -> pattern ) ; $ options = [ 'pattern' => new JsExpression ( $ pattern ) , 'not' => $ this -> not , 'message' => $ this -> formatMessage ( $ this -> message , [ 'attribute' => $ model -> getAttributeLabel ( $ attribute ) , ] ) , ] ; if ( $ this -> skipOnEmpty ) { $ options [ 'skipOnEmpty' ] = 1 ; } return $ options ; } 
public function applyTo ( $ path ) { $ pathMap = $ this -> pathMap ; if ( empty ( $ pathMap ) ) { if ( ( $ basePath = $ this -> getBasePath ( ) ) === null ) { throw new InvalidConfigException ( 'The "basePath" property must be set.' ) ; } $ pathMap = [ Yii :: $ app -> getBasePath ( ) => [ $ basePath ] ] ; } $ path = FileHelper :: normalizePath ( $ path ) ; foreach ( $ pathMap as $ from => $ tos ) { $ from = FileHelper :: normalizePath ( Yii :: getAlias ( $ from ) ) . DIRECTORY_SEPARATOR ; if ( strpos ( $ path , $ from ) === 0 ) { $ n = strlen ( $ from ) ; foreach ( ( array ) $ tos as $ to ) { $ to = FileHelper :: normalizePath ( Yii :: getAlias ( $ to ) ) . DIRECTORY_SEPARATOR ; $ file = $ to . substr ( $ path , $ n ) ; if ( is_file ( $ file ) ) { return $ file ; } } } } return $ path ; } 
public function getUrl ( $ url ) { if ( ( $ baseUrl = $ this -> getBaseUrl ( ) ) !== null ) { return $ baseUrl . '/' . ltrim ( $ url , '/' ) ; } throw new InvalidConfigException ( 'The "baseUrl" property must be set.' ) ; } 
protected function writeInteger ( $ fileHandle , $ integer ) { return $ this -> writeBytes ( $ fileHandle , pack ( $ this -> useBigEndian ? 'N' : 'V' , ( int ) $ integer ) ) ; } 
protected function readString ( $ fileHandle , $ length , $ offset = null ) { if ( $ offset !== null ) { fseek ( $ fileHandle , $ offset ) ; } return $ this -> readBytes ( $ fileHandle , $ length ) ; } 
public function build ( ExpressionInterface $ condition , array & $ params = [ ] ) { $ parts = $ this -> buildExpressionsFrom ( $ condition , $ params ) ; if ( empty ( $ parts ) ) { return '' ; } if ( count ( $ parts ) === 1 ) { return reset ( $ parts ) ; } return '(' . implode ( ") {$condition->getOperator()} (" , $ parts ) . ')' ; } 
private function buildExpressionsFrom ( ExpressionInterface $ condition , & $ params = [ ] ) { $ parts = [ ] ; foreach ( $ condition -> getExpressions ( ) as $ condition ) { if ( is_array ( $ condition ) ) { $ condition = $ this -> queryBuilder -> buildCondition ( $ condition , $ params ) ; } if ( $ condition instanceof ExpressionInterface ) { $ condition = $ this -> queryBuilder -> buildExpression ( $ condition , $ params ) ; } if ( $ condition !== '' ) { $ parts [ ] = $ condition ; } } return $ parts ; } 
public function init ( ) { parent :: init ( ) ; if ( ! isset ( $ this -> options [ 'id' ] ) ) { $ this -> options [ 'id' ] = $ this -> getId ( ) ; } if ( $ this -> requiresPjax ( ) ) { ob_start ( ) ; ob_implicit_flush ( false ) ; $ view = $ this -> getView ( ) ; $ view -> clear ( ) ; $ view -> beginPage ( ) ; $ view -> head ( ) ; $ view -> beginBody ( ) ; if ( $ view -> title !== null ) { echo Html :: tag ( 'title' , Html :: encode ( $ view -> title ) ) ; } } else { $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'div' ) ; echo Html :: beginTag ( $ tag , array_merge ( [ 'data-pjax-container' => '' , 'data-pjax-push-state' => $ this -> enablePushState , 'data-pjax-replace-state' => $ this -> enableReplaceState , 'data-pjax-timeout' => $ this -> timeout , 'data-pjax-scrollto' => $ this -> scrollTo , ] , $ options ) ) ; } } 
public function init ( ) { parent :: init ( ) ; if ( empty ( $ this -> name ) ) { throw new InvalidConfigException ( 'The "name" property must be set.' ) ; } if ( substr_compare ( $ this -> name , '[]' , - 2 , 2 ) ) { $ this -> name .= '[]' ; } $ this -> registerClientScript ( ) ; } 
protected function renderHeaderCellContent ( ) { if ( $ this -> header !== null || ! $ this -> multiple ) { return parent :: renderHeaderCellContent ( ) ; } return Html :: checkbox ( $ this -> getHeaderCheckBoxName ( ) , false , [ 'class' => 'select-on-check-all' ] ) ; } 
protected function renderDataCellContent ( $ model , $ key , $ index ) { if ( $ this -> content !== null ) { return parent :: renderDataCellContent ( $ model , $ key , $ index ) ; } if ( $ this -> checkboxOptions instanceof Closure ) { $ options = call_user_func ( $ this -> checkboxOptions , $ model , $ key , $ index , $ this ) ; } else { $ options = $ this -> checkboxOptions ; } if ( ! isset ( $ options [ 'value' ] ) ) { $ options [ 'value' ] = is_array ( $ key ) ? Json :: encode ( $ key ) : $ key ; } if ( $ this -> cssClass !== null ) { Html :: addCssClass ( $ options , $ this -> cssClass ) ; } return Html :: checkbox ( $ this -> name , ! empty ( $ options [ 'checked' ] ) , $ options ) ; } 
protected function getHeaderCheckBoxName ( ) { $ name = $ this -> name ; if ( substr_compare ( $ name , '[]' , - 2 , 2 ) === 0 ) { $ name = substr ( $ name , 0 , - 2 ) ; } if ( substr_compare ( $ name , ']' , - 1 , 1 ) === 0 ) { $ name = substr ( $ name , 0 , - 1 ) . '_all]' ; } else { $ name .= '_all' ; } return $ name ; } 
public function registerClientScript ( ) { $ id = $ this -> grid -> options [ 'id' ] ; $ options = Json :: encode ( [ 'name' => $ this -> name , 'class' => $ this -> cssClass , 'multiple' => $ this -> multiple , 'checkAll' => $ this -> grid -> showHeader ? $ this -> getHeaderCheckBoxName ( ) : null , ] ) ; $ this -> grid -> getView ( ) -> registerJs ( "jQuery('#$id').yiiGridView('setSelectionColumn', $options);" ) ; } 
public function batchInsert ( $ table , $ columns , $ rows , & $ params = [ ] ) { if ( empty ( $ rows ) ) { return '' ; } 
public function renameTable ( $ table , $ newName ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' RENAME TO ' . $ this -> db -> quoteTableName ( $ newName ) ; } 
public function build ( $ query , $ params = [ ] ) { $ query = $ query -> prepare ( $ this ) ; $ params = empty ( $ params ) ? $ query -> params : array_merge ( $ params , $ query -> params ) ; $ clauses = [ $ this -> buildSelect ( $ query -> select , $ params , $ query -> distinct , $ query -> selectOption ) , $ this -> buildFrom ( $ query -> from , $ params ) , $ this -> buildJoin ( $ query -> join , $ params ) , $ this -> buildWhere ( $ query -> where , $ params ) , $ this -> buildGroupBy ( $ query -> groupBy ) , $ this -> buildHaving ( $ query -> having , $ params ) , ] ; $ sql = implode ( $ this -> separator , array_filter ( $ clauses ) ) ; $ sql = $ this -> buildOrderByAndLimit ( $ sql , $ query -> orderBy , $ query -> limit , $ query -> offset ) ; if ( ! empty ( $ query -> orderBy ) ) { foreach ( $ query -> orderBy as $ expression ) { if ( $ expression instanceof ExpressionInterface ) { $ this -> buildExpression ( $ expression , $ params ) ; } } } if ( ! empty ( $ query -> groupBy ) ) { foreach ( $ query -> groupBy as $ expression ) { if ( $ expression instanceof ExpressionInterface ) { $ this -> buildExpression ( $ expression , $ params ) ; } } } $ union = $ this -> buildUnion ( $ query -> union , $ params ) ; if ( $ union !== '' ) { $ sql = "$sql{$this->separator}$union" ; } return [ $ sql , $ params ] ; } 
public function init ( ) { parent :: init ( ) ; $ this -> mutexPath = Yii :: getAlias ( $ this -> mutexPath ) ; if ( ! is_dir ( $ this -> mutexPath ) ) { FileHelper :: createDirectory ( $ this -> mutexPath , $ this -> dirMode , true ) ; } if ( $ this -> isWindows === null ) { $ this -> isWindows = DIRECTORY_SEPARATOR === '\\' ; } } 
protected function acquireLock ( $ name , $ timeout = 0 ) { $ filePath = $ this -> getLockFilePath ( $ name ) ; return $ this -> retryAcquire ( $ timeout , function ( ) use ( $ filePath , $ name ) { $ file = fopen ( $ filePath , 'w+' ) ; if ( $ file === false ) { return false ; } if ( $ this -> fileMode !== null ) { @ chmod ( $ filePath , $ this -> fileMode ) ; } if ( ! flock ( $ file , LOCK_EX | LOCK_NB ) ) { fclose ( $ file ) ; return false ; } 
protected function releaseLock ( $ name ) { if ( ! isset ( $ this -> _files [ $ name ] ) ) { return false ; } if ( $ this -> isWindows ) { 
protected function renderHtmlResponse ( ) { return $ this -> controller -> render ( $ this -> view ? : $ this -> id , $ this -> getViewRenderParams ( ) ) ; } 
protected function getExceptionCode ( ) { if ( $ this -> exception instanceof HttpException ) { return $ this -> exception -> statusCode ; } return $ this -> exception -> getCode ( ) ; } 
protected function getExceptionName ( ) { if ( $ this -> exception instanceof Exception ) { $ name = $ this -> exception -> getName ( ) ; } else { $ name = $ this -> defaultName ; } if ( $ code = $ this -> getExceptionCode ( ) ) { $ name .= " (#$code)" ; } return $ name ; } 
public function up ( ) { $ authManager = $ this -> getAuthManager ( ) ; $ this -> db = $ authManager -> db ; $ schema = $ this -> db -> getSchema ( ) -> defaultSchema ; $ tableOptions = null ; if ( $ this -> db -> driverName === 'mysql' ) { ON {$schema}.{$authManager->itemTable} INSTEAD OF DELETE, UPDATE AS DECLARE @old_name VARCHAR (64) = (SELECT name FROM deleted) DECLARE @new_name VARCHAR (64) = (SELECT name FROM inserted) BEGIN IF COLUMNS_UPDATED() > 0 BEGIN IF @old_name <> @new_name BEGIN ALTER TABLE {$authManager->itemChildTable} NOCHECK CONSTRAINT FK__auth_item__child; UPDATE {$authManager->itemChildTable} SET child = @new_name WHERE child = @old_name; END UPDATE {$authManager->itemTable} SET name = (SELECT name FROM inserted), type = (SELECT type FROM inserted), description = (SELECT description FROM inserted), rule_name = (SELECT rule_name FROM inserted), data = (SELECT data FROM inserted), created_at = (SELECT created_at FROM inserted), updated_at = (SELECT updated_at FROM inserted) WHERE name IN (SELECT name FROM deleted) IF @old_name <> @new_name BEGIN ALTER TABLE {$authManager->itemChildTable} CHECK CONSTRAINT FK__auth_item__child; END END ELSE BEGIN DELETE FROM {$schema}.{$authManager->itemChildTable} WHERE parent IN (SELECT name FROM deleted) OR child IN (SELECT name FROM deleted); DELETE FROM {$schema}.{$authManager->itemTable} WHERE name IN (SELECT name FROM deleted); END END;" ) ; } } 
public function down ( ) { $ authManager = $ this -> getAuthManager ( ) ; $ this -> db = $ authManager -> db ; if ( $ this -> isMSSQL ( ) ) { $ this -> execute ( 'DROP TRIGGER {$schema}.trigger_auth_item_child;' ) ; } $ this -> dropTable ( $ authManager -> assignmentTable ) ; $ this -> dropTable ( $ authManager -> itemChildTable ) ; $ this -> dropTable ( $ authManager -> itemTable ) ; $ this -> dropTable ( $ authManager -> ruleTable ) ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> message === null ) { $ this -> message = $ this -> requiredValue === null ? Yii :: t ( 'yii' , '{attribute} cannot be blank.' ) : Yii :: t ( 'yii' , '{attribute} must be "{requiredValue}".' ) ; } } 
public function getClientOptions ( $ model , $ attribute ) { $ options = [ ] ; if ( $ this -> requiredValue !== null ) { $ options [ 'message' ] = $ this -> formatMessage ( $ this -> message , [ 'requiredValue' => $ this -> requiredValue , ] ) ; $ options [ 'requiredValue' ] = $ this -> requiredValue ; } else { $ options [ 'message' ] = $ this -> message ; } if ( $ this -> strict ) { $ options [ 'strict' ] = 1 ; } $ options [ 'message' ] = $ this -> formatMessage ( $ options [ 'message' ] , [ 'attribute' => $ model -> getAttributeLabel ( $ attribute ) , ] ) ; return $ options ; } 
public function init ( ) { parent :: init ( ) ; if ( ! isset ( $ this -> translations [ 'yii' ] ) && ! isset ( $ this -> translations [ 'yii*' ] ) ) { $ this -> translations [ 'yii' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@yii/messages' , ] ; } if ( ! isset ( $ this -> translations [ 'app' ] ) && ! isset ( $ this -> translations [ 'app*' ] ) ) { $ this -> translations [ 'app' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => Yii :: $ app -> sourceLanguage , 'basePath' => '@app/messages' , ] ; } } 
public function translate ( $ category , $ message , $ params , $ language ) { $ messageSource = $ this -> getMessageSource ( $ category ) ; $ translation = $ messageSource -> translate ( $ category , $ message , $ language ) ; if ( $ translation === false ) { return $ this -> format ( $ message , $ params , $ messageSource -> sourceLanguage ) ; } return $ this -> format ( $ translation , $ params , $ language ) ; } 
public function format ( $ message , $ params , $ language ) { $ params = ( array ) $ params ; if ( $ params === [ ] ) { return $ message ; } if ( preg_match ( '~{\s*[\w.]+\s*,~u' , $ message ) ) { $ formatter = $ this -> getMessageFormatter ( ) ; $ result = $ formatter -> format ( $ message , $ params , $ language ) ; if ( $ result === false ) { $ errorMessage = $ formatter -> getErrorMessage ( ) ; Yii :: warning ( "Formatting message for language '$language' failed with error: $errorMessage. The message being formatted was: $message." , __METHOD__ ) ; return $ message ; } return $ result ; } $ p = [ ] ; foreach ( $ params as $ name => $ value ) { $ p [ '{' . $ name . '}' ] = $ value ; } return strtr ( $ message , $ p ) ; } 
public function getMessageFormatter ( ) { if ( $ this -> _messageFormatter === null ) { $ this -> _messageFormatter = new MessageFormatter ( ) ; } elseif ( is_array ( $ this -> _messageFormatter ) || is_string ( $ this -> _messageFormatter ) ) { $ this -> _messageFormatter = Yii :: createObject ( $ this -> _messageFormatter ) ; } return $ this -> _messageFormatter ; } 
public function getMessageSource ( $ category ) { if ( isset ( $ this -> translations [ $ category ] ) ) { $ source = $ this -> translations [ $ category ] ; if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = Yii :: createObject ( $ source ) ; } 
protected function composeFields ( $ id = null , $ data = null ) { $ fields = $ this -> writeCallback ? call_user_func ( $ this -> writeCallback , $ this ) : [ ] ; if ( $ id !== null ) { $ fields [ 'id' ] = $ id ; } if ( $ data !== null ) { $ fields [ 'data' ] = $ data ; } return $ fields ; } 
public function actionIndex ( $ command = null ) { if ( $ command !== null ) { $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result === false ) { $ name = $ this -> ansiFormat ( $ command , Console :: FG_YELLOW ) ; throw new Exception ( "No help for unknown command \"$name\"." ) ; } list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( $ actionID !== '' || count ( $ actions ) === 1 && $ actions [ 0 ] === $ controller -> defaultAction ) { $ this -> getSubCommandHelp ( $ controller , $ actionID ) ; } else { $ this -> getCommandHelp ( $ controller ) ; } } else { $ this -> getDefaultHelp ( ) ; } } 
public function actionList ( ) { foreach ( $ this -> getCommandDescriptions ( ) as $ command => $ description ) { $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result === false || ! ( $ result [ 0 ] instanceof Controller ) ) { continue ; } list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( ! empty ( $ actions ) ) { $ prefix = $ controller -> getUniqueId ( ) ; $ this -> stdout ( "$prefix\n" ) ; foreach ( $ actions as $ action ) { $ this -> stdout ( "$prefix/$action\n" ) ; } } } } 
public function actionListActionOptions ( $ action ) { $ result = Yii :: $ app -> createController ( $ action ) ; if ( $ result === false || ! ( $ result [ 0 ] instanceof Controller ) ) { return ; } list ( $ controller , $ actionID ) = $ result ; $ action = $ controller -> createAction ( $ actionID ) ; if ( $ action === null ) { return ; } foreach ( $ controller -> getActionArgsHelp ( $ action ) as $ argument => $ help ) { $ description = preg_replace ( "~\R~" , '' , addcslashes ( $ help [ 'comment' ] , ':' ) ) ? : $ argument ; $ this -> stdout ( $ argument . ':' . $ description . "\n" ) ; } $ this -> stdout ( "\n" ) ; foreach ( $ controller -> getActionOptionsHelp ( $ action ) as $ argument => $ help ) { $ description = preg_replace ( "~\R~" , '' , addcslashes ( $ help [ 'comment' ] , ':' ) ) ; $ this -> stdout ( '--' . $ argument . ( $ description ? ':' . $ description : '' ) . "\n" ) ; } } 
public function actionUsage ( $ action ) { $ result = Yii :: $ app -> createController ( $ action ) ; if ( $ result === false || ! ( $ result [ 0 ] instanceof Controller ) ) { return ; } list ( $ controller , $ actionID ) = $ result ; $ action = $ controller -> createAction ( $ actionID ) ; if ( $ action === null ) { return ; } $ scriptName = $ this -> getScriptName ( ) ; if ( $ action -> id === $ controller -> defaultAction ) { $ this -> stdout ( $ scriptName . ' ' . $ this -> ansiFormat ( $ controller -> getUniqueId ( ) , Console :: FG_YELLOW ) ) ; } else { $ this -> stdout ( $ scriptName . ' ' . $ this -> ansiFormat ( $ action -> getUniqueId ( ) , Console :: FG_YELLOW ) ) ; } foreach ( $ controller -> getActionArgsHelp ( $ action ) as $ name => $ arg ) { if ( $ arg [ 'required' ] ) { $ this -> stdout ( ' <' . $ name . '>' , Console :: FG_CYAN ) ; } else { $ this -> stdout ( ' [' . $ name . ']' , Console :: FG_CYAN ) ; } } $ this -> stdout ( "\n" ) ; } 
protected function getDefaultHelp ( ) { $ commands = $ this -> getCommandDescriptions ( ) ; $ this -> stdout ( $ this -> getDefaultHelpHeader ( ) ) ; if ( ! empty ( $ commands ) ) { $ this -> stdout ( "\nThe following commands are available:\n\n" , Console :: BOLD ) ; $ len = 0 ; foreach ( $ commands as $ command => $ description ) { $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result !== false && $ result [ 0 ] instanceof Controller ) { list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( ! empty ( $ actions ) ) { $ prefix = $ controller -> getUniqueId ( ) ; foreach ( $ actions as $ action ) { $ string = $ prefix . '/' . $ action ; if ( $ action === $ controller -> defaultAction ) { $ string .= ' (default)' ; } if ( ( $ l = strlen ( $ string ) ) > $ len ) { $ len = $ l ; } } } } elseif ( ( $ l = strlen ( $ command ) ) > $ len ) { $ len = $ l ; } } foreach ( $ commands as $ command => $ description ) { $ this -> stdout ( '- ' . $ this -> ansiFormat ( $ command , Console :: FG_YELLOW ) ) ; $ this -> stdout ( str_repeat ( ' ' , $ len + 4 - strlen ( $ command ) ) ) ; $ this -> stdout ( Console :: wrapText ( $ description , $ len + 4 + 2 ) , Console :: BOLD ) ; $ this -> stdout ( "\n" ) ; $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result !== false && $ result [ 0 ] instanceof Controller ) { list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( ! empty ( $ actions ) ) { $ prefix = $ controller -> getUniqueId ( ) ; foreach ( $ actions as $ action ) { $ string = ' ' . $ prefix . '/' . $ action ; $ this -> stdout ( ' ' . $ this -> ansiFormat ( $ string , Console :: FG_GREEN ) ) ; if ( $ action === $ controller -> defaultAction ) { $ string .= ' (default)' ; $ this -> stdout ( ' (default)' , Console :: FG_YELLOW ) ; } $ summary = $ controller -> getActionHelpSummary ( $ controller -> createAction ( $ action ) ) ; if ( $ summary !== '' ) { $ this -> stdout ( str_repeat ( ' ' , $ len + 4 - strlen ( $ string ) ) ) ; $ this -> stdout ( Console :: wrapText ( $ summary , $ len + 4 + 2 ) ) ; } $ this -> stdout ( "\n" ) ; } } $ this -> stdout ( "\n" ) ; } } $ scriptName = $ this -> getScriptName ( ) ; $ this -> stdout ( "\nTo see the help of each command, enter:\n" , Console :: BOLD ) ; $ this -> stdout ( "\n $scriptName " . $ this -> ansiFormat ( 'help' , Console :: FG_YELLOW ) . ' ' . $ this -> ansiFormat ( '<command-name>' , Console :: FG_CYAN ) . "\n\n" ) ; } else { $ this -> stdout ( "\nNo commands are found.\n\n" , Console :: BOLD ) ; } } 
protected function getSubCommandHelp ( $ controller , $ actionID ) { $ action = $ controller -> createAction ( $ actionID ) ; if ( $ action === null ) { $ name = $ this -> ansiFormat ( rtrim ( $ controller -> getUniqueId ( ) . '/' . $ actionID , '/' ) , Console :: FG_YELLOW ) ; throw new Exception ( "No help for unknown sub-command \"$name\"." ) ; } $ description = $ controller -> getActionHelp ( $ action ) ; if ( $ description !== '' ) { $ this -> stdout ( "\nDESCRIPTION\n" , Console :: BOLD ) ; $ this -> stdout ( "\n$description\n\n" ) ; } $ this -> stdout ( "\nUSAGE\n\n" , Console :: BOLD ) ; $ scriptName = $ this -> getScriptName ( ) ; if ( $ action -> id === $ controller -> defaultAction ) { $ this -> stdout ( $ scriptName . ' ' . $ this -> ansiFormat ( $ controller -> getUniqueId ( ) , Console :: FG_YELLOW ) ) ; } else { $ this -> stdout ( $ scriptName . ' ' . $ this -> ansiFormat ( $ action -> getUniqueId ( ) , Console :: FG_YELLOW ) ) ; } $ args = $ controller -> getActionArgsHelp ( $ action ) ; foreach ( $ args as $ name => $ arg ) { if ( $ arg [ 'required' ] ) { $ this -> stdout ( ' <' . $ name . '>' , Console :: FG_CYAN ) ; } else { $ this -> stdout ( ' [' . $ name . ']' , Console :: FG_CYAN ) ; } } $ options = $ controller -> getActionOptionsHelp ( $ action ) ; $ options [ \ yii \ console \ Application :: OPTION_APPCONFIG ] = [ 'type' => 'string' , 'default' => null , 'comment' => "custom application configuration file path.\nIf not set, default application configuration is used." , ] ; ksort ( $ options ) ; if ( ! empty ( $ options ) ) { $ this -> stdout ( ' [...options...]' , Console :: FG_RED ) ; } $ this -> stdout ( "\n\n" ) ; if ( ! empty ( $ args ) ) { foreach ( $ args as $ name => $ arg ) { $ this -> stdout ( $ this -> formatOptionHelp ( '- ' . $ this -> ansiFormat ( $ name , Console :: FG_CYAN ) , $ arg [ 'required' ] , $ arg [ 'type' ] , $ arg [ 'default' ] , $ arg [ 'comment' ] ) . "\n\n" ) ; } } if ( ! empty ( $ options ) ) { $ this -> stdout ( "\nOPTIONS\n\n" , Console :: BOLD ) ; foreach ( $ options as $ name => $ option ) { $ this -> stdout ( $ this -> formatOptionHelp ( $ this -> ansiFormat ( '--' . $ name . $ this -> formatOptionAliases ( $ controller , $ name ) , Console :: FG_RED , empty ( $ option [ 'required' ] ) ? Console :: FG_RED : Console :: BOLD ) , ! empty ( $ option [ 'required' ] ) , $ option [ 'type' ] , $ option [ 'default' ] , $ option [ 'comment' ] ) . "\n\n" ) ; } } } 
protected function formatOptionHelp ( $ name , $ required , $ type , $ defaultValue , $ comment ) { $ comment = trim ( $ comment ) ; $ type = trim ( $ type ) ; if ( strncmp ( $ type , 'bool' , 4 ) === 0 ) { $ type = 'boolean, 0 or 1' ; } if ( $ defaultValue !== null && ! is_array ( $ defaultValue ) ) { if ( $ type === null ) { $ type = gettype ( $ defaultValue ) ; } if ( is_bool ( $ defaultValue ) ) { 
protected function loadMessages ( $ category , $ language ) { $ messageFile = $ this -> getMessageFilePath ( $ category , $ language ) ; $ messages = $ this -> loadMessagesFromFile ( $ messageFile ) ; $ fallbackLanguage = substr ( $ language , 0 , 2 ) ; $ fallbackSourceLanguage = substr ( $ this -> sourceLanguage , 0 , 2 ) ; if ( $ language !== $ fallbackLanguage ) { $ messages = $ this -> loadFallbackMessages ( $ category , $ fallbackLanguage , $ messages , $ messageFile ) ; } elseif ( $ language === $ fallbackSourceLanguage ) { $ messages = $ this -> loadFallbackMessages ( $ category , $ this -> sourceLanguage , $ messages , $ messageFile ) ; } else { if ( $ messages === null ) { Yii :: warning ( "The message file for category '$category' does not exist: $messageFile" , __METHOD__ ) ; } } return ( array ) $ messages ; } 
protected function getMessageFilePath ( $ category , $ language ) { $ messageFile = Yii :: getAlias ( $ this -> basePath ) . "/$language/" ; if ( isset ( $ this -> fileMap [ $ category ] ) ) { $ messageFile .= $ this -> fileMap [ $ category ] ; } else { $ messageFile .= str_replace ( '\\' , '/' , $ category ) . '.php' ; } return $ messageFile ; } 
public function exists ( $ key ) { $ key = $ this -> buildKey ( $ key ) ; return $ this -> useApcu ? apcu_exists ( $ key ) : apc_exists ( $ key ) ; } 
protected function getValues ( $ keys ) { $ values = $ this -> useApcu ? apcu_fetch ( $ keys ) : apc_fetch ( $ keys ) ; return is_array ( $ values ) ? $ values : [ ] ; } 
protected function setValue ( $ key , $ value , $ duration ) { return $ this -> useApcu ? apcu_store ( $ key , $ value , $ duration ) : apc_store ( $ key , $ value , $ duration ) ; } 
protected function setValues ( $ data , $ duration ) { $ result = $ this -> useApcu ? apcu_store ( $ data , null , $ duration ) : apc_store ( $ data , null , $ duration ) ; return is_array ( $ result ) ? array_keys ( $ result ) : [ ] ; } 
protected function addValue ( $ key , $ value , $ duration ) { return $ this -> useApcu ? apcu_add ( $ key , $ value , $ duration ) : apc_add ( $ key , $ value , $ duration ) ; } 
protected function addValues ( $ data , $ duration ) { $ result = $ this -> useApcu ? apcu_add ( $ data , null , $ duration ) : apc_add ( $ data , null , $ duration ) ; return is_array ( $ result ) ? array_keys ( $ result ) : [ ] ; } 
public function actionUp ( $ limit = 0 ) { $ migrations = $ this -> getNewMigrations ( ) ; if ( empty ( $ migrations ) ) { $ this -> stdout ( "No new migrations found. Your system is up-to-date.\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; } $ total = count ( $ migrations ) ; $ limit = ( int ) $ limit ; if ( $ limit > 0 ) { $ migrations = array_slice ( $ migrations , 0 , $ limit ) ; } $ n = count ( $ migrations ) ; if ( $ n === $ total ) { $ this -> stdout ( "Total $n new " . ( $ n === 1 ? 'migration' : 'migrations' ) . " to be applied:\n" , Console :: FG_YELLOW ) ; } else { $ this -> stdout ( "Total $n out of $total new " . ( $ total === 1 ? 'migration' : 'migrations' ) . " to be applied:\n" , Console :: FG_YELLOW ) ; } foreach ( $ migrations as $ migration ) { $ nameLimit = $ this -> getMigrationNameLimit ( ) ; if ( $ nameLimit !== null && strlen ( $ migration ) > $ nameLimit ) { $ this -> stdout ( "\nThe migration name '$migration' is too long. Its not possible to apply this migration.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "\t$migration\n" ) ; } $ this -> stdout ( "\n" ) ; $ applied = 0 ; if ( $ this -> confirm ( 'Apply the above ' . ( $ n === 1 ? 'migration' : 'migrations' ) . '?' ) ) { foreach ( $ migrations as $ migration ) { if ( ! $ this -> migrateUp ( $ migration ) ) { $ this -> stdout ( "\n$applied from $n " . ( $ applied === 1 ? 'migration was' : 'migrations were' ) . " applied.\n" , Console :: FG_RED ) ; $ this -> stdout ( "\nMigration failed. The rest of the migrations are canceled.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ applied ++ ; } $ this -> stdout ( "\n$n " . ( $ n === 1 ? 'migration was' : 'migrations were' ) . " applied.\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "\nMigrated up successfully.\n" , Console :: FG_GREEN ) ; } } 
public function actionDown ( $ limit = 1 ) { if ( $ limit === 'all' ) { $ limit = null ; } else { $ limit = ( int ) $ limit ; if ( $ limit < 1 ) { throw new Exception ( 'The step argument must be greater than 0.' ) ; } } $ migrations = $ this -> getMigrationHistory ( $ limit ) ; if ( empty ( $ migrations ) ) { $ this -> stdout ( "No migration has been done before.\n" , Console :: FG_YELLOW ) ; return ExitCode :: OK ; } $ migrations = array_keys ( $ migrations ) ; $ n = count ( $ migrations ) ; $ this -> stdout ( "Total $n " . ( $ n === 1 ? 'migration' : 'migrations' ) . " to be reverted:\n" , Console :: FG_YELLOW ) ; foreach ( $ migrations as $ migration ) { $ this -> stdout ( "\t$migration\n" ) ; } $ this -> stdout ( "\n" ) ; $ reverted = 0 ; if ( $ this -> confirm ( 'Revert the above ' . ( $ n === 1 ? 'migration' : 'migrations' ) . '?' ) ) { foreach ( $ migrations as $ migration ) { if ( ! $ this -> migrateDown ( $ migration ) ) { $ this -> stdout ( "\n$reverted from $n " . ( $ reverted === 1 ? 'migration was' : 'migrations were' ) . " reverted.\n" , Console :: FG_RED ) ; $ this -> stdout ( "\nMigration failed. The rest of the migrations are canceled.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ reverted ++ ; } $ this -> stdout ( "\n$n " . ( $ n === 1 ? 'migration was' : 'migrations were' ) . " reverted.\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "\nMigrated down successfully.\n" , Console :: FG_GREEN ) ; } } 
public function actionTo ( $ version ) { if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ namespaceVersion ) ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ migrationName ) ; } elseif ( ( string ) ( int ) $ version == $ version ) { $ this -> migrateToTime ( $ version ) ; } elseif ( ( $ time = strtotime ( $ version ) ) !== false ) { $ this -> migrateToTime ( $ time ) ; } else { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401),\n the full name of a migration (e.g. m101129_185401_create_user_table),\n the full namespaced name of a migration (e.g. app\\migrations\\M101129185401CreateUserTable),\n a UNIX timestamp (e.g. 1392853000), or a datetime string parseable\nby the strtotime() function (e.g. 2014-02-15 13:00:50)." ) ; } } 
public function actionMark ( $ version ) { $ originalVersion = $ version ; if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ version = $ namespaceVersion ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ version = $ migrationName ; } elseif ( $ version !== static :: BASE_MIGRATION ) { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401)\nor the full name of a migration (e.g. m101129_185401_create_user_table)\nor the full name of a namespaced migration (e.g. app\\migrations\\M101129185401CreateUserTable)." ) ; } 
public function actionFresh ( ) { if ( YII_ENV_PROD ) { $ this -> stdout ( "YII_ENV is set to 'prod'.\nRefreshing migrations is not possible on production systems.\n" ) ; return ExitCode :: OK ; } if ( $ this -> confirm ( "Are you sure you want to reset the database and start the migration from the beginning?\nAll data will be lost irreversibly!" ) ) { $ this -> truncateDatabase ( ) ; $ this -> actionUp ( ) ; } else { $ this -> stdout ( 'Action was cancelled by user. Nothing has been performed.' ) ; } } 
private function generateClassName ( $ name ) { $ namespace = null ; $ name = trim ( $ name , '\\' ) ; if ( strpos ( $ name , '\\' ) !== false ) { $ namespace = substr ( $ name , 0 , strrpos ( $ name , '\\' ) ) ; $ name = substr ( $ name , strrpos ( $ name , '\\' ) + 1 ) ; } else { if ( $ this -> migrationPath === null ) { $ migrationNamespaces = $ this -> migrationNamespaces ; $ namespace = array_shift ( $ migrationNamespaces ) ; } } if ( $ namespace === null ) { $ class = 'm' . gmdate ( 'ymd_His' ) . '_' . $ name ; } else { $ class = 'M' . gmdate ( 'ymdHis' ) . ucfirst ( $ name ) ; } return [ $ namespace , $ class ] ; } 
private function findMigrationPath ( $ namespace ) { if ( empty ( $ namespace ) ) { return is_array ( $ this -> migrationPath ) ? reset ( $ this -> migrationPath ) : $ this -> migrationPath ; } if ( ! in_array ( $ namespace , $ this -> migrationNamespaces , true ) ) { throw new Exception ( "Namespace '{$namespace}' not found in `migrationNamespaces`" ) ; } return $ this -> getNamespacePath ( $ namespace ) ; } 
protected function migrateUp ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** applying $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> up ( ) !== false ) { $ this -> addMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** applied $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to apply $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; } 
protected function migrateDown ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** reverting $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> down ( ) !== false ) { $ this -> removeMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** reverted $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to revert $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; } 
protected function createMigration ( $ class ) { $ this -> includeMigrationFile ( $ class ) ; $ migration = Yii :: createObject ( $ class ) ; if ( $ migration instanceof BaseObject && $ migration -> canSetProperty ( 'compact' ) ) { $ migration -> compact = $ this -> compact ; } return $ migration ; } 
protected function includeMigrationFile ( $ class ) { $ class = trim ( $ class , '\\' ) ; if ( strpos ( $ class , '\\' ) === false ) { if ( is_array ( $ this -> migrationPath ) ) { foreach ( $ this -> migrationPath as $ path ) { $ file = $ path . DIRECTORY_SEPARATOR . $ class . '.php' ; if ( is_file ( $ file ) ) { require_once $ file ; break ; } } } else { $ file = $ this -> migrationPath . DIRECTORY_SEPARATOR . $ class . '.php' ; require_once $ file ; } } } 
protected function migrateToTime ( $ time ) { $ count = 0 ; $ migrations = array_values ( $ this -> getMigrationHistory ( null ) ) ; while ( $ count < count ( $ migrations ) && $ migrations [ $ count ] > $ time ) { ++ $ count ; } if ( $ count === 0 ) { $ this -> stdout ( "Nothing needs to be done.\n" , Console :: FG_GREEN ) ; } else { $ this -> actionDown ( $ count ) ; } } 
protected function migrateToVersion ( $ version ) { $ originalVersion = $ version ; 
public function init ( ) { if ( $ this -> sourcePath !== null ) { $ this -> sourcePath = rtrim ( Yii :: getAlias ( $ this -> sourcePath ) , '/\\' ) ; } if ( $ this -> basePath !== null ) { $ this -> basePath = rtrim ( Yii :: getAlias ( $ this -> basePath ) , '/\\' ) ; } if ( $ this -> baseUrl !== null ) { $ this -> baseUrl = rtrim ( Yii :: getAlias ( $ this -> baseUrl ) , '/' ) ; } } 
public function registerAssetFiles ( $ view ) { $ manager = $ view -> getAssetManager ( ) ; foreach ( $ this -> js as $ js ) { if ( is_array ( $ js ) ) { $ file = array_shift ( $ js ) ; $ options = ArrayHelper :: merge ( $ this -> jsOptions , $ js ) ; $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ js !== null ) { $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ js ) , $ this -> jsOptions ) ; } } } foreach ( $ this -> css as $ css ) { if ( is_array ( $ css ) ) { $ file = array_shift ( $ css ) ; $ options = ArrayHelper :: merge ( $ this -> cssOptions , $ css ) ; $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ css !== null ) { $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ css ) , $ this -> cssOptions ) ; } } } } 
public function publish ( $ am ) { if ( $ this -> sourcePath !== null && ! isset ( $ this -> basePath , $ this -> baseUrl ) ) { list ( $ this -> basePath , $ this -> baseUrl ) = $ am -> publish ( $ this -> sourcePath , $ this -> publishOptions ) ; } if ( isset ( $ this -> basePath , $ this -> baseUrl ) && ( $ converter = $ am -> getConverter ( ) ) !== null ) { foreach ( $ this -> js as $ i => $ js ) { if ( is_array ( $ js ) ) { $ file = array_shift ( $ js ) ; if ( Url :: isRelative ( $ file ) ) { $ js = ArrayHelper :: merge ( $ this -> jsOptions , $ js ) ; array_unshift ( $ js , $ converter -> convert ( $ file , $ this -> basePath ) ) ; $ this -> js [ $ i ] = $ js ; } } elseif ( Url :: isRelative ( $ js ) ) { $ this -> js [ $ i ] = $ converter -> convert ( $ js , $ this -> basePath ) ; } } foreach ( $ this -> css as $ i => $ css ) { if ( is_array ( $ css ) ) { $ file = array_shift ( $ css ) ; if ( Url :: isRelative ( $ file ) ) { $ css = ArrayHelper :: merge ( $ this -> cssOptions , $ css ) ; array_unshift ( $ css , $ converter -> convert ( $ file , $ this -> basePath ) ) ; $ this -> css [ $ i ] = $ css ; } } elseif ( Url :: isRelative ( $ css ) ) { $ this -> css [ $ i ] = $ converter -> convert ( $ css , $ this -> basePath ) ; } } } } 
public function actionInfo ( ) { $ items = [ 'framework' , 'app-basic' , 'app-advanced' , ] ; $ extensionPath = "{$this->basePath}/extensions" ; foreach ( scandir ( $ extensionPath ) as $ extension ) { if ( ctype_alpha ( $ extension ) && is_dir ( $ extensionPath . '/' . $ extension ) ) { $ items [ ] = $ extension ; } } if ( $ this -> update ) { foreach ( $ items as $ item ) { $ this -> stdout ( "fetching tags for $item..." ) ; if ( $ item === 'framework' ) { $ this -> gitFetchTags ( ( string ) $ this -> basePath ) ; } elseif ( strncmp ( 'app-' , $ item , 4 ) === 0 ) { $ this -> gitFetchTags ( "{$this->basePath}/apps/" . substr ( $ item , 4 ) ) ; } else { $ this -> gitFetchTags ( "{$this->basePath}/extensions/$item" ) ; } $ this -> stdout ( "done.\n" , Console :: FG_GREEN , Console :: BOLD ) ; } } else { $ this -> stdout ( "\nInformation may be outdated, re-run with `--update` to fetch latest tags.\n\n" ) ; } $ versions = $ this -> getCurrentVersions ( $ items ) ; $ nextVersions = $ this -> getNextVersions ( $ versions , self :: PATCH ) ; 
public function actionRelease ( array $ what ) { if ( \ count ( $ what ) > 1 ) { $ this -> stdout ( "Currently only one simultaneous release is supported.\n" ) ; return 1 ; } $ this -> stdout ( "This is the Yii release manager\n\n" , Console :: BOLD ) ; if ( $ this -> dryRun ) { $ this -> stdout ( "Running in \"dry-run\" mode, nothing will actually be changed.\n\n" , Console :: BOLD , Console :: FG_GREEN ) ; } $ this -> validateWhat ( $ what ) ; $ versions = $ this -> getCurrentVersions ( $ what ) ; if ( $ this -> version !== null ) { 
public function actionPackage ( array $ what ) { $ this -> validateWhat ( $ what , [ 'app' ] ) ; $ versions = $ this -> getCurrentVersions ( $ what ) ; $ this -> stdout ( "You are about to generate packages for the following things:\n\n" ) ; foreach ( $ what as $ ext ) { if ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( substr ( $ ext , 4 ) , Console :: FG_RED ) ; $ this -> stdout ( ' application version ' ) ; } elseif ( $ ext === 'framework' ) { $ this -> stdout ( ' - Yii Framework version ' ) ; } else { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( $ ext , Console :: FG_RED ) ; $ this -> stdout ( ' extension version ' ) ; } $ this -> stdout ( $ versions [ $ ext ] , Console :: BOLD ) ; $ this -> stdout ( "\n" ) ; } $ this -> stdout ( "\n" ) ; $ packagePath = "{$this->basePath}/packages" ; $ this -> stdout ( "Packages will be stored in $packagePath\n\n" ) ; if ( ! $ this -> confirm ( 'Continue?' , false ) ) { $ this -> stdout ( "Canceled.\n" ) ; return 1 ; } foreach ( $ what as $ ext ) { if ( $ ext === 'framework' ) { throw new Exception ( 'Can not package framework.' ) ; } elseif ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> packageApplication ( substr ( $ ext , 4 ) , $ versions [ $ ext ] , $ packagePath ) ; } else { throw new Exception ( 'Can not package extension.' ) ; } } $ this -> stdout ( "\ndone. verify the versions composer installed above and push it to github!\n\n" ) ; return 0 ; } 
public function actionSortChangelog ( array $ what ) { if ( \ count ( $ what ) > 1 ) { $ this -> stdout ( "Currently only one simultaneous release is supported.\n" ) ; return 1 ; } $ this -> validateWhat ( $ what , [ 'framework' , 'ext' ] , false ) ; $ version = $ this -> version ? : array_values ( $ this -> getNextVersions ( $ this -> getCurrentVersions ( $ what ) , self :: PATCH ) ) [ 0 ] ; $ this -> stdout ( 'sorting CHANGELOG of ' ) ; $ this -> stdout ( reset ( $ what ) , Console :: BOLD ) ; $ this -> stdout ( ' for version ' ) ; $ this -> stdout ( $ version , Console :: BOLD ) ; $ this -> stdout ( '...' ) ; $ this -> resortChangelogs ( $ what , $ version ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } 
protected function splitChangelog ( $ file , $ version ) { $ lines = explode ( "\n" , file_get_contents ( $ file ) ) ; 
protected function resortChangelog ( $ changelog ) { 
public function actionFix ( $ root = null ) { $ files = $ this -> findFiles ( $ root , false ) ; $ nFilesTotal = 0 ; $ nFilesUpdated = 0 ; foreach ( $ files as $ file ) { $ contents = file_get_contents ( $ file ) ; $ hash = $ this -> hash ( $ contents ) ; 
protected function fixFileDoc ( & $ lines ) { 
protected function fixDocBlockIndentation ( & $ lines ) { $ docBlock = false ; $ codeBlock = false ; $ listIndent = '' ; $ tag = false ; $ indent = '' ; foreach ( $ lines as $ i => $ line ) { if ( preg_match ( '~^(\s*)/\*\*$~' , $ line , $ matches ) ) { $ docBlock = true ; $ indent = $ matches [ 1 ] ; } elseif ( preg_match ( '~^(\s*)\*+/~' , $ line ) ) { if ( $ docBlock ) { 
protected function fixLineSpacing ( $ lines ) { $ propertiesOnly = false ; 
protected function cleanDocComment ( $ doc ) { $ lines = explode ( "\n" , $ doc ) ; $ n = \ count ( $ lines ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ lines [ $ i ] = rtrim ( $ lines [ $ i ] ) ; if ( trim ( $ lines [ $ i ] ) == '*' && trim ( $ lines [ $ i + 1 ] ) == '*' ) { unset ( $ lines [ $ i ] ) ; } } return implode ( "\n" , $ lines ) ; } 
protected function updateDocComment ( $ doc , $ properties ) { $ lines = explode ( "\n" , $ doc ) ; $ propertyPart = false ; $ propertyPosition = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( strncmp ( $ line , '* @property ' , 12 ) === 0 ) { $ propertyPart = true ; } elseif ( $ propertyPart && $ line == '*' ) { $ propertyPosition = $ i ; $ propertyPart = false ; } if ( strncmp ( $ line , '* @author ' , 10 ) === 0 && $ propertyPosition === false ) { $ propertyPosition = $ i - 1 ; $ propertyPart = false ; } if ( $ propertyPart ) { unset ( $ lines [ $ i ] ) ; } } 
public function buildOrderByAndLimit ( $ sql , $ orderBy , $ limit , $ offset ) { $ orderBy = $ this -> buildOrderBy ( $ orderBy ) ; if ( $ orderBy !== '' ) { $ sql .= $ this -> separator . $ orderBy ; } $ filters = [ ] ; if ( $ this -> hasOffset ( $ offset ) ) { $ filters [ ] = 'rowNumId > ' . $ offset ; } if ( $ this -> hasLimit ( $ limit ) ) { $ filters [ ] = 'rownum <= ' . $ limit ; } if ( empty ( $ filters ) ) { return $ sql ; } $ filter = implode ( ' AND ' , $ filters ) ; return <<<EOD WITH USER_SQL AS ($sql), PAGINATION AS (SELECT USER_SQL.*, rownum as rowNumId FROM USER_SQL) SELECT * FROM PAGINATION WHERE $filter EOD ; } 
public function executeResetSequence ( $ table , $ value = null ) { $ tableSchema = $ this -> db -> getTableSchema ( $ table ) ; if ( $ tableSchema === null ) { throw new InvalidArgumentException ( "Unknown table: $table" ) ; } if ( $ tableSchema -> sequenceName === null ) { throw new InvalidArgumentException ( "There is no sequence associated with table: $table" ) ; } if ( $ value !== null ) { $ value = ( int ) $ value ; } else { if ( count ( $ tableSchema -> primaryKey ) > 1 ) { throw new InvalidArgumentException ( "Can't reset sequence for composite primary key in table: $table" ) ; } 
public function addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete = null , $ update = null ) { $ sql = 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' ADD CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) . ' FOREIGN KEY (' . $ this -> buildColumns ( $ columns ) . ')' . ' REFERENCES ' . $ this -> db -> quoteTableName ( $ refTable ) . ' (' . $ this -> buildColumns ( $ refColumns ) . ')' ; if ( $ delete !== null ) { $ sql .= ' ON DELETE ' . $ delete ; } if ( $ update !== null ) { throw new Exception ( 'Oracle does not support ON UPDATE clause.' ) ; } return $ sql ; } 
protected function prepareInsertValues ( $ table , $ columns , $ params = [ ] ) { list ( $ names , $ placeholders , $ values , $ params ) = parent :: prepareInsertValues ( $ table , $ columns , $ params ) ; if ( ! $ columns instanceof Query && empty ( $ names ) ) { $ tableSchema = $ this -> db -> getSchema ( ) -> getTableSchema ( $ table ) ; if ( $ tableSchema !== null ) { $ columns = ! empty ( $ tableSchema -> primaryKey ) ? $ tableSchema -> primaryKey : [ reset ( $ tableSchema -> columns ) -> name ] ; foreach ( $ columns as $ name ) { $ names [ ] = $ this -> db -> quoteColumnName ( $ name ) ; $ placeholders [ ] = 'DEFAULT' ; } } } return [ $ names , $ placeholders , $ values , $ params ] ; } 
public function upsert ( $ table , $ insertColumns , $ updateColumns , & $ params ) { list ( $ uniqueNames , $ insertNames , $ updateNames ) = $ this -> prepareUpsertColumns ( $ table , $ insertColumns , $ updateColumns , $ constraints ) ; if ( empty ( $ uniqueNames ) ) { return $ this -> insert ( $ table , $ insertColumns , $ params ) ; } $ onCondition = [ 'or' ] ; $ quotedTableName = $ this -> db -> quoteTableName ( $ table ) ; foreach ( $ constraints as $ constraint ) { $ constraintCondition = [ 'and' ] ; foreach ( $ constraint -> columnNames as $ name ) { $ quotedName = $ this -> db -> quoteColumnName ( $ name ) ; $ constraintCondition [ ] = "$quotedTableName.$quotedName=\"EXCLUDED\".$quotedName" ; } $ onCondition [ ] = $ constraintCondition ; } $ on = $ this -> buildCondition ( $ onCondition , $ params ) ; list ( , $ placeholders , $ values , $ params ) = $ this -> prepareInsertValues ( $ table , $ insertColumns , $ params ) ; if ( ! empty ( $ placeholders ) ) { $ usingSelectValues = [ ] ; foreach ( $ insertNames as $ index => $ name ) { $ usingSelectValues [ $ name ] = new Expression ( $ placeholders [ $ index ] ) ; } $ usingSubQuery = ( new Query ( ) ) -> select ( $ usingSelectValues ) -> from ( 'DUAL' ) ; list ( $ usingValues , $ params ) = $ this -> build ( $ usingSubQuery , $ params ) ; } $ mergeSql = 'MERGE INTO ' . $ this -> db -> quoteTableName ( $ table ) . ' ' . 'USING (' . ( isset ( $ usingValues ) ? $ usingValues : ltrim ( $ values , ' ' ) ) . ') "EXCLUDED" ' . "ON ($on)" ; $ insertValues = [ ] ; foreach ( $ insertNames as $ name ) { $ quotedName = $ this -> db -> quoteColumnName ( $ name ) ; if ( strrpos ( $ quotedName , '.' ) === false ) { $ quotedName = '"EXCLUDED".' . $ quotedName ; } $ insertValues [ ] = $ quotedName ; } $ insertSql = 'INSERT (' . implode ( ', ' , $ insertNames ) . ')' . ' VALUES (' . implode ( ', ' , $ insertValues ) . ')' ; if ( $ updateColumns === false ) { return "$mergeSql WHEN NOT MATCHED THEN $insertSql" ; } if ( $ updateColumns === true ) { $ updateColumns = [ ] ; foreach ( $ updateNames as $ name ) { $ quotedName = $ this -> db -> quoteColumnName ( $ name ) ; if ( strrpos ( $ quotedName , '.' ) === false ) { $ quotedName = '"EXCLUDED".' . $ quotedName ; } $ updateColumns [ $ name ] = new Expression ( $ quotedName ) ; } } list ( $ updates , $ params ) = $ this -> prepareUpdateSets ( $ table , $ updateColumns , $ params ) ; $ updateSql = 'UPDATE SET ' . implode ( ', ' , $ updates ) ; return "$mergeSql WHEN MATCHED THEN $updateSql WHEN NOT MATCHED THEN $insertSql" ; } 
public function dropCommentFromColumn ( $ table , $ column ) { return 'COMMENT ON COLUMN ' . $ this -> db -> quoteTableName ( $ table ) . '.' . $ this -> db -> quoteColumnName ( $ column ) . " IS ''" ; } 
public function dbTypecast ( $ value ) { if ( $ value === null ) { return $ value ; } if ( $ value instanceof ExpressionInterface ) { return $ value ; } if ( ! $ this -> disableJsonSupport && $ this -> dbType === Schema :: TYPE_JSON ) { return new JsonExpression ( $ value , $ this -> type ) ; } return $ this -> typecast ( $ value ) ; } 
public function phpTypecast ( $ value ) { if ( $ value === null ) { return null ; } if ( ! $ this -> disableJsonSupport && $ this -> type === Schema :: TYPE_JSON ) { return json_decode ( $ value , true ) ; } return parent :: phpTypecast ( $ value ) ; } 
public function init ( ) { if ( $ this -> request === null ) { $ this -> request = Yii :: $ app -> getRequest ( ) ; } if ( $ this -> response === null ) { $ this -> response = Yii :: $ app -> getResponse ( ) ; } } 
protected function serializeDataProvider ( $ dataProvider ) { if ( $ this -> preserveKeys ) { $ models = $ dataProvider -> getModels ( ) ; } else { $ models = array_values ( $ dataProvider -> getModels ( ) ) ; } $ models = $ this -> serializeModels ( $ models ) ; if ( ( $ pagination = $ dataProvider -> getPagination ( ) ) !== false ) { $ this -> addPaginationHeaders ( $ pagination ) ; } if ( $ this -> request -> getIsHead ( ) ) { return null ; } elseif ( $ this -> collectionEnvelope === null ) { return $ models ; } $ result = [ $ this -> collectionEnvelope => $ models , ] ; if ( $ pagination !== false ) { return array_merge ( $ result , $ this -> serializePagination ( $ pagination ) ) ; } return $ result ; } 
protected function serializePagination ( $ pagination ) { return [ $ this -> linksEnvelope => Link :: serialize ( $ pagination -> getLinks ( true ) ) , $ this -> metaEnvelope => [ 'totalCount' => $ pagination -> totalCount , 'pageCount' => $ pagination -> getPageCount ( ) , 'currentPage' => $ pagination -> getPage ( ) + 1 , 'perPage' => $ pagination -> getPageSize ( ) , ] , ] ; } 
protected function addPaginationHeaders ( $ pagination ) { $ links = [ ] ; foreach ( $ pagination -> getLinks ( true ) as $ rel => $ url ) { $ links [ ] = "<$url>; rel=$rel" ; } $ this -> response -> getHeaders ( ) -> set ( $ this -> totalCountHeader , $ pagination -> totalCount ) -> set ( $ this -> pageCountHeader , $ pagination -> getPageCount ( ) ) -> set ( $ this -> currentPageHeader , $ pagination -> getPage ( ) + 1 ) -> set ( $ this -> perPageHeader , $ pagination -> pageSize ) -> set ( 'Link' , implode ( ', ' , $ links ) ) ; } 
protected function serializeModelErrors ( $ model ) { $ this -> response -> setStatusCode ( 422 , 'Data Validation Failed.' ) ; $ result = [ ] ; foreach ( $ model -> getFirstErrors ( ) as $ name => $ message ) { $ result [ ] = [ 'field' => $ name , 'message' => $ message , ] ; } return $ result ; } 
protected function serializeModels ( array $ models ) { list ( $ fields , $ expand ) = $ this -> getRequestedFields ( ) ; foreach ( $ models as $ i => $ model ) { if ( $ model instanceof Arrayable ) { $ models [ $ i ] = $ model -> toArray ( $ fields , $ expand ) ; } elseif ( is_array ( $ model ) ) { $ models [ $ i ] = ArrayHelper :: toArray ( $ model ) ; } } return $ models ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> logFile === null ) { $ this -> logFile = Yii :: $ app -> getRuntimePath ( ) . '/logs/app.log' ; } else { $ this -> logFile = Yii :: getAlias ( $ this -> logFile ) ; } if ( $ this -> maxLogFiles < 1 ) { $ this -> maxLogFiles = 1 ; } if ( $ this -> maxFileSize < 1 ) { $ this -> maxFileSize = 1 ; } } 
public function export ( ) { $ logPath = dirname ( $ this -> logFile ) ; FileHelper :: createDirectory ( $ logPath , $ this -> dirMode , true ) ; $ text = implode ( "\n" , array_map ( [ $ this , 'formatMessage' ] , $ this -> messages ) ) . "\n" ; if ( ( $ fp = @ fopen ( $ this -> logFile , 'a' ) ) === false ) { throw new InvalidConfigException ( "Unable to append to log file: {$this->logFile}" ) ; } @ flock ( $ fp , LOCK_EX ) ; if ( $ this -> enableRotation ) { 
protected function rotateFiles ( ) { $ file = $ this -> logFile ; for ( $ i = $ this -> maxLogFiles ; $ i >= 0 ; -- $ i ) { 
private function rotateByCopy ( $ rotateFile , $ newFile ) { @ copy ( $ rotateFile , $ newFile ) ; if ( $ this -> fileMode !== null ) { @ chmod ( $ newFile , $ this -> fileMode ) ; } } 
protected function findTableNames ( $ schema = '' ) { $ sql = 'SHOW TABLES' ; if ( $ schema !== '' ) { $ sql .= ' FROM ' . $ this -> quoteSimpleTableName ( $ schema ) ; } return $ this -> db -> createCommand ( $ sql ) -> queryColumn ( ) ; } 
protected function findColumns ( $ table ) { $ sql = 'SHOW FULL COLUMNS FROM ' . $ this -> quoteTableName ( $ table -> fullName ) ; try { $ columns = $ this -> db -> createCommand ( $ sql ) -> queryAll ( ) ; } catch ( \ Exception $ e ) { $ previous = $ e -> getPrevious ( ) ; if ( $ previous instanceof \ PDOException && strpos ( $ previous -> getMessage ( ) , 'SQLSTATE[42S02' ) !== false ) { 
protected function getCreateTableSql ( $ table ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> quoteTableName ( $ table -> fullName ) ) -> queryOne ( ) ; if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } return $ sql ; } 
protected function findConstraints ( $ table ) { $ sql = <<<'SQL' SELECT kcu.constraint_name, kcu.column_name, kcu.referenced_table_name, kcu.referenced_column_name FROM information_schema.referential_constraints AS rc JOIN information_schema.key_column_usage AS kcu ON ( kcu.constraint_catalog = rc.constraint_catalog OR (kcu.constraint_catalog IS NULL AND rc.constraint_catalog IS NULL) ) AND kcu.constraint_schema = rc.constraint_schema AND kcu.constraint_name = rc.constraint_name WHERE rc.constraint_schema = database() AND kcu.table_schema = database() AND rc.table_name = :tableName AND kcu.table_name = :tableName1 SQL ; try { $ rows = $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':tableName1' => $ table -> name ] ) -> queryAll ( ) ; $ constraints = [ ] ; foreach ( $ rows as $ row ) { $ constraints [ $ row [ 'constraint_name' ] ] [ 'referenced_table_name' ] = $ row [ 'referenced_table_name' ] ; $ constraints [ $ row [ 'constraint_name' ] ] [ 'columns' ] [ $ row [ 'column_name' ] ] = $ row [ 'referenced_column_name' ] ; } $ table -> foreignKeys = [ ] ; foreach ( $ constraints as $ name => $ constraint ) { $ table -> foreignKeys [ $ name ] = array_merge ( [ $ constraint [ 'referenced_table_name' ] ] , $ constraint [ 'columns' ] ) ; } } catch ( \ Exception $ e ) { $ previous = $ e -> getPrevious ( ) ; if ( ! $ previous instanceof \ PDOException || strpos ( $ previous -> getMessage ( ) , 'SQLSTATE[42S02' ) === false ) { throw $ e ; } 
public function findUniqueIndexes ( $ table ) { $ sql = $ this -> getCreateTableSql ( $ table ) ; $ uniqueIndexes = [ ] ; $ regexp = '/UNIQUE KEY\s+\`(.+)\`\s*\((\`.+\`)+\)/mi' ; if ( preg_match_all ( $ regexp , $ sql , $ matches , PREG_SET_ORDER ) ) { foreach ( $ matches as $ match ) { $ indexName = $ match [ 1 ] ; $ indexColumns = array_map ( 'trim' , explode ( '`,`' , trim ( $ match [ 2 ] , '`' ) ) ) ; $ uniqueIndexes [ $ indexName ] = $ indexColumns ; } } return $ uniqueIndexes ; } 
protected function addServers ( $ cache , $ servers ) { if ( empty ( $ servers ) ) { $ servers = [ new MemCacheServer ( [ 'host' => '127.0.0.1' , 'port' => 11211 , ] ) ] ; } else { foreach ( $ servers as $ server ) { if ( $ server -> host === null ) { throw new InvalidConfigException ( "The 'host' property must be specified for every memcache server." ) ; } } } if ( $ this -> useMemcached ) { $ this -> addMemcachedServers ( $ cache , $ servers ) ; } else { $ this -> addMemcacheServers ( $ cache , $ servers ) ; } } 
protected function addMemcachedServers ( $ cache , $ servers ) { $ existingServers = [ ] ; if ( $ this -> persistentId !== null ) { foreach ( $ cache -> getServerList ( ) as $ s ) { $ existingServers [ $ s [ 'host' ] . ':' . $ s [ 'port' ] ] = true ; } } foreach ( $ servers as $ server ) { if ( empty ( $ existingServers ) || ! isset ( $ existingServers [ $ server -> host . ':' . $ server -> port ] ) ) { $ cache -> addServer ( $ server -> host , $ server -> port , $ server -> weight ) ; } } } 
protected function getValues ( $ keys ) { return $ this -> useMemcached ? $ this -> _cache -> getMulti ( $ keys ) : $ this -> _cache -> get ( $ keys ) ; } 
protected function setValue ( $ key , $ value , $ duration ) { 
protected function setValues ( $ data , $ duration ) { if ( $ this -> useMemcached ) { 
protected function addValue ( $ key , $ value , $ duration ) { 
public static function dumpAsString ( $ var , $ depth = 10 , $ highlight = false ) { self :: $ _output = '' ; self :: $ _objects = [ ] ; self :: $ _depth = $ depth ; self :: dumpInternal ( $ var , 0 ) ; if ( $ highlight ) { $ result = highlight_string ( "<?php\n" . self :: $ _output , true ) ; self :: $ _output = preg_replace ( '/&lt;\\?php<br \\/>/' , '' , $ result , 1 ) ; } return self :: $ _output ; } 
private static function exportClosure ( \ Closure $ closure ) { $ reflection = new \ ReflectionFunction ( $ closure ) ; $ fileName = $ reflection -> getFileName ( ) ; $ start = $ reflection -> getStartLine ( ) ; $ end = $ reflection -> getEndLine ( ) ; if ( $ fileName === false || $ start === false || $ end === false ) { return 'function() {/* Error: unable to determine Closure source */}' ; } -- $ start ; $ source = implode ( "\n" , array_slice ( file ( $ fileName ) , $ start , $ end - $ start ) ) ; $ tokens = token_get_all ( '<?php ' . $ source ) ; array_shift ( $ tokens ) ; $ closureTokens = [ ] ; $ pendingParenthesisCount = 0 ; foreach ( $ tokens as $ token ) { if ( isset ( $ token [ 0 ] ) && $ token [ 0 ] === T_FUNCTION ) { $ closureTokens [ ] = $ token [ 1 ] ; continue ; } if ( $ closureTokens !== [ ] ) { $ closureTokens [ ] = isset ( $ token [ 1 ] ) ? $ token [ 1 ] : $ token ; if ( $ token === '}' ) { $ pendingParenthesisCount -- ; if ( $ pendingParenthesisCount === 0 ) { break ; } } elseif ( $ token === '{' ) { $ pendingParenthesisCount ++ ; } } } return implode ( '' , $ closureTokens ) ; } 
public function actionIndex ( ) { $ caches = $ this -> findCaches ( ) ; if ( ! empty ( $ caches ) ) { $ this -> notifyCachesCanBeFlushed ( $ caches ) ; } else { $ this -> notifyNoCachesFound ( ) ; } } 
public function actionFlush ( ) { $ cachesInput = func_get_args ( ) ; if ( empty ( $ cachesInput ) ) { throw new Exception ( 'You should specify cache components names' ) ; } $ caches = $ this -> findCaches ( $ cachesInput ) ; $ cachesInfo = [ ] ; $ foundCaches = array_keys ( $ caches ) ; $ notFoundCaches = array_diff ( $ cachesInput , array_keys ( $ caches ) ) ; if ( $ notFoundCaches ) { $ this -> notifyNotFoundCaches ( $ notFoundCaches ) ; } if ( ! $ foundCaches ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } if ( ! $ this -> confirmFlush ( $ foundCaches ) ) { return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; } 
public function actionFlushAll ( ) { $ caches = $ this -> findCaches ( ) ; $ cachesInfo = [ ] ; if ( empty ( $ caches ) ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; } 
public function actionFlushSchema ( $ db = 'db' ) { $ connection = Yii :: $ app -> get ( $ db , false ) ; if ( $ connection === null ) { $ this -> stdout ( "Unknown component \"$db\".\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } if ( ! $ connection instanceof \ yii \ db \ Connection ) { $ this -> stdout ( "\"$db\" component doesn't inherit \\yii\\db\\Connection.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } elseif ( ! $ this -> confirm ( "Flush cache schema for \"$db\" connection?" ) ) { return ExitCode :: OK ; } try { $ schema = $ connection -> getSchema ( ) ; $ schema -> refresh ( ) ; $ this -> stdout ( "Schema cache for component \"$db\", was flushed.\n\n" , Console :: FG_GREEN ) ; } catch ( \ Exception $ e ) { $ this -> stdout ( $ e -> getMessage ( ) . "\n\n" , Console :: FG_RED ) ; } } 
private function notifyCachesCanBeFlushed ( $ caches ) { $ this -> stdout ( "The following caches were found in the system:\n\n" , Console :: FG_YELLOW ) ; foreach ( $ caches as $ name => $ class ) { if ( $ this -> canBeFlushed ( $ class ) ) { $ this -> stdout ( "\t* $name ($class)\n" , Console :: FG_GREEN ) ; } else { $ this -> stdout ( "\t* $name ($class) - can not be flushed via console\n" , Console :: FG_YELLOW ) ; } } $ this -> stdout ( "\n" ) ; } 
private function notifyNotFoundCaches ( $ cachesNames ) { $ this -> stdout ( "The following cache components were NOT found:\n\n" , Console :: FG_RED ) ; foreach ( $ cachesNames as $ name ) { $ this -> stdout ( "\t* $name \n" , Console :: FG_GREEN ) ; } $ this -> stdout ( "\n" ) ; } 
public function has ( $ id , $ checkInstance = false ) { return $ checkInstance ? isset ( $ this -> _components [ $ id ] ) : isset ( $ this -> _definitions [ $ id ] ) ; } 
public function setComponents ( $ components ) { foreach ( $ components as $ id => $ component ) { $ this -> set ( $ id , $ component ) ; } } 
protected function buildInternal ( ) { $ filter = $ this -> normalize ( false ) ; if ( empty ( $ filter ) ) { return [ ] ; } return $ this -> buildCondition ( $ filter ) ; } 
protected function buildConjunctionCondition ( $ operator , $ condition ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } $ result = [ $ operator ] ; foreach ( $ condition as $ part ) { $ result [ ] = $ this -> buildCondition ( $ part ) ; } return $ result ; } 
protected function buildBlockCondition ( $ operator , $ condition ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ this -> buildCondition ( $ condition ) , ] ; } 
protected function buildAttributeCondition ( $ attribute , $ condition ) { if ( is_array ( $ condition ) ) { $ parts = [ ] ; foreach ( $ condition as $ operator => $ value ) { if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { if ( isset ( $ this -> conditionBuilders [ $ operator ] ) ) { $ method = $ this -> conditionBuilders [ $ operator ] ; if ( is_string ( $ method ) ) { $ callback = [ $ this , $ method ] ; } else { $ callback = $ method ; } $ parts [ ] = $ callback ( $ operator , $ value , $ attribute ) ; } else { $ parts [ ] = $ this -> buildOperatorCondition ( $ operator , $ value , $ attribute ) ; } } } if ( ! empty ( $ parts ) ) { if ( count ( $ parts ) > 1 ) { return array_merge ( [ 'AND' ] , $ parts ) ; } return array_shift ( $ parts ) ; } } return [ $ attribute => $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; } 
protected function buildOperatorCondition ( $ operator , $ condition , $ attribute ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ attribute , $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; } 
public function init ( ) { parent :: init ( ) ; $ this -> db = Instance :: ensure ( $ this -> db , Connection :: className ( ) ) ; if ( $ this -> sql === null ) { throw new InvalidConfigException ( 'The "sql" property must be set.' ) ; } } 
protected function prepareModels ( ) { $ sort = $ this -> getSort ( ) ; $ pagination = $ this -> getPagination ( ) ; if ( $ pagination === false && $ sort === false ) { return $ this -> db -> createCommand ( $ this -> sql , $ this -> params ) -> queryAll ( ) ; } $ sql = $ this -> sql ; $ orders = [ ] ; $ limit = $ offset = null ; if ( $ sort !== false ) { $ orders = $ sort -> getOrders ( ) ; $ pattern = '/\s+order\s+by\s+([\w\s,\.]+)$/i' ; if ( preg_match ( $ pattern , $ sql , $ matches ) ) { array_unshift ( $ orders , new Expression ( $ matches [ 1 ] ) ) ; $ sql = preg_replace ( $ pattern , '' , $ sql ) ; } } if ( $ pagination !== false ) { $ pagination -> totalCount = $ this -> getTotalCount ( ) ; $ limit = $ pagination -> getLimit ( ) ; $ offset = $ pagination -> getOffset ( ) ; } $ sql = $ this -> db -> getQueryBuilder ( ) -> buildOrderByAndLimit ( $ sql , $ orders , $ limit , $ offset ) ; return $ this -> db -> createCommand ( $ sql , $ this -> params ) -> queryAll ( ) ; } 
public function validateAttribute ( $ model , $ attribute ) { $ value = $ model -> $ attribute ; if ( ! $ this -> skipOnArray || ! is_array ( $ value ) ) { $ model -> $ attribute = call_user_func ( $ this -> filter , $ value ) ; } } 
public static function autoload ( $ className ) { if ( isset ( static :: $ classMap [ $ className ] ) ) { $ classFile = static :: $ classMap [ $ className ] ; if ( $ classFile [ 0 ] === '@' ) { $ classFile = static :: getAlias ( $ classFile ) ; } } elseif ( strpos ( $ className , '\\' ) !== false ) { $ classFile = static :: getAlias ( '@' . str_replace ( '\\' , '/' , $ className ) . '.php' , false ) ; if ( $ classFile === false || ! is_file ( $ classFile ) ) { return ; } } else { return ; } include $ classFile ; if ( YII_DEBUG && ! class_exists ( $ className , false ) && ! interface_exists ( $ className , false ) && ! trait_exists ( $ className , false ) ) { throw new UnknownClassException ( "Unable to find '$className' in file: $classFile. Namespace missing?" ) ; } } 
public static function debug ( $ message , $ category = 'application' ) { if ( YII_DEBUG ) { static :: getLogger ( ) -> log ( $ message , Logger :: LEVEL_TRACE , $ category ) ; } } 
public static function t ( $ category , $ message , $ params = [ ] , $ language = null ) { if ( static :: $ app !== null ) { return static :: $ app -> getI18n ( ) -> translate ( $ category , $ message , $ params , $ language ? : static :: $ app -> language ) ; } $ placeholders = [ ] ; foreach ( ( array ) $ params as $ name => $ value ) { $ placeholders [ '{' . $ name . '}' ] = $ value ; } return ( $ placeholders === [ ] ) ? $ message : strtr ( $ message , $ placeholders ) ; } 
public function run ( ) { if ( $ this -> showOnEmpty || $ this -> dataProvider -> getCount ( ) > 0 ) { $ content = preg_replace_callback ( '/{\\w+}/' , function ( $ matches ) { $ content = $ this -> renderSection ( $ matches [ 0 ] ) ; return $ content === false ? $ matches [ 0 ] : $ content ; } , $ this -> layout ) ; } else { $ content = $ this -> renderEmpty ( ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'div' ) ; echo Html :: tag ( $ tag , $ content , $ options ) ; } 
public function renderSummary ( ) { $ count = $ this -> dataProvider -> getCount ( ) ; if ( $ count <= 0 ) { return '' ; } $ summaryOptions = $ this -> summaryOptions ; $ tag = ArrayHelper :: remove ( $ summaryOptions , 'tag' , 'div' ) ; if ( ( $ pagination = $ this -> dataProvider -> getPagination ( ) ) !== false ) { $ totalCount = $ this -> dataProvider -> getTotalCount ( ) ; $ begin = $ pagination -> getPage ( ) * $ pagination -> pageSize + 1 ; $ end = $ begin + $ count - 1 ; if ( $ begin > $ end ) { $ begin = $ end ; } $ page = $ pagination -> getPage ( ) + 1 ; $ pageCount = $ pagination -> pageCount ; if ( ( $ summaryContent = $ this -> summary ) === null ) { return Html :: tag ( $ tag , Yii :: t ( 'yii' , 'Showing <b>{begin, number}-{end, number}</b> of <b>{totalCount, number}</b> {totalCount, plural, one{item} other{items}}.' , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] ) , $ summaryOptions ) ; } } else { $ begin = $ page = $ pageCount = 1 ; $ end = $ totalCount = $ count ; if ( ( $ summaryContent = $ this -> summary ) === null ) { return Html :: tag ( $ tag , Yii :: t ( 'yii' , 'Total <b>{count, number}</b> {count, plural, one{item} other{items}}.' , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] ) , $ summaryOptions ) ; } } return Yii :: $ app -> getI18n ( ) -> format ( $ summaryContent , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] , Yii :: $ app -> language ) ; } 
public function renderPager ( ) { $ pagination = $ this -> dataProvider -> getPagination ( ) ; if ( $ pagination === false || $ this -> dataProvider -> getCount ( ) <= 0 ) { return '' ; } $ pager = $ this -> pager ; $ class = ArrayHelper :: remove ( $ pager , 'class' , LinkPager :: className ( ) ) ; $ pager [ 'pagination' ] = $ pagination ; $ pager [ 'view' ] = $ this -> getView ( ) ; return $ class :: widget ( $ pager ) ; } 
public function renderSorter ( ) { $ sort = $ this -> dataProvider -> getSort ( ) ; if ( $ sort === false || empty ( $ sort -> attributes ) || $ this -> dataProvider -> getCount ( ) <= 0 ) { return '' ; } $ sorter = $ this -> sorter ; $ class = ArrayHelper :: remove ( $ sorter , 'class' , LinkSorter :: className ( ) ) ; $ sorter [ 'sort' ] = $ sort ; $ sorter [ 'view' ] = $ this -> getView ( ) ; return $ class :: widget ( $ sorter ) ; } 
public function dbTypecast ( $ value ) { if ( $ value === null ) { return $ value ; } if ( $ value instanceof ExpressionInterface ) { return $ value ; } if ( $ this -> dimension > 0 ) { return $ this -> disableArraySupport ? ( string ) $ value : new ArrayExpression ( $ value , $ this -> dbType , $ this -> dimension ) ; } if ( ! $ this -> disableJsonSupport && in_array ( $ this -> dbType , [ Schema :: TYPE_JSON , Schema :: TYPE_JSONB ] , true ) ) { return new JsonExpression ( $ value , $ this -> dbType ) ; } return $ this -> typecast ( $ value ) ; } 
public function phpTypecast ( $ value ) { if ( $ this -> dimension > 0 ) { if ( $ this -> disableArraySupport ) { return $ value ; } if ( ! is_array ( $ value ) ) { $ value = $ this -> getArrayParser ( ) -> parse ( $ value ) ; } if ( is_array ( $ value ) ) { array_walk_recursive ( $ value , function ( & $ val , $ key ) { $ val = $ this -> phpTypecastValue ( $ val ) ; } ) ; } elseif ( $ value === null ) { return null ; } return $ this -> deserializeArrayColumnToArrayExpression ? new ArrayExpression ( $ value , $ this -> dbType , $ this -> dimension ) : $ value ; } return $ this -> phpTypecastValue ( $ value ) ; } 
protected function phpTypecastValue ( $ value ) { if ( $ value === null ) { return null ; } switch ( $ this -> type ) { case Schema :: TYPE_BOOLEAN : switch ( strtolower ( $ value ) ) { case 't' : case 'true' : return true ; case 'f' : case 'false' : return false ; } return ( bool ) $ value ; case Schema :: TYPE_JSON : return $ this -> disableJsonSupport ? $ value : json_decode ( $ value , true ) ; } return parent :: phpTypecast ( $ value ) ; } 
public function getScriptFile ( ) { if ( $ this -> _scriptFile === null ) { if ( isset ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ) { $ this -> setScriptFile ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } } return $ this -> _scriptFile ; } 
public function setScriptFile ( $ value ) { $ scriptFile = realpath ( Yii :: getAlias ( $ value ) ) ; if ( $ scriptFile !== false && is_file ( $ scriptFile ) ) { $ this -> _scriptFile = $ scriptFile ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } } 
private function parseDateValueFormat ( $ value , $ format ) { if ( is_array ( $ value ) ) { return false ; } if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { if ( extension_loaded ( 'intl' ) ) { return $ this -> parseDateValueIntl ( $ value , $ format ) ; } 
private function formatTimestamp ( $ timestamp , $ format ) { if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } $ date = new DateTime ( ) ; $ date -> setTimestamp ( $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ this -> timestampAttributeTimeZone ) ) ; return $ date -> format ( $ format ) ; } 
public function build ( ExpressionInterface $ expression , array & $ params = [ ] ) { list ( $ sql , $ params ) = $ this -> queryBuilder -> build ( $ expression , $ params ) ; return "($sql)" ; } 
public function encryptByKey ( $ data , $ inputKey , $ info = null ) { return $ this -> encrypt ( $ data , false , $ inputKey , $ info ) ; } 
public function decryptByKey ( $ data , $ inputKey , $ info = null ) { return $ this -> decrypt ( $ data , false , $ inputKey , $ info ) ; } 
protected function encrypt ( $ data , $ passwordBased , $ secret , $ info ) { if ( ! extension_loaded ( 'openssl' ) ) { throw new InvalidConfigException ( 'Encryption requires the OpenSSL PHP extension' ) ; } if ( ! isset ( $ this -> allowedCiphers [ $ this -> cipher ] [ 0 ] , $ this -> allowedCiphers [ $ this -> cipher ] [ 1 ] ) ) { throw new InvalidConfigException ( $ this -> cipher . ' is not an allowed cipher' ) ; } list ( $ blockSize , $ keySize ) = $ this -> allowedCiphers [ $ this -> cipher ] ; $ keySalt = $ this -> generateRandomKey ( $ keySize ) ; if ( $ passwordBased ) { $ key = $ this -> pbkdf2 ( $ this -> kdfHash , $ secret , $ keySalt , $ this -> derivationIterations , $ keySize ) ; } else { $ key = $ this -> hkdf ( $ this -> kdfHash , $ secret , $ keySalt , $ info , $ keySize ) ; } $ iv = $ this -> generateRandomKey ( $ blockSize ) ; $ encrypted = openssl_encrypt ( $ data , $ this -> cipher , $ key , OPENSSL_RAW_DATA , $ iv ) ; if ( $ encrypted === false ) { throw new \ yii \ base \ Exception ( 'OpenSSL failure on encryption: ' . openssl_error_string ( ) ) ; } $ authKey = $ this -> hkdf ( $ this -> kdfHash , $ key , null , $ this -> authKeyInfo , $ keySize ) ; $ hashed = $ this -> hashData ( $ iv . $ encrypted , $ authKey ) ; return $ keySalt . $ hashed ; } 
public function hashData ( $ data , $ key , $ rawHash = false ) { $ hash = hash_hmac ( $ this -> macHash , $ data , $ key , $ rawHash ) ; if ( ! $ hash ) { throw new InvalidConfigException ( 'Failed to generate HMAC with hash algorithm: ' . $ this -> macHash ) ; } return $ hash . $ data ; } 
public function validateData ( $ data , $ key , $ rawHash = false ) { $ test = @ hash_hmac ( $ this -> macHash , '' , '' , $ rawHash ) ; if ( ! $ test ) { throw new InvalidConfigException ( 'Failed to generate HMAC with hash algorithm: ' . $ this -> macHash ) ; } $ hashLength = StringHelper :: byteLength ( $ test ) ; if ( StringHelper :: byteLength ( $ data ) >= $ hashLength ) { $ hash = StringHelper :: byteSubstr ( $ data , 0 , $ hashLength ) ; $ pureData = StringHelper :: byteSubstr ( $ data , $ hashLength , null ) ; $ calculatedHash = hash_hmac ( $ this -> macHash , $ pureData , $ key , $ rawHash ) ; if ( $ this -> compareString ( $ hash , $ calculatedHash ) ) { return $ pureData ; } } return false ; } 
public function generateRandomKey ( $ length = 32 ) { if ( ! is_int ( $ length ) ) { throw new InvalidArgumentException ( 'First parameter ($length) must be an integer' ) ; } if ( $ length < 1 ) { throw new InvalidArgumentException ( 'First parameter ($length) must be greater than 0' ) ; } 
public function generateRandomString ( $ length = 32 ) { if ( ! is_int ( $ length ) ) { throw new InvalidArgumentException ( 'First parameter ($length) must be an integer' ) ; } if ( $ length < 1 ) { throw new InvalidArgumentException ( 'First parameter ($length) must be greater than 0' ) ; } $ bytes = $ this -> generateRandomKey ( $ length ) ; return substr ( StringHelper :: base64UrlEncode ( $ bytes ) , 0 , $ length ) ; } 
public function generatePasswordHash ( $ password , $ cost = null ) { if ( $ cost === null ) { $ cost = $ this -> passwordHashCost ; } if ( function_exists ( 'password_hash' ) ) { return password_hash ( $ password , PASSWORD_DEFAULT , [ 'cost' => $ cost ] ) ; } $ salt = $ this -> generateSalt ( $ cost ) ; $ hash = crypt ( $ password , $ salt ) ; 
public function validatePassword ( $ password , $ hash ) { if ( ! is_string ( $ password ) || $ password === '' ) { throw new InvalidArgumentException ( 'Password must be a string and cannot be empty.' ) ; } if ( ! preg_match ( '/^\$2[axy]\$(\d\d)\$[\.\/0-9A-Za-z]{22}/' , $ hash , $ matches ) || $ matches [ 1 ] < 4 || $ matches [ 1 ] > 30 ) { throw new InvalidArgumentException ( 'Hash is invalid.' ) ; } if ( function_exists ( 'password_verify' ) ) { return password_verify ( $ password , $ hash ) ; } $ test = crypt ( $ password , $ hash ) ; $ n = strlen ( $ test ) ; if ( $ n !== 60 ) { return false ; } return $ this -> compareString ( $ test , $ hash ) ; } 
public function compareString ( $ expected , $ actual ) { if ( ! is_string ( $ expected ) ) { throw new InvalidArgumentException ( 'Expected expected value to be a string, ' . gettype ( $ expected ) . ' given.' ) ; } if ( ! is_string ( $ actual ) ) { throw new InvalidArgumentException ( 'Expected actual value to be a string, ' . gettype ( $ actual ) . ' given.' ) ; } if ( function_exists ( 'hash_equals' ) ) { return hash_equals ( $ expected , $ actual ) ; } $ expected .= "\0" ; $ actual .= "\0" ; $ expectedLength = StringHelper :: byteLength ( $ expected ) ; $ actualLength = StringHelper :: byteLength ( $ actual ) ; $ diff = $ expectedLength - $ actualLength ; for ( $ i = 0 ; $ i < $ actualLength ; $ i ++ ) { $ diff |= ( ord ( $ actual [ $ i ] ) ^ ord ( $ expected [ $ i % $ expectedLength ] ) ) ; } return $ diff === 0 ; } 
public function unmaskToken ( $ maskedToken ) { $ decoded = StringHelper :: base64UrlDecode ( $ maskedToken ) ; $ length = StringHelper :: byteLength ( $ decoded ) / 2 ; 
public function init ( ) { parent :: init ( ) ; if ( empty ( $ this -> attributes ) ) { $ this -> attributes = [ BaseActiveRecord :: EVENT_BEFORE_INSERT => [ $ this -> createdByAttribute , $ this -> updatedByAttribute ] , BaseActiveRecord :: EVENT_BEFORE_UPDATE => $ this -> updatedByAttribute , ] ; } } 
protected function getValue ( $ event ) { if ( $ this -> value === null && Yii :: $ app -> has ( 'user' ) ) { $ userId = Yii :: $ app -> get ( 'user' ) -> id ; if ( $ userId === null ) { return $ this -> getDefaultValue ( $ event ) ; } return $ userId ; } elseif ( $ this -> value === null ) { return $ this -> getDefaultValue ( $ event ) ; } return parent :: getValue ( $ event ) ; } 
protected function getDefaultValue ( $ event ) { if ( $ this -> defaultValue instanceof \ Closure || ( is_array ( $ this -> defaultValue ) && is_callable ( $ this -> defaultValue ) ) ) { return call_user_func ( $ this -> defaultValue , $ event ) ; } return $ this -> defaultValue ; } 
public function run ( $ id = null ) { if ( Yii :: $ app -> getRequest ( ) -> getMethod ( ) !== 'OPTIONS' ) { Yii :: $ app -> getResponse ( ) -> setStatusCode ( 405 ) ; } $ options = $ id === null ? $ this -> collectionOptions : $ this -> resourceOptions ; $ headers = Yii :: $ app -> getResponse ( ) -> getHeaders ( ) ; $ headers -> set ( 'Allow' , implode ( ', ' , $ options ) ) ; $ headers -> set ( 'Access-Control-Allow-Methods' , implode ( ', ' , $ options ) ) ; } 
public function build ( ExpressionInterface $ expression , array & $ params = [ ] ) { $ params = array_merge ( $ params , $ expression -> params ) ; return $ expression -> __toString ( ) ; } 
protected static function normalizeRoute ( $ route ) { $ route = Yii :: getAlias ( ( string ) $ route ) ; if ( strncmp ( $ route , '/' , 1 ) === 0 ) { 
public static function to ( $ url = '' , $ scheme = false ) { if ( is_array ( $ url ) ) { return static :: toRoute ( $ url , $ scheme ) ; } $ url = Yii :: getAlias ( $ url ) ; if ( $ url === '' ) { $ url = Yii :: $ app -> getRequest ( ) -> getUrl ( ) ; } if ( $ scheme === false ) { return $ url ; } if ( static :: isRelative ( $ url ) ) { 
public static function ensureScheme ( $ url , $ scheme ) { if ( static :: isRelative ( $ url ) || ! is_string ( $ scheme ) ) { return $ url ; } if ( substr ( $ url , 0 , 2 ) === '//' ) { 
public static function base ( $ scheme = false ) { $ url = static :: getUrlManager ( ) -> getBaseUrl ( ) ; if ( $ scheme !== false ) { $ url = static :: getUrlManager ( ) -> getHostInfo ( ) . $ url ; $ url = static :: ensureScheme ( $ url , $ scheme ) ; } return $ url ; } 
public static function remember ( $ url = '' , $ name = null ) { $ url = static :: to ( $ url ) ; if ( $ name === null ) { Yii :: $ app -> getUser ( ) -> setReturnUrl ( $ url ) ; } else { Yii :: $ app -> getSession ( ) -> set ( $ name , $ url ) ; } } 
public static function current ( array $ params = [ ] , $ scheme = false ) { $ currentParams = Yii :: $ app -> getRequest ( ) -> getQueryParams ( ) ; $ currentParams [ 0 ] = '/' . Yii :: $ app -> controller -> getRoute ( ) ; $ route = array_replace_recursive ( $ currentParams , $ params ) ; return static :: toRoute ( $ route , $ scheme ) ; } 
public function getAssetManager ( ) { if ( ! is_object ( $ this -> _assetManager ) ) { $ options = $ this -> _assetManager ; if ( ! isset ( $ options [ 'class' ] ) ) { $ options [ 'class' ] = 'yii\\web\\AssetManager' ; } if ( ! isset ( $ options [ 'basePath' ] ) ) { throw new Exception ( "Please specify 'basePath' for the 'assetManager' option." ) ; } if ( ! isset ( $ options [ 'baseUrl' ] ) ) { throw new Exception ( "Please specify 'baseUrl' for the 'assetManager' option." ) ; } if ( ! isset ( $ options [ 'forceCopy' ] ) ) { $ options [ 'forceCopy' ] = true ; } $ this -> _assetManager = Yii :: createObject ( $ options ) ; } return $ this -> _assetManager ; } 
public function setAssetManager ( $ assetManager ) { if ( is_scalar ( $ assetManager ) ) { throw new Exception ( '"' . get_class ( $ this ) . '::assetManager" should be either object or array - "' . gettype ( $ assetManager ) . '" given.' ) ; } $ this -> _assetManager = $ assetManager ; } 
public function actionCompress ( $ configFile , $ bundleFile ) { $ this -> loadConfiguration ( $ configFile ) ; $ bundles = $ this -> loadBundles ( $ this -> bundles ) ; $ targets = $ this -> loadTargets ( $ this -> targets , $ bundles ) ; foreach ( $ targets as $ name => $ target ) { $ this -> stdout ( "Creating output bundle '{$name}':\n" ) ; if ( ! empty ( $ target -> js ) ) { $ this -> buildTarget ( $ target , 'js' , $ bundles ) ; } if ( ! empty ( $ target -> css ) ) { $ this -> buildTarget ( $ target , 'css' , $ bundles ) ; } $ this -> stdout ( "\n" ) ; } $ targets = $ this -> adjustDependency ( $ targets , $ bundles ) ; $ this -> saveTargets ( $ targets , $ bundleFile ) ; if ( $ this -> deleteSource ) { $ this -> deletePublishedAssets ( $ bundles ) ; } } 
protected function loadConfiguration ( $ configFile ) { $ this -> stdout ( "Loading configuration from '{$configFile}'...\n" ) ; $ config = require $ configFile ; foreach ( $ config as $ name => $ value ) { if ( property_exists ( $ this , $ name ) || $ this -> canSetProperty ( $ name ) ) { $ this -> $ name = $ value ; } else { throw new Exception ( "Unknown configuration option: $name" ) ; } } $ this -> getAssetManager ( ) ; 
protected function loadBundles ( $ bundles ) { $ this -> stdout ( "Collecting source bundles information...\n" ) ; $ am = $ this -> getAssetManager ( ) ; $ result = [ ] ; foreach ( $ bundles as $ name ) { $ result [ $ name ] = $ am -> getBundle ( $ name ) ; } foreach ( $ result as $ bundle ) { $ this -> loadDependency ( $ bundle , $ result ) ; } return $ result ; } 
protected function loadDependency ( $ bundle , & $ result ) { $ am = $ this -> getAssetManager ( ) ; foreach ( $ bundle -> depends as $ name ) { if ( ! isset ( $ result [ $ name ] ) ) { $ dependencyBundle = $ am -> getBundle ( $ name ) ; $ result [ $ name ] = false ; $ this -> loadDependency ( $ dependencyBundle , $ result ) ; $ result [ $ name ] = $ dependencyBundle ; } elseif ( $ result [ $ name ] === false ) { throw new Exception ( "A circular dependency is detected for bundle '{$name}': " . $ this -> composeCircularDependencyTrace ( $ name , $ result ) . '.' ) ; } } } 
protected function buildTarget ( $ target , $ type , $ bundles ) { $ inputFiles = [ ] ; foreach ( $ target -> depends as $ name ) { if ( isset ( $ bundles [ $ name ] ) ) { if ( ! $ this -> isBundleExternal ( $ bundles [ $ name ] ) ) { foreach ( $ bundles [ $ name ] -> $ type as $ file ) { if ( is_array ( $ file ) ) { $ inputFiles [ ] = $ bundles [ $ name ] -> basePath . '/' . $ file [ 0 ] ; } else { $ inputFiles [ ] = $ bundles [ $ name ] -> basePath . '/' . $ file ; } } } } else { throw new Exception ( "Unknown bundle: '{$name}'" ) ; } } if ( empty ( $ inputFiles ) ) { $ target -> $ type = [ ] ; } else { FileHelper :: createDirectory ( $ target -> basePath , $ this -> getAssetManager ( ) -> dirMode ) ; $ tempFile = $ target -> basePath . '/' . strtr ( $ target -> $ type , [ '{hash}' => 'temp' ] ) ; if ( $ type === 'js' ) { $ this -> compressJsFiles ( $ inputFiles , $ tempFile ) ; } else { $ this -> compressCssFiles ( $ inputFiles , $ tempFile ) ; } $ targetFile = strtr ( $ target -> $ type , [ '{hash}' => md5_file ( $ tempFile ) ] ) ; $ outputFile = $ target -> basePath . '/' . $ targetFile ; rename ( $ tempFile , $ outputFile ) ; $ target -> $ type = [ $ targetFile ] ; } } 
protected function adjustDependency ( $ targets , $ bundles ) { $ this -> stdout ( "Creating new bundle configuration...\n" ) ; $ map = [ ] ; foreach ( $ targets as $ name => $ target ) { foreach ( $ target -> depends as $ bundle ) { $ map [ $ bundle ] = $ name ; } } foreach ( $ targets as $ name => $ target ) { $ depends = [ ] ; foreach ( $ target -> depends as $ bn ) { foreach ( $ bundles [ $ bn ] -> depends as $ bundle ) { $ depends [ $ map [ $ bundle ] ] = true ; } } unset ( $ depends [ $ name ] ) ; $ target -> depends = array_keys ( $ depends ) ; } 
protected function registerBundle ( $ bundles , $ name , & $ registered ) { if ( ! isset ( $ registered [ $ name ] ) ) { $ registered [ $ name ] = false ; $ bundle = $ bundles [ $ name ] ; foreach ( $ bundle -> depends as $ depend ) { $ this -> registerBundle ( $ bundles , $ depend , $ registered ) ; } unset ( $ registered [ $ name ] ) ; $ registered [ $ name ] = $ bundle ; } elseif ( $ registered [ $ name ] === false ) { throw new Exception ( "A circular dependency is detected for target '{$name}': " . $ this -> composeCircularDependencyTrace ( $ name , $ registered ) . '.' ) ; } } 
protected function compressJsFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing JavaScript files...\n" ) ; if ( is_string ( $ this -> jsCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineJsFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> jsCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> jsCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress JavaScript files into '{$outputFile}'." ) ; } $ this -> stdout ( " JavaScript files compressed into '{$outputFile}'.\n" ) ; } 
protected function compressCssFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing CSS files...\n" ) ; if ( is_string ( $ this -> cssCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineCssFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> cssCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> cssCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress CSS files into '{$outputFile}'." ) ; } $ this -> stdout ( " CSS files compressed into '{$outputFile}'.\n" ) ; } 
public function combineJsFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; foreach ( $ inputFiles as $ file ) { 
public function combineCssFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; $ outputFilePath = dirname ( $ this -> findRealPath ( $ outputFile ) ) ; foreach ( $ inputFiles as $ file ) { $ content .= "/*** BEGIN FILE: $file ***/\n" . $ this -> adjustCssUrl ( file_get_contents ( $ file ) , dirname ( $ this -> findRealPath ( $ file ) ) , $ outputFilePath ) . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output CSS file '{$outputFile}'." ) ; } } 
protected function adjustCssUrl ( $ cssContent , $ inputFilePath , $ outputFilePath ) { $ inputFilePath = str_replace ( '\\' , '/' , $ inputFilePath ) ; $ outputFilePath = str_replace ( '\\' , '/' , $ outputFilePath ) ; $ sharedPathParts = [ ] ; $ inputFilePathParts = explode ( '/' , $ inputFilePath ) ; $ inputFilePathPartsCount = count ( $ inputFilePathParts ) ; $ outputFilePathParts = explode ( '/' , $ outputFilePath ) ; $ outputFilePathPartsCount = count ( $ outputFilePathParts ) ; for ( $ i = 0 ; $ i < $ inputFilePathPartsCount && $ i < $ outputFilePathPartsCount ; $ i ++ ) { if ( $ inputFilePathParts [ $ i ] == $ outputFilePathParts [ $ i ] ) { $ sharedPathParts [ ] = $ inputFilePathParts [ $ i ] ; } else { break ; } } $ sharedPath = implode ( '/' , $ sharedPathParts ) ; $ inputFileRelativePath = trim ( str_replace ( $ sharedPath , '' , $ inputFilePath ) , '/' ) ; $ outputFileRelativePath = trim ( str_replace ( $ sharedPath , '' , $ outputFilePath ) , '/' ) ; if ( empty ( $ inputFileRelativePath ) ) { $ inputFileRelativePathParts = [ ] ; } else { $ inputFileRelativePathParts = explode ( '/' , $ inputFileRelativePath ) ; } if ( empty ( $ outputFileRelativePath ) ) { $ outputFileRelativePathParts = [ ] ; } else { $ outputFileRelativePathParts = explode ( '/' , $ outputFileRelativePath ) ; } $ callback = function ( $ matches ) use ( $ inputFileRelativePathParts , $ outputFileRelativePathParts ) { $ fullMatch = $ matches [ 0 ] ; $ inputUrl = $ matches [ 1 ] ; if ( strncmp ( $ inputUrl , '/' , 1 ) === 0 || strncmp ( $ inputUrl , '#' , 1 ) === 0 || preg_match ( '/^https?:\/\//i' , $ inputUrl ) || preg_match ( '/^data:/i' , $ inputUrl ) ) { return $ fullMatch ; } if ( $ inputFileRelativePathParts === $ outputFileRelativePathParts ) { return $ fullMatch ; } if ( empty ( $ outputFileRelativePathParts ) ) { $ outputUrlParts = [ ] ; } else { $ outputUrlParts = array_fill ( 0 , count ( $ outputFileRelativePathParts ) , '..' ) ; } $ outputUrlParts = array_merge ( $ outputUrlParts , $ inputFileRelativePathParts ) ; if ( strpos ( $ inputUrl , '/' ) !== false ) { $ inputUrlParts = explode ( '/' , $ inputUrl ) ; foreach ( $ inputUrlParts as $ key => $ inputUrlPart ) { if ( $ inputUrlPart === '..' ) { array_pop ( $ outputUrlParts ) ; unset ( $ inputUrlParts [ $ key ] ) ; } } $ outputUrlParts [ ] = implode ( '/' , $ inputUrlParts ) ; } else { $ outputUrlParts [ ] = $ inputUrl ; } $ outputUrl = implode ( '/' , $ outputUrlParts ) ; return str_replace ( $ inputUrl , $ outputUrl , $ fullMatch ) ; } ; $ cssContent = preg_replace_callback ( '/url\(["\']?([^)^"^\']*)["\']?\)/i' , $ callback , $ cssContent ) ; return $ cssContent ; } 
private function findRealPath ( $ path ) { $ path = str_replace ( [ '/' , '\\' ] , DIRECTORY_SEPARATOR , $ path ) ; $ pathParts = explode ( DIRECTORY_SEPARATOR , $ path ) ; $ realPathParts = [ ] ; foreach ( $ pathParts as $ pathPart ) { if ( $ pathPart === '..' ) { array_pop ( $ realPathParts ) ; } else { $ realPathParts [ ] = $ pathPart ; } } return implode ( DIRECTORY_SEPARATOR , $ realPathParts ) ; } 
private function composeCircularDependencyTrace ( $ circularDependencyName , array $ registered ) { $ dependencyTrace = [ ] ; $ startFound = false ; foreach ( $ registered as $ name => $ value ) { if ( $ name === $ circularDependencyName ) { $ startFound = true ; } if ( $ startFound && $ value === false ) { $ dependencyTrace [ ] = $ name ; } } $ dependencyTrace [ ] = $ circularDependencyName ; return implode ( ' -> ' , $ dependencyTrace ) ; } 
private function deletePublishedAssets ( $ bundles ) { $ this -> stdout ( "Deleting source files...\n" ) ; if ( $ this -> getAssetManager ( ) -> linkAssets ) { $ this -> stdout ( "`AssetManager::linkAssets` option is enabled. Deleting of source files canceled.\n" , Console :: FG_YELLOW ) ; return ; } foreach ( $ bundles as $ bundle ) { if ( $ bundle -> sourcePath !== null ) { foreach ( $ bundle -> js as $ jsFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ jsFile ) ; } foreach ( $ bundle -> css as $ cssFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ cssFile ) ; } } } $ this -> stdout ( "Source files deleted.\n" , Console :: FG_GREEN ) ; } 
public function actionCheckGuide ( $ directory = null ) { if ( $ directory === null ) { $ directory = \ dirname ( \ dirname ( __DIR__ ) ) . '/docs' ; } if ( is_file ( $ directory ) ) { $ files = [ $ directory ] ; } else { $ files = FileHelper :: findFiles ( $ directory , [ 'only' => [ '*.md' ] , ] ) ; } foreach ( $ files as $ file ) { $ content = file_get_contents ( $ file ) ; $ chars = preg_split ( '//u' , $ content , null , PREG_SPLIT_NO_EMPTY ) ; $ line = 1 ; $ pos = 0 ; foreach ( $ chars as $ c ) { $ ord = $ this -> unicodeOrd ( $ c ) ; $ pos ++ ; if ( $ ord == 0x000A ) { $ line ++ ; $ pos = 0 ; } if ( $ ord === false ) { $ this -> found ( 'BROKEN UTF8' , $ c , $ line , $ pos , $ file ) ; continue ; } 
private function unicodeOrd ( $ c ) { $ h = \ ord ( $ c [ 0 ] ) ; if ( $ h <= 0x7F ) { return $ h ; } elseif ( $ h < 0xC2 ) { return false ; } elseif ( $ h <= 0xDF ) { return ( $ h & 0x1F ) << 6 | ( \ ord ( $ c [ 1 ] ) & 0x3F ) ; } elseif ( $ h <= 0xEF ) { return ( $ h & 0x0F ) << 12 | ( \ ord ( $ c [ 1 ] ) & 0x3F ) << 6 | ( \ ord ( $ c [ 2 ] ) & 0x3F ) ; } elseif ( $ h <= 0xF4 ) { return ( $ h & 0x0F ) << 18 | ( \ ord ( $ c [ 1 ] ) & 0x3F ) << 12 | ( \ ord ( $ c [ 2 ] ) & 0x3F ) << 6 | ( \ ord ( $ c [ 3 ] ) & 0x3F ) ; } return false ; } 
public function populate ( $ rows ) { if ( empty ( $ rows ) ) { return [ ] ; } $ models = $ this -> createModels ( $ rows ) ; if ( ! empty ( $ this -> join ) && $ this -> indexBy === null ) { $ models = $ this -> removeDuplicatedModels ( $ models ) ; } if ( ! empty ( $ this -> with ) ) { $ this -> findWith ( $ this -> with , $ models ) ; } if ( $ this -> inverseOf !== null ) { $ this -> addInverseRelations ( $ models ) ; } if ( ! $ this -> asArray ) { foreach ( $ models as $ model ) { $ model -> afterFind ( ) ; } } return parent :: populate ( $ models ) ; } 
public function one ( $ db = null ) { $ row = parent :: one ( $ db ) ; if ( $ row !== false ) { $ models = $ this -> populate ( [ $ row ] ) ; return reset ( $ models ) ? : null ; } return null ; } 
protected function queryScalar ( $ selectExpression , $ db ) { $ modelClass = $ this -> modelClass ; if ( $ db === null ) { $ db = $ modelClass :: getDb ( ) ; } if ( $ this -> sql === null ) { return parent :: queryScalar ( $ selectExpression , $ db ) ; } $ command = ( new Query ( ) ) -> select ( [ $ selectExpression ] ) -> from ( [ 'c' => "({$this->sql})" ] ) -> params ( $ this -> params ) -> createCommand ( $ db ) ; $ this -> setCommandCache ( $ command ) ; return $ command -> queryScalar ( ) ; } 
public function joinWith ( $ with , $ eagerLoading = true , $ joinType = 'LEFT JOIN' ) { $ relations = [ ] ; foreach ( ( array ) $ with as $ name => $ callback ) { if ( is_int ( $ name ) ) { $ name = $ callback ; $ callback = null ; } if ( preg_match ( '/^(.*?)(?:\s+AS\s+|\s+)(\w+)$/i' , $ name , $ matches ) ) { 
protected function getTableNameAndAlias ( ) { if ( empty ( $ this -> from ) ) { $ tableName = $ this -> getPrimaryTableName ( ) ; } else { $ tableName = '' ; 
private function joinWithRelation ( $ parent , $ child , $ joinType ) { $ via = $ child -> via ; $ child -> via = null ; if ( $ via instanceof self ) { 
public function onCondition ( $ condition , $ params = [ ] ) { $ this -> on = $ condition ; $ this -> addParams ( $ params ) ; return $ this ; } 
public function andOnCondition ( $ condition , $ params = [ ] ) { if ( $ this -> on === null ) { $ this -> on = $ condition ; } else { $ this -> on = [ 'and' , $ this -> on , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; } 
public function orOnCondition ( $ condition , $ params = [ ] ) { if ( $ this -> on === null ) { $ this -> on = $ condition ; } else { $ this -> on = [ 'or' , $ this -> on , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; } 
public function alias ( $ alias ) { if ( empty ( $ this -> from ) || count ( $ this -> from ) < 2 ) { list ( $ tableName ) = $ this -> getTableNameAndAlias ( ) ; $ this -> from = [ $ alias => $ tableName ] ; } else { $ tableName = $ this -> getPrimaryTableName ( ) ; foreach ( $ this -> from as $ key => $ table ) { if ( $ table === $ tableName ) { unset ( $ this -> from [ $ key ] ) ; $ this -> from [ $ alias ] = $ tableName ; } } } return $ this ; } 
public function getTablesUsedInFrom ( ) { if ( empty ( $ this -> from ) ) { return $ this -> cleanUpTableNames ( [ $ this -> getPrimaryTableName ( ) ] ) ; } return parent :: getTablesUsedInFrom ( ) ; } 
public function actions ( ) { return [ 'index' => [ 'class' => 'yii\rest\IndexAction' , 'modelClass' => $ this -> modelClass , 'checkAccess' => [ $ this , 'checkAccess' ] , ] , 'view' => [ 'class' => 'yii\rest\ViewAction' , 'modelClass' => $ this -> modelClass , 'checkAccess' => [ $ this , 'checkAccess' ] , ] , 'create' => [ 'class' => 'yii\rest\CreateAction' , 'modelClass' => $ this -> modelClass , 'checkAccess' => [ $ this , 'checkAccess' ] , 'scenario' => $ this -> createScenario , ] , 'update' => [ 'class' => 'yii\rest\UpdateAction' , 'modelClass' => $ this -> modelClass , 'checkAccess' => [ $ this , 'checkAccess' ] , 'scenario' => $ this -> updateScenario , ] , 'delete' => [ 'class' => 'yii\rest\DeleteAction' , 'modelClass' => $ this -> modelClass , 'checkAccess' => [ $ this , 'checkAccess' ] , ] , 'options' => [ 'class' => 'yii\rest\OptionsAction' , ] , ] ; } 
public function tokenize ( ) { $ this -> length = mb_strlen ( $ this -> sql , 'UTF-8' ) ; $ this -> offset = 0 ; $ this -> _substrings = [ ] ; $ this -> _buffer = '' ; $ this -> _token = new SqlToken ( [ 'type' => SqlToken :: TYPE_CODE , 'content' => $ this -> sql , ] ) ; $ this -> _tokenStack = new \ SplStack ( ) ; $ this -> _tokenStack -> push ( $ this -> _token ) ; $ this -> _token [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_STATEMENT ] ) ; $ this -> _tokenStack -> push ( $ this -> _token [ 0 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; while ( ! $ this -> isEof ( ) ) { if ( $ this -> isWhitespace ( $ length ) || $ this -> isComment ( $ length ) ) { $ this -> addTokenFromBuffer ( ) ; $ this -> advance ( $ length ) ; continue ; } if ( $ this -> tokenizeOperator ( $ length ) || $ this -> tokenizeDelimitedString ( $ length ) ) { $ this -> advance ( $ length ) ; continue ; } $ this -> _buffer .= $ this -> substring ( 1 ) ; $ this -> advance ( 1 ) ; } $ this -> addTokenFromBuffer ( ) ; if ( $ this -> _token -> getHasChildren ( ) && ! $ this -> _token [ - 1 ] -> getHasChildren ( ) ) { unset ( $ this -> _token [ - 1 ] ) ; } return $ this -> _token ; } 
protected function startsWithAnyLongest ( array & $ with , $ caseSensitive , & $ length = null , & $ content = null ) { if ( empty ( $ with ) ) { return false ; } if ( ! is_array ( reset ( $ with ) ) ) { usort ( $ with , function ( $ string1 , $ string2 ) { return mb_strlen ( $ string2 , 'UTF-8' ) - mb_strlen ( $ string1 , 'UTF-8' ) ; } ) ; $ map = [ ] ; foreach ( $ with as $ string ) { $ map [ mb_strlen ( $ string , 'UTF-8' ) ] [ $ caseSensitive ? $ string : mb_strtoupper ( $ string , 'UTF-8' ) ] = true ; } $ with = $ map ; } foreach ( $ with as $ testLength => $ testValues ) { $ content = $ this -> substring ( $ testLength , $ caseSensitive ) ; if ( isset ( $ testValues [ $ content ] ) ) { $ length = $ testLength ; return true ; } } return false ; } 
protected function substring ( $ length , $ caseSensitive = true , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + $ length > $ this -> length ) { return '' ; } $ cacheKey = $ offset . ',' . $ length ; if ( ! isset ( $ this -> _substrings [ $ cacheKey . ',1' ] ) ) { $ this -> _substrings [ $ cacheKey . ',1' ] = mb_substr ( $ this -> sql , $ offset , $ length , 'UTF-8' ) ; } if ( ! $ caseSensitive && ! isset ( $ this -> _substrings [ $ cacheKey . ',0' ] ) ) { $ this -> _substrings [ $ cacheKey . ',0' ] = mb_strtoupper ( $ this -> _substrings [ $ cacheKey . ',1' ] , 'UTF-8' ) ; } return $ this -> _substrings [ $ cacheKey . ',' . ( int ) $ caseSensitive ] ; } 
protected function indexAfter ( $ string , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + mb_strlen ( $ string , 'UTF-8' ) > $ this -> length ) { return $ this -> length ; } $ afterIndexOf = mb_strpos ( $ this -> sql , $ string , $ offset , 'UTF-8' ) ; if ( $ afterIndexOf === false ) { $ afterIndexOf = $ this -> length ; } else { $ afterIndexOf += mb_strlen ( $ string , 'UTF-8' ) ; } return $ afterIndexOf ; } 
private function tokenizeDelimitedString ( & $ length ) { $ isIdentifier = $ this -> isIdentifier ( $ length , $ content ) ; $ isStringLiteral = ! $ isIdentifier && $ this -> isStringLiteral ( $ length , $ content ) ; if ( ! $ isIdentifier && ! $ isStringLiteral ) { return false ; } $ this -> addTokenFromBuffer ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => $ isIdentifier ? SqlToken :: TYPE_IDENTIFIER : SqlToken :: TYPE_STRING_LITERAL , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; return true ; } 
private function tokenizeOperator ( & $ length ) { if ( ! $ this -> isOperator ( $ length , $ content ) ) { return false ; } $ this -> addTokenFromBuffer ( ) ; switch ( $ this -> substring ( $ length ) ) { case '(' : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_PARENTHESIS ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; case ')' : $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => ')' , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; case ';' : if ( ! $ this -> _currentToken -> getHasChildren ( ) ) { break ; } $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_STATEMENT ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; default : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; } return true ; } 
private function addTokenFromBuffer ( ) { if ( $ this -> _buffer === '' ) { return ; } $ isKeyword = $ this -> isKeyword ( $ this -> _buffer , $ content ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => $ isKeyword ? SqlToken :: TYPE_KEYWORD : SqlToken :: TYPE_TOKEN , 'content' => is_string ( $ content ) ? $ content : $ this -> _buffer , 'startOffset' => $ this -> offset - mb_strlen ( $ this -> _buffer , 'UTF-8' ) , 'endOffset' => $ this -> offset , ] ) ; $ this -> _buffer = '' ; } 
public function convert ( $ asset , $ basePath ) { $ pos = strrpos ( $ asset , '.' ) ; if ( $ pos !== false ) { $ ext = substr ( $ asset , $ pos + 1 ) ; if ( isset ( $ this -> commands [ $ ext ] ) ) { list ( $ ext , $ command ) = $ this -> commands [ $ ext ] ; $ result = substr ( $ asset , 0 , $ pos + 1 ) . $ ext ; if ( $ this -> forceConvert || @ filemtime ( "$basePath/$result" ) < @ filemtime ( "$basePath/$asset" ) ) { $ this -> runCommand ( $ command , $ basePath , $ asset , $ result ) ; } return $ result ; } } return $ asset ; } 
public function get ( $ class , $ params = [ ] , $ config = [ ] ) { if ( isset ( $ this -> _singletons [ $ class ] ) ) { 
public function set ( $ class , $ definition = [ ] , array $ params = [ ] ) { $ this -> _definitions [ $ class ] = $ this -> normalizeDefinition ( $ class , $ definition ) ; $ this -> _params [ $ class ] = $ params ; unset ( $ this -> _singletons [ $ class ] ) ; return $ this ; } 
public function setSingleton ( $ class , $ definition = [ ] , array $ params = [ ] ) { $ this -> _definitions [ $ class ] = $ this -> normalizeDefinition ( $ class , $ definition ) ; $ this -> _params [ $ class ] = $ params ; $ this -> _singletons [ $ class ] = null ; return $ this ; } 
protected function build ( $ class , $ params , $ config ) { list ( $ reflection , $ dependencies ) = $ this -> getDependencies ( $ class ) ; foreach ( $ params as $ index => $ param ) { $ dependencies [ $ index ] = $ param ; } $ dependencies = $ this -> resolveDependencies ( $ dependencies , $ reflection ) ; if ( ! $ reflection -> isInstantiable ( ) ) { throw new NotInstantiableException ( $ reflection -> name ) ; } if ( empty ( $ config ) ) { return $ reflection -> newInstanceArgs ( $ dependencies ) ; } $ config = $ this -> resolveDependencies ( $ config ) ; if ( ! empty ( $ dependencies ) && $ reflection -> implementsInterface ( 'yii\base\Configurable' ) ) { 
protected function mergeParams ( $ class , $ params ) { if ( empty ( $ this -> _params [ $ class ] ) ) { return $ params ; } elseif ( empty ( $ params ) ) { return $ this -> _params [ $ class ] ; } $ ps = $ this -> _params [ $ class ] ; foreach ( $ params as $ index => $ value ) { $ ps [ $ index ] = $ value ; } return $ ps ; } 
protected function getDependencies ( $ class ) { if ( isset ( $ this -> _reflections [ $ class ] ) ) { return [ $ this -> _reflections [ $ class ] , $ this -> _dependencies [ $ class ] ] ; } $ dependencies = [ ] ; try { $ reflection = new ReflectionClass ( $ class ) ; } catch ( \ ReflectionException $ e ) { throw new InvalidConfigException ( 'Failed to instantiate component or class "' . $ class . '".' , 0 , $ e ) ; } $ constructor = $ reflection -> getConstructor ( ) ; if ( $ constructor !== null ) { foreach ( $ constructor -> getParameters ( ) as $ param ) { if ( version_compare ( PHP_VERSION , '5.6.0' , '>=' ) && $ param -> isVariadic ( ) ) { break ; } elseif ( $ param -> isDefaultValueAvailable ( ) ) { $ dependencies [ ] = $ param -> getDefaultValue ( ) ; } else { $ c = $ param -> getClass ( ) ; $ dependencies [ ] = Instance :: of ( $ c === null ? null : $ c -> getName ( ) ) ; } } } $ this -> _reflections [ $ class ] = $ reflection ; $ this -> _dependencies [ $ class ] = $ dependencies ; return [ $ reflection , $ dependencies ] ; } 
protected function resolveDependencies ( $ dependencies , $ reflection = null ) { foreach ( $ dependencies as $ index => $ dependency ) { if ( $ dependency instanceof Instance ) { if ( $ dependency -> id !== null ) { $ dependencies [ $ index ] = $ this -> get ( $ dependency -> id ) ; } elseif ( $ reflection !== null ) { $ name = $ reflection -> getConstructor ( ) -> getParameters ( ) [ $ index ] -> getName ( ) ; $ class = $ reflection -> getName ( ) ; throw new InvalidConfigException ( "Missing required parameter \"$name\" when instantiating \"$class\"." ) ; } } } return $ dependencies ; } 
public function resolveCallableDependencies ( callable $ callback , $ params = [ ] ) { if ( is_array ( $ callback ) ) { $ reflection = new \ ReflectionMethod ( $ callback [ 0 ] , $ callback [ 1 ] ) ; } elseif ( is_object ( $ callback ) && ! $ callback instanceof \ Closure ) { $ reflection = new \ ReflectionMethod ( $ callback , '__invoke' ) ; } else { $ reflection = new \ ReflectionFunction ( $ callback ) ; } $ args = [ ] ; $ associative = ArrayHelper :: isAssociative ( $ params ) ; foreach ( $ reflection -> getParameters ( ) as $ param ) { $ name = $ param -> getName ( ) ; if ( ( $ class = $ param -> getClass ( ) ) !== null ) { $ className = $ class -> getName ( ) ; if ( version_compare ( PHP_VERSION , '5.6.0' , '>=' ) && $ param -> isVariadic ( ) ) { $ args = array_merge ( $ args , array_values ( $ params ) ) ; break ; } elseif ( $ associative && isset ( $ params [ $ name ] ) && $ params [ $ name ] instanceof $ className ) { $ args [ ] = $ params [ $ name ] ; unset ( $ params [ $ name ] ) ; } elseif ( ! $ associative && isset ( $ params [ 0 ] ) && $ params [ 0 ] instanceof $ className ) { $ args [ ] = array_shift ( $ params ) ; } elseif ( isset ( Yii :: $ app ) && Yii :: $ app -> has ( $ name ) && ( $ obj = Yii :: $ app -> get ( $ name ) ) instanceof $ className ) { $ args [ ] = $ obj ; } else { 
public function setDefinitions ( array $ definitions ) { foreach ( $ definitions as $ class => $ definition ) { if ( is_array ( $ definition ) && count ( $ definition ) === 2 && array_values ( $ definition ) === $ definition ) { $ this -> set ( $ class , $ definition [ 0 ] , $ definition [ 1 ] ) ; continue ; } $ this -> set ( $ class , $ definition ) ; } } 
public function setSingletons ( array $ singletons ) { foreach ( $ singletons as $ class => $ definition ) { if ( is_array ( $ definition ) && count ( $ definition ) === 2 && array_values ( $ definition ) === $ definition ) { $ this -> setSingleton ( $ class , $ definition [ 0 ] , $ definition [ 1 ] ) ; continue ; } $ this -> setSingleton ( $ class , $ definition ) ; } } 
private function parseArray ( $ value , & $ i = 0 ) { $ result = [ ] ; $ len = strlen ( $ value ) ; for ( ++ $ i ; $ i < $ len ; ++ $ i ) { switch ( $ value [ $ i ] ) { case '{' : $ result [ ] = $ this -> parseArray ( $ value , $ i ) ; break ; case '}' : break 2 ; case $ this -> delimiter : if ( empty ( $ result ) ) { 
private function parseString ( $ value , & $ i ) { $ isQuoted = $ value [ $ i ] === '"' ; $ stringEndChars = $ isQuoted ? [ '"' ] : [ $ this -> delimiter , '}' ] ; $ result = '' ; $ len = strlen ( $ value ) ; for ( $ i += $ isQuoted ? 1 : 0 ; $ i < $ len ; ++ $ i ) { if ( in_array ( $ value [ $ i ] , [ '\\' , '"' ] , true ) && in_array ( $ value [ $ i + 1 ] , [ $ value [ $ i ] , '"' ] , true ) ) { ++ $ i ; } elseif ( in_array ( $ value [ $ i ] , $ stringEndChars , true ) ) { break ; } $ result .= $ value [ $ i ] ; } $ i -= $ isQuoted ? 0 : 1 ; if ( ! $ isQuoted && $ result === 'NULL' ) { $ result = null ; } return $ result ; } 
protected function buildSubqueryInCondition ( $ operator , $ columns , $ values , & $ params ) { if ( is_array ( $ columns ) ) { throw new NotSupportedException ( __METHOD__ . ' is not supported by SQLite.' ) ; } return parent :: buildSubqueryInCondition ( $ operator , $ columns , $ values , $ params ) ; } 
protected function buildCompositeInCondition ( $ operator , $ columns , $ values , & $ params ) { $ quotedColumns = [ ] ; foreach ( $ columns as $ i => $ column ) { $ quotedColumns [ $ i ] = strpos ( $ column , '(' ) === false ? $ this -> queryBuilder -> db -> quoteColumnName ( $ column ) : $ column ; } $ vss = [ ] ; foreach ( $ values as $ value ) { $ vs = [ ] ; foreach ( $ columns as $ i => $ column ) { if ( isset ( $ value [ $ column ] ) ) { $ phName = $ this -> queryBuilder -> bindParam ( $ value [ $ column ] , $ params ) ; $ vs [ ] = $ quotedColumns [ $ i ] . ( $ operator === 'IN' ? ' = ' : ' != ' ) . $ phName ; } else { $ vs [ ] = $ quotedColumns [ $ i ] . ( $ operator === 'IN' ? ' IS' : ' IS NOT' ) . ' NULL' ; } } $ vss [ ] = '(' . implode ( $ operator === 'IN' ? ' AND ' : ' OR ' , $ vs ) . ')' ; } return '(' . implode ( $ operator === 'IN' ? ' OR ' : ' AND ' , $ vss ) . ')' ; } 
public function canGetProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { return parent :: canGetProperty ( $ name , $ checkVars , $ checkBehaviors ) || $ this -> hasAttribute ( $ name ) ; } 
public function addRule ( $ attributes , $ validator , $ options = [ ] ) { $ validators = $ this -> getValidators ( ) ; $ validators -> append ( Validator :: createValidator ( $ validator , $ this , ( array ) $ attributes , $ options ) ) ; return $ this ; } 
public static function validateData ( array $ data , $ rules = [ ] ) { $ model = new static ( $ data ) ; if ( ! empty ( $ rules ) ) { $ validators = $ model -> getValidators ( ) ; foreach ( $ rules as $ rule ) { if ( $ rule instanceof Validator ) { $ validators -> append ( $ rule ) ; } elseif ( is_array ( $ rule ) && isset ( $ rule [ 0 ] , $ rule [ 1 ] ) ) { 
protected function generateDependencyData ( $ cache ) { $ db = $ this -> db ; if ( $ db !== null ) { $ db = Instance :: ensure ( $ db ) ; } if ( ! $ this -> query instanceof QueryInterface ) { throw new InvalidConfigException ( '"' . get_class ( $ this ) . '::$query" should be an instance of "yii\db\QueryInterface".' ) ; } if ( ! empty ( $ db -> enableQueryCache ) ) { 
private function executeQuery ( $ query , $ db ) { if ( $ this -> method === null ) { return $ query -> one ( $ db ) ; } if ( is_string ( $ this -> method ) ) { return call_user_func ( [ $ query , $ this -> method ] , $ db ) ; } return call_user_func ( $ this -> method , $ query , $ db ) ; } 
public function build ( ExpressionInterface $ expression , array & $ params = [ ] ) { $ splitCondition = $ this -> splitCondition ( $ expression , $ params ) ; if ( $ splitCondition !== null ) { return $ splitCondition ; } return parent :: build ( $ expression , $ params ) ; } 
protected function splitCondition ( InCondition $ condition , & $ params ) { $ operator = $ condition -> getOperator ( ) ; $ values = $ condition -> getValues ( ) ; $ column = $ condition -> getColumn ( ) ; if ( $ values instanceof \ Traversable ) { $ values = iterator_to_array ( $ values ) ; } if ( ! is_array ( $ values ) ) { return null ; } $ maxParameters = 1000 ; $ count = count ( $ values ) ; if ( $ count <= $ maxParameters ) { return null ; } $ slices = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i += $ maxParameters ) { $ slices [ ] = $ this -> queryBuilder -> createConditionFromArray ( [ $ operator , $ column , array_slice ( $ values , $ i , $ maxParameters ) ] ) ; } array_unshift ( $ slices , ( $ operator === 'IN' ) ? 'OR' : 'AND' ) ; return $ this -> queryBuilder -> buildCondition ( $ slices , $ params ) ; } 
public function build ( ExpressionInterface $ expression , array & $ params = [ ] ) { $ operator = $ expression -> getOperator ( ) ; $ column = $ expression -> getColumn ( ) ; $ values = $ expression -> getValues ( ) ; if ( $ column === [ ] ) { 
protected function buildValues ( ConditionInterface $ condition , $ values , & $ params ) { $ sqlValues = [ ] ; $ column = $ condition -> getColumn ( ) ; if ( is_array ( $ column ) ) { $ column = reset ( $ column ) ; } if ( $ column instanceof \ Traversable ) { $ column -> rewind ( ) ; $ column = $ column -> current ( ) ; } foreach ( $ values as $ i => $ value ) { if ( is_array ( $ value ) || $ value instanceof \ ArrayAccess ) { $ value = isset ( $ value [ $ column ] ) ? $ value [ $ column ] : null ; } if ( $ value === null ) { $ sqlValues [ $ i ] = 'NULL' ; } elseif ( $ value instanceof ExpressionInterface ) { $ sqlValues [ $ i ] = $ this -> queryBuilder -> buildExpression ( $ value , $ params ) ; } else { $ sqlValues [ $ i ] = $ this -> queryBuilder -> bindParam ( $ value , $ params ) ; } } return $ sqlValues ; } 
protected function buildSubqueryInCondition ( $ operator , $ columns , $ values , & $ params ) { $ sql = $ this -> queryBuilder -> buildExpression ( $ values , $ params ) ; if ( is_array ( $ columns ) ) { foreach ( $ columns as $ i => $ col ) { if ( strpos ( $ col , '(' ) === false ) { $ columns [ $ i ] = $ this -> queryBuilder -> db -> quoteColumnName ( $ col ) ; } } return '(' . implode ( ', ' , $ columns ) . ") $operator $sql" ; } if ( strpos ( $ columns , '(' ) === false ) { $ columns = $ this -> queryBuilder -> db -> quoteColumnName ( $ columns ) ; } return "$columns $operator $sql" ; } 
protected function buildCompositeInCondition ( $ operator , $ columns , $ values , & $ params ) { $ vss = [ ] ; foreach ( $ values as $ value ) { $ vs = [ ] ; foreach ( $ columns as $ column ) { if ( isset ( $ value [ $ column ] ) ) { $ vs [ ] = $ this -> queryBuilder -> bindParam ( $ value [ $ column ] , $ params ) ; } else { $ vs [ ] = 'NULL' ; } } $ vss [ ] = '(' . implode ( ', ' , $ vs ) . ')' ; } if ( empty ( $ vss ) ) { return $ operator === 'IN' ? '0=1' : '' ; } $ sqlColumns = [ ] ; foreach ( $ columns as $ i => $ column ) { $ sqlColumns [ ] = strpos ( $ column , '(' ) === false ? $ this -> queryBuilder -> db -> quoteColumnName ( $ column ) : $ column ; } return '(' . implode ( ', ' , $ sqlColumns ) . ") $operator (" . implode ( ', ' , $ vss ) . ')' ; } 
public function createUrl ( $ manager , $ route , $ params ) { $ this -> createStatus = UrlRule :: CREATE_STATUS_SUCCESS ; $ url = $ this -> iterateRules ( $ this -> rules , $ manager , $ route , $ params ) ; if ( $ url !== false ) { return $ url ; } if ( $ this -> createStatus === UrlRule :: CREATE_STATUS_SUCCESS ) { 
protected function iterateRules ( $ rules , $ manager , $ route , $ params ) { foreach ( $ rules as $ rule ) { $ url = $ rule -> createUrl ( $ manager , $ route , $ params ) ; if ( $ url !== false ) { $ this -> createStatus = UrlRule :: CREATE_STATUS_SUCCESS ; return $ url ; } if ( $ this -> createStatus === null || ! method_exists ( $ rule , 'getCreateUrlStatus' ) || $ rule -> getCreateUrlStatus ( ) === null ) { $ this -> createStatus = null ; } else { $ this -> createStatus |= $ rule -> getCreateUrlStatus ( ) ; } } return false ; } 
public function with ( ) { $ with = func_get_args ( ) ; if ( isset ( $ with [ 0 ] ) && is_array ( $ with [ 0 ] ) ) { 
protected function createModels ( $ rows ) { if ( $ this -> asArray ) { return $ rows ; } else { $ models = [ ] ; $ class = $ this -> modelClass ; foreach ( $ rows as $ row ) { $ model = $ class :: instantiate ( $ row ) ; $ modelClass = get_class ( $ model ) ; $ modelClass :: populateRecord ( $ model , $ row ) ; $ models [ ] = $ model ; } return $ models ; } } 
public function findWith ( $ with , & $ models ) { $ primaryModel = reset ( $ models ) ; if ( ! $ primaryModel instanceof ActiveRecordInterface ) { $ modelClass = $ this -> modelClass ; $ primaryModel = $ modelClass :: instance ( ) ; } $ relations = $ this -> normalizeRelations ( $ primaryModel , $ with ) ; foreach ( $ relations as $ name => $ relation ) { if ( $ relation -> asArray === null ) { 
protected function handleFallbackExceptionMessage ( $ exception , $ previousException ) { $ msg = "An Error occurred while handling another error:\n" ; $ msg .= ( string ) $ exception ; $ msg .= "\nPrevious exception:\n" ; $ msg .= ( string ) $ previousException ; if ( YII_DEBUG ) { if ( PHP_SAPI === 'cli' ) { echo $ msg . "\n" ; } else { echo '<pre>' . htmlspecialchars ( $ msg , ENT_QUOTES , Yii :: $ app -> charset ) . '</pre>' ; } } else { echo 'An internal server error occurred.' ; } $ msg .= "\n\$_SERVER = " . VarDumper :: export ( $ _SERVER ) ; error_log ( $ msg ) ; if ( defined ( 'HHVM_VERSION' ) ) { flush ( ) ; } exit ( 1 ) ; } 
public function handleHhvmError ( $ code , $ message , $ file , $ line , $ context , $ backtrace ) { if ( $ this -> handleError ( $ code , $ message , $ file , $ line ) ) { return true ; } if ( E_ERROR & $ code ) { $ exception = new ErrorException ( $ message , $ code , $ code , $ file , $ line ) ; $ ref = new \ ReflectionProperty ( '\Exception' , 'trace' ) ; $ ref -> setAccessible ( true ) ; $ ref -> setValue ( $ exception , $ backtrace ) ; $ this -> _hhvmException = $ exception ; } return false ; } 
public static function convertExceptionToVerboseString ( $ exception ) { if ( $ exception instanceof Exception ) { $ message = "Exception ({$exception->getName()})" ; } elseif ( $ exception instanceof ErrorException ) { $ message = ( string ) $ exception -> getName ( ) ; } else { $ message = 'Exception' ; } $ message .= " '" . get_class ( $ exception ) . "' with message '{$exception->getMessage()}' \n\nin " . $ exception -> getFile ( ) . ':' . $ exception -> getLine ( ) . "\n\n" . "Stack trace:\n" . $ exception -> getTraceAsString ( ) ; return $ message ; } 
public function build ( ExpressionInterface $ expression , array & $ params = [ ] ) { $ operator = $ expression -> getOperator ( ) ; $ column = $ expression -> getColumn ( ) ; if ( strpos ( $ column , '(' ) === false ) { $ column = $ this -> queryBuilder -> db -> quoteColumnName ( $ column ) ; } $ phName1 = $ this -> createPlaceholder ( $ expression -> getIntervalStart ( ) , $ params ) ; $ phName2 = $ this -> createPlaceholder ( $ expression -> getIntervalEnd ( ) , $ params ) ; return "$column $operator $phName1 AND $phName2" ; } 
public function cache ( $ duration = null , $ dependency = null ) { $ this -> queryCacheDuration = $ duration === null ? $ this -> db -> queryCacheDuration : $ duration ; $ this -> queryCacheDependency = $ dependency ; return $ this ; } 
public function bindParam ( $ name , & $ value , $ dataType = null , $ length = null , $ driverOptions = null ) { $ this -> prepare ( ) ; if ( $ dataType === null ) { $ dataType = $ this -> db -> getSchema ( ) -> getPdoType ( $ value ) ; } if ( $ length === null ) { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType ) ; } elseif ( $ driverOptions === null ) { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType , $ length ) ; } else { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType , $ length , $ driverOptions ) ; } $ this -> params [ $ name ] = & $ value ; return $ this ; } 
protected function bindPendingParams ( ) { foreach ( $ this -> _pendingParams as $ name => $ value ) { $ this -> pdoStatement -> bindValue ( $ name , $ value [ 0 ] , $ value [ 1 ] ) ; } $ this -> _pendingParams = [ ] ; } 
public function bindValue ( $ name , $ value , $ dataType = null ) { if ( $ dataType === null ) { $ dataType = $ this -> db -> getSchema ( ) -> getPdoType ( $ value ) ; } $ this -> _pendingParams [ $ name ] = [ $ value , $ dataType ] ; $ this -> params [ $ name ] = $ value ; return $ this ; } 
public function queryScalar ( ) { $ result = $ this -> queryInternal ( 'fetchColumn' , 0 ) ; if ( is_resource ( $ result ) && get_resource_type ( $ result ) === 'stream' ) { return stream_get_contents ( $ result ) ; } return $ result ; } 
public function insert ( $ table , $ columns ) { $ params = [ ] ; $ sql = $ this -> db -> getQueryBuilder ( ) -> insert ( $ table , $ columns , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; } 
public function batchInsert ( $ table , $ columns , $ rows ) { $ table = $ this -> db -> quoteSql ( $ table ) ; $ columns = array_map ( function ( $ column ) { return $ this -> db -> quoteSql ( $ column ) ; } , $ columns ) ; $ params = [ ] ; $ sql = $ this -> db -> getQueryBuilder ( ) -> batchInsert ( $ table , $ columns , $ rows , $ params ) ; $ this -> setRawSql ( $ sql ) ; $ this -> bindValues ( $ params ) ; return $ this ; } 
public function upsert ( $ table , $ insertColumns , $ updateColumns = true , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> upsert ( $ table , $ insertColumns , $ updateColumns , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; } 
public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> update ( $ table , $ columns , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; } 
public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> delete ( $ table , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; } 
public function createTable ( $ table , $ columns , $ options = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createTable ( $ table , $ columns , $ options ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function renameTable ( $ table , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameTable ( $ table , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function dropTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropTable ( $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function truncateTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> truncateTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; } 
public function addColumn ( $ table , $ column , $ type ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addColumn ( $ table , $ column , $ type ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function renameColumn ( $ table , $ oldName , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameColumn ( $ table , $ oldName , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function dropPrimaryKey ( $ name , $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropPrimaryKey ( $ name , $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete = null , $ update = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete , $ update ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function addUnique ( $ name , $ table , $ columns ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addUnique ( $ name , $ table , $ columns ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function addCheck ( $ name , $ table , $ expression ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addCheck ( $ name , $ table , $ expression ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function addDefaultValue ( $ name , $ table , $ column , $ value ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addDefaultValue ( $ name , $ table , $ column , $ value ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function resetSequence ( $ table , $ value = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> resetSequence ( $ table , $ value ) ; return $ this -> setSql ( $ sql ) ; } 
public function executeResetSequence ( $ table , $ value = null ) { return $ this -> db -> getQueryBuilder ( ) -> executeResetSequence ( $ table , $ value ) ; } 
public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> checkIntegrity ( $ check , $ schema , $ table ) ; return $ this -> setSql ( $ sql ) ; } 
public function addCommentOnColumn ( $ table , $ column , $ comment ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addCommentOnColumn ( $ table , $ column , $ comment ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function addCommentOnTable ( $ table , $ comment ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addCommentOnTable ( $ table , $ comment ) ; return $ this -> setSql ( $ sql ) ; } 
public function dropCommentFromColumn ( $ table , $ column ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropCommentFromColumn ( $ table , $ column ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; } 
public function dropCommentFromTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropCommentFromTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; } 
public function createView ( $ viewName , $ subquery ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createView ( $ viewName , $ subquery ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ viewName ) ; } 
public function dropView ( $ viewName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropView ( $ viewName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ viewName ) ; } 
public function execute ( ) { $ sql = $ this -> getSql ( ) ; list ( $ profile , $ rawSql ) = $ this -> logQuery ( __METHOD__ ) ; if ( $ sql == '' ) { return 0 ; } $ this -> prepare ( false ) ; try { $ profile and Yii :: beginProfile ( $ rawSql , __METHOD__ ) ; $ this -> internalExecute ( $ rawSql ) ; $ n = $ this -> pdoStatement -> rowCount ( ) ; $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; $ this -> refreshTableSchema ( ) ; return $ n ; } catch ( Exception $ e ) { $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; throw $ e ; } } 
protected function getCacheKey ( $ method , $ fetchMode , $ rawSql ) { return [ __CLASS__ , $ method , $ fetchMode , $ this -> db -> dsn , $ this -> db -> username , $ rawSql , ] ; } 
protected function refreshTableSchema ( ) { if ( $ this -> _refreshTableName !== null ) { $ this -> db -> getSchema ( ) -> refreshTableSchema ( $ this -> _refreshTableName ) ; } } 
protected function internalExecute ( $ rawSql ) { $ attempt = 0 ; while ( true ) { try { if ( ++ $ attempt === 1 && $ this -> _isolationLevel !== false && $ this -> db -> getTransaction ( ) === null ) { $ this -> db -> transaction ( function ( ) use ( $ rawSql ) { $ this -> internalExecute ( $ rawSql ) ; } , $ this -> _isolationLevel ) ; } else { $ this -> pdoStatement -> execute ( ) ; } break ; } catch ( \ Exception $ e ) { $ rawSql = $ rawSql ? : $ this -> getRawSql ( ) ; $ e = $ this -> db -> getSchema ( ) -> convertException ( $ e , $ rawSql ) ; if ( $ this -> _retryHandler === null || ! call_user_func ( $ this -> _retryHandler , $ e , $ attempt ) ) { throw $ e ; } } } } 
protected function reset ( ) { $ this -> _sql = null ; $ this -> _pendingParams = [ ] ; $ this -> params = [ ] ; $ this -> _refreshTableName = null ; $ this -> _isolationLevel = false ; $ this -> _retryHandler = null ; } 
public function beforeAction ( $ action ) { $ user = $ this -> user ; $ request = Yii :: $ app -> getRequest ( ) ; foreach ( $ this -> rules as $ rule ) { if ( $ allow = $ rule -> allows ( $ action , $ user , $ request ) ) { return true ; } elseif ( $ allow === false ) { if ( isset ( $ rule -> denyCallback ) ) { call_user_func ( $ rule -> denyCallback , $ rule , $ action ) ; } elseif ( $ this -> denyCallback !== null ) { call_user_func ( $ this -> denyCallback , $ rule , $ action ) ; } else { $ this -> denyAccess ( $ user ) ; } return false ; } } if ( $ this -> denyCallback !== null ) { call_user_func ( $ this -> denyCallback , null , $ action ) ; } else { $ this -> denyAccess ( $ user ) ; } return false ; } 
protected function denyAccess ( $ user ) { if ( $ user !== false && $ user -> getIsGuest ( ) ) { $ user -> loginRequired ( ) ; } else { throw new ForbiddenHttpException ( Yii :: t ( 'yii' , 'You are not allowed to perform this action.' ) ) ; } } 
public function init ( ) { if ( $ this -> autoRelease ) { $ locks = & $ this -> _locks ; register_shutdown_function ( function ( ) use ( & $ locks ) { foreach ( $ locks as $ lock ) { $ this -> release ( $ lock ) ; } } ) ; } } 
public function acquire ( $ name , $ timeout = 0 ) { if ( ! in_array ( $ name , $ this -> _locks , true ) && $ this -> acquireLock ( $ name , $ timeout ) ) { $ this -> _locks [ ] = $ name ; return true ; } return false ; } 
public function release ( $ name ) { if ( $ this -> releaseLock ( $ name ) ) { $ index = array_search ( $ name , $ this -> _locks ) ; if ( $ index !== false ) { unset ( $ this -> _locks [ $ index ] ) ; } return true ; } return false ; } 
public function init ( ) { parent :: init ( ) ; if ( ! is_array ( $ this -> range ) && ! ( $ this -> range instanceof \ Closure ) && ! ( $ this -> range instanceof \ Traversable ) ) { throw new InvalidConfigException ( 'The "range" property must be set.' ) ; } if ( $ this -> message === null ) { $ this -> message = Yii :: t ( 'yii' , '{attribute} is invalid.' ) ; } } 
public function validateAttribute ( $ model , $ attribute ) { if ( $ this -> range instanceof \ Closure ) { $ this -> range = call_user_func ( $ this -> range , $ model , $ attribute ) ; } parent :: validateAttribute ( $ model , $ attribute ) ; } 
public function clientValidateAttribute ( $ model , $ attribute , $ view ) { if ( $ this -> range instanceof \ Closure ) { $ this -> range = call_user_func ( $ this -> range , $ model , $ attribute ) ; } ValidationAsset :: register ( $ view ) ; $ options = $ this -> getClientOptions ( $ model , $ attribute ) ; return 'yii.validation.range(value, messages, ' . json_encode ( $ options , JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ) . ');' ; } 
public function getClientOptions ( $ model , $ attribute ) { $ range = [ ] ; foreach ( $ this -> range as $ value ) { $ range [ ] = ( string ) $ value ; } $ options = [ 'range' => $ range , 'not' => $ this -> not , 'message' => $ this -> formatMessage ( $ this -> message , [ 'attribute' => $ model -> getAttributeLabel ( $ attribute ) , ] ) , ] ; if ( $ this -> skipOnEmpty ) { $ options [ 'skipOnEmpty' ] = 1 ; } if ( $ this -> allowArray ) { $ options [ 'allowArray' ] = 1 ; } return $ options ; } 
public function cache ( callable $ callable , $ duration = null , $ dependency = null ) { $ this -> _queryCacheInfo [ ] = [ $ duration === null ? $ this -> queryCacheDuration : $ duration , $ dependency ] ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } } 
public function noCache ( callable $ callable ) { $ this -> _queryCacheInfo [ ] = false ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } } 
public function open ( ) { if ( $ this -> pdo !== null ) { return ; } if ( ! empty ( $ this -> masters ) ) { $ db = $ this -> getMaster ( ) ; if ( $ db !== null ) { $ this -> pdo = $ db -> pdo ; return ; } throw new InvalidConfigException ( 'None of the master DB servers is available.' ) ; } if ( empty ( $ this -> dsn ) ) { throw new InvalidConfigException ( 'Connection::dsn cannot be empty.' ) ; } $ token = 'Opening DB connection: ' . $ this -> dsn ; $ enableProfiling = $ this -> enableProfiling ; try { Yii :: info ( $ token , __METHOD__ ) ; if ( $ enableProfiling ) { Yii :: beginProfile ( $ token , __METHOD__ ) ; } $ this -> pdo = $ this -> createPdoInstance ( ) ; $ this -> initConnection ( ) ; if ( $ enableProfiling ) { Yii :: endProfile ( $ token , __METHOD__ ) ; } } catch ( \ PDOException $ e ) { if ( $ enableProfiling ) { Yii :: endProfile ( $ token , __METHOD__ ) ; } throw new Exception ( $ e -> getMessage ( ) , $ e -> errorInfo , ( int ) $ e -> getCode ( ) , $ e ) ; } } 
protected function initConnection ( ) { $ this -> pdo -> setAttribute ( PDO :: ATTR_ERRMODE , PDO :: ERRMODE_EXCEPTION ) ; if ( $ this -> emulatePrepare !== null && constant ( 'PDO::ATTR_EMULATE_PREPARES' ) ) { $ this -> pdo -> setAttribute ( PDO :: ATTR_EMULATE_PREPARES , $ this -> emulatePrepare ) ; } if ( $ this -> charset !== null && in_array ( $ this -> getDriverName ( ) , [ 'pgsql' , 'mysql' , 'mysqli' , 'cubrid' ] , true ) ) { $ this -> pdo -> exec ( 'SET NAMES ' . $ this -> pdo -> quote ( $ this -> charset ) ) ; } $ this -> trigger ( self :: EVENT_AFTER_OPEN ) ; } 
public function createCommand ( $ sql = null , $ params = [ ] ) { $ driver = $ this -> getDriverName ( ) ; $ config = [ 'class' => 'yii\db\Command' ] ; if ( $ this -> commandClass !== $ config [ 'class' ] ) { $ config [ 'class' ] = $ this -> commandClass ; } elseif ( isset ( $ this -> commandMap [ $ driver ] ) ) { $ config = ! is_array ( $ this -> commandMap [ $ driver ] ) ? [ 'class' => $ this -> commandMap [ $ driver ] ] : $ this -> commandMap [ $ driver ] ; } $ config [ 'db' ] = $ this ; $ config [ 'sql' ] = $ sql ; $ command = Yii :: createObject ( $ config ) ; return $ command -> bindValues ( $ params ) ; } 
public function beginTransaction ( $ isolationLevel = null ) { $ this -> open ( ) ; if ( ( $ transaction = $ this -> getTransaction ( ) ) === null ) { $ transaction = $ this -> _transaction = new Transaction ( [ 'db' => $ this ] ) ; } $ transaction -> begin ( $ isolationLevel ) ; return $ transaction ; } 
public function transaction ( callable $ callback , $ isolationLevel = null ) { $ transaction = $ this -> beginTransaction ( $ isolationLevel ) ; $ level = $ transaction -> level ; try { $ result = call_user_func ( $ callback , $ this ) ; if ( $ transaction -> isActive && $ transaction -> level === $ level ) { $ transaction -> commit ( ) ; } } catch ( \ Exception $ e ) { $ this -> rollbackTransactionOnLevel ( $ transaction , $ level ) ; throw $ e ; } catch ( \ Throwable $ e ) { $ this -> rollbackTransactionOnLevel ( $ transaction , $ level ) ; throw $ e ; } return $ result ; } 
public function quoteSql ( $ sql ) { return preg_replace_callback ( '/(\\{\\{(%?[\w\-\. ]+%?)\\}\\}|\\[\\[([\w\-\. ]+)\\]\\])/' , function ( $ matches ) { if ( isset ( $ matches [ 3 ] ) ) { return $ this -> quoteColumnName ( $ matches [ 3 ] ) ; } return str_replace ( '%' , $ this -> tablePrefix , $ this -> quoteTableName ( $ matches [ 2 ] ) ) ; } , $ sql ) ; } 
public function getDriverName ( ) { if ( $ this -> _driverName === null ) { if ( ( $ pos = strpos ( $ this -> dsn , ':' ) ) !== false ) { $ this -> _driverName = strtolower ( substr ( $ this -> dsn , 0 , $ pos ) ) ; } else { $ this -> _driverName = strtolower ( $ this -> getSlavePdo ( ) -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) ) ; } } return $ this -> _driverName ; } 
public function getSlavePdo ( $ fallbackToMaster = true ) { $ db = $ this -> getSlave ( false ) ; if ( $ db === null ) { return $ fallbackToMaster ? $ this -> getMasterPdo ( ) : null ; } return $ db -> pdo ; } 
public function getSlave ( $ fallbackToMaster = true ) { if ( ! $ this -> enableSlaves ) { return $ fallbackToMaster ? $ this : null ; } if ( $ this -> _slave === false ) { $ this -> _slave = $ this -> openFromPool ( $ this -> slaves , $ this -> slaveConfig ) ; } return $ this -> _slave === null && $ fallbackToMaster ? $ this : $ this -> _slave ; } 
public function getMaster ( ) { if ( $ this -> _master === false ) { $ this -> _master = $ this -> shuffleMasters ? $ this -> openFromPool ( $ this -> masters , $ this -> masterConfig ) : $ this -> openFromPoolSequentially ( $ this -> masters , $ this -> masterConfig ) ; } return $ this -> _master ; } 
public function useMaster ( callable $ callback ) { if ( $ this -> enableSlaves ) { $ this -> enableSlaves = false ; try { $ result = call_user_func ( $ callback , $ this ) ; } catch ( \ Exception $ e ) { $ this -> enableSlaves = true ; throw $ e ; } catch ( \ Throwable $ e ) { $ this -> enableSlaves = true ; throw $ e ; } 
protected function openFromPoolSequentially ( array $ pool , array $ sharedConfig ) { if ( empty ( $ pool ) ) { return null ; } if ( ! isset ( $ sharedConfig [ 'class' ] ) ) { $ sharedConfig [ 'class' ] = get_class ( $ this ) ; } $ cache = is_string ( $ this -> serverStatusCache ) ? Yii :: $ app -> get ( $ this -> serverStatusCache , false ) : $ this -> serverStatusCache ; foreach ( $ pool as $ config ) { $ config = array_merge ( $ sharedConfig , $ config ) ; if ( empty ( $ config [ 'dsn' ] ) ) { throw new InvalidConfigException ( 'The "dsn" option must be specified.' ) ; } $ key = [ __METHOD__ , $ config [ 'dsn' ] ] ; if ( $ cache instanceof CacheInterface && $ cache -> get ( $ key ) ) { 
public function renderItems ( ) { $ models = $ this -> dataProvider -> getModels ( ) ; $ keys = $ this -> dataProvider -> getKeys ( ) ; $ rows = [ ] ; foreach ( array_values ( $ models ) as $ index => $ model ) { $ key = $ keys [ $ index ] ; if ( ( $ before = $ this -> renderBeforeItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ before ; } $ rows [ ] = $ this -> renderItem ( $ model , $ key , $ index ) ; if ( ( $ after = $ this -> renderAfterItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ after ; } } return implode ( $ this -> separator , $ rows ) ; } 
protected function renderBeforeItem ( $ model , $ key , $ index ) { if ( $ this -> beforeItem instanceof Closure ) { return call_user_func ( $ this -> beforeItem , $ model , $ key , $ index , $ this ) ; } return null ; } 
protected function renderAfterItem ( $ model , $ key , $ index ) { if ( $ this -> afterItem instanceof Closure ) { return call_user_func ( $ this -> afterItem , $ model , $ key , $ index , $ this ) ; } return null ; } 
public static function dirname ( $ path ) { $ pos = mb_strrpos ( str_replace ( '\\' , '/' , $ path ) , '/' ) ; if ( $ pos !== false ) { return mb_substr ( $ path , 0 , $ pos ) ; } return '' ; } 
public static function startsWith ( $ string , $ with , $ caseSensitive = true ) { if ( ! $ bytes = static :: byteLength ( $ with ) ) { return true ; } if ( $ caseSensitive ) { return strncmp ( $ string , $ with , $ bytes ) === 0 ; } $ encoding = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; return mb_strtolower ( mb_substr ( $ string , 0 , $ bytes , '8bit' ) , $ encoding ) === mb_strtolower ( $ with , $ encoding ) ; } 
public static function normalizeNumber ( $ value ) { $ value = ( string ) $ value ; $ localeInfo = localeconv ( ) ; $ decimalSeparator = isset ( $ localeInfo [ 'decimal_point' ] ) ? $ localeInfo [ 'decimal_point' ] : null ; if ( $ decimalSeparator !== null && $ decimalSeparator !== '.' ) { $ value = str_replace ( $ decimalSeparator , '.' , $ value ) ; } return $ value ; } 
private function getValidator ( $ model = null ) { if ( $ this -> _validator === null ) { $ this -> _validator = $ this -> createEmbeddedValidator ( $ model ) ; } return $ this -> _validator ; } 
private function createEmbeddedValidator ( $ model ) { $ rule = $ this -> rule ; if ( $ rule instanceof Validator ) { return $ rule ; } elseif ( is_array ( $ rule ) && isset ( $ rule [ 0 ] ) ) { 
public function validateAttribute ( $ model , $ attribute ) { $ value = $ model -> $ attribute ; if ( ! is_array ( $ value ) && ! $ value instanceof \ ArrayAccess ) { $ this -> addError ( $ model , $ attribute , $ this -> message , [ ] ) ; return ; } $ validator = $ this -> getValidator ( $ model ) ; 
public function format ( $ response ) { if ( stripos ( $ this -> contentType , 'charset' ) === false ) { $ this -> contentType .= '; charset=' . $ response -> charset ; } $ response -> getHeaders ( ) -> set ( 'Content-Type' , $ this -> contentType ) ; if ( $ response -> data !== null ) { $ response -> content = $ response -> data ; } } 
protected function generateDependencyData ( $ cache ) { $ db = Instance :: ensure ( $ this -> db , Connection :: className ( ) ) ; if ( $ this -> sql === null ) { throw new InvalidConfigException ( 'DbDependency::sql must be set.' ) ; } if ( $ db -> enableQueryCache ) { 
protected function acquireLock ( $ name , $ timeout = 0 ) { list ( $ key1 , $ key2 ) = $ this -> getKeysFromName ( $ name ) ; return $ this -> retryAcquire ( $ timeout , function ( ) use ( $ key1 , $ key2 ) { return $ this -> db -> useMaster ( function ( $ db ) use ( $ key1 , $ key2 ) { return ( bool ) $ db -> createCommand ( 'SELECT pg_try_advisory_lock(:key1, :key2)' , [ ':key1' => $ key1 , ':key2' => $ key2 ] ) -> queryScalar ( ) ; } ) ; } ) ; } 
protected function releaseLock ( $ name ) { list ( $ key1 , $ key2 ) = $ this -> getKeysFromName ( $ name ) ; return $ this -> db -> useMaster ( function ( $ db ) use ( $ key1 , $ key2 ) { return ( bool ) $ db -> createCommand ( 'SELECT pg_advisory_unlock(:key1, :key2)' , [ ':key1' => $ key1 , ':key2' => $ key2 ] ) -> queryScalar ( ) ; } ) ; } 
public function exists ( $ key ) { $ key = $ this -> buildKey ( $ key ) ; $ query = new Query ( ) ; $ query -> select ( [ 'COUNT(*)' ] ) -> from ( $ this -> cacheTable ) -> where ( '[[id]] = :id AND ([[expire]] = 0 OR [[expire]] >' . time ( ) . ')' , [ ':id' => $ key ] ) ; if ( $ this -> db -> enableQueryCache ) { 
public function gc ( $ force = false ) { if ( $ force || mt_rand ( 0 , 1000000 ) < $ this -> gcProbability ) { $ this -> db -> createCommand ( ) -> delete ( $ this -> cacheTable , '[[expire]] > 0 AND [[expire]] < ' . time ( ) ) -> execute ( ) ; } } 
public function init ( ) { parent :: init ( ) ; if ( ! $ this -> ipv4 && ! $ this -> ipv6 ) { throw new InvalidConfigException ( 'Both IPv4 and IPv6 checks can not be disabled at the same time' ) ; } if ( $ this -> message === null ) { $ this -> message = Yii :: t ( 'yii' , '{attribute} must be a valid IP address.' ) ; } if ( $ this -> ipv6NotAllowed === null ) { $ this -> ipv6NotAllowed = Yii :: t ( 'yii' , '{attribute} must not be an IPv6 address.' ) ; } if ( $ this -> ipv4NotAllowed === null ) { $ this -> ipv4NotAllowed = Yii :: t ( 'yii' , '{attribute} must not be an IPv4 address.' ) ; } if ( $ this -> wrongCidr === null ) { $ this -> wrongCidr = Yii :: t ( 'yii' , '{attribute} contains wrong subnet mask.' ) ; } if ( $ this -> noSubnet === null ) { $ this -> noSubnet = Yii :: t ( 'yii' , '{attribute} must be an IP address with specified subnet.' ) ; } if ( $ this -> hasSubnet === null ) { $ this -> hasSubnet = Yii :: t ( 'yii' , '{attribute} must not be a subnet.' ) ; } if ( $ this -> notInRange === null ) { $ this -> notInRange = Yii :: t ( 'yii' , '{attribute} is not in the allowed range.' ) ; } } 
public function validateAttribute ( $ model , $ attribute ) { $ value = $ model -> $ attribute ; $ result = $ this -> validateSubnet ( $ value ) ; if ( is_array ( $ result ) ) { $ result [ 1 ] = array_merge ( [ 'ip' => is_array ( $ value ) ? 'array()' : $ value ] , $ result [ 1 ] ) ; $ this -> addError ( $ model , $ attribute , $ result [ 0 ] , $ result [ 1 ] ) ; } else { $ model -> $ attribute = $ result ; } } 
private function isAllowed ( $ ip , $ cidr ) { if ( empty ( $ this -> ranges ) ) { return true ; } foreach ( $ this -> ranges as $ string ) { list ( $ isNegated , $ range ) = $ this -> parseNegatedRange ( $ string ) ; if ( $ this -> inRange ( $ ip , $ cidr , $ range ) ) { return ! $ isNegated ; } } return false ; } 
private function parseNegatedRange ( $ string ) { $ isNegated = strpos ( $ string , static :: NEGATION_CHAR ) === 0 ; return [ $ isNegated , $ isNegated ? substr ( $ string , strlen ( static :: NEGATION_CHAR ) ) : $ string ] ; } 
private function prepareRanges ( $ ranges ) { $ result = [ ] ; foreach ( $ ranges as $ string ) { list ( $ isRangeNegated , $ range ) = $ this -> parseNegatedRange ( $ string ) ; if ( isset ( $ this -> networks [ $ range ] ) ) { $ replacements = $ this -> prepareRanges ( $ this -> networks [ $ range ] ) ; foreach ( $ replacements as & $ replacement ) { list ( $ isReplacementNegated , $ replacement ) = $ this -> parseNegatedRange ( $ replacement ) ; $ result [ ] = ( $ isRangeNegated && ! $ isReplacementNegated ? static :: NEGATION_CHAR : '' ) . $ replacement ; } } else { $ result [ ] = $ string ; } } return array_unique ( $ result ) ; } 
public function getClientOptions ( $ model , $ attribute ) { $ messages = [ 'ipv6NotAllowed' => $ this -> ipv6NotAllowed , 'ipv4NotAllowed' => $ this -> ipv4NotAllowed , 'message' => $ this -> message , 'noSubnet' => $ this -> noSubnet , 'hasSubnet' => $ this -> hasSubnet , ] ; foreach ( $ messages as & $ message ) { $ message = $ this -> formatMessage ( $ message , [ 'attribute' => $ model -> getAttributeLabel ( $ attribute ) , ] ) ; } $ options = [ 'ipv4Pattern' => new JsExpression ( Html :: escapeJsRegularExpression ( $ this -> ipv4Pattern ) ) , 'ipv6Pattern' => new JsExpression ( Html :: escapeJsRegularExpression ( $ this -> ipv6Pattern ) ) , 'messages' => $ messages , 'ipv4' => ( bool ) $ this -> ipv4 , 'ipv6' => ( bool ) $ this -> ipv6 , 'ipParsePattern' => new JsExpression ( Html :: escapeJsRegularExpression ( $ this -> getIpParsePattern ( ) ) ) , 'negation' => $ this -> negation , 'subnet' => $ this -> subnet , ] ; if ( $ this -> skipOnEmpty ) { $ options [ 'skipOnEmpty' ] = 1 ; } return $ options ; } 
public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } $ model -> scenario = $ this -> scenario ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) === false && ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to update the object for unknown reason.' ) ; } return $ model ; } 
public function attach ( $ owner ) { parent :: attach ( $ owner ) ; if ( empty ( $ this -> attributes ) ) { $ lock = $ this -> getLockAttribute ( ) ; $ this -> attributes = array_fill_keys ( array_keys ( $ this -> events ( ) ) , $ lock ) ; } } 
protected function getLockAttribute ( ) { if ( $ this -> _lockAttribute ) { return $ this -> _lockAttribute ; } $ owner = $ this -> owner ; $ lock = $ owner -> optimisticLock ( ) ; if ( $ lock === null || $ owner -> hasAttribute ( $ lock ) === false ) { throw new InvalidCallException ( "Unable to get the optimistic lock attribute. Probably 'optimisticLock()' method is misconfigured." ) ; } $ this -> _lockAttribute = $ lock ; return $ lock ; } 
protected function getValue ( $ event ) { if ( $ this -> value === null ) { $ request = Yii :: $ app -> getRequest ( ) ; $ lock = $ this -> getLockAttribute ( ) ; $ formName = $ this -> owner -> formName ( ) ; $ formValue = $ formName ? ArrayHelper :: getValue ( $ request -> getBodyParams ( ) , $ formName . '.' . $ lock ) : null ; $ input = $ formValue ? : $ request -> getBodyParam ( $ lock ) ; $ isValid = $ input && ( new NumberValidator ( ) ) -> validate ( $ input ) ; return $ isValid ? $ input : 0 ; } return parent :: getValue ( $ event ) ; } 
public function upgrade ( ) { $ owner = $ this -> owner ; if ( $ owner -> getIsNewRecord ( ) ) { throw new InvalidCallException ( 'Upgrading the model version is not possible on a new record.' ) ; } $ lock = $ this -> getLockAttribute ( ) ; $ version = $ owner -> $ lock ? : 0 ; $ owner -> updateAttributes ( [ $ lock => $ version + 1 ] ) ; } 
public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { if ( $ unique === self :: INDEX_UNIQUE || $ unique === true ) { $ index = false ; $ unique = true ; } else { $ index = $ unique ; $ unique = false ; } return ( $ unique ? 'CREATE UNIQUE INDEX ' : 'CREATE INDEX ' ) . $ this -> db -> quoteTableName ( $ name ) . ' ON ' . $ this -> db -> quoteTableName ( $ table ) . ( $ index !== false ? " USING $index" : '' ) . ' (' . $ this -> buildColumns ( $ columns ) . ')' ; } 
public function dropIndex ( $ name , $ table ) { if ( strpos ( $ table , '.' ) !== false && strpos ( $ name , '.' ) === false ) { if ( strpos ( $ table , '{{' ) !== false ) { $ table = preg_replace ( '/\\{\\{(.*?)\\}\\}/' , '\1' , $ table ) ; list ( $ schema , $ table ) = explode ( '.' , $ table ) ; if ( strpos ( $ schema , '%' ) === false ) $ name = $ schema . '.' . $ name ; else $ name = '{{' . $ schema . '.' . $ name . '}}' ; } else { list ( $ schema ) = explode ( '.' , $ table ) ; $ name = $ schema . '.' . $ name ; } } return 'DROP INDEX ' . $ this -> db -> quoteTableName ( $ name ) ; } 
public function renameTable ( $ oldName , $ newName ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ oldName ) . ' RENAME TO ' . $ this -> db -> quoteTableName ( $ newName ) ; } 
public function alterColumn ( $ table , $ column , $ type ) { $ columnName = $ this -> db -> quoteColumnName ( $ column ) ; $ tableName = $ this -> db -> quoteTableName ( $ table ) ; 
public function insert ( $ table , $ columns , & $ params ) { return parent :: insert ( $ table , $ this -> normalizeTableRowData ( $ table , $ columns ) , $ params ) ; } 
public function upsert ( $ table , $ insertColumns , $ updateColumns , & $ params ) { $ insertColumns = $ this -> normalizeTableRowData ( $ table , $ insertColumns ) ; if ( ! is_bool ( $ updateColumns ) ) { $ updateColumns = $ this -> normalizeTableRowData ( $ table , $ updateColumns ) ; } if ( version_compare ( $ this -> db -> getServerVersion ( ) , '9.5' , '<' ) ) { return $ this -> oldUpsert ( $ table , $ insertColumns , $ updateColumns , $ params ) ; } return $ this -> newUpsert ( $ table , $ insertColumns , $ updateColumns , $ params ) ; } 
private function normalizeTableRowData ( $ table , $ columns ) { if ( $ columns instanceof Query ) { return $ columns ; } if ( ( $ tableSchema = $ this -> db -> getSchema ( ) -> getTableSchema ( $ table ) ) !== null ) { $ columnSchemas = $ tableSchema -> columns ; foreach ( $ columns as $ name => $ value ) { if ( isset ( $ columnSchemas [ $ name ] ) && $ columnSchemas [ $ name ] -> type === Schema :: TYPE_BINARY && is_string ( $ value ) ) { $ columns [ $ name ] = new PdoValue ( $ value , \ PDO :: PARAM_LOB ) ; 
public function getPage ( $ recalculate = false ) { if ( $ this -> _page === null || $ recalculate ) { $ page = ( int ) $ this -> getQueryParam ( $ this -> pageParam , 1 ) - 1 ; $ this -> setPage ( $ page , true ) ; } return $ this -> _page ; } 
public function setPage ( $ value , $ validatePage = false ) { if ( $ value === null ) { $ this -> _page = null ; } else { $ value = ( int ) $ value ; if ( $ validatePage && $ this -> validatePage ) { $ pageCount = $ this -> getPageCount ( ) ; if ( $ value >= $ pageCount ) { $ value = $ pageCount - 1 ; } } if ( $ value < 0 ) { $ value = 0 ; } $ this -> _page = $ value ; } } 
public function getPageSize ( ) { if ( $ this -> _pageSize === null ) { if ( empty ( $ this -> pageSizeLimit ) ) { $ pageSize = $ this -> defaultPageSize ; $ this -> setPageSize ( $ pageSize ) ; } else { $ pageSize = ( int ) $ this -> getQueryParam ( $ this -> pageSizeParam , $ this -> defaultPageSize ) ; $ this -> setPageSize ( $ pageSize , true ) ; } } return $ this -> _pageSize ; } 
public function getLinks ( $ absolute = false ) { $ currentPage = $ this -> getPage ( ) ; $ pageCount = $ this -> getPageCount ( ) ; $ links = [ Link :: REL_SELF => $ this -> createUrl ( $ currentPage , null , $ absolute ) , ] ; if ( $ currentPage > 0 ) { $ links [ self :: LINK_FIRST ] = $ this -> createUrl ( 0 , null , $ absolute ) ; $ links [ self :: LINK_PREV ] = $ this -> createUrl ( $ currentPage - 1 , null , $ absolute ) ; } if ( $ currentPage < $ pageCount - 1 ) { $ links [ self :: LINK_NEXT ] = $ this -> createUrl ( $ currentPage + 1 , null , $ absolute ) ; $ links [ self :: LINK_LAST ] = $ this -> createUrl ( $ pageCount - 1 , null , $ absolute ) ; } return $ links ; } 
protected function getQueryParam ( $ name , $ defaultValue = null ) { if ( ( $ params = $ this -> params ) === null ) { $ request = Yii :: $ app -> getRequest ( ) ; $ params = $ request instanceof Request ? $ request -> getQueryParams ( ) : [ ] ; } return isset ( $ params [ $ name ] ) && is_scalar ( $ params [ $ name ] ) ? $ params [ $ name ] : $ defaultValue ; } 
public static function fromArrayDefinition ( $ operator , $ operands ) { if ( ! isset ( $ operands [ 0 ] , $ operands [ 1 ] ) ) { throw new InvalidArgumentException ( "Operator '$operator' requires two operands." ) ; } $ condition = new static ( $ operands [ 0 ] , $ operator , $ operands [ 1 ] ) ; if ( isset ( $ operands [ 2 ] ) ) { $ condition -> escapingReplacements = $ operands [ 2 ] ; } return $ condition ; } 
protected function detectSearchAttributeTypes ( ) { $ model = $ this -> getSearchModel ( ) ; $ attributeTypes = [ ] ; foreach ( $ model -> activeAttributes ( ) as $ attribute ) { $ attributeTypes [ $ attribute ] = self :: TYPE_STRING ; } foreach ( $ model -> getValidators ( ) as $ validator ) { $ type = $ this -> detectSearchAttributeType ( $ validator ) ; if ( $ type !== null ) { foreach ( ( array ) $ validator -> attributes as $ attribute ) { $ attributeTypes [ $ attribute ] = $ type ; } } } return $ attributeTypes ; } 
protected function detectSearchAttributeType ( Validator $ validator ) { if ( $ validator instanceof BooleanValidator ) { return self :: TYPE_BOOLEAN ; } if ( $ validator instanceof NumberValidator ) { return $ validator -> integerOnly ? self :: TYPE_INTEGER : self :: TYPE_FLOAT ; } if ( $ validator instanceof StringValidator ) { return self :: TYPE_STRING ; } if ( $ validator instanceof EachValidator ) { return self :: TYPE_ARRAY ; } if ( $ validator instanceof DateValidator ) { if ( $ validator -> type == DateValidator :: TYPE_DATETIME ) { return self :: TYPE_DATETIME ; } if ( $ validator -> type == DateValidator :: TYPE_TIME ) { return self :: TYPE_TIME ; } return self :: TYPE_DATE ; } } 
public function setErrorMessages ( $ errorMessages ) { if ( is_array ( $ errorMessages ) ) { $ errorMessages = array_merge ( $ this -> defaultErrorMessages ( ) , $ errorMessages ) ; } $ this -> _errorMessages = $ errorMessages ; } 
protected function defaultErrorMessages ( ) { return [ 'invalidFilter' => Yii :: t ( 'yii' , 'The format of {filter} is invalid.' ) , 'operatorRequireMultipleOperands' => Yii :: t ( 'yii' , 'Operator "{operator}" requires multiple operands.' ) , 'unknownAttribute' => Yii :: t ( 'yii' , 'Unknown filter attribute "{attribute}"' ) , 'invalidAttributeValueFormat' => Yii :: t ( 'yii' , 'Condition for "{attribute}" should be either a value or valid operator specification.' ) , 'operatorRequireAttribute' => Yii :: t ( 'yii' , 'Operator "{operator}" must be used with a search attribute.' ) , 'unsupportedOperatorType' => Yii :: t ( 'yii' , '"{attribute}" does not support operator "{operator}".' ) , ] ; } 
protected function parseErrorMessage ( $ messageKey , $ params = [ ] ) { $ messages = $ this -> getErrorMessages ( ) ; if ( isset ( $ messages [ $ messageKey ] ) ) { $ message = $ messages [ $ messageKey ] ; } else { $ message = Yii :: t ( 'yii' , 'The format of {filter} is invalid.' ) ; } $ params = array_merge ( [ 'filter' => $ this -> getAttributeLabel ( $ this -> filterAttributeName ) , ] , $ params ) ; return Yii :: $ app -> getI18n ( ) -> format ( $ message , $ params , Yii :: $ app -> language ) ; } 
protected function validateCondition ( $ condition ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidFilter' ) ) ; return ; } if ( empty ( $ condition ) ) { return ; } foreach ( $ condition as $ key => $ value ) { $ method = 'validateAttributeCondition' ; if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ controlKey = $ this -> filterControls [ $ key ] ; if ( isset ( $ this -> conditionValidators [ $ controlKey ] ) ) { $ method = $ this -> conditionValidators [ $ controlKey ] ; } } $ this -> $ method ( $ key , $ value ) ; } } 
protected function validateConjunctionCondition ( $ operator , $ condition ) { if ( ! is_array ( $ condition ) || ! ArrayHelper :: isIndexed ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; return ; } foreach ( $ condition as $ part ) { $ this -> validateCondition ( $ part ) ; } } 
protected function validateAttributeCondition ( $ attribute , $ condition ) { $ attributeTypes = $ this -> getSearchAttributeTypes ( ) ; if ( ! isset ( $ attributeTypes [ $ attribute ] ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'unknownAttribute' , [ 'attribute' => $ attribute ] ) ) ; return ; } if ( is_array ( $ condition ) ) { $ operatorCount = 0 ; foreach ( $ condition as $ rawOperator => $ value ) { if ( isset ( $ this -> filterControls [ $ rawOperator ] ) ) { $ operator = $ this -> filterControls [ $ rawOperator ] ; if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { $ operatorCount ++ ; $ this -> validateOperatorCondition ( $ rawOperator , $ value , $ attribute ) ; } } } if ( $ operatorCount > 0 ) { if ( $ operatorCount < count ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidAttributeValueFormat' , [ 'attribute' => $ attribute ] ) ) ; } } else { 
protected function validateOperatorCondition ( $ operator , $ condition , $ attribute = null ) { if ( $ attribute === null ) { 
protected function validateAttributeValue ( $ attribute , $ value ) { $ model = $ this -> getSearchModel ( ) ; if ( ! $ model -> isAttributeSafe ( $ attribute ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'unknownAttribute' , [ 'attribute' => $ attribute ] ) ) ; return ; } $ model -> { $ attribute } = $ value ; if ( ! $ model -> validate ( [ $ attribute ] ) ) { $ this -> addError ( $ this -> filterAttributeName , $ model -> getFirstError ( $ attribute ) ) ; return ; } } 
public function normalize ( $ runValidation = true ) { if ( $ runValidation && ! $ this -> validate ( ) ) { return false ; } $ filter = $ this -> getFilter ( ) ; if ( ! is_array ( $ filter ) || empty ( $ filter ) ) { return [ ] ; } return $ this -> normalizeComplexFilter ( $ filter ) ; } 
private function normalizeComplexFilter ( array $ filter ) { $ result = [ ] ; foreach ( $ filter as $ key => $ value ) { if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ key = $ this -> filterControls [ $ key ] ; } elseif ( isset ( $ this -> attributeMap [ $ key ] ) ) { $ key = $ this -> attributeMap [ $ key ] ; } if ( is_array ( $ value ) ) { $ result [ $ key ] = $ this -> normalizeComplexFilter ( $ value ) ; } else { $ result [ $ key ] = $ value ; } } return $ result ; } 
public function canGetProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { if ( $ name === $ this -> filterAttributeName ) { return true ; } return parent :: canGetProperty ( $ name , $ checkVars , $ checkBehaviors ) ; } 
public function canSetProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { if ( $ name === $ this -> filterAttributeName ) { return true ; } return parent :: canSetProperty ( $ name , $ checkVars , $ checkBehaviors ) ; } 
public function __isset ( $ name ) { if ( $ name === $ this -> filterAttributeName ) { return $ this -> getFilter ( ) !== null ; } return parent :: __isset ( $ name ) ; } 
public function mergeRules ( array $ rules ) { $ this -> setRules ( ArrayHelper :: merge ( $ this -> getRules ( ) , $ rules ) ) ; return $ this ; } 
public function init ( ) { parent :: init ( ) ; if ( empty ( $ this -> attributes ) ) { $ this -> attributes = [ BaseActiveRecord :: EVENT_BEFORE_INSERT => [ $ this -> createdAtAttribute , $ this -> updatedAtAttribute ] , BaseActiveRecord :: EVENT_BEFORE_UPDATE => $ this -> updatedAtAttribute , ] ; } } 
public function init ( ) { if ( ! extension_loaded ( 'intl' ) ) { throw new InvalidConfigException ( 'Locale component requires PHP intl extension to be installed.' ) ; } if ( $ this -> locale === null ) { $ this -> locale = Yii :: $ app -> language ; } } 
public function getCurrencySymbol ( $ currencyCode = null ) { $ locale = $ this -> locale ; if ( $ currencyCode !== null ) { $ locale .= '@currency=' . $ currencyCode ; } $ formatter = new \ NumberFormatter ( $ locale , \ NumberFormatter :: CURRENCY ) ; return $ formatter -> getSymbol ( \ NumberFormatter :: CURRENCY_SYMBOL ) ; } 
protected function getValue ( $ event ) { if ( $ this -> value instanceof Closure || ( is_array ( $ this -> value ) && is_callable ( $ this -> value ) ) ) { return call_user_func ( $ this -> value , $ event ) ; } return $ this -> value ; } 
protected function prepareModels ( ) { if ( ( $ models = $ this -> allModels ) === null ) { return [ ] ; } if ( ( $ sort = $ this -> getSort ( ) ) !== false ) { $ models = $ this -> sortModels ( $ models , $ sort ) ; } if ( ( $ pagination = $ this -> getPagination ( ) ) !== false ) { $ pagination -> totalCount = $ this -> getTotalCount ( ) ; if ( $ pagination -> getPageSize ( ) > 0 ) { $ models = array_slice ( $ models , $ pagination -> getOffset ( ) , $ pagination -> getLimit ( ) , true ) ; } } return $ models ; } 
protected function prepareKeys ( $ models ) { if ( $ this -> key !== null ) { $ keys = [ ] ; foreach ( $ models as $ model ) { if ( is_string ( $ this -> key ) ) { $ keys [ ] = $ model [ $ this -> key ] ; } else { $ keys [ ] = call_user_func ( $ this -> key , $ model ) ; } } return $ keys ; } return array_keys ( $ models ) ; } 
protected function sortModels ( $ models , $ sort ) { $ orders = $ sort -> getOrders ( ) ; if ( ! empty ( $ orders ) ) { ArrayHelper :: multisort ( $ models , array_keys ( $ orders ) , array_values ( $ orders ) ) ; } return $ models ; } 
public function checkAccess ( $ userId , $ permissionName , $ params = [ ] ) { if ( isset ( $ this -> _checkAccessAssignments [ ( string ) $ userId ] ) ) { $ assignments = $ this -> _checkAccessAssignments [ ( string ) $ userId ] ; } else { $ assignments = $ this -> getAssignments ( $ userId ) ; $ this -> _checkAccessAssignments [ ( string ) $ userId ] = $ assignments ; } if ( $ this -> hasNoAssignments ( $ assignments ) ) { return false ; } $ this -> loadFromCache ( ) ; if ( $ this -> items !== null ) { return $ this -> checkAccessFromCache ( $ userId , $ permissionName , $ params , $ assignments ) ; } return $ this -> checkAccessRecursive ( $ userId , $ permissionName , $ params , $ assignments ) ; } 
protected function removeItem ( $ item ) { if ( ! $ this -> supportsCascadeUpdate ( ) ) { $ this -> db -> createCommand ( ) -> delete ( $ this -> itemChildTable , [ 'or' , '[[parent]]=:name' , '[[child]]=:name' ] , [ ':name' => $ item -> name ] ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> delete ( $ this -> assignmentTable , [ 'item_name' => $ item -> name ] ) -> execute ( ) ; } $ this -> db -> createCommand ( ) -> delete ( $ this -> itemTable , [ 'name' => $ item -> name ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; return true ; } 
protected function updateItem ( $ name , $ item ) { if ( $ item -> name !== $ name && ! $ this -> supportsCascadeUpdate ( ) ) { $ this -> db -> createCommand ( ) -> update ( $ this -> itemChildTable , [ 'parent' => $ item -> name ] , [ 'parent' => $ name ] ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> update ( $ this -> itemChildTable , [ 'child' => $ item -> name ] , [ 'child' => $ name ] ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> update ( $ this -> assignmentTable , [ 'item_name' => $ item -> name ] , [ 'item_name' => $ name ] ) -> execute ( ) ; } $ item -> updatedAt = time ( ) ; $ this -> db -> createCommand ( ) -> update ( $ this -> itemTable , [ 'name' => $ item -> name , 'description' => $ item -> description , 'rule_name' => $ item -> ruleName , 'data' => $ item -> data === null ? null : serialize ( $ item -> data ) , 'updated_at' => $ item -> updatedAt , ] , [ 'name' => $ name , ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; return true ; } 
protected function addRule ( $ rule ) { $ time = time ( ) ; if ( $ rule -> createdAt === null ) { $ rule -> createdAt = $ time ; } if ( $ rule -> updatedAt === null ) { $ rule -> updatedAt = $ time ; } $ this -> db -> createCommand ( ) -> insert ( $ this -> ruleTable , [ 'name' => $ rule -> name , 'data' => serialize ( $ rule ) , 'created_at' => $ rule -> createdAt , 'updated_at' => $ rule -> updatedAt , ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; return true ; } 
protected function updateRule ( $ name , $ rule ) { if ( $ rule -> name !== $ name && ! $ this -> supportsCascadeUpdate ( ) ) { $ this -> db -> createCommand ( ) -> update ( $ this -> itemTable , [ 'rule_name' => $ rule -> name ] , [ 'rule_name' => $ name ] ) -> execute ( ) ; } $ rule -> updatedAt = time ( ) ; $ this -> db -> createCommand ( ) -> update ( $ this -> ruleTable , [ 'name' => $ rule -> name , 'data' => serialize ( $ rule ) , 'updated_at' => $ rule -> updatedAt , ] , [ 'name' => $ name , ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; return true ; } 
protected function removeRule ( $ rule ) { if ( ! $ this -> supportsCascadeUpdate ( ) ) { $ this -> db -> createCommand ( ) -> update ( $ this -> itemTable , [ 'rule_name' => null ] , [ 'rule_name' => $ rule -> name ] ) -> execute ( ) ; } $ this -> db -> createCommand ( ) -> delete ( $ this -> ruleTable , [ 'name' => $ rule -> name ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; return true ; } 
public function getChildRoles ( $ roleName ) { $ role = $ this -> getRole ( $ roleName ) ; if ( $ role === null ) { throw new InvalidArgumentException ( "Role \"$roleName\" not found." ) ; } $ result = [ ] ; $ this -> getChildrenRecursive ( $ roleName , $ this -> getChildrenList ( ) , $ result ) ; $ roles = [ $ roleName => $ role ] ; $ roles += array_filter ( $ this -> getRoles ( ) , function ( Role $ roleItem ) use ( $ result ) { return array_key_exists ( $ roleItem -> name , $ result ) ; } ) ; return $ roles ; } 
public function getPermissionsByRole ( $ roleName ) { $ childrenList = $ this -> getChildrenList ( ) ; $ result = [ ] ; $ this -> getChildrenRecursive ( $ roleName , $ childrenList , $ result ) ; if ( empty ( $ result ) ) { return [ ] ; } $ query = ( new Query ( ) ) -> from ( $ this -> itemTable ) -> where ( [ 'type' => Item :: TYPE_PERMISSION , 'name' => array_keys ( $ result ) , ] ) ; $ permissions = [ ] ; foreach ( $ query -> all ( $ this -> db ) as $ row ) { $ permissions [ $ row [ 'name' ] ] = $ this -> populateItem ( $ row ) ; } return $ permissions ; } 
public function getPermissionsByUser ( $ userId ) { if ( $ this -> isEmptyUserId ( $ userId ) ) { return [ ] ; } $ directPermission = $ this -> getDirectPermissionsByUser ( $ userId ) ; $ inheritedPermission = $ this -> getInheritedPermissionsByUser ( $ userId ) ; return array_merge ( $ directPermission , $ inheritedPermission ) ; } 
protected function getChildrenRecursive ( $ name , $ childrenList , & $ result ) { if ( isset ( $ childrenList [ $ name ] ) ) { foreach ( $ childrenList [ $ name ] as $ child ) { $ result [ $ child ] = true ; $ this -> getChildrenRecursive ( $ child , $ childrenList , $ result ) ; } } } 
public function getRules ( ) { if ( $ this -> rules !== null ) { return $ this -> rules ; } $ query = ( new Query ( ) ) -> from ( $ this -> ruleTable ) ; $ rules = [ ] ; foreach ( $ query -> all ( $ this -> db ) as $ row ) { $ data = $ row [ 'data' ] ; if ( is_resource ( $ data ) ) { $ data = stream_get_contents ( $ data ) ; } $ rules [ $ row [ 'name' ] ] = unserialize ( $ data ) ; } return $ rules ; } 
public function getAssignment ( $ roleName , $ userId ) { if ( $ this -> isEmptyUserId ( $ userId ) ) { return null ; } $ row = ( new Query ( ) ) -> from ( $ this -> assignmentTable ) -> where ( [ 'user_id' => ( string ) $ userId , 'item_name' => $ roleName ] ) -> one ( $ this -> db ) ; if ( $ row === false ) { return null ; } return new Assignment ( [ 'userId' => $ row [ 'user_id' ] , 'roleName' => $ row [ 'item_name' ] , 'createdAt' => $ row [ 'created_at' ] , ] ) ; } 
public function addChild ( $ parent , $ child ) { if ( $ parent -> name === $ child -> name ) { throw new InvalidArgumentException ( "Cannot add '{$parent->name}' as a child of itself." ) ; } if ( $ parent instanceof Permission && $ child instanceof Role ) { throw new InvalidArgumentException ( 'Cannot add a role as a child of a permission.' ) ; } if ( $ this -> detectLoop ( $ parent , $ child ) ) { throw new InvalidCallException ( "Cannot add '{$child->name}' as a child of '{$parent->name}'. A loop has been detected." ) ; } $ this -> db -> createCommand ( ) -> insert ( $ this -> itemChildTable , [ 'parent' => $ parent -> name , 'child' => $ child -> name ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; return true ; } 
public function removeChild ( $ parent , $ child ) { $ result = $ this -> db -> createCommand ( ) -> delete ( $ this -> itemChildTable , [ 'parent' => $ parent -> name , 'child' => $ child -> name ] ) -> execute ( ) > 0 ; $ this -> invalidateCache ( ) ; return $ result ; } 
public function removeChildren ( $ parent ) { $ result = $ this -> db -> createCommand ( ) -> delete ( $ this -> itemChildTable , [ 'parent' => $ parent -> name ] ) -> execute ( ) > 0 ; $ this -> invalidateCache ( ) ; return $ result ; } 
public function getChildren ( $ name ) { $ query = ( new Query ( ) ) -> select ( [ 'name' , 'type' , 'description' , 'rule_name' , 'data' , 'created_at' , 'updated_at' ] ) -> from ( [ $ this -> itemTable , $ this -> itemChildTable ] ) -> where ( [ 'parent' => $ name , 'name' => new Expression ( '[[child]]' ) ] ) ; $ children = [ ] ; foreach ( $ query -> all ( $ this -> db ) as $ row ) { $ children [ $ row [ 'name' ] ] = $ this -> populateItem ( $ row ) ; } return $ children ; } 
protected function detectLoop ( $ parent , $ child ) { if ( $ child -> name === $ parent -> name ) { return true ; } foreach ( $ this -> getChildren ( $ child -> name ) as $ grandchild ) { if ( $ this -> detectLoop ( $ parent , $ grandchild ) ) { return true ; } } return false ; } 
public function revoke ( $ role , $ userId ) { if ( $ this -> isEmptyUserId ( $ userId ) ) { return false ; } unset ( $ this -> _checkAccessAssignments [ ( string ) $ userId ] ) ; return $ this -> db -> createCommand ( ) -> delete ( $ this -> assignmentTable , [ 'user_id' => ( string ) $ userId , 'item_name' => $ role -> name ] ) -> execute ( ) > 0 ; } 
public function revokeAll ( $ userId ) { if ( $ this -> isEmptyUserId ( $ userId ) ) { return false ; } unset ( $ this -> _checkAccessAssignments [ ( string ) $ userId ] ) ; return $ this -> db -> createCommand ( ) -> delete ( $ this -> assignmentTable , [ 'user_id' => ( string ) $ userId ] ) -> execute ( ) > 0 ; } 
public function removeAll ( ) { $ this -> removeAllAssignments ( ) ; $ this -> db -> createCommand ( ) -> delete ( $ this -> itemChildTable ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> delete ( $ this -> itemTable ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> delete ( $ this -> ruleTable ) -> execute ( ) ; $ this -> invalidateCache ( ) ; } 
protected function removeAllItems ( $ type ) { if ( ! $ this -> supportsCascadeUpdate ( ) ) { $ names = ( new Query ( ) ) -> select ( [ 'name' ] ) -> from ( $ this -> itemTable ) -> where ( [ 'type' => $ type ] ) -> column ( $ this -> db ) ; if ( empty ( $ names ) ) { return ; } $ key = $ type == Item :: TYPE_PERMISSION ? 'child' : 'parent' ; $ this -> db -> createCommand ( ) -> delete ( $ this -> itemChildTable , [ $ key => $ names ] ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> delete ( $ this -> assignmentTable , [ 'item_name' => $ names ] ) -> execute ( ) ; } $ this -> db -> createCommand ( ) -> delete ( $ this -> itemTable , [ 'type' => $ type ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; } 
public function removeAllRules ( ) { if ( ! $ this -> supportsCascadeUpdate ( ) ) { $ this -> db -> createCommand ( ) -> update ( $ this -> itemTable , [ 'rule_name' => null ] ) -> execute ( ) ; } $ this -> db -> createCommand ( ) -> delete ( $ this -> ruleTable ) -> execute ( ) ; $ this -> invalidateCache ( ) ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> normalizer !== false ) { $ this -> normalizer = Yii :: createObject ( $ this -> normalizer ) ; if ( ! $ this -> normalizer instanceof UrlNormalizer ) { throw new InvalidConfigException ( '`' . get_class ( $ this ) . '::normalizer` should be an instance of `' . UrlNormalizer :: className ( ) . '` or its DI compatible configuration.' ) ; } } if ( ! $ this -> enablePrettyUrl ) { return ; } if ( is_string ( $ this -> cache ) ) { $ this -> cache = Yii :: $ app -> get ( $ this -> cache , false ) ; } if ( empty ( $ this -> rules ) ) { return ; } $ this -> rules = $ this -> buildRules ( $ this -> rules ) ; } 
public function addRules ( $ rules , $ append = true ) { if ( ! $ this -> enablePrettyUrl ) { return ; } $ rules = $ this -> buildRules ( $ rules ) ; if ( $ append ) { $ this -> rules = array_merge ( $ this -> rules , $ rules ) ; } else { $ this -> rules = array_merge ( $ rules , $ this -> rules ) ; } } 
protected function buildRules ( $ ruleDeclarations ) { $ builtRules = $ this -> getBuiltRulesFromCache ( $ ruleDeclarations ) ; if ( $ builtRules !== false ) { return $ builtRules ; } $ builtRules = [ ] ; $ verbs = 'GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS' ; foreach ( $ ruleDeclarations as $ key => $ rule ) { if ( is_string ( $ rule ) ) { $ rule = [ 'route' => $ rule ] ; if ( preg_match ( "/^((?:($verbs),)*($verbs))\\s+(.*)$/" , $ key , $ matches ) ) { $ rule [ 'verb' ] = explode ( ',' , $ matches [ 1 ] ) ; 
protected function setBuiltRulesCache ( $ ruleDeclarations , $ builtRules ) { if ( ! $ this -> cache instanceof CacheInterface ) { return false ; } return $ this -> cache -> set ( [ $ this -> cacheKey , $ this -> ruleConfig , $ ruleDeclarations ] , $ builtRules ) ; } 
protected function getBuiltRulesFromCache ( $ ruleDeclarations ) { if ( ! $ this -> cache instanceof CacheInterface ) { return false ; } return $ this -> cache -> get ( [ $ this -> cacheKey , $ this -> ruleConfig , $ ruleDeclarations ] ) ; } 
public function parseRequest ( $ request ) { if ( $ this -> enablePrettyUrl ) { foreach ( $ this -> rules as $ rule ) { $ result = $ rule -> parseRequest ( $ this , $ request ) ; if ( YII_DEBUG ) { Yii :: debug ( [ 'rule' => method_exists ( $ rule , '__toString' ) ? $ rule -> __toString ( ) : get_class ( $ rule ) , 'match' => $ result !== false , 'parent' => null , ] , __METHOD__ ) ; } if ( $ result !== false ) { return $ result ; } } if ( $ this -> enableStrictParsing ) { return false ; } Yii :: debug ( 'No matching URL rules. Using default URL parsing logic.' , __METHOD__ ) ; $ suffix = ( string ) $ this -> suffix ; $ pathInfo = $ request -> getPathInfo ( ) ; $ normalized = false ; if ( $ this -> normalizer !== false ) { $ pathInfo = $ this -> normalizer -> normalizePathInfo ( $ pathInfo , $ suffix , $ normalized ) ; } if ( $ suffix !== '' && $ pathInfo !== '' ) { $ n = strlen ( $ this -> suffix ) ; if ( substr_compare ( $ pathInfo , $ this -> suffix , - $ n , $ n ) === 0 ) { $ pathInfo = substr ( $ pathInfo , 0 , - $ n ) ; if ( $ pathInfo === '' ) { 
public function createUrl ( $ params ) { $ params = ( array ) $ params ; $ anchor = isset ( $ params [ '#' ] ) ? '#' . $ params [ '#' ] : '' ; unset ( $ params [ '#' ] , $ params [ $ this -> routeParam ] ) ; $ route = trim ( $ params [ 0 ] , '/' ) ; unset ( $ params [ 0 ] ) ; $ baseUrl = $ this -> showScriptName || ! $ this -> enablePrettyUrl ? $ this -> getScriptUrl ( ) : $ this -> getBaseUrl ( ) ; if ( $ this -> enablePrettyUrl ) { $ cacheKey = $ route . '?' ; foreach ( $ params as $ key => $ value ) { if ( $ value !== null ) { $ cacheKey .= $ key . '&' ; } } $ url = $ this -> getUrlFromCache ( $ cacheKey , $ route , $ params ) ; if ( $ url === false ) { foreach ( $ this -> rules as $ rule ) { if ( in_array ( $ rule , $ this -> _ruleCache [ $ cacheKey ] , true ) ) { 
protected function canBeCached ( UrlRuleInterface $ rule ) { return 
protected function getUrlFromCache ( $ cacheKey , $ route , $ params ) { if ( ! empty ( $ this -> _ruleCache [ $ cacheKey ] ) ) { foreach ( $ this -> _ruleCache [ $ cacheKey ] as $ rule ) { if ( ( $ url = $ rule -> createUrl ( $ this , $ route , $ params ) ) !== false ) { return $ url ; } } } else { $ this -> _ruleCache [ $ cacheKey ] = [ ] ; } return false ; } 
public function createAbsoluteUrl ( $ params , $ scheme = null ) { $ params = ( array ) $ params ; $ url = $ this -> createUrl ( $ params ) ; if ( strpos ( $ url , '://' ) === false ) { $ hostInfo = $ this -> getHostInfo ( ) ; if ( strncmp ( $ url , '//' , 2 ) === 0 ) { $ url = substr ( $ hostInfo , 0 , strpos ( $ hostInfo , '://' ) ) . ':' . $ url ; } else { $ url = $ hostInfo . $ url ; } } return Url :: ensureScheme ( $ url , $ scheme ) ; } 
public function getBaseUrl ( ) { if ( $ this -> _baseUrl === null ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ request instanceof Request ) { $ this -> _baseUrl = $ request -> getBaseUrl ( ) ; } else { throw new InvalidConfigException ( 'Please configure UrlManager::baseUrl correctly as you are running a console application.' ) ; } } return $ this -> _baseUrl ; } 
public function setBaseUrl ( $ value ) { $ this -> _baseUrl = $ value === null ? null : rtrim ( Yii :: getAlias ( $ value ) , '/' ) ; } 
public function getScriptUrl ( ) { if ( $ this -> _scriptUrl === null ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ request instanceof Request ) { $ this -> _scriptUrl = $ request -> getScriptUrl ( ) ; } else { throw new InvalidConfigException ( 'Please configure UrlManager::scriptUrl correctly as you are running a console application.' ) ; } } return $ this -> _scriptUrl ; } 
public function getHostInfo ( ) { if ( $ this -> _hostInfo === null ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ request instanceof \ yii \ web \ Request ) { $ this -> _hostInfo = $ request -> getHostInfo ( ) ; } else { throw new InvalidConfigException ( 'Please configure UrlManager::hostInfo correctly as you are running a console application.' ) ; } } return $ this -> _hostInfo ; } 
public function attach ( $ owner ) { $ this -> owner = $ owner ; $ owner -> on ( Controller :: EVENT_BEFORE_ACTION , [ $ this , 'beforeFilter' ] ) ; } 
public function detach ( ) { if ( $ this -> owner ) { $ this -> owner -> off ( Controller :: EVENT_BEFORE_ACTION , [ $ this , 'beforeFilter' ] ) ; $ this -> owner -> off ( Controller :: EVENT_AFTER_ACTION , [ $ this , 'afterFilter' ] ) ; $ this -> owner = null ; } } 
protected function getActionId ( $ action ) { if ( $ this -> owner instanceof Module ) { $ mid = $ this -> owner -> getUniqueId ( ) ; $ id = $ action -> getUniqueId ( ) ; if ( $ mid !== '' && strpos ( $ id , $ mid ) === 0 ) { $ id = substr ( $ id , strlen ( $ mid ) + 1 ) ; } } else { $ id = $ action -> id ; } return $ id ; } 
protected function isActive ( $ action ) { $ id = $ this -> getActionId ( $ action ) ; if ( empty ( $ this -> only ) ) { $ onlyMatch = true ; } else { $ onlyMatch = false ; foreach ( $ this -> only as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ onlyMatch = true ; break ; } } } $ exceptMatch = false ; foreach ( $ this -> except as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ exceptMatch = true ; break ; } } return ! $ exceptMatch && $ onlyMatch ; } 
protected function createView ( array $ config ) { if ( ! array_key_exists ( 'class' , $ config ) ) { $ config [ 'class' ] = View :: className ( ) ; } return Yii :: createObject ( $ config ) ; } 
public function compose ( $ view = null , array $ params = [ ] ) { $ message = $ this -> createMessage ( ) ; if ( $ view === null ) { return $ message ; } if ( ! array_key_exists ( 'message' , $ params ) ) { $ params [ 'message' ] = $ message ; } $ this -> _message = $ message ; if ( is_array ( $ view ) ) { if ( isset ( $ view [ 'html' ] ) ) { $ html = $ this -> render ( $ view [ 'html' ] , $ params , $ this -> htmlLayout ) ; } if ( isset ( $ view [ 'text' ] ) ) { $ text = $ this -> render ( $ view [ 'text' ] , $ params , $ this -> textLayout ) ; } } else { $ html = $ this -> render ( $ view , $ params , $ this -> htmlLayout ) ; } $ this -> _message = null ; if ( isset ( $ html ) ) { $ message -> setHtmlBody ( $ html ) ; } if ( isset ( $ text ) ) { $ message -> setTextBody ( $ text ) ; } elseif ( isset ( $ html ) ) { if ( preg_match ( '~<body[^>]*>(.*?)</body>~is' , $ html , $ match ) ) { $ html = $ match [ 1 ] ; } 
protected function createMessage ( ) { $ config = $ this -> messageConfig ; if ( ! array_key_exists ( 'class' , $ config ) ) { $ config [ 'class' ] = $ this -> messageClass ; } $ config [ 'mailer' ] = $ this ; return Yii :: createObject ( $ config ) ; } 
public function sendMultiple ( array $ messages ) { $ successCount = 0 ; foreach ( $ messages as $ message ) { if ( $ this -> send ( $ message ) ) { $ successCount ++ ; } } return $ successCount ; } 
protected function saveMessage ( $ message ) { $ path = Yii :: getAlias ( $ this -> fileTransportPath ) ; if ( ! is_dir ( $ path ) ) { mkdir ( $ path , 0777 , true ) ; } if ( $ this -> fileTransportCallback !== null ) { $ file = $ path . '/' . call_user_func ( $ this -> fileTransportCallback , $ this , $ message ) ; } else { $ file = $ path . '/' . $ this -> generateMessageFileName ( ) ; } file_put_contents ( $ file , $ message -> toString ( ) ) ; return true ; } 
public function beforeSend ( $ message ) { $ event = new MailEvent ( [ 'message' => $ message ] ) ; $ this -> trigger ( self :: EVENT_BEFORE_SEND , $ event ) ; return $ event -> isValid ; } 
public function afterSend ( $ message , $ isSuccessful ) { $ event = new MailEvent ( [ 'message' => $ message , 'isSuccessful' => $ isSuccessful ] ) ; $ this -> trigger ( self :: EVENT_AFTER_SEND , $ event ) ; } 
public function build ( ExpressionInterface $ expression , array & $ params = [ ] ) { $ placeholder = static :: PARAM_PREFIX . count ( $ params ) ; $ params [ $ placeholder ] = $ expression ; return $ placeholder ; } 
public function actionAll ( ) { if ( ! $ this -> confirm ( 'Install all applications and all extensions now?' ) ) { return 1 ; } foreach ( $ this -> extensions as $ ext => $ repo ) { $ ret = $ this -> actionExt ( $ ext ) ; if ( $ ret !== 0 ) { return $ ret ; } } foreach ( $ this -> apps as $ app => $ repo ) { $ ret = $ this -> actionApp ( $ app ) ; if ( $ ret !== 0 ) { return $ ret ; } } return 0 ; } 
public function actionRun ( $ command ) { $ command = implode ( ' ' , \ func_get_args ( ) ) ; 
public function actionApp ( $ app , $ repo = null ) { 
public function actionExt ( $ extension , $ repo = null ) { 
public function options ( $ actionID ) { $ options = parent :: options ( $ actionID ) ; if ( \ in_array ( $ actionID , [ 'ext' , 'app' , 'all' ] , true ) ) { $ options [ ] = 'useHttp' ; $ options [ ] = 'composerNoProgress' ; } return $ options ; } 
protected function cleanupVendorDir ( $ dir ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } $ extensions = $ this -> findDirs ( "$dir/vendor/yiisoft" ) ; foreach ( $ extensions as $ ext ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2-$ext" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } } } 
protected function linkFrameworkAndExtensions ( $ dir , $ base ) { if ( is_dir ( $ link = "$dir/vendor/yiisoft/yii2" ) ) { $ this -> stdout ( "Removing dir $link.\n" ) ; FileHelper :: removeDirectory ( $ link ) ; $ this -> stdout ( "Creating symlink for $link.\n" ) ; symlink ( "$base/framework" , $ link ) ; } $ extensions = $ this -> findDirs ( "$dir/vendor/yiisoft" ) ; foreach ( $ extensions as $ ext ) { if ( is_dir ( $ link = "$dir/vendor/yiisoft/yii2-$ext" ) ) { $ this -> stdout ( "Removing dir $link.\n" ) ; FileHelper :: removeDirectory ( $ link ) ; $ this -> stdout ( "Creating symlink for $link.\n" ) ; if ( ! file_exists ( "$base/extensions/$ext" ) ) { $ ret = $ this -> actionExt ( $ ext ) ; if ( $ ret !== 0 ) { return $ ret ; } } symlink ( "$base/extensions/$ext" , $ link ) ; } } } 
protected function listSubDirs ( $ dir ) { $ list = [ ] ; $ handle = opendir ( $ dir ) ; if ( $ handle === false ) { throw new InvalidParamException ( "Unable to open directory: $dir" ) ; } while ( ( $ file = readdir ( $ handle ) ) !== false ) { if ( $ file === '.' || $ file === '..' ) { continue ; } 
protected function findDirs ( $ dir ) { $ list = [ ] ; $ handle = @ opendir ( $ dir ) ; if ( $ handle === false ) { return [ ] ; } while ( ( $ file = readdir ( $ handle ) ) !== false ) { if ( $ file === '.' || $ file === '..' ) { continue ; } $ path = $ dir . DIRECTORY_SEPARATOR . $ file ; if ( is_dir ( $ path ) && preg_match ( '/^yii2-(.*)$/' , $ file , $ matches ) ) { $ list [ ] = $ matches [ 1 ] ; } } closedir ( $ handle ) ; foreach ( $ list as $ i => $ e ) { if ( $ e === 'composer' ) { 
public function parse ( $ rawBody , $ contentType ) { try { $ parameters = Json :: decode ( $ rawBody , $ this -> asArray ) ; return $ parameters === null ? [ ] : $ parameters ; } catch ( InvalidArgumentException $ e ) { if ( $ this -> throwException ) { throw new BadRequestHttpException ( 'Invalid JSON data in request body: ' . $ e -> getMessage ( ) ) ; } return [ ] ; } } 
public function add ( $ object ) { if ( $ object instanceof Item ) { if ( $ object -> ruleName && $ this -> getRule ( $ object -> ruleName ) === null ) { $ rule = \ Yii :: createObject ( $ object -> ruleName ) ; $ rule -> name = $ object -> ruleName ; $ this -> addRule ( $ rule ) ; } return $ this -> addItem ( $ object ) ; } elseif ( $ object instanceof Rule ) { return $ this -> addRule ( $ object ) ; } throw new InvalidArgumentException ( 'Adding unsupported object type.' ) ; } 
public function remove ( $ object ) { if ( $ object instanceof Item ) { return $ this -> removeItem ( $ object ) ; } elseif ( $ object instanceof Rule ) { return $ this -> removeRule ( $ object ) ; } throw new InvalidArgumentException ( 'Removing unsupported object type.' ) ; } 
public function getRole ( $ name ) { $ item = $ this -> getItem ( $ name ) ; return $ item instanceof Item && $ item -> type == Item :: TYPE_ROLE ? $ item : null ; } 
public function getPermission ( $ name ) { $ item = $ this -> getItem ( $ name ) ; return $ item instanceof Item && $ item -> type == Item :: TYPE_PERMISSION ? $ item : null ; } 
public function setDefaultRoles ( $ roles ) { if ( is_array ( $ roles ) ) { $ this -> defaultRoles = $ roles ; } elseif ( $ roles instanceof \ Closure ) { $ roles = call_user_func ( $ roles ) ; if ( ! is_array ( $ roles ) ) { throw new InvalidValueException ( 'Default roles closure must return an array' ) ; } $ this -> defaultRoles = $ roles ; } else { throw new InvalidArgumentException ( 'Default roles must be either an array or a callable' ) ; } } 
public function getDefaultRoleInstances ( ) { $ result = [ ] ; foreach ( $ this -> defaultRoles as $ roleName ) { $ result [ $ roleName ] = $ this -> createRole ( $ roleName ) ; } return $ result ; } 
public function primaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_PK , $ length ) ; } 
public function bigPrimaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BIGPK , $ length ) ; } 
public function char ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_CHAR , $ length ) ; } 
public function string ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_STRING , $ length ) ; } 
public function tinyInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TINYINT , $ length ) ; } 
public function smallInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_SMALLINT , $ length ) ; } 
public function integer ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_INTEGER , $ length ) ; } 
public function bigInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BIGINT , $ length ) ; } 
public function float ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_FLOAT , $ precision ) ; } 
public function double ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DOUBLE , $ precision ) ; } 
public function decimal ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DECIMAL , $ length ) ; } 
public function dateTime ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DATETIME , $ precision ) ; } 
public function timestamp ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TIMESTAMP , $ precision ) ; } 
public function time ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TIME , $ precision ) ; } 
public function binary ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BINARY , $ length ) ; } 
public function money ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_MONEY , $ length ) ; } 
public function json ( ) { if ( version_compare ( PHP_VERSION , '5.6' , '<' ) && $ this -> getDb ( ) -> getDriverName ( ) === 'mysql' ) { throw new \ yii \ base \ Exception ( 'JSON column type is not supported in PHP < 5.6' ) ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_JSON ) ; } 
public function up ( ) { $ cache = $ this -> getCache ( ) ; $ this -> db = $ cache -> db ; $ tableOptions = null ; if ( $ this -> db -> driverName === 'mysql' ) { 
public function down ( ) { $ cache = $ this -> getCache ( ) ; $ this -> db = $ cache -> db ; $ this -> dropTable ( $ cache -> cacheTable ) ; } 
public function buildOrderByAndLimit ( $ sql , $ orderBy , $ limit , $ offset ) { if ( ! $ this -> hasOffset ( $ offset ) && ! $ this -> hasLimit ( $ limit ) ) { $ orderBy = $ this -> buildOrderBy ( $ orderBy ) ; return $ orderBy === '' ? $ sql : $ sql . $ this -> separator . $ orderBy ; } if ( version_compare ( $ this -> db -> getSchema ( ) -> getServerVersion ( ) , '11' , '<' ) ) { return $ this -> oldBuildOrderByAndLimit ( $ sql , $ orderBy , $ limit , $ offset ) ; } return $ this -> newBuildOrderByAndLimit ( $ sql , $ orderBy , $ limit , $ offset ) ; } 
protected function newBuildOrderByAndLimit ( $ sql , $ orderBy , $ limit , $ offset ) { $ orderBy = $ this -> buildOrderBy ( $ orderBy ) ; if ( $ orderBy === '' ) { 
protected function oldBuildOrderByAndLimit ( $ sql , $ orderBy , $ limit , $ offset ) { $ orderBy = $ this -> buildOrderBy ( $ orderBy ) ; if ( $ orderBy === '' ) { 
public function addDefaultValue ( $ name , $ table , $ column , $ value ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' ADD CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) . ' DEFAULT ' . $ this -> db -> quoteValue ( $ value ) . ' FOR ' . $ this -> db -> quoteColumnName ( $ column ) ; } 
public function dropDefaultValue ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; } 
public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ enable = $ check ? 'CHECK' : 'NOCHECK' ; $ schema = $ schema ? : $ this -> db -> getSchema ( ) -> defaultSchema ; $ tableNames = $ this -> db -> getTableSchema ( $ table ) ? [ $ table ] : $ this -> db -> getSchema ( ) -> getTableNames ( $ schema ) ; $ viewNames = $ this -> db -> getSchema ( ) -> getViewNames ( $ schema ) ; $ tableNames = array_diff ( $ tableNames , $ viewNames ) ; $ command = '' ; foreach ( $ tableNames as $ tableName ) { $ tableName = $ this -> db -> quoteTableName ( "{$schema}.{$tableName}" ) ; $ command .= "ALTER TABLE $tableName $enable CONSTRAINT ALL; " ; } return $ command ; } 
public function update ( $ table , $ columns , $ condition , & $ params ) { return parent :: update ( $ table , $ this -> normalizeTableRowData ( $ table , $ columns , $ params ) , $ condition , $ params ) ; } 
public function run ( $ route , $ params = [ ] ) { $ pos = strpos ( $ route , '/' ) ; if ( $ pos === false ) { return $ this -> runAction ( $ route , $ params ) ; } elseif ( $ pos > 0 ) { return $ this -> module -> runAction ( $ route , $ params ) ; } return Yii :: $ app -> runAction ( ltrim ( $ route , '/' ) , $ params ) ; } 
public function createAction ( $ id ) { if ( $ id === '' ) { $ id = $ this -> defaultAction ; } $ actionMap = $ this -> actions ( ) ; if ( isset ( $ actionMap [ $ id ] ) ) { return Yii :: createObject ( $ actionMap [ $ id ] , [ $ id , $ this ] ) ; } elseif ( preg_match ( '/^[a-z0-9\\-_]+$/' , $ id ) && strpos ( $ id , '--' ) === false && trim ( $ id , '-' ) === $ id ) { $ methodName = 'action' . str_replace ( ' ' , '' , ucwords ( str_replace ( '-' , ' ' , $ id ) ) ) ; if ( method_exists ( $ this , $ methodName ) ) { $ method = new \ ReflectionMethod ( $ this , $ methodName ) ; if ( $ method -> isPublic ( ) && $ method -> getName ( ) === $ methodName ) { return new InlineAction ( $ id , $ this , $ methodName ) ; } } } return null ; } 
public function getModules ( ) { $ modules = [ $ this -> module ] ; $ module = $ this -> module ; while ( $ module -> module !== null ) { array_unshift ( $ modules , $ module -> module ) ; $ module = $ module -> module ; } return $ modules ; } 
public function getUniqueId ( ) { return $ this -> module instanceof Application ? $ this -> id : $ this -> module -> getUniqueId ( ) . '/' . $ this -> id ; } 
public function render ( $ view , $ params = [ ] ) { $ content = $ this -> getView ( ) -> render ( $ view , $ params , $ this ) ; return $ this -> renderContent ( $ content ) ; } 
public function getViewPath ( ) { if ( $ this -> _viewPath === null ) { $ this -> _viewPath = $ this -> module -> getViewPath ( ) . DIRECTORY_SEPARATOR . $ this -> id ; } return $ this -> _viewPath ; } 
public function getAttribute ( $ attribute ) { try { return parent :: getAttribute ( $ attribute ) ; } catch ( \ PDOException $ e ) { switch ( $ attribute ) { case self :: ATTR_SERVER_VERSION : return $ this -> query ( "SELECT CAST(SERVERPROPERTY('productversion') AS VARCHAR)" ) -> fetchColumn ( ) ; default : throw $ e ; } } } 
public static function on ( $ class , $ name , $ handler , $ data = null , $ append = true ) { $ class = ltrim ( $ class , '\\' ) ; if ( strpos ( $ class , '*' ) !== false || strpos ( $ name , '*' ) !== false ) { if ( $ append || empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { self :: $ _eventWildcards [ $ name ] [ $ class ] [ ] = [ $ handler , $ data ] ; } else { array_unshift ( self :: $ _eventWildcards [ $ name ] [ $ class ] , [ $ handler , $ data ] ) ; } return ; } if ( $ append || empty ( self :: $ _events [ $ name ] [ $ class ] ) ) { self :: $ _events [ $ name ] [ $ class ] [ ] = [ $ handler , $ data ] ; } else { array_unshift ( self :: $ _events [ $ name ] [ $ class ] , [ $ handler , $ data ] ) ; } } 
public static function off ( $ class , $ name , $ handler = null ) { $ class = ltrim ( $ class , '\\' ) ; if ( empty ( self :: $ _events [ $ name ] [ $ class ] ) && empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { return false ; } if ( $ handler === null ) { unset ( self :: $ _events [ $ name ] [ $ class ] ) ; unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; return true ; } 
protected function getMigrationHistory ( $ limit ) { if ( $ this -> db -> schema -> getTableSchema ( $ this -> migrationTable , true ) === null ) { $ this -> createMigrationHistoryTable ( ) ; } $ query = ( new Query ( ) ) -> select ( [ 'version' , 'apply_time' ] ) -> from ( $ this -> migrationTable ) -> orderBy ( [ 'apply_time' => SORT_DESC , 'version' => SORT_DESC ] ) ; if ( empty ( $ this -> migrationNamespaces ) ) { $ query -> limit ( $ limit ) ; $ rows = $ query -> all ( $ this -> db ) ; $ history = ArrayHelper :: map ( $ rows , 'version' , 'apply_time' ) ; unset ( $ history [ self :: BASE_MIGRATION ] ) ; return $ history ; } $ rows = $ query -> all ( $ this -> db ) ; $ history = [ ] ; foreach ( $ rows as $ key => $ row ) { if ( $ row [ 'version' ] === self :: BASE_MIGRATION ) { continue ; } if ( preg_match ( '/m?(\d{6}_?\d{6})(\D.*)?$/is' , $ row [ 'version' ] , $ matches ) ) { $ time = str_replace ( '_' , '' , $ matches [ 1 ] ) ; $ row [ 'canonicalVersion' ] = $ time ; } else { $ row [ 'canonicalVersion' ] = $ row [ 'version' ] ; } $ row [ 'apply_time' ] = ( int ) $ row [ 'apply_time' ] ; $ history [ ] = $ row ; } usort ( $ history , function ( $ a , $ b ) { if ( $ a [ 'apply_time' ] === $ b [ 'apply_time' ] ) { if ( ( $ compareResult = strcasecmp ( $ b [ 'canonicalVersion' ] , $ a [ 'canonicalVersion' ] ) ) !== 0 ) { return $ compareResult ; } return strcasecmp ( $ b [ 'version' ] , $ a [ 'version' ] ) ; } return ( $ a [ 'apply_time' ] > $ b [ 'apply_time' ] ) ? - 1 : + 1 ; } ) ; $ history = array_slice ( $ history , 0 , $ limit ) ; $ history = ArrayHelper :: map ( $ history , 'version' , 'apply_time' ) ; return $ history ; } 
protected function truncateDatabase ( ) { $ db = $ this -> db ; $ schemas = $ db -> schema -> getTableSchemas ( ) ; 
protected function parseFields ( ) { $ fields = [ ] ; $ foreignKeys = [ ] ; foreach ( $ this -> fields as $ index => $ field ) { $ chunks = preg_split ( '/\s?:\s?/' , $ field , null ) ; $ property = array_shift ( $ chunks ) ; foreach ( $ chunks as $ i => & $ chunk ) { if ( strncmp ( $ chunk , 'foreignKey' , 10 ) === 0 ) { preg_match ( '/foreignKey\((\w*)\s?(\w*)\)/' , $ chunk , $ matches ) ; $ foreignKeys [ $ property ] = [ 'table' => isset ( $ matches [ 1 ] ) ? $ matches [ 1 ] : preg_replace ( '/_id$/' , '' , $ property ) , 'column' => ! empty ( $ matches [ 2 ] ) ? $ matches [ 2 ] : null , ] ; unset ( $ chunks [ $ i ] ) ; continue ; } if ( ! preg_match ( '/^(.+?)\(([^(]+)\)$/' , $ chunk ) ) { $ chunk .= '()' ; } } $ fields [ ] = [ 'property' => $ property , 'decorators' => implode ( '->' , $ chunks ) , ] ; } return [ 'fields' => $ fields , 'foreignKeys' => $ foreignKeys , ] ; } 
protected function addDefaultPrimaryKey ( & $ fields ) { foreach ( $ fields as $ field ) { if ( false !== strripos ( $ field [ 'decorators' ] , 'primarykey()' ) ) { return ; } } array_unshift ( $ fields , [ 'property' => 'id' , 'decorators' => 'primaryKey()' ] ) ; } 
public function run ( ) { if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id ) ; } $ model = new $ this -> modelClass ( [ 'scenario' => $ this -> scenario , ] ) ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> setStatusCode ( 201 ) ; $ id = implode ( ',' , array_values ( $ model -> getPrimaryKey ( true ) ) ) ; $ response -> getHeaders ( ) -> set ( 'Location' , Url :: toRoute ( [ $ this -> viewAction , 'id' => $ id ] , true ) ) ; } elseif ( ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to create the object for unknown reason.' ) ; } return $ model ; } 
protected function loadTableIndexes ( $ tableName ) { static $ sql = <<<'SQL' SELECT "ic"."relname" AS "name", "ia"."attname" AS "column_name", "i"."indisunique" AS "index_is_unique", "i"."indisprimary" AS "index_is_primary" FROM "pg_class" AS "tc" INNER JOIN "pg_namespace" AS "tcns" ON "tcns"."oid" = "tc"."relnamespace" INNER JOIN "pg_index" AS "i" ON "i"."indrelid" = "tc"."oid" INNER JOIN "pg_class" AS "ic" ON "ic"."oid" = "i"."indexrelid" INNER JOIN "pg_attribute" AS "ia" ON "ia"."attrelid" = "i"."indrelid" AND "ia"."attnum" = ANY ("i"."indkey") WHERE "tcns"."nspname" = :schemaName AND "tc"."relname" = :tableName ORDER BY "ia"."attnum" ASC SQL ; $ resolvedName = $ this -> resolveTableName ( $ tableName ) ; $ indexes = $ this -> db -> createCommand ( $ sql , [ ':schemaName' => $ resolvedName -> schemaName , ':tableName' => $ resolvedName -> name , ] ) -> queryAll ( ) ; $ indexes = $ this -> normalizePdoRowKeyCase ( $ indexes , true ) ; $ indexes = ArrayHelper :: index ( $ indexes , null , 'name' ) ; $ result = [ ] ; foreach ( $ indexes as $ name => $ index ) { $ result [ ] = new IndexConstraint ( [ 'isPrimary' => ( bool ) $ index [ 0 ] [ 'index_is_primary' ] , 'isUnique' => ( bool ) $ index [ 0 ] [ 'index_is_unique' ] , 'name' => $ name , 'columnNames' => ArrayHelper :: getColumn ( $ index , 'column_name' ) , ] ) ; } return $ result ; } 
protected function resolveTableNames ( $ table , $ name ) { $ parts = explode ( '.' , str_replace ( '"' , '' , $ name ) ) ; if ( isset ( $ parts [ 1 ] ) ) { $ table -> schemaName = $ parts [ 0 ] ; $ table -> name = $ parts [ 1 ] ; } else { $ table -> schemaName = $ this -> defaultSchema ; $ table -> name = $ parts [ 0 ] ; } $ table -> fullName = $ table -> schemaName !== $ this -> defaultSchema ? $ table -> schemaName . '.' . $ table -> name : $ table -> name ; } 
protected function findViewNames ( $ schema = '' ) { if ( $ schema === '' ) { $ schema = $ this -> defaultSchema ; } $ sql = <<<'SQL' SELECT c.relname AS table_name FROM pg_class c INNER JOIN pg_namespace ns ON ns.oid = c.relnamespace WHERE ns.nspname = :schemaName AND (c.relkind = 'v' OR c.relkind = 'm') ORDER BY c.relname SQL ; return $ this -> db -> createCommand ( $ sql , [ ':schemaName' => $ schema ] ) -> queryColumn ( ) ; } 
protected function findConstraints ( $ table ) { $ tableName = $ this -> quoteValue ( $ table -> name ) ; $ tableSchema = $ this -> quoteValue ( $ table -> schemaName ) ; select ct.conname as constraint_name, a.attname as column_name, fc.relname as foreign_table_name, fns.nspname as foreign_table_schema, fa.attname as foreign_column_name from (SELECT ct.conname, ct.conrelid, ct.confrelid, ct.conkey, ct.contype, ct.confkey, generate_subscripts(ct.conkey, 1) AS s FROM pg_constraint ct ) AS ct inner join pg_class c on c.oid=ct.conrelid inner join pg_namespace ns on c.relnamespace=ns.oid inner join pg_attribute a on a.attrelid=ct.conrelid and a.attnum = ct.conkey[ct.s] left join pg_class fc on fc.oid=ct.confrelid left join pg_namespace fns on fc.relnamespace=fns.oid left join pg_attribute fa on fa.attrelid=ct.confrelid and fa.attnum = ct.confkey[ct.s] where ct.contype='f' and c.relname={$tableName} and ns.nspname={$tableSchema} order by fns.nspname, fc.relname, a.attnum SQL ; $ constraints = [ ] ; foreach ( $ this -> db -> createCommand ( $ sql ) -> queryAll ( ) as $ constraint ) { if ( $ this -> db -> slavePdo -> getAttribute ( \ PDO :: ATTR_CASE ) === \ PDO :: CASE_UPPER ) { $ constraint = array_change_key_case ( $ constraint , CASE_LOWER ) ; } if ( $ constraint [ 'foreign_table_schema' ] !== $ this -> defaultSchema ) { $ foreignTable = $ constraint [ 'foreign_table_schema' ] . '.' . $ constraint [ 'foreign_table_name' ] ; } else { $ foreignTable = $ constraint [ 'foreign_table_name' ] ; } $ name = $ constraint [ 'constraint_name' ] ; if ( ! isset ( $ constraints [ $ name ] ) ) { $ constraints [ $ name ] = [ 'tableName' => $ foreignTable , 'columns' => [ ] , ] ; } $ constraints [ $ name ] [ 'columns' ] [ $ constraint [ 'column_name' ] ] = $ constraint [ 'foreign_column_name' ] ; } foreach ( $ constraints as $ name => $ constraint ) { $ table -> foreignKeys [ $ name ] = array_merge ( [ $ constraint [ 'tableName' ] ] , $ constraint [ 'columns' ] ) ; } } 
protected function getUniqueIndexInformation ( $ table ) { $ sql = <<<'SQL' SELECT i.relname as indexname, pg_get_indexdef(idx.indexrelid, k + 1, TRUE) AS columnname FROM ( SELECT *, generate_subscripts(indkey, 1) AS k FROM pg_index ) idx INNER JOIN pg_class i ON i.oid = idx.indexrelid INNER JOIN pg_class c ON c.oid = idx.indrelid INNER JOIN pg_namespace ns ON c.relnamespace = ns.oid WHERE idx.indisprimary = FALSE AND idx.indisunique = TRUE AND c.relname = :tableName AND ns.nspname = :schemaName ORDER BY i.relname, k SQL ; return $ this -> db -> createCommand ( $ sql , [ ':schemaName' => $ table -> schemaName , ':tableName' => $ table -> name , ] ) -> queryAll ( ) ; } 
protected function findColumns ( $ table ) { $ tableName = $ this -> db -> quoteValue ( $ table -> name ) ; $ schemaName = $ this -> db -> quoteValue ( $ table -> schemaName ) ; $ sql = <<<SQL SELECT d.nspname AS table_schema, c.relname AS table_name, a.attname AS column_name, COALESCE(td.typname, tb.typname, t.typname) AS data_type, COALESCE(td.typtype, tb.typtype, t.typtype) AS type_type, a.attlen AS character_maximum_length, pg_catalog.col_description(c.oid, a.attnum) AS column_comment, a.atttypmod AS modifier, a.attnotnull = false AS is_nullable, CAST(pg_get_expr(ad.adbin, ad.adrelid) AS varchar) AS column_default, coalesce(pg_get_expr(ad.adbin, ad.adrelid) ~ 'nextval',false) AS is_autoinc, CASE WHEN COALESCE(td.typtype, tb.typtype, t.typtype) = 'e'::char THEN array_to_string((SELECT array_agg(enumlabel) FROM pg_enum WHERE enumtypid = COALESCE(td.oid, tb.oid, a.atttypid))::varchar[], ',') ELSE NULL END AS enum_values, CASE atttypid WHEN 21 THEN 16 WHEN 23 THEN 32 WHEN 20 THEN 64 WHEN 1700 THEN CASE WHEN atttypmod = -1 THEN null ELSE ((atttypmod - 4) >> 16) & 65535 END WHEN 700 THEN 24 WHEN 701 THEN 53 ELSE null END AS numeric_precision, CASE WHEN atttypid IN (21, 23, 20) THEN 0 WHEN atttypid IN (1700) THEN CASE WHEN atttypmod = -1 THEN null ELSE (atttypmod - 4) & 65535 END ELSE null END AS numeric_scale, CAST( information_schema._pg_char_max_length(information_schema._pg_truetypid(a, t), information_schema._pg_truetypmod(a, t)) AS numeric ) AS size, a.attnum = any (ct.conkey) as is_pkey, COALESCE(NULLIF(a.attndims, 0), NULLIF(t.typndims, 0), (t.typcategory='A')::int) AS dimension FROM pg_class c LEFT JOIN pg_attribute a ON a.attrelid = c.oid LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum LEFT JOIN pg_type t ON a.atttypid = t.oid LEFT JOIN pg_type tb ON (a.attndims > 0 OR t.typcategory='A') AND t.typelem > 0 AND t.typelem = tb.oid OR t.typbasetype > 0 AND t.typbasetype = tb.oid LEFT JOIN pg_type td ON t.typndims > 0 AND t.typbasetype > 0 AND tb.typelem = td.oid LEFT JOIN pg_namespace d ON d.oid = c.relnamespace LEFT JOIN pg_constraint ct ON ct.conrelid = c.oid AND ct.contype = 'p' WHERE a.attnum > 0 AND t.typname != '' AND c.relname = {$tableName} AND d.nspname = {$schemaName} ORDER BY a.attnum; SQL ; $ columns = $ this -> db -> createCommand ( $ sql ) -> queryAll ( ) ; if ( empty ( $ columns ) ) { return false ; } foreach ( $ columns as $ column ) { if ( $ this -> db -> slavePdo -> getAttribute ( \ PDO :: ATTR_CASE ) === \ PDO :: CASE_UPPER ) { $ column = array_change_key_case ( $ column , CASE_LOWER ) ; } $ column = $ this -> loadColumnSchema ( $ column ) ; $ table -> columns [ $ column -> name ] = $ column ; if ( $ column -> isPrimaryKey ) { $ table -> primaryKey [ ] = $ column -> name ; if ( $ table -> sequenceName === null && preg_match ( "/nextval\\('\"?\\w+\"?\.?\"?\\w+\"?'(::regclass)?\\)/" , $ column -> defaultValue ) === 1 ) { $ table -> sequenceName = preg_replace ( [ '/nextval/' , '/::/' , '/regclass/' , '/\'\)/' , '/\(\'/' ] , '' , $ column -> defaultValue ) ; } $ column -> defaultValue = null ; } elseif ( $ column -> defaultValue ) { if ( $ column -> type === 'timestamp' && $ column -> defaultValue === 'now()' ) { $ column -> defaultValue = new Expression ( $ column -> defaultValue ) ; } elseif ( $ column -> type === 'boolean' ) { $ column -> defaultValue = ( $ column -> defaultValue === 'true' ) ; } elseif ( strncasecmp ( $ column -> dbType , 'bit' , 3 ) === 0 || strncasecmp ( $ column -> dbType , 'varbit' , 6 ) === 0 ) { $ column -> defaultValue = bindec ( trim ( $ column -> defaultValue , 'B\'' ) ) ; } elseif ( preg_match ( "/^'(.*?)'::/" , $ column -> defaultValue , $ matches ) ) { $ column -> defaultValue = $ column -> phpTypecast ( $ matches [ 1 ] ) ; } elseif ( preg_match ( '/^(\()?(.*?)(?(1)\))(?:::.+)?$/' , $ column -> defaultValue , $ matches ) ) { if ( $ matches [ 2 ] === 'NULL' ) { $ column -> defaultValue = null ; } else { $ column -> defaultValue = $ column -> phpTypecast ( $ matches [ 2 ] ) ; } } else { $ column -> defaultValue = $ column -> phpTypecast ( $ column -> defaultValue ) ; } } } return true ; } 
public function insert ( $ table , $ columns ) { $ params = [ ] ; $ sql = $ this -> db -> getQueryBuilder ( ) -> insert ( $ table , $ columns , $ params ) ; $ returnColumns = $ this -> getTableSchema ( $ table ) -> primaryKey ; if ( ! empty ( $ returnColumns ) ) { $ returning = [ ] ; foreach ( ( array ) $ returnColumns as $ name ) { $ returning [ ] = $ this -> quoteColumnName ( $ name ) ; } $ sql .= ' RETURNING ' . implode ( ', ' , $ returning ) ; } $ command = $ this -> db -> createCommand ( $ sql , $ params ) ; $ command -> prepare ( false ) ; $ result = $ command -> queryOne ( ) ; return ! $ command -> pdoStatement -> rowCount ( ) ? false : $ result ; } 
public function exists ( $ key ) { $ key = $ this -> buildKey ( $ key ) ; return isset ( $ this -> _cache [ $ key ] ) && ( $ this -> _cache [ $ key ] [ 1 ] === 0 || $ this -> _cache [ $ key ] [ 1 ] > microtime ( true ) ) ; } 
protected function getValue ( $ key ) { if ( isset ( $ this -> _cache [ $ key ] ) && ( $ this -> _cache [ $ key ] [ 1 ] === 0 || $ this -> _cache [ $ key ] [ 1 ] > microtime ( true ) ) ) { return $ this -> _cache [ $ key ] [ 0 ] ; } return false ; } 
protected function setValue ( $ key , $ value , $ duration ) { $ this -> _cache [ $ key ] = [ $ value , $ duration === 0 ? 0 : microtime ( true ) + $ duration ] ; return true ; } 
public function events ( ) { return array_fill_keys ( array_reduce ( $ this -> attributes , function ( $ carry , $ item ) { return array_merge ( $ carry , array_keys ( $ item ) ) ; } , [ ] ) , 'evaluateAttributes' ) ; } 
public function evaluateAttributes ( $ event ) { if ( $ this -> skipUpdateOnClean && $ event -> name === ActiveRecord :: EVENT_BEFORE_UPDATE && empty ( $ this -> owner -> dirtyAttributes ) ) { return ; } $ attributes = array_keys ( array_filter ( $ this -> attributes , function ( $ carry ) use ( $ event ) { return array_key_exists ( $ event -> name , $ carry ) ; } ) ) ; if ( ! empty ( $ this -> order [ $ event -> name ] ) ) { $ attributes = array_merge ( array_intersect ( ( array ) $ this -> order [ $ event -> name ] , $ attributes ) , array_diff ( $ attributes , ( array ) $ this -> order [ $ event -> name ] ) ) ; } foreach ( $ attributes as $ attribute ) { if ( $ this -> preserveNonEmptyValues && ! empty ( $ this -> owner -> $ attribute ) ) { continue ; } $ this -> owner -> $ attribute = $ this -> getValue ( $ attribute , $ event ) ; } } 
protected function getValue ( $ attribute , $ event ) { if ( ! isset ( $ this -> attributes [ $ attribute ] [ $ event -> name ] ) ) { return null ; } $ value = $ this -> attributes [ $ attribute ] [ $ event -> name ] ; if ( $ value instanceof Closure || ( is_array ( $ value ) && is_callable ( $ value ) ) ) { return $ value ( $ event , $ attribute ) ; } return $ value ; } 
public function toArray ( array $ fields = [ ] , array $ expand = [ ] , $ recursive = true ) { $ data = [ ] ; foreach ( $ this -> resolveFields ( $ fields , $ expand ) as $ field => $ definition ) { $ attribute = is_string ( $ definition ) ? $ this -> $ definition : $ definition ( $ this , $ field ) ; if ( $ recursive ) { $ nestedFields = $ this -> extractFieldsFor ( $ fields , $ field ) ; $ nestedExpand = $ this -> extractFieldsFor ( $ expand , $ field ) ; if ( $ attribute instanceof Arrayable ) { $ attribute = $ attribute -> toArray ( $ nestedFields , $ nestedExpand ) ; } elseif ( is_array ( $ attribute ) ) { $ attribute = array_map ( function ( $ item ) use ( $ nestedFields , $ nestedExpand ) { if ( $ item instanceof Arrayable ) { return $ item -> toArray ( $ nestedFields , $ nestedExpand ) ; } return $ item ; } , $ attribute ) ; } } $ data [ $ field ] = $ attribute ; } if ( $ this instanceof Linkable ) { $ data [ '_links' ] = Link :: serialize ( $ this -> getLinks ( ) ) ; } return $ recursive ? ArrayHelper :: toArray ( $ data ) : $ data ; } 
protected function extractRootFields ( array $ fields ) { $ result = [ ] ; foreach ( $ fields as $ field ) { $ result [ ] = current ( explode ( '.' , $ field , 2 ) ) ; } if ( in_array ( '*' , $ result , true ) ) { $ result = [ ] ; } return array_unique ( $ result ) ; } 
protected function extractFieldsFor ( array $ fields , $ rootField ) { $ result = [ ] ; foreach ( $ fields as $ field ) { if ( 0 === strpos ( $ field , "{$rootField}." ) ) { $ result [ ] = preg_replace ( '/^' . preg_quote ( $ rootField , '/' ) . '\./i' , '' , $ field ) ; } } return array_unique ( $ result ) ; } 
protected function resolveFields ( array $ fields , array $ expand ) { $ fields = $ this -> extractRootFields ( $ fields ) ; $ expand = $ this -> extractRootFields ( $ expand ) ; $ result = [ ] ; foreach ( $ this -> fields ( ) as $ field => $ definition ) { if ( is_int ( $ field ) ) { $ field = $ definition ; } if ( empty ( $ fields ) || in_array ( $ field , $ fields , true ) ) { $ result [ $ field ] = $ definition ; } } if ( empty ( $ expand ) ) { return $ result ; } foreach ( $ this -> extraFields ( ) as $ field => $ definition ) { if ( is_int ( $ field ) ) { $ field = $ definition ; } if ( in_array ( $ field , $ expand , true ) ) { $ result [ $ field ] = $ definition ; } } return $ result ; } 
public function init ( ) { parent :: init ( ) ; $ this -> itemFile = Yii :: getAlias ( $ this -> itemFile ) ; $ this -> assignmentFile = Yii :: getAlias ( $ this -> assignmentFile ) ; $ this -> ruleFile = Yii :: getAlias ( $ this -> ruleFile ) ; $ this -> load ( ) ; } 
public function checkAccess ( $ userId , $ permissionName , $ params = [ ] ) { $ assignments = $ this -> getAssignments ( $ userId ) ; if ( $ this -> hasNoAssignments ( $ assignments ) ) { return false ; } return $ this -> checkAccessRecursive ( $ userId , $ permissionName , $ params , $ assignments ) ; } 
protected function checkAccessRecursive ( $ user , $ itemName , $ params , $ assignments ) { if ( ! isset ( $ this -> items [ $ itemName ] ) ) { return false ; } $ item = $ this -> items [ $ itemName ] ; Yii :: debug ( $ item instanceof Role ? "Checking role: $itemName" : "Checking permission : $itemName" , __METHOD__ ) ; if ( ! $ this -> executeRule ( $ user , $ item , $ params ) ) { return false ; } if ( isset ( $ assignments [ $ itemName ] ) || in_array ( $ itemName , $ this -> defaultRoles ) ) { return true ; } foreach ( $ this -> children as $ parentName => $ children ) { if ( isset ( $ children [ $ itemName ] ) && $ this -> checkAccessRecursive ( $ user , $ parentName , $ params , $ assignments ) ) { return true ; } } return false ; } 
protected function detectLoop ( $ parent , $ child ) { if ( $ child -> name === $ parent -> name ) { return true ; } if ( ! isset ( $ this -> children [ $ child -> name ] , $ this -> items [ $ parent -> name ] ) ) { return false ; } foreach ( $ this -> children [ $ child -> name ] as $ grandchild ) { if ( $ this -> detectLoop ( $ parent , $ grandchild ) ) { return true ; } } return false ; } 
public function removeChild ( $ parent , $ child ) { if ( isset ( $ this -> children [ $ parent -> name ] [ $ child -> name ] ) ) { unset ( $ this -> children [ $ parent -> name ] [ $ child -> name ] ) ; $ this -> saveItems ( ) ; return true ; } return false ; } 
public function removeChildren ( $ parent ) { if ( isset ( $ this -> children [ $ parent -> name ] ) ) { unset ( $ this -> children [ $ parent -> name ] ) ; $ this -> saveItems ( ) ; return true ; } return false ; } 
public function hasChild ( $ parent , $ child ) { return isset ( $ this -> children [ $ parent -> name ] [ $ child -> name ] ) ; } 
public function revoke ( $ role , $ userId ) { if ( isset ( $ this -> assignments [ $ userId ] [ $ role -> name ] ) ) { unset ( $ this -> assignments [ $ userId ] [ $ role -> name ] ) ; $ this -> saveAssignments ( ) ; return true ; } return false ; } 
public function revokeAll ( $ userId ) { if ( isset ( $ this -> assignments [ $ userId ] ) && is_array ( $ this -> assignments [ $ userId ] ) ) { foreach ( $ this -> assignments [ $ userId ] as $ itemName => $ value ) { unset ( $ this -> assignments [ $ userId ] [ $ itemName ] ) ; } $ this -> saveAssignments ( ) ; return true ; } return false ; } 
public function getAssignment ( $ roleName , $ userId ) { return isset ( $ this -> assignments [ $ userId ] [ $ roleName ] ) ? $ this -> assignments [ $ userId ] [ $ roleName ] : null ; } 
public function removeItem ( $ item ) { if ( isset ( $ this -> items [ $ item -> name ] ) ) { foreach ( $ this -> children as & $ children ) { unset ( $ children [ $ item -> name ] ) ; } foreach ( $ this -> assignments as & $ assignments ) { unset ( $ assignments [ $ item -> name ] ) ; } unset ( $ this -> items [ $ item -> name ] ) ; $ this -> saveItems ( ) ; $ this -> saveAssignments ( ) ; return true ; } return false ; } 
public function getItem ( $ name ) { return isset ( $ this -> items [ $ name ] ) ? $ this -> items [ $ name ] : null ; } 
public function updateRule ( $ name , $ rule ) { if ( $ rule -> name !== $ name ) { unset ( $ this -> rules [ $ name ] ) ; } $ this -> rules [ $ rule -> name ] = $ rule ; $ this -> saveRules ( ) ; return true ; } 
protected function getDirectPermissionsByUser ( $ userId ) { $ permissions = [ ] ; foreach ( $ this -> getAssignments ( $ userId ) as $ name => $ assignment ) { $ permission = $ this -> items [ $ assignment -> roleName ] ; if ( $ permission -> type === Item :: TYPE_PERMISSION ) { $ permissions [ $ name ] = $ permission ; } } return $ permissions ; } 
protected function getInheritedPermissionsByUser ( $ userId ) { $ assignments = $ this -> getAssignments ( $ userId ) ; $ result = [ ] ; foreach ( array_keys ( $ assignments ) as $ roleName ) { $ this -> getChildrenRecursive ( $ roleName , $ result ) ; } if ( empty ( $ result ) ) { return [ ] ; } $ permissions = [ ] ; foreach ( array_keys ( $ result ) as $ itemName ) { if ( isset ( $ this -> items [ $ itemName ] ) && $ this -> items [ $ itemName ] instanceof Permission ) { $ permissions [ $ itemName ] = $ this -> items [ $ itemName ] ; } } return $ permissions ; } 
protected function removeRule ( $ rule ) { if ( isset ( $ this -> rules [ $ rule -> name ] ) ) { unset ( $ this -> rules [ $ rule -> name ] ) ; foreach ( $ this -> items as $ item ) { if ( $ item -> ruleName === $ rule -> name ) { $ item -> ruleName = null ; } } $ this -> saveRules ( ) ; return true ; } return false ; } 
protected function addRule ( $ rule ) { $ this -> rules [ $ rule -> name ] = $ rule ; $ this -> saveRules ( ) ; return true ; } 
protected function updateItem ( $ name , $ item ) { if ( $ name !== $ item -> name ) { if ( isset ( $ this -> items [ $ item -> name ] ) ) { throw new InvalidArgumentException ( "Unable to change the item name. The name '{$item->name}' is already used by another item." ) ; } 
protected function saveToFile ( $ data , $ file ) { file_put_contents ( $ file , "<?php\nreturn " . VarDumper :: export ( $ data ) . ";\n" , LOCK_EX ) ; $ this -> invalidateScriptCache ( $ file ) ; } 
protected function saveItems ( ) { $ items = [ ] ; foreach ( $ this -> items as $ name => $ item ) { $ items [ $ name ] = array_filter ( [ 'type' => $ item -> type , 'description' => $ item -> description , 'ruleName' => $ item -> ruleName , 'data' => $ item -> data , ] ) ; if ( isset ( $ this -> children [ $ name ] ) ) { foreach ( $ this -> children [ $ name ] as $ child ) { $ items [ $ name ] [ 'children' ] [ ] = $ child -> name ; } } } $ this -> saveToFile ( $ items , $ this -> itemFile ) ; } 
protected function saveAssignments ( ) { $ assignmentData = [ ] ; foreach ( $ this -> assignments as $ userId => $ assignments ) { foreach ( $ assignments as $ name => $ assignment ) { $ assignmentData [ $ userId ] [ ] = $ assignment -> roleName ; } } $ this -> saveToFile ( $ assignmentData , $ this -> assignmentFile ) ; } 
protected function saveRules ( ) { $ rules = [ ] ; foreach ( $ this -> rules as $ name => $ rule ) { $ rules [ $ name ] = serialize ( $ rule ) ; } $ this -> saveToFile ( $ rules , $ this -> ruleFile ) ; } 
public function getUserIdsByRole ( $ roleName ) { $ result = [ ] ; foreach ( $ this -> assignments as $ userID => $ assignments ) { foreach ( $ assignments as $ userAssignment ) { if ( $ userAssignment -> roleName === $ roleName && $ userAssignment -> userId == $ userID ) { $ result [ ] = ( string ) $ userID ; } } } return $ result ; } 
public function beforeRun ( $ event ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ fragmentCacheConfiguration = $ this -> getFragmentCacheConfiguration ( ) ; if ( ! $ this -> owner -> view -> beginCache ( $ cacheKey , $ fragmentCacheConfiguration ) ) { $ event -> isValid = false ; } } 
public function afterRun ( $ event ) { echo $ event -> result ; $ event -> result = null ; $ this -> owner -> view -> endCache ( ) ; } 
private function initializeEventHandlers ( ) { $ this -> owner -> on ( Widget :: EVENT_BEFORE_RUN , [ $ this , 'beforeRun' ] ) ; $ this -> owner -> on ( Widget :: EVENT_AFTER_RUN , [ $ this , 'afterRun' ] ) ; } 
private function getFragmentCacheConfiguration ( ) { $ cache = $ this -> getCacheInstance ( ) ; $ fragmentCacheConfiguration = [ 'cache' => $ cache , 'duration' => $ this -> cacheDuration , 'dependency' => $ this -> cacheDependency , 'enabled' => $ this -> cacheEnabled , ] ; return $ fragmentCacheConfiguration ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> view === null ) { $ this -> view = Yii :: $ app -> getView ( ) ; } } 
public function beforeAction ( $ action ) { if ( ! $ this -> enabled ) { return true ; } $ this -> cache = Instance :: ensure ( $ this -> cache , 'yii\caching\CacheInterface' ) ; if ( is_array ( $ this -> dependency ) ) { $ this -> dependency = Yii :: createObject ( $ this -> dependency ) ; } $ response = Yii :: $ app -> getResponse ( ) ; $ data = $ this -> cache -> get ( $ this -> calculateCacheKey ( ) ) ; if ( ! is_array ( $ data ) || ! isset ( $ data [ 'cacheVersion' ] ) || $ data [ 'cacheVersion' ] !== static :: PAGE_CACHE_VERSION ) { $ this -> view -> pushDynamicContent ( $ this ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; $ response -> on ( Response :: EVENT_AFTER_SEND , [ $ this , 'cacheResponse' ] ) ; Yii :: debug ( 'Valid page content is not found in the cache.' , __METHOD__ ) ; return true ; } $ this -> restoreResponse ( $ response , $ data ) ; Yii :: debug ( 'Valid page content is found in the cache.' , __METHOD__ ) ; return false ; } 
public function cacheResponse ( ) { $ this -> view -> popDynamicContent ( ) ; $ beforeCacheResponseResult = $ this -> beforeCacheResponse ( ) ; if ( $ beforeCacheResponseResult === false ) { echo $ this -> updateDynamicContent ( ob_get_clean ( ) , $ this -> getDynamicPlaceholders ( ) ) ; return ; } $ response = Yii :: $ app -> getResponse ( ) ; $ response -> off ( Response :: EVENT_AFTER_SEND , [ $ this , 'cacheResponse' ] ) ; $ data = [ 'cacheVersion' => static :: PAGE_CACHE_VERSION , 'cacheData' => is_array ( $ beforeCacheResponseResult ) ? $ beforeCacheResponseResult : null , 'content' => ob_get_clean ( ) , ] ; if ( $ data [ 'content' ] === false || $ data [ 'content' ] === '' ) { return ; } $ data [ 'dynamicPlaceholders' ] = $ this -> getDynamicPlaceholders ( ) ; foreach ( [ 'format' , 'version' , 'statusCode' , 'statusText' ] as $ name ) { $ data [ $ name ] = $ response -> { $ name } ; } $ this -> insertResponseCollectionIntoData ( $ response , 'headers' , $ data ) ; $ this -> insertResponseCollectionIntoData ( $ response , 'cookies' , $ data ) ; $ this -> cache -> set ( $ this -> calculateCacheKey ( ) , $ data , $ this -> duration , $ this -> dependency ) ; $ data [ 'content' ] = $ this -> updateDynamicContent ( $ data [ 'content' ] , $ this -> getDynamicPlaceholders ( ) ) ; echo $ data [ 'content' ] ; } 
protected function validateValue ( $ value ) { $ captcha = $ this -> createCaptchaAction ( ) ; $ valid = ! is_array ( $ value ) && $ captcha -> validate ( $ value , $ this -> caseSensitive ) ; return $ valid ? null : [ $ this -> message , [ ] ] ; } 
public function createCaptchaAction ( ) { $ ca = Yii :: $ app -> createController ( $ this -> captchaAction ) ; if ( $ ca !== false ) { list ( $ controller , $ actionID ) = $ ca ; $ action = $ controller -> createAction ( $ actionID ) ; if ( $ action !== null ) { return $ action ; } } throw new InvalidConfigException ( 'Invalid CAPTCHA action ID: ' . $ this -> captchaAction ) ; } 
public function getClientOptions ( $ model , $ attribute ) { $ captcha = $ this -> createCaptchaAction ( ) ; $ code = $ captcha -> getVerifyCode ( false ) ; $ hash = $ captcha -> generateValidationHash ( $ this -> caseSensitive ? $ code : strtolower ( $ code ) ) ; $ options = [ 'hash' => $ hash , 'hashKey' => 'yiiCaptcha/' . $ captcha -> getUniqueId ( ) , 'caseSensitive' => $ this -> caseSensitive , 'message' => Yii :: $ app -> getI18n ( ) -> format ( $ this -> message , [ 'attribute' => $ model -> getAttributeLabel ( $ attribute ) , ] , Yii :: $ app -> language ) , ] ; if ( $ this -> skipOnEmpty ) { $ options [ 'skipOnEmpty' ] = 1 ; } return $ options ; } 
public function unsigned ( ) { switch ( $ this -> type ) { case Schema :: TYPE_PK : $ this -> type = Schema :: TYPE_UPK ; break ; case Schema :: TYPE_BIGPK : $ this -> type = Schema :: TYPE_UBIGPK ; break ; } $ this -> isUnsigned = true ; return $ this ; } 
protected function buildLengthString ( ) { if ( $ this -> length === null || $ this -> length === [ ] ) { return '' ; } if ( is_array ( $ this -> length ) ) { $ this -> length = implode ( ',' , $ this -> length ) ; } return "({$this->length})" ; } 
protected function buildDefaultString ( ) { if ( $ this -> default === null ) { return $ this -> isNotNull === false ? ' DEFAULT NULL' : '' ; } $ string = ' DEFAULT ' ; switch ( gettype ( $ this -> default ) ) { case 'integer' : $ string .= ( string ) $ this -> default ; break ; case 'double' : 
protected function getTypeCategory ( ) { return isset ( $ this -> categoryMap [ $ this -> type ] ) ? $ this -> categoryMap [ $ this -> type ] : null ; } 
protected function buildCompleteString ( $ format ) { $ placeholderValues = [ '{type}' => $ this -> type , '{length}' => $ this -> buildLengthString ( ) , '{unsigned}' => $ this -> buildUnsignedString ( ) , '{notnull}' => $ this -> buildNotNullString ( ) , '{unique}' => $ this -> buildUniqueString ( ) , '{default}' => $ this -> buildDefaultString ( ) , '{check}' => $ this -> buildCheckString ( ) , '{comment}' => $ this -> buildCommentString ( ) , '{pos}' => $ this -> isFirst ? $ this -> buildFirstString ( ) : $ this -> buildAfterString ( ) , '{append}' => $ this -> buildAppendString ( ) , ] ; return strtr ( $ format , $ placeholderValues ) ; } 
public function load ( $ filePath , $ context ) { $ pattern = '/(msgctxt\s+"(.*?(?<!\\\\))")?\s+' 
public function save ( $ filePath , $ messages ) { $ language = str_replace ( '-' , '_' , basename ( dirname ( $ filePath ) ) ) ; $ headers = [ 'msgid ""' , 'msgstr ""' , '"Project-Id-Version: \n"' , '"POT-Creation-Date: \n"' , '"PO-Revision-Date: \n"' , '"Last-Translator: \n"' , '"Language-Team: \n"' , '"Language: ' . $ language . '\n"' , '"MIME-Version: 1.0\n"' , '"Content-Type: text/plain; charset=' . Yii :: $ app -> charset . '\n"' , '"Content-Transfer-Encoding: 8bit\n"' , ] ; $ content = implode ( "\n" , $ headers ) . "\n\n" ; foreach ( $ messages as $ id => $ message ) { $ separatorPosition = strpos ( $ id , chr ( 4 ) ) ; if ( $ separatorPosition !== false ) { $ content .= 'msgctxt "' . substr ( $ id , 0 , $ separatorPosition ) . "\"\n" ; $ id = substr ( $ id , $ separatorPosition + 1 ) ; } $ content .= 'msgid "' . $ this -> encode ( $ id ) . "\"\n" ; $ content .= 'msgstr "' . $ this -> encode ( $ message ) . "\"\n\n" ; } file_put_contents ( $ filePath , $ content ) ; } 
public function init ( ) { parent :: init ( ) ; if ( empty ( $ this -> attributes ) ) { $ this -> attributes = [ BaseActiveRecord :: EVENT_BEFORE_VALIDATE => $ this -> slugAttribute ] ; } if ( $ this -> attribute === null && $ this -> value === null ) { throw new InvalidConfigException ( 'Either "attribute" or "value" property must be specified.' ) ; } } 
protected function getValue ( $ event ) { if ( ! $ this -> isNewSlugNeeded ( ) ) { return $ this -> owner -> { $ this -> slugAttribute } ; } if ( $ this -> attribute !== null ) { $ slugParts = [ ] ; foreach ( ( array ) $ this -> attribute as $ attribute ) { $ part = ArrayHelper :: getValue ( $ this -> owner , $ attribute ) ; if ( $ this -> skipOnEmpty && $ this -> isEmpty ( $ part ) ) { return $ this -> owner -> { $ this -> slugAttribute } ; } $ slugParts [ ] = $ part ; } $ slug = $ this -> generateSlug ( $ slugParts ) ; } else { $ slug = parent :: getValue ( $ event ) ; } return $ this -> ensureUnique ? $ this -> makeUnique ( $ slug ) : $ slug ; } 
protected function isNewSlugNeeded ( ) { if ( empty ( $ this -> owner -> { $ this -> slugAttribute } ) ) { return true ; } if ( $ this -> immutable ) { return false ; } if ( $ this -> attribute === null ) { return true ; } foreach ( ( array ) $ this -> attribute as $ attribute ) { if ( $ this -> owner -> isAttributeChanged ( $ attribute ) ) { return true ; } } return false ; } 
protected function makeUnique ( $ slug ) { $ uniqueSlug = $ slug ; $ iteration = 0 ; while ( ! $ this -> validateSlug ( $ uniqueSlug ) ) { $ iteration ++ ; $ uniqueSlug = $ this -> generateUniqueSlug ( $ slug , $ iteration ) ; } return $ uniqueSlug ; } 
protected function validateSlug ( $ slug ) { $ validator = Yii :: createObject ( array_merge ( [ 'class' => UniqueValidator :: className ( ) , ] , $ this -> uniqueValidator ) ) ; $ model = clone $ this -> owner ; $ model -> clearErrors ( ) ; $ model -> { $ this -> slugAttribute } = $ slug ; $ validator -> validateAttribute ( $ model , $ this -> slugAttribute ) ; return ! $ model -> hasErrors ( ) ; } 
public function addRateLimitHeaders ( $ response , $ limit , $ remaining , $ reset ) { if ( $ this -> enableRateLimitHeaders ) { $ response -> getHeaders ( ) -> set ( 'X-Rate-Limit-Limit' , $ limit ) -> set ( 'X-Rate-Limit-Remaining' , $ remaining ) -> set ( 'X-Rate-Limit-Reset' , $ reset ) ; } } 
public function init ( ) { $ this -> fontFile = Yii :: getAlias ( $ this -> fontFile ) ; if ( ! is_file ( $ this -> fontFile ) ) { throw new InvalidConfigException ( "The font file does not exist: {$this->fontFile}" ) ; } } 
public function run ( ) { if ( Yii :: $ app -> request -> getQueryParam ( self :: REFRESH_GET_VAR ) !== null ) { 
public function validate ( $ input , $ caseSensitive ) { $ code = $ this -> getVerifyCode ( ) ; $ valid = $ caseSensitive ? ( $ input === $ code ) : strcasecmp ( $ input , $ code ) === 0 ; $ session = Yii :: $ app -> getSession ( ) ; $ session -> open ( ) ; $ name = $ this -> getSessionKey ( ) . 'count' ; $ session [ $ name ] += 1 ; if ( $ valid || $ session [ $ name ] > $ this -> testLimit && $ this -> testLimit > 0 ) { $ this -> getVerifyCode ( true ) ; } return $ valid ; } 
protected function renderImage ( $ code ) { if ( isset ( $ this -> imageLibrary ) ) { $ imageLibrary = $ this -> imageLibrary ; } else { $ imageLibrary = Captcha :: checkRequirements ( ) ; } if ( $ imageLibrary === 'gd' ) { return $ this -> renderImageByGD ( $ code ) ; } elseif ( $ imageLibrary === 'imagick' ) { return $ this -> renderImageByImagick ( $ code ) ; } throw new InvalidConfigException ( "Defined library '{$imageLibrary}' is not supported" ) ; } 
protected function renderImageByGD ( $ code ) { $ image = imagecreatetruecolor ( $ this -> width , $ this -> height ) ; $ backColor = imagecolorallocate ( $ image , ( int ) ( $ this -> backColor % 0x1000000 / 0x10000 ) , ( int ) ( $ this -> backColor % 0x10000 / 0x100 ) , $ this -> backColor % 0x100 ) ; imagefilledrectangle ( $ image , 0 , 0 , $ this -> width - 1 , $ this -> height - 1 , $ backColor ) ; imagecolordeallocate ( $ image , $ backColor ) ; if ( $ this -> transparent ) { imagecolortransparent ( $ image , $ backColor ) ; } $ foreColor = imagecolorallocate ( $ image , ( int ) ( $ this -> foreColor % 0x1000000 / 0x10000 ) , ( int ) ( $ this -> foreColor % 0x10000 / 0x100 ) , $ this -> foreColor % 0x100 ) ; $ length = strlen ( $ code ) ; $ box = imagettfbbox ( 30 , 0 , $ this -> fontFile , $ code ) ; $ w = $ box [ 4 ] - $ box [ 0 ] + $ this -> offset * ( $ length - 1 ) ; $ h = $ box [ 1 ] - $ box [ 5 ] ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ fontSize = ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ; $ angle = mt_rand ( - 10 , 10 ) ; $ letter = $ code [ $ i ] ; $ box = imagettftext ( $ image , $ fontSize , $ angle , $ x , $ y , $ foreColor , $ this -> fontFile , $ letter ) ; $ x = $ box [ 2 ] + $ this -> offset ; } imagecolordeallocate ( $ image , $ foreColor ) ; ob_start ( ) ; imagepng ( $ image ) ; imagedestroy ( $ image ) ; return ob_get_clean ( ) ; } 
protected function renderImageByImagick ( $ code ) { $ backColor = $ this -> transparent ? new \ ImagickPixel ( 'transparent' ) : new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> backColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ foreColor = new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> foreColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ image = new \ Imagick ( ) ; $ image -> newImage ( $ this -> width , $ this -> height , $ backColor ) ; $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( 30 ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code ) ; $ length = strlen ( $ code ) ; $ w = ( int ) $ fontMetrics [ 'textWidth' ] - 8 + $ this -> offset * ( $ length - 1 ) ; $ h = ( int ) $ fontMetrics [ 'textHeight' ] - 8 ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ) ; $ draw -> setFillColor ( $ foreColor ) ; $ image -> annotateImage ( $ draw , $ x , $ y , mt_rand ( - 10 , 10 ) , $ code [ $ i ] ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code [ $ i ] ) ; $ x += ( int ) $ fontMetrics [ 'textWidth' ] + $ this -> offset ; } $ image -> setImageFormat ( 'png' ) ; return $ image -> getImageBlob ( ) ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> sourceLanguage === null ) { $ this -> sourceLanguage = Yii :: $ app -> sourceLanguage ; } } 
protected function translateMessage ( $ category , $ message , $ language ) { $ key = $ language . '/' . $ category ; if ( ! isset ( $ this -> _messages [ $ key ] ) ) { $ this -> _messages [ $ key ] = $ this -> loadMessages ( $ category , $ language ) ; } if ( isset ( $ this -> _messages [ $ key ] [ $ message ] ) && $ this -> _messages [ $ key ] [ $ message ] !== '' ) { return $ this -> _messages [ $ key ] [ $ message ] ; } elseif ( $ this -> hasEventHandlers ( self :: EVENT_MISSING_TRANSLATION ) ) { $ event = new MissingTranslationEvent ( [ 'category' => $ category , 'message' => $ message , 'language' => $ language , ] ) ; $ this -> trigger ( self :: EVENT_MISSING_TRANSLATION , $ event ) ; if ( $ event -> translatedMessage !== null ) { return $ this -> _messages [ $ key ] [ $ message ] = $ event -> translatedMessage ; } } return $ this -> _messages [ $ key ] [ $ message ] = false ; } 
public function offsetGet ( $ offset ) { $ offset = $ this -> calculateOffset ( $ offset ) ; return isset ( $ this -> _children [ $ offset ] ) ? $ this -> _children [ $ offset ] : null ; } 
public function offsetSet ( $ offset , $ token ) { $ token -> parent = $ this ; if ( $ offset === null ) { $ this -> _children [ ] = $ token ; } else { $ this -> _children [ $ this -> calculateOffset ( $ offset ) ] = $ token ; } $ this -> updateCollectionOffsets ( ) ; } 
public function offsetUnset ( $ offset ) { $ offset = $ this -> calculateOffset ( $ offset ) ; if ( isset ( $ this -> _children [ $ offset ] ) ) { array_splice ( $ this -> _children , $ offset , 1 ) ; } $ this -> updateCollectionOffsets ( ) ; } 
public function setChildren ( $ children ) { $ this -> _children = [ ] ; foreach ( $ children as $ child ) { $ child -> parent = $ this ; $ this -> _children [ ] = $ child ; } $ this -> updateCollectionOffsets ( ) ; } 
public function getIsCollection ( ) { return in_array ( $ this -> type , [ self :: TYPE_CODE , self :: TYPE_STATEMENT , self :: TYPE_PARENTHESIS , ] , true ) ; } 
public function getSql ( ) { $ code = $ this ; while ( $ code -> parent !== null ) { $ code = $ code -> parent ; } return mb_substr ( $ code -> content , $ this -> startOffset , $ this -> endOffset - $ this -> startOffset , 'UTF-8' ) ; } 
public function matches ( SqlToken $ patternToken , $ offset = 0 , & $ firstMatchIndex = null , & $ lastMatchIndex = null ) { if ( ! $ patternToken -> getHasChildren ( ) ) { return false ; } $ patternToken = $ patternToken [ 0 ] ; return $ this -> tokensMatch ( $ patternToken , $ this , $ offset , $ firstMatchIndex , $ lastMatchIndex ) ; } 
private function tokensMatch ( SqlToken $ patternToken , SqlToken $ token , $ offset = 0 , & $ firstMatchIndex = null , & $ lastMatchIndex = null ) { if ( $ patternToken -> getIsCollection ( ) !== $ token -> getIsCollection ( ) || ( ! $ patternToken -> getIsCollection ( ) && $ patternToken -> content !== $ token -> content ) ) { return false ; } if ( $ patternToken -> children === $ token -> children ) { $ firstMatchIndex = $ lastMatchIndex = $ offset ; return true ; } $ firstMatchIndex = $ lastMatchIndex = null ; $ wildcard = false ; for ( $ index = 0 , $ count = count ( $ patternToken -> children ) ; $ index < $ count ; $ index ++ ) { 
private function updateCollectionOffsets ( ) { if ( ! empty ( $ this -> _children ) ) { $ this -> startOffset = reset ( $ this -> _children ) -> startOffset ; $ this -> endOffset = end ( $ this -> _children ) -> endOffset ; } if ( $ this -> parent !== null ) { $ this -> parent -> updateCollectionOffsets ( ) ; } } 
public function execute ( ) { $ sql = $ this -> getSql ( ) ; $ params = $ this -> params ; $ statements = $ this -> splitStatements ( $ sql , $ params ) ; if ( $ statements === false ) { return parent :: execute ( ) ; } $ result = null ; foreach ( $ statements as $ statement ) { list ( $ statementSql , $ statementParams ) = $ statement ; $ this -> setSql ( $ statementSql ) -> bindValues ( $ statementParams ) ; $ result = parent :: execute ( ) ; } $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; return $ result ; } 
protected function queryInternal ( $ method , $ fetchMode = null ) { $ sql = $ this -> getSql ( ) ; $ params = $ this -> params ; $ statements = $ this -> splitStatements ( $ sql , $ params ) ; if ( $ statements === false ) { return parent :: queryInternal ( $ method , $ fetchMode ) ; } list ( $ lastStatementSql , $ lastStatementParams ) = array_pop ( $ statements ) ; foreach ( $ statements as $ statement ) { list ( $ statementSql , $ statementParams ) = $ statement ; $ this -> setSql ( $ statementSql ) -> bindValues ( $ statementParams ) ; parent :: execute ( ) ; } $ this -> setSql ( $ lastStatementSql ) -> bindValues ( $ lastStatementParams ) ; $ result = parent :: queryInternal ( $ method , $ fetchMode ) ; $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; return $ result ; } 
private function splitStatements ( $ sql , $ params ) { $ semicolonIndex = strpos ( $ sql , ';' ) ; if ( $ semicolonIndex === false || $ semicolonIndex === StringHelper :: byteLength ( $ sql ) - 1 ) { return false ; } $ tokenizer = new SqlTokenizer ( $ sql ) ; $ codeToken = $ tokenizer -> tokenize ( ) ; if ( count ( $ codeToken -> getChildren ( ) ) === 1 ) { return false ; } $ statements = [ ] ; foreach ( $ codeToken -> getChildren ( ) as $ statement ) { $ statements [ ] = [ $ statement -> getSql ( ) , $ this -> extractUsedParams ( $ statement , $ params ) ] ; } return $ statements ; } 
private function extractUsedParams ( SqlToken $ statement , $ params ) { preg_match_all ( '/(?P<placeholder>[:][a-zA-Z0-9_]+)/' , $ statement -> getSql ( ) , $ matches , PREG_SET_ORDER ) ; $ result = [ ] ; foreach ( $ matches as $ match ) { $ phName = ltrim ( $ match [ 'placeholder' ] , ':' ) ; if ( isset ( $ params [ $ phName ] ) ) { $ result [ $ phName ] = $ params [ $ phName ] ; } elseif ( isset ( $ params [ ':' . $ phName ] ) ) { $ result [ ':' . $ phName ] = $ params [ ':' . $ phName ] ; } } return $ result ; } 
public function init ( ) { parent :: init ( ) ; if ( $ this -> identityClass === null ) { throw new InvalidConfigException ( 'User::identityClass must be set.' ) ; } if ( $ this -> enableAutoLogin && ! isset ( $ this -> identityCookie [ 'name' ] ) ) { throw new InvalidConfigException ( 'User::identityCookie must contain the "name" element.' ) ; } if ( ! empty ( $ this -> accessChecker ) && is_string ( $ this -> accessChecker ) ) { $ this -> accessChecker = Yii :: createObject ( $ this -> accessChecker ) ; } } 
public function getIdentity ( $ autoRenew = true ) { if ( $ this -> _identity === false ) { if ( $ this -> enableSession && $ autoRenew ) { try { $ this -> _identity = null ; $ this -> renewAuthStatus ( ) ; } catch ( \ Exception $ e ) { $ this -> _identity = false ; throw $ e ; } catch ( \ Throwable $ e ) { $ this -> _identity = false ; throw $ e ; } } else { return null ; } } return $ this -> _identity ; } 
public function setIdentity ( $ identity ) { if ( $ identity instanceof IdentityInterface ) { $ this -> _identity = $ identity ; } elseif ( $ identity === null ) { $ this -> _identity = null ; } else { throw new InvalidValueException ( 'The identity object must implement IdentityInterface.' ) ; } $ this -> _access = [ ] ; } 
public function login ( IdentityInterface $ identity , $ duration = 0 ) { if ( $ this -> beforeLogin ( $ identity , false , $ duration ) ) { $ this -> switchIdentity ( $ identity , $ duration ) ; $ id = $ identity -> getId ( ) ; $ ip = Yii :: $ app -> getRequest ( ) -> getUserIP ( ) ; if ( $ this -> enableSession ) { $ log = "User '$id' logged in from $ip with duration $duration." ; } else { $ log = "User '$id' logged in from $ip. Session not enabled." ; } $ this -> regenerateCsrfToken ( ) ; Yii :: info ( $ log , __METHOD__ ) ; $ this -> afterLogin ( $ identity , false , $ duration ) ; } return ! $ this -> getIsGuest ( ) ; } 
protected function regenerateCsrfToken ( ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ request -> enableCsrfCookie || $ this -> enableSession ) { $ request -> getCsrfToken ( true ) ; } } 
protected function beforeLogin ( $ identity , $ cookieBased , $ duration ) { $ event = new UserEvent ( [ 'identity' => $ identity , 'cookieBased' => $ cookieBased , 'duration' => $ duration , ] ) ; $ this -> trigger ( self :: EVENT_BEFORE_LOGIN , $ event ) ; return $ event -> isValid ; } 
protected function afterLogin ( $ identity , $ cookieBased , $ duration ) { $ this -> trigger ( self :: EVENT_AFTER_LOGIN , new UserEvent ( [ 'identity' => $ identity , 'cookieBased' => $ cookieBased , 'duration' => $ duration , ] ) ) ; } 
protected function beforeLogout ( $ identity ) { $ event = new UserEvent ( [ 'identity' => $ identity , ] ) ; $ this -> trigger ( self :: EVENT_BEFORE_LOGOUT , $ event ) ; return $ event -> isValid ; } 
protected function removeIdentityCookie ( ) { Yii :: $ app -> getResponse ( ) -> getCookies ( ) -> remove ( Yii :: createObject ( array_merge ( $ this -> identityCookie , [ 'class' => 'yii\web\Cookie' , ] ) ) ) ; } 
public function can ( $ permissionName , $ params = [ ] , $ allowCaching = true ) { if ( $ allowCaching && empty ( $ params ) && isset ( $ this -> _access [ $ permissionName ] ) ) { return $ this -> _access [ $ permissionName ] ; } if ( ( $ accessChecker = $ this -> getAccessChecker ( ) ) === null ) { return false ; } $ access = $ accessChecker -> checkAccess ( $ this -> getId ( ) , $ permissionName , $ params ) ; if ( $ allowCaching && empty ( $ params ) ) { $ this -> _access [ $ permissionName ] = $ access ; } return $ access ; } 
protected function checkRedirectAcceptable ( ) { $ acceptableTypes = Yii :: $ app -> getRequest ( ) -> getAcceptableContentTypes ( ) ; if ( empty ( $ acceptableTypes ) || count ( $ acceptableTypes ) === 1 && array_keys ( $ acceptableTypes ) [ 0 ] === '*/*' ) { return true ; } foreach ( $ acceptableTypes as $ type => $ params ) { if ( in_array ( $ type , $ this -> acceptableRedirectTypes , true ) ) { return true ; } } return false ; } 
public static function isFatalError ( $ error ) { return isset ( $ error [ 'type' ] ) && in_array ( $ error [ 'type' ] , [ E_ERROR , E_PARSE , E_CORE_ERROR , E_CORE_WARNING , E_COMPILE_ERROR , E_COMPILE_WARNING , self :: E_HHVM_FATAL_ERROR ] ) ; } 
public function getIterator ( ) { $ value = $ this -> getValue ( ) ; if ( $ value instanceof QueryInterface ) { throw new InvalidConfigException ( 'The ArrayExpression class can not be iterated when the value is a QueryInterface object' ) ; } if ( $ value === null ) { $ value = [ ] ; } return new \ ArrayIterator ( $ value ) ; } 
public function actionConfig ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; $ dir = dirname ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } $ array = VarDumper :: export ( $ this -> getOptionValues ( $ this -> action -> id ) ) ; $ content = <<<EOD <?php return $array; EOD ; if ( FileHelper :: createDirectory ( $ dir ) === false || file_put_contents ( $ filePath , $ content , LOCK_EX ) === false ) { $ this -> stdout ( "Configuration file was NOT created: '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file created: '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; } 
public function actionConfigTemplate ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } if ( ! copy ( Yii :: getAlias ( '@yii/views/messageConfig.php' ) , $ filePath ) ) { $ this -> stdout ( "Configuration file template was NOT created at '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file template created at '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; } 
public function actionExtract ( $ configFile = null ) { $ this -> initConfig ( $ configFile ) ; $ files = FileHelper :: findFiles ( realpath ( $ this -> config [ 'sourcePath' ] ) , $ this -> config ) ; $ messages = [ ] ; foreach ( $ files as $ file ) { $ messages = array_merge_recursive ( $ messages , $ this -> extractMessages ( $ file , $ this -> config [ 'translator' ] , $ this -> config [ 'ignoreCategories' ] ) ) ; } $ catalog = isset ( $ this -> config [ 'catalog' ] ) ? $ this -> config [ 'catalog' ] : 'messages' ; if ( in_array ( $ this -> config [ 'format' ] , [ 'php' , 'po' ] ) ) { foreach ( $ this -> config [ 'languages' ] as $ language ) { $ dir = $ this -> config [ 'messagePath' ] . DIRECTORY_SEPARATOR . $ language ; if ( ! is_dir ( $ dir ) && ! @ mkdir ( $ dir ) ) { throw new Exception ( "Directory '{$dir}' can not be created." ) ; } if ( $ this -> config [ 'format' ] === 'po' ) { $ this -> saveMessagesToPO ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ catalog , $ this -> config [ 'markUnused' ] ) ; } else { $ this -> saveMessagesToPHP ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ this -> config [ 'markUnused' ] ) ; } } } elseif ( $ this -> config [ 'format' ] === 'db' ) { $ db = Instance :: ensure ( $ this -> config [ 'db' ] , Connection :: className ( ) ) ; $ sourceMessageTable = isset ( $ this -> config [ 'sourceMessageTable' ] ) ? $ this -> config [ 'sourceMessageTable' ] : '{{%source_message}}' ; $ messageTable = isset ( $ this -> config [ 'messageTable' ] ) ? $ this -> config [ 'messageTable' ] : '{{%message}}' ; $ this -> saveMessagesToDb ( $ messages , $ db , $ sourceMessageTable , $ messageTable , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'languages' ] , $ this -> config [ 'markUnused' ] ) ; } elseif ( $ this -> config [ 'format' ] === 'pot' ) { $ this -> saveMessagesToPOT ( $ messages , $ this -> config [ 'messagePath' ] , $ catalog ) ; } } 
protected function saveMessagesToDb ( $ messages , $ db , $ sourceMessageTable , $ messageTable , $ removeUnused , $ languages , $ markUnused ) { $ currentMessages = [ ] ; $ rows = ( new Query ( ) ) -> select ( [ 'id' , 'category' , 'message' ] ) -> from ( $ sourceMessageTable ) -> all ( $ db ) ; foreach ( $ rows as $ row ) { $ currentMessages [ $ row [ 'category' ] ] [ $ row [ 'id' ] ] = $ row [ 'message' ] ; } $ currentLanguages = [ ] ; $ rows = ( new Query ( ) ) -> select ( [ 'language' ] ) -> from ( $ messageTable ) -> groupBy ( 'language' ) -> all ( $ db ) ; foreach ( $ rows as $ row ) { $ currentLanguages [ ] = $ row [ 'language' ] ; } $ missingLanguages = [ ] ; if ( ! empty ( $ currentLanguages ) ) { $ missingLanguages = array_diff ( $ languages , $ currentLanguages ) ; } $ new = [ ] ; $ obsolete = [ ] ; foreach ( $ messages as $ category => $ msgs ) { $ msgs = array_unique ( $ msgs ) ; if ( isset ( $ currentMessages [ $ category ] ) ) { $ new [ $ category ] = array_diff ( $ msgs , $ currentMessages [ $ category ] ) ; $ obsolete += array_diff ( $ currentMessages [ $ category ] , $ msgs ) ; } else { $ new [ $ category ] = $ msgs ; } } foreach ( array_diff ( array_keys ( $ currentMessages ) , array_keys ( $ messages ) ) as $ category ) { $ obsolete += $ currentMessages [ $ category ] ; } if ( ! $ removeUnused ) { foreach ( $ obsolete as $ pk => $ msg ) { if ( mb_substr ( $ msg , 0 , 2 ) === '@@' && mb_substr ( $ msg , - 2 ) === '@@' ) { unset ( $ obsolete [ $ pk ] ) ; } } } $ obsolete = array_keys ( $ obsolete ) ; $ this -> stdout ( 'Inserting new messages...' ) ; $ savedFlag = false ; foreach ( $ new as $ category => $ msgs ) { foreach ( $ msgs as $ msg ) { $ savedFlag = true ; $ lastPk = $ db -> schema -> insert ( $ sourceMessageTable , [ 'category' => $ category , 'message' => $ msg ] ) ; foreach ( $ languages as $ language ) { $ db -> createCommand ( ) -> insert ( $ messageTable , [ 'id' => $ lastPk [ 'id' ] , 'language' => $ language ] ) -> execute ( ) ; } } } if ( ! empty ( $ missingLanguages ) ) { $ updatedMessages = [ ] ; $ rows = ( new Query ( ) ) -> select ( [ 'id' , 'category' , 'message' ] ) -> from ( $ sourceMessageTable ) -> all ( $ db ) ; foreach ( $ rows as $ row ) { $ updatedMessages [ $ row [ 'category' ] ] [ $ row [ 'id' ] ] = $ row [ 'message' ] ; } foreach ( $ updatedMessages as $ category => $ msgs ) { foreach ( $ msgs as $ id => $ msg ) { $ savedFlag = true ; foreach ( $ missingLanguages as $ language ) { $ db -> createCommand ( ) -> insert ( $ messageTable , [ 'id' => $ id , 'language' => $ language ] ) -> execute ( ) ; } } } } $ this -> stdout ( $ savedFlag ? "saved.\n" : "Nothing to save.\n" ) ; $ this -> stdout ( $ removeUnused ? 'Deleting obsoleted messages...' : 'Updating obsoleted messages...' ) ; if ( empty ( $ obsolete ) ) { $ this -> stdout ( "Nothing obsoleted...skipped.\n" ) ; return ; } if ( $ removeUnused ) { $ db -> createCommand ( ) -> delete ( $ sourceMessageTable , [ 'in' , 'id' , $ obsolete ] ) -> execute ( ) ; $ this -> stdout ( "deleted.\n" ) ; } elseif ( $ markUnused ) { $ rows = ( new Query ( ) ) -> select ( [ 'id' , 'message' ] ) -> from ( $ sourceMessageTable ) -> where ( [ 'in' , 'id' , $ obsolete ] ) -> all ( $ db ) ; foreach ( $ rows as $ row ) { $ db -> createCommand ( ) -> update ( $ sourceMessageTable , [ 'message' => '@@' . $ row [ 'message' ] . '@@' ] , [ 'id' => $ row [ 'id' ] ] ) -> execute ( ) ; } $ this -> stdout ( "updated.\n" ) ; } else { $ this -> stdout ( "kept untouched.\n" ) ; } } 
protected function extractMessages ( $ fileName , $ translator , $ ignoreCategories = [ ] ) { $ this -> stdout ( 'Extracting messages from ' ) ; $ this -> stdout ( $ fileName , Console :: FG_CYAN ) ; $ this -> stdout ( "...\n" ) ; $ subject = file_get_contents ( $ fileName ) ; $ messages = [ ] ; $ tokens = token_get_all ( $ subject ) ; foreach ( ( array ) $ translator as $ currentTranslator ) { $ translatorTokens = token_get_all ( '<?php ' . $ currentTranslator ) ; array_shift ( $ translatorTokens ) ; $ messages = array_merge_recursive ( $ messages , $ this -> extractMessagesFromTokens ( $ tokens , $ translatorTokens , $ ignoreCategories ) ) ; } $ this -> stdout ( "\n" ) ; return $ messages ; } 
protected function extractMessagesFromTokens ( array $ tokens , array $ translatorTokens , array $ ignoreCategories ) { $ messages = [ ] ; $ translatorTokensCount = count ( $ translatorTokens ) ; $ matchedTokensCount = 0 ; $ buffer = [ ] ; $ pendingParenthesisCount = 0 ; foreach ( $ tokens as $ tokenIndex => $ token ) { 
protected function isCategoryIgnored ( $ category , array $ ignoreCategories ) { if ( ! empty ( $ ignoreCategories ) ) { if ( in_array ( $ category , $ ignoreCategories , true ) ) { return true ; } foreach ( $ ignoreCategories as $ pattern ) { if ( strpos ( $ pattern , '*' ) > 0 && strpos ( $ category , rtrim ( $ pattern , '*' ) ) === 0 ) { return true ; } } } return false ; } 
protected function saveMessagesToPO ( $ messages , $ dirName , $ overwrite , $ removeUnused , $ sort , $ catalog , $ markUnused ) { $ file = str_replace ( '\\' , '/' , "$dirName/$catalog.po" ) ; FileHelper :: createDirectory ( dirname ( $ file ) ) ; $ this -> stdout ( "Saving messages to $file...\n" ) ; $ poFile = new GettextPoFile ( ) ; $ merged = [ ] ; $ todos = [ ] ; $ hasSomethingToWrite = false ; foreach ( $ messages as $ category => $ msgs ) { $ notTranslatedYet = [ ] ; $ msgs = array_values ( array_unique ( $ msgs ) ) ; if ( is_file ( $ file ) ) { $ existingMessages = $ poFile -> load ( $ file , $ category ) ; sort ( $ msgs ) ; ksort ( $ existingMessages ) ; if ( array_keys ( $ existingMessages ) == $ msgs ) { $ this -> stdout ( "Nothing new in \"$category\" category...\n" ) ; sort ( $ msgs ) ; foreach ( $ msgs as $ message ) { $ merged [ $ category . chr ( 4 ) . $ message ] = $ existingMessages [ $ message ] ; } ksort ( $ merged ) ; continue ; } 
public function init ( ) { parent :: init ( ) ; $ this -> typeMap = array_merge ( $ this -> typeMap , $ this -> defaultTimeTypeMap ( ) ) ; } 
public function renameColumn ( $ table , $ oldName , $ newName ) { $ quotedTable = $ this -> db -> quoteTableName ( $ table ) ; $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ quotedTable ) -> queryOne ( ) ; if ( $ row === false ) { throw new Exception ( "Unable to find column '$oldName' in table '$table'." ) ; } if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } if ( preg_match_all ( '/^\s*`(.*?)`\s+(.*?),?$/m' , $ sql , $ matches ) ) { foreach ( $ matches [ 1 ] as $ i => $ c ) { if ( $ c === $ oldName ) { return "ALTER TABLE $quotedTable CHANGE " . $ this -> db -> quoteColumnName ( $ oldName ) . ' ' . $ this -> db -> quoteColumnName ( $ newName ) . ' ' . $ matches [ 2 ] [ $ i ] ; } } } 
public function resetSequence ( $ tableName , $ value = null ) { $ table = $ this -> db -> getTableSchema ( $ tableName ) ; if ( $ table !== null && $ table -> sequenceName !== null ) { $ tableName = $ this -> db -> quoteTableName ( $ tableName ) ; if ( $ value === null ) { $ key = reset ( $ table -> primaryKey ) ; $ value = $ this -> db -> createCommand ( "SELECT MAX(`$key`) FROM $tableName" ) -> queryScalar ( ) + 1 ; } else { $ value = ( int ) $ value ; } return "ALTER TABLE $tableName AUTO_INCREMENT=$value" ; } elseif ( $ table === null ) { throw new InvalidArgumentException ( "Table not found: $tableName" ) ; } throw new InvalidArgumentException ( "There is no sequence associated with table '$tableName'." ) ; } 
public function buildLimit ( $ limit , $ offset ) { $ sql = '' ; if ( $ this -> hasLimit ( $ limit ) ) { $ sql = 'LIMIT ' . $ limit ; if ( $ this -> hasOffset ( $ offset ) ) { $ sql .= ' OFFSET ' . $ offset ; } } elseif ( $ this -> hasOffset ( $ offset ) ) { 
public function addCommentOnColumn ( $ table , $ column , $ comment ) { 
private function supportsFractionalSeconds ( ) { $ version = $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_SERVER_VERSION ) ; return version_compare ( $ version , '5.6.4' , '>=' ) ; } 
private function defaultTimeTypeMap ( ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime' , Schema :: TYPE_TIMESTAMP => 'timestamp' , Schema :: TYPE_TIME => 'time' , ] ; if ( $ this -> supportsFractionalSeconds ( ) ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime(0)' , Schema :: TYPE_TIMESTAMP => 'timestamp(0)' , Schema :: TYPE_TIME => 'time(0)' , ] ; } return $ map ; } 
protected function addValue ( $ key , $ value , $ duration ) { return ! xcache_isset ( $ key ) ? $ this -> setValue ( $ key , $ value , $ duration ) : false ; } 
public function init ( ) { parent :: init ( ) ; static :: checkRequirements ( ) ; if ( ! isset ( $ this -> imageOptions [ 'id' ] ) ) { $ this -> imageOptions [ 'id' ] = $ this -> options [ 'id' ] . '-image' ; } } 
public function run ( ) { $ this -> registerClientScript ( ) ; $ input = $ this -> renderInputHtml ( 'text' ) ; $ route = $ this -> captchaAction ; if ( is_array ( $ route ) ) { $ route [ 'v' ] = uniqid ( '' , true ) ; } else { $ route = [ $ route , 'v' => uniqid ( '' , true ) ] ; } $ image = Html :: img ( $ route , $ this -> imageOptions ) ; echo strtr ( $ this -> template , [ '{input}' => $ input , '{image}' => $ image , ] ) ; } 
public static function checkRequirements ( ) { if ( extension_loaded ( 'imagick' ) ) { $ imagickFormats = ( new \ Imagick ( ) ) -> queryFormats ( 'PNG' ) ; if ( in_array ( 'PNG' , $ imagickFormats , true ) ) { return 'imagick' ; } } if ( extension_loaded ( 'gd' ) ) { $ gdInfo = gd_info ( ) ; if ( ! empty ( $ gdInfo [ 'FreeType Support' ] ) ) { return 'gd' ; } } throw new InvalidConfigException ( 'Either GD PHP extension with FreeType support or ImageMagick PHP extension with PNG support is required.' ) ; } 
public function validateAttribute ( $ model , $ attribute ) { if ( $ this -> isEmpty ( $ model -> $ attribute ) ) { if ( $ this -> value instanceof \ Closure ) { $ model -> $ attribute = call_user_func ( $ this -> value , $ model , $ attribute ) ; } else { $ model -> $ attribute = $ this -> value ; } } } 
public function get ( $ name ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] : null ; } 
public function getValue ( $ name , $ defaultValue = null ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] -> value : $ defaultValue ; } 
public function has ( $ name ) { return isset ( $ this -> _cookies [ $ name ] ) && $ this -> _cookies [ $ name ] -> value !== '' && ( $ this -> _cookies [ $ name ] -> expire === null || $ this -> _cookies [ $ name ] -> expire === 0 || $ this -> _cookies [ $ name ] -> expire >= time ( ) ) ; } 
public function add ( $ cookie ) { if ( $ this -> readOnly ) { throw new InvalidCallException ( 'The cookie collection is read only.' ) ; } $ this -> _cookies [ $ cookie -> name ] = $ cookie ; } 
public function remove ( $ cookie , $ removeFromBrowser = true ) { if ( $ this -> readOnly ) { throw new InvalidCallException ( 'The cookie collection is read only.' ) ; } if ( $ cookie instanceof Cookie ) { $ cookie -> expire = 1 ; $ cookie -> value = '' ; } else { $ cookie = Yii :: createObject ( [ 'class' => 'yii\web\Cookie' , 'name' => $ cookie , 'expire' => 1 , ] ) ; } if ( $ removeFromBrowser ) { $ this -> _cookies [ $ cookie -> name ] = $ cookie ; } else { unset ( $ this -> _cookies [ $ cookie -> name ] ) ; } } 
public function actionReport ( $ sourcePath , $ translationPath , $ title = 'Translation report' ) { $ sourcePath = trim ( $ sourcePath , '/\\' ) ; $ translationPath = trim ( $ translationPath , '/\\' ) ; $ results = [ ] ; $ dir = new DirectoryIterator ( $ sourcePath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ sourceFilePath = $ sourcePath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( $ translatedFilePath ) ; $ diff = empty ( $ errors ) ? $ this -> getDiff ( $ translatedFilePath , $ sourceFilePath ) : '' ; if ( ! empty ( $ diff ) ) { $ errors [ ] = 'Translation outdated.' ; } $ result = [ 'errors' => $ errors , 'diff' => $ diff , ] ; $ results [ $ fileinfo -> getFilename ( ) ] = $ result ; } } 
public function beforeAction ( $ action ) { if ( ! $ this -> enabled ) { return true ; } $ verb = Yii :: $ app -> getRequest ( ) -> getMethod ( ) ; if ( $ verb !== 'GET' && $ verb !== 'HEAD' || $ this -> lastModified === null && $ this -> etagSeed === null ) { return true ; } $ lastModified = $ etag = null ; if ( $ this -> lastModified !== null ) { $ lastModified = call_user_func ( $ this -> lastModified , $ action , $ this -> params ) ; } if ( $ this -> etagSeed !== null ) { $ seed = call_user_func ( $ this -> etagSeed , $ action , $ this -> params ) ; if ( $ seed !== null ) { $ etag = $ this -> generateEtag ( $ seed ) ; } } $ this -> sendCacheControlHeader ( ) ; $ response = Yii :: $ app -> getResponse ( ) ; if ( $ etag !== null ) { $ response -> getHeaders ( ) -> set ( 'Etag' , $ etag ) ; } $ cacheValid = $ this -> validateCache ( $ lastModified , $ etag ) ; 
protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { 
protected function generateEtag ( $ seed ) { $ etag = '"' . rtrim ( base64_encode ( sha1 ( $ seed , true ) ) , '=' ) . '"' ; return $ this -> weakEtag ? 'W/' . $ etag : $ etag ; } 
public function scenarios ( ) { $ scenarios = [ self :: SCENARIO_DEFAULT => [ ] ] ; foreach ( $ this -> getValidators ( ) as $ validator ) { foreach ( $ validator -> on as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } foreach ( $ validator -> except as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } } $ names = array_keys ( $ scenarios ) ; foreach ( $ this -> getValidators ( ) as $ validator ) { if ( empty ( $ validator -> on ) && empty ( $ validator -> except ) ) { foreach ( $ names as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } elseif ( empty ( $ validator -> on ) ) { foreach ( $ names as $ name ) { if ( ! in_array ( $ name , $ validator -> except , true ) ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } else { foreach ( $ validator -> on as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } foreach ( $ scenarios as $ scenario => $ attributes ) { if ( ! empty ( $ attributes ) ) { $ scenarios [ $ scenario ] = array_keys ( $ attributes ) ; } } return $ scenarios ; } 
public function formName ( ) { $ reflector = new ReflectionClass ( $ this ) ; if ( PHP_VERSION_ID >= 70000 && $ reflector -> isAnonymous ( ) ) { throw new InvalidConfigException ( 'The "formName()" method should be explicitly defined for anonymous models' ) ; } return $ reflector -> getShortName ( ) ; } 
public function getValidators ( ) { if ( $ this -> _validators === null ) { $ this -> _validators = $ this -> createValidators ( ) ; } return $ this -> _validators ; } 
public function getActiveValidators ( $ attribute = null ) { $ activeAttributes = $ this -> activeAttributes ( ) ; if ( $ attribute !== null && ! in_array ( $ attribute , $ activeAttributes , true ) ) { return [ ] ; } $ scenario = $ this -> getScenario ( ) ; $ validators = [ ] ; foreach ( $ this -> getValidators ( ) as $ validator ) { if ( $ attribute === null ) { $ validatorAttributes = $ validator -> getValidationAttributes ( $ activeAttributes ) ; $ attributeValid = ! empty ( $ validatorAttributes ) ; } else { $ attributeValid = in_array ( $ attribute , $ validator -> getValidationAttributes ( $ attribute ) , true ) ; } if ( $ attributeValid && $ validator -> isActive ( $ scenario ) ) { $ validators [ ] = $ validator ; } } return $ validators ; } 
public function getAttributeHint ( $ attribute ) { $ hints = $ this -> attributeHints ( ) ; return isset ( $ hints [ $ attribute ] ) ? $ hints [ $ attribute ] : '' ; } 
public function getFirstError ( $ attribute ) { return isset ( $ this -> _errors [ $ attribute ] ) ? reset ( $ this -> _errors [ $ attribute ] ) : null ; } 
public function getErrorSummary ( $ showAllErrors ) { $ lines = [ ] ; $ errors = $ showAllErrors ? $ this -> getErrors ( ) : $ this -> getFirstErrors ( ) ; foreach ( $ errors as $ es ) { $ lines = array_merge ( ( array ) $ es , $ lines ) ; } return $ lines ; } 
public function addErrors ( array $ items ) { foreach ( $ items as $ attribute => $ errors ) { if ( is_array ( $ errors ) ) { foreach ( $ errors as $ error ) { $ this -> addError ( $ attribute , $ error ) ; } } else { $ this -> addError ( $ attribute , $ errors ) ; } } } 
public function clearErrors ( $ attribute = null ) { if ( $ attribute === null ) { $ this -> _errors = [ ] ; } else { unset ( $ this -> _errors [ $ attribute ] ) ; } } 
public function getAttributes ( $ names = null , $ except = [ ] ) { $ values = [ ] ; if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } foreach ( $ names as $ name ) { $ values [ $ name ] = $ this -> $ name ; } foreach ( $ except as $ name ) { unset ( $ values [ $ name ] ) ; } return $ values ; } 
public function activeAttributes ( ) { $ scenario = $ this -> getScenario ( ) ; $ scenarios = $ this -> scenarios ( ) ; if ( ! isset ( $ scenarios [ $ scenario ] ) ) { return [ ] ; } $ attributes = array_keys ( array_flip ( $ scenarios [ $ scenario ] ) ) ; foreach ( $ attributes as $ i => $ attribute ) { if ( $ attribute [ 0 ] === '!' ) { $ attributes [ $ i ] = substr ( $ attribute , 1 ) ; } } return $ attributes ; } 
public function load ( $ data , $ formName = null ) { $ scope = $ formName === null ? $ this -> formName ( ) : $ formName ; if ( $ scope === '' && ! empty ( $ data ) ) { $ this -> setAttributes ( $ data ) ; return true ; } elseif ( isset ( $ data [ $ scope ] ) ) { $ this -> setAttributes ( $ data [ $ scope ] ) ; return true ; } return false ; } 
public static function loadMultiple ( $ models , $ data , $ formName = null ) { if ( $ formName === null ) { $ first = reset ( $ models ) ; if ( $ first === false ) { return false ; } $ formName = $ first -> formName ( ) ; } $ success = false ; foreach ( $ models as $ i => $ model ) { if ( $ formName == '' ) { if ( ! empty ( $ data [ $ i ] ) && $ model -> load ( $ data [ $ i ] , '' ) ) { $ success = true ; } } elseif ( ! empty ( $ data [ $ formName ] [ $ i ] ) && $ model -> load ( $ data [ $ formName ] [ $ i ] , '' ) ) { $ success = true ; } } return $ success ; } 
public static function invalidate ( $ cache , $ tags ) { $ keys = [ ] ; foreach ( ( array ) $ tags as $ tag ) { $ keys [ ] = $ cache -> buildKey ( [ __CLASS__ , $ tag ] ) ; } static :: touchKeys ( $ cache , $ keys ) ; } 
public function encrypt ( $ data ) { if ( $ this -> key === false ) { return '' ; } $ res = openssl_get_privatekey ( $ this -> key ) ; if ( empty ( $ res ) ) { throw new \ Exception ( '您使用的私钥格式错误，请检查RSA私钥配置'); } openssl_sign ( $ data , $ sign , $ res , OPENSSL_ALGO_SHA256 ) ; openssl_free_key ( $ res ) ; 
public function decrypt ( $ content ) { if ( $ this -> key === false ) { return '' ; } $ res = openssl_get_privatekey ( $ this -> key ) ; if ( empty ( $ res ) ) { throw new \ Exception ( '您使用的私钥格式错误，请检查RSA私钥配置'); } 
protected function buildData ( ) { $ signData = [ 
protected function checkDataParam ( ) { $ branchNo = $ this -> branchNo ; $ merchantNo = $ this -> merchantNo ; if ( empty ( $ branchNo ) || mb_strlen ( $ branchNo ) !== 4 ) { throw new PayException ( '商户分行号，4位数字'); } if ( empty ( $ merchantNo ) || mb_strlen ( $ merchantNo ) !== 6 ) { throw new PayException ( '商户号，6位数字'); } } 
protected function retData ( array $ data ) { if ( $ this -> config -> returnRaw ) { $ data [ 'channel' ] = Config :: WX_RED ; return $ data ; } 
protected function createBackData ( array $ data ) { 
public function encrypt ( $ data ) { $ cipher = $ box [ ] = $ key [ ] = '' ; $ pwd_length = strlen ( $ this -> key ) ; $ data_length = strlen ( $ data ) ; for ( $ i = 0 ; $ i < 256 ; $ i ++ ) { $ key [ $ i ] = ord ( $ this -> key [ $ i % $ pwd_length ] ) ; $ box [ $ i ] = $ i ; } for ( $ j = $ i = 0 ; $ i < 256 ; $ i ++ ) { $ j = ( $ j + $ box [ $ i ] + $ key [ $ i ] ) % 256 ; $ tmp = $ box [ $ i ] ; $ box [ $ i ] = $ box [ $ j ] ; $ box [ $ j ] = $ tmp ; } for ( $ a = $ j = $ i = 0 ; $ i < $ data_length ; $ i ++ ) { $ a = ( $ a + 1 ) % 256 ; $ j = ( $ j + $ box [ $ a ] ) % 256 ; $ tmp = $ box [ $ a ] ; $ box [ $ a ] = $ box [ $ j ] ; $ box [ $ j ] = $ tmp ; $ k = $ box [ ( ( $ box [ $ a ] + $ box [ $ j ] ) % 256 ) ] ; $ cipher .= chr ( ord ( $ data [ $ i ] ) ^ $ k ) ; } return strtoupper ( StrUtil :: String2Hex ( $ cipher ) ) ; } 
public function initHelper ( $ way , array $ config ) { try { switch ( $ way ) { case Config :: CMB_BIND : $ this -> helper = new BindCardHelper ( $ config ) ; break ; case Config :: CMB_PUB_KEY : $ this -> helper = new PubKeyHelper ( $ config ) ; break ; default : throw new PayException ( '当前仅支持：CMB_BIND CMB_PUB_KEY 操作'); } } catch ( PayException $ e ) { throw $ e ; } } 
public function helper ( array $ data ) { if ( ! $ this -> helper instanceof BaseStrategy ) { throw new PayException ( '请检查初始化是否正确'); } try { return $ this -> helper -> handle ( $ data ) ; } catch ( PayException $ e ) { throw $ e ; } } 
public function decrypt ( $ content ) { if ( $ this -> key === false ) { return '' ; } $ res = openssl_get_privatekey ( $ this -> key ) ; if ( empty ( $ res ) ) { throw new \ Exception ( '您使用的私钥格式错误，请检查RSA私钥配置'); } 
public function rsaVerify ( $ data , $ sign ) { 
protected function checkDataParam ( ) { $ tradeNo = $ this -> trade_no ; 
protected function getBizContent ( ) { $ content = [ 'out_trade_no' => $ this -> out_trade_no , 'trade_no' => $ this -> trade_no , 'refund_amount' => $ this -> refund_fee , 'refund_reason' => $ this -> reason , 'out_request_no' => $ this -> refund_no , 'operator_id' => $ this -> operator_id , 'store_id' => $ this -> store_id , 'terminal_id' => $ this -> terminal_id , ] ; return $ content ; } 
protected function retData ( array $ data ) { if ( $ this -> config -> returnRaw ) { $ data [ 'channel' ] = Config :: WX_REFUND ; return $ data ; } 
protected function createBackData ( array $ data ) { $ refund_count = $ data [ 'refund_count' ] ; 
protected function retData ( array $ ret ) { $ url = parent :: retData ( $ ret ) ; 
protected function getBizContent ( ) { $ content = [ 'out_trade_no' => strval ( $ this -> order_no ) , 'scene' => $ this -> scene , 'auth_code' => $ this -> auth_code , 'product_code' => 'FACE_TO_FACE_PAYMENT' , 'subject' => strval ( $ this -> subject ) , 
protected function retData ( array $ ret ) { if ( $ this -> config -> returnRaw ) { $ ret [ 'channel' ] = Config :: WX_REFUND ; return $ ret ; } 
protected function createBackData ( array $ data ) { 
public function getNotifyData ( ) { 
protected function verifySign ( array $ retData ) { $ retSign = $ retData [ 'sign' ] ; $ values = ArrayUtil :: removeKeys ( $ retData , [ 'sign' , 'sign_type' ] ) ; $ values = ArrayUtil :: paraFilter ( $ values ) ; $ values = ArrayUtil :: arraySort ( $ values ) ; $ signStr = ArrayUtil :: createLinkstring ( $ values ) ; $ signStr .= '&key=' . $ this -> config -> md5Key ; switch ( $ this -> config -> signType ) { case 'MD5' : $ sign = md5 ( $ signStr ) ; break ; case 'HMAC-SHA256' : $ sign = hash_hmac ( 'sha256' , $ signStr , $ this -> config -> md5Key ) ; break ; default : $ sign = '' ; } return strtoupper ( $ sign ) === $ retSign ; } 
protected function getRetData ( array $ data ) { if ( $ this -> config -> returnRaw ) { $ data [ 'channel' ] = Config :: WX_CHARGE ; return $ data ; } 
protected function replyNotify ( $ flag , $ msg = 'OK' ) { 
protected function retData ( array $ ret ) { $ ret [ 'total_fee' ] = bcdiv ( $ ret [ 'total_fee' ] , 100 , 2 ) ; $ ret [ 'cash_fee' ] = bcdiv ( $ ret [ 'cash_fee' ] , 100 , 2 ) ; if ( $ this -> config -> returnRaw ) { return $ ret ; } return $ ret ; } 
protected function retData ( array $ data ) { $ data = parent :: retData ( $ data ) ; return $ this -> config -> getewayUrl . '?' . http_build_query ( $ data ) ; } 
protected function buildData ( ) { $ info = $ this -> scene_info ; $ sceneInfo = [ ] ; if ( $ info && is_array ( $ info ) ) { $ sceneInfo [ 'store_info' ] = $ info ; } $ signData = [ 'appid' => trim ( $ this -> appId ) , 'mch_id' => trim ( $ this -> mchId ) , 'device_info' => $ this -> terminal_id , 'nonce_str' => $ this -> nonceStr , 'sign_type' => $ this -> signType , 'body' => trim ( $ this -> subject ) , 
public function setSign ( ) { $ this -> buildData ( ) ; if ( $ this -> channel === Config :: CMB_PAY ) { $ data = $ this -> retData [ 'reqData' ] ; } else { $ data = $ this -> retData ; } $ values = ArrayUtil :: removeKeys ( $ data , [ 'sign' ] ) ; $ values = ArrayUtil :: arraySort ( $ values ) ; $ signStr = ArrayUtil :: createLinkstring ( $ values ) ; $ this -> retData [ 'sign' ] = $ this -> makeSign ( $ signStr ) ; } 
public function getSandboxSignKey ( ) { $ this -> setSign ( ) ; $ xml = DataParser :: toXml ( $ this -> getData ( ) ) ; $ url = self :: SANDBOX_URL ; $ client = new Client ( [ 'timeout' => '10.0' ] ) ; $ options = [ 'body' => $ xml , 'http_errors' => false ] ; $ response = $ client -> request ( 'POST' , self :: SANDBOX_URL , $ options ) ; if ( $ response -> getStatusCode ( ) != '200' ) { throw new PayException ( '网络发生错误，请稍后再试curl返回码：' . $response->getReasonPhrase()) } 
protected function checkDataParam ( ) { $ refundNo = $ this -> refund_no ; 
protected function retData ( array $ data ) { $ reqData = parent :: retData ( $ data ) ; try { $ ret = $ this -> sendReq ( $ reqData ) ; } catch ( PayException $ e ) { throw $ e ; } $ content = \ GuzzleHttp \ json_decode ( $ data [ 'biz_content' ] , true ) ; $ refundNo = $ content [ 'out_request_no' ] ; if ( $ this -> config -> returnRaw ) { $ ret [ 'channel' ] = Config :: ALI_REFUND ; $ ret [ 'refund_no' ] = $ refundNo ; return $ ret ; } if ( $ ret [ 'code' ] !== '10000' ) { return [ 'is_success' => 'F' , 'error' => $ ret [ 'sub_msg' ] , 'refund_no' => $ refundNo ] ; } $ retData = [ 'is_success' => 'T' , 'response' => [ 'transaction_id' => $ ret [ 'trade_no' ] , 'order_no' => $ ret [ 'out_trade_no' ] , 'logon_id' => $ ret [ 'buyer_logon_id' ] , 'fund_change' => $ ret [ 'fund_change' ] , 
protected function initConfig ( array $ config ) { $ basePath = dirname ( dirname ( __FILE__ ) ) . DIRECTORY_SEPARATOR . 'CacertFile' . DIRECTORY_SEPARATOR ; $ this -> cacertPath = "{$basePath}wx_cacert.pem" ; $ config = ArrayUtil :: paraFilter ( $ config ) ; 
public function initRefund ( $ channel , array $ config ) { try { switch ( $ channel ) { case Config :: ALI_REFUND : $ this -> refund = new AliRefund ( $ config ) ; break ; case Config :: WX_REFUND : $ this -> refund = new WxRefund ( $ config ) ; break ; case Config :: CMB_REFUND : $ this -> refund = new CmbRefund ( $ config ) ; break ; default : throw new PayException ( '当前仅支持：ALI WEIXIN CMB'); } } catch ( PayException $ e ) { throw $ e ; } } 
public function refund ( array $ data ) { if ( ! $ this -> refund instanceof BaseStrategy ) { throw new PayException ( '请检查初始化是否正确'); } try { return $ this -> refund -> handle ( $ data ) ; } catch ( PayException $ e ) { throw $ e ; } } 
protected function checkDataParam ( ) { $ mch_billno = $ this -> mch_billno ; 
protected function retData ( array $ data ) { if ( $ this -> config -> returnRaw ) { $ data [ 'channel' ] = Config :: WX_TRANSFER ; return $ data ; } 
protected function createBackData ( array $ data ) { 
protected function createBackData ( array $ data ) { if ( $ this -> config -> returnRaw ) { $ data [ 'channel' ] = Config :: ALI_TRANSFER ; return $ data ; } if ( $ data [ 'code' ] !== '10000' ) { return $ retData = [ 'is_success' => 'F' , 'error' => $ data [ 'sub_msg' ] , 'channel' => Config :: ALI_TRANSFER , ] ; } $ retData = [ 'is_success' => 'T' , 'response' => [ 'trans_no' => $ data [ 'out_biz_no' ] , 
protected function retData ( array $ ret ) { if ( $ this -> config -> returnRaw ) { $ ret [ 'channel' ] = Config :: WX_RED ; return $ ret ; } 
protected function createBackData ( array $ data ) { $ retData = [ 'is_success' => 'T' , 'response' => [ 'mch_billno' => $ data [ 'mch_billno' ] , 'send_listid' => $ data [ 'send_listid' ] , 'total_amount' => $ data [ 'total_amount' ] , 're_openid' => $ data [ 're_openid' ] , 'wxappid' => $ data [ 'wxappid' ] , 'mch_id' => $ data [ 'mch_id' ] , 'channel' => Config :: WX_RED , ] , ] ; return $ retData ; } 
public static function characet ( $ str , $ targetCharset ) { if ( empty ( $ str ) ) { return $ str ; } if ( strcasecmp ( 'UTF-8' , $ targetCharset ) != 0 ) { $ str = mb_convert_encoding ( $ str , $ targetCharset , 'UTF-8' ) ; } return $ str ; } 
public static function String2Hex ( $ string ) { $ hex = '' ; $ len = strlen ( $ string ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ hex .= dechex ( ord ( $ string [ $ i ] ) ) ; } return $ hex ; } 
public static function getRsaKeyValue ( $ key , $ type = 'private' ) { if ( is_file ( $ key ) ) { 
public function getNotifyData ( ) { $ data = empty ( $ _POST ) ? $ _GET : $ _POST ; if ( empty ( $ data ) || ! is_array ( $ data ) ) { return false ; } return $ data ; } 
public function checkNotifyData ( array $ data ) { $ status = $ this -> getTradeStatus ( $ data [ 'trade_status' ] ) ; if ( $ status !== Config :: TRADE_STATUS_SUCC ) { 
protected function getRetData ( array $ data ) { if ( $ this -> config -> returnRaw ) { $ data [ 'channel' ] = Config :: ALI_CHARGE ; return $ data ; } $ retData = [ 'notify_time' => ArrayUtil :: get ( $ data , 'notify_time' ) , 'notify_type' => ArrayUtil :: get ( $ data , 'notify_type' ) , 'notify_id' => ArrayUtil :: get ( $ data , 'notify_id' ) , 'app_id' => ArrayUtil :: get ( $ data , 'app_id' ) , 'transaction_id' => ArrayUtil :: get ( $ data , 'trade_no' ) , 'order_no' => ArrayUtil :: get ( $ data , 'out_trade_no' ) , 'out_biz_no' => ArrayUtil :: get ( $ data , 'out_biz_no' ) , 'buyer_id' => ArrayUtil :: get ( $ data , 'buyer_id' ) , 'buyer_account' => ArrayUtil :: get ( $ data , 'buyer_logon_id' ) , 'seller_id' => ArrayUtil :: get ( $ data , 'seller_id' ) , 'seller_email' => ArrayUtil :: get ( $ data , 'seller_email' ) , 'trade_state' => $ this -> getTradeStatus ( $ data [ 'trade_status' ] ) , 'amount' => ArrayUtil :: get ( $ data , 'total_amount' ) , 'receipt_amount' => ArrayUtil :: get ( $ data , 'receipt_amount' ) , 
protected function verifySign ( array $ data ) { $ signType = strtoupper ( $ data [ 'sign_type' ] ) ; $ sign = $ data [ 'sign' ] ; 
protected function checkDataParam ( ) { $ subject = $ this -> subject ; $ orderNo = $ this -> order_no ; $ amount = $ this -> amount ; $ goodsType = $ this -> goods_type ; $ passBack = $ this -> return_param ; 
public function initTransfer ( $ channel , array $ config ) { try { switch ( $ channel ) { case Config :: ALI_TRANSFER : $ this -> transfer = new AliTransfer ( $ config ) ; break ; case Config :: WX_TRANSFER : $ this -> transfer = new WxTransfer ( $ config ) ; break ; default : throw new PayException ( '当前仅支持：ALI WEIXIN两个常量'); } } catch ( PayException $ e ) { throw $ e ; } } 
public function transfer ( array $ data ) { if ( ! $ this -> transfer instanceof BaseStrategy ) { throw new PayException ( '请检查初始化是否正确'); } try { return $ this -> transfer -> handle ( $ data ) ; } catch ( PayException $ e ) { throw $ e ; } } 
protected function retData ( array $ ret ) { $ back = new BackAppChargeData ( $ this -> config , $ ret ) ; $ back -> setSign ( ) ; $ backData = $ back -> getData ( ) ; return $ backData ; } 
protected function createBackData ( array $ data ) { if ( $ data [ 'code' ] !== '10000' ) { return $ retData = [ 'is_success' => 'F' , 'error' => $ data [ 'sub_msg' ] , 'channel' => Config :: ALI_TRANSFER , ] ; } $ retData = [ 'is_success' => 'T' , 'response' => [ 'transaction_id' => ArrayUtil :: get ( $ data , 'order_id' ) , 
public static function toXml ( $ values ) { if ( ! is_array ( $ values ) || count ( $ values ) <= 0 ) { return false ; } $ xml = "<xml>" ; foreach ( $ values as $ key => $ val ) { if ( is_numeric ( $ val ) ) { $ xml .= "<" . $ key . ">" . $ val . "</" . $ key . ">" ; } else { $ xml .= "<" . $ key . "><![CDATA[" . $ val . "]]></" . $ key . ">" ; } } $ xml .= "</xml>" ; return $ xml ; } 
public static function toArray ( $ xml ) { if ( ! $ xml ) { return false ; } 
public function initCharge ( $ channel , array $ config ) { 
public function charge ( array $ data ) { if ( ! $ this -> channel instanceof BaseStrategy ) { throw new PayException ( '请检查初始化是否正确'); } try { return $ this -> channel -> handle ( $ data ) ; } catch ( PayException $ e ) { throw $ e ; } } 
public function initQuery ( $ channel , array $ config ) { try { switch ( $ channel ) { case Config :: ALI_CHARGE : $ this -> query = new AliChargeQuery ( $ config ) ; break ; case Config :: ALI_REFUND : 
public function query ( array $ data ) { if ( ! $ this -> query instanceof BaseStrategy ) { throw new PayException ( '请检查初始化是否正确'); } try { return $ this -> query -> handle ( $ data ) ; } catch ( PayException $ e ) { throw $ e ; } } 
public static function run ( $ channel , $ config , $ metadata ) { if ( ! in_array ( $ channel , self :: $ supportChannel ) ) { throw new PayException ( 'sdk当前不支持该支付渠道，当前仅支持：' . implode(',', self::$supportChan e )); } try { $ instance = self :: getInstance ( $ channel , $ config ) ; $ ret = $ instance -> red ( $ metadata ) ; } catch ( PayException $ e ) { throw $ e ; } return $ ret ; } 
protected function retData ( array $ data ) { if ( $ this -> config -> returnRaw ) { $ data [ 'channel' ] = Config :: WX_CHARGE ; return $ data ; } 
protected function createBackData ( array $ data ) { 
public static function paraFilter ( $ para ) { $ paraFilter = [ ] ; foreach ( $ para as $ key => $ val ) { if ( $ val === '' || $ val === null ) { continue ; } else { if ( ! is_array ( $ para [ $ key ] ) ) { $ para [ $ key ] = is_bool ( $ para [ $ key ] ) ? $ para [ $ key ] : trim ( $ para [ $ key ] ) ; } $ paraFilter [ $ key ] = $ para [ $ key ] ; } } return $ paraFilter ; } 
public static function removeKeys ( array $ inputs , $ keys ) { if ( ! is_array ( $ keys ) ) { 
public static function createLinkstring ( $ para ) { if ( ! is_array ( $ para ) ) { throw new \ Exception ( '必须传入数组参数'); } reset ( $ para ) ; $ arg = '' ; foreach ( $ para as $ key => $ val ) { if ( is_array ( $ val ) ) { continue ; } $ arg .= $ key . '=' . urldecode ( $ val ) . '&' ; } 
public static function get ( array $ arr , $ key , $ default = '' ) { if ( isset ( $ arr [ $ key ] ) && ! empty ( $ arr [ $ key ] ) ) { return $ arr [ $ key ] ; } return $ default ; } 
public function handle ( array $ data ) { $ buildClass = $ this -> getBuildDataClass ( ) ; try { $ this -> reqData = new $ buildClass ( $ this -> config , $ data ) ; } catch ( PayException $ e ) { throw $ e ; } $ this -> reqData -> setSign ( ) ; $ data = $ this -> reqData -> getData ( ) ; return $ this -> retData ( $ data ) ; } 
protected function retData ( array $ ret ) { $ json = json_encode ( $ ret , JSON_UNESCAPED_UNICODE ) ; $ reqData = [ 'url' => $ this -> config -> getewayUrl , 'name' => CmbConfig :: REQ_FILED_NAME , 'value' => $ json , ] ; return $ reqData ; } 
protected function sendReq ( $ json ) { $ client = new Client ( [ 'timeout' => '10.0' ] ) ; 
protected function retData ( array $ ret ) { if ( $ this -> config -> returnRaw ) { return $ ret ; } $ wabUrl = $ ret [ 'mweb_url' ] ; if ( $ this -> config -> returnUrl ) { $ wabUrl .= '&redirect_url=' . urlencode ( $ this -> config -> returnUrl ) ; } return $ wabUrl ; } 
protected function retData ( array $ ret ) { if ( $ this -> config -> returnRaw ) { $ ret [ 'channel' ] = Config :: WX_TRANSFER ; return $ ret ; } 
protected function createBackData ( array $ data ) { $ retData = [ 'is_success' => 'T' , 'response' => [ 'trans_no' => $ data [ 'partner_trade_no' ] , 'transaction_id' => $ data [ 'payment_no' ] , 'pay_date' => $ data [ 'payment_time' ] , 
protected function getBizContent ( ) { $ content = [ 'body' => strval ( $ this -> body ) , 'subject' => strval ( $ this -> subject ) , 'out_trade_no' => strval ( $ this -> order_no ) , 'total_amount' => strval ( $ this -> amount ) , 
final public function handle ( PayNotifyInterface $ notify ) { 
protected function callback ( PayNotifyInterface $ notify , array $ notifyData ) { $ data = $ this -> getRetData ( $ notifyData ) ; if ( $ data === false ) { return false ; } return $ notify -> notifyProcess ( $ data ) ; } 
protected function checkDataParam ( ) { parent :: checkDataParam ( ) ; $ amount = $ this -> amount ; 
protected function getReqData ( ) { $ reqData = [ 'dateTime' => $ this -> dateTime , 'branchNo' => $ this -> branchNo , 'merchantNo' => $ this -> merchantNo , 'date' => $ this -> date ? $ this -> date : date ( 'Ymd' , time ( ) ) , 'orderNo' => $ this -> order_no , 'amount' => $ this -> amount , 'expireTimeSpan' => $ this -> timeout_express ? $ this -> timeout_express : '' , 'payNoticeUrl' => $ this -> notifyUrl , 'payNoticePara' => $ this -> return_param ? $ this -> return_param : '' , 'returnUrl' => $ this -> returnUrl ? $ this -> returnUrl : '' , 'clientIP' => $ this -> client_ip , 'cardType' => $ this -> limitPay ? $ this -> limitPay : '' , 'agrNo' => $ this -> agr_no , 'merchantSerialNo' => $ this -> serial_no ? $ this -> serial_no : '' , 'userID' => $ this -> user_id ? $ this -> user_id : '' , 'mobile' => $ this -> mobile ? $ this -> mobile : '' , 'lon' => $ this -> lon ? $ this -> lon : '' , 'lat' => $ this -> lat ? $ this -> lat : '' , 'riskLevel' => $ this -> risk_level ? $ this -> risk_level : '' , 'signNoticeUrl' => $ this -> signNoticeUrl ? $ this -> signNoticeUrl : '' , 'signNoticePara' => $ this -> return_param ? $ this -> return_param : '' , 
public static function run ( $ channel , $ config , array $ metadata = [ ] ) { if ( ! in_array ( $ channel , self :: $ supportChannel ) ) { throw new PayException ( 'sdk当前不支持该渠道，当前仅支持：' . implode(',', self::$support h nnel)); } try { $ instance = self :: getInstance ( $ channel , $ config ) ; $ ret = $ instance -> helper ( $ metadata ) ; } catch ( PayException $ e ) { throw $ e ; } return $ ret ; } 
public function checkNotifyData ( array $ data ) { $ signType = strtoupper ( $ data [ 'signType' ] ) ; $ sign = $ data [ 'sign' ] ; 
protected function getRetData ( array $ data ) { $ noticeData = $ data [ 'noticeData' ] ; $ noticeType = $ noticeData [ 'noticeType' ] ; if ( $ noticeType === CmbConfig :: NOTICE_PAY ) { $ channel = Config :: CMB_CHARGE ; } elseif ( $ noticeType === CmbConfig :: NOTICE_SIGN ) { $ channel = Config :: CMB_BIND ; } else { $ channel = 'other' ; } if ( $ this -> config -> returnRaw ) { $ data [ 'channel' ] = $ channel ; return $ data ; } elseif ( $ noticeType === CmbConfig :: NOTICE_PAY ) { $ retData = [ 'amount' => $ noticeData [ 'amount' ] , 'channel' => $ channel , 'date' => $ noticeData [ 'date' ] , 'order_no' => $ noticeData [ 'orderNo' ] , 'trade_state' => Config :: TRADE_STATUS_SUCC , 
protected function checkDataParam ( ) { $ openId = $ this -> openid ; $ transNo = $ this -> trans_no ; $ checkName = $ this -> check_name ; $ realName = $ this -> payer_real_name ; $ amount = $ this -> amount ; $ clientIp = $ this -> client_ip ; if ( empty ( $ openId ) ) { throw new PayException ( '商户appid下，某用户的openid 必须传入'); } if ( empty ( $ transNo ) ) { throw new PayException ( '商户订单号，需保持唯一性'); } if ( $ checkName !== 'NO_CHECK' && empty ( $ realName ) ) { throw new PayException ( '请传入收款人真实姓名'); } 
public static function run ( $ type , $ config , $ callback ) { if ( ! in_array ( $ type , self :: $ supportChannel ) ) { throw new PayException ( 'sdk当前不支持该异步方式，当前仅支持：' . implode(',', self::$supportChan e )); } try { $ instance = self :: getInstance ( $ type , $ config ) ; $ ret = $ instance -> notify ( $ callback ) ; } catch ( PayException $ e ) { throw $ e ; } return $ ret ; } 
public static function getNotifyData ( $ type , $ config ) { try { $ instance = self :: getInstance ( $ type , $ config ) ; return $ instance -> getNotifyData ( ) ; } catch ( PayException $ e ) { throw $ e ; } } 
protected function initConfig ( array $ config ) { $ config = ArrayUtil :: paraFilter ( $ config ) ; 
protected function sendReq ( $ xml ) { $ url = $ this -> reqUrl ; if ( is_null ( $ url ) ) { throw new PayException ( '目前不支持该接口。请联系开发者添加'); } if ( $ this -> config -> useSandbox ) { $ url = str_ireplace ( '{debug}' , WxConfig :: SANDBOX_PRE , $ url ) ; } else { $ url = str_ireplace ( '{debug}/' , '' , $ url ) ; } $ client = new Client ( [ 'timeout' => '10.0' ] ) ; 
protected function retData ( array $ data ) { $ sign = $ data [ 'sign' ] ; $ data = ArrayUtil :: removeKeys ( $ data , [ 'sign' ] ) ; $ data = ArrayUtil :: arraySort ( $ data ) ; 
protected function sendReq ( array $ data , $ method = 'GET' ) { $ client = new Client ( [ 'base_uri' => $ this -> config -> getewayUrl , 'timeout' => '10.0' ] ) ; $ method = strtoupper ( $ method ) ; $ options = [ ] ; if ( $ method === 'GET' ) { $ options = [ 'query' => $ data , 'http_errors' => false ] ; } elseif ( $ method === 'POST' ) { $ options = [ 'form_params' => $ data , 'http_errors' => false ] ; } 
protected function verifySign ( array $ data , $ sign ) { $ preStr = \ GuzzleHttp \ json_encode ( $ data , JSON_UNESCAPED_UNICODE ) ; 
protected function retData ( array $ data ) { $ data = parent :: retData ( $ data ) ; 
protected function createBackData ( array $ data ) { 
public function initNotify ( $ channel , array $ config ) { try { switch ( $ channel ) { case Config :: ALI_CHARGE : $ this -> notify = new AliNotify ( $ config ) ; break ; case Config :: WX_CHARGE : $ this -> notify = new WxNotify ( $ config ) ; break ; case Config :: CMB_CHARGE : $ this -> notify = new CmbNotify ( $ config ) ; break ; default : throw new PayException ( '当前仅支持：ALI_CHARGE WX_CHARGE CMB_CHARGE 常量'); } } catch ( PayException $ e ) { throw $ e ; } } 
public function notify ( PayNotifyInterface $ notify ) { if ( ! $ this -> notify instanceof NotifyStrategy ) { throw new PayException ( '请检查初始化是否正确'); } return $ this -> notify -> handle ( $ notify ) ; } 
protected function makeSign ( $ signStr ) { switch ( $ this -> signType ) { case 'RSA' : $ rsa = new RsaEncrypt ( $ this -> rsaPrivateKey ) ; $ sign = $ rsa -> encrypt ( $ signStr ) ; break ; case 'RSA2' : $ rsa = new Rsa2Encrypt ( $ this -> rsaPrivateKey ) ; $ sign = $ rsa -> encrypt ( $ signStr ) ; break ; default : $ sign = '' ; } return $ sign ; } 
protected function buildData ( ) { $ bizContent = $ this -> getBizContent ( ) ; $ bizContent = ArrayUtil :: paraFilter ( $ bizContent ) ; 
protected function makeSign ( $ signStr ) { switch ( $ this -> signType ) { case 'MD5' : $ signStr .= '&key=' . $ this -> md5Key ; $ sign = md5 ( $ signStr ) ; break ; case 'HMAC-SHA256' : $ sign = base64_encode ( hash_hmac ( 'sha256' , $ signStr , $ this -> md5Key ) ) ; break ; default : $ sign = '' ; } return strtoupper ( $ sign ) ; } 
protected function checkDataParam ( ) { $ orderNo = $ this -> order_no ; $ amount = $ this -> amount ; $ subject = $ this -> subject ; $ body = $ this -> body ; $ deviceInfo = $ this -> terminal_id ; 
protected function createBackData ( array $ data ) { if ( $ data [ 'code' ] !== '10000' ) { return $ retData = [ 'is_success' => 'F' , 'error' => $ data [ 'sub_msg' ] , 'channel' => Config :: ALI_REFUND , ] ; } 
protected function initConfig ( array $ config ) { $ config = ArrayUtil :: paraFilter ( $ config ) ; 
public function initRed ( $ channel , array $ config ) { try { switch ( $ channel ) { case Config :: ALI_RED : $ this -> red = new AliRed ( $ config ) ; break ; case Config :: WX_RED : $ this -> red = new WxRed ( $ config ) ; break ; default : throw new PayException ( '当前仅支持：ALI WEIXIN两个常量'); } } catch ( PayException $ e ) { throw $ e ; } } 
public function red ( array $ data ) { if ( ! $ this -> red instanceof BaseStrategy ) { throw new PayException ( '请检查初始化是否正确'); } try { return $ this -> red -> handle ( $ data ) ; } catch ( PayException $ e ) { throw $ e ; } } 
protected function checkDataParam ( ) { $ transNo = $ this -> trans_no ; $ payeeType = $ this -> payee_type ; $ payeeAccount = $ this -> payee_account ; $ amount = $ this -> amount ; $ remark = $ this -> remark ; if ( empty ( $ transNo ) ) { throw new PayException ( '请传入 商户转账唯一订单号'); } if ( empty ( $ payeeType ) || ! in_array ( $ payeeType , [ 'ALIPAY_USERID' , 'ALIPAY_LOGONID' ] ) ) { throw new PayException ( '请传入收款账户类型'); } if ( empty ( $ payeeAccount ) ) { throw new PayException ( '请传入转账帐号'); } if ( empty ( $ amount ) || bccomp ( $ amount , 0 , 2 ) !== 1 ) { throw new PayException ( '请输入转账金额，且大于0'); } if ( bccomp ( $ amount , Config :: TRANS_FEE , 2 ) !== - 1 && empty ( $ remark ) ) { throw new PayException ( '转账金额大于等于' . Config::TRANS F E, '必须 设置 remark') ; } } 
protected function getBizContent ( ) { $ content = [ 'out_biz_no' => $ this -> trans_no , 
protected function checkDataParam ( ) { $ tradeNo = $ this -> trade_no ; 
public static function createFromDocComment ( PhpToken $ input , array $ ignoredTags = [ ] ) { if ( ! $ input -> isGivenKind ( T_DOC_COMMENT ) ) { throw new \ InvalidArgumentException ( 'Input must be a T_DOC_COMMENT token.' ) ; } $ tokens = new self ( ) ; $ content = $ input -> getContent ( ) ; $ ignoredTextPosition = 0 ; $ currentPosition = 0 ; while ( false !== $ nextAtPosition = strpos ( $ content , '@' , $ currentPosition ) ) { if ( 0 !== $ nextAtPosition && ! Preg :: match ( '/\s/' , $ content [ $ nextAtPosition - 1 ] ) ) { $ currentPosition = $ nextAtPosition + 1 ; continue ; } $ lexer = new DocLexer ( ) ; $ lexer -> setInput ( substr ( $ content , $ nextAtPosition ) ) ; $ scannedTokens = [ ] ; $ index = 0 ; $ nbScannedTokensToUse = 0 ; $ nbScopes = 0 ; while ( null !== $ token = $ lexer -> peek ( ) ) { if ( 0 === $ index && DocLexer :: T_AT !== $ token [ 'type' ] ) { break ; } if ( 1 === $ index ) { if ( DocLexer :: T_IDENTIFIER !== $ token [ 'type' ] || \ in_array ( $ token [ 'value' ] , $ ignoredTags , true ) ) { break ; } $ nbScannedTokensToUse = 2 ; } if ( $ index >= 2 && 0 === $ nbScopes && ! \ in_array ( $ token [ 'type' ] , [ DocLexer :: T_NONE , DocLexer :: T_OPEN_PARENTHESIS ] , true ) ) { break ; } $ scannedTokens [ ] = $ token ; if ( DocLexer :: T_OPEN_PARENTHESIS === $ token [ 'type' ] ) { ++ $ nbScopes ; } elseif ( DocLexer :: T_CLOSE_PARENTHESIS === $ token [ 'type' ] ) { if ( 0 === -- $ nbScopes ) { $ nbScannedTokensToUse = \ count ( $ scannedTokens ) ; break ; } } ++ $ index ; } if ( 0 !== $ nbScopes ) { break ; } if ( 0 !== $ nbScannedTokensToUse ) { $ ignoredTextLength = $ nextAtPosition - $ ignoredTextPosition ; if ( 0 !== $ ignoredTextLength ) { $ tokens [ ] = new Token ( DocLexer :: T_NONE , substr ( $ content , $ ignoredTextPosition , $ ignoredTextLength ) ) ; } $ lastTokenEndIndex = 0 ; foreach ( \ array_slice ( $ scannedTokens , 0 , $ nbScannedTokensToUse ) as $ token ) { if ( DocLexer :: T_STRING === $ token [ 'type' ] ) { $ token [ 'value' ] = '"' . str_replace ( '"' , '""' , $ token [ 'value' ] ) . '"' ; } $ missingTextLength = $ token [ 'position' ] - $ lastTokenEndIndex ; if ( $ missingTextLength > 0 ) { $ tokens [ ] = new Token ( DocLexer :: T_NONE , substr ( $ content , $ nextAtPosition + $ lastTokenEndIndex , $ missingTextLength ) ) ; } $ tokens [ ] = new Token ( $ token [ 'type' ] , $ token [ 'value' ] ) ; $ lastTokenEndIndex = $ token [ 'position' ] + \ strlen ( $ token [ 'value' ] ) ; } $ currentPosition = $ ignoredTextPosition = $ nextAtPosition + $ token [ 'position' ] + \ strlen ( $ token [ 'value' ] ) ; } else { $ currentPosition = $ nextAtPosition + 1 ; } } if ( $ ignoredTextPosition < \ strlen ( $ content ) ) { $ tokens [ ] = new Token ( DocLexer :: T_NONE , substr ( $ content , $ ignoredTextPosition ) ) ; } return $ tokens ; } 
public function getAnnotationEnd ( $ index ) { $ currentIndex = null ; if ( isset ( $ this [ $ index + 2 ] ) ) { if ( $ this [ $ index + 2 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { $ currentIndex = $ index + 2 ; } elseif ( isset ( $ this [ $ index + 3 ] ) && $ this [ $ index + 2 ] -> isType ( DocLexer :: T_NONE ) && $ this [ $ index + 3 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) && Preg :: match ( '/^(\R\s*\*\s*)*\s*$/' , $ this [ $ index + 2 ] -> getContent ( ) ) ) { $ currentIndex = $ index + 3 ; } } if ( null !== $ currentIndex ) { $ level = 0 ; for ( $ max = \ count ( $ this ) ; $ currentIndex < $ max ; ++ $ currentIndex ) { if ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { ++ $ level ; } elseif ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_CLOSE_PARENTHESIS ) ) { -- $ level ; } if ( 0 === $ level ) { return $ currentIndex ; } } return null ; } return $ index + 1 ; } 
public function getArrayEnd ( $ index ) { $ level = 1 ; for ( ++ $ index , $ max = \ count ( $ this ) ; $ index < $ max ; ++ $ index ) { if ( $ this [ $ index ] -> isType ( DocLexer :: T_OPEN_CURLY_BRACES ) ) { ++ $ level ; } elseif ( $ this [ $ index ] -> isType ( $ index , DocLexer :: T_CLOSE_CURLY_BRACES ) ) { -- $ level ; } if ( 0 === $ level ) { return $ index ; } } return null ; } 
public function insertAt ( $ index , Token $ token ) { $ this -> setSize ( $ this -> getSize ( ) + 1 ) ; for ( $ i = $ this -> getSize ( ) - 1 ; $ i > $ index ; -- $ i ) { $ this [ $ i ] = isset ( $ this [ $ i - 1 ] ) ? $ this [ $ i - 1 ] : new Token ( ) ; } $ this [ $ index ] = $ token ; } 
public function offsetSet ( $ index , $ token ) { if ( ! $ token instanceof Token ) { $ type = \ gettype ( $ token ) ; if ( 'object' === $ type ) { $ type = \ get_class ( $ token ) ; } throw new \ InvalidArgumentException ( sprintf ( 'Token must be an instance of PhpCsFixer\\Doctrine\\Annotation\\Token, %s given.' , $ type ) ) ; } if ( null === $ index ) { $ index = \ count ( $ this ) ; $ this -> setSize ( $ this -> getSize ( ) + 1 ) ; } parent :: offsetSet ( $ index , $ token ) ; } 
public function offsetUnset ( $ index ) { if ( ! isset ( $ this [ $ index ] ) ) { throw new \ OutOfBoundsException ( sprintf ( 'Index %s is invalid or does not exist.' , $ index ) ) ; } $ max = \ count ( $ this ) - 1 ; while ( $ index < $ max ) { $ this [ $ index ] = $ this [ $ index + 1 ] ; ++ $ index ; } parent :: offsetUnset ( $ index ) ; $ this -> setSize ( $ max ) ; } 
private function getMeaningfulTokenSibling ( $ index , $ direction ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { break ; } if ( ! $ this [ $ index ] -> isType ( DocLexer :: T_NONE ) ) { return $ index ; } } return null ; } 
private function getTokenOfTypeSibling ( $ index , $ type , $ direction ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { break ; } if ( $ this [ $ index ] -> isType ( $ type ) ) { return $ index ; } } return null ; } 
protected function fixLinesBeforeNamespace ( Tokens $ tokens , $ index , $ expectedMin , $ expectedMax ) { 
public function lintFile ( $ path ) { $ checksum = crc32 ( file_get_contents ( $ path ) ) ; if ( ! isset ( $ this -> cache [ $ checksum ] ) ) { $ this -> cache [ $ checksum ] = $ this -> sublinter -> lintFile ( $ path ) ; } return $ this -> cache [ $ checksum ] ; } 
public function lintSource ( $ source ) { $ checksum = crc32 ( $ source ) ; if ( ! isset ( $ this -> cache [ $ checksum ] ) ) { $ this -> cache [ $ checksum ] = $ this -> sublinter -> lintSource ( $ source ) ; } return $ this -> cache [ $ checksum ] ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> equals ( '(' ) ) { continue ; } $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; 
private function removeSpaceAroundToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isWhitespace ( ) && false === strpos ( $ token -> getContent ( ) , "\n" ) ) { $ tokens -> clearAt ( $ index ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ doc = new DocBlock ( $ token -> getContent ( ) ) ; $ annotations = $ doc -> getAnnotations ( ) ; if ( empty ( $ annotations ) ) { continue ; } foreach ( $ annotations as $ annotation ) { if ( ! $ annotation -> getTag ( ) -> valid ( ) || ! \ in_array ( $ annotation -> getTag ( ) -> getName ( ) , $ this -> tags , true ) ) { continue ; } $ lineAfterAnnotation = $ doc -> getLine ( $ annotation -> getEnd ( ) + 1 ) ; if ( null !== $ lineAfterAnnotation ) { $ lineAfterAnnotationTrimmed = ltrim ( $ lineAfterAnnotation -> getContent ( ) ) ; if ( '' === $ lineAfterAnnotationTrimmed || '*' !== $ lineAfterAnnotationTrimmed [ 0 ] ) { 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; $ index > 0 ; -- $ index ) { $ expressionEnd = $ tokens [ $ index ] ; if ( ! $ expressionEnd -> equalsAny ( self :: EXPRESSION_END_TOKENS ) ) { continue ; } $ numberIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; $ number = $ tokens [ $ numberIndex ] ; if ( ! $ number -> isGivenKind ( T_LNUMBER ) || '1' !== $ number -> getContent ( ) ) { continue ; } $ operatorIndex = $ tokens -> getPrevMeaningfulToken ( $ numberIndex ) ; $ operator = $ tokens [ $ operatorIndex ] ; if ( ! $ operator -> isGivenKind ( [ T_PLUS_EQUAL , T_MINUS_EQUAL ] ) ) { continue ; } $ startIndex = $ this -> findStart ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ operatorIndex ) ) ; $ this -> clearRangeLeaveComments ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ operatorIndex ) + 1 , $ numberIndex ) ; $ tokens -> insertAt ( $ startIndex , new Token ( $ operator -> isGivenKind ( T_PLUS_EQUAL ) ? [ T_INC , '++' ] : [ T_DEC , '--' ] ) ) ; } } 
private function findStart ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ $ index ] -> equalsAny ( [ '$' , [ T_VARIABLE ] ] ) ) { if ( $ tokens [ $ index ] -> equals ( ']' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_INDEX_SQUARE_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_PROP_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_PROP_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_VAR_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_VAR_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_INDEX_CURLY_BRACE , $ index ) ; } else { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } } while ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equals ( '$' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } if ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return $ this -> findStart ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ index ) ) ; } return $ index ; } 
private function clearRangeLeaveComments ( Tokens $ tokens , $ indexStart , $ indexEnd ) { for ( $ i = $ indexStart ; $ i <= $ indexEnd ; ++ $ i ) { $ token = $ tokens [ $ i ] ; if ( $ token -> isComment ( ) ) { continue ; } if ( $ token -> isWhitespace ( "\n\r" ) ) { continue ; } $ tokens -> clearAt ( $ i ) ; } } 
public static function shouldBeTogether ( Tag $ first , Tag $ second ) { $ firstName = $ first -> getName ( ) ; $ secondName = $ second -> getName ( ) ; if ( $ firstName === $ secondName ) { return true ; } foreach ( self :: $ groups as $ group ) { if ( \ in_array ( $ firstName , $ group , true ) && \ in_array ( $ secondName , $ group , true ) ) { return true ; } } return false ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; $ index >= 0 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> equals ( '!' ) ) { if ( ! $ tokens [ $ index + 1 ] -> isWhitespace ( ) ) { $ tokens -> insertAt ( $ index + 1 , new Token ( [ T_WHITESPACE , ' ' ] ) ) ; } if ( ! $ tokens [ $ index - 1 ] -> isWhitespace ( ) ) { $ tokens -> insertAt ( $ index , new Token ( [ T_WHITESPACE , ' ' ] ) ) ; } } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; for ( $ index = 1 , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { continue ; } if ( $ this -> canBeMovedToNextLine ( $ index , $ tokens ) ) { $ newline = new Token ( [ T_WHITESPACE , $ lineEnding ] ) ; if ( $ tokens [ $ index - 1 ] -> isWhitespace ( ) ) { $ tokens [ $ index - 1 ] = $ newline ; } else { $ tokens -> insertAt ( $ index , $ newline ) ; ++ $ index ; } } $ currentIndent = $ this -> getIndentAt ( $ tokens , $ index - 1 ) ; if ( null === $ currentIndent ) { continue ; } $ expectedIndent = $ this -> getExpectedIndentAt ( $ tokens , $ index ) ; if ( $ currentIndent !== $ expectedIndent ) { $ tokens [ $ index - 1 ] = new Token ( [ T_WHITESPACE , $ lineEnding . $ expectedIndent ] ) ; } } } 
private function getExpectedIndentAt ( Tokens $ tokens , $ index ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; $ indent = $ this -> whitespacesConfig -> getIndent ( ) ; for ( $ i = $ index ; $ i >= 0 ; -- $ i ) { if ( $ tokens [ $ i ] -> equals ( ')' ) ) { $ i = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ i ) ; } $ currentIndent = $ this -> getIndentAt ( $ tokens , $ i ) ; if ( null === $ currentIndent ) { continue ; } if ( $ this -> currentLineRequiresExtraIndentLevel ( $ tokens , $ i , $ index ) ) { return $ currentIndent . $ indent ; } return $ currentIndent ; } return $ indent ; } 
private function canBeMovedToNextLine ( $ index , Tokens $ tokens ) { $ prevMeaningful = $ tokens -> getPrevMeaningfulToken ( $ index ) ; $ hasCommentBefore = false ; for ( $ i = $ index - 1 ; $ i > $ prevMeaningful ; -- $ i ) { if ( $ tokens [ $ i ] -> isComment ( ) ) { $ hasCommentBefore = true ; continue ; } if ( $ tokens [ $ i ] -> isWhitespace ( ) && 1 === Preg :: match ( '/\R/' , $ tokens [ $ i ] -> getContent ( ) ) ) { return $ hasCommentBefore ; } } return false ; } 
private function getIndentAt ( Tokens $ tokens , $ index ) { if ( 1 === Preg :: match ( '/\R{1}([ \t]*)$/' , $ this -> getIndentContentAt ( $ tokens , $ index ) , $ matches ) ) { return $ matches [ 1 ] ; } return null ; } 
private function currentLineRequiresExtraIndentLevel ( Tokens $ tokens , $ start , $ end ) { if ( $ tokens [ $ start + 1 ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return false ; } if ( $ tokens [ $ end ] -> isGivenKind ( CT :: T_BRACE_CLASS_INSTANTIATION_CLOSE ) ) { return true ; } return ! $ tokens [ $ end ] -> equals ( ')' ) || $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ end ) >= $ start ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { 
private function hasVoidReturnAnnotation ( Tokens $ tokens , $ index ) { foreach ( $ this -> findReturnAnnotations ( $ tokens , $ index ) as $ return ) { if ( [ 'void' ] === $ return -> getTypes ( ) ) { return true ; } } return false ; } 
private function hasReturnTypeHint ( Tokens $ tokens , $ index ) { $ endFuncIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' ] ) ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endFuncIndex ) ; return $ tokens [ $ nextIndex ] -> isGivenKind ( CT :: T_TYPE_COLON ) ; } 
private function hasVoidReturn ( Tokens $ tokens , $ startIndex , $ endIndex ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ i = $ startIndex ; $ i < $ endIndex ; ++ $ i ) { if ( 
private function findReturnAnnotations ( Tokens $ tokens , $ index ) { do { $ index = $ tokens -> getPrevNonWhitespace ( $ index ) ; } while ( $ tokens [ $ index ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL , T_PRIVATE , T_PROTECTED , T_PUBLIC , T_STATIC , ] ) ) ; if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DOC_COMMENT ) ) { return [ ] ; } $ doc = new DocBlock ( $ tokens [ $ index ] -> getContent ( ) ) ; return $ doc -> getAnnotationsOfType ( 'return' ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ header = <<<'EOF' PHP Coding Standards Fixer ========================== The PHP Coding Standards Fixer (PHP CS Fixer) tool fixes your code to follow standards; whether you want to follow PHP coding standards as defined in the PSR-1, PSR-2, etc., or other community driven ones like the Symfony one. You can **also** define your (teams) style through configuration. It can modernize your code (like converting the ``pow`` function to the ``**`` operator on PHP 5.6) and (micro) optimize it. If you are already using a linter to identify coding standards problems in your code, you know that fixing them by hand is tedious, especially on large projects. This tool does not only detect them, but also fixes them for you. The PHP CS Fixer is maintained on GitHub at https: bug reports and ideas about new features are welcome there. You can talk to us at https: configuration, possible improvements, ideas and questions, please visit us! Requirements ------------ PHP needs to be a minimum version of PHP 5.6.0. Installation ------------ Locally ~~~~~~~ Download the `php-cs-fixer.phar`_ file and store it somewhere on your computer. Globally (manual) ~~~~~~~~~~~~~~~~~ You can run these commands to easily access latest ``php-cs-fixer`` from anywhere on your system: .. code-block:: bash $ wget %download.url% -O php-cs-fixer or with specified version: .. code-block:: bash $ wget %download.version_url% -O php-cs-fixer or with curl: .. code-block:: bash $ curl -L %download.url% -o php-cs-fixer then: .. code-block:: bash $ sudo chmod a+x php-cs-fixer $ sudo mv php-cs-fixer /usr/local/bin/php-cs-fixer Then, just run ``php-cs-fixer``. Globally (Composer) ~~~~~~~~~~~~~~~~~~~ To install PHP CS Fixer, `install Composer <https: .. code-block:: bash $ composer global require friendsofphp/php-cs-fixer Then make sure you have the global Composer binaries directory in your ``PATH``. This directory is platform-dependent, see `Composer documentation <https: .. code-block:: bash $ export PATH="$PATH:$HOME/.composer/vendor/bin" Globally (homebrew) ~~~~~~~~~~~~~~~~~~~ .. code-block:: bash $ brew install php-cs-fixer Locally (PHIVE) ~~~~~~~~~~~~~~~ Install `PHIVE <https: .. code-block:: bash $ phive install php-cs-fixer # use `--global` for global install Update ------ Locally ~~~~~~~ The ``self-update`` command tries to update ``php-cs-fixer`` itself: .. code-block:: bash $ php php-cs-fixer.phar self-update Globally (manual) ~~~~~~~~~~~~~~~~~ You can update ``php-cs-fixer`` through this command: .. code-block:: bash $ sudo php-cs-fixer self-update Globally (Composer) ~~~~~~~~~~~~~~~~~~~ You can update ``php-cs-fixer`` through this command: .. code-block:: bash $ ./composer.phar global update friendsofphp/php-cs-fixer Globally (homebrew) ~~~~~~~~~~~~~~~~~~~ You can update ``php-cs-fixer`` through this command: .. code-block:: bash $ brew upgrade php-cs-fixer Locally (PHIVE) ~~~~~~~~~~~~~~~~~~~ .. code-block:: bash $ phive update php-cs-fixer Usage ----- EOF ; $ footer = <<<'EOF' Helpers ------- Dedicated plugins exist for: * `Atom`_ * `NetBeans`_ * `PhpStorm`_ * `Sublime Text`_ * `Vim`_ * `VS Code`_ Contribute ---------- The tool comes with quite a few built-in fixers, but everyone is more than welcome to `contribute`_ more of them. Fixers ~~~~~~ A *fixer* is a class that tries to fix one CS issue (a ``Fixer`` class must implement ``FixerInterface``). Configs ~~~~~~~ A *config* knows about the CS rules and the files and directories that must be scanned by the tool when run in the directory of your project. It is useful for projects that follow a well-known directory structures (like for Symfony projects for instance). .. _php-cs-fixer.phar: %download.url% .. _Atom: https: .. _NetBeans: http: .. _PhpStorm: https: .. _Sublime Text: https: .. _Vim: https: .. _VS Code: https: .. _contribute: https: EOF ; $ command = $ this -> getApplication ( ) -> get ( 'fix' ) ; $ help = $ command -> getHelp ( ) ; $ help = str_replace ( '%command.full_name%' , 'php-cs-fixer.phar ' . $ command -> getName ( ) , $ help ) ; $ help = str_replace ( '%command.name%' , $ command -> getName ( ) , $ help ) ; $ help = Preg :: replace ( '#</?(comment|info)>#' , '``' , $ help ) ; $ help = Preg :: replace ( '#`(``.+?``)`#' , '$1' , $ help ) ; $ help = Preg :: replace ( '#^(\s+)``(.+)``$#m' , '$1$2' , $ help ) ; $ help = Preg :: replace ( '#^ \* ``(.+)``(.*?\n)#m' , "* **$1**$2\n" , $ help ) ; $ help = Preg :: replace ( '#^ \\| #m' , ' ' , $ help ) ; $ help = Preg :: replace ( '#^ \\|#m' , '' , $ help ) ; $ help = Preg :: replace ( '#^(?= \\*Risky rule: )#m' , "\n" , $ help ) ; $ help = Preg :: replace ( "#^( Configuration options:\n)( - )#m" , "$1\n$2" , $ help ) ; $ help = Preg :: replace ( "#^\n( +\\$ )#m" , "\n.. code-block:: bash\n\n$1" , $ help ) ; $ help = Preg :: replace ( "#^\n( +<\\?php)#m" , "\n.. code-block:: php\n\n$1" , $ help ) ; $ help = Preg :: replaceCallback ( '#^\s*<\?(\w+).*?\?>#ms' , static function ( $ matches ) { $ result = Preg :: replace ( "#^\\.\\. code-block:: bash\n\n#m" , '' , $ matches [ 0 ] ) ; if ( 'php' !== $ matches [ 1 ] ) { $ result = Preg :: replace ( "#<\\?{$matches[1]}\\s*#" , '' , $ result ) ; } return Preg :: replace ( "#\n\n +\\?>#" , '' , $ result ) ; } , $ help ) ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> equals ( ';' ) || ! $ tokens [ $ index - 1 ] -> isWhitespace ( " \t" ) ) { continue ; } if ( $ tokens [ $ index - 2 ] -> equals ( ';' ) ) { 
protected function configure ( ) { $ this -> setName ( self :: COMMAND_NAME ) -> setDefinition ( [ new InputArgument ( 'name' , InputArgument :: REQUIRED , 'Name of rule / set.' ) , ] ) -> setDescription ( 'Describe rule / ruleset.' ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ name = $ input -> getArgument ( 'name' ) ; try { if ( '@' === $ name [ 0 ] ) { $ this -> describeSet ( $ output , $ name ) ; return null ; } $ this -> describeRule ( $ output , $ name ) ; } catch ( DescribeNameNotFoundException $ e ) { $ matcher = new WordMatcher ( 'set' === $ e -> getType ( ) ? $ this -> getSetNames ( ) : array_keys ( $ this -> getFixers ( ) ) ) ; $ alternative = $ matcher -> match ( $ name ) ; $ this -> describeList ( $ output , $ e -> getType ( ) ) ; throw new \ InvalidArgumentException ( sprintf ( '%s "%s" not found.%s' , ucfirst ( $ e -> getType ( ) ) , $ name , null === $ alternative ? '' : ' Did you mean "' . $ alternative . '"?' ) ) ; } } 
public function generate ( $ input ) { $ tokens = [ ] ; $ parts = explode ( '\\' , $ input ) ; foreach ( $ parts as $ index => $ part ) { $ tokens [ ] = new Token ( [ T_STRING , $ part ] ) ; if ( $ index !== \ count ( $ parts ) - 1 ) { $ tokens [ ] = new Token ( [ T_NS_SEPARATOR , '\\' ] ) ; } } return $ tokens ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { $ originalContent = $ token -> getContent ( ) ; if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) && ! ( $ token -> isGivenKind ( T_COMMENT ) && 0 === strpos ( $ originalContent , '/*' ) ) ) { continue ; } $ newContent = $ originalContent ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; $ usesIndexes = $ tokensAnalyzer -> getImportUseIndexes ( ) ; foreach ( $ usesIndexes as $ idx ) { $ nextTokenIdx = $ tokens -> getNextMeaningfulToken ( $ idx ) ; $ nextToken = $ tokens [ $ nextTokenIdx ] ; if ( $ nextToken -> isGivenKind ( T_NS_SEPARATOR ) ) { $ tokens -> clearAt ( $ nextTokenIdx ) ; } elseif ( $ nextToken -> isGivenKind ( [ CT :: T_FUNCTION_IMPORT , CT :: T_CONST_IMPORT ] ) ) { $ nextTokenIdx = $ tokens -> getNextMeaningfulToken ( $ nextTokenIdx ) ; if ( $ tokens [ $ nextTokenIdx ] -> isGivenKind ( T_NS_SEPARATOR ) ) { $ tokens -> clearAt ( $ nextTokenIdx ) ; } } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ i = 0 , $ l = $ tokens -> count ( ) ; $ i < $ l ; ++ $ i ) { if ( ! $ tokens [ $ i ] -> isGivenKind ( T_FUNCTION ) ) { continue ; } $ startIndex = $ tokens -> getNextTokenOfKind ( $ i , [ '(' ] ) ; $ i = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startIndex ) ; $ this -> fixFunctionDefinition ( $ tokens , $ startIndex , $ i ) ; } } 
private function getLastNonDefaultArgumentIndex ( Tokens $ tokens , $ startIndex , $ endIndex ) { for ( $ i = $ endIndex - 1 ; $ i > $ startIndex ; -- $ i ) { $ token = $ tokens [ $ i ] ; if ( $ token -> equals ( '=' ) ) { $ i = $ tokens -> getPrevMeaningfulToken ( $ i ) ; continue ; } if ( $ token -> isGivenKind ( T_VARIABLE ) && ! $ this -> isEllipsis ( $ tokens , $ i ) ) { return $ i ; } } } 
private function isEllipsis ( Tokens $ tokens , $ variableIndex ) { return $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ variableIndex ) ] -> isGivenKind ( T_ELLIPSIS ) ; } 
private function isNonNullableTypehintedNullableVariable ( Tokens $ tokens , $ index ) { $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; if ( ! $ nextToken -> equals ( [ T_STRING , 'null' ] , false ) ) { return false ; } $ variableIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; $ searchTokens = [ ',' , '(' , [ T_STRING ] , [ CT :: T_ARRAY_TYPEHINT ] , [ T_CALLABLE ] ] ; $ typehintKinds = [ T_STRING , CT :: T_ARRAY_TYPEHINT , T_CALLABLE ] ; $ prevIndex = $ tokens -> getPrevTokenOfKind ( $ variableIndex , $ searchTokens ) ; if ( ! $ tokens [ $ prevIndex ] -> isGivenKind ( $ typehintKinds ) ) { return false ; } return ! $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ prevIndex ) ] -> isGivenKind ( CT :: T_NULLABLE_TYPE ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isKeyword ( ) && ! $ token -> isGivenKind ( self :: $ excludedTokens ) ) { $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , strtolower ( $ token -> getContent ( ) ) ] ) ; } } } 
public function getDefinition ( ) { return new FixerDefinition ( 'Ordering `use` statements.' , [ new CodeSample ( "<?php\nuse Z; use A;\n" ) , new CodeSample ( '<?php use Acme\Bar; use Bar1; use Acme; use Bar; ' , [ 'sort_algorithm' => self :: SORT_LENGTH ] ) , new VersionSpecificCodeSample ( "<?php\nuse function AAC;\nuse const AAB;\nuse AAA;\n" , new VersionSpecification ( 70000 ) ) , new VersionSpecificCodeSample ( '<?php use const AAAA; use const BBB; use Bar; use AAC; use Acme; use function CCC\AA; use function DDD; ' , new VersionSpecification ( 70000 ) , [ 'sort_algorithm' => self :: SORT_LENGTH , 'imports_order' => [ self :: IMPORT_TYPE_CONST , self :: IMPORT_TYPE_CLASS , self :: IMPORT_TYPE_FUNCTION , ] , ] ) , new VersionSpecificCodeSample ( '<?php use const BBB; use const AAAA; use Acme; use AAC; use Bar; use function DDD; use function CCC\AA; ' , new VersionSpecification ( 70000 ) , [ 'sort_algorithm' => self :: SORT_ALPHA , 'imports_order' => [ self :: IMPORT_TYPE_CONST , self :: IMPORT_TYPE_CLASS , self :: IMPORT_TYPE_FUNCTION , ] , ] ) , new VersionSpecificCodeSample ( '<?php use const BBB; use const AAAA; use function DDD; use function CCC\AA; use Acme; use AAC; use Bar; ' , new VersionSpecification ( 70000 ) , [ 'sort_algorithm' => self :: SORT_NONE , 'imports_order' => [ self :: IMPORT_TYPE_CONST , self :: IMPORT_TYPE_CLASS , self :: IMPORT_TYPE_FUNCTION , ] , ] ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; $ namespacesImports = $ tokensAnalyzer -> getImportUseIndexes ( true ) ; if ( 0 === \ count ( $ namespacesImports ) ) { return ; } $ usesOrder = [ ] ; foreach ( $ namespacesImports as $ uses ) { $ usesOrder [ ] = $ this -> getNewOrder ( array_reverse ( $ uses ) , $ tokens ) ; } $ usesOrder = array_replace ( ... $ usesOrder ) ; $ usesOrder = array_reverse ( $ usesOrder , true ) ; $ mapStartToEnd = [ ] ; foreach ( $ usesOrder as $ use ) { $ mapStartToEnd [ $ use [ 'startIndex' ] ] = $ use [ 'endIndex' ] ; } 
protected function createConfigurationDefinition ( ) { $ supportedSortTypes = $ this -> supportedSortTypes ; return new FixerConfigurationResolver ( [ ( new AliasedFixerOptionBuilder ( new FixerOptionBuilder ( 'sort_algorithm' , 'whether the statements should be sorted alphabetically or by length, or not sorted' ) , 'sortAlgorithm' ) ) -> setAllowedValues ( $ this -> supportedSortAlgorithms ) -> setDefault ( self :: SORT_ALPHA ) -> getOption ( ) , ( new AliasedFixerOptionBuilder ( new FixerOptionBuilder ( 'imports_order' , 'Defines the order of import types.' ) , 'importsOrder' ) ) -> setAllowedTypes ( [ 'array' , 'null' ] ) -> setAllowedValues ( [ static function ( $ value ) use ( $ supportedSortTypes ) { if ( null !== $ value ) { $ missing = array_diff ( $ supportedSortTypes , $ value ) ; if ( \ count ( $ missing ) ) { throw new InvalidOptionsException ( sprintf ( 'Missing sort %s "%s".' , 1 === \ count ( $ missing ) ? 'type' : 'types' , implode ( '", "' , $ missing ) ) ) ; } $ unknown = array_diff ( $ value , $ supportedSortTypes ) ; if ( \ count ( $ unknown ) ) { throw new InvalidOptionsException ( sprintf ( 'Unknown sort %s "%s".' , 1 === \ count ( $ unknown ) ? 'type' : 'types' , implode ( '", "' , $ unknown ) ) ) ; } } return true ; } ] ) -> setDefault ( null ) -> getOption ( ) , ] ) ; } 
private function sortAlphabetically ( array $ first , array $ second ) { 
private function sortByLength ( array $ first , array $ second ) { $ firstNamespace = ( self :: IMPORT_TYPE_CLASS === $ first [ 'importType' ] ? '' : $ first [ 'importType' ] . ' ' ) . $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ; $ secondNamespace = ( self :: IMPORT_TYPE_CLASS === $ second [ 'importType' ] ? '' : $ second [ 'importType' ] . ' ' ) . $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ; $ firstNamespaceLength = \ strlen ( $ firstNamespace ) ; $ secondNamespaceLength = \ strlen ( $ secondNamespace ) ; if ( $ firstNamespaceLength === $ secondNamespaceLength ) { $ sortResult = strcasecmp ( $ firstNamespace , $ secondNamespace ) ; } else { $ sortResult = $ firstNamespaceLength > $ secondNamespaceLength ? 1 : - 1 ; } return $ sortResult ; } 
private function getNewOrder ( array $ uses , Tokens $ tokens ) { $ indexes = [ ] ; $ originalIndexes = [ ] ; $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; for ( $ i = \ count ( $ uses ) - 1 ; $ i >= 0 ; -- $ i ) { $ index = $ uses [ $ i ] ; $ startIndex = $ tokens -> getTokenNotOfKindSibling ( $ index + 1 , 1 , [ [ T_WHITESPACE ] ] ) ; $ endIndex = $ tokens -> getNextTokenOfKind ( $ startIndex , [ ';' , [ T_CLOSE_TAG ] ] ) ; $ previous = $ tokens -> getPrevMeaningfulToken ( $ endIndex ) ; $ group = $ tokens [ $ previous ] -> isGivenKind ( CT :: T_GROUP_IMPORT_BRACE_CLOSE ) ; if ( $ tokens [ $ startIndex ] -> isGivenKind ( CT :: T_CONST_IMPORT ) ) { $ type = self :: IMPORT_TYPE_CONST ; $ index = $ tokens -> getNextNonWhitespace ( $ startIndex ) ; } elseif ( $ tokens [ $ startIndex ] -> isGivenKind ( CT :: T_FUNCTION_IMPORT ) ) { $ type = self :: IMPORT_TYPE_FUNCTION ; $ index = $ tokens -> getNextNonWhitespace ( $ startIndex ) ; } else { $ type = self :: IMPORT_TYPE_CLASS ; $ index = $ startIndex ; } $ namespaceTokens = [ ] ; while ( $ index <= $ endIndex ) { $ token = $ tokens [ $ index ] ; if ( $ index === $ endIndex || ( ! $ group && $ token -> equals ( ',' ) ) ) { if ( $ group && self :: SORT_NONE !== $ this -> configuration [ 'sort_algorithm' ] ) { 
private function sortByAlgorithm ( array $ indexes ) { if ( self :: SORT_ALPHA === $ this -> configuration [ 'sort_algorithm' ] ) { uasort ( $ indexes , [ $ this , 'sortAlphabetically' ] ) ; } elseif ( self :: SORT_LENGTH === $ this -> configuration [ 'sort_algorithm' ] ) { uasort ( $ indexes , [ $ this , 'sortByLength' ] ) ; } return $ indexes ; } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> fixMessageRegExp = PhpUnitTargetVersion :: fulfills ( $ this -> configuration [ 'target' ] , PhpUnitTargetVersion :: VERSION_4_3 ) ; } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'target' , 'Target version of PHPUnit.' ) ) -> setAllowedTypes ( [ 'string' ] ) -> setAllowedValues ( [ PhpUnitTargetVersion :: VERSION_3_2 , PhpUnitTargetVersion :: VERSION_4_3 , PhpUnitTargetVersion :: VERSION_NEWEST ] ) -> setDefault ( PhpUnitTargetVersion :: VERSION_NEWEST ) -> getOption ( ) , ( new FixerOptionBuilder ( 'use_class_const' , 'Use ::class notation.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( true ) -> getOption ( ) , ] ) ; } 
private function detectIndent ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index - 1 ] -> isWhitespace ( ) ) { return '' ; 
private function extractContentFromAnnotation ( Annotation $ annotation ) { $ tag = $ annotation -> getTag ( ) -> getName ( ) ; Preg :: match ( '/@' . $ tag . '\s+(.+)$/s' , $ annotation -> getContent ( ) , $ matches ) ; $ content = $ matches [ 1 ] ; if ( Preg :: match ( '/\R/u' , $ content ) ) { $ content = Preg :: replace ( '/\s*\R+\s*\*\s*/u' , ' ' , $ content ) ; } return rtrim ( $ content ) ; } 
public function getDeclarations ( Tokens $ tokens ) { $ namespaces = [ ] ; for ( $ index = 1 , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_NAMESPACE ) ) { continue ; } $ declarationEndIndex = $ tokens -> getNextTokenOfKind ( $ index , [ ';' , '{' ] ) ; $ namespace = trim ( $ tokens -> generatePartialCode ( $ index + 1 , $ declarationEndIndex - 1 ) ) ; $ declarationParts = explode ( '\\' , $ namespace ) ; $ shortName = end ( $ declarationParts ) ; if ( $ tokens [ $ declarationEndIndex ] -> equals ( '{' ) ) { $ scopeEndIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ declarationEndIndex ) ; } else { $ scopeEndIndex = $ tokens -> getNextTokenOfKind ( $ declarationEndIndex , [ [ T_NAMESPACE ] ] ) ; if ( null === $ scopeEndIndex ) { $ scopeEndIndex = \ count ( $ tokens ) ; } -- $ scopeEndIndex ; } $ namespaces [ ] = new NamespaceAnalysis ( $ namespace , $ shortName , $ index , $ declarationEndIndex , $ index , $ scopeEndIndex ) ; 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( ! $ token -> equals ( '?' ) ) { return ; } $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; $ prevToken = $ tokens [ $ prevIndex ] ; if ( $ prevToken -> equalsAny ( [ '(' , ',' , [ CT :: T_TYPE_COLON ] ] ) ) { $ tokens [ $ index ] = new Token ( [ CT :: T_NULLABLE_TYPE , '?' ] ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_CONSTANT_ENCAPSED_STRING ) ) { continue ; } $ content = $ token -> getContent ( ) ; $ prefix = '' ; if ( 'b' === strtolower ( $ content [ 0 ] ) ) { $ prefix = $ content [ 0 ] ; $ content = substr ( $ content , 1 ) ; } if ( '"' === $ content [ 0 ] && ( true === $ this -> configuration [ 'strings_containing_single_quote_chars' ] || false === strpos ( $ content , "'" ) ) && 
public function configure ( array $ configuration = null ) { if ( null !== $ configuration && ( \ array_key_exists ( 'align_equals' , $ configuration ) || \ array_key_exists ( 'align_double_arrow' , $ configuration ) ) ) { $ configuration = $ this -> resolveOldConfig ( $ configuration ) ; } parent :: configure ( $ configuration ) ; $ this -> operators = $ this -> resolveOperatorsFromConfig ( ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ this -> tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'default' , 'Default fix strategy.' ) ) -> setDefault ( self :: SINGLE_SPACE ) -> setAllowedValues ( self :: $ allowedValues ) -> getOption ( ) , ( new FixerOptionBuilder ( 'operators' , 'Dictionary of `binary operator` => `fix strategy` values that differ from the default strategy.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ static function ( $ option ) { foreach ( $ option as $ operator => $ value ) { if ( ! \ in_array ( $ operator , self :: $ supportedOperators , true ) ) { throw new InvalidOptionsException ( sprintf ( 'Unexpected "operators" key, expected any of "%s", got "%s".' , implode ( '", "' , self :: $ supportedOperators ) , \ is_object ( $ operator ) ? \ get_class ( $ operator ) : \ gettype ( $ operator ) . '#' . $ operator ) ) ; } if ( ! \ in_array ( $ value , self :: $ allowedValues , true ) ) { throw new InvalidOptionsException ( sprintf ( 'Unexpected value for operator "%s", expected any of "%s", got "%s".' , $ operator , implode ( '", "' , self :: $ allowedValues ) , \ is_object ( $ value ) ? \ get_class ( $ value ) : ( null === $ value ? 'null' : \ gettype ( $ value ) . '#' . $ value ) ) ) ; } } return true ; } ] ) -> setDefault ( [ ] ) -> getOption ( ) , 
private function isEqualPartOfDeclareStatement ( Tokens $ tokens , $ index ) { $ prevMeaningfulIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ prevMeaningfulIndex ] -> isGivenKind ( T_STRING ) ) { $ prevMeaningfulIndex = $ tokens -> getPrevMeaningfulToken ( $ prevMeaningfulIndex ) ; if ( $ tokens [ $ prevMeaningfulIndex ] -> equals ( '(' ) ) { $ prevMeaningfulIndex = $ tokens -> getPrevMeaningfulToken ( $ prevMeaningfulIndex ) ; if ( $ tokens [ $ prevMeaningfulIndex ] -> isGivenKind ( T_DECLARE ) ) { return $ prevMeaningfulIndex ; } } } return false ; } 
private function resolveOldConfig ( array $ configuration ) { $ newConfig = [ 'operators' => [ ] , ] ; foreach ( $ configuration as $ name => $ setting ) { if ( 'align_double_arrow' === $ name ) { if ( true === $ configuration [ $ name ] ) { $ newConfig [ 'operators' ] [ '=>' ] = self :: ALIGN ; } elseif ( false === $ configuration [ $ name ] ) { $ newConfig [ 'operators' ] [ '=>' ] = self :: SINGLE_SPACE ; } elseif ( null !== $ configuration [ $ name ] ) { throw new InvalidFixerConfigurationException ( $ this -> getName ( ) , sprintf ( 'Invalid configuration: The option "align_double_arrow" with value %s is invalid. Accepted values are: true, false, null.' , $ configuration [ $ name ] ) ) ; } } elseif ( 'align_equals' === $ name ) { if ( true === $ configuration [ $ name ] ) { $ newConfig [ 'operators' ] [ '=' ] = self :: ALIGN ; } elseif ( false === $ configuration [ $ name ] ) { $ newConfig [ 'operators' ] [ '=' ] = self :: SINGLE_SPACE ; } elseif ( null !== $ configuration [ $ name ] ) { throw new InvalidFixerConfigurationException ( $ this -> getName ( ) , sprintf ( 'Invalid configuration: The option "align_equals" with value %s is invalid. Accepted values are: true, false, null.' , $ configuration [ $ name ] ) ) ; } } else { throw new InvalidFixerConfigurationException ( $ this -> getName ( ) , 'Mixing old configuration with new configuration is not allowed.' ) ; } } $ message = sprintf ( 'Given configuration is deprecated and will be removed in 3.0. Use configuration %s as replacement for %s.' , HelpCommand :: toString ( $ newConfig ) , HelpCommand :: toString ( $ configuration ) ) ; if ( getenv ( 'PHP_CS_FIXER_FUTURE_MODE' ) ) { throw new InvalidFixerConfigurationException ( $ this -> getName ( ) , "{$message} This check was performed as `PHP_CS_FIXER_FUTURE_MODE` env var is set." ) ; } @ trigger_error ( $ message , E_USER_DEPRECATED ) ; return $ newConfig ; } 
private function replacePlaceholders ( Tokens $ tokens , $ alignStrategy ) { $ tmpCode = $ tokens -> generateCode ( ) ; for ( $ j = 0 ; $ j <= $ this -> deepestLevel ; ++ $ j ) { $ placeholder = sprintf ( self :: ALIGN_PLACEHOLDER , $ j ) ; if ( false === strpos ( $ tmpCode , $ placeholder ) ) { continue ; } $ lines = explode ( "\n" , $ tmpCode ) ; $ groups = [ ] ; $ groupIndex = 0 ; $ groups [ $ groupIndex ] = [ ] ; foreach ( $ lines as $ index => $ line ) { if ( substr_count ( $ line , $ placeholder ) > 0 ) { $ groups [ $ groupIndex ] [ ] = $ index ; } else { ++ $ groupIndex ; $ groups [ $ groupIndex ] = [ ] ; } } foreach ( $ groups as $ group ) { if ( \ count ( $ group ) < 1 ) { continue ; } if ( self :: ALIGN !== $ alignStrategy ) { 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOUBLE_ARROW ) ) { continue ; } $ this -> fixWhitespace ( $ tokens , $ index - 1 ) ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } if ( Preg :: match ( '#^/\*\*[\s\*]*\*/$#' , $ token -> getContent ( ) ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ callBack = $ this -> fixCallback ; for ( $ index = $ tokens -> count ( ) - 1 ; $ index >= 0 ; -- $ index ) { if ( $ tokens [ $ index ] -> equals ( '.' ) ) { $ this -> { $ callBack } ( $ tokens , $ index ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ namespaceUseAnalyzer = new NamespaceUsesAnalyzer ( ) ; $ shortNames = [ ] ; foreach ( $ namespaceUseAnalyzer -> getDeclarationsFromTokens ( $ tokens ) as $ namespaceUseAnalysis ) { $ shortNames [ strtolower ( $ namespaceUseAnalysis -> getShortName ( ) ) ] = '\\' . strtolower ( $ namespaceUseAnalysis -> getFullName ( ) ) ; } foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ functionIndex = $ this -> findDocumentedFunction ( $ tokens , $ index ) ; if ( null === $ functionIndex ) { continue ; } $ docBlock = new DocBlock ( $ token -> getContent ( ) ) ; $ openingParenthesisIndex = $ tokens -> getNextTokenOfKind ( $ functionIndex , [ '(' ] ) ; $ closingParenthesisIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ openingParenthesisIndex ) ; $ argumentsInfo = $ this -> getArgumentsInfo ( $ tokens , $ openingParenthesisIndex + 1 , $ closingParenthesisIndex - 1 ) ; foreach ( $ docBlock -> getAnnotationsOfType ( 'param' ) as $ annotation ) { if ( 0 === Preg :: match ( '/@param(?:\s+[^\$]\S+)?\s+(\$\S+)/' , $ annotation -> getContent ( ) , $ matches ) ) { continue ; } $ argumentName = $ matches [ 1 ] ; if ( ! isset ( $ argumentsInfo [ $ argumentName ] ) || $ this -> annotationIsSuperfluous ( $ annotation , $ argumentsInfo [ $ argumentName ] , $ shortNames ) ) { $ annotation -> remove ( ) ; } } $ returnTypeInfo = $ this -> getReturnTypeInfo ( $ tokens , $ closingParenthesisIndex ) ; foreach ( $ docBlock -> getAnnotationsOfType ( 'return' ) as $ annotation ) { if ( $ this -> annotationIsSuperfluous ( $ annotation , $ returnTypeInfo , $ shortNames ) ) { $ annotation -> remove ( ) ; } } $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , $ docBlock -> getContent ( ) ] ) ; } } 
private function getArgumentsInfo ( Tokens $ tokens , $ start , $ end ) { $ argumentsInfo = [ ] ; for ( $ index = $ start ; $ index <= $ end ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_VARIABLE ) ) { continue ; } $ beforeArgumentIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ '(' , ',' ] ) ; $ typeIndex = $ tokens -> getNextMeaningfulToken ( $ beforeArgumentIndex ) ; if ( $ typeIndex !== $ index ) { $ info = $ this -> parseTypeHint ( $ tokens , $ typeIndex ) ; } else { $ info = [ 'type' => null , 'allows_null' => true , ] ; } if ( ! $ info [ 'allows_null' ] ) { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ tokens [ $ nextIndex ] -> equals ( '=' ) && $ tokens [ $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ] -> equals ( [ T_STRING , 'null' ] ) ) { $ info [ 'allows_null' ] = true ; } } $ argumentsInfo [ $ token -> getContent ( ) ] = $ info ; } return $ argumentsInfo ; } 
private function parseTypeHint ( Tokens $ tokens , $ index ) { $ allowsNull = false ; if ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_NULLABLE_TYPE ) ) { $ allowsNull = true ; $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; } $ type = '' ; while ( $ tokens [ $ index ] -> isGivenKind ( [ T_NS_SEPARATOR , T_STRING , CT :: T_ARRAY_TYPEHINT , T_CALLABLE ] ) ) { $ type .= $ tokens [ $ index ] -> getContent ( ) ; $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; } return [ 'type' => $ type , 'allows_null' => $ allowsNull , ] ; } 
private function annotationIsSuperfluous ( Annotation $ annotation , array $ info , array $ symbolShortNames ) { if ( 'param' === $ annotation -> getTag ( ) -> getName ( ) ) { $ regex = '/@param\s+(?:\S|\s(?!\$))+\s\$\S+\s+\S/' ; } else { $ regex = '/@return\s+\S+\s+\S/' ; } if ( Preg :: match ( $ regex , $ annotation -> getContent ( ) ) ) { return false ; } $ annotationTypes = $ this -> toComparableNames ( $ annotation -> getTypes ( ) , $ symbolShortNames ) ; if ( [ 'null' ] === $ annotationTypes ) { return false ; } if ( [ 'mixed' ] === $ annotationTypes && null === $ info [ 'type' ] ) { return ! $ this -> configuration [ 'allow_mixed' ] ; } $ actualTypes = null === $ info [ 'type' ] ? [ ] : [ $ info [ 'type' ] ] ; if ( $ info [ 'allows_null' ] ) { $ actualTypes [ ] = 'null' ; } return $ annotationTypes === $ this -> toComparableNames ( $ actualTypes , $ symbolShortNames ) ; } 
private function toComparableNames ( array $ types , array $ symbolShortNames ) { $ normalized = array_map ( function ( $ type ) use ( $ symbolShortNames ) { $ type = strtolower ( $ type ) ; if ( isset ( $ symbolShortNames [ $ type ] ) ) { return $ symbolShortNames [ $ type ] ; } return $ type ; } , $ types ) ; sort ( $ normalized ) ; return $ normalized ; } 
public function getDefinition ( ) { return new FixerDefinition ( 'Classes must be in a path that matches their namespace, be at least one namespace deep and the class name should match the file name.' , [ new FileSpecificCodeSample ( '<?php namespace PhpCsFixer\FIXER\Basic; class InvalidName {} ' , new \ SplFileInfo ( __FILE__ ) ) , new FileSpecificCodeSample ( '<?php namespace PhpCsFixer\FIXER\Basic; class InvalidName {} ' , new \ SplFileInfo ( __FILE__ ) , [ 'dir' => realpath ( __DIR__ . '/../..' ) ] ) , ] , null , 'This fixer may change your class name, which will break the code that is depended on old name.' ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ namespace = false ; $ namespaceIndex = 0 ; $ namespaceEndIndex = 0 ; $ classyName = null ; $ classyIndex = 0 ; foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isGivenKind ( T_NAMESPACE ) ) { if ( false !== $ namespace ) { return ; } $ namespaceIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ namespaceEndIndex = $ tokens -> getNextTokenOfKind ( $ index , [ ';' ] ) ; $ namespace = trim ( $ tokens -> generatePartialCode ( $ namespaceIndex , $ namespaceEndIndex - 1 ) ) ; } elseif ( $ token -> isClassy ( ) ) { $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ prevToken -> isGivenKind ( T_NEW ) ) { continue ; } if ( null !== $ classyName ) { return ; } $ classyIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ classyName = $ tokens [ $ classyIndex ] -> getContent ( ) ; } } if ( null === $ classyName ) { return ; } if ( false !== $ namespace ) { $ normNamespace = str_replace ( '\\' , '/' , $ namespace ) ; $ path = str_replace ( '\\' , '/' , $ file -> getRealPath ( ) ) ; $ dir = \ dirname ( $ path ) ; if ( '' !== $ this -> configuration [ 'dir' ] ) { $ dir = substr ( $ dir , \ strlen ( realpath ( $ this -> configuration [ 'dir' ] ) ) + 1 ) ; if ( false === $ dir ) { $ dir = '' ; } if ( \ strlen ( $ normNamespace ) > \ strlen ( $ dir ) ) { if ( '' !== $ dir ) { $ normNamespace = substr ( $ normNamespace , - \ strlen ( $ dir ) ) ; } else { $ normNamespace = '' ; } } } $ dir = substr ( $ dir , - \ strlen ( $ normNamespace ) ) ; if ( false === $ dir ) { $ dir = '' ; } $ filename = basename ( $ path , '.php' ) ; if ( $ classyName !== $ filename ) { $ tokens [ $ classyIndex ] = new Token ( [ T_STRING , $ filename ] ) ; } if ( $ normNamespace !== $ dir && strtolower ( $ normNamespace ) === strtolower ( $ dir ) ) { for ( $ i = $ namespaceIndex ; $ i <= $ namespaceEndIndex ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ namespace = substr ( $ namespace , 0 , - \ strlen ( $ dir ) ) . str_replace ( '/' , '\\' , $ dir ) ; $ newNamespace = Tokens :: fromCode ( '<?php namespace ' . $ namespace . ';' ) ; $ newNamespace -> clearRange ( 0 , 2 ) ; $ newNamespace -> clearEmptyTokens ( ) ; $ tokens -> insertAt ( $ namespaceIndex , $ newNamespace ) ; } } else { $ normClass = str_replace ( '_' , '/' , $ classyName ) ; $ path = str_replace ( '\\' , '/' , $ file -> getRealPath ( ) ) ; $ filename = substr ( $ path , - \ strlen ( $ normClass ) - 4 , - 4 ) ; if ( $ normClass !== $ filename && strtolower ( $ normClass ) === strtolower ( $ filename ) ) { $ tokens [ $ classyIndex ] = new Token ( [ T_STRING , str_replace ( '/' , '_' , $ filename ) ] ) ; } } } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ tagsWithNameToAlign = array_intersect ( $ this -> configuration [ 'tags' ] , self :: $ tagsWithName ) ; $ tagsWithMethodSignatureToAlign = array_intersect ( $ this -> configuration [ 'tags' ] , self :: $ tagsWithMethodSignature ) ; $ tagsWithoutNameToAlign = array_diff ( $ this -> configuration [ 'tags' ] , $ tagsWithNameToAlign , $ tagsWithMethodSignatureToAlign ) ; $ types = [ ] ; $ indent = '(?P<indent>(?: {2}|\t)*)' ; 
public function getDefinition ( ) { $ code = <<<'EOF' <?php EOF ; return new FixerDefinition ( 'All items of the given phpdoc tags must be either left-aligned or (by default) aligned vertically.' , [ new CodeSample ( $ code ) , new CodeSample ( $ code , [ 'align' => self :: ALIGN_VERTICAL ] ) , new CodeSample ( $ code , [ 'align' => self :: ALIGN_LEFT ] ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ content = $ token -> getContent ( ) ; $ docBlock = new DocBlock ( $ content ) ; $ this -> fixDocBlock ( $ docBlock ) ; $ newContent = $ docBlock -> getContent ( ) ; if ( $ newContent !== $ content ) { $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , $ newContent ] ) ; } } } 
protected function createConfigurationDefinition ( ) { $ tags = new FixerOptionBuilder ( 'tags' , 'The tags that should be aligned.' ) ; $ tags -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ new AllowedValueSubset ( self :: $ alignableTags ) ] ) -> setDefault ( [ 'param' , 'return' , 'throws' , 'type' , 'var' , ] ) ; $ align = new FixerOptionBuilder ( 'align' , 'Align comments' ) ; $ align -> setAllowedTypes ( [ 'string' ] ) -> setAllowedValues ( [ self :: ALIGN_LEFT , self :: ALIGN_VERTICAL ] ) -> setDefault ( self :: ALIGN_VERTICAL ) ; return new FixerConfigurationResolver ( [ $ tags -> getOption ( ) , $ align -> getOption ( ) ] ) ; } 
private function getMatches ( $ line , $ matchCommentOnly = false ) { if ( Preg :: match ( $ this -> regex , $ line , $ matches ) ) { if ( ! empty ( $ matches [ 'tag2' ] ) ) { $ matches [ 'tag' ] = $ matches [ 'tag2' ] ; $ matches [ 'hint' ] = $ matches [ 'hint2' ] ; $ matches [ 'var' ] = '' ; } if ( ! empty ( $ matches [ 'tag3' ] ) ) { $ matches [ 'tag' ] = $ matches [ 'tag3' ] ; $ matches [ 'hint' ] = $ matches [ 'hint3' ] ; $ matches [ 'var' ] = $ matches [ 'signature' ] ; } if ( isset ( $ matches [ 'hint' ] ) ) { $ matches [ 'hint' ] = trim ( $ matches [ 'hint' ] ) ; } return $ matches ; } if ( $ matchCommentOnly && Preg :: match ( $ this -> regexCommentLine , $ line , $ matches ) ) { $ matches [ 'tag' ] = null ; $ matches [ 'var' ] = '' ; $ matches [ 'hint' ] = '' ; return $ matches ; } } 
private function getIndent ( $ verticalAlignIndent , $ leftAlignIndent = 1 ) { $ indent = self :: ALIGN_VERTICAL === $ this -> align ? $ verticalAlignIndent : $ leftAlignIndent ; return str_repeat ( ' ' , $ indent ) ; } 
private function getLeftAlignedDescriptionIndent ( array $ items , $ index ) { if ( self :: ALIGN_LEFT !== $ this -> align ) { return 0 ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ functions = array_filter ( self :: $ functionsMap , static function ( $ mapping ) { return \ function_exists ( $ mapping [ 'alternativeName' ] ) ; } ) ; $ argumentsAnalyzer = new ArgumentsAnalyzer ( ) ; foreach ( $ functions as $ functionIdentity => $ functionReplacement ) { $ currIndex = 0 ; while ( null !== $ currIndex ) { 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> classElementTypes = [ ] ; 
protected function applyFix ( SplFileInfo $ file , Tokens $ tokens ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; $ class = $ classStart = $ classEnd = false ; foreach ( array_reverse ( $ tokensAnalyzer -> getClassyElements ( ) , true ) as $ index => $ element ) { if ( ! isset ( $ this -> classElementTypes [ $ element [ 'type' ] ] ) ) { continue ; 
private function fixSpaceBelowClassElement ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { for ( $ nextNotWhite = $ elementEndIndex + 1 ; ; ++ $ nextNotWhite ) { if ( ( $ tokens [ $ nextNotWhite ] -> isComment ( ) || $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) && false === strpos ( $ tokens [ $ nextNotWhite ] -> getContent ( ) , "\n" ) ) { continue ; } break ; } if ( $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ nextNotWhite ) ; } $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; } 
private function fixSpaceBelowClassMethod ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ elementEndIndex ) ; $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; } 
private function fixSpaceAboveClassElement ( Tokens $ tokens , $ classStartIndex , $ elementIndex ) { static $ methodAttr = [ T_PRIVATE , T_PROTECTED , T_PUBLIC , T_ABSTRACT , T_FINAL , T_STATIC ] ; 
private function getLineBreakCount ( Tokens $ tokens , $ whiteSpaceStartIndex , $ whiteSpaceEndIndex ) { $ lineCount = 0 ; for ( $ i = $ whiteSpaceStartIndex ; $ i < $ whiteSpaceEndIndex ; ++ $ i ) { $ lineCount += substr_count ( $ tokens [ $ i ] -> getContent ( ) , "\n" ) ; } return $ lineCount ; } 
private function findCommentBlockStart ( Tokens $ tokens , $ commentIndex ) { $ start = $ commentIndex ; for ( $ i = $ commentIndex - 1 ; $ i > 0 ; -- $ i ) { if ( $ tokens [ $ i ] -> isComment ( ) ) { $ start = $ i ; continue ; } if ( ! $ tokens [ $ i ] -> isWhitespace ( ) || $ this -> getLineBreakCount ( $ tokens , $ i , $ i + 1 ) > 1 ) { break ; } } return $ start ; } 
private function replaceClassKeywords ( Tokens $ tokens , $ namespaceNumber = - 1 ) { $ namespaceIndexes = array_keys ( $ tokens -> findGivenKind ( T_NAMESPACE ) ) ; 
private function makeClassFQN ( $ classImport , $ classString ) { if ( false === $ classImport ) { return $ classString ; } $ classStringArray = explode ( '\\' , $ classString ) ; $ classStringLength = \ count ( $ classStringArray ) ; $ classImportArray = explode ( '\\' , $ classImport ) ; $ classImportLength = \ count ( $ classImportArray ) ; if ( 1 === $ classStringLength ) { return $ classImport ; } return implode ( '\\' , array_merge ( \ array_slice ( $ classImportArray , 0 , $ classImportLength - $ classStringLength + 1 ) , $ classStringArray ) ) ; } 
public function getDeclarationsFromTokens ( Tokens $ tokens ) { $ tokenAnalyzer = new TokensAnalyzer ( $ tokens ) ; $ useIndexes = $ tokenAnalyzer -> getImportUseIndexes ( ) ; return $ this -> getDeclarations ( $ tokens , $ useIndexes ) ; } 
private function getDeclarations ( Tokens $ tokens , array $ useIndexes ) { $ uses = [ ] ; foreach ( $ useIndexes as $ index ) { $ endIndex = $ tokens -> getNextTokenOfKind ( $ index , [ ';' , [ T_CLOSE_TAG ] ] ) ; $ analysis = $ this -> parseDeclaration ( $ tokens , $ index , $ endIndex ) ; if ( $ analysis ) { $ uses [ ] = $ analysis ; } } return $ uses ; } 
private function parseDeclaration ( Tokens $ tokens , $ startIndex , $ endIndex ) { $ fullName = $ shortName = '' ; $ aliased = false ; $ type = NamespaceUseAnalysis :: TYPE_CLASS ; for ( $ i = $ startIndex ; $ i <= $ endIndex ; ++ $ i ) { $ token = $ tokens [ $ i ] ; if ( $ token -> equals ( ',' ) || $ token -> isGivenKind ( CT :: T_GROUP_IMPORT_BRACE_CLOSE ) ) { 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( array_merge ( parent :: createConfigurationDefinition ( ) -> getOptions ( ) , [ ( new FixerOptionBuilder ( 'indent_mixed_lines' , 'Whether to indent lines that have content before closing parenthesis.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( false ) -> getOption ( ) , ] ) ) ; } 
protected function fixAnnotations ( Tokens $ tokens ) { $ annotationPositions = [ ] ; for ( $ index = 0 , $ max = \ count ( $ tokens ) ; $ index < $ max ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isType ( DocLexer :: T_AT ) ) { continue ; } $ annotationEndIndex = $ tokens -> getAnnotationEnd ( $ index ) ; if ( null === $ annotationEndIndex ) { return ; } $ annotationPositions [ ] = [ $ index , $ annotationEndIndex ] ; $ index = $ annotationEndIndex ; } $ indentLevel = 0 ; foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isType ( DocLexer :: T_NONE ) || false === strpos ( $ token -> getContent ( ) , "\n" ) ) { continue ; } if ( ! $ this -> indentationCanBeFixed ( $ tokens , $ index , $ annotationPositions ) ) { continue ; } $ braces = $ this -> getLineBracesCount ( $ tokens , $ index ) ; $ delta = $ braces [ 0 ] - $ braces [ 1 ] ; $ mixedBraces = 0 === $ delta && $ braces [ 0 ] > 0 ; $ extraIndentLevel = 0 ; if ( $ indentLevel > 0 && ( $ delta < 0 || $ mixedBraces ) ) { -- $ indentLevel ; if ( $ this -> configuration [ 'indent_mixed_lines' ] && $ this -> isClosingLineWithMeaningfulContent ( $ tokens , $ index ) ) { $ extraIndentLevel = 1 ; } } $ token -> setContent ( Preg :: replace ( '/(\n( +\*)?) *$/' , '$1' . str_repeat ( ' ' , 4 * ( $ indentLevel + $ extraIndentLevel ) + 1 ) , $ token -> getContent ( ) ) ) ; if ( $ delta > 0 || $ mixedBraces ) { ++ $ indentLevel ; } } } 
private function getLineBracesCount ( Tokens $ tokens , $ index ) { $ opening = 0 ; $ closing = 0 ; while ( isset ( $ tokens [ ++ $ index ] ) ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isType ( DocLexer :: T_NONE ) && false !== strpos ( $ token -> getContent ( ) , "\n" ) ) { break ; } if ( $ token -> isType ( [ DocLexer :: T_OPEN_PARENTHESIS , DocLexer :: T_OPEN_CURLY_BRACES ] ) ) { ++ $ opening ; continue ; } if ( ! $ token -> isType ( [ DocLexer :: T_CLOSE_PARENTHESIS , DocLexer :: T_CLOSE_CURLY_BRACES ] ) ) { continue ; } if ( $ opening > 0 ) { -- $ opening ; } else { ++ $ closing ; } } return [ $ opening , $ closing ] ; } 
private function isClosingLineWithMeaningfulContent ( Tokens $ tokens , $ index ) { while ( isset ( $ tokens [ ++ $ index ] ) ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isType ( DocLexer :: T_NONE ) ) { if ( false !== strpos ( $ token -> getContent ( ) , "\n" ) ) { return false ; } continue ; } return ! $ token -> isType ( [ DocLexer :: T_CLOSE_PARENTHESIS , DocLexer :: T_CLOSE_CURLY_BRACES ] ) ; } return false ; } 
private function indentationCanBeFixed ( Tokens $ tokens , $ newLineTokenIndex , array $ annotationPositions ) { foreach ( $ annotationPositions as $ position ) { if ( $ newLineTokenIndex >= $ position [ 0 ] && $ newLineTokenIndex <= $ position [ 1 ] ) { return true ; } } for ( $ index = $ newLineTokenIndex + 1 , $ max = \ count ( $ tokens ) ; $ index < $ max ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( false !== strpos ( $ token -> getContent ( ) , "\n" ) ) { return false ; } return $ tokens [ $ index ] -> isType ( DocLexer :: T_AT ) ; } return false ; } 
public function getDefinition ( ) { $ codeSample = <<<'EOF' <?php $singleQuoted = 'String with \" and My\Prefix\\'; $doubleQuoted = "Interpret my \n but not my \a"; $hereDoc = <<<HEREDOC Interpret my \100 but not my \999 HEREDOC; EOF ; return new FixerDefinition ( 'Escape implicit backslashes in strings and heredocs to ease the understanding of which are special chars interpreted by PHP and which not.' , [ new CodeSample ( $ codeSample ) , new CodeSample ( $ codeSample , [ 'single_quoted' => true ] ) , new CodeSample ( $ codeSample , [ 'double_quoted' => false ] ) , new CodeSample ( $ codeSample , [ 'heredoc_syntax' => false ] ) , ] , 'In PHP double-quoted strings and heredocs some chars like `n`, `$` or `u` have special meanings if preceded by a backslash ' . '(and some are special only if followed by other special chars), while a backslash preceding other chars are interpreted like a plain ' . 'backslash. The precise list of those special chars is hard to remember and to identify quickly: this fixer escapes backslashes ' . 'that do not start a special interpretation with the char after them.' . PHP_EOL . 'It is possible to fix also single-quoted strings: in this case there is no special chars apart from single-quote and backslash ' . 'itself, so the fixer simply ensure that all backslashes are escaped. Both single and double backslashes are allowed in single-quoted ' . 'strings, so the purpose in this context is mainly to have a uniformed way to have them written all over the codebase.' ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { static $ singleQuotedRegex = '/(?<!\\\\)\\\\((?:\\\\\\\\)*)(?![\\\'\\\\])/' ; static $ doubleQuotedRegex = '/(?<!\\\\)\\\\((?:\\\\\\\\)*)(?![efnrtv$"\\\\0-7]|x[0-9A-Fa-f]|u{)/' ; static $ heredocSyntaxRegex = '/(?<!\\\\)\\\\((?:\\\\\\\\)*)(?![efnrtv$\\\\0-7]|x[0-9A-Fa-f]|u{)/' ; $ doubleQuoteOpened = false ; foreach ( $ tokens as $ index => $ token ) { $ content = $ token -> getContent ( ) ; if ( $ token -> equalsAny ( [ '"' , 'b"' , 'B"' ] ) ) { $ doubleQuoteOpened = ! $ doubleQuoteOpened ; } if ( ! $ token -> isGivenKind ( [ T_ENCAPSED_AND_WHITESPACE , T_CONSTANT_ENCAPSED_STRING ] ) || false === strpos ( $ content , '\\' ) ) { continue ; } // Nowdoc syntax if ( $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) && '\'' === substr ( rtrim ( $ tokens [ $ index - 1 ] -> getContent ( ) ) , - 1 ) ) { continue ; } $ firstTwoCharacters = strtolower ( substr ( $ content , 0 , 2 ) ) ; $ isSingleQuotedString = $ token -> isGivenKind ( T_CONSTANT_ENCAPSED_STRING ) && ( '\'' === $ content [ 0 ] || 'b\'' === $ firstTwoCharacters ) ; $ isDoubleQuotedString = ( $ token -> isGivenKind ( T_CONSTANT_ENCAPSED_STRING ) && ( '"' === $ content [ 0 ] || 'b"' === $ firstTwoCharacters ) ) || ( $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) && $ doubleQuoteOpened ) ; $ isHeredocSyntax = ! $ isSingleQuotedString && ! $ isDoubleQuotedString ; if ( ( false === $ this -> configuration [ 'single_quoted' ] && $ isSingleQuotedString ) || ( false === $ this -> configuration [ 'double_quoted' ] && $ isDoubleQuotedString ) || ( false === $ this -> configuration [ 'heredoc_syntax' ] && $ isHeredocSyntax ) ) { continue ; } $ regex = $ heredocSyntaxRegex ; if ( $ isSingleQuotedString ) { $ regex = $ singleQuotedRegex ; } elseif ( $ isDoubleQuotedString ) { $ regex = $ doubleQuotedRegex ; } $ newContent = Preg :: replace ( $ regex , '\\\\\\\\$1' , $ content ) ; if ( $ newContent !== $ content ) { $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , $ newContent ] ) ; } } } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'strategy' , 'Forbid multi-line whitespace or move the semicolon to the new line for chained calls.' ) ) -> setAllowedValues ( [ self :: STRATEGY_NO_MULTI_LINE , self :: STRATEGY_NEW_LINE_FOR_CHAINED_CALLS ] ) -> setDefault ( self :: STRATEGY_NO_MULTI_LINE ) -> getOption ( ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { if ( self :: STRATEGY_NEW_LINE_FOR_CHAINED_CALLS === $ this -> configuration [ 'strategy' ] ) { $ this -> applyChainedCallsFix ( $ tokens ) ; return ; } if ( self :: STRATEGY_NO_MULTI_LINE === $ this -> configuration [ 'strategy' ] ) { $ this -> applyNoMultiLineFix ( $ tokens ) ; } } 
private function getNewLineIndex ( $ index , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; for ( $ index , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { if ( false !== strstr ( $ tokens [ $ index ] -> getContent ( ) , $ lineEnding ) ) { return $ index ; } } return $ index ; } 
private function findWhitespaceBeforeFirstCall ( $ index , Tokens $ tokens ) { 
private function getIndentAt ( Tokens $ tokens , $ index ) { $ content = '' ; $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { static $ castMap = [ 'boolean' => 'bool' , 'integer' => 'int' , 'double' => 'float' , 'real' => 'float' , 'binary' => 'string' , ] ; for ( $ index = 0 , $ count = $ tokens -> count ( ) ; $ index < $ count ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isCast ( ) ) { continue ; } $ castFrom = trim ( substr ( $ tokens [ $ index ] -> getContent ( ) , 1 , - 1 ) ) ; $ castFromLowered = strtolower ( $ castFrom ) ; if ( ! \ array_key_exists ( $ castFromLowered , $ castMap ) ) { continue ; } $ tokens [ $ index ] = new Token ( [ $ tokens [ $ index ] -> getId ( ) , str_replace ( $ castFrom , $ castMap [ $ castFromLowered ] , $ tokens [ $ index ] -> getContent ( ) ) , ] ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ doc = new DocBlock ( $ token -> getContent ( ) ) ; $ annotations = $ doc -> getAnnotationsOfType ( 'return' ) ; if ( empty ( $ annotations ) ) { continue ; } foreach ( $ annotations as $ annotation ) { $ this -> fixAnnotation ( $ doc , $ annotation ) ; } $ newContent = $ doc -> getContent ( ) ; if ( $ newContent === $ token -> getContent ( ) ) { continue ; } if ( '' === $ newContent ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; continue ; } $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , $ doc -> getContent ( ) ] ) ; } } 
private function fixAnnotation ( DocBlock $ doc , Annotation $ annotation ) { $ types = $ annotation -> getNormalizedTypes ( ) ; if ( 1 === \ count ( $ types ) && ( 'null' === $ types [ 0 ] || 'void' === $ types [ 0 ] ) ) { $ annotation -> remove ( ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ issetIndexes = array_keys ( $ tokens -> findGivenKind ( T_ISSET ) ) ; while ( $ issetIndex = array_pop ( $ issetIndexes ) ) { $ this -> fixIsset ( $ tokens , $ issetIndex ) ; } } 
private function getMeaningfulSequence ( Tokens $ tokens , $ start , $ end ) { $ sequence = [ ] ; $ index = $ start ; while ( $ index < $ end ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ index >= $ end || null === $ index ) { break ; } $ sequence [ ] = $ tokens [ $ index ] ; } return Tokens :: fromArray ( $ sequence ) ; } 
private function isHigherPrecedenceAssociativityOperator ( Token $ token ) { static $ operatorsPerId = [ T_ARRAY_CAST => true , T_BOOLEAN_AND => true , T_BOOLEAN_OR => true , T_BOOL_CAST => true , T_COALESCE => true , T_DEC => true , T_DOUBLE_CAST => true , T_INC => true , T_INT_CAST => true , T_IS_EQUAL => true , T_IS_GREATER_OR_EQUAL => true , T_IS_IDENTICAL => true , T_IS_NOT_EQUAL => true , T_IS_NOT_IDENTICAL => true , T_IS_SMALLER_OR_EQUAL => true , T_OBJECT_CAST => true , T_POW => true , T_SL => true , T_SPACESHIP => true , T_SR => true , T_STRING_CAST => true , T_UNSET_CAST => true , ] ; static $ operatorsPerContent = [ '!' , '%' , '&' , '*' , '+' , '-' , '/' , ':' , '^' , '|' , '~' , ] ; return isset ( $ operatorsPerId [ $ token -> getId ( ) ] ) || $ token -> equalsAny ( $ operatorsPerContent ) ; } 
private function hasChangingContent ( Tokens $ tokens ) { static $ operatorsPerId = [ T_DEC , T_INC , T_STRING , T_YIELD , ] ; foreach ( $ tokens as $ token ) { if ( $ token -> isGivenKind ( $ operatorsPerId ) || $ token -> equals ( '(' ) ) { return true ; } } return false ; } 
public function fixSpace ( Tokens $ tokens , $ index ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; $ this -> fixSpace2 ( $ tokens , $ index ) ; } 
public function getDefinition ( ) { return new FixerDefinition ( 'In method arguments and method call, there MUST NOT be a space before each comma and there MUST be one space after each comma. Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line.' , [ new CodeSample ( "<?php\nfunction sample(\$a=10,\$b=20,\$c=30) {}\nsample(1, 2);\n" , null ) , new CodeSample ( "<?php\nfunction sample(\$a=10,\$b=20,\$c=30) {}\nsample(1, 2);\n" , [ 'keep_multiple_spaces_after_comma' => false ] ) , new CodeSample ( "<?php\nfunction sample(\$a=10,\$b=20,\$c=30) {}\nsample(1, 2);\n" , [ 'keep_multiple_spaces_after_comma' => true ] ) , new CodeSample ( "<?php\nfunction sample(\$a=10,\n \$b=20,\$c=30) {}\nsample(1,\n 2);\n" , [ 'on_multiline' => 'ensure_fully_multiline' ] ) , new CodeSample ( "<?php\nfunction sample(\n \$a=10,\n \$b=20,\n \$c=30\n) {}\nsample(\n 1,\n 2\n);\n" , [ 'on_multiline' => 'ensure_single_line' ] ) , new CodeSample ( "<?php\nfunction sample(\$a=10,\n \$b=20,\$c=30) {}\nsample(1, \n 2);\nsample('foo', 'foobarbaz', 'baz');\nsample('foobar', 'bar', 'baz');\n" , [ 'on_multiline' => 'ensure_fully_multiline' , 'keep_multiple_spaces_after_comma' => true , ] ) , new CodeSample ( "<?php\nfunction sample(\$a=10,\n \$b=20,\$c=30) {}\nsample(1, \n 2);\nsample('foo', 'foobarbaz', 'baz');\nsample('foobar', 'bar', 'baz');\n" , [ 'on_multiline' => 'ensure_fully_multiline' , 'keep_multiple_spaces_after_comma' => false , ] ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; $ index > 0 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> equals ( '(' ) ) { continue ; } $ meaningfulTokenBeforeParenthesis = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ meaningfulTokenBeforeParenthesis -> isKeyword ( ) && ! $ meaningfulTokenBeforeParenthesis -> isGivenKind ( [ T_LIST , T_FUNCTION ] ) ) { continue ; } $ isMultiline = $ this -> fixFunction ( $ tokens , $ index ) ; if ( $ isMultiline && 'ensure_fully_multiline' === $ this -> configuration [ 'on_multiline' ] && ! $ meaningfulTokenBeforeParenthesis -> isGivenKind ( T_LIST ) ) { $ this -> ensureFunctionFullyMultiline ( $ tokens , $ index ) ; } } } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'keep_multiple_spaces_after_comma' , 'Whether keep multiple spaces after comma.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( false ) -> getOption ( ) , ( new FixerOptionBuilder ( 'ensure_fully_multiline' , 'ensure every argument of a multiline argument list is on its own line' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( false ) 
private function fixFunction ( Tokens $ tokens , $ startFunctionIndex ) { $ endFunctionIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startFunctionIndex ) ; $ isMultiline = false ; $ firstWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ startFunctionIndex , $ endFunctionIndex ) ; $ lastWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ endFunctionIndex , $ startFunctionIndex ) ; foreach ( [ $ firstWhitespaceIndex , $ lastWhitespaceIndex ] as $ index ) { if ( null === $ index || ! Preg :: match ( '/\R/' , $ tokens [ $ index ] -> getContent ( ) ) ) { continue ; } if ( 'ensure_single_line' !== $ this -> configuration [ 'on_multiline' ] ) { $ isMultiline = true ; continue ; } $ newLinesRemoved = $ this -> ensureSingleLine ( $ tokens , $ index ) ; if ( ! $ newLinesRemoved ) { $ isMultiline = true ; } } for ( $ index = $ endFunctionIndex - 1 ; $ index > $ startFunctionIndex ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> equals ( ')' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; continue ; } if ( $ token -> isGivenKind ( CT :: T_ARRAY_SQUARE_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( '}' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( ',' ) ) { $ this -> fixSpace2 ( $ tokens , $ index ) ; if ( ! $ isMultiline && $ this -> isNewline ( $ tokens [ $ index + 1 ] ) ) { $ isMultiline = true ; break ; } } } return $ isMultiline ; } 
private function findWhitespaceIndexAfterParenthesis ( Tokens $ tokens , $ startParenthesisIndex , $ endParenthesisIndex ) { $ direction = $ endParenthesisIndex > $ startParenthesisIndex ? 1 : - 1 ; $ startIndex = $ startParenthesisIndex + $ direction ; $ endIndex = $ endParenthesisIndex - $ direction ; for ( $ index = $ startIndex ; $ index !== $ endIndex ; $ index += $ direction ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isWhitespace ( ) ) { return $ index ; } if ( ! $ token -> isComment ( ) ) { break ; } } return null ; } 
private function ensureSingleLine ( Tokens $ tokens , $ index ) { $ previousToken = $ tokens [ $ index - 1 ] ; if ( $ previousToken -> isComment ( ) && 0 !== strpos ( $ previousToken -> getContent ( ) , '/*' ) ) { return false ; } $ content = Preg :: replace ( '/\R[ \t]*/' , '' , $ tokens [ $ index ] -> getContent ( ) ) ; if ( '' !== $ content ) { $ tokens [ $ index ] = new Token ( [ T_WHITESPACE , $ content ] ) ; } else { $ tokens -> clearAt ( $ index ) ; } return true ; } 
private function fixNewline ( Tokens $ tokens , $ index , $ indentation , $ override = true ) { if ( $ tokens [ $ index + 1 ] -> isComment ( ) ) { return ; } if ( $ tokens [ $ index + 2 ] -> isComment ( ) ) { $ nextMeaningfulTokenIndex = $ tokens -> getNextMeaningfulToken ( $ index + 2 ) ; if ( ! $ this -> isNewline ( $ tokens [ $ nextMeaningfulTokenIndex - 1 ] ) ) { $ tokens -> ensureWhitespaceAtIndex ( $ nextMeaningfulTokenIndex , 0 , $ this -> whitespacesConfig -> getLineEnding ( ) . $ indentation ) ; } return ; } $ tokens -> ensureWhitespaceAtIndex ( $ index + 1 , 0 , $ this -> whitespacesConfig -> getLineEnding ( ) . $ indentation ) ; } 
private function fixSpace2 ( Tokens $ tokens , $ index ) { 
private function isCommentLastLineToken ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) || ! $ tokens [ $ index + 1 ] -> isWhitespace ( ) ) { return false ; } $ content = $ tokens [ $ index + 1 ] -> getContent ( ) ; return $ content !== ltrim ( $ content , "\r\n" ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ backtickStarted = false ; $ backtickTokens = [ ] ; for ( $ index = $ tokens -> count ( ) - 1 ; $ index > 0 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> equals ( '`' ) ) { if ( $ backtickStarted ) { $ backtickTokens [ $ index ] = $ token ; } continue ; } $ backtickTokens [ $ index ] = $ token ; if ( $ backtickStarted ) { $ this -> fixBackticks ( $ tokens , $ backtickTokens ) ; $ backtickTokens = [ ] ; } $ backtickStarted = ! $ backtickStarted ; } } 
private function fixBackticks ( Tokens $ tokens , array $ backtickTokens ) { 
public function check ( ) { if ( null !== $ this -> error ) { throw new LintingException ( sprintf ( 'PHP Parse error: %s on line %d.' , $ this -> error -> getMessage ( ) , $ this -> error -> getLine ( ) ) , $ this -> error -> getCode ( ) , $ this -> error ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; 0 < $ index ; -- $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) ) { continue ; } $ funcName = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ tokens [ $ funcName ] -> equalsAny ( $ this -> blacklistFuncNames , false ) ) { continue ; } $ returnTypeAnnotation = $ this -> findReturnAnnotations ( $ tokens , $ index ) ; if ( 1 !== \ count ( $ returnTypeAnnotation ) ) { continue ; } $ returnTypeAnnotation = current ( $ returnTypeAnnotation ) ; $ types = array_values ( $ returnTypeAnnotation -> getTypes ( ) ) ; $ typesCount = \ count ( $ types ) ; if ( 1 > $ typesCount || 2 < $ typesCount ) { continue ; } $ isNullable = false ; $ returnType = current ( $ types ) ; if ( 2 === $ typesCount ) { $ null = $ types [ 0 ] ; $ returnType = $ types [ 1 ] ; if ( 'null' !== $ null ) { $ null = $ types [ 1 ] ; $ returnType = $ types [ 0 ] ; } if ( 'null' !== $ null ) { continue ; } $ isNullable = true ; if ( \ PHP_VERSION_ID < 70100 ) { continue ; } if ( 'void' === $ returnType ) { continue ; } } if ( 'static' === $ returnType ) { $ returnType = 'self' ; } if ( isset ( $ this -> skippedTypes [ $ returnType ] ) ) { continue ; } if ( isset ( $ this -> versionSpecificTypes [ $ returnType ] ) && \ PHP_VERSION_ID < $ this -> versionSpecificTypes [ $ returnType ] ) { continue ; } if ( isset ( $ this -> scalarTypes [ $ returnType ] ) && false === $ this -> configuration [ 'scalar_types' ] ) { continue ; } if ( 1 !== Preg :: match ( $ this -> classRegex , $ returnType , $ matches ) ) { continue ; } if ( isset ( $ matches [ 'array' ] ) ) { $ returnType = 'array' ; } $ startIndex = $ tokens -> getNextTokenOfKind ( $ index , [ '{' , ';' ] ) ; if ( $ this -> hasReturnTypeHint ( $ tokens , $ startIndex ) ) { continue ; } $ this -> fixFunctionDefinition ( $ tokens , $ startIndex , $ isNullable , $ returnType ) ; } } 
protected function createConfigurationDefinition ( ) { $ types = [ 'normal' , 'final' , 'abstract' ] ; return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'types' , 'What types of classes to mark as internal' ) ) -> setAllowedValues ( [ ( new AllowedValueSubset ( $ types ) ) ] ) -> setAllowedTypes ( [ 'array' ] ) -> setDefault ( [ 'normal' , 'final' ] ) -> getOption ( ) , ] ) ; } 
private function isAllowedByConfiguration ( Tokens $ tokens , $ i ) { $ typeIndex = $ tokens -> getPrevMeaningfulToken ( $ i ) ; if ( $ tokens [ $ typeIndex ] -> isGivenKind ( T_FINAL ) ) { return \ in_array ( 'final' , $ this -> configuration [ 'types' ] , true ) ; } if ( $ tokens [ $ typeIndex ] -> isGivenKind ( T_ABSTRACT ) ) { return \ in_array ( 'abstract' , $ this -> configuration [ 'types' ] , true ) ; } return \ in_array ( 'normal' , $ this -> configuration [ 'types' ] , true ) ; } 
private function hasDocBlock ( Tokens $ tokens , $ index ) { $ docBlockIndex = $ this -> getDocBlockIndex ( $ tokens , $ index ) ; return $ tokens [ $ docBlockIndex ] -> isGivenKind ( T_DOC_COMMENT ) ; } 
private function getDocBlockIndex ( Tokens $ tokens , $ index ) { do { $ index = $ tokens -> getPrevNonWhitespace ( $ index ) ; } while ( $ tokens [ $ index ] -> isGivenKind ( [ T_PUBLIC , T_PROTECTED , T_PRIVATE , T_FINAL , T_ABSTRACT , T_COMMENT ] ) ) ; return $ index ; } 
private function detectIndent ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index - 1 ] -> isWhitespace ( ) ) { return '' ; 
private function addInternalAnnotation ( DocBlock $ docBlock , Tokens $ tokens , $ docBlockIndex ) { $ lines = $ docBlock -> getLines ( ) ; $ originalIndent = $ this -> detectIndent ( $ tokens , $ docBlockIndex ) ; $ lineEnd = $ this -> whitespacesConfig -> getLineEnding ( ) ; array_splice ( $ lines , - 1 , 0 , $ originalIndent . ' *' . $ lineEnd . $ originalIndent . ' * @internal' . $ lineEnd ) ; return $ lines ; } 
private function makeDocBlockMultiLineIfNeeded ( DocBlock $ doc , Tokens $ tokens , $ docBlockIndex ) { $ lines = $ doc -> getLines ( ) ; if ( 1 === \ count ( $ lines ) && empty ( $ doc -> getAnnotationsOfType ( 'internal' ) ) ) { $ lines = $ this -> splitUpDocBlock ( $ lines , $ tokens , $ docBlockIndex ) ; return new DocBlock ( implode ( '' , $ lines ) ) ; } return $ doc ; } 
private function splitUpDocBlock ( $ lines , Tokens $ tokens , $ docBlockIndex ) { $ lineContent = $ this -> getSingleLineDocBlockEntry ( $ lines ) ; $ lineEnd = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ originalIndent = $ this -> detectIndent ( $ tokens , $ tokens -> getNextNonWhitespace ( $ docBlockIndex ) ) ; return [ new Line ( '/**' . $ lineEnd ) , new Line ( $ originalIndent . ' * ' . $ lineContent . $ lineEnd ) , new Line ( $ originalIndent . ' */' ) , ] ; } 
private function getSingleLineDocBlockEntry ( $ line ) { $ line = $ line [ 0 ] ; $ line = str_replace ( '*/' , '' , $ line ) ; $ line = trim ( $ line ) ; $ line = str_split ( $ line ) ; $ i = \ count ( $ line ) ; do { -- $ i ; } while ( '*' !== $ line [ $ i ] && '*' !== $ line [ $ i - 1 ] && '/' !== $ line [ $ i - 2 ] ) ; if ( ' ' === $ line [ $ i ] ) { ++ $ i ; } $ line = \ array_slice ( $ line , $ i ) ; return implode ( '' , $ line ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ commentsAnalyzer = new CommentsAnalyzer ( ) ; for ( $ index = 0 , $ limit = \ count ( $ tokens ) ; $ index < $ limit ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_COMMENT ) ) { continue ; } if ( $ commentsAnalyzer -> isHeaderComment ( $ tokens , $ index ) ) { continue ; } if ( ! $ commentsAnalyzer -> isBeforeStructuralElement ( $ tokens , $ index ) ) { continue ; } $ commentIndices = $ commentsAnalyzer -> getCommentBlockIndices ( $ tokens , $ index ) ; if ( $ this -> isCommentCandidate ( $ tokens , $ commentIndices ) ) { $ this -> fixComment ( $ tokens , $ commentIndices ) ; } $ index = max ( $ commentIndices ) ; } } 
private function isCommentCandidate ( Tokens $ tokens , array $ indices ) { return array_reduce ( $ indices , function ( $ carry , $ index ) use ( $ tokens ) { return $ carry || 1 === Preg :: match ( '~(#|//|/\*+|\R(\s*\*)?)\s*\@[a-zA-Z0-9_\\\\-]+(?=\s|\(|$)~' , $ tokens [ $ index ] -> getContent ( ) ) ; } , false ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ ternaryLevel = 0 ; foreach ( $ tokens as $ index => $ token ) { if ( $ token -> equals ( '?' ) ) { ++ $ ternaryLevel ; $ nextNonWhitespaceIndex = $ tokens -> getNextNonWhitespace ( $ index ) ; $ nextNonWhitespaceToken = $ tokens [ $ nextNonWhitespaceIndex ] ; if ( $ nextNonWhitespaceToken -> equals ( ':' ) ) { 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( [ T_CASE , T_DEFAULT ] ) ) { continue ; } $ ternariesCount = 0 ; for ( $ colonIndex = $ index + 1 ; ; ++ $ colonIndex ) { 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'types' , 'A map of types to fix.' ) ) -> setAllowedValues ( [ new AllowedValueSubset ( array_keys ( self :: $ types ) ) ] ) -> setDefault ( [ 'boolean' , 'double' , 'integer' , 'real' , 'str' ] ) 
protected function normalize ( $ type ) { if ( \ in_array ( $ type , $ this -> configuration [ 'types' ] , true ) ) { return self :: $ types [ $ type ] ; } return $ type ; } 
public function check ( ) { if ( ! $ this -> isSuccessful ( ) ) { 
public function supports ( \ SplFileInfo $ file ) { $ path = $ file -> getPathname ( ) ; if ( false !== strpos ( $ path , \ DIRECTORY_SEPARATOR . 'Fixtures' . \ DIRECTORY_SEPARATOR ) && false === strpos ( $ path , \ DIRECTORY_SEPARATOR . 'tests' . \ DIRECTORY_SEPARATOR . 'Fixtures' . \ DIRECTORY_SEPARATOR ) ) { return false ; } return true ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ useDeclarations = ( new NamespaceUsesAnalyzer ( ) ) -> getDeclarationsFromTokens ( $ tokens ) ; if ( 0 === \ count ( $ useDeclarations ) ) { return ; } foreach ( ( new NamespacesAnalyzer ( ) ) -> getDeclarations ( $ tokens ) as $ namespace ) { $ currentNamespaceUseDeclarations = array_filter ( $ useDeclarations , function ( NamespaceUseAnalysis $ useDeclaration ) use ( $ namespace ) { return $ useDeclaration -> getStartIndex ( ) >= $ namespace -> getScopeStartIndex ( ) && $ useDeclaration -> getEndIndex ( ) <= $ namespace -> getScopeEndIndex ( ) ; } ) ; $ usagesSearchIgnoredIndexes = [ ] ; foreach ( $ currentNamespaceUseDeclarations as $ useDeclaration ) { $ usagesSearchIgnoredIndexes [ $ useDeclaration -> getStartIndex ( ) ] = $ useDeclaration -> getEndIndex ( ) ; } foreach ( $ currentNamespaceUseDeclarations as $ useDeclaration ) { if ( ! $ this -> importIsUsed ( $ tokens , $ namespace , $ usagesSearchIgnoredIndexes , $ useDeclaration -> getShortName ( ) ) ) { $ this -> removeUseDeclaration ( $ tokens , $ useDeclaration ) ; } } $ this -> removeUsesInSameNamespace ( $ tokens , $ currentNamespaceUseDeclarations , $ namespace ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { static $ forbiddenSuccessors = [ T_DOC_COMMENT , T_COMMENT , T_WHITESPACE , T_RETURN , T_THROW , T_GOTO , T_CONTINUE , T_BREAK , T_DECLARE , ] ; foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } 
private function fixWhitespace ( Tokens $ tokens , $ index ) { $ content = $ tokens [ $ index ] -> getContent ( ) ; 
private function isSetupOrTearDownMethod ( Tokens $ tokens , $ index ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; $ isMethod = $ tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) && ! $ tokensAnalyzer -> isLambda ( $ index ) ; if ( ! $ isMethod ) { return false ; } $ functionNameIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ functionName = strtolower ( $ tokens [ $ functionNameIndex ] -> getContent ( ) ) ; return 'setup' === $ functionName || 'teardown' === $ functionName ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = 0 , $ count = $ tokens -> count ( ) ; $ index < $ count ; ++ $ index ) { 
private function fixSemicolonAfterCurlyBraceClose ( Tokens $ tokens , $ index , $ curlyCloseIndex ) { static $ beforeCurlyOpeningKinds = null ; if ( null === $ beforeCurlyOpeningKinds ) { $ beforeCurlyOpeningKinds = [ T_ELSE , T_FINALLY , T_NAMESPACE , T_OPEN_TAG ] ; } $ curlyOpeningIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ curlyCloseIndex ) ; $ beforeCurlyOpening = $ tokens -> getPrevMeaningfulToken ( $ curlyOpeningIndex ) ; if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( $ beforeCurlyOpeningKinds ) || $ tokens [ $ beforeCurlyOpening ] -> equalsAny ( [ ';' , '{' , '}' ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ phpUnitTestCaseIndicator = new PhpUnitTestCaseIndicator ( ) ; foreach ( $ phpUnitTestCaseIndicator -> findPhpUnitClasses ( $ tokens ) as $ indexes ) { $ this -> applyCasing ( $ tokens , $ indexes [ 0 ] , $ indexes [ 1 ] ) ; } } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'case' , 'Apply camel or snake case to test methods' ) ) -> setAllowedValues ( [ self :: CAMEL_CASE , self :: SNAKE_CASE ] ) -> setDefault ( self :: CAMEL_CASE ) -> getOption ( ) , ] ) ; } 
private function updateMethodCasing ( $ functionName ) { if ( self :: CAMEL_CASE === $ this -> configuration [ 'case' ] ) { $ newFunctionName = $ functionName ; $ newFunctionName = ucwords ( $ newFunctionName , '_' ) ; $ newFunctionName = str_replace ( '_' , '' , $ newFunctionName ) ; $ newFunctionName = lcfirst ( $ newFunctionName ) ; } else { $ newFunctionName = Utils :: camelCaseToUnderscore ( $ functionName ) ; } return $ newFunctionName ; } 
private function isMethod ( Tokens $ tokens , $ index ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; return $ tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) && ! $ tokensAnalyzer -> isLambda ( $ index ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = 0 , $ limit = $ tokens -> count ( ) ; $ index < $ limit ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_NAMESPACE ) ) { continue ; } $ this -> fixLinesBeforeNamespace ( $ tokens , $ index , 0 , 1 ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { if ( \ count ( $ tokens ) < 2 || ! $ tokens -> isMonolithicPhp ( ) ) { return ; } if ( ! $ tokens -> isTokenKindFound ( T_CLOSE_TAG ) ) { return ; } $ closeTags = $ tokens -> findGivenKind ( T_CLOSE_TAG ) ; $ index = key ( $ closeTags ) ; if ( isset ( $ tokens [ $ index - 1 ] ) && $ tokens [ $ index - 1 ] -> isWhitespace ( ) ) { $ tokens -> clearAt ( $ index - 1 ) ; } $ tokens -> clearAt ( $ index ) ; $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( ! $ tokens [ $ prevIndex ] -> equalsAny ( [ ';' , '}' , [ T_OPEN_TAG ] ] ) ) { $ tokens -> insertAt ( $ prevIndex + 1 , new Token ( ';' ) ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; $ index >= 0 ; -- $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_UNSET ) ) { continue ; } $ previousUnsetCall = $ this -> getPreviousUnsetCall ( $ tokens , $ index ) ; if ( \ is_int ( $ previousUnsetCall ) ) { $ index = $ previousUnsetCall ; continue ; } list ( $ previousUnset , , $ previousUnsetBraceEnd ) = $ previousUnsetCall ; 
private function getPreviousUnsetCall ( Tokens $ tokens , $ index ) { $ previousUnsetSemicolon = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( null === $ previousUnsetSemicolon ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetSemicolon ] -> equals ( ';' ) ) { return $ previousUnsetSemicolon ; } $ previousUnsetBraceEnd = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetSemicolon ) ; if ( null === $ previousUnsetBraceEnd ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetBraceEnd ] -> equals ( ')' ) ) { return $ previousUnsetBraceEnd ; } $ previousUnsetBraceStart = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ previousUnsetBraceEnd ) ; $ previousUnset = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetBraceStart ) ; if ( null === $ previousUnset ) { return $ index ; } if ( ! $ tokens [ $ previousUnset ] -> isGivenKind ( T_UNSET ) ) { return $ previousUnset ; } return [ $ previousUnset , $ previousUnsetBraceStart , $ previousUnsetBraceEnd , $ previousUnsetSemicolon , ] ; } 
private function moveTokens ( Tokens $ tokens , $ start , $ end , $ to ) { $ added = 0 ; for ( $ i = $ start + 1 ; $ i < $ end ; $ i += 2 ) { if ( $ tokens [ $ i ] -> isWhitespace ( ) && $ tokens [ $ to + 1 ] -> isWhitespace ( ) ) { $ tokens [ $ to + 1 ] = new Token ( [ T_WHITESPACE , $ tokens [ $ to + 1 ] -> getContent ( ) . $ tokens [ $ i ] -> getContent ( ) ] ) ; } else { $ tokens -> insertAt ( ++ $ to , clone $ tokens [ $ i ] ) ; ++ $ end ; ++ $ added ; } $ tokens -> clearAt ( $ i + 1 ) ; } return $ added ; } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> tokenKinds = [ T_DOC_COMMENT ] ; if ( 'phpdocs_only' !== $ this -> configuration [ 'comment_type' ] ) { $ this -> tokenKinds [ ] = T_COMMENT ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( $ this -> tokenKinds ) ) { continue ; } $ whitespace = '' ; $ previousIndex = $ index - 1 ; if ( $ tokens [ $ previousIndex ] -> isWhitespace ( ) ) { $ whitespace = $ tokens [ $ previousIndex ] -> getContent ( ) ; -- $ previousIndex ; } if ( $ tokens [ $ previousIndex ] -> isGivenKind ( T_OPEN_TAG ) ) { $ whitespace = Preg :: replace ( '/\S/' , '' , $ tokens [ $ previousIndex ] -> getContent ( ) ) . $ whitespace ; } if ( 1 !== Preg :: match ( '/\R([ \t]*)$/' , $ whitespace , $ matches ) ) { continue ; } if ( $ token -> isGivenKind ( T_COMMENT ) && 'all_multiline' !== $ this -> configuration [ 'comment_type' ] && 1 === Preg :: match ( '/\R(?:\R|\s*[^\s\*])/' , $ token -> getContent ( ) ) ) { continue ; } $ indentation = $ matches [ 1 ] ; $ lines = Preg :: split ( '/\R/u' , $ token -> getContent ( ) ) ; foreach ( $ lines as $ lineNumber => $ line ) { if ( 0 === $ lineNumber ) { continue ; } $ line = ltrim ( $ line ) ; if ( $ token -> isGivenKind ( T_COMMENT ) && ( ! isset ( $ line [ 0 ] ) || '*' !== $ line [ 0 ] ) ) { continue ; } if ( ! isset ( $ line [ 0 ] ) ) { $ line = '*' ; } elseif ( '*' !== $ line [ 0 ] ) { $ line = '* ' . $ line ; } $ lines [ $ lineNumber ] = $ indentation . ' ' . $ line ; } $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , implode ( $ lineEnding , $ lines ) ] ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = \ count ( $ tokens ) - 1 ; $ index >= 0 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_OPEN_TAG ) && $ tokens -> offsetExists ( $ index + 1 ) && $ tokens [ $ index + 1 ] -> isWhitespace ( ) && 1 === Preg :: match ( '/(.*)\h$/' , $ token -> getContent ( ) , $ openTagMatches ) && 1 === Preg :: match ( '/^(\R)(.*)$/s' , $ tokens [ $ index + 1 ] -> getContent ( ) , $ whitespaceMatches ) ) { $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , $ openTagMatches [ 1 ] . $ whitespaceMatches [ 1 ] ] ) ; if ( '' === $ whitespaceMatches [ 2 ] ) { $ tokens -> clearAt ( $ index + 1 ) ; } else { $ tokens [ $ index + 1 ] = new Token ( [ T_WHITESPACE , $ whitespaceMatches [ 2 ] ] ) ; } continue ; } if ( ! $ token -> isWhitespace ( ) ) { continue ; } $ lines = Preg :: split ( '/(\\R+)/' , $ token -> getContent ( ) , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; $ linesSize = \ count ( $ lines ) ; 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; static $ reprToTokenMap = [ 'break' => T_BREAK , 'case' => T_CASE , 'continue' => T_CONTINUE , 'curly_brace_block' => '{' , 'default' => T_DEFAULT , 'extra' => T_WHITESPACE , 'parenthesis_brace_block' => '(' , 'return' => T_RETURN , 'square_brace_block' => CT :: T_ARRAY_SQUARE_BRACE_OPEN , 'switch' => T_SWITCH , 'throw' => T_THROW , 'use' => T_USE , 'use_trait' => CT :: T_USE_TRAIT , ] ; static $ tokenKindCallbackMap = [ T_BREAK => 'fixAfterToken' , T_CASE => 'fixAfterToken' , T_CONTINUE => 'fixAfterToken' , T_DEFAULT => 'fixAfterToken' , T_RETURN => 'fixAfterToken' , T_SWITCH => 'fixAfterToken' , T_THROW => 'fixAfterToken' , T_USE => 'removeBetweenUse' , T_WHITESPACE => 'removeMultipleBlankLines' , CT :: T_USE_TRAIT => 'removeBetweenUse' , CT :: T_ARRAY_SQUARE_BRACE_OPEN => 'fixStructureOpenCloseIfMultiLine' , 
public function getDefinition ( ) { return new FixerDefinition ( 'Removes extra blank lines and/or blank lines following configuration.' , [ new CodeSample ( '<?php $foo = array("foo"); $bar = "bar"; ' ) , new CodeSample ( '<?php switch ($foo) { case 41: echo "foo"; break; case 42: break; } ' , [ 'tokens' => [ 'break' ] ] ) , new CodeSample ( '<?php for ($i = 0; $i < 9000; ++$i) { if (true) { continue; } } ' , [ 'tokens' => [ 'continue' ] ] ) , new CodeSample ( '<?php for ($i = 0; $i < 9000; ++$i) { echo $i; } ' , [ 'tokens' => [ 'curly_brace_block' ] ] ) , new CodeSample ( '<?php $foo = array("foo"); $bar = "bar"; ' , [ 'tokens' => [ 'extra' ] ] ) , new CodeSample ( '<?php $foo = array( "foo" ); ' , [ 'tokens' => [ 'parenthesis_brace_block' ] ] ) , new CodeSample ( '<?php function foo($bar) { return $bar; } ' , [ 'tokens' => [ 'return' ] ] ) , new CodeSample ( '<?php $foo = [ "foo" ]; ' , [ 'tokens' => [ 'square_brace_block' ] ] ) , new CodeSample ( '<?php function foo($bar) { throw new \Exception("Hello!"); } ' , [ 'tokens' => [ 'throw' ] ] ) , new CodeSample ( '<?php namespace Foo; use Bar\Baz; use Baz\Bar; class Bar { } ' , [ 'tokens' => [ 'use' ] ] ) , new CodeSample ( '<?php class Foo { use Bar; use Baz; } ' , [ 'tokens' => [ 'use_trait' ] ] ) , new CodeSample ( '<?php switch($a) { case 1: default: echo 3; } ' , [ 'tokens' => [ 'switch' , 'case' , 'default' ] ] ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ this -> tokens = $ tokens ; $ this -> tokensAnalyzer = new TokensAnalyzer ( $ this -> tokens ) ; for ( $ index = $ tokens -> getSize ( ) - 1 ; $ index > 0 ; -- $ index ) { $ this -> fixByToken ( $ tokens [ $ index ] , $ index ) ; } } 
protected function createConfigurationDefinition ( ) { $ that = $ this ; return new FixerConfigurationResolverRootless ( 'tokens' , [ ( new FixerOptionBuilder ( 'tokens' , 'List of tokens to fix.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ new AllowedValueSubset ( self :: $ availableTokens ) ] ) -> setNormalizer ( static function ( Options $ options , $ tokens ) use ( $ that ) { foreach ( $ tokens as & $ token ) { if ( 'useTrait' === $ token ) { $ message = "Token \"useTrait\" in option \"tokens\" for rule \"{$that->getName()}\" is deprecated and will be removed in 3.0, use \"use_trait\" instead." ; if ( getenv ( 'PHP_CS_FIXER_FUTURE_MODE' ) ) { throw new InvalidConfigurationException ( "{$message} This check was performed as `PHP_CS_FIXER_FUTURE_MODE` env var is set." ) ; } @ trigger_error ( $ message , E_USER_DEPRECATED ) ; $ token = 'use_trait' ; break ; } } return $ tokens ; } ) -> setDefault ( [ 'extra' ] ) -> getOption ( ) , ] , $ this -> getName ( ) ) ; } 
private function fixStructureOpenCloseIfMultiLine ( $ index ) { $ blockTypeInfo = Tokens :: detectBlockType ( $ this -> tokens [ $ index ] ) ; $ bodyEnd = $ this -> tokens -> findBlockEnd ( $ blockTypeInfo [ 'type' ] , $ index ) ; for ( $ i = $ bodyEnd - 1 ; $ i >= $ index ; -- $ i ) { if ( false !== strpos ( $ this -> tokens [ $ i ] -> getContent ( ) , "\n" ) ) { $ this -> removeEmptyLinesAfterLineWithTokenAt ( $ i ) ; $ this -> removeEmptyLinesAfterLineWithTokenAt ( $ index ) ; break ; } } } 
public function getName ( ) { $ nameParts = explode ( '\\' , static :: class ) ; $ name = substr ( end ( $ nameParts ) , 0 , - \ strlen ( 'Fixer' ) ) ; return Utils :: camelCaseToUnderscore ( $ name ) ; } 
public function getConfigurationDefinition ( ) { if ( ! $ this instanceof ConfigurationDefinitionFixerInterface ) { throw new \ LogicException ( 'Cannot get configuration definition using Abstract parent, child not implementing "PhpCsFixer\Fixer\ConfigurationDefinitionFixerInterface".' ) ; } if ( null === $ this -> configurationDefinition ) { $ this -> configurationDefinition = $ this -> createConfigurationDefinition ( ) ; } return $ this -> configurationDefinition ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ index = $ tokens -> count ( ) - 1 ; $ index >= 0 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_FUNCTION ) ) { continue ; } $ startParenthesisIndex = $ tokens -> getNextTokenOfKind ( $ index , [ '(' , ';' , [ T_CLOSE_TAG ] ] ) ; if ( ! $ tokens [ $ startParenthesisIndex ] -> equals ( '(' ) ) { continue ; } $ endParenthesisIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startParenthesisIndex ) ; $ startBraceIndex = $ tokens -> getNextTokenOfKind ( $ endParenthesisIndex , [ ';' , '{' ] ) ; 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'closure_function_spacing' , 'Spacing to use before open parenthesis for closures.' ) ) -> setDefault ( self :: SPACING_ONE ) -> setAllowedValues ( $ this -> supportedSpacings ) -> getOption ( ) , ] ) ; } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ intersect = array_intersect_assoc ( $ this -> configuration [ 'annotation-white-list' ] , $ this -> configuration [ 'annotation-black-list' ] ) ; if ( \ count ( $ intersect ) ) { throw new InvalidFixerConfigurationException ( $ this -> getName ( ) , sprintf ( 'Annotation cannot be used in both the white- and black list, got duplicates: "%s".' , implode ( '", "' , array_keys ( $ intersect ) ) ) ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; 0 <= $ index ; -- $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_CLASS ) || ! $ this -> isClassCandidate ( $ tokens , $ index ) ) { continue ; } 
protected function createConfigurationDefinition ( ) { $ annotationsAsserts = [ static function ( array $ values ) { foreach ( $ values as $ value ) { if ( ! \ is_string ( $ value ) || '' === $ value ) { return false ; } } return true ; } ] ; $ annotationsNormalizer = static function ( Options $ options , array $ value ) { $ newValue = [ ] ; foreach ( $ value as $ key ) { if ( '@' === $ key [ 0 ] ) { $ key = substr ( $ key , 1 ) ; } $ newValue [ strtolower ( $ key ) ] = true ; } return $ newValue ; } ; return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'annotation-white-list' , 'Class level annotations tags that must be set in order to fix the class. (case insensitive)' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( $ annotationsAsserts ) -> setDefault ( [ '@internal' ] ) -> setNormalizer ( $ annotationsNormalizer ) -> getOption ( ) , ( new FixerOptionBuilder ( 'annotation-black-list' , 'Class level annotations tags that must be omitted to fix the class, even if all of the white list ones are used as well. (case insensitive)' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( $ annotationsAsserts ) -> setDefault ( [ '@final' , '@Entity' , '@ORM' ] ) -> setNormalizer ( $ annotationsNormalizer ) -> getOption ( ) , ] ) ; } 
private function isClassCandidate ( Tokens $ tokens , $ index ) { if ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL ] ) ) { return false ; 
public function getName ( ) { if ( null === $ this -> name ) { Preg :: matchAll ( '/@[a-zA-Z0-9_-]+(?=\s|$)/' , $ this -> line -> getContent ( ) , $ matches ) ; if ( isset ( $ matches [ 0 ] [ 0 ] ) ) { $ this -> name = ltrim ( $ matches [ 0 ] [ 0 ] , '@' ) ; } else { $ this -> name = 'other' ; } } return $ this -> name ; } 
public function setName ( $ name ) { $ current = $ this -> getName ( ) ; if ( 'other' === $ current ) { throw new \ RuntimeException ( 'Cannot set name on unknown tag.' ) ; } $ this -> line -> setContent ( Preg :: replace ( "/@{$current}/" , "@{$name}" , $ this -> line -> getContent ( ) , 1 ) ) ; $ this -> name = $ name ; } 
public function isGlobalFunctionCall ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_STRING ) ) { return false ; } $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ prevIndex ] -> isGivenKind ( T_NS_SEPARATOR ) ) { $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ prevIndex ) ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; return ! $ tokens [ $ prevIndex ] -> isGivenKind ( [ T_DOUBLE_COLON , T_FUNCTION , CT :: T_NAMESPACE_OPERATOR , T_NEW , T_OBJECT_OPERATOR , CT :: T_RETURN_REF , T_STRING ] ) && $ tokens [ $ nextIndex ] -> equals ( '(' ) ; } 
public function getFunctionArguments ( Tokens $ tokens , $ methodIndex ) { $ argumentsStart = $ tokens -> getNextTokenOfKind ( $ methodIndex , [ '(' ] ) ; $ argumentsEnd = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ argumentsStart ) ; $ argumentAnalyzer = new ArgumentsAnalyzer ( ) ; $ arguments = [ ] ; foreach ( $ argumentAnalyzer -> getArguments ( $ tokens , $ argumentsStart , $ argumentsEnd ) as $ start => $ end ) { $ argumentInfo = $ argumentAnalyzer -> getArgumentInfo ( $ tokens , $ start , $ end ) ; $ arguments [ $ argumentInfo -> getName ( ) ] = $ argumentInfo ; } return $ arguments ; } 
public function getFunctionReturnType ( Tokens $ tokens , $ methodIndex ) { $ argumentsStart = $ tokens -> getNextTokenOfKind ( $ methodIndex , [ '(' ] ) ; $ argumentsEnd = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ argumentsStart ) ; $ typeColonIndex = $ tokens -> getNextMeaningfulToken ( $ argumentsEnd ) ; if ( ':' !== $ tokens [ $ typeColonIndex ] -> getContent ( ) ) { return null ; } $ type = '' ; $ typeStartIndex = $ tokens -> getNextNonWhitespace ( $ typeColonIndex ) ; $ typeEndIndex = $ typeStartIndex ; $ functionBodyStart = $ tokens -> getNextTokenOfKind ( $ typeColonIndex , [ '{' , ';' ] ) ; for ( $ i = $ typeStartIndex ; $ i < $ functionBodyStart ; ++ $ i ) { if ( $ tokens [ $ i ] -> isWhitespace ( ) ) { continue ; } $ type .= $ tokens [ $ i ] -> getContent ( ) ; $ typeEndIndex = $ i ; } return new TypeAnalysis ( $ type , $ typeStartIndex , $ typeEndIndex ) ; } 
public function getDefinition ( ) { return new FixerDefinition ( 'Whitespace around the keywords of a class, trait or interfaces definition should be one space.' , [ new CodeSample ( '<?php class Foo extends Bar implements Baz, BarBaz { } final class Foo extends Bar implements Baz, BarBaz { } trait Foo { } ' ) , new VersionSpecificCodeSample ( '<?php $foo = new class extends Bar implements Baz, BarBaz {}; ' , new VersionSpecification ( 70100 ) ) , new CodeSample ( '<?php class Foo extends Bar implements Baz, BarBaz {} ' , [ 'single_line' => true ] ) , new CodeSample ( '<?php class Foo extends Bar implements Baz {} ' , [ 'single_item_single_line' => true ] ) , new CodeSample ( '<?php interface Bar extends Bar, BarBaz, FooBarBaz {} ' , [ 'multi_line_extends_each_single_line' => true ] ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new AliasedFixerOptionBuilder ( new FixerOptionBuilder ( 'multi_line_extends_each_single_line' , 'Whether definitions should be multiline.' ) , 'multiLineExtendsEachSingleLine' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( false ) -> getOption ( ) , ( new AliasedFixerOptionBuilder ( new FixerOptionBuilder ( 'single_item_single_line' , 'Whether definitions should be single line when including a single item.' ) , 'singleItemSingleLine' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( false ) -> getOption ( ) , ( new AliasedFixerOptionBuilder ( new FixerOptionBuilder ( 'single_line' , 'Whether definitions should be single line.' ) , 'singleLine' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( false ) -> getOption ( ) , ] ) ; } 
private function fixClassyDefinitionExtends ( Tokens $ tokens , $ classOpenIndex , array $ classExtendsInfo ) { $ endIndex = $ tokens -> getPrevNonWhitespace ( $ classOpenIndex ) ; if ( $ this -> configuration [ 'single_line' ] || false === $ classExtendsInfo [ 'multiLine' ] ) { $ this -> makeClassyDefinitionSingleLine ( $ tokens , $ classExtendsInfo [ 'start' ] , $ endIndex ) ; $ classExtendsInfo [ 'multiLine' ] = false ; } elseif ( $ this -> configuration [ 'single_item_single_line' ] && 1 === $ classExtendsInfo [ 'numberOfExtends' ] ) { $ this -> makeClassyDefinitionSingleLine ( $ tokens , $ classExtendsInfo [ 'start' ] , $ endIndex ) ; $ classExtendsInfo [ 'multiLine' ] = false ; } elseif ( $ this -> configuration [ 'multi_line_extends_each_single_line' ] && $ classExtendsInfo [ 'multiLine' ] ) { $ this -> makeClassyInheritancePartMultiLine ( $ tokens , $ classExtendsInfo [ 'start' ] , $ endIndex ) ; $ classExtendsInfo [ 'multiLine' ] = true ; } return $ classExtendsInfo ; } 
private function fixClassyDefinitionImplements ( Tokens $ tokens , $ classOpenIndex , array $ classImplementsInfo ) { $ endIndex = $ tokens -> getPrevNonWhitespace ( $ classOpenIndex ) ; if ( $ this -> configuration [ 'single_line' ] || false === $ classImplementsInfo [ 'multiLine' ] ) { $ this -> makeClassyDefinitionSingleLine ( $ tokens , $ classImplementsInfo [ 'start' ] , $ endIndex ) ; $ classImplementsInfo [ 'multiLine' ] = false ; } elseif ( $ this -> configuration [ 'single_item_single_line' ] && 1 === $ classImplementsInfo [ 'numberOfImplements' ] ) { $ this -> makeClassyDefinitionSingleLine ( $ tokens , $ classImplementsInfo [ 'start' ] , $ endIndex ) ; $ classImplementsInfo [ 'multiLine' ] = false ; } else { $ this -> makeClassyInheritancePartMultiLine ( $ tokens , $ classImplementsInfo [ 'start' ] , $ endIndex ) ; $ classImplementsInfo [ 'multiLine' ] = true ; } return $ classImplementsInfo ; } 
private function fixClassyDefinitionOpenSpacing ( Tokens $ tokens , array $ classDefInfo ) { if ( $ classDefInfo [ 'anonymousClass' ] ) { if ( false !== $ classDefInfo [ 'implements' ] ) { $ spacing = $ classDefInfo [ 'implements' ] [ 'multiLine' ] ? $ this -> whitespacesConfig -> getLineEnding ( ) : ' ' ; } elseif ( false !== $ classDefInfo [ 'extends' ] ) { $ spacing = $ classDefInfo [ 'extends' ] [ 'multiLine' ] ? $ this -> whitespacesConfig -> getLineEnding ( ) : ' ' ; } else { $ spacing = ' ' ; } } else { $ spacing = $ this -> whitespacesConfig -> getLineEnding ( ) ; } $ openIndex = $ tokens -> getNextTokenOfKind ( $ classDefInfo [ 'classy' ] , [ '{' ] ) ; if ( ' ' !== $ spacing && false !== strpos ( $ tokens [ $ openIndex - 1 ] -> getContent ( ) , "\n" ) ) { return $ openIndex ; } if ( $ tokens [ $ openIndex - 1 ] -> isWhitespace ( ) ) { if ( ' ' !== $ spacing || ! $ tokens [ $ tokens -> getPrevNonWhitespace ( $ openIndex - 1 ) ] -> isComment ( ) ) { $ tokens [ $ openIndex - 1 ] = new Token ( [ T_WHITESPACE , $ spacing ] ) ; } return $ openIndex ; } $ tokens -> insertAt ( $ openIndex , new Token ( [ T_WHITESPACE , $ spacing ] ) ) ; return $ openIndex + 1 ; } 
private function getClassyDefinitionInfo ( Tokens $ tokens , $ classyIndex ) { $ openIndex = $ tokens -> getNextTokenOfKind ( $ classyIndex , [ '{' ] ) ; $ prev = $ tokens -> getPrevMeaningfulToken ( $ classyIndex ) ; $ startIndex = $ tokens [ $ prev ] -> isGivenKind ( [ T_FINAL , T_ABSTRACT ] ) ? $ prev : $ classyIndex ; $ extends = false ; $ implements = false ; $ anonymousClass = false ; if ( ! $ tokens [ $ classyIndex ] -> isGivenKind ( T_TRAIT ) ) { $ extends = $ tokens -> findGivenKind ( T_EXTENDS , $ classyIndex , $ openIndex ) ; $ extends = \ count ( $ extends ) ? $ this -> getClassyInheritanceInfo ( $ tokens , key ( $ extends ) , 'numberOfExtends' ) : false ; if ( ! $ tokens [ $ classyIndex ] -> isGivenKind ( T_INTERFACE ) ) { $ implements = $ tokens -> findGivenKind ( T_IMPLEMENTS , $ classyIndex , $ openIndex ) ; $ implements = \ count ( $ implements ) ? $ this -> getClassyInheritanceInfo ( $ tokens , key ( $ implements ) , 'numberOfImplements' ) : false ; $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; $ anonymousClass = $ tokensAnalyzer -> isAnonymousClass ( $ classyIndex ) ; } } return [ 'start' => $ startIndex , 'classy' => $ classyIndex , 'open' => $ openIndex , 'extends' => $ extends , 'implements' => $ implements , 'anonymousClass' => $ anonymousClass , ] ; } 
private function getClassyInheritanceInfo ( Tokens $ tokens , $ startIndex , $ label ) { $ implementsInfo = [ 'start' => $ startIndex , $ label => 1 , 'multiLine' => false ] ; ++ $ startIndex ; $ endIndex = $ tokens -> getNextTokenOfKind ( $ startIndex , [ '{' , [ T_IMPLEMENTS ] , [ T_EXTENDS ] ] ) ; $ endIndex = $ tokens [ $ endIndex ] -> equals ( '{' ) ? $ tokens -> getPrevNonWhitespace ( $ endIndex ) : $ endIndex ; for ( $ i = $ startIndex ; $ i < $ endIndex ; ++ $ i ) { if ( $ tokens [ $ i ] -> equals ( ',' ) ) { ++ $ implementsInfo [ $ label ] ; continue ; } if ( ! $ implementsInfo [ 'multiLine' ] && false !== strpos ( $ tokens [ $ i ] -> getContent ( ) , "\n" ) ) { $ implementsInfo [ 'multiLine' ] = true ; } } return $ implementsInfo ; } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> typesToFix = array_merge ( ... array_map ( function ( $ group ) { return self :: $ possibleTypes [ $ group ] ; } , $ this -> configuration [ 'groups' ] ) ) ; } 
protected function normalize ( $ type ) { $ lower = strtolower ( $ type ) ; if ( \ in_array ( $ lower , $ this -> typesToFix , true ) ) { return $ lower ; } return $ type ; } 
protected function createConfigurationDefinition ( ) { $ possibleGroups = array_keys ( self :: $ possibleTypes ) ; return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'groups' , 'Type groups to fix.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ new AllowedValueSubset ( $ possibleGroups ) ] ) -> setDefault ( $ possibleGroups ) -> getOption ( ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; $ index > 1 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_VARIABLE ) ) { continue ; } $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; $ prevToken = $ tokens [ $ prevIndex ] ; if ( ! $ prevToken -> equals ( '$' ) && ! $ prevToken -> isGivenKind ( T_OBJECT_OPERATOR ) ) { continue ; } $ openingBrace = CT :: T_DYNAMIC_VAR_BRACE_OPEN ; $ closingBrace = CT :: T_DYNAMIC_VAR_BRACE_CLOSE ; if ( $ prevToken -> isGivenKind ( T_OBJECT_OPERATOR ) ) { $ openingBrace = CT :: T_DYNAMIC_PROP_BRACE_OPEN ; $ closingBrace = CT :: T_DYNAMIC_PROP_BRACE_CLOSE ; } $ tokens -> overrideRange ( $ index , $ index , [ new Token ( [ $ openingBrace , '{' ] ) , new Token ( [ T_VARIABLE , $ token -> getContent ( ) ] ) , new Token ( [ $ closingBrace , '}' ] ) , ] ) ; } } 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( ! $ token -> equals ( '|' ) ) { return ; } $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; $ prevToken = $ tokens [ $ prevIndex ] ; if ( ! $ prevToken -> isGivenKind ( T_STRING ) ) { return ; } do { $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ prevIndex ) ; if ( null === $ prevIndex ) { break ; } $ prevToken = $ tokens [ $ prevIndex ] ; if ( $ prevToken -> isGivenKind ( [ T_NS_SEPARATOR , T_STRING ] ) ) { continue ; } if ( $ prevToken -> isGivenKind ( CT :: T_TYPE_ALTERNATION ) || ( $ prevToken -> equals ( '(' ) && $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ prevIndex ) ] -> isGivenKind ( T_CATCH ) ) ) { $ tokens [ $ index ] = new Token ( [ CT :: T_TYPE_ALTERNATION , '|' ] ) ; } break ; } while ( true ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { 
public function isHeaderComment ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( [ T_COMMENT , T_DOC_COMMENT ] ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; return $ tokens [ $ prevIndex ] -> isGivenKind ( T_OPEN_TAG ) && null !== $ tokens -> getNextMeaningfulToken ( $ index ) ; } 
public function isBeforeStructuralElement ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_COMMENT , T_DOC_COMMENT ] ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ nextIndex = $ index ; do { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ; } while ( null !== $ nextIndex && $ tokens [ $ nextIndex ] -> equals ( '(' ) ) ; if ( null === $ nextIndex || $ tokens [ $ nextIndex ] -> equals ( '}' ) ) { return false ; } $ nextToken = $ tokens [ $ nextIndex ] ; if ( $ this -> isStructuralElement ( $ nextToken ) ) { return true ; } if ( $ this -> isValidControl ( $ tokens , $ token , $ nextIndex ) ) { return true ; } if ( $ this -> isValidVariable ( $ tokens , $ nextIndex ) ) { return true ; } if ( $ this -> isValidLanguageConstruct ( $ tokens , $ token , $ nextIndex ) ) { return true ; } return false ; } 
public function getCommentBlockIndices ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_COMMENT ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ commentType = $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ; $ indices = [ $ index ] ; if ( self :: TYPE_SLASH_ASTERISK === $ commentType ) { return $ indices ; } $ count = \ count ( $ tokens ) ; ++ $ index ; for ( ; $ index < $ count ; ++ $ index ) { if ( $ tokens [ $ index ] -> isComment ( ) ) { if ( $ commentType === $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ) { $ indices [ ] = $ index ; continue ; } break ; } if ( ! $ tokens [ $ index ] -> isWhitespace ( ) || $ this -> getLineBreakCount ( $ tokens , $ index , $ index + 1 ) > 1 ) { break ; } } return $ indices ; } 
private function isStructuralElement ( Token $ token ) { static $ skip = [ T_PRIVATE , T_PROTECTED , T_PUBLIC , T_VAR , T_FUNCTION , T_ABSTRACT , T_CONST , T_NAMESPACE , T_REQUIRE , T_REQUIRE_ONCE , T_INCLUDE , T_INCLUDE_ONCE , T_FINAL , T_STATIC , ] ; return $ token -> isClassy ( ) || $ token -> isGivenKind ( $ skip ) ; } 
private function isValidControl ( Tokens $ tokens , Token $ docsToken , $ controlIndex ) { static $ controlStructures = [ T_FOR , T_FOREACH , T_IF , T_SWITCH , T_WHILE , ] ; if ( ! $ tokens [ $ controlIndex ] -> isGivenKind ( $ controlStructures ) ) { return false ; } $ index = $ tokens -> getNextMeaningfulToken ( $ controlIndex ) ; $ endIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ docsContent = $ docsToken -> getContent ( ) ; for ( $ index = $ index + 1 ; $ index < $ endIndex ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_VARIABLE ) && false !== strpos ( $ docsContent , $ token -> getContent ( ) ) ) { return true ; } } return false ; } 
private function isValidLanguageConstruct ( Tokens $ tokens , Token $ docsToken , $ languageConstructIndex ) { static $ languageStructures = [ T_LIST , T_PRINT , T_ECHO , CT :: T_DESTRUCTURING_SQUARE_BRACE_OPEN , ] ; if ( ! $ tokens [ $ languageConstructIndex ] -> isGivenKind ( $ languageStructures ) ) { return false ; } $ endKind = $ tokens [ $ languageConstructIndex ] -> isGivenKind ( CT :: T_DESTRUCTURING_SQUARE_BRACE_OPEN ) ? [ CT :: T_DESTRUCTURING_SQUARE_BRACE_CLOSE ] : ')' ; $ endIndex = $ tokens -> getNextTokenOfKind ( $ languageConstructIndex , [ $ endKind ] ) ; $ docsContent = $ docsToken -> getContent ( ) ; for ( $ index = $ languageConstructIndex + 1 ; $ index < $ endIndex ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_VARIABLE ) && false !== strpos ( $ docsContent , $ token -> getContent ( ) ) ) { return true ; } } return false ; } 
private function isValidVariable ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_VARIABLE ) ) { return false ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; return $ tokens [ $ nextIndex ] -> equals ( '=' ) ; } 
private function getCommentType ( $ content ) { if ( '#' === $ content [ 0 ] ) { return self :: TYPE_HASH ; } if ( '*' === $ content [ 1 ] ) { return self :: TYPE_SLASH_ASTERISK ; } return self :: TYPE_DOUBLE_SLASH ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ analyzer = new TokensAnalyzer ( $ tokens ) ; $ elements = array_reverse ( $ analyzer -> getClassyElements ( ) , true ) ; foreach ( $ elements as $ index => $ element ) { if ( ! \ in_array ( $ element [ 'type' ] , $ this -> configuration [ 'elements' ] , true ) ) { continue ; 
private function getModifiersSequences ( Tokens $ tokens , $ startIndex , $ endIndex ) { $ sequence = [ ] ; for ( $ i = $ startIndex ; $ i < $ endIndex - 1 ; ++ $ i ) { if ( $ tokens [ $ i ] -> isWhitespace ( ) || $ tokens [ $ i ] -> isComment ( ) ) { continue ; } if ( ! $ tokens [ $ i ] -> isGivenKind ( [ T_PUBLIC , T_PROTECTED , T_PRIVATE , T_STATIC , T_CONST , T_VAR ] ) ) { break ; } $ sequence [ ] = clone $ tokens [ $ i ] ; $ sequence [ ] = new Token ( [ T_WHITESPACE , ' ' ] ) ; } return $ sequence ; } 
public function isValid ( $ name , $ isCustom ) { if ( ! $ isCustom ) { return 1 === Preg :: match ( '/^[a-z][a-z0-9_]*$/' , $ name ) ; } return 1 === Preg :: match ( '/^[A-Z][a-zA-Z0-9]*\/[a-z][a-z0-9_]*$/' , $ name ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { static $ map = null ; if ( null === $ map ) { $ trueToken = new Token ( [ T_STRING , 'true' ] ) ; $ map = [ 'array_keys' => [ null , null , $ trueToken ] , 'array_search' => [ null , null , $ trueToken ] , 'base64_decode' => [ null , $ trueToken ] , 'in_array' => [ null , null , $ trueToken ] , 'mb_detect_encoding' => [ null , [ new Token ( [ T_STRING , 'mb_detect_order' ] ) , new Token ( '(' ) , new Token ( ')' ) ] , $ trueToken ] , ] ; } for ( $ index = $ tokens -> count ( ) - 1 ; 0 <= $ index ; -- $ index ) { $ token = $ tokens [ $ index ] ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( null !== $ nextIndex && ! $ tokens [ $ nextIndex ] -> equals ( '(' ) ) { continue ; } $ lowercaseContent = strtolower ( $ token -> getContent ( ) ) ; if ( $ token -> isGivenKind ( T_STRING ) && isset ( $ map [ $ lowercaseContent ] ) ) { $ this -> fixFunction ( $ tokens , $ index , $ map [ $ lowercaseContent ] ) ; } } } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'sort_algorithm' , 'The sorting algorithm to apply.' ) ) -> setAllowedValues ( [ 'alpha' , 'none' ] ) -> setDefault ( 'alpha' ) -> getOption ( ) , ( new FixerOptionBuilder ( 'null_adjustment' , 'Forces the position of `null` (overrides `sort_algorithm`).' ) ) -> setAllowedValues ( [ 'always_first' , 'always_last' , 'none' ] ) -> setDefault ( 'always_first' ) -> getOption ( ) , ] ) ; } 
private function sortTypes ( array $ types ) { foreach ( $ types as $ index => $ type ) { $ types [ $ index ] = Preg :: replaceCallback ( '/^([^<]+)<(?:([\w\|]+?)(,\s*))?(.*)>$/' , function ( array $ matches ) { return $ matches [ 1 ] . '<' . $ this -> sortJoinedTypes ( $ matches [ 2 ] ) . $ matches [ 3 ] . $ this -> sortJoinedTypes ( $ matches [ 4 ] ) . '>' ; } , $ type ) ; } if ( 'alpha' === $ this -> configuration [ 'sort_algorithm' ] ) { $ types = Utils :: stableSort ( $ types , static function ( $ type ) { return $ type ; } , static function ( $ typeA , $ typeB ) { $ regexp = '/^\\??\\\?/' ; return strcasecmp ( Preg :: replace ( $ regexp , '' , $ typeA ) , Preg :: replace ( $ regexp , '' , $ typeB ) ) ; } ) ; } if ( 'none' !== $ this -> configuration [ 'null_adjustment' ] ) { $ nulls = [ ] ; foreach ( $ types as $ index => $ type ) { if ( Preg :: match ( '/^\\\?null$/i' , $ type ) ) { $ nulls [ $ index ] = $ type ; unset ( $ types [ $ index ] ) ; } } if ( \ count ( $ nulls ) ) { if ( 'always_last' === $ this -> configuration [ 'null_adjustment' ] ) { array_push ( $ types , ... $ nulls ) ; } else { array_unshift ( $ types , ... $ nulls ) ; } } } return $ types ; } 
private function sortJoinedTypes ( $ types ) { $ types = array_filter ( Preg :: split ( '/([^|<]+(?:<.*>)?)/' , $ types , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) , static function ( $ value ) { return '|' !== $ value ; } ) ; return implode ( '|' , $ this -> sortTypes ( $ types ) ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ backtickStarted = false ; for ( $ index = \ count ( $ tokens ) - 1 ; $ index > 0 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> equals ( '`' ) ) { $ backtickStarted = ! $ backtickStarted ; continue ; } if ( $ backtickStarted || ! $ token -> isGivenKind ( T_VARIABLE ) ) { continue ; } $ prevToken = $ tokens [ $ index - 1 ] ; if ( ! $ this -> isStringPartToken ( $ prevToken ) ) { continue ; } $ distinctVariableIndex = $ index ; $ variableTokens = [ $ distinctVariableIndex => [ 'tokens' => [ $ index => $ token ] , 'firstVariableTokenIndex' => $ index , 'lastVariableTokenIndex' => $ index , ] , ] ; $ nextIndex = $ index + 1 ; $ squareBracketCount = 0 ; while ( ! $ this -> isStringPartToken ( $ tokens [ $ nextIndex ] ) ) { if ( $ tokens [ $ nextIndex ] -> isGivenKind ( T_VARIABLE ) && 1 !== $ squareBracketCount ) { $ distinctVariableIndex = $ nextIndex ; $ variableTokens [ $ distinctVariableIndex ] = [ 'tokens' => [ $ nextIndex => $ tokens [ $ nextIndex ] ] , 'firstVariableTokenIndex' => $ nextIndex , 'lastVariableTokenIndex' => $ nextIndex , ] ; } else { $ variableTokens [ $ distinctVariableIndex ] [ 'tokens' ] [ $ nextIndex ] = $ tokens [ $ nextIndex ] ; $ variableTokens [ $ distinctVariableIndex ] [ 'lastVariableTokenIndex' ] = $ nextIndex ; if ( $ tokens [ $ nextIndex ] -> equalsAny ( [ '[' , ']' ] ) ) { ++ $ squareBracketCount ; } } ++ $ nextIndex ; } krsort ( $ variableTokens , \ SORT_NUMERIC ) ; foreach ( $ variableTokens as $ distinctVariableSet ) { if ( 1 === \ count ( $ distinctVariableSet [ 'tokens' ] ) ) { $ singleVariableIndex = key ( $ distinctVariableSet [ 'tokens' ] ) ; $ singleVariableToken = current ( $ distinctVariableSet [ 'tokens' ] ) ; $ tokens -> overrideRange ( $ singleVariableIndex , $ singleVariableIndex , [ new Token ( [ T_DOLLAR_OPEN_CURLY_BRACES , '${' ] ) , new Token ( [ T_STRING_VARNAME , substr ( $ singleVariableToken -> getContent ( ) , 1 ) ] ) , new Token ( [ CT :: T_DOLLAR_CLOSE_CURLY_BRACES , '}' ] ) , ] ) ; } else { foreach ( $ distinctVariableSet [ 'tokens' ] as $ variablePartIndex => $ variablePartToken ) { if ( $ variablePartToken -> isGivenKind ( T_NUM_STRING ) ) { $ tokens [ $ variablePartIndex ] = new Token ( [ T_LNUMBER , $ variablePartToken -> getContent ( ) ] ) ; continue ; } if ( $ variablePartToken -> isGivenKind ( T_STRING ) && $ tokens [ $ variablePartIndex + 1 ] -> equals ( ']' ) ) { $ tokens [ $ variablePartIndex ] = new Token ( [ T_CONSTANT_ENCAPSED_STRING , "'" . $ variablePartToken -> getContent ( ) . "'" ] ) ; } } $ tokens -> insertAt ( $ distinctVariableSet [ 'lastVariableTokenIndex' ] + 1 , new Token ( [ CT :: T_CURLY_CLOSE , '}' ] ) ) ; $ tokens -> insertAt ( $ distinctVariableSet [ 'firstVariableTokenIndex' ] , new Token ( [ T_CURLY_OPEN , '{' ] ) ) ; } } } } 
private function isStringPartToken ( Token $ token ) { return $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) || $ token -> isGivenKind ( T_START_HEREDOC ) || '"' === $ token -> getContent ( ) || 'b"' === strtolower ( $ token -> getContent ( ) ) ; } 
public function isSatisfiedBy ( $ version ) { if ( null !== $ this -> minimum && $ version < $ this -> minimum ) { return false ; } if ( null !== $ this -> maximum && $ version > $ this -> maximum ) { return false ; } return true ; } 
public function compareVersions ( $ versionA , $ versionB ) { $ versionA = $ this -> versionParser -> normalize ( $ versionA ) ; $ versionB = $ this -> versionParser -> normalize ( $ versionB ) ; if ( Comparator :: lessThan ( $ versionA , $ versionB ) ) { return - 1 ; } if ( Comparator :: greaterThan ( $ versionA , $ versionB ) ) { return 1 ; } return 0 ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ doc = new DocBlock ( $ token -> getContent ( ) ) ; $ summaryEnd = ( new ShortDescription ( $ doc ) ) -> getEnd ( ) ; if ( null !== $ summaryEnd ) { $ this -> fixSummary ( $ doc , $ summaryEnd ) ; $ this -> fixDescription ( $ doc , $ summaryEnd ) ; } $ this -> fixAllTheRest ( $ doc ) ; $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , $ doc -> getContent ( ) ] ) ; } } 
private function findNonBlankLine ( DocBlock $ doc , $ after ) { foreach ( $ doc -> getLines ( ) as $ index => $ line ) { if ( $ index <= $ after ) { continue ; } if ( $ line -> containsATag ( ) || $ line -> containsUsefulContent ( ) || $ line -> isTheEnd ( ) ) { return $ index ; } } } 
private function findFirstAnnotationOrEnd ( DocBlock $ doc ) { $ index = null ; foreach ( $ doc -> getLines ( ) as $ index => $ line ) { if ( $ line -> containsATag ( ) ) { return $ index ; } } return $ index ; 
private function reverseFindLastUsefulContent ( DocBlock $ doc , $ from ) { for ( $ index = $ from - 1 ; $ index >= 0 ; -- $ index ) { if ( $ doc -> getLine ( $ index ) -> containsUsefulContent ( ) ) { return $ index ; } } return null ; } 
public function getDefinition ( ) { return new FixerDefinition ( 'Remove Zero-width space (ZWSP), Non-breaking space (NBSP) and other invisible unicode symbols.' , [ new CodeSample ( '<?php echo "' . pack ( 'H*' , 'e2808b' ) . 'Hello' . pack ( 'H*' , 'e28087' ) . 'World' . pack ( 'H*' , 'c2a0' ) . "!\";\n" ) , new VersionSpecificCodeSample ( '<?php echo "' . pack ( 'H*' , 'e2808b' ) . 'Hello' . pack ( 'H*' , 'e28087' ) . 'World' . pack ( 'H*' , 'c2a0' ) . "!\";\n" , new VersionSpecification ( 70000 ) , [ 'use_escape_sequences_in_strings' => true ] ) , ] , null , 'Risky when strings contain intended invisible characters.' ) ; } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'use_escape_sequences_in_strings' , 'Whether characters should be replaced with escape sequences in strings.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( false ) 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ replacements = [ ] ; $ escapeSequences = [ ] ; foreach ( $ this -> symbolsReplace as $ character => list ( $ replacement , $ codepoint ) ) { $ replacements [ $ character ] = $ replacement ; $ escapeSequences [ $ character ] = '\u{' . $ codepoint . '}' ; } foreach ( $ tokens as $ index => $ token ) { $ content = $ token -> getContent ( ) ; if ( $ this -> configuration [ 'use_escape_sequences_in_strings' ] && $ token -> isGivenKind ( [ T_CONSTANT_ENCAPSED_STRING , T_ENCAPSED_AND_WHITESPACE ] ) ) { if ( ! Preg :: match ( '/' . implode ( '|' , array_keys ( $ escapeSequences ) ) . '/' , $ content ) ) { continue ; } $ previousToken = $ tokens [ $ index - 1 ] ; $ stringTypeChanged = false ; if ( $ previousToken -> isGivenKind ( T_START_HEREDOC ) ) { $ previousTokenContent = $ previousToken -> getContent ( ) ; if ( false !== strpos ( $ previousTokenContent , '\'' ) ) { $ tokens [ $ index - 1 ] = new Token ( [ T_START_HEREDOC , str_replace ( '\'' , '' , $ previousTokenContent ) ] ) ; $ stringTypeChanged = true ; } } elseif ( "'" === $ content [ 0 ] ) { $ content = Preg :: replace ( '/^\'(.*)\'$/' , '"$1"' , $ content ) ; $ stringTypeChanged = true ; } if ( $ stringTypeChanged ) { $ content = Preg :: replace ( '/([\\\\$])/' , '\\\\$1' , $ content ) ; } $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , strtr ( $ content , $ escapeSequences ) ] ) ; continue ; } if ( $ token -> isGivenKind ( self :: $ tokens ) ) { $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , strtr ( $ content , $ replacements ) ] ) ; } } } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; if ( 'echo' === $ this -> configuration [ 'use' ] ) { $ this -> candidateTokenType = T_PRINT ; $ this -> callBack = 'fixPrintToEcho' ; } else { $ this -> candidateTokenType = T_ECHO ; $ this -> callBack = 'fixEchoToPrint' ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ callBack = $ this -> callBack ; foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isGivenKind ( $ this -> candidateTokenType ) ) { $ this -> { $ callBack } ( $ tokens , $ index ) ; } } } 
public function resolve ( Tokens $ tokens , $ typeName ) { 
private function getNamespacesFromTokens ( Tokens $ tokens ) { return array_map ( function ( NamespaceAnalysis $ info ) { return $ info -> getFullName ( ) ; } , ( new NamespacesAnalyzer ( ) ) -> getDeclarations ( $ tokens ) ) ; } 
private function getUseMapFromTokens ( Tokens $ tokens ) { $ map = [ ] ; foreach ( ( new NamespaceUsesAnalyzer ( ) ) -> getDeclarationsFromTokens ( $ tokens ) as $ useDeclaration ) { $ map [ $ useDeclaration -> getShortName ( ) ] = $ useDeclaration -> getFullName ( ) ; } return $ map ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ analyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ index = $ tokens -> count ( ) - 4 ; $ index > 0 ; -- $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) || ! $ analyzer -> isLambda ( $ index ) ) { continue ; } $ prev = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ prev ] -> isGivenKind ( T_STATIC ) ) { continue ; 
private function hasPossibleReferenceToThis ( Tokens $ tokens , $ startIndex , $ endIndex ) { for ( $ i = $ startIndex ; $ i < $ endIndex ; ++ $ i ) { if ( $ tokens [ $ i ] -> isGivenKind ( T_VARIABLE ) && '$this' === strtolower ( $ tokens [ $ i ] -> getContent ( ) ) ) { return true ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; 
public function generate ( ReportSummary $ reportSummary ) { $ output = '' ; $ i = 0 ; foreach ( $ reportSummary -> getChanged ( ) as $ file => $ fixResult ) { ++ $ i ; $ output .= sprintf ( '%4d) %s' , $ i , $ file ) ; if ( $ reportSummary -> shouldAddAppliedFixers ( ) ) { $ output .= $ this -> getAppliedFixers ( $ reportSummary -> isDecoratedOutput ( ) , $ fixResult ) ; } $ output .= $ this -> getDiff ( $ reportSummary -> isDecoratedOutput ( ) , $ fixResult ) ; $ output .= PHP_EOL ; } return $ output . $ this -> getFooter ( $ reportSummary -> getTime ( ) , $ reportSummary -> getMemory ( ) , $ reportSummary -> isDryRun ( ) ) ; } 
private function getDiff ( $ isDecoratedOutput , array $ fixResult ) { if ( empty ( $ fixResult [ 'diff' ] ) ) { return '' ; } $ diffFormatter = new DiffConsoleFormatter ( $ isDecoratedOutput , sprintf ( '<comment> ---------- begin diff ----------</comment>%s%%s%s<comment> ----------- end diff -----------</comment>' , PHP_EOL , PHP_EOL ) ) ; return PHP_EOL . $ diffFormatter -> format ( $ fixResult [ 'diff' ] ) . PHP_EOL ; } 
private function getFooter ( $ time , $ memory , $ isDryRun ) { if ( 0 === $ time || 0 === $ memory ) { return '' ; } return PHP_EOL . sprintf ( '%s all files in %.3f seconds, %.3f MB memory used' . PHP_EOL , $ isDryRun ? 'Checked' : 'Fixed' , $ time / 1000 , $ memory / 1024 / 1024 ) ; } 
private function processException ( $ name , $ e ) { $ this -> dispatchEvent ( FixerFileProcessedEvent :: NAME , new FixerFileProcessedEvent ( FixerFileProcessedEvent :: STATUS_EXCEPTION ) ) ; $ this -> errorsManager -> report ( new Error ( Error :: TYPE_EXCEPTION , $ name , $ e ) ) ; } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolverRootless ( 'elements' , [ ( new FixerOptionBuilder ( 'elements' , 'The structural elements to fix (PHP >= 7.1 required for `const`).' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ new AllowedValueSubset ( [ 'property' , 'method' , 'const' ] ) ] ) -> setNormalizer ( static function ( Options $ options , $ value ) { if ( \ PHP_VERSION_ID < 70100 && \ in_array ( 'const' , $ value , true ) ) { throw new InvalidOptionsForEnvException ( '"const" option can only be enabled with PHP 7.1+.' ) ; } return $ value ; } ) -> setDefault ( [ 'property' , 'method' ] ) -> getOption ( ) , ] , $ this -> getName ( ) ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; $ elements = $ tokensAnalyzer -> getClassyElements ( ) ; foreach ( array_reverse ( $ elements , true ) as $ index => $ element ) { if ( ! \ in_array ( $ element [ 'type' ] , $ this -> configuration [ 'elements' ] , true ) ) { continue ; } $ abstractFinalIndex = null ; $ visibilityIndex = null ; $ staticIndex = null ; $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; while ( $ tokens [ $ prevIndex ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL , T_PRIVATE , T_PROTECTED , T_PUBLIC , T_STATIC , T_VAR ] ) ) { if ( $ tokens [ $ prevIndex ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL ] ) ) { $ abstractFinalIndex = $ prevIndex ; } elseif ( $ tokens [ $ prevIndex ] -> isGivenKind ( T_STATIC ) ) { $ staticIndex = $ prevIndex ; } else { $ visibilityIndex = $ prevIndex ; } $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ prevIndex ) ; } if ( $ tokens [ $ prevIndex ] -> equals ( ',' ) ) { continue ; } if ( null !== $ staticIndex ) { if ( $ this -> isKeywordPlacedProperly ( $ tokens , $ staticIndex , $ index ) ) { $ index = $ staticIndex ; } else { $ this -> moveTokenAndEnsureSingleSpaceFollows ( $ tokens , $ staticIndex , $ index ) ; } } if ( null === $ visibilityIndex ) { $ tokens -> insertAt ( $ index , [ new Token ( [ T_PUBLIC , 'public' ] ) , new Token ( [ T_WHITESPACE , ' ' ] ) ] ) ; } else { if ( $ tokens [ $ visibilityIndex ] -> isGivenKind ( T_VAR ) ) { $ tokens [ $ visibilityIndex ] = new Token ( [ T_PUBLIC , 'public' ] ) ; } if ( $ this -> isKeywordPlacedProperly ( $ tokens , $ visibilityIndex , $ index ) ) { $ index = $ visibilityIndex ; } else { $ this -> moveTokenAndEnsureSingleSpaceFollows ( $ tokens , $ visibilityIndex , $ index ) ; } } if ( null === $ abstractFinalIndex ) { continue ; } if ( $ this -> isKeywordPlacedProperly ( $ tokens , $ abstractFinalIndex , $ index ) ) { continue ; } $ this -> moveTokenAndEnsureSingleSpaceFollows ( $ tokens , $ abstractFinalIndex , $ index ) ; } } 
private function isKeywordPlacedProperly ( Tokens $ tokens , $ keywordIndex , $ comparedIndex ) { return $ keywordIndex + 2 === $ comparedIndex && ' ' === $ tokens [ $ keywordIndex + 1 ] -> getContent ( ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; $ classes = array_keys ( $ tokens -> findGivenKind ( T_CLASS ) ) ; $ numClasses = \ count ( $ classes ) ; for ( $ i = 0 ; $ i < $ numClasses ; ++ $ i ) { $ index = $ classes [ $ i ] ; 
private function fixConstructor ( Tokens $ tokens , $ className , $ classStart , $ classEnd ) { $ php4 = $ this -> findFunction ( $ tokens , $ className , $ classStart , $ classEnd ) ; if ( null === $ php4 ) { 
private function fixParent ( Tokens $ tokens , $ classStart , $ classEnd ) { 
private function fixInfiniteRecursion ( Tokens $ tokens , $ start , $ end ) { $ seq = [ [ T_VARIABLE , '$this' ] , [ T_OBJECT_OPERATOR ] , [ T_STRING , '__construct' ] , ] ; while ( true ) { $ callSeq = $ tokens -> findSequence ( $ seq , $ start , $ end , [ 2 => false ] ) ; if ( null === $ callSeq ) { return ; } $ callSeq = array_keys ( $ callSeq ) ; $ tokens [ $ callSeq [ 0 ] ] = new Token ( [ T_STRING , 'parent' ] ) ; $ tokens [ $ callSeq [ 1 ] ] = new Token ( [ T_DOUBLE_COLON , '::' ] ) ; } } 
private function getWrapperMethodSequence ( Tokens $ tokens , $ method , $ startIndex , $ bodyIndex ) { 
private function findFunction ( Tokens $ tokens , $ name , $ startIndex , $ endIndex ) { $ function = $ tokens -> findSequence ( [ [ T_FUNCTION ] , [ T_STRING , $ name ] , '(' , ] , $ startIndex , $ endIndex , false ) ; if ( null === $ function ) { return null ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ count = $ tokens -> count ( ) ; if ( $ count && ! $ tokens [ $ count - 1 ] -> isGivenKind ( [ T_INLINE_HTML , T_CLOSE_TAG , T_OPEN_TAG ] ) ) { $ tokens -> ensureWhitespaceAtIndex ( $ count - 1 , 1 , $ this -> whitespacesConfig -> getLineEnding ( ) ) ; } } 
public function isCandidate ( Tokens $ tokens ) { return $ tokens -> isTokenKindFound ( T_UNSET ) && $ tokens -> isAnyTokenKindsFound ( [ T_OBJECT_OPERATOR , T_PAAMAYIM_NEKUDOTAYIM ] ) ; } 
private function getUnsetsInfo ( Tokens $ tokens , $ index ) { $ argumentsAnalyzer = new ArgumentsAnalyzer ( ) ; $ unsetStart = $ tokens -> getNextTokenOfKind ( $ index , [ '(' ] ) ; $ unsetEnd = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ unsetStart ) ; $ isFirst = true ; $ unsets = [ ] ; foreach ( $ argumentsAnalyzer -> getArguments ( $ tokens , $ unsetStart , $ unsetEnd ) as $ startIndex => $ endIndex ) { $ startIndex = $ tokens -> getNextMeaningfulToken ( $ startIndex - 1 ) ; $ endIndex = $ tokens -> getPrevMeaningfulToken ( $ endIndex + 1 ) ; $ unsets [ ] = [ 'startIndex' => $ startIndex , 'endIndex' => $ endIndex , 'isToTransform' => $ this -> isProperty ( $ tokens , $ startIndex , $ endIndex ) , 'isFirst' => $ isFirst , ] ; $ isFirst = false ; } return $ unsets ; } 
private function isProperty ( Tokens $ tokens , $ index , $ endIndex ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_VARIABLE ) ) { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( null === $ nextIndex || ! $ tokens [ $ nextIndex ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return false ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ; $ nextNextIndex = $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ; if ( null !== $ nextNextIndex && $ nextNextIndex < $ endIndex ) { return false ; } return null !== $ nextIndex && $ tokens [ $ nextIndex ] -> isGivenKind ( T_STRING ) ; } if ( $ tokens [ $ index ] -> isGivenKind ( [ T_NS_SEPARATOR , T_STRING ] ) ) { $ nextIndex = $ tokens -> getTokenNotOfKindSibling ( $ index , 1 , [ [ T_DOUBLE_COLON ] , [ T_NS_SEPARATOR ] , [ T_STRING ] ] ) ; $ nextNextIndex = $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ; if ( null !== $ nextNextIndex && $ nextNextIndex < $ endIndex ) { return false ; } return null !== $ nextIndex && $ tokens [ $ nextIndex ] -> isGivenKind ( T_VARIABLE ) ; } return false ; } 
public function resolve ( array $ options ) { $ resolver = new OptionsResolver ( ) ; foreach ( $ this -> options as $ option ) { $ name = $ option -> getName ( ) ; if ( $ option instanceof AliasedFixerOption ) { $ alias = $ option -> getAlias ( ) ; if ( \ array_key_exists ( $ alias , $ options ) ) { 
private function addOption ( FixerOptionInterface $ option ) { $ name = $ option -> getName ( ) ; if ( \ in_array ( $ name , $ this -> registeredNames , true ) ) { throw new \ LogicException ( sprintf ( 'The "%s" option is defined multiple times.' , $ name ) ) ; } $ this -> options [ ] = $ option ; $ this -> registeredNames [ ] = $ name ; return $ this ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( $ this -> isElseif ( $ tokens , $ index ) && $ this -> isSuperfluousElse ( $ tokens , $ index ) ) { $ this -> convertElseifToIf ( $ tokens , $ index ) ; } } } 
private function isElseif ( Tokens $ tokens , $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_ELSEIF ) ) { return true ; } return $ tokens [ $ index ] -> isGivenKind ( T_ELSE ) && $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] -> isGivenKind ( T_IF ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ map = [ 'array' => [ T_ARRAY_CAST , '(array)' ] , 'bool' => [ T_BOOL_CAST , '(bool)' ] , 'boolean' => [ T_BOOL_CAST , '(bool)' ] , 'double' => [ T_DOUBLE_CAST , '(float)' ] , 'float' => [ T_DOUBLE_CAST , '(float)' ] , 'int' => [ T_INT_CAST , '(int)' ] , 'integer' => [ T_INT_CAST , '(int)' ] , 'object' => [ T_OBJECT_CAST , '(object)' ] , 'string' => [ T_STRING_CAST , '(string)' ] , 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ ending = $ this -> whitespacesConfig -> getLineEnding ( ) ; foreach ( $ tokens as $ tokenIndex => $ token ) { if ( ! $ token -> isGivenKind ( [ T_CONSTANT_ENCAPSED_STRING , T_ENCAPSED_AND_WHITESPACE ] ) ) { continue ; } $ tokens [ $ tokenIndex ] = new Token ( [ $ token -> getId ( ) , Preg :: replace ( '#\R#u' , $ ending , $ token -> getContent ( ) ) , ] ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ functionyTokens = $ this -> getFunctionyTokenKinds ( ) ; $ languageConstructionTokens = $ this -> getLanguageConstructionTokenKinds ( ) ; $ braceTypes = $ this -> getBraceAfterVariableKinds ( ) ; foreach ( $ tokens as $ index => $ token ) { 
private function fixFunctionCall ( Tokens $ tokens , $ index ) { 
private function getFunctionyTokenKinds ( ) { static $ tokens = [ T_ARRAY , T_ECHO , T_EMPTY , T_EVAL , T_EXIT , T_INCLUDE , T_INCLUDE_ONCE , T_ISSET , T_LIST , T_PRINT , T_REQUIRE , T_REQUIRE_ONCE , T_UNSET , T_VARIABLE , ] ; return $ tokens ; } 
public function lintSource ( $ source ) { try { 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> functionsFixMap = [ ] ; foreach ( $ this -> configuration [ 'functions' ] as $ key ) { $ this -> functionsFixMap [ $ key ] = self :: $ availableFunctions [ $ key ] ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 4 ; $ index > 0 ; -- $ index ) { $ candidate = $ this -> getReplaceCandidate ( $ tokens , $ index ) ; if ( null === $ candidate ) { continue ; } $ this -> fixFunctionCallToConstant ( $ tokens , $ index , $ candidate [ 0 ] , 
protected function createConfigurationDefinition ( ) { $ functionNames = array_keys ( self :: $ availableFunctions ) ; return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'functions' , 'List of function names to fix.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ new AllowedValueSubset ( $ functionNames ) ] ) -> setDefault ( [ 'get_class' , 'php_sapi_name' , 'phpversion' , 'pi' , 
private function getReplaceCandidate ( Tokens $ tokens , $ index ) { 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ insideForParenthesesUntil = null ; for ( $ index = 0 , $ max = \ count ( $ tokens ) - 1 ; $ index < $ max ; ++ $ index ) { if ( $ this -> configuration [ 'remove_in_empty_for_expressions' ] ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_FOR ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ insideForParenthesesUntil = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; continue ; } if ( $ index === $ insideForParenthesesUntil ) { $ insideForParenthesesUntil = null ; continue ; } } if ( ! $ tokens [ $ index ] -> equals ( ';' ) ) { continue ; } if ( ! $ tokens [ $ index + 1 ] -> isWhitespace ( ) ) { if ( ! $ tokens [ $ index + 1 ] -> equalsAny ( [ ')' , [ T_INLINE_HTML ] ] ) && ( ! $ this -> configuration [ 'remove_in_empty_for_expressions' ] || ! $ tokens [ $ index + 1 ] -> equals ( ';' ) ) ) { $ tokens -> insertAt ( $ index + 1 , new Token ( [ T_WHITESPACE , ' ' ] ) ) ; ++ $ max ; } continue ; } if ( null !== $ insideForParenthesesUntil && ( $ tokens [ $ index + 2 ] -> equals ( ';' ) || $ index + 2 === $ insideForParenthesesUntil ) && ! Preg :: match ( '/\R/' , $ tokens [ $ index + 1 ] -> getContent ( ) ) ) { $ tokens -> clearAt ( $ index + 1 ) ; continue ; } if ( isset ( $ tokens [ $ index + 2 ] ) && ! $ tokens [ $ index + 1 ] -> equals ( [ T_WHITESPACE , ' ' ] ) && $ tokens [ $ index + 1 ] -> isWhitespace ( " \t" ) && ! $ tokens [ $ index + 2 ] -> isComment ( ) && ! $ tokens [ $ index + 2 ] -> equals ( ')' ) ) { $ tokens [ $ index + 1 ] = new Token ( [ T_WHITESPACE , ' ' ] ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { static $ nativeFunctionNames = null ; if ( null === $ nativeFunctionNames ) { $ nativeFunctionNames = $ this -> getNativeFunctionNames ( ) ; } for ( $ index = 0 , $ count = $ tokens -> count ( ) ; $ index < $ count ; ++ $ index ) { 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> callback = 'none' === $ this -> configuration [ 'space' ] ? 'removeWhitespaceAroundToken' : 'ensureWhitespaceAroundToken' ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ callback = $ this -> callback ; for ( $ index = 0 , $ count = $ tokens -> count ( ) ; $ index < $ count - 6 ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DECLARE ) ) { continue ; } while ( ! $ tokens [ ++ $ index ] -> equals ( '=' ) ) ; $ this -> { $ callback } ( $ tokens , $ index ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ candidates = $ this -> findPowCalls ( $ tokens ) ; $ argumentsAnalyzer = new ArgumentsAnalyzer ( ) ; $ numberOfTokensAdded = 0 ; $ previousCloseParenthesisIndex = \ count ( $ tokens ) ; foreach ( array_reverse ( $ candidates ) as $ candidate ) { 
private function fixPowToExponentiation ( Tokens $ tokens , $ functionNameIndex , $ openParenthesisIndex , $ closeParenthesisIndex , array $ arguments ) { 
private function isParenthesisNeeded ( Tokens $ tokens , $ argumentStartIndex , $ argumentEndIndex ) { static $ allowedKinds = [ T_DNUMBER , T_LNUMBER , T_VARIABLE , T_STRING , T_OBJECT_OPERATOR , T_CONSTANT_ENCAPSED_STRING , T_DOUBLE_CAST , T_INT_CAST , T_INC , T_DEC , T_NS_SEPARATOR , T_WHITESPACE , T_DOUBLE_COLON , T_LINE , T_COMMENT , T_DOC_COMMENT , CT :: T_NAMESPACE_OPERATOR , ] ; for ( $ i = $ argumentStartIndex ; $ i <= $ argumentEndIndex ; ++ $ i ) { if ( $ tokens [ $ i ] -> isGivenKind ( $ allowedKinds ) || $ tokens -> isEmptyAt ( $ i ) ) { continue ; } if ( null !== $ blockType = Tokens :: detectBlockType ( $ tokens [ $ i ] ) ) { $ i = $ tokens -> findBlockEnd ( $ blockType [ 'type' ] , $ i ) ; continue ; } if ( $ tokens [ $ i ] -> equals ( '$' ) ) { $ i = $ tokens -> getNextMeaningfulToken ( $ i ) ; if ( $ tokens [ $ i ] -> isGivenKind ( CT :: T_DYNAMIC_VAR_BRACE_OPEN ) ) { $ i = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_DYNAMIC_VAR_BRACE , $ i ) ; continue ; } } if ( $ tokens [ $ i ] -> equals ( '+' ) && $ tokens -> getPrevMeaningfulToken ( $ i ) < $ argumentStartIndex ) { continue ; } return true ; } return false ; } 
public function generate ( ReportSummary $ reportSummary ) { if ( ! \ extension_loaded ( 'dom' ) ) { throw new \ RuntimeException ( 'Cannot generate report! `ext-dom` is not available!' ) ; } $ dom = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ testsuites = $ dom -> appendChild ( $ dom -> createElement ( 'testsuites' ) ) ; $ testsuite = $ testsuites -> appendChild ( $ dom -> createElement ( 'testsuite' ) ) ; $ testsuite -> setAttribute ( 'name' , 'PHP CS Fixer' ) ; if ( \ count ( $ reportSummary -> getChanged ( ) ) ) { $ this -> createFailedTestCases ( $ dom , $ testsuite , $ reportSummary ) ; } else { $ this -> createSuccessTestCase ( $ dom , $ testsuite ) ; } if ( $ reportSummary -> getTime ( ) ) { $ testsuite -> setAttribute ( 'time' , sprintf ( '%.3f' , $ reportSummary -> getTime ( ) / 1000 ) ) ; } $ dom -> formatOutput = true ; return $ reportSummary -> isDecoratedOutput ( ) ? OutputFormatter :: escape ( $ dom -> saveXML ( ) ) : $ dom -> saveXML ( ) ; } 
protected function createConfigurationDefinition ( ) { $ options = parent :: createConfigurationDefinition ( ) -> getOptions ( ) ; $ operator = new FixerOptionBuilder ( 'operator' , 'The operator to use.' ) ; $ options [ ] = $ operator -> setAllowedValues ( [ '=' , ':' ] ) -> setDefault ( '=' ) -> getOption ( ) ; return new FixerConfigurationResolver ( $ options ) ; } 
protected function fixAnnotations ( Tokens $ tokens ) { $ scopes = [ ] ; foreach ( $ tokens as $ token ) { if ( $ token -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { $ scopes [ ] = 'annotation' ; continue ; } if ( $ token -> isType ( DocLexer :: T_OPEN_CURLY_BRACES ) ) { $ scopes [ ] = 'array' ; continue ; } if ( $ token -> isType ( [ DocLexer :: T_CLOSE_PARENTHESIS , DocLexer :: T_CLOSE_CURLY_BRACES ] ) ) { array_pop ( $ scopes ) ; continue ; } if ( 'array' === end ( $ scopes ) && $ token -> isType ( [ DocLexer :: T_EQUALS , DocLexer :: T_COLON ] ) ) { $ token -> setContent ( $ this -> configuration [ 'operator' ] ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokensOrg ) { $ content = $ tokensOrg -> generateCode ( ) ; * > echo '<? '; * with * > echo '<?php '; */ $ tokens = Tokens :: fromCode ( $ newContent ) ; $ tokensOldContent = '' ; $ tokensOldContentLength = 0 ; foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isGivenKind ( T_OPEN_TAG ) ) { $ tokenContent = $ token -> getContent ( ) ; if ( '<?php' !== strtolower ( substr ( $ content , $ tokensOldContentLength , 5 ) ) ) { $ tokenContent = '<? ' ; } $ tokensOldContent .= $ tokenContent ; $ tokensOldContentLength += \ strlen ( $ tokenContent ) ; continue ; } if ( $ token -> isGivenKind ( [ T_COMMENT , T_DOC_COMMENT , T_CONSTANT_ENCAPSED_STRING , T_ENCAPSED_AND_WHITESPACE , T_STRING ] ) ) { $ tokenContent = '' ; $ tokenContentLength = 0 ; $ parts = explode ( '<?php' , $ token -> getContent ( ) ) ; $ iLast = \ count ( $ parts ) - 1 ; foreach ( $ parts as $ i => $ part ) { $ tokenContent .= $ part ; $ tokenContentLength += \ strlen ( $ part ) ; if ( $ i !== $ iLast ) { $ originalTokenContent = substr ( $ content , $ tokensOldContentLength + $ tokenContentLength , 5 ) ; if ( '<?php' === strtolower ( $ originalTokenContent ) ) { $ tokenContent .= $ originalTokenContent ; $ tokenContentLength += 5 ; } else { $ tokenContent .= '<?' ; $ tokenContentLength += 2 ; } } } $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , $ tokenContent ] ) ; $ token = $ tokens [ $ index ] ; } $ tokensOldContent .= $ token -> getContent ( ) ; $ tokensOldContentLength += \ strlen ( $ token -> getContent ( ) ) ; } $ tokensOrg -> overrideRange ( 0 , $ tokensOrg -> count ( ) - 1 , $ tokens ) ; } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; if ( isset ( $ this -> configuration [ 'functions' ] ) ) { $ this -> functions = $ this -> configuration [ 'functions' ] ; return ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ this -> getPreviousAssertCall ( $ tokens ) as $ assertCall ) { 
protected function createConfigurationDefinition ( ) { $ values = [ 'array_key_exists' , 'empty' , 'file_exists' , 'is_array' , 'is_bool' , 'is_callable' , 'is_double' , 'is_float' , 'is_infinite' , 'is_int' , 'is_integer' , 'is_long' , 'is_nan' , 'is_null' , 'is_numeric' , 'is_object' , 'is_real' , 'is_resource' , 'is_scalar' , 'is_string' , ] ; sort ( $ values ) ; return new FixerConfigurationResolverRootless ( 'functions' , [ ( new FixerOptionBuilder ( 'functions' , 'List of assertions to fix (overrides `target`).' ) ) -> setAllowedTypes ( [ 'null' , 'array' ] ) -> setAllowedValues ( [ null , new AllowedValueSubset ( $ values ) , ] ) -> setDefault ( null ) -> setDeprecationMessage ( 'Use option `target` instead.' ) -> getOption ( ) , ( new FixerOptionBuilder ( 'target' , 'Target version of PHPUnit.' ) ) -> setAllowedTypes ( [ 'string' ] ) -> setAllowedValues ( [ PhpUnitTargetVersion :: VERSION_3_0 , PhpUnitTargetVersion :: VERSION_3_5 , PhpUnitTargetVersion :: VERSION_5_0 , PhpUnitTargetVersion :: VERSION_5_6 , PhpUnitTargetVersion :: VERSION_NEWEST , ] ) -> setDefault ( PhpUnitTargetVersion :: VERSION_5_0 ) 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( ! $ token -> isComment ( ) ) { return ; } $ content = $ token -> getContent ( ) ; $ trimmedContent = rtrim ( $ content ) ; 
public function doRun ( InputInterface $ input , OutputInterface $ output ) { $ stdErr = $ output instanceof ConsoleOutputInterface ? $ output -> getErrorOutput ( ) : ( $ input -> hasParameterOption ( '--format' , true ) && 'txt' !== $ input -> getParameterOption ( '--format' , null , true ) ? null : $ output ) ; if ( null !== $ stdErr ) { $ warningsDetector = new WarningsDetector ( $ this -> toolInfo ) ; $ warningsDetector -> detectOldVendor ( ) ; $ warningsDetector -> detectOldMajor ( ) ; foreach ( $ warningsDetector -> getWarnings ( ) as $ warning ) { $ stdErr -> writeln ( sprintf ( $ stdErr -> isDecorated ( ) ? '<bg=yellow;fg=black;>%s</>' : '%s' , $ warning ) ) ; } } return parent :: doRun ( $ input , $ output ) ; } 
public function getLongVersion ( ) { $ version = parent :: getLongVersion ( ) ; if ( self :: VERSION_CODENAME ) { $ version .= ' <info>' . self :: VERSION_CODENAME . '</info>' ; } $ version .= ' by <comment>Fabien Potencier</comment> and <comment>Dariusz Ruminski</comment>' ; $ commit = '@git-commit@' ; if ( '@' . 'git-commit@' !== $ commit ) { $ version .= ' (' . substr ( $ commit , 0 , 7 ) . ')' ; } return $ version ; } 
protected function find ( $ functionNameToSearch , Tokens $ tokens , $ start = 0 , $ end = null ) { 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ argumentsAnalyzer = new ArgumentsAnalyzer ( ) ; for ( $ index = 0 , $ limit = $ tokens -> count ( ) ; $ index < $ limit ; ++ $ index ) { $ mainIndex = $ index ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ tokenContent = $ token -> getContent ( ) ; if ( false !== stripos ( $ tokenContent , 'inheritdoc' ) ) { continue ; } 
private function prepareArgumentInformation ( Tokens $ tokens , $ start , $ end ) { $ info = [ 'default' => '' , 'name' => '' , 'type' => '' , ] ; $ sawName = false ; for ( $ index = $ start ; $ index <= $ end ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isComment ( ) || $ token -> isWhitespace ( ) ) { continue ; } if ( $ token -> isGivenKind ( T_VARIABLE ) ) { $ sawName = true ; $ info [ 'name' ] = $ token -> getContent ( ) ; continue ; } if ( $ token -> equals ( '=' ) ) { continue ; } if ( $ sawName ) { $ info [ 'default' ] .= $ token -> getContent ( ) ; } elseif ( '&' !== $ token -> getContent ( ) ) { if ( $ token -> isGivenKind ( T_ELLIPSIS ) ) { if ( '' === $ info [ 'type' ] ) { $ info [ 'type' ] = 'array' ; } else { $ info [ 'type' ] .= '[]' ; } } else { $ info [ 'type' ] .= $ token -> getContent ( ) ; } } } return $ info ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ isInNamespace = false ; $ isImported = false ; 
public static function clearCache ( $ key = null ) { if ( null === $ key ) { self :: $ cache = [ ] ; return ; } if ( self :: hasCache ( $ key ) ) { unset ( self :: $ cache [ $ key ] ) ; } } 
public static function detectBlockType ( Token $ token ) { foreach ( self :: getBlockEdgeDefinitions ( ) as $ type => $ definition ) { if ( $ token -> equals ( $ definition [ 'start' ] ) ) { return [ 'type' => $ type , 'isStart' => true ] ; } if ( $ token -> equals ( $ definition [ 'end' ] ) ) { return [ 'type' => $ type , 'isStart' => false ] ; } } } 
public static function fromArray ( $ array , $ saveIndexes = null ) { $ tokens = new self ( \ count ( $ array ) ) ; if ( null === $ saveIndexes || $ saveIndexes ) { foreach ( $ array as $ key => $ val ) { $ tokens [ $ key ] = $ val ; } } else { $ index = 0 ; foreach ( $ array as $ val ) { $ tokens [ $ index ++ ] = $ val ; } } $ tokens -> generateCode ( ) ; 
public static function fromCode ( $ code ) { $ codeHash = self :: calculateCodeHash ( $ code ) ; if ( self :: hasCache ( $ codeHash ) ) { $ tokens = self :: getCache ( $ codeHash ) ; 
public function setSize ( $ size ) { if ( $ this -> getSize ( ) !== $ size ) { $ this -> changed = true ; parent :: setSize ( $ size ) ; } } 
public function offsetUnset ( $ index ) { $ this -> changed = true ; $ this -> unregisterFoundToken ( $ this [ $ index ] ) ; parent :: offsetUnset ( $ index ) ; } 
public function offsetSet ( $ index , $ newval ) { $ this -> blockEndCache = [ ] ; if ( ! $ this [ $ index ] || ! $ this [ $ index ] -> equals ( $ newval ) ) { $ this -> changed = true ; if ( isset ( $ this [ $ index ] ) ) { $ this -> unregisterFoundToken ( $ this [ $ index ] ) ; } $ this -> registerFoundToken ( $ newval ) ; } parent :: offsetSet ( $ index , $ newval ) ; } 
public function clearChanged ( ) { $ this -> changed = false ; if ( self :: isLegacyMode ( ) ) { foreach ( $ this as $ token ) { $ token -> clearChanged ( ) ; } } } 
public function clearEmptyTokens ( ) { $ limit = $ this -> count ( ) ; $ index = 0 ; for ( ; $ index < $ limit ; ++ $ index ) { if ( $ this -> isEmptyAt ( $ index ) ) { break ; } } 
public function ensureWhitespaceAtIndex ( $ index , $ indexOffset , $ whitespace ) { $ removeLastCommentLine = static function ( self $ tokens , $ index , $ indexOffset , $ whitespace ) { $ token = $ tokens [ $ index ] ; if ( 1 === $ indexOffset && $ token -> isGivenKind ( T_OPEN_TAG ) ) { if ( 0 === strpos ( $ whitespace , "\r\n" ) ) { $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , rtrim ( $ token -> getContent ( ) ) . "\r\n" ] ) ; return \ strlen ( $ whitespace ) > 2 
public function findBlockEnd ( $ type , $ searchIndex , $ findEnd = true ) { if ( 3 === \ func_num_args ( ) ) { if ( $ findEnd ) { @ trigger_error ( 'Argument #3 of Tokens::findBlockEnd is deprecated and will be removed in 3.0, you can safely drop the argument.' , E_USER_DEPRECATED ) ; } else { @ trigger_error ( 'Argument #3 of Tokens::findBlockEnd is deprecated and will be removed in 3.0, use Tokens::findBlockStart instead.' , E_USER_DEPRECATED ) ; } } return $ this -> findOppositeBlockEdge ( $ type , $ searchIndex , $ findEnd ) ; } 
public function findGivenKind ( $ possibleKind , $ start = 0 , $ end = null ) { $ this -> rewind ( ) ; if ( null === $ end ) { $ end = $ this -> count ( ) ; } $ elements = [ ] ; $ possibleKinds = ( array ) $ possibleKind ; foreach ( $ possibleKinds as $ kind ) { $ elements [ $ kind ] = [ ] ; } if ( ! self :: isLegacyMode ( ) ) { $ possibleKinds = array_filter ( $ possibleKinds , function ( $ kind ) { return $ this -> isTokenKindFound ( $ kind ) ; } ) ; } if ( \ count ( $ possibleKinds ) ) { for ( $ i = $ start ; $ i < $ end ; ++ $ i ) { $ token = $ this [ $ i ] ; if ( $ token -> isGivenKind ( $ possibleKinds ) ) { $ elements [ $ token -> getId ( ) ] [ $ i ] = $ token ; } } } return \ is_array ( $ possibleKind ) ? $ elements : $ elements [ $ possibleKind ] ; } 
public function generatePartialCode ( $ start , $ end ) { $ code = '' ; for ( $ i = $ start ; $ i <= $ end ; ++ $ i ) { $ code .= $ this [ $ i ] -> getContent ( ) ; } return $ code ; } 
public function getNextTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , 1 , $ tokens , $ caseSensitive ) ; } 
public function getNonWhitespaceSibling ( $ index , $ direction , $ whitespaces = null ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( ! $ token -> isWhitespace ( $ whitespaces ) ) { return $ index ; } } } 
public function getPrevTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , - 1 , $ tokens , $ caseSensitive ) ; } 
public function getTokenOfKindSibling ( $ index , $ direction , array $ tokens = [ ] , $ caseSensitive = true ) { if ( ! self :: isLegacyMode ( ) ) { $ tokens = array_filter ( $ tokens , function ( $ token ) { return $ this -> isTokenKindFound ( $ this -> extractTokenKind ( $ token ) ) ; } ) ; } if ( ! \ count ( $ tokens ) ) { return null ; } while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( $ token -> equalsAny ( $ tokens , $ caseSensitive ) ) { return $ index ; } } } 
public function getTokenNotOfKindSibling ( $ index , $ direction , array $ tokens = [ ] ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( $ this -> isEmptyAt ( $ index ) ) { continue ; } if ( $ this [ $ index ] -> equalsAny ( $ tokens ) ) { continue ; } return $ index ; } } 
public function getMeaningfulTokenSibling ( $ index , $ direction ) { return $ this -> getTokenNotOfKindSibling ( $ index , $ direction , [ [ T_WHITESPACE ] , [ T_COMMENT ] , [ T_DOC_COMMENT ] ] ) ; } 
public function getNonEmptySibling ( $ index , $ direction ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( ! $ this -> isEmptyAt ( $ index ) ) { return $ index ; } } } 
public function findSequence ( array $ sequence , $ start = 0 , $ end = null , $ caseSensitive = true ) { $ sequenceCount = \ count ( $ sequence ) ; if ( 0 === $ sequenceCount ) { throw new \ InvalidArgumentException ( 'Invalid sequence.' ) ; } 
public function insertAt ( $ index , $ items ) { $ items = \ is_array ( $ items ) || $ items instanceof self ? $ items : [ $ items ] ; $ itemsCnt = \ count ( $ items ) ; if ( 0 === $ itemsCnt ) { return ; } $ oldSize = \ count ( $ this ) ; $ this -> changed = true ; $ this -> blockEndCache = [ ] ; $ this -> setSize ( $ oldSize + $ itemsCnt ) ; 
public function isChanged ( ) { if ( $ this -> changed ) { return true ; } if ( self :: isLegacyMode ( ) ) { foreach ( $ this as $ token ) { if ( $ token -> isChanged ( ) ) { return true ; } } } return false ; } 
public function isEmptyAt ( $ index ) { $ token = $ this [ $ index ] ; return null === $ token -> getId ( ) && '' === $ token -> getContent ( ) ; } 
public function overrideAt ( $ index , $ token ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0, use offsetSet instead.' , E_USER_DEPRECATED ) ; self :: $ isLegacyMode = true ; $ this [ $ index ] -> override ( $ token ) ; $ this -> registerFoundToken ( $ token ) ; } 
public function overrideRange ( $ indexStart , $ indexEnd , $ items ) { $ oldCode = $ this -> generatePartialCode ( $ indexStart , $ indexEnd ) ; $ newCode = '' ; foreach ( $ items as $ item ) { $ newCode .= $ item -> getContent ( ) ; } 
public function setCode ( $ code ) { 
public function isAllTokenKindsFound ( array $ tokenKinds ) { foreach ( $ tokenKinds as $ tokenKind ) { if ( empty ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { return false ; } } return true ; } 
public function countTokenKind ( $ tokenKind ) { if ( self :: isLegacyMode ( ) ) { throw new \ RuntimeException ( sprintf ( '%s is not available in legacy mode.' , __METHOD__ ) ) ; } return isset ( $ this -> foundTokenKinds [ $ tokenKind ] ) ? $ this -> foundTokenKinds [ $ tokenKind ] : 0 ; } 
public function clearRange ( $ indexStart , $ indexEnd ) { for ( $ i = $ indexStart ; $ i <= $ indexEnd ; ++ $ i ) { $ this -> clearAt ( $ i ) ; } } 
public function isMonolithicPhp ( ) { $ size = $ this -> count ( ) ; if ( 0 === $ size ) { return false ; } if ( self :: isLegacyMode ( ) ) { 
public function isPartialCodeMultiline ( $ start , $ end ) { for ( $ i = $ start ; $ i <= $ end ; ++ $ i ) { if ( false !== strpos ( $ this [ $ i ] -> getContent ( ) , "\n" ) ) { return true ; } } return false ; } 
private function findOppositeBlockEdge ( $ type , $ searchIndex , $ findEnd ) { $ blockEdgeDefinitions = self :: getBlockEdgeDefinitions ( ) ; if ( ! isset ( $ blockEdgeDefinitions [ $ type ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid param type: %s.' , $ type ) ) ; } if ( ! self :: isLegacyMode ( ) && isset ( $ this -> blockEndCache [ $ searchIndex ] ) ) { return $ this -> blockEndCache [ $ searchIndex ] ; } $ startEdge = $ blockEdgeDefinitions [ $ type ] [ 'start' ] ; $ endEdge = $ blockEdgeDefinitions [ $ type ] [ 'end' ] ; $ startIndex = $ searchIndex ; $ endIndex = $ this -> count ( ) - 1 ; $ indexOffset = 1 ; if ( ! $ findEnd ) { list ( $ startEdge , $ endEdge ) = [ $ endEdge , $ startEdge ] ; $ indexOffset = - 1 ; $ endIndex = 0 ; } if ( ! $ this [ $ startIndex ] -> equals ( $ startEdge ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid param $startIndex - not a proper block %s.' , $ findEnd ? 'start' : 'end' ) ) ; } $ blockLevel = 0 ; for ( $ index = $ startIndex ; $ index !== $ endIndex ; $ index += $ indexOffset ) { $ token = $ this [ $ index ] ; if ( $ token -> equals ( $ startEdge ) ) { ++ $ blockLevel ; continue ; } if ( $ token -> equals ( $ endEdge ) ) { -- $ blockLevel ; if ( 0 === $ blockLevel ) { break ; } continue ; } } if ( ! $ this [ $ index ] -> equals ( $ endEdge ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Missing block %s.' , $ findEnd ? 'end' : 'start' ) ) ; } $ this -> blockEndCache [ $ startIndex ] = $ index ; $ this -> blockEndCache [ $ index ] = $ startIndex ; return $ index ; } 
private static function getCache ( $ key ) { if ( ! self :: hasCache ( $ key ) ) { throw new \ OutOfBoundsException ( sprintf ( 'Unknown cache key: "%s".' , $ key ) ) ; } return self :: $ cache [ $ key ] ; } 
private function changeCodeHash ( $ codeHash ) { if ( null !== $ this -> codeHash ) { self :: clearCache ( $ this -> codeHash ) ; } $ this -> codeHash = $ codeHash ; self :: setCache ( $ this -> codeHash , $ this ) ; } 
private function registerFoundToken ( $ token ) { 
private function extractTokenKind ( $ token ) { return $ token instanceof Token ? ( $ token -> isArray ( ) ? $ token -> getId ( ) : $ token -> getContent ( ) ) : ( \ is_array ( $ token ) ? $ token [ 0 ] : $ token ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> equalsAny ( [ '[' , [ CT :: T_ARRAY_INDEX_CURLY_BRACE_OPEN ] ] ) ) { continue ; } if ( \ in_array ( 'inside' , $ this -> configuration [ 'positions' ] , true ) ) { if ( $ token -> equals ( '[' ) ) { $ endIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_INDEX_SQUARE_BRACE , $ index ) ; } else { $ endIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_ARRAY_INDEX_CURLY_BRACE , $ index ) ; } 
protected function createConfigurationDefinition ( ) { $ values = [ 'inside' , 'outside' ] ; return new FixerConfigurationResolverRootless ( 'positions' , [ ( new FixerOptionBuilder ( 'positions' , 'Whether spacing should be fixed inside and/or outside the offset braces.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ new AllowedValueSubset ( $ values ) ] ) -> setDefault ( $ values ) -> getOption ( ) , ] , $ this -> getName ( ) ) ; } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> methodMap = [ 'setExpectedException' => 'expectExceptionMessage' , ] ; if ( PhpUnitTargetVersion :: fulfills ( $ this -> configuration [ 'target' ] , PhpUnitTargetVersion :: VERSION_5_6 ) ) { $ this -> methodMap [ 'setExpectedExceptionRegExp' ] = 'expectExceptionMessageRegExp' ; } } 
public function getDefinition ( ) { return new FixerDefinition ( 'Usages of `->setExpectedException*` methods MUST be replaced by `->expectException*` methods.' , [ new CodeSample ( '<?php final class MyTest extends \PHPUnit_Framework_TestCase { public function testFoo() { $this->setExpectedException("RuntimeException", "Msg", 123); foo(); } public function testBar() { $this->setExpectedExceptionRegExp("RuntimeException", "/Msg.*/", 123); bar(); } } ' ) , new CodeSample ( '<?php final class MyTest extends \PHPUnit_Framework_TestCase { public function testFoo() { $this->setExpectedException("RuntimeException", null, 123); foo(); } public function testBar() { $this->setExpectedExceptionRegExp("RuntimeException", "/Msg.*/", 123); bar(); } } ' , [ 'target' => PhpUnitTargetVersion :: VERSION_5_6 ] ) , new CodeSample ( '<?php final class MyTest extends \PHPUnit_Framework_TestCase { public function testFoo() { $this->setExpectedException("RuntimeException", "Msg", 123); foo(); } public function testBar() { $this->setExpectedExceptionRegExp("RuntimeException", "/Msg.*/", 123); bar(); } } ' , [ 'target' => PhpUnitTargetVersion :: VERSION_5_2 ] ) , ] , null , 'Risky when PHPUnit classes are overridden or not accessible, or when project has PHPUnit incompatibilities.' ) ; } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'target' , 'Target version of PHPUnit.' ) ) -> setAllowedTypes ( [ 'string' ] ) -> setAllowedValues ( [ PhpUnitTargetVersion :: VERSION_5_2 , PhpUnitTargetVersion :: VERSION_5_6 , PhpUnitTargetVersion :: VERSION_NEWEST ] ) -> setDefault ( PhpUnitTargetVersion :: VERSION_NEWEST ) -> getOption ( ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; $ index >= 0 ; -- $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( [ T_ARRAY , CT :: T_ARRAY_SQUARE_BRACE_OPEN ] ) ) { $ this -> fixSpacing ( $ index , $ tokens ) ; } } } 
private function fixSpacing ( $ index , Tokens $ tokens ) { if ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_ARRAY_SQUARE_BRACE_OPEN ) ) { $ startIndex = $ index ; $ endIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ startIndex ) ; } else { $ startIndex = $ tokens -> getNextTokenOfKind ( $ index , [ '(' ] ) ; $ endIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startIndex ) ; } for ( $ i = $ endIndex - 1 ; $ i > $ startIndex ; -- $ i ) { $ i = $ this -> skipNonArrayElements ( $ i , $ tokens ) ; $ currentToken = $ tokens [ $ i ] ; $ prevIndex = $ tokens -> getPrevNonWhitespace ( $ i - 1 ) ; if ( $ currentToken -> equals ( ',' ) && ! $ tokens [ $ prevIndex ] -> equals ( [ T_END_HEREDOC ] ) && ! $ tokens [ $ prevIndex ] -> isComment ( ) ) { $ tokens -> removeLeadingWhitespace ( $ i ) ; } } } 
private function skipNonArrayElements ( $ index , Tokens $ tokens ) { if ( $ tokens [ $ index ] -> equals ( '}' ) ) { return $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; } if ( $ tokens [ $ index ] -> equals ( ')' ) ) { $ startIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ startIndex = $ tokens -> getPrevMeaningfulToken ( $ startIndex ) ; if ( ! $ tokens [ $ startIndex ] -> isGivenKind ( [ T_ARRAY , CT :: T_ARRAY_SQUARE_BRACE_OPEN ] ) ) { return $ startIndex ; } } return $ index ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = \ count ( $ tokens ) - 1 ; $ index > 0 ; -- $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_UNSET_CAST ) ) { $ this -> fixUnsetCast ( $ tokens , $ index ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isCast ( ) ) { continue ; } $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , strtr ( $ token -> getContent ( ) , self :: INSIDE_CAST_SPACE_REPLACE_MAP ) , ] ) ; if ( 'single' === $ this -> configuration [ 'space' ] ) { 
public function isType ( $ types ) { if ( ! \ is_array ( $ types ) ) { $ types = [ $ types ] ; } return \ in_array ( $ this -> getType ( ) , $ types , true ) ; } 
protected function injectAlignmentPlaceholders ( Tokens $ tokens , $ startAt , $ endAt ) { for ( $ index = $ startAt ; $ index < $ endAt ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> equals ( '=' ) ) { $ tokens [ $ index ] = new Token ( sprintf ( self :: ALIGNABLE_PLACEHOLDER , $ this -> deepestLevel ) . $ token -> getContent ( ) ) ; continue ; } if ( $ token -> isGivenKind ( T_FUNCTION ) ) { ++ $ this -> deepestLevel ; continue ; } if ( $ token -> equals ( '(' ) ) { $ index = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( '[' ) ) { $ index = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_INDEX_SQUARE_BRACE , $ index ) ; continue ; } if ( $ token -> isGivenKind ( CT :: T_ARRAY_SQUARE_BRACE_OPEN ) ) { $ index = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ index ) ; continue ; } } } 
protected function isSuperfluousElse ( Tokens $ tokens , $ index ) { $ previousBlockStart = $ index ; do { 
private function getPreviousBlock ( Tokens $ tokens , $ index ) { $ close = $ previous = $ tokens -> getPrevMeaningfulToken ( $ index ) ; 
private function isInConditional ( Tokens $ tokens , $ index , $ lowerLimitIndex ) { $ candidateIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' , ';' , ':' ] ) ; if ( $ tokens [ $ candidateIndex ] -> equals ( ':' ) ) { return true ; } if ( ! $ tokens [ $ candidateIndex ] -> equals ( ')' ) ) { return false ; 
private function isInConditionWithoutBraces ( Tokens $ tokens , $ index , $ lowerLimitIndex ) { do { if ( $ tokens [ $ index ] -> isComment ( ) || $ tokens [ $ index ] -> isWhitespace ( ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_IF , T_ELSEIF , T_ELSE ] ) ) { return true ; } if ( $ token -> equals ( ';' , '}' ) ) { return false ; } if ( $ token -> equals ( '{' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; 
private function createProcessForFile ( $ path ) { 
private function createProcessForSource ( $ source ) { if ( null === $ this -> temporaryFile ) { $ this -> temporaryFile = tempnam ( '.' , 'cs_fixer_tmp_' ) ; $ this -> fileRemoval -> observe ( $ this -> temporaryFile ) ; } if ( false === @ file_put_contents ( $ this -> temporaryFile , $ source ) ) { throw new IOException ( sprintf ( 'Failed to write file "%s".' , $ this -> temporaryFile ) , 0 , null , $ this -> temporaryFile ) ; } return $ this -> createProcessForFile ( $ this -> temporaryFile ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ isNamespaceFound = false ; $ classyIndex = 0 ; $ classyName = null ; foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isGivenKind ( T_NAMESPACE ) ) { if ( $ isNamespaceFound ) { return ; } $ isNamespaceFound = true ; } elseif ( $ token -> isClassy ( ) ) { $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ prevToken -> isGivenKind ( T_NEW ) ) { continue ; } if ( null !== $ classyName ) { return ; } $ classyIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ classyName = $ tokens [ $ classyIndex ] -> getContent ( ) ; } } if ( null === $ classyName ) { return ; } if ( $ isNamespaceFound ) { $ filename = basename ( str_replace ( '\\' , '/' , $ file -> getRealPath ( ) ) , '.php' ) ; if ( $ classyName !== $ filename ) { $ tokens [ $ classyIndex ] = new Token ( [ T_STRING , $ filename ] ) ; } } else { $ normClass = str_replace ( '_' , '/' , $ classyName ) ; $ filename = substr ( str_replace ( '\\' , '/' , $ file -> getRealPath ( ) ) , - \ strlen ( $ normClass ) - 4 , - 4 ) ; if ( $ normClass !== $ filename && strtolower ( $ normClass ) === strtolower ( $ filename ) ) { $ tokens [ $ classyIndex ] = new Token ( [ T_STRING , str_replace ( '/' , '_' , $ filename ) ] ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; foreach ( $ tokensAnalyzer -> getClassyElements ( ) as $ index => $ element ) { if ( 'method' === $ element [ 'type' ] ) { $ this -> fixMethod ( $ tokens , $ index ) ; } } } 
protected function createConfigurationDefinition ( ) { $ default = [ 'this' => '$this' , '@this' => '$this' , '$self' => 'self' , '@self' => 'self' , '$static' => 'static' , '@static' => 'static' , ] ; return new FixerConfigurationResolverRootless ( 'replacements' , [ ( new FixerOptionBuilder ( 'replacements' , 'Mapping between replaced return types with new ones.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setNormalizer ( static function ( Options $ options , $ value ) use ( $ default ) { $ normalizedValue = [ ] ; foreach ( $ value as $ from => $ to ) { if ( \ is_string ( $ from ) ) { $ from = strtolower ( $ from ) ; } if ( ! isset ( $ default [ $ from ] ) ) { throw new InvalidOptionsException ( sprintf ( 'Unknown key "%s", expected any of "%s".' , \ is_object ( $ from ) ? \ get_class ( $ from ) : \ gettype ( $ from ) . ( \ is_resource ( $ from ) ? '' : '#' . $ from ) , implode ( '", "' , array_keys ( $ default ) ) ) ) ; } if ( ! \ in_array ( $ to , self :: $ toTypes , true ) ) { throw new InvalidOptionsException ( sprintf ( 'Unknown value "%s", expected any of "%s".' , \ is_object ( $ to ) ? \ get_class ( $ to ) : \ gettype ( $ to ) . ( \ is_resource ( $ to ) ? '' : '#' . $ to ) , implode ( '", "' , self :: $ toTypes ) ) ) ; } $ normalizedValue [ $ from ] = $ to ; } return $ normalizedValue ; } ) -> setDefault ( $ default ) -> getOption ( ) , ] , $ this -> getName ( ) ) ; } 
public function generate ( ReportSummary $ reportSummary ) { if ( ! \ extension_loaded ( 'dom' ) ) { throw new \ RuntimeException ( 'Cannot generate report! `ext-dom` is not available!' ) ; } $ dom = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ checkstyles = $ dom -> appendChild ( $ dom -> createElement ( 'checkstyle' ) ) ; foreach ( $ reportSummary -> getChanged ( ) as $ filePath => $ fixResult ) { $ file = $ checkstyles -> appendChild ( $ dom -> createElement ( 'file' ) ) ; $ file -> setAttribute ( 'name' , $ filePath ) ; foreach ( $ fixResult [ 'appliedFixers' ] as $ appliedFixer ) { $ error = $ this -> createError ( $ dom , $ appliedFixer ) ; $ file -> appendChild ( $ error ) ; } } $ dom -> formatOutput = true ; return $ reportSummary -> isDecoratedOutput ( ) ? OutputFormatter :: escape ( $ dom -> saveXML ( ) ) : $ dom -> saveXML ( ) ; } 
private function createError ( \ DOMDocument $ dom , $ appliedFixer ) { $ error = $ dom -> createElement ( 'error' ) ; $ error -> setAttribute ( 'severity' , 'warning' ) ; $ error -> setAttribute ( 'source' , 'PHP-CS-Fixer.' . $ appliedFixer ) ; $ error -> setAttribute ( 'message' , 'Found violation(s) of type: ' . $ appliedFixer ) ; return $ error ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ searchFor = array_keys ( $ this -> configuration [ 'replacements' ] ) ; foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ doc = new DocBlock ( $ token -> getContent ( ) ) ; $ annotations = $ doc -> getAnnotationsOfType ( $ searchFor ) ; if ( empty ( $ annotations ) ) { continue ; } foreach ( $ annotations as $ annotation ) { $ annotation -> getTag ( ) -> setName ( $ this -> configuration [ 'replacements' ] [ $ annotation -> getTag ( ) -> getName ( ) ] ) ; } $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , $ doc -> getContent ( ) ] ) ; } } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolverRootless ( 'replacements' , [ ( new FixerOptionBuilder ( 'replacements' , 'Mapping between replaced annotations with new ones.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setNormalizer ( static function ( Options $ options , $ value ) { $ normalizedValue = [ ] ; foreach ( $ value as $ from => $ to ) { if ( ! \ is_string ( $ from ) ) { throw new InvalidOptionsException ( 'Tag to replace must be a string.' ) ; } if ( ! \ is_string ( $ to ) ) { throw new InvalidOptionsException ( sprintf ( 'Tag to replace to from "%s" must be a string.' , $ from ) ) ; } if ( 1 !== Preg :: match ( '#^\S+$#' , $ to ) || false !== strpos ( $ to , '*/' ) ) { throw new InvalidOptionsException ( sprintf ( 'Tag "%s" cannot be replaced by invalid tag "%s".' , $ from , $ to ) ) ; } $ normalizedValue [ trim ( $ from ) ] = trim ( $ to ) ; } foreach ( $ normalizedValue as $ from => $ to ) { if ( isset ( $ normalizedValue [ $ to ] ) ) { throw new InvalidOptionsException ( sprintf ( 'Cannot change tag "%1$s" to tag "%2$s", as the tag "%2$s" is configured to be replaced to "%3$s".' , $ from , $ to , $ normalizedValue [ $ to ] ) ) ; } } return $ normalizedValue ; } ) -> setDefault ( [ 'property-read' => 'property' , 'property-write' => 'property' , 'type' => 'var' , 'link' => 'see' , ] ) -> getOption ( ) , ] , $ this -> getName ( ) ) ; } 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( ! $ token -> equals ( ':' ) ) { return ; } $ endIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( ! $ tokens [ $ endIndex ] -> equals ( ')' ) ) { return ; } $ startIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ endIndex ) ; $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ startIndex ) ; $ prevToken = $ tokens [ $ prevIndex ] ; 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> candidateTokenKind = 'long' === $ this -> configuration [ 'syntax' ] ? CT :: T_DESTRUCTURING_SQUARE_BRACE_OPEN : T_LIST ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; 0 <= $ index ; -- $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( $ this -> candidateTokenKind ) ) { if ( T_LIST === $ this -> candidateTokenKind ) { $ this -> fixToShortSyntax ( $ tokens , $ index ) ; } else { $ this -> fixToLongSyntax ( $ tokens , $ index ) ; } } } } 
public function format ( $ diff , $ lineTemplate = '%s' ) { $ isDecorated = $ this -> isDecoratedOutput ; $ template = $ isDecorated ? $ this -> template : Preg :: replace ( '/<[^<>]+>/' , '' , $ this -> template ) ; return sprintf ( $ template , implode ( PHP_EOL , array_map ( static function ( $ line ) use ( $ isDecorated , $ lineTemplate ) { if ( $ isDecorated ) { $ count = 0 ; $ line = Preg :: replaceCallback ( [ '/^(\+.*)/' , '/^(\-.*)/' , '/^(@.*)/' , ] , function ( $ matches ) { if ( '+' === $ matches [ 0 ] [ 0 ] ) { $ colour = 'green' ; } elseif ( '-' === $ matches [ 0 ] [ 0 ] ) { $ colour = 'red' ; } else { $ colour = 'cyan' ; } return sprintf ( '<fg=%s>%s</fg=%s>' , $ colour , OutputFormatter :: escape ( $ matches [ 0 ] ) , $ colour ) ; } , $ line , 1 , $ count ) ; if ( 0 === $ count ) { $ line = OutputFormatter :: escape ( $ line ) ; } } return sprintf ( $ lineTemplate , $ line ) ; } , Preg :: split ( '#\R#u' , $ diff ) ) ) ) ; } 
public static function getHelpCopy ( ) { $ template = <<<'EOF' The <info>%command.name%</info> command tries to fix as much coding standards problems as possible on a given file or files in a given directory and its subdirectories: <info>$ php %command.full_name% /path/to/dir</info> <info>$ php %command.full_name% /path/to/file</info> By default <comment>--path-mode</comment> is set to ``override``, which means, that if you specify the path to a file or a directory via command arguments, then the paths provided to a ``Finder`` in config file will be ignored. You can use <comment>--path-mode=intersection</comment> to merge paths from the config file and from the argument: <info>$ php %command.full_name% --path-mode=intersection /path/to/dir</info> The <comment>--format</comment> option for the output format. Supported formats are ``txt`` (default one), ``json``, ``xml``, ``checkstyle`` and ``junit``. NOTE: the output for the following formats are generated in accordance with XML schemas * ``junit`` follows the `JUnit xml schema from Jenkins </doc/junit-10.xsd>`_ * ``checkstyle`` follows the common `"checkstyle" xml schema </doc/checkstyle.xsd>`_ The <comment>--verbose</comment> option will show the applied rules. When using the ``txt`` format it will also displays progress notifications. The <comment>--rules</comment> option limits the rules to apply on the project: <info>$ php %command.full_name% /path/to/project --rules=@PSR2</info> By default the PSR1 and PSR2 rules are used. The <comment>--rules</comment> option lets you choose the exact rules to apply (the rule names must be separated by a comma): <info>$ php %command.full_name% /path/to/dir --rules=line_ending,full_opening_tag,indentation_type</info> You can also blacklist the rules you don't want by placing a dash in front of the rule name, if this is more convenient, using <comment>-name_of_fixer</comment>: <info>$ php %command.full_name% /path/to/dir --rules=-full_opening_tag,-indentation_type</info> When using combinations of exact and blacklist rules, applying exact rules along with above blacklisted results: <info>$ php %command.full_name% /path/to/project --rules=@Symfony,-@PSR1,-blank_line_before_statement,strict_comparison</info> Complete configuration for rules can be supplied using a ``json`` formatted string. <info>$ php %command.full_name% /path/to/project --rules='{"concat_space": {"spacing": "none"}}'</info> The <comment>--dry-run</comment> flag will run the fixer without making changes to your files. The <comment>--diff</comment> flag can be used to let the fixer output all the changes it makes. The <comment>--diff-format</comment> option allows to specify in which format the fixer should output the changes it makes: * <comment>udiff</comment>: unified diff format; * <comment>sbd</comment>: Sebastianbergmann/diff format (default when using `--diff` without specifying `diff-format`). The <comment>--allow-risky</comment> option (pass ``yes`` or ``no``) allows you to set whether risky rules may run. Default value is taken from config file. Risky rule is a rule, which could change code behaviour. By default no risky rules are run. The <comment>--stop-on-violation</comment> flag stops the execution upon first file that needs to be fixed. The <comment>--show-progress</comment> option allows you to choose the way process progress is rendered: * <comment>none</comment>: disables progress output; * <comment>run-in</comment>: [deprecated] simple single-line progress output; * <comment>estimating</comment>: [deprecated] multiline progress output with number of files and percentage on each line. Note that with this option, the files list is evaluated before processing to get the total number of files and then kept in memory to avoid using the file iterator twice. This has an impact on memory usage so using this option is not recommended on very large projects; * <comment>estimating-max</comment>: [deprecated] same as <comment>dots</comment>; * <comment>dots</comment>: same as <comment>estimating</comment> but using all terminal columns instead of default 80. If the option is not provided, it defaults to <comment>run-in</comment> unless a config file that disables output is used, in which case it defaults to <comment>none</comment>. This option has no effect if the verbosity of the command is less than <comment>verbose</comment>. <info>$ php %command.full_name% --verbose --show-progress=estimating</info> The command can also read from standard input, in which case it won't automatically fix anything: <info>$ cat foo.php | php %command.full_name% --diff -</info> Finally, if you don't need BC kept on CLI level, you might use `PHP_CS_FIXER_FUTURE_MODE` to start using options that would be default in next MAJOR release (unified differ, estimating, full-width progress indicator): <info>$ PHP_CS_FIXER_FUTURE_MODE=1 php %command.full_name% -v --diff</info> Choose from the list of available rules: %%%FIXERS_DETAILS%%% The <comment>--dry-run</comment> option displays the files that need to be fixed but without actually modifying them: <info>$ php %command.full_name% /path/to/code --dry-run</info> Config file ----------- Instead of using command line options to customize the rule, you can save the project configuration in a <comment>.php_cs.dist</comment> file in the root directory of your project. The file must return an instance of `PhpCsFixer\ConfigInterface` (<url>%%%CONFIG_INTERFACE_URL%%%</url>) which lets you configure the rules, the files and directories that need to be analyzed. You may also create <comment>.php_cs</comment> file, which is the local configuration that will be used instead of the project configuration. It is a good practice to add that file into your <comment>.gitignore</comment> file. With the <comment>--config</comment> option you can specify the path to the <comment>.php_cs</comment> file. The example below will add two rules to the default list of PSR2 set rules: <?php $finder = PhpCsFixer\Finder::create() ->exclude('somedir') ->notPath('src/Symfony/Component/Translation/Tests/fixtures/resources.php') ->in(__DIR__) ; return PhpCsFixer\Config::create() ->setRules([ '@PSR2' => true, 'strict_param' => true, 'array_syntax' => ['syntax' => 'short'], ]) ->setFinder($finder) ; ?> **NOTE**: ``exclude`` will work only for directories, so if you need to exclude file, try ``notPath``. See `Symfony\Finder` (<url>https://symfony.com/doc/current/components/finder.html</url>) online documentation for other `Finder` methods. You may also use a blacklist for the rules instead of the above shown whitelist approach. The following example shows how to use all ``Symfony`` rules but the ``full_opening_tag`` rule. <?php $finder = PhpCsFixer\Finder::create() ->exclude('somedir') ->in(__DIR__) ; return PhpCsFixer\Config::create() ->setRules([ '@Symfony' => true, 'full_opening_tag' => false, ]) ->setFinder($finder) ; ?> You may want to use non-linux whitespaces in your project. Then you need to configure them in your config file. <?php return PhpCsFixer\Config::create() ->setIndent("\t") ->setLineEnding("\r\n") ; ?> By using ``--using-cache`` option with ``yes`` or ``no`` you can set if the caching mechanism should be used. Caching ------- The caching mechanism is enabled by default. This will speed up further runs by fixing only files that were modified since the last run. The tool will fix all files if the tool version has changed or the list of rules has changed. Cache is supported only for tool downloaded as phar file or installed via composer. Cache can be disabled via ``--using-cache`` option or config file: <?php return PhpCsFixer\Config::create() ->setUsingCache(false) ; ?> Cache file can be specified via ``--cache-file`` option or config file: <?php return PhpCsFixer\Config::create() ->setCacheFile(__DIR__.'/.php_cs.cache') ; ?> Using PHP CS Fixer on CI ------------------------ Require ``friendsofphp/php-cs-fixer`` as a ``dev`` dependency: $ ./composer.phar require --dev friendsofphp/php-cs-fixer Then, add the following command to your CI: %%%CI_INTEGRATION%%% Where ``$COMMIT_RANGE`` is your range of commits, e.g. ``$TRAVIS_COMMIT_RANGE`` or ``HEAD~..HEAD``. Exit code --------- Exit code is built using following bit flags: * 0 - OK. * 1 - General error (or PHP minimal requirement not matched). * 4 - Some files have invalid syntax (only in dry-run mode). * 8 - Some files need fixing (only in dry-run mode). * 16 - Configuration error of the application. * 32 - Configuration error of a Fixer. * 64 - Exception raised within the application. (Applies to exit code of the `fix` command only) EOF ; return strtr ( $ template , [ '%%%CONFIG_INTERFACE_URL%%%' => sprintf ( 'https: 
public static function toString ( $ value ) { if ( \ is_array ( $ value ) ) { 
public static function getDisplayableAllowedValues ( FixerOptionInterface $ option ) { $ allowed = $ option -> getAllowedValues ( ) ; if ( null !== $ allowed ) { $ allowed = array_filter ( $ allowed , static function ( $ value ) { return ! ( $ value instanceof \ Closure ) ; } ) ; usort ( $ allowed , static function ( $ valueA , $ valueB ) { if ( $ valueA instanceof AllowedValueSubset ) { return - 1 ; } if ( $ valueB instanceof AllowedValueSubset ) { return 1 ; } return strcasecmp ( self :: toString ( $ valueA ) , self :: toString ( $ valueB ) ) ; } ) ; if ( 0 === \ count ( $ allowed ) ) { $ allowed = null ; } } return $ allowed ; } 
private static function wordwrap ( $ string , $ width ) { $ result = [ ] ; $ currentLine = 0 ; $ lineLength = 0 ; foreach ( explode ( ' ' , $ string ) as $ word ) { $ wordLength = \ strlen ( Preg :: replace ( '~</?(\w+)>~' , '' , $ word ) ) ; if ( 0 !== $ lineLength ) { ++ $ wordLength ; 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( array_merge ( parent :: createConfigurationDefinition ( ) -> getOptions ( ) , [ ( new FixerOptionBuilder ( 'syntax' , 'Whether to add or remove braces.' ) ) -> setAllowedValues ( [ 'with_braces' , 'without_braces' ] ) -> setDefault ( 'without_braces' ) -> getOption ( ) , ] ) ) ; } 
protected function fixAnnotations ( Tokens $ tokens ) { if ( 'without_braces' === $ this -> configuration [ 'syntax' ] ) { $ this -> removesBracesFromAnnotations ( $ tokens ) ; } else { $ this -> addBracesToAnnotations ( $ tokens ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; $ index >= 0 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_FUNCTION ) ) { continue ; } $ startParenthesisIndex = $ tokens -> getNextTokenOfKind ( $ index , [ '(' , ';' , [ T_CLOSE_TAG ] ] ) ; if ( ! $ tokens [ $ startParenthesisIndex ] -> equals ( '(' ) ) { continue ; } $ endParenthesisIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startParenthesisIndex ) ; for ( $ iter = $ endParenthesisIndex - 1 ; $ iter > $ startParenthesisIndex ; -- $ iter ) { if ( ! $ tokens [ $ iter ] -> isGivenKind ( T_VARIABLE ) ) { continue ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( [ T_VARIABLE , T_STRING ] ) ) { continue ; } $ replaced = Preg :: replaceCallback ( '/[^[:ascii:]]/u' , static function ( $ matches ) { return isset ( self :: $ replacements [ $ matches [ 0 ] ] ) ? self :: $ replacements [ $ matches [ 0 ] ] : $ matches [ 0 ] ; } , $ token -> getContent ( ) , - 1 , $ count ) ; if ( $ count ) { $ tokens -> offsetSet ( $ index , new Token ( [ $ token -> getId ( ) , $ replaced ] ) ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = 0 , $ c = $ tokens -> count ( ) ; $ index < $ c ; ++ $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( [ T_ARRAY , CT :: T_ARRAY_SQUARE_BRACE_OPEN ] ) ) { self :: fixArray ( $ tokens , $ index ) ; } } } 
private static function fixArray ( Tokens $ tokens , $ index ) { $ startIndex = $ index ; if ( $ tokens [ $ startIndex ] -> isGivenKind ( T_ARRAY ) ) { $ startIndex = $ tokens -> getNextMeaningfulToken ( $ startIndex ) ; $ endIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startIndex ) ; } else { $ endIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ startIndex ) ; } $ nextIndex = $ startIndex + 1 ; $ nextToken = $ tokens [ $ nextIndex ] ; $ nextNonWhitespaceIndex = $ tokens -> getNextNonWhitespace ( $ startIndex ) ; $ nextNonWhitespaceToken = $ tokens [ $ nextNonWhitespaceIndex ] ; $ tokenAfterNextNonWhitespaceToken = $ tokens [ $ nextNonWhitespaceIndex + 1 ] ; $ prevIndex = $ endIndex - 1 ; $ prevToken = $ tokens [ $ prevIndex ] ; $ prevNonWhitespaceIndex = $ tokens -> getPrevNonWhitespace ( $ endIndex ) ; $ prevNonWhitespaceToken = $ tokens [ $ prevNonWhitespaceIndex ] ; if ( $ nextToken -> isWhitespace ( " \t" ) && ( ! $ nextNonWhitespaceToken -> isComment ( ) || $ nextNonWhitespaceIndex === $ prevNonWhitespaceIndex || $ tokenAfterNextNonWhitespaceToken -> isWhitespace ( " \t" ) || '/*' === substr ( $ nextNonWhitespaceToken -> getContent ( ) , 0 , 2 ) ) ) { $ tokens -> clearAt ( $ nextIndex ) ; } if ( $ prevToken -> isWhitespace ( " \t" ) && ! $ prevNonWhitespaceToken -> equals ( ',' ) ) { $ tokens -> clearAt ( $ prevIndex ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { static $ typehintKinds = [ CT :: T_ARRAY_TYPEHINT , T_CALLABLE , T_NS_SEPARATOR , T_STRING , ] ; for ( $ index = $ tokens -> count ( ) - 1 ; $ index >= 0 ; -- $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( CT :: T_NULLABLE_TYPE ) ) { continue ; } 
public function supports ( \ SplFileInfo $ file ) { if ( $ file instanceof StdinFileInfo ) { return false ; } $ filenameParts = explode ( '.' , $ file -> getBasename ( ) , 2 ) ; if ( 
protected function configure ( ) { $ this -> setName ( self :: COMMAND_NAME ) -> setDefinition ( [ new InputArgument ( 'path' , InputArgument :: IS_ARRAY , 'The path.' ) , new InputOption ( 'path-mode' , '' , InputOption :: VALUE_REQUIRED , 'Specify path mode (can be override or intersection).' , 'override' ) , new InputOption ( 'allow-risky' , '' , InputOption :: VALUE_REQUIRED , 'Are risky fixers allowed (can be yes or no).' ) , new InputOption ( 'config' , '' , InputOption :: VALUE_REQUIRED , 'The path to a .php_cs file.' ) , new InputOption ( 'dry-run' , '' , InputOption :: VALUE_NONE , 'Only shows which files would have been modified.' ) , new InputOption ( 'rules' , '' , InputOption :: VALUE_REQUIRED , 'The rules.' ) , new InputOption ( 'using-cache' , '' , InputOption :: VALUE_REQUIRED , 'Does cache should be used (can be yes or no).' ) , new InputOption ( 'cache-file' , '' , InputOption :: VALUE_REQUIRED , 'The path to the cache file.' ) , new InputOption ( 'diff' , '' , InputOption :: VALUE_NONE , 'Also produce diff for each file.' ) , new InputOption ( 'diff-format' , '' , InputOption :: VALUE_REQUIRED , 'Specify diff format.' ) , new InputOption ( 'format' , '' , InputOption :: VALUE_REQUIRED , 'To output results in other formats.' ) , new InputOption ( 'stop-on-violation' , '' , InputOption :: VALUE_NONE , 'Stop execution on first violation.' ) , new InputOption ( 'show-progress' , '' , InputOption :: VALUE_REQUIRED , 'Type of progress indicator (none, run-in, estimating, estimating-max or dots).' ) , ] ) -> setDescription ( 'Fixes a directory or a file.' ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ verbosity = $ output -> getVerbosity ( ) ; $ passedConfig = $ input -> getOption ( 'config' ) ; $ passedRules = $ input -> getOption ( 'rules' ) ; $ resolver = new ConfigurationResolver ( $ this -> defaultConfig , [ 'allow-risky' => $ input -> getOption ( 'allow-risky' ) , 'config' => $ passedConfig , 'dry-run' => $ input -> getOption ( 'dry-run' ) , 'rules' => $ passedRules , 'path' => $ input -> getArgument ( 'path' ) , 'path-mode' => $ input -> getOption ( 'path-mode' ) , 'using-cache' => $ input -> getOption ( 'using-cache' ) , 'cache-file' => $ input -> getOption ( 'cache-file' ) , 'format' => $ input -> getOption ( 'format' ) , 'diff' => $ input -> getOption ( 'diff' ) , 'diff-format' => $ input -> getOption ( 'diff-format' ) , 'stop-on-violation' => $ input -> getOption ( 'stop-on-violation' ) , 'verbosity' => $ verbosity , 'show-progress' => $ input -> getOption ( 'show-progress' ) , ] , getcwd ( ) , $ this -> toolInfo ) ; $ reporter = $ resolver -> getReporter ( ) ; $ stdErr = $ output instanceof ConsoleOutputInterface ? $ output -> getErrorOutput ( ) : ( 'txt' === $ reporter -> getFormat ( ) ? $ output : null ) ; if ( null !== $ stdErr ) { if ( null !== $ passedConfig && null !== $ passedRules ) { if ( getenv ( 'PHP_CS_FIXER_FUTURE_MODE' ) ) { throw new \ RuntimeException ( 'Passing both `config` and `rules` options is not possible. This check was performed as `PHP_CS_FIXER_FUTURE_MODE` env var is set.' ) ; } $ stdErr -> writeln ( [ sprintf ( $ stdErr -> isDecorated ( ) ? '<bg=yellow;fg=black;>%s</>' : '%s' , 'When passing both "--config" and "--rules" the rules within the configuration file are not used.' ) , sprintf ( $ stdErr -> isDecorated ( ) ? '<bg=yellow;fg=black;>%s</>' : '%s' , 'Passing both options is deprecated; version v3.0 PHP-CS-Fixer will exit with a configuration error code.' ) , ] ) ; } $ configFile = $ resolver -> getConfigFile ( ) ; $ stdErr -> writeln ( sprintf ( 'Loaded config <comment>%s</comment>%s.' , $ resolver -> getConfig ( ) -> getName ( ) , null === $ configFile ? '' : ' from "' . $ configFile . '"' ) ) ; if ( $ resolver -> getUsingCache ( ) ) { $ cacheFile = $ resolver -> getCacheFile ( ) ; if ( is_file ( $ cacheFile ) ) { $ stdErr -> writeln ( sprintf ( 'Using cache file "%s".' , $ cacheFile ) ) ; } } } $ progressType = $ resolver -> getProgress ( ) ; $ finder = $ resolver -> getFinder ( ) ; if ( null !== $ stdErr && $ resolver -> configFinderIsOverridden ( ) ) { $ stdErr -> writeln ( sprintf ( $ stdErr -> isDecorated ( ) ? '<bg=yellow;fg=black;>%s</>' : '%s' , 'Paths from configuration file have been overridden by paths provided as command arguments.' ) ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ content = $ token -> getContent ( ) ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ doc = new DocBlock ( $ token -> getContent ( ) ) ; $ end = ( new ShortDescription ( $ doc ) ) -> getEnd ( ) ; if ( null !== $ end ) { $ line = $ doc -> getLine ( $ end ) ; $ content = rtrim ( $ line -> getContent ( ) ) ; if ( ! $ this -> isCorrectlyFormatted ( $ content ) ) { $ line -> setContent ( $ content . '.' . $ this -> whitespacesConfig -> getLineEnding ( ) ) ; $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , $ doc -> getContent ( ) ] ) ; } } } } 
public function isCandidate ( Tokens $ tokens ) { $ types = [ ] ; foreach ( self :: $ loops as $ loop ) { $ types [ ] = ( array ) $ loop [ 'lookupTokens' ] ; } $ types = array_merge ( ... $ types ) ; return $ tokens -> isAnyTokenKindsFound ( $ types ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( $ token -> equals ( '&' ) && $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_FUNCTION ) ) { $ tokens [ $ index ] = new Token ( [ CT :: T_RETURN_REF , '&' ] ) ; } } 
public function getAnnotations ( ) { if ( null === $ this -> annotations ) { $ this -> annotations = [ ] ; $ total = \ count ( $ this -> lines ) ; for ( $ index = 0 ; $ index < $ total ; ++ $ index ) { if ( $ this -> lines [ $ index ] -> containsATag ( ) ) { 
public function getAnnotation ( $ pos ) { $ annotations = $ this -> getAnnotations ( ) ; if ( isset ( $ annotations [ $ pos ] ) ) { return $ annotations [ $ pos ] ; } } 
public function getAnnotationsOfType ( $ types ) { $ annotations = [ ] ; $ types = ( array ) $ types ; foreach ( $ this -> getAnnotations ( ) as $ annotation ) { $ tag = $ annotation -> getTag ( ) -> getName ( ) ; foreach ( $ types as $ type ) { if ( $ type === $ tag ) { $ annotations [ ] = $ annotation ; } } } return $ annotations ; } 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( ! $ token -> equalsAny ( [ [ T_CLASS , 'class' ] , [ T_STRING , 'class' ] , ] , false ) ) { return ; } $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; $ prevToken = $ tokens [ $ prevIndex ] ; if ( $ prevToken -> isGivenKind ( T_DOUBLE_COLON ) ) { $ tokens [ $ index ] = new Token ( [ CT :: T_CLASS_CONSTANT , $ token -> getContent ( ) ] ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_START_HEREDOC ) || false !== strpos ( $ token -> getContent ( ) , "'" ) ) { continue ; } if ( $ tokens [ $ index + 1 ] -> isGivenKind ( T_END_HEREDOC ) ) { $ tokens [ $ index ] = $ this -> convertToNowdoc ( $ token ) ; continue ; } if ( ! $ tokens [ $ index + 1 ] -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) || ! $ tokens [ $ index + 2 ] -> isGivenKind ( T_END_HEREDOC ) ) { continue ; } $ content = $ tokens [ $ index + 1 ] -> getContent ( ) ; 
private function convertToNowdoc ( Token $ token ) { return new Token ( [ $ token -> getId ( ) , Preg :: replace ( '/^([Bb]?<<<)([ \t]*)"?([^\s"]+)"?/' , '$1$2\'$3\'' , $ token -> getContent ( ) ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ doc = new DocBlock ( $ token -> getContent ( ) ) ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isGivenKind ( CT :: T_ARRAY_INDEX_CURLY_BRACE_OPEN ) ) { $ tokens [ $ index ] = new Token ( '[' ) ; } elseif ( $ token -> isGivenKind ( CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ) ) { $ tokens [ $ index ] = new Token ( ']' ) ; } } } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> fixTokenMap = [ ] ; foreach ( $ this -> configuration [ 'statements' ] as $ key ) { $ this -> fixTokenMap [ $ key ] = self :: $ tokenMap [ $ key ] ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ tokenKinds = array_values ( $ this -> fixTokenMap ) ; $ analyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ index = 0 , $ limit = $ tokens -> count ( ) ; $ index < $ limit ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( $ tokenKinds ) || ( $ token -> isGivenKind ( T_WHILE ) && $ analyzer -> isWhilePartOfDoWhile ( $ index ) ) ) { continue ; } $ prevNonWhitespaceToken = $ tokens [ $ tokens -> getPrevNonWhitespace ( $ index ) ] ; if ( ! $ prevNonWhitespaceToken -> equalsAny ( [ ';' , '}' ] ) ) { continue ; } $ prevIndex = $ index - 1 ; $ prevToken = $ tokens [ $ prevIndex ] ; if ( $ prevToken -> isWhitespace ( ) ) { $ countParts = substr_count ( $ prevToken -> getContent ( ) , "\n" ) ; if ( 0 === $ countParts ) { $ tokens [ $ prevIndex ] = new Token ( [ T_WHITESPACE , rtrim ( $ prevToken -> getContent ( ) , " \t" ) . $ lineEnding . $ lineEnding ] ) ; } elseif ( 1 === $ countParts ) { $ tokens [ $ prevIndex ] = new Token ( [ T_WHITESPACE , $ lineEnding . $ prevToken -> getContent ( ) ] ) ; } } else { $ tokens -> insertAt ( $ index , new Token ( [ T_WHITESPACE , $ lineEnding . $ lineEnding ] ) ) ; ++ $ index ; ++ $ limit ; } } } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'statements' , 'List of statements which must be preceded by an empty line.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ new AllowedValueSubset ( array_keys ( self :: $ tokenMap ) ) ] ) -> setDefault ( [ 'break' , 'continue' , 'declare' , 'return' , 'throw' , 'try' , ] ) -> getOption ( ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { static $ sequenceNeeded = [ [ T_STRING , 'is_null' ] , '(' ] ; $ functionsAnalyzer = new FunctionsAnalyzer ( ) ; $ currIndex = 0 ; while ( null !== $ currIndex ) { $ matches = $ tokens -> findSequence ( $ sequenceNeeded , $ currIndex , $ tokens -> count ( ) - 1 , false ) ; 
public function getDefinition ( ) { return new FixerDefinition ( 'Add leading `\` before function invocation to speed up resolving.' , [ new CodeSample ( '<?php function baz($options) { if (!array_key_exists("foo", $options)) { throw new \InvalidArgumentException(); } return json_encode($options); } ' ) , new CodeSample ( '<?php function baz($options) { if (!array_key_exists("foo", $options)) { throw new \InvalidArgumentException(); } return json_encode($options); } ' , [ 'exclude' => [ 'json_encode' , ] , ] ) , new CodeSample ( '<?php namespace space1 { echo count([1]); } namespace { echo count([1]); } ' , [ 'scope' => 'all' ] ) , new CodeSample ( '<?php namespace space1 { echo count([1]); } namespace { echo count([1]); } ' , [ 'scope' => 'namespaced' ] ) , new CodeSample ( '<?php myGlobalFunction(); count(); ' , [ 'include' => [ 'myGlobalFunction' ] ] ) , new CodeSample ( '<?php myGlobalFunction(); count(); ' , [ 'include' => [ '@all' ] ] ) , new CodeSample ( '<?php myGlobalFunction(); count(); ' , [ 'include' => [ '@internal' ] ] ) , new CodeSample ( '<?php $a .= str_repeat($a, 4); $c = get_class($d); ' , [ 'include' => [ '@compiler_optimized' ] ] ) , ] , null , 'Risky when any of the functions are overridden.' ) ; } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'exclude' , 'List of functions to ignore.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ static function ( array $ value ) { foreach ( $ value as $ functionName ) { if ( ! \ is_string ( $ functionName ) || '' === trim ( $ functionName ) || trim ( $ functionName ) !== $ functionName ) { throw new InvalidOptionsException ( sprintf ( 'Each element must be a non-empty, trimmed string, got "%s" instead.' , \ is_object ( $ functionName ) ? \ get_class ( $ functionName ) : \ gettype ( $ functionName ) ) ) ; } } return true ; } ] ) -> setDefault ( [ ] ) -> getOption ( ) , ( new FixerOptionBuilder ( 'include' , 'List of function names or sets to fix. Defined sets are `@internal` (all native functions), `@all` (all global functions) and `@compiler_optimized` (functions that are specially optimized by Zend).' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ static function ( array $ value ) { foreach ( $ value as $ functionName ) { if ( ! \ is_string ( $ functionName ) || '' === trim ( $ functionName ) || trim ( $ functionName ) !== $ functionName ) { throw new InvalidOptionsException ( sprintf ( 'Each element must be a non-empty, trimmed string, got "%s" instead.' , \ is_object ( $ functionName ) ? \ get_class ( $ functionName ) : \ gettype ( $ functionName ) ) ) ; } $ sets = [ self :: SET_ALL , self :: SET_INTERNAL , self :: SET_COMPILER_OPTIMIZED , ] ; if ( '@' === $ functionName [ 0 ] && ! \ in_array ( $ functionName , $ sets , true ) ) { throw new InvalidOptionsException ( sprintf ( 'Unknown set "%s", known sets are "%s".' , $ functionName , implode ( '", "' , $ sets ) ) ) ; } } return true ; } ] ) -> setDefault ( [ self :: SET_INTERNAL ] ) -> getOption ( ) , ( new FixerOptionBuilder ( 'scope' , 'Only fix function calls that are made within a namespace or fix all.' ) ) -> setAllowedValues ( [ 'all' , 'namespaced' ] ) -> setDefault ( 'all' ) -> getOption ( ) , ( new FixerOptionBuilder ( 'strict' , 'Whether leading `\` of function call not meant to have it should be removed.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( false ) 
private function normalizeFunctionNames ( array $ functionNames ) { foreach ( $ functionNames as $ index => $ functionName ) { $ functionNames [ strtolower ( $ functionName ) ] = true ; unset ( $ functionNames [ $ index ] ) ; } return $ functionNames ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ index = $ tokens -> count ( ) - 1 ; $ index >= 0 ; -- $ index ) { if ( $ tokensAnalyzer -> isUnarySuccessorOperator ( $ index ) ) { if ( ! $ tokens [ $ tokens -> getPrevNonWhitespace ( $ index ) ] -> isComment ( ) ) { $ tokens -> removeLeadingWhitespace ( $ index ) ; } continue ; } if ( $ tokensAnalyzer -> isUnaryPredecessorOperator ( $ index ) ) { $ tokens -> removeTrailingWhitespace ( $ index ) ; continue ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; $ index >= 0 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_LIST ) ) { continue ; } $ openIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ closeIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ openIndex ) ; $ markIndex = null ; $ prevIndex = $ tokens -> getPrevNonWhitespace ( $ closeIndex ) ; while ( $ tokens [ $ prevIndex ] -> equals ( ',' ) ) { $ markIndex = $ prevIndex ; $ prevIndex = $ tokens -> getPrevNonWhitespace ( $ prevIndex ) ; } if ( null !== $ markIndex ) { $ tokens -> clearRange ( $ tokens -> getPrevNonWhitespace ( $ markIndex ) + 1 , $ closeIndex - 1 ) ; } } } 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( ! $ tokens [ $ index ] -> equals ( '(' ) || ! $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] -> equals ( [ T_NEW ] ) ) { return ; } if ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equalsAny ( [ ']' , [ CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ] , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ T_ARRAY ] , [ T_CLASS ] , [ T_ELSEIF ] , [ T_FOR ] , [ T_FOREACH ] , [ T_IF ] , [ T_STATIC ] , [ T_STRING ] , [ T_SWITCH ] , [ T_VARIABLE ] , [ T_WHILE ] , ] ) ) { return ; } $ closeIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ tokens [ $ index ] = new Token ( [ CT :: T_BRACE_CLASS_INSTANTIATION_OPEN , '(' ] ) ; $ tokens [ $ closeIndex ] = new Token ( [ CT :: T_BRACE_CLASS_INSTANTIATION_CLOSE , ')' ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { static $ map = [ T_IS_EQUAL => [ 'id' => T_IS_IDENTICAL , 'content' => '===' , ] , T_IS_NOT_EQUAL => [ 'id' => T_IS_NOT_IDENTICAL , 'content' => '!==' , ] , ] ; foreach ( $ tokens as $ index => $ token ) { $ tokenId = $ token -> getId ( ) ; if ( isset ( $ map [ $ tokenId ] ) ) { $ tokens [ $ index ] = new Token ( [ $ map [ $ tokenId ] [ 'id' ] , $ map [ $ tokenId ] [ 'content' ] ] ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = \ count ( $ tokens ) - 1 ; $ index > 1 ; -- $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_CLOSE_TAG ) ) { continue ; } $ prev = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ prev ] -> equalsAny ( [ ';' , '{' , '}' , ':' , [ T_OPEN_TAG ] ] ) ) { continue ; } $ tokens -> insertAt ( $ prev + 1 , new Token ( ';' ) ) ; } } 
public function checkFileValidity ( $ filename ) { try { $ phar = new \ Phar ( $ filename ) ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ this -> fixCommentBeforeBrace ( $ tokens ) ; $ this -> fixMissingControlBraces ( $ tokens ) ; $ this -> fixIndents ( $ tokens ) ; $ this -> fixControlContinuationBraces ( $ tokens ) ; $ this -> fixSpaceAroundToken ( $ tokens ) ; $ this -> fixDoWhile ( $ tokens ) ; } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'allow_single_line_closure' , 'Whether single line lambda notation should be allowed.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( false ) -> getOption ( ) , ( new FixerOptionBuilder ( 'position_after_functions_and_oop_constructs' , 'whether the opening brace should be placed on "next" or "same" line after classy constructs (non-anonymous classes, interfaces, traits, methods and non-lambda functions).' ) ) -> setAllowedValues ( [ self :: LINE_NEXT , self :: LINE_SAME ] ) -> setDefault ( self :: LINE_NEXT ) -> getOption ( ) , ( new FixerOptionBuilder ( 'position_after_control_structures' , 'whether the opening brace should be placed on "next" or "same" line after control structures.' ) ) -> setAllowedValues ( [ self :: LINE_NEXT , self :: LINE_SAME ] ) -> setDefault ( self :: LINE_SAME ) -> getOption ( ) , ( new FixerOptionBuilder ( 'position_after_anonymous_constructs' , 'whether the opening brace should be placed on "next" or "same" line after anonymous constructs (anonymous classes and lambda functions).' ) ) -> setAllowedValues ( [ self :: LINE_NEXT , self :: LINE_SAME ] ) -> setDefault ( self :: LINE_SAME ) -> getOption ( ) , ] ) ; } 
private function findParenthesisEnd ( Tokens $ tokens , $ structureTokenIndex ) { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ structureTokenIndex ) ; $ nextToken = $ tokens [ $ nextIndex ] ; 
private function findStatementEnd ( Tokens $ tokens , $ parenthesisEndIndex ) { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ parenthesisEndIndex ) ; $ nextToken = $ tokens [ $ nextIndex ] ; if ( ! $ nextToken ) { return $ parenthesisEndIndex ; } if ( $ nextToken -> equals ( '{' ) ) { return $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ nextIndex ) ; } if ( $ nextToken -> isGivenKind ( $ this -> getControlTokens ( ) ) ) { $ parenthesisEndIndex = $ this -> findParenthesisEnd ( $ tokens , $ nextIndex ) ; $ endIndex = $ this -> findStatementEnd ( $ tokens , $ parenthesisEndIndex ) ; if ( $ nextToken -> isGivenKind ( [ T_IF , T_TRY , T_DO ] ) ) { $ openingTokenKind = $ nextToken -> getId ( ) ; while ( true ) { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endIndex ) ; $ nextToken = isset ( $ nextIndex ) ? $ tokens [ $ nextIndex ] : null ; if ( $ nextToken && $ nextToken -> isGivenKind ( $ this -> getControlContinuationTokensForOpeningToken ( $ openingTokenKind ) ) ) { $ parenthesisEndIndex = $ this -> findParenthesisEnd ( $ tokens , $ nextIndex ) ; $ endIndex = $ this -> findStatementEnd ( $ tokens , $ parenthesisEndIndex ) ; if ( $ nextToken -> isGivenKind ( $ this -> getFinalControlContinuationTokensForOpeningToken ( $ openingTokenKind ) ) ) { return $ endIndex ; } } else { break ; } } } return $ endIndex ; } $ index = $ parenthesisEndIndex ; while ( true ) { $ token = $ tokens [ ++ $ index ] ; 
private function isMultilined ( Tokens $ tokens , $ startParenthesisIndex , $ endParenthesisIndex ) { for ( $ i = $ startParenthesisIndex ; $ i < $ endParenthesisIndex ; ++ $ i ) { if ( false !== strpos ( $ tokens [ $ i ] -> getContent ( ) , "\n" ) ) { return true ; } } return false ; } 
private function isCommentWithFixableIndentation ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) ) { return false ; } if ( 0 === strpos ( $ tokens [ $ index ] -> getContent ( ) , '/*' ) ) { return true ; } $ firstCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ firstCommentIndex , false ) ; if ( null === $ i ) { break ; } $ firstCommentIndex = $ i ; } $ lastCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ lastCommentIndex , true ) ; if ( null === $ i ) { break ; } $ lastCommentIndex = $ i ; } if ( $ firstCommentIndex === $ lastCommentIndex ) { return true ; } for ( $ i = $ firstCommentIndex + 1 ; $ i < $ lastCommentIndex ; ++ $ i ) { if ( ! $ tokens [ $ i ] -> isWhitespace ( ) && ! $ tokens [ $ i ] -> isComment ( ) ) { return false ; } } return true ; } 
private function getSiblingContinuousSingleLineComment ( Tokens $ tokens , $ index , $ after ) { $ siblingIndex = $ index ; do { if ( $ after ) { $ siblingIndex = $ tokens -> getNextTokenOfKind ( $ siblingIndex , [ [ T_COMMENT ] ] ) ; } else { $ siblingIndex = $ tokens -> getPrevTokenOfKind ( $ siblingIndex , [ [ T_COMMENT ] ] ) ; } if ( null === $ siblingIndex ) { return null ; } } while ( 0 === strpos ( $ tokens [ $ siblingIndex ] -> getContent ( ) , '/*' ) ) ; $ newLines = 0 ; for ( $ i = min ( $ siblingIndex , $ index ) + 1 , $ max = max ( $ siblingIndex , $ index ) ; $ i < $ max ; ++ $ i ) { if ( $ tokens [ $ i ] -> isWhitespace ( ) && Preg :: match ( '/\R/' , $ tokens [ $ i ] -> getContent ( ) ) ) { if ( 1 === $ newLines || Preg :: match ( '/\R.*\R/' , $ tokens [ $ i ] -> getContent ( ) ) ) { return null ; } ++ $ newLines ; } } return $ siblingIndex ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ end = \ count ( $ tokens ) - 3 ; 
private function skipClass ( Tokens $ tokens , $ classIndex , $ classOpenIndex , $ classCloseIndex ) { $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ classIndex ) ] ; if ( ! $ prevToken -> isGivenKind ( T_FINAL ) ) { return true ; } for ( $ index = $ classIndex ; $ index < $ classOpenIndex ; ++ $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_EXTENDS ) ) { return true ; } } $ useIndex = $ tokens -> getNextTokenOfKind ( $ classIndex , [ [ CT :: T_USE_TRAIT ] ] ) ; return $ useIndex && $ useIndex < $ classCloseIndex ; } 
protected function applyFix ( \ SplFileInfo $ file , PhpTokens $ phpTokens ) { 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'ignored_tags' , 'List of tags that must not be treated as Doctrine Annotations.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ static function ( $ values ) { foreach ( $ values as $ value ) { if ( ! \ is_string ( $ value ) ) { return false ; } } return true ; } ] ) -> setDefault ( [ 
private function nextElementAcceptsDoctrineAnnotations ( PhpTokens $ tokens , $ index ) { do { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( null === $ index ) { return false ; } } while ( $ tokens [ $ index ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL ] ) ) ; if ( $ tokens [ $ index ] -> isClassy ( ) ) { return true ; } while ( $ tokens [ $ index ] -> isGivenKind ( [ T_PUBLIC , T_PROTECTED , T_PRIVATE , T_FINAL , T_ABSTRACT ] ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; } return isset ( $ this -> classyElements [ $ index ] ) ; } 
public function getTags ( ) { $ url = 'https://api.github.com/repos/FriendsOfPHP/PHP-CS-Fixer/tags' ; $ result = @ file_get_contents ( $ url , false , stream_context_create ( [ 'http' => [ 'header' => 'User-Agent: FriendsOfPHP/PHP-CS-Fixer' , ] , ] ) ) ; if ( false === $ result ) { throw new \ RuntimeException ( sprintf ( 'Failed to load tags at "%s".' , $ url ) ) ; } $ result = json_decode ( $ result , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new \ RuntimeException ( sprintf ( 'Failed to read response from "%s" as JSON: %s.' , $ url , json_last_error_msg ( ) ) ) ; } return $ result ; } 
public static function fromJson ( $ json ) { $ data = json_decode ( $ json , true ) ; if ( null === $ data && JSON_ERROR_NONE !== json_last_error ( ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Value needs to be a valid JSON string, got "%s", error: "%s".' , \ is_object ( $ json ) ? \ get_class ( $ json ) : \ gettype ( $ json ) , json_last_error_msg ( ) ) ) ; } $ requiredKeys = [ 'php' , 'version' , 'indent' , 'lineEnding' , 'rules' , 'hashes' , ] ; $ missingKeys = array_diff_key ( array_flip ( $ requiredKeys ) , $ data ) ; if ( \ count ( $ missingKeys ) ) { throw new \ InvalidArgumentException ( sprintf ( 'JSON data is missing keys "%s"' , implode ( '", "' , $ missingKeys ) ) ) ; } $ signature = new Signature ( $ data [ 'php' ] , $ data [ 'version' ] , $ data [ 'indent' ] , $ data [ 'lineEnding' ] , $ data [ 'rules' ] ) ; $ cache = new self ( $ signature ) ; $ cache -> hashes = $ data [ 'hashes' ] ; return $ cache ; } 
public function generate ( ReportSummary $ reportSummary ) { $ jFiles = [ ] ; foreach ( $ reportSummary -> getChanged ( ) as $ file => $ fixResult ) { $ jfile = [ 'name' => $ file ] ; if ( $ reportSummary -> shouldAddAppliedFixers ( ) ) { $ jfile [ 'appliedFixers' ] = $ fixResult [ 'appliedFixers' ] ; } if ( ! empty ( $ fixResult [ 'diff' ] ) ) { $ jfile [ 'diff' ] = $ fixResult [ 'diff' ] ; } $ jFiles [ ] = $ jfile ; } $ json = [ 'files' => $ jFiles , ] ; if ( null !== $ reportSummary -> getTime ( ) ) { $ json [ 'time' ] = [ 'total' => round ( $ reportSummary -> getTime ( ) / 1000 , 3 ) , ] ; } if ( null !== $ reportSummary -> getMemory ( ) ) { $ json [ 'memory' ] = round ( $ reportSummary -> getMemory ( ) / 1024 / 1024 , 3 ) ; } $ json = json_encode ( $ json ) ; return $ reportSummary -> isDecoratedOutput ( ) ? OutputFormatter :: escape ( $ json ) : $ json ; } 
public function isCandidate ( Tokens $ tokens ) { return $ tokens -> isTokenKindFound ( T_FUNCTION ) && ( \ count ( ( new NamespacesAnalyzer ( ) ) -> getDeclarations ( $ tokens ) ) || \ count ( ( new NamespaceUsesAnalyzer ( ) ) -> getDeclarationsFromTokens ( $ tokens ) ) ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ lastIndex = $ tokens -> count ( ) - 1 ; for ( $ index = $ lastIndex ; $ index >= 0 ; -- $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) ) { continue ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; $ index > 0 ; -- $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DOC_COMMENT ) || 0 === Preg :: match ( '/@covers\s.+@covers\s/s' , $ tokens [ $ index ] -> getContent ( ) ) ) { continue ; } $ docBlock = new DocBlock ( $ tokens [ $ index ] -> getContent ( ) ) ; $ covers = $ docBlock -> getAnnotationsOfType ( 'covers' ) ; $ coversMap = [ ] ; foreach ( $ covers as $ annotation ) { $ rawContent = $ annotation -> getContent ( ) ; $ comparableContent = Preg :: replace ( '/\*\s*@covers\s+(.+)/' , '\1' , strtolower ( trim ( $ rawContent ) ) ) ; $ coversMap [ $ comparableContent ] = $ rawContent ; } $ orderedCoversMap = $ coversMap ; ksort ( $ orderedCoversMap , SORT_STRING ) ; if ( $ orderedCoversMap === $ coversMap ) { continue ; } $ lines = $ docBlock -> getLines ( ) ; foreach ( array_reverse ( $ covers ) as $ annotation ) { array_splice ( $ lines , $ annotation -> getStart ( ) , $ annotation -> getEnd ( ) - $ annotation -> getStart ( ) + 1 , array_pop ( $ orderedCoversMap ) ) ; } $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , implode ( '' , $ lines ) ] ) ; } } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'style' , 'Whether to use pre- or post-increment and decrement operators.' ) ) -> setAllowedValues ( [ self :: STYLE_PRE , self :: STYLE_POST ] ) -> setDefault ( self :: STYLE_PRE ) -> getOption ( ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ index = $ tokens -> count ( ) - 1 ; 0 <= $ index ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_INC , T_DEC ] ) ) { continue ; } if ( self :: STYLE_PRE === $ this -> configuration [ 'style' ] && $ tokensAnalyzer -> isUnarySuccessorOperator ( $ index ) ) { $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; if ( ! $ nextToken -> equalsAny ( [ ';' , ')' ] ) ) { continue ; } $ startIndex = $ this -> findStart ( $ tokens , $ index ) ; $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ startIndex ) ] ; if ( $ prevToken -> equalsAny ( [ ';' , '{' , '}' , [ T_OPEN_TAG ] ] ) ) { $ tokens -> clearAt ( $ index ) ; $ tokens -> insertAt ( $ startIndex , clone $ token ) ; } } elseif ( self :: STYLE_POST === $ this -> configuration [ 'style' ] && $ tokensAnalyzer -> isUnaryPredecessorOperator ( $ index ) ) { $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( ! $ prevToken -> equalsAny ( [ ';' , '{' , '}' , [ T_OPEN_TAG ] ] ) ) { continue ; } $ endIndex = $ this -> findEnd ( $ tokens , $ index ) ; $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ endIndex ) ] ; if ( $ nextToken -> equalsAny ( [ ';' , ')' ] ) ) { $ tokens -> clearAt ( $ index ) ; $ tokens -> insertAt ( $ tokens -> getNextNonWhitespace ( $ endIndex ) , clone $ token ) ; } } } } 
private function findEnd ( Tokens $ tokens , $ index ) { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ nextToken = $ tokens [ $ nextIndex ] ; while ( $ nextToken -> equalsAny ( [ '$' , '[' , [ CT :: T_DYNAMIC_PROP_BRACE_OPEN ] , [ CT :: T_DYNAMIC_VAR_BRACE_OPEN ] , [ T_NS_SEPARATOR ] , [ T_STATIC ] , [ T_STRING ] , [ T_VARIABLE ] , ] ) ) { $ blockType = Tokens :: detectBlockType ( $ nextToken ) ; if ( null !== $ blockType ) { $ nextIndex = $ tokens -> findBlockEnd ( $ blockType [ 'type' ] , $ nextIndex ) ; } $ index = $ nextIndex ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ; $ nextToken = $ tokens [ $ nextIndex ] ; } if ( $ nextToken -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return $ this -> findEnd ( $ tokens , $ nextIndex ) ; } if ( $ nextToken -> isGivenKind ( T_PAAMAYIM_NEKUDOTAYIM ) ) { return $ this -> findEnd ( $ tokens , $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ) ; } return $ index ; } 
private function findStart ( Tokens $ tokens , $ index ) { do { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; $ token = $ tokens [ $ index ] ; $ blockType = Tokens :: detectBlockType ( $ token ) ; if ( null !== $ blockType && ! $ blockType [ 'isStart' ] ) { $ index = $ tokens -> findBlockStart ( $ blockType [ 'type' ] , $ index ) ; $ token = $ tokens [ $ index ] ; } } while ( ! $ token -> equalsAny ( [ '$' , [ T_VARIABLE ] ] ) ) ; $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; $ prevToken = $ tokens [ $ prevIndex ] ; if ( $ prevToken -> equals ( '$' ) ) { $ index = $ prevIndex ; $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; $ prevToken = $ tokens [ $ prevIndex ] ; } if ( $ prevToken -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return $ this -> findStart ( $ tokens , $ prevIndex ) ; } if ( $ prevToken -> isGivenKind ( T_PAAMAYIM_NEKUDOTAYIM ) ) { $ prevPrevIndex = $ tokens -> getPrevMeaningfulToken ( $ prevIndex ) ; if ( ! $ tokens [ $ prevPrevIndex ] -> isGivenKind ( [ T_STATIC , T_STRING ] ) ) { return $ this -> findStart ( $ tokens , $ prevIndex ) ; } $ index = $ tokens -> getTokenNotOfKindSibling ( $ prevIndex , - 1 , [ [ T_NS_SEPARATOR ] , [ T_STATIC ] , [ T_STRING ] ] ) ; $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; } return $ index ; } 
public function registerCustomFixers ( array $ fixers ) { foreach ( $ fixers as $ fixer ) { $ this -> registerFixer ( $ fixer , true ) ; } return $ this ; } 
public function registerFixer ( FixerInterface $ fixer , $ isCustom ) { $ name = $ fixer -> getName ( ) ; if ( isset ( $ this -> fixersByName [ $ name ] ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Fixer named "%s" is already registered.' , $ name ) ) ; } if ( ! $ this -> nameValidator -> isValid ( $ name , $ isCustom ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Fixer named "%s" has invalid name.' , $ name ) ) ; } $ this -> fixers [ ] = $ fixer ; $ this -> fixersByName [ $ name ] = $ fixer ; return $ this ; } 
public function useRuleSet ( RuleSetInterface $ ruleSet ) { $ fixers = [ ] ; $ fixersByName = [ ] ; $ fixerConflicts = [ ] ; $ fixerNames = array_keys ( $ ruleSet -> getRules ( ) ) ; foreach ( $ fixerNames as $ name ) { if ( ! \ array_key_exists ( $ name , $ this -> fixersByName ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Rule "%s" does not exist.' , $ name ) ) ; } $ fixer = $ this -> fixersByName [ $ name ] ; $ config = $ ruleSet -> getRuleConfiguration ( $ name ) ; if ( null !== $ config ) { if ( $ fixer instanceof ConfigurableFixerInterface ) { if ( ! \ is_array ( $ config ) || ! \ count ( $ config ) ) { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Configuration must be an array and may not be empty.' ) ; } $ fixer -> configure ( $ config ) ; } else { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Is not configurable.' ) ; } } $ fixers [ ] = $ fixer ; $ fixersByName [ $ name ] = $ fixer ; $ conflicts = array_intersect ( $ this -> getFixersConflicts ( $ fixer ) , $ fixerNames ) ; if ( \ count ( $ conflicts ) > 0 ) { $ fixerConflicts [ $ name ] = $ conflicts ; } } if ( \ count ( $ fixerConflicts ) > 0 ) { throw new \ UnexpectedValueException ( $ this -> generateConflictMessage ( $ fixerConflicts ) ) ; } $ this -> fixers = $ fixers ; $ this -> fixersByName = $ fixersByName ; return $ this ; } 
private function getFixersConflicts ( FixerInterface $ fixer ) { static $ conflictMap = [ 'no_blank_lines_before_namespace' => [ 'single_blank_line_before_namespace' ] , ] ; $ fixerName = $ fixer -> getName ( ) ; return \ array_key_exists ( $ fixerName , $ conflictMap ) ? $ conflictMap [ $ fixerName ] : [ ] ; } 
private function generateConflictMessage ( array $ fixerConflicts ) { $ message = 'Rule contains conflicting fixers:' ; $ report = [ ] ; foreach ( $ fixerConflicts as $ fixer => $ fixers ) { 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( ! $ token -> isGivenKind ( [ T_CONST , T_FUNCTION ] ) ) { return ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ prevToken -> isGivenKind ( T_USE ) ) { $ tokens [ $ index ] = new Token ( [ $ token -> isGivenKind ( T_FUNCTION ) ? CT :: T_FUNCTION_IMPORT : CT :: T_CONST_IMPORT , $ token -> getContent ( ) , ] ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = \ count ( $ tokens ) - 1 ; $ index > 1 ; -- $ index ) { if ( $ tokens [ $ index ] -> equals ( '!' ) ) { $ index = $ this -> fixShortCast ( $ tokens , $ index ) ; } } } 
private function fixShortCast ( Tokens $ tokens , $ index ) { for ( $ i = $ index - 1 ; $ i > 1 ; -- $ i ) { if ( $ tokens [ $ i ] -> equals ( '!' ) ) { $ this -> fixShortCastToBoolCast ( $ tokens , $ i , $ index ) ; break ; } if ( ! $ tokens [ $ i ] -> isComment ( ) && ! $ tokens [ $ i ] -> isWhitespace ( ) ) { break ; } } return $ i ; } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> resolveCandidateTokenKind ( ) ; $ this -> resolveFixCallback ( ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ callback = $ this -> fixCallback ; for ( $ index = $ tokens -> count ( ) - 1 ; 0 <= $ index ; -- $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( $ this -> candidateTokenKind ) ) { $ this -> { $ callback } ( $ tokens , $ index ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ functionsAnalyzer = new FunctionsAnalyzer ( ) ; foreach ( $ tokens as $ index => $ token ) { if ( ! $ tokens [ $ index ] -> equals ( [ T_STRING , 'implode' ] , false ) ) { continue ; } if ( ! $ functionsAnalyzer -> isGlobalFunctionCall ( $ tokens , $ index ) ) { continue ; } $ argumentsIndices = $ this -> getArgumentIndices ( $ tokens , $ index ) ; if ( 1 === \ count ( $ argumentsIndices ) ) { $ firstArgumentIndex = key ( $ argumentsIndices ) ; $ tokens -> insertAt ( $ firstArgumentIndex , [ new Token ( [ T_CONSTANT_ENCAPSED_STRING , "''" ] ) , new Token ( ',' ) , new Token ( [ T_WHITESPACE , ' ' ] ) , ] ) ; continue ; } if ( 2 === \ count ( $ argumentsIndices ) ) { list ( $ firstArgumentIndex , $ secondArgumentIndex ) = array_keys ( $ argumentsIndices ) ; 
private function getArgumentIndices ( Tokens $ tokens , $ functionNameIndex ) { $ argumentsAnalyzer = new ArgumentsAnalyzer ( ) ; $ openParenthesis = $ tokens -> getNextTokenOfKind ( $ functionNameIndex , [ '(' ] ) ; $ closeParenthesis = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ openParenthesis ) ; $ indices = [ ] ; foreach ( $ argumentsAnalyzer -> getArguments ( $ tokens , $ openParenthesis , $ closeParenthesis ) as $ startIndexCandidate => $ endIndex ) { $ indices [ $ tokens -> getNextMeaningfulToken ( $ startIndexCandidate - 1 ) ] = $ tokens -> getPrevMeaningfulToken ( $ endIndex + 1 ) ; } return $ indices ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; 
public function getRuleConfiguration ( $ rule ) { if ( ! $ this -> hasRule ( $ rule ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Rule "%s" is not in the set.' , $ rule ) ) ; } if ( true === $ this -> rules [ $ rule ] ) { return null ; } return $ this -> rules [ $ rule ] ; } 
private function getSetDefinition ( $ name ) { if ( ! isset ( $ this -> setDefinitions [ $ name ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Set "%s" does not exist.' , $ name ) ) ; } return $ this -> setDefinitions [ $ name ] ; } 
private function resolveSet ( ) { $ rules = $ this -> set ; $ resolvedRules = [ ] ; 
private function resolveSubset ( $ setName , $ setValue ) { $ rules = $ this -> getSetDefinition ( $ setName ) ; foreach ( $ rules as $ name => $ value ) { if ( '@' === $ name [ 0 ] ) { $ set = $ this -> resolveSubset ( $ name , $ setValue ) ; unset ( $ rules [ $ name ] ) ; $ rules = array_merge ( $ rules , $ set ) ; } elseif ( ! $ setValue ) { $ rules [ $ name ] = false ; } else { $ rules [ $ name ] = $ value ; } } return $ rules ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = \ count ( $ tokens ) - 1 ; 0 <= $ index ; -- $ index ) { $ token = $ tokens [ $ index ] ; $ this -> fixElseif ( $ index , $ token , $ tokens ) ; $ this -> fixElse ( $ index , $ token , $ tokens ) ; $ this -> fixOpenCloseControls ( $ index , $ token , $ tokens ) ; } } 
private function fixOpenCloseControls ( $ index , Token $ token , Tokens $ tokens ) { if ( $ token -> isGivenKind ( [ T_IF , T_FOREACH , T_WHILE , T_FOR ] ) ) { $ openIndex = $ tokens -> getNextTokenOfKind ( $ index , [ '(' ] ) ; $ closeIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ openIndex ) ; $ afterParenthesisIndex = $ tokens -> getNextNonWhitespace ( $ closeIndex ) ; $ afterParenthesis = $ tokens [ $ afterParenthesisIndex ] ; if ( ! $ afterParenthesis -> equals ( ':' ) ) { return ; } $ items = [ ] ; if ( ! $ tokens [ $ afterParenthesisIndex - 1 ] -> isWhitespace ( ) ) { $ items [ ] = new Token ( [ T_WHITESPACE , ' ' ] ) ; } $ items [ ] = new Token ( '{' ) ; if ( ! $ tokens [ $ afterParenthesisIndex + 1 ] -> isWhitespace ( ) ) { $ items [ ] = new Token ( [ T_WHITESPACE , ' ' ] ) ; } $ tokens -> clearAt ( $ afterParenthesisIndex ) ; $ tokens -> insertAt ( $ afterParenthesisIndex , $ items ) ; } if ( ! $ token -> isGivenKind ( [ T_ENDIF , T_ENDFOREACH , T_ENDWHILE , T_ENDFOR ] ) ) { return ; } $ nextTokenIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ nextToken = $ tokens [ $ nextTokenIndex ] ; $ tokens [ $ index ] = new Token ( '}' ) ; if ( $ nextToken -> equals ( ';' ) ) { $ tokens -> clearAt ( $ nextTokenIndex ) ; } } 
private function fixElse ( $ index , Token $ token , Tokens $ tokens ) { if ( ! $ token -> isGivenKind ( T_ELSE ) ) { return ; } $ tokenAfterElseIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ tokenAfterElse = $ tokens [ $ tokenAfterElseIndex ] ; if ( ! $ tokenAfterElse -> equals ( ':' ) ) { return ; } $ this -> addBraces ( $ tokens , new Token ( [ T_ELSE , 'else' ] ) , $ index , $ tokenAfterElseIndex ) ; } 
private function fixElseif ( $ index , Token $ token , Tokens $ tokens ) { if ( ! $ token -> isGivenKind ( T_ELSEIF ) ) { return ; } $ parenthesisEndIndex = $ this -> findParenthesisEnd ( $ tokens , $ index ) ; $ tokenAfterParenthesisIndex = $ tokens -> getNextMeaningfulToken ( $ parenthesisEndIndex ) ; $ tokenAfterParenthesis = $ tokens [ $ tokenAfterParenthesisIndex ] ; if ( ! $ tokenAfterParenthesis -> equals ( ':' ) ) { return ; } $ this -> addBraces ( $ tokens , new Token ( [ T_ELSEIF , 'elseif' ] ) , $ index , $ tokenAfterParenthesisIndex ) ; } 
private function addBraces ( Tokens $ tokens , Token $ token , $ index , $ colonIndex ) { $ items = [ new Token ( '}' ) , new Token ( [ T_WHITESPACE , ' ' ] ) , $ token , ] ; if ( ! $ tokens [ $ index + 1 ] -> isWhitespace ( ) ) { $ items [ ] = new Token ( [ T_WHITESPACE , ' ' ] ) ; } $ tokens -> clearAt ( $ index ) ; $ tokens -> insertAt ( $ index , $ items ) ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ this -> indent = $ this -> whitespacesConfig -> getIndent ( ) ; foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isComment ( ) ) { $ tokens [ $ index ] = $ this -> fixIndentInComment ( $ tokens , $ index ) ; continue ; } if ( $ token -> isWhitespace ( ) ) { $ tokens [ $ index ] = $ this -> fixIndentToken ( $ tokens , $ index ) ; continue ; } } } 
private function fixIndentInComment ( Tokens $ tokens , $ index ) { $ content = Preg :: replace ( '/^(?:(?<! ) {1,3})?\t/m' , '\1 ' , $ tokens [ $ index ] -> getContent ( ) , - 1 , $ count ) ; 
private function fixIndentToken ( Tokens $ tokens , $ index ) { $ content = $ tokens [ $ index ] -> getContent ( ) ; $ previousTokenHasTrailingLinebreak = false ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ doc = new DocBlock ( $ token -> getContent ( ) ) ; $ annotations = $ doc -> getAnnotationsOfType ( $ this -> tags ) ; if ( empty ( $ annotations ) ) { continue ; } foreach ( $ annotations as $ annotation ) { $ this -> fixTypes ( $ annotation ) ; } $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , $ doc -> getContent ( ) ] ) ; } } 
private function fixTypes ( Annotation $ annotation ) { $ types = $ annotation -> getTypes ( ) ; $ new = $ this -> normalizeTypes ( $ types ) ; if ( $ types !== $ new ) { $ annotation -> setTypes ( $ new ) ; } } 
private function normalizeTypes ( array $ types ) { foreach ( $ types as $ index => $ type ) { $ types [ $ index ] = $ this -> normalizeType ( $ type ) ; } return $ types ; } 
private function normalizeType ( $ type ) { if ( '[]' === substr ( $ type , - 2 ) ) { return $ this -> normalize ( substr ( $ type , 0 , - 2 ) ) . '[]' ; } return $ this -> normalize ( $ type ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = \ count ( $ tokens ) - 1 ; 0 <= $ index ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_NAMESPACE ) ) { continue ; } $ beforeNamespaceIndex = $ index - 1 ; $ beforeNamespace = $ tokens [ $ beforeNamespaceIndex ] ; if ( ! $ beforeNamespace -> isWhitespace ( ) ) { if ( ! self :: endsWithWhitespace ( $ beforeNamespace -> getContent ( ) ) ) { $ tokens -> insertAt ( $ index , new Token ( [ T_WHITESPACE , $ this -> whitespacesConfig -> getLineEnding ( ) ] ) ) ; } continue ; } $ lastNewline = strrpos ( $ beforeNamespace -> getContent ( ) , "\n" ) ; if ( false === $ lastNewline ) { $ beforeBeforeNamespace = $ tokens [ $ index - 2 ] ; if ( self :: endsWithWhitespace ( $ beforeBeforeNamespace -> getContent ( ) ) ) { $ tokens -> clearAt ( $ beforeNamespaceIndex ) ; } else { $ tokens [ $ beforeNamespaceIndex ] = new Token ( [ T_WHITESPACE , ' ' ] ) ; } } else { $ tokens [ $ beforeNamespaceIndex ] = new Token ( [ T_WHITESPACE , substr ( $ beforeNamespace -> getContent ( ) , 0 , $ lastNewline + 1 ) ] ) ; } } } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( ! $ this -> toolInfo -> isInstalledAsPhar ( ) ) { $ output -> writeln ( '<error>Self-update is available only for PHAR version.</error>' ) ; return 1 ; } $ currentVersion = $ this -> getApplication ( ) -> getVersion ( ) ; Preg :: match ( '/^v?(?<major>\d+)\./' , $ currentVersion , $ matches ) ; $ currentMajor = ( int ) $ matches [ 'major' ] ; try { $ latestVersion = $ this -> versionChecker -> getLatestVersion ( ) ; $ latestVersionOfCurrentMajor = $ this -> versionChecker -> getLatestVersionOfMajor ( $ currentMajor ) ; } catch ( \ Exception $ exception ) { $ output -> writeln ( sprintf ( '<error>Unable to determine newest version: %s</error>' , $ exception -> getMessage ( ) ) ) ; return 1 ; } if ( 1 !== $ this -> versionChecker -> compareVersions ( $ latestVersion , $ currentVersion ) ) { $ output -> writeln ( '<info>php-cs-fixer is already up to date.</info>' ) ; return 0 ; } $ remoteTag = $ latestVersion ; if ( 0 !== $ this -> versionChecker -> compareVersions ( $ latestVersionOfCurrentMajor , $ latestVersion ) && true !== $ input -> getOption ( 'force' ) ) { $ output -> writeln ( sprintf ( '<info>A new major version of php-cs-fixer is available</info> (<comment>%s</comment>)' , $ latestVersion ) ) ; $ output -> writeln ( sprintf ( '<info>Before upgrading please read</info> https://github.com/FriendsOfPHP/PHP-CS-Fixer/blob/%s/UPGRADE.md' , $ latestVersion ) ) ; $ output -> writeln ( '<info>If you are ready to upgrade run this command with</info> <comment>-f</comment>' ) ; $ output -> writeln ( '<info>Checking for new minor/patch version...</info>' ) ; if ( 1 !== $ this -> versionChecker -> compareVersions ( $ latestVersionOfCurrentMajor , $ currentVersion ) ) { $ output -> writeln ( '<info>No minor update for php-cs-fixer.</info>' ) ; return 0 ; } $ remoteTag = $ latestVersionOfCurrentMajor ; } $ localFilename = realpath ( $ _SERVER [ 'argv' ] [ 0 ] ) ? : $ _SERVER [ 'argv' ] [ 0 ] ; if ( ! is_writable ( $ localFilename ) ) { $ output -> writeln ( sprintf ( '<error>No permission to update %s file.</error>' , $ localFilename ) ) ; return 1 ; } $ tempFilename = \ dirname ( $ localFilename ) . '/' . basename ( $ localFilename , '.phar' ) . '-tmp.phar' ; $ remoteFilename = $ this -> toolInfo -> getPharDownloadUri ( $ remoteTag ) ; if ( false === @ copy ( $ remoteFilename , $ tempFilename ) ) { $ output -> writeln ( sprintf ( '<error>Unable to download new version %s from the server.</error>' , $ remoteTag ) ) ; return 1 ; } chmod ( $ tempFilename , 0777 & ~ umask ( ) ) ; $ pharInvalidityReason = $ this -> pharChecker -> checkFileValidity ( $ tempFilename ) ; if ( null !== $ pharInvalidityReason ) { unlink ( $ tempFilename ) ; $ output -> writeln ( sprintf ( '<error>The download of %s is corrupt (%s).</error>' , $ remoteTag , $ pharInvalidityReason ) ) ; $ output -> writeln ( '<error>Please re-run the self-update command to try again.</error>' ) ; return 1 ; } rename ( $ tempFilename , $ localFilename ) ; $ output -> writeln ( sprintf ( '<info>php-cs-fixer updated</info> (<comment>%s</comment>)' , $ remoteTag ) ) ; } 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( $ token -> isGivenKind ( T_USE ) && $ this -> isUseForLambda ( $ tokens , $ index ) ) { $ tokens [ $ index ] = new Token ( [ CT :: T_USE_LAMBDA , $ token -> getContent ( ) ] ) ; return ; } 
private function isUseForLambda ( Tokens $ tokens , $ index ) { $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ end = $ tokens -> count ( ) - 1 ; $ functionsAnalyzer = new FunctionsAnalyzer ( ) ; foreach ( self :: $ functions as $ map ) { 
private function getBestDelimiter ( $ pattern ) { 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( [ T_CONSTANT_ENCAPSED_STRING , T_START_HEREDOC ] ) ) { continue ; } $ content = $ token -> getContent ( ) ; if ( 'b' === strtolower ( $ content [ 0 ] ) ) { $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , substr ( $ content , 1 ) ] ) ; } } } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> asteriskEnabled = \ in_array ( 'asterisk' , $ this -> configuration [ 'comment_types' ] , true ) ; $ this -> hashEnabled = \ in_array ( 'hash' , $ this -> configuration [ 'comment_types' ] , true ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_COMMENT ) ) { continue ; } $ content = $ token -> getContent ( ) ; $ commentContent = substr ( $ content , 2 , - 2 ) ? : '' ; if ( $ this -> hashEnabled && '#' === $ content [ 0 ] ) { $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , '//' . substr ( $ content , 1 ) ] ) ; continue ; } if ( ! $ this -> asteriskEnabled || false !== strpos ( $ commentContent , '?>' ) || '/*' !== substr ( $ content , 0 , 2 ) || 1 === Preg :: match ( '/[^\s\*].*\R.*[^\s\*]/s' , $ commentContent ) ) { continue ; } $ nextTokenIndex = $ index + 1 ; if ( isset ( $ tokens [ $ nextTokenIndex ] ) ) { $ nextToken = $ tokens [ $ nextTokenIndex ] ; if ( ! $ nextToken -> isWhitespace ( ) || 1 !== Preg :: match ( '/\R/' , $ nextToken -> getContent ( ) ) ) { continue ; } $ tokens [ $ nextTokenIndex ] = new Token ( [ $ nextToken -> getId ( ) , ltrim ( $ nextToken -> getContent ( ) , " \t" ) ] ) ; } $ content = '//' ; if ( 1 === Preg :: match ( '/[^\s\*]/' , $ commentContent ) ) { $ content = '// ' . Preg :: replace ( '/[\s\*]*([^\s\*](?:.+[^\s\*])?)[\s\*]*/' , '\1' , $ commentContent ) ; } $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , $ content ] ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isClassy ( ) ) { continue ; } $ startBraceIndex = $ tokens -> getNextTokenOfKind ( $ index , [ '{' ] ) ; if ( ! $ tokens [ $ startBraceIndex + 1 ] -> isWhitespace ( ) ) { continue ; } $ this -> fixWhitespace ( $ tokens , $ startBraceIndex + 1 ) ; } } 
private function fixWhitespace ( Tokens $ tokens , $ index ) { $ content = $ tokens [ $ index ] -> getContent ( ) ; 
public static function getName ( $ value ) { if ( ! self :: has ( $ value ) ) { throw new \ InvalidArgumentException ( sprintf ( 'No custom token was found for "%s".' , $ value ) ) ; } $ tokens = self :: getMapById ( ) ; return 'CT::' . $ tokens [ $ value ] ; } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( array_merge ( parent :: createConfigurationDefinition ( ) -> getOptions ( ) , [ ( new FixerOptionBuilder ( 'around_parentheses' , 'Whether to fix spaces around parentheses.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( true ) -> getOption ( ) , ( new FixerOptionBuilder ( 'around_commas' , 'Whether to fix spaces around commas.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( true ) -> getOption ( ) , ( new FixerOptionBuilder ( 'around_argument_assignments' , 'Whether to fix spaces around argument assignment operator.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( true ) -> setDeprecationMessage ( 'Use options `before_argument_assignments` and `after_argument_assignments` instead.' ) -> getOption ( ) , ( new FixerOptionBuilder ( 'before_argument_assignments' , 'Whether to add, remove or ignore spaces before argument assignment operator.' ) ) -> setAllowedTypes ( [ 'null' , 'bool' ] ) -> setDefault ( false ) -> getOption ( ) , ( new FixerOptionBuilder ( 'after_argument_assignments' , 'Whether to add, remove or ignore spaces after argument assignment operator.' ) ) -> setAllowedTypes ( [ 'null' , 'bool' ] ) -> setDefault ( false ) -> getOption ( ) , ( new FixerOptionBuilder ( 'around_array_assignments' , 'Whether to fix spaces around array assignment operators.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( true ) -> setDeprecationMessage ( 'Use options `before_array_assignments_equals`, `after_array_assignments_equals`, `before_array_assignments_colon` and `after_array_assignments_colon` instead.' ) -> getOption ( ) , ( new FixerOptionBuilder ( 'before_array_assignments_equals' , 'Whether to add, remove or ignore spaces before array `=` assignment operator.' ) ) -> setAllowedTypes ( [ 'null' , 'bool' ] ) -> setDefault ( true ) -> getOption ( ) , ( new FixerOptionBuilder ( 'after_array_assignments_equals' , 'Whether to add, remove or ignore spaces after array assignment `=` operator.' ) ) -> setAllowedTypes ( [ 'null' , 'bool' ] ) -> setDefault ( true ) -> getOption ( ) , ( new FixerOptionBuilder ( 'before_array_assignments_colon' , 'Whether to add, remove or ignore spaces before array `:` assignment operator.' ) ) -> setAllowedTypes ( [ 'null' , 'bool' ] ) -> setDefault ( true ) -> getOption ( ) , ( new FixerOptionBuilder ( 'after_array_assignments_colon' , 'Whether to add, remove or ignore spaces after array assignment `:` operator.' ) ) -> setAllowedTypes ( [ 'null' , 'bool' ] ) -> setDefault ( true ) -> getOption ( ) , ] ) ) ; } 
protected function fixAnnotations ( Tokens $ tokens ) { if ( $ this -> configuration [ 'around_parentheses' ] ) { $ this -> fixSpacesAroundParentheses ( $ tokens ) ; } if ( $ this -> configuration [ 'around_commas' ] ) { $ this -> fixSpacesAroundCommas ( $ tokens ) ; } if ( null !== $ this -> configuration [ 'before_argument_assignments' ] || null !== $ this -> configuration [ 'after_argument_assignments' ] || null !== $ this -> configuration [ 'before_array_assignments_equals' ] || null !== $ this -> configuration [ 'after_array_assignments_equals' ] || null !== $ this -> configuration [ 'before_array_assignments_colon' ] || null !== $ this -> configuration [ 'after_array_assignments_colon' ] ) { $ this -> fixAroundAssignments ( $ tokens ) ; } } 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( ! $ token -> isGivenKind ( T_ARRAY ) ) { return ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ nextToken = $ tokens [ $ nextIndex ] ; if ( ! $ nextToken -> equals ( '(' ) ) { $ tokens [ $ index ] = new Token ( [ CT :: T_ARRAY_TYPEHINT , $ token -> getContent ( ) ] ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isGivenKind ( [ T_CASE , T_DEFAULT ] ) ) { $ this -> fixSwitchCase ( $ tokens , $ index ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_RETURN ) ) { continue ; } if ( $ this -> needFixing ( $ tokens , $ index ) ) { $ this -> clear ( $ tokens , $ index ) ; } } } 
private function clear ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ ++ $ index ] -> equals ( ';' ) ) { if ( $ this -> shouldClearToken ( $ tokens , $ index ) ) { $ tokens -> clearAt ( $ index ) ; } } } 
private function needFixing ( Tokens $ tokens , $ index ) { if ( $ this -> isStrictOrNullableReturnTypeFunction ( $ tokens , $ index ) ) { return false ; } $ content = '' ; while ( ! $ tokens [ $ index ] -> equals ( ';' ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ content .= $ tokens [ $ index ] -> getContent ( ) ; } $ content = ltrim ( $ content , '(' ) ; $ content = rtrim ( $ content , ');' ) ; return 'null' === strtolower ( $ content ) ; } 
private function isStrictOrNullableReturnTypeFunction ( Tokens $ tokens , $ returnIndex ) { $ functionIndex = $ returnIndex ; do { $ functionIndex = $ tokens -> getPrevTokenOfKind ( $ functionIndex , [ [ T_FUNCTION ] ] ) ; if ( null === $ functionIndex ) { return false ; } $ openingCurlyBraceIndex = $ tokens -> getNextTokenOfKind ( $ functionIndex , [ '{' ] ) ; $ closingCurlyBraceIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ openingCurlyBraceIndex ) ; } while ( $ closingCurlyBraceIndex < $ returnIndex ) ; $ possibleVoidIndex = $ tokens -> getPrevMeaningfulToken ( $ openingCurlyBraceIndex ) ; $ isStrictReturnType = $ tokens [ $ possibleVoidIndex ] -> isGivenKind ( T_STRING ) && 'void' !== $ tokens [ $ possibleVoidIndex ] -> getContent ( ) ; $ nullableTypeIndex = $ tokens -> getNextTokenOfKind ( $ functionIndex , [ [ CT :: T_NULLABLE_TYPE ] ] ) ; $ isNullableReturnType = null !== $ nullableTypeIndex && $ nullableTypeIndex < $ openingCurlyBraceIndex ; return $ isStrictReturnType || $ isNullableReturnType ; } 
private function shouldClearToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; return ! $ token -> isComment ( ) && ! ( $ token -> isWhitespace ( ) && $ tokens [ $ index + 1 ] -> isComment ( ) ) ; } 
public static function fulfills ( $ candidate , $ target ) { if ( self :: VERSION_NEWEST === $ target ) { throw new \ LogicException ( sprintf ( 'Parameter `target` shall not be provided as `%s`, determine proper target for tested PHPUnit feature instead.' , self :: VERSION_NEWEST ) ) ; } if ( self :: VERSION_NEWEST === $ candidate ) { return true ; } return Comparator :: greaterThanOrEqualTo ( $ candidate , $ target ) ; } 
public function getTypes ( ) { if ( null === $ this -> types ) { $ this -> types = [ ] ; $ content = $ this -> getTypesContent ( ) ; while ( '' !== $ content && false !== $ content ) { Preg :: match ( '{^' . self :: REGEX_TYPES . '$}x' , $ content , $ matches ) ; $ this -> types [ ] = $ matches [ 'type' ] ; $ content = substr ( $ content , \ strlen ( $ matches [ 'type' ] ) + 1 ) ; } } return $ this -> types ; } 
public function setTypes ( array $ types ) { $ pattern = '/' . preg_quote ( $ this -> getTypesContent ( ) , '/' ) . '/' ; $ this -> lines [ 0 ] -> setContent ( Preg :: replace ( $ pattern , implode ( '|' , $ types ) , $ this -> lines [ 0 ] -> getContent ( ) , 1 ) ) ; $ this -> clearCache ( ) ; } 
public function getNormalizedTypes ( ) { $ normalized = array_map ( static function ( $ type ) { return strtolower ( $ type ) ; } , $ this -> getTypes ( ) ) ; sort ( $ normalized ) ; return $ normalized ; } 
private function getTypesContent ( ) { if ( null === $ this -> typesContent ) { $ name = $ this -> getTag ( ) -> getName ( ) ; if ( ! $ this -> supportTypes ( ) ) { throw new \ RuntimeException ( 'This tag does not support types.' ) ; } $ matchingResult = Preg :: match ( '{^(?:\s*\*|/\*\*)\s*@' . $ name . '\s+' . self :: REGEX_TYPES . '(?:[ \t].*)?$}sx' , $ this -> lines [ 0 ] -> getContent ( ) , $ matches ) ; $ this -> typesContent = 1 === $ matchingResult ? $ matches [ 'types' ] : '' ; } return $ this -> typesContent ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_ELSE ) ) { continue ; } $ ifTokenIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; 
public function countArguments ( Tokens $ tokens , $ openParenthesis , $ closeParenthesis ) { return \ count ( $ this -> getArguments ( $ tokens , $ openParenthesis , $ closeParenthesis ) ) ; } 
public function getArguments ( Tokens $ tokens , $ openParenthesis , $ closeParenthesis ) { $ arguments = [ ] ; $ firstSensibleToken = $ tokens -> getNextMeaningfulToken ( $ openParenthesis ) ; if ( $ tokens [ $ firstSensibleToken ] -> equals ( ')' ) ) { return $ arguments ; } $ paramContentIndex = $ openParenthesis + 1 ; $ argumentsStart = $ paramContentIndex ; for ( ; $ paramContentIndex < $ closeParenthesis ; ++ $ paramContentIndex ) { $ token = $ tokens [ $ paramContentIndex ] ; 
public function getArgumentInfo ( Tokens $ tokens , $ argumentStart , $ argumentEnd ) { $ info = [ 'default' => null , 'name' => null , 'name_index' => null , 'type' => null , 'type_index_start' => null , 'type_index_end' => null , ] ; $ sawName = false ; for ( $ index = $ argumentStart ; $ index <= $ argumentEnd ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isComment ( ) || $ token -> isWhitespace ( ) || $ token -> isGivenKind ( T_ELLIPSIS ) || $ token -> equals ( '&' ) ) { continue ; } if ( $ token -> isGivenKind ( T_VARIABLE ) ) { $ sawName = true ; $ info [ 'name_index' ] = $ index ; $ info [ 'name' ] = $ token -> getContent ( ) ; continue ; } if ( $ token -> equals ( '=' ) ) { continue ; } if ( $ sawName ) { $ info [ 'default' ] .= $ token -> getContent ( ) ; } else { $ info [ 'type_index_start' ] = ( $ info [ 'type_index_start' ] > 0 ) ? $ info [ 'type_index_start' ] : $ index ; $ info [ 'type_index_end' ] = $ index ; $ info [ 'type' ] .= $ token -> getContent ( ) ; } } return new ArgumentAnalysis ( $ info [ 'name' ] , $ info [ 'name_index' ] , $ info [ 'default' ] , $ info [ 'type' ] ? new TypeAnalysis ( $ info [ 'type' ] , $ info [ 'type_index_start' ] , $ info [ 'type_index_end' ] ) : null ) ; } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'equal' , 'Style for equal (`==`, `!=`) statements.' ) ) -> setAllowedTypes ( [ 'bool' , 'null' ] ) -> setDefault ( true ) -> getOption ( ) , ( new FixerOptionBuilder ( 'identical' , 'Style for identical (`===`, `!==`) statements.' ) ) -> setAllowedTypes ( [ 'bool' , 'null' ] ) -> setDefault ( true ) -> getOption ( ) , ( new FixerOptionBuilder ( 'less_and_greater' , 'Style for less and greater than (`<`, `<=`, `>`, `>=`) statements.' ) ) -> setAllowedTypes ( [ 'bool' , 'null' ] ) -> setDefault ( null ) -> getOption ( ) , ( new FixerOptionBuilder ( 'always_move_variable' , 'Whether variables should always be on non assignable side when applying Yoda style.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( false ) -> getOption ( ) , ] ) ; } 
private function findComparisonEnd ( Tokens $ tokens , $ index ) { ++ $ index ; $ count = \ count ( $ tokens ) ; while ( $ index < $ count ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { ++ $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { ++ $ index ; continue ; } if ( ! $ block [ 'isStart' ] ) { break ; } $ index = $ tokens -> findBlockEnd ( $ block [ 'type' ] , $ index ) + 1 ; } $ prev = $ tokens -> getPrevMeaningfulToken ( $ index ) ; return $ tokens [ $ prev ] -> isGivenKind ( T_CLOSE_TAG ) ? $ tokens -> getPrevMeaningfulToken ( $ prev ) : $ prev ; } 
private function findComparisonStart ( Tokens $ tokens , $ index ) { -- $ index ; $ nonBlockFound = false ; while ( 0 <= $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { -- $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { -- $ index ; $ nonBlockFound = true ; continue ; } if ( $ block [ 'isStart' ] || ( $ nonBlockFound && Tokens :: BLOCK_TYPE_CURLY_BRACE === $ block [ 'type' ] ) 
private function fixTokens ( Tokens $ tokens ) { for ( $ i = \ count ( $ tokens ) - 1 ; $ i > 1 ; -- $ i ) { if ( $ tokens [ $ i ] -> isGivenKind ( $ this -> candidateTypes ) ) { $ yoda = $ this -> candidateTypesConfiguration [ $ tokens [ $ i ] -> getId ( ) ] ; } elseif ( ( $ tokens [ $ i ] -> equals ( '<' ) && \ in_array ( '<' , $ this -> candidateTypes , true ) ) || ( $ tokens [ $ i ] -> equals ( '>' ) && \ in_array ( '>' , $ this -> candidateTypes , true ) ) ) { $ yoda = $ this -> candidateTypesConfiguration [ $ tokens [ $ i ] -> getContent ( ) ] ; } else { continue ; } $ fixableCompareInfo = $ this -> getCompareFixableInfo ( $ tokens , $ i , $ yoda ) ; if ( null === $ fixableCompareInfo ) { continue ; } $ i = $ this -> fixTokensCompare ( $ tokens , $ fixableCompareInfo [ 'left' ] [ 'start' ] , $ fixableCompareInfo [ 'left' ] [ 'end' ] , $ i , $ fixableCompareInfo [ 'right' ] [ 'start' ] , $ fixableCompareInfo [ 'right' ] [ 'end' ] ) ; } return $ tokens ; } 
private function fixTokensCompare ( Tokens $ tokens , $ startLeft , $ endLeft , $ compareOperatorIndex , $ startRight , $ endRight ) { $ type = $ tokens [ $ compareOperatorIndex ] -> getId ( ) ; $ content = $ tokens [ $ compareOperatorIndex ] -> getContent ( ) ; if ( \ array_key_exists ( $ type , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ type ] ; } elseif ( \ array_key_exists ( $ content , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ content ] ; } $ right = $ this -> fixTokensComparePart ( $ tokens , $ startRight , $ endRight ) ; $ left = $ this -> fixTokensComparePart ( $ tokens , $ startLeft , $ endLeft ) ; for ( $ i = $ startRight ; $ i <= $ endRight ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } for ( $ i = $ startLeft ; $ i <= $ endLeft ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens -> insertAt ( $ startRight , $ left ) ; $ tokens -> insertAt ( $ startLeft , $ right ) ; return $ startLeft ; } 
private function fixTokensComparePart ( Tokens $ tokens , $ start , $ end ) { $ newTokens = $ tokens -> generatePartialCode ( $ start , $ end ) ; $ newTokens = $ this -> fixTokens ( Tokens :: fromCode ( sprintf ( '<?php %s;' , $ newTokens ) ) ) ; $ newTokens -> clearAt ( \ count ( $ newTokens ) - 1 ) ; $ newTokens -> clearAt ( 0 ) ; $ newTokens -> clearEmptyTokens ( ) ; return $ newTokens ; } 
private function getCompareFixableInfo ( Tokens $ tokens , $ index , $ yoda ) { $ left = $ this -> getLeftSideCompareFixableInfo ( $ tokens , $ index ) ; $ right = $ this -> getRightSideCompareFixableInfo ( $ tokens , $ index ) ; if ( $ yoda ) { $ expectedAssignableSide = $ right ; $ expectedValueSide = $ left ; } else { if ( $ tokens [ $ tokens -> getNextMeaningfulToken ( $ right [ 'end' ] ) ] -> equals ( '=' ) ) { return null ; } $ expectedAssignableSide = $ left ; $ expectedValueSide = $ right ; } if ( 
private function getLeftSideCompareFixableInfo ( Tokens $ tokens , $ index ) { return [ 'start' => $ this -> findComparisonStart ( $ tokens , $ index ) , 'end' => $ tokens -> getPrevMeaningfulToken ( $ index ) , ] ; } 
private function getRightSideCompareFixableInfo ( Tokens $ tokens , $ index ) { return [ 'start' => $ tokens -> getNextMeaningfulToken ( $ index ) , 'end' => $ this -> findComparisonEnd ( $ tokens , $ index ) , ] ; } 
private function isListStatement ( Tokens $ tokens , $ index , $ end ) { for ( $ i = $ index ; $ i <= $ end ; ++ $ i ) { if ( $ tokens [ $ i ] -> isGivenKind ( [ T_LIST , CT :: T_DESTRUCTURING_SQUARE_BRACE_OPEN , CT :: T_DESTRUCTURING_SQUARE_BRACE_CLOSE ] ) ) { return true ; } } return false ; } 
private function isOfLowerPrecedence ( Token $ token ) { static $ tokens ; if ( null === $ tokens ) { $ tokens = [ T_AND_EQUAL , 
private function isVariable ( Tokens $ tokens , $ start , $ end , $ strict ) { $ tokenAnalyzer = new TokensAnalyzer ( $ tokens ) ; if ( $ start === $ end ) { return $ tokens [ $ start ] -> isGivenKind ( T_VARIABLE ) ; } if ( $ strict ) { if ( $ tokens [ $ start ] -> equals ( '(' ) ) { return false ; } for ( $ index = $ start ; $ index <= $ end ; ++ $ index ) { if ( $ tokens [ $ index ] -> isCast ( ) || $ tokens [ $ index ] -> isGivenKind ( T_INSTANCEOF ) || $ tokens [ $ index ] -> equals ( '!' ) || $ tokenAnalyzer -> isBinaryOperator ( $ index ) ) { return false ; } } } $ index = $ start ; 
public function getClassyElements ( ) { $ this -> tokens -> rewind ( ) ; $ elements = [ ] ; for ( $ index = 1 , $ count = \ count ( $ this -> tokens ) - 2 ; $ index < $ count ; ++ $ index ) { if ( $ this -> tokens [ $ index ] -> isClassy ( ) ) { list ( $ index , $ newElements ) = $ this -> findClassyElements ( $ index ) ; $ elements += $ newElements ; } } ksort ( $ elements ) ; return $ elements ; } 
public function getImportUseIndexes ( $ perNamespace = false ) { $ tokens = $ this -> tokens ; $ tokens -> rewind ( ) ; $ uses = [ ] ; $ namespaceIndex = 0 ; for ( $ index = 0 , $ limit = $ tokens -> count ( ) ; $ index < $ limit ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_NAMESPACE ) ) { $ nextTokenIndex = $ tokens -> getNextTokenOfKind ( $ index , [ ';' , '{' ] ) ; $ nextToken = $ tokens [ $ nextTokenIndex ] ; if ( $ nextToken -> equals ( '{' ) ) { $ index = $ nextTokenIndex ; } if ( $ perNamespace ) { ++ $ namespaceIndex ; } continue ; } if ( $ token -> isGivenKind ( T_USE ) ) { $ uses [ $ namespaceIndex ] [ ] = $ index ; } } if ( ! $ perNamespace && isset ( $ uses [ $ namespaceIndex ] ) ) { return $ uses [ $ namespaceIndex ] ; } return $ uses ; } 
public function isArrayMultiLine ( $ index ) { if ( ! $ this -> isArray ( $ index ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Not an array at given index %d.' , $ index ) ) ; } $ tokens = $ this -> tokens ; 
public function getMethodAttributes ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_FUNCTION ) ) { throw new \ LogicException ( sprintf ( 'No T_FUNCTION at given index %d, got %s.' , $ index , $ token -> getName ( ) ) ) ; } $ attributes = [ 'visibility' => null , 'static' => false , 'abstract' => false , 'final' => false , ] ; for ( $ i = $ index ; $ i >= 0 ; -- $ i ) { $ tokenIndex = $ tokens -> getPrevMeaningfulToken ( $ i ) ; $ i = $ tokenIndex ; $ token = $ tokens [ $ tokenIndex ] ; if ( $ token -> isGivenKind ( T_STATIC ) ) { $ attributes [ 'static' ] = true ; continue ; } if ( $ token -> isGivenKind ( T_FINAL ) ) { $ attributes [ 'final' ] = true ; continue ; } if ( $ token -> isGivenKind ( T_ABSTRACT ) ) { $ attributes [ 'abstract' ] = true ; continue ; } 
public function isAnonymousClass ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isClassy ( ) ) { throw new \ LogicException ( sprintf ( 'No classy token at given index %d.' , $ index ) ) ; } if ( ! $ token -> isGivenKind ( T_CLASS ) ) { return false ; } return $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_NEW ) ; } 
public function isLambda ( $ index ) { if ( ! $ this -> tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) ) { throw new \ LogicException ( sprintf ( 'No T_FUNCTION at given index %d, got %s.' , $ index , $ this -> tokens [ $ index ] -> getName ( ) ) ) ; } $ startParenthesisIndex = $ this -> tokens -> getNextMeaningfulToken ( $ index ) ; $ startParenthesisToken = $ this -> tokens [ $ startParenthesisIndex ] ; 
public function isConstantInvocation ( $ index ) { if ( ! $ this -> tokens [ $ index ] -> isGivenKind ( T_STRING ) ) { throw new \ LogicException ( sprintf ( 'No T_STRING at given index %d, got %s.' , $ index , $ this -> tokens [ $ index ] -> getName ( ) ) ) ; } $ nextIndex = $ this -> tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ this -> tokens [ $ nextIndex ] -> equalsAny ( [ '(' , '{' ] ) || $ this -> tokens [ $ nextIndex ] -> isGivenKind ( [ T_AS , T_DOUBLE_COLON , T_ELLIPSIS , T_NS_SEPARATOR , CT :: T_RETURN_REF , CT :: T_TYPE_ALTERNATION , T_VARIABLE ] ) ) { return false ; } $ prevIndex = $ this -> tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ this -> tokens [ $ prevIndex ] -> isGivenKind ( [ T_AS , T_CLASS , T_CONST , T_DOUBLE_COLON , T_FUNCTION , T_GOTO , CT :: T_GROUP_IMPORT_BRACE_OPEN , T_INTERFACE , T_OBJECT_OPERATOR , T_TRAIT ] ) ) { return false ; } while ( $ this -> tokens [ $ prevIndex ] -> isGivenKind ( [ CT :: T_NAMESPACE_OPERATOR , T_NS_SEPARATOR , T_STRING ] ) ) { $ prevIndex = $ this -> tokens -> getPrevMeaningfulToken ( $ prevIndex ) ; } if ( $ this -> tokens [ $ prevIndex ] -> isGivenKind ( [ CT :: T_CONST_IMPORT , T_EXTENDS , CT :: T_FUNCTION_IMPORT , T_IMPLEMENTS , T_INSTANCEOF , T_INSTEADOF , T_NAMESPACE , T_NEW , T_USE , CT :: T_USE_TRAIT ] ) ) { return false ; } 
public function isUnarySuccessorOperator ( $ index ) { static $ allowedPrevToken = [ ']' , [ T_STRING ] , [ T_VARIABLE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , ] ; $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_INC , T_DEC ] ) ) { return false ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; return $ prevToken -> equalsAny ( $ allowedPrevToken ) ; } 
public function isUnaryPredecessorOperator ( $ index ) { static $ potentialSuccessorOperator = [ T_INC , T_DEC ] ; static $ potentialBinaryOperator = [ '+' , '-' , '&' , [ CT :: T_RETURN_REF ] ] ; static $ otherOperators ; if ( null === $ otherOperators ) { $ otherOperators = [ '!' , '~' , '@' , [ T_ELLIPSIS ] ] ; } static $ disallowedPrevTokens ; if ( null === $ disallowedPrevTokens ) { $ disallowedPrevTokens = [ ']' , '}' , ')' , '"' , '`' , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ T_CLASS_C ] , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_DEC ] , [ T_DIR ] , [ T_DNUMBER ] , [ T_FILE ] , [ T_FUNC_C ] , [ T_INC ] , [ T_LINE ] , [ T_LNUMBER ] , [ T_METHOD_C ] , [ T_NS_C ] , [ T_STRING ] , [ T_TRAIT_C ] , [ T_VARIABLE ] , ] ; } $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( $ potentialSuccessorOperator ) ) { return ! $ this -> isUnarySuccessorOperator ( $ index ) ; } if ( $ token -> equalsAny ( $ otherOperators ) ) { return true ; } if ( ! $ token -> equalsAny ( $ potentialBinaryOperator ) ) { return false ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( ! $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return true ; } if ( ! $ token -> equals ( '&' ) || ! $ prevToken -> isGivenKind ( T_STRING ) ) { return false ; } static $ searchTokens = [ ';' , '{' , '}' , [ T_FUNCTION ] , [ T_OPEN_TAG ] , [ T_OPEN_TAG_WITH_ECHO ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevTokenOfKind ( $ index , $ searchTokens ) ] ; return $ prevToken -> isGivenKind ( T_FUNCTION ) ; } 
public function isBinaryOperator ( $ index ) { static $ nonArrayOperators = [ '=' => true , '*' => true , '/' => true , '%' => true , '<' => true , '>' => true , '|' => true , '^' => true , '.' => true , ] ; static $ potentialUnaryNonArrayOperators = [ '+' => true , '-' => true , '&' => true , ] ; static $ arrayOperators ; if ( null === $ arrayOperators ) { $ arrayOperators = [ T_AND_EQUAL => true , 
public function isWhilePartOfDoWhile ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_WHILE ) ) { throw new \ LogicException ( sprintf ( 'No T_WHILE at given index %d, got %s.' , $ index , $ token -> getName ( ) ) ) ; } $ endIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( ! $ tokens [ $ endIndex ] -> equals ( '}' ) ) { return false ; } $ startIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ endIndex ) ; $ beforeStartIndex = $ tokens -> getPrevMeaningfulToken ( $ startIndex ) ; return $ tokens [ $ beforeStartIndex ] -> isGivenKind ( T_DO ) ; } 
private function findClassyElements ( $ index ) { $ elements = [ ] ; $ curlyBracesLevel = 0 ; $ bracesLevel = 0 ; $ classIndex = $ index ; ++ $ index ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = $ tokens -> count ( ) - 1 ; 0 <= $ index ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> equals ( [ T_STRING , 'dirname' ] , false ) ) { continue ; } $ dirnameInfo = $ this -> getDirnameInfo ( $ tokens , $ index ) ; if ( ! $ dirnameInfo ) { continue ; } $ prev = $ tokens -> getPrevMeaningfulToken ( $ dirnameInfo [ 'indexes' ] [ 0 ] ) ; if ( ! $ tokens [ $ prev ] -> equals ( '(' ) ) { continue ; } $ prev = $ tokens -> getPrevMeaningfulToken ( $ prev ) ; $ firstArgumentEnd = $ dirnameInfo [ 'end' ] ; $ dirnameInfoArray = [ $ dirnameInfo ] ; while ( $ dirnameInfo = $ this -> getDirnameInfo ( $ tokens , $ prev , $ firstArgumentEnd ) ) { $ dirnameInfoArray [ ] = $ dirnameInfo ; $ prev = $ tokens -> getPrevMeaningfulToken ( $ dirnameInfo [ 'indexes' ] [ 0 ] ) ; if ( ! $ tokens [ $ prev ] -> equals ( '(' ) ) { break ; } $ prev = $ tokens -> getPrevMeaningfulToken ( $ prev ) ; $ firstArgumentEnd = $ dirnameInfo [ 'end' ] ; } if ( \ count ( $ dirnameInfoArray ) > 1 ) { $ this -> combineDirnames ( $ tokens , $ dirnameInfoArray ) ; } $ index = $ prev ; } } 
private function getDirnameInfo ( Tokens $ tokens , $ index , $ firstArgumentEndIndex = null ) { if ( ! $ tokens [ $ index ] -> equals ( [ T_STRING , 'dirname' ] , false ) ) { return false ; } if ( ! ( new FunctionsAnalyzer ( ) ) -> isGlobalFunctionCall ( $ tokens , $ index ) ) { return false ; } $ info [ 'indexes' ] = [ ] ; $ prev = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ prev ] -> isGivenKind ( T_NS_SEPARATOR ) ) { $ info [ 'indexes' ] [ ] = $ prev ; } $ info [ 'indexes' ] [ ] = $ index ; 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> typePosition = [ ] ; $ pos = 0 ; foreach ( $ this -> configuration [ 'order' ] as $ type ) { $ this -> typePosition [ $ type ] = $ pos ++ ; } foreach ( self :: $ typeHierarchy as $ type => $ parents ) { if ( isset ( $ this -> typePosition [ $ type ] ) ) { continue ; } if ( ! $ parents ) { $ this -> typePosition [ $ type ] = null ; continue ; } foreach ( $ parents as $ parent ) { if ( isset ( $ this -> typePosition [ $ parent ] ) ) { $ this -> typePosition [ $ type ] = $ this -> typePosition [ $ parent ] ; continue 2 ; } } $ this -> typePosition [ $ type ] = null ; } $ lastPosition = \ count ( $ this -> configuration [ 'order' ] ) ; foreach ( $ this -> typePosition as & $ pos ) { if ( null === $ pos ) { $ pos = $ lastPosition ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ i = 1 , $ count = $ tokens -> count ( ) ; $ i < $ count ; ++ $ i ) { if ( ! $ tokens [ $ i ] -> isClassy ( ) ) { continue ; } $ i = $ tokens -> getNextTokenOfKind ( $ i , [ '{' ] ) ; $ elements = $ this -> getElements ( $ tokens , $ i ) ; if ( ! $ elements ) { continue ; } $ sorted = $ this -> sortElements ( $ elements ) ; $ endIndex = $ elements [ \ count ( $ elements ) - 1 ] [ 'end' ] ; if ( $ sorted !== $ elements ) { $ this -> sortTokens ( $ tokens , $ i , $ endIndex , $ sorted ) ; } $ i = $ endIndex ; } } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolverRootless ( 'order' , [ ( new FixerOptionBuilder ( 'order' , 'List of strings defining order of elements.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ new AllowedValueSubset ( array_keys ( array_merge ( self :: $ typeHierarchy , self :: $ specialTypes ) ) ) ] ) -> setDefault ( [ 'use_trait' , 'constant_public' , 'constant_protected' , 'constant_private' , 'property_public' , 'property_protected' , 'property_private' , 'construct' , 'destruct' , 'magic' , 'phpunit' , 'method_public' , 'method_protected' , 'method_private' , ] ) -> getOption ( ) , ( new FixerOptionBuilder ( 'sortAlgorithm' , 'How multiple occurrences of same type statements should be sorted' ) ) -> setAllowedValues ( $ this -> supportedSortAlgorithms ) -> setDefault ( self :: SORT_NONE ) -> getOption ( ) , ] , $ this -> getName ( ) ) ; } 
private function getElements ( Tokens $ tokens , $ startIndex ) { static $ elementTokenKinds = [ CT :: T_USE_TRAIT , T_CONST , T_VARIABLE , T_FUNCTION ] ; ++ $ startIndex ; $ elements = [ ] ; while ( true ) { $ element = [ 'start' => $ startIndex , 'visibility' => 'public' , 'static' => false , ] ; for ( $ i = $ startIndex ; ; ++ $ i ) { $ token = $ tokens [ $ i ] ; 
private function detectElementType ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( CT :: T_USE_TRAIT ) ) { return 'use_trait' ; } if ( $ token -> isGivenKind ( T_CONST ) ) { return 'constant' ; } if ( $ token -> isGivenKind ( T_VARIABLE ) ) { return 'property' ; } $ nameToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; if ( $ nameToken -> equals ( [ T_STRING , '__construct' ] , false ) ) { return 'construct' ; } if ( $ nameToken -> equals ( [ T_STRING , '__destruct' ] , false ) ) { return 'destruct' ; } if ( $ nameToken -> equalsAny ( [ [ T_STRING , 'setUpBeforeClass' ] , [ T_STRING , 'tearDownAfterClass' ] , [ T_STRING , 'setUp' ] , [ T_STRING , 'tearDown' ] , ] , false ) ) { return [ 'phpunit' , strtolower ( $ nameToken -> getContent ( ) ) ] ; } if ( '__' === substr ( $ nameToken -> getContent ( ) , 0 , 2 ) ) { return 'magic' ; } return 'method' ; } 
private function findElementEnd ( Tokens $ tokens , $ index ) { $ index = $ tokens -> getNextTokenOfKind ( $ index , [ '{' , ';' ] ) ; if ( $ tokens [ $ index ] -> equals ( '{' ) ) { $ index = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; } for ( ++ $ index ; $ tokens [ $ index ] -> isWhitespace ( " \t" ) || $ tokens [ $ index ] -> isComment ( ) ; ++ $ index ) ; -- $ index ; return $ tokens [ $ index ] -> isWhitespace ( ) ? $ index - 1 : $ index ; } 
private function sortElements ( array $ elements ) { static $ phpunitPositions = [ 'setupbeforeclass' => 1 , 'teardownafterclass' => 2 , 'setup' => 3 , 'teardown' => 4 , ] ; foreach ( $ elements as & $ element ) { $ type = $ element [ 'type' ] ; if ( \ array_key_exists ( $ type , self :: $ specialTypes ) ) { if ( isset ( $ this -> typePosition [ $ type ] ) ) { $ element [ 'position' ] = $ this -> typePosition [ $ type ] ; if ( 'phpunit' === $ type ) { $ element [ 'position' ] += $ phpunitPositions [ $ element [ 'name' ] ] ; } continue ; } $ type = 'method' ; } if ( \ in_array ( $ type , [ 'constant' , 'property' , 'method' ] , true ) ) { $ type .= '_' . $ element [ 'visibility' ] ; if ( $ element [ 'static' ] ) { $ type .= '_static' ; } } $ element [ 'position' ] = $ this -> typePosition [ $ type ] ; } unset ( $ element ) ; usort ( $ elements , function ( array $ a , array $ b ) { if ( $ a [ 'position' ] === $ b [ 'position' ] ) { return $ this -> sortGroupElements ( $ a , $ b ) ; } return $ a [ 'position' ] > $ b [ 'position' ] ? 1 : - 1 ; } ) ; return $ elements ; } 
public function match ( $ needle ) { $ word = null ; $ distance = ceil ( \ strlen ( $ needle ) * 0.35 ) ; foreach ( $ this -> candidates as $ candidate ) { $ candidateDistance = levenshtein ( $ needle , $ candidate ) ; if ( $ candidateDistance < $ distance ) { $ word = $ candidate ; $ distance = $ candidateDistance ; } } return $ word ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isGivenKind ( T_DOC_COMMENT ) ) { $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , $ this -> fixTokenContent ( $ token -> getContent ( ) ) ] ) ; continue ; } if ( ! $ token -> isGivenKind ( T_COMMENT ) ) { continue ; } $ content = $ token -> getContent ( ) ; $ fixedContent = $ this -> fixTokenContent ( $ content ) ; if ( $ content !== $ fixedContent ) { $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , $ fixedContent ] ) ; } } } 
private function fixTokenContent ( $ content ) { return Preg :: replaceCallback ( '#^/\*\*[ \t]*@var[ \t]+(\S+)[ \t]*(\$\S+)?[ \t]*([^\n]*)\*/$#' , static function ( array $ matches ) { $ content = '/** @var' ; for ( $ i = 1 , $ m = \ count ( $ matches ) ; $ i < $ m ; ++ $ i ) { if ( '' !== $ matches [ $ i ] ) { $ content .= ' ' . $ matches [ $ i ] ; } } $ content = rtrim ( $ content ) ; return $ content . ' */' ; } , $ content ) ; } 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( $ this -> isArrayDestructing ( $ tokens , $ index ) ) { $ this -> transformIntoDestructuringSquareBrace ( $ tokens , $ index ) ; return ; } if ( $ this -> isShortArray ( $ tokens , $ index ) ) { $ this -> transformIntoArraySquareBrace ( $ tokens , $ index ) ; } } 
private function isShortArray ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> equals ( '[' ) ) { return false ; } static $ disallowedPrevTokens = [ ')' , ']' , '}' , '"' , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_STRING ] , [ T_STRING_VARNAME ] , [ T_VARIABLE ] , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return false ; } $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; if ( $ nextToken -> equals ( ']' ) ) { return true ; } return ! $ this -> isArrayDestructing ( $ tokens , $ index ) ; } 
private function isArrayDestructing ( Tokens $ tokens , $ index ) { if ( \ PHP_VERSION_ID < 70100 || ! $ tokens [ $ index ] -> equals ( '[' ) ) { return false ; } static $ disallowedPrevTokens = [ ')' , ']' , '"' , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_STRING ] , [ T_STRING_VARNAME ] , [ T_VARIABLE ] , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return false ; } $ type = Tokens :: detectBlockType ( $ tokens [ $ index ] ) ; $ end = $ tokens -> findBlockEnd ( $ type [ 'type' ] , $ index ) ; $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ end ) ] ; return $ nextToken -> equals ( '=' ) ; } 
private function sortFlags ( array $ flags ) { usort ( $ flags , static function ( $ flag1 , $ flag2 ) { if ( $ flag1 === $ flag2 ) { return 0 ; } if ( 'b' === $ flag1 ) { return 1 ; } if ( 'b' === $ flag2 ) { return - 1 ; } if ( 't' === $ flag1 ) { return 1 ; } if ( 't' === $ flag2 ) { return - 1 ; } return $ flag1 < $ flag2 ? - 1 : 1 ; } ) ; return $ flags ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ this -> findCurlyBraceOpen ( $ tokens ) as $ index ) { if ( $ this -> isOverComplete ( $ tokens , $ index ) ) { $ this -> clearOverCompleteBraces ( $ tokens , $ index , $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ) ; } } } 
private function isOverComplete ( Tokens $ tokens , $ index ) { static $ whiteList = [ '{' , '}' , [ T_OPEN_TAG ] , ':' , ';' ] ; return $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equalsAny ( $ whiteList ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { 
protected function createConfigurationDefinition ( ) { $ fixerName = $ this -> getName ( ) ; return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'header' , 'Proper header content.' ) ) -> setAllowedTypes ( [ 'string' ] ) -> setNormalizer ( static function ( Options $ options , $ value ) use ( $ fixerName ) { if ( '' === trim ( $ value ) ) { return '' ; } if ( false !== strpos ( $ value , '*/' ) ) { throw new InvalidFixerConfigurationException ( $ fixerName , 'Cannot use \'*/\' in header.' ) ; } return $ value ; } ) -> getOption ( ) , ( new AliasedFixerOptionBuilder ( new FixerOptionBuilder ( 'comment_type' , 'Comment syntax type.' ) , 'commentType' ) ) -> setAllowedValues ( [ self :: HEADER_PHPDOC , self :: HEADER_COMMENT ] ) -> setDefault ( self :: HEADER_COMMENT ) -> getOption ( ) , ( new FixerOptionBuilder ( 'location' , 'The location of the inserted header.' ) ) -> setAllowedValues ( [ 'after_open' , 'after_declare_strict' ] ) -> setDefault ( 'after_declare_strict' ) -> getOption ( ) , ( new FixerOptionBuilder ( 'separate' , 'Whether the header should be separated from the file content with a new line.' ) ) -> setAllowedValues ( [ 'both' , 'top' , 'bottom' , 'none' ] ) -> setDefault ( 'both' ) -> getOption ( ) , ] ) ; } 
private function getHeaderAsComment ( ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ comment = ( self :: HEADER_COMMENT === $ this -> configuration [ 'comment_type' ] ? '/*' : '/**' ) . $ lineEnding ; $ lines = explode ( "\n" , str_replace ( "\r" , '' , $ this -> configuration [ 'header' ] ) ) ; foreach ( $ lines as $ line ) { $ comment .= rtrim ( ' * ' . $ line ) . $ lineEnding ; } return $ comment . ' */' ; } 
private function findHeaderCommentCurrentIndex ( Tokens $ tokens , $ headerNewIndex ) { $ index = $ tokens -> getNextNonWhitespace ( $ headerNewIndex ) ; return null === $ index || ! $ tokens [ $ index ] -> isComment ( ) ? null : $ index ; } 
private function findHeaderCommentInsertionIndex ( Tokens $ tokens ) { if ( 'after_open' === $ this -> configuration [ 'location' ] ) { return 1 ; } $ index = $ tokens -> getNextMeaningfulToken ( 0 ) ; if ( null === $ index ) { 
private function getLineBreakCount ( Tokens $ tokens , $ indexStart , $ indexEnd ) { $ lineCount = 0 ; for ( $ i = $ indexStart ; $ i < $ indexEnd ; ++ $ i ) { $ lineCount += substr_count ( $ tokens [ $ i ] -> getContent ( ) , "\n" ) ; } return $ lineCount ; } 
private function fixSpacing ( $ index , Tokens $ tokens ) { if ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_ARRAY_SQUARE_BRACE_OPEN ) ) { $ startIndex = $ index ; $ endIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ startIndex ) ; } else { $ startIndex = $ tokens -> getNextTokenOfKind ( $ index , [ '(' ] ) ; $ endIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startIndex ) ; } for ( $ i = $ endIndex - 1 ; $ i > $ startIndex ; -- $ i ) { $ i = $ this -> skipNonArrayElements ( $ i , $ tokens ) ; if ( $ tokens [ $ i ] -> equals ( ',' ) && ! $ tokens [ $ i + 1 ] -> isWhitespace ( ) ) { $ tokens -> insertAt ( $ i + 1 , new Token ( [ T_WHITESPACE , ' ' ] ) ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ currIndex = 0 ; while ( null !== $ currIndex ) { $ boundaries = $ this -> find ( 'dirname' , $ tokens , $ currIndex , $ tokens -> count ( ) - 1 ) ; if ( null === $ boundaries ) { return ; } list ( $ functionNameIndex , $ openParenthesis , $ closeParenthesis ) = $ boundaries ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { 
public function addBlank ( ) { $ matched = Preg :: match ( '/^([ \t]*\*)[^\r\n]*(\r?\n)$/' , $ this -> content , $ matches ) ; if ( 1 !== $ matched ) { return ; } $ this -> content .= $ matches [ 1 ] . $ matches [ 2 ] ; } 
public function resolve ( array $ options ) { if ( ! empty ( $ options ) && ! \ array_key_exists ( $ this -> root , $ options ) ) { $ names = array_map ( function ( FixerOptionInterface $ option ) { return $ option -> getName ( ) ; } , $ this -> resolver -> getOptions ( ) ) ; $ passedNames = array_keys ( $ options ) ; if ( ! empty ( array_diff ( $ passedNames , $ names ) ) ) { $ message = "Passing \"{$this->root}\" at the root of the configuration for rule \"{$this->fixerName}\" is deprecated and will not be supported in 3.0, use \"{$this->root}\" => array(...) option instead." ; if ( getenv ( 'PHP_CS_FIXER_FUTURE_MODE' ) ) { throw new \ RuntimeException ( "{$message}. This check was performed as `PHP_CS_FIXER_FUTURE_MODE` env var is set." ) ; } @ trigger_error ( $ message , E_USER_DEPRECATED ) ; $ options = [ $ this -> root => $ options ] ; } } return $ this -> resolver -> resolve ( $ options ) ; } 
public function generate ( ReportSummary $ reportSummary ) { if ( ! \ extension_loaded ( 'dom' ) ) { throw new \ RuntimeException ( 'Cannot generate report! `ext-dom` is not available!' ) ; } $ dom = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; 
private function createAppliedFixersElement ( $ dom , array $ fixResult ) { $ appliedFixersXML = $ dom -> createElement ( 'applied_fixers' ) ; foreach ( $ fixResult [ 'appliedFixers' ] as $ appliedFixer ) { $ appliedFixerXML = $ dom -> createElement ( 'applied_fixer' ) ; $ appliedFixerXML -> setAttribute ( 'name' , $ appliedFixer ) ; $ appliedFixersXML -> appendChild ( $ appliedFixerXML ) ; } return $ appliedFixersXML ; } 
private function createDiffElement ( \ DOMDocument $ dom , array $ fixResult ) { $ diffXML = $ dom -> createElement ( 'diff' ) ; $ diffXML -> appendChild ( $ dom -> createCDATASection ( $ fixResult [ 'diff' ] ) ) ; return $ diffXML ; } 
private function createTimeElement ( $ time , \ DOMDocument $ dom ) { $ time = round ( $ time / 1000 , 3 ) ; $ timeXML = $ dom -> createElement ( 'time' ) ; $ timeXML -> setAttribute ( 'unit' , 's' ) ; $ timeTotalXML = $ dom -> createElement ( 'total' ) ; $ timeTotalXML -> setAttribute ( 'value' , ( string ) $ time ) ; $ timeXML -> appendChild ( $ timeTotalXML ) ; return $ timeXML ; } 
private function createMemoryElement ( $ memory , \ DOMDocument $ dom ) { $ memory = round ( $ memory / 1024 / 1024 , 3 ) ; $ memoryXML = $ dom -> createElement ( 'memory' ) ; $ memoryXML -> setAttribute ( 'value' , ( string ) $ memory ) ; $ memoryXML -> setAttribute ( 'unit' , 'MB' ) ; return $ memoryXML ; } 
public function getCustomTokens ( ) { return [ CT :: T_CURLY_CLOSE , CT :: T_DOLLAR_CLOSE_CURLY_BRACES , CT :: T_DYNAMIC_PROP_BRACE_OPEN , CT :: T_DYNAMIC_PROP_BRACE_CLOSE , CT :: T_DYNAMIC_VAR_BRACE_OPEN , CT :: T_DYNAMIC_VAR_BRACE_CLOSE , CT :: T_ARRAY_INDEX_CURLY_BRACE_OPEN , CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE , CT :: T_GROUP_IMPORT_BRACE_OPEN , CT :: T_GROUP_IMPORT_BRACE_CLOSE , ] ; } 
public function process ( Tokens $ tokens , Token $ token , $ index ) { $ this -> transformIntoCurlyCloseBrace ( $ tokens , $ token , $ index ) ; $ this -> transformIntoDollarCloseBrace ( $ tokens , $ token , $ index ) ; $ this -> transformIntoDynamicPropBraces ( $ tokens , $ token , $ index ) ; $ this -> transformIntoDynamicVarBraces ( $ tokens , $ token , $ index ) ; $ this -> transformIntoCurlyIndexBraces ( $ tokens , $ token , $ index ) ; if ( \ PHP_VERSION_ID >= 70000 ) { $ this -> transformIntoGroupUseBraces ( $ tokens , $ token , $ index ) ; } } 
private function transformIntoCurlyCloseBrace ( Tokens $ tokens , Token $ token , $ index ) { if ( ! $ token -> isGivenKind ( T_CURLY_OPEN ) ) { return ; } $ level = 1 ; $ nestIndex = $ index ; while ( 0 < $ level ) { ++ $ nestIndex ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { 
private function fixAssertNegative ( Tokens $ tokens , $ index , $ method ) { static $ map = [ 'false' => 'assertNotFalse' , 'null' => 'assertNotNull' , 'true' => 'assertNotTrue' , ] ; return $ this -> fixAssert ( $ map , $ tokens , $ index , $ method ) ; } 
private function fixAssertPositive ( Tokens $ tokens , $ index , $ method ) { static $ map = [ 'false' => 'assertFalse' , 'null' => 'assertNull' , 'true' => 'assertTrue' , ] ; return $ this -> fixAssert ( $ map , $ tokens , $ index , $ method ) ; } 
private function fixAssert ( array $ map , Tokens $ tokens , $ index , $ method ) { $ sequence = $ tokens -> findSequence ( [ [ T_STRING , $ method ] , '(' , ] , $ index ) ; if ( null === $ sequence ) { return null ; } $ sequenceIndexes = array_keys ( $ sequence ) ; $ operatorIndex = $ tokens -> getPrevMeaningfulToken ( $ sequenceIndexes [ 0 ] ) ; $ referenceIndex = $ tokens -> getPrevMeaningfulToken ( $ operatorIndex ) ; if ( ! ( $ tokens [ $ operatorIndex ] -> equals ( [ T_OBJECT_OPERATOR , '->' ] ) && $ tokens [ $ referenceIndex ] -> equals ( [ T_VARIABLE , '$this' ] ) ) && ! ( $ tokens [ $ operatorIndex ] -> equals ( [ T_DOUBLE_COLON , '::' ] ) && $ tokens [ $ referenceIndex ] -> equals ( [ T_STRING , 'self' ] ) ) && ! ( $ tokens [ $ operatorIndex ] -> equals ( [ T_DOUBLE_COLON , '::' ] ) && $ tokens [ $ referenceIndex ] -> equals ( [ T_STATIC , 'static' ] ) ) ) { return null ; } $ sequenceIndexes [ 2 ] = $ tokens -> getNextMeaningfulToken ( $ sequenceIndexes [ 1 ] ) ; $ firstParameterToken = $ tokens [ $ sequenceIndexes [ 2 ] ] ; if ( ! $ firstParameterToken -> isNativeConstant ( ) ) { return $ sequenceIndexes [ 2 ] ; } $ sequenceIndexes [ 3 ] = $ tokens -> getNextMeaningfulToken ( $ sequenceIndexes [ 2 ] ) ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_FUNCTION ) ) { continue ; } $ index = $ tokens -> getNextTokenOfKind ( $ index , [ ';' , '{' ] ) ; if ( $ tokens [ $ index ] -> equals ( '{' ) ) { $ this -> fixFunction ( $ tokens , $ index , $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ) ; } } } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; foreach ( $ this -> configuration [ 'replacements' ] as $ functionName => $ replacement ) { $ this -> configuration [ 'replacements' ] [ $ functionName ] = [ 'alternativeName' => $ replacement , 'argumentCount' => self :: $ argumentCounts [ $ functionName ] , ] ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ argumentsAnalyzer = new ArgumentsAnalyzer ( ) ; foreach ( $ this -> configuration [ 'replacements' ] as $ functionIdentity => $ functionReplacement ) { if ( $ functionIdentity === $ functionReplacement [ 'alternativeName' ] ) { continue ; } $ currIndex = 0 ; while ( null !== $ currIndex ) { 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolverRootless ( 'replacements' , [ ( new FixerOptionBuilder ( 'replacements' , 'Mapping between replaced functions with the new ones.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ static function ( $ value ) { foreach ( $ value as $ functionName => $ replacement ) { if ( ! \ array_key_exists ( $ functionName , self :: $ argumentCounts ) ) { throw new InvalidOptionsException ( sprintf ( 'Function "%s" is not handled by the fixer.' , $ functionName ) ) ; } if ( ! \ is_string ( $ replacement ) ) { throw new InvalidOptionsException ( sprintf ( 'Replacement for function "%s" must be a string, "%s" given.' , $ functionName , \ is_object ( $ replacement ) ? \ get_class ( $ replacement ) : \ gettype ( $ replacement ) ) ) ; } } return true ; } ] ) -> setDefault ( [ 'getrandmax' => 'mt_getrandmax' , 'rand' => 'mt_rand' , 'srand' => 'mt_srand' , ] ) -> getOption ( ) , ] , $ this -> getName ( ) ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokensCount = \ count ( $ tokens ) ; for ( $ index = 0 ; $ index < $ tokensCount ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_CLASS ) ) { continue ; } $ classOpen = $ tokens -> getNextTokenOfKind ( $ index , [ '{' ] ) ; $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; $ classIsFinal = $ prevToken -> isGivenKind ( T_FINAL ) ; $ this -> fixClass ( $ tokens , $ classOpen , $ classIsFinal ) ; } } 
private function isPrivateMethod ( Tokens $ tokens , $ index , $ classOpenIndex ) { $ index = max ( $ classOpenIndex + 1 , $ tokens -> getPrevTokenOfKind ( $ index , [ ';' , '{' , '}' ] ) ) ; while ( ! $ tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_PRIVATE ) ) { return true ; } ++ $ index ; } return false ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ content = $ token -> getContent ( ) ; 
private function moveParamAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ params = $ doc -> getAnnotationsOfType ( 'param' ) ; 
private function moveReturnAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ returns = $ doc -> getAnnotationsOfType ( 'return' ) ; 
public function calculate ( $ isDryRun , $ hasChangedFiles , $ hasInvalidErrors , $ hasExceptionErrors ) { $ exitStatus = 0 ; if ( $ isDryRun ) { if ( $ hasChangedFiles ) { $ exitStatus |= self :: EXIT_STATUS_FLAG_HAS_CHANGED_FILES ; } if ( $ hasInvalidErrors ) { $ exitStatus |= self :: EXIT_STATUS_FLAG_HAS_INVALID_FILES ; } } if ( $ hasExceptionErrors ) { $ exitStatus |= self :: EXIT_STATUS_FLAG_EXCEPTION_IN_APP ; } return $ exitStatus ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ ending = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ lastIndex = $ tokens -> count ( ) - 1 ; for ( $ index = $ lastIndex ; $ index >= 0 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_NAMESPACE ) ) { continue ; } $ semicolonIndex = $ tokens -> getNextTokenOfKind ( $ index , [ ';' , '{' , [ T_CLOSE_TAG ] ] ) ; $ semicolonToken = $ tokens [ $ semicolonIndex ] ; if ( ! isset ( $ tokens [ $ semicolonIndex + 1 ] ) || ! $ semicolonToken -> equals ( ';' ) ) { continue ; } $ nextIndex = $ semicolonIndex + 1 ; $ nextToken = $ tokens [ $ nextIndex ] ; if ( ! $ nextToken -> isWhitespace ( ) ) { $ tokens -> insertAt ( $ semicolonIndex + 1 , new Token ( [ T_WHITESPACE , $ ending . $ ending ] ) ) ; } else { $ tokens [ $ nextIndex ] = new Token ( [ T_WHITESPACE , ( $ nextIndex === $ lastIndex ? $ ending : $ ending . $ ending ) . ltrim ( $ nextToken -> getContent ( ) ) , ] ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; if ( PhpUnitTargetVersion :: fulfills ( $ this -> configuration [ 'target' ] , PhpUnitTargetVersion :: VERSION_6_0 ) ) { $ this -> originalClassRegEx = '/^PHPUnit_\w+$/i' ; } elseif ( PhpUnitTargetVersion :: fulfills ( $ this -> configuration [ 'target' ] , PhpUnitTargetVersion :: VERSION_5_7 ) ) { $ this -> originalClassRegEx = '/^PHPUnit_Framework_TestCase|PHPUnit_Framework_Assert|PHPUnit_Framework_BaseTestListener|PHPUnit_Framework_TestListener$/i' ; } else { $ this -> originalClassRegEx = '/^PHPUnit_Framework_TestCase$/i' ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ importedOriginalClassesMap = [ ] ; $ currIndex = 0 ; while ( null !== $ currIndex ) { $ currIndex = $ tokens -> getNextTokenOfKind ( $ currIndex , [ [ T_STRING ] ] ) ; if ( null === $ currIndex ) { break ; } $ originalClass = $ tokens [ $ currIndex ] -> getContent ( ) ; if ( 1 !== Preg :: match ( $ this -> originalClassRegEx , $ originalClass ) ) { ++ $ currIndex ; continue ; } $ substituteTokens = $ this -> generateReplacement ( $ originalClass ) ; $ tokens -> clearAt ( $ currIndex ) ; $ tokens -> insertAt ( $ currIndex , isset ( $ importedOriginalClassesMap [ $ originalClass ] ) ? $ substituteTokens [ $ substituteTokens -> getSize ( ) - 1 ] : $ substituteTokens ) ; $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ currIndex ) ; if ( $ tokens [ $ prevIndex ] -> isGivenKind ( T_USE ) ) { $ importedOriginalClassesMap [ $ originalClass ] = true ; } elseif ( $ tokens [ $ prevIndex ] -> isGivenKind ( T_NS_SEPARATOR ) ) { $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ prevIndex ) ; if ( $ tokens [ $ prevIndex ] -> isGivenKind ( T_USE ) ) { $ importedOriginalClassesMap [ $ originalClass ] = true ; } } } } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'target' , 'Target version of PHPUnit.' ) ) -> setAllowedTypes ( [ 'string' ] ) -> setAllowedValues ( [ PhpUnitTargetVersion :: VERSION_4_8 , PhpUnitTargetVersion :: VERSION_5_7 , PhpUnitTargetVersion :: VERSION_6_0 , PhpUnitTargetVersion :: VERSION_NEWEST ] ) -> setDefault ( PhpUnitTargetVersion :: VERSION_NEWEST ) -> getOption ( ) , ] ) ; } 
private function generateReplacement ( $ originalClassName ) { $ parts = explode ( '_' , $ originalClassName ) ; $ tokensArray = [ ] ; while ( ! empty ( $ parts ) ) { $ tokensArray [ ] = new Token ( [ T_STRING , array_shift ( $ parts ) ] ) ; if ( ! empty ( $ parts ) ) { $ tokensArray [ ] = new Token ( [ T_NS_SEPARATOR , '\\' ] ) ; } } return Tokens :: fromArray ( $ tokensArray ) ; } 
public static function calculateBitmask ( array $ options ) { $ bitmask = 0 ; foreach ( $ options as $ optionName ) { if ( \ defined ( $ optionName ) ) { $ bitmask |= \ constant ( $ optionName ) ; } } return $ bitmask ; } 
public static function camelCaseToUnderscore ( $ string ) { return Preg :: replaceCallback ( '/(^|[a-z0-9])([A-Z])/' , static function ( array $ matches ) { return strtolower ( '' !== $ matches [ 1 ] ? $ matches [ 1 ] . '_' . $ matches [ 2 ] : $ matches [ 2 ] ) ; } , $ string ) ; } 
public static function calculateTrailingWhitespaceIndent ( Token $ token ) { if ( ! $ token -> isWhitespace ( ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The given token must be whitespace, got "%s".' , $ token -> getName ( ) ) ) ; } $ str = strrchr ( str_replace ( [ "\r\n" , "\r" ] , "\n" , $ token -> getContent ( ) ) , "\n" ) ; if ( false === $ str ) { return '' ; } return ltrim ( $ str , "\n" ) ; } 
public static function stableSort ( array $ elements , callable $ getComparedValue , callable $ compareValues ) { array_walk ( $ elements , static function ( & $ element , $ index ) use ( $ getComparedValue ) { $ element = [ $ element , $ index , $ getComparedValue ( $ element ) ] ; } ) ; usort ( $ elements , static function ( $ a , $ b ) use ( $ compareValues ) { $ comparison = $ compareValues ( $ a [ 2 ] , $ b [ 2 ] ) ; if ( 0 !== $ comparison ) { return $ comparison ; } return self :: cmpInt ( $ a [ 1 ] , $ b [ 1 ] ) ; } ) ; return array_map ( static function ( array $ item ) { return $ item [ 0 ] ; } , $ elements ) ; } 
public static function sortFixers ( array $ fixers ) { 
public static function naturalLanguageJoinWithBackticks ( array $ names ) { if ( empty ( $ names ) ) { throw new \ InvalidArgumentException ( 'Array of names cannot be empty' ) ; } $ names = array_map ( static function ( $ name ) { return sprintf ( '`%s`' , $ name ) ; } , $ names ) ; $ last = array_pop ( $ names ) ; if ( $ names ) { return implode ( ', ' , $ names ) . ' and ' . $ last ; } return $ last ; } 
public function getEnd ( ) { $ reachedContent = false ; foreach ( $ this -> doc -> getLines ( ) as $ index => $ line ) { 
public function registerCustomFixers ( $ fixers ) { if ( false === \ is_array ( $ fixers ) && false === $ fixers instanceof \ Traversable ) { throw new \ InvalidArgumentException ( sprintf ( 'Argument must be an array or a Traversable, got "%s".' , \ is_object ( $ fixers ) ? \ get_class ( $ fixers ) : \ gettype ( $ fixers ) ) ) ; } foreach ( $ fixers as $ fixer ) { $ this -> addCustomFixer ( $ fixer ) ; } return $ this ; } 
public function setFinder ( $ finder ) { if ( false === \ is_array ( $ finder ) && false === $ finder instanceof \ Traversable ) { throw new \ InvalidArgumentException ( sprintf ( 'Argument must be an array or a Traversable, got "%s".' , \ is_object ( $ finder ) ? \ get_class ( $ finder ) : \ gettype ( $ finder ) ) ) ; } $ this -> finder = $ finder ; return $ this ; } 
protected function replacePlaceholder ( Tokens $ tokens ) { $ tmpCode = $ tokens -> generateCode ( ) ; for ( $ j = 0 ; $ j <= $ this -> deepestLevel ; ++ $ j ) { $ placeholder = sprintf ( self :: ALIGNABLE_PLACEHOLDER , $ j ) ; if ( false === strpos ( $ tmpCode , $ placeholder ) ) { continue ; } $ lines = explode ( "\n" , $ tmpCode ) ; $ linesWithPlaceholder = [ ] ; $ blockSize = 0 ; $ linesWithPlaceholder [ $ blockSize ] = [ ] ; foreach ( $ lines as $ index => $ line ) { if ( substr_count ( $ line , $ placeholder ) > 0 ) { $ linesWithPlaceholder [ $ blockSize ] [ ] = $ index ; } else { ++ $ blockSize ; $ linesWithPlaceholder [ $ blockSize ] = [ ] ; } } foreach ( $ linesWithPlaceholder as $ group ) { if ( \ count ( $ group ) < 1 ) { continue ; } $ rightmostSymbol = 0 ; foreach ( $ group as $ index ) { $ rightmostSymbol = max ( $ rightmostSymbol , strpos ( utf8_decode ( $ lines [ $ index ] ) , $ placeholder ) ) ; } foreach ( $ group as $ index ) { $ line = $ lines [ $ index ] ; $ currentSymbol = strpos ( utf8_decode ( $ line ) , $ placeholder ) ; $ delta = abs ( $ rightmostSymbol - $ currentSymbol ) ; if ( $ delta > 0 ) { $ line = str_replace ( $ placeholder , str_repeat ( ' ' , $ delta ) . $ placeholder , $ line ) ; $ lines [ $ index ] = $ line ; } } } $ tmpCode = str_replace ( $ placeholder , '' , implode ( "\n" , $ lines ) ) ; } return $ tmpCode ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ content = $ token -> getContent ( ) ; $ content = $ this -> fixStart ( $ content ) ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } $ doc = new DocBlock ( $ token -> getContent ( ) ) ; $ this -> fixDescription ( $ doc ) ; $ this -> fixAnnotations ( $ doc ) ; $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , $ doc -> getContent ( ) ] ) ; } } 
private function fixDescription ( DocBlock $ doc ) { foreach ( $ doc -> getLines ( ) as $ index => $ line ) { if ( $ line -> containsATag ( ) ) { break ; } if ( $ line -> containsUsefulContent ( ) ) { $ next = $ doc -> getLine ( $ index + 1 ) ; if ( $ next -> containsATag ( ) ) { $ line -> addBlank ( ) ; break ; } } } } 
private function fixAnnotations ( DocBlock $ doc ) { foreach ( $ doc -> getAnnotations ( ) as $ index => $ annotation ) { $ next = $ doc -> getAnnotation ( $ index + 1 ) ; if ( null === $ next ) { break ; } if ( true === $ next -> getTag ( ) -> valid ( ) ) { if ( TagComparator :: shouldBeTogether ( $ annotation -> getTag ( ) , $ next -> getTag ( ) ) ) { $ this -> ensureAreTogether ( $ doc , $ annotation , $ next ) ; } else { $ this -> ensureAreSeparate ( $ doc , $ annotation , $ next ) ; } } } return $ doc -> getContent ( ) ; } 
private function ensureAreTogether ( DocBlock $ doc , Annotation $ first , Annotation $ second ) { $ pos = $ first -> getEnd ( ) ; $ final = $ second -> getStart ( ) ; for ( $ pos = $ pos + 1 ; $ pos < $ final ; ++ $ pos ) { $ doc -> getLine ( $ pos ) -> remove ( ) ; } } 
private function ensureAreSeparate ( DocBlock $ doc , Annotation $ first , Annotation $ second ) { $ pos = $ first -> getEnd ( ) ; $ final = $ second -> getStart ( ) - 1 ; 
public function getInvalidErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_INVALID === $ error -> getType ( ) ; } ) ; } 
public function getExceptionErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_EXCEPTION === $ error -> getType ( ) ; } ) ; } 
public function getLintErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_LINT === $ error -> getType ( ) ; } ) ; } 
public function getDefinition ( ) { return new FixerDefinition ( 'Error control operator should be added to deprecation notices and/or removed from other cases.' , [ new CodeSample ( "<?php\ntrigger_error('Warning.', E_USER_DEPRECATED);\n" ) , new CodeSample ( "<?php\n@mkdir(\$dir);\n@unlink(\$path);\n" , [ self :: OPTION_NOISE_REMAINING_USAGES => true ] ) , new CodeSample ( "<?php\n@mkdir(\$dir);\n@unlink(\$path);\n" , [ self :: OPTION_NOISE_REMAINING_USAGES => true , self :: OPTION_NOISE_REMAINING_USAGES_EXCLUDE => [ 'unlink' ] , ] ) , ] , null , 'Risky because adding/removing `@` might cause changes to code behaviour or if `trigger_error` function is overridden.' ) ; } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( self :: OPTION_MUTE_DEPRECATION_ERROR , 'Whether to add `@` in deprecation notices.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( true ) -> getOption ( ) , ( new FixerOptionBuilder ( self :: OPTION_NOISE_REMAINING_USAGES , 'Whether to remove `@` in remaining usages.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( false ) -> getOption ( ) , ( new FixerOptionBuilder ( self :: OPTION_NOISE_REMAINING_USAGES_EXCLUDE , 'List of global functions to exclude from removing `@`' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setDefault ( [ ] ) -> getOption ( ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ functionsAnalyzer = new FunctionsAnalyzer ( ) ; $ excludedFunctions = array_map ( function ( $ function ) { return strtolower ( $ function ) ; } , $ this -> configuration [ self :: OPTION_NOISE_REMAINING_USAGES_EXCLUDE ] ) ; for ( $ index = $ tokens -> count ( ) - 1 ; $ index >= 0 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( $ this -> configuration [ self :: OPTION_NOISE_REMAINING_USAGES ] && $ token -> equals ( '@' ) ) { $ tokens -> clearAt ( $ index ) ; continue ; } if ( ! $ functionsAnalyzer -> isGlobalFunctionCall ( $ tokens , $ index ) ) { continue ; } $ functionIndex = $ index ; $ startIndex = $ index ; $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ prevIndex ] -> isGivenKind ( T_NS_SEPARATOR ) ) { $ startIndex = $ prevIndex ; $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ startIndex ) ; } $ index = $ prevIndex ; if ( $ this -> isDeprecationErrorCall ( $ tokens , $ functionIndex ) ) { if ( ! $ this -> configuration [ self :: OPTION_MUTE_DEPRECATION_ERROR ] ) { continue ; } if ( $ tokens [ $ prevIndex ] -> equals ( '@' ) ) { continue ; } $ tokens -> insertAt ( $ startIndex , new Token ( '@' ) ) ; continue ; } if ( ! $ tokens [ $ prevIndex ] -> equals ( '@' ) ) { continue ; } if ( $ this -> configuration [ self :: OPTION_NOISE_REMAINING_USAGES ] && ! \ in_array ( $ tokens [ $ functionIndex ] -> getContent ( ) , $ excludedFunctions , true ) ) { $ tokens -> clearAt ( $ index ) ; } } } 
private function isDeprecationErrorCall ( Tokens $ tokens , $ index ) { if ( 'trigger_error' !== strtolower ( $ tokens [ $ index ] -> getContent ( ) ) ) { return false ; } $ endBraceIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ tokens -> getNextTokenOfKind ( $ index , [ T_STRING , '(' ] ) ) ; $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ endBraceIndex ) ; if ( $ tokens [ $ prevIndex ] -> equals ( ',' ) ) { $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ prevIndex ) ; } return $ tokens [ $ prevIndex ] -> equals ( [ T_STRING , 'E_USER_DEPRECATED' ] ) ; } 
public function getDefinition ( ) { return new FixerDefinition ( 'Add leading `\` before constant invocation of internal constant to speed up resolving. Constant name match is case-sensitive, except for `null`, `false` and `true`.' , [ new CodeSample ( '<?php var_dump(PHP_VERSION, M_PI, MY_CUSTOM_PI);' . PHP_EOL ) , new CodeSample ( '<?php namespace space1 { echo PHP_VERSION; } namespace { echo M_PI; } ' , [ 'scope' => 'namespaced' ] ) , new CodeSample ( '<?php var_dump(PHP_VERSION, M_PI, MY_CUSTOM_PI);' . PHP_EOL , [ 'include' => [ 'MY_CUSTOM_PI' , ] , ] ) , new CodeSample ( '<?php var_dump(PHP_VERSION, M_PI, MY_CUSTOM_PI);' . PHP_EOL , [ 'fix_built_in' => false , 'include' => [ 'MY_CUSTOM_PI' , ] , ] ) , new CodeSample ( '<?php var_dump(PHP_VERSION, M_PI, MY_CUSTOM_PI);' . PHP_EOL , [ 'exclude' => [ 'M_PI' , ] , ] ) , ] , null , 'Risky when any of the constants are namespaced or overridden.' ) ; } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ uniqueConfiguredExclude = array_unique ( $ this -> configuration [ 'exclude' ] ) ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { if ( 'all' === $ this -> configuration [ 'scope' ] ) { $ this -> fixConstantInvocations ( $ tokens , 0 , \ count ( $ tokens ) - 1 ) ; return ; } $ namespaces = ( new NamespacesAnalyzer ( ) ) -> getDeclarations ( $ tokens ) ; 
protected function createConfigurationDefinition ( ) { $ constantChecker = static function ( $ value ) { foreach ( $ value as $ constantName ) { if ( ! \ is_string ( $ constantName ) || '' === trim ( $ constantName ) || trim ( $ constantName ) !== $ constantName ) { throw new InvalidOptionsException ( sprintf ( 'Each element must be a non-empty, trimmed string, got "%s" instead.' , \ is_object ( $ constantName ) ? \ get_class ( $ constantName ) : \ gettype ( $ constantName ) ) ) ; } } return true ; } ; return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'fix_built_in' , 'Whether to fix constants returned by `get_defined_constants`. User constants are not accounted in this list and must be specified in the include one.' ) ) -> setAllowedTypes ( [ 'bool' ] ) -> setDefault ( true ) -> getOption ( ) , ( new FixerOptionBuilder ( 'include' , 'List of additional constants to fix.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ $ constantChecker ] ) -> setDefault ( [ ] ) -> getOption ( ) , ( new FixerOptionBuilder ( 'exclude' , 'List of constants to ignore.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ $ constantChecker ] ) -> setDefault ( [ 'null' , 'false' , 'true' ] ) -> getOption ( ) , ( new FixerOptionBuilder ( 'scope' , 'Only fix constant invocations that are made within a namespace or fix all.' ) ) -> setAllowedValues ( [ 'all' , 'namespaced' ] ) -> setDefault ( 'all' ) -> getOption ( ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ argumentsAnalyzer = new ArgumentsAnalyzer ( ) ; foreach ( $ this -> configuration [ 'assertions' ] as $ methodBefore ) { $ methodAfter = self :: $ assertionMap [ $ methodBefore ] ; for ( $ index = 0 , $ limit = $ tokens -> count ( ) ; $ index < $ limit ; ++ $ index ) { $ methodIndex = $ tokens -> getNextTokenOfKind ( $ index , [ [ T_STRING , $ methodBefore ] ] ) ; if ( null === $ methodIndex ) { break ; } $ operatorIndex = $ tokens -> getPrevMeaningfulToken ( $ methodIndex ) ; $ referenceIndex = $ tokens -> getPrevMeaningfulToken ( $ operatorIndex ) ; if ( ! ( $ tokens [ $ operatorIndex ] -> equals ( [ T_OBJECT_OPERATOR , '->' ] ) && $ tokens [ $ referenceIndex ] -> equals ( [ T_VARIABLE , '$this' ] ) ) && ! ( $ tokens [ $ operatorIndex ] -> equals ( [ T_DOUBLE_COLON , '::' ] ) && $ tokens [ $ referenceIndex ] -> equals ( [ T_STRING , 'self' ] ) ) && ! ( $ tokens [ $ operatorIndex ] -> equals ( [ T_DOUBLE_COLON , '::' ] ) && $ tokens [ $ referenceIndex ] -> equals ( [ T_STATIC , 'static' ] ) ) ) { continue ; } $ openingParenthesisIndex = $ tokens -> getNextMeaningfulToken ( $ methodIndex ) ; $ argumentsCount = $ argumentsAnalyzer -> countArguments ( $ tokens , $ openingParenthesisIndex , $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ openingParenthesisIndex ) ) ; if ( 2 === $ argumentsCount || 3 === $ argumentsCount ) { $ tokens [ $ methodIndex ] = new Token ( [ T_STRING , $ methodAfter ] ) ; } $ index = $ methodIndex ; } } } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolverRootless ( 'assertions' , [ ( new FixerOptionBuilder ( 'assertions' , 'List of assertion methods to fix.' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ new AllowedValueSubset ( array_keys ( self :: $ assertionMap ) ) ] ) -> setDefault ( [ 'assertAttributeEquals' , 'assertAttributeNotEquals' , 'assertEquals' , 'assertNotEquals' , ] ) -> getOption ( ) , ] , $ this -> getName ( ) ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; $ uses = array_reverse ( $ tokensAnalyzer -> getImportUseIndexes ( ) ) ; foreach ( $ uses as $ index ) { $ endIndex = $ tokens -> getNextTokenOfKind ( $ index , [ ';' , [ T_CLOSE_TAG ] ] ) ; $ groupClose = $ tokens -> getPrevMeaningfulToken ( $ endIndex ) ; if ( $ tokens [ $ groupClose ] -> isGivenKind ( CT :: T_GROUP_IMPORT_BRACE_CLOSE ) ) { $ this -> fixGroupUse ( $ tokens , $ index , $ endIndex ) ; } else { $ this -> fixMultipleUse ( $ tokens , $ index , $ endIndex ) ; } } } 
private function getGroupDeclaration ( Tokens $ tokens , $ index ) { $ groupPrefix = '' ; $ comment = '' ; for ( $ i = $ index + 1 ; ; ++ $ i ) { if ( $ tokens [ $ i ] -> isGivenKind ( CT :: T_GROUP_IMPORT_BRACE_OPEN ) ) { $ groupOpenIndex = $ i ; break ; } if ( $ tokens [ $ i ] -> isComment ( ) ) { $ comment .= $ tokens [ $ i ] -> getContent ( ) ; if ( ! $ tokens [ $ i - 1 ] -> isWhitespace ( ) && ! $ tokens [ $ i + 1 ] -> isWhitespace ( ) ) { $ groupPrefix .= ' ' ; } continue ; } if ( $ tokens [ $ i ] -> isWhitespace ( ) ) { $ groupPrefix .= ' ' ; continue ; } $ groupPrefix .= $ tokens [ $ i ] -> getContent ( ) ; } return [ rtrim ( $ groupPrefix ) , $ groupOpenIndex , $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_GROUP_IMPORT_BRACE , $ groupOpenIndex ) , $ comment , ] ; } 
private function getGroupStatements ( Tokens $ tokens , $ groupPrefix , $ groupOpenIndex , $ groupCloseIndex , $ comment ) { $ statements = [ ] ; $ statement = $ groupPrefix ; for ( $ i = $ groupOpenIndex + 1 ; $ i <= $ groupCloseIndex ; ++ $ i ) { $ token = $ tokens [ $ i ] ; if ( $ token -> equals ( ',' ) && $ tokens [ $ tokens -> getNextMeaningfulToken ( $ i ) ] -> equals ( [ CT :: T_GROUP_IMPORT_BRACE_CLOSE ] ) ) { continue ; } if ( $ token -> equalsAny ( [ ',' , [ CT :: T_GROUP_IMPORT_BRACE_CLOSE ] ] ) ) { $ statements [ ] = 'use' . $ statement . ';' ; $ statement = $ groupPrefix ; continue ; } if ( $ token -> isWhitespace ( ) ) { $ j = $ tokens -> getNextMeaningfulToken ( $ i ) ; if ( $ tokens [ $ j ] -> equals ( [ T_AS ] ) ) { $ statement .= ' as ' ; $ i += 2 ; } elseif ( $ tokens [ $ j ] -> equals ( [ T_FUNCTION ] ) ) { $ statement = ' function' . $ statement ; $ i += 2 ; } elseif ( $ tokens [ $ j ] -> equals ( [ T_CONST ] ) ) { $ statement = ' const' . $ statement ; $ i += 2 ; } if ( $ token -> isWhitespace ( " \t" ) || '//' !== substr ( $ tokens [ $ i - 1 ] -> getContent ( ) , 0 , 2 ) ) { continue ; } } $ statement .= $ token -> getContent ( ) ; } if ( '' !== $ comment ) { $ statements [ 0 ] .= ' ' . $ comment ; } return $ statements ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokenCount = \ count ( $ tokens ) ; for ( $ index = 1 ; $ index < $ tokenCount ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) ) { continue ; } $ functionOpenIndex = $ tokens -> getNextTokenOfKind ( $ index , [ '{' , ';' ] ) ; if ( $ tokens [ $ functionOpenIndex ] -> equals ( ';' ) ) { 
private function fixFunction ( Tokens $ tokens , $ functionIndex , $ functionOpenIndex , $ functionCloseIndex ) { static $ riskyKinds = [ CT :: T_DYNAMIC_VAR_BRACE_OPEN , 
private function simplifyReturnStatement ( Tokens $ tokens , $ assignVarIndex , $ assignVarOperatorIndex , $ returnIndex , $ returnVarEndIndex ) { $ inserted = 0 ; $ originalIndent = $ tokens [ $ assignVarIndex - 1 ] -> isWhitespace ( ) ? $ tokens [ $ assignVarIndex - 1 ] -> getContent ( ) : null ; 
private function isSuperGlobal ( Token $ token ) { static $ superNames = [ '$_COOKIE' => true , '$_ENV' => true , '$_FILES' => true , '$_GET' => true , '$_POST' => true , '$_REQUEST' => true , '$_SERVER' => true , '$_SESSION' => true , '$GLOBALS' => true , ] ; if ( ! $ token -> isGivenKind ( T_VARIABLE ) ) { return false ; } return isset ( $ superNames [ strtoupper ( $ token -> getContent ( ) ) ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ argumentsAnalyzer = new ArgumentsAnalyzer ( ) ; $ index = 0 ; $ end = $ tokens -> count ( ) - 1 ; while ( true ) { $ candidate = $ this -> find ( 'fopen' , $ tokens , $ index , $ end ) ; if ( null === $ candidate ) { break ; } $ index = $ candidate [ 1 ] ; 
protected function isValidModeString ( $ mode ) { $ modeLength = \ strlen ( $ mode ) ; if ( $ modeLength < 1 || $ modeLength > 13 ) { 
private function replaceNameOccurrences ( Tokens $ tokens , $ namespace , $ name , $ startIndex , $ endIndex ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; $ insideMethodSignatureUntil = null ; for ( $ i = $ startIndex ; $ i < $ endIndex ; ++ $ i ) { if ( $ i === $ insideMethodSignatureUntil ) { $ insideMethodSignatureUntil = null ; } $ token = $ tokens [ $ i ] ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isGivenKind ( T_LOGICAL_AND ) ) { $ tokens [ $ index ] = new Token ( [ T_BOOLEAN_AND , '&&' ] ) ; } elseif ( $ token -> isGivenKind ( T_LOGICAL_OR ) ) { $ tokens [ $ index ] = new Token ( [ T_BOOLEAN_OR , '||' ] ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ this -> clearIncludies ( $ tokens , $ this -> findIncludies ( $ tokens ) ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = 1 , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_COMMENT ) ) { continue ; } list ( $ blockStart , $ index , $ isEmpty ) = $ this -> getCommentBlock ( $ tokens , $ index ) ; if ( false === $ isEmpty ) { continue ; } for ( $ i = $ blockStart ; $ i <= $ index ; ++ $ i ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ i ) ; } } } 
private function getCommentBlock ( Tokens $ tokens , $ index ) { $ commentType = $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ; $ empty = $ this -> isEmptyComment ( $ tokens [ $ index ] -> getContent ( ) ) ; $ start = $ index ; $ count = \ count ( $ tokens ) ; ++ $ index ; for ( ; $ index < $ count ; ++ $ index ) { if ( $ tokens [ $ index ] -> isComment ( ) ) { if ( $ commentType !== $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ) { break ; } if ( $ empty ) { 
private function getLineBreakCount ( Tokens $ tokens , $ whiteStart , $ whiteEnd ) { $ lineCount = 0 ; for ( $ i = $ whiteStart ; $ i < $ whiteEnd ; ++ $ i ) { $ lineCount += Preg :: matchAll ( '/\R/u' , $ tokens [ $ i ] -> getContent ( ) , $ matches ) ; } return $ lineCount ; } 
private function isEmptyComment ( $ content ) { static $ mapper = [ self :: TYPE_HASH => '|^#\s*$|' , 
public function isCandidate ( Tokens $ tokens ) { return $ tokens -> isAnyTokenKindsFound ( [ T_CLASS , T_TRAIT ] ) && $ tokens -> isAnyTokenKindsFound ( [ T_PUBLIC , T_PROTECTED , T_PRIVATE , T_VAR ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = 0 , $ count = $ tokens -> count ( ) ; $ index < $ count ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( [ T_PUBLIC , T_PROTECTED , T_PRIVATE , T_VAR ] ) ) { continue ; } while ( true ) { $ varTokenIndex = $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( ! $ tokens [ $ index ] -> isGivenKind ( T_VARIABLE ) ) { break ; } $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> equals ( '=' ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( T_NS_SEPARATOR ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; } if ( $ tokens [ $ index ] -> equals ( [ T_STRING , 'null' ] , false ) ) { for ( $ i = $ varTokenIndex + 1 ; $ i <= $ index ; ++ $ i ) { if ( ! ( $ tokens [ $ i ] -> isWhitespace ( ) && false !== strpos ( $ tokens [ $ i ] -> getContent ( ) , "\n" ) ) && ! $ tokens [ $ i ] -> isComment ( ) ) { $ tokens -> clearAt ( $ i ) ; } } } ++ $ index ; } if ( ! $ tokens [ $ index ] -> equals ( ',' ) ) { break ; } } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokenCount = $ tokens -> count ( ) ; for ( $ index = 1 ; $ index < $ tokenCount ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_ISSET ) || $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equals ( '!' ) ) { continue ; } $ issetInfo = $ this -> getIssetInfo ( $ tokens , $ index ) ; $ issetCloseBraceIndex = end ( $ issetInfo ) ; 
private function getIssetInfo ( Tokens $ tokens , $ index ) { $ openIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ braceOpenCount = 1 ; $ meaningfulTokenIndexes = [ $ openIndex ] ; for ( $ i = $ openIndex + 1 ; ; ++ $ i ) { if ( $ tokens [ $ i ] -> isWhitespace ( ) || $ tokens [ $ i ] -> isComment ( ) ) { continue ; } $ meaningfulTokenIndexes [ ] = $ i ; if ( $ tokens [ $ i ] -> equals ( ')' ) ) { -- $ braceOpenCount ; if ( 0 === $ braceOpenCount ) { break ; } } elseif ( $ tokens [ $ i ] -> equals ( '(' ) ) { ++ $ braceOpenCount ; } } return $ meaningfulTokenIndexes ; } 
private function getTokenClones ( Tokens $ tokens , array $ indexes ) { $ clones = [ ] ; foreach ( $ indexes as $ i ) { $ clones [ ] = clone $ tokens [ $ i ] ; } return $ clones ; } 
public function isCandidate ( Tokens $ tokens ) { return $ tokens -> isTokenKindFound ( T_STRING ) && $ tokens -> isAnyTokenKindsFound ( [ T_FUNCTION , T_OBJECT_OPERATOR , T_DOUBLE_COLON ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ inClass = 0 ; $ tokenCount = \ count ( $ tokens ) ; for ( $ index = 1 ; $ index < $ tokenCount - 2 ; ++ $ index ) { if ( 0 === $ inClass && $ tokens [ $ index ] -> isClassy ( ) ) { $ inClass = 1 ; $ index = $ tokens -> getNextTokenOfKind ( $ index , [ '{' ] ) ; continue ; } if ( 0 !== $ inClass ) { if ( $ tokens [ $ index ] -> equals ( '{' ) ) { ++ $ inClass ; continue ; } if ( $ tokens [ $ index ] -> equals ( '}' ) ) { -- $ inClass ; continue ; } } if ( ! $ tokens [ $ index ] -> isGivenKind ( T_STRING ) ) { continue ; 
private function isFunctionSignature ( Tokens $ tokens , $ index ) { $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( ! $ tokens [ $ prevIndex ] -> isGivenKind ( T_FUNCTION ) ) { return false ; 
private function isMethodCall ( Tokens $ tokens , $ index ) { $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( ! $ tokens [ $ prevIndex ] -> equals ( [ T_OBJECT_OPERATOR , '->' ] ) ) { return false ; 
private function isStaticMethodCall ( Tokens $ tokens , $ index ) { $ prevIndex = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( ! $ tokens [ $ prevIndex ] -> isGivenKind ( T_DOUBLE_COLON ) ) { return false ; 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'comment_text' , 'The text to use in the added comment and to detect it.' ) ) -> setAllowedTypes ( [ 'string' ] ) -> setAllowedValues ( [ function ( $ value ) { if ( \ is_string ( $ value ) && Preg :: match ( '/\R/' , $ value ) ) { throw new InvalidOptionsException ( 'The comment text must not contain new lines.' ) ; } return true ; } , ] ) -> setNormalizer ( function ( Options $ options , $ value ) { return rtrim ( $ value ) ; } ) -> setDefault ( 'no break' ) -> getOption ( ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ position = \ count ( $ tokens ) - 1 ; $ position >= 0 ; -- $ position ) { if ( $ tokens [ $ position ] -> isGivenKind ( [ T_CASE , T_DEFAULT ] ) ) { $ this -> fixCase ( $ tokens , $ position ) ; } } } 
private function isNoBreakComment ( Token $ token ) { if ( ! $ token -> isComment ( ) ) { return false ; } $ text = preg_quote ( $ this -> configuration [ 'comment_text' ] , '~' ) ; return 1 === Preg :: match ( "~^((//|#)\\s*{$text}\\s*)|(/\\*\\*?\\s*{$text}\\s*\\*/)$~i" , $ token -> getContent ( ) ) ; } 
private function ensureNewLineAt ( Tokens $ tokens , $ position ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ content = $ lineEnding . $ this -> getIndentAt ( $ tokens , $ position ) ; $ whitespaceToken = $ tokens [ $ position - 1 ] ; if ( ! $ whitespaceToken -> isGivenKind ( T_WHITESPACE ) ) { if ( $ whitespaceToken -> isGivenKind ( T_OPEN_TAG ) ) { $ content = Preg :: replace ( '/\R/' , '' , $ content ) ; if ( ! Preg :: match ( '/\R/' , $ whitespaceToken -> getContent ( ) ) ) { $ tokens [ $ position - 1 ] = new Token ( [ T_OPEN_TAG , Preg :: replace ( '/\s+$/' , $ lineEnding , $ whitespaceToken -> getContent ( ) ) ] ) ; } } if ( '' !== $ content ) { $ tokens -> insertAt ( $ position , new Token ( [ T_WHITESPACE , $ content ] ) ) ; return $ position ; } return $ position - 1 ; } if ( $ tokens [ $ position - 2 ] -> isGivenKind ( T_OPEN_TAG ) && Preg :: match ( '/\R/' , $ tokens [ $ position - 2 ] -> getContent ( ) ) ) { $ content = Preg :: replace ( '/^\R/' , '' , $ content ) ; } if ( ! Preg :: match ( '/\R/' , $ whitespaceToken -> getContent ( ) ) ) { $ tokens [ $ position - 1 ] = new Token ( [ T_WHITESPACE , $ content ] ) ; } return $ position - 1 ; } 
private function getIndentAt ( Tokens $ tokens , $ position ) { while ( true ) { $ position = $ tokens -> getPrevTokenOfKind ( $ position , [ [ T_WHITESPACE ] ] ) ; if ( null === $ position ) { break ; } $ content = $ tokens [ $ position ] -> getContent ( ) ; $ prevToken = $ tokens [ $ position - 1 ] ; if ( $ prevToken -> isGivenKind ( T_OPEN_TAG ) && Preg :: match ( '/\R$/' , $ prevToken -> getContent ( ) ) ) { $ content = $ this -> whitespacesConfig -> getLineEnding ( ) . $ content ; } if ( Preg :: match ( '/\R([ \t]*)$/' , $ content , $ matches ) ) { return $ matches [ 1 ] ; } } return '' ; } 
private function getStructureEnd ( Tokens $ tokens , $ position ) { $ initialToken = $ tokens [ $ position ] ; if ( $ initialToken -> isGivenKind ( [ T_FOR , T_FOREACH , T_WHILE , T_IF , T_ELSEIF , T_SWITCH , T_FUNCTION ] ) ) { $ position = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ tokens -> getNextTokenOfKind ( $ position , [ '(' ] ) ) ; } elseif ( $ initialToken -> isGivenKind ( T_CLASS ) ) { $ openParenthesisPosition = $ tokens -> getNextMeaningfulToken ( $ position ) ; if ( '(' === $ tokens [ $ openParenthesisPosition ] -> getContent ( ) ) { $ position = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ openParenthesisPosition ) ; } } $ position = $ tokens -> getNextMeaningfulToken ( $ position ) ; if ( '{' !== $ tokens [ $ position ] -> getContent ( ) ) { return $ tokens -> getNextTokenOfKind ( $ position , [ ';' ] ) ; } $ position = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ position ) ; if ( $ initialToken -> isGivenKind ( T_DO ) ) { $ position = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ tokens -> getNextTokenOfKind ( $ position , [ '(' ] ) ) ; return $ tokens -> getNextTokenOfKind ( $ position , [ ';' ] ) ; } return $ position ; } 
public static function match ( $ pattern , $ subject , & $ matches = null , $ flags = 0 , $ offset = 0 ) { $ result = @ preg_match ( self :: addUtf8Modifier ( $ pattern ) , $ subject , $ matches , $ flags , $ offset ) ; if ( false !== $ result && PREG_NO_ERROR === preg_last_error ( ) ) { return $ result ; } $ result = @ preg_match ( self :: removeUtf8Modifier ( $ pattern ) , $ subject , $ matches , $ flags , $ offset ) ; if ( false !== $ result && PREG_NO_ERROR === preg_last_error ( ) ) { return $ result ; } throw new PregException ( 'Error occurred when calling preg_match.' , preg_last_error ( ) ) ; } 
public static function matchAll ( $ pattern , $ subject , & $ matches = null , $ flags = PREG_PATTERN_ORDER , $ offset = 0 ) { $ result = @ preg_match_all ( self :: addUtf8Modifier ( $ pattern ) , $ subject , $ matches , $ flags , $ offset ) ; if ( false !== $ result && PREG_NO_ERROR === preg_last_error ( ) ) { return $ result ; } $ result = @ preg_match_all ( self :: removeUtf8Modifier ( $ pattern ) , $ subject , $ matches , $ flags , $ offset ) ; if ( false !== $ result && PREG_NO_ERROR === preg_last_error ( ) ) { return $ result ; } throw new PregException ( 'Error occurred when calling preg_match_all.' , preg_last_error ( ) ) ; } 
public static function replace ( $ pattern , $ replacement , $ subject , $ limit = - 1 , & $ count = null ) { $ result = @ preg_replace ( self :: addUtf8Modifier ( $ pattern ) , $ replacement , $ subject , $ limit , $ count ) ; if ( null !== $ result && PREG_NO_ERROR === preg_last_error ( ) ) { return $ result ; } $ result = @ preg_replace ( self :: removeUtf8Modifier ( $ pattern ) , $ replacement , $ subject , $ limit , $ count ) ; if ( null !== $ result && PREG_NO_ERROR === preg_last_error ( ) ) { return $ result ; } throw new PregException ( 'Error occurred when calling preg_replace.' , preg_last_error ( ) ) ; } 
public static function replaceCallback ( $ pattern , $ callback , $ subject , $ limit = - 1 , & $ count = null ) { $ result = @ preg_replace_callback ( self :: addUtf8Modifier ( $ pattern ) , $ callback , $ subject , $ limit , $ count ) ; if ( null !== $ result && PREG_NO_ERROR === preg_last_error ( ) ) { return $ result ; } $ result = @ preg_replace_callback ( self :: removeUtf8Modifier ( $ pattern ) , $ callback , $ subject , $ limit , $ count ) ; if ( null !== $ result && PREG_NO_ERROR === preg_last_error ( ) ) { return $ result ; } throw new PregException ( 'Error occurred when calling preg_replace_callback.' , preg_last_error ( ) ) ; } 
public static function split ( $ pattern , $ subject , $ limit = - 1 , $ flags = 0 ) { $ result = @ preg_split ( self :: addUtf8Modifier ( $ pattern ) , $ subject , $ limit , $ flags ) ; if ( false !== $ result && PREG_NO_ERROR === preg_last_error ( ) ) { return $ result ; } $ result = @ preg_split ( self :: removeUtf8Modifier ( $ pattern ) , $ subject , $ limit , $ flags ) ; if ( false !== $ result && PREG_NO_ERROR === preg_last_error ( ) ) { return $ result ; } throw new PregException ( 'Error occurred when calling preg_split.' , preg_last_error ( ) ) ; } 
private static function removeUtf8Modifier ( $ pattern ) { if ( \ is_array ( $ pattern ) ) { return array_map ( __METHOD__ , $ pattern ) ; } if ( '' === $ pattern ) { return '' ; } $ delimiter = substr ( $ pattern , 0 , 1 ) ; $ endDelimiterPosition = strrpos ( $ pattern , $ delimiter ) ; return substr ( $ pattern , 0 , $ endDelimiterPosition ) . str_replace ( 'u' , '' , substr ( $ pattern , $ endDelimiterPosition ) ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ commentsAnalyzer = new CommentsAnalyzer ( ) ; foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_DOC_COMMENT ) ) { continue ; } if ( $ commentsAnalyzer -> isHeaderComment ( $ tokens , $ index ) ) { continue ; } if ( $ commentsAnalyzer -> isBeforeStructuralElement ( $ tokens , $ index ) ) { continue ; } $ tokens [ $ index ] = new Token ( [ T_COMMENT , '/*' . ltrim ( $ token -> getContent ( ) , '/*' ) ] ) ; } } 
public function read ( $ filePath ) { if ( 'php://stdin' === $ filePath ) { if ( null === $ this -> stdinContent ) { $ this -> stdinContent = $ this -> readRaw ( $ filePath ) ; } return $ this -> stdinContent ; } return $ this -> readRaw ( $ filePath ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { static $ nextTokenKinds = null ; if ( null === $ nextTokenKinds ) { $ nextTokenKinds = [ '?' , ';' , ',' , '(' , ')' , '[' , ']' , ':' , '<' , '>' , '+' , '-' , '*' , '/' , '%' , '&' , '^' , '|' , [ T_CLASS ] , [ T_IS_SMALLER_OR_EQUAL ] , [ T_IS_GREATER_OR_EQUAL ] , [ T_IS_EQUAL ] , [ T_IS_NOT_EQUAL ] , [ T_IS_IDENTICAL ] , [ T_IS_NOT_IDENTICAL ] , [ T_CLOSE_TAG ] , [ T_LOGICAL_AND ] , [ T_LOGICAL_OR ] , [ T_LOGICAL_XOR ] , [ T_BOOLEAN_AND ] , [ T_BOOLEAN_OR ] , [ T_SL ] , [ T_SR ] , [ T_INSTANCEOF ] , [ T_AS ] , [ T_DOUBLE_ARROW ] , [ T_POW ] , [ CT :: T_ARRAY_SQUARE_BRACE_OPEN ] , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_BRACE_CLASS_INSTANTIATION_OPEN ] , [ CT :: T_BRACE_CLASS_INSTANTIATION_CLOSE ] , ] ; if ( \ defined ( 'T_SPACESHIP' ) ) { $ nextTokenKinds [ ] = [ T_SPACESHIP ] ; } } for ( $ index = $ tokens -> count ( ) - 3 ; $ index > 0 ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_NEW ) ) { continue ; } $ nextIndex = $ tokens -> getNextTokenOfKind ( $ index , $ nextTokenKinds ) ; $ nextToken = $ tokens [ $ nextIndex ] ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { 
private function fixClassy ( Tokens $ tokens , $ index ) { 
private function isExtendingOrImplementing ( Tokens $ tokens , $ classIndex , $ classOpenIndex ) { for ( $ index = $ classIndex ; $ index < $ classOpenIndex ; ++ $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( [ T_EXTENDS , T_IMPLEMENTS ] ) ) { return true ; } } return false ; } 
private function isUsingTrait ( Tokens $ tokens , $ classIndex , $ classOpenIndex , $ classCloseIndex ) { if ( $ tokens [ $ classIndex ] -> isGivenKind ( T_INTERFACE ) ) { 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ phpUnitTestCaseIndicator = new PhpUnitTestCaseIndicator ( ) ; foreach ( $ phpUnitTestCaseIndicator -> findPhpUnitClasses ( $ tokens ) as $ indexes ) { $ startIndex = $ indexes [ 0 ] ; $ prevDocCommentIndex = $ tokens -> getPrevTokenOfKind ( $ startIndex , [ [ T_DOC_COMMENT ] ] ) ; if ( null !== $ prevDocCommentIndex ) { $ startIndex = $ prevDocCommentIndex ; } $ this -> fixPhpUnitClass ( $ tokens , $ startIndex , $ indexes [ 1 ] ) ; } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ functionsAnalyzer = new FunctionsAnalyzer ( ) ; foreach ( $ tokens -> findGivenKind ( T_STRING ) as $ index => $ token ) { 
protected function createConfigurationDefinition ( ) { $ sets = [ '@internal' , '@IMAP' , '@mbreg' , '@all' ] ; return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'sets' , 'List of sets to fix. Defined sets are `@internal` (native functions), `@IMAP` (IMAP functions), `@mbreg` (from `ext-mbstring`) `@all` (all listed sets).' ) ) -> setAllowedTypes ( [ 'array' ] ) -> setAllowedValues ( [ new AllowedValueSubset ( $ sets ) ] ) -> setDefault ( [ '@internal' , '@IMAP' ] ) -> getOption ( ) , ] ) ; } 
public function registerReporter ( ReporterInterface $ reporter ) { $ format = $ reporter -> getFormat ( ) ; if ( isset ( $ this -> reporters [ $ format ] ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Reporter for format "%s" is already registered.' , $ format ) ) ; } $ this -> reporters [ $ format ] = $ reporter ; return $ this ; } 
public function getReporter ( $ format ) { if ( ! isset ( $ this -> reporters [ $ format ] ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Reporter for format "%s" is not registered.' , $ format ) ) ; } return $ this -> reporters [ $ format ] ; } 
public function delete ( $ path ) { if ( isset ( $ this -> files [ $ path ] ) ) { unset ( $ this -> files [ $ path ] ) ; } $ this -> unlink ( $ path ) ; } 
public function clean ( ) { foreach ( $ this -> files as $ file => $ value ) { $ this -> unlink ( $ file ) ; } $ this -> files = [ ] ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isGivenKind ( T_IS_NOT_EQUAL ) ) { $ tokens [ $ index ] = new Token ( [ T_IS_NOT_EQUAL , '!=' ] ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ i = \ count ( $ tokens ) ; while ( $ i -- ) { $ token = $ tokens [ $ i ] ; if ( ! $ token -> isGivenKind ( T_OPEN_TAG_WITH_ECHO ) ) { continue ; } $ nextIndex = $ i + 1 ; $ tokens [ $ i ] = new Token ( [ T_OPEN_TAG , '<?php ' ] ) ; if ( ! $ tokens [ $ nextIndex ] -> isWhitespace ( ) ) { $ tokens -> insertAt ( $ nextIndex , new Token ( [ T_WHITESPACE , ' ' ] ) ) ; } $ tokens -> insertAt ( $ nextIndex , new Token ( [ T_ECHO , 'echo' ] ) ) ; } } 
public function isCandidate ( Tokens $ tokens ) { foreach ( $ this -> proxyFixers as $ fixer ) { if ( $ fixer -> isCandidate ( $ tokens ) ) { return true ; } } return false ; } 
public function supports ( \ SplFileInfo $ file ) { foreach ( $ this -> proxyFixers as $ fixer ) { if ( $ fixer -> supports ( $ file ) ) { return true ; } } return false ; } 
public function setWhitespacesConfig ( WhitespacesFixerConfig $ config ) { parent :: setWhitespacesConfig ( $ config ) ; foreach ( $ this -> proxyFixers as $ fixer ) { if ( $ fixer instanceof WhitespacesAwareFixerInterface ) { $ fixer -> setWhitespacesConfig ( $ config ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ this -> proxyFixers as $ fixer ) { $ fixer -> fix ( $ file , $ tokens ) ; } } 
public function transform ( Tokens $ tokens ) { foreach ( $ this -> items as $ transformer ) { foreach ( $ tokens as $ index => $ token ) { $ transformer -> process ( $ tokens , $ token , $ index ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ ending = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; $ added = 0 ; foreach ( $ tokensAnalyzer -> getImportUseIndexes ( ) as $ index ) { $ index += $ added ; $ indent = '' ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isNativeConstant ( ) ) { continue ; } if ( $ this -> isNeighbourAccepted ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ index ) ) && $ this -> isNeighbourAccepted ( $ tokens , $ tokens -> getNextMeaningfulToken ( $ index ) ) ) { $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , strtolower ( $ token -> getContent ( ) ) ] ) ; } } } 
private function isNeighbourAccepted ( Tokens $ tokens , $ index ) { static $ forbiddenTokens = [ T_AS , T_CLASS , T_CONST , T_EXTENDS , T_IMPLEMENTS , T_INSTANCEOF , T_INSTEADOF , T_INTERFACE , T_NEW , T_NS_SEPARATOR , T_OBJECT_OPERATOR , T_PAAMAYIM_NEKUDOTAYIM , T_TRAIT , T_USE , CT :: T_USE_TRAIT , CT :: T_USE_LAMBDA , ] ; $ token = $ tokens [ $ index ] ; if ( $ token -> equalsAny ( [ '{' , '}' ] ) ) { return false ; } return ! $ token -> isGivenKind ( $ forbiddenTokens ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isGivenKind ( T_DOC_COMMENT ) ) { $ tokens [ $ index ] = new Token ( [ T_DOC_COMMENT , Preg :: replace ( '/(*ANY)[ \t]+$/m' , '' , $ token -> getContent ( ) ) ] ) ; continue ; } if ( $ token -> isGivenKind ( T_COMMENT ) ) { if ( '/*' === substr ( $ token -> getContent ( ) , 0 , 2 ) ) { $ tokens [ $ index ] = new Token ( [ T_COMMENT , Preg :: replace ( '/(*ANY)[ \t]+$/m' , '' , $ token -> getContent ( ) ) ] ) ; } elseif ( isset ( $ tokens [ $ index + 1 ] ) && $ tokens [ $ index + 1 ] -> isWhitespace ( ) ) { $ trimmedContent = ltrim ( $ tokens [ $ index + 1 ] -> getContent ( ) , " \t" ) ; if ( '' !== $ trimmedContent ) { $ tokens [ $ index + 1 ] = new Token ( [ T_WHITESPACE , $ trimmedContent ] ) ; } else { $ tokens -> clearAt ( $ index + 1 ) ; } } } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ index = $ tokens -> count ( ) - 1 ; $ index >= 0 ; -- $ index ) { if ( $ tokensAnalyzer -> isArray ( $ index ) && $ tokensAnalyzer -> isArrayMultiLine ( $ index ) ) { $ this -> fixArray ( $ tokens , $ index ) ; } } } 
public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> fixCreatePartialMock = PhpUnitTargetVersion :: fulfills ( $ this -> configuration [ 'target' ] , PhpUnitTargetVersion :: VERSION_5_5 ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ phpUnitTestCaseIndicator = new PhpUnitTestCaseIndicator ( ) ; $ argumentsAnalyzer = new ArgumentsAnalyzer ( ) ; foreach ( $ phpUnitTestCaseIndicator -> findPhpUnitClasses ( $ tokens ) as $ indexes ) { for ( $ index = $ indexes [ 0 ] ; $ index < $ indexes [ 1 ] ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { continue ; } $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> equals ( [ T_STRING , 'getMockWithoutInvokingTheOriginalConstructor' ] , false ) ) { $ tokens [ $ index ] = new Token ( [ T_STRING , 'createMock' ] ) ; } elseif ( $ tokens [ $ index ] -> equals ( [ T_STRING , 'getMock' ] , false ) ) { $ openingParenthesis = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ closingParenthesis = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ openingParenthesis ) ; $ argumentsCount = $ argumentsAnalyzer -> countArguments ( $ tokens , $ openingParenthesis , $ closingParenthesis ) ; if ( 1 === $ argumentsCount ) { $ tokens [ $ index ] = new Token ( [ T_STRING , 'createMock' ] ) ; } elseif ( 2 === $ argumentsCount && true === $ this -> fixCreatePartialMock ) { $ tokens [ $ index ] = new Token ( [ T_STRING , 'createPartialMock' ] ) ; } } } } } 
protected function createConfigurationDefinition ( ) { return new FixerConfigurationResolver ( [ ( new FixerOptionBuilder ( 'target' , 'Target version of PHPUnit.' ) ) -> setAllowedTypes ( [ 'string' ] ) -> setAllowedValues ( [ PhpUnitTargetVersion :: VERSION_5_4 , PhpUnitTargetVersion :: VERSION_5_5 , PhpUnitTargetVersion :: VERSION_NEWEST ] ) -> setDefault ( PhpUnitTargetVersion :: VERSION_NEWEST ) -> getOption ( ) , ] ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ magicConstants = $ this -> getMagicConstants ( ) ; $ magicConstantTokens = $ this -> getMagicConstantTokens ( ) ; foreach ( $ tokens as $ index => $ token ) { if ( $ token -> isGivenKind ( $ magicConstantTokens ) ) { $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , $ magicConstants [ $ token -> getId ( ) ] ] ) ; } } } 
public function clear ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> content = '' ; $ this -> id = null ; $ this -> isArray = false ; } 
public function clearChanged ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> changed = false ; } 
public function equals ( $ other , $ caseSensitive = true ) { if ( $ other instanceof self ) { 
public function equalsAny ( array $ others , $ caseSensitive = true ) { foreach ( $ others as $ other ) { if ( $ this -> equals ( $ other , $ caseSensitive ) ) { return true ; } } return false ; } 
public static function isKeyCaseSensitive ( $ caseSensitive , $ key ) { if ( \ is_array ( $ caseSensitive ) ) { return isset ( $ caseSensitive [ $ key ] ) ? $ caseSensitive [ $ key ] : true ; } return $ caseSensitive ; } 
public static function getNameForId ( $ id ) { if ( CT :: has ( $ id ) ) { return CT :: getName ( $ id ) ; } $ name = token_name ( $ id ) ; return 'UNKNOWN' === $ name ? null : $ name ; } 
public static function getKeywords ( ) { static $ keywords = null ; if ( null === $ keywords ) { $ keywords = self :: getTokenKindsForNames ( [ 'T_ABSTRACT' , 'T_ARRAY' , 'T_AS' , 'T_BREAK' , 'T_CALLABLE' , 'T_CASE' , 'T_CATCH' , 'T_CLASS' , 'T_CLONE' , 'T_CONST' , 'T_CONTINUE' , 'T_DECLARE' , 'T_DEFAULT' , 'T_DO' , 'T_ECHO' , 'T_ELSE' , 'T_ELSEIF' , 'T_EMPTY' , 'T_ENDDECLARE' , 'T_ENDFOR' , 'T_ENDFOREACH' , 'T_ENDIF' , 'T_ENDSWITCH' , 'T_ENDWHILE' , 'T_EVAL' , 'T_EXIT' , 'T_EXTENDS' , 'T_FINAL' , 'T_FINALLY' , 'T_FOR' , 'T_FOREACH' , 'T_FUNCTION' , 'T_GLOBAL' , 'T_GOTO' , 'T_HALT_COMPILER' , 'T_IF' , 'T_IMPLEMENTS' , 'T_INCLUDE' , 'T_INCLUDE_ONCE' , 'T_INSTANCEOF' , 'T_INSTEADOF' , 'T_INTERFACE' , 'T_ISSET' , 'T_LIST' , 'T_LOGICAL_AND' , 'T_LOGICAL_OR' , 'T_LOGICAL_XOR' , 'T_NAMESPACE' , 'T_NEW' , 'T_PRINT' , 'T_PRIVATE' , 'T_PROTECTED' , 'T_PUBLIC' , 'T_REQUIRE' , 'T_REQUIRE_ONCE' , 'T_RETURN' , 'T_STATIC' , 'T_SWITCH' , 'T_THROW' , 'T_TRAIT' , 'T_TRY' , 'T_UNSET' , 'T_USE' , 'T_VAR' , 'T_WHILE' , 'T_YIELD' , 'T_YIELD_FROM' , ] ) + [ CT :: T_ARRAY_TYPEHINT => CT :: T_ARRAY_TYPEHINT , CT :: T_CLASS_CONSTANT => CT :: T_CLASS_CONSTANT , CT :: T_CONST_IMPORT => CT :: T_CONST_IMPORT , CT :: T_FUNCTION_IMPORT => CT :: T_FUNCTION_IMPORT , CT :: T_NAMESPACE_OPERATOR => CT :: T_NAMESPACE_OPERATOR , CT :: T_USE_TRAIT => CT :: T_USE_TRAIT , CT :: T_USE_LAMBDA => CT :: T_USE_LAMBDA , ] ; } return $ keywords ; } 
public function isEmpty ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; return null === $ this -> id && ( '' === $ this -> content || null === $ this -> content ) ; } 
public function isGivenKind ( $ possibleKind ) { return $ this -> isArray && ( \ is_array ( $ possibleKind ) ? \ in_array ( $ this -> id , $ possibleKind , true ) : $ this -> id === $ possibleKind ) ; } 
public function isNativeConstant ( ) { static $ nativeConstantStrings = [ 'true' , 'false' , 'null' ] ; return $ this -> isArray && \ in_array ( strtolower ( $ this -> content ) , $ nativeConstantStrings , true ) ; } 
public function isWhitespace ( $ whitespaces = " \t\n\r\0\x0B" ) { if ( null === $ whitespaces ) { $ whitespaces = " \t\n\r\0\x0B" ; } if ( $ this -> isArray && ! $ this -> isGivenKind ( T_WHITESPACE ) ) { return false ; } return '' === trim ( $ this -> content , $ whitespaces ) ; } 
public function override ( $ other ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ prototype = $ other instanceof self ? $ other -> getPrototype ( ) : $ other ; if ( $ this -> equals ( $ prototype ) ) { return ; } $ this -> changed = true ; if ( \ is_array ( $ prototype ) ) { $ this -> isArray = true ; $ this -> id = $ prototype [ 0 ] ; $ this -> content = $ prototype [ 1 ] ; return ; } $ this -> isArray = false ; $ this -> id = null ; $ this -> content = $ prototype ; } 
public function setContent ( $ content ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; if ( $ this -> content === $ content ) { return ; } $ this -> changed = true ; $ this -> content = $ content ; 
public function toJson ( array $ options = null ) { static $ defaultOptions = null ; if ( null === $ options ) { if ( null === $ defaultOptions ) { $ defaultOptions = Utils :: calculateBitmask ( [ 'JSON_PRETTY_PRINT' , 'JSON_NUMERIC_CHECK' ] ) ; } $ options = $ defaultOptions ; } else { $ options = Utils :: calculateBitmask ( $ options ) ; } return json_encode ( $ this -> toArray ( ) , $ options ) ; } 
private static function getTokenKindsForNames ( array $ tokenNames ) { $ keywords = [ ] ; foreach ( $ tokenNames as $ keywordName ) { if ( \ defined ( $ keywordName ) ) { $ keyword = \ constant ( $ keywordName ) ; $ keywords [ $ keyword ] = $ keyword ; } } return $ keywords ; } 
public function process ( Tokens $ tokens , Token $ token , $ index ) { if ( ! $ token -> isGivenKind ( T_NAMESPACE ) ) { return ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ nextToken = $ tokens [ $ nextIndex ] ; if ( $ nextToken -> isGivenKind ( T_NS_SEPARATOR ) ) { $ tokens [ $ index ] = new Token ( [ CT :: T_NAMESPACE_OPERATOR , $ token -> getContent ( ) ] ) ; } } 
public function getDefinition ( ) { $ versionSpecification = new VersionSpecification ( 70000 ) ; return new FixerDefinition ( 'There should be one or no space before colon, and one space after it in return type declarations, according to configuration.' , [ new VersionSpecificCodeSample ( "<?php\nfunction foo(int \$a):string {};\n" , $ versionSpecification ) , new VersionSpecificCodeSample ( "<?php\nfunction foo(int \$a):string {};\n" , $ versionSpecification , [ 'space_before' => 'none' ] ) , new VersionSpecificCodeSample ( "<?php\nfunction foo(int \$a):string {};\n" , $ versionSpecification , [ 'space_before' => 'one' ] ) , ] , 'Rule is applied only in a PHP 7+ environment.' ) ; } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ oneSpaceBefore = 'one' === $ this -> configuration [ 'space_before' ] ; for ( $ index = 0 , $ limit = $ tokens -> count ( ) ; $ index < $ limit ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( CT :: T_TYPE_COLON ) ) { continue ; } $ previousIndex = $ index - 1 ; $ previousToken = $ tokens [ $ previousIndex ] ; if ( $ previousToken -> isWhitespace ( ) ) { if ( ! $ tokens [ $ tokens -> getPrevNonWhitespace ( $ index - 1 ) ] -> isComment ( ) ) { if ( $ oneSpaceBefore ) { $ tokens [ $ previousIndex ] = new Token ( [ T_WHITESPACE , ' ' ] ) ; } else { $ tokens -> clearAt ( $ previousIndex ) ; } } } elseif ( $ oneSpaceBefore ) { $ tokenWasAdded = $ tokens -> ensureWhitespaceAtIndex ( $ index , 0 , ' ' ) ; if ( $ tokenWasAdded ) { ++ $ limit ; } ++ $ index ; } ++ $ index ; $ tokenWasAdded = $ tokens -> ensureWhitespaceAtIndex ( $ index , 0 , ' ' ) ; if ( $ tokenWasAdded ) { ++ $ limit ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ content = $ tokens [ 0 ] -> getContent ( ) ; if ( 0 === strncmp ( $ content , $ this -> BOM , 3 ) ) { $ newContent = substr ( $ content , 3 ) ; if ( false === $ newContent ) { $ newContent = '' ; 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { $ ending = $ this -> whitespacesConfig -> getLineEnding ( ) ; for ( $ index = 0 , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) ) { if ( $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] -> isGivenKind ( T_END_HEREDOC ) ) { $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , Preg :: replace ( "#\r\n|\n#" , $ ending , $ token -> getContent ( ) ) , ] ) ; } continue ; } if ( $ token -> isGivenKind ( [ T_OPEN_TAG , T_WHITESPACE , T_COMMENT , T_DOC_COMMENT , T_START_HEREDOC ] ) ) { $ tokens [ $ index ] = new Token ( [ $ token -> getId ( ) , Preg :: replace ( "#\r\n|\n#" , $ ending , $ token -> getContent ( ) ) , ] ) ; } } } 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { foreach ( $ tokens as $ index => $ token ) { if ( ! $ token -> isGivenKind ( T_ELSE ) ) { continue ; } 
private function fixEmptyElse ( Tokens $ tokens , $ index ) { $ next = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ tokens [ $ next ] -> equals ( '{' ) ) { $ close = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ next ) ; if ( 1 === $ close - $ next ) { 
protected function applyFix ( \ SplFileInfo $ file , Tokens $ tokens ) { for ( $ index = 0 , $ count = $ tokens -> count ( ) ; $ index < $ count ; ++ $ index ) { if ( ! $ tokens [ $ index ] -> isCast ( ) ) { continue ; } $ tokens [ $ index ] = new Token ( [ $ tokens [ $ index ] -> getId ( ) , strtolower ( $ tokens [ $ index ] -> getContent ( ) ) ] ) ; } } 
public function getPath ( ) { if ( null === $ this -> path ) { $ filesystem = new Filesystem ( ) ; $ cwd = $ this -> cwd ; if ( 1 === \ count ( $ this -> options [ 'path' ] ) && '-' === $ this -> options [ 'path' ] [ 0 ] ) { $ this -> path = $ this -> options [ 'path' ] ; } else { $ this -> path = array_map ( static function ( $ path ) use ( $ cwd , $ filesystem ) { $ absolutePath = $ filesystem -> isAbsolutePath ( $ path ) ? $ path : $ cwd . \ DIRECTORY_SEPARATOR . $ path ; if ( ! file_exists ( $ absolutePath ) ) { throw new InvalidConfigurationException ( sprintf ( 'The path "%s" is not readable.' , $ path ) ) ; } return $ absolutePath ; } , $ this -> options [ 'path' ] ) ; } } return $ this -> path ; } 
public function getProgress ( ) { if ( null === $ this -> progress ) { if ( OutputInterface :: VERBOSITY_VERBOSE <= $ this -> options [ 'verbosity' ] && 'txt' === $ this -> getFormat ( ) ) { $ progressType = $ this -> options [ 'show-progress' ] ; $ progressTypes = [ 'none' , 'run-in' , 'estimating' , 'estimating-max' , 'dots' ] ; if ( null === $ progressType ) { $ default = 'run-in' ; if ( getenv ( 'PHP_CS_FIXER_FUTURE_MODE' ) ) { $ default = 'dots' ; } $ progressType = $ this -> getConfig ( ) -> getHideProgress ( ) ? 'none' : $ default ; } elseif ( ! \ in_array ( $ progressType , $ progressTypes , true ) ) { throw new InvalidConfigurationException ( sprintf ( 'The progress type "%s" is not defined, supported are "%s".' , $ progressType , implode ( '", "' , $ progressTypes ) ) ) ; } elseif ( \ in_array ( $ progressType , [ 'estimating' , 'estimating-max' , 'run-in' ] , true ) ) { $ message = 'Passing `estimating`, `estimating-max` or `run-in` is deprecated and will not be supported in 3.0, use `none` or `dots` instead.' ; if ( getenv ( 'PHP_CS_FIXER_FUTURE_MODE' ) ) { throw new \ InvalidArgumentException ( "{$message} This check was performed as `PHP_CS_FIXER_FUTURE_MODE` env var is set." ) ; } @ trigger_error ( $ message , E_USER_DEPRECATED ) ; } $ this -> progress = $ progressType ; } else { $ this -> progress = 'none' ; } } return $ this -> progress ; } 
public function isDryRun ( ) { if ( null === $ this -> isDryRun ) { if ( $ this -> isStdIn ( ) ) { 
private function computeConfigFiles ( ) { $ configFile = $ this -> options [ 'config' ] ; if ( null !== $ configFile ) { if ( false === file_exists ( $ configFile ) || false === is_readable ( $ configFile ) ) { throw new InvalidConfigurationException ( sprintf ( 'Cannot read config file "%s".' , $ configFile ) ) ; } return [ $ configFile ] ; } $ path = $ this -> getPath ( ) ; if ( $ this -> isStdIn ( ) || 0 === \ count ( $ path ) ) { $ configDir = $ this -> cwd ; } elseif ( 1 < \ count ( $ path ) ) { throw new InvalidConfigurationException ( 'For multiple paths config parameter is required.' ) ; } elseif ( is_file ( $ path [ 0 ] ) && $ dirName = pathinfo ( $ path [ 0 ] , PATHINFO_DIRNAME ) ) { $ configDir = $ dirName ; } else { $ configDir = $ path [ 0 ] ; } $ candidates = [ $ configDir . \ DIRECTORY_SEPARATOR . '.php_cs' , $ configDir . \ DIRECTORY_SEPARATOR . '.php_cs.dist' , ] ; if ( $ configDir !== $ this -> cwd ) { $ candidates [ ] = $ this -> cwd . \ DIRECTORY_SEPARATOR . '.php_cs' ; $ candidates [ ] = $ this -> cwd . \ DIRECTORY_SEPARATOR . '.php_cs.dist' ; } return $ candidates ; } 
private function parseRules ( ) { if ( null === $ this -> options [ 'rules' ] ) { return $ this -> getConfig ( ) -> getRules ( ) ; } $ rules = trim ( $ this -> options [ 'rules' ] ) ; if ( '' === $ rules ) { throw new InvalidConfigurationException ( 'Empty rules value is not allowed.' ) ; } if ( '{' === $ rules [ 0 ] ) { $ rules = json_decode ( $ rules , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidConfigurationException ( sprintf ( 'Invalid JSON rules input: %s.' , json_last_error_msg ( ) ) ) ; } return $ rules ; } $ rules = [ ] ; foreach ( explode ( ',' , $ this -> options [ 'rules' ] ) as $ rule ) { $ rule = trim ( $ rule ) ; if ( '' === $ rule ) { throw new InvalidConfigurationException ( 'Empty rule name is not allowed.' ) ; } if ( '-' === $ rule [ 0 ] ) { $ rules [ substr ( $ rule , 1 ) ] = false ; } else { $ rules [ $ rule ] = true ; } } return $ rules ; } 
private function validateRules ( array $ rules ) { $ ruleSet = [ ] ; foreach ( $ rules as $ key => $ value ) { if ( \ is_int ( $ key ) ) { throw new InvalidConfigurationException ( sprintf ( 'Missing value for "%s" rule/set.' , $ value ) ) ; } $ ruleSet [ $ key ] = true ; } $ ruleSet = new RuleSet ( $ ruleSet ) ; $ configuredFixers = array_keys ( $ ruleSet -> getRules ( ) ) ; $ fixers = $ this -> createFixerFactory ( ) -> getFixers ( ) ; $ availableFixers = array_map ( static function ( FixerInterface $ fixer ) { return $ fixer -> getName ( ) ; } , $ fixers ) ; $ unknownFixers = array_diff ( $ configuredFixers , $ availableFixers ) ; if ( \ count ( $ unknownFixers ) ) { $ matcher = new WordMatcher ( $ availableFixers ) ; $ message = 'The rules contain unknown fixers: ' ; foreach ( $ unknownFixers as $ unknownFixer ) { $ alternative = $ matcher -> match ( $ unknownFixer ) ; $ message .= sprintf ( '"%s"%s, ' , $ unknownFixer , null === $ alternative ? '' : ' (did you mean "' . $ alternative . '"?)' ) ; } throw new InvalidConfigurationException ( substr ( $ message , 0 , - 2 ) . '.' ) ; } foreach ( $ fixers as $ fixer ) { $ fixerName = $ fixer -> getName ( ) ; if ( isset ( $ rules [ $ fixerName ] ) && $ fixer instanceof DeprecatedFixerInterface ) { $ successors = $ fixer -> getSuccessorsNames ( ) ; $ messageEnd = [ ] === $ successors ? sprintf ( ' and will be removed in version %d.0.' , ( int ) Application :: VERSION + 1 ) : sprintf ( '. Use %s instead.' , str_replace ( '`' , '"' , Utils :: naturalLanguageJoinWithBackticks ( $ successors ) ) ) ; $ message = "Rule \"{$fixerName}\" is deprecated{$messageEnd}" ; if ( getenv ( 'PHP_CS_FIXER_FUTURE_MODE' ) ) { throw new \ RuntimeException ( "{$message} This check was performed as `PHP_CS_FIXER_FUTURE_MODE` env var is set." ) ; } @ trigger_error ( $ message , E_USER_DEPRECATED ) ; } } } 
private function resolveFinder ( ) { $ this -> configFinderIsOverridden = false ; if ( $ this -> isStdIn ( ) ) { return new \ ArrayIterator ( [ new StdinFileInfo ( ) ] ) ; } $ modes = [ self :: PATH_MODE_OVERRIDE , self :: PATH_MODE_INTERSECTION ] ; if ( ! \ in_array ( $ this -> options [ 'path-mode' ] , $ modes , true ) ) { throw new InvalidConfigurationException ( sprintf ( 'The path-mode "%s" is not defined, supported are "%s".' , $ this -> options [ 'path-mode' ] , implode ( '", "' , $ modes ) ) ) ; } $ isIntersectionPathMode = self :: PATH_MODE_INTERSECTION === $ this -> options [ 'path-mode' ] ; $ paths = array_filter ( array_map ( static function ( $ path ) { return realpath ( $ path ) ; } , $ this -> getPath ( ) ) ) ; if ( ! \ count ( $ paths ) ) { if ( $ isIntersectionPathMode ) { return new \ ArrayIterator ( [ ] ) ; } return $ this -> iterableToTraversable ( $ this -> getConfig ( ) -> getFinder ( ) ) ; } $ pathsByType = [ 'file' => [ ] , 'dir' => [ ] , ] ; foreach ( $ paths as $ path ) { if ( is_file ( $ path ) ) { $ pathsByType [ 'file' ] [ ] = $ path ; } else { $ pathsByType [ 'dir' ] [ ] = $ path . \ DIRECTORY_SEPARATOR ; } } $ nestedFinder = null ; $ currentFinder = $ this -> iterableToTraversable ( $ this -> getConfig ( ) -> getFinder ( ) ) ; try { $ nestedFinder = $ currentFinder instanceof \ IteratorAggregate ? $ currentFinder -> getIterator ( ) : $ currentFinder ; } catch ( \ Exception $ e ) { } if ( $ isIntersectionPathMode ) { if ( null === $ nestedFinder ) { throw new InvalidConfigurationException ( 'Cannot create intersection with not-fully defined Finder in configuration file.' ) ; } return new \ CallbackFilterIterator ( $ nestedFinder , static function ( \ SplFileInfo $ current ) use ( $ pathsByType ) { $ currentRealPath = $ current -> getRealPath ( ) ; if ( \ in_array ( $ currentRealPath , $ pathsByType [ 'file' ] , true ) ) { return true ; } foreach ( $ pathsByType [ 'dir' ] as $ path ) { if ( 0 === strpos ( $ currentRealPath , $ path ) ) { return true ; } } return false ; } ) ; } if ( null !== $ this -> getConfigFile ( ) && null !== $ nestedFinder ) { $ this -> configFinderIsOverridden = true ; } if ( $ currentFinder instanceof SymfonyFinder && null === $ nestedFinder ) { 
private function setOption ( $ name , $ value ) { if ( ! \ array_key_exists ( $ name , $ this -> options ) ) { throw new InvalidConfigurationException ( sprintf ( 'Unknown option name: "%s".' , $ name ) ) ; } $ this -> options [ $ name ] = $ value ; } 
private function resolveOptionBooleanValue ( $ optionName ) { $ value = $ this -> options [ $ optionName ] ; if ( \ is_bool ( $ value ) ) { return $ value ; } if ( ! \ is_string ( $ value ) ) { throw new InvalidConfigurationException ( sprintf ( 'Expected boolean or string value for option "%s".' , $ optionName ) ) ; } if ( 'yes' === $ value ) { return true ; } if ( 'no' === $ value ) { return false ; } $ message = sprintf ( 'Expected "yes" or "no" for option "%s", other values are deprecated and support will be removed in 3.0. Got "%s", this implicitly set the option to "false".' , $ optionName , $ value ) ; if ( getenv ( 'PHP_CS_FIXER_FUTURE_MODE' ) ) { throw new InvalidConfigurationException ( "{$message} This check was performed as `PHP_CS_FIXER_FUTURE_MODE` env var is set." ) ; } @ trigger_error ( $ message , E_USER_DEPRECATED ) ; return false ; } 
public function withValidator ( Validator $ validator ) { 
public function handle ( Request $ request , Closure $ next ) { 
public function handle ( ) { 
protected function scripttagExists ( array $ shopScripttags , array $ scripttag ) { foreach ( $ shopScripttags as $ shopScripttag ) { if ( $ shopScripttag -> src === $ scripttag [ 'src' ] ) { 
public function shop ( string $ shopDomain = null ) { $ shopifyDomain = $ shopDomain ? $ this -> sanitizeShopDomain ( $ shopDomain ) : ( new ShopSession ( ) ) -> getDomain ( ) ; if ( ! $ this -> shop && $ shopifyDomain ) { 
public function api ( ) { $ apiClass = Config :: get ( 'shopify-app.api_class' ) ; $ api = new $ apiClass ( ) ; $ api -> setApiKey ( Config :: get ( 'shopify-app.api_key' ) ) ; $ api -> setApiSecret ( Config :: get ( 'shopify-app.api_secret' ) ) ; 
public function sanitizeShopDomain ( $ domain ) { if ( empty ( $ domain ) ) { return ; } $ configEndDomain = Config :: get ( 'shopify-app.myshopify_domain' ) ; $ domain = strtolower ( preg_replace ( '/https?:\/\//i' , '' , trim ( $ domain ) ) ) ; if ( strpos ( $ domain , $ configEndDomain ) === false && strpos ( $ domain , '.' ) === false ) { 
public function createHmac ( array $ opts ) { 
public function boot ( ) { 
public function register ( ) { 
public function activate ( ) { 
public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } 
public function authenticate ( AuthShop $ request ) { 
protected function returnTo ( ) { 
public function retrieve ( ) { $ path = null ; switch ( $ this -> type ) { case self :: CHARGE_CREDIT : $ path = 'application_credits' ; break ; case self :: CHARGE_ONETIME : $ path = 'application_charges' ; break ; default : $ path = 'recurring_application_charges' ; break ; } return $ this -> shop -> api ( ) -> rest ( 'GET' , "/admin/{$path}/{$this->charge_id}.json" ) -> body -> { substr ( $ path , 0 , - 1 ) } ; } 
public function isActiveTrial ( ) { return $ this -> isTrial ( ) && Carbon :: today ( ) -> lte ( Carbon :: parse ( $ this -> trial_ends_on ) ) ; } 
public function remainingTrialDays ( ) { if ( ! $ this -> isTrial ( ) ) { return ; } return $ this -> isActiveTrial ( ) ? Carbon :: today ( ) -> diffInDays ( $ this -> trial_ends_on ) : 0 ; } 
public function remainingTrialDaysFromCancel ( ) { if ( ! $ this -> isTrial ( ) ) { return ; } $ cancelledDate = Carbon :: parse ( $ this -> cancelled_on ) ; $ trialEndsDate = Carbon :: parse ( $ this -> trial_ends_on ) ; 
public function cancel ( ) { if ( ! $ this -> isType ( self :: CHARGE_ONETIME ) && ! $ this -> isType ( self :: CHARGE_RECURRING ) ) { throw new Exception ( 'Cancel may only be called for single and recurring charges.' ) ; } $ this -> status = self :: STATUS_CANCELLED ; $ this -> cancelled_on = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; return $ this -> save ( ) ; } 
public function up ( ) { 
public function handle ( Request $ request , Closure $ next ) { if ( Config :: get ( 'shopify-app.billing_enabled' ) === true ) { $ shop = ShopifyApp :: shop ( ) ; if ( ! $ shop -> isFreemium ( ) && ! $ shop -> isGrandfathered ( ) && ! $ shop -> plan ) { 
public function handle ( $ type ) { 
public function buildAuthUrl ( $ mode = null ) { 
public function postProcess ( ) { if ( ! $ this -> shop -> trashed ( ) ) { return ; } 
public function dispatchWebhooks ( ) { $ webhooks = Config :: get ( 'shopify-app.webhooks' ) ; if ( count ( $ webhooks ) > 0 ) { WebhookInstaller :: dispatch ( $ this -> shop ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.webhooks' ) ) ; } } 
public function dispatchScripttags ( ) { $ scripttags = Config :: get ( 'shopify-app.scripttags' ) ; if ( count ( $ scripttags ) > 0 ) { ScripttagInstaller :: dispatch ( $ this -> shop , $ scripttags ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.scripttags' ) ) ; } } 
public function dispatchAfterAuthenticate ( ) { * Fires the job. * * @param array $config The job's configuration * * @return bool */ $ fireJob = function ( $ config ) { $ job = $ config [ 'job' ] ; if ( isset ( $ config [ 'inline' ] ) && $ config [ 'inline' ] === true ) { // Run this job immediately $ job :: dispatchNow ( $ this -> shop ) ; } else { // Run later $ job :: dispatch ( $ this -> shop ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.after_authenticate' ) ) ; } return true ; } ; // We have multi-jobs if ( isset ( $ jobsConfig [ 0 ] ) ) { foreach ( $ jobsConfig as $ jobConfig ) { // We have a job, pass the shop object to the contructor $ fireJob ( $ jobConfig ) ; } return true ; } // We have a single job if ( isset ( $ jobsConfig [ 'job' ] ) ) { return $ fireJob ( $ jobsConfig ) ; } return false ; } 
public function up ( ) { Schema :: table ( 'shops' , function ( Blueprint $ table ) { $ table -> string ( 'namespace' ) -> nullable ( true ) -> default ( null ) ; } ) ; } 
public function down ( ) { Schema :: table ( 'shops' , function ( Blueprint $ table ) { $ table -> bigInteger ( 'charge_id' ) -> nullable ( true ) -> default ( null ) ; } ) ; } 
public function handle ( ) { if ( ! $ this -> shop ) { return false ; } $ this -> cancelCharge ( ) ; $ this -> cleanShop ( ) ; $ this -> softDeleteShop ( ) ; return true ; } 
protected function cleanShop ( ) { $ this -> shop -> shopify_token = null ; $ this -> shop -> plan_id = null ; $ this -> shop -> save ( ) ; } 
protected function cancelCharge ( ) { $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } } 
public function getType ( ) { $ config = Config :: get ( 'shopify-app.api_grant_mode' ) ; if ( $ config === self :: GRANT_PERUSER ) { return self :: GRANT_PERUSER ; } return self :: GRANT_OFFLINE ; } 
public function setDomain ( string $ shopDomain ) { $ this -> fixLifetime ( ) ; Session :: put ( self :: DOMAIN , $ shopDomain ) ; } 
public function setAccess ( stdClass $ access ) { 
public function getToken ( bool $ strict = false ) { 
public function forget ( ) { $ keys = [ self :: DOMAIN , self :: USER , self :: TOKEN ] ; foreach ( $ keys as $ key ) { Session :: forget ( $ key ) ; } } 
public function creating ( $ shop ) { if ( ! isset ( $ shop -> namespace ) ) { 
public function up ( ) { Schema :: table ( 'charges' , function ( Blueprint $ table ) { 
public function down ( ) { Schema :: table ( 'charges' , function ( Blueprint $ table ) { 
public function handle ( Request $ request , Closure $ next ) { $ hmac = $ request -> header ( 'x-shopify-hmac-sha256' ) ? : '' ; $ shop = $ request -> header ( 'x-shopify-shop-domain' ) ; $ data = $ request -> getContent ( ) ; $ hmacLocal = ShopifyApp :: createHmac ( [ 'data' => $ data , 'raw' => true , 'encode' => true ] ) ; if ( ! hash_equals ( $ hmac , $ hmacLocal ) || empty ( $ shop ) ) { 
public function withValidator ( Validator $ validator ) { 
public function up ( ) { Schema :: table ( 'charges' , function ( Blueprint $ table ) { 
public function down ( ) { Schema :: table ( 'charges' , function ( Blueprint $ table ) { 
public function shopWebhooks ( ) { if ( ! $ this -> shopWebhooks ) { $ this -> shopWebhooks = $ this -> api -> rest ( 'GET' , '/admin/webhooks.json' , [ 'limit' => 250 , 'fields' => 'id,address' , ] ) -> body -> webhooks ; } return $ this -> shopWebhooks ; } 
public function webhookExists ( array $ webhook ) { $ shopWebhooks = $ this -> shopWebhooks ( ) ; foreach ( $ shopWebhooks as $ shopWebhook ) { if ( $ shopWebhook -> address === $ webhook [ 'address' ] ) { 
public function createWebhooks ( ) { $ configWebhooks = $ this -> configWebhooks ( ) ; 
public function deleteWebhooks ( ) { $ shopWebhooks = $ this -> shopWebhooks ( ) ; $ deleted = [ ] ; foreach ( $ shopWebhooks as $ webhook ) { 
public function handle ( ) { 'webhooks' => [ [ 'topic' => '{$this->argument('topic')}', 'address' => 'https://your-domain.com/webhook/{$this->getUrlFromName($this->getNameInput())}' ] ] " ) ; } 
protected function getUrlFromName ( string $ name ) { if ( Str :: endsWith ( $ name , 'Job' ) ) { $ name = substr ( $ name , 0 , - 3 ) ; } return strtolower ( preg_replace ( '/(?<!^)[A-Z]/' , '-$0' , $ name ) ) ; } 
public function typeAsString ( $ plural = false ) { $ type = null ; switch ( $ this -> type ) { case self :: PLAN_ONETIME : $ type = 'application_charge' ; break ; default : case self :: PLAN_RECURRING : $ type = 'recurring_application_charge' ; break ; } return $ plural ? "{$type}s" : $ type ; } 
public function handle ( Request $ request , Closure $ next ) { $ validation = $ this -> validateShop ( $ request ) ; if ( $ validation !== true ) { return $ validation ; } return $ this -> response ( $ request , $ next ) ; } 
protected function validateShop ( Request $ request ) { $ shopParam = ShopifyApp :: sanitizeShopDomain ( $ request -> get ( 'shop' ) ) ; $ shop = ShopifyApp :: shop ( $ shopParam ) ; $ session = new ShopSession ( $ shop ) ; 
protected function response ( Request $ request , Closure $ next ) { 
public function api ( ) { if ( ! $ this -> api ) { 
public function planCharge ( ) { return $ this -> charges ( ) -> whereIn ( 'type' , [ Charge :: CHARGE_RECURRING , Charge :: CHARGE_ONETIME ] ) -> where ( 'plan_id' , $ this -> plan_id ) -> orderBy ( 'created_at' , 'desc' ) -> first ( ) ; } 
public function index ( Plan $ plan ) { 
public function process ( Plan $ plan ) { 
public function usageCharge ( StoreUsageCharge $ request ) { 
public function up ( ) { Schema :: table ( 'shops' , function ( Blueprint $ table ) { $ table -> bigInteger ( 'charge_id' ) -> nullable ( true ) -> default ( null ) ; $ table -> boolean ( 'grandfathered' ) -> default ( false ) ; } ) ; } 
public function getCharge ( ) { 
public function confirmationUrl ( ) { 
public function chargeParams ( ) { 
public function activate ( ) { 
public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } 
public static function validate ( Schema $ schema , DocumentNode $ ast , ? array $ rules = null , ? TypeInfo $ typeInfo = null ) { if ( $ rules === null ) { $ rules = static :: allRules ( ) ; } if ( is_array ( $ rules ) === true && count ( $ rules ) === 0 ) { 
public static function allRules ( ) { if ( ! self :: $ initRules ) { static :: $ rules = array_merge ( static :: defaultRules ( ) , self :: securityRules ( ) , self :: $ rules ) ; static :: $ initRules = true ; } return self :: $ rules ; } 
public static function visitUsingRules ( Schema $ schema , TypeInfo $ typeInfo , DocumentNode $ documentNode , array $ rules ) { $ context = new ValidationContext ( $ schema , $ documentNode , $ typeInfo ) ; $ visitors = [ ] ; foreach ( $ rules as $ rule ) { $ visitors [ ] = $ rule -> getVisitor ( $ context ) ; } Visitor :: visit ( $ documentNode , Visitor :: visitWithTypeInfo ( $ typeInfo , Visitor :: visitInParallel ( $ visitors ) ) ) ; return $ context -> getErrors ( ) ; } 
public static function getRule ( $ name ) { $ rules = static :: allRules ( ) ; if ( isset ( $ rules [ $ name ] ) ) { return $ rules [ $ name ] ; } $ name = sprintf ( 'GraphQL\\Validator\\Rules\\%s' , $ name ) ; return $ rules [ $ name ] ?? null ; } 
public static function isValidLiteralValue ( Type $ type , $ valueNode ) { $ emptySchema = new Schema ( [ ] ) ; $ emptyDoc = new DocumentNode ( [ 'definitions' => [ ] ] ) ; $ typeInfo = new TypeInfo ( $ emptySchema , $ type ) ; $ context = new ValidationContext ( $ emptySchema , $ emptyDoc , $ typeInfo ) ; $ validator = new ValuesOfCorrectType ( ) ; $ visitor = $ validator -> getVisitor ( $ context ) ; Visitor :: visit ( $ valueNode , Visitor :: visitWithTypeInfo ( $ typeInfo , $ visitor ) ) ; return $ context -> getErrors ( ) ; } 
public static function assertNullableType ( $ type ) { Utils :: invariant ( Type :: isType ( $ type ) && ! $ type instanceof self , 'Expected ' . Utils :: printSafe ( $ type ) . ' to be a GraphQL nullable type.' ) ; return $ type ; } 
public static function assertNullType ( $ type ) { Utils :: invariant ( $ type instanceof self , 'Expected ' . Utils :: printSafe ( $ type ) . ' to be a GraphQL Non-Null type.' ) ; return $ type ; } 
public function getWrappedType ( $ recurse = false ) { $ type = $ this -> ofType ; return $ recurse && $ type instanceof WrappingType ? $ type -> getWrappedType ( $ recurse ) : $ type ; } 
private function completeValue ( CoroutineContext $ ctx , Type $ type , $ value , array $ path , ? array $ nullFence ) { $ nonNull = false ; $ returnValue = null ; if ( $ type instanceof NonNull ) { $ nonNull = true ; $ type = $ type -> getWrappedType ( ) ; } else { $ nullFence = $ path ; } 
private function getDescription ( $ node ) { if ( $ node -> description ) { return $ node -> description -> value ; } if ( isset ( $ this -> options [ 'commentDescriptions' ] ) ) { $ rawValue = $ this -> getLeadingCommentBlock ( $ node ) ; if ( $ rawValue !== null ) { return BlockString :: value ( "\n" . $ rawValue ) ; } } return null ; } 
private function internalBuildWrappedType ( TypeNode $ typeNode ) { $ typeDef = $ this -> buildType ( $ this -> getNamedTypeNode ( $ typeNode ) ) ; return $ this -> buildWrappedType ( $ typeDef , $ typeNode ) ; } 
public function buildType ( $ ref ) { if ( is_string ( $ ref ) ) { return $ this -> internalBuildType ( $ ref ) ; } return $ this -> internalBuildType ( $ ref -> name -> value , $ ref ) ; } 
private function internalBuildType ( $ typeName , $ typeNode = null ) { if ( ! isset ( $ this -> cache [ $ typeName ] ) ) { if ( isset ( $ this -> typeDefinitionsMap [ $ typeName ] ) ) { $ type = $ this -> makeSchemaDef ( $ this -> typeDefinitionsMap [ $ typeName ] ) ; if ( $ this -> typeConfigDecorator ) { $ fn = $ this -> typeConfigDecorator ; try { $ config = $ fn ( $ type -> config , $ this -> typeDefinitionsMap [ $ typeName ] , $ this -> typeDefinitionsMap ) ; } catch ( Throwable $ e ) { throw new Error ( sprintf ( 'Type config decorator passed to %s threw an error ' , static :: class ) . sprintf ( 'when building %s type: %s' , $ typeName , $ e -> getMessage ( ) ) , null , null , null , null , $ e ) ; } if ( ! is_array ( $ config ) || isset ( $ config [ 0 ] ) ) { throw new Error ( sprintf ( 'Type config decorator passed to %s is expected to return an array, but got %s' , static :: class , Utils :: getVariableType ( $ config ) ) ) ; } $ type = $ this -> makeSchemaDefFromConfig ( $ this -> typeDefinitionsMap [ $ typeName ] , $ config ) ; } $ this -> cache [ $ typeName ] = $ type ; } else { $ fn = $ this -> resolveType ; $ this -> cache [ $ typeName ] = $ fn ( $ typeName , $ typeNode ) ; } } return $ this -> cache [ $ typeName ] ; } 
private function makeSchemaDef ( $ def ) { if ( ! $ def ) { throw new Error ( 'def must be defined.' ) ; } switch ( $ def -> kind ) { case NodeKind :: OBJECT_TYPE_DEFINITION : return $ this -> makeTypeDef ( $ def ) ; case NodeKind :: INTERFACE_TYPE_DEFINITION : return $ this -> makeInterfaceDef ( $ def ) ; case NodeKind :: ENUM_TYPE_DEFINITION : return $ this -> makeEnumDef ( $ def ) ; case NodeKind :: UNION_TYPE_DEFINITION : return $ this -> makeUnionDef ( $ def ) ; case NodeKind :: SCALAR_TYPE_DEFINITION : return $ this -> makeScalarDef ( $ def ) ; case NodeKind :: INPUT_OBJECT_TYPE_DEFINITION : return $ this -> makeInputObjectDef ( $ def ) ; default : throw new Error ( sprintf ( 'Type kind of %s not supported.' , $ def -> kind ) ) ; } } 
private function getDeprecationReason ( $ node ) { $ deprecated = Values :: getDirectiveValues ( Directive :: deprecatedDirective ( ) , $ node ) ; return $ deprecated [ 'reason' ] ?? null ; } 
private function makeSchemaDefFromConfig ( $ def , array $ config ) { if ( ! $ def ) { throw new Error ( 'def must be defined.' ) ; } switch ( $ def -> kind ) { case NodeKind :: OBJECT_TYPE_DEFINITION : return new ObjectType ( $ config ) ; case NodeKind :: INTERFACE_TYPE_DEFINITION : return new InterfaceType ( $ config ) ; case NodeKind :: ENUM_TYPE_DEFINITION : return new EnumType ( $ config ) ; case NodeKind :: UNION_TYPE_DEFINITION : return new UnionType ( $ config ) ; case NodeKind :: SCALAR_TYPE_DEFINITION : return new CustomScalarType ( $ config ) ; case NodeKind :: INPUT_OBJECT_TYPE_DEFINITION : return new InputObjectType ( $ config ) ; default : throw new Error ( sprintf ( 'Type kind of %s not supported.' , $ def -> kind ) ) ; } } 
private function getNamedTypeNode ( TypeNode $ typeNode ) { $ namedType = $ typeNode ; while ( $ namedType -> kind === NodeKind :: LIST_TYPE || $ namedType -> kind === NodeKind :: NON_NULL_TYPE ) { $ namedType = $ namedType -> type ; } return $ namedType ; } 
private function buildWrappedType ( Type $ innerType , TypeNode $ inputTypeNode ) { if ( $ inputTypeNode -> kind === NodeKind :: LIST_TYPE ) { return Type :: listOf ( $ this -> buildWrappedType ( $ innerType , $ inputTypeNode -> type ) ) ; } if ( $ inputTypeNode -> kind === NodeKind :: NON_NULL_TYPE ) { $ wrappedType = $ this -> buildWrappedType ( $ innerType , $ inputTypeNode -> type ) ; return Type :: nonNull ( NonNull :: assertNullableType ( $ wrappedType ) ) ; } return $ innerType ; } 
public function offsetExists ( $ offset ) { if ( $ offset === false ) { return $ this -> falseValueIsSet ; } if ( $ offset === true ) { return $ this -> trueValueIsSet ; } if ( is_int ( $ offset ) || is_string ( $ offset ) ) { return array_key_exists ( $ offset , $ this -> standardStore ) ; } if ( is_float ( $ offset ) ) { return array_key_exists ( ( string ) $ offset , $ this -> floatStore ) ; } if ( is_object ( $ offset ) ) { return $ this -> objectStore -> offsetExists ( $ offset ) ; } if ( is_array ( $ offset ) ) { foreach ( $ this -> arrayKeys as $ index => $ entry ) { if ( $ entry === $ offset ) { $ this -> lastArrayKey = $ offset ; $ this -> lastArrayValue = $ this -> arrayValues [ $ index ] ; return true ; } } } if ( $ offset === null ) { return $ this -> nullValueIsSet ; } return false ; } 
public function offsetGet ( $ offset ) { if ( $ offset === true ) { return $ this -> trueValue ; } if ( $ offset === false ) { return $ this -> falseValue ; } if ( is_int ( $ offset ) || is_string ( $ offset ) ) { return $ this -> standardStore [ $ offset ] ; } if ( is_float ( $ offset ) ) { return $ this -> floatStore [ ( string ) $ offset ] ; } if ( is_object ( $ offset ) ) { return $ this -> objectStore -> offsetGet ( $ offset ) ; } if ( is_array ( $ offset ) ) { 
public function offsetSet ( $ offset , $ value ) { if ( $ offset === false ) { $ this -> falseValue = $ value ; $ this -> falseValueIsSet = true ; } elseif ( $ offset === true ) { $ this -> trueValue = $ value ; $ this -> trueValueIsSet = true ; } elseif ( is_int ( $ offset ) || is_string ( $ offset ) ) { $ this -> standardStore [ $ offset ] = $ value ; } elseif ( is_float ( $ offset ) ) { $ this -> floatStore [ ( string ) $ offset ] = $ value ; } elseif ( is_object ( $ offset ) ) { $ this -> objectStore [ $ offset ] = $ value ; } elseif ( is_array ( $ offset ) ) { $ this -> arrayKeys [ ] = $ offset ; $ this -> arrayValues [ ] = $ value ; } elseif ( $ offset === null ) { $ this -> nullValue = $ value ; $ this -> nullValueIsSet = true ; } else { throw new InvalidArgumentException ( 'Unexpected offset type: ' . Utils :: printSafe ( $ offset ) ) ; } } 
public function offsetUnset ( $ offset ) { if ( $ offset === true ) { $ this -> trueValue = null ; $ this -> trueValueIsSet = false ; } elseif ( $ offset === false ) { $ this -> falseValue = null ; $ this -> falseValueIsSet = false ; } elseif ( is_int ( $ offset ) || is_string ( $ offset ) ) { unset ( $ this -> standardStore [ $ offset ] ) ; } elseif ( is_float ( $ offset ) ) { unset ( $ this -> floatStore [ ( string ) $ offset ] ) ; } elseif ( is_object ( $ offset ) ) { $ this -> objectStore -> offsetUnset ( $ offset ) ; } elseif ( is_array ( $ offset ) ) { $ index = array_search ( $ offset , $ this -> arrayKeys , true ) ; if ( $ index !== false ) { array_splice ( $ this -> arrayKeys , $ index , 1 ) ; array_splice ( $ this -> arrayValues , $ index , 1 ) ; } } elseif ( $ offset === null ) { $ this -> nullValue = null ; $ this -> nullValueIsSet = false ; } } 
public function getTypeMap ( ) { if ( ! $ this -> fullyLoaded ) { $ this -> resolvedTypes = $ this -> collectAllTypes ( ) ; $ this -> fullyLoaded = true ; } return $ this -> resolvedTypes ; } 
public function getType ( $ name ) { if ( ! isset ( $ this -> resolvedTypes [ $ name ] ) ) { $ type = $ this -> loadType ( $ name ) ; if ( ! $ type ) { return null ; } $ this -> resolvedTypes [ $ name ] = $ type ; } return $ this -> resolvedTypes [ $ name ] ; } 
private function loadType ( $ typeName ) { $ typeLoader = $ this -> config -> typeLoader ; if ( ! $ typeLoader ) { return $ this -> defaultTypeLoader ( $ typeName ) ; } $ type = $ typeLoader ( $ typeName ) ; if ( ! $ type instanceof Type ) { throw new InvariantViolation ( sprintf ( 'Type loader is expected to return valid type "%s", but it returned %s' , $ typeName , Utils :: printSafe ( $ type ) ) ) ; } if ( $ type -> name !== $ typeName ) { throw new InvariantViolation ( sprintf ( 'Type loader is expected to return type "%s", but it returned "%s"' , $ typeName , $ type -> name ) ) ; } return $ type ; } 
public function getPossibleTypes ( AbstractType $ abstractType ) { $ possibleTypeMap = $ this -> getPossibleTypeMap ( ) ; return isset ( $ possibleTypeMap [ $ abstractType -> name ] ) ? array_values ( $ possibleTypeMap [ $ abstractType -> name ] ) : [ ] ; } 
public function isPossibleType ( AbstractType $ abstractType , ObjectType $ possibleType ) { if ( $ abstractType instanceof InterfaceType ) { return $ possibleType -> implementsInterface ( $ abstractType ) ; } return $ abstractType -> isPossibleType ( $ possibleType ) ; } 
public function getDirective ( $ name ) { foreach ( $ this -> getDirectives ( ) as $ directive ) { if ( $ directive -> name === $ name ) { return $ directive ; } } return null ; } 
public function assertValid ( ) { $ errors = $ this -> validate ( ) ; if ( $ errors ) { throw new InvariantViolation ( implode ( "\n\n" , $ this -> validationErrors ) ) ; } $ internalTypes = Type :: getStandardTypes ( ) + Introspection :: getTypes ( ) ; foreach ( $ this -> getTypeMap ( ) as $ name => $ type ) { if ( isset ( $ internalTypes [ $ name ] ) ) { continue ; } $ type -> assertValid ( ) ; 
public function validate ( ) { 
public static function isEqualType ( Type $ typeA , Type $ typeB ) { 
public static function isTypeSubTypeOf ( Schema $ schema , $ maybeSubType , $ superType ) { 
public static function doTypesOverlap ( Schema $ schema , CompositeType $ typeA , CompositeType $ typeB ) { 
public function offsetGet ( $ offset ) { $ item = $ this -> nodes [ $ offset ] ; if ( is_array ( $ item ) && isset ( $ item [ 'kind' ] ) ) { $ this -> nodes [ $ offset ] = $ item = AST :: fromArray ( $ item ) ; } return $ item ; } 
public function splice ( $ offset , $ length , $ replacement = null ) { return new NodeList ( array_splice ( $ this -> nodes , $ offset , $ length , $ replacement ) ) ; } 
public function merge ( $ list ) { if ( $ list instanceof self ) { $ list = $ list -> nodes ; } return new NodeList ( array_merge ( $ this -> nodes , $ list ) ) ; } 
public static function visit ( $ root , $ visitor , $ keyMap = null ) { $ visitorKeys = $ keyMap ? : self :: $ visitorKeys ; $ stack = null ; $ inArray = $ root instanceof NodeList || is_array ( $ root ) ; $ keys = [ $ root ] ; $ index = - 1 ; $ edits = [ ] ; $ parent = null ; $ path = [ ] ; $ ancestors = [ ] ; $ newRoot = $ root ; $ UNDEFINED = null ; do { $ index ++ ; $ isLeaving = $ index === count ( $ keys ) ; $ key = null ; $ node = null ; $ isEdited = $ isLeaving && count ( $ edits ) !== 0 ; if ( $ isLeaving ) { $ key = ! $ ancestors ? $ UNDEFINED : $ path [ count ( $ path ) - 1 ] ; $ node = $ parent ; $ parent = array_pop ( $ ancestors ) ; if ( $ isEdited ) { if ( $ inArray ) { 
public static function visitInParallel ( $ visitors ) { $ visitorsCount = count ( $ visitors ) ; $ skipping = new SplFixedArray ( $ visitorsCount ) ; return [ 'enter' => static function ( Node $ node ) use ( $ visitors , $ skipping , $ visitorsCount ) { for ( $ i = 0 ; $ i < $ visitorsCount ; $ i ++ ) { if ( ! empty ( $ skipping [ $ i ] ) ) { continue ; } $ fn = self :: getVisitFn ( $ visitors [ $ i ] , $ node -> kind , false ) ; if ( ! $ fn ) { continue ; } $ result = call_user_func_array ( $ fn , func_get_args ( ) ) ; if ( $ result instanceof VisitorOperation ) { if ( $ result -> doContinue ) { $ skipping [ $ i ] = $ node ; } elseif ( $ result -> doBreak ) { $ skipping [ $ i ] = $ result ; } elseif ( $ result -> removeNode ) { return $ result ; } } elseif ( $ result !== null ) { return $ result ; } } } , 'leave' => static function ( Node $ node ) use ( $ visitors , $ skipping , $ visitorsCount ) { for ( $ i = 0 ; $ i < $ visitorsCount ; $ i ++ ) { if ( empty ( $ skipping [ $ i ] ) ) { $ fn = self :: getVisitFn ( $ visitors [ $ i ] , $ node -> kind , true ) ; if ( $ fn ) { $ result = call_user_func_array ( $ fn , func_get_args ( ) ) ; if ( $ result instanceof VisitorOperation ) { if ( $ result -> doBreak ) { $ skipping [ $ i ] = $ result ; } elseif ( $ result -> removeNode ) { return $ result ; } } elseif ( $ result !== null ) { return $ result ; } } } elseif ( $ skipping [ $ i ] === $ node ) { $ skipping [ $ i ] = null ; } } } , ] ; } 
public static function visitWithTypeInfo ( TypeInfo $ typeInfo , $ visitor ) { return [ 'enter' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ typeInfo -> enter ( $ node ) ; $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , false ) ; if ( $ fn ) { $ result = call_user_func_array ( $ fn , func_get_args ( ) ) ; if ( $ result !== null ) { $ typeInfo -> leave ( $ node ) ; if ( $ result instanceof Node ) { $ typeInfo -> enter ( $ result ) ; } } return $ result ; } return null ; } , 'leave' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , true ) ; $ result = $ fn ? call_user_func_array ( $ fn , func_get_args ( ) ) : null ; $ typeInfo -> leave ( $ node ) ; return $ result ; } , ] ; } 
public static function getVisitFn ( $ visitor , $ kind , $ isLeaving ) { if ( $ visitor === null ) { return null ; } $ kindVisitor = $ visitor [ $ kind ] ?? null ; if ( ! $ isLeaving && is_callable ( $ kindVisitor ) ) { 
public function parseHttpRequest ( ? callable $ readRawBodyFn = null ) { $ method = $ _SERVER [ 'REQUEST_METHOD' ] ?? null ; $ bodyParams = [ ] ; $ urlParams = $ _GET ; if ( $ method === 'POST' ) { $ contentType = $ _SERVER [ 'CONTENT_TYPE' ] ?? null ; if ( $ contentType === null ) { throw new RequestError ( 'Missing "Content-Type" header' ) ; } if ( stripos ( $ contentType , 'application/graphql' ) !== false ) { $ rawBody = $ readRawBodyFn ? $ readRawBodyFn ( ) : $ this -> readRawBody ( ) ; $ bodyParams = [ 'query' => $ rawBody ? : '' ] ; } elseif ( stripos ( $ contentType , 'application/json' ) !== false ) { $ rawBody = $ readRawBodyFn ? $ readRawBodyFn ( ) : $ this -> readRawBody ( ) ; $ bodyParams = json_decode ( $ rawBody ? : '' , true ) ; if ( json_last_error ( ) ) { throw new RequestError ( 'Could not parse JSON: ' . json_last_error_msg ( ) ) ; } if ( ! is_array ( $ bodyParams ) ) { throw new RequestError ( 'GraphQL Server expects JSON object or array, but got ' . Utils :: printSafeJson ( $ bodyParams ) ) ; } } elseif ( stripos ( $ contentType , 'application/x-www-form-urlencoded' ) !== false ) { $ bodyParams = $ _POST ; } elseif ( stripos ( $ contentType , 'multipart/form-data' ) !== false ) { $ bodyParams = $ _POST ; } else { throw new RequestError ( 'Unexpected content type: ' . Utils :: printSafeJson ( $ contentType ) ) ; } } return $ this -> parseRequestParams ( $ method , $ bodyParams , $ urlParams ) ; } 
public function parseRequestParams ( $ method , array $ bodyParams , array $ queryParams ) { if ( $ method === 'GET' ) { $ result = OperationParams :: create ( $ queryParams , true ) ; } elseif ( $ method === 'POST' ) { if ( isset ( $ bodyParams [ 0 ] ) ) { $ result = [ ] ; foreach ( $ bodyParams as $ index => $ entry ) { $ op = OperationParams :: create ( $ entry ) ; $ result [ ] = $ op ; } } else { $ result = OperationParams :: create ( $ bodyParams ) ; } } else { throw new RequestError ( 'HTTP Method "' . $ method . '" is not supported' ) ; } return $ result ; } 
public function validateOperationParams ( OperationParams $ params ) { $ errors = [ ] ; if ( ! $ params -> query && ! $ params -> queryId ) { $ errors [ ] = new RequestError ( 'GraphQL Request must include at least one of those two parameters: "query" or "queryId"' ) ; } if ( $ params -> query && $ params -> queryId ) { $ errors [ ] = new RequestError ( 'GraphQL Request parameters "query" and "queryId" are mutually exclusive' ) ; } if ( $ params -> query !== null && ( ! is_string ( $ params -> query ) || empty ( $ params -> query ) ) ) { $ errors [ ] = new RequestError ( 'GraphQL Request parameter "query" must be string, but got ' . Utils :: printSafeJson ( $ params -> query ) ) ; } if ( $ params -> queryId !== null && ( ! is_string ( $ params -> queryId ) || empty ( $ params -> queryId ) ) ) { $ errors [ ] = new RequestError ( 'GraphQL Request parameter "queryId" must be string, but got ' . Utils :: printSafeJson ( $ params -> queryId ) ) ; } if ( $ params -> operation !== null && ( ! is_string ( $ params -> operation ) || empty ( $ params -> operation ) ) ) { $ errors [ ] = new RequestError ( 'GraphQL Request parameter "operation" must be string, but got ' . Utils :: printSafeJson ( $ params -> operation ) ) ; } if ( $ params -> variables !== null && ( ! is_array ( $ params -> variables ) || isset ( $ params -> variables [ 0 ] ) ) ) { $ errors [ ] = new RequestError ( 'GraphQL Request parameter "variables" must be object or JSON string parsed to object, but got ' . Utils :: printSafeJson ( $ params -> getOriginalInput ( 'variables' ) ) ) ; } return $ errors ; } 
public function executeOperation ( ServerConfig $ config , OperationParams $ op ) { $ promiseAdapter = $ config -> getPromiseAdapter ( ) ? : Executor :: getPromiseAdapter ( ) ; $ result = $ this -> promiseToExecuteOperation ( $ promiseAdapter , $ config , $ op ) ; if ( $ promiseAdapter instanceof SyncPromiseAdapter ) { $ result = $ promiseAdapter -> wait ( $ result ) ; } return $ result ; } 
public function executeBatch ( ServerConfig $ config , array $ operations ) { $ promiseAdapter = $ config -> getPromiseAdapter ( ) ? : Executor :: getPromiseAdapter ( ) ; $ result = [ ] ; foreach ( $ operations as $ operation ) { $ result [ ] = $ this -> promiseToExecuteOperation ( $ promiseAdapter , $ config , $ operation , true ) ; } $ result = $ promiseAdapter -> all ( $ result ) ; 
private function promiseToExecuteOperation ( PromiseAdapter $ promiseAdapter , ServerConfig $ config , OperationParams $ op , $ isBatch = false ) { try { if ( ! $ config -> getSchema ( ) ) { throw new InvariantViolation ( 'Schema is required for the server' ) ; } if ( $ isBatch && ! $ config -> getQueryBatching ( ) ) { throw new RequestError ( 'Batched queries are not supported by this server' ) ; } $ errors = $ this -> validateOperationParams ( $ op ) ; if ( ! empty ( $ errors ) ) { $ errors = Utils :: map ( $ errors , static function ( RequestError $ err ) { return Error :: createLocatedError ( $ err , null , null ) ; } ) ; return $ promiseAdapter -> createFulfilled ( new ExecutionResult ( null , $ errors ) ) ; } $ doc = $ op -> queryId ? $ this -> loadPersistedQuery ( $ config , $ op ) : $ op -> query ; if ( ! $ doc instanceof DocumentNode ) { $ doc = Parser :: parse ( $ doc ) ; } $ operationType = AST :: getOperation ( $ doc , $ op -> operation ) ; if ( $ operationType !== 'query' && $ op -> isReadOnly ( ) ) { throw new RequestError ( 'GET supports only query operation' ) ; } $ result = GraphQL :: promiseToExecute ( $ promiseAdapter , $ config -> getSchema ( ) , $ doc , $ this -> resolveRootValue ( $ config , $ op , $ doc , $ operationType ) , $ this -> resolveContextValue ( $ config , $ op , $ doc , $ operationType ) , $ op -> variables , $ op -> operation , $ config -> getFieldResolver ( ) , $ this -> resolveValidationRules ( $ config , $ op , $ doc , $ operationType ) ) ; } catch ( RequestError $ e ) { $ result = $ promiseAdapter -> createFulfilled ( new ExecutionResult ( null , [ Error :: createLocatedError ( $ e ) ] ) ) ; } catch ( Error $ e ) { $ result = $ promiseAdapter -> createFulfilled ( new ExecutionResult ( null , [ $ e ] ) ) ; } $ applyErrorHandling = static function ( ExecutionResult $ result ) use ( $ config ) { if ( $ config -> getErrorsHandler ( ) ) { $ result -> setErrorsHandler ( $ config -> getErrorsHandler ( ) ) ; } if ( $ config -> getErrorFormatter ( ) || $ config -> getDebug ( ) ) { $ result -> setErrorFormatter ( FormattedError :: prepareFormatter ( $ config -> getErrorFormatter ( ) , $ config -> getDebug ( ) ) ) ; } return $ result ; } ; return $ result -> then ( $ applyErrorHandling ) ; } 
private function loadPersistedQuery ( ServerConfig $ config , OperationParams $ operationParams ) { 
private function resolveValidationRules ( ServerConfig $ config , OperationParams $ params , DocumentNode $ doc , $ operationType ) { 
private function resolveRootValue ( ServerConfig $ config , OperationParams $ params , DocumentNode $ doc , $ operationType ) { $ root = $ config -> getRootValue ( ) ; if ( is_callable ( $ root ) ) { $ root = $ root ( $ params , $ doc , $ operationType ) ; } return $ root ; } 
private function resolveContextValue ( ServerConfig $ config , OperationParams $ params , DocumentNode $ doc , $ operationType ) { $ context = $ config -> getContext ( ) ; if ( is_callable ( $ context ) ) { $ context = $ context ( $ params , $ doc , $ operationType ) ; } return $ context ; } 
public function sendResponse ( $ result , $ exitWhenDone = false ) { if ( $ result instanceof Promise ) { $ result -> then ( function ( $ actualResult ) use ( $ exitWhenDone ) { $ this -> doSendResponse ( $ actualResult , $ exitWhenDone ) ; } ) ; } else { $ this -> doSendResponse ( $ result , $ exitWhenDone ) ; } } 
private function resolveHttpStatus ( $ result ) { if ( is_array ( $ result ) && isset ( $ result [ 0 ] ) ) { Utils :: each ( $ result , static function ( $ executionResult , $ index ) { if ( ! $ executionResult instanceof ExecutionResult ) { throw new InvariantViolation ( sprintf ( 'Expecting every entry of batched query result to be instance of %s but entry at position %d is %s' , ExecutionResult :: class , $ index , Utils :: printSafe ( $ executionResult ) ) ) ; } } ) ; $ httpStatus = 200 ; } else { if ( ! $ result instanceof ExecutionResult ) { throw new InvariantViolation ( sprintf ( 'Expecting query result to be instance of %s but got %s' , ExecutionResult :: class , Utils :: printSafe ( $ result ) ) ) ; } if ( $ result -> data === null && ! empty ( $ result -> errors ) ) { $ httpStatus = 400 ; } else { $ httpStatus = 200 ; } } return $ httpStatus ; } 
public function parsePsrRequest ( ServerRequestInterface $ request ) { if ( $ request -> getMethod ( ) === 'GET' ) { $ bodyParams = [ ] ; } else { $ contentType = $ request -> getHeader ( 'content-type' ) ; if ( ! isset ( $ contentType [ 0 ] ) ) { throw new RequestError ( 'Missing "Content-Type" header' ) ; } if ( stripos ( $ contentType [ 0 ] , 'application/graphql' ) !== false ) { $ bodyParams = [ 'query' => $ request -> getBody ( ) -> getContents ( ) ] ; } elseif ( stripos ( $ contentType [ 0 ] , 'application/json' ) !== false ) { $ bodyParams = $ request -> getParsedBody ( ) ; if ( $ bodyParams === null ) { throw new InvariantViolation ( 'PSR-7 request is expected to provide parsed body for "application/json" requests but got null' ) ; } if ( ! is_array ( $ bodyParams ) ) { throw new RequestError ( 'GraphQL Server expects JSON object or array, but got ' . Utils :: printSafeJson ( $ bodyParams ) ) ; } } else { $ bodyParams = $ request -> getParsedBody ( ) ; if ( ! is_array ( $ bodyParams ) ) { throw new RequestError ( 'Unexpected content type: ' . Utils :: printSafeJson ( $ contentType [ 0 ] ) ) ; } } } return $ this -> parseRequestParams ( $ request -> getMethod ( ) , $ bodyParams , $ request -> getQueryParams ( ) ) ; } 
public function toPsrResponse ( $ result , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { if ( $ result instanceof Promise ) { return $ result -> then ( function ( $ actualResult ) use ( $ response , $ writableBodyStream ) { return $ this -> doConvertToPsrResponse ( $ actualResult , $ response , $ writableBodyStream ) ; } ) ; } return $ this -> doConvertToPsrResponse ( $ result , $ response , $ writableBodyStream ) ; } 
private function cloneValue ( $ value ) { if ( is_array ( $ value ) ) { $ cloned = [ ] ; foreach ( $ value as $ key => $ arrValue ) { $ cloned [ $ key ] = $ this -> cloneValue ( $ arrValue ) ; } } elseif ( $ value instanceof self ) { $ cloned = clone $ value ; foreach ( get_object_vars ( $ cloned ) as $ prop => $ propValue ) { $ cloned -> { $ prop } = $ this -> cloneValue ( $ propValue ) ; } } else { $ cloned = $ value ; } return $ cloned ; } 
public function toArray ( $ recursive = false ) { if ( $ recursive ) { return $ this -> recursiveToArray ( $ this ) ; } $ tmp = ( array ) $ this ; if ( $ this -> loc ) { $ tmp [ 'loc' ] = [ 'start' => $ this -> loc -> start , 'end' => $ this -> loc -> end , ] ; } return $ tmp ; } 
public function parseLiteral ( $ valueNode , ? array $ variables = null ) { if ( $ valueNode instanceof FloatValueNode || $ valueNode instanceof IntValueNode ) { return ( float ) $ valueNode -> value ; } 
public function resolveType ( $ objectValue , $ context , ResolveInfo $ info ) { if ( isset ( $ this -> config [ 'resolveType' ] ) ) { $ fn = $ this -> config [ 'resolveType' ] ; return $ fn ( $ objectValue , $ context , $ info ) ; } return null ; } 
public static function assign ( $ obj , array $ vars , array $ requiredKeys = [ ] ) { foreach ( $ requiredKeys as $ key ) { if ( ! isset ( $ vars [ $ key ] ) ) { throw new InvalidArgumentException ( sprintf ( 'Key %s is expected to be set and not to be null' , $ key ) ) ; } } foreach ( $ vars as $ key => $ value ) { if ( ! property_exists ( $ obj , $ key ) ) { $ cls = get_class ( $ obj ) ; Warning :: warn ( sprintf ( "Trying to set non-existing property '%s' on class '%s'" , $ key , $ cls ) , Warning :: WARNING_ASSIGN ) ; } $ obj -> { $ key } = $ value ; } return $ obj ; } 
public static function find ( $ traversable , callable $ predicate ) { self :: invariant ( is_array ( $ traversable ) || $ traversable instanceof Traversable , __METHOD__ . ' expects array or Traversable' ) ; foreach ( $ traversable as $ key => $ value ) { if ( $ predicate ( $ value , $ key ) ) { return $ value ; } } return null ; } 
public static function filter ( $ traversable , callable $ predicate ) { self :: invariant ( is_array ( $ traversable ) || $ traversable instanceof Traversable , __METHOD__ . ' expects array or Traversable' ) ; $ result = [ ] ; $ assoc = false ; foreach ( $ traversable as $ key => $ value ) { if ( ! $ assoc && ! is_int ( $ key ) ) { $ assoc = true ; } if ( ! $ predicate ( $ value , $ key ) ) { continue ; } $ result [ $ key ] = $ value ; } return $ assoc ? $ result : array_values ( $ result ) ; } 
public static function map ( $ traversable , callable $ fn ) { self :: invariant ( is_array ( $ traversable ) || $ traversable instanceof Traversable , __METHOD__ . ' expects array or Traversable' ) ; $ map = [ ] ; foreach ( $ traversable as $ key => $ value ) { $ map [ $ key ] = $ fn ( $ value , $ key ) ; } return $ map ; } 
public static function mapKeyValue ( $ traversable , callable $ fn ) { self :: invariant ( is_array ( $ traversable ) || $ traversable instanceof Traversable , __METHOD__ . ' expects array or Traversable' ) ; $ map = [ ] ; foreach ( $ traversable as $ key => $ value ) { [ $ newKey , $ newValue ] = $ fn ( $ value , $ key ) ; $ map [ $ newKey ] = $ newValue ; } return $ map ; } 
public static function keyMap ( $ traversable , callable $ keyFn ) { self :: invariant ( is_array ( $ traversable ) || $ traversable instanceof Traversable , __METHOD__ . ' expects array or Traversable' ) ; $ map = [ ] ; foreach ( $ traversable as $ key => $ value ) { $ newKey = $ keyFn ( $ value , $ key ) ; if ( ! is_scalar ( $ newKey ) ) { continue ; } $ map [ $ newKey ] = $ value ; } return $ map ; } 
public static function groupBy ( $ traversable , callable $ keyFn ) { self :: invariant ( is_array ( $ traversable ) || $ traversable instanceof Traversable , __METHOD__ . ' expects array or Traversable' ) ; $ grouped = [ ] ; foreach ( $ traversable as $ key => $ value ) { $ newKeys = ( array ) $ keyFn ( $ value , $ key ) ; foreach ( $ newKeys as $ newKey ) { $ grouped [ $ newKey ] [ ] = $ value ; } } return $ grouped ; } 
public static function keyValMap ( $ traversable , callable $ keyFn , callable $ valFn ) { $ map = [ ] ; foreach ( $ traversable as $ item ) { $ map [ $ keyFn ( $ item ) ] = $ valFn ( $ item ) ; } return $ map ; } 
public static function every ( $ traversable , callable $ predicate ) { foreach ( $ traversable as $ key => $ value ) { if ( ! $ predicate ( $ value , $ key ) ) { return false ; } } return true ; } 
public static function printSafeJson ( $ var ) { if ( $ var instanceof stdClass ) { $ var = ( array ) $ var ; } if ( is_array ( $ var ) ) { return json_encode ( $ var ) ; } if ( $ var === '' ) { return '(empty string)' ; } if ( $ var === null ) { return 'null' ; } if ( $ var === false ) { return 'false' ; } if ( $ var === true ) { return 'true' ; } if ( is_string ( $ var ) ) { return sprintf ( '"%s"' , $ var ) ; } if ( is_scalar ( $ var ) ) { return ( string ) $ var ; } return gettype ( $ var ) ; } 
public static function printSafe ( $ var ) { if ( $ var instanceof Type ) { return $ var -> toString ( ) ; } if ( is_object ( $ var ) ) { if ( method_exists ( $ var , '__toString' ) ) { return ( string ) $ var ; } return 'instance of ' . get_class ( $ var ) ; } if ( is_array ( $ var ) ) { return json_encode ( $ var ) ; } if ( $ var === '' ) { return '(empty string)' ; } if ( $ var === null ) { return 'null' ; } if ( $ var === false ) { return 'false' ; } if ( $ var === true ) { return 'true' ; } if ( is_string ( $ var ) ) { return $ var ; } if ( is_scalar ( $ var ) ) { return ( string ) $ var ; } return gettype ( $ var ) ; } 
public static function chr ( $ ord , $ encoding = 'UTF-8' ) { if ( $ ord <= 255 ) { return chr ( $ ord ) ; } if ( $ encoding === 'UCS-4BE' ) { return pack ( 'N' , $ ord ) ; } return mb_convert_encoding ( self :: chr ( $ ord , 'UCS-4BE' ) , $ encoding , 'UCS-4BE' ) ; } 
public static function ord ( $ char , $ encoding = 'UTF-8' ) { if ( ! $ char && $ char !== '0' ) { return 0 ; } if ( ! isset ( $ char [ 1 ] ) ) { return ord ( $ char ) ; } if ( $ encoding !== 'UCS-4BE' ) { $ char = mb_convert_encoding ( $ char , 'UCS-4BE' , $ encoding ) ; } return unpack ( 'N' , $ char ) [ 1 ] ; } 
public static function charCodeAt ( $ string , $ position ) { $ char = mb_substr ( $ string , $ position , 1 , 'UTF-8' ) ; return self :: ord ( $ char ) ; } 
public static function printCharCode ( $ code ) { if ( $ code === null ) { return '<EOF>' ; } return $ code < 0x007F 
public static function isValidNameError ( $ name , $ node = null ) { self :: invariant ( is_string ( $ name ) , 'Expected string' ) ; if ( isset ( $ name [ 1 ] ) && $ name [ 0 ] === '_' && $ name [ 1 ] === '_' ) { return new Error ( sprintf ( 'Name "%s" must not begin with "__", which is reserved by ' , $ name ) . 'GraphQL introspection.' , $ node ) ; } if ( ! preg_match ( '/^[_a-zA-Z][_a-zA-Z0-9]*$/' , $ name ) ) { return new Error ( sprintf ( 'Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "%s" does not.' , $ name ) , $ node ) ; } return null ; } 
public static function withErrorHandling ( callable $ fn , array & $ errors ) { return static function ( ) use ( $ fn , & $ errors ) { 
public static function quotedOrList ( array $ items ) { $ items = array_map ( static function ( $ item ) { return sprintf ( '"%s"' , $ item ) ; } , $ items ) ; return self :: orList ( $ items ) ; } 
public static function orList ( array $ items ) { if ( count ( $ items ) === 0 ) { throw new LogicException ( 'items must not need to be empty.' ) ; } $ selected = array_slice ( $ items , 0 , 5 ) ; $ selectedLength = count ( $ selected ) ; $ firstSelected = $ selected [ 0 ] ; if ( $ selectedLength === 1 ) { return $ firstSelected ; } return array_reduce ( range ( 1 , $ selectedLength - 1 ) , static function ( $ list , $ index ) use ( $ selected , $ selectedLength ) { return $ list . ( $ selectedLength > 2 ? ', ' : ' ' ) . ( $ index === $ selectedLength - 1 ? 'or ' : '' ) . $ selected [ $ index ] ; } , $ firstSelected ) ; } 
public static function suggestionList ( $ input , array $ options ) { $ optionsByDistance = [ ] ; $ inputThreshold = mb_strlen ( $ input ) / 2 ; foreach ( $ options as $ option ) { if ( $ input === $ option ) { $ distance = 0 ; } else { $ distance = ( strtolower ( $ input ) === strtolower ( $ option ) ? 1 : levenshtein ( $ input , $ option ) ) ; } $ threshold = max ( $ inputThreshold , mb_strlen ( $ option ) / 2 , 1 ) ; if ( $ distance > $ threshold ) { continue ; } $ optionsByDistance [ $ option ] = $ distance ; } asort ( $ optionsByDistance ) ; return array_keys ( $ optionsByDistance ) ; } 
public static function execute ( Schema $ schema , DocumentNode $ documentNode , $ rootValue = null , $ contextValue = null , $ variableValues = null , $ operationName = null , ? callable $ fieldResolver = null ) { 
public static function promiseToExecute ( PromiseAdapter $ promiseAdapter , Schema $ schema , DocumentNode $ documentNode , $ rootValue = null , $ contextValue = null , $ variableValues = null , $ operationName = null , ? callable $ fieldResolver = null ) { $ factory = self :: $ implementationFactory ; $ executor = $ factory ( $ promiseAdapter , $ schema , $ documentNode , $ rootValue , $ contextValue , $ variableValues , $ operationName , $ fieldResolver ? : self :: $ defaultFieldResolver ) ; return $ executor -> doExecute ( ) ; } 
public static function defaultFieldResolver ( $ source , $ args , $ context , ResolveInfo $ info ) { $ fieldName = $ info -> fieldName ; $ property = null ; if ( is_array ( $ source ) || $ source instanceof ArrayAccess ) { if ( isset ( $ source [ $ fieldName ] ) ) { $ property = $ source [ $ fieldName ] ; } } elseif ( is_object ( $ source ) ) { if ( isset ( $ source -> { $ fieldName } ) ) { $ property = $ source -> { $ fieldName } ; } } return $ property instanceof Closure ? $ property ( $ source , $ args , $ context , $ info ) : $ property ; } 
private function readToken ( Token $ prev ) { $ bodyLength = $ this -> source -> length ; $ this -> positionAfterWhitespace ( ) ; $ position = $ this -> position ; $ line = $ this -> line ; $ col = 1 + $ position - $ this -> lineStart ; if ( $ position >= $ bodyLength ) { return new Token ( Token :: EOF , $ bodyLength , $ bodyLength , $ line , $ col , $ prev ) ; } 
private function readName ( $ line , $ col , Token $ prev ) { $ value = '' ; $ start = $ this -> position ; [ $ char , $ code ] = $ this -> readChar ( ) ; while ( $ code && ( $ code === 95 || 
private function readNumber ( $ line , $ col , Token $ prev ) { $ value = '' ; $ start = $ this -> position ; [ $ char , $ code ] = $ this -> readChar ( ) ; $ isFloat = false ; if ( $ code === 45 ) { 
private function readDigits ( ) { [ $ char , $ code ] = $ this -> readChar ( ) ; if ( $ code >= 48 && $ code <= 57 ) { 
private function readString ( $ line , $ col , Token $ prev ) { $ start = $ this -> position ; 
private function readBlockString ( $ line , $ col , Token $ prev ) { $ start = $ this -> position ; 
private function positionAfterWhitespace ( ) { while ( $ this -> position < $ this -> source -> length ) { [ , $ code , $ bytes ] = $ this -> readChar ( ) ; 
private function readComment ( $ line , $ col , Token $ prev ) { $ start = $ this -> position ; $ value = '' ; $ bytes = 1 ; do { [ $ char , $ code , $ bytes ] = $ this -> moveStringCursor ( 1 , $ bytes ) -> readChar ( ) ; $ value .= $ char ; } while ( $ code && 
private function readChar ( $ advance = false , $ byteStreamPosition = null ) { if ( $ byteStreamPosition === null ) { $ byteStreamPosition = $ this -> byteStreamPosition ; } $ code = null ; $ utf8char = '' ; $ bytes = 0 ; $ positionOffset = 0 ; if ( isset ( $ this -> source -> body [ $ byteStreamPosition ] ) ) { $ ord = ord ( $ this -> source -> body [ $ byteStreamPosition ] ) ; if ( $ ord < 128 ) { $ bytes = 1 ; } elseif ( $ ord < 224 ) { $ bytes = 2 ; } elseif ( $ ord < 240 ) { $ bytes = 3 ; } else { $ bytes = 4 ; } $ utf8char = '' ; for ( $ pos = $ byteStreamPosition ; $ pos < $ byteStreamPosition + $ bytes ; $ pos ++ ) { $ utf8char .= $ this -> source -> body [ $ pos ] ; } $ positionOffset = 1 ; $ code = $ bytes === 1 ? $ ord : Utils :: ord ( $ utf8char ) ; } if ( $ advance ) { $ this -> moveStringCursor ( $ positionOffset , $ bytes ) ; } return [ $ utf8char , $ code , $ bytes ] ; } 
private function readChars ( $ charCount , $ advance = false , $ byteStreamPosition = null ) { $ result = '' ; $ totalBytes = 0 ; $ byteOffset = $ byteStreamPosition ? : $ this -> byteStreamPosition ; for ( $ i = 0 ; $ i < $ charCount ; $ i ++ ) { [ $ char , $ code , $ bytes ] = $ this -> readChar ( false , $ byteOffset ) ; $ totalBytes += $ bytes ; $ byteOffset += $ bytes ; $ result .= $ char ; } if ( $ advance ) { $ this -> moveStringCursor ( $ charCount , $ totalBytes ) ; } return [ $ result , $ totalBytes ] ; } 
private function moveStringCursor ( $ positionOffset , $ byteStreamOffset ) { $ this -> position += $ positionOffset ; $ this -> byteStreamPosition += $ byteStreamOffset ; return $ this ; } 
private function getDirectiveLocationForASTPath ( array $ ancestors ) { $ appliedTo = $ ancestors [ count ( $ ancestors ) - 1 ] ; switch ( $ appliedTo -> kind ) { case NodeKind :: OPERATION_DEFINITION : switch ( $ appliedTo -> operation ) { case 'query' : return DirectiveLocation :: QUERY ; case 'mutation' : return DirectiveLocation :: MUTATION ; case 'subscription' : return DirectiveLocation :: SUBSCRIPTION ; } break ; case NodeKind :: FIELD : return DirectiveLocation :: FIELD ; case NodeKind :: FRAGMENT_SPREAD : return DirectiveLocation :: FRAGMENT_SPREAD ; case NodeKind :: INLINE_FRAGMENT : return DirectiveLocation :: INLINE_FRAGMENT ; case NodeKind :: FRAGMENT_DEFINITION : return DirectiveLocation :: FRAGMENT_DEFINITION ; case NodeKind :: SCHEMA_DEFINITION : case NodeKind :: SCHEMA_EXTENSION : return DirectiveLocation :: SCHEMA ; case NodeKind :: SCALAR_TYPE_DEFINITION : case NodeKind :: SCALAR_TYPE_EXTENSION : return DirectiveLocation :: SCALAR ; case NodeKind :: OBJECT_TYPE_DEFINITION : case NodeKind :: OBJECT_TYPE_EXTENSION : return DirectiveLocation :: OBJECT ; case NodeKind :: FIELD_DEFINITION : return DirectiveLocation :: FIELD_DEFINITION ; case NodeKind :: INTERFACE_TYPE_DEFINITION : case NodeKind :: INTERFACE_TYPE_EXTENSION : return DirectiveLocation :: IFACE ; case NodeKind :: UNION_TYPE_DEFINITION : case NodeKind :: UNION_TYPE_EXTENSION : return DirectiveLocation :: UNION ; case NodeKind :: ENUM_TYPE_DEFINITION : case NodeKind :: ENUM_TYPE_EXTENSION : return DirectiveLocation :: ENUM ; case NodeKind :: ENUM_VALUE_DEFINITION : return DirectiveLocation :: ENUM_VALUE ; case NodeKind :: INPUT_OBJECT_TYPE_DEFINITION : case NodeKind :: INPUT_OBJECT_TYPE_EXTENSION : return DirectiveLocation :: INPUT_OBJECT ; case NodeKind :: INPUT_VALUE_DEFINITION : $ parentNode = $ ancestors [ count ( $ ancestors ) - 3 ] ; return $ parentNode instanceof InputObjectTypeDefinitionNode ? DirectiveLocation :: INPUT_FIELD_DEFINITION : DirectiveLocation :: ARGUMENT_DEFINITION ; } } 
public static function create ( array $ config = [ ] ) { $ instance = new static ( ) ; foreach ( $ config as $ key => $ value ) { $ method = 'set' . ucfirst ( $ key ) ; if ( ! method_exists ( $ instance , $ method ) ) { throw new InvariantViolation ( sprintf ( 'Unknown server config option "%s"' , $ key ) ) ; } $ instance -> $ method ( $ value ) ; } return $ instance ; } 
public function setValidationRules ( $ validationRules ) { if ( ! is_callable ( $ validationRules ) && ! is_array ( $ validationRules ) && $ validationRules !== null ) { throw new InvariantViolation ( 'Server config expects array of validation rules or callable returning such array, but got ' . Utils :: printSafe ( $ validationRules ) ) ; } $ this -> validationRules = $ validationRules ; return $ this ; } 
private static function getStandardType ( $ name = null ) { if ( self :: $ standardTypes === null ) { self :: $ standardTypes = [ self :: ID => new IDType ( ) , self :: STRING => new StringType ( ) , self :: FLOAT => new FloatType ( ) , self :: INT => new IntType ( ) , self :: BOOLEAN => new BooleanType ( ) , ] ; } return $ name ? self :: $ standardTypes [ $ name ] : self :: $ standardTypes ; } 
public static function isBuiltInType ( Type $ type ) { return in_array ( $ type -> name , array_keys ( self :: getAllBuiltInTypes ( ) ) , true ) ; } 
public static function getAllBuiltInTypes ( ) { if ( self :: $ builtInTypes === null ) { self :: $ builtInTypes = array_merge ( Introspection :: getTypes ( ) , self :: getStandardTypes ( ) ) ; } return self :: $ builtInTypes ; } 
public static function isInputType ( $ type ) { return $ type instanceof InputType && ( ! $ type instanceof WrappingType || self :: getNamedType ( $ type ) instanceof InputType ) ; } 
public static function getNamedType ( $ type ) { if ( $ type === null ) { return null ; } while ( $ type instanceof WrappingType ) { $ type = $ type -> getWrappedType ( ) ; } return $ type ; } 
public static function isOutputType ( $ type ) { return $ type instanceof OutputType && ( ! $ type instanceof WrappingType || self :: getNamedType ( $ type ) instanceof OutputType ) ; } 
public static function assertType ( $ type ) { Utils :: invariant ( self :: isType ( $ type ) , 'Expected ' . Utils :: printSafe ( $ type ) . ' to be a GraphQL type.' ) ; return $ type ; } 
public function buildSelectionSet ( $ fields ) { $ selections [ ] = new FieldNode ( [ 'name' => new NameNode ( [ 'value' => '__typename' ] ) , ] ) ; $ this -> currentLeafFields ++ ; foreach ( $ fields as $ field ) { if ( $ this -> currentLeafFields >= $ this -> maxLeafFields ) { break ; } $ type = $ field -> getType ( ) ; if ( $ type instanceof WrappingType ) { $ type = $ type -> getWrappedType ( true ) ; } if ( $ type instanceof ObjectType || $ type instanceof InterfaceType ) { $ selectionSet = $ this -> buildSelectionSet ( $ type -> getFields ( ) ) ; } else { $ selectionSet = null ; $ this -> currentLeafFields ++ ; } $ selections [ ] = new FieldNode ( [ 'name' => new NameNode ( [ 'value' => $ field -> name ] ) , 'selectionSet' => $ selectionSet , ] ) ; } $ selectionSet = new SelectionSetNode ( [ 'selections' => $ selections , ] ) ; return $ selectionSet ; } 
public function getArg ( $ name ) { foreach ( $ this -> args ? : [ ] as $ arg ) { if ( $ arg -> name === $ name ) { return $ arg ; } } return null ; } 
private function analyzeSelectionSet ( SelectionSetNode $ selectionSet , ObjectType $ parentType ) : array { $ fields = [ ] ; foreach ( $ selectionSet -> selections as $ selectionNode ) { if ( $ selectionNode instanceof FieldNode ) { $ fieldName = $ selectionNode -> name -> value ; $ type = $ parentType -> getField ( $ fieldName ) ; $ selectionType = $ type -> getType ( ) ; $ subfields = [ ] ; if ( $ selectionNode -> selectionSet ) { $ subfields = $ this -> analyzeSubFields ( $ selectionType , $ selectionNode -> selectionSet ) ; } $ fields [ $ fieldName ] = [ 'type' => $ selectionType , 'fields' => $ subfields ?? [ ] , 'args' => Values :: getArgumentValues ( $ type , $ selectionNode , $ this -> variableValues ) , ] ; } elseif ( $ selectionNode instanceof FragmentSpreadNode ) { $ spreadName = $ selectionNode -> name -> value ; if ( isset ( $ this -> fragments [ $ spreadName ] ) ) { $ fragment = $ this -> fragments [ $ spreadName ] ; $ type = $ this -> schema -> getType ( $ fragment -> typeCondition -> name -> value ) ; $ subfields = $ this -> analyzeSubFields ( $ type , $ fragment -> selectionSet ) ; $ fields = $ this -> arrayMergeDeep ( $ subfields , $ fields ) ; } } elseif ( $ selectionNode instanceof InlineFragmentNode ) { $ type = $ this -> schema -> getType ( $ selectionNode -> typeCondition -> name -> value ) ; $ subfields = $ this -> analyzeSubFields ( $ type , $ selectionNode -> selectionSet ) ; $ fields = $ this -> arrayMergeDeep ( $ subfields , $ fields ) ; } } return $ fields ; } 
private function arrayMergeDeep ( array $ array1 , array $ array2 ) : array { $ merged = $ array1 ; foreach ( $ array2 as $ key => & $ value ) { if ( is_numeric ( $ key ) ) { if ( ! in_array ( $ value , $ merged , true ) ) { $ merged [ ] = $ value ; } } elseif ( is_array ( $ value ) && isset ( $ merged [ $ key ] ) && is_array ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = $ this -> arrayMergeDeep ( $ merged [ $ key ] , $ value ) ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; } 
public static function createLocatedError ( $ error , $ nodes = null , $ path = null ) { if ( $ error instanceof self ) { if ( $ error -> path && $ error -> nodes ) { return $ error ; } $ nodes = $ nodes ? : $ error -> nodes ; $ path = $ path ? : $ error -> path ; } $ source = $ positions = $ originalError = null ; $ extensions = [ ] ; if ( $ error instanceof self ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; $ nodes = $ error -> nodes ? : $ nodes ; $ source = $ error -> source ; $ positions = $ error -> positions ; $ extensions = $ error -> extensions ; } elseif ( $ error instanceof Exception || $ error instanceof Throwable ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; } else { $ message = ( string ) $ error ; } return new static ( $ message ? : 'An unknown error occurred.' , $ nodes , $ source , $ positions , $ path , $ originalError , $ extensions ) ; } 
public function getLocations ( ) { if ( $ this -> locations === null ) { $ positions = $ this -> getPositions ( ) ; $ source = $ this -> getSource ( ) ; $ nodes = $ this -> nodes ; if ( $ positions && $ source ) { $ this -> locations = array_map ( static function ( $ pos ) use ( $ source ) { return $ source -> getLocation ( $ pos ) ; } , $ positions ) ; } elseif ( $ nodes ) { $ locations = array_filter ( array_map ( static function ( $ node ) { if ( $ node -> loc && $ node -> loc -> source ) { return $ node -> loc -> source -> getLocation ( $ node -> loc -> start ) ; } } , $ nodes ) ) ; $ this -> locations = array_values ( $ locations ) ; } else { $ this -> locations = [ ] ; } } return $ this -> locations ; } 
public function toSerializableArray ( ) { $ arr = [ 'message' => $ this -> getMessage ( ) , ] ; $ locations = Utils :: map ( $ this -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ arr [ 'locations' ] = $ locations ; } if ( ! empty ( $ this -> path ) ) { $ arr [ 'path' ] = $ this -> path ; } if ( ! empty ( $ this -> extensions ) ) { $ arr [ 'extensions' ] = $ this -> extensions ; } return $ arr ; } 
private static function buildExecutionContext ( Schema $ schema , DocumentNode $ documentNode , $ rootValue , $ contextValue , $ rawVariableValues , $ operationName = null , ? callable $ fieldResolver = null , ? PromiseAdapter $ promiseAdapter = null ) { $ errors = [ ] ; $ fragments = [ ] ; $ operation = null ; $ hasMultipleAssumedOperations = false ; foreach ( $ documentNode -> definitions as $ definition ) { switch ( $ definition -> kind ) { case NodeKind :: OPERATION_DEFINITION : if ( ! $ operationName && $ operation ) { $ hasMultipleAssumedOperations = true ; } if ( ! $ operationName || ( isset ( $ definition -> name ) && $ definition -> name -> value === $ operationName ) ) { $ operation = $ definition ; } break ; case NodeKind :: FRAGMENT_DEFINITION : $ fragments [ $ definition -> name -> value ] = $ definition ; break ; } } if ( $ operation === null ) { if ( $ operationName ) { $ errors [ ] = new Error ( sprintf ( 'Unknown operation named "%s".' , $ operationName ) ) ; } else { $ errors [ ] = new Error ( 'Must provide an operation.' ) ; } } elseif ( $ hasMultipleAssumedOperations ) { $ errors [ ] = new Error ( 'Must provide operation name if query contains multiple operations.' ) ; } $ variableValues = null ; if ( $ operation !== null ) { [ $ coercionErrors , $ coercedVariableValues ] = Values :: getVariableValues ( $ schema , $ operation -> variableDefinitions ? : [ ] , $ rawVariableValues ? : [ ] ) ; if ( empty ( $ coercionErrors ) ) { $ variableValues = $ coercedVariableValues ; } else { $ errors = array_merge ( $ errors , $ coercionErrors ) ; } } if ( ! empty ( $ errors ) ) { return $ errors ; } Utils :: invariant ( $ operation , 'Has operation if no errors.' ) ; Utils :: invariant ( $ variableValues !== null , 'Has variables if no errors.' ) ; return new ExecutionContext ( $ schema , $ fragments , $ rootValue , $ contextValue , $ operation , $ variableValues , $ errors , $ fieldResolver , $ promiseAdapter ) ; } 
private function buildResponse ( $ data ) { if ( $ this -> isPromise ( $ data ) ) { return $ data -> then ( function ( $ resolved ) { return $ this -> buildResponse ( $ resolved ) ; } ) ; } if ( $ data !== null ) { $ data = ( array ) $ data ; } return new ExecutionResult ( $ data , $ this -> exeContext -> errors ) ; } 
private function executeOperation ( OperationDefinitionNode $ operation , $ rootValue ) { $ type = $ this -> getOperationRootType ( $ this -> exeContext -> schema , $ operation ) ; $ fields = $ this -> collectFields ( $ type , $ operation -> selectionSet , new ArrayObject ( ) , new ArrayObject ( ) ) ; $ path = [ ] ; 
private function getOperationRootType ( Schema $ schema , OperationDefinitionNode $ operation ) { switch ( $ operation -> operation ) { case 'query' : $ queryType = $ schema -> getQueryType ( ) ; if ( ! $ queryType ) { throw new Error ( 'Schema does not define the required query root type.' , [ $ operation ] ) ; } return $ queryType ; case 'mutation' : $ mutationType = $ schema -> getMutationType ( ) ; if ( ! $ mutationType ) { throw new Error ( 'Schema is not configured for mutations.' , [ $ operation ] ) ; } return $ mutationType ; case 'subscription' : $ subscriptionType = $ schema -> getSubscriptionType ( ) ; if ( ! $ subscriptionType ) { throw new Error ( 'Schema is not configured for subscriptions.' , [ $ operation ] ) ; } return $ subscriptionType ; default : throw new Error ( 'Can only execute queries, mutations and subscriptions.' , [ $ operation ] ) ; } } 
private function collectFields ( ObjectType $ runtimeType , SelectionSetNode $ selectionSet , $ fields , $ visitedFragmentNames ) { $ exeContext = $ this -> exeContext ; foreach ( $ selectionSet -> selections as $ selection ) { switch ( $ selection -> kind ) { case NodeKind :: FIELD : if ( ! $ this -> shouldIncludeNode ( $ selection ) ) { break ; } $ name = self :: getFieldEntryKey ( $ selection ) ; if ( ! isset ( $ fields [ $ name ] ) ) { $ fields [ $ name ] = new ArrayObject ( ) ; } $ fields [ $ name ] [ ] = $ selection ; break ; case NodeKind :: INLINE_FRAGMENT : if ( ! $ this -> shouldIncludeNode ( $ selection ) || ! $ this -> doesFragmentConditionMatch ( $ selection , $ runtimeType ) ) { break ; } $ this -> collectFields ( $ runtimeType , $ selection -> selectionSet , $ fields , $ visitedFragmentNames ) ; break ; case NodeKind :: FRAGMENT_SPREAD : $ fragName = $ selection -> name -> value ; if ( ! empty ( $ visitedFragmentNames [ $ fragName ] ) || ! $ this -> shouldIncludeNode ( $ selection ) ) { break ; } $ visitedFragmentNames [ $ fragName ] = true ; $ fragment = $ exeContext -> fragments [ $ fragName ] ?? null ; if ( ! $ fragment || ! $ this -> doesFragmentConditionMatch ( $ fragment , $ runtimeType ) ) { break ; } $ this -> collectFields ( $ runtimeType , $ fragment -> selectionSet , $ fields , $ visitedFragmentNames ) ; break ; } } return $ fields ; } 
private function shouldIncludeNode ( $ node ) { $ variableValues = $ this -> exeContext -> variableValues ; $ skipDirective = Directive :: skipDirective ( ) ; $ skip = Values :: getDirectiveValues ( $ skipDirective , $ node , $ variableValues ) ; if ( isset ( $ skip [ 'if' ] ) && $ skip [ 'if' ] === true ) { return false ; } $ includeDirective = Directive :: includeDirective ( ) ; $ include = Values :: getDirectiveValues ( $ includeDirective , $ node , $ variableValues ) ; return ! isset ( $ include [ 'if' ] ) || $ include [ 'if' ] !== false ; } 
private static function getFieldEntryKey ( FieldNode $ node ) { return $ node -> alias ? $ node -> alias -> value : $ node -> name -> value ; } 
private function doesFragmentConditionMatch ( $ fragment , ObjectType $ type ) { $ typeConditionNode = $ fragment -> typeCondition ; if ( $ typeConditionNode === null ) { return true ; } $ conditionalType = TypeInfo :: typeFromAST ( $ this -> exeContext -> schema , $ typeConditionNode ) ; if ( $ conditionalType === $ type ) { return true ; } if ( $ conditionalType instanceof AbstractType ) { return $ this -> exeContext -> schema -> isPossibleType ( $ conditionalType , $ type ) ; } return false ; } 
private function executeFieldsSerially ( ObjectType $ parentType , $ sourceValue , $ path , $ fields ) { $ result = $ this -> promiseReduce ( array_keys ( $ fields -> getArrayCopy ( ) ) , function ( $ results , $ responseName ) use ( $ path , $ parentType , $ sourceValue , $ fields ) { $ fieldNodes = $ fields [ $ responseName ] ; $ fieldPath = $ path ; $ fieldPath [ ] = $ responseName ; $ result = $ this -> resolveField ( $ parentType , $ sourceValue , $ fieldNodes , $ fieldPath ) ; if ( $ result === self :: $ UNDEFINED ) { return $ results ; } $ promise = $ this -> getPromise ( $ result ) ; if ( $ promise ) { return $ promise -> then ( static function ( $ resolvedResult ) use ( $ responseName , $ results ) { $ results [ $ responseName ] = $ resolvedResult ; return $ results ; } ) ; } $ results [ $ responseName ] = $ result ; return $ results ; } , [ ] ) ; if ( $ this -> isPromise ( $ result ) ) { return $ result -> then ( static function ( $ resolvedResults ) { return self :: fixResultsIfEmptyArray ( $ resolvedResults ) ; } ) ; } return self :: fixResultsIfEmptyArray ( $ result ) ; } 
private function resolveField ( ObjectType $ parentType , $ source , $ fieldNodes , $ path ) { $ exeContext = $ this -> exeContext ; $ fieldNode = $ fieldNodes [ 0 ] ; $ fieldName = $ fieldNode -> name -> value ; $ fieldDef = $ this -> getFieldDef ( $ exeContext -> schema , $ parentType , $ fieldName ) ; if ( ! $ fieldDef ) { return self :: $ UNDEFINED ; } $ returnType = $ fieldDef -> getType ( ) ; 
private function getFieldDef ( Schema $ schema , ObjectType $ parentType , $ fieldName ) { static $ schemaMetaFieldDef , $ typeMetaFieldDef , $ typeNameMetaFieldDef ; $ schemaMetaFieldDef = $ schemaMetaFieldDef ? : Introspection :: schemaMetaFieldDef ( ) ; $ typeMetaFieldDef = $ typeMetaFieldDef ? : Introspection :: typeMetaFieldDef ( ) ; $ typeNameMetaFieldDef = $ typeNameMetaFieldDef ? : Introspection :: typeNameMetaFieldDef ( ) ; if ( $ fieldName === $ schemaMetaFieldDef -> name && $ schema -> getQueryType ( ) === $ parentType ) { return $ schemaMetaFieldDef ; } if ( $ fieldName === $ typeMetaFieldDef -> name && $ schema -> getQueryType ( ) === $ parentType ) { return $ typeMetaFieldDef ; } if ( $ fieldName === $ typeNameMetaFieldDef -> name ) { return $ typeNameMetaFieldDef ; } $ tmp = $ parentType -> getFields ( ) ; return $ tmp [ $ fieldName ] ?? null ; } 
private function resolveOrError ( $ fieldDef , $ fieldNode , $ resolveFn , $ source , $ context , $ info ) { try { 
private function completeValueCatchingError ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , $ result ) { $ exeContext = $ this -> exeContext ; 
public function completeValueWithLocatedError ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , $ result ) { try { $ completed = $ this -> completeValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; $ promise = $ this -> getPromise ( $ completed ) ; if ( $ promise ) { return $ promise -> then ( null , function ( $ error ) use ( $ fieldNodes , $ path ) { return $ this -> exeContext -> promises -> createRejected ( Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ) ; } ) ; } return $ completed ; } catch ( Exception $ error ) { throw Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ; } catch ( Throwable $ error ) { throw Error :: createLocatedError ( $ error , $ fieldNodes , $ path ) ; } } 
private function completeValue ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ promise = $ this -> getPromise ( $ result ) ; 
private function getPromise ( $ value ) { if ( $ value === null || $ value instanceof Promise ) { return $ value ; } if ( $ this -> exeContext -> promises -> isThenable ( $ value ) ) { $ promise = $ this -> exeContext -> promises -> convertThenable ( $ value ) ; if ( ! $ promise instanceof Promise ) { throw new InvariantViolation ( sprintf ( '%s::convertThenable is expected to return instance of GraphQL\Executor\Promise\Promise, got: %s' , get_class ( $ this -> exeContext -> promises ) , Utils :: printSafe ( $ promise ) ) ) ; } return $ promise ; } return null ; } 
private function promiseReduce ( array $ values , callable $ callback , $ initialValue ) { return array_reduce ( $ values , function ( $ previous , $ value ) use ( $ callback ) { $ promise = $ this -> getPromise ( $ previous ) ; if ( $ promise ) { return $ promise -> then ( static function ( $ resolved ) use ( $ callback , $ value ) { return $ callback ( $ resolved , $ value ) ; } ) ; } return $ callback ( $ previous , $ value ) ; } , $ initialValue ) ; } 
private function completeListValue ( ListOfType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ itemType = $ returnType -> getWrappedType ( ) ; Utils :: invariant ( is_array ( $ result ) || $ result instanceof Traversable , 'User Error: expected iterable, but did not find one for field ' . $ info -> parentType . '.' . $ info -> fieldName . '.' ) ; $ containsPromise = false ; $ i = 0 ; $ completedItems = [ ] ; foreach ( $ result as $ item ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ i ++ ; $ completedItem = $ this -> completeValueCatchingError ( $ itemType , $ fieldNodes , $ info , $ fieldPath , $ item ) ; if ( ! $ containsPromise && $ this -> getPromise ( $ completedItem ) ) { $ containsPromise = true ; } $ completedItems [ ] = $ completedItem ; } return $ containsPromise ? $ this -> exeContext -> promises -> all ( $ completedItems ) : $ completedItems ; } 
private function completeLeafValue ( LeafType $ returnType , & $ result ) { try { return $ returnType -> serialize ( $ result ) ; } catch ( Exception $ error ) { throw new InvariantViolation ( 'Expected a value of type "' . Utils :: printSafe ( $ returnType ) . '" but received: ' . Utils :: printSafe ( $ result ) , 0 , $ error ) ; } catch ( Throwable $ error ) { throw new InvariantViolation ( 'Expected a value of type "' . Utils :: printSafe ( $ returnType ) . '" but received: ' . Utils :: printSafe ( $ result ) , 0 , $ error ) ; } } 
private function completeAbstractValue ( AbstractType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ exeContext = $ this -> exeContext ; $ runtimeType = $ returnType -> resolveType ( $ result , $ exeContext -> contextValue , $ info ) ; if ( $ runtimeType === null ) { $ runtimeType = self :: defaultTypeResolver ( $ result , $ exeContext -> contextValue , $ info , $ returnType ) ; } $ promise = $ this -> getPromise ( $ runtimeType ) ; if ( $ promise ) { return $ promise -> then ( function ( $ resolvedRuntimeType ) use ( $ returnType , $ fieldNodes , $ info , $ path , & $ result ) { return $ this -> completeObjectValue ( $ this -> ensureValidRuntimeType ( $ resolvedRuntimeType , $ returnType , $ info , $ result ) , $ fieldNodes , $ info , $ path , $ result ) ; } ) ; } return $ this -> completeObjectValue ( $ this -> ensureValidRuntimeType ( $ runtimeType , $ returnType , $ info , $ result ) , $ fieldNodes , $ info , $ path , $ result ) ; } 
private function defaultTypeResolver ( $ value , $ context , ResolveInfo $ info , AbstractType $ abstractType ) { 
private function completeObjectValue ( ObjectType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { 
private function invalidReturnTypeError ( ObjectType $ returnType , $ result , $ fieldNodes ) { return new Error ( 'Expected value of type "' . $ returnType -> name . '" but got: ' . Utils :: printSafe ( $ result ) . '.' , $ fieldNodes ) ; } 
private function collectAndExecuteSubfields ( ObjectType $ returnType , $ fieldNodes , $ path , & $ result ) { $ subFieldNodes = $ this -> collectSubFields ( $ returnType , $ fieldNodes ) ; return $ this -> executeFields ( $ returnType , $ result , $ path , $ subFieldNodes ) ; } 
private function executeFields ( ObjectType $ parentType , $ source , $ path , $ fields ) { $ containsPromise = false ; $ finalResults = [ ] ; foreach ( $ fields as $ responseName => $ fieldNodes ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ responseName ; $ result = $ this -> resolveField ( $ parentType , $ source , $ fieldNodes , $ fieldPath ) ; if ( $ result === self :: $ UNDEFINED ) { continue ; } if ( ! $ containsPromise && $ this -> getPromise ( $ result ) ) { $ containsPromise = true ; } $ finalResults [ $ responseName ] = $ result ; } 
private function promiseForAssocArray ( array $ assoc ) { $ keys = array_keys ( $ assoc ) ; $ valuesAndPromises = array_values ( $ assoc ) ; $ promise = $ this -> exeContext -> promises -> all ( $ valuesAndPromises ) ; return $ promise -> then ( static function ( $ values ) use ( $ keys ) { $ resolvedResults = [ ] ; foreach ( $ values as $ i => $ value ) { $ resolvedResults [ $ keys [ $ i ] ] = $ value ; } return self :: fixResultsIfEmptyArray ( $ resolvedResults ) ; } ) ; } 
private function ensureValidRuntimeType ( $ runtimeTypeOrName , AbstractType $ returnType , ResolveInfo $ info , & $ result ) { $ runtimeType = is_string ( $ runtimeTypeOrName ) ? $ this -> exeContext -> schema -> getType ( $ runtimeTypeOrName ) : $ runtimeTypeOrName ; if ( ! $ runtimeType instanceof ObjectType ) { throw new InvariantViolation ( sprintf ( 'Abstract type %s must resolve to an Object type at ' . 'runtime for field %s.%s with value "%s", received "%s". ' . 'Either the %s type should provide a "resolveType" ' . 'function or each possible type should provide an "isTypeOf" function.' , $ returnType , $ info -> parentType , $ info -> fieldName , Utils :: printSafe ( $ result ) , Utils :: printSafe ( $ runtimeType ) , $ returnType ) ) ; } if ( ! $ this -> exeContext -> schema -> isPossibleType ( $ returnType , $ runtimeType ) ) { throw new InvariantViolation ( sprintf ( 'Runtime Object type "%s" is not a possible type for "%s".' , $ runtimeType , $ returnType ) ) ; } if ( $ runtimeType !== $ this -> exeContext -> schema -> getType ( $ runtimeType -> name ) ) { throw new InvariantViolation ( sprintf ( 'Schema must contain unique named types but contains multiple types named "%s". ' . 'Make sure that `resolveType` function of abstract type "%s" returns the same ' . 'type instance as referenced anywhere else within the schema ' . '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).' , $ runtimeType , $ returnType ) ) ; } return $ runtimeType ; } 
public static function coerceValue ( $ value , InputType $ type , $ blameNode = null , ? array $ path = null ) { if ( $ type instanceof NonNull ) { if ( $ value === null ) { return self :: ofErrors ( [ self :: coercionError ( sprintf ( 'Expected non-nullable type %s not to be null' , $ type ) , $ blameNode , $ path ) , ] ) ; } return self :: coerceValue ( $ value , $ type -> getWrappedType ( ) , $ blameNode , $ path ) ; } if ( $ value === null ) { 
private static function coercionError ( $ message , $ blameNode , ? array $ path = null , $ subMessage = null , $ originalError = null ) { $ pathStr = self :: printPath ( $ path ) ; 
private static function printPath ( ? array $ path = null ) { $ pathStr = '' ; $ currentPath = $ path ; while ( $ currentPath ) { $ pathStr = ( is_string ( $ currentPath [ 'key' ] ) ? '.' . $ currentPath [ 'key' ] : '[' . $ currentPath [ 'key' ] . ']' ) . $ pathStr ; $ currentPath = $ currentPath [ 'prev' ] ; } return $ pathStr ? 'value' . $ pathStr : '' ; } 
public function getValue ( $ name ) { $ lookup = $ this -> getNameLookup ( ) ; if ( ! is_string ( $ name ) ) { return null ; } return $ lookup [ $ name ] ?? null ; } 
public function serialize ( $ value ) { $ lookup = $ this -> getValueLookup ( ) ; if ( isset ( $ lookup [ $ value ] ) ) { return $ lookup [ $ value ] -> name ; } throw new Error ( 'Cannot serialize value as enum: ' . Utils :: printSafe ( $ value ) ) ; } 
public function parseValue ( $ value ) { $ lookup = $ this -> getNameLookup ( ) ; if ( isset ( $ lookup [ $ value ] ) ) { return $ lookup [ $ value ] -> value ; } throw new Error ( 'Cannot represent value as enum: ' . Utils :: printSafe ( $ value ) ) ; } 
public function parseLiteral ( $ valueNode , ? array $ variables = null ) { if ( $ valueNode instanceof EnumValueNode ) { $ lookup = $ this -> getNameLookup ( ) ; if ( isset ( $ lookup [ $ valueNode -> value ] ) ) { $ enumValue = $ lookup [ $ valueNode -> value ] ; if ( $ enumValue !== null ) { return $ enumValue -> value ; } } } 
public static function send500Error ( $ error , $ debug = false , $ exitWhenDone = false ) { $ response = [ 'errors' => [ FormattedError :: createFromException ( $ error , $ debug ) ] , ] ; $ helper = new Helper ( ) ; $ helper -> emitResponse ( $ response , 500 , $ exitWhenDone ) ; } 
public function handleRequest ( $ parsedBody = null , $ exitWhenDone = false ) { $ result = $ this -> executeRequest ( $ parsedBody ) ; $ this -> helper -> sendResponse ( $ result , $ exitWhenDone ) ; } 
public function executeRequest ( $ parsedBody = null ) { if ( $ parsedBody === null ) { $ parsedBody = $ this -> helper -> parseHttpRequest ( ) ; } if ( is_array ( $ parsedBody ) ) { return $ this -> helper -> executeBatch ( $ this -> config , $ parsedBody ) ; } return $ this -> helper -> executeOperation ( $ this -> config , $ parsedBody ) ; } 
public function processPsrRequest ( ServerRequestInterface $ request , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { $ result = $ this -> executePsrRequest ( $ request ) ; return $ this -> helper -> toPsrResponse ( $ result , $ response , $ writableBodyStream ) ; } 
public function executePsrRequest ( ServerRequestInterface $ request ) { $ parsedBody = $ this -> helper -> parsePsrRequest ( $ request ) ; return $ this -> executeRequest ( $ parsedBody ) ; } 
public function wait ( Promise $ promise ) { $ this -> beforeWait ( $ promise ) ; $ dfdQueue = Deferred :: getQueue ( ) ; $ promiseQueue = SyncPromise :: getQueue ( ) ; while ( $ promise -> adoptedPromise -> state === SyncPromise :: PENDING && ! ( $ dfdQueue -> isEmpty ( ) && $ promiseQueue -> isEmpty ( ) ) ) { Deferred :: runQueue ( ) ; SyncPromise :: runQueue ( ) ; $ this -> onWait ( $ promise ) ; } $ syncPromise = $ promise -> adoptedPromise ; if ( $ syncPromise -> state === SyncPromise :: FULFILLED ) { return $ syncPromise -> result ; } if ( $ syncPromise -> state === SyncPromise :: REJECTED ) { throw $ syncPromise -> result ; } throw new InvariantViolation ( 'Could not resolve promise' ) ; } 
public static function assertObjectType ( $ type ) { Utils :: invariant ( $ type instanceof self , 'Expected ' . Utils :: printSafe ( $ type ) . ' to be a GraphQL Object type.' ) ; return $ type ; } 
public function getField ( $ name ) { if ( $ this -> fields === null ) { $ this -> getFields ( ) ; } Utils :: invariant ( isset ( $ this -> fields [ $ name ] ) , 'Field "%s" is not defined for type "%s"' , $ name , $ this -> name ) ; return $ this -> fields [ $ name ] ; } 
public function hasField ( $ name ) { if ( $ this -> fields === null ) { $ this -> getFields ( ) ; } return isset ( $ this -> fields [ $ name ] ) ; } 
public function getFields ( ) { if ( $ this -> fields === null ) { $ fields = $ this -> config [ 'fields' ] ?? [ ] ; $ this -> fields = FieldDefinition :: defineFieldMap ( $ this , $ fields ) ; } return $ this -> fields ; } 
public function isTypeOf ( $ value , $ context , ResolveInfo $ info ) { return isset ( $ this -> config [ 'isTypeOf' ] ) ? call_user_func ( $ this -> config [ 'isTypeOf' ] , $ value , $ context , $ info ) : null ; } 
public function assertValid ( ) { parent :: assertValid ( ) ; Utils :: invariant ( $ this -> description === null || is_string ( $ this -> description ) , sprintf ( '%s description must be string if set, but it is: %s' , $ this -> name , Utils :: printSafe ( $ this -> description ) ) ) ; $ isTypeOf = $ this -> config [ 'isTypeOf' ] ?? null ; Utils :: invariant ( $ isTypeOf === null || is_callable ( $ isTypeOf ) , sprintf ( '%s must provide "isTypeOf" as a function, but got: %s' , $ this -> name , Utils :: printSafe ( $ isTypeOf ) ) ) ; foreach ( $ this -> getFields ( ) as $ field ) { $ field -> assertValid ( $ this ) ; } } 
protected function invokeIfNeeded ( ValidationContext $ context , array $ validators ) { 
protected function collectFieldASTsAndDefs ( ValidationContext $ context , $ parentType , SelectionSetNode $ selectionSet , ? ArrayObject $ visitedFragmentNames = null , ? ArrayObject $ astAndDefs = null ) { $ _visitedFragmentNames = $ visitedFragmentNames ? : new ArrayObject ( ) ; $ _astAndDefs = $ astAndDefs ? : new ArrayObject ( ) ; foreach ( $ selectionSet -> selections as $ selection ) { switch ( $ selection -> kind ) { case NodeKind :: FIELD : $ fieldName = $ selection -> name -> value ; $ fieldDef = null ; if ( $ parentType && method_exists ( $ parentType , 'getFields' ) ) { $ tmp = $ parentType -> getFields ( ) ; $ schemaMetaFieldDef = Introspection :: schemaMetaFieldDef ( ) ; $ typeMetaFieldDef = Introspection :: typeMetaFieldDef ( ) ; $ typeNameMetaFieldDef = Introspection :: typeNameMetaFieldDef ( ) ; if ( $ fieldName === $ schemaMetaFieldDef -> name && $ context -> getSchema ( ) -> getQueryType ( ) === $ parentType ) { $ fieldDef = $ schemaMetaFieldDef ; } elseif ( $ fieldName === $ typeMetaFieldDef -> name && $ context -> getSchema ( ) -> getQueryType ( ) === $ parentType ) { $ fieldDef = $ typeMetaFieldDef ; } elseif ( $ fieldName === $ typeNameMetaFieldDef -> name ) { $ fieldDef = $ typeNameMetaFieldDef ; } elseif ( isset ( $ tmp [ $ fieldName ] ) ) { $ fieldDef = $ tmp [ $ fieldName ] ; } } $ responseName = $ this -> getFieldName ( $ selection ) ; if ( ! isset ( $ _astAndDefs [ $ responseName ] ) ) { $ _astAndDefs [ $ responseName ] = new ArrayObject ( ) ; } 
private function printBlockString ( $ value , $ isDescription ) { $ escaped = str_replace ( '"""' , '\\"""' , $ value ) ; return ( $ value [ 0 ] === ' ' || $ value [ 0 ] === "\t" ) && strpos ( $ value , "\n" ) === false ? ( '"""' . preg_replace ( '/"$/' , "\"\n" , $ escaped ) . '"""' ) : ( '"""' . "\n" . ( $ isDescription ? $ escaped : $ this -> indent ( $ escaped ) ) . "\n" . '"""' ) ; } 
public static function printError ( Error $ error ) { $ printedLocations = [ ] ; if ( $ error -> nodes ) { foreach ( $ error -> nodes as $ node ) { if ( ! $ node -> loc ) { continue ; } if ( $ node -> loc -> source === null ) { continue ; } $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ node -> loc -> source , $ node -> loc -> source -> getLocation ( $ node -> loc -> start ) ) ; } } elseif ( $ error -> getSource ( ) && $ error -> getLocations ( ) ) { $ source = $ error -> getSource ( ) ; foreach ( $ error -> getLocations ( ) as $ location ) { $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ source , $ location ) ; } } return ! $ printedLocations ? $ error -> getMessage ( ) : implode ( "\n\n" , array_merge ( [ $ error -> getMessage ( ) ] , $ printedLocations ) ) . "\n" ; } 
private static function highlightSourceAtLocation ( Source $ source , SourceLocation $ location ) { $ line = $ location -> line ; $ lineOffset = $ source -> locationOffset -> line - 1 ; $ columnOffset = self :: getColumnOffset ( $ source , $ location ) ; $ contextLine = $ line + $ lineOffset ; $ contextColumn = $ location -> column + $ columnOffset ; $ prevLineNum = ( string ) ( $ contextLine - 1 ) ; $ lineNum = ( string ) $ contextLine ; $ nextLineNum = ( string ) ( $ contextLine + 1 ) ; $ padLen = strlen ( $ nextLineNum ) ; $ lines = preg_split ( '/\r\n|[\n\r]/' , $ source -> body ) ; $ lines [ 0 ] = self :: whitespace ( $ source -> locationOffset -> column - 1 ) . $ lines [ 0 ] ; $ outputLines = [ sprintf ( '%s (%s:%s)' , $ source -> name , $ contextLine , $ contextColumn ) , $ line >= 2 ? ( self :: lpad ( $ padLen , $ prevLineNum ) . ': ' . $ lines [ $ line - 2 ] ) : null , self :: lpad ( $ padLen , $ lineNum ) . ': ' . $ lines [ $ line - 1 ] , self :: whitespace ( 2 + $ padLen + $ contextColumn - 1 ) . '^' , $ line < count ( $ lines ) ? self :: lpad ( $ padLen , $ nextLineNum ) . ': ' . $ lines [ $ line ] : null , ] ; return implode ( "\n" , array_filter ( $ outputLines ) ) ; } 
public static function createFromException ( $ e , $ debug = false , $ internalErrorMessage = null ) { Utils :: invariant ( $ e instanceof Exception || $ e instanceof Throwable , 'Expected exception, got %s' , Utils :: getVariableType ( $ e ) ) ; $ internalErrorMessage = $ internalErrorMessage ? : self :: $ internalErrorMessage ; if ( $ e instanceof ClientAware ) { $ formattedError = [ 'message' => $ e -> isClientSafe ( ) ? $ e -> getMessage ( ) : $ internalErrorMessage , 'extensions' => [ 'category' => $ e -> getCategory ( ) , ] , ] ; } else { $ formattedError = [ 'message' => $ internalErrorMessage , 'extensions' => [ 'category' => Error :: CATEGORY_INTERNAL , ] , ] ; } if ( $ e instanceof Error ) { $ locations = Utils :: map ( $ e -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ formattedError [ 'locations' ] = $ locations ; } if ( ! empty ( $ e -> path ) ) { $ formattedError [ 'path' ] = $ e -> path ; } if ( ! empty ( $ e -> getExtensions ( ) ) ) { $ formattedError [ 'extensions' ] = $ e -> getExtensions ( ) + $ formattedError [ 'extensions' ] ; } } if ( $ debug ) { $ formattedError = self :: addDebugEntries ( $ formattedError , $ e , $ debug ) ; } return $ formattedError ; } 
public static function addDebugEntries ( array $ formattedError , $ e , $ debug ) { if ( ! $ debug ) { return $ formattedError ; } Utils :: invariant ( $ e instanceof Exception || $ e instanceof Throwable , 'Expected exception, got %s' , Utils :: getVariableType ( $ e ) ) ; $ debug = ( int ) $ debug ; if ( $ debug & Debug :: RETHROW_INTERNAL_EXCEPTIONS ) { if ( ! $ e instanceof Error ) { throw $ e ; } if ( $ e -> getPrevious ( ) ) { throw $ e -> getPrevious ( ) ; } } $ isUnsafe = ! $ e instanceof ClientAware || ! $ e -> isClientSafe ( ) ; if ( ( $ debug & Debug :: RETHROW_UNSAFE_EXCEPTIONS ) && $ isUnsafe ) { if ( $ e -> getPrevious ( ) ) { throw $ e -> getPrevious ( ) ; } } if ( ( $ debug & Debug :: INCLUDE_DEBUG_MESSAGE ) && $ isUnsafe ) { 
public static function prepareFormatter ( ? callable $ formatter = null , $ debug ) { $ formatter = $ formatter ? : static function ( $ e ) { return FormattedError :: createFromException ( $ e ) ; } ; if ( $ debug ) { $ formatter = static function ( $ e ) use ( $ formatter , $ debug ) { return FormattedError :: addDebugEntries ( $ formatter ( $ e ) , $ e , $ debug ) ; } ; } return $ formatter ; } 
public static function toSafeTrace ( $ error ) { $ trace = $ error -> getTrace ( ) ; if ( isset ( $ trace [ 0 ] [ 'function' ] ) && isset ( $ trace [ 0 ] [ 'class' ] ) && 
public static function printVar ( $ var ) { if ( $ var instanceof Type ) { 
public static function create ( $ error , array $ locations = [ ] ) { $ formatted = [ 'message' => $ error ] ; if ( ! empty ( $ locations ) ) { $ formatted [ 'locations' ] = array_map ( static function ( $ loc ) { return $ loc -> toArray ( ) ; } , $ locations ) ; } return $ formatted ; } 
public static function createFromPHPError ( ErrorException $ e ) { return [ 'message' => $ e -> getMessage ( ) , 'severity' => $ e -> getSeverity ( ) , 'trace' => self :: toSafeTrace ( $ e ) , ] ; } 
public static function create ( array $ params , bool $ readonly = false ) : OperationParams { $ instance = new static ( ) ; $ params = array_change_key_case ( $ params , CASE_LOWER ) ; $ instance -> originalInput = $ params ; $ params += [ 'query' => null , 'queryid' => null , 'documentid' => null , 
public static function createMap ( array $ config ) { $ map = [ ] ; foreach ( $ config as $ name => $ argConfig ) { if ( ! is_array ( $ argConfig ) ) { $ argConfig = [ 'type' => $ argConfig ] ; } $ map [ ] = new self ( $ argConfig + [ 'name' => $ name ] ) ; } return $ map ; } 
public function parseValue ( $ value ) { if ( isset ( $ this -> config [ 'parseValue' ] ) ) { return call_user_func ( $ this -> config [ 'parseValue' ] , $ value ) ; } return $ value ; } 
public function parseLiteral ( $ valueNode , ? array $ variables = null ) { if ( isset ( $ this -> config [ 'parseLiteral' ] ) ) { return call_user_func ( $ this -> config [ 'parseLiteral' ] , $ valueNode , $ variables ) ; } return AST :: valueFromASTUntyped ( $ valueNode , $ variables ) ; } 
public static function value ( $ rawString ) { 
public static function getVariableValues ( Schema $ schema , $ varDefNodes , array $ inputs ) { $ errors = [ ] ; $ coercedValues = [ ] ; foreach ( $ varDefNodes as $ varDefNode ) { $ varName = $ varDefNode -> variable -> name -> value ; $ varType = TypeInfo :: typeFromAST ( $ schema , $ varDefNode -> type ) ; if ( Type :: isInputType ( $ varType ) ) { if ( array_key_exists ( $ varName , $ inputs ) ) { $ value = $ inputs [ $ varName ] ; $ coerced = Value :: coerceValue ( $ value , $ varType , $ varDefNode ) ; $ coercionErrors = $ coerced [ 'errors' ] ; if ( empty ( $ coercionErrors ) ) { $ coercedValues [ $ varName ] = $ coerced [ 'value' ] ; } else { $ messagePrelude = sprintf ( 'Variable "$%s" got invalid value %s; ' , $ varName , Utils :: printSafeJson ( $ value ) ) ; foreach ( $ coercionErrors as $ error ) { $ errors [ ] = new Error ( $ messagePrelude . $ error -> getMessage ( ) , $ error -> getNodes ( ) , $ error -> getSource ( ) , $ error -> getPositions ( ) , $ error -> getPath ( ) , $ error , $ error -> getExtensions ( ) ) ; } } } else { if ( $ varType instanceof NonNull ) { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" of required type "%s" was not provided.' , $ varName , $ varType ) , [ $ varDefNode ] ) ; } elseif ( $ varDefNode -> defaultValue ) { $ coercedValues [ $ varName ] = AST :: valueFromAST ( $ varDefNode -> defaultValue , $ varType ) ; } } } else { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" expected value of type "%s" which cannot be used as an input type.' , $ varName , Printer :: doPrint ( $ varDefNode -> type ) ) , [ $ varDefNode -> type ] ) ; } } if ( ! empty ( $ errors ) ) { return [ $ errors , null ] ; } return [ null , $ coercedValues ] ; } 
public static function getDirectiveValues ( Directive $ directiveDef , $ node , $ variableValues = null ) { if ( isset ( $ node -> directives ) && $ node -> directives instanceof NodeList ) { $ directiveNode = Utils :: find ( $ node -> directives , static function ( DirectiveNode $ directive ) use ( $ directiveDef ) { return $ directive -> name -> value === $ directiveDef -> name ; } ) ; if ( $ directiveNode !== null ) { return self :: getArgumentValues ( $ directiveDef , $ directiveNode , $ variableValues ) ; } } return null ; } 
public static function getArgumentValues ( $ def , $ node , $ variableValues = null ) { if ( empty ( $ def -> args ) ) { return [ ] ; } $ argumentNodes = $ node -> arguments ; if ( empty ( $ argumentNodes ) ) { return [ ] ; } $ argumentValueMap = [ ] ; foreach ( $ argumentNodes as $ argumentNode ) { $ argumentValueMap [ $ argumentNode -> name -> value ] = $ argumentNode -> value ; } return static :: getArgumentValuesForMap ( $ def , $ argumentValueMap , $ variableValues , $ node ) ; } 
public static function getArgumentValuesForMap ( $ fieldDefinition , $ argumentValueMap , $ variableValues = null , $ referenceNode = null ) { $ argumentDefinitions = $ fieldDefinition -> args ; $ coercedValues = [ ] ; foreach ( $ argumentDefinitions as $ argumentDefinition ) { $ name = $ argumentDefinition -> name ; $ argType = $ argumentDefinition -> getType ( ) ; $ argumentValueNode = $ argumentValueMap [ $ name ] ?? null ; if ( ! $ argumentValueNode ) { if ( $ argumentDefinition -> defaultValueExists ( ) ) { $ coercedValues [ $ name ] = $ argumentDefinition -> defaultValue ; } elseif ( $ argType instanceof NonNull ) { throw new Error ( 'Argument "' . $ name . '" of required type ' . '"' . Utils :: printSafe ( $ argType ) . '" was not provided.' , $ referenceNode ) ; } } elseif ( $ argumentValueNode instanceof VariableNode ) { $ variableName = $ argumentValueNode -> name -> value ; if ( $ variableValues && array_key_exists ( $ variableName , $ variableValues ) ) { 
public static function valueFromAST ( $ valueNode , InputType $ type , ? array $ variables = null ) { return AST :: valueFromAST ( $ valueNode , $ type , $ variables ) ; } 
public static function isValidPHPValue ( $ value , InputType $ type ) { $ errors = Value :: coerceValue ( $ value , $ type ) [ 'errors' ] ; return $ errors ? array_map ( static function ( Throwable $ error ) { return $ error -> getMessage ( ) ; } , $ errors ) : [ ] ; } 
public static function build ( $ source , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ doc = $ source instanceof DocumentNode ? $ source : Parser :: parse ( $ source ) ; return self :: buildAST ( $ doc , $ typeConfigDecorator , $ options ) ; } 
public static function buildAST ( DocumentNode $ ast , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ builder = new self ( $ ast , $ typeConfigDecorator , $ options ) ; return $ builder -> buildSchema ( ) ; } 
private function getOperationTypes ( $ schemaDef ) { $ opTypes = [ ] ; foreach ( $ schemaDef -> operationTypes as $ operationType ) { $ typeName = $ operationType -> type -> name -> value ; $ operation = $ operationType -> operation ; if ( isset ( $ opTypes [ $ operation ] ) ) { throw new Error ( sprintf ( 'Must provide only one %s type in schema.' , $ operation ) ) ; } if ( ! isset ( $ this -> nodeMap [ $ typeName ] ) ) { throw new Error ( sprintf ( 'Specified %s type "%s" not found in document.' , $ operation , $ typeName ) ) ; } $ opTypes [ $ operation ] = $ typeName ; } return $ opTypes ; } 
protected static function extendArgs ( array $ args ) : array { return Utils :: keyValMap ( $ args , static function ( FieldArgument $ arg ) { return $ arg -> name ; } , static function ( FieldArgument $ arg ) { $ def = [ 'type' => static :: extendType ( $ arg -> getType ( ) ) , 'description' => $ arg -> description , 'astNode' => $ arg -> astNode , ] ; if ( $ arg -> defaultValueExists ( ) ) { $ def [ 'defaultValue' ] = $ arg -> defaultValue ; } return $ def ; } ) ; } 
protected static function extendFieldMap ( $ type ) : array { $ newFieldMap = [ ] ; $ oldFieldMap = $ type -> getFields ( ) ; foreach ( array_keys ( $ oldFieldMap ) as $ fieldName ) { $ field = $ oldFieldMap [ $ fieldName ] ; $ newFieldMap [ $ fieldName ] = [ 'name' => $ fieldName , 'description' => $ field -> description , 'deprecationReason' => $ field -> deprecationReason , 'type' => static :: extendType ( $ field -> getType ( ) ) , 'args' => static :: extendArgs ( $ field -> args ) , 'astNode' => $ field -> astNode , 'resolve' => $ field -> resolveFn , ] ; } $ extensions = static :: $ typeExtensionsMap [ $ type -> name ] ?? null ; if ( $ extensions !== null ) { foreach ( $ extensions as $ extension ) { foreach ( $ extension -> fields as $ field ) { $ fieldName = $ field -> name -> value ; if ( isset ( $ oldFieldMap [ $ fieldName ] ) ) { throw new Error ( 'Field "' . $ type -> name . '.' . $ fieldName . '" already exists in the schema. It cannot also be defined in this type extension.' , [ $ field ] ) ; } $ newFieldMap [ $ fieldName ] = static :: $ astBuilder -> buildField ( $ field ) ; } } } return $ newFieldMap ; } 
protected static function getMergedDirectives ( Schema $ schema , array $ directiveDefinitions ) : array { $ existingDirectives = array_map ( static function ( Directive $ directive ) { return static :: extendDirective ( $ directive ) ; } , $ schema -> getDirectives ( ) ) ; Utils :: invariant ( count ( $ existingDirectives ) > 0 , 'schema must have default directives' ) ; return array_merge ( $ existingDirectives , array_map ( static function ( DirectiveDefinitionNode $ directive ) { return static :: $ astBuilder -> buildDirective ( $ directive ) ; } , $ directiveDefinitions ) ) ; } 
public static function assertInterfaceType ( $ type ) { Utils :: invariant ( $ type instanceof self , 'Expected ' . Utils :: printSafe ( $ type ) . ' to be a GraphQL Interface type.' ) ; return $ type ; } 
public static function doPrint ( Schema $ schema , array $ options = [ ] ) : string { return self :: printFilteredSchema ( $ schema , static function ( $ type ) { return ! Directive :: isSpecifiedDirective ( $ type ) ; } , static function ( $ type ) { return ! Type :: isBuiltInType ( $ type ) ; } , $ options ) ; } 
private static function isSchemaOfCommonNames ( Schema $ schema ) { $ queryType = $ schema -> getQueryType ( ) ; if ( $ queryType && $ queryType -> name !== 'Query' ) { return false ; } $ mutationType = $ schema -> getMutationType ( ) ; if ( $ mutationType && $ mutationType -> name !== 'Mutation' ) { return false ; } $ subscriptionType = $ schema -> getSubscriptionType ( ) ; return ! $ subscriptionType || $ subscriptionType -> name === 'Subscription' ; } 
public static function printIntrospectionSchema ( Schema $ schema , array $ options = [ ] ) : string { return self :: printFilteredSchema ( $ schema , [ Directive :: class , 'isSpecifiedDirective' ] , [ Introspection :: class , 'isIntrospectionType' ] , $ options ) ; } 
public function parseValue ( $ value ) { if ( ! is_string ( $ value ) || ! filter_var ( $ value , FILTER_VALIDATE_URL ) ) { 
public function parseLiteral ( $ valueNode , array $ variables = null ) { 
public function getFieldSelection ( $ depth = 0 ) { $ fields = [ ] ; foreach ( $ this -> fieldNodes as $ fieldNode ) { $ fields = array_merge_recursive ( $ fields , $ this -> foldSelectionSet ( $ fieldNode -> selectionSet , $ depth ) ) ; } return $ fields ; } 
private function varTypeAllowedForType ( $ varType , $ expectedType ) { if ( $ expectedType instanceof NonNull ) { if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return false ; } if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType ) ; } if ( $ varType instanceof ListOfType && $ expectedType instanceof ListOfType ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return $ varType === $ expectedType ; } 
public static function findBreakingChanges ( Schema $ oldSchema , Schema $ newSchema ) { return array_merge ( self :: findRemovedTypes ( $ oldSchema , $ newSchema ) , self :: findTypesThatChangedKind ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnObjectOrInterfaceTypes ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnInputObjectTypes ( $ oldSchema , $ newSchema ) [ 'breakingChanges' ] , self :: findTypesRemovedFromUnions ( $ oldSchema , $ newSchema ) , self :: findValuesRemovedFromEnums ( $ oldSchema , $ newSchema ) , self :: findArgChanges ( $ oldSchema , $ newSchema ) [ 'breakingChanges' ] , self :: findInterfacesRemovedFromObjectTypes ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectives ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectiveArgs ( $ oldSchema , $ newSchema ) , self :: findAddedNonNullDirectiveArgs ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectiveLocations ( $ oldSchema , $ newSchema ) ) ; } 
public static function findRemovedTypes ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ breakingChanges = [ ] ; foreach ( array_keys ( $ oldTypeMap ) as $ typeName ) { if ( isset ( $ newTypeMap [ $ typeName ] ) ) { continue ; } $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_REMOVED , 'description' => "${typeName} was removed." , ] ; } return $ breakingChanges ; } 
public static function findTypesThatChangedKind ( Schema $ schemaA , Schema $ schemaB ) : iterable { $ schemaATypeMap = $ schemaA -> getTypeMap ( ) ; $ schemaBTypeMap = $ schemaB -> getTypeMap ( ) ; $ breakingChanges = [ ] ; foreach ( $ schemaATypeMap as $ typeName => $ schemaAType ) { if ( ! isset ( $ schemaBTypeMap [ $ typeName ] ) ) { continue ; } $ schemaBType = $ schemaBTypeMap [ $ typeName ] ; if ( $ schemaAType instanceof $ schemaBType ) { continue ; } if ( $ schemaBType instanceof $ schemaAType ) { continue ; } $ schemaATypeKindName = self :: typeKindName ( $ schemaAType ) ; $ schemaBTypeKindName = self :: typeKindName ( $ schemaBType ) ; $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_CHANGED_KIND , 'description' => "${typeName} changed from ${schemaATypeKindName} to ${schemaBTypeKindName}." , ] ; } return $ breakingChanges ; } 
private static function typeKindName ( Type $ type ) { if ( $ type instanceof ScalarType ) { return 'a Scalar type' ; } if ( $ type instanceof ObjectType ) { return 'an Object type' ; } if ( $ type instanceof InterfaceType ) { return 'an Interface type' ; } if ( $ type instanceof UnionType ) { return 'a Union type' ; } if ( $ type instanceof EnumType ) { return 'an Enum type' ; } if ( $ type instanceof InputObjectType ) { return 'an Input type' ; } throw new TypeError ( 'unknown type ' . $ type -> name ) ; } 
public static function findTypesRemovedFromUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesRemovedFromUnion = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInNewUnion = [ ] ; foreach ( $ newType -> getTypes ( ) as $ type ) { $ typeNamesInNewUnion [ $ type -> name ] = true ; } foreach ( $ oldType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInNewUnion [ $ type -> name ] ) ) { continue ; } $ typesRemovedFromUnion [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_REMOVED_FROM_UNION , 'description' => sprintf ( '%s was removed from union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesRemovedFromUnion ; } 
public static function findValuesRemovedFromEnums ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ valuesRemovedFromEnums = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof EnumType ) || ! ( $ newType instanceof EnumType ) ) { continue ; } $ valuesInNewEnum = [ ] ; foreach ( $ newType -> getValues ( ) as $ value ) { $ valuesInNewEnum [ $ value -> name ] = true ; } foreach ( $ oldType -> getValues ( ) as $ value ) { if ( isset ( $ valuesInNewEnum [ $ value -> name ] ) ) { continue ; } $ valuesRemovedFromEnums [ ] = [ 'type' => self :: BREAKING_CHANGE_VALUE_REMOVED_FROM_ENUM , 'description' => sprintf ( '%s was removed from enum type %s.' , $ value -> name , $ typeName ) , ] ; } } return $ valuesRemovedFromEnums ; } 
public static function findArgChanges ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ breakingChanges = [ ] ; $ dangerousChanges = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof ObjectType || $ oldType instanceof InterfaceType ) || ! ( $ newType instanceof ObjectType || $ newType instanceof InterfaceType ) || ! ( $ newType instanceof $ oldType ) ) { continue ; } $ oldTypeFields = $ oldType -> getFields ( ) ; $ newTypeFields = $ newType -> getFields ( ) ; foreach ( $ oldTypeFields as $ fieldName => $ oldField ) { if ( ! isset ( $ newTypeFields [ $ fieldName ] ) ) { continue ; } foreach ( $ oldField -> args as $ oldArgDef ) { $ newArgs = $ newTypeFields [ $ fieldName ] -> args ; $ newArgDef = Utils :: find ( $ newArgs , static function ( $ arg ) use ( $ oldArgDef ) { return $ arg -> name === $ oldArgDef -> name ; } ) ; if ( $ newArgDef !== null ) { $ isSafe = self :: isChangeSafeForInputObjectFieldOrFieldArg ( $ oldArgDef -> getType ( ) , $ newArgDef -> getType ( ) ) ; $ oldArgType = $ oldArgDef -> getType ( ) ; $ oldArgName = $ oldArgDef -> name ; if ( ! $ isSafe ) { $ newArgType = $ newArgDef -> getType ( ) ; $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_ARG_CHANGED_KIND , 'description' => "${typeName}.${fieldName} arg ${oldArgName} has changed type from ${oldArgType} to ${newArgType}" , ] ; } elseif ( $ oldArgDef -> defaultValueExists ( ) && $ oldArgDef -> defaultValue !== $ newArgDef -> defaultValue ) { $ dangerousChanges [ ] = [ 'type' => self :: DANGEROUS_CHANGE_ARG_DEFAULT_VALUE_CHANGED , 'description' => "${typeName}.${fieldName} arg ${oldArgName} has changed defaultValue" , ] ; } } else { $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_ARG_REMOVED , 'description' => sprintf ( '%s.%s arg %s was removed' , $ typeName , $ fieldName , $ oldArgDef -> name ) , ] ; } 
public static function findDangerousChanges ( Schema $ oldSchema , Schema $ newSchema ) { return array_merge ( self :: findArgChanges ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] , self :: findValuesAddedToEnums ( $ oldSchema , $ newSchema ) , self :: findInterfacesAddedToObjectTypes ( $ oldSchema , $ newSchema ) , self :: findTypesAddedToUnions ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnInputObjectTypes ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] ) ; } 
public static function findValuesAddedToEnums ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ valuesAddedToEnums = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof EnumType ) || ! ( $ newType instanceof EnumType ) ) { continue ; } $ valuesInOldEnum = [ ] ; foreach ( $ oldType -> getValues ( ) as $ value ) { $ valuesInOldEnum [ $ value -> name ] = true ; } foreach ( $ newType -> getValues ( ) as $ value ) { if ( isset ( $ valuesInOldEnum [ $ value -> name ] ) ) { continue ; } $ valuesAddedToEnums [ ] = [ 'type' => self :: DANGEROUS_CHANGE_VALUE_ADDED_TO_ENUM , 'description' => sprintf ( '%s was added to enum type %s.' , $ value -> name , $ typeName ) , ] ; } } return $ valuesAddedToEnums ; } 
public static function findTypesAddedToUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesAddedToUnion = [ ] ; foreach ( $ newTypeMap as $ typeName => $ newType ) { $ oldType = $ oldTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInOldUnion = [ ] ; foreach ( $ oldType -> getTypes ( ) as $ type ) { $ typeNamesInOldUnion [ $ type -> name ] = true ; } foreach ( $ newType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInOldUnion [ $ type -> name ] ) ) { continue ; } $ typesAddedToUnion [ ] = [ 'type' => self :: DANGEROUS_CHANGE_TYPE_ADDED_TO_UNION , 'description' => sprintf ( '%s was added to union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesAddedToUnion ; } 
public static function getIntrospectionQuery ( $ options = [ ] ) { if ( is_bool ( $ options ) ) { trigger_error ( 'Calling Introspection::getIntrospectionQuery(boolean) is deprecated. ' . 'Please use Introspection::getIntrospectionQuery(["descriptions" => boolean]).' , E_USER_DEPRECATED ) ; $ descriptions = $ options ; } else { $ descriptions = ! array_key_exists ( 'descriptions' , $ options ) || $ options [ 'descriptions' ] === true ; } $ descriptionField = $ descriptions ? 'description' : '' ; return <<<EOD query IntrospectionQuery { __schema { queryType { name } mutationType { name } subscriptionType { name } types { ...FullType } directives { name {$descriptionField} locations args { ...InputValue } } } } fragment FullType on __Type { kind name {$descriptionField} fields(includeDeprecated: true) { name {$descriptionField} args { ...InputValue } type { ...TypeRef } isDeprecated deprecationReason } inputFields { ...InputValue } interfaces { ...TypeRef } enumValues(includeDeprecated: true) { name {$descriptionField} isDeprecated deprecationReason } possibleTypes { ...TypeRef } } fragment InputValue on __InputValue { name {$descriptionField} type { ...TypeRef } defaultValue } fragment TypeRef on __Type { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name } } } } } } } } EOD ; } 
public static function create ( array $ options = [ ] ) { $ config = new static ( ) ; if ( ! empty ( $ options ) ) { if ( isset ( $ options [ 'query' ] ) ) { $ config -> setQuery ( $ options [ 'query' ] ) ; } if ( isset ( $ options [ 'mutation' ] ) ) { $ config -> setMutation ( $ options [ 'mutation' ] ) ; } if ( isset ( $ options [ 'subscription' ] ) ) { $ config -> setSubscription ( $ options [ 'subscription' ] ) ; } if ( isset ( $ options [ 'types' ] ) ) { $ config -> setTypes ( $ options [ 'types' ] ) ; } if ( isset ( $ options [ 'directives' ] ) ) { $ config -> setDirectives ( $ options [ 'directives' ] ) ; } if ( isset ( $ options [ 'typeLoader' ] ) ) { Utils :: invariant ( is_callable ( $ options [ 'typeLoader' ] ) , 'Schema type loader must be callable if provided but got: %s' , Utils :: printSafe ( $ options [ 'typeLoader' ] ) ) ; $ config -> setTypeLoader ( $ options [ 'typeLoader' ] ) ; } if ( isset ( $ options [ 'astNode' ] ) ) { $ config -> setAstNode ( $ options [ 'astNode' ] ) ; } if ( isset ( $ options [ 'assumeValid' ] ) ) { $ config -> setAssumeValid ( ( bool ) $ options [ 'assumeValid' ] ) ; } if ( isset ( $ options [ 'extensionASTNodes' ] ) ) { $ config -> setExtensionASTNodes ( $ options [ 'extensionASTNodes' ] ) ; } } return $ config ; } 
private function findConflictsWithinSelectionSet ( ValidationContext $ context , $ parentType , SelectionSetNode $ selectionSet ) { [ $ fieldMap , $ fragmentNames ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType , $ selectionSet ) ; $ conflicts = [ ] ; 
private function getFieldsAndFragmentNames ( ValidationContext $ context , $ parentType , SelectionSetNode $ selectionSet ) { if ( isset ( $ this -> cachedFieldsAndFragmentNames [ $ selectionSet ] ) ) { $ cached = $ this -> cachedFieldsAndFragmentNames [ $ selectionSet ] ; } else { $ astAndDefs = [ ] ; $ fragmentNames = [ ] ; $ this -> internalCollectFieldsAndFragmentNames ( $ context , $ parentType , $ selectionSet , $ astAndDefs , $ fragmentNames ) ; $ cached = [ $ astAndDefs , array_keys ( $ fragmentNames ) ] ; $ this -> cachedFieldsAndFragmentNames [ $ selectionSet ] = $ cached ; } return $ cached ; } 
private function internalCollectFieldsAndFragmentNames ( ValidationContext $ context , $ parentType , SelectionSetNode $ selectionSet , array & $ astAndDefs , array & $ fragmentNames ) { foreach ( $ selectionSet -> selections as $ selection ) { switch ( true ) { case $ selection instanceof FieldNode : $ fieldName = $ selection -> name -> value ; $ fieldDef = null ; if ( $ parentType instanceof ObjectType || $ parentType instanceof InterfaceType ) { $ tmp = $ parentType -> getFields ( ) ; if ( isset ( $ tmp [ $ fieldName ] ) ) { $ fieldDef = $ tmp [ $ fieldName ] ; } } $ responseName = $ selection -> alias ? $ selection -> alias -> value : $ fieldName ; if ( ! isset ( $ astAndDefs [ $ responseName ] ) ) { $ astAndDefs [ $ responseName ] = [ ] ; } $ astAndDefs [ $ responseName ] [ ] = [ $ parentType , $ selection , $ fieldDef ] ; break ; case $ selection instanceof FragmentSpreadNode : $ fragmentNames [ $ selection -> name -> value ] = true ; break ; case $ selection instanceof InlineFragmentNode : $ typeCondition = $ selection -> typeCondition ; $ inlineFragmentType = $ typeCondition ? TypeInfo :: typeFromAST ( $ context -> getSchema ( ) , $ typeCondition ) : $ parentType ; $ this -> internalCollectFieldsAndFragmentNames ( $ context , $ inlineFragmentType , $ selection -> selectionSet , $ astAndDefs , $ fragmentNames ) ; break ; } } } 
private function collectConflictsWithin ( ValidationContext $ context , array & $ conflicts , array $ fieldMap ) { 
private function findConflict ( ValidationContext $ context , $ parentFieldsAreMutuallyExclusive , $ responseName , array $ field1 , array $ field2 ) { [ $ parentType1 , $ ast1 , $ def1 ] = $ field1 ; [ $ parentType2 , $ ast2 , $ def2 ] = $ field2 ; 
private function sameArguments ( $ arguments1 , $ arguments2 ) { if ( count ( $ arguments1 ) !== count ( $ arguments2 ) ) { return false ; } foreach ( $ arguments1 as $ argument1 ) { $ argument2 = null ; foreach ( $ arguments2 as $ argument ) { if ( $ argument -> name -> value === $ argument1 -> name -> value ) { $ argument2 = $ argument ; break ; } } if ( ! $ argument2 ) { return false ; } if ( ! $ this -> sameValue ( $ argument1 -> value , $ argument2 -> value ) ) { return false ; } } return true ; } 
private function doTypesConflict ( OutputType $ type1 , OutputType $ type2 ) { if ( $ type1 instanceof ListOfType ) { return $ type2 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof ListOfType ) { return $ type1 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type1 instanceof NonNull ) { return $ type2 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof NonNull ) { return $ type1 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( Type :: isLeafType ( $ type1 ) || Type :: isLeafType ( $ type2 ) ) { return $ type1 !== $ type2 ; } return false ; } 
private function findConflictsBetweenSubSelectionSets ( ValidationContext $ context , $ areMutuallyExclusive , $ parentType1 , SelectionSetNode $ selectionSet1 , $ parentType2 , SelectionSetNode $ selectionSet2 ) { $ conflicts = [ ] ; [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType1 , $ selectionSet1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType2 , $ selectionSet2 ) ; 
private function collectConflictsBetween ( ValidationContext $ context , array & $ conflicts , $ parentFieldsAreMutuallyExclusive , array $ fieldMap1 , array $ fieldMap2 ) { 
private function collectConflictsBetweenFieldsAndFragment ( ValidationContext $ context , array & $ conflicts , array & $ comparedFragments , $ areMutuallyExclusive , array $ fieldMap , $ fragmentName ) { if ( isset ( $ comparedFragments [ $ fragmentName ] ) ) { return ; } $ comparedFragments [ $ fragmentName ] = true ; $ fragment = $ context -> getFragment ( $ fragmentName ) ; if ( ! $ fragment ) { return ; } [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment ) ; if ( $ fieldMap === $ fieldMap2 ) { return ; } 
private function getReferencedFieldsAndFragmentNames ( ValidationContext $ context , FragmentDefinitionNode $ fragment ) { 
private function collectConflictsBetweenFragments ( ValidationContext $ context , array & $ conflicts , $ areMutuallyExclusive , $ fragmentName1 , $ fragmentName2 ) { 
private function subfieldConflicts ( array $ conflicts , $ responseName , FieldNode $ ast1 , FieldNode $ ast2 ) { if ( count ( $ conflicts ) === 0 ) { return null ; } return [ [ $ responseName , array_map ( static function ( $ conflict ) { return $ conflict [ 0 ] ; } , $ conflicts ) , ] , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 1 ] ) ; } , [ $ ast1 ] ) , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 2 ] ) ; } , [ $ ast2 ] ) , ] ; } 
public function serialize ( $ value ) { if ( $ value === true ) { return 'true' ; } if ( $ value === false ) { return 'false' ; } if ( $ value === null ) { return 'null' ; } if ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } if ( ! is_scalar ( $ value ) ) { throw new Error ( 'String cannot represent non scalar value: ' . Utils :: printSafe ( $ value ) ) ; } return $ this -> coerceString ( $ value ) ; } 
public function getFragment ( $ name ) { $ fragments = $ this -> fragments ; if ( ! $ fragments ) { $ fragments = [ ] ; foreach ( $ this -> getDocument ( ) -> definitions as $ statement ) { if ( $ statement -> kind !== NodeKind :: FRAGMENT_DEFINITION ) { continue ; } $ fragments [ $ statement -> name -> value ] = $ statement ; } $ this -> fragments = $ fragments ; } return $ fragments [ $ name ] ?? null ; } 
private function getSuggestedTypeNames ( Schema $ schema , $ type , $ fieldName ) { if ( Type :: isAbstractType ( $ type ) ) { $ suggestedObjectTypes = [ ] ; $ interfaceUsageCount = [ ] ; foreach ( $ schema -> getPossibleTypes ( $ type ) as $ possibleType ) { $ fields = $ possibleType -> getFields ( ) ; if ( ! isset ( $ fields [ $ fieldName ] ) ) { continue ; } 
private function getSuggestedFieldNames ( Schema $ schema , $ type , $ fieldName ) { if ( $ type instanceof ObjectType || $ type instanceof InterfaceType ) { $ possibleFieldNames = array_keys ( $ type -> getFields ( ) ) ; return Utils :: suggestionList ( $ fieldName , $ possibleFieldNames ) ; } 
public static function undefinedFieldMessage ( $ fieldName , $ type , array $ suggestedTypeNames , array $ suggestedFieldNames ) { $ message = sprintf ( 'Cannot query field "%s" on type "%s".' , $ fieldName , $ type ) ; if ( $ suggestedTypeNames ) { $ suggestions = Utils :: quotedOrList ( $ suggestedTypeNames ) ; $ message .= sprintf ( ' Did you mean to use an inline fragment on %s?' , $ suggestions ) ; } elseif ( ! empty ( $ suggestedFieldNames ) ) { $ suggestions = Utils :: quotedOrList ( $ suggestedFieldNames ) ; $ message .= sprintf ( ' Did you mean %s?' , $ suggestions ) ; } return $ message ; } 
public function assertValid ( ) { parent :: assertValid ( ) ; Utils :: invariant ( ! empty ( $ this -> getFields ( ) ) , sprintf ( '%s fields must be an associative array with field names as keys or a callable which returns such an array.' , $ this -> name ) ) ; foreach ( $ this -> getFields ( ) as $ field ) { $ field -> assertValid ( $ this ) ; } } 
public function toArray ( $ debug = false ) { $ result = [ ] ; if ( ! empty ( $ this -> errors ) ) { $ errorsHandler = $ this -> errorsHandler ? : static function ( array $ errors , callable $ formatter ) { return array_map ( $ formatter , $ errors ) ; } ; $ result [ 'errors' ] = $ errorsHandler ( $ this -> errors , FormattedError :: prepareFormatter ( $ this -> errorFormatter , $ debug ) ) ; } if ( $ this -> data !== null ) { $ result [ 'data' ] = $ this -> data ; } if ( ! empty ( $ this -> extensions ) ) { $ result [ 'extensions' ] = $ this -> extensions ; } return $ result ; } 
public static function fromArray ( array $ node ) : Node { if ( ! isset ( $ node [ 'kind' ] ) || ! isset ( NodeKind :: $ classMap [ $ node [ 'kind' ] ] ) ) { throw new InvariantViolation ( 'Unexpected node structure: ' . Utils :: printSafeJson ( $ node ) ) ; } $ kind = $ node [ 'kind' ] ?? null ; $ class = NodeKind :: $ classMap [ $ kind ] ; $ instance = new $ class ( [ ] ) ; if ( isset ( $ node [ 'loc' ] , $ node [ 'loc' ] [ 'start' ] , $ node [ 'loc' ] [ 'end' ] ) ) { $ instance -> loc = Location :: create ( $ node [ 'loc' ] [ 'start' ] , $ node [ 'loc' ] [ 'end' ] ) ; } foreach ( $ node as $ key => $ value ) { if ( $ key === 'loc' || $ key === 'kind' ) { continue ; } if ( is_array ( $ value ) ) { if ( isset ( $ value [ 0 ] ) || empty ( $ value ) ) { $ value = new NodeList ( $ value ) ; } else { $ value = self :: fromArray ( $ value ) ; } } $ instance -> { $ key } = $ value ; } return $ instance ; } 
public static function astFromValue ( $ value , InputType $ type ) { if ( $ type instanceof NonNull ) { $ astValue = self :: astFromValue ( $ value , $ type -> getWrappedType ( ) ) ; if ( $ astValue instanceof NullValueNode ) { return null ; } return $ astValue ; } if ( $ value === null ) { return new NullValueNode ( [ ] ) ; } 
public static function valueFromAST ( $ valueNode , InputType $ type , ? array $ variables = null ) { $ undefined = Utils :: undefined ( ) ; if ( $ valueNode === null ) { 
private static function isMissingVariable ( $ valueNode , $ variables ) { return $ valueNode instanceof VariableNode && ( count ( $ variables ) === 0 || ! array_key_exists ( $ valueNode -> name -> value , $ variables ) ) ; } 
public static function valueFromASTUntyped ( $ valueNode , ? array $ variables = null ) { switch ( true ) { case $ valueNode instanceof NullValueNode : return null ; case $ valueNode instanceof IntValueNode : return intval ( $ valueNode -> value , 10 ) ; case $ valueNode instanceof FloatValueNode : return floatval ( $ valueNode -> value ) ; case $ valueNode instanceof StringValueNode : case $ valueNode instanceof EnumValueNode : case $ valueNode instanceof BooleanValueNode : return $ valueNode -> value ; case $ valueNode instanceof ListValueNode : return array_map ( static function ( $ node ) use ( $ variables ) { return self :: valueFromASTUntyped ( $ node , $ variables ) ; } , iterator_to_array ( $ valueNode -> values ) ) ; case $ valueNode instanceof ObjectValueNode : return array_combine ( array_map ( static function ( $ field ) { return $ field -> name -> value ; } , iterator_to_array ( $ valueNode -> fields ) ) , array_map ( static function ( $ field ) use ( $ variables ) { return self :: valueFromASTUntyped ( $ field -> value , $ variables ) ; } , iterator_to_array ( $ valueNode -> fields ) ) ) ; case $ valueNode instanceof VariableNode : $ variableName = $ valueNode -> name -> value ; return $ variables && isset ( $ variables [ $ variableName ] ) ? $ variables [ $ variableName ] : null ; } throw new Error ( 'Unexpected value kind: ' . $ valueNode -> kind . '.' ) ; } 
public static function typeFromAST ( Schema $ schema , $ inputTypeNode ) { if ( $ inputTypeNode instanceof ListTypeNode ) { $ innerType = self :: typeFromAST ( $ schema , $ inputTypeNode -> type ) ; return $ innerType ? new ListOfType ( $ innerType ) : null ; } if ( $ inputTypeNode instanceof NonNullTypeNode ) { $ innerType = self :: typeFromAST ( $ schema , $ inputTypeNode -> type ) ; return $ innerType ? new NonNull ( $ innerType ) : null ; } if ( $ inputTypeNode instanceof NamedTypeNode ) { return $ schema -> getType ( $ inputTypeNode -> name -> value ) ; } throw new Error ( 'Unexpected type kind: ' . $ inputTypeNode -> kind . '.' ) ; } 
public static function getOperation ( DocumentNode $ document , $ operationName = null ) { if ( $ document -> definitions ) { foreach ( $ document -> definitions as $ def ) { if ( ! ( $ def instanceof OperationDefinitionNode ) ) { continue ; } if ( ! $ operationName || ( isset ( $ def -> name -> value ) && $ def -> name -> value === $ operationName ) ) { return $ def -> operation ; } } } return false ; } 
public static function executeQuery ( SchemaType $ schema , $ source , $ rootValue = null , $ context = null , $ variableValues = null , ? string $ operationName = null , ? callable $ fieldResolver = null , ? array $ validationRules = null ) : ExecutionResult { $ promiseAdapter = new SyncPromiseAdapter ( ) ; $ promise = self :: promiseToExecute ( $ promiseAdapter , $ schema , $ source , $ rootValue , $ context , $ variableValues , $ operationName , $ fieldResolver , $ validationRules ) ; return $ promiseAdapter -> wait ( $ promise ) ; } 
public static function promiseToExecute ( PromiseAdapter $ promiseAdapter , SchemaType $ schema , $ source , $ rootValue = null , $ context = null , $ variableValues = null , ? string $ operationName = null , ? callable $ fieldResolver = null , ? array $ validationRules = null ) : Promise { try { if ( $ source instanceof DocumentNode ) { $ documentNode = $ source ; } else { $ documentNode = Parser :: parse ( new Source ( $ source ? : '' , 'GraphQL' ) ) ; } 
public static function execute ( SchemaType $ schema , $ source , $ rootValue = null , $ contextValue = null , $ variableValues = null , ? string $ operationName = null ) { trigger_error ( __METHOD__ . ' is deprecated, use GraphQL::executeQuery()->toArray() as a quick replacement' , E_USER_DEPRECATED ) ; $ promiseAdapter = Executor :: getPromiseAdapter ( ) ; $ result = self :: promiseToExecute ( $ promiseAdapter , $ schema , $ source , $ rootValue , $ contextValue , $ variableValues , $ operationName ) ; if ( $ promiseAdapter instanceof SyncPromiseAdapter ) { $ result = $ promiseAdapter -> wait ( $ result ) -> toArray ( ) ; } else { $ result = $ result -> then ( static function ( ExecutionResult $ r ) { return $ r -> toArray ( ) ; } ) ; } return $ result ; } 
public static function executeAndReturnResult ( SchemaType $ schema , $ source , $ rootValue = null , $ contextValue = null , $ variableValues = null , ? string $ operationName = null ) { trigger_error ( __METHOD__ . ' is deprecated, use GraphQL::executeQuery() as a quick replacement' , E_USER_DEPRECATED ) ; $ promiseAdapter = Executor :: getPromiseAdapter ( ) ; $ result = self :: promiseToExecute ( $ promiseAdapter , $ schema , $ source , $ rootValue , $ contextValue , $ variableValues , $ operationName ) ; if ( $ promiseAdapter instanceof SyncPromiseAdapter ) { $ result = $ promiseAdapter -> wait ( $ result ) ; } return $ result ; } 
public static function suppress ( $ suppress = true ) { if ( $ suppress === true ) { self :: $ enableWarnings = 0 ; } elseif ( $ suppress === false ) { self :: $ enableWarnings = self :: ALL ; } else { self :: $ enableWarnings &= ~ $ suppress ; } } 
public static function enable ( $ enable = true ) { if ( $ enable === true ) { self :: $ enableWarnings = self :: ALL ; } elseif ( $ enable === false ) { self :: $ enableWarnings = 0 ; } else { self :: $ enableWarnings |= $ enable ; } } 
public function parseValue ( $ value ) { if ( is_string ( $ value ) || is_int ( $ value ) ) { return ( string ) $ value ; } throw new Error ( 'Cannot represent value as ID: ' . Utils :: printSafe ( $ value ) ) ; } 
public function parseLiteral ( $ valueNode , ? array $ variables = null ) { if ( $ valueNode instanceof StringValueNode || $ valueNode instanceof IntValueNode ) { return $ valueNode -> value ; } 
public static function parse ( $ source , array $ options = [ ] ) { $ sourceObj = $ source instanceof Source ? $ source : new Source ( $ source ) ; $ parser = new self ( $ sourceObj , $ options ) ; return $ parser -> parseDocument ( ) ; } 
public static function parseValue ( $ source , array $ options = [ ] ) { $ sourceObj = $ source instanceof Source ? $ source : new Source ( $ source ) ; $ parser = new Parser ( $ sourceObj , $ options ) ; $ parser -> expect ( Token :: SOF ) ; $ value = $ parser -> parseValueLiteral ( false ) ; $ parser -> expect ( Token :: EOF ) ; return $ value ; } 
public static function parseType ( $ source , array $ options = [ ] ) { $ sourceObj = $ source instanceof Source ? $ source : new Source ( $ source ) ; $ parser = new Parser ( $ sourceObj , $ options ) ; $ parser -> expect ( Token :: SOF ) ; $ type = $ parser -> parseTypeReference ( ) ; $ parser -> expect ( Token :: EOF ) ; return $ type ; } 
private function loc ( Token $ startToken ) { if ( empty ( $ this -> lexer -> options [ 'noLocation' ] ) ) { return new Location ( $ startToken , $ this -> lexer -> lastToken , $ this -> lexer -> source ) ; } return null ; } 
private function skip ( $ kind ) { $ match = $ this -> lexer -> token -> kind === $ kind ; if ( $ match ) { $ this -> lexer -> advance ( ) ; } return $ match ; } 
private function expect ( $ kind ) { $ token = $ this -> lexer -> token ; if ( $ token -> kind === $ kind ) { $ this -> lexer -> advance ( ) ; return $ token ; } throw new SyntaxError ( $ this -> lexer -> source , $ token -> start , sprintf ( 'Expected %s, found %s' , $ kind , $ token -> getDescription ( ) ) ) ; } 
private function expectKeyword ( $ value ) { $ token = $ this -> lexer -> token ; if ( $ token -> kind === Token :: NAME && $ token -> value === $ value ) { $ this -> lexer -> advance ( ) ; return $ token ; } throw new SyntaxError ( $ this -> lexer -> source , $ token -> start , 'Expected "' . $ value . '", found ' . $ token -> getDescription ( ) ) ; } 
private function parseName ( ) { $ token = $ this -> expect ( Token :: NAME ) ; return new NameNode ( [ 'value' => $ token -> value , 'loc' => $ this -> loc ( $ token ) , ] ) ; } 
private function parseDocument ( ) { $ start = $ this -> lexer -> token ; $ this -> expect ( Token :: SOF ) ; $ definitions = [ ] ; do { $ definitions [ ] = $ this -> parseDefinition ( ) ; } while ( ! $ this -> skip ( Token :: EOF ) ) ; return new DocumentNode ( [ 'definitions' => new NodeList ( $ definitions ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseDefinition ( ) { if ( $ this -> peek ( Token :: NAME ) ) { switch ( $ this -> lexer -> token -> value ) { case 'query' : case 'mutation' : case 'subscription' : case 'fragment' : return $ this -> parseExecutableDefinition ( ) ; 
private function parseExecutableDefinition ( ) { if ( $ this -> peek ( Token :: NAME ) ) { switch ( $ this -> lexer -> token -> value ) { case 'query' : case 'mutation' : case 'subscription' : return $ this -> parseOperationDefinition ( ) ; case 'fragment' : return $ this -> parseFragmentDefinition ( ) ; } } elseif ( $ this -> peek ( Token :: BRACE_L ) ) { return $ this -> parseOperationDefinition ( ) ; } throw $ this -> unexpected ( ) ; } 
private function parseOperationDefinition ( ) { $ start = $ this -> lexer -> token ; if ( $ this -> peek ( Token :: BRACE_L ) ) { return new OperationDefinitionNode ( [ 'operation' => 'query' , 'name' => null , 'variableDefinitions' => new NodeList ( [ ] ) , 'directives' => new NodeList ( [ ] ) , 'selectionSet' => $ this -> parseSelectionSet ( ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; } $ operation = $ this -> parseOperationType ( ) ; $ name = null ; if ( $ this -> peek ( Token :: NAME ) ) { $ name = $ this -> parseName ( ) ; } return new OperationDefinitionNode ( [ 'operation' => $ operation , 'name' => $ name , 'variableDefinitions' => $ this -> parseVariableDefinitions ( ) , 'directives' => $ this -> parseDirectives ( false ) , 'selectionSet' => $ this -> parseSelectionSet ( ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseOperationType ( ) { $ operationToken = $ this -> expect ( Token :: NAME ) ; switch ( $ operationToken -> value ) { case 'query' : return 'query' ; case 'mutation' : return 'mutation' ; case 'subscription' : return 'subscription' ; } throw $ this -> unexpected ( $ operationToken ) ; } 
private function parseVariableDefinition ( ) { $ start = $ this -> lexer -> token ; $ var = $ this -> parseVariable ( ) ; $ this -> expect ( Token :: COLON ) ; $ type = $ this -> parseTypeReference ( ) ; return new VariableDefinitionNode ( [ 'variable' => $ var , 'type' => $ type , 'defaultValue' => ( $ this -> skip ( Token :: EQUALS ) ? $ this -> parseValueLiteral ( true ) : null ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseVariable ( ) { $ start = $ this -> lexer -> token ; $ this -> expect ( Token :: DOLLAR ) ; return new VariableNode ( [ 'name' => $ this -> parseName ( ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseField ( ) { $ start = $ this -> lexer -> token ; $ nameOrAlias = $ this -> parseName ( ) ; if ( $ this -> skip ( Token :: COLON ) ) { $ alias = $ nameOrAlias ; $ name = $ this -> parseName ( ) ; } else { $ alias = null ; $ name = $ nameOrAlias ; } return new FieldNode ( [ 'alias' => $ alias , 'name' => $ name , 'arguments' => $ this -> parseArguments ( false ) , 'directives' => $ this -> parseDirectives ( false ) , 'selectionSet' => $ this -> peek ( Token :: BRACE_L ) ? $ this -> parseSelectionSet ( ) : null , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseArguments ( $ isConst ) { $ parseFn = $ isConst ? function ( ) { return $ this -> parseConstArgument ( ) ; } : function ( ) { return $ this -> parseArgument ( ) ; } ; return $ this -> peek ( Token :: PAREN_L ) ? $ this -> many ( Token :: PAREN_L , $ parseFn , Token :: PAREN_R ) : new NodeList ( [ ] ) ; } 
private function parseArgument ( ) { $ start = $ this -> lexer -> token ; $ name = $ this -> parseName ( ) ; $ this -> expect ( Token :: COLON ) ; $ value = $ this -> parseValueLiteral ( false ) ; return new ArgumentNode ( [ 'name' => $ name , 'value' => $ value , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseConstArgument ( ) { $ start = $ this -> lexer -> token ; $ name = $ this -> parseName ( ) ; $ this -> expect ( Token :: COLON ) ; $ value = $ this -> parseConstValue ( ) ; return new ArgumentNode ( [ 'name' => $ name , 'value' => $ value , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseFragment ( ) { $ start = $ this -> lexer -> token ; $ this -> expect ( Token :: SPREAD ) ; if ( $ this -> peek ( Token :: NAME ) && $ this -> lexer -> token -> value !== 'on' ) { return new FragmentSpreadNode ( [ 'name' => $ this -> parseFragmentName ( ) , 'directives' => $ this -> parseDirectives ( false ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; } $ typeCondition = null ; if ( $ this -> lexer -> token -> value === 'on' ) { $ this -> lexer -> advance ( ) ; $ typeCondition = $ this -> parseNamedType ( ) ; } return new InlineFragmentNode ( [ 'typeCondition' => $ typeCondition , 'directives' => $ this -> parseDirectives ( false ) , 'selectionSet' => $ this -> parseSelectionSet ( ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseFragmentDefinition ( ) { $ start = $ this -> lexer -> token ; $ this -> expectKeyword ( 'fragment' ) ; $ name = $ this -> parseFragmentName ( ) ; 
private function parseValueLiteral ( $ isConst ) { $ token = $ this -> lexer -> token ; switch ( $ token -> kind ) { case Token :: BRACKET_L : return $ this -> parseArray ( $ isConst ) ; case Token :: BRACE_L : return $ this -> parseObject ( $ isConst ) ; case Token :: INT : $ this -> lexer -> advance ( ) ; return new IntValueNode ( [ 'value' => $ token -> value , 'loc' => $ this -> loc ( $ token ) , ] ) ; case Token :: FLOAT : $ this -> lexer -> advance ( ) ; return new FloatValueNode ( [ 'value' => $ token -> value , 'loc' => $ this -> loc ( $ token ) , ] ) ; case Token :: STRING : case Token :: BLOCK_STRING : return $ this -> parseStringLiteral ( ) ; case Token :: NAME : if ( $ token -> value === 'true' || $ token -> value === 'false' ) { $ this -> lexer -> advance ( ) ; return new BooleanValueNode ( [ 'value' => $ token -> value === 'true' , 'loc' => $ this -> loc ( $ token ) , ] ) ; } if ( $ token -> value === 'null' ) { $ this -> lexer -> advance ( ) ; return new NullValueNode ( [ 'loc' => $ this -> loc ( $ token ) , ] ) ; } else { $ this -> lexer -> advance ( ) ; return new EnumValueNode ( [ 'value' => $ token -> value , 'loc' => $ this -> loc ( $ token ) , ] ) ; } break ; case Token :: DOLLAR : if ( ! $ isConst ) { return $ this -> parseVariable ( ) ; } break ; } throw $ this -> unexpected ( ) ; } 
private function parseArray ( $ isConst ) { $ start = $ this -> lexer -> token ; $ parseFn = $ isConst ? function ( ) { return $ this -> parseConstValue ( ) ; } : function ( ) { return $ this -> parseVariableValue ( ) ; } ; return new ListValueNode ( [ 'values' => $ this -> any ( Token :: BRACKET_L , $ parseFn , Token :: BRACKET_R ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseObject ( $ isConst ) { $ start = $ this -> lexer -> token ; $ this -> expect ( Token :: BRACE_L ) ; $ fields = [ ] ; while ( ! $ this -> skip ( Token :: BRACE_R ) ) { $ fields [ ] = $ this -> parseObjectField ( $ isConst ) ; } return new ObjectValueNode ( [ 'fields' => new NodeList ( $ fields ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseObjectField ( $ isConst ) { $ start = $ this -> lexer -> token ; $ name = $ this -> parseName ( ) ; $ this -> expect ( Token :: COLON ) ; return new ObjectFieldNode ( [ 'name' => $ name , 'value' => $ this -> parseValueLiteral ( $ isConst ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseDirectives ( $ isConst ) { $ directives = [ ] ; while ( $ this -> peek ( Token :: AT ) ) { $ directives [ ] = $ this -> parseDirective ( $ isConst ) ; } return new NodeList ( $ directives ) ; } 
private function parseDirective ( $ isConst ) { $ start = $ this -> lexer -> token ; $ this -> expect ( Token :: AT ) ; return new DirectiveNode ( [ 'name' => $ this -> parseName ( ) , 'arguments' => $ this -> parseArguments ( $ isConst ) , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseTypeReference ( ) { $ start = $ this -> lexer -> token ; if ( $ this -> skip ( Token :: BRACKET_L ) ) { $ type = $ this -> parseTypeReference ( ) ; $ this -> expect ( Token :: BRACKET_R ) ; $ type = new ListTypeNode ( [ 'type' => $ type , 'loc' => $ this -> loc ( $ start ) , ] ) ; } else { $ type = $ this -> parseNamedType ( ) ; } if ( $ this -> skip ( Token :: BANG ) ) { return new NonNullTypeNode ( [ 'type' => $ type , 'loc' => $ this -> loc ( $ start ) , ] ) ; } return $ type ; } 
private function parseTypeSystemDefinition ( ) { 
private function parseSchemaDefinition ( ) { $ start = $ this -> lexer -> token ; $ this -> expectKeyword ( 'schema' ) ; $ directives = $ this -> parseDirectives ( true ) ; $ operationTypes = $ this -> many ( Token :: BRACE_L , function ( ) { return $ this -> parseOperationTypeDefinition ( ) ; } , Token :: BRACE_R ) ; return new SchemaDefinitionNode ( [ 'directives' => $ directives , 'operationTypes' => $ operationTypes , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseOperationTypeDefinition ( ) { $ start = $ this -> lexer -> token ; $ operation = $ this -> parseOperationType ( ) ; $ this -> expect ( Token :: COLON ) ; $ type = $ this -> parseNamedType ( ) ; return new OperationTypeDefinitionNode ( [ 'operation' => $ operation , 'type' => $ type , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseScalarTypeDefinition ( ) { $ start = $ this -> lexer -> token ; $ description = $ this -> parseDescription ( ) ; $ this -> expectKeyword ( 'scalar' ) ; $ name = $ this -> parseName ( ) ; $ directives = $ this -> parseDirectives ( true ) ; return new ScalarTypeDefinitionNode ( [ 'name' => $ name , 'directives' => $ directives , 'loc' => $ this -> loc ( $ start ) , 'description' => $ description , ] ) ; } 
private function parseObjectTypeDefinition ( ) { $ start = $ this -> lexer -> token ; $ description = $ this -> parseDescription ( ) ; $ this -> expectKeyword ( 'type' ) ; $ name = $ this -> parseName ( ) ; $ interfaces = $ this -> parseImplementsInterfaces ( ) ; $ directives = $ this -> parseDirectives ( true ) ; $ fields = $ this -> parseFieldsDefinition ( ) ; return new ObjectTypeDefinitionNode ( [ 'name' => $ name , 'interfaces' => $ interfaces , 'directives' => $ directives , 'fields' => $ fields , 'loc' => $ this -> loc ( $ start ) , 'description' => $ description , ] ) ; } 
private function parseImplementsInterfaces ( ) { $ types = [ ] ; if ( $ this -> lexer -> token -> value === 'implements' ) { $ this -> lexer -> advance ( ) ; 
private function parseFieldsDefinition ( ) { 
private function parseFieldDefinition ( ) { $ start = $ this -> lexer -> token ; $ description = $ this -> parseDescription ( ) ; $ name = $ this -> parseName ( ) ; $ args = $ this -> parseArgumentDefs ( ) ; $ this -> expect ( Token :: COLON ) ; $ type = $ this -> parseTypeReference ( ) ; $ directives = $ this -> parseDirectives ( true ) ; return new FieldDefinitionNode ( [ 'name' => $ name , 'arguments' => $ args , 'type' => $ type , 'directives' => $ directives , 'loc' => $ this -> loc ( $ start ) , 'description' => $ description , ] ) ; } 
private function parseArgumentDefs ( ) { if ( ! $ this -> peek ( Token :: PAREN_L ) ) { return new NodeList ( [ ] ) ; } return $ this -> many ( Token :: PAREN_L , function ( ) { return $ this -> parseInputValueDef ( ) ; } , Token :: PAREN_R ) ; } 
private function parseInputValueDef ( ) { $ start = $ this -> lexer -> token ; $ description = $ this -> parseDescription ( ) ; $ name = $ this -> parseName ( ) ; $ this -> expect ( Token :: COLON ) ; $ type = $ this -> parseTypeReference ( ) ; $ defaultValue = null ; if ( $ this -> skip ( Token :: EQUALS ) ) { $ defaultValue = $ this -> parseConstValue ( ) ; } $ directives = $ this -> parseDirectives ( true ) ; return new InputValueDefinitionNode ( [ 'name' => $ name , 'type' => $ type , 'defaultValue' => $ defaultValue , 'directives' => $ directives , 'loc' => $ this -> loc ( $ start ) , 'description' => $ description , ] ) ; } 
private function parseInterfaceTypeDefinition ( ) { $ start = $ this -> lexer -> token ; $ description = $ this -> parseDescription ( ) ; $ this -> expectKeyword ( 'interface' ) ; $ name = $ this -> parseName ( ) ; $ directives = $ this -> parseDirectives ( true ) ; $ fields = $ this -> parseFieldsDefinition ( ) ; return new InterfaceTypeDefinitionNode ( [ 'name' => $ name , 'directives' => $ directives , 'fields' => $ fields , 'loc' => $ this -> loc ( $ start ) , 'description' => $ description , ] ) ; } 
private function parseUnionTypeDefinition ( ) { $ start = $ this -> lexer -> token ; $ description = $ this -> parseDescription ( ) ; $ this -> expectKeyword ( 'union' ) ; $ name = $ this -> parseName ( ) ; $ directives = $ this -> parseDirectives ( true ) ; $ types = $ this -> parseUnionMemberTypes ( ) ; return new UnionTypeDefinitionNode ( [ 'name' => $ name , 'directives' => $ directives , 'types' => $ types , 'loc' => $ this -> loc ( $ start ) , 'description' => $ description , ] ) ; } 
private function parseUnionMemberTypes ( ) { $ types = [ ] ; if ( $ this -> skip ( Token :: EQUALS ) ) { 
private function parseEnumTypeDefinition ( ) { $ start = $ this -> lexer -> token ; $ description = $ this -> parseDescription ( ) ; $ this -> expectKeyword ( 'enum' ) ; $ name = $ this -> parseName ( ) ; $ directives = $ this -> parseDirectives ( true ) ; $ values = $ this -> parseEnumValuesDefinition ( ) ; return new EnumTypeDefinitionNode ( [ 'name' => $ name , 'directives' => $ directives , 'values' => $ values , 'loc' => $ this -> loc ( $ start ) , 'description' => $ description , ] ) ; } 
private function parseEnumValuesDefinition ( ) { return $ this -> peek ( Token :: BRACE_L ) ? $ this -> many ( Token :: BRACE_L , function ( ) { return $ this -> parseEnumValueDefinition ( ) ; } , Token :: BRACE_R ) : new NodeList ( [ ] ) ; } 
private function parseEnumValueDefinition ( ) { $ start = $ this -> lexer -> token ; $ description = $ this -> parseDescription ( ) ; $ name = $ this -> parseName ( ) ; $ directives = $ this -> parseDirectives ( true ) ; return new EnumValueDefinitionNode ( [ 'name' => $ name , 'directives' => $ directives , 'loc' => $ this -> loc ( $ start ) , 'description' => $ description , ] ) ; } 
private function parseInputObjectTypeDefinition ( ) { $ start = $ this -> lexer -> token ; $ description = $ this -> parseDescription ( ) ; $ this -> expectKeyword ( 'input' ) ; $ name = $ this -> parseName ( ) ; $ directives = $ this -> parseDirectives ( true ) ; $ fields = $ this -> parseInputFieldsDefinition ( ) ; return new InputObjectTypeDefinitionNode ( [ 'name' => $ name , 'directives' => $ directives , 'fields' => $ fields , 'loc' => $ this -> loc ( $ start ) , 'description' => $ description , ] ) ; } 
private function parseInputFieldsDefinition ( ) { return $ this -> peek ( Token :: BRACE_L ) ? $ this -> many ( Token :: BRACE_L , function ( ) { return $ this -> parseInputValueDef ( ) ; } , Token :: BRACE_R ) : new NodeList ( [ ] ) ; } 
private function parseTypeExtension ( ) { $ keywordToken = $ this -> lexer -> lookahead ( ) ; if ( $ keywordToken -> kind === Token :: NAME ) { switch ( $ keywordToken -> value ) { case 'schema' : return $ this -> parseSchemaTypeExtension ( ) ; case 'scalar' : return $ this -> parseScalarTypeExtension ( ) ; case 'type' : return $ this -> parseObjectTypeExtension ( ) ; case 'interface' : return $ this -> parseInterfaceTypeExtension ( ) ; case 'union' : return $ this -> parseUnionTypeExtension ( ) ; case 'enum' : return $ this -> parseEnumTypeExtension ( ) ; case 'input' : return $ this -> parseInputObjectTypeExtension ( ) ; } } throw $ this -> unexpected ( $ keywordToken ) ; } 
private function parseSchemaTypeExtension ( ) { $ start = $ this -> lexer -> token ; $ this -> expectKeyword ( 'extend' ) ; $ this -> expectKeyword ( 'schema' ) ; $ directives = $ this -> parseDirectives ( true ) ; $ operationTypes = $ this -> peek ( Token :: BRACE_L ) ? $ this -> many ( Token :: BRACE_L , [ $ this , 'parseOperationTypeDefinition' ] , Token :: BRACE_R ) : [ ] ; if ( count ( $ directives ) === 0 && count ( $ operationTypes ) === 0 ) { $ this -> unexpected ( ) ; } return new SchemaTypeExtensionNode ( [ 'directives' => $ directives , 'operationTypes' => $ operationTypes , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseScalarTypeExtension ( ) { $ start = $ this -> lexer -> token ; $ this -> expectKeyword ( 'extend' ) ; $ this -> expectKeyword ( 'scalar' ) ; $ name = $ this -> parseName ( ) ; $ directives = $ this -> parseDirectives ( true ) ; if ( count ( $ directives ) === 0 ) { throw $ this -> unexpected ( ) ; } return new ScalarTypeExtensionNode ( [ 'name' => $ name , 'directives' => $ directives , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseObjectTypeExtension ( ) { $ start = $ this -> lexer -> token ; $ this -> expectKeyword ( 'extend' ) ; $ this -> expectKeyword ( 'type' ) ; $ name = $ this -> parseName ( ) ; $ interfaces = $ this -> parseImplementsInterfaces ( ) ; $ directives = $ this -> parseDirectives ( true ) ; $ fields = $ this -> parseFieldsDefinition ( ) ; if ( count ( $ interfaces ) === 0 && count ( $ directives ) === 0 && count ( $ fields ) === 0 ) { throw $ this -> unexpected ( ) ; } return new ObjectTypeExtensionNode ( [ 'name' => $ name , 'interfaces' => $ interfaces , 'directives' => $ directives , 'fields' => $ fields , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseInterfaceTypeExtension ( ) { $ start = $ this -> lexer -> token ; $ this -> expectKeyword ( 'extend' ) ; $ this -> expectKeyword ( 'interface' ) ; $ name = $ this -> parseName ( ) ; $ directives = $ this -> parseDirectives ( true ) ; $ fields = $ this -> parseFieldsDefinition ( ) ; if ( count ( $ directives ) === 0 && count ( $ fields ) === 0 ) { throw $ this -> unexpected ( ) ; } return new InterfaceTypeExtensionNode ( [ 'name' => $ name , 'directives' => $ directives , 'fields' => $ fields , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseUnionTypeExtension ( ) { $ start = $ this -> lexer -> token ; $ this -> expectKeyword ( 'extend' ) ; $ this -> expectKeyword ( 'union' ) ; $ name = $ this -> parseName ( ) ; $ directives = $ this -> parseDirectives ( true ) ; $ types = $ this -> parseUnionMemberTypes ( ) ; if ( count ( $ directives ) === 0 && ! $ types ) { throw $ this -> unexpected ( ) ; } return new UnionTypeExtensionNode ( [ 'name' => $ name , 'directives' => $ directives , 'types' => $ types , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseEnumTypeExtension ( ) { $ start = $ this -> lexer -> token ; $ this -> expectKeyword ( 'extend' ) ; $ this -> expectKeyword ( 'enum' ) ; $ name = $ this -> parseName ( ) ; $ directives = $ this -> parseDirectives ( true ) ; $ values = $ this -> parseEnumValuesDefinition ( ) ; if ( count ( $ directives ) === 0 && count ( $ values ) === 0 ) { throw $ this -> unexpected ( ) ; } return new EnumTypeExtensionNode ( [ 'name' => $ name , 'directives' => $ directives , 'values' => $ values , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseInputObjectTypeExtension ( ) { $ start = $ this -> lexer -> token ; $ this -> expectKeyword ( 'extend' ) ; $ this -> expectKeyword ( 'input' ) ; $ name = $ this -> parseName ( ) ; $ directives = $ this -> parseDirectives ( true ) ; $ fields = $ this -> parseInputFieldsDefinition ( ) ; if ( count ( $ directives ) === 0 && count ( $ fields ) === 0 ) { throw $ this -> unexpected ( ) ; } return new InputObjectTypeExtensionNode ( [ 'name' => $ name , 'directives' => $ directives , 'fields' => $ fields , 'loc' => $ this -> loc ( $ start ) , ] ) ; } 
private function parseDirectiveDefinition ( ) { $ start = $ this -> lexer -> token ; $ description = $ this -> parseDescription ( ) ; $ this -> expectKeyword ( 'directive' ) ; $ this -> expect ( Token :: AT ) ; $ name = $ this -> parseName ( ) ; $ args = $ this -> parseArgumentDefs ( ) ; $ this -> expectKeyword ( 'on' ) ; $ locations = $ this -> parseDirectiveLocations ( ) ; return new DirectiveDefinitionNode ( [ 'name' => $ name , 'arguments' => $ args , 'locations' => $ locations , 'loc' => $ this -> loc ( $ start ) , 'description' => $ description , ] ) ; } 
private function parseDirectiveLocations ( ) { 
private function parseDirectiveLocation ( ) { $ start = $ this -> lexer -> token ; $ name = $ this -> parseName ( ) ; if ( DirectiveLocation :: has ( $ name -> value ) ) { return $ name ; } throw $ this -> unexpected ( $ start ) ; } 
public static function extractTypes ( $ type , ? array $ typeMap = null ) { if ( ! $ typeMap ) { $ typeMap = [ ] ; } if ( ! $ type ) { return $ typeMap ; } if ( $ type instanceof WrappingType ) { return self :: extractTypes ( $ type -> getWrappedType ( true ) , $ typeMap ) ; } if ( ! $ type instanceof Type ) { 
public static function extractTypesFromDirectives ( Directive $ directive , array $ typeMap = [ ] ) { if ( is_array ( $ directive -> args ) ) { foreach ( $ directive -> args as $ arg ) { $ typeMap = self :: extractTypes ( $ arg -> getType ( ) , $ typeMap ) ; } } return $ typeMap ; } 
private static function getFieldDefinition ( Schema $ schema , Type $ parentType , FieldNode $ fieldNode ) { $ name = $ fieldNode -> name -> value ; $ schemaMeta = Introspection :: schemaMetaFieldDef ( ) ; if ( $ name === $ schemaMeta -> name && $ schema -> getQueryType ( ) === $ parentType ) { return $ schemaMeta ; } $ typeMeta = Introspection :: typeMetaFieldDef ( ) ; if ( $ name === $ typeMeta -> name && $ schema -> getQueryType ( ) === $ parentType ) { return $ typeMeta ; } $ typeNameMeta = Introspection :: typeNameMetaFieldDef ( ) ; if ( $ name === $ typeNameMeta -> name && $ parentType instanceof CompositeType ) { return $ typeNameMeta ; } if ( $ parentType instanceof ObjectType || $ parentType instanceof InterfaceType ) { $ fields = $ parentType -> getFields ( ) ; return $ fields [ $ name ] ?? null ; } return null ; } 
private function getOperationTypeNode ( $ type , $ operation ) { $ astNode = $ this -> schema -> getAstNode ( ) ; $ operationTypeNode = null ; if ( $ astNode instanceof SchemaDefinitionNode ) { $ operationTypeNode = null ; foreach ( $ astNode -> operationTypes as $ operationType ) { if ( $ operationType -> operation === $ operation ) { $ operationTypeNode = $ operationType ; break ; } } } return $ operationTypeNode ? $ operationTypeNode -> type : ( $ type ? $ type -> astNode : null ) ; } 
private function getAllDirectiveArgNodes ( Directive $ directive , $ argName ) { $ argNodes = [ ] ; $ directiveNode = $ directive -> astNode ; if ( $ directiveNode && $ directiveNode -> arguments ) { foreach ( $ directiveNode -> arguments as $ node ) { if ( $ node -> name -> value !== $ argName ) { continue ; } $ argNodes [ ] = $ node ; } } return $ argNodes ; } 
private function getDirectiveArgTypeNode ( Directive $ directive , $ argName ) { $ argNode = $ this -> getAllDirectiveArgNodes ( $ directive , $ argName ) [ 0 ] ; return $ argNode ? $ argNode -> type : null ; } 
private function getAllObjectOrInterfaceNodes ( $ type ) { return $ type -> astNode ? ( $ type -> extensionASTNodes ? array_merge ( [ $ type -> astNode ] , $ type -> extensionASTNodes ) : [ $ type -> astNode ] ) : ( $ type -> extensionASTNodes ? : [ ] ) ; } 
private function getAllFieldNodes ( $ type , $ fieldName ) { $ fieldNodes = [ ] ; $ astNodes = $ this -> getAllObjectOrInterfaceNodes ( $ type ) ; foreach ( $ astNodes as $ astNode ) { if ( ! $ astNode || ! $ astNode -> fields ) { continue ; } foreach ( $ astNode -> fields as $ node ) { if ( $ node -> name -> value !== $ fieldName ) { continue ; } $ fieldNodes [ ] = $ node ; } } return $ fieldNodes ; } 
private function getFieldTypeNode ( $ type , $ fieldName ) { $ fieldNode = $ this -> getFieldNode ( $ type , $ fieldName ) ; return $ fieldNode ? $ fieldNode -> type : null ; } 
private function getFieldNode ( $ type , $ fieldName ) { $ nodes = $ this -> getAllFieldNodes ( $ type , $ fieldName ) ; return $ nodes [ 0 ] ?? null ; } 
private function getAllFieldArgNodes ( $ type , $ fieldName , $ argName ) { $ argNodes = [ ] ; $ fieldNode = $ this -> getFieldNode ( $ type , $ fieldName ) ; if ( $ fieldNode && $ fieldNode -> arguments ) { foreach ( $ fieldNode -> arguments as $ node ) { if ( $ node -> name -> value !== $ argName ) { continue ; } $ argNodes [ ] = $ node ; } } return $ argNodes ; } 
private function getFieldArgTypeNode ( $ type , $ fieldName , $ argName ) { $ fieldArgNode = $ this -> getFieldArgNode ( $ type , $ fieldName , $ argName ) ; return $ fieldArgNode ? $ fieldArgNode -> type : null ; } 
private function getFieldArgNode ( $ type , $ fieldName , $ argName ) { $ nodes = $ this -> getAllFieldArgNodes ( $ type , $ fieldName , $ argName ) ; return $ nodes [ 0 ] ?? null ; } 
private function getImplementsInterfaceNode ( ObjectType $ type , $ iface ) { $ nodes = $ this -> getAllImplementsInterfaceNodes ( $ type , $ iface ) ; return $ nodes [ 0 ] ?? null ; } 
private function getAllImplementsInterfaceNodes ( ObjectType $ type , $ iface ) { $ implementsNodes = [ ] ; $ astNodes = $ this -> getAllObjectOrInterfaceNodes ( $ type ) ; foreach ( $ astNodes as $ astNode ) { if ( ! $ astNode || ! $ astNode -> interfaces ) { continue ; } foreach ( $ astNode -> interfaces as $ node ) { if ( $ node -> name -> value !== $ iface -> name ) { continue ; } $ implementsNodes [ ] = $ node ; } } return $ implementsNodes ; } 
private function getUnionMemberTypeNodes ( UnionType $ union , $ typeName ) { if ( $ union -> astNode && $ union -> astNode -> types ) { return array_filter ( $ union -> astNode -> types , static function ( NamedTypeNode $ value ) use ( $ typeName ) { return $ value -> name -> value === $ typeName ; } ) ; } return $ union -> astNode ? $ union -> astNode -> types : null ; } 
private function getEnumValueNodes ( EnumType $ enum , $ valueName ) { if ( $ enum -> astNode && $ enum -> astNode -> values ) { return array_filter ( iterator_to_array ( $ enum -> astNode -> values ) , static function ( EnumValueDefinitionNode $ value ) use ( $ valueName ) { return $ value -> name -> value === $ valueName ; } ) ; } return $ enum -> astNode ? $ enum -> astNode -> values : null ; } 
private function coerceInt ( $ value ) { if ( $ value === '' ) { throw new Error ( 'Int cannot represent non 32-bit signed integer value: (empty string)' ) ; } $ num = floatval ( $ value ) ; if ( ( ! is_numeric ( $ value ) && ! is_bool ( $ value ) ) || $ num > self :: MAX_INT || $ num < self :: MIN_INT ) { throw new Error ( 'Int cannot represent non 32-bit signed integer value: ' . Utils :: printSafe ( $ value ) ) ; } $ int = intval ( $ num ) ; 
public function parseLiteral ( $ valueNode , ? array $ variables = null ) { if ( $ valueNode instanceof IntValueNode ) { $ val = ( int ) $ valueNode -> value ; if ( $ valueNode -> value === ( string ) $ val && self :: MIN_INT <= $ val && $ val <= self :: MAX_INT ) { return $ val ; } } 
public static function create ( $ start , $ end ) { $ tmp = new static ( ) ; $ tmp -> start = $ start ; $ tmp -> end = $ end ; return $ tmp ; } 
public static function parseValue ( $ value ) { if ( ! filter_var ( $ value , FILTER_VALIDATE_EMAIL ) ) { throw new \ UnexpectedValueException ( "Cannot represent value as email: " . Utils :: printSafe ( $ value ) ) ; } return $ value ; } 
public static function parseLiteral ( $ valueNode ) { 
public function getLocation ( $ position ) { $ line = 1 ; $ column = $ position + 1 ; $ utfChars = json_decode ( '"\u2028\u2029"' ) ; $ lineRegexp = '/\r\n|[\n\r' . $ utfChars . ']/su' ; $ matches = [ ] ; preg_match_all ( $ lineRegexp , mb_substr ( $ this -> body , 0 , $ position , 'UTF-8' ) , $ matches , PREG_OFFSET_CAPTURE ) ; foreach ( $ matches [ 0 ] as $ index => $ match ) { $ line += 1 ; $ column = $ position + 1 - ( $ match [ 1 ] + mb_strlen ( $ match [ 0 ] , 'UTF-8' ) ) ; } return new SourceLocation ( $ line , $ column ) ; } 
protected function getStub ( $ name ) { if ( stripos ( $ name , '.php' ) === FALSE ) $ name = $ name . '.php' ; return $ this -> files -> get ( $ this -> getStubPath ( ) . '/' . $ name ) ; } 
protected function registerInstallCommand ( ) { $ this -> app -> singleton ( 'command.baum.install' , function ( $ app ) { $ migrator = new MigrationGenerator ( $ app [ 'files' ] ) ; $ modeler = new ModelGenerator ( $ app [ 'files' ] ) ; return new InstallCommand ( $ migrator , $ modeler ) ; } ) ; } 
public function reOrderBy ( $ column , $ direction = 'asc' ) { $ this -> orders = null ; if ( ! is_null ( $ column ) ) return $ this -> orderBy ( $ column , $ direction ) ; return $ this ; } 
public function aggregate ( $ function , $ columns = array ( '*' ) ) { 
public function reload ( ) { if ( $ this -> exists || ( $ this -> areSoftDeletesEnabled ( ) && $ this -> trashed ( ) ) ) { $ fresh = $ this -> getFreshInstance ( ) ; if ( is_null ( $ fresh ) ) throw with ( new ModelNotFoundException ) -> setModel ( get_called_class ( ) ) ; $ this -> setRawAttributes ( $ fresh -> getAttributes ( ) , true ) ; $ this -> setRelations ( $ fresh -> getRelations ( ) ) ; $ this -> exists = $ fresh -> exists ; } else { 
protected function getFreshInstance ( ) { if ( $ this -> areSoftDeletesEnabled ( ) ) return static :: withTrashed ( ) -> find ( $ this -> getKey ( ) ) ; return static :: find ( $ this -> getKey ( ) ) ; } 
public function roots ( ) { return $ this -> node -> newQuery ( ) -> whereNull ( $ this -> node -> getQualifiedParentColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) -> get ( ) ; } 
public function rebuildBounds ( $ node , $ depth = 0 ) { $ k = $ this -> scopedKey ( $ node ) ; $ node -> setAttribute ( $ node -> getLeftColumnName ( ) , $ this -> getNextBound ( $ k ) ) ; $ node -> setAttribute ( $ node -> getDepthColumnName ( ) , $ depth ) ; foreach ( $ this -> children ( $ node ) as $ child ) $ this -> rebuildBounds ( $ child , $ depth + 1 ) ; $ node -> setAttribute ( $ node -> getRightColumnName ( ) , $ this -> getNextBound ( $ k ) ) ; $ node -> save ( ) ; } 
public function children ( $ node ) { $ query = $ this -> node -> newQuery ( ) ; $ query -> where ( $ this -> node -> getQualifiedParentColumnName ( ) , '=' , $ node -> getKey ( ) ) ; 
protected function scopedAttributes ( $ node ) { $ keys = $ this -> node -> getScopedColumns ( ) ; if ( count ( $ keys ) == 0 ) return array ( ) ; $ values = array_map ( function ( $ column ) use ( $ node ) { return $ node -> getAttribute ( $ column ) ; } , $ keys ) ; return array_combine ( $ keys , $ values ) ; } 
protected function scopedKey ( $ node ) { $ attributes = $ this -> scopedAttributes ( $ node ) ; $ output = array ( ) ; foreach ( $ attributes as $ fld => $ value ) $ output [ ] = $ this -> qualify ( $ fld ) . '=' . ( is_null ( $ value ) ? 'NULL' : $ value ) ; 
protected function getNextBound ( $ key ) { if ( false === array_key_exists ( $ key , $ this -> bounds ) ) $ this -> bounds [ $ key ] = 0 ; $ this -> bounds [ $ key ] = $ this -> bounds [ $ key ] + 1 ; return $ this -> bounds [ $ key ] ; } 
public static function to ( $ node , $ target , $ position ) { $ instance = new static ( $ node , $ target , $ position ) ; return $ instance -> perform ( ) ; } 
public function updateStructure ( ) { list ( $ a , $ b , $ c , $ d ) = $ this -> boundaries ( ) ; WHEN $wrappedLeft BETWEEN $a AND $b THEN $wrappedLeft + $d - $b WHEN $wrappedLeft BETWEEN $c AND $d THEN $wrappedLeft + $a - $c ELSE $wrappedLeft END" ; $ rgtSql = "CASE WHEN $wrappedRight BETWEEN $a AND $b THEN $wrappedRight + $d - $b WHEN $wrappedRight BETWEEN $c AND $d THEN $wrappedRight + $a - $c ELSE $wrappedRight END" ; $ parentSql = "CASE WHEN $wrappedId = $currentId THEN $parentId ELSE $wrappedParent END" ; $ updateConditions = array ( $ leftColumn => $ connection -> raw ( $ lftSql ) , $ rightColumn => $ connection -> raw ( $ rgtSql ) , $ parentColumn => $ connection -> raw ( $ parentSql ) ) ; if ( $ this -> node -> timestamps ) $ updateConditions [ $ this -> node -> getUpdatedAtColumn ( ) ] = $ this -> node -> freshTimestamp ( ) ; return $ this -> node -> newNestedSetQuery ( ) -> where ( function ( $ query ) use ( $ leftColumn , $ rightColumn , $ a , $ d ) { $ query -> whereBetween ( $ leftColumn , array ( $ a , $ d ) ) -> orWhereBetween ( $ rightColumn , array ( $ a , $ d ) ) ; } ) -> update ( $ updateConditions ) ; } 
protected function resolveNode ( $ node ) { if ( $ node instanceof \ Baum \ Node ) return $ node -> reload ( ) ; return $ this -> node -> newNestedSetQuery ( ) -> find ( $ node ) ; } 
protected function guardAgainstImpossibleMove ( ) { if ( ! $ this -> node -> exists ) throw new MoveNotPossibleException ( 'A new node cannot be moved.' ) ; if ( array_search ( $ this -> position , array ( 'child' , 'left' , 'right' , 'root' ) ) === FALSE ) throw new MoveNotPossibleException ( "Position should be one of ['child', 'left', 'right'] but is {$this->position}." ) ; if ( ! $ this -> promotingToRoot ( ) ) { if ( is_null ( $ this -> target ) ) { if ( $ this -> position === 'left' || $ this -> position === 'right' ) throw new MoveNotPossibleException ( "Could not resolve target node. This node cannot move any further to the {$this->position}." ) ; else throw new MoveNotPossibleException ( 'Could not resolve target node.' ) ; } if ( $ this -> node -> equals ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to itself.' ) ; if ( $ this -> target -> insideSubtree ( $ this -> node ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a descendant of itself (inside moved tree).' ) ; if ( ! $ this -> node -> inSameScope ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a different scope.' ) ; } } 
protected function bound2 ( ) { if ( ! is_null ( $ this -> _bound2 ) ) return $ this -> _bound2 ; $ this -> _bound2 = ( ( $ this -> bound1 ( ) > $ this -> node -> getRight ( ) ) ? $ this -> node -> getRight ( ) + 1 : $ this -> node -> getLeft ( ) - 1 ) ; return $ this -> _bound2 ; } 
protected function parentId ( ) { switch ( $ this -> position ) { case 'root' : return NULL ; case 'child' : return $ this -> target -> getKey ( ) ; default : return $ this -> target -> getParentId ( ) ; } } 
protected function hasChange ( ) { return ! ( $ this -> bound1 ( ) == $ this -> node -> getRight ( ) || $ this -> bound1 ( ) == $ this -> node -> getLeft ( ) ) ; } 
protected function fireMoveEvent ( $ event , $ halt = true ) { if ( ! isset ( static :: $ dispatcher ) ) return true ; 
protected function quoteIdentifier ( $ value ) { if ( is_null ( $ value ) ) return 'NULL' ; $ connection = $ this -> node -> getConnection ( ) ; $ pdo = $ connection -> getPdo ( ) ; return $ pdo -> quote ( $ value ) ; } 
protected function applyLockBetween ( $ lft , $ rgt ) { $ this -> node -> newQuery ( ) -> where ( $ this -> node -> getLeftColumnName ( ) , '>=' , $ lft ) -> where ( $ this -> node -> getRightColumnName ( ) , '<=' , $ rgt ) -> select ( $ this -> node -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; } 
public function fire ( ) { $ name = $ this -> input -> getArgument ( 'name' ) ; $ this -> writeMigration ( $ name ) ; $ this -> writeModel ( $ name ) ; } 
protected function writeMigration ( $ name ) { $ output = pathinfo ( $ this -> migrator -> create ( $ name , $ this -> getMigrationsPath ( ) ) , PATHINFO_FILENAME ) ; $ this -> line ( " <fg=green;options=bold>create</fg=green;options=bold> $output" ) ; } 
protected function writeModel ( $ name ) { $ output = pathinfo ( $ this -> modeler -> create ( $ name , $ this -> getModelsPath ( ) ) , PATHINFO_FILENAME ) ; $ this -> line ( " <fg=green;options=bold>create</fg=green;options=bold> $output" ) ; } 
protected function validateDuplicates ( ) { return ( ! $ this -> duplicatesExistForColumn ( $ this -> node -> getQualifiedLeftColumnName ( ) ) && ! $ this -> duplicatesExistForColumn ( $ this -> node -> getQualifiedRightColumnName ( ) ) ) ; } 
protected function isEachRootValid ( $ roots ) { $ left = $ right = 0 ; foreach ( $ roots as $ root ) { $ rootLeft = $ root -> getLeft ( ) ; $ rootRight = $ root -> getRight ( ) ; if ( ! ( $ rootLeft > $ left && $ rootRight > $ right ) ) return false ; $ left = $ rootLeft ; $ right = $ rootRight ; } return true ; } 
protected function validateRootsByScope ( $ roots ) { foreach ( $ this -> groupRootsByScope ( $ roots ) as $ scope => $ groupedRoots ) { $ valid = $ this -> isEachRootValid ( $ groupedRoots ) ; if ( ! $ valid ) return false ; } return true ; } 
protected function groupRootsByScope ( $ roots ) { $ rootsGroupedByScope = array ( ) ; foreach ( $ roots as $ root ) { $ key = $ this -> keyForScope ( $ root ) ; if ( ! isset ( $ rootsGroupedByScope [ $ key ] ) ) $ rootsGroupedByScope [ $ key ] = array ( ) ; $ rootsGroupedByScope [ $ key ] [ ] = $ root ; } return $ rootsGroupedByScope ; } 
protected function keyForScope ( $ node ) { return implode ( '-' , array_map ( function ( $ column ) use ( $ node ) { $ value = $ node -> getAttribute ( $ column ) ; if ( is_null ( $ value ) ) return 'NULL' ; return $ value ; } , $ node -> getScopedColumns ( ) ) ) ; } 
public function map ( $ nodeList ) { $ self = $ this ; return $ this -> wrapInTransaction ( function ( ) use ( $ self , $ nodeList ) { forward_static_call ( array ( get_class ( $ self -> node ) , 'unguard' ) ) ; $ result = $ self -> mapTree ( $ nodeList ) ; forward_static_call ( array ( get_class ( $ self -> node ) , 'reguard' ) ) ; return $ result ; } ) ; } 
public function mapTree ( $ nodeList ) { $ tree = $ nodeList instanceof ArrayableInterface ? $ nodeList -> toArray ( ) : $ nodeList ; $ affectedKeys = array ( ) ; $ result = $ this -> mapTreeRecursive ( $ tree , $ this -> node -> getKey ( ) , $ affectedKeys ) ; if ( $ result && count ( $ affectedKeys ) > 0 ) $ this -> deleteUnaffected ( $ affectedKeys ) ; return $ result ; } 
protected function mapTreeRecursive ( array $ tree , $ parentKey = null , & $ affectedKeys = array ( ) ) { 
protected static function boot ( ) { parent :: boot ( ) ; static :: creating ( function ( $ node ) { $ node -> setDefaultLeftAndRight ( ) ; } ) ; static :: saving ( function ( $ node ) { $ node -> storeNewParent ( ) ; } ) ; static :: saved ( function ( $ node ) { $ node -> moveToNewParent ( ) ; $ node -> setDepth ( ) ; } ) ; static :: deleting ( function ( $ node ) { $ node -> destroyDescendants ( ) ; } ) ; if ( static :: softDeletesEnabled ( ) ) { static :: restoring ( function ( $ node ) { $ node -> shiftSiblingsForRestore ( ) ; } ) ; static :: restored ( function ( $ node ) { $ node -> restoreDescendants ( ) ; } ) ; } } 
public function getQualifiedScopedColumns ( ) { if ( ! $ this -> isScoped ( ) ) return $ this -> getScopedColumns ( ) ; $ prefix = $ this -> getTable ( ) . '.' ; return array_map ( function ( $ c ) use ( $ prefix ) { return $ prefix . $ c ; } , $ this -> getScopedColumns ( ) ) ; } 
public function children ( ) { return $ this -> hasMany ( get_class ( $ this ) , $ this -> getParentColumnName ( ) ) -> orderBy ( $ this -> getOrderColumnName ( ) ) ; } 
public function newNestedSetQuery ( $ excludeDeleted = true ) { $ builder = $ this -> newQuery ( $ excludeDeleted ) -> orderBy ( $ this -> getQualifiedOrderColumnName ( ) ) ; if ( $ this -> isScoped ( ) ) { foreach ( $ this -> scoped as $ scopeFld ) $ builder -> where ( $ scopeFld , '=' , $ this -> $ scopeFld ) ; } return $ builder ; } 
public static function roots ( ) { $ instance = new static ; return $ instance -> newQuery ( ) -> whereNull ( $ instance -> getParentColumnName ( ) ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; } 
public static function allLeaves ( ) { $ instance = new static ; $ grammar = $ instance -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ instance -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ instance -> getQualifiedLeftColumnName ( ) ) ; return $ instance -> newQuery ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; } 
public static function allTrunks ( ) { $ instance = new static ; $ grammar = $ instance -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ instance -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ instance -> getQualifiedLeftColumnName ( ) ) ; return $ instance -> newQuery ( ) -> whereNotNull ( $ instance -> getParentColumnName ( ) ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' != 1' ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; } 
public function scopeLimitDepth ( $ query , $ limit ) { $ depth = $ this -> exists ? $ this -> getDepth ( ) : $ this -> getLevel ( ) ; $ max = $ depth + $ limit ; $ scopes = array ( $ depth , $ max ) ; return $ query -> whereBetween ( $ this -> getDepthColumnName ( ) , array ( min ( $ scopes ) , max ( $ scopes ) ) ) ; } 
public function getRoot ( ) { if ( $ this -> exists ) { return $ this -> ancestorsAndSelf ( ) -> whereNull ( $ this -> getParentColumnName ( ) ) -> first ( ) ; } else { $ parentId = $ this -> getParentId ( ) ; if ( ! is_null ( $ parentId ) && $ currentParent = static :: find ( $ parentId ) ) { return $ currentParent -> getRoot ( ) ; } else { return $ this ; } } } 
public function ancestorsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '<=' , $ this -> getLeft ( ) ) -> where ( $ this -> getRightColumnName ( ) , '>=' , $ this -> getRight ( ) ) ; } 
public function leaves ( ) { $ grammar = $ this -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ this -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ this -> getQualifiedLeftColumnName ( ) ) ; return $ this -> descendants ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) ; } 
public function trunks ( ) { $ grammar = $ this -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ this -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ this -> getQualifiedLeftColumnName ( ) ) ; return $ this -> descendants ( ) -> whereNotNull ( $ this -> getQualifiedParentColumnName ( ) ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' != 1' ) ; } 
public function descendantsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '>=' , $ this -> getLeft ( ) ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getRight ( ) ) ; } 
public function getDescendants ( $ columns = array ( '*' ) ) { if ( is_array ( $ columns ) ) return $ this -> descendants ( ) -> get ( $ columns ) ; $ arguments = func_get_args ( ) ; $ limit = intval ( array_shift ( $ arguments ) ) ; $ columns = array_shift ( $ arguments ) ? : array ( '*' ) ; return $ this -> descendants ( ) -> limitDepth ( $ limit ) -> get ( $ columns ) ; } 
public function isDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) > $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; } 
public function isSelfOrDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) >= $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; } 
public function isAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) < $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; } 
public function isSelfOrAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) <= $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; } 
public function getLeftSibling ( ) { return $ this -> siblings ( ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getLeft ( ) ) -> orderBy ( $ this -> getOrderColumnName ( ) , 'desc' ) -> get ( ) -> last ( ) ; } 
public function makeFirstChildOf ( $ node ) { if ( $ node -> children ( ) -> count ( ) == 0 ) return $ this -> makeChildOf ( $ node ) ; return $ this -> moveToLeftOf ( $ node -> children ( ) -> first ( ) ) ; } 
public function inSameScope ( $ other ) { foreach ( $ this -> getScopedColumns ( ) as $ fld ) { if ( $ this -> $ fld != $ other -> $ fld ) return false ; } return true ; } 
public function insideSubtree ( $ node ) { return ( $ this -> getLeft ( ) >= $ node -> getLeft ( ) && $ this -> getLeft ( ) <= $ node -> getRight ( ) && $ this -> getRight ( ) >= $ node -> getLeft ( ) && $ this -> getRight ( ) <= $ node -> getRight ( ) ) ; } 
public function setDefaultLeftAndRight ( ) { $ withHighestRight = $ this -> newNestedSetQuery ( ) -> reOrderBy ( $ this -> getRightColumnName ( ) , 'desc' ) -> take ( 1 ) -> sharedLock ( ) -> first ( ) ; $ maxRgt = 0 ; if ( ! is_null ( $ withHighestRight ) ) $ maxRgt = $ withHighestRight -> getRight ( ) ; $ this -> setAttribute ( $ this -> getLeftColumnName ( ) , $ maxRgt + 1 ) ; $ this -> setAttribute ( $ this -> getRightColumnName ( ) , $ maxRgt + 2 ) ; } 
public function storeNewParent ( ) { if ( $ this -> isDirty ( $ this -> getParentColumnName ( ) ) && ( $ this -> exists || ! $ this -> isRoot ( ) ) ) static :: $ moveToNewParentId = $ this -> getParentId ( ) ; else static :: $ moveToNewParentId = FALSE ; } 
public function moveToNewParent ( ) { $ pid = static :: $ moveToNewParentId ; if ( is_null ( $ pid ) ) $ this -> makeRoot ( ) ; else if ( $ pid !== FALSE ) $ this -> makeChildOf ( $ pid ) ; } 
public function setDepth ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ level = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ level ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ level ) ; } ) ; return $ this ; } 
public function setDepthWithSubtree ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ self -> descendantsAndSelf ( ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ oldDepth = ! is_null ( $ self -> getDepth ( ) ) ? $ self -> getDepth ( ) : 0 ; $ newDepth = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ newDepth ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ newDepth ) ; $ diff = $ newDepth - $ oldDepth ; if ( ! $ self -> isLeaf ( ) && $ diff != 0 ) $ self -> descendants ( ) -> increment ( $ self -> getDepthColumnName ( ) , $ diff ) ; } ) ; return $ this ; } 
public function destroyDescendants ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; 
public function shiftSiblingsForRestore ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> increment ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>=' , $ lft ) -> increment ( $ rgtCol , $ diff ) ; } ) ; } 
public static function getNestedList ( $ column , $ key = null , $ seperator = ' ' ) { $ instance = new static ; $ key = $ key ? : $ instance -> getKeyName ( ) ; $ depthColumn = $ instance -> getDepthColumnName ( ) ; $ nodes = $ instance -> newNestedSetQuery ( ) -> get ( ) -> toArray ( ) ; return array_combine ( array_map ( function ( $ node ) use ( $ key ) { return $ node [ $ key ] ; } , $ nodes ) , array_map ( function ( $ node ) use ( $ seperator , $ depthColumn , $ column ) { return str_repeat ( $ seperator , $ node [ $ depthColumn ] ) . $ node [ $ column ] ; } , $ nodes ) ) ; } 
protected function computeLevel ( ) { list ( $ node , $ nesting ) = $ this -> determineDepth ( $ this ) ; if ( $ node -> equals ( $ this ) ) return $ this -> ancestors ( ) -> count ( ) ; return $ node -> getLevel ( ) + $ nesting ; } 
protected function initialize ( ) { $ tagName = $ this -> element -> getTagName ( ) ; if ( 'input' !== $ tagName && 'button' !== $ tagName ) { throw new \ LogicException ( \ sprintf ( 'An InputFormField can only be created from an input or button tag (%s given).' , $ tagName ) ) ; } $ type = \ strtolower ( $ this -> element -> getAttribute ( 'type' ) ) ; if ( 'checkbox' === $ type ) { throw new \ LogicException ( 'Checkboxes should be instances of ChoiceFormField.' ) ; } if ( 'file' === $ type ) { throw new \ LogicException ( 'File inputs should be instances of FileFormField.' ) ; } } 
public function tick ( ) { if ( 'checkbox' !== $ type = $ this -> element -> getAttribute ( 'type' ) ) { throw new \ LogicException ( \ sprintf ( 'You cannot tick "%s" as it is not a checkbox (%s).' , $ this -> element -> getAttribute ( 'name' ) , $ type ) ) ; } $ this -> setValue ( true ) ; } 
public function untick ( ) { if ( 'checkbox' !== $ type = $ this -> element -> getAttribute ( 'type' ) ) { throw new \ LogicException ( \ sprintf ( 'You cannot tick "%s" as it is not a checkbox (%s).' , $ this -> element -> getAttribute ( 'name' ) , $ type ) ) ; } $ this -> setValue ( false ) ; } 
public function setValue ( $ value ) { if ( \ is_bool ( $ value ) ) { if ( 'checkbox' !== $ this -> type ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Invalid argument of type "%s"' , \ gettype ( $ value ) ) ) ; } if ( $ value ) { if ( ! $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } } elseif ( $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } return ; } foreach ( ( array ) $ value as $ v ) { $ this -> selector -> selectByValue ( $ v ) ; } } 
public function availableOptionValues ( ) { $ options = [ ] ; foreach ( $ this -> selector -> getOptions ( ) as $ option ) { $ options [ ] = $ option -> getAttribute ( 'value' ) ; } return $ options ; } 
protected function initialize ( ) { $ tagName = $ this -> element -> getTagName ( ) ; if ( 'input' !== $ tagName && 'select' !== $ tagName ) { throw new \ LogicException ( \ sprintf ( 'A ChoiceFormField can only be created from an input or select tag (%s given).' , $ tagName ) ) ; } $ type = \ strtolower ( $ this -> element -> getAttribute ( 'type' ) ) ; if ( 'input' === $ tagName && 'checkbox' !== $ type && 'radio' !== $ type ) { throw new \ LogicException ( \ sprintf ( 'A ChoiceFormField can only be created from an input tag with a type of checkbox or radio (given type is %s).' , $ type ) ) ; } $ this -> type = 'select' === $ tagName ? 'select' : $ type ; $ this -> selector = 'select' === $ this -> type ? new WebDriverSelect ( $ this -> element ) : new WebDriverCheckbox ( $ this -> element ) ; } 
public function waitFor ( string $ cssSelector , int $ timeoutInSecond = 30 , int $ intervalInMillisecond = 250 ) { $ this -> wait ( $ timeoutInSecond , $ intervalInMillisecond ) -> until ( WebDriverExpectedCondition :: visibilityOfElementLocated ( WebDriverBy :: cssSelector ( $ cssSelector ) ) ) ; return $ this -> crawler = $ this -> createCrawler ( ) ; } 
public function boot ( ) { $ this -> bootstrapConfigs ( ) ; $ this -> bootstrapViews ( ) ; $ this -> bootstrapValidator ( ) ; $ this -> publishAssets ( ) ; if ( $ this -> app [ 'config' ] -> get ( 'jsvalidation.disable_remote_validation' ) === false ) { $ this -> app [ Kernel :: class ] -> pushMiddleware ( RemoteValidationMiddleware :: class ) ; } } 
public function register ( ) { $ this -> app -> singleton ( 'jsvalidator' , function ( $ app ) { $ config = $ app [ 'config' ] -> get ( 'jsvalidation' ) ; return new JsValidatorFactory ( $ app , $ config ) ; } ) ; } 
protected function bootstrapViews ( ) { $ viewPath = realpath ( __DIR__ . '/../resources/views' ) ; $ this -> loadViewsFrom ( $ viewPath , 'jsvalidation' ) ; $ this -> publishes ( [ $ viewPath => $ this -> app [ 'path.base' ] . '/resources/views/vendor/jsvalidation' , ] , 'views' ) ; } 
protected function bootstrapConfigs ( ) { $ configFile = realpath ( __DIR__ . '/../config/jsvalidation.php' ) ; $ this -> mergeConfigFrom ( $ configFile , 'jsvalidation' ) ; $ this -> publishes ( [ $ configFile => $ this -> app [ 'path.config' ] . '/jsvalidation.php' ] , 'config' ) ; } 
public function getRule ( $ attribute , $ rule , $ parameters , $ rawRule ) { $ isConditional = $ this -> isConditionalRule ( $ attribute , $ rawRule ) ; $ isRemote = $ this -> isRemoteRule ( $ rule ) ; if ( $ isConditional || $ isRemote ) { list ( $ attribute , $ parameters ) = $ this -> remoteRule ( $ attribute , $ isConditional ) ; $ jsRule = self :: REMOTE_RULE ; } else { list ( $ jsRule , $ attribute , $ parameters ) = $ this -> clientRule ( $ attribute , $ rule , $ parameters ) ; } $ attribute = $ this -> getAttributeName ( $ attribute ) ; return [ $ attribute , $ jsRule , $ parameters ] ; } 
public function addConditionalRules ( $ attribute , $ rules = [ ] ) { foreach ( ( array ) $ attribute as $ key ) { $ current = isset ( $ this -> conditional [ $ key ] ) ? $ this -> conditional [ $ key ] : [ ] ; $ merge = head ( $ this -> validator -> explodeRules ( ( array ) $ rules ) ) ; $ this -> conditional [ $ key ] = array_merge ( $ current , $ merge ) ; } } 
protected function isConditionalRule ( $ attribute , $ rule ) { return isset ( $ this -> conditional [ $ attribute ] ) && in_array ( $ rule , $ this -> conditional [ $ attribute ] ) ; } 
protected function clientRule ( $ attribute , $ rule , $ parameters ) { $ jsRule = self :: JAVASCRIPT_RULE ; $ method = "rule{$rule}" ; if ( method_exists ( $ this , $ method ) ) { list ( $ attribute , $ parameters ) = $ this -> $ method ( $ attribute , $ parameters ) ; } return [ $ jsRule , $ attribute , $ parameters ] ; } 
protected function remoteRule ( $ attribute , $ forceRemote ) { $ attrHtmlName = $ this -> getAttributeName ( $ attribute ) ; $ params = [ $ attrHtmlName , $ this -> remoteToken , $ forceRemote , ] ; return [ $ attribute , $ params ] ; } 
protected function getAttributeName ( $ attribute ) { $ attributeArray = explode ( '.' , $ attribute ) ; if ( count ( $ attributeArray ) > 1 ) { return $ attributeArray [ 0 ] . '[' . implode ( '][' , array_slice ( $ attributeArray , 1 ) ) . ']' ; } return $ attribute ; } 
protected function setDefaults ( $ options ) { $ this -> selector = empty ( $ options [ 'selector' ] ) ? 'form' : $ options [ 'selector' ] ; $ this -> view = empty ( $ options [ 'view' ] ) ? 'jsvalidation::bootstrap' : $ options [ 'view' ] ; $ this -> remote = isset ( $ options [ 'remote' ] ) ? $ options [ 'remote' ] : true ; } 
public function render ( $ view = null , $ selector = null ) { $ this -> view ( $ view ) ; $ this -> selector ( $ selector ) ; return View :: make ( $ this -> view , [ 'validator' => $ this -> getViewData ( ) ] ) -> render ( ) ; } 
protected function getViewData ( ) { $ this -> validator -> setRemote ( $ this -> remote ) ; $ data = $ this -> validator -> validationData ( ) ; $ data [ 'selector' ] = $ this -> selector ; if ( ! is_null ( $ this -> ignore ) ) { $ data [ 'ignore' ] = $ this -> ignore ; } return $ data ; } 
public function selector ( $ selector ) { $ this -> selector = is_null ( $ selector ) ? $ this -> selector : $ selector ; return $ this ; } 
public function view ( $ view ) { $ this -> view = is_null ( $ view ) ? $ this -> view : $ view ; return $ this ; } 
public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; } 
public function getMessage ( $ attribute , $ rule ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'getMessage' , [ $ attribute , $ rule ] ) ; } 
public function sometimes ( $ attribute , $ rules , callable $ callback ) { $ this -> validator -> sometimes ( $ attribute , $ rules , $ callback ) ; } 
protected function ruleConfirmed ( $ attribute , array $ parameters ) { $ parameters [ 0 ] = $ this -> getAttributeName ( $ attribute ) ; $ attribute = "{$attribute}_confirmation" ; return [ $ attribute , $ parameters ] ; } 
protected function ruleAfter ( $ attribute , array $ parameters ) { if ( ! ( $ date = strtotime ( $ parameters [ 0 ] ) ) ) { $ date = $ this -> getAttributeName ( $ parameters [ 0 ] ) ; } return [ $ attribute , [ $ date ] ] ; } 
public function getMessage ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> fakeValidationData ( $ attribute , $ rule , $ parameters ) ; $ message = $ this -> validator -> getMessage ( $ attribute , $ rule ) ; $ message = $ this -> validator -> makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) ; $ this -> validator -> setData ( $ data ) ; return $ message ; } 
protected function fakeValidationData ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> validator -> getData ( ) ; $ this -> fakeFileData ( $ data , $ attribute ) ; $ this -> fakeRequiredIfData ( $ data , $ rule , $ parameters ) ; return $ data ; } 
private function fakeRequiredIfData ( $ data , $ rule , $ parameters ) { if ( $ rule !== 'RequiredIf' ) { return ; } $ newData = $ data ; $ newData [ $ parameters [ 0 ] ] = $ parameters [ 1 ] ; $ this -> validator -> setData ( $ newData ) ; } 
private function fakeFileData ( $ data , $ attribute ) { if ( ! $ this -> validator -> hasRule ( $ attribute , [ 'Mimes' , 'Image' ] ) ) { return ; } $ newFiles = $ data ; $ newFiles [ $ attribute ] = $ this -> createUploadedFile ( ) ; $ this -> validator -> setData ( $ newFiles ) ; } 
public function validate ( $ field , $ parameters = [ ] ) { $ attribute = $ this -> parseAttributeName ( $ field ) ; $ validationParams = $ this -> parseParameters ( $ parameters ) ; $ validationResult = $ this -> validateJsRemoteRequest ( $ attribute , $ validationParams ) ; $ this -> throwValidationException ( $ validationResult , $ this -> validator ) ; } 
protected function throwValidationException ( $ result , $ validator ) { $ response = new JsonResponse ( $ result , 200 ) ; if ( $ result !== true && class_exists ( ValidationException :: class ) ) { throw new ValidationException ( $ validator , $ response ) ; } throw new HttpResponseException ( $ response ) ; } 
protected function parseAttributeName ( $ data ) { parse_str ( $ data , $ attrParts ) ; $ attrParts = is_null ( $ attrParts ) ? [ ] : $ attrParts ; $ newAttr = array_keys ( array_dot ( $ attrParts ) ) ; return array_pop ( $ newAttr ) ; } 
protected function parseParameters ( $ parameters ) { $ newParams = [ 'validate_all' => false ] ; if ( isset ( $ parameters [ 0 ] ) ) { $ newParams [ 'validate_all' ] = ( $ parameters [ 0 ] === 'true' ) ? true : false ; } return $ newParams ; } 
protected function validateJsRemoteRequest ( $ attribute , $ parameters ) { $ this -> setRemoteValidation ( $ attribute , $ parameters [ 'validate_all' ] ) ; $ validator = $ this -> validator ; if ( $ validator -> passes ( ) ) { return true ; } return $ validator -> messages ( ) -> get ( $ attribute ) ; } 
protected function setRemoteValidation ( $ attribute , $ validateAll = false ) { $ validator = $ this -> validator ; $ rules = $ validator -> getRules ( ) ; $ rules = isset ( $ rules [ $ attribute ] ) ? $ rules [ $ attribute ] : [ ] ; if ( in_array ( 'no_js_validation' , $ rules ) ) { $ validator -> setRules ( [ $ attribute => [ ] ] ) ; return ; } if ( ! $ validateAll ) { $ rules = $ this -> purgeNonRemoteRules ( $ rules , $ validator ) ; } $ validator -> setRules ( [ $ attribute => $ rules ] ) ; } 
protected function purgeNonRemoteRules ( $ rules , $ validator ) { $ protectedValidator = $ this -> createProtectedCaller ( $ validator ) ; foreach ( $ rules as $ i => $ rule ) { $ parsedRule = ValidationRuleParser :: parse ( [ $ rule ] ) ; if ( ! $ this -> isRemoteRule ( $ parsedRule [ 0 ] ) ) { unset ( $ rules [ $ i ] ) ; } } return $ rules ; } 
protected function createProtectedCaller ( $ instance ) { $ closure = function ( $ method , $ args ) { $ callable = [ $ this , $ method ] ; return call_user_func_array ( $ callable , $ args ) ; } ; return $ closure -> bindTo ( $ instance , $ instance ) ; } 
protected function getProtected ( $ instance , $ property ) { $ closure = function ( $ property ) { return $ this -> $ property ; } ; $ callback = $ closure -> bindTo ( $ instance , $ instance ) ; return $ callback ( $ property ) ; } 
protected function callProtected ( $ instance , $ method , $ args = [ ] ) { if ( ! ( $ instance instanceof Closure ) ) { $ instance = $ this -> createProtectedCaller ( $ instance ) ; } return call_user_func ( $ instance , $ method , $ args ) ; } 
public function setDelegatedValidator ( DelegatedValidator $ validator ) { $ this -> validator = $ validator ; $ this -> rules -> setDelegatedValidator ( $ validator ) ; $ this -> messages -> setDelegatedValidator ( $ validator ) ; } 
protected function generateJavascriptValidations ( ) { $ jsValidations = [ ] ; foreach ( $ this -> validator -> getRules ( ) as $ attribute => $ rules ) { if ( ! $ this -> jsValidationEnabled ( $ attribute ) ) { continue ; } $ newRules = $ this -> jsConvertRules ( $ attribute , $ rules , $ this -> remote ) ; $ jsValidations = array_merge ( $ jsValidations , $ newRules ) ; } return $ jsValidations ; } 
protected function jsConvertRules ( $ attribute , $ rules , $ includeRemote ) { $ jsRules = [ ] ; foreach ( $ rules as $ rawRule ) { list ( $ rule , $ parameters ) = $ this -> validator -> parseRule ( $ rawRule ) ; list ( $ jsAttribute , $ jsRule , $ jsParams ) = $ this -> rules -> getRule ( $ attribute , $ rule , $ parameters , $ rawRule ) ; if ( $ this -> isValidatable ( $ jsRule , $ includeRemote ) ) { $ jsRules [ $ jsAttribute ] [ $ jsRule ] [ ] = [ $ rule , $ jsParams , $ this -> messages -> getMessage ( $ attribute , $ rule , $ parameters ) , $ this -> validator -> isImplicit ( $ rule ) , ] ; } } return $ jsRules ; } 
public function sometimes ( $ attribute , $ rules = [ ] ) { $ callback = function ( ) { return true ; } ; $ this -> validator -> sometimes ( $ attribute , $ rules , $ callback ) ; $ this -> rules -> addConditionalRules ( $ attribute , ( array ) $ rules ) ; } 
public function make ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , $ selector = null ) { $ validator = $ this -> getValidatorInstance ( $ rules , $ messages , $ customAttributes ) ; return $ this -> validator ( $ validator , $ selector ) ; } 
protected function getValidatorInstance ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ factory = $ this -> app -> make ( ValidationFactory :: class ) ; $ data = $ this -> getValidationData ( $ rules , $ customAttributes ) ; $ validator = $ factory -> make ( $ data , $ rules , $ messages , $ customAttributes ) ; $ validator -> addCustomAttributes ( $ customAttributes ) ; return $ validator ; } 
protected function getValidationData ( array $ rules , array $ customAttributes = [ ] ) { $ attributes = array_filter ( array_keys ( $ rules ) , function ( $ attribute ) { return $ attribute !== '' && mb_strpos ( $ attribute , '*' ) !== false ; } ) ; $ attributes = array_merge ( array_keys ( $ customAttributes ) , $ attributes ) ; $ data = array_reduce ( $ attributes , function ( $ data , $ attribute ) { Arr :: set ( $ data , $ attribute , true ) ; return $ data ; } , [ ] ) ; return $ data ; } 
public function formRequest ( $ formRequest , $ selector = null ) { if ( ! is_object ( $ formRequest ) ) { $ formRequest = $ this -> createFormRequest ( $ formRequest ) ; } $ rules = method_exists ( $ formRequest , 'rules' ) ? $ formRequest -> rules ( ) : [ ] ; $ validator = $ this -> getValidatorInstance ( $ rules , $ formRequest -> messages ( ) , $ formRequest -> attributes ( ) ) ; return $ this -> validator ( $ validator , $ selector ) ; } 
protected function createFormRequest ( $ class ) { list ( $ class , $ params ) = $ this -> parseFormRequestName ( $ class ) ; $ request = $ this -> app -> __get ( 'request' ) ; $ formRequest = $ this -> app -> build ( $ class , $ params ) ; if ( $ session = $ request -> getSession ( ) ) { $ formRequest -> setLaravelSession ( $ session ) ; } $ formRequest -> setUserResolver ( $ request -> getUserResolver ( ) ) ; $ formRequest -> setRouteResolver ( $ request -> getRouteResolver ( ) ) ; $ formRequest -> setContainer ( $ this -> app ) ; $ formRequest -> query = $ request -> query ; return $ formRequest ; } 
protected function jsValidator ( Validator $ validator , $ selector = null ) { $ remote = ! $ this -> options [ 'disable_remote_validation' ] ; $ view = $ this -> options [ 'view' ] ; $ selector = is_null ( $ selector ) ? $ this -> options [ 'form_selector' ] : $ selector ; $ delegated = new DelegatedValidator ( $ validator , new ValidationRuleParserProxy ( ) ) ; $ rules = new RuleParser ( $ delegated , $ this -> getSessionToken ( ) ) ; $ messages = new MessageParser ( $ delegated ) ; $ jsValidator = new ValidatorHandler ( $ rules , $ messages ) ; $ manager = new JavascriptValidator ( $ jsValidator , compact ( 'view' , 'selector' , 'remote' ) ) ; return $ manager ; } 
protected function getSessionToken ( ) { $ token = null ; if ( $ session = $ this -> app -> __get ( 'session' ) ) { $ token = $ session -> token ( ) ; } if ( $ encrypter = $ this -> app -> __get ( 'encrypter' ) ) { $ token = $ encrypter -> encrypt ( $ token ) ; } return $ token ; } 
public function handle ( Request $ request , Closure $ next ) { if ( $ request -> has ( $ this -> field ) ) { $ this -> wrapValidator ( ) ; } return $ next ( $ request ) ; } 
protected function wrapValidator ( ) { $ resolver = new Resolver ( $ this -> factory ) ; $ this -> factory -> resolver ( $ resolver -> resolver ( $ this -> field ) ) ; $ this -> factory -> extend ( RemoteValidator :: EXTENSION_NAME , $ resolver -> validatorClosure ( ) ) ; } 
public function resolver ( $ field ) { return function ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) use ( $ field ) { return $ this -> resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) ; } ; } 
protected function resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) { $ validateAll = Arr :: get ( $ data , $ field . '_validate_all' , false ) ; $ validationRule = 'bail|' . Validator :: EXTENSION_NAME . ':' . $ validateAll ; $ rules = [ $ field => $ validationRule ] + $ rules ; $ validator = $ this -> createValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; return $ validator ; } 
protected function createValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) { if ( is_null ( $ this -> resolver ) ) { return new BaseValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; } return call_user_func ( $ this -> resolver , $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; } 
public function validatorClosure ( ) { return function ( $ attribute , $ value , $ parameters , BaseValidator $ validator ) { $ remoteValidator = new Validator ( $ validator ) ; $ remoteValidator -> validate ( $ value , $ parameters ) ; return $ attribute ; } ; } 
protected function isImplemented ( $ rule ) { return in_array ( $ rule , $ this -> clientRules ) || in_array ( $ rule , $ this -> serverRules ) ; } 
protected function isRemoteRule ( $ rule ) { return in_array ( $ rule , $ this -> serverRules ) || ! in_array ( $ rule , $ this -> clientRules ) ; } 
private function setUp ( ) { if ( ! $ this -> config -> has ( 'purifier' ) ) { throw new Exception ( 'Configuration parameters not loaded!' ) ; } $ this -> checkCacheDirectory ( ) ; 
private function addCustomDefinition ( array $ definitionConfig , HTMLPurifier_Config $ configObject = null ) { if ( ! $ configObject ) { $ configObject = HTMLPurifier_Config :: createDefault ( ) ; $ configObject -> loadArray ( $ this -> getConfig ( ) ) ; } 
private function addCustomAttributes ( array $ attributes , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ attributes as $ attribute ) { 
private function addCustomElements ( array $ elements , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ elements as $ element ) { 
private function checkCacheDirectory ( ) { $ cachePath = $ this -> config -> get ( 'purifier.cachePath' ) ; if ( $ cachePath ) { if ( ! $ this -> files -> isDirectory ( $ cachePath ) ) { $ this -> files -> makeDirectory ( $ cachePath , $ this -> config -> get ( 'purifier.cacheFileMode' , 0755 ) , true ) ; } } } 
protected function getConfig ( $ config = null ) { 
public function clean ( $ dirty , $ config = null ) { if ( is_array ( $ dirty ) ) { return array_map ( function ( $ item ) use ( $ config ) { return $ this -> clean ( $ item , $ config ) ; } , $ dirty ) ; } return $ this -> purifier -> purify ( $ dirty , $ config ? $ this -> getConfig ( $ config ) : null ) ; } 
public function register ( ) { $ this -> mergeConfigFrom ( $ this -> getConfigSource ( ) , 'purifier' ) ; $ this -> app -> singleton ( 'purifier' , function ( Container $ app ) { return new Purifier ( $ app [ 'files' ] , $ app [ 'config' ] ) ; } ) ; $ this -> app -> alias ( 'purifier' , Purifier :: class ) ; } 
public function setRequest ( Request $ request ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 2.3 and will be removed in 3.0. Pass a RequestStack in the constructor instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ this -> request = $ request ; } 
private function getExtensions ( ) { if ( null === $ this -> sorted ) { krsort ( $ this -> extensions ) ; $ this -> sorted = ! empty ( $ this -> extensions ) ? call_user_func_array ( 'array_merge' , $ this -> extensions ) : array ( ) ; } return $ this -> sorted ; } 
protected function renderHtmlAttribute ( $ name , $ value ) { if ( true === $ value ) { return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ name ) ) ; } return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ value ) ) ; } 
private function htmlAttributesCallback ( $ name , $ value ) { if ( false === $ value || null === $ value ) { return '' ; } return ' ' . $ this -> renderHtmlAttribute ( $ name , $ value ) ; } 
protected function escape ( $ value ) { return $ this -> fixDoubleEscape ( htmlspecialchars ( ( string ) $ value , ENT_QUOTES | ENT_SUBSTITUTE , $ this -> charset ) ) ; } 
public function addVoter ( VoterInterface $ voter ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 2.3 and will be removed in 3.0. Pass voters in the constructor instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( $ this -> voters instanceof \ Traversable ) { $ this -> voters = iterator_to_array ( $ this -> voters ) ; } $ this -> voters [ ] = $ voter ; } 
public function get ( $ menu , array $ path = array ( ) , array $ options = array ( ) ) { if ( ! $ menu instanceof ItemInterface ) { if ( null === $ this -> menuProvider ) { throw new \ BadMethodCallException ( 'A menu provider must be set to retrieve a menu' ) ; } $ menuName = $ menu ; $ menu = $ this -> menuProvider -> get ( $ menuName , $ options ) ; if ( ! $ menu instanceof ItemInterface ) { throw new \ LogicException ( sprintf ( 'The menu "%s" exists, but is not a valid menu item object. Check where you created the menu to be sure it returns an ItemInterface object.' , $ menuName ) ) ; } } foreach ( $ path as $ child ) { $ menu = $ menu -> getChild ( $ child ) ; if ( null === $ menu ) { throw new \ InvalidArgumentException ( sprintf ( 'The menu has no child named "%s"' , $ child ) ) ; } } return $ menu ; } 
public function render ( $ menu , array $ options = array ( ) , $ renderer = null ) { $ menu = $ this -> castMenu ( $ menu ) ; return $ this -> rendererProvider -> get ( $ renderer ) -> render ( $ menu , $ options ) ; } 
public function getBreadcrumbsArray ( $ menu , $ subItem = null ) { if ( null === $ this -> menuManipulator ) { throw new \ BadMethodCallException ( 'The menu manipulator must be set to get the breadcrumbs array' ) ; } $ menu = $ this -> castMenu ( $ menu ) ; return $ this -> menuManipulator -> getBreadcrumbsArray ( $ menu , $ subItem ) ; } 
public function getCurrentItem ( $ menu ) { if ( null === $ this -> matcher ) { throw new \ BadMethodCallException ( 'The matcher must be set to get the current item of a menu' ) ; } $ menu = $ this -> castMenu ( $ menu ) ; return $ this -> retrieveCurrentItem ( $ menu ) ; } 
private function castMenu ( $ menu ) { if ( ! $ menu instanceof ItemInterface ) { $ path = array ( ) ; if ( is_array ( $ menu ) ) { if ( empty ( $ menu ) ) { throw new \ InvalidArgumentException ( 'The array cannot be empty' ) ; } $ path = $ menu ; $ menu = array_shift ( $ path ) ; } return $ this -> get ( $ menu , $ path ) ; } return $ menu ; } 
private function retrieveCurrentItem ( ItemInterface $ item ) { if ( $ this -> matcher -> isCurrent ( $ item ) ) { return $ item ; } if ( $ this -> matcher -> isAncestor ( $ item ) ) { foreach ( $ item -> getChildren ( ) as $ child ) { $ currentItem = $ this -> retrieveCurrentItem ( $ child ) ; if ( null !== $ currentItem ) { return $ currentItem ; } } } return null ; } 
public function render ( $ menu , array $ options = array ( ) , $ renderer = null ) { return $ this -> helper -> render ( $ menu , $ options , $ renderer ) ; } 
public function getCurrentItem ( $ menu ) { $ rootItem = $ this -> get ( $ menu ) ; $ currentItem = $ this -> helper -> getCurrentItem ( $ rootItem ) ; if ( null === $ currentItem ) { $ currentItem = $ rootItem ; } return $ currentItem ; } 
public function pathAsString ( ItemInterface $ menu , $ separator = ' > ' ) { if ( null === $ this -> menuManipulator ) { throw new \ BadMethodCallException ( 'The menu manipulator must be set to get the breadcrumbs array' ) ; } return $ this -> menuManipulator -> getPathAsString ( $ menu , $ separator ) ; } 
public function isCurrent ( ItemInterface $ item ) { if ( null === $ this -> matcher ) { throw new \ BadMethodCallException ( 'The matcher must be set to get the breadcrumbs array' ) ; } return $ this -> matcher -> isCurrent ( $ item ) ; } 
public function buildItem ( ItemInterface $ item , array $ options ) { $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setCurrent ( $ options [ 'current' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) ; $ this -> buildExtras ( $ item , $ options ) ; } 
private function buildExtras ( ItemInterface $ item , array $ options ) { if ( ! empty ( $ options [ 'extras' ] ) ) { foreach ( $ options [ 'extras' ] as $ key => $ value ) { $ item -> setExtra ( $ key , $ value ) ; } } } 
private function fromArray ( array $ data , $ name = null ) { $ name = isset ( $ data [ 'name' ] ) ? $ data [ 'name' ] : $ name ; if ( isset ( $ data [ 'children' ] ) ) { $ children = $ data [ 'children' ] ; unset ( $ data [ 'children' ] ) ; } else { $ children = array ( ) ; } $ item = $ this -> factory -> createItem ( $ name , $ data ) ; foreach ( $ children as $ name => $ child ) { $ item -> addChild ( $ this -> fromArray ( $ child , $ name ) ) ; } return $ item ; } 
protected function renderChildren ( ItemInterface $ item , array $ options ) { 
protected function renderItem ( ItemInterface $ item , array $ options ) { 
protected function renderLink ( ItemInterface $ item , array $ options = array ( ) ) { if ( $ item -> getUri ( ) && ( ! $ item -> isCurrent ( ) || $ options [ 'currentAsLink' ] ) ) { $ text = $ this -> renderLinkElement ( $ item , $ options ) ; } else { $ text = $ this -> renderSpanElement ( $ item , $ options ) ; } return $ this -> format ( $ text , 'link' , $ item -> getLevel ( ) , $ options ) ; } 
protected function format ( $ html , $ type , $ level , array $ options ) { if ( $ options [ 'compressed' ] ) { return $ html ; } switch ( $ type ) { case 'ul' : case 'link' : $ spacing = $ level * 4 ; break ; case 'li' : $ spacing = $ level * 4 - 2 ; break ; } return str_repeat ( ' ' , $ spacing ) . $ html . "\n" ; } 
public function moveToPosition ( ItemInterface $ item , $ position ) { $ this -> moveChildToPosition ( $ item -> getParent ( ) , $ item , $ position ) ; } 
public function moveChildToPosition ( ItemInterface $ item , ItemInterface $ child , $ position ) { $ name = $ child -> getName ( ) ; $ order = array_keys ( $ item -> getChildren ( ) ) ; $ oldPosition = array_search ( $ name , $ order ) ; unset ( $ order [ $ oldPosition ] ) ; $ order = array_values ( $ order ) ; array_splice ( $ order , $ position , 0 , $ name ) ; $ item -> reorderChildren ( $ order ) ; } 
public function slice ( ItemInterface $ item , $ offset , $ length = null ) { $ names = array_keys ( $ item -> getChildren ( ) ) ; if ( $ offset instanceof ItemInterface ) { $ offset = $ offset -> getName ( ) ; } if ( ! is_numeric ( $ offset ) ) { $ offset = array_search ( $ offset , $ names ) ; } if ( null !== $ length ) { if ( $ length instanceof ItemInterface ) { $ length = $ length -> getName ( ) ; } if ( ! is_numeric ( $ length ) ) { $ index = array_search ( $ length , $ names ) ; $ length = ( $ index < $ offset ) ? 0 : $ index - $ offset ; } } $ slicedItem = $ item -> copy ( ) ; $ children = array_slice ( $ slicedItem -> getChildren ( ) , $ offset , $ length ) ; $ slicedItem -> setChildren ( $ children ) ; return $ slicedItem ; } 
public function split ( ItemInterface $ item , $ length ) { return array ( 'primary' => $ this -> slice ( $ item , 0 , $ length ) , 'secondary' => $ this -> slice ( $ item , $ length ) , ) ; } 
public function callRecursively ( ItemInterface $ item , $ method , $ arguments = array ( ) ) { call_user_func_array ( array ( $ item , $ method ) , $ arguments ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> callRecursively ( $ child , $ method , $ arguments ) ; } } 
public function getPathAsString ( ItemInterface $ item , $ separator = ' > ' ) { $ children = array ( ) ; $ obj = $ item ; do { $ children [ ] = $ obj -> getLabel ( ) ; } while ( $ obj = $ obj -> getParent ( ) ) ; return implode ( $ separator , array_reverse ( $ children ) ) ; } 
public function toArray ( ItemInterface $ item , $ depth = null ) { $ array = array ( 'name' => $ item -> getName ( ) , 'label' => $ item -> getLabel ( ) , 'uri' => $ item -> getUri ( ) , 'attributes' => $ item -> getAttributes ( ) , 'labelAttributes' => $ item -> getLabelAttributes ( ) , 'linkAttributes' => $ item -> getLinkAttributes ( ) , 'childrenAttributes' => $ item -> getChildrenAttributes ( ) , 'extras' => $ item -> getExtras ( ) , 'display' => $ item -> isDisplayed ( ) , 'displayChildren' => $ item -> getDisplayChildren ( ) , 'current' => $ item -> isCurrent ( ) , ) ; 
public function getBreadcrumbsArray ( ItemInterface $ item , $ subItem = null ) { $ breadcrumbs = $ this -> buildBreadcrumbsArray ( $ item ) ; if ( null === $ subItem ) { return $ breadcrumbs ; } if ( $ subItem instanceof ItemInterface ) { $ breadcrumbs [ ] = $ this -> getBreadcrumbsItem ( $ subItem ) ; return $ breadcrumbs ; } if ( ! is_array ( $ subItem ) && ! $ subItem instanceof \ Traversable ) { $ subItem = array ( $ subItem ) ; } foreach ( $ subItem as $ key => $ value ) { switch ( true ) { case $ value instanceof ItemInterface : $ value = $ this -> getBreadcrumbsItem ( $ value ) ; break ; case is_array ( $ value ) : 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Merchandising \ Services \ MerchandisingService :: API_VERSION ] , 'globalId' => [ 'valid' => [ 'string' ] ] ] ; } 
protected function getEbayHeaders ( $ operationName ) { $ headers = [ ] ; 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Product \ Services \ ProductService :: API_VERSION ] , 'globalId' => [ 'valid' => [ 'string' ] ] ] ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ HalfFinding \ Services \ HalfFindingService :: API_VERSION ] , 'globalId' => [ 'valid' => [ 'string' ] ] ] ; } 
public static function isTruthy ( $ value ) { if ( ! $ value ) { return $ value === 0 || $ value === '0' ; } elseif ( $ value instanceof \ stdClass ) { return ( bool ) get_object_vars ( $ value ) ; } elseif ( $ value instanceof JmesPathableArrayInterface ) { return Utils :: isTruthy ( iterator_to_array ( $ value ) ) ; } elseif ( $ value instanceof JmesPathableObjectInterface ) { return ( bool ) $ value -> toArray ( ) ; } else { return true ; } } 
public static function type ( $ arg ) { $ type = gettype ( $ arg ) ; if ( isset ( self :: $ typeMap [ $ type ] ) ) { return self :: $ typeMap [ $ type ] ; } elseif ( $ type === 'array' ) { if ( empty ( $ arg ) ) { return 'array' ; } reset ( $ arg ) ; return key ( $ arg ) === 0 ? 'array' : 'object' ; } elseif ( $ arg instanceof \ stdClass ) { return 'object' ; } elseif ( $ arg instanceof JmesPathableObjectInterface ) { return 'object' ; } elseif ( $ arg instanceof \ Closure ) { return 'expression' ; } elseif ( $ arg instanceof \ ArrayAccess && $ arg instanceof \ Countable ) { return count ( $ arg ) == 0 || $ arg -> offsetExists ( 0 ) ? 'array' : 'object' ; } elseif ( method_exists ( $ arg , '__toString' ) ) { return 'string' ; } throw new \ InvalidArgumentException ( 'Unable to determine JMESPath type from ' . get_class ( $ arg ) ) ; } 
public static function isObject ( $ value ) { if ( is_array ( $ value ) ) { return ! $ value || array_keys ( $ value ) [ 0 ] !== 0 ; } 
public static function isEqual ( $ a , $ b ) { if ( $ a === $ b ) { return true ; } elseif ( $ a instanceof \ stdClass ) { return self :: isEqual ( ( array ) $ a , $ b ) ; } elseif ( $ b instanceof \ stdClass ) { return self :: isEqual ( $ a , ( array ) $ b ) ; } elseif ( $ a instanceof JmesPathableArrayInterface ) { return Utils :: isEqual ( iterator_to_array ( $ a ) , $ b ) ; } elseif ( $ b instanceof JmesPathableArrayInterface ) { return Utils :: isEqual ( $ a , iterator_to_array ( $ b ) ) ; } elseif ( $ a instanceof JmesPathableObjectInterface ) { return Utils :: isEqual ( $ a -> toArray ( ) , $ b ) ; } elseif ( $ b instanceof JmesPathableObjectInterface ) { return Utils :: isEqual ( $ a , $ b -> toArray ( ) ) ; } else { return false ; } } 
public static function stableSort ( array $ data , callable $ sortFn ) { 
public static function slice ( $ value , $ start = null , $ stop = null , $ step = 1 ) { if ( ! Utils :: isArray ( $ value ) && ! is_string ( $ value ) ) { throw new \ InvalidArgumentException ( 'Expects string or array' ) ; } return self :: sliceIndices ( $ value , $ start , $ stop , $ step ) ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ FileTransfer \ Services \ FileTransferService :: API_VERSION ] , 'authToken' => [ 'valid' => [ 'string' ] , 'required' => true ] ] ; } 
protected function callOperationAsync ( $ name , \ DTS \ eBaySDK \ Types \ BaseType $ request , $ responseClass ) { if ( $ name === 'uploadFile' && $ request -> hasAttachment ( ) ) { if ( ! isset ( $ request -> fileAttachment ) ) { $ request -> fileAttachment = new \ DTS \ eBaySDK \ FileTransfer \ Types \ FileAttachment ( ) ; } if ( ! isset ( $ request -> fileAttachment -> Data ) ) { $ request -> fileAttachment -> Data = new \ DTS \ eBaySDK \ FileTransfer \ Types \ Data ( [ 'xopInclude' => new \ DTS \ eBaySDK \ FileTransfer \ Types \ XopInclude ( [ 'href' => 'cid:attachment.bin@devbay.net' ] ) ] ) ; } if ( ! isset ( $ request -> fileAttachment -> Size ) ) { $ attachment = $ request -> attachment ( ) ; $ request -> fileAttachment -> Size = strlen ( $ attachment [ 'data' ] ) ; } } return parent :: callOperationAsync ( $ name , $ request , $ responseClass ) ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Marketing \ Services \ MarketingService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
protected function getEbayHeaders ( ) { $ headers = [ ] ; 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ BulkDataExchange \ Services \ BulkDataExchangeService :: API_VERSION ] , 'authToken' => [ 'valid' => [ 'string' ] , 'required' => true ] ] ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'affiliateCampaignId' => [ 'valid' => [ 'string' ] ] , 'affiliateReferenceId' => [ 'valid' => [ 'string' ] ] , 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Browse \ Services \ BrowseService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'contextualLocation' => [ 'valid' => [ 'string' ] ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
protected function getEbayHeaders ( ) { $ headers = [ ] ; 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Finding \ Services \ FindingService :: API_VERSION ] , 'globalId' => [ 'valid' => [ 'string' ] ] ] ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ PostOrder \ Services \ PostOrderService :: API_VERSION , 'required' => true ] , 'authToken' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
protected function getEbayHeaders ( ) { $ headers = [ ] ; 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Metadata \ Services \ MetadataService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
public function setConfig ( array $ configuration ) { $ this -> config = Functions \ arrayMergeDeep ( $ this -> config , $ this -> resolver -> resolveOptions ( $ configuration ) ) ; } 
private function buildRequestHeaders ( $ body ) { $ headers = $ this -> getEbayHeaders ( ) ; $ headers [ 'Accept' ] = 'application/json' ; $ headers [ 'Content-Type' ] = 'application/json' ; $ headers [ 'Content-Length' ] = strlen ( $ body ) ; 
private function debugRequest ( $ url , array $ headers , $ body ) { $ str = $ url . PHP_EOL ; $ str .= array_reduce ( array_keys ( $ headers ) , function ( $ str , $ key ) use ( $ headers ) { $ str .= $ key . ': ' . $ headers [ $ key ] . PHP_EOL ; return $ str ; } , '' ) ; $ str .= $ body ; $ this -> debug ( $ str ) ; } 
private function validateSeq ( $ from , array $ types , $ a , $ b ) { $ ta = Utils :: type ( $ a ) ; $ tb = Utils :: type ( $ b ) ; if ( $ ta !== $ tb ) { $ msg = "encountered a type mismatch in sequence: {$ta}, {$tb}" ; $ this -> typeError ( $ from , $ msg ) ; } $ typeMatch = ( $ types && $ types [ 0 ] == 'any' ) || in_array ( $ ta , $ types ) ; if ( ! $ typeMatch ) { $ msg = 'encountered a type error in sequence. The argument must be ' . 'an array of ' . implode ( '|' , $ types ) . ' types. ' . "Found {$ta}, {$tb}." ; $ this -> typeError ( $ from , $ msg ) ; } } 
private function reduce ( $ from , array $ values , array $ types , callable $ reduce ) { $ i = - 1 ; return array_reduce ( $ values , function ( $ carry , $ item ) use ( $ from , $ types , $ reduce , & $ i ) { if ( ++ $ i > 0 ) { $ this -> validateSeq ( $ from , $ types , $ carry , $ item ) ; } return $ reduce ( $ carry , $ item , $ i ) ; } ) ; } 
private function wrapExpression ( $ from , callable $ expr , array $ types ) { list ( $ fn , $ pos ) = explode ( ':' , $ from ) ; $ from = "The expression return value of argument {$pos} of {$fn}" ; return function ( $ value ) use ( $ from , $ expr , $ types ) { $ value = $ expr ( $ value ) ; $ this -> validateType ( $ from , $ value , $ types ) ; return $ value ; } ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Taxonomy \ Services \ TaxonomyService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Account \ Services \ AccountService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
public function resolve ( $ uri , $ version , $ resource , array $ paramDefs , array $ paramValues ) { foreach ( $ paramValues as $ param => $ value ) { if ( ! array_key_exists ( $ param , $ paramDefs ) ) { throw new \ InvalidArgumentException ( "Unknown uri parameter \"$param\" provided" ) ; } } foreach ( $ paramDefs as $ key => $ def ) { if ( ! isset ( $ paramValues [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ paramValues [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ paramValues ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ paramDefs , $ paramValues ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ paramValues [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ paramValues [ $ key ] , $ paramValues ) ; } } return ( "$uri/" . "$version/" . $ this -> fillPathParams ( $ resource , $ paramValues ) . $ this -> buildQueryParameters ( $ paramValues ) ) ; } 
private function fillPathParams ( $ uri , array & $ paramValues ) { return preg_replace_callback ( '/{(\S+)}/U' , function ( $ matches ) use ( & $ paramValues ) { $ path = $ matches [ 1 ] ; if ( array_key_exists ( $ path , $ paramValues ) ) { $ value = $ paramValues [ $ path ] ; unset ( $ paramValues [ $ path ] ) ; } else { $ value = $ path ; } return $ value ; } , $ uri ) ; } 
private function buildQueryParameters ( array $ paramValues ) { if ( empty ( $ paramValues ) ) { return '' ; } $ query = [ ] ; foreach ( $ paramValues as $ param => $ value ) { if ( is_array ( $ value ) ) { $ value = join ( ',' , $ value ) ; } elseif ( is_bool ( $ value ) ) { $ value = $ value ? 'true' : 'false' ; } elseif ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } $ query [ ] = $ param . '=' . urlencode ( $ value ) ; } return '?' . join ( '&' , $ query ) ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Order \ Services \ OrderService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] , 'riskCorrelationId' => [ 'valid' => [ 'string' ] ] ] ; } 
protected function getEbayHeaders ( ) { $ headers = [ ] ; 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ ProductMetadata \ Services \ ProductMetadataService :: API_VERSION ] , 'globalId' => [ 'valid' => [ 'string' ] ] ] ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Feed \ Services \ FeedService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ BusinessPoliciesManagement \ Services \ BusinessPoliciesManagementService :: API_VERSION ] , 'authToken' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'globalId' => [ 'valid' => [ 'string' ] , 'required' => true ] ] ; } 
public function tokenize ( $ input ) { $ tokens = [ ] ; if ( $ input === '' ) { goto eof ; } $ chars = str_split ( $ input ) ; while ( false !== ( $ current = current ( $ chars ) ) ) { 
private function matchOr ( array & $ chars , $ current , $ expected , $ type , $ orElse ) { if ( next ( $ chars ) === $ expected ) { next ( $ chars ) ; return [ 'type' => $ type , 'pos' => key ( $ chars ) - 1 , 'value' => $ current . $ expected ] ; } return [ 'type' => $ orElse , 'pos' => key ( $ chars ) - 1 , 'value' => $ current ] ; } 
private function inside ( array & $ chars , $ delim , $ type ) { $ position = key ( $ chars ) ; $ current = next ( $ chars ) ; $ buffer = '' ; while ( $ current !== $ delim ) { if ( $ current === '\\' ) { $ buffer .= '\\' ; $ current = next ( $ chars ) ; } if ( $ current === false ) { 
private function parseJson ( array $ token ) { $ value = json_decode ( $ token [ 'value' ] , true ) ; if ( $ error = json_last_error ( ) ) { 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'affiliateUserId' => [ 'valid' => [ 'string' ] ] , 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Shopping \ Services \ ShoppingService :: API_VERSION , 'required' => true ] , 'siteId' => [ 'valid' => [ 'int' , 'string' ] ] , 'trackingId' => [ 'valid' => [ 'string' ] ] , 'trackingPartnerCode' => [ 'valid' => [ 'string' ] ] ] ; } 
protected function getEbayHeaders ( $ operationName ) { $ headers = [ ] ; 
protected function callOperationAsync ( $ name , \ DTS \ eBaySDK \ Types \ BaseType $ request , $ responseClass ) { $ url = $ this -> getUrl ( ) ; $ body = $ this -> buildRequestBody ( $ request ) ; $ headers = $ this -> buildRequestHeaders ( $ name , $ request , $ body ) ; $ debug = $ this -> getConfig ( 'debug' ) ; $ httpHandler = $ this -> getConfig ( 'httpHandler' ) ; $ httpOptions = $ this -> getConfig ( 'httpOptions' ) ; if ( $ debug !== false ) { $ this -> debugRequest ( $ url , $ headers , $ body ) ; } $ request = new Request ( 'POST' , $ url , $ headers , $ body ) ; return $ httpHandler ( $ request , $ httpOptions ) -> then ( function ( ResponseInterface $ res ) use ( $ debug , $ responseClass ) { list ( $ xmlResponse , $ attachment ) = $ this -> extractXml ( $ res -> getBody ( ) -> getContents ( ) ) ; if ( $ debug !== false ) { $ this -> debugResponse ( $ xmlResponse ) ; } $ xmlParser = new XmlParser ( $ responseClass ) ; $ response = $ xmlParser -> parse ( $ xmlResponse ) ; $ response -> attachment ( $ attachment ) ; return $ response ; } ) ; } 
protected function buildRequestBody ( \ DTS \ eBaySDK \ Types \ BaseType $ request ) { if ( ! $ request -> hasAttachment ( ) ) { return $ request -> toRequestXml ( ) ; } else { return $ this -> buildXopDocument ( $ request ) . $ this -> buildAttachmentBody ( $ request -> attachment ( ) ) ; } } 
protected function buildMultipartFormDataXMLPayload ( \ DTS \ eBaySDK \ Types \ BaseType $ request ) { return sprintf ( '%s%s%s' , '--boundary' . self :: CRLF , 'Content-Disposition: form-data; name="XML Payload"' . self :: CRLF . self :: CRLF , $ request -> toRequestXml ( ) . self :: CRLF ) ; } 
protected function buildMultipartFormDataFilePayload ( $ name , $ attachment ) { return sprintf ( '%s%s%s%s%s' , '--boundary' . self :: CRLF , 'Content-Disposition: form-data; name="' . $ name . '"; filename="picture"' . self :: CRLF , 'Content-Type: ' . $ attachment [ 'mimeType' ] . self :: CRLF . self :: CRLF , $ attachment [ 'data' ] . self :: CRLF , '--boundary--' ) ; } 
private function buildRequestHeaders ( $ name , $ request , $ body ) { $ headers = [ ] ; if ( $ request -> hasAttachment ( ) ) { $ headers [ 'Content-Type' ] = 'multipart/related;boundary=MIME_boundary;type="application/xop+xml";start="<request.xml@devbay.net>";start-info="text/xml"' ; } else { $ headers [ 'Content-Type' ] = 'text/xml' ; } if ( $ this -> getConfig ( 'compressResponse' ) ) { $ headers [ self :: HDR_RESPONSE_ENCODING ] = 'application/gzip' ; } $ headers [ 'Content-Length' ] = strlen ( $ body ) ; return array_merge ( $ headers , $ this -> getEbayHeaders ( $ name ) ) ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Compliance \ Services \ ComplianceService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
public function parse ( $ expression ) { $ this -> expression = $ expression ; $ this -> tokens = $ this -> lexer -> tokenize ( $ expression ) ; $ this -> tpos = - 1 ; $ this -> next ( ) ; $ result = $ this -> expr ( ) ; if ( $ this -> token [ 'type' ] === T :: T_EOF ) { return $ result ; } throw $ this -> syntax ( 'Did not reach the end of the token stream' ) ; } 
private function expr ( $ rbp = 0 ) { $ left = $ this -> { "nud_{$this->token['type']}" } ( ) ; while ( $ rbp < self :: $ bp [ $ this -> token [ 'type' ] ] ) { $ left = $ this -> { "led_{$this->token['type']}" } ( $ left ) ; } return $ left ; } 
private function parseArrayIndexExpression ( ) { static $ matchNext = [ T :: T_NUMBER => true , T :: T_COLON => true , T :: T_RBRACKET => true ] ; $ pos = 0 ; $ parts = [ null , null , null ] ; $ expected = $ matchNext ; do { if ( $ this -> token [ 'type' ] == T :: T_COLON ) { $ pos ++ ; $ expected = $ matchNext ; } elseif ( $ this -> token [ 'type' ] == T :: T_NUMBER ) { $ parts [ $ pos ] = $ this -> token [ 'value' ] ; $ expected = [ T :: T_COLON => true , T :: T_RBRACKET => true ] ; } $ this -> next ( $ expected ) ; } while ( $ this -> token [ 'type' ] != T :: T_RBRACKET ) ; 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Feedback \ Services \ FeedbackService :: API_VERSION ] , 'authToken' => [ 'valid' => [ 'string' ] , 'required' => true ] ] ; } 
public function resolve ( array $ configuration ) { foreach ( $ this -> definitions as $ key => $ def ) { if ( ! isset ( $ configuration [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ configuration [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ configuration ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ configuration ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ configuration [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ configuration [ $ key ] , $ configuration ) ; } } return $ configuration ; } 
public function resolveOptions ( array $ configuration ) { foreach ( $ configuration as $ key => $ value ) { if ( isset ( $ this -> definitions [ $ key ] ) ) { $ def = $ this -> definitions [ $ key ] ; $ this -> checkType ( $ def [ 'valid' ] , $ key , $ value ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ configuration [ $ key ] , $ configuration ) ; } } } return $ configuration ; } 
private function checkType ( array $ valid , $ name , $ provided ) { foreach ( $ valid as $ check ) { if ( isset ( self :: $ typeMap [ $ check ] ) ) { $ fn = self :: $ typeMap [ $ check ] ; if ( $ fn ( $ provided ) ) { return ; } } elseif ( $ provided instanceof $ check ) { return ; } } $ expected = implode ( '|' , $ valid ) ; $ msg = sprintf ( 'Invalid configuration value provided for "%s". Expected %s, but got %s' , $ name , $ expected , describeType ( $ provided ) ) ; throw new \ InvalidArgumentException ( $ msg ) ; } 
private function throwRequired ( array $ configuration ) { $ missing = [ ] ; foreach ( $ this -> definitions as $ key => $ def ) { if ( empty ( $ def [ 'required' ] ) || isset ( $ def [ 'default' ] ) || array_key_exists ( $ key , $ configuration ) ) { continue ; } $ missing [ ] = $ key ; } $ msg = "Missing required configuration options: \n\n" ; $ msg .= implode ( "\n\n" , $ missing ) ; throw new \ InvalidArgumentException ( $ msg ) ; } 
public function offsetSet ( $ offset , $ value ) { self :: ensurePropertyType ( $ value ) ; if ( is_null ( $ offset ) ) { $ this -> data [ ] = $ value ; } else { $ this -> data [ $ offset ] = $ value ; } } 
private function ensurePropertyType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } $ valid = explode ( '|' , $ this -> expectedType ) ; $ isValid = false ; foreach ( $ valid as $ check ) { if ( $ check !== 'any' && \ DTS \ eBaySDK \ checkPropertyType ( $ check ) ) { if ( $ check === $ actualType ) { return ; } $ isValid = false ; } else { $ isValid = true ; } } if ( ! $ isValid ) { throw new Exceptions \ InvalidPropertyTypeException ( $ this -> property , $ this -> expectedType , $ actualType ) ; } } 
private function toXml ( $ elementName , $ rootElement = false ) { return sprintf ( '%s<%s%s%s>%s</%s>' , $ rootElement ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" : '' , $ elementName , $ this -> attributesToXml ( ) , array_key_exists ( get_class ( $ this ) , self :: $ xmlNamespaces ) ? sprintf ( ' %s' , self :: $ xmlNamespaces [ get_class ( $ this ) ] ) : '' , $ this -> propertiesToXml ( ) , $ elementName ) ; } 
public function elementMeta ( $ elementName ) { $ class = get_class ( $ this ) ; if ( array_key_exists ( $ elementName , self :: $ properties [ $ class ] ) ) { $ info = self :: $ properties [ $ class ] [ $ elementName ] ; $ nameKey = $ info [ 'attribute' ] ? 'attributeName' : 'elementName' ; if ( array_key_exists ( $ nameKey , $ info ) ) { if ( $ info [ $ nameKey ] === $ elementName ) { $ meta = new \ stdClass ( ) ; $ meta -> propertyName = $ elementName ; $ meta -> phpType = $ info [ 'type' ] ; $ meta -> repeatable = $ info [ 'repeatable' ] ; $ meta -> attribute = $ info [ 'attribute' ] ; $ meta -> elementName = $ info [ $ nameKey ] ; $ meta -> strData = '' ; return $ meta ; } } } return null ; } 
public function attachment ( $ data = null , $ mimeType = 'application/octet-stream' ) { if ( $ data !== null ) { if ( is_array ( $ data ) ) { $ this -> attachment [ 'data' ] = array_key_exists ( 'data' , $ data ) ? $ data [ 'data' ] : null ; $ this -> attachment [ 'mimeType' ] = array_key_exists ( 'mimeType' , $ data ) ? $ data [ 'mimeType' ] : 'application/octet-stream' ; } else { $ this -> attachment [ 'data' ] = $ data ; $ this -> attachment [ 'mimeType' ] = $ mimeType ; } } return $ this -> attachment ; } 
private function set ( $ class , $ name , $ value ) { self :: ensurePropertyExists ( $ class , $ name ) ; self :: ensurePropertyType ( $ class , $ name , $ value ) ; $ this -> setValue ( $ class , $ name , $ value ) ; } 
private static function ensurePropertyType ( $ class , $ name , $ value ) { $ isValid = false ; $ info = self :: propertyInfo ( $ class , $ name ) ; $ actualType = self :: getActualType ( $ value ) ; $ valid = explode ( '|' , $ info [ 'type' ] ) ; foreach ( $ valid as $ check ) { if ( $ check !== 'any' && \ DTS \ eBaySDK \ checkPropertyType ( $ check ) ) { if ( $ check === $ actualType || 'array' === $ actualType ) { return ; } $ isValid = false ; } else { $ isValid = true ; } } if ( ! $ isValid ) { $ expectedType = $ info [ 'type' ] ; throw new Exceptions \ InvalidPropertyTypeException ( $ name , $ expectedType , $ actualType ) ; } } 
private static function getActualType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } return $ actualType ; } 
private static function propertyToXml ( $ name , $ value ) { if ( is_subclass_of ( $ value , '\DTS\eBaySDK\Types\BaseType' , false ) ) { return $ value -> toXml ( $ name ) ; } else { return sprintf ( '<%s>%s</%s>' , $ name , self :: encodeValueXml ( $ value ) , $ name ) ; } } 
private static function encodeValueXml ( $ value ) { if ( $ value instanceof \ DateTime ) { return $ value -> format ( 'Y-m-d\TH:i:s.000\Z' ) ; } elseif ( is_bool ( $ value ) ) { return $ value ? 'true' : 'false' ; } else { return htmlspecialchars ( $ value , ENT_QUOTES , 'UTF-8' , true ) ; } } 
private static function determineActualValueToAssign ( $ class , $ property , $ value ) { if ( ! array_key_exists ( $ property , self :: $ properties [ $ class ] ) ) { return $ value ; } $ info = self :: propertyInfo ( $ class , $ property ) ; if ( $ info [ 'repeatable' ] && is_array ( $ value ) ) { $ values = [ ] ; foreach ( $ value as $ val ) { $ values [ ] = self :: actualValue ( $ info , $ val ) ; } return $ values ; } return self :: actualValue ( $ info , $ value ) ; } 
private static function actualValue ( array $ info , $ value ) { if ( is_object ( $ value ) ) { return $ value ; } $ types = explode ( '|' , $ info [ 'type' ] ) ; foreach ( $ types as $ type ) { switch ( $ type ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'any' : return $ value ; case 'DateTime' : return new \ DateTime ( $ value , new \ DateTimeZone ( 'UTC' ) ) ; } } return new $ info [ 'type' ] ( $ value ) ; } 
private static function removeNull ( $ value ) { if ( ! is_array ( $ value ) ) { return $ value ; } return array_filter ( $ value , function ( $ val ) { return ! is_null ( $ val ) ; } ) ; } 
public static function memoize ( callable $ provider ) { return function ( ) use ( $ provider ) { static $ result ; static $ isConstant ; if ( $ isConstant ) { return $ result ; } $ isConstant = true ; return $ result = $ provider ( ) ; } ; } 
public static function chain ( ) { $ providers = func_get_args ( ) ; if ( empty ( $ providers ) ) { throw new \ InvalidArgumentException ( 'No providers in chain' ) ; } return function ( ) use ( $ providers ) { $ provider = array_shift ( $ providers ) ; $ credentials = $ provider ( ) ; while ( ( $ provider = array_shift ( $ providers ) ) && ! ( $ credentials instanceof Credentials ) ) { $ credentials = $ provider ( ) ; } return $ credentials ; } ; } 
public static function env ( ) { return function ( ) { $ appId = getenv ( self :: ENV_APP_ID ) ; $ certId = getenv ( self :: ENV_CERT_ID ) ; $ devId = getenv ( self :: ENV_DEV_ID ) ; if ( $ appId && $ certId && $ devId ) { return new Credentials ( $ appId , $ certId , $ devId ) ; } else { return new \ InvalidArgumentException ( 'Could not find environment variable ' . 'credentials in ' . self :: ENV_APP_ID . '/' . self :: ENV_CERT_ID . '/' . self :: ENV_DEV_ID ) ; } } ; } 
public static function ini ( $ profile = null , $ filename = null ) { $ filename = $ filename ? : ( self :: getHomeDir ( ) . '/.ebay_sdk/credentials' ) ; $ profile = $ profile ? : ( getenv ( self :: ENV_PROFILE ) ? : 'default' ) ; return function ( ) use ( $ filename , $ profile ) { if ( ! is_readable ( $ filename ) ) { return new \ InvalidArgumentException ( "Cannot read credentials from $filename" ) ; } $ data = parse_ini_file ( $ filename , true ) ; if ( $ data === false ) { return new \ InvalidArgumentException ( "Invalid credentials file $filename" ) ; } if ( ! isset ( $ data [ $ profile ] ) ) { return new \ InvalidArgumentException ( "'$profile' not found in credentials file" ) ; } if ( ! isset ( $ data [ $ profile ] [ 'ebay_app_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_cert_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_dev_id' ] ) ) { return new \ InvalidArgumentException ( "No credentials present in INI profile '$profile' ($filename)" ) ; } return new Credentials ( $ data [ $ profile ] [ 'ebay_app_id' ] , $ data [ $ profile ] [ 'ebay_cert_id' ] , $ data [ $ profile ] [ 'ebay_dev_id' ] ) ; } ; } 
private static function getHomeDir ( ) { 
public function createService ( $ namespace , array $ config = [ ] ) { $ configuration = $ this -> config ; if ( isset ( $ this -> config [ $ namespace ] ) ) { $ configuration = arrayMergeDeep ( $ configuration , $ this -> config [ $ namespace ] ) ; } $ configuration = arrayMergeDeep ( $ configuration , $ config ) ; $ service = "DTS\\eBaySDK\\{$namespace}\\Services\\{$namespace}Service" ; return new $ service ( $ configuration ) ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Trading \ Services \ TradingService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] ] , 'authToken' => [ 'valid' => [ 'string' ] ] , 'siteId' => [ 'valid' => [ 'int' , 'string' ] , 'required' => true ] ] ; } 
protected function callOperationAsync ( $ name , \ DTS \ eBaySDK \ Types \ BaseType $ request , $ responseClass ) { if ( $ this -> getConfig ( 'authorization' ) !== null ) { if ( isset ( $ request -> RequesterCredentials ) ) { unset ( $ request -> RequesterCredentials ) ; } } elseif ( $ this -> getConfig ( 'authToken' ) !== null ) { if ( ! isset ( $ request -> RequesterCredentials ) ) { $ request -> RequesterCredentials = new \ DTS \ eBaySDK \ Trading \ Types \ CustomSecurityHeaderType ( ) ; } if ( ! isset ( $ request -> RequesterCredentials -> eBayAuthToken ) ) { $ request -> RequesterCredentials -> eBayAuthToken = $ this -> getConfig ( 'authToken' ) ; } } return parent :: callOperationAsync ( $ name , $ request , $ responseClass ) ; } 
protected function getEbayHeaders ( $ operationName ) { $ credentials = $ this -> getConfig ( 'credentials' ) ; $ appId = $ credentials -> getAppId ( ) ; $ certId = $ credentials -> getCertId ( ) ; $ devId = $ credentials -> getDevId ( ) ; $ headers = [ ] ; * Note that we have no way of detecting that the actual request has an attachment. */ if ( $ operationName === 'UploadSiteHostedPictures' ) { $ headers [ 'Content-Type' ] = 'multipart/form-data;boundary="boundary"' ; } return $ headers ; } 
protected function buildRequestBody ( \ DTS \ eBaySDK \ Types \ BaseType $ request ) { if ( $ request -> hasAttachment ( ) && $ request instanceof Types \ UploadSiteHostedPicturesRequestType ) { return $ this -> buildMultipartFormDataXMLPayload ( $ request ) . $ this -> buildMultipartFormDataFilePayload ( $ request -> PictureName , $ request -> attachment ( ) ) ; } else { return parent :: buildRequestBody ( $ request ) ; } } 
public function parse ( $ xml ) { $ parser = xml_parser_create_ns ( 'UTF-8' , '@' ) ; xml_parser_set_option ( $ parser , XML_OPTION_CASE_FOLDING , 0 ) ; xml_parser_set_option ( $ parser , XML_OPTION_SKIP_WHITE , 1 ) ; xml_set_object ( $ parser , $ this ) ; xml_set_element_handler ( $ parser , 'startElement' , 'endElement' ) ; xml_set_character_data_handler ( $ parser , 'cdata' ) ; xml_parse ( $ parser , $ xml , true ) ; xml_parser_free ( $ parser ) ; return $ this -> rootObject ; } 
private function startElement ( $ parser , $ name , array $ attributes ) { $ this -> metaStack -> push ( $ this -> getPhpMeta ( $ this -> normalizeElementName ( $ name ) , $ attributes ) ) ; } 
private function normalizeElementName ( $ name ) { $ nsElement = explode ( '@' , $ name ) ; if ( count ( $ nsElement ) > 1 ) { array_shift ( $ nsElement ) ; return $ nsElement [ 0 ] ; } else { return $ name ; } } 
private function newPhpObject ( \ stdClass $ meta ) { $ phpTypes = explode ( '|' , $ meta -> phpType ) ; foreach ( $ phpTypes as $ phpType ) { switch ( $ phpType ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'DateTime' : continue ; default : return $ meta -> phpType !== '' ? new $ phpType ( ) : null ; } } return null ; } 
private function isSimplePhpType ( \ stdClass $ meta ) { $ phpTypes = explode ( '|' , $ meta -> phpType ) ; foreach ( $ phpTypes as $ phpType ) { switch ( $ phpType ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'DateTime' : continue ; default : return false ; } } return true ; } 
private function getValueToAssignToValue ( \ stdClass $ meta ) { if ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\Base64BinaryType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\BooleanType' , false ) ) { return strtolower ( $ meta -> strData ) === 'true' ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DecimalType' , false ) ) { return is_int ( 0 + $ meta -> strData ) ? ( integer ) $ meta -> strData : ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DoubleType' , false ) ) { return ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\IntegerType' , false ) ) { return ( integer ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\StringType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\TokenType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\URIType' , false ) ) { return $ meta -> strData ; } return $ meta -> strData ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Analytics \ Services \ AnalyticsService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
private static function determineActualValueToAssign ( $ propertyMeta , $ value ) { if ( $ propertyMeta -> repeatable && is_array ( $ value ) ) { $ values = [ ] ; foreach ( $ value as $ val ) { $ values [ ] = self :: actualValue ( $ propertyMeta , $ val ) ; } return $ values ; } return self :: actualValue ( $ propertyMeta , $ value ) ; } 
private static function actualValue ( \ stdClass $ propertyMeta , $ value ) { if ( is_object ( $ value ) ) { return $ value ; } $ types = explode ( '|' , $ propertyMeta -> phpType ) ; foreach ( $ types as $ type ) { switch ( $ type ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'any' : return $ value ; case 'DateTime' : return new \ DateTime ( $ value , new \ DateTimeZone ( 'UTC' ) ) ; } } $ object = new $ propertyMeta -> phpType ( ) ; self :: assignProperties ( $ object , $ value ) ; return $ object ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Inventory \ Services \ InventoryService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ ResolutionCaseManagement \ Services \ ResolutionCaseManagementService :: API_VERSION ] , 'authToken' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'globalId' => [ 'valid' => [ 'string' ] ] ] ; } 
public static function search ( $ expression , $ data ) { static $ runtime ; if ( ! $ runtime ) { $ runtime = Env :: createRuntime ( ) ; } return $ runtime ( $ expression , $ data ) ; } 
public static function createRuntime ( ) { switch ( $ compileDir = getenv ( self :: COMPILE_DIR ) ) { case false : return new AstRuntime ( ) ; case 'on' : return new CompilerRuntime ( ) ; default : return new CompilerRuntime ( $ compileDir ) ; } } 
public static function cleanCompileDir ( ) { $ total = 0 ; $ compileDir = getenv ( self :: COMPILE_DIR ) ? : sys_get_temp_dir ( ) ; foreach ( glob ( "{$compileDir}/jmespath_*.php" ) as $ file ) { $ total ++ ; unlink ( $ file ) ; } return $ total ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Catalog \ Services \ CatalogService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
public function visit ( array $ ast , $ fnName , $ expr ) { $ this -> vars = [ ] ; $ this -> source = $ this -> indentation = '' ; $ this -> write ( "<?php\n" ) -> write ( 'use DTS\\eBaySDK\\JmesPath\\TreeInterpreter as Ti;' ) -> write ( 'use DTS\\eBaySDK\\JmesPath\\FnDispatcher as Fn;' ) -> write ( 'use DTS\\eBaySDK\\JmesPath\\Utils;' ) -> write ( '' ) -> write ( 'function %s(Ti $interpreter, $value) {' , $ fnName ) -> indent ( ) -> dispatch ( $ ast ) -> write ( '' ) -> write ( 'return $value;' ) -> outdent ( ) -> write ( '}' ) ; return $ this -> source ; } 
private function makeVar ( $ prefix ) { if ( ! isset ( $ this -> vars [ $ prefix ] ) ) { $ this -> vars [ $ prefix ] = 0 ; return '$' . $ prefix ; } return '$' . $ prefix . ++ $ this -> vars [ $ prefix ] ; } 
private function write ( $ str ) { $ this -> source .= $ this -> indentation ; if ( func_num_args ( ) == 1 ) { $ this -> source .= $ str . "\n" ; return $ this ; } $ this -> source .= vsprintf ( $ str , array_slice ( func_get_args ( ) , 1 ) ) . "\n" ; return $ this ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ ReturnManagement \ Services \ ReturnManagementService :: API_VERSION ] , 'authToken' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'globalId' => [ 'valid' => [ 'string' ] ] ] ; } 
public static function getConfigDefinitions ( ) { return [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ OAuth \ Services \ OAuthService :: API_VERSION , 'required' => true ] , 'profile' => [ 'valid' => [ 'string' ] , 'fn' => 'DTS\eBaySDK\applyProfile' , ] , 'credentials' => [ 'valid' => [ 'DTS\eBaySDK\Credentials\CredentialsInterface' , 'array' , 'callable' ] , 'fn' => 'DTS\eBaySDK\applyCredentials' , 'default' => [ CredentialsProvider :: class , 'defaultProvider' ] ] , 'debug' => [ 'valid' => [ 'bool' , 'array' ] , 'fn' => 'DTS\eBaySDK\applyDebug' , 'default' => false ] , 'httpHandler' => [ 'valid' => [ 'callable' ] , 'default' => 'DTS\eBaySDK\defaultHttpHandler' ] , 'httpOptions' => [ 'valid' => [ 'array' ] , 'default' => [ 'http_errors' => false ] ] , 'ruName' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'sandbox' => [ 'valid' => [ 'bool' ] , 'default' => false ] ] ; } 
public function redirectUrlForUser ( array $ params ) { if ( ! array_key_exists ( 'state' , $ params ) ) { throw new \ InvalidArgumentException ( 'state parameter required' ) ; } if ( ! array_key_exists ( 'scope' , $ params ) ) { throw new \ InvalidArgumentException ( 'scope parameter required' ) ; } $ url = $ this -> getConfig ( 'sandbox' ) ? 'https://auth.sandbox.ebay.com/oauth2/authorize?' : 'https://auth.ebay.com/oauth2/authorize?' ; $ urlParams = [ 'client_id' => $ this -> getConfig ( 'credentials' ) -> getAppId ( ) , 'redirect_uri' => $ this -> getConfig ( 'ruName' ) , 'response_type' => 'code' , 'state' => $ params [ 'state' ] , 'scope' => implode ( $ params [ 'scope' ] , ' ' ) ] ; return $ url . http_build_query ( $ urlParams , null , '&' , PHP_QUERY_RFC3986 ) ; } 
private function callOperationAsync ( $ name , \ DTS \ eBaySDK \ Types \ BaseType $ request = null ) { $ operation = static :: $ operations [ $ name ] ; $ paramValues = [ ] ; $ requestValues = [ ] ; if ( $ request ) { $ requestArray = $ request -> toArray ( ) ; $ paramValues = array_intersect_key ( $ requestArray , $ operation [ 'params' ] ) ; $ requestValues = array_diff_key ( $ requestArray , $ operation [ 'params' ] ) ; } $ url = $ this -> uriResolver -> resolve ( $ this -> getUrl ( ) , $ this -> getConfig ( 'apiVersion' ) , $ operation [ 'resource' ] , $ operation [ 'params' ] , $ paramValues ) ; $ method = $ operation [ 'method' ] ; $ body = $ this -> buildRequestBody ( $ requestValues ) ; $ headers = $ this -> buildRequestHeaders ( $ body ) ; $ responseClass = $ operation [ 'responseClass' ] ; $ debug = $ this -> getConfig ( 'debug' ) ; $ httpHandler = $ this -> getConfig ( 'httpHandler' ) ; $ httpOptions = $ this -> getConfig ( 'httpOptions' ) ; if ( $ debug !== false ) { $ this -> debugRequest ( $ url , $ headers , $ body ) ; } $ request = new Request ( $ method , $ url , $ headers , $ body ) ; return $ httpHandler ( $ request , $ httpOptions ) -> then ( function ( ResponseInterface $ res ) use ( $ debug , $ responseClass ) { $ json = $ res -> getBody ( ) -> getContents ( ) ; if ( $ debug !== false ) { $ this -> debugResponse ( $ json ) ; } return new $ responseClass ( $ json !== '' ? json_decode ( $ json , true ) : [ ] , $ res -> getStatusCode ( ) , $ res -> getHeaders ( ) ) ; } ) ; } 
private function buildRequestBody ( array $ request ) { $ params = array_reduce ( array_keys ( $ request ) , function ( $ carry , $ key ) use ( $ request ) { $ value = $ request [ $ key ] ; $ carry [ $ key ] = is_array ( $ value ) ? implode ( ' ' , $ value ) : $ value ; return $ carry ; } , [ ] ) ; return empty ( $ request ) ? '' : http_build_query ( $ params , null , '&' , PHP_QUERY_RFC3986 ) ; } 
private function buildRequestHeaders ( $ body ) { $ credentials = $ this -> getConfig ( 'credentials' ) ; $ appId = $ credentials -> getAppId ( ) ; $ certId = $ credentials -> getCertId ( ) ; $ headers = [ ] ; $ headers [ 'Accept' ] = 'application/json' ; $ headers [ 'Authorization' ] = 'Basic ' . base64_encode ( $ appId . ':' . $ certId ) ; $ headers [ 'Content-Type' ] = 'application/x-www-form-urlencoded' ; $ headers [ 'Content-Length' ] = strlen ( $ body ) ; return $ headers ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ Fulfillment \ Services \ FulfillmentService :: API_VERSION , 'required' => true ] , 'authorization' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'marketplaceId' => [ 'valid' => [ 'string' ] ] ] ; } 
public static function getConfigDefinitions ( ) { $ definitions = parent :: getConfigDefinitions ( ) ; return $ definitions + [ 'apiVersion' => [ 'valid' => [ 'string' ] , 'default' => \ DTS \ eBaySDK \ RelatedItemsManagement \ Services \ RelatedItemsManagementService :: API_VERSION ] , 'authToken' => [ 'valid' => [ 'string' ] , 'required' => true ] , 'globalId' => [ 'valid' => [ 'string' ] ] ] ; } 
public function shopRates ( $ rateRequest ) { if ( $ rateRequest instanceof Shipment ) { $ shipment = $ rateRequest ; $ rateRequest = new RateRequest ( ) ; $ rateRequest -> setShipment ( $ shipment ) ; } $ this -> requestOption = 'Shop' ; return $ this -> sendRequest ( $ rateRequest ) ; } 
protected function sendRequest ( RateRequest $ rateRequest ) { $ request = $ this -> createRequest ( $ rateRequest ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ this -> compileEndpointUrl ( self :: ENDPOINT ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { return $ this -> formatResponse ( $ response ) ; } } 
private function createRequest ( RateRequest $ rateRequest ) { $ shipment = $ rateRequest -> getShipment ( ) ; $ document = $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'RatingServiceSelectionRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'Rate' ) ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestOption' , $ this -> requestOption ) ) ; $ trackRequest -> appendChild ( $ rateRequest -> getPickupType ( ) -> toNode ( $ document ) ) ; $ customerClassification = $ rateRequest -> getCustomerClassification ( ) ; if ( isset ( $ customerClassification ) ) { $ trackRequest -> appendChild ( $ customerClassification -> toNode ( $ document ) ) ; } $ shipmentNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Shipment' ) ) ; 
private function formatResponse ( SimpleXMLElement $ response ) { 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'CODAmount' ) ; if ( $ this -> CurrencyCode ) { $ node -> appendChild ( $ document -> createElement ( 'CurrencyCode' , $ this -> CurrencyCode ) ) ; } if ( $ this -> MonetaryValue ) { $ node -> appendChild ( $ document -> createElement ( 'MonetaryValue' , $ this -> MonetaryValue ) ) ; } return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'Locale' ) ; $ node -> appendChild ( $ document -> createElement ( 'Language' , $ this -> getLanguage ( ) ) ) ; $ node -> appendChild ( $ document -> createElement ( 'Dialect' , $ this -> getDialect ( ) ) ) ; return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ packageNode = $ document -> createElement ( 'Package' ) ; if ( $ this -> getDescription ( ) ) { $ packageNode -> appendChild ( $ document -> createElement ( 'Description' , $ this -> getDescription ( ) ) ) ; } $ packageNode -> appendChild ( $ this -> getPackagingType ( ) -> toNode ( $ document ) ) ; $ packageNode -> appendChild ( $ this -> getPackageWeight ( ) -> toNode ( $ document ) ) ; if ( null !== $ this -> getDimensions ( ) ) { $ packageNode -> appendChild ( $ this -> getDimensions ( ) -> toNode ( $ document ) ) ; } if ( $ this -> isLargePackage ( ) ) { $ packageNode -> appendChild ( $ document -> createElement ( 'LargePackageIndicator' ) ) ; } if ( $ this -> getAdditionalHandling ( ) ) { $ packageNode -> appendChild ( $ document -> createElement ( 'AdditionalHandling' ) ) ; } if ( $ this -> getPackageServiceOptions ( ) ) { $ packageNode -> appendChild ( $ this -> getPackageServiceOptions ( ) -> toNode ( $ document ) ) ; } if ( $ this -> getReferenceNumber ( ) && ! is_null ( $ this -> getReferenceNumber ( ) -> getCode ( ) ) && ! is_null ( $ this -> getReferenceNumber ( ) -> getValue ( ) ) ) { $ packageNode -> appendChild ( $ this -> getReferenceNumber ( ) -> toNode ( $ document ) ) ; } if ( $ this -> getReferenceNumber2 ( ) && ! is_null ( $ this -> getReferenceNumber2 ( ) -> getCode ( ) ) && ! is_null ( $ this -> getReferenceNumber2 ( ) -> getValue ( ) ) ) { $ packageNode -> appendChild ( $ this -> getReferenceNumber2 ( ) -> toNode ( $ document ) ) ; } return $ packageNode ; } 
protected function createAccess ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; 
protected function createTransactionNode ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trxRef = $ xml -> appendChild ( $ xml -> createElement ( 'TransactionReference' ) ) ; if ( null !== $ this -> context ) { $ trxRef -> appendChild ( $ xml -> createElement ( 'CustomerContext' , $ this -> context ) ) ; } return $ trxRef -> cloneNode ( true ) ; } 
protected function request ( $ access , $ request , $ endpointurl ) { $ requestInstance = new Request ( $ this -> logger ) ; $ response = $ requestInstance -> request ( $ access , $ request , $ endpointurl ) ; if ( $ response -> getResponse ( ) instanceof SimpleXMLElement ) { $ this -> response = $ response -> getResponse ( ) ; return $ response -> getResponse ( ) ; } throw new Exception ( 'Failure: Response is invalid.' ) ; } 
protected function compileEndpointUrl ( $ segment ) { $ base = ( $ this -> useIntegration ? $ this -> integrationBaseUrl : $ this -> productionBaseUrl ) ; return $ base . $ segment ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'PackageWeight' ) ; $ node -> appendChild ( $ document -> createElement ( 'Weight' , $ this -> getWeight ( ) ) ) ; $ node -> appendChild ( $ this -> getUnitOfMeasurement ( ) -> toNode ( $ document ) ) ; return $ node ; } 
public function setUnitOfMeasurement ( UnitOfMeasurement $ unitOfMeasurement ) { $ this -> UnitOfMeasurement = $ unitOfMeasurement ; $ this -> unitOfMeasurement = $ unitOfMeasurement ; return $ this ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'Pickup' ) ; $ node -> appendChild ( $ document -> createElement ( 'Date' , $ this -> getDate ( ) ) ) ; $ node -> appendChild ( $ document -> createElement ( 'Time' , $ this -> getTime ( ) ) ) ; return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'LocationSearchCriteria' ) ; if ( $ this -> getAccessPointSearch ( ) ) { $ node -> appendChild ( $ this -> getAccessPointSearch ( ) -> toNode ( $ document ) ) ; } if ( $ this -> getMaximumListSize ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'MaximumListSize' , $ this -> getMaximumListSize ( ) ) ) ; } return $ node ; } 
public function setMaximumListSize ( $ maximumListSize ) { $ maximumListSize = ( int ) $ maximumListSize ; if ( $ maximumListSize < 1 || $ maximumListSize > 50 ) { throw new BaseException ( 'Maximum list size: If present, indicates the maximum number of locations the client wishes to receive in response; ranges from 1 to 50 with a default value of 10' ) ; } $ this -> maximumListSize = $ maximumListSize ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'Dimensions' ) ; $ node -> appendChild ( $ document -> createElement ( 'Length' , $ this -> getLength ( ) ) ) ; $ node -> appendChild ( $ document -> createElement ( 'Height' , $ this -> getHeight ( ) ) ) ; $ node -> appendChild ( $ document -> createElement ( 'Width' , $ this -> getWidth ( ) ) ) ; $ node -> appendChild ( $ this -> getUnitOfMeasurement ( ) -> toNode ( $ document ) ) ; return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'PackageServiceOptions' ) ; if ( $ this -> getInsuredValue ( ) ) { $ node -> appendChild ( $ this -> getInsuredValue ( ) -> toNode ( $ document ) ) ; } foreach ( $ this -> getHazMat ( ) as $ hazmat ) { $ node -> appendChild ( $ hazmat -> toNode ( $ document ) ) ; } if ( $ this -> getHazMatPackageInformation ( ) !== null ) { $ node -> appendChild ( $ this -> getHazMatPackageInformation ( ) -> toNode ( $ document ) ) ; } if ( isset ( $ this -> deliveryConfirmation ) ) { $ node -> appendChild ( $ this -> deliveryConfirmation -> toNode ( $ document ) ) ; } if ( isset ( $ this -> ShipperReleaseIndicator ) ) { $ node -> appendChild ( $ document -> createElement ( 'ShipperReleaseIndicator' ) ) ; } return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'ShipperFiled' ) ; $ code = $ this -> getCode ( ) ; if ( isset ( $ code ) ) { $ node -> appendChild ( $ document -> createElement ( 'Code' , $ code ) ) ; } $ description = $ this -> getDescription ( ) ; if ( isset ( $ description ) ) { $ node -> appendChild ( $ document -> createElement ( 'Description' , $ description ) ) ; } $ preDepartureITNNumber = $ this -> getPreDepartureITNNumber ( ) ; if ( isset ( $ code ) ) { $ node -> appendChild ( $ document -> createElement ( 'PreDepartureITNNumber' , $ preDepartureITNNumber ) ) ; } $ exemptionLegend = $ this -> getExemptionLegend ( ) ; if ( isset ( $ exemptionLegend ) ) { $ node -> appendChild ( $ document -> createElement ( 'ExemptionLegend' , $ exemptionLegend ) ) ; } return $ node ; } 
public function confirm ( $ validation , Shipment $ shipment , ShipmentRequestLabelSpecification $ labelSpec = null , ShipmentRequestReceiptSpecification $ receiptSpec = null ) { $ request = $ this -> createConfirmRequest ( $ validation , $ shipment , $ labelSpec , $ receiptSpec ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ this -> compileEndpointUrl ( $ this -> shipConfirmEndpoint ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } if ( $ response instanceof SimpleXMLElement && $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { return $ this -> formatResponse ( $ response ) ; } } 
private function createConfirmRequest ( $ validation , Shipment $ shipment , ShipmentRequestLabelSpecification $ labelSpec = null , ShipmentRequestReceiptSpecification $ receiptSpec = null ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; 
public function accept ( $ shipmentDigest ) { $ request = $ this -> createAcceptRequest ( $ shipmentDigest ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ this -> compileEndpointUrl ( $ this -> shipAcceptEndpoint ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } if ( $ response instanceof SimpleXMLElement && $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { return $ this -> formatResponse ( $ response -> ShipmentResults ) ; } } 
private function createAcceptRequest ( $ shipmentDigest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'ShipmentAcceptRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'ShipAccept' ) ) ; $ container -> appendChild ( $ xml -> createElement ( 'ShipmentDigest' , $ shipmentDigest ) ) ; return $ xml -> saveXML ( ) ; } 
public function void ( $ shipmentData ) { if ( is_array ( $ shipmentData ) && ! isset ( $ shipmentData [ 'shipmentId' ] ) ) { throw new InvalidArgumentException ( '$shipmentData parameter is required to contain a key `shipmentId`.' ) ; } $ request = $ this -> createVoidRequest ( $ shipmentData ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ this -> compileEndpointUrl ( $ this -> voidEndpoint ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { unset ( $ response -> Response ) ; return $ this -> formatResponse ( $ response ) ; } } 
private function createVoidRequest ( $ shipmentData ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'VoidShipmentRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , '1' ) ) ; if ( is_string ( $ shipmentData ) ) { $ container -> appendChild ( $ xml -> createElement ( 'ShipmentIdentificationNumber' , strtoupper ( $ shipmentData ) ) ) ; } else { $ expanded = $ container -> appendChild ( $ xml -> createElement ( 'ExpandedVoidShipment' ) ) ; $ expanded -> appendChild ( $ xml -> createElement ( 'ShipmentIdentificationNumber' , strtoupper ( $ shipmentData [ 'shipmentId' ] ) ) ) ; if ( array_key_exists ( 'trackingNumbers' , $ shipmentData ) ) { foreach ( $ shipmentData [ 'trackingNumbers' ] as $ tn ) { $ expanded -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , strtoupper ( $ tn ) ) ) ; } } } return $ xml -> saveXML ( ) ; } 
public function recoverLabel ( $ trackingData , $ labelSpecification = null , $ labelDelivery = null , $ translate = null ) { if ( is_array ( $ trackingData ) ) { if ( ! isset ( $ trackingData [ 'value' ] ) ) { throw new InvalidArgumentException ( '$trackingData parameter is required to contain `value`.' ) ; } if ( ! isset ( $ trackingData [ 'shipperNumber' ] ) ) { throw new InvalidArgumentException ( '$trackingData parameter is required to contain `shipperNumber`.' ) ; } } if ( ! empty ( $ translate ) ) { if ( ! isset ( $ translateOpts [ 'language' ] ) ) { $ translateOpts [ 'language' ] = 'eng' ; } if ( ! isset ( $ translateOpts [ 'dialect' ] ) ) { $ translateOpts [ 'dialect' ] = 'US' ; } } $ request = $ this -> createRecoverLabelRequest ( $ trackingData , $ labelSpecification , $ labelDelivery , $ translate ) ; $ response = $ this -> request ( $ this -> createAccess ( ) , $ request , $ this -> compileEndpointUrl ( $ this -> recoverLabelEndpoint ) ) ; if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { unset ( $ response -> Response ) ; return $ this -> formatResponse ( $ response ) ; } } 
private function createRecoverLabelRequest ( $ trackingData , $ labelSpecificationOpts = null , $ labelDeliveryOpts = null , $ translateOpts = null ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; if ( is_string ( $ trackingData ) ) { $ container -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ trackingData ) ) ; } elseif ( is_array ( $ trackingData ) ) { $ referenceNumber = $ container -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumber -> appendChild ( $ xml -> createElement ( 'Value' , $ trackingData [ 'value' ] ) ) ; $ container -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ trackingData [ 'shipperNumber' ] ) ) ; } if ( ! empty ( $ labelSpecificationOpts ) ) { $ labelSpec = $ request -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelSpecificationOpts [ 'userAgent' ] ) ) { $ labelSpec -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelSpecificationOpts [ 'userAgent' ] ) ) ; } if ( isset ( $ labelSpecificationOpts [ 'imageFormat' ] ) ) { $ format = $ labelSpec -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ format -> appendChild ( $ xml -> createElement ( 'Code' , $ labelSpecificationOpts [ 'imageFormat' ] ) ) ; } } if ( ! empty ( $ labelDeliveryOpts ) ) { $ labelDelivery = $ request -> appendChild ( $ xml -> createElement ( 'LabelDelivery' ) ) ; $ labelDelivery -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' , $ labelDeliveryOpts [ 'link' ] ) ) ; } if ( ! empty ( $ translateOpts ) ) { $ translate = $ request -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ translateOpts [ 'language' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ translateOpts [ 'dialect' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'Code' , '01' ) ) ; } return $ xml -> saveXML ( ) ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'Product' ) ; for ( $ i = 1 ; $ i <= 3 ; $ i ++ ) { $ desc = $ this -> { 'getDescription' . $ i } ( ) ; if ( $ desc !== null ) { $ node -> appendChild ( $ document -> createElement ( 'Description' , $ desc ) ) ; } } if ( $ this -> getUnit ( ) !== null ) { $ node -> appendChild ( $ this -> getUnit ( ) -> toNode ( $ document ) ) ; } if ( $ this -> getCommodityCode ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'CommodityCode' , $ this -> getCommodityCode ( ) ) ) ; } if ( $ this -> getPartNumber ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'PartNumber' , $ this -> getPartNumber ( ) ) ) ; } if ( $ this -> getOriginCountryCode ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'OriginCountryCode' , $ this -> getOriginCountryCode ( ) ) ) ; } return $ node ; } 
public function setDescription1 ( $ description ) { if ( strlen ( $ description ) > 35 ) { $ description = substr ( $ description , 0 , 35 ) ; } $ this -> description1 = $ description ; return $ this ; } 
public function setDescription2 ( $ description ) { if ( strlen ( $ description ) > 35 ) { $ description = substr ( $ description , 0 , 35 ) ; } $ this -> description2 = $ description ; return $ this ; } 
public function setDescription3 ( $ description ) { if ( strlen ( $ description ) > 35 ) { $ description = substr ( $ description , 0 , 35 ) ; } $ this -> description3 = $ description ; return $ this ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'QueryRequest' ) ; if ( $ this -> getShipment ( ) !== null ) { $ node -> appendChild ( $ this -> getShipment ( ) -> toNode ( $ document ) ) ; } $ node -> appendChild ( $ document -> createElement ( 'SuppressQuestionIndicator' , ( $ this -> isSuppressQuestionIndicator ( ) ? 'Y' : 'N' ) ) ) ; return $ node ; } 
public function addPackage ( Package $ package ) { $ packages = $ this -> getPackages ( ) ; $ packages [ ] = $ package ; $ this -> setPackages ( $ packages ) ; return $ this ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'UPSFiled' ) ; $ poa = $ this -> getPOA ( ) ; if ( isset ( $ poa ) ) { $ node -> appendChild ( $ poa -> toNode ( $ document ) ) ; } return $ node ; } 
private function sendRequest ( $ labelRecoveryRequest ) { $ request = $ this -> createRequest ( $ labelRecoveryRequest ) ; $ response = $ this -> request ( $ this -> createAccess ( ) , $ request , $ this -> compileEndpointUrl ( self :: ENDPOINT ) ) ; if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { return $ this -> formatResponse ( $ response ) ; } } 
private function createRequest ( $ labelRecoveryRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; $ labelSpecificationNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelRecoveryRequest -> LabelSpecification ) ) { $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelRecoveryRequest -> LabelSpecification -> HTTPUserAgent ) ) ; $ labelImageFormatNode = $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ labelImageFormatNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> LabelSpecification -> LabelImageFormat -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> Translate ) ) { $ translateNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ labelRecoveryRequest -> Translate -> LanguageCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ labelRecoveryRequest -> Translate -> DialectCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> Translate -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> LabelLinkIndicator ) ) { $ labelLinkIndicatorNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; $ labelLinkIndicatorNode -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; } if ( isset ( $ labelRecoveryRequest -> TrackingNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ labelRecoveryRequest -> TrackingNumber ) ) ; } if ( isset ( $ labelRecoveryRequest -> ReferenceNumber ) ) { $ referenceNumberNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumberNode -> appendChild ( $ xml -> createElement ( 'Value' , $ labelRecoveryRequest -> ReferenceNumber -> getValue ( ) ) ) ; } if ( isset ( $ labelRecoveryRequest -> ShipperNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ labelRecoveryRequest -> ShipperNumber ) ) ; } return $ xml -> saveXML ( ) ; } 
private function formatResponse ( SimpleXMLElement $ response ) { 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'EMailMessage' ) ; foreach ( $ this -> getEmailAddresses ( ) as $ email ) { $ node -> appendChild ( $ document -> createElement ( 'EMailAddress' , $ email ) ) ; } if ( $ this -> getUndeliverableEmailAddress ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'UndeliverableEMailAddress' , $ this -> getUndeliverableEmailAddress ( ) ) ) ; } if ( $ this -> getFromEmailAddress ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'FromEMailAddress' , $ this -> getFromEmailAddress ( ) ) ) ; } if ( $ this -> getFromName ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'FromName' , $ this -> getFromName ( ) ) ) ; } if ( $ this -> getMemo ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'Memo' , $ this -> getMemo ( ) ) ) ; } if ( $ this -> getSubject ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'Subject' , $ this -> getSubject ( ) ) ) ; } if ( $ this -> getSubjectCode ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'SubjectCode' , $ this -> getSubjectCode ( ) ) ) ; } return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'POA' ) ; $ code = $ this -> getCode ( ) ; if ( isset ( $ code ) ) { $ node -> appendChild ( $ document -> createElement ( 'Code' , $ code ) ) ; } $ description = $ this -> getDescription ( ) ; if ( isset ( $ description ) ) { $ node -> appendChild ( $ document -> createElement ( 'Description' , $ description ) ) ; } return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'HazMatPackageInformation' ) ; if ( $ this -> isAllPackedInOneIndicator ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'AllPackedInOneIndicator' ) ) ; } if ( $ this -> isOverPackedIndicator ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'OverPackedIndicator' ) ) ; } if ( $ this -> getQValue ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'QValue' , $ this -> getQValue ( ) ) ) ; } return $ node ; } 
public function setMaximumListSize ( $ maximumListSize ) { $ maximumListSize = ( int ) $ maximumListSize ; if ( $ maximumListSize < 1 || $ maximumListSize > 50 ) { throw new \ Exception ( 'Maximum list size: If present, indicates the maximum number of locations the client wishes to receive in response; ranges from 1 to 50 with a default value of 10' ) ; } $ this -> maximumListSize = $ maximumListSize ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'EEIFilingOption' ) ; $ code = $ this -> getCode ( ) ; if ( isset ( $ code ) ) { $ node -> appendChild ( $ document -> createElement ( 'Code' , $ code ) ) ; } $ emailAddress = $ this -> getEmailAddress ( ) ; if ( isset ( $ emailAddress ) ) { $ node -> appendChild ( $ document -> createElement ( 'EMailAdress' , $ emailAddress ) ) ; } $ description = $ this -> getDescription ( ) ; if ( isset ( $ description ) ) { $ node -> appendChild ( $ document -> createElement ( 'Description' , $ description ) ) ; } $ upsFiled = $ this -> getUPSFiled ( ) ; if ( isset ( $ upsFiled ) ) { $ node -> appendChild ( $ upsFiled -> toNode ( $ document ) ) ; } $ shipperFiled = $ this -> getShipperFiled ( ) ; if ( isset ( $ shipperFiled ) ) { $ node -> appendChild ( $ shipperFiled -> toNode ( $ document ) ) ; } return $ node ; } 
public function validate ( Address $ address ) { $ this -> address = $ address ; $ access = $ this -> createAccess ( ) ; $ request = $ this -> createRequest ( ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ access , $ request , $ this -> compileEndpointUrl ( self :: ENDPOINT ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } if ( $ response instanceof SimpleXMLElement && $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } return $ this -> formatResponse ( $ response ) ; } 
private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ avRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AddressValidationRequest' ) ) ; $ avRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ avRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'AV' ) ) ; if ( null !== $ this -> address ) { $ addressNode = $ avRequest -> appendChild ( $ xml -> createElement ( 'Address' ) ) ; if ( $ this -> address -> getStateProvinceCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'StateProvinceCode' , $ this -> address -> getStateProvinceCode ( ) ) ) ; } if ( $ this -> address -> getCity ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'City' , $ this -> address -> getCity ( ) ) ) ; } if ( $ this -> address -> getCountryCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'CountryCode' , $ this -> address -> getCountryCode ( ) ) ) ; } if ( $ this -> address -> getPostalCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'PostalCode' , $ this -> address -> getPostalCode ( ) ) ) ; } } return $ xml -> saveXML ( ) ; } 
private function formatResponse ( SimpleXMLElement $ response ) { $ result = $ this -> convertXmlObject ( $ response ) ; if ( ! is_array ( $ result -> AddressValidationResult ) ) { return [ $ result -> AddressValidationResult ] ; } return $ result -> AddressValidationResult ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null !== $ document ) { $ node = $ document -> createElement ( 'UnitOfMeasure' ) ; $ node -> appendChild ( $ document -> createElement ( 'UnitCode' , $ this -> getCode ( ) ) ) ; if ( $ this -> getDescription ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'UnitDescription' , $ this -> getDescription ( ) ) ) ; } return $ node ; } return new DOMElement ( 'UnitOfMeasure' ) ; } 
public function getSubscription ( $ name = null , $ beginDateTime = null , $ endDateTime = null , $ fileName = null , $ bookmark = null ) { 
private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; 
private function formatResponse ( SimpleXMLElement $ response ) { $ eventsException = [ 'FileName' , 'StatusType' ] ; $ output = new ArrayObject ( ) ; 
public function request ( $ access , $ request , $ endpointurl , $ operation = null , $ wsdl = null ) { 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'TariffInfo' ) ; 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'AddressKeyFormat' ) ; if ( $ this -> getConsigneeName ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'ConsigneeName' , $ this -> getConsigneeName ( ) ) ) ; } for ( $ i = 1 ; $ i <= 3 ; $ i ++ ) { $ line = $ this -> { 'getAddressLine' . $ i } ( ) ; if ( $ line ) { $ node -> appendChild ( $ document -> createElement ( 'AddressLine' . ( $ i == 1 ? '' : $ i ) , $ line ) ) ; } } for ( $ i = 1 ; $ i <= 3 ; $ i ++ ) { $ line = $ this -> { 'getPoliticalDivision' . $ i } ( ) ; if ( $ line ) { $ node -> appendChild ( $ document -> createElement ( 'PoliticalDivision' . $ i , $ line ) ) ; } } if ( $ this -> getPostcodePrimaryLow ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'PostcodePrimaryLow' , $ this -> getPostcodePrimaryLow ( ) ) ) ; } if ( $ this -> getPostcodeExtendedLow ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'PostcodeExtendedLow' , $ this -> getPostcodeExtendedLow ( ) ) ) ; } if ( $ this -> getCountryCode ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'CountryCode' , $ this -> getCountryCode ( ) ) ) ; } if ( $ this -> getSingleLineAddress ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'SingleLineAddress' , $ this -> getSingleLineAddress ( ) ) ) ; } return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'FreightCharges' ) ; $ node -> appendChild ( $ document -> createElement ( 'MonetaryValue' , $ this -> getMonetaryValue ( ) ) ) ; return $ node ; } 
public function setMonetaryValue ( $ var ) { $ this -> monetaryValue = round ( $ var , 2 ) ; 
private function sendRequest ( TimeInTransitRequest $ timeInTransitRequest ) { $ request = $ this -> createRequest ( $ timeInTransitRequest ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ this -> compileEndpointUrl ( self :: ENDPOINT ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } if ( $ response instanceof SimpleXMLElement && $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { return $ this -> formatResponse ( $ response ) ; } } 
private function createRequest ( TimeInTransitRequest $ timeInTransitRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'TimeInTransitRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'TimeInTransit' ) ) ; $ transitFromNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'TransitFrom' ) ) ; $ address = $ timeInTransitRequest -> getTransitFrom ( ) ; if ( isset ( $ address ) ) { $ transitFromNode -> appendChild ( $ address -> toNode ( $ xml ) ) ; } $ transitToNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'TransitTo' ) ) ; $ address = $ timeInTransitRequest -> getTransitTo ( ) ; if ( isset ( $ address ) ) { $ transitToNode -> appendChild ( $ address -> toNode ( $ xml ) ) ; } $ weight = $ timeInTransitRequest -> getShipmentWeight ( ) ; if ( isset ( $ weight ) ) { $ trackRequest -> appendChild ( $ weight -> toNode ( $ xml ) ) ; } $ packages = $ timeInTransitRequest -> getTotalPackagesInShipment ( ) ; if ( isset ( $ packages ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TotalPackagesInShipment' , $ packages ) ) ; } $ invoiceLineTotal = $ timeInTransitRequest -> getInvoiceLineTotal ( ) ; if ( isset ( $ invoiceLineTotal ) ) { $ trackRequest -> appendChild ( $ invoiceLineTotal -> toNode ( $ xml ) ) ; } $ pickupDate = $ timeInTransitRequest -> getPickupDate ( ) ; if ( $ pickupDate ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'PickupDate' , $ pickupDate -> format ( 'Ymd' ) ) ) ; } $ indicator = $ timeInTransitRequest -> getDocumentsOnlyIndicator ( ) ; if ( $ indicator ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'DocumentsOnlyIndicator' ) ) ; } return $ xml -> saveXML ( ) ; } 
private function formatResponse ( SimpleXMLElement $ response ) { 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'Shipment' ) ; if ( $ this -> getFreightCharges ( ) instanceof FreightCharges ) { $ node -> appendChild ( $ this -> getFreightCharges ( ) -> toNode ( $ document ) ) ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'AddressArtifactFormat' ) ; for ( $ i = 1 ; $ i <= 3 ; $ i ++ ) { $ line = $ this -> { 'getPoliticalDivision' . $ i } ( ) ; if ( $ line ) { $ node -> appendChild ( $ document -> createElement ( 'PoliticalDivision' . $ i , $ line ) ) ; } } if ( $ this -> getCountryCode ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'CountryCode' , $ this -> getCountryCode ( ) ) ) ; } if ( $ this -> getCountry ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'Country' , $ this -> getCountry ( ) ) ) ; } if ( $ this -> getPostcodePrimaryHigh ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'PostcodePrimaryHigh' , $ this -> getPostcodePrimaryHigh ( ) ) ) ; } if ( $ this -> getPostcodePrimaryLow ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'PostcodePrimaryLow' , $ this -> getPostcodePrimaryLow ( ) ) ) ; } return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'RateInformation' ) ; if ( $ this -> getNegotiatedRatesIndicator ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'NegotiatedRatesIndicator' ) ) ; } if ( $ this -> getRateChartIndicator ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'RateChartIndicator' ) ) ; } return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'Product' ) ; 
public function noCandidates ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> NoCandidatesIndicator ) ; } 
public function isValid ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { return $ this -> response -> AddressClassification -> Code > 0 ; } return isset ( $ this -> response -> ValidAddressIndicator ) ; } 
public function isAmbiguous ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> AmbiguousAddressIndicator ) ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'ShipmentServiceOptions' ) ; if ( isset ( $ this -> DirectDeliveryOnlyIndicator ) ) { $ node -> appendChild ( $ document -> createElement ( 'DirectDeliveryOnlyIndicator' ) ) ; } if ( isset ( $ this -> DeliverToAddresseeOnlyIndicator ) ) { $ node -> appendChild ( $ document -> createElement ( 'DeliverToAddresseeOnlyIndicator' ) ) ; } if ( isset ( $ this -> SaturdayPickup ) ) { $ node -> appendChild ( $ document -> createElement ( 'SaturdayPickup' ) ) ; } if ( isset ( $ this -> SaturdayDelivery ) ) { $ node -> appendChild ( $ document -> createElement ( 'SaturdayDelivery' ) ) ; } if ( $ this -> getCOD ( ) ) { $ node -> appendChild ( $ this -> getCOD ( ) -> toNode ( $ document ) ) ; } if ( $ this -> getAccessPointCOD ( ) ) { $ node -> appendChild ( $ this -> getAccessPointCOD ( ) -> toNode ( $ document ) ) ; } if ( isset ( $ this -> internationalForms ) ) { $ node -> appendChild ( $ this -> internationalForms -> toNode ( $ document ) ) ; } if ( isset ( $ this -> deliveryConfirmation ) ) { $ node -> appendChild ( $ this -> deliveryConfirmation -> toNode ( $ document ) ) ; } if ( isset ( $ this -> importControlIndicator ) ) { $ node -> appendChild ( $ document -> createElement ( 'ImportControlIndicator' ) ) ; } if ( isset ( $ this -> labelMethod ) ) { $ node -> appendChild ( $ this -> labelMethod -> toNode ( $ document ) ) ; } if ( isset ( $ this -> labelDelivery ) ) { $ labelDeliveryNode = $ node -> appendChild ( $ document -> createElement ( 'LabelDelivery' ) ) ; $ emailMessageNode = $ labelDeliveryNode -> appendChild ( $ document -> createElement ( 'EMailMessage' ) ) ; $ labelDelivery = $ this -> getLabelDelivery ( ) ; foreach ( $ labelDelivery as $ key => $ value ) { if ( $ key == 'LabelLinkIndicator' ) { $ labelDeliveryNode -> appendChild ( $ document -> createElement ( $ key , $ value ) ) ; } elseif ( $ key == 'SubjectCode' ) { $ SubjectNode = $ emailMessageNode -> appendChild ( $ document -> createElement ( 'Subject' ) ) ; $ SubjectNode -> appendChild ( $ document -> createElement ( $ key , $ value ) ) ; } else { $ emailMessageNode -> appendChild ( $ document -> createElement ( $ key , $ value ) ) ; } } } if ( ! empty ( $ this -> notifications ) ) { foreach ( $ this -> notifications as $ notification ) { $ node -> appendChild ( $ notification -> toNode ( $ document ) ) ; } } return $ node ; } 
public function addNotification ( Notification $ notification ) { $ this -> notifications [ ] = $ notification ; if ( count ( $ this -> notifications ) > 3 ) { throw new \ Exception ( 'Maximum 3 notifications allowed' ) ; } return $ this ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'Weight' ) ; 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'AccessPointSearch' ) ; if ( $ this -> getAccessPointStatus ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'AccessPointStatus' , $ this -> getAccessPointStatus ( ) ) ) ; } if ( $ this -> getPublicAccessPointId ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'PublicAccessPointID' , $ this -> getPublicAccessPointId ( ) ) ) ; } if ( $ this -> getAccountNumber ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'AccountNumber' , $ this -> getAccountNumber ( ) ) ) ; } return $ node ; } 
public function request ( $ access , $ request , $ endpointurl ) { $ this -> setAccess ( $ access ) ; $ this -> setRequest ( $ request ) ; $ this -> setEndpointUrl ( $ endpointurl ) ; 
private function createRequestLandedCost ( LandedCostRequest $ landedCostRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ tradeabilityRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LandedCostRequest' ) ) ; $ tradeabilityRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ tradeabilityRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LandedCost' ) ) ; if ( $ landedCostRequest -> getQueryRequest ( ) !== null ) { $ tradeabilityRequest -> appendChild ( $ landedCostRequest -> getQueryRequest ( ) -> toNode ( $ xml ) ) ; } return $ xml -> saveXML ( ) ; } 
private function sendRequest ( $ request , $ endpoint , $ operation , $ wsdl ) { $ endpointurl = $ this -> compileEndpointUrl ( $ endpoint ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ endpointurl , $ operation , $ wsdl ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } return $ this -> formatResponse ( $ response ) ; } 
public function validate ( Address $ address , $ requestOption = self :: REQUEST_OPTION_ADDRESS_VALIDATION , $ maxSuggestion = 15 ) { if ( $ maxSuggestion > 50 ) { throw new \ Exception ( 'Maximum of 50 suggestions allowed' ) ; } if ( ! in_array ( $ requestOption , range ( 1 , 3 ) ) ) { throw new \ Exception ( 'Invalid request option supplied' ) ; } $ this -> address = $ address ; $ this -> requestOption = $ requestOption ; $ this -> maxSuggestion = $ maxSuggestion ; $ access = $ this -> createAccess ( ) ; $ request = $ this -> createRequest ( ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ access , $ request , $ this -> compileEndpointUrl ( self :: ENDPOINT ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } if ( $ response instanceof SimpleXMLElement && $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } if ( $ this -> useAVResponseObject ) { unset ( $ response -> Response ) ; $ avResponse = new AddressValidationResponse ( $ response , $ requestOption ) ; return $ avResponse ; } return $ this -> formatResponse ( $ response ) ; } 
private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ avRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AddressValidationRequest' ) ) ; $ avRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ avRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'XAV' ) ) ; if ( null !== $ this -> requestOption ) { $ request -> appendChild ( $ xml -> createElement ( 'RequestOption' , $ this -> requestOption ) ) ; } if ( null !== $ this -> maxSuggestion ) { $ avRequest -> appendChild ( $ xml -> createElement ( 'MaximumListSize' , $ this -> maxSuggestion ) ) ; } if ( null !== $ this -> address ) { $ addressNode = $ avRequest -> appendChild ( $ xml -> createElement ( 'AddressKeyFormat' ) ) ; if ( $ this -> address -> getAttentionName ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'ConsigneeName' , $ this -> address -> getAttentionName ( ) ) ) ; } if ( $ this -> address -> getBuildingName ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'BuildingName' , $ this -> address -> getBuildingName ( ) ) ) ; } if ( $ this -> address -> getAddressLine1 ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'AddressLine' , $ this -> address -> getAddressLine1 ( ) ) ) ; } if ( $ this -> address -> getAddressLine2 ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'AddressLine' , $ this -> address -> getAddressLine2 ( ) ) ) ; } if ( $ this -> address -> getAddressLine3 ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'AddressLine' , $ this -> address -> getAddressLine3 ( ) ) ) ; } if ( $ this -> address -> getStateProvinceCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'PoliticalDivision1' , $ this -> address -> getStateProvinceCode ( ) ) ) ; } if ( $ this -> address -> getCity ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'PoliticalDivision2' , $ this -> address -> getCity ( ) ) ) ; } if ( $ this -> address -> getCountryCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'CountryCode' , $ this -> address -> getCountryCode ( ) ) ) ; } if ( $ this -> address -> getPostalCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'PostcodePrimaryLow' , $ this -> address -> getPostalCode ( ) ) ) ; } } return $ xml -> saveXML ( ) ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'ShipFrom' ) ; if ( $ this -> getCompanyName ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'CompanyName' , $ this -> getCompanyName ( ) ) ) ; } if ( $ this -> getAttentionName ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'AttentionName' , $ this -> getAttentionName ( ) ) ) ; } $ address = $ this -> getAddress ( ) ; if ( isset ( $ address ) ) { $ node -> appendChild ( $ address -> toNode ( $ document ) ) ; } return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'AlternateDeliveryAddress' ) ; if ( $ this -> getName ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'Name' , $ this -> getName ( ) ) ) ; } if ( $ this -> getUpsAccessPointId ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'UPSAccessPointID' , $ this -> getUpsAccessPointId ( ) ) ) ; } $ address = $ this -> getAddress ( ) ; if ( isset ( $ address ) ) { $ node -> appendChild ( $ address -> toNode ( $ document ) ) ; } return $ node ; } 
public function track ( $ trackingNumber , $ requestOption = 'activity' ) { $ this -> trackingNumber = $ trackingNumber ; $ this -> requestOption = $ requestOption ; return $ this -> getFormattedResponse ( ) ; } 
public function trackByReference ( $ referenceNumber , $ requestOption = 'activity' ) { $ this -> referenceNumber = $ referenceNumber ; $ this -> requestOption = $ requestOption ; return $ this -> getFormattedResponse ( ) ; } 
private function isMailInnovations ( ) { $ patterns = [ 
private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'TrackRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'Track' ) ) ; if ( null !== $ this -> requestOption ) { $ request -> appendChild ( $ xml -> createElement ( 'RequestOption' , $ this -> requestOption ) ) ; } if ( null !== $ this -> trackingNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ this -> trackingNumber ) ) ; } if ( $ this -> isMailInnovations ( ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'IncludeMailInnovationIndicator' ) ) ; } if ( null !== $ this -> referenceNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) -> appendChild ( $ xml -> createElement ( 'Value' , $ this -> referenceNumber ) ) ; } if ( null !== $ this -> shipperNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ this -> shipperNumber ) ) ; } if ( null !== $ this -> beginDate || null !== $ this -> endDate ) { $ DateRange = $ xml -> createElement ( 'PickupDateRange' ) ; if ( null !== $ this -> beginDate ) { $ beginDate = $ this -> beginDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'BeginDate' , $ beginDate ) ) ; } if ( null !== $ this -> endDate ) { $ endDate = $ this -> endDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'EndDate' , $ endDate ) ) ; } $ trackRequest -> appendChild ( $ DateRange ) ; } return $ xml -> saveXML ( ) ; } 
private function formatResponse ( SimpleXMLElement $ response ) { if ( $ this -> allowMultipleShipments ) { $ response = $ this -> convertXmlObject ( $ response ) ; if ( ! is_array ( $ response -> Shipment ) ) { $ response -> Shipment = [ $ response -> Shipment ] ; } return $ response ; } return $ this -> convertXmlObject ( $ response -> Shipment ) ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'DeliveryTimeInformation' ) ; $ node -> appendChild ( $ document -> createElement ( 'PackageBillType' , $ this -> getPackageBillType ( ) ) ) ; if ( $ this -> getPickup ( ) !== null ) { $ node -> appendChild ( $ this -> getPickup ( ) -> toNode ( $ document ) ) ; } return $ node ; } 
public static function addAddressNode ( & $ address , DOMNode $ element ) { $ node = $ element -> appendChild ( $ element -> ownerDocument -> createElement ( 'Address' ) ) ; self :: appendChild ( $ address , 'AddressLine1' , $ node ) ; self :: appendChild ( $ address , 'AddressLine2' , $ node ) ; self :: appendChild ( $ address , 'AddressLine3' , $ node ) ; self :: appendChild ( $ address , 'City' , $ node ) ; self :: appendChild ( $ address , 'StateProvinceCode' , $ node ) ; self :: appendChild ( $ address , 'PostalCode' , $ node ) ; self :: appendChild ( $ address , 'CountryCode' , $ node ) ; } 
public static function addAddressArtifactNode ( & $ address , DOMNode $ element ) { $ node = $ element -> appendChild ( $ element -> ownerDocument -> createElement ( 'AddressArtifactFormat' ) ) ; self :: appendChild ( $ address , 'CountryCode' , $ node ) ; self :: appendChild ( $ address , 'PoliticalDivision1' , $ node ) ; self :: appendChild ( $ address , 'PoliticalDivision2' , $ node ) ; self :: appendChild ( $ address , 'PostcodePrimaryLow' , $ node ) ; } 
public static function addLocationInformation ( stdClass $ location , DOMNode $ locationNode ) { self :: appendChild ( $ location , 'CompanyName' , $ locationNode ) ; self :: appendChild ( $ location , 'AttentionName' , $ locationNode ) ; if ( isset ( $ location -> Address ) ) { self :: addAddressNode ( $ location -> Address , $ locationNode ) ; } } 
public static function addPackages ( stdClass $ shipment , DOMNode $ node ) { foreach ( $ shipment -> Package as $ package ) { $ packageNode = $ node -> appendChild ( $ node -> ownerDocument -> createElement ( 'Package' ) ) ; if ( isset ( $ package -> PackagingType ) ) { $ packagingType = $ packageNode -> appendChild ( $ node -> ownerDocument -> createElement ( 'PackagingType' ) ) ; self :: appendChild ( $ package -> PackagingType , 'Code' , $ packagingType ) ; self :: appendChild ( $ package -> PackagingType , 'Description' , $ packagingType ) ; } $ pwNode = $ packageNode -> appendChild ( $ node -> ownerDocument -> createElement ( 'PackageWeight' ) ) ; if ( isset ( $ package -> PackageWeight ) ) { self :: appendChild ( $ package -> PackageWeight , 'Weight' , $ pwNode ) ; if ( isset ( $ package -> PackageWeight -> UnitOfMeasurement ) ) { 
public static function appendChild ( stdClass $ object , $ propertyName , DOMNode $ node ) { if ( isset ( $ object -> { $ propertyName } ) ) { $ node -> appendChild ( $ node -> ownerDocument -> createElement ( $ propertyName , $ object -> { $ propertyName } ) ) ; } } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'Address' ) ; if ( $ this -> getAddressLine1 ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'AddressLine1' , $ this -> getAddressLine1 ( ) ) ) ; } if ( $ this -> getAddressLine2 ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'AddressLine2' , $ this -> getAddressLine2 ( ) ) ) ; } if ( $ this -> getAddressLine3 ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'AddressLine3' , $ this -> getAddressLine3 ( ) ) ) ; } if ( $ this -> getCity ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'City' , $ this -> getCity ( ) ) ) ; } if ( $ this -> getStateProvinceCode ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'StateProvinceCode' , $ this -> getStateProvinceCode ( ) ) ) ; } if ( $ this -> getPostalCode ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'PostalCode' , $ this -> getPostalCode ( ) ) ) ; } if ( $ this -> getCountryCode ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'CountryCode' , $ this -> getCountryCode ( ) ) ) ; } if ( $ this -> getResidentialAddressIndicator ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'ResidentialAddressIndicator' ) ) ; } return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'Notification' ) ; $ node -> appendChild ( $ document -> createElement ( 'NotificationCode' , $ this -> getNotificationCode ( ) ) ) ; if ( $ this -> getEmailMessage ( ) !== null ) { $ node -> appendChild ( $ this -> emailMessage -> toNode ( $ document ) ) ; } if ( $ this -> getLocale ( ) !== null ) { $ node -> appendChild ( $ this -> locale -> toNode ( $ document ) ) ; } return $ node ; } 
public function setPickupType ( PickupType $ pickupType ) { $ this -> PickupType = $ pickupType ; $ this -> pickupType = $ pickupType ; return $ this ; } 
public function setShipment ( Shipment $ shipment ) { $ this -> Shipment = $ shipment ; $ this -> shipment = $ shipment ; return $ this ; } 
public function setAddress ( Address $ address ) { $ this -> Address = $ address ; $ this -> address = $ address ; return $ this ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'ReferenceNumber' ) ; if ( $ this -> getBarCodeIndicator ( ) ) { $ node -> appendChild ( $ document -> createElement ( 'BarCodeIndicator' ) ) ; } $ node -> appendChild ( $ document -> createElement ( 'Code' , $ this -> getCode ( ) ) ) ; $ node -> appendChild ( $ document -> createElement ( 'Value' , $ this -> getValue ( ) ) ) ; return $ node ; } 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'Shipper' ) ; $ shipperName = $ this -> getName ( ) ; if ( isset ( $ shipperName ) ) { $ node -> appendChild ( $ document -> createElement ( 'Name' , $ shipperName ) ) ; } $ shipperNumber = $ this -> getShipperNumber ( ) ; if ( isset ( $ shipperNumber ) ) { $ node -> appendChild ( $ document -> createElement ( 'ShipperNumber' , $ shipperNumber ) ) ; } $ address = $ this -> getAddress ( ) ; if ( isset ( $ address ) ) { $ node -> appendChild ( $ address -> toNode ( $ document ) ) ; } return $ node ; } 
private function createRequest ( LocatorRequest $ locatorRequest , $ requestOption ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LocatorRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'Locator' ) ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestOption' , $ requestOption ) ) ; 
public function toNode ( DOMDocument $ document = null ) { if ( null === $ document ) { $ document = new DOMDocument ( ) ; } $ node = $ document -> createElement ( 'InternationalForms' ) ; foreach ( $ this -> getTypes ( ) as $ type ) { $ node -> appendChild ( $ document -> createElement ( 'FormType' , $ type ) ) ; } if ( $ this -> getInvoiceNumber ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'InvoiceNumber' , $ this -> getInvoiceNumber ( ) ) ) ; } if ( $ this -> getInvoiceDate ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'InvoiceDate' , $ this -> getInvoiceDate ( ) -> format ( 'Ymd' ) ) ) ; } if ( $ this -> getPurchaseOrderNumber ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'PurchaseOrderNumber' , $ this -> getPurchaseOrderNumber ( ) ) ) ; } if ( $ this -> getTermsOfShipment ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'TermsOfShipment' , $ this -> getTermsOfShipment ( ) ) ) ; } if ( $ this -> getReasonForExport ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'ReasonForExport' , $ this -> getReasonForExport ( ) ) ) ; } if ( $ this -> getComments ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'Comments' , $ this -> getComments ( ) ) ) ; } if ( $ this -> getDeclarationStatement ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'DeclarationStatement' , $ this -> getDeclarationStatement ( ) ) ) ; } if ( $ this -> getCurrencyCode ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'CurrencyCode' , $ this -> getCurrencyCode ( ) ) ) ; } if ( $ this -> getDiscount ( ) !== null ) { $ node -> appendChild ( $ this -> getDiscount ( ) -> toNode ( $ document ) ) ; } if ( $ this -> getFreightCharges ( ) !== null ) { $ node -> appendChild ( $ this -> getFreightCharges ( ) -> toNode ( $ document ) ) ; } if ( $ this -> getAdditionalDocumentIndicator ( ) !== null ) { $ node -> appendChild ( $ document -> createElement ( 'AdditionalDocumentIndicator' ) ) ; } if ( $ this -> getEEIFilingOption ( ) !== null ) { $ node -> appendChild ( $ this -> getEEIFilingOption ( ) -> toNode ( $ document ) ) ; } foreach ( $ this -> products as $ product ) { $ node -> appendChild ( $ product -> toNode ( $ document ) ) ; } return $ node ; } 
public function setReasonForExport ( $ reason ) { if ( strlen ( $ reason ) > 20 ) { $ reason = substr ( $ reason , 0 , 20 ) ; } $ this -> reasonForExport = $ reason ; return $ this ; } 
public function setComments ( $ comments ) { if ( strlen ( $ comments ) > 150 ) { $ comments = substr ( $ comments , 0 , 150 ) ; } $ this -> comments = $ comments ; return $ this ; } 
public function setValue ( $ value ) { $ this -> value = number_format ( $ value , 6 , '.' , '' ) ; if ( strlen ( ( string ) $ this -> value ) > 19 ) { throw new \ Exception ( 'Value too long' ) ; } return $ this ; } 
protected function warmUp ( string $ key , string $ type ) { $ currentlyWarmingUp = isset ( $ this -> warmupStack [ $ key ] ) ; $ alreadyWarmedUp = isset ( $ this -> resources [ $ key ] ) ; $ shouldWarmUp = \ in_array ( $ type , $ this -> warmupTypes , true ) ; if ( $ currentlyWarmingUp || $ alreadyWarmedUp || ! $ shouldWarmUp ) { return ; } $ item = $ this -> cacheItemPool -> getItem ( $ key ) ; if ( $ item -> isHit ( ) ) { $ this -> warmupStack [ $ key ] = true ; $ resource = $ this -> client -> parseJson ( $ item -> get ( ) ) ; $ this -> resources [ $ key ] = $ resource ; unset ( $ this -> warmupStack [ $ key ] ) ; } } 
public function save ( ResourceInterface $ resource ) : bool { if ( ! parent :: save ( $ resource ) ) { return false ; } $ key = $ this -> generateKey ( $ resource -> getType ( ) , $ resource -> getId ( ) , [ 'locale' => $ this -> getResourceLocale ( $ resource ) ] ) ; if ( $ this -> autoWarmup && \ in_array ( $ resource -> getType ( ) , $ this -> warmupTypes , true ) ) { $ cacheItem = $ this -> cacheItemPool -> getItem ( $ key ) ; if ( ! $ cacheItem -> isHit ( ) ) { $ cacheItem -> set ( guzzle_json_encode ( $ resource ) ) ; $ this -> cacheItemPool -> save ( $ cacheItem ) ; } } return true ; } 
public function decode ( string $ json ) : array { $ data = guzzle_json_decode ( $ json , true ) ; $ spaceId = $ this -> extractSpaceId ( $ data ) ; $ environmentId = $ this -> extractEnvironmentId ( $ data ) ; if ( $ spaceId !== $ this -> spaceId || $ environmentId !== $ this -> environmentId ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to parse and build a JSON structure with a client configured for handling space "%s" and environment "%s", but space "%s" and environment "%s" were detected.' , $ this -> spaceId , $ this -> environmentId , $ spaceId , $ environmentId ) ) ; } return $ data ; } 
private function extractSpaceId ( array $ data ) : string { 
public function extractEnvironmentId ( array $ data ) : string { 
public function jsonSerialize ( ) : array { $ locale = [ 'sys' => $ this -> sys , 'code' => $ this -> code , 'default' => $ this -> default , 'name' => $ this -> name , 'fallbackCode' => $ this -> fallbackCode , ] ; return $ locale ; } 
public function jsonSerialize ( ) : array { return \ array_filter ( \ array_merge ( parent :: jsonSerialize ( ) , $ this -> jsonSerializeEdited ( ) , $ this -> jsonSerializeEnvironment ( ) , $ this -> jsonSerializeSpace ( ) ) ) ; } 
protected function getLocaleFromInput ( $ input = null ) : string { if ( $ input instanceof Locale ) { $ input = $ input -> getCode ( ) ; } if ( null === $ input ) { return $ this -> localeCode ; } if ( $ this -> sys -> getLocale ( ) && $ input !== $ this -> sys -> getLocale ( ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Entry with ID "%s" was built using locale "%s", but now access using locale "%s" is being attempted.' , $ this -> sys -> getId ( ) , $ this -> sys -> getLocale ( ) , $ input ) ) ; } if ( ! \ in_array ( $ input , $ this -> localeCodes , true ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to use invalid locale "%s", available locales are "%s".' , $ input , \ implode ( ', ' , $ this -> localeCodes ) ) ) ; } return $ input ; } 
protected function walkFallbackChain ( array $ valueMap , string $ localeCode , Environment $ environment ) { $ loopCounter = 0 ; while ( ! isset ( $ valueMap [ $ localeCode ] ) ) { $ localeCode = $ environment -> getLocale ( $ localeCode ) -> getFallbackCode ( ) ; if ( null === $ localeCode ) { 
public function jsonSerialize ( ) : array { $ field = [ 'id' => $ this -> id , 'name' => $ this -> name , 'type' => $ this -> type , 'required' => $ this -> required , 'localized' => $ this -> localized , ] ; if ( $ this -> disabled ) { $ field [ 'disabled' ] = true ; } if ( null !== $ this -> linkType ) { $ field [ 'linkType' ] = $ this -> linkType ; } if ( 'Array' === $ this -> type ) { $ field [ 'items' ] = [ 'type' => $ this -> itemsType , ] ; if ( 'Link' === $ this -> itemsType ) { $ field [ 'items' ] [ 'linkType' ] = $ this -> itemsLinkType ; } } return $ field ; } 
public function map ( $ resource , array $ data ) : ResourceClass { $ sys = $ this -> createSystemProperties ( SystemProperties :: class , $ data ) ; $ locale = $ sys -> getLocale ( ) ; $ asset = $ this -> hydrator -> hydrate ( $ resource ? : ResourceClass :: class , [ 'sys' => $ sys , 'title' => isset ( $ data [ 'fields' ] [ 'title' ] ) ? $ this -> normalizeFieldData ( $ data [ 'fields' ] [ 'title' ] , $ locale ) : null , 'description' => isset ( $ data [ 'fields' ] [ 'description' ] ) ? $ this -> normalizeFieldData ( $ data [ 'fields' ] [ 'description' ] , $ locale ) : null , 'file' => isset ( $ data [ 'fields' ] [ 'file' ] ) ? \ array_map ( [ $ this , 'buildFile' ] , $ this -> normalizeFieldData ( $ data [ 'fields' ] [ 'file' ] , $ locale ) ) : null , ] ) ; $ asset -> initLocales ( $ asset -> getSystemProperties ( ) -> getEnvironment ( ) -> getLocales ( ) ) ; return $ asset ; } 
protected function buildFile ( array $ data ) : FileInterface { if ( isset ( $ data [ 'uploadFrom' ] ) ) { return new LocalUploadFile ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , new Link ( $ data [ 'uploadFrom' ] [ 'sys' ] [ 'id' ] , $ data [ 'uploadFrom' ] [ 'sys' ] [ 'linkType' ] ) ) ; } if ( isset ( $ data [ 'upload' ] ) ) { return new RemoteUploadFile ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , $ data [ 'upload' ] ) ; } if ( isset ( $ data [ 'details' ] [ 'image' ] ) ) { return new ImageFile ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , $ data [ 'url' ] , $ data [ 'details' ] [ 'size' ] , $ data [ 'details' ] [ 'image' ] [ 'width' ] , $ data [ 'details' ] [ 'image' ] [ 'height' ] ) ; } return new File ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , $ data [ 'url' ] , $ data [ 'details' ] [ 'size' ] ) ; } 
protected function configure ( ) { $ this -> setName ( $ this -> getCommandName ( ) ) -> setDefinition ( [ new InputOption ( 'access-token' , 't' , InputOption :: VALUE_REQUIRED , 'Token to access the space.' ) , new InputOption ( 'space-id' , 's' , InputOption :: VALUE_REQUIRED , 'ID of the space to use.' ) , new InputOption ( 'environment-id' , 'e' , InputOption :: VALUE_REQUIRED , 'ID of the environment to use' , 'master' ) , new InputOption ( 'factory-class' , 'f' , InputOption :: VALUE_REQUIRED , \ sprintf ( 'The FQCN of a factory class which implements "%s".' , CacheItemPoolFactoryInterface :: class ) ) , new InputOption ( 'use-preview' , 'p' , InputOption :: VALUE_NONE , 'Use the Preview API instead of the Delivery API' ) , new InputOption ( 'cache-content' , 'c' , InputOption :: VALUE_NONE , 'Include entries and assets' ) , ] ) ; } 
private function getCacheItemPool ( InputInterface $ input , ClientInterface $ client ) : CacheItemPoolInterface { $ factoryClass = $ input -> getOption ( 'factory-class' ) ; $ cacheItemPoolFactory = new $ factoryClass ( ) ; if ( ! $ cacheItemPoolFactory instanceof CacheItemPoolFactoryInterface ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Cache item pool factory must implement "%s".' , CacheItemPoolFactoryInterface :: class ) ) ; } return $ cacheItemPoolFactory -> getCacheItemPool ( $ client -> getApi ( ) , $ client -> getSpaceId ( ) , $ client -> getEnvironmentId ( ) ) ; } 
public function map ( $ resource , array $ data ) : ResourceClass { $ fields = [ ] ; foreach ( $ data [ 'fields' ] as $ field ) { $ field = $ this -> mapField ( $ field ) ; $ fields [ $ field -> getId ( ) ] = $ field ; } $ contentType = $ this -> hydrator -> hydrate ( $ resource ? : ResourceClass :: class , [ 'sys' => $ this -> createSystemProperties ( SystemProperties :: class , $ data ) , 'name' => $ data [ 'name' ] , 'displayField' => $ data [ 'displayField' ] ?? null , 'description' => $ data [ 'description' ] ?? null , 'fields' => $ fields , ] ) ; return $ contentType ; } 
protected function mapField ( array $ data ) : ResourceContentTypeField { $ field = $ this -> hydrator -> hydrate ( ResourceContentTypeField :: class , [ 'id' => $ data [ 'id' ] , 'name' => $ data [ 'name' ] , 'type' => $ data [ 'type' ] , 'linkType' => $ data [ 'linkType' ] ?? null , 'itemsType' => isset ( $ data [ 'items' ] ) && isset ( $ data [ 'items' ] [ 'type' ] ) ? $ data [ 'items' ] [ 'type' ] : null , 'itemsLinkType' => isset ( $ data [ 'items' ] ) && isset ( $ data [ 'items' ] [ 'linkType' ] ) ? $ data [ 'items' ] [ 'linkType' ] : null , 'required' => $ data [ 'required' ] ?? false , 'localized' => $ data [ 'localized' ] ?? false , 'disabled' => $ data [ 'disabled' ] ?? false , ] ) ; return $ field ; } 
public function getField ( string $ fieldId , bool $ tryCaseInsensitive = false ) { if ( isset ( $ this -> fields [ $ fieldId ] ) ) { return $ this -> fields [ $ fieldId ] ; } if ( $ tryCaseInsensitive ) { foreach ( $ this -> fields as $ name => $ field ) { if ( \ mb_strtolower ( $ name ) === \ mb_strtolower ( $ fieldId ) ) { return $ field ; } } } return null ; } 
public function addUnknownField ( string $ name ) : Field { $ this -> fields [ $ name ] = new Field ( $ name , $ name , 'Unknown' ) ; return $ this -> fields [ $ name ] ; } 
public function jsonSerialize ( ) : array { return [ 'sys' => $ this -> sys , 'name' => $ this -> name , 'description' => $ this -> description , 'displayField' => $ this -> displayField , 'fields' => \ array_values ( $ this -> fields ) , ] ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ this -> initClient ( $ input ) ; $ cacheContent = ( bool ) $ input -> getOption ( 'cache-content' ) ; $ warmer = new CacheClearer ( $ this -> client , $ this -> resourcePool , $ this -> cacheItemPool ) ; if ( ! $ warmer -> clear ( $ cacheContent ) ) { throw new \ RuntimeException ( \ sprintf ( 'The SDK could not clear the cache. Try checking your PSR-6 implementation (class "%s").' , \ get_class ( $ this -> cacheItemPool ) ) ) ; } $ output -> writeln ( \ sprintf ( '<info>Cache cleared for space "%s" on environment "%s" using API "%s".</info>' , $ this -> client -> getSpaceId ( ) , $ this -> client -> getEnvironmentId ( ) , $ this -> client -> getApi ( ) ) ) ; } 
public function resolveLink ( Link $ link , array $ parameters = [ ] ) : ResourceInterface { $ locale = $ parameters [ 'locale' ] ?? null ; switch ( $ link -> getLinkType ( ) ) { case 'Asset' : return $ this -> client -> getAsset ( $ link -> getId ( ) , $ locale ) ; case 'ContentType' : return $ this -> client -> getContentType ( $ link -> getId ( ) ) ; case 'Entry' : return $ this -> client -> getEntry ( $ link -> getId ( ) , $ locale ) ; case 'Environment' : return $ this -> client -> getEnvironment ( ) ; case 'Space' : return $ this -> client -> getSpace ( ) ; default : throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to resolve link for unknown type "%s".' , $ link -> getLinkType ( ) ) ) ; } } 
public function resolveLinkCollection ( array $ links , array $ parameters = [ ] ) : array { $ locale = $ parameters [ 'locale' ] ?? null ; 
private function resolveLinksForResourceType ( string $ type , array $ links , string $ locale = null ) : array { $ resourceIds = \ array_map ( function ( Link $ link ) : string { return $ link -> getId ( ) ; } , \ array_filter ( $ links , function ( Link $ link ) use ( $ type ) : bool { return $ link -> getLinkType ( ) === $ type ; } ) ) ; $ resources = [ ] ; $ collection = $ this -> fetchResourcesForGivenIds ( $ resourceIds , $ type , $ locale ) ; foreach ( $ collection as $ resource ) { $ resources [ $ type . '.' . $ resource -> getId ( ) ] = $ resource ; } return $ resources ; } 
private function fetchResourcesForGivenIds ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ resources = [ ] ; $ resourcePoolOptions = [ 'locale' => $ locale ] ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( $ this -> resourcePool -> has ( $ type , $ resourceId , $ resourcePoolOptions ) ) { $ resources [ ] = $ this -> resourcePool -> get ( $ type , $ resourceId , $ resourcePoolOptions ) ; unset ( $ resourceIds [ $ index ] ) ; } } foreach ( $ this -> createIdChunks ( $ resourceIds ) as $ chunk ) { $ resources += $ this -> fetchCollectionFromApi ( $ chunk , $ type , $ locale ) ; } return $ resources ; } 
private function createIdChunks ( array $ resourceIds ) : array { $ chunks = [ ] ; $ chunkId = - 1 ; $ resourceIds = \ array_values ( $ resourceIds ) ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( 0 === $ index % 30 ) { ++ $ chunkId ; $ chunks [ $ chunkId ] = [ ] ; } $ chunks [ $ chunkId ] [ ] = $ resourceId ; } return $ chunks ; } 
private function fetchCollectionFromApi ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , $ resourceIds ) ; if ( 'Asset' === $ type || 'Entry' === $ type ) { $ query -> setLocale ( $ locale ) ; } switch ( $ type ) { case 'Asset' : return $ this -> client -> getAssets ( $ query ) -> getItems ( ) ; case 'ContentType' : return $ this -> client -> getContentTypes ( $ query ) -> getItems ( ) ; case 'Entry' : return $ this -> client -> getEntries ( $ query ) -> getItems ( ) ; case 'Environment' : return [ $ this -> client -> getEnvironment ( ) ] ; case 'Space' : return [ $ this -> client -> getSpace ( ) ] ; default : throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to resolve link for unknown type "%s".' , $ type ) ) ; } } 
protected function getSystemType ( array $ data ) : string { if ( 'Array' === $ data [ 'sys' ] [ 'type' ] ) { return 'ResourceArray' ; } if ( \ in_array ( $ data [ 'sys' ] [ 'type' ] , self :: $ availableTypes , true ) ) { return $ data [ 'sys' ] [ 'type' ] ; } throw new \ InvalidArgumentException ( \ sprintf ( 'Unexpected system type "%s" while trying to build a resource.' , $ data [ 'sys' ] [ 'type' ] ) ) ; } 
public function build ( array $ data , ResourceInterface $ resource = null ) { $ type = $ data [ 'sys' ] [ 'type' ] ; if ( 'Array' === $ type ) { $ this -> buildContentTypeCollection ( $ data ) ; $ this -> buildIncludes ( $ data ) ; return parent :: build ( $ data ) ; } $ resourceId = $ data [ 'sys' ] [ 'id' ] ; 
private function buildContentTypeCollection ( array $ data ) { $ items = \ array_merge ( $ data [ 'items' ] , $ data [ 'includes' ] [ 'Entry' ] ?? [ ] ) ; $ ids = \ array_map ( function ( array $ item ) { return 'Entry' === $ item [ 'sys' ] [ 'type' ] ? $ item [ 'sys' ] [ 'contentType' ] [ 'sys' ] [ 'id' ] : null ; } , $ items ) ; $ ids = \ array_filter ( \ array_unique ( $ ids ) , function ( $ id ) : bool { return $ id && ! $ this -> resourcePool -> has ( 'ContentType' , $ id ) ; } ) ; if ( $ ids ) { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , \ implode ( ',' , $ ids ) ) ; $ this -> client -> getContentTypes ( $ query ) ; } } 
public function clear ( $ cacheContent = false ) : bool { $ keys = [ ] ; foreach ( $ this -> fetchResources ( $ cacheContent ) as $ resource ) { $ sys = $ resource -> getSystemProperties ( ) ; $ options = $ sys instanceof LocalizedResourceSystemProperties ? [ 'locale' => $ sys -> getLocale ( ) ] : [ ] ; $ keys [ ] = $ this -> resourcePool -> generateKey ( $ sys -> getType ( ) , $ sys -> getId ( ) , $ options ) ; } return $ this -> cacheItemPool -> deleteItems ( $ keys ) ; } 
public function withHost ( string $ host ) : self { if ( '/' === \ mb_substr ( $ host , - 1 ) ) { $ host = \ mb_substr ( $ host , 0 , - 1 ) ; } $ this -> host = $ host ; return $ this ; } 
public function withCache ( CacheItemPoolInterface $ cacheItemPool , bool $ autoWarmup = false , bool $ cacheContent = false ) : self { $ this -> cacheItemPool = $ cacheItemPool ; $ this -> cacheAutoWarmup = $ autoWarmup ; $ this -> cacheContent = $ cacheContent ; return $ this ; } 
protected function fetchResources ( bool $ cacheContent = false ) { $ resources = [ $ this -> client -> getSpace ( ) , $ this -> client -> getEnvironment ( ) , ] ; $ query = ( new Query ( ) ) -> setLimit ( 100 ) ; foreach ( $ this -> client -> getContentTypes ( $ query ) as $ contentType ) { $ resources [ ] = $ contentType ; } foreach ( $ resources as $ resource ) { yield $ resource ; } if ( $ cacheContent ) { $ locales = \ array_map ( function ( Locale $ locale ) { return $ locale -> getCode ( ) ; } , $ this -> client -> getEnvironment ( ) -> getLocales ( ) ) ; $ locales [ ] = '*' ; foreach ( $ this -> fetchCollection ( 'Entry' , $ locales ) as $ entry ) { yield $ entry ; } foreach ( $ this -> fetchCollection ( 'Asset' , $ locales ) as $ asset ) { yield $ asset ; } } } 
private function fetchCollection ( string $ type , array $ locales ) : \ Generator { foreach ( $ locales as $ locale ) { $ skip = 0 ; do { $ query = ( new Query ( ) ) -> setLocale ( $ locale ) -> setLimit ( 1000 ) -> setSkip ( $ skip ) ; $ resources = 'Entry' === $ type ? $ this -> client -> getEntries ( $ query ) : $ this -> client -> getAssets ( $ query ) ; foreach ( $ resources as $ resource ) { yield $ resource ; } $ skip += 1000 ; } while ( $ resources -> getTotal ( ) > $ resources -> getSkip ( ) + 1000 ) ; } } 
protected function createSystemProperties ( string $ class , array $ data ) : SystemPropertiesInterface { $ sys = $ data [ 'sys' ] ; if ( isset ( $ sys [ 'space' ] ) && ! $ sys [ 'space' ] instanceof ResourceInterface ) { $ sys [ 'space' ] = $ this -> client -> getSpace ( ) ; } if ( isset ( $ sys [ 'environment' ] ) && ! $ sys [ 'environment' ] instanceof ResourceInterface ) { $ sys [ 'environment' ] = $ this -> client -> getEnvironment ( ) ; } if ( isset ( $ sys [ 'contentType' ] ) && ! $ sys [ 'contentType' ] instanceof ResourceInterface ) { $ sys [ 'contentType' ] = $ this -> client -> getContentType ( $ sys [ 'contentType' ] [ 'sys' ] [ 'id' ] ) ; } return new $ class ( $ sys ) ; } 
public function map ( $ resource , array $ data ) : ResourceClass { if ( ! isset ( $ data [ 'sys' ] [ 'contentType' ] ) ) { $ data [ 'sys' ] [ 'contentType' ] = $ this -> contentType ; } $ deletedEntry = $ this -> hydrator -> hydrate ( $ resource ? : ResourceClass :: class , [ 'sys' => $ this -> createSystemProperties ( SystemProperties :: class , $ data ) , ] ) ; return $ deletedEntry ; } 
public function getQueryData ( ) : array { $ data = [ 'initial' => 'true' , 'type' => 'all' !== $ this -> type ? $ this -> type : null , 'content_type' => $ this -> contentType , ] ; return $ data ; } 
public function setType ( string $ type = null ) { $ validTypes = [ 'all' , 'Asset' , 'Entry' , 'Deletion' , 'DeletedAsset' , 'DeletedEntry' ] ; if ( ! \ in_array ( $ type , $ validTypes , true ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Unexpected type "%s".' , $ type ) ) ; } $ this -> type = $ type ; return $ this ; } 
public function setContentType ( $ contentType ) { if ( $ contentType instanceof ContentType ) { $ contentType = $ contentType -> getId ( ) ; } $ this -> contentType = $ contentType ; $ this -> setType ( 'Entry' ) ; return $ this ; } 
public function sync ( string $ token = null , Query $ query = null ) : \ Generator { do { $ result = $ token ? $ this -> continueSync ( $ token ) : $ this -> startSync ( $ query ) ; yield $ result ; $ token = $ result -> getToken ( ) ; } while ( ! $ result -> isDone ( ) ) ; } 
public function startSync ( Query $ query = null ) { $ query = null !== $ query ? $ query : new Query ( ) ; $ response = $ this -> client -> syncRequest ( $ query -> getQueryData ( ) ) ; return $ this -> buildResult ( $ response ) ; } 
public function continueSync ( $ token ) : Result { if ( $ token instanceof Result ) { if ( ! $ this -> isDeliveryApi && $ token -> isDone ( ) ) { throw new \ RuntimeException ( 'Can not continue syncing when using the Content Preview API.' ) ; } $ token = $ token -> getToken ( ) ; } $ response = $ this -> client -> syncRequest ( [ 'sync_token' => $ token ] ) ; return $ this -> buildResult ( $ response ) ; } 
private function buildResult ( array $ data ) : Result { $ token = $ this -> getTokenFromResponse ( $ data ) ; $ done = isset ( $ data [ 'nextSyncUrl' ] ) ; $ items = \ array_map ( function ( array $ item ) : ResourceInterface { return $ this -> builder -> build ( $ item ) ; } , $ data [ 'items' ] ) ; return new Result ( $ items , $ token , $ done ) ; } 
private function getTokenFromResponse ( array $ data ) : string { $ url = $ data [ 'nextSyncUrl' ] ?? $ data [ 'nextPageUrl' ] ; $ queryValues = [ ] ; \ parse_str ( \ parse_url ( $ url , \ PHP_URL_QUERY ) , $ queryValues ) ; return $ queryValues [ 'sync_token' ] ; } 
public function getQueryData ( ) : array { $ query = parent :: getQueryData ( ) ; if ( null !== $ this -> include ) { $ query [ 'include' ] = $ this -> include ; } if ( null !== $ this -> locale ) { $ query [ 'locale' ] = $ this -> locale ; } return $ query ; } 
public static function create ( JsonDecoderClientInterface $ client , ClientOptions $ options ) : ResourcePoolInterface { if ( $ options -> usesLowMemoryResourcePool ( ) ) { return new Standard ( $ client -> getApi ( ) , $ client -> getSpaceId ( ) , $ client -> getEnvironmentId ( ) ) ; } return new Extended ( $ client , $ options -> getCacheItemPool ( ) , $ options -> hasCacheAutoWarmup ( ) , $ options -> hasCacheContent ( ) ) ; } 
public function map ( $ resource , array $ data ) : ResourceClass { $ deletedAsset = $ this -> hydrator -> hydrate ( $ resource ? : ResourceClass :: class , [ 'sys' => $ this -> createSystemProperties ( SystemProperties :: class , $ data ) , ] ) ; return $ deletedAsset ; } 
public function map ( $ resource , array $ data ) : ResourceClass { $ environment = $ this -> hydrator -> hydrate ( $ resource ? : ResourceClass :: class , [ 'sys' => $ this -> createSystemProperties ( SystemProperties :: class , $ data ) , 'locales' => \ array_map ( function ( array $ localeData ) : Locale { $ locale = $ this -> builder -> build ( $ localeData ) ; return $ locale ; } , $ data [ 'locales' ] ) , ] ) ; return $ environment ; } 
public function warmUp ( $ cacheContent = false ) : bool { foreach ( $ this -> fetchResources ( $ cacheContent ) as $ resource ) { $ sys = $ resource -> getSystemProperties ( ) ; $ options = $ sys instanceof LocalizedResourceSystemProperties ? [ 'locale' => $ sys -> getLocale ( ) ] : [ ] ; $ key = $ this -> resourcePool -> generateKey ( $ sys -> getType ( ) , $ sys -> getId ( ) , $ options ) ; $ item = $ this -> cacheItemPool -> getItem ( $ key ) ; $ item -> set ( guzzle_json_encode ( $ resource ) ) ; $ this -> cacheItemPool -> saveDeferred ( $ item ) ; } return $ this -> cacheItemPool -> commit ( ) ; } 
public function has ( string $ name , string $ locale = null , bool $ checkLinksAreResolved = true ) : bool { $ field = $ this -> sys -> getContentType ( ) -> getField ( $ name , true ) ; if ( ! $ field ) { return false ; } if ( ! \ array_key_exists ( $ field -> getId ( ) , $ this -> fields ) ) { return false ; } try { $ result = $ this -> getUnresolvedField ( $ field , $ locale ) ; if ( $ checkLinksAreResolved ) { $ this -> resolveFieldLinks ( $ result , $ locale ) ; } } catch ( \ Exception $ exception ) { return false ; } return true ; } 
public function all ( string $ locale = null , bool $ resolveLinks = true ) : array { $ values = [ ] ; foreach ( $ this -> getContentType ( ) -> getFields ( ) as $ field ) { $ result = $ this -> getUnresolvedField ( $ field , $ locale ) ; $ values [ $ field -> getId ( ) ] = $ resolveLinks ? $ this -> resolveFieldLinks ( $ result , $ locale ) : $ result ; } return $ values ; } 
public function get ( string $ name , string $ locale = null , bool $ resolveLinks = true ) { $ field = $ this -> sys -> getContentType ( ) -> getField ( $ name , true ) ; if ( $ field ) { $ result = $ this -> getUnresolvedField ( $ field , $ locale ) ; return $ resolveLinks ? $ this -> resolveFieldLinks ( $ result , $ locale ) : $ result ; } 
private function getUnresolvedField ( Field $ field , string $ locale = null ) { 
private function resolveFieldLinks ( $ field , string $ locale = null ) { 
private function getFieldWithId ( string $ name , string $ locale = null ) { if ( 'Id' !== \ mb_substr ( $ name , - 2 ) ) { return null ; } $ field = $ this -> sys -> getContentType ( ) -> getField ( \ mb_substr ( $ name , 0 , - 2 ) , true ) ; if ( ! $ field ) { return null ; } if ( 'Link' !== $ field -> getType ( ) && ( 'Array' !== $ field -> getType ( ) || 'Link' !== $ field -> getItemsType ( ) ) ) { return null ; } $ value = $ this -> getUnresolvedField ( $ field , $ locale ) ; if ( $ value instanceof Link ) { return $ value -> getId ( ) ; } return \ array_map ( function ( Link $ link ) { return $ link -> getId ( ) ; } , $ value ) ; } 
public function getReferences ( Query $ query = null ) : ResourceArray { $ query = $ query ? : new Query ( ) ; $ query -> linksToEntry ( $ this -> getId ( ) ) ; return $ this -> client -> getEntries ( $ query ) ; } 
public function jsonSerialize ( ) : array { $ locale = $ this -> sys -> getLocale ( ) ; $ fields = new \ stdClass ( ) ; foreach ( $ this -> fields as $ name => $ value ) { $ fields -> $ name = $ locale ? $ value [ $ locale ] : $ value ; } return [ 'sys' => $ this -> sys , 'fields' => $ fields , ] ; } 
public function map ( $ resource , array $ data ) : ResourceClass { $ sys = $ this -> createSystemProperties ( SystemProperties :: class , $ data ) ; $ locale = $ sys -> getLocale ( ) ; 
private function buildFields ( ResourceContentType $ contentType , array $ fields , ResourceClass $ previous = null ) : array { if ( $ previous ) { $ fields = $ this -> mergePreviousFields ( $ fields , $ previous ) ; } foreach ( $ fields as $ name => $ data ) { $ field = $ contentType -> getField ( $ name ) ; 
private function mergePreviousFields ( array $ fields , ResourceClass $ entry ) : array { 
private function formatValue ( string $ type , $ value , string $ itemsType = null ) { 
private function getLocaleForCacheKey ( string $ locale = null ) : string { if ( $ locale ) { return $ locale ; } return $ this -> getEnvironment ( ) -> getDefaultLocale ( ) -> getCode ( ) ; } 
public function getAsset ( string $ assetId , string $ locale = null ) : Asset { $ locale = $ locale ? : $ this -> defaultLocale ; $ asset = $ this -> requestWithCache ( '/spaces/' . $ this -> spaceId . '/environments/' . $ this -> environmentId . '/assets/' . $ assetId , [ 'locale' => $ locale ] , 'Asset' , $ assetId , $ this -> getLocaleForCacheKey ( $ locale ) ) ; return $ asset ; } 
public function getAssets ( Query $ query = null ) : ResourceArray { $ queryData = $ query ? $ query -> getQueryData ( ) : [ ] ; if ( ! isset ( $ queryData [ 'locale' ] ) ) { $ queryData [ 'locale' ] = $ this -> defaultLocale ; } $ assets = $ this -> request ( 'GET' , '/spaces/' . $ this -> spaceId . '/environments/' . $ this -> environmentId . '/assets' , [ 'query' => $ queryData ] ) ; return $ assets ; } 
public function getContentType ( string $ contentTypeId ) : ContentType { $ contentType = $ this -> requestWithCache ( '/spaces/' . $ this -> spaceId . '/environments/' . $ this -> environmentId . '/content_types/' . $ contentTypeId , [ ] , 'ContentType' , $ contentTypeId ) ; return $ contentType ; } 
public function getContentTypes ( Query $ query = null ) : ResourceArray { $ contentTypes = $ this -> request ( 'GET' , '/spaces/' . $ this -> spaceId . '/environments/' . $ this -> environmentId . '/content_types' , [ 'query' => $ query ? $ query -> getQueryData ( ) : [ ] ] ) ; return $ contentTypes ; } 
public function getEnvironment ( ) : Environment { if ( $ this -> resourcePool -> has ( 'Environment' , $ this -> environmentId ) ) { $ environment = $ this -> resourcePool -> get ( 'Environment' , $ this -> environmentId ) ; return $ environment ; } 
public function getEntry ( string $ entryId , string $ locale = null ) : Entry { $ locale = $ locale ? : $ this -> defaultLocale ; $ entry = $ this -> requestWithCache ( '/spaces/' . $ this -> spaceId . '/environments/' . $ this -> environmentId . '/entries/' . $ entryId , [ 'locale' => $ locale ] , 'Entry' , $ entryId , $ this -> getLocaleForCacheKey ( $ locale ) ) ; return $ entry ; } 
public function getEntries ( Query $ query = null ) : ResourceArray { $ queryData = $ query ? $ query -> getQueryData ( ) : [ ] ; if ( ! isset ( $ queryData [ 'locale' ] ) ) { $ queryData [ 'locale' ] = $ this -> defaultLocale ; } $ entries = $ this -> request ( 'GET' , '/spaces/' . $ this -> spaceId . '/environments/' . $ this -> environmentId . '/entries' , [ 'query' => $ queryData ] ) ; return $ entries ; } 
public function getSpace ( ) : Space { try { $ space = $ this -> requestWithCache ( '/spaces/' . $ this -> spaceId , [ ] , 'Space' , $ this -> spaceId ) ; } catch ( Exception $ exception ) { 
public function resolveLink ( Link $ link , string $ locale = null ) : ResourceInterface { return $ this -> linkResolver -> resolveLink ( $ link , [ 'locale' => ( string ) $ locale , ] ) ; } 
public function resolveLinkCollection ( array $ links , string $ locale = null ) : array { return $ this -> linkResolver -> resolveLinkCollection ( $ links , [ 'locale' => ( string ) $ locale , ] ) ; } 
public function parseJson ( string $ json ) { return $ this -> builder -> build ( $ this -> scopedJsonDecoder -> decode ( $ json ) ) ; } 
public function request ( string $ method , string $ uri , array $ options = [ ] ) : ResourceInterface { $ response = $ this -> callApi ( 'GET' , $ uri , $ options ) ; return $ this -> builder -> build ( $ response ) ; } 
private function requestWithCache ( string $ uri , array $ query = [ ] , string $ type = null , string $ resourceId = null , string $ locale = null ) { if ( $ type && $ resourceId && $ this -> resourcePool -> has ( $ type , $ resourceId , [ 'locale' => $ locale ] ) ) { return $ this -> resourcePool -> get ( $ type , $ resourceId , [ 'locale' => $ locale ] ) ; } return $ this -> request ( 'GET' , $ uri , [ 'query' => $ query ] ) ; } 
public function map ( $ resource , array $ data ) : ResourceClass { return new ResourceClass ( \ array_map ( function ( $ item ) { return $ this -> builder -> build ( $ item ) ; } , $ data [ 'items' ] ) , $ data [ 'total' ] , $ data [ 'limit' ] , $ data [ 'skip' ] ) ; } 
private function getProperty ( string $ property , $ locale = null ) { $ localeCode = $ this -> getLocaleFromInput ( $ locale ) ; 
public function jsonSerialize ( ) : array { $ locale = $ this -> sys -> getLocale ( ) ; $ asset = [ 'sys' => $ this -> sys , 'fields' => [ ] , ] ; if ( null !== $ this -> title ) { $ asset [ 'fields' ] [ 'title' ] = $ locale ? $ this -> title [ $ locale ] : $ this -> title ; } if ( null !== $ this -> description ) { $ asset [ 'fields' ] [ 'description' ] = $ locale ? $ this -> description [ $ locale ] : $ this -> description ; } if ( null !== $ this -> file ) { $ asset [ 'fields' ] [ 'file' ] = $ locale ? $ this -> file [ $ locale ] : $ this -> file ; } $ asset [ 'fields' ] = ( object ) $ asset [ 'fields' ] ; return $ asset ; } 
protected function getResourceLocale ( ResourceInterface $ resource ) { $ sys = $ resource -> getSystemProperties ( ) ; return $ sys instanceof LocalizedResourceSystemProperties ? $ sys -> getLocale ( ) : null ; } 
public function has ( string $ type , string $ id , array $ options = [ ] ) : bool { if ( ! $ this -> savesResource ( $ type ) ) { return false ; } $ key = $ this -> generateKey ( $ type , $ id , $ options ) ; $ this -> warmUp ( $ key , $ type ) ; return isset ( $ this -> resources [ $ key ] ) ; } 
public function save ( ResourceInterface $ resource ) : bool { if ( ! $ this -> savesResource ( $ resource -> getType ( ) ) ) { return false ; } $ key = $ this -> generateKey ( $ resource -> getType ( ) , $ resource -> getId ( ) , [ 'locale' => $ this -> getResourceLocale ( $ resource ) ] ) ; $ exists = isset ( $ this -> resources [ $ key ] ) ; $ this -> resources [ $ key ] = $ resource ; return ! $ exists ; } 
public function get ( string $ type , string $ id , array $ options = [ ] ) : ResourceInterface { $ locale = $ options [ 'locale' ] ?? null ; $ key = $ this -> generateKey ( $ type , $ id , $ options ) ; $ this -> warmUp ( $ key , $ type ) ; if ( ! $ this -> savesResource ( $ type ) || ! isset ( $ this -> resources [ $ key ] ) ) { throw new \ OutOfBoundsException ( \ sprintf ( 'Resource pool could not find a resource with type "%s", ID "%s"%s.' , $ type , $ id , $ locale ? ', and locale "' . $ locale . '"' : '' ) ) ; } return $ this -> resources [ $ key ] ; } 
public function generateKey ( string $ type , string $ id , array $ options = [ ] ) : string { $ locale = \ strtr ( $ options [ 'locale' ] ?? '__ALL__' , [ '-' => '_' , '*' => '__ALL__' , ] ) ; return 'contentful.' . $ this -> api . '.' . $ this -> spaceId . '.' . $ this -> environmentId . '.' . $ type . '.' . $ this -> sanitize ( $ id ) . '.' . $ locale ; } 
public function map ( $ resource , array $ data ) : ResourceClass { $ locale = $ this -> hydrator -> hydrate ( $ resource ? : ResourceClass :: class , [ 'sys' => $ this -> createSystemProperties ( SystemProperties :: class , $ data ) , 'code' => $ data [ 'code' ] , 'name' => $ data [ 'name' ] , 'default' => $ data [ 'default' ] , 'fallbackCode' => $ data [ 'fallbackCode' ] , ] ) ; return $ locale ; } 
public function getLocale ( string $ code ) : Locale { foreach ( $ this -> locales as $ locale ) { if ( $ locale -> getCode ( ) === $ code ) { return $ locale ; } } throw new \ InvalidArgumentException ( \ sprintf ( 'No locale with code "%s" exists in this environment.' , $ code ) ) ; } 
public function getDefaultLocale ( ) : Locale { foreach ( $ this -> locales as $ locale ) { if ( $ locale -> isDefault ( ) ) { return $ locale ; } } throw new \ RuntimeException ( 'No locale marked as default exists in this environment.' ) ; } 
public function refund ( $ options = [ ] ) { $ this -> config = array_merge ( $ this -> config , $ options ) ; $ this -> config [ 'op_user_id' ] = isset ( $ this -> config [ 'op_user_id' ] ) ? : $ this -> userConfig -> get ( 'mch_id' , '' ) ; $ this -> unsetTradeTypeAndNotifyUrl ( ) ; return $ this -> getResult ( $ this -> gateway_refund , true ) ; } 
public function close ( $ out_trade_no = '' ) { $ this -> config [ 'out_trade_no' ] = $ out_trade_no ; $ this -> unsetTradeTypeAndNotifyUrl ( ) ; return $ this -> getResult ( $ this -> gateway_close ) ; } 
public function find ( $ out_trade_no = '' ) { $ this -> config [ 'out_trade_no' ] = $ out_trade_no ; $ this -> unsetTradeTypeAndNotifyUrl ( ) ; return $ this -> getResult ( $ this -> gateway_query ) ; } 
public function verify ( $ data , $ sign = null , $ sync = false ) { $ data = $ this -> fromXml ( $ data ) ; $ sign = is_null ( $ sign ) ? $ data [ 'sign' ] : $ sign ; return $ this -> getSign ( $ data ) === $ sign ? $ data : false ; } 
protected function getResult ( $ url , $ cert = false ) { $ this -> config [ 'sign' ] = $ this -> getSign ( $ this -> config ) ; if ( $ cert ) { $ data = $ this -> fromXml ( $ this -> post ( $ url , $ this -> toXml ( $ this -> config ) , [ 'ssl_cer' => $ this -> userConfig -> get ( 'ssl_cer' , '' ) , 'ssl_key' => $ this -> userConfig -> get ( 'ssl_key' , '' ) ] ) ) ; } else { $ data = $ this -> fromXml ( $ this -> post ( $ url , $ this -> toXml ( $ this -> config ) ) ) ; } if ( ! isset ( $ data [ 'return_code' ] ) || $ data [ 'return_code' ] !== 'SUCCESS' || $ data [ 'result_code' ] !== 'SUCCESS' ) { $ error = 'ResultError:' . $ data [ 'return_msg' ] ; $ error .= isset ( $ data [ 'err_code_des' ] ) ? ' - ' . $ data [ 'err_code_des' ] : '' ; } if ( isset ( $ data [ 'sign' ] ) ) { if ( ! isset ( $ error ) && $ this -> getSign ( $ data ) !== $ data [ 'sign' ] ) { $ error = 'GetResultError: return data sign error' ; } } if ( isset ( $ error ) ) { throw new GatewayException ( $ error , 20000 , $ data ) ; } return $ data ; } 
protected function getSign ( $ data ) { if ( is_null ( $ this -> userConfig -> get ( 'mch_key' ) ) ) { throw new InvalidArgumentException ( 'Missing Config -- [mch_key]' ) ; } ksort ( $ data ) ; $ string = md5 ( $ this -> getSignContent ( $ data ) . '&key=' . $ this -> userConfig -> get ( 'mch_key' ) ) ; return strtoupper ( $ string ) ; } 
protected function toXml ( $ data ) { if ( ! is_array ( $ data ) || count ( $ data ) <= 0 ) { throw new InvalidArgumentException ( 'convert to xml error !invalid array!' ) ; } $ xml = '<xml>' ; foreach ( $ data as $ key => $ val ) { $ xml .= ( is_numeric ( $ val ) ? "<{$key}>{$val}</{$key}>" : "<{$key}><![CDATA[{$val}]]></{$key}>" ) ; } return $ xml . '</xml>' ; } 
public function apply ( array $ options = [ ] ) { $ options [ 'mchid' ] = $ this -> config [ 'mch_id' ] ; $ options [ 'mch_appid' ] = $ this -> userConfig -> get ( 'app_id' ) ; unset ( $ this -> config [ 'appid' ] ) ; unset ( $ this -> config [ 'mch_id' ] ) ; unset ( $ this -> config [ 'sign_type' ] ) ; unset ( $ this -> config [ 'trade_type' ] ) ; unset ( $ this -> config [ 'notify_url' ] ) ; $ this -> config = array_merge ( $ this -> config , $ options ) ; $ this -> config [ 'sign' ] = $ this -> getSign ( $ this -> config ) ; $ data = $ this -> fromXml ( $ this -> post ( $ this -> gateway_transfer , $ this -> toXml ( $ this -> config ) , [ 'ssl_cer' => $ this -> userConfig -> get ( 'ssl_cer' , '' ) , 'ssl_key' => $ this -> userConfig -> get ( 'ssl_key' , '' ) , ] ) ) ; if ( ! isset ( $ data [ 'return_code' ] ) || $ data [ 'return_code' ] !== 'SUCCESS' || $ data [ 'result_code' ] !== 'SUCCESS' ) { $ error = 'GetResultError:' . $ data [ 'return_msg' ] ; $ error .= isset ( $ data [ 'err_code_des' ] ) ? ' - ' . $ data [ 'err_code_des' ] : '' ; } if ( isset ( $ error ) ) { throw new GatewayException ( $ error , 20001 , $ data ) ; } return $ data ; } 
public static function get ( $ url , $ query = [ ] , $ options = [ ] ) { $ options [ 'query' ] = $ query ; return self :: request ( 'get' , $ url , $ options ) ; } 
public static function post ( $ url , $ data = [ ] , $ options = [ ] ) { $ options [ 'data' ] = $ data ; return self :: request ( 'post' , $ url , $ options ) ; } 
protected static function request ( $ method , $ url , $ options = [ ] ) { $ curl = curl_init ( ) ; 
private static function build ( $ data ) { if ( ! is_array ( $ data ) ) { return $ data ; } foreach ( $ data as $ key => $ value ) { if ( is_string ( $ value ) && class_exists ( 'CURLFile' , false ) && stripos ( $ value , '@' ) === 0 ) { $ filename = realpath ( trim ( $ value , '@' ) ) ; if ( $ filename && file_exists ( $ filename ) ) { $ data [ $ key ] = new \ CURLFile ( $ filename ) ; } } } return $ data ; } 
public static function setCache ( $ name , $ value = '' , $ expired = 3600 ) { $ cache_file = self :: getCacheName ( $ name ) ; $ content = serialize ( [ 'name' => $ name , 'value' => $ value , 'expired' => time ( ) + intval ( $ expired ) ] ) ; if ( ! file_put_contents ( $ cache_file , $ content ) ) { throw new Exception ( 'local cache error.' , 500 ) ; } } 
public static function getCache ( $ name ) { $ cache_file = self :: getCacheName ( $ name ) ; if ( file_exists ( $ cache_file ) && ( $ content = file_get_contents ( $ cache_file ) ) ) { $ data = unserialize ( $ content ) ; if ( isset ( $ data [ 'expired' ] ) && ( intval ( $ data [ 'expired' ] ) === 0 || intval ( $ data [ 'expired' ] ) >= time ( ) ) ) { return $ data [ 'value' ] ; } self :: delCache ( $ name ) ; } return null ; } 
public static function delCache ( $ name ) { $ cache_file = self :: getCacheName ( $ name ) ; return file_exists ( $ cache_file ) ? unlink ( $ cache_file ) : true ; } 
private static function getCacheName ( $ name ) { if ( empty ( self :: $ cachePath ) ) { self :: $ cachePath = dirname ( __DIR__ ) . DIRECTORY_SEPARATOR . 'Cache' . DIRECTORY_SEPARATOR ; } self :: $ cachePath = rtrim ( self :: $ cachePath , '/\\' ) . DIRECTORY_SEPARATOR ; file_exists ( self :: $ cachePath ) || mkdir ( self :: $ cachePath , 0755 , true ) ; return self :: $ cachePath . $ name ; } 
public function driver ( $ driver ) { if ( is_null ( $ this -> config -> get ( $ driver ) ) ) { throw new InvalidArgumentException ( "Driver [$driver]'s Config is not defined." ) ; } $ this -> drivers = $ driver ; return $ this ; } 
public function gateway ( $ gateway = 'web' ) { if ( ! isset ( $ this -> drivers ) ) { throw new InvalidArgumentException ( 'Driver is not defined.' ) ; } return $ this -> gateways = $ this -> createGateway ( $ gateway ) ; } 
protected function createGateway ( $ gateway ) { if ( ! file_exists ( __DIR__ . '/Gateways/' . ucfirst ( $ this -> drivers ) . '/' . ucfirst ( $ gateway ) . 'Gateway.php' ) ) { throw new InvalidArgumentException ( "Gateway [$gateway] is not supported." ) ; } $ gateway = __NAMESPACE__ . '\\Gateways\\' . ucfirst ( $ this -> drivers ) . '\\' . ucfirst ( $ gateway ) . 'Gateway' ; return new $ gateway ( $ this -> config -> get ( $ this -> drivers ) ) ; } 
public function apply ( array $ options ) { if ( ! isset ( $ options [ 'partner_trade_no' ] ) ) { throw new InvalidArgumentException ( 'Missing Options -- [partner_trade_no]' ) ; } if ( ! isset ( $ options [ 'enc_bank_no' ] ) ) { throw new InvalidArgumentException ( 'Missing Options -- [enc_bank_no]' ) ; } if ( ! isset ( $ options [ 'enc_true_name' ] ) ) { throw new InvalidArgumentException ( 'Missing Options -- [enc_true_name]' ) ; } if ( ! isset ( $ options [ 'bank_code' ] ) ) { throw new InvalidArgumentException ( 'Missing Options -- [bank_code]' ) ; } if ( ! isset ( $ options [ 'amount' ] ) ) { throw new InvalidArgumentException ( 'Missing Options -- [amount]' ) ; } unset ( $ this -> config [ 'appid' ] , $ this -> config [ 'notify_url' ] , $ this -> config [ 'trade_type' ] , $ this -> config [ 'sign_type' ] ) ; if ( isset ( $ options [ 'desc' ] ) ) { $ this -> config [ 'desc' ] = $ options [ 'desc' ] ; } $ this -> config [ 'amount' ] = $ options [ 'amount' ] ; $ this -> config [ 'bank_code' ] = $ options [ 'bank_code' ] ; $ this -> config [ 'partner_trade_no' ] = $ options [ 'partner_trade_no' ] ; $ this -> config [ 'enc_bank_no' ] = $ this -> rsaEncode ( $ options [ 'enc_bank_no' ] ) ; $ this -> config [ 'enc_true_name' ] = $ this -> rsaEncode ( $ options [ 'enc_true_name' ] ) ; return $ this -> getResult ( $ this -> gateway_paybank , true ) ; } 
public function find ( $ partner_trade_no = '' ) { $ this -> unsetTradeTypeAndNotifyUrl ( ) ; $ this -> config [ 'partner_trade_no' ] = $ partner_trade_no ; unset ( $ this -> config [ 'appid' ] , $ this -> config [ 'sign_type' ] ) ; return $ this -> getResult ( $ this -> gateway_query , true ) ; } 
public function apply ( array $ options = [ ] , $ return_url = '' ) { $ data = $ this -> preOrder ( $ options ) ; $ data [ 'mweb_url' ] = isset ( $ data [ 'mweb_url' ] ) ? $ data [ 'mweb_url' ] : '' ; if ( empty ( $ return_url ) ) { $ return_url = $ this -> userConfig -> get ( 'return_url' ) ; } return $ data [ 'mweb_url' ] . "&redirect_url=" . urlencode ( $ return_url ) ; } 
public function apply ( array $ options ) { unset ( $ this -> config [ 'trade_type' ] ) ; unset ( $ this -> config [ 'notify_url' ] ) ; $ this -> config = array_merge ( $ this -> config , $ options ) ; $ this -> config [ 'sign' ] = $ this -> getSign ( $ this -> config ) ; return $ this -> post ( $ this -> gateway_bill , $ this -> toXml ( $ this -> config ) ) ; } 
public function set ( $ key , $ value ) { if ( $ key == '' ) { throw new InvalidArgumentException ( 'Invalid config key.' ) ; } 
public function apply ( array $ options = [ ] ) { unset ( $ this -> config [ 'trade_type' ] ) ; unset ( $ this -> config [ 'notify_url' ] ) ; $ this -> gateway = $ this -> gateway_micropay ; return $ this -> preOrder ( $ options ) ; } 
public function apply ( array $ options = [ ] ) { $ payRequest = [ 'appId' => $ this -> userConfig -> get ( 'app_id' ) , 'timeStamp' => time ( ) . '' , 'nonceStr' => $ this -> createNonceStr ( ) , 'package' => 'prepay_id=' . $ this -> preOrder ( $ options ) [ 'prepay_id' ] , 'signType' => 'MD5' , ] ; $ payRequest [ 'paySign' ] = $ this -> getSign ( $ payRequest ) ; return $ payRequest ; } 
public function apply ( array $ options ) { $ options [ 'product_code' ] = $ this -> getProductCode ( ) ; $ this -> config [ 'biz_content' ] = json_encode ( $ options ) ; $ this -> config [ 'method' ] = $ this -> getMethod ( ) ; $ this -> config [ 'sign' ] = $ this -> getSign ( ) ; } 
public function verify ( $ data , $ sign = null , $ sync = false ) { if ( is_null ( $ this -> userConfig -> get ( 'public_key' ) ) ) { throw new InvalidArgumentException ( 'Missing Config -- [public_key]' ) ; } $ sign = is_null ( $ sign ) ? $ data [ 'sign' ] : $ sign ; $ res = "-----BEGIN PUBLIC KEY-----\n" . wordwrap ( $ this -> userConfig -> get ( 'public_key' ) , 64 , "\n" , true ) . "\n-----END PUBLIC KEY-----" ; $ toVerify = $ sync ? json_encode ( $ data ) : $ this -> getSignContent ( $ data , true ) ; return openssl_verify ( $ toVerify , base64_decode ( $ sign ) , $ res , OPENSSL_ALGO_SHA256 ) === 1 ? $ data : false ; } 
protected function getResult ( $ options , $ method ) { $ this -> config [ 'method' ] = $ method ; $ this -> config [ 'biz_content' ] = json_encode ( $ options ) ; $ this -> config [ 'sign' ] = $ this -> getSign ( ) ; $ method = str_replace ( '.' , '_' , $ method ) . '_response' ; $ data = json_decode ( $ this -> post ( $ this -> gateway , $ this -> config ) , true ) ; if ( ! isset ( $ data [ $ method ] [ 'code' ] ) || $ data [ $ method ] [ 'code' ] !== '10000' ) { throw new GatewayException ( "\nResultError" . ( empty ( $ data [ $ method ] [ 'code' ] ) ? '' : "\n{$data[$method]['msg']}[{$data[$method]['code']}]" ) . ( empty ( $ data [ $ method ] [ 'sub_code' ] ) ? '' : "\n{$data[$method]['sub_msg']}[{$data[$method]['sub_code']}]\n" ) , $ data [ $ method ] [ 'code' ] , $ data ) ; } return $ this -> verify ( $ data [ $ method ] , $ data [ 'sign' ] , true ) ; } 
protected function getSign ( ) { if ( is_null ( $ this -> userConfig -> get ( 'private_key' ) ) ) { throw new InvalidArgumentException ( 'Missing Config -- [private_key]' ) ; } $ res = "-----BEGIN RSA PRIVATE KEY-----\n" . wordwrap ( $ this -> userConfig -> get ( 'private_key' ) , 64 , "\n" , true ) . "\n-----END RSA PRIVATE KEY-----" ; openssl_sign ( $ this -> getSignContent ( $ this -> config ) , $ sign , $ res , OPENSSL_ALGO_SHA256 ) ; return base64_encode ( $ sign ) ; } 
protected function getSignContent ( array $ toBeSigned , $ verify = false ) { ksort ( $ toBeSigned ) ; $ stringToBeSigned = '' ; foreach ( $ toBeSigned as $ k => $ v ) { if ( $ v !== '' ) { if ( $ verify && $ k != 'sign' && $ k != 'sign_type' ) { $ stringToBeSigned .= $ k . '=' . $ v . '&' ; } if ( ! $ verify && $ v !== '' && ! is_null ( $ v ) && $ k != 'sign' && '@' != substr ( $ v , 0 , 1 ) ) { $ stringToBeSigned .= $ k . '=' . $ v . '&' ; } } } $ stringToBeSigned = substr ( $ stringToBeSigned , 0 , - 1 ) ; unset ( $ k , $ v ) ; return $ stringToBeSigned ; } 
public function apply ( array $ options = [ ] , $ scene = 'bar_code' ) { $ options [ 'scene' ] = $ scene ; return $ this -> getResult ( $ options , $ this -> getMethod ( ) ) ; } 
public function copy ( $ originUrl , $ fileUrl , $ fileName , $ progress = true , $ options = [ ] ) { $ options = array_replace_recursive ( $ this -> nextOptions , $ options ) ; $ this -> nextOptions = [ ] ; $ rfs = clone $ this ; $ rfs -> fileName = $ fileName ; $ rfs -> progress = $ this -> progress && $ progress ; try { return $ rfs -> get ( $ originUrl , $ fileUrl , $ options , $ fileName , $ rfs -> progress ) ; } finally { $ rfs -> lastHeaders = null ; $ this -> lastHeaders = $ rfs -> getLastHeaders ( ) ; } } 
protected function getRemoteContents ( $ originUrl , $ fileUrl , $ context , array & $ responseHeaders = null ) { if ( isset ( self :: $ cache [ $ fileUrl ] ) ) { $ result = self :: $ cache [ $ fileUrl ] ; if ( 3 < \ func_num_args ( ) ) { list ( $ responseHeaders , $ result ) = $ result ; } return $ result ; } if ( self :: $ cacheNext ) { self :: $ cacheNext = false ; if ( 3 < \ func_num_args ( ) ) { $ result = $ this -> getRemoteContents ( $ originUrl , $ fileUrl , $ context , $ responseHeaders ) ; self :: $ cache [ $ fileUrl ] = [ $ responseHeaders , $ result ] ; } else { $ result = $ this -> getRemoteContents ( $ originUrl , $ fileUrl , $ context ) ; self :: $ cache [ $ fileUrl ] = $ result ; } return $ result ; } if ( ! $ this -> downloader ) { return parent :: getRemoteContents ( $ originUrl , $ fileUrl , $ context , $ responseHeaders ) ; } try { $ result = $ this -> downloader -> get ( $ originUrl , $ fileUrl , $ context , $ this -> fileName ) ; if ( 3 < \ func_num_args ( ) ) { list ( $ responseHeaders , $ result ) = $ result ; } return $ result ; } catch ( TransportException $ e ) { $ this -> io -> writeError ( 'Retrying download: ' . $ e -> getMessage ( ) , true , IOInterface :: DEBUG ) ; return parent :: getRemoteContents ( $ originUrl , $ fileUrl , $ context , $ responseHeaders ) ; } catch ( \ Throwable $ e ) { $ responseHeaders = [ ] ; throw $ e ; } } 
public function getRecipes ( array $ operations ) : array { $ paths = [ ] ; $ chunk = '' ; foreach ( $ operations as $ i => $ operation ) { $ o = 'i' ; if ( $ operation instanceof UpdateOperation ) { $ package = $ operation -> getTargetPackage ( ) ; $ o = 'u' ; } else { $ package = $ operation -> getPackage ( ) ; if ( $ operation instanceof UninstallOperation ) { $ o = 'r' ; } } $ version = $ package -> getPrettyVersion ( ) ; if ( 0 === strpos ( $ version , 'dev-' ) && isset ( $ package -> getExtra ( ) [ 'branch-alias' ] ) ) { $ branchAliases = $ package -> getExtra ( ) [ 'branch-alias' ] ; if ( ( isset ( $ branchAliases [ $ version ] ) && $ alias = $ branchAliases [ $ version ] ) || ( isset ( $ branchAliases [ 'dev-master' ] ) && $ alias = $ branchAliases [ 'dev-master' ] ) ) { $ version = $ alias ; } } 
public function get ( string $ path , array $ headers = [ ] , $ cache = true ) : Response { if ( null === $ this -> endpoint ) { return new Response ( [ ] ) ; } $ headers [ ] = 'Package-Session: ' . $ this -> sess ; $ url = $ this -> endpoint . '/' . ltrim ( $ path , '/' ) ; $ cacheKey = $ cache ? ltrim ( $ path , '/' ) : '' ; if ( $ cacheKey && $ contents = $ this -> cache -> read ( $ cacheKey ) ) { $ cachedResponse = Response :: fromJson ( json_decode ( $ contents , true ) ) ; if ( $ lastModified = $ cachedResponse -> getHeader ( 'last-modified' ) ) { $ response = $ this -> fetchFileIfLastModified ( $ url , $ cacheKey , $ lastModified , $ headers ) ; if ( 304 === $ response -> getStatusCode ( ) ) { $ response = new Response ( $ cachedResponse -> getBody ( ) , $ response -> getOrigHeaders ( ) , 304 ) ; } return $ response ; } } return $ this -> fetchFile ( $ url , $ cacheKey , $ headers ) ; } 
public function store ( Request $ request ) { $ request -> request -> add ( [ 'body_content' => strip_tags ( $ request -> body ) ] ) ; $ validator = Validator :: make ( $ request -> all ( ) , [ 'title' => 'required|min:5|max:255' , 'body_content' => 'required|min:10' , 'chatter_category_id' => 'required' , ] , [ 'title.required' => trans ( 'chatter::alert.danger.reason.title_required' ) , 'title.min' => [ 'string' => trans ( 'chatter::alert.danger.reason.title_min' ) , ] , 'title.max' => [ 'string' => trans ( 'chatter::alert.danger.reason.title_max' ) , ] , 'body_content.required' => trans ( 'chatter::alert.danger.reason.content_required' ) , 'body_content.min' => trans ( 'chatter::alert.danger.reason.content_min' ) , 'chatter_category_id.required' => trans ( 'chatter::alert.danger.reason.category_required' ) , ] ) ; Event :: fire ( new ChatterBeforeNewDiscussion ( $ request , $ validator ) ) ; if ( function_exists ( 'chatter_before_new_discussion' ) ) { chatter_before_new_discussion ( $ request , $ validator ) ; } if ( $ validator -> fails ( ) ) { return back ( ) -> withErrors ( $ validator ) -> withInput ( ) ; } $ user_id = Auth :: user ( ) -> id ; if ( config ( 'chatter.security.limit_time_between_posts' ) ) { if ( $ this -> notEnoughTimeBetweenDiscussion ( ) ) { $ minutes = trans_choice ( 'chatter::messages.words.minutes' , config ( 'chatter.security.time_between_posts' ) ) ; $ chatter_alert = [ 'chatter_alert_type' => 'danger' , 'chatter_alert' => trans ( 'chatter::alert.danger.reason.prevent_spam' , [ 'minutes' => $ minutes , ] ) , ] ; return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( $ chatter_alert ) -> withInput ( ) ; } } 
public function show ( $ category , $ slug = null ) { if ( ! isset ( $ category ) || ! isset ( $ slug ) ) { return redirect ( config ( 'chatter.routes.home' ) ) ; } $ discussion = Models :: discussion ( ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; if ( is_null ( $ discussion ) ) { abort ( 404 ) ; } $ discussion_category = Models :: category ( ) -> find ( $ discussion -> chatter_category_id ) ; if ( $ category != $ discussion_category -> slug ) { return redirect ( config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.discussion' ) . '/' . $ discussion_category -> slug . '/' . $ discussion -> slug ) ; } $ posts = Models :: post ( ) -> with ( 'user' ) -> where ( 'chatter_discussion_id' , '=' , $ discussion -> id ) -> orderBy ( config ( 'chatter.order_by.posts.order' ) , config ( 'chatter.order_by.posts.by' ) ) -> paginate ( 10 ) ; $ chatter_editor = config ( 'chatter.editor' ) ; if ( $ chatter_editor == 'simplemde' ) { 
public function up ( ) { Schema :: table ( 'chatter_discussion' , function ( Blueprint $ table ) { $ table -> softDeletes ( ) ; } ) ; Schema :: table ( 'chatter_post' , function ( Blueprint $ table ) { $ table -> softDeletes ( ) ; } ) ; } 
public function index ( ) { $ discussions = Discussion :: limit ( 20 ) -> orderBy ( 'created_at' , 'DESC' ) -> get ( ) ; $ discussions -> load ( [ 'user' , 'posts' ] ) ; $ xml = new SimpleXMLElement ( '<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" xml:lang="en-US"/>' ) ; $ xml -> addChild ( 'id' , route ( 'chatter.home' ) ) ; $ link = $ xml -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'text/html' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.home' ) ) ; $ link = $ xml -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'application/atom+xml' ) ; $ link -> addAttribute ( 'rel' , 'self' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.atom' ) ) ; $ xml -> addChild ( 'title' , config ( 'app.name' ) . ' Discussions' ) ; $ updated = count ( $ discussions ) ? Carbon :: parse ( $ discussions [ 0 ] -> created_at ) : Carbon :: now ( ) ; $ xml -> addChild ( 'updated' , $ updated -> toAtomString ( ) ) ; foreach ( $ discussions as $ discussion ) { $ child = $ xml -> addChild ( 'entry' ) ; $ child -> addChild ( 'id' , route ( 'chatter.discussion.show' , [ 'discussion' => $ discussion -> slug ] ) ) ; $ child -> addChild ( 'title' , $ discussion -> title ) ; $ link = $ child -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'text/html' ) ; $ link -> addAttribute ( 'rel' , 'alternate' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.discussion.show' , [ 'discussion' => $ discussion -> slug ] ) ) ; $ child -> addChild ( 'updated' , Carbon :: parse ( $ discussion -> created_at ) -> toAtomString ( ) ) ; $ author = $ child -> addChild ( 'author' ) ; $ author -> addChild ( 'name' , $ discussion -> user -> name ) ; $ content = $ child -> addChild ( 'content' , htmlentities ( count ( $ discussion -> posts ) ? $ discussion -> posts [ 0 ] -> body : '' ) ) ; $ content -> addAttribute ( 'type' , 'html' ) ; } return response ( $ xml -> asXML ( ) , 200 , [ 'Content-Type' => 'application/atom+xml' , ] ) ; } 
public function register ( ) { $ this -> app -> register ( \ LukeTowers \ Purifier \ PurifierServiceProvider :: class ) ; $ loader = \ Illuminate \ Foundation \ AliasLoader :: getInstance ( ) ; $ loader -> alias ( 'Purifier' , 'LukeTowers\Purifier\Facades\Purifier' ) ; $ this -> loadViewsFrom ( __DIR__ . '/Views' , 'chatter' ) ; } 
public function store ( Request $ request ) { $ stripped_tags_body = [ 'body' => strip_tags ( $ request -> body ) ] ; $ validator = Validator :: make ( $ stripped_tags_body , [ 'body' => 'required|min:10' , ] , [ 'body.required' => trans ( 'chatter::alert.danger.reason.content_required' ) , 'body.min' => trans ( 'chatter::alert.danger.reason.content_min' ) , ] ) ; Event :: fire ( new ChatterBeforeNewResponse ( $ request , $ validator ) ) ; if ( function_exists ( 'chatter_before_new_response' ) ) { chatter_before_new_response ( $ request , $ validator ) ; } if ( $ validator -> fails ( ) ) { return back ( ) -> withErrors ( $ validator ) -> withInput ( ) ; } if ( config ( 'chatter.security.limit_time_between_posts' ) ) { if ( $ this -> notEnoughTimeBetweenPosts ( ) ) { $ minutes = trans_choice ( 'chatter::messages.words.minutes' , config ( 'chatter.security.time_between_posts' ) ) ; $ chatter_alert = [ 'chatter_alert_type' => 'danger' , 'chatter_alert' => trans ( 'chatter::alert.danger.reason.prevent_spam' , [ 'minutes' => $ minutes , ] ) , ] ; return back ( ) -> with ( $ chatter_alert ) -> withInput ( ) ; } } $ request -> request -> add ( [ 'user_id' => Auth :: user ( ) -> id ] ) ; if ( config ( 'chatter.editor' ) == 'simplemde' ) : $ request -> request -> add ( [ 'markdown' => 1 ] ) ; endif ; $ new_post = Models :: post ( ) -> create ( $ request -> all ( ) ) ; $ discussion = Models :: discussion ( ) -> find ( $ request -> chatter_discussion_id ) ; $ category = Models :: category ( ) -> find ( $ discussion -> chatter_category_id ) ; if ( ! isset ( $ category -> slug ) ) { $ category = Models :: category ( ) -> first ( ) ; } if ( $ new_post -> id ) { $ discussion -> last_reply_at = $ discussion -> freshTimestamp ( ) ; $ discussion -> save ( ) ; Event :: fire ( new ChatterAfterNewResponse ( $ request , $ new_post ) ) ; if ( function_exists ( 'chatter_after_new_response' ) ) { chatter_after_new_response ( $ request ) ; } 
public function update ( Request $ request , $ id ) { $ stripped_tags_body = [ 'body' => strip_tags ( $ request -> body ) ] ; $ validator = Validator :: make ( $ stripped_tags_body , [ 'body' => 'required|min:10' , ] , [ 'body.required' => trans ( 'chatter::alert.danger.reason.content_required' ) , 'body.min' => trans ( 'chatter::alert.danger.reason.content_min' ) , ] ) ; if ( $ validator -> fails ( ) ) { return back ( ) -> withErrors ( $ validator ) -> withInput ( ) ; } $ post = Models :: post ( ) -> find ( $ id ) ; if ( ! Auth :: guest ( ) && ( Auth :: user ( ) -> id == $ post -> user_id ) ) { if ( $ post -> markdown ) { $ post -> body = $ request -> body ; } else { $ post -> body = Purifier :: clean ( $ request -> body ) ; } $ post -> save ( ) ; $ discussion = Models :: discussion ( ) -> find ( $ post -> chatter_discussion_id ) ; $ category = Models :: category ( ) -> find ( $ discussion -> chatter_category_id ) ; if ( ! isset ( $ category -> slug ) ) { $ category = Models :: category ( ) -> first ( ) ; } $ chatter_alert = [ 'chatter_alert_type' => 'success' , 'chatter_alert' => trans ( 'chatter::alert.success.reason.updated_post' ) , ] ; return redirect ( '/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.discussion' ) . '/' . $ category -> slug . '/' . $ discussion -> slug ) -> with ( $ chatter_alert ) ; } else { $ chatter_alert = [ 'chatter_alert_type' => 'danger' , 'chatter_alert' => trans ( 'chatter::alert.danger.reason.update_post' ) , ] ; return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( $ chatter_alert ) ; } } 
public function destroy ( $ id , Request $ request ) { $ post = Models :: post ( ) -> with ( 'discussion' ) -> findOrFail ( $ id ) ; if ( $ request -> user ( ) -> id !== ( int ) $ post -> user_id ) { return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( [ 'chatter_alert_type' => 'danger' , 'chatter_alert' => trans ( 'chatter::alert.danger.reason.destroy_post' ) , ] ) ; } if ( $ post -> discussion -> posts ( ) -> oldest ( ) -> first ( ) -> id === $ post -> id ) { if ( config ( 'chatter.soft_deletes' ) ) { $ post -> discussion -> posts ( ) -> delete ( ) ; $ post -> discussion ( ) -> delete ( ) ; } else { $ post -> discussion -> posts ( ) -> forceDelete ( ) ; $ post -> discussion ( ) -> forceDelete ( ) ; } return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( [ 'chatter_alert_type' => 'success' , 'chatter_alert' => trans ( 'chatter::alert.success.reason.destroy_post' ) , ] ) ; } $ post -> delete ( ) ; $ url = '/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.discussion' ) . '/' . $ post -> discussion -> category -> slug . '/' . $ post -> discussion -> slug ; return redirect ( $ url ) -> with ( [ 'chatter_alert_type' => 'success' , 'chatter_alert' => trans ( 'chatter::alert.success.reason.destroy_from_discussion' ) , ] ) ; } 
private static function replaceUrlParameter ( $ url , $ source ) { $ parameter = static :: urlParameter ( $ url ) ; return str_replace ( '{' . $ parameter . '}' , $ source [ $ parameter ] , $ url ) ; } 
private static function urlParameter ( $ url ) { $ start = strpos ( $ url , '{' ) + 1 ; $ length = strpos ( $ url , '}' ) - $ start ; return substr ( $ url , $ start , $ length ) ; } 
public static function demoteHtmlHeaderTags ( $ html ) { $ originalHeaderTags = [ ] ; $ demotedHeaderTags = [ ] ; foreach ( range ( 100 , 1 ) as $ index ) { $ originalHeaderTags [ ] = '<h' . $ index . '>' ; $ originalHeaderTags [ ] = '</h' . $ index . '>' ; $ demotedHeaderTags [ ] = '<h' . ( $ index + 1 ) . '>' ; $ demotedHeaderTags [ ] = '</h' . ( $ index + 1 ) . '>' ; } return str_ireplace ( $ originalHeaderTags , $ demotedHeaderTags , $ html ) ; } 
public static function categoriesMenu ( $ categories ) { $ menu = '<ul class="nav nav-pills nav-stacked">' ; foreach ( $ categories as $ category ) { $ menu .= '<li>' ; $ menu .= '<a href="/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.category' ) . '/' . $ category [ 'slug' ] . '">' ; $ menu .= '<div class="chatter-box" style="background-color:' . $ category [ 'color' ] . '"></div>' ; $ menu .= $ category [ 'name' ] . '</a>' ; if ( count ( $ category [ 'parents' ] ) ) { $ menu .= static :: categoriesMenu ( $ category [ 'parents' ] ) ; } $ menu .= '</li>' ; } $ menu .= '</ul>' ; return $ menu ; } 
public function run ( ) { <p>You can check me out on twitter at <a href="http://www.twitter.com/tnylea" target="_blank">http: <p>or you can subscribe to me on YouTube at <a href="http://www.youtube.com/devdojo" target="_blank">http: <p>Thanks again for checking out chatter. If you want to login with the default user you can login with the following credentials:</p> <p><strong>email address</strong>: tony@hello.com</p> <p><strong>password</strong>: password</p> <p>You\'ll probably want to delete this user, but if for some reason you want to keep it... Go ahead :)</p>' , 'created_at' => '2016-08-18 14:39:36' , 'updated_at' => '2016-08-18 14:39:36' , ] , 2 => [ 'id' => 6 , 'chatter_discussion_id' => 7 , 'user_id' => 1 , 'body' => '<p>If you would like to leave some feedback or have any issues be sure to visit the github page here: <a href="https://github.com/thedevdojo/chatter" target="_blank">https://github.com/thedevdojo/chatter</a>&nbsp;and I\'m sure I can help out.</p> <p>Let\'s make this package the go to Laravel Forum package. Feel free to contribute and share your ideas :)</p>' , 'created_at' => '2016-08-18 14:42:29' , 'updated_at' => '2016-08-18 14:42:29' , ] , 3 => [ 'id' => 7 , 'chatter_discussion_id' => 8 , 'user_id' => 1 , 'body' => '<p>This is just a random post to show you some of the formatting that you can do in the WYSIWYG editor. You can make your text <strong>bold</strong>, <em>italic</em>, or <span style="text-decoration: underline;">underlined</span>.</p> <p style="text-align: center;">Additionally, you can center align text.</p> <p style="text-align: right;">You can align the text to the right!</p> <p>Or by default it will be aligned to the left.</p> <ul> <li>We can also</li> <li>add a bulleted</li> <li>list</li> </ul> <ol> <li><span style="line-height: 1.6;">or we can</span></li> <li><span style="line-height: 1.6;">add a numbered list</span></li> </ol> <p style="padding-left: 30px;"><span style="line-height: 1.6;">We can choose to indent our text</span></p> <p><span style="line-height: 1.6;">Post links: <a href="https://devdojo.com" target="_blank">https://devdojo.com</a></span></p> <p><span style="line-height: 1.6;">and add images:</span></p> <p><span style="line-height: 1.6;"><img src="https://media.giphy.com/media/o0vwzuFwCGAFO/giphy.gif" alt="" width="300" height="300" /></span></p>' , 'created_at' => '2016-08-18 14:46:38' , 'updated_at' => '2016-08-18 14:46:38' , ] , 4 => [ 'id' => 8 , 'chatter_discussion_id' => 8 , 'user_id' => 1 , 'body' => '<p>Haha :) Cats!</p> <p><img src="https://media.giphy.com/media/5Vy3WpDbXXMze/giphy.gif" alt="" width="250" height="141" /></p> <p><img src="https://media.giphy.com/media/XNdoIMwndQfqE/200.gif" alt="" width="200" height="200" /></p>' , 'created_at' => '2016-08-18 14:55:42' , 'updated_at' => '2016-08-18 15:45:13' , ] , 5 => [ 'id' => 9 , 'chatter_discussion_id' => 9 , 'user_id' => 1 , 'body' => '<p>Hey There!</p> <p>My name is Tony and I\'m the creator of this package that you\'ve just installed. Thanks for checking out it out and if you have any questions or want to contribute be sure to checkout the repo here: <a href="https://github.com/thedevdojo/chatter" target="_blank">https://github.com/thedevdojo/chatter</a></p> <p>Happy programming!</p>' , 'created_at' => '2016-08-18 14:59:37' , 'updated_at' => '2016-08-18 14:59:37' , ] , 6 => [ 'id' => 10 , 'chatter_discussion_id' => 9 , 'user_id' => 1 , 'body' => '<p>Hell yeah Bro Sauce!</p> <p><img src="https://media.giphy.com/media/j5QcmXoFWl4Q0/giphy.gif" alt="" width="366" height="229" /></p>' , 'created_at' => '2016-08-18 15:01:25' , 'updated_at' => '2016-08-18 15:01:25' , ] , ] ) ; } 
public function checkSignature ( Request $ request , Consumer $ consumer , Token $ token , $ signature ) { $ built = $ this -> buildSignature ( $ request , $ consumer , $ token ) ; 
public static function urlencodeRfc3986 ( $ input ) { $ output = '' ; if ( is_array ( $ input ) ) { $ output = array_map ( [ __NAMESPACE__ . '\Util' , 'urlencodeRfc3986' ] , $ input ) ; } elseif ( is_scalar ( $ input ) ) { $ output = rawurlencode ( $ input ) ; } return $ output ; } 
public static function parseParameters ( $ input ) { if ( ! is_string ( $ input ) ) { return [ ] ; } $ pairs = explode ( '&' , $ input ) ; $ parameters = [ ] ; foreach ( $ pairs as $ pair ) { $ split = explode ( '=' , $ pair , 2 ) ; $ parameter = Util :: urldecodeRfc3986 ( $ split [ 0 ] ) ; $ value = isset ( $ split [ 1 ] ) ? Util :: urldecodeRfc3986 ( $ split [ 1 ] ) : '' ; if ( isset ( $ parameters [ $ parameter ] ) ) { 
public function setTimeouts ( $ connectionTimeout , $ timeout ) { $ this -> connectionTimeout = ( int ) $ connectionTimeout ; $ this -> timeout = ( int ) $ timeout ; } 
public function setRetries ( $ maxRetries , $ retriesDelay ) { $ this -> maxRetries = ( int ) $ maxRetries ; $ this -> retriesDelay = ( int ) $ retriesDelay ; } 
public function url ( $ path , array $ parameters ) { $ this -> resetLastResponse ( ) ; $ this -> response -> setApiPath ( $ path ) ; $ query = http_build_query ( $ parameters ) ; return sprintf ( '%s/%s?%s' , self :: API_HOST , $ path , $ query ) ; } 
public function oauth ( $ path , array $ parameters = [ ] ) { $ response = [ ] ; $ this -> resetLastResponse ( ) ; $ this -> response -> setApiPath ( $ path ) ; $ url = sprintf ( '%s/%s' , self :: API_HOST , $ path ) ; $ result = $ this -> oAuthRequest ( $ url , 'POST' , $ parameters ) ; if ( $ this -> getLastHttpCode ( ) != 200 ) { throw new TwitterOAuthException ( $ result ) ; } parse_str ( $ result , $ response ) ; $ this -> response -> setBody ( $ response ) ; return $ response ; } 
public function oauth2 ( $ path , array $ parameters = [ ] ) { $ method = 'POST' ; $ this -> resetLastResponse ( ) ; $ this -> response -> setApiPath ( $ path ) ; $ url = sprintf ( '%s/%s' , self :: API_HOST , $ path ) ; $ request = Request :: fromConsumerAndToken ( $ this -> consumer , $ this -> token , $ method , $ url , $ parameters ) ; $ authorization = 'Authorization: Basic ' . $ this -> encodeAppAuthorization ( $ this -> consumer ) ; $ result = $ this -> request ( $ request -> getNormalizedHttpUrl ( ) , $ method , $ authorization , $ parameters ) ; $ response = JsonDecoder :: decode ( $ result , $ this -> decodeJsonAsArray ) ; $ this -> response -> setBody ( $ response ) ; return $ response ; } 
public function get ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'GET' , self :: API_HOST , $ path , $ parameters , false ) ; } 
public function post ( $ path , array $ parameters = [ ] , $ json = false ) { return $ this -> http ( 'POST' , self :: API_HOST , $ path , $ parameters , $ json ) ; } 
public function delete ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'DELETE' , self :: API_HOST , $ path , $ parameters , false ) ; } 
public function put ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'PUT' , self :: API_HOST , $ path , $ parameters , false ) ; } 
public function upload ( $ path , array $ parameters = [ ] , $ chunked = false ) { if ( $ chunked ) { return $ this -> uploadMediaChunked ( $ path , $ parameters ) ; } else { return $ this -> uploadMediaNotChunked ( $ path , $ parameters ) ; } } 
private function uploadMediaNotChunked ( $ path , array $ parameters ) { if ( ! is_readable ( $ parameters [ 'media' ] ) || ( $ file = file_get_contents ( $ parameters [ 'media' ] ) ) === false ) { throw new \ InvalidArgumentException ( 'You must supply a readable file' ) ; } $ parameters [ 'media' ] = base64_encode ( $ file ) ; return $ this -> http ( 'POST' , self :: UPLOAD_HOST , $ path , $ parameters , false ) ; } 
private function uploadMediaChunked ( $ path , array $ parameters ) { $ init = $ this -> http ( 'POST' , self :: UPLOAD_HOST , $ path , $ this -> mediaInitParameters ( $ parameters ) , false ) ; 
private function mediaInitParameters ( array $ parameters ) { $ allowed_keys = [ 'media_type' , 'additional_owners' , 'media_category' , 'shared' ] ; $ base = [ 'command' => 'INIT' , 'total_bytes' => filesize ( $ parameters [ 'media' ] ) ] ; $ allowed_parameters = array_intersect_key ( $ parameters , array_flip ( $ allowed_keys ) ) ; return array_merge ( $ base , $ allowed_parameters ) ; } 
private function cleanUpParameters ( array $ parameters ) { foreach ( $ parameters as $ key => $ value ) { 
private function http ( $ method , $ host , $ path , array $ parameters , $ json ) { $ this -> resetLastResponse ( ) ; $ this -> resetAttemptsNumber ( ) ; $ url = sprintf ( '%s/%s/%s.json' , $ host , self :: API_VERSION , $ path ) ; $ this -> response -> setApiPath ( $ path ) ; if ( ! $ json ) { $ parameters = $ this -> cleanUpParameters ( $ parameters ) ; } return $ this -> makeRequests ( $ url , $ method , $ parameters , $ json ) ; } 
private function oAuthRequest ( $ url , $ method , array $ parameters , $ json = false ) { $ request = Request :: fromConsumerAndToken ( $ this -> consumer , $ this -> token , $ method , $ url , $ parameters , $ json ) ; if ( array_key_exists ( 'oauth_callback' , $ parameters ) ) { 
private function curlOptions ( ) { $ options = [ 
private function request ( $ url , $ method , $ authorization , array $ postfields , $ json = false ) { $ options = $ this -> curlOptions ( ) ; $ options [ CURLOPT_URL ] = $ url ; $ options [ CURLOPT_HTTPHEADER ] = [ 'Accept: application/json' , $ authorization , 'Expect:' ] ; switch ( $ method ) { case 'GET' : break ; case 'POST' : $ options [ CURLOPT_POST ] = true ; if ( $ json ) { $ options [ CURLOPT_HTTPHEADER ] [ ] = 'Content-type: application/json' ; $ options [ CURLOPT_POSTFIELDS ] = json_encode ( $ postfields ) ; } else { $ options [ CURLOPT_POSTFIELDS ] = Util :: buildHttpQuery ( $ postfields ) ; } break ; case 'DELETE' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case 'PUT' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; } if ( in_array ( $ method , [ 'GET' , 'PUT' , 'DELETE' ] ) && ! empty ( $ postfields ) ) { $ options [ CURLOPT_URL ] .= '?' . Util :: buildHttpQuery ( $ postfields ) ; } $ curlHandle = curl_init ( ) ; curl_setopt_array ( $ curlHandle , $ options ) ; $ response = curl_exec ( $ curlHandle ) ; 
private function parseHeaders ( $ header ) { $ headers = [ ] ; foreach ( explode ( "\r\n" , $ header ) as $ line ) { if ( strpos ( $ line , ':' ) !== false ) { list ( $ key , $ value ) = explode ( ': ' , $ line ) ; $ key = str_replace ( '-' , '_' , strtolower ( $ key ) ) ; $ headers [ $ key ] = trim ( $ value ) ; } } return $ headers ; } 
private function encodeAppAuthorization ( Consumer $ consumer ) { $ key = rawurlencode ( $ consumer -> key ) ; $ secret = rawurlencode ( $ consumer -> secret ) ; return base64_encode ( $ key . ':' . $ secret ) ; } 
public static function decode ( $ string , $ asArray ) { if ( version_compare ( PHP_VERSION , '5.4.0' , '>=' ) && ! ( defined ( 'JSON_C_VERSION' ) && PHP_INT_SIZE > 4 ) ) { return json_decode ( $ string , $ asArray , 512 , JSON_BIGINT_AS_STRING ) ; } return json_decode ( $ string , $ asArray ) ; } 
public static function fromConsumerAndToken ( Consumer $ consumer , Token $ token = null , $ httpMethod , $ httpUrl , array $ parameters = [ ] , $ json = false ) { $ defaults = [ "oauth_version" => Request :: $ version , "oauth_nonce" => Request :: generateNonce ( ) , "oauth_timestamp" => time ( ) , "oauth_consumer_key" => $ consumer -> key ] ; if ( null !== $ token ) { $ defaults [ 'oauth_token' ] = $ token -> key ; } 
public function getSignableParameters ( ) { 
public function getNormalizedHttpUrl ( ) { $ parts = parse_url ( $ this -> httpUrl ) ; $ scheme = $ parts [ 'scheme' ] ; $ host = strtolower ( $ parts [ 'host' ] ) ; $ path = $ parts [ 'path' ] ; return "$scheme://$host$path" ; } 
public function toUrl ( ) { $ postData = $ this -> toPostdata ( ) ; $ out = $ this -> getNormalizedHttpUrl ( ) ; if ( $ postData ) { $ out .= '?' . $ postData ; } return $ out ; } 
public function toHeader ( ) { $ first = true ; $ out = 'Authorization: OAuth' ; foreach ( $ this -> parameters as $ k => $ v ) { if ( substr ( $ k , 0 , 5 ) != "oauth" ) { continue ; } if ( is_array ( $ v ) ) { throw new TwitterOAuthException ( 'Arrays not supported in headers' ) ; } $ out .= ( $ first ) ? ' ' : ', ' ; $ out .= Util :: urlencodeRfc3986 ( $ k ) . '="' . Util :: urlencodeRfc3986 ( $ v ) . '"' ; $ first = false ; } return $ out ; } 
public function buildSignature ( SignatureMethod $ signatureMethod , Consumer $ consumer , Token $ token = null ) { return $ signatureMethod -> buildSignature ( $ this , $ consumer , $ token ) ; } 
public function buildSignature ( Request $ request , Consumer $ consumer , Token $ token = null ) { $ signatureBase = $ request -> getSignatureBaseString ( ) ; $ parts = [ $ consumer -> secret , null !== $ token ? $ token -> secret : "" ] ; $ parts = Util :: urlencodeRfc3986 ( $ parts ) ; $ key = implode ( '&' , $ parts ) ; return base64_encode ( hash_hmac ( 'sha1' , $ signatureBase , $ key , true ) ) ; } 
public function boot ( ) { if ( $ this -> app -> runningInConsole ( ) ) { $ this -> publishes ( [ __DIR__ . '/../database/migrations' => database_path ( 'migrations' ) , ] , 'migrations' ) ; $ this -> commands ( [ \ Appstract \ Options \ Console \ OptionSetCommand :: class , ] ) ; } } 
public function get ( $ key , $ default = null ) { if ( $ option = self :: where ( 'key' , $ key ) -> first ( ) ) { return $ option -> value ; } return $ default ; } 
public function set ( $ key , $ value = null ) { $ keys = is_array ( $ key ) ? $ key : [ $ key => $ value ] ; foreach ( $ keys as $ key => $ value ) { self :: updateOrCreate ( [ 'key' => $ key ] , [ 'value' => $ value ] ) ; } 
public function queryToMany ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryAllOrOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; } 
public function queryToOne ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; } 
protected function readWithFilters ( $ record , EncodingParametersInterface $ parameters ) { $ query = $ this -> newQuery ( ) -> whereKey ( $ record -> getKey ( ) ) ; $ this -> applyFilters ( $ query , collect ( $ parameters -> getFilteringParameters ( ) ) ) ; return $ query -> exists ( ) ? $ record : null ; } 
protected function applyFilters ( $ query , Collection $ filters ) { if ( $ this -> isFindMany ( $ filters ) ) { $ this -> filterByIds ( $ query , $ filters ) ; } $ this -> filter ( $ query , $ filters ) ; } 
protected function fillRelated ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ relationships = $ resource -> getRelationships ( ) ; $ changed = false ; foreach ( $ relationships as $ field => $ value ) { if ( $ this -> isNotFillable ( $ field , $ record ) ) { continue ; } if ( ! $ this -> isRelation ( $ field ) ) { continue ; } $ relation = $ this -> getRelated ( $ field ) ; if ( $ this -> requiresPrimaryRecordPersistence ( $ relation ) ) { $ relation -> update ( $ record , $ value , $ parameters ) ; $ changed = true ; } } if ( $ changed ) { $ record -> refresh ( ) ; } } 
protected function paginate ( $ query , EncodingParametersInterface $ parameters ) { if ( ! $ this -> paging ) { throw new RuntimeException ( 'Paging is not supported on adapter: ' . get_class ( $ this ) ) ; } if ( method_exists ( $ this -> paging , 'withQualifiedKeyName' ) ) { $ this -> paging -> withQualifiedKeyName ( $ this -> getQualifiedKeyName ( ) ) ; } return $ this -> paging -> paginate ( $ query , $ parameters ) ; } 
protected function queryAllOrOne ( $ query , EncodingParametersInterface $ parameters ) { $ filters = collect ( $ parameters -> getFilteringParameters ( ) ) ; if ( $ this -> isSearchOne ( $ filters ) ) { return $ this -> queryOne ( $ query , $ parameters ) ; } return $ this -> queryAll ( $ query , $ parameters ) ; } 
protected function getQueryParameters ( EncodingParametersInterface $ parameters ) { return new EncodingParameters ( $ parameters -> getIncludePaths ( ) , $ parameters -> getFieldSets ( ) , $ parameters -> getSortParameters ( ) ? : $ this -> defaultSort ( ) , $ parameters -> getPaginationParameters ( ) ? : $ this -> defaultPagination ( ) , $ parameters -> getFilteringParameters ( ) , $ parameters -> getUnrecognizedParameters ( ) ) ; } 
public static function defaultApi ( string $ name ) : self { if ( empty ( $ name ) ) { throw new \ InvalidArgumentException ( 'Default API name must not be empty.' ) ; } self :: $ defaultApi = $ name ; return new self ( ) ; } 
public function add ( ResourceIdentifierInterface $ identifier , $ record ) { if ( ! is_object ( $ record ) && ! is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Expecting an object or a boolean to add to the identity map.' ) ; } $ existing = $ this -> lookup ( $ identifier ) ; if ( is_object ( $ existing ) && is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Attempting to push a boolean into the map in place of an object.' ) ; } $ this -> map [ $ identifier -> toString ( ) ] = $ record ; return $ this ; } 
public function exists ( ResourceIdentifierInterface $ identifier ) { $ record = $ this -> lookup ( $ identifier ) ; return is_object ( $ record ) ? true : $ record ; } 
public function find ( ResourceIdentifierInterface $ identifier ) { $ record = $ this -> lookup ( $ identifier ) ; if ( false === $ record ) { return false ; } return is_object ( $ record ) ? $ record : null ; } 
public function getParameters ( ) : EncodingParametersInterface { if ( $ this -> parameters ) { return $ this -> parameters ; } return $ this -> parameters = $ this -> container -> make ( EncodingParametersInterface :: class ) ; } 
public function isIndex ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isNotResource ( ) && $ this -> getRoute ( ) -> isNotProcesses ( ) ; } 
public function isReadResource ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; } 
public function isUpdateResource ( ) : bool { return $ this -> isMethod ( 'patch' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; } 
public function isDeleteResource ( ) : bool { return $ this -> isMethod ( 'delete' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; } 
public function isReadProcesses ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isProcesses ( ) && $ this -> getRoute ( ) -> isNotProcess ( ) ; } 
public function allow ( string $ resourceType , array $ fields = null ) : self { $ this -> all = false ; $ this -> allowed [ $ resourceType ] = $ fields ; return $ this ; } 
public function any ( string ... $ resourceTypes ) : self { foreach ( $ resourceTypes as $ resourceType ) { $ this -> allow ( $ resourceType , null ) ; } return $ this ; } 
public function none ( string ... $ resourceTypes ) : self { foreach ( $ resourceTypes as $ resourceType ) { $ this -> allow ( $ resourceType , [ ] ) ; } return $ this ; } 
protected function allowed ( string $ resourceType , string $ fields ) : bool { return $ this -> notAllowed ( $ resourceType , $ fields ) -> isEmpty ( ) ; } 
protected function notAllowed ( string $ resourceType , string $ fields ) : Collection { $ fields = collect ( explode ( ',' , $ fields ) ) ; if ( ! $ this -> allowed -> has ( $ resourceType ) ) { return $ fields ; } $ allowed = $ this -> allowed -> get ( $ resourceType ) ; if ( is_null ( $ allowed ) ) { return collect ( ) ; } $ allowed = collect ( ( array ) $ allowed ) ; return $ fields -> reject ( function ( $ value ) use ( $ allowed ) { return $ allowed -> contains ( $ value ) ; } ) ; } 
protected function invalid ( ) : Collection { if ( ! is_array ( $ this -> value ) ) { return collect ( ) ; } return collect ( $ this -> value ) -> map ( function ( $ value , $ key ) { return $ this -> notAllowed ( $ key , $ value ) ; } ) -> flatMap ( function ( Collection $ fields , $ type ) { return $ fields -> map ( function ( $ field ) use ( $ type ) { return "{$type}.{$field}" ; } ) ; } ) ; } 
protected function sort ( $ query , array $ sortBy ) { foreach ( $ sortBy as $ param ) { $ this -> sortBy ( $ query , $ param ) ; } } 
protected function defaultSort ( ) { return collect ( $ this -> defaultSort ) -> map ( function ( $ param ) { $ desc = ( $ param [ 0 ] === '-' ) ; $ field = ltrim ( $ param , '-' ) ; return new SortParameter ( $ field , ! $ desc ) ; } ) -> all ( ) ; } 
protected function getSortColumn ( $ field , Model $ model ) { if ( isset ( $ this -> sortColumns [ $ field ] ) ) { return $ this -> sortColumns [ $ field ] ; } return $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; } 
public function middleware ( string ... $ middleware ) : self { $ this -> attributes [ 'middleware' ] = array_merge ( Arr :: wrap ( $ this -> attributes [ 'middleware' ] ?? [ ] ) , $ middleware ) ; return $ this ; } 
public function handle ( $ event ) : void { if ( ! $ job = $ this -> deserialize ( $ event -> job ) ) { return ; } $ clientJob = $ job -> clientJob ?? null ; if ( ! $ clientJob instanceof AsynchronousProcess ) { return ; } $ clientJob -> processed ( $ event -> job ) ; } 
public function field ( string $ field , string $ inverse = null ) : self { $ this -> defaults = array_merge ( $ this -> defaults , [ ResourceRegistrar :: PARAM_RELATIONSHIP_NAME => $ field , ResourceRegistrar :: PARAM_RELATIONSHIP_INVERSE_TYPE => $ inverse ? : Str :: plural ( $ field ) , ] ) ; return $ this ; } 
public static function create ( $ mediaType , int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , new EncoderOptions ( $ options , $ urlPrefix , $ depth ) ) ; } 
public static function jsonApi ( int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { return self :: create ( MediaTypeInterface :: JSON_API_MEDIA_TYPE , $ options , $ urlPrefix , $ depth ) ; } 
public static function custom ( $ mediaType ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , null ) ; } 
public function is ( string ... $ mediaTypes ) : bool { $ mediaTypes = collect ( $ mediaTypes ) -> map ( function ( $ mediaType , $ index ) { return MediaType :: parse ( $ index , $ mediaType ) ; } ) ; return $ this -> any ( ... $ mediaTypes ) ; } 
public function accept ( AcceptMediaTypeInterface $ mediaType ) : bool { 
public static function create ( array $ parameters , $ beforeKey = 'before' , $ afterKey = 'after' , $ limitKey = 'limit' ) { return new self ( array_get ( $ parameters , $ beforeKey ) , array_get ( $ parameters , $ afterKey ) , array_get ( $ parameters , $ limitKey , 15 ) ) ; } 
public function register ( ) { $ this -> bindNeomerx ( ) ; $ this -> bindService ( ) ; $ this -> bindInboundRequest ( ) ; $ this -> bindRouteRegistrar ( ) ; $ this -> bindApiRepository ( ) ; $ this -> bindExceptionParser ( ) ; $ this -> bindRenderer ( ) ; $ this -> mergePackageConfig ( ) ; } 
protected function bootMiddleware ( Router $ router ) { $ router -> aliasMiddleware ( 'json-api' , BootJsonApi :: class ) ; $ router -> aliasMiddleware ( 'json-api.content' , NegotiateContent :: class ) ; $ router -> aliasMiddleware ( 'json-api.auth' , Authorize :: class ) ; } 
protected function bootResponseMacro ( ) { Response :: macro ( 'jsonApi' , function ( $ api = null ) { return json_api ( $ api ) -> getResponses ( ) -> withEncodingParameters ( app ( EncodingParametersInterface :: class ) ) ; } ) ; } 
protected function bootBladeDirectives ( ) { $ compiler = $ this -> app -> make ( BladeCompiler :: class ) ; $ compiler -> directive ( 'jsonapi' , Renderer :: class . '::compileWith' ) ; $ compiler -> directive ( 'encode' , Renderer :: class . '::compileEncode' ) ; } 
protected function bindNeomerx ( ) { $ this -> app -> singleton ( Factory :: class , function ( Application $ app ) { $ factory = new Factory ( $ app ) ; $ factory -> setLogger ( $ app -> make ( LoggerInterface :: class ) ) ; return $ factory ; } ) ; $ this -> app -> alias ( Factory :: class , FactoryInterface :: class ) ; $ this -> app -> alias ( Factory :: class , NeomerxFactoryInterface :: class ) ; $ this -> app -> alias ( Factory :: class , DocumentFactoryInterface :: class ) ; $ this -> app -> alias ( Factory :: class , HandlerFactoryInterface :: class ) ; $ this -> app -> alias ( Factory :: class , HttpFactoryInterface :: class ) ; $ this -> app -> alias ( Factory :: class , ParserFactoryInterface :: class ) ; $ this -> app -> alias ( Factory :: class , SchemaFactoryInterface :: class ) ; $ this -> app -> alias ( Factory :: class , StackFactoryInterface :: class ) ; } 
protected function bindService ( ) { $ this -> app -> singleton ( JsonApiService :: class ) ; $ this -> app -> alias ( JsonApiService :: class , 'json-api' ) ; $ this -> app -> alias ( JsonApiService :: class , 'json-api.service' ) ; } 
protected function bindInboundRequest ( ) { $ this -> app -> singleton ( JsonApiRequest :: class ) ; $ this -> app -> alias ( JsonApiRequest :: class , 'json-api.request' ) ; $ this -> app -> singleton ( Route :: class , function ( Application $ app ) { return new Route ( $ app -> make ( ResolverInterface :: class ) , $ app -> make ( 'router' ) -> current ( ) ) ; } ) ; $ this -> app -> bind ( StoreInterface :: class , function ( ) { return json_api ( ) -> getStore ( ) ; } ) ; $ this -> app -> bind ( ResolverInterface :: class , function ( ) { return json_api ( ) -> getResolver ( ) ; } ) ; $ this -> app -> bind ( ErrorRepositoryInterface :: class , function ( ) { return json_api ( ) -> getErrors ( ) ; } ) ; $ this -> app -> bind ( ContainerInterface :: class , function ( ) { return json_api ( ) -> getContainer ( ) ; } ) ; $ this -> app -> singleton ( HeaderParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createHeaderParametersParser ( ) ; $ serverRequest = $ app -> make ( ServerRequestInterface :: class ) ; return $ parser -> parse ( $ serverRequest , http_contains_body ( $ serverRequest ) ) ; } ) ; $ this -> app -> singleton ( EncodingParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createQueryParametersParser ( ) ; return $ parser -> parseQueryParameters ( request ( ) -> query ( ) ) ; } ) ; } 
protected function bindExceptionParser ( ) { $ this -> app -> singleton ( ExceptionParserInterface :: class , ExceptionParser :: class ) ; $ this -> app -> alias ( ExceptionParserInterface :: class , 'json-api.exceptions' ) ; } 
protected function make ( array $ data ) { $ validator = $ this -> validatorFactory -> make ( $ data , $ this -> getRules ( ) , $ this -> getMessages ( ) , $ this -> getAttributes ( ) ) ; $ this -> configureValidator ( $ validator ) ; return $ validator ; } 
protected function isFillable ( $ field , $ record ) { if ( in_array ( $ field , $ fillable = $ this -> getFillable ( $ record ) ) ) { return true ; } if ( $ this -> isGuarded ( $ field , $ record ) ) { return false ; } return empty ( $ fillable ) ; } 
public function all ( ) { if ( is_array ( $ this -> data ) ) { return $ this -> data ; } return $ this -> data = $ this -> route -> getCodec ( ) -> all ( $ this -> request ) ; } 
public function checkHeaders ( HeaderParametersInterface $ parameters ) { 
protected function checkAcceptHeader ( HeaderParametersInterface $ parameters ) { $ this -> codecMatcher -> matchEncoder ( $ parameters -> getAcceptHeader ( ) ) ; 
protected function checkContentTypeHeader ( HeaderParametersInterface $ parameters ) { 
public function handle ( ) { $ resourceParameter = [ 'resource' => $ this -> argument ( 'resource' ) , 'api' => $ this -> argument ( 'api' ) , ] ; $ eloquentParameters = array_merge ( $ resourceParameter , [ '--eloquent' => $ this -> option ( 'eloquent' ) , '--no-eloquent' => $ this -> option ( 'no-eloquent' ) , ] ) ; $ commands = collect ( $ this -> commands ) ; if ( $ commands -> isEmpty ( ) ) { $ this -> info ( 'No files created.' ) ; return 0 ; } if ( $ this -> option ( 'only' ) || $ this -> option ( 'except' ) ) { $ type = $ this -> option ( 'only' ) ? 'only' : 'except' ; $ commands = $ this -> filterCommands ( $ commands , $ type ) ; } $ notEloquent = [ 'make:json-api:validators' ] ; if ( ! $ this -> runCommandsWithParameters ( $ commands -> only ( $ notEloquent ) , $ resourceParameter ) ) { return 1 ; } $ eloquent = [ 'make:json-api:adapter' , 'make:json-api:schema' ] ; if ( ! $ this -> runCommandsWithParameters ( $ commands -> only ( $ eloquent ) , $ eloquentParameters ) ) { return 1 ; } if ( $ this -> option ( 'auth' ) ) { $ this -> call ( 'make:json-api:authorizer' , [ 'name' => $ this -> argument ( 'resource' ) , 'api' => $ this -> argument ( 'api' ) , '--resource' => true , ] ) ; } if ( $ this -> option ( 'content-negotiator' ) ) { $ this -> call ( 'make:json-api:content-negotiator' , [ 'name' => $ this -> argument ( 'resource' ) , 'api' => $ this -> argument ( 'api' ) , '--resource' => true , ] ) ; } $ this -> comment ( 'All done, keep doing what you do.' ) ; return 0 ; } 
private function filterCommands ( Collection $ commands , $ type ) { $ baseCommandName = 'make:json-api:' ; $ filterValues = explode ( ',' , $ this -> option ( $ type ) ) ; $ targetCommands = collect ( $ filterValues ) -> map ( function ( $ target ) use ( $ baseCommandName ) { return $ baseCommandName . strtolower ( trim ( $ target ) ) ; } ) ; return $ commands -> { $ type } ( $ targetCommands -> toArray ( ) ) ; } 
private function runCommandsWithParameters ( Collection $ commands , array $ parameters ) { foreach ( $ commands -> keys ( ) as $ command ) { if ( 0 !== $ this -> call ( $ command , $ parameters ) ) { return false ; } } return true ; } 
protected function validateTypeMember ( $ value , string $ path ) : bool { if ( ! is_string ( $ value ) ) { $ this -> memberNotString ( $ path , 'type' ) ; return false ; } if ( empty ( $ value ) ) { $ this -> memberEmpty ( $ path , 'type' ) ; return false ; } if ( ! $ this -> store -> isType ( $ value ) ) { $ this -> resourceTypeNotRecognised ( $ value , $ path ) ; return false ; } return true ; } 
protected function validateIdMember ( $ value , string $ path ) : bool { if ( ! is_string ( $ value ) ) { $ this -> memberNotString ( $ path , 'id' ) ; return false ; } if ( empty ( $ value ) ) { $ this -> memberEmpty ( $ path , 'id' ) ; return false ; } return true ; } 
protected function validateIdentifier ( $ value , string $ path , ? int $ index = null ) : bool { $ member = is_int ( $ index ) ? ( string ) $ index : 'data' ; if ( ! is_object ( $ value ) ) { $ this -> memberNotObject ( $ path , $ member ) ; return false ; } $ dataPath = sprintf ( '%s/%s' , rtrim ( $ path , '/' ) , $ member ) ; $ valid = true ; if ( ! property_exists ( $ value , 'type' ) ) { $ this -> memberRequired ( $ dataPath , 'type' ) ; $ valid = false ; } else if ( ! $ this -> validateTypeMember ( $ value -> type , $ dataPath ) ) { $ valid = false ; } if ( ! property_exists ( $ value , 'id' ) ) { $ this -> memberRequired ( $ dataPath , 'id' ) ; $ valid = false ; } else if ( ! $ this -> validateIdMember ( $ value -> id , $ dataPath ) ) { $ valid = false ; } if ( property_exists ( $ value , 'attributes' ) || property_exists ( $ value , 'relationships' ) ) { $ this -> memberNotIdentifier ( $ path , $ member ) ; $ valid = false ; } return $ valid ; } 
protected function validateRelationship ( $ relation , ? string $ field = null ) : bool { $ path = $ field ? '/data/relationships' : '/' ; $ member = $ field ? : 'data' ; if ( ! is_object ( $ relation ) ) { $ this -> memberNotObject ( $ path , $ member ) ; return false ; } $ path = $ field ? "{$path}/{$field}" : $ path ; if ( ! property_exists ( $ relation , 'data' ) ) { $ this -> memberRequired ( $ path , 'data' ) ; return false ; } $ data = $ relation -> data ; if ( is_array ( $ data ) ) { return $ this -> validateToMany ( $ data , $ field ) ; } return $ this -> validateToOne ( $ data , $ field ) ; } 
protected function validateToOne ( $ value , ? string $ field = null ) : bool { if ( is_null ( $ value ) ) { return true ; } $ dataPath = $ field ? "/data/relationships/{$field}" : "/" ; $ identifierPath = $ field ? "/data/relationships/{$field}" : "/data" ; if ( ! $ this -> validateIdentifier ( $ value , $ dataPath ) ) { return false ; } if ( ! $ this -> store -> exists ( new ResourceIdentifier ( $ value ) ) ) { $ this -> resourceDoesNotExist ( $ identifierPath ) ; return false ; } return true ; } 
protected function validateToMany ( array $ value , ? string $ field = null ) : bool { $ path = $ field ? "/data/relationships/{$field}/data" : "/data" ; $ valid = true ; foreach ( $ value as $ index => $ item ) { if ( ! $ this -> validateIdentifier ( $ item , $ path , $ index ) ) { $ valid = false ; continue ; } if ( $ this -> isNotFound ( $ item -> type , $ item -> id ) ) { $ this -> resourceDoesNotExist ( "{$path}/{$index}" ) ; $ valid = false ; } } return $ valid ; } 
protected function dataHas ( $ key ) : bool { if ( ! isset ( $ this -> document -> data ) ) { return false ; } return property_exists ( $ this -> document -> data , $ key ) ; } 
protected function dataGet ( $ key , $ default = null ) { if ( ! isset ( $ this -> document -> data ) ) { return $ default ; } return data_get ( $ this -> document -> data , $ key , $ default ) ; } 
protected function isNotFound ( string $ type , string $ id ) : bool { return ! $ this -> store -> exists ( ResourceIdentifier :: create ( $ type , $ id ) ) ; } 
protected function memberRequired ( string $ path , string $ member ) : void { $ this -> errors -> add ( $ this -> translator -> memberRequired ( $ path , $ member ) ) ; } 
protected function memberFieldsNotAllowed ( string $ path , string $ member , iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> memberFieldNotAllowed ( $ path , $ member , $ field ) ) ; } } 
protected function resourceTypeNotSupported ( string $ actual , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceTypeNotSupported ( $ actual , $ path ) ) ; } 
protected function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotSupportClientIds ( $ type , $ path ) ) ; } 
protected function resourceExists ( string $ type , string $ id , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceExists ( $ type , $ id , $ path ) ) ; } 
protected function resourceDoesNotExist ( string $ path ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotExist ( $ path ) ) ; } 
protected function resourceFieldsExistInAttributesAndRelationships ( iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> resourceFieldExistsInAttributesAndRelationships ( $ field ) ) ; } } 
public function isJsonApi ( $ request , Exception $ e ) { if ( Helpers :: wantsJsonApi ( $ request ) ) { return true ; } $ route = app ( JsonApiService :: class ) -> currentRoute ( ) ; return $ route -> hasCodec ( ) && $ route -> getCodec ( ) -> willEncode ( ) ; } 
protected function prepareJsonApiException ( JsonApiException $ ex ) { $ error = collect ( $ ex -> getErrors ( ) ) -> map ( function ( ErrorInterface $ err ) { return $ err -> getDetail ( ) ? : $ err -> getTitle ( ) ; } ) -> filter ( ) -> first ( ) ; return new HttpException ( $ ex -> getHttpCode ( ) , $ error , $ ex ) ; } 
public function withMediaType ( string $ mediaType ) : self { if ( ! $ encoding = $ this -> api -> getEncodings ( ) -> find ( $ mediaType ) ) { throw new \ InvalidArgumentException ( "Media type {$mediaType} is not valid for API {$this->api->getName()}." ) ; } $ codec = $ this -> factory -> createCodec ( $ this -> api -> getContainer ( ) , $ encoding , null ) ; return $ this -> withCodec ( $ codec ) ; } 
public function withEncoding ( int $ options = 0 , int $ depth = 512 , string $ mediaType = MediaTypeInterface :: JSON_API_MEDIA_TYPE ) { $ encoding = Encoding :: create ( $ mediaType , $ options , $ this -> api -> getUrl ( ) -> toString ( ) , $ depth ) ; $ codec = $ this -> factory -> createCodec ( $ this -> api -> getContainer ( ) , $ encoding , null ) ; return $ this -> withCodec ( $ codec ) ; } 
public function updated ( $ resource = null , array $ links = [ ] , $ meta = null , array $ headers = [ ] ) { return $ this -> getResourceResponse ( $ resource , $ links , $ meta , $ headers ) ; } 
public function deleted ( $ resource = null , array $ links = [ ] , $ meta = null , array $ headers = [ ] ) { return $ this -> getResourceResponse ( $ resource , $ links , $ meta , $ headers ) ; } 
public function error ( $ error , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( is_string ( $ error ) ) { $ error = $ this -> api -> getErrors ( ) -> error ( $ error ) ; } else if ( is_array ( $ error ) ) { $ error = Error :: create ( $ error ) ; } if ( ! $ error instanceof ErrorInterface ) { throw new \ InvalidArgumentException ( 'Expecting a string, array or error object.' ) ; } return $ this -> errors ( $ error , $ defaultStatusCode , $ headers ) ; } 
public function errors ( $ errors , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( $ errors instanceof ErrorResponseInterface ) { return $ this -> getErrorResponse ( $ errors ) ; } if ( is_array ( $ errors ) ) { $ errors = $ this -> api -> getErrors ( ) -> errors ( ... $ errors ) ; } return $ this -> errors ( $ this -> factory -> createErrorResponse ( $ errors , $ defaultStatusCode , $ headers ) ) ; } 
public function exception ( \ Exception $ ex ) { if ( $ this -> getCodec ( ) -> willNotEncode ( ) ) { $ this -> codec = $ this -> api -> getDefaultCodec ( ) ; } return $ this -> getErrorResponse ( $ this -> exceptions -> parse ( $ ex ) ) ; } 
protected function isNoContent ( $ resource , $ links , $ meta ) { return is_null ( $ resource ) && empty ( $ links ) && empty ( $ meta ) ; } 
public function getErrors ( ) { if ( ! is_null ( $ this -> errors ) ) { return collect ( $ this -> errors ) ; } try { $ this -> errors = $ this -> parse ( ) ; } catch ( \ Exception $ ex ) { $ this -> errors = [ ] ; } return collect ( $ this -> errors ) ; } 
private function parse ( ) { if ( ! $ this -> response ) { return [ ] ; } $ body = json_decode ( ( string ) $ this -> response -> getBody ( ) , true ) ; return isset ( $ body [ 'errors' ] ) ? $ body [ 'errors' ] : [ ] ; } 
public function add ( $ record , array $ relationship , EncodingParametersInterface $ parameters ) { $ related = $ this -> findRelated ( $ record , $ relationship ) ; $ relation = $ this -> getRelation ( $ record , $ this -> key ) ; $ existing = $ relation -> getQuery ( ) -> whereKey ( $ related -> modelKeys ( ) ) -> get ( ) ; $ relation -> saveMany ( $ related -> diff ( $ existing ) ) ; $ record -> refresh ( ) ; 
protected function findRelated ( $ record , array $ relationship ) { $ inverse = $ this -> getRelation ( $ record , $ this -> key ) -> getRelated ( ) ; $ related = $ this -> findToMany ( $ relationship ) ; $ related = collect ( $ related ) -> filter ( function ( $ model ) use ( $ inverse ) { return $ model instanceof $ inverse ; } ) ; return new Collection ( $ related ) ; } 
protected function getDefaultAttributes ( Model $ model ) { $ defaults = [ ] ; if ( $ this -> hasCreatedAtAttribute ( $ model ) ) { $ createdAt = $ model -> getCreatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ createdAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ createdAt , $ field ) ; } if ( $ this -> hasUpdatedAtAttribute ( $ model ) ) { $ updatedAt = $ model -> getUpdatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ updatedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ updatedAt , $ field ) ; } if ( $ this -> hasDeletedAtAttribute ( $ model ) ) { $ deletedAt = $ model -> getDeletedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ deletedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ deletedAt , $ field ) ; } return $ defaults ; } 
protected function getModelAttributes ( Model $ model ) { $ attributes = [ ] ; foreach ( $ this -> attributeKeys ( $ model ) as $ modelKey => $ field ) { if ( is_numeric ( $ modelKey ) ) { $ modelKey = $ field ; $ field = $ this -> fieldForAttribute ( $ field ) ; } $ attributes [ $ field ] = $ this -> extractAttribute ( $ model , $ modelKey , $ field ) ; } return $ attributes ; } 
protected function attributeKeys ( Model $ model ) { if ( is_array ( $ this -> attributes ) ) { return $ this -> attributes ; } return $ model -> getVisible ( ) ; } 
public function memberRequired ( string $ path , string $ member ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'member_required' , 'code' ) , $ this -> trans ( 'member_required' , 'title' ) , $ this -> trans ( 'member_required' , 'detail' , compact ( 'member' ) ) , $ this -> pointer ( $ path ) ) ; } 
public function resourceTypeNotRecognised ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'resource_type_not_recognised' , 'code' ) , $ this -> trans ( 'resource_type_not_recognised' , 'title' ) , $ this -> trans ( 'resource_type_not_recognised' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'type' ) ) ; } 
public function resourceIdNotSupported ( string $ id , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_CONFLICT , $ this -> trans ( 'resource_id_not_supported' , 'code' ) , $ this -> trans ( 'resource_id_not_supported' , 'title' ) , $ this -> trans ( 'resource_id_not_supported' , 'detail' , compact ( 'id' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; } 
public function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_FORBIDDEN , $ this -> trans ( 'resource_client_ids_not_supported' , 'code' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'title' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; } 
public function resourceDoesNotExist ( string $ path ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_NOT_FOUND , $ this -> trans ( 'resource_not_found' , 'code' ) , $ this -> trans ( 'resource_not_found' , 'title' ) , $ this -> trans ( 'resource_not_found' , 'detail' ) , $ this -> pointer ( $ path ) ) ; } 
public function resourceCannotBeDeleted ( string $ detail = null ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_cannot_be_deleted' , 'code' ) , $ this -> trans ( 'resource_cannot_be_deleted' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_cannot_be_deleted' , 'detail' ) ) ; } 
public function invalidResource ( string $ path , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_invalid' , 'code' ) , $ this -> trans ( 'resource_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_invalid' , 'detail' ) , $ this -> pointer ( $ path ) , $ failed ? compact ( 'failed' ) : null ) ; } 
public function invalidQueryParameter ( string $ param , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'query_invalid' , 'code' ) , $ this -> trans ( 'query_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'query_invalid' , 'detail' ) , [ Error :: SOURCE_PARAMETER => $ param ] , $ failed ? compact ( 'failed' ) : null ) ; } 
public function failedValidator ( ValidatorContract $ validator , \ Closure $ closure = null ) : ErrorCollection { $ failed = $ this -> doesIncludeFailed ( ) ? $ validator -> failed ( ) : [ ] ; $ errors = new ErrorCollection ( ) ; foreach ( $ validator -> errors ( ) -> messages ( ) as $ key => $ messages ) { $ failures = $ this -> createValidationFailures ( $ failed [ $ key ] ?? [ ] ) ; foreach ( $ messages as $ detail ) { $ failed = $ failures -> shift ( ) ? : [ ] ; if ( $ closure ) { $ errors -> add ( $ this -> call ( $ closure , $ key , $ detail , $ failed ) ) ; continue ; } $ errors -> add ( new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'failed_validator' , 'code' ) , $ this -> trans ( 'failed_validator' , 'title' ) , $ detail ? : $ this -> trans ( 'failed_validator' , 'detail' ) ) ) ; } } return $ errors ; } 
public function failedValidatorException ( ValidatorContract $ validator , \ Closure $ closure = null ) : JsonApiException { return new ValidationException ( $ this -> failedValidator ( $ validator , $ closure ) ) ; } 
protected function trans ( string $ key , string $ member , array $ replace = [ ] , ? string $ locale = null ) { return $ this -> translator -> trans ( "jsonapi::errors.{$key}.{$member}" , $ replace , $ locale ) ? : null ; } 
protected function pointer ( string $ path , ? string $ member = null ) : array { $ withoutMember = is_null ( $ member ) || '' === $ member ; $ pointer = ! $ withoutMember ? sprintf ( '%s/%s' , rtrim ( $ path , '/' ) , $ member ) : $ path ; return [ Error :: SOURCE_POINTER => $ pointer ] ; } 
protected function createBelongsToIdentity ( Model $ model , $ relationshipKey ) { $ relation = $ model -> { $ relationshipKey } ( ) ; if ( ! $ relation instanceof BelongsTo ) { throw new RuntimeException ( sprintf ( 'Expecting %s on %s to be a belongs-to relationship.' , $ relationshipKey , get_class ( $ model ) ) ) ; } 
protected function createModelIdentity ( $ modelClass , $ id , $ keyName = null ) { if ( is_null ( $ id ) ) { return null ; } $ model = new $ modelClass ( ) ; if ( ! $ model instanceof Model ) { throw new RuntimeException ( sprintf ( 'Expecting a model class, got %s.' , $ modelClass ) ) ; } $ model -> setAttribute ( $ keyName ? : $ model -> getRouteKeyName ( ) , $ id ) ; return $ model ; } 
protected function with ( $ query , EncodingParametersInterface $ parameters ) { $ query -> with ( $ this -> getRelationshipPaths ( ( array ) $ parameters -> getIncludePaths ( ) ) ) ; } 
protected function load ( $ record , EncodingParametersInterface $ parameters ) { $ relationshipPaths = $ this -> getRelationshipPaths ( $ parameters -> getIncludePaths ( ) ) ; $ record -> loadMissing ( $ relationshipPaths ) ; } 
protected function getRelationshipPaths ( $ includePaths ) { return $ this -> convertIncludePaths ( $ includePaths ) -> merge ( $ this -> defaultWith ) -> unique ( ) -> all ( ) ; } 
protected function convertIncludePath ( $ path ) { if ( array_key_exists ( $ path , $ this -> includePaths ) ) { return $ this -> includePaths [ $ path ] ? : null ; } return collect ( explode ( '.' , $ path ) ) -> map ( function ( $ segment ) { return $ this -> modelRelationForField ( $ segment ) ; } ) -> implode ( '.' ) ; } 
protected function modelRelationForField ( $ field ) { return $ this -> camelCaseRelations ? Str :: camelize ( $ field ) : Str :: underscore ( $ field ) ; } 
public static function createMany ( array $ input ) { $ errors = new ErrorCollection ( ) ; foreach ( $ input as $ item ) { $ errors -> add ( self :: create ( $ item ) ) ; } return $ errors ; } 
protected function fillSoftDelete ( Model $ record , $ field , $ value ) { $ value = $ this -> deserializeSoftDelete ( $ value , $ field , $ record ) ; $ record -> forceFill ( [ $ this -> getSoftDeleteKey ( $ record ) => $ value , ] ) ; } 
protected function deserializeSoftDelete ( $ value , $ field , $ record ) { if ( collect ( [ true , false , 1 , 0 , '1' , '0' ] ) -> containsStrict ( $ value ) ) { return $ value ? Carbon :: now ( ) : null ; } return $ this -> deserializeAttribute ( $ value , $ field , $ record ) ; } 
protected function getSoftDeleteField ( Model $ record ) { if ( $ field = $ this -> softDeleteField ( ) ) { return $ field ; } $ key = $ this -> getSoftDeleteKey ( $ record ) ; return Str :: dasherize ( $ key ) ; } 
public function allow ( string ... $ params ) : self { $ this -> all = false ; foreach ( $ params as $ param ) { $ this -> allowed -> put ( $ param , $ param ) ; } return $ this ; } 
public static function dasherize ( $ value ) { if ( isset ( self :: $ dasherized [ $ value ] ) ) { return self :: $ dasherized [ $ value ] ; } return self :: $ dasherized [ $ value ] = str_replace ( '_' , '-' , self :: decamelize ( $ value ) ) ; } 
public static function decamelize ( $ value ) { if ( isset ( self :: $ decamelized [ $ value ] ) ) { return self :: $ decamelized [ $ value ] ; } return self :: $ decamelized [ $ value ] = strtolower ( preg_replace ( '/(.)(?=[A-Z])/u' , '$1_' , $ value ) ) ; } 
public static function underscore ( $ value ) { if ( isset ( self :: $ underscored [ $ value ] ) ) { return self :: $ underscored [ $ value ] ; } return self :: $ underscored [ $ value ] = str_replace ( '-' , '_' , self :: decamelize ( $ value ) ) ; } 
public static function camelize ( $ value ) { if ( isset ( self :: $ camelized [ $ value ] ) ) { return self :: $ camelized [ $ value ] ; } return self :: $ camelized [ $ value ] = lcfirst ( self :: classify ( $ value ) ) ; } 
public static function classify ( $ value ) { if ( isset ( self :: $ classified [ $ value ] ) ) { return self :: $ classified [ $ value ] ; } $ converted = ucwords ( str_replace ( [ '-' , '_' ] , ' ' , $ value ) ) ; return self :: $ classified [ $ value ] = str_replace ( ' ' , '' , $ converted ) ; } 
protected function buildClass ( $ name ) { $ stub = $ this -> files -> get ( $ this -> getStub ( ) ) ; $ this -> replaceNamespace ( $ stub , $ name ) -> replaceClassName ( $ stub , $ name ) -> replaceResourceType ( $ stub ) -> replaceApplicationNamespace ( $ stub ) -> replaceRecord ( $ stub ) ; return $ stub ; } 
protected function getStub ( ) { if ( $ this -> isIndependent ) { return $ this -> getStubFor ( 'independent' ) ; } if ( $ this -> isEloquent ( ) ) { return $ this -> getStubFor ( 'eloquent' ) ; } return $ this -> getStubFor ( 'abstract' ) ; } 
protected function getResourceName ( ) { $ name = ucwords ( $ this -> getResourceInput ( ) ) ; if ( $ this -> isByResource ( ) ) { return str_plural ( $ name ) ; } return $ name ; } 
protected function replaceResourceType ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'dummyResourceType' , Str :: dasherize ( $ resource ) , $ stub ) ; return $ this ; } 
protected function replaceRecord ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'DummyRecord' , Str :: classify ( str_singular ( $ resource ) ) , $ stub ) ; return $ this ; } 
protected function replaceApplicationNamespace ( & $ stub ) { $ namespace = rtrim ( $ this -> laravel -> getNamespace ( ) , '\\' ) ; $ stub = str_replace ( 'DummyApplicationNamespace' , $ namespace , $ stub ) ; return $ this ; } 
protected function getStubFor ( $ implementationType ) { return sprintf ( '%s/%s/%s.stub' , $ this -> stubsDirectory , $ implementationType , Str :: dasherize ( $ this -> type ) ) ; } 
protected function isEloquent ( ) { if ( $ this -> isIndependent ) { return false ; } if ( $ this -> option ( 'no-eloquent' ) ) { return false ; } return $ this -> option ( 'eloquent' ) ? : $ this -> getApi ( ) -> isEloquent ( ) ; } 
protected function dataForUpdate ( $ record , array $ document ) : array { $ resource = $ document [ 'data' ] ?? [ ] ; if ( $ this -> mustValidateExisting ( $ record , $ document ) ) { $ resource [ 'attributes' ] = $ this -> extractAttributes ( $ record , $ resource [ 'attributes' ] ?? [ ] ) ; $ resource [ 'relationships' ] = $ this -> extractRelationships ( $ record , $ resource [ 'relationships' ] ?? [ ] ) ; } return $ resource ; } 
protected function dataForDelete ( $ record ) : array { $ schema = $ this -> container -> getSchema ( $ record ) ; return ResourceObject :: create ( [ 'type' => $ schema -> getResourceType ( ) , 'id' => $ schema -> getId ( $ record ) , 'attributes' => $ schema -> getAttributes ( $ record ) , 'relationships' => collect ( $ this -> existingRelationships ( $ record ) ) -> all ( ) , ] ) -> all ( ) ; } 
protected function dataForRelationship ( $ record , string $ field , array $ document ) : array { $ schema = $ this -> container -> getSchema ( $ record ) ; return [ 'type' => $ schema -> getResourceType ( ) , 'id' => $ schema -> getId ( $ record ) , 'relationships' => [ $ field => [ 'data' => $ document [ 'data' ] , ] , ] , ] ; } 
protected function relationshipRules ( $ record , string $ field ) : array { return collect ( $ this -> rules ( $ record ) ) -> filter ( function ( $ v , $ key ) use ( $ field ) { return Str :: startsWith ( $ key , $ field ) ; } ) -> all ( ) ; } 
protected function validatorForResource ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> factory -> createResourceValidator ( ResourceObject :: create ( $ data ) , $ rules , $ messages , $ customAttributes ) ; } 
protected function validatorForDelete ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> createValidator ( $ data , $ rules , $ messages , $ customAttributes ) ; } 
protected function createValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> factory -> createDeleteValidator ( $ data , $ rules , $ messages , $ customAttributes ) ; } 
protected function excluded ( string ... $ keys ) : Collection { return collect ( $ keys ) -> mapWithKeys ( function ( $ key ) { return [ $ key => new DisallowedParameter ( $ key ) ] ; } ) ; } 
protected function queryValidator ( array $ params , $ without = null ) : ValidatorInterface { $ without = ( array ) $ without ; return $ this -> validatorForQuery ( $ params , $ this -> queryRulesWithout ( ... $ without ) , $ this -> queryMessages ( ) , $ this -> queryAttributes ( ) ) ; } 
protected function validateRelationship ( RelationshipInterface $ relationship , $ key = null ) { if ( ! $ relationship -> has ( RelationshipInterface :: DATA ) ) { $ this -> addError ( $ this -> errorFactory -> memberRequired ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ relationship -> isHasOne ( ) && ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> memberRelationshipExpected ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ this -> validateEmpty ( $ relationship , $ key ) ) { return false ; } return true ; } 
protected function validateHasOne ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasOne ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasOneExpected ( $ key ) ) ; return false ; } $ identifier = $ relationship -> getData ( ) ; if ( ! $ identifier ) { return true ; } if ( ! $ this -> validateIdentifier ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateExists ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateAcceptable ( $ identifier , $ record , $ key , $ resource ) ) { return false ; } return true ; } 
protected function validateHasMany ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasManyExpected ( $ key ) ) ; return false ; } $ identifiers = $ relationship -> getIdentifiers ( ) ; if ( ! $ this -> validateIdentifiers ( $ identifiers , $ record , $ key , $ resource ) ) { return false ; } return true ; } 
protected function next ( Cursor $ cursor , $ columns ) { if ( $ cursor -> isAfter ( ) ) { $ this -> whereId ( $ cursor -> getAfter ( ) , $ this -> descending ? '<' : '>' ) ; } $ items = $ this -> orderForNext ( ) -> get ( $ cursor -> getLimit ( ) + 1 , $ columns ) ; $ more = $ items -> count ( ) > $ cursor -> getLimit ( ) ; return new CursorPaginator ( $ items -> slice ( 0 , $ cursor -> getLimit ( ) ) , $ more , $ cursor , $ this -> key ) ; } 
protected function previous ( Cursor $ cursor , $ columns ) { $ items = $ this -> whereId ( $ cursor -> getBefore ( ) , $ this -> descending ? '>' : '<' ) -> orderForPrevious ( ) -> get ( $ cursor -> getLimit ( ) , $ columns ) -> reverse ( ) -> values ( ) ; return new CursorPaginator ( $ items , true , $ cursor , $ this -> key ) ; } 
protected function whereId ( $ id , $ operator ) { if ( $ this -> isPagingOnKey ( ) ) { $ this -> query -> where ( $ this -> key , $ operator , $ id ) ; return $ this ; } $ value = $ this -> getColumnValue ( $ id ) ; $ this -> query -> where ( $ this -> column , $ operator . '=' , $ value ) -> where ( function ( $ query ) use ( $ id , $ value , $ operator ) { $ query -> where ( $ this -> column , $ operator , $ value ) -> orWhere ( $ this -> key , $ operator , $ id ) ; } ) ; return $ this ; } 
protected function orderDesc ( ) { $ this -> query -> orderByDesc ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderByDesc ( $ this -> key ) ; } return $ this ; } 
protected function orderAsc ( ) { $ this -> query -> orderBy ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderBy ( $ this -> key ) ; } return $ this ; } 
protected function getColumnValue ( $ id ) { $ value = $ this -> getQuery ( ) 
private function guessColumn ( ) { if ( $ this -> query instanceof EloquentBuilder || $ this -> query instanceof Relation ) { return $ this -> query -> getModel ( ) -> getCreatedAtColumn ( ) ; } return Model :: CREATED_AT ; } 
private function guessKey ( ) { if ( $ this -> query instanceof EloquentBuilder || $ this -> query instanceof Relation ) { return $ this -> query -> getModel ( ) -> getRouteKeyName ( ) ; } return 'id' ; } 
public static function decode ( $ content , $ assoc = false , $ depth = 512 , $ options = 0 ) { $ decoded = \ json_decode ( $ content , $ assoc , $ depth , $ options ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw InvalidJsonException :: create ( ) ; } if ( ! $ assoc && ! is_object ( $ decoded ) ) { throw new DocumentRequiredException ( ) ; } if ( $ assoc && ! is_array ( $ decoded ) ) { throw new InvalidJsonException ( null , 'JSON is not an array.' ) ; } return $ decoded ; } 
public static function doesRequestHaveBody ( $ request ) { if ( self :: hasHeader ( $ request , 'Transfer-Encoding' ) ) { return true ; } ; if ( 1 > self :: getHeader ( $ request , 'Content-Length' ) ) { return false ; } return true ; } 
public static function doesResponseHaveBody ( $ request , $ response ) { if ( 'HEAD' === strtoupper ( $ request -> getMethod ( ) ) ) { return false ; } $ status = $ response -> getStatusCode ( ) ; if ( ( 100 <= $ status && 200 > $ status ) || 204 === $ status || 304 === $ status ) { return false ; } if ( self :: hasHeader ( $ response , 'Transfer-Encoding' ) ) { return true ; } ; if ( ! $ contentLength = self :: getHeader ( $ response , 'Content-Length' ) ) { return false ; } return 0 < $ contentLength [ 0 ] ; } 
public static function wantsJsonApi ( $ request ) { $ acceptable = $ request -> getAcceptableContentTypes ( ) ; return isset ( $ acceptable [ 0 ] ) && IlluminateStr :: contains ( $ acceptable [ 0 ] , MediaType :: JSON_API_SUB_TYPE ) ; } 
public static function httpErrorStatus ( $ errors , int $ default = SymfonyResponse :: HTTP_BAD_REQUEST ) : int { if ( $ errors instanceof ErrorInterface ) { $ errors = [ $ errors ] ; } $ statuses = collect ( $ errors ) -> reject ( function ( ErrorInterface $ error ) { return is_null ( $ error -> getStatus ( ) ) ; } ) -> map ( function ( ErrorInterface $ error ) { return ( int ) $ error -> getStatus ( ) ; } ) -> unique ( ) ; if ( 2 > count ( $ statuses ) ) { return $ statuses -> first ( ) ? : $ default ; } $ only4xx = $ statuses -> every ( function ( int $ status ) { return 400 <= $ status && 499 >= $ status ; } ) ; return $ only4xx ? SymfonyResponse :: HTTP_BAD_REQUEST : SymfonyResponse :: HTTP_INTERNAL_SERVER_ERROR ; } 
public function createResolver ( $ apiName , array $ config ) { $ factoryName = isset ( $ config [ 'resolver' ] ) ? $ config [ 'resolver' ] : ResolverFactory :: class ; $ factory = $ this -> container -> make ( $ factoryName ) ; if ( $ factory instanceof ResolverInterface ) { return $ factory ; } if ( ! is_callable ( $ factory ) ) { throw new RuntimeException ( "Factory {$factoryName} cannot be invoked." ) ; } $ resolver = $ factory ( $ apiName , $ config ) ; if ( ! $ resolver instanceof ResolverInterface ) { throw new RuntimeException ( "Factory {$factoryName} did not create a resolver instance." ) ; } return $ resolver ; } 
public function createResponseFactory ( Api $ api ) { return new Responses ( $ this , $ api , $ this -> container -> make ( Route :: class ) , $ this -> container -> make ( 'json-api.exceptions' ) ) ; } 
public function createNewResourceDocumentValidator ( $ document , $ expectedType , $ clientIds ) { $ store = $ this -> container -> make ( StoreInterface :: class ) ; $ errors = $ this -> createErrorTranslator ( ) ; return new Validation \ Spec \ CreateResourceValidator ( $ store , $ errors , $ document , $ expectedType , $ clientIds ) ; } 
public function createExistingResourceDocumentValidator ( $ document , $ expectedType , $ expectedId ) { $ store = $ this -> container -> make ( StoreInterface :: class ) ; $ errors = $ this -> createErrorTranslator ( ) ; return new Validation \ Spec \ UpdateResourceValidator ( $ store , $ errors , $ document , $ expectedType , $ expectedId ) ; } 
public function createRelationshipDocumentValidator ( $ document ) { return new Validation \ Spec \ RelationValidator ( $ this -> container -> make ( StoreInterface :: class ) , $ this -> createErrorTranslator ( ) , $ document ) ; } 
public function createValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , \ Closure $ callback = null ) : ValidatorInterface { $ translator = $ this -> createErrorTranslator ( ) ; return new Validation \ Validator ( $ this -> makeValidator ( $ data , $ rules , $ messages , $ customAttributes ) , $ translator , $ callback ) ; } 
public function createResourceValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointer ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; } 
public function createRelationshipValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointerForRelationship ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; } 
public function createQueryValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ data , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) { return $ this -> invalidQueryParameter ( $ key , $ detail , $ failed ) ; } ) ; } 
public function read ( $ resourceType , $ id , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: read ( $ resourceType ) , $ id , $ queryParams ) ; } 
public function update ( $ resourceType , $ id , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: update ( $ resourceType ) , $ id , $ queryParams ) ; } 
public function delete ( $ resourceType , $ id , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: delete ( $ resourceType ) , $ id , $ queryParams ) ; } 
public function relatedResource ( $ resourceType , $ id , $ relationshipKey , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: related ( $ resourceType , $ relationshipKey ) , $ id , $ queryParams ) ; } 
public function removeRelationship ( $ resourceType , $ id , $ relationshipKey , array $ queryParams = [ ] ) { $ name = RouteName :: removeRelationship ( $ resourceType , $ relationshipKey ) ; return $ this -> resource ( $ name , $ id , $ queryParams ) ; } 
public function up ( ) { Schema :: create ( 'json_api_client_jobs' , function ( Blueprint $ table ) { $ table -> uuid ( 'uuid' ) -> primary ( ) ; $ table -> timestamps ( ) ; $ table -> string ( 'api' ) ; $ table -> string ( 'resource_type' ) ; $ table -> string ( 'resource_id' ) -> nullable ( ) ; $ table -> timestamp ( 'completed_at' ) -> nullable ( ) ; $ table -> integer ( 'attempts' ) -> default ( 0 ) ; $ table -> integer ( 'timeout' ) -> nullable ( ) ; $ table -> timestamp ( 'timeout_at' ) -> nullable ( ) ; $ table -> integer ( 'tries' ) -> nullable ( ) ; $ table -> boolean ( 'failed' ) -> default ( false ) ; } ) ; } 
private function flip ( array $ resources ) { $ all = [ ] ; foreach ( $ resources as $ resourceType => $ types ) { foreach ( ( array ) $ types as $ type ) { $ all [ $ type ] = $ resourceType ; } } return $ all ; } 
public function getDefaultCodec ( ) : Codec { return $ this -> factory -> createCodec ( $ this -> getContainer ( ) , $ this -> encodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ? : Encoding :: jsonApi ( ) , $ this -> decodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ) ; } 
public function encoder ( $ options = 0 , $ depth = 512 ) { if ( $ options instanceof Encoding ) { $ options = $ options -> getOptions ( ) ; } if ( ! $ options instanceof EncoderOptions ) { $ options = new EncoderOptions ( $ options , $ this -> getUrl ( ) -> toString ( ) , $ depth ) ; } return $ this -> factory -> createEncoder ( $ this -> getContainer ( ) , $ options ) ; } 
public function register ( AbstractProvider $ provider ) { $ this -> resolver -> attach ( $ provider -> getResolver ( ) ) ; $ this -> errors = array_replace ( $ provider -> getErrors ( ) , $ this -> errors ) ; } 
public static function create ( $ mediaType , $ decoder ) : self { if ( is_string ( $ mediaType ) ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } if ( ! $ mediaType instanceof MediaTypeInterface ) { throw new \ InvalidArgumentException ( 'Expecting a media type object or string.' ) ; } if ( is_string ( $ decoder ) ) { $ decoder = app ( $ decoder ) ; } if ( ! $ decoder instanceof DecoderInterface ) { throw new \ InvalidArgumentException ( 'Expecting a decoder or decoder service name.' ) ; } return new self ( $ mediaType , $ decoder ) ; } 
public function prepend ( Decoding ... $ decodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ decodings ) ; return $ copy ; } 
public function push ( Decoding ... $ decodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ decodings ) -> all ( ) ; return $ copy ; } 
public function merge ( DecodingList $ decodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ decodings -> stack ) -> all ( ) ; return $ copy ; } 
public function when ( bool $ test , $ decodings ) : self { if ( ! $ test ) { return $ this ; } if ( $ decodings instanceof \ Closure ) { return $ decodings ( $ this ) ; } $ decodings = $ decodings instanceof Decoding ? [ $ decodings ] : $ decodings ; return $ this -> push ( ... $ decodings ) ; } 
public function unless ( bool $ test , $ decodings ) : self { return $ this -> when ( true !== $ test , $ decodings ) ; } 
public function equalsTo ( MediaTypeInterface $ mediaType ) : ? Decoding { return collect ( $ this -> stack ) -> first ( function ( Decoding $ decoding ) use ( $ mediaType ) { return $ decoding -> equalsTo ( $ mediaType ) ; } ) ; } 
public static function camelize ( $ data ) { return collect ( $ data ) -> mapWithKeys ( function ( $ value , $ key ) { $ key = Str :: camelize ( $ key ) ; if ( is_array ( $ value ) ) { return [ $ key => static :: camelize ( $ value ) ] ; } return [ $ key => $ value ] ; } ) -> all ( ) ; } 
public function current ( $ meta = null , array $ queryParams = [ ] ) { $ url = $ this -> generator -> current ( ) ; if ( $ queryParams ) { $ url .= '?' . http_build_query ( $ queryParams ) ; } return $ this -> factory -> createLink ( $ url , $ meta , true ) ; } 
public function index ( $ resourceType , $ meta = null , array $ queryParams = [ ] ) { return $ this -> factory -> createLink ( $ this -> urls -> index ( $ resourceType , $ queryParams ) , $ meta , true ) ; } 
public function read ( $ resourceType , $ id , $ meta = null , array $ queryParams = [ ] ) { return $ this -> factory -> createLink ( $ this -> urls -> read ( $ resourceType , $ id , $ queryParams ) , $ meta , true ) ; } 
public function relatedResource ( $ resourceType , $ id , $ relationshipKey , $ meta = null , array $ queryParams = [ ] ) { return $ this -> factory -> createLink ( $ this -> urls -> relatedResource ( $ resourceType , $ id , $ relationshipKey , $ queryParams ) , $ meta , true ) ; } 
public static function fromArray ( iterable $ config , string $ urlPrefix = null ) : self { return new self ( ... collect ( $ config ) -> map ( function ( $ value , $ key ) use ( $ urlPrefix ) { return Encoding :: fromArray ( $ key , $ value , $ urlPrefix ) ; } ) -> values ( ) ) ; } 
public static function createCustom ( ... $ mediaTypes ) : self { $ encodings = new self ( ) ; $ encodings -> stack = collect ( $ mediaTypes ) -> map ( function ( $ mediaType ) { return Encoding :: custom ( $ mediaType ) ; } ) -> all ( ) ; return $ encodings ; } 
public function prepend ( Encoding ... $ encodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ encodings ) ; return $ copy ; } 
public function push ( Encoding ... $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings ) -> all ( ) ; return $ copy ; } 
public function merge ( EncodingList $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings -> stack ) -> all ( ) ; return $ copy ; } 
public function when ( bool $ test , $ encodings ) : self { if ( ! $ test || is_null ( $ encodings ) ) { return $ this ; } if ( $ encodings instanceof \ Closure ) { return $ encodings ( $ this ) ; } if ( is_string ( $ encodings ) ) { $ encodings = Encoding :: custom ( $ encodings ) ; } $ encodings = $ encodings instanceof Encoding ? [ $ encodings ] : $ encodings ; return $ this -> push ( ... $ encodings ) ; } 
public function unless ( bool $ test , $ encodings ) : self { return $ this -> when ( true !== $ test , $ encodings ) ; } 
public function matchesTo ( MediaTypeInterface $ mediaType ) : ? Encoding { return collect ( $ this -> stack ) -> first ( function ( Encoding $ encoding ) use ( $ mediaType ) { return $ encoding -> matchesTo ( $ mediaType ) ; } ) ; } 
public function acceptable ( AcceptHeaderInterface $ accept ) : ? Encoding { foreach ( $ accept -> getMediaTypes ( ) as $ mediaType ) { if ( $ encoding = $ this -> matchesTo ( $ mediaType ) ) { return $ encoding ; } } return null ; } 
public function handle ( $ request , Closure $ next , string $ namespace ) { $ api = $ this -> bindApi ( $ namespace , $ request -> getSchemeAndHttpHost ( ) . $ request -> getBaseUrl ( ) ) ; $ this -> substituteBindings ( $ api ) ; $ this -> bindPageResolver ( ) ; return $ next ( $ request ) ; } 
protected function bindApi ( string $ namespace , string $ host ) : Api { $ repository = $ this -> container -> make ( Repository :: class ) ; $ api = $ repository -> createApi ( $ namespace , $ host ) ; $ this -> container -> instance ( Api :: class , $ api ) ; $ this -> container -> alias ( Api :: class , 'json-api.inbound' ) ; return $ api ; } 
protected function bindPageResolver ( ) : void { AbstractPaginator :: currentPageResolver ( function ( $ pageName ) { $ pagination = app ( EncodingParametersInterface :: class ) -> getPaginationParameters ( ) ? : [ ] ; return $ pagination [ $ pageName ] ?? null ; } ) ; } 
protected function buildParams ( EncodingParametersInterface $ parameters ) { return array_filter ( [ QueryParametersParserInterface :: PARAM_FILTER => $ parameters -> getFilteringParameters ( ) , QueryParametersParserInterface :: PARAM_SORT => $ this -> buildSortParams ( ( array ) $ parameters -> getSortParameters ( ) ) ] ) ; } 
public function didCreate ( $ resource ) : void { if ( $ this -> wasClientDispatched ( ) ) { $ this -> clientJob -> setResource ( $ resource ) -> save ( ) ; } } 
public static function fromArray ( array $ url ) : self { return new self ( isset ( $ url [ 'host' ] ) ? $ url [ 'host' ] : '' , isset ( $ url [ 'namespace' ] ) ? $ url [ 'namespace' ] : '' , isset ( $ url [ 'name' ] ) ? $ url [ 'name' ] : '' ) ; } 
public function getResourceUrl ( string $ type , $ id , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id ] , $ params ) ; } 
public function getRelatedUrl ( string $ type , $ id , string $ field , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id , $ field ] , $ params ) ; } 
public function getRelationshipUri ( string $ type , $ id , string $ field , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id , 'relationships' , $ field ] , $ params ) ; } 
public function index ( StoreInterface $ store , FetchResources $ request ) { $ result = $ this -> doSearch ( $ store , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ result ) ; } 
public function read ( StoreInterface $ store , FetchResource $ request ) { $ result = $ this -> doRead ( $ store , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ result ) ; } 
public function create ( StoreInterface $ store , CreateResource $ request ) { $ record = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doCreate ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ record ) ) { return $ record ; } return $ this -> reply ( ) -> created ( $ record ) ; } 
public function update ( StoreInterface $ store , UpdateResource $ request ) { $ record = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doUpdate ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ record ) ) { return $ record ; } return $ this -> reply ( ) -> updated ( $ record ) ; } 
public function delete ( StoreInterface $ store , DeleteResource $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doDelete ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> deleted ( $ result ) ; } 
public function readRelatedResource ( StoreInterface $ store , FetchRelated $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelated ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ related ) ; } 
public function readRelationship ( StoreInterface $ store , FetchRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelationship ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> relationship ( $ related ) ; } 
public function replaceRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doReplaceRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; } 
public function addToRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doAddToRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; } 
public function removeFromRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doRemoveFromRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; } 
public function processes ( StoreInterface $ store , FetchProcesses $ request ) { $ result = $ store -> queryRecords ( $ request -> getProcessType ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> content ( $ result ) ; } 
public function process ( StoreInterface $ store , FetchProcess $ request ) { $ record = $ store -> readRecord ( $ request -> getProcess ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> process ( $ record ) ; } 
protected function doSearch ( StoreInterface $ store , FetchResources $ request ) { if ( $ result = $ this -> invoke ( 'searching' , $ request ) ) { return $ result ; } $ found = $ store -> queryRecords ( $ request -> getResourceType ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ found instanceof PageInterface ) ? $ found -> getData ( ) : $ found ; if ( $ result = $ this -> invoke ( 'searched' , $ records , $ request ) ) { return $ result ; } return $ found ; } 
protected function doRead ( StoreInterface $ store , FetchResource $ request ) { $ record = $ request -> getRecord ( ) ; if ( $ result = $ this -> invoke ( 'reading' , $ record , $ request ) ) { return $ result ; } $ record = $ store -> readRecord ( $ record , $ request -> getParameters ( ) ) ; if ( $ result = $ this -> invoke ( 'didRead' , $ record , $ request ) ) { return $ result ; } return $ record ; } 
protected function doCreate ( StoreInterface $ store , CreateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> createRecord ( $ request -> getResourceType ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , false ) ? : $ record ; } 
protected function doUpdate ( StoreInterface $ store , UpdateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> updateRecord ( $ request -> getRecord ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , true ) ? : $ record ; } 
protected function doDelete ( StoreInterface $ store , DeleteResource $ request ) { $ record = $ request -> getRecord ( ) ; if ( $ response = $ this -> invoke ( 'deleting' , $ record , $ request ) ) { return $ response ; } $ result = $ store -> deleteRecord ( $ record , $ request -> getParameters ( ) ) ; return $ this -> invoke ( 'deleted' , $ record , $ request ) ? : $ result ; } 
protected function doReplaceRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ name = Str :: classify ( $ field = $ request -> getRelationshipName ( ) ) ; if ( $ result = $ this -> invokeMany ( [ 'replacing' , "replacing{$name}" ] , $ record , $ request ) ) { return $ result ; } $ record = $ store -> replaceRelationship ( $ record , $ field , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> invokeMany ( [ "replaced{$name}" , "replaced" ] , $ record , $ request ) ? : $ record ; } 
protected function transaction ( Closure $ closure ) { if ( ! $ this -> useTransactions ) { return $ closure ( ) ; } return app ( 'db' ) -> connection ( $ this -> connection ) -> transaction ( $ closure ) ; } 
public function route ( ) : RouteRegistration { $ route = new RouteRegistration ( $ this -> router , $ this , $ this -> defaults ) ; $ route -> controller ( $ this -> options [ 'controller' ] ?? '' ) ; return $ route ; } 
public function resource ( string $ resourceType , array $ options = [ ] ) : ResourceRegistration { return new ResourceRegistration ( $ this -> router , $ resourceType , array_merge ( $ this -> options , $ options ) ) ; } 
public static function create ( ValidatorInterface $ validator ) : self { $ ex = new self ( $ validator -> getErrors ( ) ) ; $ ex -> validator = $ validator ; return $ ex ; } 
protected function deserialize ( array $ document , $ record = null ) : ResourceObject { $ data = $ document [ 'data' ] ?? [ ] ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { throw new \ InvalidArgumentException ( 'Expecting a JSON API document with a data member.' ) ; } return ResourceObject :: create ( $ data ) ; } 
protected function isFillableRelation ( $ field , $ record ) { return $ this -> isRelation ( $ field ) && $ this -> isFillable ( $ field , $ record ) ; } 
protected function methodForRelation ( $ field ) { if ( method_exists ( $ this , $ field ) ) { return $ field ; } $ method = Str :: camelize ( $ field ) ; return method_exists ( $ this , $ method ) ? $ method : null ; } 
protected function fill ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ this -> fillAttributes ( $ record , $ resource -> getAttributes ( ) ) ; $ this -> fillRelationships ( $ record , $ resource -> getRelationships ( ) , $ parameters ) ; } 
protected function fillRelationships ( $ record , Collection $ relationships , EncodingParametersInterface $ parameters ) { $ relationships -> filter ( function ( $ value , $ field ) use ( $ record ) { return $ this -> isFillableRelation ( $ field , $ record ) ; } ) -> each ( function ( $ value , $ field ) use ( $ record , $ parameters ) { $ this -> fillRelationship ( $ record , $ field , $ value , $ parameters ) ; } ) ; } 
protected function fillRelationship ( $ record , $ field , array $ relationship , EncodingParametersInterface $ parameters ) { $ relation = $ this -> getRelated ( $ field ) ; $ relation -> update ( $ record , $ relationship , $ parameters ) ; } 
public function setResource ( string $ type , string $ id = null ) : ClientDispatch { $ this -> resourceType = $ type ; $ this -> resourceId = $ id ; return $ this ; } 
public function handle ( $ request , \ Closure $ next , string $ default = null ) { $ api = $ this -> container -> make ( Api :: class ) ; $ headers = $ this -> container -> make ( HeaderParametersInterface :: class ) ; $ contentType = $ headers -> getContentTypeHeader ( ) ; $ codec = $ this -> factory -> createCodec ( $ api -> getContainer ( ) , $ this -> matchEncoding ( $ api , $ request , $ headers -> getAcceptHeader ( ) , $ default ) , $ decoder = $ contentType ? $ this -> matchDecoder ( $ api , $ request , $ contentType , $ default ) : null ) ; $ this -> matched ( $ codec ) ; if ( ! $ contentType && $ this -> isExpectingContent ( $ request ) ) { throw new DocumentRequiredException ( ) ; } return $ next ( $ request ) ; } 
public function willSeeOne ( $ request ) : bool { if ( $ this -> route -> isRelationship ( ) ) { return false ; } if ( $ this -> route -> isResource ( ) ) { return true ; } return $ request -> isMethod ( 'POST' ) ; } 
protected function isExpectingContent ( $ request ) : bool { $ methods = $ this -> route -> isNotRelationship ( ) ? [ 'POST' , 'PATCH' ] : [ 'POST' , 'PATCH' , 'DELETE' ] ; return \ in_array ( $ request -> getMethod ( ) , $ methods ) ; } 
public function withQualifiedColumn ( $ column ) { $ parts = explode ( '.' , $ column ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withColumn ( $ parts [ 1 ] ) ; return $ this ; } 
public function withQualifiedKeyName ( $ keyName ) { $ parts = explode ( '.' , $ keyName ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withIdentifierColumn ( $ parts [ 1 ] ) ; return $ this ; } 
protected function query ( $ query ) { return new CursorBuilder ( $ query , $ this -> column , $ this -> identifier , $ this -> descending ) ; } 
protected function cursor ( EncodingParametersInterface $ parameters ) { return Cursor :: create ( ( array ) $ parameters -> getPaginationParameters ( ) , $ this -> before , $ this -> after , $ this -> limit ) ; } 
public function encodes ( string ... $ mediaTypes ) : bool { $ encoding = $ this -> getEncodingMediaType ( ) ; return collect ( $ mediaTypes ) -> contains ( function ( $ mediaType , $ index ) use ( $ encoding ) { return $ encoding -> equalsTo ( MediaType :: parse ( $ index , $ mediaType ) ) ; } ) ; } 
public function decodes ( string ... $ mediaTypes ) : bool { if ( ! $ decoding = $ this -> getDecodingMediaType ( ) ) { return false ; } return collect ( $ mediaTypes ) -> contains ( function ( $ mediaType , $ index ) use ( $ decoding ) { return $ decoding -> equalsTo ( MediaType :: parse ( $ index , $ mediaType ) ) ; } ) ; } 
public function document ( $ request ) : ? \ stdClass { if ( $ this -> cannotDecodeJsonApi ( ) ) { return null ; } return $ this -> decoding -> getJsonApiDecoder ( ) -> document ( $ request ) ; } 
public function registerCustom ( ) : void { if ( ! $ fn = $ this -> group ) { return ; } $ this -> router -> group ( [ ] , function ( ) use ( $ fn ) { $ fn ( new RouteRegistrar ( $ this -> router , [ 'controller' => $ this -> controller ( ) ] , [ self :: PARAM_RESOURCE_TYPE => $ this -> resourceType ] ) ) ; } ) ; } 
private function registerProcesses ( ) : void { $ this -> routeForProcess ( 'get' , $ this -> baseProcessUrl ( ) , $ this -> actionForRoute ( 'processes' ) ) ; $ this -> routeForProcess ( 'get' , $ this -> processUrl ( ) , $ this -> actionForRoute ( 'process' ) ) ; } 
public function handle ( $ request , Closure $ next , $ authorizer ) { $ authorizer = $ this -> container -> getAuthorizerByName ( $ authorizer ) ; $ record = $ this -> route -> getResource ( ) ; if ( $ field = $ this -> route -> getRelationshipName ( ) ) { $ this -> authorizeRelationship ( $ authorizer , $ request , $ record , $ field ) ; } else if ( $ record ) { $ this -> authorizeResource ( $ authorizer , $ request , $ record ) ; } else { $ this -> authorize ( $ authorizer , $ request , $ this -> route -> getType ( ) ) ; } return $ next ( $ request ) ; } 
protected function authorizeRelationship ( AuthorizerInterface $ authorizer , $ request , $ record , string $ field ) : void { if ( $ this -> isModifyRelationship ( $ request ) ) { $ authorizer -> modifyRelationship ( $ record , $ field , $ request ) ; return ; } $ authorizer -> readRelationship ( $ record , $ field , $ request ) ; } 
protected function getRelation ( $ record , $ key ) { $ relation = $ record -> { $ key } ( ) ; if ( ! $ relation || ! $ this -> acceptRelation ( $ relation ) ) { throw new RuntimeException ( sprintf ( 'JSON API relation %s cannot be used for an Eloquent %s relation.' , class_basename ( $ this ) , class_basename ( $ relation ) ) ) ; } return $ relation ; } 
protected function requiresInverseAdapter ( $ record , EncodingParametersInterface $ parameters ) { return ! empty ( $ parameters -> getFilteringParameters ( ) ) || ! empty ( $ parameters -> getSortParameters ( ) ) || ! empty ( $ parameters -> getPaginationParameters ( ) ) || ! empty ( $ parameters -> getIncludePaths ( ) ) ; } 
protected function adapterFor ( $ relation ) { $ adapter = $ this -> getStore ( ) -> adapterFor ( $ relation -> getModel ( ) ) ; if ( ! $ adapter instanceof AbstractAdapter ) { throw new RuntimeException ( 'Expecting inverse resource adapter to be an Eloquent adapter.' ) ; } return $ adapter ; } 
protected function resourceAttributes ( $ record = null ) { return $ this -> validatorFactory ( ) -> attributes ( $ this -> attributeRules ( $ record ) , $ this -> attributeMessages ( $ record ) , $ this -> attributeCustomAttributes ( $ record ) , function ( Validator $ validator ) use ( $ record ) { return $ this -> conditionalAttributes ( $ validator , $ record ) ; } , function ( ResourceObjectInterface $ resource , $ record ) { return $ this -> extractAttributes ( $ resource , $ record ) ; } ) ; } 
protected function resourceRelationships ( $ record = null ) { $ validator = $ this -> validatorFactory ( ) -> relationships ( ) ; $ this -> relationshipRules ( $ validator , $ record ) ; return $ validator ; } 
protected function queryValidator ( ) { return $ this -> validatorFactory ( ) -> queryParameters ( $ this -> queryRules ( ) , $ this -> queryMessages ( ) , $ this -> queryCustomAttributes ( ) , function ( Validator $ validator ) { return $ this -> conditionalQuery ( $ validator ) ; } ) ; } 
protected function queryValidatorWithoutSearch ( ) { return $ this -> validatorFactory ( ) -> queryParameters ( $ this -> queryRulesWithoutSearch ( ) , $ this -> queryMessages ( ) , $ this -> queryCustomAttributes ( ) , function ( Validator $ validator ) { return $ this -> conditionalQuery ( $ validator ) ; } ) ; } 
protected function queryRulesWithoutSearch ( ) { return collect ( $ this -> queryRules ( ) ) -> reject ( function ( $ value , $ key ) { return Str :: startsWith ( $ key , [ 'filter.' , 'sort.' , 'page.' ] ) ; } ) -> all ( ) ; } 
protected function defaultOrder ( $ query ) { if ( $ this -> doesRequireOrdering ( $ query ) ) { $ query -> orderBy ( $ this -> primaryKey ) ; } return $ this ; } 
protected function doesRequireOrdering ( $ query ) { if ( ! $ this -> primaryKey ) { return false ; } $ query = ( $ query instanceof Relation ) ? $ query -> getBaseQuery ( ) : $ query -> getQuery ( ) ; return ! collect ( $ query -> orders ? : [ ] ) -> contains ( function ( array $ order ) { $ col = $ order [ 'column' ] ?? '' ; return $ this -> primaryKey === $ col ; } ) ; } 
public function middleware ( string ... $ middleware ) : self { $ this -> options [ 'middleware' ] = array_merge ( Arr :: wrap ( $ this -> options [ 'middleware' ] ?? [ ] ) , $ middleware ) ; return $ this ; } 
protected function fillAttributes ( $ record , Collection $ attributes ) { $ record -> fill ( $ this -> deserializeAttributes ( $ attributes , $ record ) ) ; } 
protected function modelKeyForField ( $ field , $ model ) { if ( isset ( $ this -> attributes [ $ field ] ) ) { return $ this -> attributes [ $ field ] ; } $ key = $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; return $ this -> attributes [ $ field ] = $ key ; } 
protected function deserializeAttributes ( $ attributes , $ record ) { return collect ( $ attributes ) -> reject ( function ( $ v , $ field ) use ( $ record ) { return $ this -> isNotFillable ( $ field , $ record ) ; } ) -> mapWithKeys ( function ( $ value , $ field ) use ( $ record ) { $ key = $ this -> modelKeyForField ( $ field , $ record ) ; return [ $ key => $ this -> deserializeAttribute ( $ value , $ field , $ record ) ] ; } ) -> all ( ) ; } 
protected function deserializeAttribute ( $ value , $ field , $ record ) { if ( $ this -> isDateAttribute ( $ field , $ record ) ) { return $ this -> deserializeDate ( $ value , $ field , $ record ) ; } $ method = 'deserialize' . Str :: classify ( $ field ) . 'Field' ; if ( method_exists ( $ this , $ method ) ) { return $ this -> { $ method } ( $ value , $ record ) ; } return $ value ; } 
protected function isDateAttribute ( $ field , $ record ) { if ( empty ( $ this -> dates ) ) { return in_array ( $ this -> modelKeyForField ( $ field , $ record ) , $ record -> getDates ( ) , true ) ; } return in_array ( $ field , $ this -> dates , true ) ; } 
public function setResource ( $ resource ) : ClientJob { $ schema = $ this -> getApi ( ) -> getContainer ( ) -> getSchema ( $ resource ) ; $ this -> fill ( [ 'resource_type' => $ schema -> getResourceType ( ) , 'resource_id' => $ schema -> getId ( $ resource ) , ] ) ; return $ this ; } 
public function getResource ( ) { if ( ! $ this -> resource_type || ! $ this -> resource_id ) { return null ; } return $ this -> getApi ( ) -> getStore ( ) -> find ( ResourceIdentifier :: create ( $ this -> resource_type , ( string ) $ this -> resource_id ) ) ; } 
public function substituteBindings ( StoreInterface $ store ) : void { $ this -> resourceId = $ this -> getResourceId ( ) ? : false ; $ this -> processId = $ this -> getProcessId ( ) ? : false ; if ( $ this -> resourceId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_RESOURCE_ID , $ store -> findOrFail ( $ this -> getResourceType ( ) , $ this -> resourceId ) ) ; } if ( $ this -> processId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_PROCESS_ID , $ store -> findOrFail ( $ this -> getProcessType ( ) , $ this -> processId ) ) ; } } 
public function getType ( ) : string { if ( $ resource = $ this -> getResource ( ) ) { return get_class ( $ resource ) ; } $ resourceType = $ this -> getResourceType ( ) ; if ( ! $ type = $ this -> resolver -> getType ( $ resourceType ) ) { throw new RuntimeException ( "JSON API resource type {$resourceType} is not registered." ) ; } return $ type ; } 
public function getResourceId ( ) : ? string { if ( is_null ( $ this -> resourceId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_RESOURCE_ID ) ; } return $ this -> resourceId ? : null ; } 
public function getResourceIdentifier ( ) : ? ResourceIdentifierInterface { if ( ! $ resourceId = $ this -> getResourceId ( ) ) { return null ; } return ResourceIdentifier :: create ( $ this -> getResourceType ( ) , $ resourceId ) ; } 
public function getResource ( ) { $ resource = $ this -> parameter ( ResourceRegistrar :: PARAM_RESOURCE_ID ) ; return is_object ( $ resource ) ? $ resource : null ; } 
public function getProcessId ( ) : ? string { if ( is_null ( $ this -> processId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; } return $ this -> processId ? : null ; } 
public function getProcess ( ) : ? AsynchronousProcess { $ process = $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; return ( $ process instanceof AsynchronousProcess ) ? $ process : null ; } 
public function getProcessIdentifier ( ) : ? ResourceIdentifierInterface { if ( ! $ id = $ this -> getProcessId ( ) ) { return null ; } return ResourceIdentifier :: create ( $ this -> getProcessType ( ) , $ id ) ; } 
public function defaultApi ( $ apiName = null ) { if ( is_null ( $ apiName ) ) { return LaravelJsonApi :: $ defaultApi ; } LaravelJsonApi :: defaultApi ( $ apiName ) ; return $ apiName ; } 
public function api ( $ apiName = null ) { $ repo = $ this -> container -> make ( Repository :: class ) ; return $ repo -> createApi ( $ apiName ? : $ this -> defaultApi ( ) ) ; } 
public function register ( $ apiName , $ options = [ ] , Closure $ routes = null ) : ApiRegistration { $ registrar = $ this -> container -> make ( 'json-api.registrar' ) ; return $ registrar -> api ( $ apiName , $ options , $ routes ) ; } 
protected function validateDocumentCompliance ( $ document , ? ValidatorFactoryInterface $ validators ) : void { $ this -> passes ( $ this -> factory -> createNewResourceDocumentValidator ( $ document , $ this -> getResourceType ( ) , $ validators && $ validators -> supportsClientIds ( ) ) ) ; } 
public static function create ( array $ data ) : self { if ( ! isset ( $ data [ 'type' ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a resource type.' ) ; } return new self ( $ data [ 'type' ] , $ data [ 'id' ] ?? null , $ data [ 'attributes' ] ?? [ ] , $ data [ 'relationships' ] ?? [ ] , $ data [ 'meta' ] ?? [ ] , $ data [ 'links' ] ?? [ ] ) ; } 
public function withType ( string $ type ) : self { if ( empty ( $ type ) ) { throw new \ InvalidArgumentException ( 'Expecting a non-empty string.' ) ; } $ copy = clone $ this ; $ copy -> type = $ type ; $ copy -> normalize ( ) ; return $ copy ; } 
public function withId ( ? string $ id ) : self { $ copy = clone $ this ; $ copy -> id = $ id ? : null ; $ copy -> normalize ( ) ; return $ copy ; } 
public function withAttributes ( $ attributes ) : self { $ copy = clone $ this ; $ copy -> attributes = collect ( $ attributes ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; } 
public function withRelationships ( $ relationships ) : self { $ copy = clone $ this ; $ copy -> relationships = collect ( $ relationships ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; } 
public function getRelations ( ) : Collection { return $ this -> getRelationships ( ) -> filter ( function ( array $ relation ) { return array_key_exists ( 'data' , $ relation ) ; } ) -> map ( function ( array $ relation ) { return $ relation [ 'data' ] ; } ) ; } 
public function withMeta ( $ meta ) : self { $ copy = clone $ this ; $ copy -> meta = collect ( $ meta ) -> all ( ) ; return $ copy ; } 
public function withLinks ( $ links ) : self { $ copy = clone $ this ; $ copy -> links = collect ( $ links ) -> all ( ) ; return $ copy ; } 
public function forget ( string ... $ fields ) : self { $ copy = clone $ this ; $ copy -> attributes = $ this -> getAttributes ( ) -> forget ( $ fields ) -> all ( ) ; $ copy -> relationships = $ this -> getRelationships ( ) -> forget ( $ fields ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; } 
public function only ( string ... $ fields ) : self { $ forget = $ this -> fields ( ) -> reject ( function ( $ value ) use ( $ fields ) { return in_array ( $ value , $ fields , true ) ; } ) ; return $ this -> forget ( ... $ forget ) ; } 
public function replace ( string $ field , $ value ) : self { if ( 'type' === $ field ) { return $ this -> putIdentifier ( $ value , $ this -> id ) ; } if ( 'id' === $ field ) { return $ this -> putIdentifier ( $ this -> type , $ value ) ; } if ( $ this -> isAttribute ( $ field ) ) { return $ this -> putAttr ( $ field , $ value ) ; } if ( $ this -> isRelationship ( $ field ) ) { return $ this -> putRelation ( $ field , $ value ) ; } throw new \ OutOfBoundsException ( "Field {$field} is not an attribute or relationship." ) ; } 
public function pointer ( string $ key , string $ prefix = '' ) : string { $ prefix = rtrim ( $ prefix , '/' ) ; if ( 'type' === $ key ) { return $ prefix . '/type' ; } if ( 'id' === $ key ) { return $ prefix . '/id' ; } $ parts = collect ( explode ( '.' , $ key ) ) ; $ field = $ parts -> first ( ) ; if ( $ this -> isAttribute ( $ field ) ) { return $ prefix . '/attributes/' . $ parts -> implode ( '/' ) ; } if ( $ this -> isRelationship ( $ field ) ) { $ name = 1 < $ parts -> count ( ) ? $ field . '/' . $ parts -> put ( 0 , 'data' ) -> implode ( '/' ) : $ field ; return $ prefix . "/relationships/{$name}" ; } return $ prefix ? $ prefix : '/' ; } 
public function pointerForRelationship ( string $ key , string $ default = '/' ) : string { $ field = collect ( explode ( '.' , $ key ) ) -> first ( ) ; if ( ! $ this -> isRelationship ( $ field ) ) { throw new \ InvalidArgumentException ( "Field {$field} is not a relationship." ) ; } $ pointer = $ this -> pointer ( $ key ) ; return Str :: after ( $ pointer , "relationships/{$field}" ) ? : $ default ; } 
public function getMeta ( ) { $ meta = $ this -> hasMeta ( ) ? $ this -> get ( DocumentInterface :: KEYWORD_META ) : new StandardObject ( ) ; if ( ! is_null ( $ meta ) && ! $ meta instanceof StandardObjectInterface ) { throw new RuntimeException ( 'Data member is not an object.' ) ; } return $ meta ; } 
protected function invoke ( string $ hook , ... $ arguments ) { if ( ! method_exists ( $ this , $ hook ) ) { return null ; } $ result = $ this -> { $ hook } ( ... $ arguments ) ; return $ this -> isInvokedResult ( $ result ) ? $ result : null ; } 
protected function invokeMany ( iterable $ hooks , ... $ arguments ) { foreach ( $ hooks as $ hook ) { $ result = $ this -> invoke ( $ hook , ... $ arguments ) ; if ( ! is_null ( $ result ) ) { return $ result ; } } return null ; } 
protected function validateData ( ) : bool { if ( ! property_exists ( $ this -> document , 'data' ) ) { $ this -> memberRequired ( '/' , 'data' ) ; return false ; } $ data = $ this -> document -> data ; if ( ! is_object ( $ data ) ) { $ this -> memberNotObject ( '/' , 'data' ) ; return false ; } return true ; } 
protected function validateResource ( ) : bool { $ identifier = $ this -> validateTypeAndId ( ) ; $ attributes = $ this -> validateAttributes ( ) ; $ relationships = $ this -> validateRelationships ( ) ; if ( $ attributes && $ relationships ) { return $ this -> validateAllFields ( ) && $ identifier ; } return $ identifier && $ attributes && $ relationships ; } 
protected function validateTypeAndId ( ) : bool { if ( ! ( $ this -> validateType ( ) && $ this -> validateId ( ) ) ) { return false ; } $ type = $ this -> dataGet ( 'type' ) ; $ id = $ this -> dataGet ( 'id' ) ; if ( $ id && ! $ this -> isNotFound ( $ type , $ id ) ) { $ this -> resourceExists ( $ type , $ id ) ; return false ; } return true ; } 
protected function validateType ( ) : bool { if ( ! $ this -> dataHas ( 'type' ) ) { $ this -> memberRequired ( '/data' , 'type' ) ; return false ; } $ value = $ this -> dataGet ( 'type' ) ; if ( ! $ this -> validateTypeMember ( $ value , '/data' ) ) { return false ; } if ( $ this -> expectedType !== $ value ) { $ this -> resourceTypeNotSupported ( $ value ) ; return false ; } return true ; } 
protected function validateId ( ) : bool { if ( ! $ this -> dataHas ( 'id' ) ) { return true ; } $ valid = $ this -> validateIdMember ( $ this -> dataGet ( 'id' ) , '/data' ) ; if ( ! $ this -> supportsClientIds ( ) ) { $ valid = false ; $ this -> resourceDoesNotSupportClientIds ( $ this -> expectedType ) ; } return $ valid ; } 
protected function validateAttributes ( ) : bool { if ( ! $ this -> dataHas ( 'attributes' ) ) { return true ; } $ attrs = $ this -> dataGet ( 'attributes' ) ; if ( ! is_object ( $ attrs ) ) { $ this -> memberNotObject ( '/data' , 'attributes' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ attrs ) { return property_exists ( $ attrs , $ field ) ; } ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'attributes' , $ disallowed ) ; return $ disallowed -> isEmpty ( ) ; } 
protected function validateRelationships ( ) : bool { if ( ! $ this -> dataHas ( 'relationships' ) ) { return true ; } $ relationships = $ this -> dataGet ( 'relationships' ) ; if ( ! is_object ( $ relationships ) ) { $ this -> memberNotObject ( '/data' , 'relationships' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ relationships ) { return property_exists ( $ relationships , $ field ) ; } ) ; $ valid = $ disallowed -> isEmpty ( ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'relationships' , $ disallowed ) ; foreach ( $ relationships as $ field => $ relation ) { if ( ! $ this -> validateRelationship ( $ relation , $ field ) ) { $ valid = false ; } } return $ valid ; } 
protected function validateAllFields ( ) : bool { $ duplicates = collect ( ( array ) $ this -> dataGet ( 'attributes' , [ ] ) ) -> intersectByKeys ( ( array ) $ this -> dataGet ( 'relationships' , [ ] ) ) -> keys ( ) ; $ this -> resourceFieldsExistInAttributesAndRelationships ( $ duplicates ) ; return $ duplicates -> isEmpty ( ) ; } 
protected function authenticate ( ) { if ( empty ( $ this -> guards ) && Auth :: check ( ) ) { return ; } foreach ( $ this -> guards as $ guard ) { if ( Auth :: guard ( $ guard ) -> check ( ) ) { Auth :: shouldUse ( $ guard ) ; return ; } } throw new AuthenticationException ( 'Unauthenticated.' , $ this -> guards ) ; } 
public function serialize ( $ record , $ meta = null , array $ links = [ ] ) { $ serializer = clone $ this -> serializer ; $ serializer -> withMeta ( $ meta ) -> withLinks ( $ links ) ; $ serialized = $ serializer -> serializeData ( $ record , $ this -> createEncodingParameters ( ) ) ; $ resourceLinks = null ; if ( empty ( $ serialized [ 'data' ] [ 'id' ] ) ) { unset ( $ serialized [ 'data' ] [ 'id' ] ) ; $ resourceLinks = false ; 
public function serializeRelated ( $ related , $ meta = null , array $ links = [ ] ) { $ serializer = clone $ this -> serializer ; $ serializer -> withMeta ( $ meta ) -> withLinks ( $ links ) ; return $ serializer -> serializeIdentifiers ( $ related ) ; } 
public function getInputHtml ( $ value , ElementInterface $ element = null ) : string { if ( ! $ element ) return '' ; 
public function injectRobots ( ) { $ headers = \ Craft :: $ app -> getResponse ( ) -> getHeaders ( ) ; 
private function _getElementAndSeoFields ( ) { static $ element = null ; static $ field = null ; if ( $ element !== null ) return [ $ field , $ element ] ; try { $ resolve = \ Craft :: $ app -> request -> resolve ( ) ; } catch ( \ Exception $ e ) { $ resolve = [ null , [ ] ] ; } $ resolve = $ resolve [ 1 ] ; $ variables = array_key_exists ( 'variables' , $ resolve ) ? $ resolve [ 'variables' ] : [ ] ; $ handle = null ; 
public function getSeoField ( $ ctx , $ handle = 'seo' ) { try { $ seo = null ; if ( isset ( $ ctx [ $ handle ] ) ) $ seo = $ ctx [ $ handle ] ; elseif ( isset ( $ ctx [ 'entry' ] ) && isset ( $ ctx [ 'entry' ] [ $ handle ] ) ) $ seo = $ ctx [ 'entry' ] [ $ handle ] ; elseif ( isset ( $ ctx [ 'product' ] ) && isset ( $ ctx [ 'product' ] [ $ handle ] ) ) $ seo = $ ctx [ 'product' ] [ $ handle ] ; elseif ( isset ( $ ctx [ 'category' ] ) && isset ( $ ctx [ 'category' ] [ $ handle ] ) ) $ seo = $ ctx [ 'category' ] [ $ handle ] ; if ( $ seo instanceof SeoData ) return $ seo ; } catch ( \ Exception $ e ) { return null ; } return null ; } 
public function init ( ) { 
public function getCanonical ( ) { if ( empty ( $ this -> advanced [ 'canonical' ] ) ) return \ Craft :: $ app -> request -> absoluteUrl ; return $ this -> advanced [ 'canonical' ] ; } 
private function _getSetting ( $ handle ) { return empty ( $ this -> _fieldSettings [ $ handle ] ) ? $ this -> _seoSettings [ $ handle ] : $ this -> _fieldSettings [ $ handle ] ; } 
private function _getSocialFallback ( ) { $ image = null ; $ assets = \ Craft :: $ app -> assets ; $ fieldFallback = $ this -> _fieldSettings [ 'socialImage' ] ; if ( ! empty ( $ fieldFallback ) ) $ image = $ assets -> getAssetById ( ( int ) $ fieldFallback [ 0 ] ) ; else { $ seoFallback = $ this -> _seoSettings [ 'socialImage' ] ; if ( ! empty ( $ seoFallback ) ) $ image = $ assets -> getAssetById ( ( int ) $ seoFallback [ 0 ] ) ; } return [ 'title' => $ this -> title , 'description' => $ this -> description , 'image' => $ image , ] ; } 
private function _getVariables ( ) { $ variables = $ this -> _overrideObject ; if ( $ this -> _element !== null ) { foreach ( $ this -> _element -> attributes ( ) as $ name ) if ( $ name !== $ this -> _handle ) $ variables [ $ name ] = $ this -> _element -> $ name ; $ variables = array_merge ( $ variables , $ this -> _element -> toArray ( $ this -> _element -> extraFields ( ) ) ) ; } return $ variables ; } 
private function _render ( $ template , $ variables ) { $ craft = \ Craft :: $ app ; if ( $ template === null ) return '' ; try { 
public function rules ( ) : array { $ rules = parent :: rules ( ) ; $ rules [ ] = [ [ 'group' , 'url' , 'frequency' , 'priority' ] , 'required' , ] ; $ rules [ ] = [ [ 'group' , 'url' , 'frequency' ] , 'string' , ] ; $ rules [ ] = [ [ 'priority' ] , 'double' , 'min' => 0 , 'max' => 1 , ] ; $ rules [ ] = [ [ 'enabled' ] , 'boolean' , ] ; $ rules [ ] = [ [ 'group' ] , 'in' , 'range' => [ 'sections' , 'categories' , 'customUrls' , ] , ] ; return $ rules ; } 
public function custom ( $ title = '' , $ description = '' , $ _ = null , $ social = [ ] ) { $ config = [ 'titleRaw' => '' , 'description' => $ description , 'social' => $ social , ] ; if ( is_array ( $ title ) ) $ config [ 'overrideObject' ] = $ title ; else $ config [ 'titleRaw' ] = $ title ; return new SeoData ( null , null , $ config ) ; } 
private function _socialImage ( $ image , array $ transform ) { if ( ! $ image ) return '' ; $ transformUrl = $ image -> getUrl ( $ transform ) ; if ( $ transformUrl === null ) return '' ; if ( $ transformUrl && strpos ( $ transformUrl , 'http' ) === false ) $ transformUrl = UrlHelper :: urlWithScheme ( $ transformUrl , ( \ Craft :: $ app -> getRequest ( ) -> getIsSecureConnection ( ) ? 'https' : 'http' ) ) ; return Template :: raw ( $ transformUrl ) ; } 
public function onException ( ExceptionEvent $ event ) { $ exception = $ event -> exception ; $ craft = \ Craft :: $ app ; if ( ! ( $ exception instanceof HttpException ) || $ exception -> statusCode !== 404 ) return ; $ path = $ craft -> request -> getFullPath ( ) ; $ query = $ craft -> request -> getQueryStringWithoutPath ( ) ; if ( $ query ) $ path .= '?' . $ query ; if ( $ redirect = $ this -> findRedirectByPath ( $ path ) ) { $ event -> handled = true ; $ craft -> response -> redirect ( $ redirect [ 'to' ] , $ redirect [ 'type' ] ) -> send ( ) ; $ craft -> end ( ) ; } } 
public function findAllRedirects ( $ currentSiteOnly = false ) { if ( $ currentSiteOnly ) return RedirectRecord :: find ( ) -> where ( '[[siteId]] IS NULL OR [[siteId]] = ' . \ Craft :: $ app -> sites -> currentSite -> id ) -> orderBy ( 'siteId asc' ) -> all ( ) ; return array_reduce ( RedirectRecord :: find ( ) -> all ( ) , function ( $ a , RedirectRecord $ record ) { $ a [ $ record -> siteId ?? 'null' ] [ ] = $ record ; return $ a ; } , array_reduce ( \ Craft :: $ app -> sites -> allSiteIds , function ( $ a , $ id ) { $ a [ $ id ] = [ ] ; return $ a ; } , [ ] ) ) ; } 
public function findRedirectByPath ( $ path ) { $ redirects = $ this -> findAllRedirects ( true ) ; foreach ( $ redirects as $ redirect ) { $ to = false ; if ( trim ( $ redirect [ 'uri' ] , '/' ) == $ path ) $ to = $ redirect [ 'to' ] ; elseif ( $ uri = $ this -> _isRedirectRegex ( $ redirect [ 'uri' ] ) ) if ( preg_match ( $ uri , $ path ) ) $ to = preg_replace ( $ uri , $ redirect [ 'to' ] , $ path ) ; if ( $ to ) { return [ 'to' => strpos ( $ to , '://' ) !== false ? $ to : UrlHelper :: siteUrl ( $ to ) , 'type' => $ redirect [ 'type' ] , ] ; } } return false ; } 
public function save ( $ uri , $ to , $ type , $ siteId = null , $ id = null ) { if ( $ siteId === 'null' ) $ siteId = null ; if ( $ id ) { $ record = RedirectRecord :: findOne ( compact ( 'id' ) ) ; if ( ! $ record ) return 'Unable to find redirect with ID: ' . $ id ; } else { $ existing = RedirectRecord :: findOne ( compact ( 'uri' , 'siteId' ) ) ; if ( $ existing ) return 'A redirect with that URI already exists!' ; $ record = new RedirectRecord ( ) ; } $ record -> uri = $ uri ; $ record -> to = $ to ; $ record -> type = $ type ; if ( $ siteId !== false ) $ record -> siteId = $ siteId ; if ( ! $ record -> save ( ) ) return $ record -> getErrors ( ) ; return $ record -> id ; } 
public function bulk ( $ redirects , $ separator , $ type , $ siteId ) { $ rawRedirects = array_map ( function ( $ line ) use ( $ separator ) { return str_getcsv ( $ line , $ separator ) ; } , explode ( PHP_EOL , $ redirects ) ) ; $ newFormatted = [ ] ; foreach ( $ rawRedirects as $ redirect ) { $ record = new RedirectRecord ( ) ; $ record -> uri = $ redirect [ 0 ] ; $ record -> to = $ redirect [ 1 ] ; $ record -> type = array_key_exists ( 2 , $ redirect ) ? $ redirect [ 2 ] : $ type ; $ record -> siteId = $ siteId ; $ record -> save ( ) ; $ newFormatted [ ] = [ 'id' => $ record -> id , 'uri' => $ record -> uri , 'to' => $ record -> to , 'type' => $ record -> type , 'siteId' => $ record -> siteId , ] ; } return [ $ newFormatted , false ] ; } 
public function delete ( $ id ) { $ redirect = RedirectRecord :: findOne ( compact ( 'id' ) ) -> delete ( ) ; if ( $ redirect === false ) return 'Unable find redirect with ID: ' . $ id ; return false ; } 
private function _isRedirectRegex ( $ uri ) { 
public function init ( ) { parent :: init ( ) ; self :: $ i = self :: getInstance ( ) ; $ craft = \ Craft :: $ app ; 
public function onRegisterSeoHook ( & $ context ) { $ craft = \ Craft :: $ app ; $ metaTemplateName = $ this -> getSettings ( ) [ 'metaTemplate' ] ; if ( $ metaTemplateName ) return $ craft -> view -> renderTemplate ( $ metaTemplateName , $ context ) ; $ oldTemplateMode = $ craft -> view -> getTemplateMode ( ) ; $ craft -> view -> setTemplateMode ( View :: TEMPLATE_MODE_CP ) ; $ rendered = $ craft -> view -> renderTemplate ( 'seo/_seo/meta' , $ context ) ; $ craft -> view -> setTemplateMode ( $ oldTemplateMode ) ; return $ rendered ; } 
public function getSitemap ( ) { $ sitemapRaw = SitemapRecord :: find ( ) -> all ( ) ; $ sitemap = [ ] ; foreach ( $ sitemapRaw as $ row ) { if ( ! array_key_exists ( $ row -> group , $ sitemap ) ) $ sitemap [ $ row -> group ] = [ ] ; if ( $ row -> group === 'customUrls' ) $ sitemap [ $ row -> group ] [ ] = $ row ; else $ sitemap [ $ row -> group ] [ $ row -> url ] = $ row ; } return $ sitemap ; } 
public function core ( array $ variables ) { $ this -> _createDocument ( ) ; $ sitemapData = $ this -> getSitemap ( ) ; $ craft = \ Craft :: $ app ; if ( ! array_key_exists ( $ variables [ 'section' ] , $ sitemapData ) ) goto out ; $ sitemapSection = $ sitemapData [ $ variables [ 'section' ] ] ; if ( ! array_key_exists ( $ variables [ 'id' ] , $ sitemapSection ) ) goto out ; $ sitemapSectionById = $ sitemapSection [ $ variables [ 'id' ] ] ; if ( ! $ sitemapSectionById [ 'enabled' ] ) goto out ; $ type = null ; $ idHandle = null ; switch ( $ variables [ 'section' ] ) { case 'sections' : $ type = Entry :: instance ( ) ; $ idHandle = 'sectionId' ; break ; case 'categories' : $ type = Category :: instance ( ) ; $ idHandle = 'groupId' ; break ; default : goto out ; } $ settings = Seo :: $ i -> getSettings ( ) ; $ elements = $ type :: find ( ) ; $ elements -> { $ idHandle } = $ variables [ 'id' ] ; $ elements -> siteId = \ Craft :: $ app -> sites -> currentSite -> id ; $ elements -> limit = $ settings -> sitemapLimit ; $ elements -> offset = $ settings -> sitemapLimit * $ variables [ 'page' ] ; $ currentLocale = $ craft -> locale -> id ; $ availableLocales = $ craft -> i18n -> getSiteLocaleIds ( ) ; if ( ( $ key = array_search ( $ currentLocale , $ availableLocales ) ) !== false ) unset ( $ availableLocales [ $ key ] ) ; $ seoFieldHandle = null ; if ( $ first = $ elements -> one ( ) ) { $ fieldLayout = $ variables [ 'section' ] === 'categories' ? $ first -> fieldLayout : $ first -> type -> fieldLayout ; foreach ( $ fieldLayout -> getFields ( ) as $ field ) if ( get_class ( $ field ) === SeoField :: class ) $ seoFieldHandle = $ field -> handle ; } foreach ( $ elements -> all ( ) as $ item ) { if ( $ item -> url === null ) continue ; if ( $ seoFieldHandle !== null ) { $ seoField = $ item -> $ seoFieldHandle ; if ( $ robots = $ seoField -> advanced [ 'robots' ] ) if ( in_array ( 'noindex' , $ robots ) ) continue ; } $ url = $ this -> _document -> createElement ( 'url' ) ; $ this -> _urlSet -> appendChild ( $ url ) ; $ loc = $ this -> _document -> createElement ( 'loc' , $ item -> url ) ; $ mod = $ this -> _document -> createElement ( 'lastmod' , DateTimeHelper :: toIso8601 ( $ item -> dateUpdated ) ) ; $ freq = $ this -> _document -> createElement ( 'changefreq' , $ sitemapSectionById [ 'frequency' ] ) ; $ priority = $ this -> _document -> createElement ( 'priority' , $ sitemapSectionById [ 'priority' ] ) ; $ url -> appendChild ( $ loc ) ; $ url -> appendChild ( $ mod ) ; $ url -> appendChild ( $ freq ) ; $ url -> appendChild ( $ priority ) ; $ enabledLookup = ( new Query ( ) ) -> select ( [ 'siteId' , 'uri' ] ) -> from ( '{{%elements_sites}}' ) -> where ( '[[elementId]] = ' . $ item -> id ) -> andWhere ( 'enabled = true' ) -> all ( ) ; $ enabledLookup = array_reduce ( $ enabledLookup , function ( $ a , $ b ) { $ uri = $ b [ 'uri' ] ; $ a [ $ b [ 'siteId' ] ] = $ uri === '__home__' ? '' : $ uri ; return $ a ; } , [ ] ) ; foreach ( $ item -> supportedSites as $ siteId ) { $ id = is_numeric ( $ siteId ) ? $ siteId : $ siteId [ 'siteId' ] ; $ site = $ id ? $ craft -> sites -> getSiteById ( $ id ) : \ Craft :: $ app -> sites -> currentSite ; $ lang = $ site -> language ; if ( ! in_array ( $ lang , $ availableLocales ) ) continue ; if ( ! array_key_exists ( $ id , $ enabledLookup ) ) continue ; $ link = UrlHelper :: siteUrl ( $ enabledLookup [ $ id ] , null , null , $ id ) ; $ alt = $ this -> _document -> createElement ( 'xhtml:link' ) ; $ alt -> setAttribute ( 'rel' , 'alternate' ) ; $ alt -> setAttribute ( 'hreflang' , str_replace ( '_' , '-' , $ lang ) ) ; $ alt -> setAttribute ( 'href' , $ link ) ; $ url -> appendChild ( $ alt ) ; } } out : return $ this -> _document -> saveXML ( ) ; } 
public function custom ( ) { $ this -> _createDocument ( ) ; $ sitemapData = $ this -> getSitemap ( ) ; if ( ! array_key_exists ( 'customUrls' , $ sitemapData ) ) return $ this -> _document -> saveXML ( ) ; foreach ( $ sitemapData [ 'customUrls' ] as $ custom ) if ( $ custom -> enabled ) { $ url = $ this -> _document -> createElement ( 'url' ) ; $ loc = $ this -> _document -> createElement ( 'loc' , UrlHelper :: url ( $ custom -> url ) ) ; $ frequency = $ this -> _document -> createElement ( 'changefreq' , $ custom -> frequency ) ; $ priority = $ this -> _document -> createElement ( 'priority' , $ custom -> priority ) ; $ url -> appendChild ( $ loc ) ; $ url -> appendChild ( $ frequency ) ; $ url -> appendChild ( $ priority ) ; $ this -> _urlSet -> appendChild ( $ url ) ; } return $ this -> _document -> saveXML ( ) ; } 
private function _filterOutNoUrls ( $ thing ) { foreach ( $ thing -> getSiteSettings ( ) as $ siteSettings ) if ( $ siteSettings -> hasUrls ) return true ; return false ; } 
private function _createDocument ( $ withUrlSet = true ) { 
private function _getUpdated ( Element $ type , $ id ) { $ criteria = $ type :: find ( ) ; $ this -> _setCriteriaIdByType ( $ criteria , $ type , $ id ) ; $ criteria -> limit = 1 ; $ element = $ criteria -> one ( ) ; return $ element ? $ element -> dateUpdated -> format ( 'c' ) : '' ; } 
private function _getPageCount ( Element $ type , $ id ) { $ criteria = $ type :: find ( ) ; $ this -> _setCriteriaIdByType ( $ criteria , $ type , $ id ) ; $ sitemapLimit = Seo :: $ i -> getSettings ( ) -> sitemapLimit ; return ceil ( $ criteria -> count ( ) / $ sitemapLimit ) ; } 
private function _setCriteriaIdByType ( $ criteria , Element $ type , $ id ) { switch ( $ type :: className ( ) ) { case 'Entry' : $ criteria -> sectionId = $ id ; break ; case 'Category' : $ criteria -> groupId = $ id ; break ; } } 
private function _generateLoop ( $ handle , $ data , $ sitemapData ) { if ( ! array_key_exists ( $ handle , $ sitemapData ) ) return ; foreach ( $ data as $ item ) if ( array_key_exists ( $ item [ 'id' ] , $ sitemapData [ $ handle ] ) ) if ( $ sitemapData [ $ handle ] [ $ item [ 'id' ] ] -> enabled ) $ this -> _generateIndex ( $ handle , $ item [ 'id' ] ) ; } 
private function _generateIndex ( $ group , $ id ) { switch ( $ group ) { case 'custom' : $ last = DateTimeHelper :: toIso8601 ( SitemapRecord :: find ( ) -> one ( ) -> dateUpdated ) ; $ pages = 1 ; break ; case 'sections' : $ last = $ this -> _getUpdated ( Entry :: instance ( ) , $ id ) ; $ pages = $ this -> _getPageCount ( Entry :: instance ( ) , $ id ) ; break ; case 'categories' : $ last = $ this -> _getUpdated ( Category :: instance ( ) , $ id ) ; $ pages = $ this -> _getPageCount ( Category :: instance ( ) , $ id ) ; break ; default : $ last = DateTimeHelper :: currentUTCDateTime ( ) -> format ( 'c' ) ; $ pages = 1 ; } for ( $ i = 0 ; $ i < $ pages ; ++ $ i ) { $ sitemap = $ this -> _document -> createElement ( 'sitemap' ) ; $ this -> _index -> appendChild ( $ sitemap ) ; $ loc = $ this -> _document -> createElement ( 'loc' , $ this -> _indexUrl ( $ group , $ id , $ i ) ) ; $ sitemap -> appendChild ( $ loc ) ; $ lastMod = $ this -> _document -> createElement ( 'lastmod' , $ last ) ; $ sitemap -> appendChild ( $ lastMod ) ; } } 
private function _indexUrl ( $ group , $ id , $ page ) { $ sitemapName = Seo :: $ i -> getSettings ( ) -> sitemapName ; return UrlHelper :: siteUrl ( $ sitemapName . '_' . $ group . ( $ id > 0 ? '_' . $ id : '' ) . ( $ id > 0 ? '_' . $ page : '' ) . '.xml' ) ; } 
private function _asXml ( $ data ) { $ response = \ Craft :: $ app -> getResponse ( ) ; $ response -> content = $ data ; $ response -> format = Response :: FORMAT_XML ; return $ response ; } 
private function _getAllSeoFields ( ) { return ( new Query ( ) ) -> select ( [ 'fields.id' , 'fields.dateCreated' , 'fields.dateUpdated' , 'fields.groupId' , 'fields.name' , 'fields.handle' , 'fields.context' , 'fields.instructions' , 'fields.translationMethod' , 'fields.translationKeyFormat' , 'fields.type' , 'fields.settings' , ] ) -> from ( [ '{{%fields}} fields' ] ) -> where ( [ 'type' => SeoField :: class ] ) -> orderBy ( [ 'fields.name' => SORT_ASC , 'fields.handle' => SORT_ASC ] ) -> all ( ) ; } 
public function init ( ) { $ seoSettings = Seo :: $ i -> getSettings ( ) ; 
public function open ( ) { if ( $ this -> _socket !== false ) { return ; } $ connection = ( $ this -> unixSocket ? : $ this -> hostname . ':' . $ this -> port ) . ', database=' . $ this -> database ; \ Yii :: trace ( 'Opening redis DB connection: ' . $ connection , __METHOD__ ) ; $ this -> _socket = @ stream_socket_client ( $ this -> unixSocket ? 'unix://' . $ this -> unixSocket : 'tcp://' . $ this -> hostname . ':' . $ this -> port , $ errorNumber , $ errorDescription , $ this -> connectionTimeout ? $ this -> connectionTimeout : ini_get ( 'default_socket_timeout' ) , $ this -> socketClientFlags ) ; if ( $ this -> _socket ) { if ( $ this -> dataTimeout !== null ) { stream_set_timeout ( $ this -> _socket , $ timeout = ( int ) $ this -> dataTimeout , ( int ) ( ( $ this -> dataTimeout - $ timeout ) * 1000000 ) ) ; } if ( $ this -> password !== null ) { $ this -> executeCommand ( 'AUTH' , [ $ this -> password ] ) ; } if ( $ this -> database !== null ) { $ this -> executeCommand ( 'SELECT' , [ $ this -> database ] ) ; } $ this -> initConnection ( ) ; } else { \ Yii :: error ( "Failed to open redis DB connection ($connection): $errorNumber - $errorDescription" , __CLASS__ ) ; $ message = YII_DEBUG ? "Failed to open redis DB connection ($connection): $errorNumber - $errorDescription" : 'Failed to open DB connection.' ; throw new Exception ( $ message , $ errorDescription , $ errorNumber ) ; } } 
public function close ( ) { if ( $ this -> _socket !== false ) { $ connection = ( $ this -> unixSocket ? : $ this -> hostname . ':' . $ this -> port ) . ', database=' . $ this -> database ; \ Yii :: trace ( 'Closing DB connection: ' . $ connection , __METHOD__ ) ; try { $ this -> executeCommand ( 'QUIT' ) ; } catch ( SocketException $ e ) { 
public function executeCommand ( $ name , $ params = [ ] ) { $ this -> open ( ) ; $ params = array_merge ( explode ( ' ' , $ name ) , $ params ) ; $ command = '' ; $ paramsCount = 0 ; foreach ( $ params as $ arg ) { if ( $ arg === null ) { continue ; } $ paramsCount ++ ; $ command .= '$' . mb_strlen ( $ arg , '8bit' ) . "\r\n" . $ arg . "\r\n" ; } $ command = '*' . $ paramsCount . "\r\n" . $ command ; \ Yii :: trace ( "Executing Redis Command: {$name}" , __METHOD__ ) ; if ( $ this -> retries > 0 ) { $ tries = $ this -> retries ; while ( $ tries -- > 0 ) { try { return $ this -> sendCommandInternal ( $ command , $ params ) ; } catch ( SocketException $ e ) { \ Yii :: error ( $ e , __METHOD__ ) ; 
private function sendCommandInternal ( $ command , $ params ) { $ written = @ fwrite ( $ this -> _socket , $ command ) ; if ( $ written === false ) { throw new SocketException ( "Failed to write to socket.\nRedis command was: " . $ command ) ; } if ( $ written !== ( $ len = mb_strlen ( $ command , '8bit' ) ) ) { throw new SocketException ( "Failed to write to socket. $written of $len bytes written.\nRedis command was: " . $ command ) ; } return $ this -> parseResponse ( implode ( ' ' , $ params ) ) ; } 
public function init ( ) { if ( is_string ( $ this -> redis ) ) { $ this -> redis = Yii :: $ app -> get ( $ this -> redis ) ; } elseif ( is_array ( $ this -> redis ) ) { if ( ! isset ( $ this -> redis [ 'class' ] ) ) { $ this -> redis [ 'class' ] = Connection :: className ( ) ; } $ this -> redis = Yii :: createObject ( $ this -> redis ) ; } if ( ! $ this -> redis instanceof Connection ) { throw new InvalidConfigException ( "Session::redis must be either a Redis connection instance or the application component ID of a Redis connection." ) ; } if ( $ this -> keyPrefix === null ) { $ this -> keyPrefix = substr ( md5 ( Yii :: $ app -> id ) , 0 , 5 ) ; } parent :: init ( ) ; } 
public function readSession ( $ id ) { $ data = $ this -> redis -> executeCommand ( 'GET' , [ $ this -> calculateKey ( $ id ) ] ) ; return $ data === false || $ data === null ? '' : $ data ; } 
public function writeSession ( $ id , $ data ) { return ( bool ) $ this -> redis -> executeCommand ( 'SET' , [ $ this -> calculateKey ( $ id ) , $ data , 'EX' , $ this -> getTimeout ( ) ] ) ; } 
public function all ( $ db = null ) { if ( $ this -> emulateExecution ) { return [ ] ; } 
public function one ( $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } 
public function count ( $ q = '*' , $ db = null ) { if ( $ this -> emulateExecution ) { return 0 ; } if ( $ this -> where === null ) { $ modelClass = $ this -> modelClass ; if ( $ db === null ) { $ db = $ modelClass :: getDb ( ) ; } return $ db -> executeCommand ( 'LLEN' , [ $ modelClass :: keyPrefix ( ) ] ) ; } else { return $ this -> executeScript ( $ db , 'Count' ) ; } } 
public function exists ( $ db = null ) { if ( $ this -> emulateExecution ) { return false ; } return $ this -> one ( $ db ) !== null ; } 
public function column ( $ column , $ db = null ) { if ( $ this -> emulateExecution ) { return [ ] ; } 
public function scalar ( $ attribute , $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } $ record = $ this -> one ( $ db ) ; if ( $ record !== null ) { return $ record -> hasAttribute ( $ attribute ) ? $ record -> $ attribute : null ; } else { return null ; } } 
protected function executeScript ( $ db , $ type , $ columnName = null ) { if ( $ this -> primaryModel !== null ) { 
private function findByPk ( $ db , $ type , $ columnName = null ) { $ needSort = ! empty ( $ this -> orderBy ) && in_array ( $ type , [ 'All' , 'One' , 'Column' ] ) ; if ( $ needSort ) { if ( ! is_array ( $ this -> orderBy ) || count ( $ this -> orderBy ) > 1 ) { throw new NotSupportedException ( 'orderBy by multiple columns is not currently supported by redis ActiveRecord.' ) ; } $ k = key ( $ this -> orderBy ) ; $ v = $ this -> orderBy [ $ k ] ; if ( is_numeric ( $ k ) ) { $ orderColumn = $ v ; $ orderType = SORT_ASC ; } else { $ orderColumn = $ k ; $ orderType = $ v ; } } if ( isset ( $ this -> where [ 0 ] ) && $ this -> where [ 0 ] === 'in' ) { $ pks = ( array ) $ this -> where [ 2 ] ; } elseif ( count ( $ this -> where ) == 1 ) { $ pks = ( array ) reset ( $ this -> where ) ; } else { foreach ( $ this -> where as $ values ) { if ( is_array ( $ values ) ) { 
public function buildAll ( $ query ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "n=n+1 pks[n]=redis.call('HGETALL',$key .. pk)" , 'pks' ) ; } 
public function buildOne ( $ query ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "do return redis.call('HGETALL',$key .. pk) end" , 'pks' ) ; } 
public function buildColumn ( $ query , $ column ) { 
private function addColumn ( $ column , & $ columns ) { if ( isset ( $ columns [ $ column ] ) ) { return $ columns [ $ column ] ; } $ name = 'c' . preg_replace ( "/[^a-z]+/i" , "" , $ column ) . count ( $ columns ) ; return $ columns [ $ column ] = $ name ; } 
public function buildCondition ( $ condition , & $ columns ) { static $ builders = [ 'not' => 'buildNotCondition' , 'and' => 'buildAndCondition' , 'or' => 'buildAndCondition' , 'between' => 'buildBetweenCondition' , 'not between' => 'buildBetweenCondition' , 'in' => 'buildInCondition' , 'not in' => 'buildInCondition' , 'like' => 'buildLikeCondition' , 'not like' => 'buildLikeCondition' , 'or like' => 'buildLikeCondition' , 'or not like' => 'buildLikeCondition' , '>' => 'buildCompareCondition' , '>=' => 'buildCompareCondition' , '<' => 'buildCompareCondition' , '<=' => 'buildCompareCondition' , ] ; if ( ! is_array ( $ condition ) ) { throw new NotSupportedException ( 'Where condition must be an array in redis ActiveRecord.' ) ; } if ( isset ( $ condition [ 0 ] ) ) { 
public function init ( ) { parent :: init ( ) ; $ this -> redis = Instance :: ensure ( $ this -> redis , Connection :: className ( ) ) ; if ( $ this -> keyPrefix === null ) { $ this -> keyPrefix = substr ( md5 ( Yii :: $ app -> id ) , 0 , 5 ) ; } } 
protected function acquireLock ( $ name , $ timeout = 0 ) { $ key = $ this -> calculateKey ( $ name ) ; $ value = Yii :: $ app -> security -> generateRandomString ( 20 ) ; $ waitTime = 0 ; while ( ! $ this -> redis -> executeCommand ( 'SET' , [ $ key , $ value , 'NX' , 'PX' , ( int ) ( $ this -> expire * 1000 ) ] ) ) { $ waitTime ++ ; if ( $ waitTime > $ timeout ) { return false ; } sleep ( 1 ) ; } $ this -> _lockValues [ $ name ] = $ value ; return true ; } 
protected function releaseLock ( $ name ) { static $ releaseLuaScript = <<<LUA if redis.call("GET",KEYS[1])==ARGV[1] then return redis.call("DEL",KEYS[1]) else return 0 end LUA ; if ( ! isset ( $ this -> _lockValues [ $ name ] ) || ! $ this -> redis -> executeCommand ( 'EVAL' , [ $ releaseLuaScript , 1 , $ this -> calculateKey ( $ name ) , $ this -> _lockValues [ $ name ] ] ) ) { return false ; } else { unset ( $ this -> _lockValues [ $ name ] ) ; return true ; } } 
public static function updateAll ( $ attributes , $ condition = null ) { if ( empty ( $ attributes ) ) { return 0 ; } $ db = static :: getDb ( ) ; $ n = 0 ; foreach ( self :: fetchPks ( $ condition ) as $ pk ) { $ newPk = $ pk ; $ pk = static :: buildKey ( $ pk ) ; $ key = static :: keyPrefix ( ) . ':a:' . $ pk ; 
public static function updateAllCounters ( $ counters , $ condition = null ) { if ( empty ( $ counters ) ) { return 0 ; } $ db = static :: getDb ( ) ; $ n = 0 ; foreach ( self :: fetchPks ( $ condition ) as $ pk ) { $ key = static :: keyPrefix ( ) . ':a:' . static :: buildKey ( $ pk ) ; foreach ( $ counters as $ attribute => $ value ) { $ db -> executeCommand ( 'HINCRBY' , [ $ key , $ attribute , $ value ] ) ; } $ n ++ ; } return $ n ; } 
public static function deleteAll ( $ condition = null ) { $ pks = self :: fetchPks ( $ condition ) ; if ( empty ( $ pks ) ) { return 0 ; } $ db = static :: getDb ( ) ; $ attributeKeys = [ ] ; $ db -> executeCommand ( 'MULTI' ) ; foreach ( $ pks as $ pk ) { $ pk = static :: buildKey ( $ pk ) ; $ db -> executeCommand ( 'LREM' , [ static :: keyPrefix ( ) , 0 , $ pk ] ) ; $ attributeKeys [ ] = static :: keyPrefix ( ) . ':a:' . $ pk ; } $ db -> executeCommand ( 'DEL' , $ attributeKeys ) ; $ result = $ db -> executeCommand ( 'EXEC' ) ; return end ( $ result ) ; } 
public static function buildKey ( $ key ) { if ( is_numeric ( $ key ) ) { return $ key ; } elseif ( is_string ( $ key ) ) { return ctype_alnum ( $ key ) && StringHelper :: byteLength ( $ key ) <= 32 ? $ key : md5 ( $ key ) ; } elseif ( is_array ( $ key ) ) { if ( count ( $ key ) == 1 ) { return self :: buildKey ( reset ( $ key ) ) ; } ksort ( $ key ) ; 
protected function getReplica ( ) { if ( $ this -> enableReplicas === false ) { return $ this -> redis ; } if ( $ this -> _replica !== null ) { return $ this -> _replica ; } if ( empty ( $ this -> replicas ) ) { return $ this -> _replica = $ this -> redis ; } $ replicas = $ this -> replicas ; shuffle ( $ replicas ) ; $ config = array_shift ( $ replicas ) ; $ this -> _replica = Instance :: ensure ( $ config , Connection :: className ( ) ) ; return $ this -> _replica ; } 
public function useFiles ( $ path , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useFiles ( $ path , $ level ) ; } } } 
public function useDailyFiles ( $ path , $ days = 0 , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useDailyFiles ( $ path , $ days , $ level ) ; } } } 
public function getMonolog ( ) { foreach ( $ this -> loggers as $ logger ) { if ( is_callable ( [ $ logger , 'getMonolog' ] ) ) { $ monolog = $ logger -> getMonolog ( ) ; if ( $ monolog === null ) { continue ; } return $ monolog ; } } } 
public function resolve ( ) { $ request = $ this -> app -> make ( Request :: class ) ; if ( $ this -> app -> runningInConsole ( ) ) { $ command = $ request -> server ( 'argv' , [ ] ) ; if ( ! is_array ( $ command ) ) { $ command = explode ( ' ' , $ command ) ; } return new ConsoleRequest ( $ command ) ; } return new LaravelRequest ( $ request ) ; } 
public function getMetaData ( ) { $ data = [ ] ; $ data [ 'url' ] = $ this -> request -> fullUrl ( ) ; $ data [ 'httpMethod' ] = $ this -> request -> getMethod ( ) ; $ data [ 'params' ] = $ this -> request -> input ( ) ; $ data [ 'clientIp' ] = $ this -> request -> getClientIp ( ) ; if ( $ agent = $ this -> request -> header ( 'User-Agent' ) ) { $ data [ 'userAgent' ] = $ agent ; } if ( $ headers = $ this -> request -> headers -> all ( ) ) { $ data [ 'headers' ] = $ headers ; } return [ 'request' => $ data ] ; } 
public function handle ( ) { $ builderName = $ this -> option ( 'builder' ) ; if ( is_null ( $ builderName ) ) { if ( class_exists ( Process :: class ) ) { $ process = new Process ( 'whoami' ) ; $ process -> run ( ) ; if ( $ process -> isSuccessful ( ) ) { $ builderName = trim ( $ process -> getOutput ( ) ) ; } } else { $ builderName = Utils :: getBuilderName ( ) ; } } Bugsnag :: build ( $ this -> option ( 'repository' ) , $ this -> option ( 'revision' ) , $ this -> option ( 'provider' ) , $ builderName ) ; $ this -> info ( 'Notified Bugsnag of the build!' ) ; } 
public function log ( $ level , $ message , array $ context = [ ] ) { parent :: log ( $ level , $ message , $ context ) ; $ this -> fireLogEvent ( $ level , $ message , $ context ) ; } 
protected function fireLogEvent ( $ level , $ message , array $ context = [ ] ) { 
public function boot ( ) { 
public function boot ( ) { $ this -> setupConfig ( $ this -> app ) ; $ this -> setupEvents ( $ this -> app -> events , $ this -> app -> config -> get ( 'bugsnag' ) ) ; $ this -> setupQueue ( $ this -> app -> queue ) ; } 
protected function setupEvents ( Dispatcher $ events , array $ config ) { if ( isset ( $ config [ 'auto_capture_sessions' ] ) && $ config [ 'auto_capture_sessions' ] ) { $ events -> listen ( RouteMatched :: class , function ( $ event ) { $ this -> app -> bugsnag -> getSessionTracker ( ) -> startSession ( ) ; } ) ; } if ( isset ( $ config [ 'query' ] ) && ! $ config [ 'query' ] ) { return ; } $ show = isset ( $ config [ 'bindings' ] ) && $ config [ 'bindings' ] ; if ( class_exists ( QueryExecuted :: class ) ) { $ events -> listen ( QueryExecuted :: class , function ( QueryExecuted $ query ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ query -> sql , $ show ? $ query -> bindings : [ ] , $ query -> time , $ query -> connectionName ) ) ; } ) ; } else { $ events -> listen ( 'illuminate.query' , function ( $ sql , array $ bindings , $ time , $ connection ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ sql , $ show ? $ bindings : [ ] , $ time , $ connection ) ) ; } ) ; } } 
protected function formatQuery ( $ sql , array $ bindings , $ time , $ connection ) { $ data = [ 'sql' => $ sql ] ; foreach ( $ bindings as $ index => $ binding ) { $ data [ "binding {$index}" ] = $ binding ; } $ data [ 'time' ] = "{$time}ms" ; $ data [ 'connection' ] = $ connection ; return $ data ; } 
protected function setupQueue ( QueueManager $ queue ) { $ queue -> looping ( function ( ) { $ this -> app -> bugsnag -> flush ( ) ; $ this -> app -> bugsnag -> clearBreadcrumbs ( ) ; $ this -> app -> make ( Tracker :: class ) -> clear ( ) ; } ) ; if ( ! class_exists ( JobProcessing :: class ) ) { return ; } $ queue -> before ( function ( JobProcessing $ event ) { $ this -> app -> bugsnag -> setFallbackType ( 'Queue' ) ; $ job = [ 'name' => $ event -> job -> getName ( ) , 'queue' => $ event -> job -> getQueue ( ) , 'attempts' => $ event -> job -> attempts ( ) , 'connection' => $ event -> connectionName , ] ; if ( method_exists ( $ event -> job , 'resolveName' ) ) { $ job [ 'resolved' ] = $ event -> job -> resolveName ( ) ; } $ this -> app -> make ( Tracker :: class ) -> set ( $ job ) ; } ) ; } 
public function register ( ) { $ this -> app -> singleton ( 'bugsnag' , function ( Container $ app ) { $ config = $ app -> config -> get ( 'bugsnag' ) ; $ client = new Client ( new Configuration ( $ config [ 'api_key' ] ) , new LaravelResolver ( $ app ) , $ this -> getGuzzle ( $ config ) ) ; $ this -> setupCallbacks ( $ client , $ app , $ config ) ; $ this -> setupPaths ( $ client , $ app -> basePath ( ) , $ app -> path ( ) , isset ( $ config [ 'strip_path' ] ) ? $ config [ 'strip_path' ] : null , isset ( $ config [ 'project_root' ] ) ? $ config [ 'project_root' ] : null ) ; $ client -> setReleaseStage ( isset ( $ config [ 'release_stage' ] ) ? $ config [ 'release_stage' ] : $ app -> environment ( ) ) ; $ client -> setHostname ( isset ( $ config [ 'hostname' ] ) ? $ config [ 'hostname' ] : null ) ; $ client -> setFallbackType ( $ app -> runningInConsole ( ) ? 'Console' : 'HTTP' ) ; $ client -> setAppType ( isset ( $ config [ 'app_type' ] ) ? $ config [ 'app_type' ] : null ) ; $ client -> setAppVersion ( isset ( $ config [ 'app_version' ] ) ? $ config [ 'app_version' ] : null ) ; $ client -> setBatchSending ( isset ( $ config [ 'batch_sending' ] ) ? $ config [ 'batch_sending' ] : true ) ; $ client -> setSendCode ( isset ( $ config [ 'send_code' ] ) ? $ config [ 'send_code' ] : true ) ; $ client -> getPipeline ( ) -> insertBefore ( new UnhandledState ( ) , 'Bugsnag\\Middleware\\SessionData' ) ; $ client -> setNotifier ( [ 'name' => 'Bugsnag Laravel' , 'version' => static :: VERSION , 'url' => 'https://github.com/bugsnag/bugsnag-laravel' , ] ) ; if ( isset ( $ config [ 'notify_release_stages' ] ) && is_array ( $ config [ 'notify_release_stages' ] ) ) { $ client -> setNotifyReleaseStages ( $ config [ 'notify_release_stages' ] ) ; } if ( isset ( $ config [ 'filters' ] ) && is_array ( $ config [ 'filters' ] ) ) { $ client -> setFilters ( $ config [ 'filters' ] ) ; } if ( isset ( $ config [ 'auto_capture_sessions' ] ) && $ config [ 'auto_capture_sessions' ] ) { $ endpoint = isset ( $ config [ 'session_endpoint' ] ) ? $ config [ 'session_endpoint' ] : null ; $ this -> setupSessionTracking ( $ client , $ endpoint , $ this -> app -> events ) ; } if ( isset ( $ config [ 'build_endpoint' ] ) ) { $ client -> setBuildEndpoint ( $ config [ 'build_endpoint' ] ) ; } return $ client ; } ) ; $ this -> app -> singleton ( 'bugsnag.tracker' , function ( ) { return new Tracker ( ) ; } ) ; $ this -> app -> singleton ( 'bugsnag.logger' , function ( Container $ app ) { $ config = $ app -> config -> get ( 'bugsnag' ) ; $ logger = interface_exists ( Log :: class ) ? new LaravelLogger ( $ app [ 'bugsnag' ] , $ app [ 'events' ] ) : new BugsnagLogger ( $ app [ 'bugsnag' ] ) ; if ( isset ( $ config [ 'logger_notify_level' ] ) ) { $ logger -> setNotifyLevel ( $ config [ 'logger_notify_level' ] ) ; } return $ logger ; } ) ; $ this -> app -> singleton ( 'bugsnag.multi' , function ( Container $ app ) { return interface_exists ( Log :: class ) ? new MultiLogger ( [ $ app [ 'log' ] , $ app [ 'bugsnag.logger' ] ] ) : new BaseMultiLogger ( [ $ app [ 'log' ] , $ app [ 'bugsnag.logger' ] ] ) ; } ) ; if ( $ this -> app [ 'log' ] instanceof LogManager ) { $ this -> app [ 'log' ] -> extend ( 'bugsnag' , function ( Container $ app , array $ config ) { $ handler = new PsrHandler ( $ app [ 'bugsnag.logger' ] ) ; return new Logger ( 'bugsnag' , [ $ handler ] ) ; } ) ; } $ this -> app -> alias ( 'bugsnag' , Client :: class ) ; $ this -> app -> alias ( 'bugsnag.tracker' , Tracker :: class ) ; $ this -> app -> alias ( 'bugsnag.logger' , interface_exists ( Log :: class ) ? LaravelLogger :: class : BugsnagLogger :: class ) ; $ this -> app -> alias ( 'bugsnag.multi' , interface_exists ( Log :: class ) ? MultiLogger :: class : BaseMultiLogger :: class ) ; } 
protected function getGuzzle ( array $ config ) { $ options = [ ] ; if ( isset ( $ config [ 'proxy' ] ) && $ config [ 'proxy' ] ) { if ( isset ( $ config [ 'proxy' ] [ 'http' ] ) && php_sapi_name ( ) != 'cli' ) { unset ( $ config [ 'proxy' ] [ 'http' ] ) ; } $ options [ 'proxy' ] = $ config [ 'proxy' ] ; } return Client :: makeGuzzle ( isset ( $ config [ 'endpoint' ] ) ? $ config [ 'endpoint' ] : null , $ options ) ; } 
protected function setupCallbacks ( Client $ client , Container $ app , array $ config ) { if ( ! isset ( $ config [ 'callbacks' ] ) || $ config [ 'callbacks' ] ) { $ client -> registerDefaultCallbacks ( ) ; $ client -> registerCallback ( function ( Report $ report ) use ( $ app ) { $ tracker = $ app -> make ( Tracker :: class ) ; if ( $ context = $ tracker -> context ( ) ) { $ report -> setContext ( $ context ) ; } if ( $ job = $ tracker -> get ( ) ) { $ report -> setMetaData ( [ 'job' => $ job ] ) ; } } ) ; } if ( ! isset ( $ config [ 'user' ] ) || $ config [ 'user' ] ) { $ client -> registerCallback ( new CustomUser ( function ( ) use ( $ app ) { if ( $ user = $ app -> auth -> user ( ) ) { if ( method_exists ( $ user , 'attributesToArray' ) && is_callable ( [ $ user , 'attributesToArray' ] ) ) { return $ user -> attributesToArray ( ) ; } if ( $ user instanceof GenericUser ) { $ reflection = new ReflectionClass ( $ user ) ; $ property = $ reflection -> getProperty ( 'attributes' ) ; $ property -> setAccessible ( true ) ; return $ property -> getValue ( $ user ) ; } } } ) ) ; } } 
protected function setupPaths ( Client $ client , $ base , $ path , $ strip , $ project ) { if ( $ strip ) { $ client -> setStripPath ( $ strip ) ; if ( ! $ project ) { $ client -> setProjectRoot ( "{$strip}/app" ) ; } return ; } if ( $ project ) { if ( $ base && substr ( $ project , 0 , strlen ( $ base ) ) === $ base ) { $ client -> setStripPath ( $ base ) ; } $ client -> setProjectRoot ( $ project ) ; return ; } $ client -> setStripPath ( $ base ) ; $ client -> setProjectRoot ( $ path ) ; } 
protected function setupSessionTracking ( Client $ client , $ endpoint , $ events ) { $ client -> setAutoCaptureSessions ( true ) ; if ( ! is_null ( $ endpoint ) ) { $ client -> setSessionEndpoint ( $ endpoint ) ; } $ sessionTracker = $ client -> getSessionTracker ( ) ; $ sessionStorage = function ( $ session = null ) { if ( is_null ( $ session ) ) { return session ( 'bugsnag-session' , [ ] ) ; } else { session ( [ 'bugsnag-session' => $ session ] ) ; } } ; $ sessionTracker -> setSessionFunction ( $ sessionStorage ) ; $ cache = $ this -> app -> cache ; $ genericStorage = function ( $ key , $ value = null ) use ( $ cache ) { if ( is_null ( $ value ) ) { return $ cache -> get ( $ key , null ) ; } else { $ cache -> put ( $ key , $ value , 60 ) ; } } ; $ sessionTracker -> setStorageFunction ( $ genericStorage ) ; } 
public function getDistance ( Coordinate $ point1 , Coordinate $ point2 ) : float { if ( $ point1 -> getEllipsoid ( ) -> getName ( ) !== $ point2 -> getEllipsoid ( ) -> getName ( ) ) { throw new NotMatchingEllipsoidException ( 'The ellipsoids for both coordinates must match' ) ; } $ lat1 = deg2rad ( $ point1 -> getLat ( ) ) ; $ lat2 = deg2rad ( $ point2 -> getLat ( ) ) ; $ lng1 = deg2rad ( $ point1 -> getLng ( ) ) ; $ lng2 = deg2rad ( $ point2 -> getLng ( ) ) ; $ a = $ point1 -> getEllipsoid ( ) -> getA ( ) ; $ b = $ point1 -> getEllipsoid ( ) -> getB ( ) ; $ f = 1 / $ point1 -> getEllipsoid ( ) -> getF ( ) ; $ L = $ lng2 - $ lng1 ; $ U1 = atan ( ( 1 - $ f ) * tan ( $ lat1 ) ) ; $ U2 = atan ( ( 1 - $ f ) * tan ( $ lat2 ) ) ; $ iterationLimit = 100 ; $ lambda = $ L ; $ sinU1 = sin ( $ U1 ) ; $ sinU2 = sin ( $ U2 ) ; $ cosU1 = cos ( $ U1 ) ; $ cosU2 = cos ( $ U2 ) ; do { $ sinLambda = sin ( $ lambda ) ; $ cosLambda = cos ( $ lambda ) ; $ sinSigma = sqrt ( ( $ cosU2 * $ sinLambda ) * ( $ cosU2 * $ sinLambda ) + ( $ cosU1 * $ sinU2 - $ sinU1 * $ cosU2 * $ cosLambda ) * ( $ cosU1 * $ sinU2 - $ sinU1 * $ cosU2 * $ cosLambda ) ) ; if ( abs ( $ sinSigma ) < 1E-12 ) { return 0.0 ; } $ cosSigma = $ sinU1 * $ sinU2 + $ cosU1 * $ cosU2 * $ cosLambda ; $ sigma = atan2 ( $ sinSigma , $ cosSigma ) ; $ sinAlpha = $ cosU1 * $ cosU2 * $ sinLambda / $ sinSigma ; $ cosSqAlpha = 1 - $ sinAlpha * $ sinAlpha ; $ cos2SigmaM = 0 ; if ( abs ( $ cosSqAlpha ) > 1E-12 ) { $ cos2SigmaM = $ cosSigma - 2 * $ sinU1 * $ sinU2 / $ cosSqAlpha ; } $ C = $ f / 16 * $ cosSqAlpha * ( 4 + $ f * ( 4 - 3 * $ cosSqAlpha ) ) ; $ lambdaP = $ lambda ; $ lambda = $ L + ( 1 - $ C ) * $ f * $ sinAlpha * ( $ sigma + $ C * $ sinSigma * ( $ cos2SigmaM + $ C * $ cosSigma * ( - 1 + 2 * $ cos2SigmaM * $ cos2SigmaM ) ) ) ; } while ( abs ( $ lambda - $ lambdaP ) > 1e-12 && -- $ iterationLimit > 0 ) ; if ( $ iterationLimit === 0 ) { throw new NotConvergingException ( 'Vincenty calculation does not converge' ) ; } $ uSq = $ cosSqAlpha * ( $ a * $ a - $ b * $ b ) / ( $ b * $ b ) ; $ A = 1 + $ uSq / 16384 * ( 4096 + $ uSq * ( - 768 + $ uSq * ( 320 - 175 * $ uSq ) ) ) ; $ B = $ uSq / 1024 * ( 256 + $ uSq * ( - 128 + $ uSq * ( 74 - 47 * $ uSq ) ) ) ; $ deltaSigma = $ B * $ sinSigma * ( $ cos2SigmaM + $ B / 4 * ( $ cosSigma * ( - 1 + 2 * $ cos2SigmaM * $ cos2SigmaM ) - $ B / 6 * $ cos2SigmaM * ( - 3 + 4 * $ sinSigma * $ sinSigma ) * ( - 3 + 4 * $ cos2SigmaM * $ cos2SigmaM ) ) ) ; $ s = $ b * $ A * ( $ sigma - $ deltaSigma ) ; return round ( $ s , 3 ) ; } 
public static function fromString ( string $ string , Ellipsoid $ ellipsoid = null ) : Coordinate { $ string = self :: mergeSecondsToMinutes ( $ string ) ; $ result = self :: parseDecimalMinutesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalMinutesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } throw new InvalidArgumentException ( 'Format of coordinates was not recognized' ) ; } 
private static function parseDecimalMinutesWithoutCardinalLetters ( string $ string , Ellipsoid $ ellipsoid = null ) { 
private static function parseDecimalMinutesWithCardinalLetters ( string $ string , Ellipsoid $ ellipsoid = null ) { 
private static function parseDecimalDegreesWithoutCardinalLetters ( string $ string , Ellipsoid $ ellipsoid = null ) { 
private static function mergeSecondsToMinutes ( string $ string ) : string { return preg_replace_callback ( '/(\d+)(°|\s)\s*(\d+)(\'|′|\s)(\s*([0-9\.]*))("|\'\'|″|′′)?/u', function ( array $ matches ) : string { return sprintf ( '%d %f' , $ matches [ 1 ] , $ matches [ 3 ] + $ matches [ 6 ] / 60 ) ; } , $ string ) ; } 
public function getCenter ( ) : Coordinate { $ centerLat = ( $ this -> getNorth ( ) + $ this -> getSouth ( ) ) / 2 ; return new Coordinate ( $ centerLat , $ this -> getCenterLng ( ) ) ; } 
public function format ( Coordinate $ coordinate ) : string { $ lat = $ coordinate -> getLat ( ) ; $ lng = $ coordinate -> getLng ( ) ; $ latValue = abs ( $ lat ) ; $ latDegrees = ( int ) $ latValue ; $ latMinutesDecimal = $ latValue - $ latDegrees ; $ latMinutes = 60 * $ latMinutesDecimal ; $ lngValue = abs ( $ lng ) ; $ lngDegrees = ( int ) $ lngValue ; $ lngMinutesDecimal = $ lngValue - $ lngDegrees ; $ lngMinutes = 60 * $ lngMinutesDecimal ; return sprintf ( '%s%02d%s %s%s%s%s%s%03d%s %s%s%s' , $ this -> getLatPrefix ( $ lat ) , abs ( $ latDegrees ) , $ this -> units [ $ this -> unitType ] [ 'deg' ] , number_format ( $ latMinutes , $ this -> digits , $ this -> decimalPoint , $ this -> decimalPoint ) , $ this -> units [ $ this -> unitType ] [ 'min' ] , $ this -> getLatSuffix ( $ lat ) , $ this -> separator , $ this -> getLngPrefix ( $ lng ) , abs ( $ lngDegrees ) , $ this -> units [ $ this -> unitType ] [ 'deg' ] , number_format ( $ lngMinutes , $ this -> digits , $ this -> decimalPoint , $ this -> decimalPoint ) , $ this -> units [ $ this -> unitType ] [ 'min' ] , $ this -> getLngSuffix ( $ lng ) ) ; } 
public function simplify ( Polyline $ polyline ) : Polyline { $ counterPoints = $ polyline -> getNumberOfPoints ( ) ; if ( $ counterPoints < 3 ) { return clone $ polyline ; } $ result = new Polyline ( ) ; $ bearingCalc = new BearingEllipsoidal ( ) ; $ points = $ polyline -> getPoints ( ) ; $ index = 0 ; 
public function format ( Polyline $ polyline ) : string { $ points = [ ] ; foreach ( $ polyline -> getPoints ( ) as $ point ) { $ points [ ] = [ $ point -> getLng ( ) , $ point -> getLat ( ) ] ; } return json_encode ( [ 'type' => 'LineString' , 'coordinates' => $ points , ] ) ; } 
public function getDistance ( Coordinate $ coordinate , DistanceInterface $ calculator ) : float { return $ calculator -> getDistance ( $ this , $ coordinate ) ; } 
protected function isNumericInBounds ( float $ value , float $ lower , float $ upper ) : bool { return ! ( $ value < $ lower || $ value > $ upper ) ; } 
public function getLength ( DistanceInterface $ calculator ) : float { $ distance = 0.0 ; if ( count ( $ this -> points ) <= 1 ) { return $ distance ; } foreach ( $ this -> getSegments ( ) as $ segment ) { $ distance += $ segment -> getLength ( $ calculator ) ; } return $ distance ; } 
public function setUnits ( string $ type ) : DMS { if ( ! array_key_exists ( $ type , $ this -> units ) ) { throw new \ InvalidArgumentException ( 'Invalid unit type' ) ; } $ this -> unitType = $ type ; return $ this ; } 
public function format ( Coordinate $ coordinate ) : string { return sprintf ( '%.' . $ this -> digits . 'f%s%.' . $ this -> digits . 'f' , $ coordinate -> getLat ( ) , $ this -> separator , $ coordinate -> getLng ( ) ) ; } 
public function getLength ( DistanceInterface $ calculator ) : float { return $ calculator -> getDistance ( $ this -> point1 , $ this -> point2 ) ; } 
public function getBearing ( BearingInterface $ bearingCalculator ) : float { return $ bearingCalculator -> calculateBearing ( $ this -> point1 , $ this -> point2 ) ; } 
public function getFinalBearing ( BearingInterface $ bearingCalculator ) : float { return $ bearingCalculator -> calculateFinalBearing ( $ this -> point1 , $ this -> point2 ) ; } 
public function simplify ( Polyline $ polyline ) : Polyline { $ resultPolyline = new Polyline ( ) ; $ simplifiedLine = $ this -> douglasPeucker ( $ polyline -> getPoints ( ) ) ; foreach ( $ simplifiedLine as $ point ) { $ resultPolyline -> addPoint ( $ point ) ; } return $ resultPolyline ; } 
protected function douglasPeucker ( array $ line ) : array { $ distanceMax = 0 ; $ index = 0 ; $ lineSize = count ( $ line ) ; $ pdCalc = new PerpendicularDistance ( ) ; for ( $ i = 1 ; $ i <= ( $ lineSize - 2 ) ; $ i ++ ) { $ distance = $ pdCalc -> getPerpendicularDistance ( $ line [ $ i ] , new Line ( $ line [ 0 ] , $ line [ $ lineSize - 1 ] ) ) ; if ( $ distance > $ distanceMax ) { $ index = $ i ; $ distanceMax = $ distance ; } } if ( $ distanceMax > $ this -> tolerance ) { $ lineSplitFirst = array_slice ( $ line , 0 , $ index + 1 ) ; $ lineSplitSecond = array_slice ( $ line , $ index , $ lineSize - $ index ) ; if ( count ( $ lineSplitFirst ) > 2 ) { $ resultsSplit1 = $ this -> douglasPeucker ( $ lineSplitFirst ) ; } else { $ resultsSplit1 = $ lineSplitFirst ; } if ( count ( $ lineSplitSecond ) > 2 ) { $ resultsSplit2 = $ this -> douglasPeucker ( $ lineSplitSecond ) ; } else { $ resultsSplit2 = $ lineSplitSecond ; } array_pop ( $ resultsSplit1 ) ; return array_merge ( $ resultsSplit1 , $ resultsSplit2 ) ; } return [ $ line [ 0 ] , $ line [ $ lineSize - 1 ] ] ; } 
public function getDistance ( Coordinate $ point1 , Coordinate $ point2 ) : float { if ( $ point1 -> getEllipsoid ( ) -> getName ( ) !== $ point2 -> getEllipsoid ( ) -> getName ( ) ) { throw new NotMatchingEllipsoidException ( 'The ellipsoids for both coordinates must match' ) ; } $ lat1 = deg2rad ( $ point1 -> getLat ( ) ) ; $ lat2 = deg2rad ( $ point2 -> getLat ( ) ) ; $ lng1 = deg2rad ( $ point1 -> getLng ( ) ) ; $ lng2 = deg2rad ( $ point2 -> getLng ( ) ) ; $ dLat = $ lat2 - $ lat1 ; $ dLng = $ lng2 - $ lng1 ; $ radius = $ point1 -> getEllipsoid ( ) -> getArithmeticMeanRadius ( ) ; $ distance = 2 * $ radius * asin ( sqrt ( ( sin ( $ dLat / 2 ) ** 2 ) + cos ( $ lat1 ) * cos ( $ lat2 ) * ( sin ( $ dLng / 2 ) ** 2 ) ) ) ; return round ( $ distance , 3 ) ; } 
public function calculateBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ lat1 = deg2rad ( $ point1 -> getLat ( ) ) ; $ lat2 = deg2rad ( $ point2 -> getLat ( ) ) ; $ lng1 = deg2rad ( $ point1 -> getLng ( ) ) ; $ lng2 = deg2rad ( $ point2 -> getLng ( ) ) ; $ y = sin ( $ lng2 - $ lng1 ) * cos ( $ lat2 ) ; $ x = cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lng2 - $ lng1 ) ; $ bearing = rad2deg ( atan2 ( $ y , $ x ) ) ; if ( $ bearing < 0 ) { $ bearing = fmod ( $ bearing + 360 , 360 ) ; } return $ bearing ; } 
public function calculateFinalBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ initialBearing = $ this -> calculateBearing ( $ point2 , $ point1 ) ; return fmod ( $ initialBearing + 180 , 360 ) ; } 
public function calculateDestination ( Coordinate $ point , float $ bearing , float $ distance ) : Coordinate { $ D = $ distance / static :: EARTH_RADIUS ; $ B = deg2rad ( $ bearing ) ; $ φ eg2rad( $ p oint- >g etLat( ) ) ; $ λ eg2rad( $ p oint- >g etLng( ) ) ; $ Φ sin( s in( $ φ ) * c s($ D ) + c s($ φ ) * i ($D ) * o ($B ) ) ; $ Λ λ + a an2(s i n($ B ) * s n($ D ) * c s($ φ ) , c o ($D ) - i ($φ ) * s n $φ) ) ; return new Coordinate ( rad2deg ( $ Φ) , ad2deg( $ Λ )) ; } 
public function getPerpendicularDistance ( Coordinate $ point , Line $ line ) : float { $ ellipsoid = $ point -> getEllipsoid ( ) ; $ ellipsoidRadius = $ ellipsoid -> getArithmeticMeanRadius ( ) ; $ firstLinePointLat = $ this -> deg2radLatitude ( $ line -> getPoint1 ( ) -> getLat ( ) ) ; $ firstLinePointLng = $ this -> deg2radLongitude ( $ line -> getPoint1 ( ) -> getLng ( ) ) ; $ firstLinePointX = $ ellipsoidRadius * cos ( $ firstLinePointLng ) * sin ( $ firstLinePointLat ) ; $ firstLinePointY = $ ellipsoidRadius * sin ( $ firstLinePointLng ) * sin ( $ firstLinePointLat ) ; $ firstLinePointZ = $ ellipsoidRadius * cos ( $ firstLinePointLat ) ; $ secondLinePointLat = $ this -> deg2radLatitude ( $ line -> getPoint2 ( ) -> getLat ( ) ) ; $ secondLinePointLng = $ this -> deg2radLongitude ( $ line -> getPoint2 ( ) -> getLng ( ) ) ; $ secondLinePointX = $ ellipsoidRadius * cos ( $ secondLinePointLng ) * sin ( $ secondLinePointLat ) ; $ secondLinePointY = $ ellipsoidRadius * sin ( $ secondLinePointLng ) * sin ( $ secondLinePointLat ) ; $ secondLinePointZ = $ ellipsoidRadius * cos ( $ secondLinePointLat ) ; $ pointLat = $ this -> deg2radLatitude ( $ point -> getLat ( ) ) ; $ pointLng = $ this -> deg2radLongitude ( $ point -> getLng ( ) ) ; $ pointX = $ ellipsoidRadius * cos ( $ pointLng ) * sin ( $ pointLat ) ; $ pointY = $ ellipsoidRadius * sin ( $ pointLng ) * sin ( $ pointLat ) ; $ pointZ = $ ellipsoidRadius * cos ( $ pointLat ) ; $ normalizedX = $ firstLinePointY * $ secondLinePointZ - $ firstLinePointZ * $ secondLinePointY ; $ normalizedY = $ firstLinePointZ * $ secondLinePointX - $ firstLinePointX * $ secondLinePointZ ; $ normalizedZ = $ firstLinePointX * $ secondLinePointY - $ firstLinePointY * $ secondLinePointX ; $ length = sqrt ( $ normalizedX * $ normalizedX + $ normalizedY * $ normalizedY + $ normalizedZ * $ normalizedZ ) ; if ( $ length == 0.0 ) { return 0 ; } $ normalizedX /= $ length ; $ normalizedY /= $ length ; $ normalizedZ /= $ length ; $ thetaPoint = $ normalizedX * $ pointX + $ normalizedY * $ pointY + $ normalizedZ * $ pointZ ; $ length = sqrt ( $ pointX * $ pointX + $ pointY * $ pointY + $ pointZ * $ pointZ ) ; $ thetaPoint /= $ length ; $ distance = ( float ) abs ( ( M_PI / 2 ) - acos ( $ thetaPoint ) ) ; return $ distance * $ ellipsoidRadius ; } 
public function format ( Polygon $ polygon ) : string { if ( $ polygon -> getNumberOfPoints ( ) < 3 ) { throw new InvalidPolygonException ( 'A polygon must consist of at least three points.' ) ; } $ points = [ ] ; foreach ( $ polygon -> getPoints ( ) as $ point ) { $ points [ ] = [ $ point -> getLng ( ) , $ point -> getLat ( ) ] ; } return json_encode ( [ 'type' => 'Polygon' , 'coordinates' => [ $ points ] , ] ) ; } 
public function getLats ( ) : array { $ lats = [ ] ; foreach ( $ this -> points as $ point ) { $ lats [ ] = $ point -> getLat ( ) ; } return $ lats ; } 
public function getLngs ( ) : array { $ lngs = [ ] ; foreach ( $ this -> points as $ point ) { $ lngs [ ] = $ point -> getLng ( ) ; } return $ lngs ; } 
public function containsGeometry ( GeometryInterface $ geometry ) : bool { $ geometryInPolygon = true ; foreach ( $ geometry -> getPoints ( ) as $ point ) { $ geometryInPolygon = $ geometryInPolygon && $ this -> contains ( $ point ) ; } return $ geometryInPolygon ; } 
public function contains ( Coordinate $ point ) : bool { $ numberOfPoints = $ this -> getNumberOfPoints ( ) ; $ polygonLats = $ this -> getLats ( ) ; $ polygonLngs = $ this -> getLngs ( ) ; $ polygonContainsPoint = false ; for ( $ node = 0 , $ altNode = ( $ numberOfPoints - 1 ) ; $ node < $ numberOfPoints ; $ altNode = $ node ++ ) { if ( ( $ polygonLngs [ $ node ] > $ point -> getLng ( ) !== ( $ polygonLngs [ $ altNode ] > $ point -> getLng ( ) ) ) && ( $ point -> getLat ( ) < ( $ polygonLats [ $ altNode ] - $ polygonLats [ $ node ] ) * ( $ point -> getLng ( ) - $ polygonLngs [ $ node ] ) / ( $ polygonLngs [ $ altNode ] - $ polygonLngs [ $ node ] ) + $ polygonLats [ $ node ] ) ) { $ polygonContainsPoint = ! $ polygonContainsPoint ; } } return $ polygonContainsPoint ; } 
public function getPerimeter ( DistanceInterface $ calculator ) : float { $ perimeter = 0.0 ; if ( count ( $ this -> points ) < 2 ) { return $ perimeter ; } foreach ( $ this -> getSegments ( ) as $ segment ) { $ perimeter += $ segment -> getLength ( $ calculator ) ; } return $ perimeter ; } 
public function getArea ( ) : float { $ area = 0 ; if ( $ this -> getNumberOfPoints ( ) <= 2 ) { return $ area ; } $ referencePoint = $ this -> points [ 0 ] ; $ radius = $ referencePoint -> getEllipsoid ( ) -> getArithmeticMeanRadius ( ) ; $ segments = $ this -> getSegments ( ) ; foreach ( $ segments as $ segment ) { $ point1 = $ segment -> getPoint1 ( ) ; $ point2 = $ segment -> getPoint2 ( ) ; $ x1 = deg2rad ( $ point1 -> getLng ( ) - $ referencePoint -> getLng ( ) ) * cos ( deg2rad ( $ point1 -> getLat ( ) ) ) ; $ y1 = deg2rad ( $ point1 -> getLat ( ) - $ referencePoint -> getLat ( ) ) ; $ x2 = deg2rad ( $ point2 -> getLng ( ) - $ referencePoint -> getLng ( ) ) * cos ( deg2rad ( $ point2 -> getLat ( ) ) ) ; $ y2 = deg2rad ( $ point2 -> getLat ( ) - $ referencePoint -> getLat ( ) ) ; $ area += ( $ x2 * $ y1 - $ x1 * $ y2 ) ; } $ area *= 0.5 * $ radius ** 2 ; return ( float ) abs ( $ area ) ; } 
public function getReverse ( ) : Polygon { $ reversed = new static ( ) ; foreach ( array_reverse ( $ this -> points ) as $ point ) { $ reversed -> addPoint ( $ point ) ; } return $ reversed ; } 
public function endConnection ( ConnectionInterface $ stream ) { $ tid = true ; $ loop = $ this -> loop ; 
private function setAuth ( $ username , $ password ) { if ( strlen ( $ username ) > 255 || strlen ( $ password ) > 255 ) { throw new InvalidArgumentException ( 'Both username and password MUST NOT exceed a length of 255 bytes each' ) ; } $ this -> auth = pack ( 'C2' , 0x01 , strlen ( $ username ) ) . $ username . pack ( 'C' , strlen ( $ password ) ) . $ password ; } 
public function connect ( $ uri ) { if ( strpos ( $ uri , '://' ) === false ) { $ uri = 'tcp://' . $ uri ; } $ parts = parse_url ( $ uri ) ; if ( ! $ parts || ! isset ( $ parts [ 'scheme' ] , $ parts [ 'host' ] , $ parts [ 'port' ] ) || $ parts [ 'scheme' ] !== 'tcp' ) { return Promise \ reject ( new InvalidArgumentException ( 'Invalid target URI specified' ) ) ; } $ host = trim ( $ parts [ 'host' ] , '[]' ) ; $ port = $ parts [ 'port' ] ; if ( strlen ( $ host ) > 255 || $ port > 65535 || $ port < 0 || ( string ) $ port !== ( string ) ( int ) $ port ) { return Promise \ reject ( new InvalidArgumentException ( 'Invalid target specified' ) ) ; } 
public function handleConnectedSocks ( ConnectionInterface $ stream , $ host , $ port , Deferred $ deferred , $ uri ) { $ reader = new StreamReader ( ) ; $ stream -> on ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> on ( 'error' , $ onError = function ( Exception $ e ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy caused a stream error (EIO)' , defined ( 'SOCKET_EIO' ) ? SOCKET_EIO : 5 , $ e ) ) ; } ) ; $ stream -> on ( 'close' , $ onClose = function ( ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy was lost while waiting for response from proxy (ECONNRESET)' , defined ( 'SOCKET_ECONNRESET' ) ? SOCKET_ECONNRESET : 104 ) ) ; } ) ; if ( $ this -> protocolVersion === 5 ) { $ promise = $ this -> handleSocks5 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } else { $ promise = $ this -> handleSocks4 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } $ promise -> then ( function ( ) use ( $ deferred , $ stream , $ reader , $ onError , $ onClose ) { $ stream -> removeListener ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> removeListener ( 'error' , $ onError ) ; $ stream -> removeListener ( 'close' , $ onClose ) ; $ deferred -> resolve ( $ stream ) ; } , function ( Exception $ error ) use ( $ deferred , $ stream , $ uri ) { 
public function add ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = new SimpleResponse ( $ message ) ; } elseif ( $ message instanceof ResponseInterface ) { $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof QuestionInterface ) { $ this -> messages [ ] = $ message ; } return $ this ; } 
public function render ( ) { $ out = [ ] ; $ out [ 'expectUserResponse' ] = $ this -> expectUserResponse ; $ items = [ ] ; $ suggestions = [ ] ; $ linkOutSuggestion = null ; foreach ( $ this -> messages as $ message ) { if ( $ message instanceof ResponseInterface ) { $ item = $ message -> renderRichResponseItem ( ) ; if ( $ item ) { $ items [ ] = $ item ; } } if ( $ message instanceof SuggestionInterface ) { $ rendered = $ message -> renderRichResponseSuggestion ( ) ; if ( is_array ( $ rendered ) ) { foreach ( $ rendered as $ suggestion ) { $ suggestions [ ] = [ 'title' => $ suggestion ] ; } } elseif ( is_string ( $ rendered ) ) { $ suggestions [ ] = [ 'title' => $ rendered ] ; } else { 
protected function renderV1 ( ) { if ( 'google' == $ this -> requestSource ) { $ out = [ 'type' => 'basic_card' , 'platform' => $ this -> requestSource , 'title' => $ this -> title , ] ; if ( ! $ this -> text && ! $ this -> imageUrl ) { $ out [ 'formattedText' ] = ' ' ; 
protected function renderV2 ( ) { if ( 'google' == $ this -> requestSource ) { $ out = [ 'basicCard' => [ 'title' => $ this -> title , ] , 'platform' => $ this -> v2PlatformMap [ $ this -> requestSource ] , ] ; if ( $ this -> text ) { $ out [ 'basicCard' ] [ 'formattedText' ] = $ this -> text ; } if ( $ this -> imageUrl ) { $ out [ 'basicCard' ] [ 'image' ] = [ 'imageUri' => $ this -> imageUrl , 'accessibilityText' => 'accessibility text' , ] ; } if ( $ this -> buttons ) { $ out [ 'basicCard' ] [ 'buttons' ] = [ ] ; foreach ( $ this -> buttons as $ button ) { $ out [ 'basicCard' ] [ 'buttons' ] [ ] = [ 'title' => $ button [ 'buttonText' ] , 'openUriAction' => [ 'uri' => $ button [ 'buttonUrl' ] , ] , ] ; } } return $ out ; } else { $ out = [ 'card' => [ 'title' => $ this -> title , ] , 'platform' => $ this -> v2PlatformMap [ $ this -> requestSource ] , ] ; if ( $ this -> text ) { $ out [ 'card' ] [ 'subtitle' ] = $ this -> text ; } if ( $ this -> imageUrl ) { $ out [ 'card' ] [ 'imageUri' ] = $ this -> imageUrl ; } if ( $ this -> buttons ) { $ out [ 'card' ] [ 'buttons' ] = [ ] ; foreach ( $ this -> buttons as $ button ) { $ out [ 'card' ] [ 'buttons' ] [ ] = [ 'text' => $ button [ 'buttonText' ] , 'postback' => $ button [ 'buttonUrl' ] , ] ; } } return $ out ; } } 
public function get ( $ name ) { foreach ( $ this -> arguments as $ argument ) { if ( $ argument [ 'name' ] == $ name ) { if ( isset ( $ this -> mapArgumentName [ $ name ] ) ) { return $ this -> { $ this -> mapArgumentName [ $ name ] } ( $ argument ) ; } else { return $ argument ; } } } } 
private function getDateTime ( $ argument ) { $ datetimeValue = $ argument [ 'datetimeValue' ] ; $ year = $ datetimeValue [ 'date' ] [ 'year' ] ; $ month = $ datetimeValue [ 'date' ] [ 'month' ] ; $ day = $ datetimeValue [ 'date' ] [ 'day' ] ; $ hours = $ datetimeValue [ 'time' ] [ 'hours' ] ; $ minutes = isset ( $ datetimeValue [ 'time' ] [ 'minutes' ] ) ? $ datetimeValue [ 'time' ] [ 'minutes' ] : 0 ; return Carbon :: create ( $ year , $ month , $ day , $ hours , $ minutes , 0 ) ; } 
protected function renderV1 ( ) { if ( 'google' == $ this -> requestSource ) { return [ 'type' => 'simple_response' , 'platform' => $ this -> requestSource , 'textToSpeech' => $ this -> text , 'displayText' => $ this -> text , ] ; } else { $ out = [ 'type' => self :: v1MessageObjectText , 'speech' => $ this -> text , ] ; if ( in_array ( $ this -> requestSource , $ this -> supportedRichMessagePlatforms ) ) { $ out [ 'platform' ] = $ this -> requestSource ; } return $ out ; } } 
protected function renderV2 ( ) { if ( 'google' == $ this -> requestSource ) { $ out = [ 'platform' => 'ACTIONS_ON_GOOGLE' , 'simpleResponses' => [ 'simpleResponses' => [ ] , ] , ] ; if ( $ this -> ssml ) { $ out [ 'simpleResponses' ] [ 'simpleResponses' ] [ 0 ] [ 'ssml' ] = $ this -> ssml ; } else { $ out [ 'simpleResponses' ] [ 'simpleResponses' ] [ 0 ] [ 'textToSpeech' ] = $ this -> text ; } $ out [ 'simpleResponses' ] [ 'simpleResponses' ] [ 0 ] [ 'displayText' ] = $ this -> text ; return $ out ; } else { $ out = [ 'text' => [ 'text' => [ $ this -> text ] , ] , ] ; if ( in_array ( $ this -> requestSource , $ this -> supportedRichMessagePlatforms ) ) { $ out [ 'platform' ] = $ this -> v2PlatformMap [ $ this -> requestSource ] ; } return $ out ; } } 
public function render ( ) { if ( self :: API_V1 == $ this -> agentVersion ) { return $ this -> renderV1 ( ) ; } elseif ( self :: API_V2 == $ this -> agentVersion ) { return $ this -> renderV2 ( ) ; } else { throw new RuntimeException ( 'Invalid agent version' ) ; } } 
public static function create ( $ reply = null ) { $ suggestion = new self ( ) ; if ( $ reply ) { $ suggestion -> reply ( $ reply ) ; } return $ suggestion ; } 
public function reply ( $ reply ) { if ( is_string ( $ reply ) ) { $ this -> replies = [ $ reply ] ; } elseif ( is_array ( $ reply ) ) { $ this -> replies = $ reply ; } return $ this ; } 
protected function renderV1 ( ) { if ( 'google' == $ this -> requestSource ) { $ out = [ 'suggestions' => [ ] , 'type' => 'suggestion_chips' , 'platform' => $ this -> requestSource , ] ; foreach ( $ this -> replies as $ i => $ reply ) { $ out [ 'suggestions' ] [ $ i ] [ 'title' ] = $ reply ; } return $ out ; } else { $ out = [ 'type' => self :: v1MessageObjectSuggestions , ] ; $ out [ 'replies' ] = $ this -> replies ; $ out [ 'platform' ] = $ this -> requestSource ; return $ out ; } } 
protected function renderV2 ( ) { if ( 'google' == $ this -> requestSource ) { $ out = [ 'suggestions' => [ 'suggestions' => [ ] , ] , ] ; foreach ( $ this -> replies as $ i => $ reply ) { $ out [ 'suggestions' ] [ 'suggestions' ] [ $ i ] [ 'title' ] = $ reply ; } $ out [ 'platform' ] = $ this -> v2PlatformMap [ $ this -> requestSource ] ; return $ out ; } else { $ out = [ 'quickReplies' => [ 'quickReplies' => $ this -> replies , ] , ] ; $ out [ 'platform' ] = $ this -> v2PlatformMap [ $ this -> requestSource ] ; return $ out ; } } 
public function renderSystemIntent ( ) { $ out = [ ] ; $ items = [ ] ; foreach ( $ this -> options as $ option ) { $ items [ ] = $ option -> render ( ) ; } $ out [ 'intent' ] = 'actions.intent.OPTION' ; $ out [ 'data' ] = [ '@type' => 'type.googleapis.com/google.actions.v2.OptionValueSpec' , 'carouselSelect' => [ 'imageDisplayOptions' => $ this -> imageDisplayOptions , 'items' => $ items , ] , ] ; return $ out ; } 
public function render ( ) { $ mediaObject = [ ] ; $ mediaObject [ 'contentUrl' ] = $ this -> url ; if ( $ this -> name ) { $ mediaObject [ 'name' ] = $ this -> name ; } if ( $ this -> description ) { $ mediaObject [ 'description' ] = $ this -> description ; } if ( $ this -> icon ) { $ mediaObject [ 'icon' ] = [ 'url' => $ this -> icon ] ; } if ( $ this -> image ) { $ mediaObject [ 'largeImage' ] = [ 'url' => $ this -> image ] ; } return $ mediaObject ; } 
public function renderRichResponseItem ( ) { $ out = [ ] ; $ mediaResponse = [ ] ; $ mediaResponse [ 'mediaType' ] = 'AUDIO' ; $ mediaObjects = [ ] ; foreach ( $ this -> mediaObjects as $ mediaObject ) { $ mediaObjects [ ] = $ mediaObject -> render ( ) ; } if ( count ( $ mediaObjects ) > 0 ) { $ mediaResponse [ 'mediaObjects' ] = $ mediaObjects ; } $ out [ 'mediaResponse' ] = $ mediaResponse ; return $ out ; } 
public function renderRichResponseItem ( ) { $ out = [ ] ; $ simpleResponse = [ ] ; if ( $ this -> ssml ) { $ simpleResponse [ 'ssml' ] = $ this -> ssml ; } if ( $ this -> displayText ) { $ simpleResponse [ 'displayText' ] = $ this -> displayText ; } if ( $ this -> textToSpeech ) { $ simpleResponse [ 'textToSpeech' ] = $ this -> textToSpeech ; } $ out [ 'simpleResponse' ] = $ simpleResponse ; return $ out ; } 
public function getContext ( $ name ) { if ( is_array ( $ this -> contexts ) ) { foreach ( $ this -> contexts as $ context ) { if ( $ context -> getName ( ) == $ name ) { return $ context ; } } } } 
public function reply ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = Text :: create ( ) -> text ( $ message ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message ; } } elseif ( $ message instanceof RichMessage ) { if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message -> getFallbackText ( ) ; } $ message -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof Conversation ) { $ this -> messages [ ] = Payload :: create ( $ message -> render ( ) ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; } return $ this ; } 
public function getOutgoingContext ( $ name ) { foreach ( $ this -> outgoingContexts as $ outgoingContext ) { if ( $ outgoingContext -> getName ( ) == $ name ) { return $ outgoingContext ; } } } 
public function setOutgoingContext ( $ context ) { if ( is_string ( $ context ) ) { $ outgoingContext = new Context ( $ context ) ; } elseif ( is_array ( $ context ) ) { if ( ! isset ( $ context [ 'name' ] ) ) { throw new RuntimeException ( 'Context must have a name' ) ; } $ name = $ context [ 'name' ] ; $ lifespan = 1 ; if ( isset ( $ context [ 'lifespan' ] ) ) { $ lifespan = is_numeric ( $ context [ 'lifespan' ] ) ? $ context [ 'lifespan' ] : null ; } $ parameters = [ ] ; if ( isset ( $ context [ 'parameters' ] ) ) { $ parameters = is_array ( $ context [ 'parameters' ] ) ? $ context [ 'parameters' ] : null ; } $ outgoingContext = new Context ( $ name , $ lifespan , $ parameters ) ; } elseif ( $ context instanceof Context ) { $ outgoingContext = $ context ; } else { throw new RuntimeException ( 'Context must be provided' ) ; } $ this -> outgoingContexts [ ] = $ outgoingContext ; return $ this ; } 
public function clearOutgoingContext ( $ contextName ) { foreach ( $ this -> outgoingContexts as $ i => $ context ) { if ( $ context -> getName ( ) == $ contextName ) { unset ( $ this -> outgoingContexts [ $ i ] ) ; } } return $ this ; } 
protected function renderV1 ( ) { $ out = [ 'messages' => [ ] ] ; $ messages = [ ] ; foreach ( $ this -> messages as $ message ) { if ( $ message instanceof Payload ) { $ out [ 'data' ] = $ message -> render ( ) ; } else { $ messages [ ] = $ message -> render ( ) ; } } $ out [ 'messages' ] = $ messages ; if ( $ this -> text ) { $ out [ 'speech' ] = $ this -> text ; } $ outgoingContexts = [ ] ; foreach ( $ this -> outgoingContexts as $ outgoingContext ) { $ outContexts = [ 'name' => $ outgoingContext -> getName ( ) ] ; if ( $ outgoingContext -> getLifespan ( ) ) { $ outContexts [ 'lifespan' ] = $ outgoingContext -> getLifespan ( ) ; } if ( $ outgoingContext -> getParameters ( ) ) { $ outContexts [ 'parameters' ] = $ outgoingContext -> getParameters ( ) ; } $ outgoingContexts [ ] = $ outContexts ; } $ out [ 'contextOut' ] = $ outgoingContexts ; return $ out ; } 
protected function renderV2 ( ) { $ out = [ ] ; $ messages = [ ] ; foreach ( $ this -> messages as $ message ) { if ( $ message instanceof Payload ) { $ out [ 'payload' ] = $ message -> render ( ) ; } else { $ messages [ ] = $ message -> render ( ) ; } } if ( count ( $ messages ) ) { $ out [ 'fulfillmentMessages' ] = $ messages ; } if ( $ this -> text ) { $ out [ 'fulfillmentText' ] = $ this -> text ; } $ outgoingContexts = [ ] ; foreach ( $ this -> outgoingContexts as $ outgoingContext ) { $ outContexts = [ 'name' => $ this -> session . '/contexts/' . $ outgoingContext -> getName ( ) , ] ; if ( $ outgoingContext -> getLifespan ( ) ) { $ outContexts [ 'lifespanCount' ] = $ outgoingContext -> getLifespan ( ) ; } if ( $ outgoingContext -> getParameters ( ) ) { $ outContexts [ 'parameters' ] = $ outgoingContext -> getParameters ( ) ; } $ outgoingContexts [ ] = $ outContexts ; } $ out [ 'outputContexts' ] = $ outgoingContexts ; return $ out ; } 
public function renderSystemIntent ( ) { $ out = [ ] ; $ out [ 'intent' ] = 'actions.intent.DATETIME' ; $ out [ 'data' ] = [ '@type' => 'type.googleapis.com/google.actions.v2.DateTimeValueSpec' , 'dialogSpec' => [ 'requestDatetimeText' => $ this -> requestDateTimeText , 'requestDateText' => $ this -> requestDateText , 'requestTimeText' => $ this -> requestTimeText , ] , ] ; return $ out ; } 
public function image ( $ imageUrl , $ accessibilityText = null ) { $ this -> imageUrl = $ imageUrl ; $ this -> accessibilityText = $ accessibilityText ; return $ this ; } 
public function renderRichResponseItem ( ) { $ out = [ ] ; $ basicCard = [ ] ; if ( $ this -> title ) { $ basicCard [ 'title' ] = $ this -> title ; } if ( $ this -> formattedText ) { $ basicCard [ 'formattedText' ] = $ this -> formattedText ; } if ( $ this -> imageUrl ) { $ basicCard [ 'image' ] = [ 'url' => $ this -> imageUrl , 'accessibilityText' => ( $ this -> accessibilityText ) ? $ this -> accessibilityText : 'accessibility text' , ] ; } if ( $ this -> buttons ) { foreach ( $ this -> buttons as $ button ) { $ basicCard [ 'buttons' ] [ ] = [ 'title' => $ button [ 'buttonText' ] , 'openUrlAction' => [ 'url' => $ button [ 'buttonUrl' ] , ] , ] ; } } $ out [ 'basicCard' ] = $ basicCard ; return $ out ; } 
public function render ( ) { $ out = [ ] ; $ optionInfo = [ ] ; if ( $ this -> title ) { $ out [ 'title' ] = $ this -> title ; } if ( $ this -> description ) { $ out [ 'description' ] = $ this -> description ; } if ( $ this -> footer ) { $ out [ 'footer' ] = $ this -> footer ; } if ( $ this -> imageUrl ) { $ out [ 'image' ] = [ 'url' => $ this -> imageUrl , 'accessibilityText' => ( $ this -> accessibilityText ) ? $ this -> accessibilityText : 'accessibility text' , ] ; } $ out [ 'openUrlAction' ] = [ 'url' => $ this -> openUrlAction , ] ; return $ out ; } 
public function renderRichResponseItem ( ) { $ out = [ ] ; $ carouselBrowse = [ ] ; if ( $ this -> imageDisplayOptions ) { $ carouselBrowse [ 'imageDisplayOptions' ] = $ this -> imageDisplayOptions ; } $ items = [ ] ; foreach ( $ this -> options as $ option ) { $ items [ ] = $ option -> render ( ) ; } $ carouselBrowse [ 'items' ] = $ items ; $ out [ 'carouselBrowse' ] = $ carouselBrowse ; return $ out ; } 
protected function renderV1 ( ) { if ( 'google' == $ this -> requestSource ) { $ out = [ 'type' => 'basic_card' , 'platform' => $ this -> requestSource , ] ; if ( $ this -> imageUrl ) { $ out [ 'image' ] = [ 'url' => $ this -> imageUrl , 'accessibilityText' => 'accessibility text' , ] ; } return $ out ; } else { $ out = [ 'type' => self :: v1MessageObjectImage , 'platform' => $ this -> requestSource , ] ; if ( $ this -> imageUrl ) { $ out [ 'imageUrl' ] = $ this -> imageUrl ; } return $ out ; } } 
protected function renderV2 ( ) { if ( 'google' == $ this -> requestSource ) { $ out = [ 'basicCard' => [ ] , 'platform' => $ this -> v2PlatformMap [ $ this -> requestSource ] , ] ; if ( $ this -> imageUrl ) { $ out [ 'basicCard' ] [ 'image' ] = [ 'imageUri' => $ this -> imageUrl , 'accessibilityText' => 'accessibility text' , ] ; } return $ out ; } else { $ out = [ 'image' => [ ] , 'platform' => $ this -> v2PlatformMap [ $ this -> requestSource ] , ] ; if ( $ this -> imageUrl ) { $ out [ 'image' ] [ 'imageUri' ] = $ this -> imageUrl ; } return $ out ; } } 
public function renderRichResponseItem ( ) { $ out = [ ] ; $ basicCard = [ ] ; if ( $ this -> imageUrl ) { $ basicCard [ 'image' ] = [ 'url' => $ this -> imageUrl , 'accessibilityText' => ( $ this -> accessibilityText ) ? $ this -> accessibilityText : 'accessibility text' , ] ; } $ out [ 'basicCard' ] = $ basicCard ; return $ out ; } 
public function render ( ) { $ out = [ ] ; $ optionInfo = [ ] ; $ optionInfo [ 'key' ] = $ this -> key ; $ optionInfo [ 'synonyms' ] = $ this -> synonyms ; $ out [ 'optionInfo' ] = $ optionInfo ; if ( $ this -> title ) { $ out [ 'title' ] = $ this -> title ; } if ( $ this -> description ) { $ out [ 'description' ] = $ this -> description ; } if ( $ this -> imageUrl ) { $ out [ 'image' ] = [ 'url' => $ this -> imageUrl , 'accessibilityText' => ( $ this -> accessibilityText ) ? $ this -> accessibilityText : 'accessibility text' , ] ; } return $ out ; } 
protected function getCountries ( ) { 
public function getListForSelect ( $ display = 'name' ) { foreach ( $ this -> getList ( $ display ) as $ key => $ value ) { $ countries [ $ key ] = $ value [ $ display ] ; } 
protected function compile ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; $ container = System :: getContainer ( ) ; $ ref = $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) ; $ return = $ container -> get ( 'router' ) -> generate ( 'contao_backend' , array ( 'do' => 'security' , 'ref' => $ ref ) ) ; $ user = BackendUser :: getInstance ( ) ; 
protected function enableTwoFactor ( BackendUser $ user , $ return ) { 
protected function disableTwoFactor ( BackendUser $ user , $ return ) { 
public function filter ( RouteCollection $ collection , Request $ request ) : RouteCollection { $ hasDomainMatch = false ; $ httpHost = $ request -> getHttpHost ( ) ; foreach ( $ collection -> all ( ) as $ route ) { $ host = $ route -> getHost ( ) ; if ( $ host && $ host === $ httpHost ) { $ hasDomainMatch = true ; break ; } } if ( $ hasDomainMatch ) { foreach ( $ collection -> all ( ) as $ name => $ route ) { $ host = $ route -> getHost ( ) ; if ( ! $ host || $ host !== $ httpHost ) { $ collection -> remove ( $ name ) ; } } } return $ collection ; } 
public function purge ( ) { $ this -> Files -> rrdir ( $ this -> strFolder , true ) ; 
public function delete ( ) { $ this -> Files -> rrdir ( $ this -> strFolder ) ; 
public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; 
public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; 
public function protect ( ) { if ( ! $ this -> isUnprotected ( ) ) { return ; } 
public function isUnprotected ( ) { $ path = $ this -> strFolder ; do { if ( file_exists ( $ this -> strRootDir . '/' . $ path . '/.public' ) ) { return true ; } $ path = \ dirname ( $ path ) ; } while ( $ path != '.' ) ; return false ; } 
public function synchronize ( ) { if ( ! $ this -> isUnsynchronized ( ) ) { return ; } 
public function unsynchronize ( ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { System :: getContainer ( ) -> get ( 'filesystem' ) -> touch ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ; } } 
public function getModel ( ) { if ( $ this -> objModel === null && Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { $ this -> objModel = FilesModel :: findByPath ( $ this -> strFolder ) ; } return $ this -> objModel ; } 
protected function getHash ( ) { @ trigger_error ( 'Using Folder::getHash() has been deprecated and will no longer work in Contao 5.0. Use Dbafs::getFolderHash() instead.' , E_USER_DEPRECATED ) ; $ arrFiles = array ( ) ; $ it = new \ RecursiveIteratorIterator ( new \ RecursiveDirectoryIterator ( $ this -> strRootDir . '/' . $ this -> strFolder , \ FilesystemIterator :: UNIX_PATHS | \ FilesystemIterator :: FOLLOW_SYMLINKS | \ FilesystemIterator :: SKIP_DOTS ) , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ it as $ i ) { if ( strncmp ( $ i -> getFilename ( ) , '.' , 1 ) !== 0 ) { $ arrFiles [ ] = substr ( $ i -> getPathname ( ) , \ strlen ( $ this -> strRootDir . '/' . $ this -> strFolder . '/' ) ) ; } } return md5 ( implode ( '-' , $ arrFiles ) ) ; } 
protected function getSize ( ) { $ intSize = 0 ; foreach ( scan ( $ this -> strRootDir . '/' . $ this -> strFolder , true ) as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ this -> strRootDir . '/' . $ this -> strFolder . '/' . $ strFile ) ) { $ objFolder = new self ( $ this -> strFolder . '/' . $ strFile ) ; $ intSize += $ objFolder -> size ; } else { $ objFile = new File ( $ this -> strFolder . '/' . $ strFile ) ; $ intSize += $ objFile -> size ; } } return $ intSize ; } 
protected function getPathinfo ( ) { $ matches = array ( ) ; $ return = array ( 'dirname' => '' , 'basename' => '' , 'extension' => '' , 'filename' => '' ) ; preg_match ( '%^^(.*?)[\\\\/]*([^/\\\\]*?)[\\\\/\.]*$%m' , $ this -> strFolder , $ matches ) ; if ( isset ( $ matches [ 1 ] ) ) { $ return [ 'dirname' ] = $ this -> strRootDir . '/' . $ matches [ 1 ] ; 
public function onPreviewUrlConvert ( PreviewUrlConvertEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request || null === ( $ news = $ this -> getNewsModel ( $ request ) ) ) { return ; } $ newsAdapter = $ this -> framework -> getAdapter ( News :: class ) ; $ event -> setUrl ( $ request -> getSchemeAndHttpHost ( ) . '/' . $ newsAdapter -> generateNewsUrl ( $ news ) ) ; } 
public function run ( ) { if ( ! Config :: get ( 'enableSearch' ) ) { return '' ; } $ this -> import ( BackendUser :: class , 'User' ) ; $ time = time ( ) ; $ arrUser = array ( '' => '-' ) ; $ objUser = null ; $ objTemplate = new BackendTemplate ( 'be_rebuild_index' ) ; $ objTemplate -> action = ampersand ( Environment :: get ( 'request' ) ) ; $ objTemplate -> indexHeadline = $ GLOBALS [ 'TL_LANG' ] [ 'tl_maintenance' ] [ 'searchIndex' ] ; $ objTemplate -> isActive = $ this -> isActive ( ) ; $ objTemplate -> message = Message :: generateUnwrapped ( __CLASS__ ) ; 
public function beginAuthentication ( AuthenticationContextInterface $ context ) : bool { $ user = $ context -> getUser ( ) ; if ( ! $ user instanceof User ) { return false ; } return ( bool ) $ user -> useTwoFactor ; } 
public function validateAuthenticationCode ( $ user , string $ authenticationCode ) : bool { if ( ! $ user instanceof User ) { return false ; } if ( ! $ this -> authenticator -> validateCode ( $ user , $ authenticationCode ) ) { return false ; } return true ; } 
public function getMenu ( ) : ItemInterface { if ( null !== $ this -> menu ) { return $ this -> menu ; } $ this -> menu = $ this -> menuFactory -> createItem ( 'picker' ) ; foreach ( $ this -> providers as $ provider ) { $ this -> menu -> addChild ( $ provider -> createMenuItem ( $ this -> config ) ) ; } return $ this -> menu ; } 
public function getCurrentProvider ( ) : ? PickerProviderInterface { foreach ( $ this -> providers as $ provider ) { if ( $ provider -> isCurrent ( $ this -> config ) ) { return $ provider ; } } return null ; } 
public function getCurrentUrl ( ) : ? string { foreach ( $ this -> providers as $ provider ) { if ( $ provider -> supportsValue ( $ this -> config ) ) { return $ provider -> getUrl ( $ this -> config ) ; } } $ menu = $ this -> getMenu ( ) ; if ( ! $ menu -> count ( ) ) { throw new \ RuntimeException ( 'No picker menu items found' ) ; } return $ menu -> getFirstChild ( ) -> getUri ( ) ; } 
public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } 
public function handleUserProfile ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: get ( 'do' ) != 'login' ) { return ; } 
public function copyUser ( $ row , $ href , $ label , $ title , $ icon , $ attributes , $ table ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'closed' ] ) { return '' ; } return ( $ this -> User -> isAdmin || ! $ row [ 'admin' ] ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } 
public function switchUser ( $ row , $ href , $ label , $ title , $ icon ) { $ authorizationChecker = Contao \ System :: getContainer ( ) -> get ( 'security.authorization_checker' ) ; if ( ! $ authorizationChecker -> isGranted ( 'ROLE_ALLOWED_TO_SWITCH' ) || $ authorizationChecker -> isGranted ( 'ROLE_PREVIOUS_ADMIN' ) ) { return '' ; } if ( $ this -> User -> id == $ row [ 'id' ] ) { return Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } $ router = Contao \ System :: getContainer ( ) -> get ( 'router' ) ; $ url = $ router -> generate ( 'contao_backend' , array ( '_switch_user' => $ row [ 'username' ] ) ) ; return '<a href="' . $ url . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '">' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } 
public function sessionField ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: post ( 'FORM_SUBMIT' ) == 'tl_user' ) { $ arrPurge = Contao \ Input :: post ( 'purge' ) ; if ( \ is_array ( $ arrPurge ) ) { $ this -> import ( 'Contao\Automator' , 'Automator' ) ; if ( \ in_array ( 'purge_session' , $ arrPurge ) ) { $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ objSessionBag -> clear ( ) ; Contao \ Message :: addConfirmation ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'sessionPurged' ] ) ; } if ( \ in_array ( 'purge_images' , $ arrPurge ) ) { $ this -> Automator -> purgeImageCache ( ) ; Contao \ Message :: addConfirmation ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'htmlPurged' ] ) ; } if ( \ in_array ( 'purge_pages' , $ arrPurge ) ) { $ this -> Automator -> purgePageCache ( ) ; Contao \ Message :: addConfirmation ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'tempPurged' ] ) ; } } } return ' <div class="widget"> <fieldset class="tl_checkbox_container"> <legend>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'session' ] [ 0 ] . '</legend> <input type="checkbox" id="check_all_purge" class="tl_checkbox" onclick="Backend.toggleCheckboxGroup(this, \'ctrl_purge\')"> <label for="check_all_purge" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label><br> <input type="checkbox" name="purge[]" id="opt_purge_0" class="tl_checkbox" value="purge_session" onfocus="Backend.getScrollOffset()"> <label for="opt_purge_0">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'sessionLabel' ] . '</label><br> <input type="checkbox" name="purge[]" id="opt_purge_1" class="tl_checkbox" value="purge_images" onfocus="Backend.getScrollOffset()"> <label for="opt_purge_1">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'htmlLabel' ] . '</label><br> <input type="checkbox" name="purge[]" id="opt_purge_2" class="tl_checkbox" value="purge_pages" onfocus="Backend.getScrollOffset()"> <label for="opt_purge_2">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'tempLabel' ] . '</label> </fieldset>' . $ dc -> help ( ) . ' </div>' ; } 
public function getModules ( ) { $ arrModules = array ( ) ; foreach ( $ GLOBALS [ 'BE_MOD' ] as $ k => $ v ) { if ( ! empty ( $ v ) ) { if ( $ k == 'accounts' ) { unset ( $ v [ 'login' ] ) ; } if ( $ k == 'system' ) { unset ( $ v [ 'undo' ] ) ; } $ arrModules [ $ k ] = array_keys ( $ v ) ; } } return $ arrModules ; } 
public function checkAdminStatus ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == '' && $ this -> User -> id == $ dc -> id ) { $ varValue = 1 ; } return $ varValue ; } 
public function checkAdminDisable ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == 1 && $ this -> User -> id == $ dc -> id ) { $ varValue = '' ; } return $ varValue ; } 
public function updateCurrentUser ( Contao \ DataContainer $ dc ) { if ( $ this -> User -> id == $ dc -> id ) { $ this -> User -> findBy ( 'id' , $ this -> User -> id ) ; } } 
public function loginAction ( ) : Response { $ this -> get ( 'contao.framework' ) -> initialize ( ) ; if ( ! isset ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) || ! class_exists ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) ) { throw new UnauthorizedHttpException ( '' , 'Not authorized' ) ; } $ pageHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ( ) ; try { return $ pageHandler -> getResponse ( ) ; } catch ( ResponseException $ e ) { return $ e -> getResponse ( ) ; } catch ( InsufficientAuthenticationException $ e ) { throw new UnauthorizedHttpException ( '' , $ e -> getMessage ( ) ) ; } } 
public function load ( array $ configs , ContainerBuilder $ container ) : void { $ loader = new YamlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; static $ files = [ 'commands.yml' , 'listener.yml' , 'services.yml' , ] ; foreach ( $ files as $ file ) { $ loader -> load ( $ file ) ; } } 
public function prepend ( ContainerBuilder $ container ) : void { $ configDir = $ container -> getParameter ( 'kernel.project_dir' ) . '/app/config' ; if ( file_exists ( $ configDir . '/parameters.yml' ) || ! file_exists ( $ configDir . '/parameters.yml.dist' ) ) { return ; } $ loader = new YamlFileLoader ( $ container , new FileLocator ( $ configDir ) ) ; $ loader -> load ( 'parameters.yml.dist' ) ; } 
public function updateStyleSheet ( $ intId ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intId ) ; if ( $ objStyleSheet -> numRows < 1 ) { return ; } 
public function updateStyleSheets ( ) { $ objStyleSheets = $ this -> Database -> execute ( "SELECT * FROM tl_style_sheet" ) ; $ arrStyleSheets = $ objStyleSheets -> fetchEach ( 'name' ) ; 
protected function writeStyleSheet ( $ row ) { if ( $ row [ 'id' ] == '' || $ row [ 'name' ] == '' ) { return ; } $ row [ 'name' ] = basename ( $ row [ 'name' ] ) ; 
public function compileDefinition ( $ row , $ blnWriteToFile = false , $ vars = array ( ) , $ parent = array ( ) , $ export = false ) { if ( $ blnWriteToFile ) { $ strGlue = '../../' ; $ lb = '' ; $ return = '' ; } elseif ( $ export ) { $ strGlue = '' ; $ lb = "\n " ; $ return = '' ; } else { $ strGlue = '' ; $ lb = "\n " ; $ return = "\n" . '<pre' . ( $ row [ 'invisible' ] ? ' class="disabled"' : '' ) . '>' ; } 
protected function compileColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { if ( ! \ is_array ( $ color ) ) { return '#' . $ this -> shortenHexColor ( $ color ) ; } elseif ( ! isset ( $ color [ 1 ] ) || empty ( $ color [ 1 ] ) ) { return '#' . $ this -> shortenHexColor ( $ color [ 0 ] ) ; } else { return 'rgba(' . implode ( ',' , $ this -> convertHexColor ( $ color [ 0 ] , $ blnWriteToFile , $ vars ) ) . ',' . ( $ color [ 1 ] / 100 ) . ')' ; } } 
protected function shortenHexColor ( $ color ) { if ( $ color [ 0 ] == $ color [ 1 ] && $ color [ 2 ] == $ color [ 3 ] && $ color [ 4 ] == $ color [ 5 ] ) { return $ color [ 0 ] . $ color [ 2 ] . $ color [ 4 ] ; } return $ color ; } 
protected function convertHexColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { 
public function importStyleSheet ( ) { if ( Input :: get ( 'key' ) != 'import' ) { return '' ; } $ objUploader = new FileUpload ( ) ; <div id="tl_buttons"> <a href="' . ampersand ( str_replace ( '&key=import' , '' , Environment :: get ( 'request' ) ) ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div> <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_style_sheet_import" class="tl_form tl_edit_form" method="post" enctype="multipart/form-data"> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="tl_style_sheet_import"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"> <input type="hidden" name="MAX_FILE_SIZE" value="' . Config :: get ( 'maxFileSize' ) . '"> <div class="tl_tbox"> <div class="widget"> <h3>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_style_sheet' ] [ 'source' ] [ 0 ] . '</h3>' . $ objUploader -> generateMarkup ( ) . ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_style_sheet' ] [ 'source' ] [ 1 ] ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_style_sheet' ] [ 'source' ] [ 1 ] . '</p>' : '' ) . ' </div> </div> </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> <button type="submit" name="save" id="save" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_style_sheet' ] [ 'import' ] [ 0 ] . '</button> </div> </div> </form>' ; } 
public function exportStyleSheet ( DataContainer $ dc ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objStyleSheet -> numRows < 1 ) { throw new \ Exception ( "Invalid style sheet ID {$dc->id}" ) ; } $ vars = array ( ) ; 
public function checkStyleSheetName ( $ strName ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_style_sheet WHERE name=?" ) -> limit ( 1 ) -> execute ( $ strName ) ; if ( $ objStyleSheet -> count < 1 ) { return $ strName ; } $ chunks = explode ( '-' , $ strName ) ; $ i = ( \ count ( $ chunks ) > 1 ) ? array_pop ( $ chunks ) : 0 ; $ strName = implode ( '-' , $ chunks ) . '-' . ( ( int ) $ i + 1 ) ; return $ this -> checkStyleSheetName ( $ strName ) ; } 
protected function createDefinition ( $ arrDefinition ) { $ arrSet = array ( 'pid' => $ arrDefinition [ 'pid' ] , 'sorting' => $ arrDefinition [ 'sorting' ] , 'tstamp' => time ( ) , 'comment' => $ arrDefinition [ 'comment' ] , 'category' => $ arrDefinition [ 'category' ] , 'selector' => $ arrDefinition [ 'selector' ] ) ; $ arrAttributes = StringUtil :: trimsplit ( ';' , $ arrDefinition [ 'attributes' ] ) ; foreach ( $ arrAttributes as $ strDefinition ) { 
protected function generateBase64Image ( $ strImage , $ arrParent ) { if ( $ arrParent [ 'embedImages' ] > 0 && file_exists ( $ this -> strRootDir . '/' . $ strImage ) ) { $ objImage = new File ( $ strImage ) ; $ strMime = $ objImage -> extension ; 
public function finalMatch ( RouteCollection $ collection , Request $ request ) { $ this -> routes = $ collection ; $ context = new RequestContext ( ) ; $ context -> fromRequest ( $ request ) ; $ context -> setHost ( $ request -> getHttpHost ( ) ) ; $ this -> setContext ( $ context ) ; return $ this -> matchRequest ( $ request ) ; } 
public function run ( ) { $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ objTemplate = new BackendTemplate ( 'be_picker' ) ; $ objTemplate -> main = '' ; 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'newsletterreader' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } 
protected function compile ( ) { global $ objPage ; $ this -> Template -> content = '' ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; $ objNewsletter = NewsletterModel :: findSentByParentAndIdOrAlias ( Input :: get ( 'items' ) , $ this -> nl_channels ) ; if ( null === $ objNewsletter ) { throw new PageNotFoundException ( 'Page not found: ' . Environment :: get ( 'uri' ) ) ; } 
public function run ( ) : void { $ this -> connection -> query ( ' ALTER TABLE tl_member CHANGE username username varchar(64) COLLATE utf8_bin NULL ' ) ; $ this -> connection -> query ( " UPDATE tl_member SET username = NULL WHERE username = '' " ) ; $ this -> connection -> query ( ' ALTER TABLE tl_member DROP INDEX username, ADD UNIQUE KEY username (username) ' ) ; } 
public static function findByIds ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> execute ( "SELECT *, (SELECT tstamp FROM tl_theme WHERE tl_theme.id=tl_style_sheet.pid) AS tstamp3, (SELECT MAX(tstamp) FROM tl_style WHERE tl_style.pid=tl_style_sheet.id) AS tstamp2, (SELECT COUNT(*) FROM tl_style WHERE tl_style.selector='@font-face' AND tl_style.invisible='' AND tl_style.pid=tl_style_sheet.id) AS hasFontFace FROM tl_style_sheet WHERE id IN (" . implode ( ',' , $ arrIds ) . ") ORDER BY " . $ objDatabase -> findInSet ( 'id' , $ arrIds ) ) ; return static :: createCollectionFromDbResult ( $ objResult , 'tl_style_sheet' ) ; } 
public function onPreviewUrlConvert ( PreviewUrlConvertEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request || null === ( $ eventModel = $ this -> getEventModel ( $ request ) ) ) { return ; } $ eventsAdapter = $ this -> framework -> getAdapter ( Events :: class ) ; $ event -> setUrl ( $ request -> getSchemeAndHttpHost ( ) . '/' . $ eventsAdapter -> generateEventUrl ( $ eventModel ) ) ; } 
public function removeFrontendAuthentication ( ) : bool { if ( ! $ this -> session -> isStarted ( ) || ! $ this -> session -> has ( FrontendUser :: SECURITY_SESSION_KEY ) ) { return false ; } $ this -> session -> remove ( FrontendUser :: SECURITY_SESSION_KEY ) ; return true ; } 
private function loadFrontendUser ( string $ username , BackendUser $ backendUser ) : ? FrontendUser { try { $ frontendUser = $ this -> userProvider -> loadUserByUsername ( $ username ) ; 
public function getFile ( $ strName ) { foreach ( $ this -> arrFiles as $ k => $ v ) { if ( $ strName == $ v [ 'file_name' ] ) { $ this -> intIndex = $ k ; return true ; } } return false ; } 
public function unzip ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ strName = $ this -> arrFiles [ $ this -> intIndex ] [ 'file_name' ] ; 
protected function readCentralDirectory ( ) { $ strMbCharset = null ; 
protected function decToUnix ( $ intTime , $ intDate ) { return mktime ( ( $ intTime & 0xf800 ) >> 11 , ( $ intTime & 0x07e0 ) >> 5 , ( $ intTime & 0x001f ) << 1 , ( $ intDate & 0x01e0 ) >> 5 , ( $ intDate & 0x001f ) , ( ( $ intDate & 0xfe00 ) >> 9 ) + 1980 ) ; } 
public function generateFeed ( $ intId ) { $ objFeed = NewsFeedModel :: findByPk ( $ intId ) ; if ( $ objFeed === null ) { return ; } $ objFeed -> feedName = $ objFeed -> alias ? : 'news' . $ objFeed -> id ; 
public function generateFeeds ( ) { $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> purgeXmlFiles ( ) ; $ objFeed = NewsFeedModel :: findAll ( ) ; if ( $ objFeed !== null ) { while ( $ objFeed -> next ( ) ) { $ objFeed -> feedName = $ objFeed -> alias ? : 'news' . $ objFeed -> id ; $ this -> generateFiles ( $ objFeed -> row ( ) ) ; $ this -> log ( 'Generated news feed "' . $ objFeed -> feedName . '.xml"' , __METHOD__ , TL_CRON ) ; } } } 
public function generateFeedsByArchive ( $ intId ) { $ objFeed = NewsFeedModel :: findByArchive ( $ intId ) ; if ( $ objFeed !== null ) { while ( $ objFeed -> next ( ) ) { $ objFeed -> feedName = $ objFeed -> alias ? : 'news' . $ objFeed -> id ; 
protected function generateFiles ( $ arrFeed ) { $ arrArchives = StringUtil :: deserialize ( $ arrFeed [ 'archives' ] ) ; if ( empty ( $ arrArchives ) || ! \ is_array ( $ arrArchives ) ) { return ; } $ strType = ( $ arrFeed [ 'format' ] == 'atom' ) ? 'generateAtom' : 'generateRss' ; $ strLink = $ arrFeed [ 'feedBase' ] ? : Environment :: get ( 'base' ) ; $ strFile = $ arrFeed [ 'feedName' ] ; $ objFeed = new Feed ( $ strFile ) ; $ objFeed -> link = $ strLink ; $ objFeed -> title = $ arrFeed [ 'title' ] ; $ objFeed -> description = $ arrFeed [ 'description' ] ; $ objFeed -> language = $ arrFeed [ 'language' ] ; $ objFeed -> published = $ arrFeed [ 'tstamp' ] ; 
public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; 
public static function generateNewsUrl ( $ objItem , $ blnAddArchive = false , $ blnAbsolute = false ) { $ strCacheKey = 'id_' . $ objItem -> id . ( $ blnAbsolute ? '_absolute' : '' ) ; 
protected function getLink ( $ objItem , $ strUrl , $ strBase = '' ) { switch ( $ objItem -> source ) { 
public function purgeOldFeeds ( ) { $ arrFeeds = array ( ) ; $ objFeeds = NewsFeedModel :: findAll ( ) ; if ( $ objFeeds !== null ) { while ( $ objFeeds -> next ( ) ) { $ arrFeeds [ ] = $ objFeeds -> alias ? : 'news' . $ objFeeds -> id ; } } return $ arrFeeds ; } 
protected function compile ( ) { $ this -> text = StringUtil :: toHtml5 ( $ this -> text ) ; 
protected function prepare ( $ objRootPage = null ) { 
protected function compile ( ) { if ( $ this -> linkTitle == '' ) { $ this -> linkTitle = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backToTop' ] ; } $ this -> Template -> label = $ this -> linkTitle ; $ this -> Template -> title = StringUtil :: specialchars ( $ this -> linkTitle ) ; $ this -> Template -> request = ampersand ( Environment :: get ( 'request' ) , true ) ; } 
public function collect ( Request $ request , Response $ response , \ Exception $ exception = null ) : void { try { $ version = PackageUtil :: getVersion ( 'contao/core-bundle' ) ; } catch ( \ OutOfBoundsException $ e ) { $ version = PackageUtil :: getVersion ( 'contao/contao' ) ; } $ this -> data = [ 'contao_version' => $ version ] ; $ this -> addSummaryData ( ) ; if ( isset ( $ GLOBALS [ 'TL_DEBUG' ] ) ) { $ this -> data = array_merge ( $ this -> data , $ GLOBALS [ 'TL_DEBUG' ] ) ; } } 
protected function compile ( ) { global $ objPage ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ objFaq = FaqModel :: findPublishedByParentAndIdOrAlias ( Input :: get ( 'items' ) , $ this -> faq_categories ) ; if ( null === $ objFaq ) { throw new PageNotFoundException ( 'Page not found: ' . Environment :: get ( 'uri' ) ) ; } 
public function addResponseCookie ( Response $ response , array $ payload = [ ] ) : void { if ( $ this -> hasCookie ( $ response ) ) { return ; } $ payload [ 'iat' ] = time ( ) ; $ payload [ 'exp' ] = strtotime ( '+30 minutes' ) ; if ( method_exists ( Cookie :: class , 'create' ) ) { $ cookie = Cookie :: create ( self :: COOKIE_NAME , JWT :: encode ( $ payload , $ this -> secret ) ) ; } else { 
public function clearResponseCookie ( Response $ response ) : Response { $ response -> headers -> clearCookie ( self :: COOKIE_NAME ) ; return $ response ; } 
private function hasCookie ( Response $ response ) : bool { $ cookies = $ response -> headers -> getCookies ( ) ; foreach ( $ cookies as $ cookie ) { if ( self :: COOKIE_NAME === $ cookie -> getName ( ) ) { return true ; } } return false ; } 
public static function indexPage ( $ arrData ) { $ objDatabase = Database :: getInstance ( ) ; $ arrSet [ 'tstamp' ] = time ( ) ; $ arrSet [ 'url' ] = $ arrData [ 'url' ] ; $ arrSet [ 'title' ] = $ arrData [ 'title' ] ; $ arrSet [ 'protected' ] = $ arrData [ 'protected' ] ; $ arrSet [ 'filesize' ] = $ arrData [ 'filesize' ] ; $ arrSet [ 'groups' ] = $ arrData [ 'groups' ] ; $ arrSet [ 'pid' ] = $ arrData [ 'pid' ] ; $ arrSet [ 'language' ] = $ arrData [ 'language' ] ; 
public static function searchFor ( $ strKeywords , $ blnOrSearch = false , $ arrPid = array ( ) , $ intRows = 0 , $ intOffset = 0 , $ blnFuzzy = false ) { 
public static function removeEntry ( $ strUrl ) { $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT id FROM tl_search WHERE url=?" ) -> execute ( $ strUrl ) ; while ( $ objResult -> next ( ) ) { $ objDatabase -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ objDatabase -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } } 
public function renderContaoBackendTemplate ( array $ blocks = [ ] ) : string { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request || ! $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { return '' ; } $ controller = $ this -> framework -> createInstance ( BackendCustom :: class ) ; $ template = $ controller -> getTemplateObject ( ) ; foreach ( $ blocks as $ key => $ content ) { $ template -> { $ key } = $ content ; } $ response = $ controller -> run ( ) ; return $ response -> getContent ( ) ; } 
public function run ( ) { if ( $ this -> strFile == '' ) { die ( 'No file given' ) ; } 
protected function compile ( ) { global $ objPage ; $ blnClearInput = false ; $ intYear = Input :: get ( 'year' ) ; $ intMonth = Input :: get ( 'month' ) ; $ intDay = Input :: get ( 'day' ) ; 
protected function getRouteParameters ( PickerConfig $ config = null ) : array { $ params = [ 'do' => 'faq' ] ; if ( null === $ config || ! $ config -> getValue ( ) || false === strpos ( $ config -> getValue ( ) , '{{faq_url::' ) ) { return $ params ; } $ value = str_replace ( [ '{{faq_url::' , '}}' ] , '' , $ config -> getValue ( ) ) ; if ( null !== ( $ faqId = $ this -> getFaqCategoryId ( $ value ) ) ) { $ params [ 'table' ] = 'tl_faq' ; $ params [ 'id' ] = $ faqId ; } return $ params ; } 
public function onReplaceInsertTags ( string $ tag , bool $ useCache , $ cacheValue , array $ flags ) { static $ supportedTags = [ 'faq' , 'faq_open' , 'faq_url' , 'faq_title' , ] ; $ elements = explode ( '::' , $ tag ) ; $ key = strtolower ( $ elements [ 0 ] ) ; if ( ! \ in_array ( $ key , $ supportedTags , true ) ) { return false ; } $ this -> framework -> initialize ( ) ; $ adapter = $ this -> framework -> getAdapter ( FaqModel :: class ) ; $ faq = $ adapter -> findByIdOrAlias ( $ elements [ 1 ] ) ; if ( null === $ faq || false === ( $ url = $ this -> generateUrl ( $ faq , \ in_array ( 'absolute' , $ flags , true ) ) ) ) { return '' ; } return $ this -> generateReplacement ( $ faq , $ key , $ url ) ; } 
protected function configureIO ( InputInterface $ input , OutputInterface $ output ) : void { $ output -> setDecorated ( false ) ; $ input -> setInteractive ( false ) ; } 
protected function getDefaultCommands ( ) : array { $ commands = parent :: getDefaultCommands ( ) ; $ commands [ ] = new VersionCommand ( $ this ) ; foreach ( $ this -> getPluginLoader ( ) -> getInstancesOf ( ApiPluginInterface :: class ) as $ plugin ) { foreach ( $ plugin -> getApiCommands ( ) as $ class ) { if ( ! is_a ( $ class , Command :: class , true ) ) { throw new \ RuntimeException ( sprintf ( '"%s" is not a console command.' , $ class ) ) ; } $ commands [ ] = new $ class ( $ this ) ; } } return $ commands ; } 
public function checkPermission ( ) { $ bundles = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; 
public function loadEndTime ( $ value , Contao \ DataContainer $ dc ) { $ return = strtotime ( '1970-01-01 ' . date ( 'H:i:s' , $ value ) ) ; 
public function setEmptyEndTime ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue === null ) { $ varValue = $ dc -> activeRecord -> startTime ; } return $ varValue ; } 
public function listEvents ( $ arrRow ) { $ span = Contao \ Calendar :: calculateSpan ( $ arrRow [ 'startTime' ] , $ arrRow [ 'endTime' ] ) ; if ( $ span > 0 ) { $ date = Contao \ Date :: parse ( Contao \ Config :: get ( ( $ arrRow [ 'addTime' ] ? 'datimFormat' : 'dateFormat' ) ) , $ arrRow [ 'startTime' ] ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Contao \ Date :: parse ( Contao \ Config :: get ( ( $ arrRow [ 'addTime' ] ? 'datimFormat' : 'dateFormat' ) ) , $ arrRow [ 'endTime' ] ) ; } elseif ( $ arrRow [ 'startTime' ] == $ arrRow [ 'endTime' ] ) { $ date = Contao \ Date :: parse ( Contao \ Config :: get ( 'dateFormat' ) , $ arrRow [ 'startTime' ] ) . ( $ arrRow [ 'addTime' ] ? ' ' . Contao \ Date :: parse ( Contao \ Config :: get ( 'timeFormat' ) , $ arrRow [ 'startTime' ] ) : '' ) ; } else { $ date = Contao \ Date :: parse ( Contao \ Config :: get ( 'dateFormat' ) , $ arrRow [ 'startTime' ] ) . ( $ arrRow [ 'addTime' ] ? ' ' . Contao \ Date :: parse ( Contao \ Config :: get ( 'timeFormat' ) , $ arrRow [ 'startTime' ] ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Contao \ Date :: parse ( Contao \ Config :: get ( 'timeFormat' ) , $ arrRow [ 'endTime' ] ) : '' ) ; } return '<div class="tl_content_left">' . $ arrRow [ 'title' ] . ' <span style="color:#999;padding-left:3px">[' . $ date . ']</span></div>' ; } 
public function getArticleAlias ( Contao \ DataContainer $ dc ) { $ arrPids = array ( ) ; $ arrAlias = array ( ) ; if ( ! $ this -> User -> isAdmin ) { foreach ( $ this -> User -> pagemounts as $ id ) { $ arrPids [ ] = array ( $ id ) ; $ arrPids [ ] = $ this -> Database -> getChildRecords ( $ id , 'tl_page' ) ; } if ( ! empty ( $ arrPids ) ) { $ arrPids = array_merge ( ... $ arrPids ) ; } else { return $ arrAlias ; } $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid WHERE a.pid IN(" . implode ( ',' , array_map ( '\intval' , array_unique ( $ arrPids ) ) ) . ") ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } else { $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } if ( $ objAlias -> numRows ) { Contao \ System :: loadLanguageFile ( 'tl_article' ) ; while ( $ objAlias -> next ( ) ) { $ arrAlias [ $ objAlias -> parent ] [ $ objAlias -> id ] = $ objAlias -> title . ' (' . ( $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ objAlias -> inColumn ] ? : $ objAlias -> inColumn ) . ', ID ' . $ objAlias -> id . ')' ; } } return $ arrAlias ; } 
public function adjustTime ( Contao \ DataContainer $ dc ) { 
protected function compile ( ) { global $ objPage ; $ items = array ( ) ; $ groups = array ( ) ; 
public function executePreActions ( ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; switch ( $ this -> strAction ) { 
public function executePostActions ( DataContainer $ dc ) { header ( 'Content-Type: text/html; charset=' . Config :: get ( 'characterSet' ) ) ; 
protected function executePostActionsHook ( DataContainer $ dc ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> strAction , $ dc ) ; } } } 
public static function getInstance ( ) { if ( static :: $ objInstance !== null ) { return static :: $ objInstance ; } $ objToken = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; 
public function hasAccess ( $ field , $ array ) { if ( $ this -> isAdmin ) { return true ; } if ( ! \ is_array ( $ field ) ) { $ field = array ( $ field ) ; } if ( \ is_array ( $ this -> $ array ) && array_intersect ( $ field , $ this -> $ array ) ) { return true ; } elseif ( $ array == 'filemounts' ) { 
public function isAllowed ( $ int , $ row ) { if ( $ this -> isAdmin ) { return true ; } 
public function canEditFieldsOf ( $ table ) { if ( $ this -> isAdmin ) { return true ; } return \ count ( preg_grep ( '/^' . preg_quote ( $ table , '/' ) . '::/' , $ this -> alexf ) ) > 0 ; } 
public function save ( ) { $ filemounts = $ this -> filemounts ; if ( ! empty ( $ this -> arrFilemountIds ) ) { $ this -> arrData [ 'filemounts' ] = $ this -> arrFilemountIds ; } parent :: save ( ) ; $ this -> filemounts = $ filemounts ; } 
protected function setUserFromDb ( ) { $ this -> intId = $ this -> id ; 
public function navigation ( $ blnShowAll = false ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ router = System :: getContainer ( ) -> get ( 'router' ) ; $ arrModules = array ( ) ; $ session = $ objSessionBag -> all ( ) ; 
public function onKernelRequest ( GetResponseEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser || ! $ user -> language ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> setLocale ( $ user -> language ) ; $ this -> translator -> setLocale ( $ user -> language ) ; 
public function getNewsArchives ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> news ) ) { return array ( ) ; } $ arrArchives = array ( ) ; $ objArchives = $ this -> Database -> execute ( "SELECT id, title FROM tl_news_archive ORDER BY title" ) ; while ( $ objArchives -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objArchives -> id , 'news' ) ) { $ arrArchives [ $ objArchives -> id ] = $ objArchives -> title ; } } return $ arrArchives ; } 
public function load ( $ file , $ type = null ) : string { return $ this -> convertXlfToPhp ( ( string ) $ file , ( $ type ? : 'en' ) ) ; } 
private function getChunksFromUnit ( \ DOMElement $ unit ) : array { $ chunks = explode ( '.' , $ unit -> getAttribute ( 'id' ) ) ; 
private function getStringRepresentation ( array $ chunks , $ value ) : string { switch ( \ count ( $ chunks ) ) { case 2 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteValue ( $ value ) ) ; case 3 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteValue ( $ value ) ) ; case 4 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteKey ( $ chunks [ 3 ] ) , $ this -> quoteValue ( $ value ) ) ; } throw new \ OutOfBoundsException ( 'Cannot load less than 2 or more than 4 levels in XLIFF language files.' ) ; } 
private function addGlobal ( array $ chunks , $ value ) : void { if ( false === $ this -> addToGlobals ) { return ; } $ data = & $ GLOBALS [ 'TL_LANG' ] ; foreach ( $ chunks as $ key ) { if ( null === $ data || ! \ is_array ( $ data ) ) { $ data = [ ] ; } $ data = & $ data [ $ key ] ; } $ data = $ value ; } 
public function supportsValue ( PickerConfig $ config ) : bool { if ( 'page' === $ config -> getContext ( ) ) { return is_numeric ( $ config -> getValue ( ) ) ; } return false !== strpos ( $ config -> getValue ( ) , '{{link_url::' ) ; } 
public function getDcaAttributes ( PickerConfig $ config ) : array { $ value = $ config -> getValue ( ) ; $ attributes = [ 'fieldType' => 'radio' ] ; if ( 'page' === $ config -> getContext ( ) ) { if ( $ fieldType = $ config -> getExtra ( 'fieldType' ) ) { $ attributes [ 'fieldType' ] = $ fieldType ; } if ( $ source = $ config -> getExtra ( 'source' ) ) { $ attributes [ 'preserveRecord' ] = $ source ; } if ( \ is_array ( $ rootNodes = $ config -> getExtra ( 'rootNodes' ) ) ) { $ attributes [ 'rootNodes' ] = $ rootNodes ; } if ( $ value ) { $ intval = static function ( $ val ) { return ( int ) $ val ; } ; $ attributes [ 'value' ] = array_map ( $ intval , explode ( ',' , $ value ) ) ; } return $ attributes ; } if ( $ value && false !== strpos ( $ value , '{{link_url::' ) ) { $ attributes [ 'value' ] = str_replace ( [ '{{link_url::' , '}}' ] , '' , $ value ) ; } return $ attributes ; } 
public function process ( ContainerBuilder $ container ) : void { if ( ! $ container -> hasDefinition ( 'contao.listener.data_container_callback' ) ) { return ; } $ callbacks = $ this -> getCallbacks ( $ container ) ; if ( empty ( $ callbacks ) ) { return ; } $ definition = $ container -> getDefinition ( 'contao.listener.data_container_callback' ) ; $ definition -> addMethodCall ( 'setCallbacks' , [ $ callbacks ] ) ; } 
protected function checkValue ( $ varInput ) { if ( $ varInput == '' ) { return ; } if ( strpos ( $ varInput , ',' ) === false ) { $ arrUuids = array ( $ varInput ) ; } else { $ arrUuids = array_filter ( explode ( ',' , $ varInput ) ) ; } $ objFiles = FilesModel :: findMultipleByUuids ( $ arrUuids ) ; if ( $ objFiles === null ) { return ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ objFiles as $ objFile ) { 
protected function getPreviewImage ( File $ objFile , $ strInfo , $ strClass = 'gimage' ) { if ( ( $ objFile -> isSvgImage || ( $ objFile -> height <= Config :: get ( 'gdMaxImgHeight' ) && $ objFile -> width <= Config :: get ( 'gdMaxImgWidth' ) ) ) && $ objFile -> viewWidth && $ objFile -> viewHeight ) { 
public static function generateRandomSecret ( Event $ event ) : void { $ extra = $ event -> getComposer ( ) -> getPackage ( ) -> getExtra ( ) ; if ( ! isset ( $ extra [ 'incenteev-parameters' ] ) || ! self :: canGenerateSecret ( $ extra [ 'incenteev-parameters' ] ) ) { return ; } if ( ! \ function_exists ( 'random_bytes' ) ) { self :: loadRandomCompat ( $ event ) ; } putenv ( static :: RANDOM_SECRET_NAME . '=' . bin2hex ( random_bytes ( 32 ) ) ) ; } 
private static function canGenerateSecret ( array $ config ) : bool { if ( isset ( $ config [ 'file' ] ) ) { return ! is_file ( $ config [ 'file' ] ) ; } foreach ( $ config as $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'file' ] ) && is_file ( $ v [ 'file' ] ) ) { return false ; } } return ! empty ( $ config ) ; } 
public function getRootDir ( ) : string { if ( null === $ this -> rootDir ) { $ this -> rootDir = $ this -> getProjectDir ( ) . '/app' ; } return $ this -> rootDir ; } 
public function registerContainerConfiguration ( LoaderInterface $ loader ) : void { $ configDir = $ this -> getProjectDir ( ) . '/app/config' ; if ( file_exists ( $ configDir . '/parameters.yml' ) ) { $ loader -> load ( $ configDir . '/parameters.yml' ) ; } $ config = $ this -> getManagerConfig ( ) -> all ( ) ; $ plugins = $ this -> getPluginLoader ( ) -> getInstancesOf ( PluginLoader :: CONFIG_PLUGINS ) ; foreach ( $ plugins as $ plugin ) { $ plugin -> registerContainerConfiguration ( $ loader , $ config ) ; } 
public function getHttpCache ( ) { if ( null !== $ this -> httpCache ) { return $ this -> httpCache ; } return $ this -> httpCache = new ContaoCache ( $ this , $ this -> getProjectDir ( ) . '/var/cache/prod/http_cache' ) ; } 
protected function getContainerBuilder ( ) : PluginContainerBuilder { $ container = new PluginContainerBuilder ( $ this -> getPluginLoader ( ) , [ ] ) ; $ container -> getParameterBag ( ) -> add ( $ this -> getKernelParameters ( ) ) ; if ( class_exists ( Configuration :: class ) && class_exists ( RuntimeInstantiator :: class ) ) { $ container -> setProxyInstantiator ( new RuntimeInstantiator ( ) ) ; } return $ container ; } 
protected function initializeContainer ( ) : void { parent :: initializeContainer ( ) ; if ( null === ( $ container = $ this -> getContainer ( ) ) ) { return ; } 
public function generate ( ) { if ( $ this -> objParent instanceof ContentModel && TL_MODE == 'FE' && ! BE_USER_LOGGED_IN && ( $ this -> objParent -> invisible || ( $ this -> objParent -> start != '' && $ this -> objParent -> start > time ( ) ) || ( $ this -> objParent -> stop != '' && $ this -> objParent -> stop < time ( ) ) ) ) { return '' ; } $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ this -> Template -> setData ( $ this -> arrData ) ; $ this -> compile ( ) ; $ this -> Template -> style = ! empty ( $ this -> arrStyle ) ? implode ( ' ' , $ this -> arrStyle ) : '' ; $ this -> Template -> cssID = ! empty ( $ this -> cssID [ 0 ] ) ? ' id="' . $ this -> cssID [ 0 ] . '"' : '' ; $ this -> Template -> class = trim ( $ this -> typePrefix . $ this -> strKey . ' ' . $ this -> cssID [ 1 ] ) ; $ this -> Template -> inColumn = $ this -> strColumn ; if ( $ this -> Template -> headline == '' ) { $ this -> Template -> headline = $ this -> headline ; } if ( $ this -> Template -> hl == '' ) { $ this -> Template -> hl = $ this -> hl ; } if ( ! empty ( $ this -> objParent -> classes ) && \ is_array ( $ this -> objParent -> classes ) ) { $ this -> Template -> class .= ' ' . implode ( ' ' , $ this -> objParent -> classes ) ; } return $ this -> Template -> parse ( ) ; } 
public function scheduleUpdate ( Contao \ DataContainer $ dc ) { 
public function manageFeeds ( $ href , $ label , $ title , $ class , $ attributes ) { return ( $ this -> User -> isAdmin || ! empty ( $ this -> User -> newsfeeds ) || ! empty ( $ this -> User -> newsfeedp ) ) ? '<a href="' . $ this -> addToUrl ( $ href ) . '" class="' . $ class . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . $ label . '</a> ' : '' ; } 
public function generate ( ) { if ( $ this -> rte ) { $ this -> strClass = trim ( $ this -> strClass . ' noresize' ) ; } return sprintf ( '<textarea name="%s" id="ctrl_%s" class="tl_textarea%s" rows="%s" cols="%s"%s onfocus="Backend.getScrollOffset()">%s</textarea>%s' , $ this -> strName , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , $ this -> intRows , $ this -> intCols , $ this -> getAttributes ( ) , StringUtil :: specialchars ( $ this -> varValue ) , $ this -> wizard ) ; } 
protected function checkAccountStatus ( ) { @ trigger_error ( 'Using User::checkAccountStatus() has been deprecated and will no longer work in Contao 5.0. Use Symfony security instead.' , E_USER_DEPRECATED ) ; try { $ userChecker = System :: getContainer ( ) -> get ( 'contao.security.user_checker' ) ; $ userChecker -> checkPreAuth ( $ this ) ; $ userChecker -> checkPostAuth ( $ this ) ; } catch ( AuthenticationException $ exception ) { return false ; } return true ; } 
public function findBy ( $ strColumn , $ varValue ) { $ objResult = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE " . Database :: quoteIdentifier ( $ strColumn ) . "=?" ) -> limit ( 1 ) -> execute ( $ varValue ) ; if ( $ objResult -> numRows > 0 ) { $ this -> arrData = $ objResult -> row ( ) ; return true ; } return false ; } 
public function save ( ) { $ arrFields = $ this -> Database -> getFieldNames ( $ this -> strTable ) ; $ arrSet = array_intersect_key ( $ this -> arrData , array_flip ( $ arrFields ) ) ; $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " %s WHERE id=?" ) -> set ( $ arrSet ) -> execute ( $ this -> id ) ; } 
protected function regenerateSessionId ( ) { @ trigger_error ( 'Using User::regenerateSessionId() has been deprecated and will no longer work in Contao 5.0. Use Symfony authentication instead.' , E_USER_DEPRECATED ) ; $ container = System :: getContainer ( ) ; $ strategy = $ container -> getParameter ( 'security.authentication.session_strategy.strategy' ) ; 
public function isMemberOf ( $ id ) { 
public static function loadUserByUsername ( $ username ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return null ; } $ user = new static ( ) ; $ isLogin = $ request -> request -> has ( 'password' ) && $ request -> isMethod ( Request :: METHOD_POST ) ; 
public function serialize ( ) { $ data = array ( 'id' => $ this -> id , 'username' => $ this -> username , 'password' => $ this -> password , 'admin' => $ this -> admin , 'disable' => $ this -> disable , 'start' => $ this -> start , 'stop' => $ this -> stop ) ; return serialize ( $ data ) ; } 
public function unserialize ( $ serialized ) { $ data = unserialize ( $ serialized , array ( 'allowed_classes' => false ) ) ; if ( array_keys ( $ data ) != array ( 'id' , 'username' , 'password' , 'admin' , 'disable' , 'start' , 'stop' ) ) { return ; } list ( $ this -> id , $ this -> username , $ this -> password , $ this -> admin , $ this -> disable , $ this -> start , $ this -> stop ) = array_values ( $ data ) ; } 
public function isEqualTo ( UserInterface $ user ) { if ( ! $ user instanceof self ) { return false ; } if ( $ this -> getRoles ( ) !== $ user -> getRoles ( ) ) { return false ; } if ( $ this -> password !== $ user -> password ) { return false ; } if ( ( bool ) $ this -> admin !== ( bool ) $ user -> admin ) { return false ; } if ( ( bool ) $ this -> disable !== ( bool ) $ user -> disable ) { return false ; } $ time = Date :: floorToMinute ( ) ; if ( $ this -> start !== '' && $ this -> start > $ time ) { return false ; } if ( $ this -> stop !== '' && $ this -> stop <= ( $ time + 60 ) ) { return false ; } return true ; } 
public static function triggerImportUserHook ( $ username , $ password , $ strTable ) { $ self = new static ( ) ; if ( empty ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] ) || ! \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] ) ) { return false ; } @ trigger_error ( 'Using the "importUser" hook has been deprecated and will no longer work in Contao 5.0. Use the contao.import_user event instead.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] as $ callback ) { $ self -> import ( $ callback [ 0 ] , 'objImport' , true ) ; $ blnLoaded = $ self -> objImport -> { $ callback [ 1 ] } ( $ username , $ password , $ strTable ) ; 
public function add ( string $ identifier , FragmentConfig $ config ) : FragmentRegistryInterface { 
public function generate ( ) { $ objArticle = ArticleModel :: findPublishedById ( $ this -> article ) ; if ( $ objArticle === null ) { return '' ; } 
protected function compile ( ) { $ link = '/articles/' ; $ objArticle = $ this -> objArticle ; if ( $ objArticle -> inColumn != 'main' ) { $ link .= $ objArticle -> inColumn . ':' ; } $ link .= $ objArticle -> alias ? : $ objArticle -> id ; $ this -> Template -> href = $ this -> objParent -> getFrontendUrl ( $ link ) ; 
public function getController ( Request $ request ) { if ( $ request -> attributes -> has ( '_controller' ) ) { $ fragmentConfig = $ this -> registry -> get ( $ request -> attributes -> get ( '_controller' ) ) ; if ( null !== $ fragmentConfig ) { $ request -> attributes -> set ( '_controller' , $ fragmentConfig -> getController ( ) ) ; } } return $ this -> resolver -> getController ( $ request ) ; } 
public function getArguments ( Request $ request , $ controller ) : array { if ( ! method_exists ( $ this -> resolver , 'getArguments' ) ) { return [ ] ; } return $ this -> resolver -> getArguments ( $ request , $ controller ) ; } 
protected function compile ( ) { 
protected function getBookPages ( $ intParentId , $ groups , $ time ) { $ objPages = PageModel :: findPublishedSubpagesWithoutGuestsByPid ( $ intParentId , $ this -> showHidden ) ; if ( $ objPages === null ) { return ; } foreach ( $ objPages as $ objPage ) { $ _groups = StringUtil :: deserialize ( $ objPage -> groups ) ; 
public function validateCode ( User $ user , string $ code ) : bool { $ totp = TOTP :: create ( $ this -> getUpperUnpaddedSecretForUser ( $ user ) ) ; return $ totp -> verify ( $ code ) ; } 
public function getProvisionUri ( User $ user , Request $ request ) : string { $ issuer = rawurlencode ( $ request -> getSchemeAndHttpHost ( ) ) ; return sprintf ( 'otpauth://totp/%s:%s?secret=%s&issuer=%s' , $ issuer , rawurlencode ( $ user -> getUsername ( ) ) . '@' . $ issuer , $ this -> getUpperUnpaddedSecretForUser ( $ user ) , $ issuer ) ; } 
public function getQrCode ( User $ user , Request $ request ) : string { $ renderer = new ImageRenderer ( new RendererStyle ( 180 , 0 ) , new SvgImageBackEnd ( ) ) ; $ writer = new Writer ( $ renderer ) ; return $ writer -> writeString ( $ this -> getProvisionUri ( $ user , $ request ) ) ; } 
public function loadFromPlugins ( ) : RouteCollection { $ collection = array_reduce ( $ this -> pluginLoader -> getInstancesOf ( PluginLoader :: ROUTING_PLUGINS , true ) , function ( RouteCollection $ collection , RoutingPluginInterface $ plugin ) : RouteCollection { $ routes = $ plugin -> getRouteCollection ( $ this -> loader -> getResolver ( ) , $ this -> kernel ) ; if ( $ routes instanceof RouteCollection ) { $ collection -> addCollection ( $ routes ) ; } return $ collection ; } , new RouteCollection ( ) ) ; 
public function generate ( ) { 
protected function compile ( ) { $ objFile = new File ( $ this -> singleSRC ) ; if ( TL_MODE == 'FE' ) { global $ objPage ; $ arrMeta = Frontend :: getMetaData ( $ this -> objFile -> meta , $ objPage -> language ) ; if ( empty ( $ arrMeta ) && $ objPage -> rootFallbackLanguage !== null ) { $ arrMeta = Frontend :: getMetaData ( $ this -> objFile -> meta , $ objPage -> rootFallbackLanguage ) ; } } else { $ arrMeta = Frontend :: getMetaData ( $ this -> objFile -> meta , $ GLOBALS [ 'TL_LANGUAGE' ] ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : int { try { $ output -> writeln ( PackageUtil :: getVersion ( 'contao/core-bundle' ) ) ; } catch ( \ OutOfBoundsException $ e ) { $ output -> writeln ( PackageUtil :: getVersion ( 'contao/contao' ) ) ; } return 0 ; } 
public function run ( ) { $ container = System :: getContainer ( ) ; $ exception = $ container -> get ( 'security.authentication_utils' ) -> getLastAuthenticationError ( ) ; if ( $ exception instanceof LockedException ) { Message :: addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'accountLocked' ] , $ exception -> getLockedMinutes ( ) ) ) ; } elseif ( $ exception instanceof InvalidTwoFactorCodeException ) { Message :: addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidTwoFactor' ] ) ; } elseif ( $ exception instanceof AuthenticationException ) { Message :: addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidLogin' ] ) ; } $ queryString = '' ; $ arrParams = array ( ) ; if ( $ referer = Input :: get ( 'referer' , true ) ) { $ queryString = '?' . base64_decode ( $ referer ) ; $ arrParams [ 'referer' ] = $ referer ; } $ router = $ container -> get ( 'router' ) ; $ objTemplate = new BackendTemplate ( 'be_login' ) ; $ objTemplate -> action = ampersand ( Environment :: get ( 'request' ) ) ; $ objTemplate -> headline = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'loginBT' ] ; $ token = $ container -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( $ token instanceof TwoFactorToken ) { $ objTemplate = new BackendTemplate ( 'be_login_two_factor' ) ; $ objTemplate -> headline = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorAuthentication' ] ; $ objTemplate -> action = $ router -> generate ( 'contao_backend_two_factor' ) ; $ objTemplate -> authCode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerification' ] ; $ objTemplate -> cancel = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cancelBT' ] ; } $ objTemplate -> theme = Backend :: getTheme ( ) ; $ objTemplate -> messages = Message :: generate ( ) ; $ objTemplate -> base = Environment :: get ( 'base' ) ; $ objTemplate -> language = $ GLOBALS [ 'TL_LANGUAGE' ] ; $ objTemplate -> languages = System :: getLanguages ( true ) ; 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'login' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( ! $ _POST && $ this -> redirectBack && ( $ strReferer = $ this -> getReferer ( ) ) != Environment :: get ( 'request' ) ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ strReferer ; } return parent :: generate ( ) ; } 
protected function compile ( ) { $ container = System :: getContainer ( ) ; $ router = $ container -> get ( 'router' ) ; if ( $ container -> get ( 'contao.security.token_checker' ) -> hasFrontendUser ( ) ) { global $ objPage ; $ this -> import ( FrontendUser :: class , 'User' ) ; $ strRedirect = Environment :: get ( 'base' ) . Environment :: get ( 'request' ) ; 
public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } 
public function checkImportantPart ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/' . $ dc -> id ) || ! \ in_array ( strtolower ( substr ( $ dc -> id , strrpos ( $ dc -> id , '.' ) + 1 ) ) , Contao \ StringUtil :: trimsplit ( ',' , strtolower ( Contao \ Config :: get ( 'validImageTypes' ) ) ) ) ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = str_replace ( ',importantPartX,importantPartY,importantPartWidth,importantPartHeight' , '' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] ) ; } } 
public function addFileLocation ( Contao \ DataContainer $ dc ) { 
public function checkFilename ( $ varValue , Contao \ DataContainer $ dc ) { $ varValue = str_replace ( '"' , '' , $ varValue ) ; if ( strpos ( $ varValue , '/' ) !== false || preg_match ( '/\.$/' , $ varValue ) ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidName' ] ) ; } 
public function syncFiles ( $ href , $ label , $ title , $ class , $ attributes ) { return $ this -> User -> hasAccess ( 'f6' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" class="' . $ class . '"' . $ attributes . '>' . $ label . '</a> ' : '' ; } 
public function uploadFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( ! $ GLOBALS [ 'TL_DCA' ] [ 'tl_files' ] [ 'config' ] [ 'closed' ] && ! $ GLOBALS [ 'TL_DCA' ] [ 'tl_files' ] [ 'config' ] [ 'notCreatable' ] && Contao \ Input :: get ( 'act' ) != 'select' && isset ( $ row [ 'type' ] ) && $ row [ 'type' ] == 'folder' ) { return '<a href="' . $ this -> addToUrl ( $ href . '&amp;pid=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } return ' ' ; } 
public function deleteFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ path = $ rootDir . '/' . urldecode ( $ row [ 'id' ] ) ; if ( ! is_dir ( $ path ) ) { return ( $ this -> User -> hasAccess ( 'f3' , 'fop' ) || $ this -> User -> hasAccess ( 'f4' , 'fop' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } $ finder = Symfony \ Component \ Finder \ Finder :: create ( ) -> in ( $ path ) ; if ( $ finder -> count ( ) > 0 ) { return $ this -> User -> hasAccess ( 'f4' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } return $ this -> User -> hasAccess ( 'f3' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } 
public function editSource ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( ! $ this -> User -> hasAccess ( 'f5' , 'fop' ) ) { return '' ; } $ strDecoded = rawurldecode ( $ row [ 'id' ] ) ; $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/' . $ strDecoded ) ) { return '' ; } $ objFile = new Contao \ File ( $ strDecoded ) ; if ( ! \ in_array ( $ objFile -> extension , Contao \ StringUtil :: trimsplit ( ',' , strtolower ( Contao \ Config :: get ( 'editableFiles' ) ) ) ) ) { return Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } return '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } 
public function showFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( Contao \ Input :: get ( 'popup' ) ) { return '' ; } else { return '<a href="contao/popup.php?src=' . base64_encode ( $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . ' onclick="Backend.openModalIframe({\'title\':\'' . str_replace ( "'" , "\\'" , Contao \ StringUtil :: specialchars ( $ row [ 'fileNameEncoded' ] ) ) . '\',\'url\':this.href});return false">' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } } 
public function protectFolder ( Contao \ DataContainer $ dc ) { $ strPath = $ dc -> id ; $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; <div class="' . $ class . '"> <div id="ctrl_' . $ dc -> field . '" class="tl_checkbox_single_container"> <input type="hidden" name="' . $ dc -> inputName . '" value=""><input type="checkbox" name="' . $ dc -> inputName . '" id="opt_' . $ dc -> inputName . '_0" class="tl_checkbox" value="1"' . ( ( $ blnUnprotected || basename ( $ strPath ) == '__new__' ) ? ' checked="checked"' : '' ) . ' onfocus="Backend.getScrollOffset()"' . ( $ blnDisable ? ' disabled' : '' ) . '> <label for="opt_' . $ dc -> inputName . '_0">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'protected' ] [ 0 ] . '</label> </div>' . ( Contao \ Config :: get ( 'showHelp' ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'protected' ] [ 1 ] . '</p>' : '' ) . ' </div>' ; } 
public function excludeFolder ( Contao \ DataContainer $ dc ) { $ strPath = $ dc -> id ; $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; <div class="' . $ class . '"> <div id="ctrl_' . $ dc -> field . '" class="tl_checkbox_single_container"> <input type="hidden" name="' . $ dc -> inputName . '" value=""><input type="checkbox" name="' . $ dc -> inputName . '" id="opt_' . $ dc -> inputName . '_0" class="tl_checkbox" value="1"' . ( $ blnUnsynchronized ? ' checked="checked"' : '' ) . ' onfocus="Backend.getScrollOffset()"' . ( $ blnDisable ? ' disabled' : '' ) . '> <label for="opt_' . $ dc -> inputName . '_0">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'syncExclude' ] [ 0 ] . '</label> </div>' . ( Contao \ Config :: get ( 'showHelp' ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'syncExclude' ] [ 1 ] . '</p>' : '' ) . ' </div>' ; } 
public function addEnclosure ( $ strFile , $ strUrl = null , $ strMedia = 'enclosure' ) { if ( $ strFile == '' || ! file_exists ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFile ) ) { return ; } if ( $ strUrl === null ) { $ strUrl = Environment :: get ( 'base' ) ; } $ objFile = new File ( $ strFile ) ; $ this -> arrData [ 'enclosure' ] [ ] = array ( 'media' => $ strMedia , 'url' => $ strUrl . System :: urlEncode ( $ strFile ) , 'length' => $ objFile -> size , 'type' => $ objFile -> mime ) ; } 
protected function compile ( ) { global $ objPage ; $ lang = null ; $ host = null ; 
public function getCalendars ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> calendars ) ) { return array ( ) ; } $ arrCalendars = array ( ) ; $ objCalendars = $ this -> Database -> execute ( "SELECT id, title FROM tl_calendar ORDER BY title" ) ; while ( $ objCalendars -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objCalendars -> id , 'calendars' ) ) { $ arrCalendars [ $ objCalendars -> id ] = $ objCalendars -> title ; } } return $ arrCalendars ; } 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'listing' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } 
protected function compile ( ) { System :: loadLanguageFile ( $ this -> list_table ) ; $ this -> loadDataContainer ( $ this -> list_table ) ; 
protected function listSingleRecord ( $ id ) { 
protected function formatValue ( $ k , $ value , $ blnListSingle = false ) { $ value = StringUtil :: deserialize ( $ value ) ; 
public function onConsoleTerminate ( ConsoleTerminateEvent $ event ) : void { if ( ! $ event -> getCommand ( ) instanceof InstallCommand ) { return ; } ( new Filesystem ( ) ) -> copy ( __DIR__ . '/../Resources/skeleton/system/initialize.php' , $ this -> projectDir . '/system/initialize.php' , true ) ; } 
public function generate ( ) { if ( $ this -> playerSRC == '' ) { return '' ; } $ source = StringUtil :: deserialize ( $ this -> playerSRC ) ; if ( empty ( $ source ) || ! \ is_array ( $ source ) ) { return '' ; } $ objFiles = FilesModel :: findMultipleByUuidsAndExtensions ( $ source , array ( 'mp4' , 'm4v' , 'mov' , 'wmv' , 'webm' , 'ogv' , 'm4a' , 'mp3' , 'wma' , 'mpeg' , 'wav' , 'ogg' ) ) ; if ( $ objFiles === null ) { return '' ; } 
protected function compile ( ) { global $ objPage ; $ this -> Template -> poster = false ; 
protected function import ( $ strClass , $ strKey = null , $ blnForce = false ) { $ strKey = $ strKey ? : $ strClass ; if ( \ is_object ( $ strKey ) ) { $ strKey = \ get_class ( $ strClass ) ; } if ( $ blnForce || ! isset ( $ this -> arrObjects [ $ strKey ] ) ) { $ container = static :: getContainer ( ) ; if ( \ is_object ( $ strClass ) ) { $ this -> arrObjects [ $ strKey ] = $ strClass ; } elseif ( $ container -> has ( $ strClass ) && ( strpos ( $ strClass , '\\' ) !== false || ! class_exists ( $ strClass ) ) ) { $ this -> arrObjects [ $ strKey ] = $ container -> get ( $ strClass ) ; } elseif ( $ container instanceof Container && isset ( $ container -> getRemovedIds ( ) [ $ strClass ] ) ) { throw new ServiceNotFoundException ( $ strClass , null , null , array ( ) , sprintf ( 'The "%s" service or alias has been removed or inlined when the container was compiled. You should either make it public, or stop using the container directly and use dependency injection instead.' , $ strClass ) ) ; } elseif ( \ in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) { $ this -> arrObjects [ $ strKey ] = \ call_user_func ( array ( $ strClass , 'getInstance' ) ) ; } else { $ this -> arrObjects [ $ strKey ] = new $ strClass ( ) ; } } } 
public static function log ( $ strText , $ strFunction , $ strCategory ) { @ trigger_error ( 'Using System::log() has been deprecated and will no longer work in Contao 5.0. Use the logger service instead.' , E_USER_DEPRECATED ) ; $ level = 'ERROR' === $ strCategory ? LogLevel :: ERROR : LogLevel :: INFO ; $ logger = static :: getContainer ( ) -> get ( 'monolog.logger.contao' ) ; $ logger -> log ( $ level , $ strText , array ( 'contao' => new ContaoContext ( $ strFunction , $ strCategory ) ) ) ; } 
public static function getReferer ( $ blnEncodeAmpersands = false , $ strTable = null ) { $ objSession = static :: getContainer ( ) -> get ( 'session' ) ; $ ref = Input :: get ( 'ref' ) ; $ key = Input :: get ( 'popup' ) ? 'popupReferer' : 'referer' ; $ session = $ objSession -> get ( $ key ) ; 
public static function loadLanguageFile ( $ strName , $ strLanguage = null , $ blnNoCache = false ) { if ( $ strLanguage === null ) { $ strLanguage = str_replace ( '-' , '_' , $ GLOBALS [ 'TL_LANGUAGE' ] ?? 'en' ) ; } 
public static function isInstalledLanguage ( $ strLanguage ) { if ( ! isset ( static :: $ arrLanguages [ $ strLanguage ] ) ) { $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/vendor/contao/core-bundle/src/Resources/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } elseif ( is_dir ( static :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) . '/contao/languages/' . $ strLanguage ) ) { static :: $ arrLanguages [ $ strLanguage ] = true ; } else { $ files = static :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'languages' ) -> depth ( 0 ) -> directories ( ) -> name ( $ strLanguage ) ; static :: $ arrLanguages [ $ strLanguage ] = \ count ( $ files ) > 0 ; } } return static :: $ arrLanguages [ $ strLanguage ] ; } 
public static function getCountries ( ) { $ return = array ( ) ; $ countries = array ( ) ; $ arrAux = array ( ) ; static :: loadLanguageFile ( 'countries' ) ; include __DIR__ . '/../../config/countries.php' ; foreach ( $ countries as $ strKey => $ strName ) { $ arrAux [ $ strKey ] = isset ( $ GLOBALS [ 'TL_LANG' ] [ 'CNT' ] [ $ strKey ] ) ? Utf8 :: toAscii ( $ GLOBALS [ 'TL_LANG' ] [ 'CNT' ] [ $ strKey ] ) : $ strName ; } asort ( $ arrAux ) ; foreach ( array_keys ( $ arrAux ) as $ strKey ) { $ return [ $ strKey ] = $ GLOBALS [ 'TL_LANG' ] [ 'CNT' ] [ $ strKey ] ?? $ countries [ $ strKey ] ; } 
public static function getLanguages ( $ blnInstalledOnly = false ) { $ return = array ( ) ; $ languages = array ( ) ; $ arrAux = array ( ) ; $ langsNative = array ( ) ; static :: loadLanguageFile ( 'languages' ) ; include __DIR__ . '/../../config/languages.php' ; foreach ( $ languages as $ strKey => $ strName ) { $ arrAux [ $ strKey ] = isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) ? Utf8 :: toAscii ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) : $ strName ; } asort ( $ arrAux ) ; $ arrBackendLanguages = self :: getContainer ( ) -> getParameter ( 'contao.locales' ) ; foreach ( array_keys ( $ arrAux ) as $ strKey ) { if ( $ blnInstalledOnly && ! \ in_array ( $ strKey , $ arrBackendLanguages ) ) { continue ; } $ return [ $ strKey ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ?? $ languages [ $ strKey ] ; if ( isset ( $ langsNative [ $ strKey ] ) && $ langsNative [ $ strKey ] != $ return [ $ strKey ] ) { $ return [ $ strKey ] .= ' - ' . $ langsNative [ $ strKey ] ; } } 
public static function getTimeZones ( ) { $ arrReturn = array ( ) ; $ timezones = array ( ) ; require __DIR__ . '/../../config/timezones.php' ; foreach ( $ timezones as $ strGroup => $ arrTimezones ) { foreach ( $ arrTimezones as $ strTimezone ) { $ arrReturn [ $ strGroup ] [ ] = $ strTimezone ; } } return $ arrReturn ; } 
public static function setCookie ( $ strName , $ varValue , $ intExpires , $ strPath = null , $ strDomain = null , $ blnSecure = false , $ blnHttpOnly = false ) { if ( $ strPath == '' ) { $ strPath = Environment :: get ( 'path' ) ? : '/' ; 
public static function getReadableSize ( $ intSize , $ intDecimals = 1 ) { for ( $ i = 0 ; $ intSize >= 1024 ; $ i ++ ) { $ intSize /= 1024 ; } return static :: getFormattedNumber ( $ intSize , $ intDecimals ) . ' ' . $ GLOBALS [ 'TL_LANG' ] [ 'UNITS' ] [ $ i ] ; } 
public static function getFormattedNumber ( $ varNumber , $ intDecimals = 2 ) { return number_format ( round ( $ varNumber , $ intDecimals ) , $ intDecimals , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'decimalSeparator' ] , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'thousandsSeparator' ] ) ; } 
public static function getSessionHash ( $ strCookie ) { @ trigger_error ( 'Using System::getSessionHash() has been deprecated and will no longer work in Contao 5.0. Use Symfony authentication instead.' , E_USER_DEPRECATED ) ; $ session = static :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { $ session -> start ( ) ; } return sha1 ( $ session -> getId ( ) . $ strCookie ) ; } 
public static function anonymizeIp ( $ strIp ) { 
protected static function readPhpFileWithoutTags ( $ strName ) { @ trigger_error ( 'Using System::readPhpFileWithoutTags() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\PhpFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; 
public static function convertXlfToPhp ( $ strName , $ strLanguage , $ blnLoad = false ) { @ trigger_error ( 'Using System::convertXlfToPhp() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\XliffFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; 
public static function parseDate ( $ strFormat , $ intTstamp = null ) { @ trigger_error ( 'Using System::parseDate() has been deprecated and will no longer work in Contao 5.0. Use Date::parse() instead.' , E_USER_DEPRECATED ) ; return Date :: parse ( $ strFormat , $ intTstamp ) ; } 
public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || ! $ this -> canRunController ( $ event -> getRequest ( ) ) ) { return ; } $ controller = $ this -> framework -> createInstance ( FrontendCron :: class ) ; $ controller -> run ( ) ; } 
private function canRunDbQuery ( ) : bool { try { return $ this -> connection -> isConnected ( ) && $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ 'tl_cron' ] ) ; } catch ( DriverException $ e ) { return false ; } } 
public function colorize ( $ row , $ label ) { switch ( $ row [ 'action' ] ) { case 'CONFIGURATION' : case 'REPOSITORY' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_blue">$2</span>' , $ label ) ; break ; case 'CRON' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_green">$2</span>' , $ label ) ; break ; case 'ERROR' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_red">$2</span>' , $ label ) ; break ; default : if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ label = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ row , $ label ) ; } } break ; } return '<div class="ellipsis">' . $ label . '</div>' ; } 
public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } $ response = $ event -> getResponse ( ) ; if ( 200 !== $ response -> getStatusCode ( ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ this -> storeBackendReferer ( $ request ) ; } else { $ this -> storeFrontendReferer ( $ request ) ; } } 
private function getRelativeRequestUri ( Request $ request ) : string { return ( string ) substr ( $ request -> getRequestUri ( ) , \ strlen ( $ request -> getBasePath ( ) ) + 1 ) ; } 
public function listNewsArticles ( $ arrRow ) { return '<div class="tl_content_left">' . $ arrRow [ 'headline' ] . ' <span style="color:#999;padding-left:3px">[' . Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ arrRow [ 'date' ] ) . ']</span></div>' ; } 
public function getSourceOptions ( Contao \ DataContainer $ dc ) { if ( $ this -> User -> isAdmin ) { return array ( 'default' , 'internal' , 'article' , 'external' ) ; } $ arrOptions = array ( 'default' ) ; 
public function adjustTime ( Contao \ DataContainer $ dc ) { 
public function scheduleUpdate ( Contao \ DataContainer $ dc ) { 
public function toggleFeatured ( $ intId , $ blnVisible , Contao \ DataContainer $ dc = null ) { 
public function __isset ( $ strKey ) { switch ( $ strKey ) { case 'id' : return isset ( $ this -> strId ) ; break ; case 'name' : return isset ( $ this -> strName ) ; break ; case 'label' : return isset ( $ this -> strLabel ) ; break ; case 'value' : return isset ( $ this -> varValue ) ; break ; case 'class' : return isset ( $ this -> strClass ) ; break ; case 'template' : return isset ( $ this -> strTemplate ) ; break ; case 'wizard' : return isset ( $ this -> strWizard ) ; break ; case 'required' : return isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; case 'forAttribute' : return isset ( $ this -> blnForAttribute ) ; break ; case 'dataContainer' : return isset ( $ this -> objDca ) ; break ; case 'activeRecord' : return isset ( $ this -> objDca -> activeRecord ) ; break ; default : return isset ( $ this -> arrAttributes [ $ strKey ] ) || isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; } } 
public function getErrorsAsString ( $ strSeparator = null ) { if ( $ strSeparator === null ) { $ strSeparator = '<br' . $ this -> strTagEnding . "\n" ; } return $ this -> hasErrors ( ) ? implode ( $ strSeparator , $ this -> arrErrors ) : '' ; } 
public function parse ( $ arrAttributes = null ) { if ( $ this -> strTemplate == '' ) { return '' ; } $ this -> addAttributes ( $ arrAttributes ) ; $ this -> mandatoryField = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mandatory' ] ; if ( $ this -> customTpl != '' && TL_MODE == 'FE' ) { $ this -> strTemplate = $ this -> customTpl ; } $ strBuffer = $ this -> inherit ( ) ; 
public function generateLabel ( ) { if ( $ this -> strLabel == '' ) { return '' ; } return sprintf ( '<label%s%s>%s%s%s</label>' , ( $ this -> blnForAttribute ? ' for="ctrl_' . $ this -> strId . '"' : '' ) , ( ( $ this -> strClass != '' ) ? ' class="' . $ this -> strClass . '"' : '' ) , ( $ this -> mandatory ? '<span class="invisible">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mandatory' ] . ' </span>' : '' ) , $ this -> strLabel , ( $ this -> mandatory ? '<span class="mandatory">*</span>' : '' ) ) ; } 
public function generateWithError ( $ blnSwitchOrder = false ) { $ strWidget = $ this -> generate ( ) ; $ strError = $ this -> getErrorAsHTML ( ) ; return $ blnSwitchOrder ? $ strWidget . $ strError : $ strError . $ strWidget ; } 
public function getAttributes ( $ arrStrip = array ( ) ) { $ strAttributes = '' ; foreach ( array_keys ( $ this -> arrAttributes ) as $ strKey ) { if ( ! \ in_array ( $ strKey , $ arrStrip ) ) { $ strAttributes .= $ this -> getAttribute ( $ strKey ) ; } } return $ strAttributes ; } 
public function getAttribute ( $ strKey ) { if ( ! isset ( $ this -> arrAttributes [ $ strKey ] ) ) { return '' ; } $ varValue = $ this -> arrAttributes [ $ strKey ] ; 
public function validate ( ) { $ varValue = $ this -> validator ( $ this -> getPost ( $ this -> strName ) ) ; if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } $ this -> varValue = $ varValue ; } 
protected function getPost ( $ strKey ) { if ( \ is_callable ( $ this -> inputCallback ) ) { return \ call_user_func ( $ this -> inputCallback ) ; } if ( $ this -> useRawRequestData === true ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; return $ request -> request -> get ( $ strKey ) ; } $ strMethod = $ this -> allowHtml ? 'postHtml' : 'post' ; if ( $ this -> preserveTags ) { $ strMethod = 'postRaw' ; } 
protected function validator ( $ varInput ) { if ( \ is_array ( $ varInput ) ) { foreach ( $ varInput as $ k => $ v ) { $ varInput [ $ k ] = $ this -> validator ( $ v ) ; } return $ varInput ; } if ( ! $ this -> doNotTrim ) { $ varInput = trim ( $ varInput ) ; } if ( $ varInput == '' ) { if ( ! $ this -> mandatory ) { return '' ; } else { if ( $ this -> strLabel == '' ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'mdtryNoLabel' ] ) ; } else { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'mandatory' ] , $ this -> strLabel ) ) ; } } } if ( $ this -> minlength && $ varInput != '' && Utf8 :: strlen ( $ varInput ) < $ this -> minlength ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'minlength' ] , $ this -> strLabel , $ this -> minlength ) ) ; } if ( $ this -> maxlength && $ varInput != '' && Utf8 :: strlen ( $ varInput ) > $ this -> maxlength ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'maxlength' ] , $ this -> strLabel , $ this -> maxlength ) ) ; } if ( $ this -> minval && is_numeric ( $ varInput ) && $ varInput < $ this -> minval ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'minval' ] , $ this -> strLabel , $ this -> minval ) ) ; } if ( $ this -> maxval && is_numeric ( $ varInput ) && $ varInput > $ this -> maxval ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'maxval' ] , $ this -> strLabel , $ this -> maxval ) ) ; } if ( $ this -> rgxp != '' ) { switch ( $ this -> rgxp ) { 
public function addAttributes ( $ arrAttributes ) { if ( ! \ is_array ( $ arrAttributes ) ) { return ; } foreach ( $ arrAttributes as $ k => $ v ) { $ this -> $ k = $ v ; } } 
protected function isChecked ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return static :: optionChecked ( 1 , 1 ) ; } return static :: optionChecked ( $ arrOption [ 'value' ] , $ this -> varValue ) ; } 
protected function isSelected ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return static :: optionSelected ( 1 , 1 ) ; } return static :: optionSelected ( $ arrOption [ 'value' ] , $ this -> varValue ) ; } 
public static function optionSelected ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' selected' : '' ; } 
public static function optionChecked ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' checked' : '' ; } 
protected function isValidOption ( $ varInput ) { if ( ! \ is_array ( $ varInput ) ) { $ varInput = array ( $ varInput ) ; } 
public static function getAttributesFromDca ( $ arrData , $ strName , $ varValue = null , $ strField = '' , $ strTable = '' , $ objDca = null ) { $ arrAttributes = $ arrData [ 'eval' ] ; $ arrAttributes [ 'id' ] = $ strName ; $ arrAttributes [ 'name' ] = $ strName ; $ arrAttributes [ 'strField' ] = $ strField ; $ arrAttributes [ 'strTable' ] = $ strTable ; $ arrAttributes [ 'label' ] = ( ( $ label = \ is_array ( $ arrData [ 'label' ] ) ? $ arrData [ 'label' ] [ 0 ] : $ arrData [ 'label' ] ) != false ) ? $ label : $ strField ; $ arrAttributes [ 'description' ] = $ arrData [ 'label' ] [ 1 ] ; $ arrAttributes [ 'type' ] = $ arrData [ 'inputType' ] ; $ arrAttributes [ 'dataContainer' ] = $ objDca ; 
public function getEmptyValue ( ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ) { return '' ; } return static :: getEmptyValueByFieldType ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ; } 
public static function getEmptyValueByFieldType ( $ sql ) { if ( empty ( $ sql ) ) { return '' ; } if ( \ is_array ( $ sql ) ) { if ( isset ( $ sql [ 'columnDefinition' ] ) ) { $ sql = $ sql [ 'columnDefinition' ] ; } else { if ( isset ( $ sql [ 'default' ] ) ) { return $ sql [ 'default' ] ; } if ( isset ( $ sql [ 'notnull' ] ) && ! $ sql [ 'notnull' ] ) { return null ; } if ( \ in_array ( $ sql [ 'type' ] , array ( Type :: BIGINT , Type :: DECIMAL , Type :: INTEGER , Type :: SMALLINT , Type :: FLOAT ) ) ) { return 0 ; } return '' ; } } if ( stripos ( $ sql , 'NOT NULL' ) === false ) { return null ; } $ type = strtolower ( preg_replace ( '/^([A-Za-z]+)(\(| ).*$/' , '$1' , $ sql ) ) ; if ( \ in_array ( $ type , array ( 'int' , 'integer' , 'tinyint' , 'smallint' , 'mediumint' , 'bigint' , 'float' , 'double' , 'dec' , 'decimal' ) ) ) { return 0 ; } return '' ; } 
public function getEmptyStringOrNull ( ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ) { return '' ; } return static :: getEmptyStringOrNullByFieldType ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ; } 
public function process ( ContainerBuilder $ container ) : void { $ tags = $ this -> getFragmentTags ( $ container , ContentElementReference :: TAG_NAME ) ; $ elements = $ this -> getGlobalsMap ( $ tags , 'TL_CTE' , ContentProxy :: class ) ; $ tags = $ this -> getFragmentTags ( $ container , FrontendModuleReference :: TAG_NAME ) ; $ modules = $ this -> getGlobalsMap ( $ tags , 'FE_MOD' , ModuleProxy :: class ) ; $ listener = new Definition ( GlobalsMapListener :: class , [ array_merge ( $ elements , $ modules ) ] ) ; $ listener -> setPublic ( true ) ; $ listener -> addTag ( 'contao.hook' , [ 'hook' => 'initializeSystem' , 'priority' => 255 ] ) ; $ container -> setDefinition ( 'contao.listener.' . ContainerBuilder :: hash ( $ listener ) , $ listener ) ; } 
private function getFragmentTags ( ContainerBuilder $ container , string $ tag ) : array { $ result = [ ] ; foreach ( $ this -> findAndSortTaggedServices ( $ tag , $ container ) as $ priority => $ reference ) { $ definition = $ container -> findDefinition ( $ reference ) ; foreach ( $ definition -> getTag ( $ tag ) as $ attributes ) { if ( ! isset ( $ attributes [ 'category' ] ) ) { throw new InvalidConfigurationException ( sprintf ( 'Missing category for "%s" fragment on service ID "%s"' , $ tag , ( string ) $ reference ) ) ; } if ( ! isset ( $ attributes [ 'type' ] ) ) { throw new InvalidConfigurationException ( sprintf ( 'Missing type for "%s" fragment on service ID "%s"' , $ tag , ( string ) $ reference ) ) ; } $ result [ ] = $ attributes ; } } return $ result ; } 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'calendar' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } $ this -> cal_calendar = $ this -> sortOutProtected ( StringUtil :: deserialize ( $ this -> cal_calendar , true ) ) ; 
protected function compile ( ) { 
protected function compileDays ( ) { $ arrDays = array ( ) ; for ( $ i = 0 ; $ i < 7 ; $ i ++ ) { $ strClass = '' ; $ intCurrentDay = ( $ i + $ this -> cal_startDay ) % 7 ; if ( $ i == 0 ) { $ strClass .= ' col_first' ; } elseif ( $ i == 6 ) { $ strClass .= ' col_last' ; } if ( $ intCurrentDay == 0 || $ intCurrentDay == 6 ) { $ strClass .= ' weekend' ; } $ arrDays [ $ intCurrentDay ] = array ( 'class' => $ strClass , 'name' => $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] [ $ intCurrentDay ] ) ; } return $ arrDays ; } 
protected function compileWeeks ( ) { $ intDaysInMonth = date ( 't' , $ this -> Date -> monthBegin ) ; $ intFirstDayOffset = date ( 'w' , $ this -> Date -> monthBegin ) - $ this -> cal_startDay ; if ( $ intFirstDayOffset < 0 ) { $ intFirstDayOffset += 7 ; } $ intColumnCount = - 1 ; $ intNumberOfRows = ceil ( ( $ intDaysInMonth + $ intFirstDayOffset ) / 7 ) ; $ arrAllEvents = $ this -> getAllEvents ( $ this -> cal_calendar , $ this -> Date -> monthBegin , $ this -> Date -> monthEnd ) ; $ arrDays = array ( ) ; 
public static function isUrl ( $ varValue ) { try { $ varValue = Idna :: encodeUrl ( $ varValue ) ; } catch ( \ InvalidArgumentException $ e ) { } return preg_match ( '/^[\w\/.*+?$#%:,;{}()[\]@&!=~|-]+$/u' , $ varValue ) ; } 
public static function isInsecurePath ( $ strPath ) { 
public static function isValidFileName ( $ strName ) { if ( $ strName == '' ) { return false ; } 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'newslist' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } $ this -> news_archives = $ this -> sortOutProtected ( StringUtil :: deserialize ( $ this -> news_archives ) ) ; 
protected function compile ( ) { $ limit = null ; $ offset = ( int ) $ this -> skipFirst ; 
protected function countItems ( $ newsArchives , $ blnFeatured ) { 
protected function fetchItems ( $ newsArchives , $ blnFeatured , $ limit , $ offset ) { 
public function handle ( Request $ request , $ type = HttpKernelInterface :: MASTER_REQUEST , $ catch = true ) : Response { 
private function isRequestPrivate ( Request $ request ) : bool { if ( $ request -> headers -> has ( 'Authorization' ) ) { return true ; } if ( \ count ( $ request -> cookies -> all ( ) ) ) { return true ; } return false ; } 
public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; 
public function addIcon ( $ row , $ label ) { $ image = 'articles' ; $ time = Contao \ Date :: floorToMinute ( ) ; $ unpublished = ( $ row [ 'start' ] != '' && $ row [ 'start' ] > $ time ) || ( $ row [ 'stop' ] != '' && $ row [ 'stop' ] < $ time ) ; if ( ! $ row [ 'published' ] || $ unpublished ) { $ image .= '_' ; } return '<a href="contao/main.php?do=feRedirect&amp;page=' . $ row [ 'pid' ] . '&amp;article=' . ( $ row [ 'alias' ] ? : $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'view' ] ) . '" target="_blank">' . Contao \ Image :: getHtml ( $ image . '.svg' , '' , 'data-icon="' . ( $ unpublished ? $ image : rtrim ( $ image , '_' ) ) . '.svg" data-icon-disabled="' . rtrim ( $ image , '_' ) . '_.svg"' ) . '</a> ' . $ label ; } 
public function generateAlias ( $ varValue , Contao \ DataContainer $ dc ) { $ aliasExists = function ( string $ alias ) use ( $ dc ) : bool { if ( \ in_array ( $ alias , array ( 'top' , 'wrapper' , 'header' , 'container' , 'main' , 'left' , 'right' , 'footer' ) , true ) ) { return true ; } return $ this -> Database -> prepare ( "SELECT id FROM tl_article WHERE alias=? AND id!=?" ) -> execute ( $ alias , $ dc -> id ) -> numRows > 0 ; } ; 
public function getActiveLayoutSections ( Contao \ DataContainer $ dc ) { 
public function editArticle ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLES , $ objPage -> row ( ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } 
public function pasteArticle ( Contao \ DataContainer $ dc , $ row , $ table , $ cr , $ arrClipboard = null ) { $ imagePasteAfter = Contao \ Image :: getHtml ( 'pasteafter.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) ; $ imagePasteInto = Contao \ Image :: getHtml ( 'pasteinto.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) ; if ( $ table == $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'ptable' ] ) { return ( $ row [ 'type' ] == 'root' || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ row ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteinto_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=2&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteInto . '</a> ' ; } $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return ( ( $ arrClipboard [ 'mode' ] == 'cut' && $ arrClipboard [ 'id' ] == $ row [ 'id' ] ) || ( $ arrClipboard [ 'mode' ] == 'cutAll' && \ in_array ( $ row [ 'id' ] , $ arrClipboard [ 'id' ] ) ) || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ objPage -> row ( ) ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteafter_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=1&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteAfter . '</a> ' ; } 
public function addAliasButton ( $ arrButtons ) { 
public function toggleIcon ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( \ strlen ( Contao \ Input :: get ( 'tid' ) ) ) { $ this -> toggleVisibility ( Contao \ Input :: get ( 'tid' ) , ( Contao \ Input :: get ( 'state' ) == 1 ) , ( @ func_get_arg ( 12 ) ? : null ) ) ; $ this -> redirect ( $ this -> getReferer ( ) ) ; } 
public function process ( ContainerBuilder $ container ) : void { if ( ! $ container -> hasDefinition ( 'session' ) ) { return ; } $ session = $ container -> findDefinition ( 'session' ) ; $ session -> addMethodCall ( 'registerBag' , [ new Reference ( 'contao.session.contao_backend' ) ] ) ; $ session -> addMethodCall ( 'registerBag' , [ new Reference ( 'contao.session.contao_frontend' ) ] ) ; } 
public function generate ( $ name , $ parameters = [ ] , $ referenceType = self :: ABSOLUTE_PATH ) : ? string { $ this -> framework -> initialize ( ) ; if ( ! \ is_array ( $ parameters ) ) { $ parameters = [ ] ; } $ context = $ this -> getContext ( ) ; 
private function prepareAlias ( string $ alias , array & $ parameters ) : void { if ( 'index' === $ alias ) { return ; } $ hasAutoItem = false ; $ autoItems = $ this -> getAutoItems ( $ parameters ) ; $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ parameters [ 'alias' ] = preg_replace_callback ( '/\{([^\}]+)\}/' , static function ( array $ matches ) use ( $ alias , & $ parameters , $ autoItems , & $ hasAutoItem , $ config ) : string { $ param = $ matches [ 1 ] ; if ( ! isset ( $ parameters [ $ param ] ) ) { throw new MissingMandatoryParametersException ( sprintf ( 'Parameters "%s" is missing to generate a URL for "%s"' , $ param , $ alias ) ) ; } $ value = $ parameters [ $ param ] ; unset ( $ parameters [ $ param ] ) ; if ( $ hasAutoItem || ! $ config -> get ( 'useAutoItem' ) || ! \ in_array ( $ param , $ autoItems , true ) ) { return $ param . '/' . $ value ; } $ hasAutoItem = true ; return $ value ; } , $ alias ) ; } 
private function prepareDomain ( RequestContext $ context , array & $ parameters , int & $ referenceType ) : void { if ( isset ( $ parameters [ '_ssl' ] ) ) { $ context -> setScheme ( true === $ parameters [ '_ssl' ] ? 'https' : 'http' ) ; } if ( isset ( $ parameters [ '_domain' ] ) && '' !== $ parameters [ '_domain' ] ) { $ this -> addHostToContext ( $ context , $ parameters , $ referenceType ) ; } unset ( $ parameters [ '_domain' ] , $ parameters [ '_ssl' ] ) ; } 
private function addHostToContext ( RequestContext $ context , array $ parameters , int & $ referenceType ) : void { [ $ host , $ port ] = $ this -> getHostAndPort ( $ parameters [ '_domain' ] ) ; if ( $ context -> getHost ( ) === $ host ) { return ; } $ context -> setHost ( $ host ) ; $ referenceType = UrlGeneratorInterface :: ABSOLUTE_URL ; if ( ! $ port ) { return ; } if ( isset ( $ parameters [ '_ssl' ] ) && true === $ parameters [ '_ssl' ] ) { $ context -> setHttpsPort ( $ port ) ; } else { $ context -> setHttpPort ( $ port ) ; } } 
private function getHostAndPort ( string $ domain ) : array { if ( false !== strpos ( $ domain , ':' ) ) { return explode ( ':' , $ domain , 2 ) ; } return [ $ domain , null ] ; } 
private function getAutoItems ( array $ parameters ) : array { if ( isset ( $ parameters [ 'auto_item' ] ) ) { return [ $ parameters [ 'auto_item' ] ] ; } if ( isset ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) && \ is_array ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) { return $ GLOBALS [ 'TL_AUTO_ITEM' ] ; } return [ ] ; } 
public function load ( $ resource , $ type = null ) : RouteCollection { $ routes = new RouteCollection ( ) ; $ defaults = [ '_token_check' => true , '_controller' => 'Contao\CoreBundle\Controller\FrontendController::indexAction' , '_scope' => ContaoCoreBundle :: SCOPE_FRONTEND , ] ; $ this -> addFrontendRoute ( $ routes , $ defaults ) ; $ this -> addIndexRoute ( $ routes , $ defaults ) ; return $ routes ; } 
private function addFrontendRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/{alias}' . $ this -> urlSuffix , $ defaults , [ 'alias' => '.+' ] ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_frontend' , $ route ) ; } 
private function addIndexRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/' , $ defaults ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_index' , $ route ) ; } 
private function addLocaleToRoute ( Route $ route ) : void { if ( ! $ this -> prependLocale ) { return ; } $ route -> setPath ( '/{_locale}' . $ route -> getPath ( ) ) ; $ route -> addRequirements ( [ '_locale' => '[a-z]{2}(\-[A-Z]{2})?' ] ) ; } 
public function generate ( ) { if ( TL_MODE == 'FE' && ! BE_USER_LOGGED_IN && ( $ this -> invisible || ( $ this -> start != '' && $ this -> start > time ( ) ) || ( $ this -> stop != '' && $ this -> stop < time ( ) ) ) ) { return '' ; } $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ this -> Template -> setData ( $ this -> arrData ) ; $ this -> compile ( ) ; 
public static function findClass ( $ strName ) { foreach ( $ GLOBALS [ 'TL_CTE' ] as $ v ) { foreach ( $ v as $ kk => $ vv ) { if ( $ kk == $ strName ) { return $ vv ; } } } return '' ; } 
protected function row ( $ strPalette = null ) { $ arrData = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] ; <script> window.addEvent("domready", function() { new Picker.Date($("ctrl_' . $ objWidget -> id . '"), { draggable: false, toggle: $("toggle_' . $ objWidget -> id . '"), format: "' . $ format . '", positionOffset: {x:-211,y:-209}' . $ time . ', pickerClass: "datepicker_bootstrap", useFadeInOut: !Browser.ie' . $ strOnSelect . ', startDay: ' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'weekOffset' ] . ', titleFormat: "' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'titleFormat' ] . '" }); }); </script>' ; } // Color picker if ( $ arrData [ 'eval' ] [ 'colorpicker' ] ) { // Support single fields as well (see #5240) $ strKey = $ arrData [ 'eval' ] [ 'multiple' ] ? $ this -> strField . '_0' : $ this -> strField ; $ wizard .= ' ' . Image :: getHtml ( 'pickcolor.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'colorpicker' ] , 'title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'colorpicker' ] ) . '" id="moo_' . $ this -> strField . '" style="cursor:pointer"' ) . ' <script> window.addEvent("domready", function() { var cl = $("ctrl_' . $ strKey . '").value.hexToRgb(true) || [255, 0, 0]; new MooRainbow("moo_' . $ this -> strField . '", { id: "ctrl_' . $ strKey . '", startColor: cl, imgPath: "assets/colorpicker/images/", onComplete: function(color) { $("ctrl_' . $ strKey . '").value = color.hex.replace("#", ""); } }); }); </script>' ; } $ arrClasses = StringUtil :: trimsplit ( ' ' , ( string ) $ arrData [ 'eval' ] [ 'tl_class' ] ) ; // DCA picker if ( isset ( $ arrData [ 'eval' ] [ 'dcaPicker' ] ) && ( \ is_array ( $ arrData [ 'eval' ] [ 'dcaPicker' ] ) || $ arrData [ 'eval' ] [ 'dcaPicker' ] === true ) ) { $ arrClasses [ ] = 'dcapicker' ; $ wizard .= Backend :: getDcaPickerWizard ( $ arrData [ 'eval' ] [ 'dcaPicker' ] , $ this -> strTable , $ this -> strField , $ this -> strInputName ) ; } // Add a custom wizard if ( \ is_array ( $ arrData [ 'wizard' ] ) ) { foreach ( $ arrData [ 'wizard' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ wizard .= $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ wizard .= $ callback ( $ this ) ; } } } if ( $ wizard != '' ) { $ objWidget -> wizard = $ wizard ; if ( $ arrData [ 'eval' ] [ 'addWizardClass' ] !== false && ! \ in_array ( 'wizard' , $ arrClasses ) ) { $ arrClasses [ ] = 'wizard' ; } } elseif ( \ in_array ( 'wizard' , $ arrClasses ) ) { unset ( $ arrClasses [ array_search ( 'wizard' , $ arrClasses ) ] ) ; } // Set correct form enctype if ( $ objWidget instanceof \ uploadable ) { $ this -> blnUploadable = true ; } if ( $ arrData [ 'inputType' ] != 'password' ) { $ arrClasses [ ] = 'widget' ; } // Mark floated single checkboxes if ( $ arrData [ 'inputType' ] == 'checkbox' && ! $ arrData [ 'eval' ] [ 'multiple' ] && \ in_array ( 'w50' , $ arrClasses ) ) { $ arrClasses [ ] = 'cbx' ; } elseif ( $ arrData [ 'inputType' ] == 'text' && $ arrData [ 'eval' ] [ 'multiple' ] && \ in_array ( 'wizard' , $ arrClasses ) ) { $ arrClasses [ ] = 'inline' ; } if ( ! empty ( $ arrClasses ) ) { $ arrData [ 'eval' ] [ 'tl_class' ] = implode ( ' ' , array_unique ( $ arrClasses ) ) ; } $ updateMode = '' ; // Replace the textarea with an RTE instance if ( ! empty ( $ arrData [ 'eval' ] [ 'rte' ] ) ) { list ( $ file , $ type ) = explode ( '|' , $ arrData [ 'eval' ] [ 'rte' ] , 2 ) ; $ fileBrowserTypes = array ( ) ; $ pickerBuilder = System :: getContainer ( ) -> get ( 'contao.picker.builder' ) ; foreach ( array ( 'file' => 'image' , 'link' => 'file' ) as $ context => $ fileBrowserType ) { if ( $ pickerBuilder -> supportsContext ( $ context ) ) { $ fileBrowserTypes [ ] = $ fileBrowserType ; } } $ objTemplate = new BackendTemplate ( 'be_' . $ file ) ; $ objTemplate -> selector = 'ctrl_' . $ this -> strInputName ; $ objTemplate -> type = $ type ; $ objTemplate -> fileBrowserTypes = $ fileBrowserTypes ; $ objTemplate -> source = $ this -> strTable . '.' . $ this -> intId ; // Deprecated since Contao 4.0, to be removed in Contao 5.0 $ objTemplate -> language = Backend :: getTinyMceLanguage ( ) ; $ updateMode = $ objTemplate -> parse ( ) ; unset ( $ file , $ type , $ pickerBuilder , $ fileBrowserTypes , $ fileBrowserType ) ; } // Handle multi-select fields in "override all" mode elseif ( Input :: get ( 'act' ) == 'overrideAll' && ( $ arrData [ 'inputType' ] == 'checkbox' || $ arrData [ 'inputType' ] == 'checkboxWizard' ) && $ arrData [ 'eval' ] [ 'multiple' ] ) { $ updateMode = ' </div> <div class="widget"> <fieldset class="tl_radio_container"> <legend>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'updateMode' ] . '</legend> <input type="radio" name="' . $ this -> strInputName . '_update" id="opt_' . $ this -> strInputName . '_update_1" class="tl_radio" value="add" onfocus="Backend.getScrollOffset()"> <label for="opt_' . $ this -> strInputName . '_update_1">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'updateAdd' ] . '</label><br> <input type="radio" name="' . $ this -> strInputName . '_update" id="opt_' . $ this -> strInputName . '_update_2" class="tl_radio" value="remove" onfocus="Backend.getScrollOffset()"> <label for="opt_' . $ this -> strInputName . '_update_2">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'updateRemove' ] . '</label><br> <input type="radio" name="' . $ this -> strInputName . '_update" id="opt_' . $ this -> strInputName . '_update_0" class="tl_radio" value="replace" checked="checked" onfocus="Backend.getScrollOffset()"> <label for="opt_' . $ this -> strInputName . '_update_0">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'updateReplace' ] . '</label> </fieldset>' ; } $ strPreview = '' ; // Show a preview image (see #4948) if ( $ this -> strTable == 'tl_files' && $ this -> strField == 'name' && $ this -> objActiveRecord !== null && $ this -> objActiveRecord -> type == 'file' ) { $ objFile = new File ( $ this -> objActiveRecord -> path ) ; if ( $ objFile -> isImage ) { $ blnCanResize = true ; // Check the maximum width and height if the GDlib is used to resize images if ( ! $ objFile -> isSvgImage && System :: getContainer ( ) -> get ( 'contao.image.imagine' ) instanceof Imagine ) { $ blnCanResize = $ objFile -> height <= Config :: get ( 'gdMaxImgHeight' ) && $ objFile -> width <= Config :: get ( 'gdMaxImgWidth' ) ; } $ image = Image :: getPath ( 'placeholder.svg' ) ; if ( $ blnCanResize ) { if ( $ objFile -> width > 699 || $ objFile -> height > 524 || ! $ objFile -> width || ! $ objFile -> height ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; $ image = rawurldecode ( $ container -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ objFile -> path , array ( 699 , 524 , ResizeConfiguration :: MODE_BOX ) ) -> getUrl ( $ rootDir ) ) ; } else { $ image = $ objFile -> path ; } } $ objImage = new File ( $ image ) ; $ ctrl = 'ctrl_preview_' . substr ( md5 ( $ image ) , 0 , 8 ) ; $ strPreview = ' <div id="' . $ ctrl . '" class="tl_edit_preview" data-original-width="' . $ objFile -> viewWidth . '" data-original-height="' . $ objFile -> viewHeight . '"> <img src="' . $ objImage -> dataUri . '" width="' . $ objImage -> width . '" height="' . $ objImage -> height . '" alt=""> </div>' ; // Add the script to mark the important part if ( basename ( $ image ) !== 'placeholder.svg' ) { $ strPreview .= '<script>Backend.editPreviewWizard($(\'' . $ ctrl . '\'));</script>' ; if ( Config :: get ( 'showHelp' ) ) { $ strPreview .= '<p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'edit_preview_help' ] . '</p>' ; } $ strPreview = '<div class="widget">' . $ strPreview . '</div>' ; } } } return $ strPreview . ' <div' . ( $ arrData [ 'eval' ] [ 'tl_class' ] ? ' class="' . trim ( $ arrData [ 'eval' ] [ 'tl_class' ] ) . '"' : '' ) . '>' . $ objWidget -> parse ( ) . $ updateMode . ( ! $ objWidget -> hasErrors ( ) ? $ this -> help ( $ strHelpClass ) : '' ) . ' </div>' ; } 
public function help ( $ strClass = '' ) { $ return = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'label' ] [ 1 ] ; if ( ! Config :: get ( 'showHelp' ) || $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'inputType' ] == 'password' || $ return == '' ) { return '' ; } return ' <p class="tl_help tl_tip' . $ strClass . '">' . $ return . '</p>' ; } 
protected function combiner ( $ names ) { $ return = array ( '' ) ; $ names = array_values ( $ names ) ; for ( $ i = 0 , $ c = \ count ( $ names ) ; $ i < $ c ; $ i ++ ) { $ buffer = array ( ) ; foreach ( $ return as $ k => $ v ) { $ buffer [ ] = ( $ k % 2 == 0 ) ? $ v : $ v . $ names [ $ i ] ; $ buffer [ ] = ( $ k % 2 == 0 ) ? $ v . $ names [ $ i ] : $ v ; } $ return = $ buffer ; } return array_filter ( $ return ) ; } 
protected function switchToEdit ( $ id ) { $ arrKeys = array ( ) ; $ arrUnset = array ( 'act' , 'id' , 'table' ) ; foreach ( array_keys ( $ _GET ) as $ strKey ) { if ( ! \ in_array ( $ strKey , $ arrUnset ) ) { $ arrKeys [ $ strKey ] = $ strKey . '=' . Input :: get ( $ strKey ) ; } } $ strUrl = TL_SCRIPT . '?' . implode ( '&' , $ arrKeys ) ; return $ strUrl . ( ! empty ( $ arrKeys ) ? '&' : '' ) . ( Input :: get ( 'table' ) ? 'table=' . Input :: get ( 'table' ) . '&amp;' : '' ) . 'act=edit&amp;id=' . rawurlencode ( $ id ) ; } 
protected function generateButtons ( $ arrRow , $ strTable , $ arrRootIds = array ( ) , $ blnCircularReference = false , $ arrChildRecordIds = null , $ strPrevious = null , $ strNext = null ) { if ( empty ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'list' ] [ 'operations' ] ) || ! \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'list' ] [ 'operations' ] ) ) { return '' ; } $ return = '' ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'list' ] [ 'operations' ] as $ k => $ v ) { $ v = \ is_array ( $ v ) ? $ v : array ( $ v ) ; $ id = StringUtil :: specialchars ( rawurldecode ( $ arrRow [ 'id' ] ) ) ; $ label = $ v [ 'label' ] [ 0 ] ? : $ k ; $ title = sprintf ( $ v [ 'label' ] [ 1 ] ? : $ k , $ id ) ; $ attributes = ( $ v [ 'attributes' ] != '' ) ? ' ' . ltrim ( sprintf ( $ v [ 'attributes' ] , $ id , $ id ) ) : '' ; 
protected function generateGlobalButtons ( ) { if ( empty ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'global_operations' ] ) || ! \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'global_operations' ] ) ) { return '' ; } $ return = '' ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'global_operations' ] as $ k => $ v ) { if ( Input :: get ( 'act' ) == 'select' && ! $ v [ 'showOnSelect' ] ) { continue ; } $ v = \ is_array ( $ v ) ? $ v : array ( $ v ) ; $ label = \ is_array ( $ v [ 'label' ] ) ? $ v [ 'label' ] [ 0 ] : $ v [ 'label' ] ; $ title = \ is_array ( $ v [ 'label' ] ) ? $ v [ 'label' ] [ 1 ] : $ v [ 'label' ] ; $ attributes = ( $ v [ 'attributes' ] != '' ) ? ' ' . ltrim ( $ v [ 'attributes' ] ) : '' ; 
protected function generateHeaderButtons ( $ arrRow , $ strPtable ) { if ( empty ( $ GLOBALS [ 'TL_DCA' ] [ $ strPtable ] [ 'list' ] [ 'operations' ] ) || ! \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ strPtable ] [ 'list' ] [ 'operations' ] ) ) { return '' ; } $ return = '' ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ strPtable ] [ 'list' ] [ 'operations' ] as $ k => $ v ) { if ( empty ( $ v [ 'showInHeader' ] ) || ( Input :: get ( 'act' ) == 'select' && ! $ v [ 'showOnSelect' ] ) ) { continue ; } $ v = \ is_array ( $ v ) ? $ v : array ( $ v ) ; $ id = StringUtil :: specialchars ( rawurldecode ( $ arrRow [ 'id' ] ) ) ; $ label = $ v [ 'label' ] [ 0 ] ? : $ k ; $ title = sprintf ( $ v [ 'label' ] [ 1 ] ? : $ k , $ id ) ; $ attributes = ( $ v [ 'attributes' ] != '' ) ? ' ' . ltrim ( sprintf ( $ v [ 'attributes' ] , $ id , $ id ) ) : '' ; 
public function initPicker ( PickerInterface $ picker ) { if ( ! empty ( $ _GET [ 'act' ] ) ) { return null ; } $ provider = $ picker -> getCurrentProvider ( ) ; if ( ! $ provider instanceof DcaPickerProviderInterface || $ provider -> getDcaTable ( ) != $ this -> strTable ) { return null ; } $ attributes = $ provider -> getDcaAttributes ( $ picker -> getConfig ( ) ) ; $ this -> objPicker = $ picker ; $ this -> strPickerFieldType = $ attributes [ 'fieldType' ] ; $ this -> objPickerCallback = function ( $ value ) use ( $ picker , $ provider ) { return $ provider -> convertDcaValue ( $ picker -> getConfig ( ) , $ value ) ; } ; if ( isset ( $ attributes [ 'value' ] ) ) { $ this -> arrPickerValue = ( array ) $ attributes [ 'value' ] ; } return $ attributes ; } 
protected function getPickerInputField ( $ value , $ attributes = '' ) { $ id = is_numeric ( $ value ) ? $ value : md5 ( $ value ) ; switch ( $ this -> strPickerFieldType ) { case 'checkbox' : return ' <input type="checkbox" name="picker[]" id="picker_' . $ id . '" class="tl_tree_checkbox" value="' . StringUtil :: specialchars ( \ call_user_func ( $ this -> objPickerCallback , $ value ) ) . '" onfocus="Backend.getScrollOffset()"' . Widget :: optionChecked ( $ value , $ this -> arrPickerValue ) . $ attributes . '>' ; case 'radio' : return ' <input type="radio" name="picker" id="picker_' . $ id . '" class="tl_tree_radio" value="' . StringUtil :: specialchars ( \ call_user_func ( $ this -> objPickerCallback , $ value ) ) . '" onfocus="Backend.getScrollOffset()"' . Widget :: optionChecked ( $ value , $ this -> arrPickerValue ) . $ attributes . '>' ; } return '' ; } 
protected function panel ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'panelLayout' ] == '' ) { return '' ; } <div class="tl_submit_panel tl_subpanel"> <button name="filter" id="filter" class="tl_img_submit filter_apply" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'applyTitle' ] ) . '">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'apply' ] . '</button> <button name="filter_reset" id="filter_reset" value="1" class="tl_img_submit filter_reset" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resetTitle' ] ) . '">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'reset' ] . '</button> </div>' ; } $ return .= ' <div class="tl_panel cf"> ' . $ submit . $ arrPanels [ $ i ] . ' </div>' ; } $ return = ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" class="tl_form" method="post" aria-label="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'searchAndFilter' ] ) . '"> <div class="tl_formbody"> <input type="hidden" name="FORM_SUBMIT" value="tl_filters"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"> ' . $ return . ' </div> </form>' ; return $ return ; } 
protected function invalidateCacheTags ( self $ dc ) { if ( ! System :: getContainer ( ) -> has ( 'fos_http_cache.cache_manager' ) ) { return ; } $ ns = 'contao.db.' ; $ tags = array ( $ ns . $ dc -> table , $ ns . $ dc -> table . '.' . $ dc -> id ) ; if ( $ dc -> ptable && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { $ tags [ ] = $ ns . $ dc -> ptable ; $ tags [ ] = $ ns . $ dc -> ptable . '.' . $ dc -> activeRecord -> pid ; } 
public function run ( ) { $ pageId = $ this -> getPageIdFromUrl ( ) ; $ objRootPage = null ; 
public function renderPage ( $ pageModel ) { global $ objPage ; $ objPage = $ pageModel ; 
public function getDcaAttributes ( PickerConfig $ config ) : array { $ attributes = [ 'fieldType' => 'radio' ] ; if ( $ source = $ config -> getExtra ( 'source' ) ) { $ attributes [ 'preserveRecord' ] = $ source ; } if ( $ this -> supportsValue ( $ config ) ) { $ attributes [ 'value' ] = str_replace ( [ '{{event_url::' , '}}' ] , '' , $ config -> getValue ( ) ) ; } return $ attributes ; } 
protected function getRouteParameters ( PickerConfig $ config = null ) : array { $ params = [ 'do' => 'calendar' ] ; if ( null === $ config || ! $ config -> getValue ( ) || false === strpos ( $ config -> getValue ( ) , '{{event_url::' ) ) { return $ params ; } $ value = str_replace ( [ '{{event_url::' , '}}' ] , '' , $ config -> getValue ( ) ) ; if ( null !== ( $ calendarId = $ this -> getCalendarId ( $ value ) ) ) { $ params [ 'table' ] = 'tl_calendar_events' ; $ params [ 'id' ] = $ calendarId ; } return $ params ; } 
public function generate ( ) { if ( TL_MODE == 'FE' && ! BE_USER_LOGGED_IN && ( $ this -> invisible || ( $ this -> start != '' && $ this -> start > time ( ) ) || ( $ this -> stop != '' && $ this -> stop < time ( ) ) ) ) { return '' ; } $ objModule = ModuleModel :: findByPk ( $ this -> module ) ; if ( $ objModule === null ) { return '' ; } $ strClass = Module :: findClass ( $ objModule -> type ) ; if ( ! class_exists ( $ strClass ) ) { return '' ; } $ objModule -> typePrefix = 'ce_' ; $ objModule = new $ strClass ( $ objModule , $ this -> strColumn ) ; $ cssID = StringUtil :: deserialize ( $ objModule -> cssID , true ) ; 
public function getActiveGroups ( ) { $ arrGroups = array ( ) ; $ objGroup = Contao \ MemberGroupModel :: findAllActive ( ) ; if ( $ objGroup !== null ) { while ( $ objGroup -> next ( ) ) { $ arrGroups [ $ objGroup -> id ] = $ objGroup -> name ; } } return $ arrGroups ; } 
public function addIcon ( $ row , $ label , Contao \ DataContainer $ dc , $ args ) { $ image = 'member' ; $ time = Contao \ Date :: floorToMinute ( ) ; $ disabled = ( $ row [ 'start' ] !== '' && $ row [ 'start' ] > $ time ) || ( $ row [ 'stop' ] !== '' && $ row [ 'stop' ] < $ time ) ; if ( $ row [ 'disable' ] || $ disabled ) { $ image .= '_' ; } $ args [ 0 ] = sprintf ( '<div class="list_icon_new" style="background-image:url(\'%ssystem/themes/%s/icons/%s.svg\')" data-icon="%s.svg" data-icon-disabled="%s.svg">&nbsp;</div>' , Contao \ System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) , Contao \ Backend :: getTheme ( ) , $ image , $ disabled ? $ image : rtrim ( $ image , '_' ) , rtrim ( $ image , '_' ) . '_' ) ; return $ args ; } 
public function switchUser ( $ row , $ href , $ label , $ title , $ icon ) { $ blnCanSwitchUser = ( $ this -> User -> isAdmin || ( ! empty ( $ this -> User -> amg ) && \ is_array ( $ this -> User -> amg ) ) ) ; if ( ! $ blnCanSwitchUser ) { return '' ; } if ( ! $ row [ 'login' ] || $ row [ 'username' ] == '' || ( ! $ this -> User -> isAdmin && \ count ( array_intersect ( Contao \ StringUtil :: deserialize ( $ row [ 'groups' ] , true ) , $ this -> User -> amg ) ) < 1 ) ) { return Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } return '<a href="contao/preview.php?user=' . rawurlencode ( $ row [ 'username' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" target="_blank">' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } 
public function setNewPassword ( $ strPassword , $ user ) { 
public function storeDateAdded ( $ dc ) { 
protected function checkValue ( $ varInput ) { if ( $ varInput == '' || ! \ is_array ( $ this -> rootNodes ) ) { return ; } if ( strpos ( $ varInput , ',' ) === false ) { $ arrIds = array ( ( int ) $ varInput ) ; } else { $ arrIds = array_map ( '\intval' , array_filter ( explode ( ',' , $ varInput ) ) ) ; } if ( \ count ( array_diff ( $ arrIds , array_merge ( $ this -> rootNodes , $ this -> Database -> getChildRecords ( $ this -> rootNodes , 'tl_page' ) ) ) ) > 0 ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidPages' ] ) ; } } 
public function generate ( ) { $ arrSet = array ( ) ; $ arrValues = array ( ) ; $ blnHasOrder = ( $ this -> orderField != '' && \ is_array ( $ this -> { $ this -> orderField } ) ) ; if ( ! empty ( $ this -> varValue ) ) <input type="hidden" name="' . $ this -> strOrderName . '" id="ctrl_' . $ this -> strOrderId . '" value="' . $ this -> { $ this -> orderField } . '">' : '' ) . ' <div class="selector_container">' . ( ( $ blnHasOrder && \ count ( $ arrValues ) > 1 ) ? ' <p class="sort_hint">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'dragItemsHint' ] . '</p>' : '' ) . ' <ul id="sort_' . $ this -> strId . '" class="' . ( $ blnHasOrder ? 'sortable' : '' ) . '">' ; foreach ( $ arrValues as $ k => $ v ) { $ return .= '<li data-id="' . $ k . '">' . $ v . '</li>' ; } $ return .= '</ul>' ; if ( ! System :: getContainer ( ) -> get ( 'contao.picker.builder' ) -> supportsContext ( 'page' ) ) { $ return .= ' <p><button class="tl_submit" disabled>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'changeSelection' ] . '</button></p>' ; } else { $ extras = array ( 'fieldType' => $ this -> fieldType , 'source' => $ this -> strTable . '.' . $ this -> currentRecord , ) ; if ( \ is_array ( $ this -> rootNodes ) ) { $ extras [ 'rootNodes' ] = array_values ( $ this -> rootNodes ) ; } $ return .= ' <p><a href="' . ampersand ( System :: getContainer ( ) -> get ( 'contao.picker.builder' ) -> getUrl ( 'page' , $ extras ) ) . '" class="tl_submit" id="pt_' . $ this -> strName . '">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'changeSelection' ] . '</a></p> <script> $("pt_' . $ this -> strName . '").addEvent("click", function(e) { e.preventDefault(); Backend.openModalSelector({ "id": "tl_listing", "title": ' . json_encode ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'label' ] [ 0 ] ) . ', "url": this.href + document.getElementById("ctrl_' . $ this -> strId . '").value, "callback": function(table, value) { new Request.Contao({ evalScripts: false, onSuccess: function(txt, json) { $("ctrl_' . $ this -> strId . '").getParent("div").set("html", json.content); json.javascript && Browser.exec(json.javascript); } }).post({"action":"reloadPagetree", "name":"' . $ this -> strId . '", "value":value.join("\t"), "REQUEST_TOKEN":"' . REQUEST_TOKEN . '"}); } }); }); </script>' . ( $ blnHasOrder ? ' <script>Backend.makeMultiSrcSortable("sort_' . $ this -> strId . '", "ctrl_' . $ this -> strOrderId . '", "ctrl_' . $ this -> strId . '")</script>' : '' ) ; } $ return = '<div>' . $ return . '</div></div>' ; return $ return ; } 
public function checkPermission ( ) { $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; 
protected function checkAccessToElement ( $ id , $ pagemounts , $ blnIsPid = false ) { if ( $ blnIsPid ) { $ objPage = $ this -> Database -> prepare ( "SELECT p.id, p.pid, p.includeChmod, p.chmod, p.cuser, p.cgroup, a.id AS aid FROM tl_article a, tl_page p WHERE a.id=? AND a.pid=p.id" ) -> limit ( 1 ) -> execute ( $ id ) ; } else { $ objPage = $ this -> Database -> prepare ( "SELECT p.id, p.pid, p.includeChmod, p.chmod, p.cuser, p.cgroup, a.id AS aid FROM tl_content c, tl_article a, tl_page p WHERE c.id=? AND c.pid=a.id AND a.pid=p.id" ) -> limit ( 1 ) -> execute ( $ id ) ; } 
public function getContentElements ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; } 
public function getContentElementGroup ( $ element ) { foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { if ( $ kk == $ element ) { return $ k ; } } } return null ; } 
public function adjustDcaByType ( $ dc ) { $ objCte = Contao \ ContentModel :: findByPk ( $ dc -> id ) ; if ( $ objCte === null ) { return ; } switch ( $ objCte -> type ) { case 'hyperlink' : unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imageUrl' ] ) ; break ; case 'image' : $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imagemargin' ] [ 'eval' ] [ 'tl_class' ] .= ' clr' ; break ; } } 
public function showJsLibraryHint ( $ dc ) { if ( $ _POST || Contao \ Input :: get ( 'act' ) != 'edit' ) { return ; } 
public function addCteType ( $ arrRow ) { $ key = $ arrRow [ 'invisible' ] ? 'unpublished' : 'published' ; $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ arrRow [ 'type' ] ] [ 0 ] ? : '&nbsp;' ; $ class = 'limit_height' ; <div class="cte_type ' . $ key . '">' . $ type . '</div> <div class="' . trim ( $ class ) . '"> ' . Contao \ StringUtil :: insertTagToSrc ( $ this -> getContentElement ( $ objModel ) ) . ' </div>' . "\n" ; } 
public function getAlias ( ) { $ arrPids = array ( ) ; $ arrAlias = array ( ) ; if ( ! $ this -> User -> isAdmin ) { foreach ( $ this -> User -> pagemounts as $ id ) { $ arrPids [ ] = array ( $ id ) ; $ arrPids [ ] = $ this -> Database -> getChildRecords ( $ id , 'tl_page' ) ; } if ( ! empty ( $ arrPids ) ) { $ arrPids = array_merge ( ... $ arrPids ) ; } else { return $ arrAlias ; } $ objAlias = $ this -> Database -> prepare ( "SELECT c.id, c.pid, c.type, (CASE c.type WHEN 'module' THEN m.name WHEN 'form' THEN f.title WHEN 'table' THEN c.summary ELSE c.headline END) AS headline, c.text, a.title FROM tl_content c LEFT JOIN tl_article a ON a.id=c.pid LEFT JOIN tl_module m ON m.id=c.module LEFT JOIN tl_form f on f.id=c.form WHERE a.pid IN(" . implode ( ',' , array_map ( '\intval' , array_unique ( $ arrPids ) ) ) . ") AND (c.ptable='tl_article' OR c.ptable='') AND c.id!=? ORDER BY a.title, c.sorting" ) -> execute ( Contao \ Input :: get ( 'id' ) ) ; } else { $ objAlias = $ this -> Database -> prepare ( "SELECT c.id, c.pid, c.type, (CASE c.type WHEN 'module' THEN m.name WHEN 'form' THEN f.title WHEN 'table' THEN c.summary ELSE c.headline END) AS headline, c.text, a.title FROM tl_content c LEFT JOIN tl_article a ON a.id=c.pid LEFT JOIN tl_module m ON m.id=c.module LEFT JOIN tl_form f on f.id=c.form WHERE (c.ptable='tl_article' OR c.ptable='') AND c.id!=? ORDER BY a.title, c.sorting" ) -> execute ( Contao \ Input :: get ( 'id' ) ) ; } while ( $ objAlias -> next ( ) ) { $ arrHeadline = Contao \ StringUtil :: deserialize ( $ objAlias -> headline , true ) ; if ( isset ( $ arrHeadline [ 'value' ] ) ) { $ headline = Contao \ StringUtil :: substr ( $ arrHeadline [ 'value' ] , 32 ) ; } else { $ headline = Contao \ StringUtil :: substr ( preg_replace ( '/[\n\r\t]+/' , ' ' , $ arrHeadline [ 0 ] ) , 32 ) ; } $ text = Contao \ StringUtil :: substr ( strip_tags ( preg_replace ( '/[\n\r\t]+/' , ' ' , $ objAlias -> text ) ) , 32 ) ; $ strText = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ objAlias -> type ] [ 0 ] . ' (' ; if ( $ headline != '' ) { $ strText .= $ headline . ', ' ; } elseif ( $ text != '' ) { $ strText .= $ text . ', ' ; } $ key = $ objAlias -> title . ' (ID ' . $ objAlias -> pid . ')' ; $ arrAlias [ $ key ] [ $ objAlias -> id ] = $ strText . 'ID ' . $ objAlias -> id . ')' ; } return $ arrAlias ; } 
public function getForms ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> forms ) ) { return array ( ) ; } $ arrForms = array ( ) ; $ objForms = $ this -> Database -> execute ( "SELECT id, title FROM tl_form ORDER BY title" ) ; while ( $ objForms -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objForms -> id , 'forms' ) ) { $ arrForms [ $ objForms -> id ] = $ objForms -> title . ' (ID ' . $ objForms -> id . ')' ; } } return $ arrForms ; } 
public function getArticles ( Contao \ DataContainer $ dc ) { $ arrPids = array ( ) ; $ arrArticle = array ( ) ; $ arrRoot = array ( ) ; $ intPid = $ dc -> activeRecord -> pid ; if ( Contao \ Input :: get ( 'act' ) == 'overrideAll' ) { $ intPid = Contao \ Input :: get ( 'id' ) ; } 
public function setRteSyntax ( $ varValue , Contao \ DataContainer $ dc ) { switch ( $ dc -> activeRecord -> highlight ) { case 'C' : case 'CSharp' : $ syntax = 'c_cpp' ; break ; case 'CSS' : case 'Diff' : case 'Groovy' : case 'HTML' : case 'Java' : case 'JavaScript' : case 'Perl' : case 'PHP' : case 'PowerShell' : case 'Python' : case 'Ruby' : case 'Scala' : case 'SQL' : case 'Text' : case 'YAML' : $ syntax = strtolower ( $ dc -> activeRecord -> highlight ) ; break ; case 'VB' : $ syntax = 'vbscript' ; break ; case 'XML' : case 'XHTML' : $ syntax = 'xml' ; break ; default : $ syntax = 'text' ; break ; } if ( $ dc -> activeRecord -> type == 'markdown' ) { $ syntax = 'markdown' ; } $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'code' ] [ 'eval' ] [ 'rte' ] = 'ace|' . $ syntax ; return $ varValue ; } 
public function listImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=list' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a>' ; } 
public function tableImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=table' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a> ' . Contao \ Image :: getHtml ( 'demagnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_shrink' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(0.9)"' ) . Contao \ Image :: getHtml ( 'magnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_expand' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(1.1)"' ) ; } 
public function pagePicker ( Contao \ DataContainer $ dc ) { @ trigger_error ( 'Using tl_content::pagePicker() has been deprecated and will no longer work in Contao 5.0. Set the "dcaPicker" eval attribute instead.' , E_USER_DEPRECATED ) ; return Contao \ Backend :: getDcaPickerWizard ( true , $ dc -> table , $ dc -> field , $ dc -> inputName ) ; } 
public function deleteElement ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objElement = $ this -> Database -> prepare ( "SELECT id FROM tl_content WHERE cteAlias=? AND type='alias'" ) -> limit ( 1 ) -> execute ( $ row [ 'id' ] ) ; return $ objElement -> numRows ? Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' : '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } 
public function setSingleSrcFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord ) { switch ( $ dc -> activeRecord -> type ) { case 'text' : case 'hyperlink' : case 'image' : case 'accordionSingle' : $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'extensions' ] = Contao \ Config :: get ( 'validImageTypes' ) ; break ; case 'download' : $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'extensions' ] = Contao \ Config :: get ( 'allowedDownload' ) ; break ; } } return $ varValue ; } 
public function setMultiSrcFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord ) { switch ( $ dc -> activeRecord -> type ) { case 'gallery' : $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'isGallery' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'extensions' ] = Contao \ Config :: get ( 'validImageTypes' ) ; break ; case 'downloads' : $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'isDownloads' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'extensions' ] = Contao \ Config :: get ( 'allowedDownload' ) ; break ; } } return $ varValue ; } 
public function extractYouTubeId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> youtube != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%(?:youtube(?:-nocookie)?\.com/(?:[^/]+/.+/|(?:v|e(?:mbed)?)/|.*[?&]v=)|youtu\.be/)([^"&?/ ]{11})%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; } 
public function extractVimeoId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> vimeo != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%vimeo\.com/(?:channels/(?:\w+/)?|groups/(?:[^/]+)/videos/|album/(?:\d+)/video/)?(\d+)(?:$|/|\?)%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; } 
protected function compile ( ) { global $ objPage ; $ lang = null ; $ host = null ; 
protected function getQuicknavPages ( $ pid , $ level = 1 , $ host = null ) { global $ objPage ; $ groups = array ( ) ; $ arrPages = array ( ) ; 
public function manageFeeds ( $ href , $ label , $ title , $ class , $ attributes ) { return ( $ this -> User -> isAdmin || ! empty ( $ this -> User -> calendarfeeds ) || ! empty ( $ this -> User -> calendarfeedp ) ) ? '<a href="' . $ this -> addToUrl ( $ href ) . '" class="' . $ class . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . $ label . '</a> ' : '' ; } 
public function validate ( ) { $ varValue = $ this -> getPost ( $ this -> strName ) ; if ( ! empty ( $ varValue ) && ! $ this -> isValidOption ( $ varValue ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalid' ] ) ; } parent :: validate ( ) ; } 
public function generate ( ) { if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } 
protected function generateCheckbox ( $ arrOption , $ i , $ strButtons ) { return sprintf ( '<span><input type="checkbox" name="%s" id="opt_%s" class="tl_checkbox" value="%s"%s%s onfocus="Backend.getScrollOffset()"> %s<label for="opt_%s">%s</label></span>' , $ this -> strName . ( $ this -> multiple ? '[]' : '' ) , $ this -> strId . '_' . $ i , ( $ this -> multiple ? StringUtil :: specialchars ( $ arrOption [ 'value' ] ) : 1 ) , ( ( ( \ is_array ( $ this -> varValue ) && \ in_array ( $ arrOption [ 'value' ] , $ this -> varValue ) ) || $ this -> varValue == $ arrOption [ 'value' ] ) ? ' checked="checked"' : '' ) , $ this -> getAttributes ( ) , $ strButtons , $ this -> strId . '_' . $ i , $ arrOption [ 'label' ] ) ; } 
protected function compile ( ) { if ( substr ( $ this -> url , 0 , 7 ) == 'mailto:' ) { $ this -> url = StringUtil :: encodeEmail ( $ this -> url ) ; } else { $ this -> url = ampersand ( $ this -> url ) ; } $ embed = explode ( '%s' , $ this -> embed ) ; 
public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } if ( ! $ this -> User -> hasAccess ( 'image_sizes' , 'themes' ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to access the image sizes module.' ) ; } } 
public function adjustPermissions ( $ insertId ) { 
public function listImageSize ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'name' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . ( int ) $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; } 
public function showJsLibraryHint ( ) { if ( $ _POST || Contao \ Input :: get ( 'act' ) != 'edit' ) { return ; } 
public function matchRequest ( Request $ request ) : array { $ this -> framework -> initialize ( true ) ; $ pathInfo = rawurldecode ( $ request -> getPathInfo ( ) ) ; if ( '/' === $ pathInfo || empty ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) || ! \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) || ( $ this -> prependLocale && preg_match ( '@^/([a-z]{2}(-[A-Z]{2})?)/$@' , $ pathInfo ) ) ) { return $ this -> requestMatcher -> matchRequest ( $ request ) ; } @ trigger_error ( 'Using the "getPageIdFromUrl" hook has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ locale = null ; $ fragments = null ; $ config = $ this -> framework -> getAdapter ( Config :: class ) ; if ( $ config -> get ( 'folderUrl' ) ) { try { $ match = $ this -> requestMatcher -> matchRequest ( $ request ) ; $ fragments = $ this -> createFragmentsFromMatch ( $ match ) ; $ locale = $ match [ '_locale' ] ?? null ; } catch ( ResourceNotFoundException $ e ) { 
public function originalRow ( ) { $ row = $ this -> row ( ) ; if ( ! $ this -> isModified ( ) ) { return $ row ; } $ originalRow = array ( ) ; foreach ( $ row as $ k => $ v ) { $ originalRow [ $ k ] = $ this -> arrModified [ $ k ] ?? $ v ; } return $ originalRow ; } 
public function setRow ( array $ arrData ) { foreach ( $ arrData as $ k => $ v ) { if ( strpos ( $ k , '__' ) !== false ) { unset ( $ arrData [ $ k ] ) ; } } $ this -> arrData = $ arrData ; return $ this ; } 
public function mergeRow ( array $ arrData ) { foreach ( $ arrData as $ k => $ v ) { if ( strpos ( $ k , '__' ) !== false ) { continue ; } if ( ! isset ( $ this -> arrModified [ $ k ] ) ) { $ this -> arrData [ $ k ] = $ v ; } } return $ this ; } 
public function markModified ( $ strKey ) { if ( ! isset ( $ this -> arrModified [ $ strKey ] ) ) { $ this -> arrModified [ $ strKey ] = $ this -> arrData [ $ strKey ] ?? null ; } } 
public function save ( ) { 
public function delete ( ) { $ intPk = $ this -> { static :: $ strPk } ; 
public function getRelated ( $ strKey , array $ arrOptions = array ( ) ) { 
public function refresh ( ) { $ intPk = $ this -> { static :: $ strPk } ; 
public function detach ( $ blnKeepClone = true ) { $ registry = Registry :: getInstance ( ) ; if ( ! $ registry -> isRegistered ( $ this ) ) { return ; } $ registry -> unregister ( $ this ) ; if ( $ blnKeepClone ) { $ this -> cloneOriginal ( ) -> attach ( ) ; } } 
public function onRegister ( Registry $ registry ) { 
public function onUnregister ( Registry $ registry ) { 
public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { 
public static function findByIdOrAlias ( $ varId , array $ arrOptions = array ( ) ) { $ isAlias = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ; 
public static function findMultipleByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ arrRegistered = array ( ) ; $ arrUnregistered = array ( ) ; 
public static function findOneBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => $ strColumn , 'value' => $ varValue , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; } 
public static function findBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ blnModel = false ; $ arrColumn = ( array ) $ strColumn ; if ( \ count ( $ arrColumn ) == 1 && ( $ arrColumn [ 0 ] === static :: getPk ( ) || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) ) { $ blnModel = true ; } $ arrOptions = array_merge ( array ( 'column' => $ strColumn , 'value' => $ varValue , 'return' => $ blnModel ? 'Model' : 'Collection' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; } 
protected static function find ( array $ arrOptions ) { if ( static :: $ strTable == '' ) { return null ; } 
public static function countBy ( $ strColumn = null , $ varValue = null , array $ arrOptions = array ( ) ) { if ( static :: $ strTable == '' ) { return 0 ; } $ arrOptions = array_merge ( array ( 'table' => static :: $ strTable , 'column' => $ strColumn , 'value' => $ varValue ) , $ arrOptions ) ; $ strQuery = static :: buildCountQuery ( $ arrOptions ) ; return ( int ) Database :: getInstance ( ) -> prepare ( $ strQuery ) -> execute ( $ arrOptions [ 'value' ] ) -> count ; } 
public static function getClassFromTable ( $ strTable ) { if ( isset ( static :: $ arrClassNames [ $ strTable ] ) ) { return static :: $ arrClassNames [ $ strTable ] ; } if ( isset ( $ GLOBALS [ 'TL_MODELS' ] [ $ strTable ] ) ) { static :: $ arrClassNames [ $ strTable ] = $ GLOBALS [ 'TL_MODELS' ] [ $ strTable ] ; 
public static function parse ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( 'Invalid file ' . $ file ) ; } $ table = '' ; $ return = array ( ) ; $ data = file ( $ file ) ; foreach ( $ data as $ k => $ v ) { $ key_name = array ( ) ; $ subpatterns = array ( ) ; 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : void { $ output -> write ( json_encode ( $ this -> managerConfig -> all ( ) ) ) ; } 
public function process ( ContainerBuilder $ container ) : void { if ( ! $ container -> has ( 'contao.fragment.registry' ) ) { return ; } $ this -> registerFragments ( $ container , ContentElementReference :: TAG_NAME ) ; $ this -> registerFragments ( $ container , FrontendModuleReference :: TAG_NAME ) ; } 
protected function getControllerName ( Reference $ reference , array $ attributes ) : string { $ controller = ( string ) $ reference ; 
protected function compile ( ) { $ objFaq = FaqModel :: findPublishedByPids ( $ this -> faq_categories ) ; if ( $ objFaq === null ) { $ this -> Template -> faq = array ( ) ; return ; } global $ objPage ; $ arrFaqs = array_fill_keys ( $ this -> faq_categories , array ( ) ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; 
public function generateFeed ( $ intId ) { $ objCalendar = CalendarFeedModel :: findByPk ( $ intId ) ; if ( $ objCalendar === null ) { return ; } $ objCalendar -> feedName = $ objCalendar -> alias ? : 'calendar' . $ objCalendar -> id ; 
public function generateFeeds ( ) { $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> purgeXmlFiles ( ) ; $ objCalendar = CalendarFeedModel :: findAll ( ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { $ objCalendar -> feedName = $ objCalendar -> alias ? : 'calendar' . $ objCalendar -> id ; $ this -> generateFiles ( $ objCalendar -> row ( ) ) ; $ this -> log ( 'Generated calendar feed "' . $ objCalendar -> feedName . '.xml"' , __METHOD__ , TL_CRON ) ; } } } 
public function generateFeedsByCalendar ( $ intId ) { $ objFeed = CalendarFeedModel :: findByCalendar ( $ intId ) ; if ( $ objFeed !== null ) { while ( $ objFeed -> next ( ) ) { $ objFeed -> feedName = $ objFeed -> alias ? : 'calendar' . $ objFeed -> id ; 
protected function generateFiles ( $ arrFeed ) { $ arrCalendars = StringUtil :: deserialize ( $ arrFeed [ 'calendars' ] ) ; if ( empty ( $ arrCalendars ) || ! \ is_array ( $ arrCalendars ) ) { return ; } $ strType = ( $ arrFeed [ 'format' ] == 'atom' ) ? 'generateAtom' : 'generateRss' ; $ strLink = $ arrFeed [ 'feedBase' ] ? : Environment :: get ( 'base' ) ; $ strFile = $ arrFeed [ 'feedName' ] ; $ objFeed = new Feed ( $ strFile ) ; $ objFeed -> link = $ strLink ; $ objFeed -> title = $ arrFeed [ 'title' ] ; $ objFeed -> description = $ arrFeed [ 'description' ] ; $ objFeed -> language = $ arrFeed [ 'language' ] ; $ objFeed -> published = $ arrFeed [ 'tstamp' ] ; $ arrUrls = array ( ) ; $ this -> arrEvents = array ( ) ; $ time = time ( ) ; 
public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; 
protected function addEvent ( $ objEvent , $ intStart , $ intEnd , $ strUrl , $ strBase = '' ) { if ( $ intEnd < time ( ) ) 
public static function unixToJd ( $ tstamp ) { list ( $ year , $ month , $ day ) = explode ( ',' , date ( 'Y,m,d' , $ tstamp ) ) ; 
protected function sortOutProtected ( $ arrArchives ) { if ( empty ( $ arrArchives ) || ! \ is_array ( $ arrArchives ) ) { return $ arrArchives ; } $ this -> import ( FrontendUser :: class , 'User' ) ; $ objArchive = NewsArchiveModel :: findMultipleByIds ( $ arrArchives ) ; $ arrArchives = array ( ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { if ( $ objArchive -> protected ) { if ( ! FE_USER_LOGGED_IN || ! \ is_array ( $ this -> User -> groups ) ) { continue ; } $ groups = StringUtil :: deserialize ( $ objArchive -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) || ! \ count ( array_intersect ( $ groups , $ this -> User -> groups ) ) ) { continue ; } } $ arrArchives [ ] = $ objArchive -> id ; } } return $ arrArchives ; } 
protected function parseArticle ( $ objArticle , $ blnAddArchive = false , $ strClass = '' , $ intCount = 0 ) { $ objTemplate = new FrontendTemplate ( $ this -> news_template ) ; $ objTemplate -> setData ( $ objArticle -> row ( ) ) ; if ( $ objArticle -> cssClass != '' ) { $ strClass = ' ' . $ objArticle -> cssClass . $ strClass ; } if ( $ objArticle -> featured ) { $ strClass = ' featured' . $ strClass ; } $ objTemplate -> class = $ strClass ; $ objTemplate -> newsHeadline = $ objArticle -> headline ; $ objTemplate -> subHeadline = $ objArticle -> subheadline ; $ objTemplate -> hasSubHeadline = $ objArticle -> subheadline ? true : false ; $ objTemplate -> linkHeadline = $ this -> generateLink ( $ objArticle -> headline , $ objArticle , $ blnAddArchive ) ; $ objTemplate -> more = $ this -> generateLink ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'more' ] , $ objArticle , $ blnAddArchive , true ) ; $ objTemplate -> link = News :: generateNewsUrl ( $ objArticle , $ blnAddArchive ) ; $ objTemplate -> archive = $ objArticle -> getRelated ( 'pid' ) ; $ objTemplate -> count = $ intCount ; 
protected function parseArticles ( $ objArticles , $ blnAddArchive = false ) { $ limit = $ objArticles -> count ( ) ; if ( $ limit < 1 ) { return array ( ) ; } $ count = 0 ; $ arrArticles = array ( ) ; while ( $ objArticles -> next ( ) ) { $ objArticle = $ objArticles -> current ( ) ; $ arrArticles [ ] = $ this -> parseArticle ( $ objArticle , $ blnAddArchive , ( ( ++ $ count == 1 ) ? ' first' : '' ) . ( ( $ count == $ limit ) ? ' last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' odd' : ' even' ) , $ count ) ; } return $ arrArticles ; } 
protected function getMetaFields ( $ objArticle ) { $ meta = StringUtil :: deserialize ( $ this -> news_metaFields ) ; if ( ! \ is_array ( $ meta ) ) { return array ( ) ; } global $ objPage ; $ return = array ( ) ; foreach ( $ meta as $ field ) { switch ( $ field ) { case 'date' : $ return [ 'date' ] = Date :: parse ( $ objPage -> datimFormat , $ objArticle -> date ) ; break ; case 'author' : if ( ( $ objAuthor = $ objArticle -> getRelated ( 'author' ) ) instanceof UserModel ) { $ return [ 'author' ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'by' ] . ' <span itemprop="author">' . $ objAuthor -> name . '</span>' ; } break ; case 'comments' : if ( $ objArticle -> noComments || $ objArticle -> source != 'default' ) { break ; } $ bundles = System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { break ; } $ intTotal = CommentsModel :: countPublishedBySourceAndParent ( 'tl_news' , $ objArticle -> id ) ; $ return [ 'ccount' ] = $ intTotal ; $ return [ 'comments' ] = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'commentCount' ] , $ intTotal ) ; break ; } } return $ return ; } 
protected function generateNewsUrl ( $ objItem , $ blnAddArchive = false ) { @ trigger_error ( 'Using ModuleNews::generateNewsUrl() has been deprecated and will no longer work in Contao 5.0. Use News::generateNewsUrl() instead.' , E_USER_DEPRECATED ) ; return News :: generateNewsUrl ( $ objItem , $ blnAddArchive ) ; } 
protected function generateLink ( $ strLink , $ objArticle , $ blnAddArchive = false , $ blnIsReadMore = false ) { 
public function process ( ContainerBuilder $ container ) : void { if ( ! $ container -> has ( 'contao.picker.builder' ) ) { return ; } $ definition = $ container -> findDefinition ( 'contao.picker.builder' ) ; $ references = $ this -> findAndSortTaggedServices ( 'contao.picker_provider' , $ container ) ; foreach ( $ references as $ reference ) { $ definition -> addMethodCall ( 'addProvider' , [ $ reference ] ) ; } } 
public function run ( ) : void { $ crop = $ GLOBALS [ 'TL_CROP' ] ; if ( empty ( $ crop ) ) { return ; } $ options = [ ] ; foreach ( $ crop as $ group => $ modes ) { $ options [ ] = array_values ( $ modes ) ; } if ( ! empty ( $ options ) ) { $ options = array_merge ( ... $ options ) ; } $ rows = $ this -> connection -> fetchAll ( ' SELECT id FROM tl_image_size ' ) ; foreach ( $ rows as $ imageSize ) { $ options [ ] = $ imageSize [ 'id' ] ; } ALTER TABLE tl_user ADD imageSizes blob NULL ' ) ; $ this -> connection -> query ( ' ALTER TABLE tl_user_group ADD imageSizes blob NULL ' ) ; // Grant access to all existing image sizes at group level $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_user_group SET imageSizes = :options ' ) ; $ stmt -> execute ( [ ':options' => serialize ( $ options ) ] ) ; } 
public function render ( $ uri , $ renderer = 'inline' , array $ options = [ ] ) : ? string { if ( ! $ uri instanceof FragmentReference ) { return $ this -> fragmentHandler -> render ( $ uri , $ renderer , $ options ) ; } $ config = $ this -> fragmentRegistry -> get ( $ uri -> controller ) ; if ( null === $ config ) { throw new UnknownFragmentException ( sprintf ( 'Invalid fragment identifier "%s"' , $ uri -> controller ) ) ; } $ this -> preHandleFragment ( $ uri , $ config ) ; $ renderer = $ config -> getRenderer ( ) ; if ( ! isset ( $ this -> initialized [ $ renderer ] ) && $ this -> renderers -> has ( $ renderer ) ) { $ this -> addRenderer ( $ this -> renderers -> get ( $ renderer ) ) ; $ this -> initialized [ $ renderer ] = true ; } return parent :: render ( $ uri , $ renderer , $ config -> getOptions ( ) ) ; } 
protected function deliver ( Response $ response ) : ? string { try { return parent :: deliver ( $ response ) ; } catch ( \ RuntimeException $ e ) { throw new ResponseException ( $ response , $ e ) ; } } 
private function preHandleFragment ( FragmentReference $ uri , FragmentConfig $ config ) : void { if ( ! isset ( $ uri -> attributes [ 'pageModel' ] ) && $ this -> hasGlobalPageObject ( ) ) { $ uri -> attributes [ 'pageModel' ] = $ GLOBALS [ 'objPage' ] -> id ; } if ( $ this -> preHandlers -> has ( $ uri -> controller ) ) { $ preHandler = $ this -> preHandlers -> get ( $ uri -> controller ) ; $ preHandler -> preHandleFragment ( $ uri , $ config ) ; } } 
public function generate ( $ rootPageId , $ blnReturn = false , $ blnPreferAlias = false ) { if ( ! $ blnReturn ) { $ this -> redirect ( $ this -> getRedirectUrl ( $ rootPageId ) , 302 ) ; } $ objNextPage = $ this -> getNextPage ( $ rootPageId ) ; return ( $ blnPreferAlias && $ objNextPage -> alias != '' ) ? $ objNextPage -> alias : $ objNextPage -> id ; } 
protected function getNextPage ( $ rootPageId ) { $ objNextPage = PageModel :: findFirstPublishedByPid ( $ rootPageId ) ; 
protected function getOptions ( ) { $ arrOptions = array ( ) ; $ blnHasGroups = false ; foreach ( $ this -> arrOptions as $ i => $ arrOption ) { if ( $ arrOption [ 'group' ] ) { if ( $ blnHasGroups ) { $ arrOptions [ ] = array ( 'type' => 'group_end' ) ; } $ arrOptions [ ] = array ( 'type' => 'group_start' , 'label' => StringUtil :: specialchars ( $ arrOption [ 'label' ] ) ) ; $ blnHasGroups = true ; } else { $ arrOptions [ ] = array_replace ( $ arrOption , array ( 'type' => 'option' , 'name' => $ this -> strName , 'id' => $ this -> strId . '_' . $ i , 'value' => $ arrOption [ 'value' ] , 'checked' => $ this -> isChecked ( $ arrOption ) , 'attributes' => $ this -> getAttributes ( ) , 'label' => $ arrOption [ 'label' ] ) ) ; } } if ( $ blnHasGroups ) { $ arrOptions [ ] = array ( 'type' => 'group_end' ) ; } return $ arrOptions ; } 
public function generate ( ) { $ strOptions = '' ; foreach ( $ this -> arrOptions as $ i => $ arrOption ) { $ strOptions .= sprintf ( '<span><input type="radio" name="%s" id="opt_%s" class="radio" value="%s"%s%s%s <label id="lbl_%s" for="opt_%s">%s</label></span> ' , $ this -> strName , $ this -> strId . '_' . $ i , $ arrOption [ 'value' ] , $ this -> isChecked ( $ arrOption ) , $ this -> getAttributes ( ) , $ this -> strTagEnding , $ this -> strId . '_' . $ i , $ this -> strId . '_' . $ i , $ arrOption [ 'label' ] ) ; } if ( $ this -> strLabel != '' ) { return sprintf ( '<fieldset id="ctrl_%s" class="radio_container%s"><legend>%s%s%s</legend>%s<input type="hidden" name="%s" value=""%s%s</fieldset>' , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , ( $ this -> mandatory ? '<span class="invisible">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mandatory' ] . ' </span>' : '' ) , $ this -> strLabel , ( $ this -> mandatory ? '<span class="mandatory">*</span>' : '' ) , $ this -> strError , $ this -> strName , $ this -> strTagEnding , $ strOptions ) ; } else { return sprintf ( '<fieldset id="ctrl_%s" class="radio_container%s">%s<input type="hidden" name="%s" value=""%s%s</fieldset>' , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , $ this -> strError , $ this -> strName , $ this -> strTagEnding , $ strOptions ) ; } } 
public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'trans' !== $ chunks [ 0 ] ) { return false ; } $ parameters = isset ( $ chunks [ 3 ] ) ? explode ( ':' , $ chunks [ 3 ] ) : [ ] ; return $ this -> translator -> trans ( $ chunks [ 1 ] , $ parameters , $ chunks [ 2 ] ?? null ) ; } 
public function confirm ( ) : void { if ( $ this -> isConfirmed ( ) ) { throw new OptInTokenAlreadyConfirmedException ( ) ; } if ( ! $ this -> isValid ( ) ) { throw new OptInTokenNoLongerValidException ( ) ; } $ this -> model -> tstamp = time ( ) ; $ this -> model -> confirmedOn = time ( ) ; $ this -> model -> removeOn = strtotime ( '+3 years' ) ; $ this -> model -> save ( ) ; $ related = $ this -> model -> getRelatedRecords ( ) ; if ( empty ( $ related ) ) { return ; } $ adapter = $ this -> framework -> getAdapter ( OptInModel :: class ) ; $ prefix = strtok ( $ this -> getIdentifier ( ) , '-' ) ; 
public function send ( string $ subject = null , string $ text = null ) : void { if ( $ this -> isConfirmed ( ) ) { throw new OptInTokenAlreadyConfirmedException ( ) ; } if ( ! $ this -> isValid ( ) ) { throw new OptInTokenNoLongerValidException ( ) ; } if ( ! $ this -> hasBeenSent ( ) ) { if ( null === $ subject || null === $ text ) { throw new \ LogicException ( 'Please provide subject and text to send the token' ) ; } $ this -> model -> emailSubject = $ subject ; $ this -> model -> emailText = $ text ; $ this -> model -> save ( ) ; } $ email = $ this -> framework -> createInstance ( Email :: class ) ; $ email -> subject = $ this -> model -> emailSubject ; $ email -> text = $ this -> model -> emailText ; $ email -> sendTo ( $ this -> model -> email ) ; } 
public static function findCurrentByPid ( $ intPid , $ intStart , $ intEnd , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ intStart = ( int ) $ intStart ; $ intEnd = ( int ) $ intEnd ; $ arrColumns = array ( "$t.pid=? AND (($t.startTime>=$intStart AND $t.startTime<=$intEnd) OR ($t.endTime>=$intStart AND $t.endTime<=$intEnd) OR ($t.startTime<=$intStart AND $t.endTime>=$intEnd) OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$intStart) AND $t.startTime<=$intEnd))" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; } 
public static function findUpcomingByPids ( $ arrIds , $ intLimit = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; 
public function generate ( $ objPage , $ blnCheckRequest = false ) { $ this -> prepare ( $ objPage ) ; $ this -> Template -> output ( $ blnCheckRequest ) ; } 
public function getResponse ( $ objPage , $ blnCheckRequest = false ) { $ this -> prepare ( $ objPage ) ; return $ this -> Template -> getResponse ( $ blnCheckRequest ) ; } 
protected function prepare ( $ objPage ) { $ GLOBALS [ 'TL_KEYWORDS' ] = '' ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ objPage -> language ; $ locale = str_replace ( '-' , '_' , $ objPage -> language ) ; $ container = System :: getContainer ( ) ; $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> setLocale ( $ locale ) ; $ container -> get ( 'translator' ) -> setLocale ( $ locale ) ; System :: loadLanguageFile ( 'default' ) ; 
protected function getPageLayout ( $ objPage ) { $ objLayout = LayoutModel :: findByPk ( $ objPage -> layout ) ; 
protected function createTemplate ( $ objPage , $ objLayout ) { $ this -> Template = new FrontendTemplate ( $ objPage -> template ) ; $ this -> Template -> viewport = '' ; $ this -> Template -> framework = '' ; $ arrFramework = StringUtil :: deserialize ( $ objLayout -> framework ) ; 
protected function createHeaderScripts ( $ objPage , $ objLayout ) { $ strStyleSheets = '' ; $ strCcStyleSheets = '' ; $ arrStyleSheets = StringUtil :: deserialize ( $ objLayout -> stylesheet ) ; $ arrFramework = StringUtil :: deserialize ( $ objLayout -> framework ) ; 
protected function createFooterScripts ( $ objLayout ) { $ strScripts = '' ; 
public function mkdir ( $ strDirectory ) { $ this -> validate ( $ strDirectory ) ; if ( file_exists ( $ this -> strRootDir . '/' . $ strDirectory ) ) { return true ; } return mkdir ( $ this -> strRootDir . '/' . $ strDirectory ) ; } 
public function rmdir ( $ strDirectory ) { $ this -> validate ( $ strDirectory ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ strDirectory ) ) { return true ; } return rmdir ( $ this -> strRootDir . '/' . $ strDirectory ) ; } 
public function rrdir ( $ strFolder , $ blnPreserveRoot = false ) { $ this -> validate ( $ strFolder ) ; $ arrFiles = scan ( $ this -> strRootDir . '/' . $ strFolder , true ) ; foreach ( $ arrFiles as $ strFile ) { if ( is_link ( $ this -> strRootDir . '/' . $ strFolder . '/' . $ strFile ) ) { $ this -> delete ( $ strFolder . '/' . $ strFile ) ; } elseif ( is_dir ( $ this -> strRootDir . '/' . $ strFolder . '/' . $ strFile ) ) { $ this -> rrdir ( $ strFolder . '/' . $ strFile ) ; } else { $ this -> delete ( $ strFolder . '/' . $ strFile ) ; } } if ( ! $ blnPreserveRoot ) { $ this -> rmdir ( $ strFolder ) ; } } 
public function fopen ( $ strFile , $ strMode ) { $ this -> validate ( $ strFile ) ; return fopen ( $ this -> strRootDir . '/' . $ strFile , $ strMode ) ; } 
public function rename ( $ strOldName , $ strNewName ) { 
public function copy ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; return copy ( $ this -> strRootDir . '/' . $ strSource , $ this -> strRootDir . '/' . $ strDestination ) ; } 
public function rcopy ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; $ this -> mkdir ( $ strDestination ) ; $ arrFiles = scan ( $ this -> strRootDir . '/' . $ strSource , true ) ; foreach ( $ arrFiles as $ strFile ) { if ( is_dir ( $ this -> strRootDir . '/' . $ strSource . '/' . $ strFile ) ) { $ this -> rcopy ( $ strSource . '/' . $ strFile , $ strDestination . '/' . $ strFile ) ; } else { $ this -> copy ( $ strSource . '/' . $ strFile , $ strDestination . '/' . $ strFile ) ; } } } 
public function chmod ( $ strFile , $ varMode ) { $ this -> validate ( $ strFile ) ; return chmod ( $ this -> strRootDir . '/' . $ strFile , $ varMode ) ; } 
public function move_uploaded_file ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; return move_uploaded_file ( $ strSource , $ this -> strRootDir . '/' . $ strDestination ) ; } 
protected function validate ( ) { foreach ( \ func_get_args ( ) as $ strPath ) { if ( $ strPath == '' ) 
public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( $ request -> isMethod ( 'POST' ) ) { return ; } if ( null === ( $ session = $ request -> getSession ( ) ) || ! $ session -> isStarted ( ) ) { return ; } $ this -> clearLegacyAttributeBags ( 'FE_DATA' ) ; $ this -> clearLegacyAttributeBags ( 'BE_DATA' ) ; $ this -> clearLegacyFormData ( ) ; } 
public function listNewsletters ( $ arrRow ) { return ' <div class="cte_type ' . ( ( $ arrRow [ 'sent' ] && $ arrRow [ 'date' ] ) ? 'published' : 'unpublished' ) . '"><strong>' . $ arrRow [ 'subject' ] . '</strong> - ' . ( ( $ arrRow [ 'sent' ] && $ arrRow [ 'date' ] ) ? sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'sentOn' ] , Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ arrRow [ 'date' ] ) ) : $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'notSent' ] ) . '</div> <div class="limit_height' . ( ! Contao \ Config :: get ( 'doNotCollapse' ) ? ' h85' : '' ) . '">' . ( ! $ arrRow [ 'sendText' ] ? ' ' . Contao \ StringUtil :: insertTagToSrc ( $ arrRow [ 'content' ] ) . '<hr>' : '' ) . ' <pre style="white-space:pre-wrap">' . $ arrRow [ 'text' ] . '</pre> </div>' . "\n" ; } 
public function addSenderPlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT sender FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> sender ; } return $ varValue ; } 
public function addSenderNamePlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT senderName FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> senderName ; } return $ varValue ; } 
public function loadUserByUsername ( $ username ) : User { $ this -> framework -> initialize ( ) ; $ adapter = $ this -> framework -> getAdapter ( $ this -> userClass ) ; $ user = $ adapter -> loadUserByUsername ( $ username ) ; if ( is_a ( $ user , $ this -> userClass ) ) { return $ user ; } throw new UsernameNotFoundException ( sprintf ( 'Could not find user "%s"' , $ username ) ) ; } 
public function refreshUser ( UserInterface $ user ) { if ( ! is_a ( $ user , $ this -> userClass ) ) { throw new UnsupportedUserException ( sprintf ( 'Unsupported class "%s".' , \ get_class ( $ user ) ) ) ; } $ user = $ this -> loadUserByUsername ( $ user -> getUsername ( ) ) ; $ this -> validateSessionLifetime ( $ user ) ; $ this -> triggerPostAuthenticateHook ( $ user ) ; return $ user ; } 
private function validateSessionLifetime ( User $ user ) : void { if ( ! $ this -> session -> isStarted ( ) ) { return ; } $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ timeout = ( int ) $ config -> get ( 'sessionTimeout' ) ; if ( $ timeout > 0 && ( time ( ) - $ this -> session -> getMetadataBag ( ) -> getLastUsed ( ) ) < $ timeout ) { return ; } if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has been logged out automatically due to inactivity' , $ user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ user -> username ) ] ) ; } throw new UsernameNotFoundException ( sprintf ( 'User "%s" has been logged out automatically due to inactivity.' , $ user -> username ) ) ; } 
public function generate ( ) { $ this -> Template = new BackendTemplate ( $ this -> strTemplate ) ; $ this -> compile ( ) ; return $ this -> Template -> parse ( ) ; } 
public function unserialize ( $ str ) : void { [ $ this -> lockedSeconds , $ parentData ] = unserialize ( $ str , [ 'allowed_classes' => true ] ) ; parent :: unserialize ( $ parentData ) ; } 
public function generate ( ) { 
protected function compile ( ) { $ images = array ( ) ; $ auxDate = array ( ) ; $ objFiles = $ this -> objFiles ; 
public function maintenanceCheck ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> hasAccess ( 'maintenance' , 'modules' ) ) { return '' ; } try { if ( System :: getContainer ( ) -> get ( 'lexik_maintenance.driver.factory' ) -> getDriver ( ) -> isExists ( ) ) { return '<p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'maintenanceEnabled' ] . '</p>' ; } } catch ( \ Exception $ e ) { 
public function languageFallback ( ) { $ arrRoots = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objRoots = $ this -> Database -> execute ( "SELECT fallback, dns FROM tl_page WHERE type='root' AND (start='' OR start<='$time') AND (stop='' OR stop>'" . ( $ time + 60 ) . "') AND published='1' ORDER BY dns" ) ; while ( $ objRoots -> next ( ) ) { $ strDns = $ objRoots -> dns ? : '*' ; if ( isset ( $ arrRoots [ $ strDns ] ) && $ arrRoots [ $ strDns ] == 1 ) { continue ; } $ arrRoots [ $ strDns ] = $ objRoots -> fallback ; } $ arrReturn = array ( ) ; foreach ( $ arrRoots as $ k => $ v ) { if ( $ v != '' ) { continue ; } if ( $ k == '*' ) { $ arrReturn [ ] = '<p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noFallbackEmpty' ] . '</p>' ; } else { $ arrReturn [ ] = '<p class="tl_error">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noFallbackDns' ] , $ k ) . '</p>' ; } } return implode ( "\n" , $ arrReturn ) ; } 
public function initialize ( bool $ isFrontend = false ) : void { if ( $ this -> isInitialized ( ) ) { return ; } 
public function createInstance ( $ class , $ args = [ ] ) { if ( \ in_array ( 'getInstance' , get_class_methods ( $ class ) , true ) ) { return \ call_user_func_array ( [ $ class , 'getInstance' ] , $ args ) ; } $ reflection = new \ ReflectionClass ( $ class ) ; return $ reflection -> newInstanceArgs ( $ args ) ; } 
public function getAdapter ( $ class ) : Adapter { if ( ! isset ( $ this -> adapterCache [ $ class ] ) ) { $ this -> adapterCache [ $ class ] = new Adapter ( $ class ) ; } return $ this -> adapterCache [ $ class ] ; } 
private function initializeLegacySessionAccess ( ) : void { if ( ! $ session = $ this -> getSession ( ) ) { return ; } if ( ! $ session -> isStarted ( ) ) { $ _SESSION = new LazySessionAccess ( $ session ) ; } else { $ _SESSION [ 'BE_DATA' ] = $ session -> getBag ( 'contao_backend' ) ; $ _SESSION [ 'FE_DATA' ] = $ session -> getBag ( 'contao_frontend' ) ; } } 
public function load ( $ file , $ type = null ) : string { [ $ code , $ namespace ] = $ this -> parseFile ( ( string ) $ file ) ; $ code = $ this -> stripLegacyCheck ( $ code ) ; if ( false !== $ namespace && 'namespaced' === $ type ) { $ code = sprintf ( "\nnamespace %s {%s}\n" , $ namespace , $ code ) ; } return $ code ; } 
private function parseFile ( string $ file ) : array { $ code = '' ; $ namespace = '' ; $ buffer = false ; $ stream = new \ PHP_Token_Stream ( $ file ) ; foreach ( $ stream as $ token ) { switch ( true ) { case $ token instanceof \ PHP_Token_OPEN_TAG : case $ token instanceof \ PHP_Token_CLOSE_TAG : 
public function getOptions ( Request $ request ) : array { if ( ! $ this -> isCorsRequest ( $ request ) || ! $ this -> canRunDbQuery ( ) ) { return [ ] ; } $ stmt = $ this -> connection -> prepare ( " SELECT EXISTS ( SELECT id FROM tl_page WHERE type = 'root' AND dns = :dns ) " ) ; $ stmt -> bindValue ( 'dns' , preg_replace ( '@^https?://@' , '' , $ request -> headers -> get ( 'origin' ) ) ) ; $ stmt -> execute ( ) ; if ( ! $ stmt -> fetchColumn ( ) ) { return [ ] ; } return [ 'allow_origin' => true , 'allow_methods' => [ 'HEAD' , 'GET' ] , 'allow_headers' => [ 'x-requested-with' ] , ] ; } 
private function isCorsRequest ( Request $ request ) : bool { return $ request -> headers -> has ( 'Origin' ) && $ request -> headers -> get ( 'Origin' ) !== $ request -> getSchemeAndHttpHost ( ) ; } 
public function generate ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; $ this -> convertValuesToPaths ( ) ; if ( $ this -> extensions != '' ) { $ this -> arrValidFileTypes = StringUtil :: trimsplit ( ',' , strtolower ( $ this -> extensions ) ) ; } $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; <li class="tl_folder_top"><div class="tl_left">' . Image :: getHtml ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_files' ] [ 'list' ] [ 'sorting' ] [ 'icon' ] ? : 'filemounts.svg' ) . ' ' . $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ 'files' ] [ 0 ] . '</div> <div class="tl_right">&nbsp;</div><div style="clear:both"></div></li><li class="parent" id="' . $ this -> strId . '_parent"><ul>' . $ tree . $ strReset . ' </ul></li></ul>' ; } 
public function generateAjax ( $ strFolder , $ strField , $ level , $ mount = false ) { if ( ! Environment :: get ( 'isAjaxRequest' ) ) { return '' ; } $ this -> strField = $ strField ; $ this -> loadDataContainer ( $ this -> strTable ) ; 
protected function renderFiletree ( $ path , $ intMargin , $ mount = false , $ blnProtected = true , $ arrFound = array ( ) ) { 
protected function convertValuesToPaths ( ) { if ( empty ( $ this -> varValue ) ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } elseif ( empty ( $ this -> varValue [ 0 ] ) ) { $ this -> varValue = array ( ) ; } if ( empty ( $ this -> varValue ) ) { return ; } 
protected function isProtectedPath ( $ path ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; do { if ( file_exists ( $ rootDir . '/' . $ path . '/.public' ) ) { return false ; } $ path = \ dirname ( $ path ) ; } while ( $ path != '.' ) ; return true ; } 
public function process ( ContainerBuilder $ container ) : void { if ( ! $ container -> hasDefinition ( 'assets.packages' ) ) { return ; } $ this -> addBundles ( $ container ) ; $ this -> addComponents ( $ container ) ; } 
private function addBundles ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; if ( $ container -> hasDefinition ( 'assets._version_default' ) ) { $ version = new Reference ( 'assets._version_default' ) ; } else { $ version = new Reference ( 'assets.empty_version_strategy' ) ; } $ bundles = $ container -> getParameter ( 'kernel.bundles' ) ; $ meta = $ container -> getParameter ( 'kernel.bundles_metadata' ) ; foreach ( $ bundles as $ name => $ class ) { if ( ! is_dir ( $ meta [ $ name ] [ 'path' ] . '/Resources/public' ) ) { continue ; } $ packageVersion = $ version ; $ packageName = $ this -> getBundlePackageName ( $ name ) ; $ serviceId = 'assets._package_' . $ packageName ; $ basePath = 'bundles/' . preg_replace ( '/bundle$/' , '' , strtolower ( $ name ) ) ; if ( is_file ( $ meta [ $ name ] [ 'path' ] . '/Resources/public/manifest.json' ) ) { $ def = new ChildDefinition ( 'assets.json_manifest_version_strategy' ) ; $ def -> replaceArgument ( 0 , $ meta [ $ name ] [ 'path' ] . '/Resources/public/manifest.json' ) ; $ container -> setDefinition ( 'assets._version_' . $ packageName , $ def ) ; $ packageVersion = new Reference ( 'assets._version_' . $ packageName ) ; } $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ packageVersion , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ packageName , new Reference ( $ serviceId ) ] ) ; } } 
private function addComponents ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; foreach ( Versions :: VERSIONS as $ name => $ version ) { if ( 0 !== strncmp ( 'contao-components/' , $ name , 18 ) ) { continue ; } $ serviceId = 'assets._package_' . $ name ; $ basePath = 'assets/' . substr ( $ name , 18 ) ; $ version = $ this -> createVersionStrategy ( $ container , $ version , $ name ) ; $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ version , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ name , new Reference ( $ serviceId ) ] ) ; } } 
private function getBundlePackageName ( string $ className ) : string { if ( 'Bundle' === substr ( $ className , - 6 ) ) { $ className = substr ( $ className , 0 , - 6 ) ; } return Container :: underscore ( $ className ) ; } 
public function showAll ( ) { $ return = '' ; $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ objSessionBag = $ objSession -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; <div id="tl_buttons">' . ( ( Input :: get ( 'act' ) == 'select' ) ? ' <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> ' : '' ) . ( ( Input :: get ( 'act' ) != 'select' && ! $ blnClipboard && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'closed' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] ) ? ' <a href="' . $ this -> addToUrl ( $ hrfNew ) . '" class="' . $ clsNew . '" title="' . StringUtil :: specialchars ( $ ttlNew ) . '" accesskey="n" onclick="Backend.getScrollOffset()">' . $ lblNew . '</a> <a href="' . $ this -> addToUrl ( '&amp;act=paste&amp;mode=move' ) . '" class="header_new" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'move' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'move' ] [ 0 ] . '</a> ' : '' ) . ( $ blnClipboard ? ' <a href="' . $ this -> addToUrl ( 'clipboard=1' ) . '" class="header_clipboard" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'clearClipboard' ] ) . '" accesskey="x">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'clearClipboard' ] . '</a> ' : $ this -> generateGlobalButtons ( ) ) . ' </div>' . ( ( Input :: get ( 'act' ) == 'select' ) ? ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_select" class="tl_form tl_edit_form' . ( ( Input :: get ( 'act' ) == 'select' ) ? ' unselectable' : '' ) . '" method="post" novalidate> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="tl_select"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' : '' ) . ( $ blnClipboard ? ' <div id="paste_hint"> <p>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectNewPosition' ] . '</p> </div>' : '' ) . ' <div class="tl_listing_container tree_view" id="tl_listing">' . ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'breadcrumb' ] ?? '' ) . ( ( Input :: get ( 'act' ) == 'select' || $ this -> strPickerFieldType == 'checkbox' ) ? ' <div class="tl_select_trigger"> <label for="tl_select_trigger" class="tl_select_label">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</label> <input type="checkbox" id="tl_select_trigger" onclick="Backend.toggleCheckboxes(this)" class="tl_tree_checkbox"> </div>' : '' ) . ' <ul class="tl_listing tl_file_manager' . ( $ this -> strPickerFieldType ? ' picker unselectable' : '' ) . '"> <li class="tl_folder_top cf"><div class="tl_left">' . $ label . '</div> <div class="tl_right">' . ( ( $ blnClipboard && empty ( $ this -> arrFilemounts ) && ! \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'root' ] ) && $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'root' ] !== false ) ? '<a href="' . $ this -> addToUrl ( '&amp;act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=2&amp;pid=' . Config :: get ( 'uploadPath' ) . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pasteinto' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteInto . '</a>' : '&nbsp;' ) . '</div></li>' . $ return . ' </ul>' . ( $ this -> strPickerFieldType == 'radio' ? ' <div class="tl_radio_reset"> <label for="tl_radio_reset" class="tl_radio_label">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resetSelected' ] . '</label> <input type="radio" name="picker" id="tl_radio_reset" value="" class="tl_tree_radio"> </div>' : '' ) . ' </div>' ; // Close the form if ( Input :: get ( 'act' ) == 'select' ) { // Submit buttons $ arrButtons = array ( ) ; if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notEditable' ] ) { $ arrButtons [ 'edit' ] = '<button type="submit" name="edit" id="edit" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editSelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { $ arrButtons [ 'delete' ] = '<button type="submit" name="delete" id="delete" class="tl_submit" accesskey="d" onclick="return confirm(\'' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'delAllConfirmFile' ] . '\')">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'deleteSelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notSortable' ] ) { $ arrButtons [ 'cut' ] = '<button type="submit" name="cut" id="cut" class="tl_submit" accesskey="x">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'moveSelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { $ arrButtons [ 'copy' ] = '<button type="submit" name="copy" id="copy" class="tl_submit" accesskey="c">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'copySelected' ] . '</button>' ; } // Call the buttons_callback (see #4691) if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'select' ] [ 'buttons_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'select' ] [ 'buttons_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ arrButtons = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ arrButtons , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ arrButtons = $ callback ( $ arrButtons , $ this ) ; } } } if ( \ count ( $ arrButtons ) < 3 ) { $ strButtons = implode ( ' ' , $ arrButtons ) ; } else { $ strButtons = array_shift ( $ arrButtons ) . ' ' ; $ strButtons .= '<div class="split-button">' ; $ strButtons .= array_shift ( $ arrButtons ) . '<button type="button" id="sbtog">' . Image :: getHtml ( 'navcol.svg' ) . '</button> <ul class="invisible">' ; foreach ( $ arrButtons as $ strButton ) { $ strButtons .= '<li>' . $ strButton . '</li>' ; } $ strButtons .= '</ul></div>' ; } $ return .= ' </div> <div class="tl_formbody_submit" style="text-align:right"> <div class="tl_submit_container"> ' . $ strButtons . ' </div> </div> </form>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'closed' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] && Input :: get ( 'act' ) != 'select' ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'assets/dropzone/css/dropzone.min.css' ; $ GLOBALS [ 'TL_JAVASCRIPT' ] [ ] = 'assets/dropzone/js/dropzone.min.js' ; $ strAccepted = implode ( ',' , array_map ( function ( $ a ) { return '.' . $ a ; } , StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'uploadTypes' ) ) ) ) ) ; $ intMaxSize = round ( FileUpload :: getMaxUploadSize ( ) / 1024 / 1024 ) ; $ return .= '<script>' . 'Dropzone.autoDiscover = false;' . 'Backend.enableFileTreeUpload("tl_listing", ' . json_encode ( array ( 'url' => html_entity_decode ( $ this -> addToUrl ( 'act=move&mode=2&pid=' . urlencode ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'root' ] [ 0 ] ?? Config :: get ( 'uploadPath' ) ) ) ) , 'paramName' => 'files' , 'maxFilesize' => $ intMaxSize , 'acceptedFiles' => $ strAccepted , 'params' => array ( 'FORM_SUBMIT' => 'tl_upload' , 'action' => 'fileupload' , ) , ) ) . ')</script>' ; } $ return .= '<script>' . 'Backend.enableFileTreeDragAndDrop($("tl_listing").getChildren(".tl_file_manager")[0], ' . json_encode ( array ( 'url' => html_entity_decode ( $ this -> addToUrl ( 'act=cut&mode=2&pid=' . urlencode ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'root' ] [ 0 ] ?? Config :: get ( 'uploadPath' ) ) ) ) , ) ) . ')</script>' ; return $ return ; } 
public function create ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not creatable.' ) ; } $ this -> import ( Files :: class , 'Files' ) ; $ strFolder = Input :: get ( 'pid' , true ) ; if ( $ strFolder == '' || ! file_exists ( $ this -> strRootDir . '/' . $ strFolder ) || ! $ this -> isMounted ( $ strFolder ) ) { throw new AccessDeniedException ( 'Folder "' . $ strFolder . '" is not mounted or is not a directory.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; 
public function cut ( $ source = null ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notSortable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not sortable.' ) ; } $ strFolder = Input :: get ( 'pid' , true ) ; $ blnDoNotRedirect = ( $ source !== null ) ; if ( $ source === null ) { $ source = $ this -> intId ; } $ this -> isValid ( $ source ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ source ) || ! $ this -> isMounted ( $ source ) ) { throw new AccessDeniedException ( 'File or folder "' . $ source . '" is not mounted or cannot be found.' ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFolder ) || ! $ this -> isMounted ( $ strFolder ) ) { throw new AccessDeniedException ( 'Parent folder "' . $ strFolder . '" is not mounted or is not a directory.' ) ; } 
public function copy ( $ source = null , $ destination = null ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not copyable.' ) ; } $ strFolder = Input :: get ( 'pid' , true ) ; $ blnDoNotRedirect = ( $ source !== null ) ; if ( $ source === null ) { $ source = $ this -> intId ; } if ( $ destination === null ) { $ destination = str_replace ( \ dirname ( $ source ) , $ strFolder , $ source ) ; } $ this -> isValid ( $ source ) ; $ this -> isValid ( $ destination ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ source ) || ! $ this -> isMounted ( $ source ) ) { throw new AccessDeniedException ( 'File or folder "' . $ source . '" is not mounted or cannot be found.' ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFolder ) || ! $ this -> isMounted ( $ strFolder ) ) { throw new AccessDeniedException ( 'Parent folder "' . $ strFolder . '" is not mounted or is not a directory.' ) ; } 
public function delete ( $ source = null ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ blnDoNotRedirect = ( $ source !== null ) ; if ( $ source === null ) { $ source = $ this -> intId ; } $ this -> isValid ( $ source ) ; 
public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( ! empty ( $ ids ) && \ is_array ( $ ids ) ) { $ ids = $ this -> eliminateNestedPaths ( $ ids ) ; 
public function move ( $ blnIsAjax = false ) { $ strFolder = Input :: get ( 'pid' , true ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFolder ) || ! $ this -> isMounted ( $ strFolder ) ) { throw new AccessDeniedException ( 'Folder "' . $ strFolder . '" is not mounted or is not a directory.' ) ; } if ( ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFolder ) ) { throw new AccessDeniedException ( 'Parent folder "' . $ strFolder . '" is not within the files directory.' ) ; } <div id="tl_buttons"> <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div> <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="' . $ this -> strTable . '" class="tl_form tl_edit_form" method="post"' . ( ! empty ( $ this -> onsubmit ) ? ' onsubmit="' . implode ( ' ' , $ this -> onsubmit ) . '"' : '' ) . ' enctype="multipart/form-data"> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="tl_upload"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"> <input type="hidden" name="MAX_FILE_SIZE" value="' . Config :: get ( 'maxFileSize' ) . '"> <div class="tl_tbox"> <div class="widget"> <h3>' . $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'fileupload' ] [ 0 ] . '</h3>' . $ objUploader -> generateMarkup ( ) . ' </div> </div> </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> ' . $ strButtons . ' </div> </div> </form>' ; } 
public function edit ( ) { $ return = '' ; $ this -> noReload = false ; $ this -> isValid ( $ this -> intId ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> intId ) || ! $ this -> isMounted ( $ this -> intId ) ) { throw new AccessDeniedException ( 'File or folder "' . $ this -> intId . '" is not mounted or cannot be found.' ) ; } $ objModel = null ; $ objVersions = null ; <div class="' . $ class . ' cf">' ; // Build rows of the current box foreach ( $ v as $ vv ) { $ this -> strField = $ vv ; $ this -> strInputName = $ vv ; // Load the current value if ( $ vv == 'name' ) { $ objFile = is_dir ( $ this -> strRootDir . '/' . $ this -> intId ) ? new Folder ( $ this -> intId ) : new File ( $ this -> intId ) ; $ this -> strPath = StringUtil :: stripRootDir ( $ objFile -> dirname ) ; $ this -> strExtension = ( $ objFile -> origext != '' ) ? '.' . $ objFile -> origext : '' ; $ this -> varValue = $ objFile -> filename ; // Fix hidden Unix system files if ( strncmp ( $ this -> varValue , '.' , 1 ) === 0 ) { $ this -> strExtension = '' ; } // Clear the current value if it is a new folder if ( Input :: post ( 'FORM_SUBMIT' ) != 'tl_files' && Input :: post ( 'FORM_SUBMIT' ) != 'tl_templates' && $ this -> varValue == '__new__' ) { $ this -> varValue = '' ; } } else { $ this -> varValue = ( $ objModel !== null ) ? $ objModel -> $ vv : null ; } // Call load_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'load_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'load_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> varValue = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> varValue , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ this -> varValue = $ callback ( $ this -> varValue , $ this ) ; } } } // Build row $ return .= $ this -> row ( ) ; } $ class = 'tl_box' ; $ return .= ' <input type="hidden" name="FORM_FIELDS[]" value="' . StringUtil :: specialchars ( $ this -> strPalette ) . '"> </div>' ; } } // Versions overview if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'enableVersioning' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'hideVersionMenu' ] && $ this -> blnIsDbAssisted && Dbafs :: shouldBeSynchronized ( $ this -> intId ) ) { $ version = $ objVersions -> renderDropdown ( ) ; } else { $ version = '' ; } // Submit buttons $ arrButtons = array ( ) ; $ arrButtons [ 'save' ] = '<button type="submit" name="save" id="save" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'save' ] . '</button>' ; if ( ! Input :: get ( 'nb' ) ) { $ arrButtons [ 'saveNclose' ] = '<button type="submit" name="saveNclose" id="saveNclose" class="tl_submit" accesskey="c">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'saveNclose' ] . '</button>' ; } // Call the buttons_callback (see #4691) if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'edit' ] [ 'buttons_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'edit' ] [ 'buttons_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ arrButtons = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ arrButtons , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ arrButtons = $ callback ( $ arrButtons , $ this ) ; } } } if ( \ count ( $ arrButtons ) < 3 ) { $ strButtons = implode ( ' ' , $ arrButtons ) ; } else { $ strButtons = array_shift ( $ arrButtons ) . ' ' ; $ strButtons .= '<div class="split-button">' ; $ strButtons .= array_shift ( $ arrButtons ) . '<button type="button" id="sbtog">' . Image :: getHtml ( 'navcol.svg' ) . '</button> <ul class="invisible">' ; foreach ( $ arrButtons as $ strButton ) { $ strButtons .= '<li>' . $ strButton . '</li>' ; } $ strButtons .= '</ul></div>' ; } // Add the buttons and end the form $ return .= ' </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> ' . $ strButtons . ' </div> </div> </form>' ; // Begin the form (-> DO NOT CHANGE THIS ORDER -> this way the onsubmit attribute of the form can be changed by a field) $ return = $ version . Message :: generate ( ) . ( $ this -> noReload ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] . '</p>' : '' ) . ' <div id="tl_buttons"> <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div> <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="' . $ this -> strTable . '" class="tl_form tl_edit_form" method="post"' . ( ! empty ( $ this -> onsubmit ) ? ' onsubmit="' . implode ( ' ' , $ this -> onsubmit ) . '"' : '' ) . '> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="' . $ this -> strTable . '"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' . $ return ; // Reload the page to prevent _POST variables from being sent twice if ( Input :: post ( 'FORM_SUBMIT' ) == $ this -> strTable && ! $ this -> noReload ) { // Trigger the onsubmit_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onsubmit_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onsubmit_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ this ) ; } } } // Save the current version if ( $ this -> blnCreateNewVersion && $ objModel !== null ) { $ objVersions -> create ( ) ; // Call the onversion_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onversion_callback' ] ) ) { @ trigger_error ( 'Using the onversion_callback has been deprecated and will no longer work in Contao 5.0. Use the oncreate_version_callback instead.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onversion_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> strTable , $ objModel -> id , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ this -> strTable , $ objModel -> id , $ this ) ; } } } } // Set the current timestamp (-> DO NOT CHANGE THE ORDER version - timestamp) if ( $ this -> blnIsDbAssisted && $ objModel !== null ) { $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET tstamp=? WHERE id=?" ) -> execute ( time ( ) , $ objModel -> id ) ; } // Redirect if ( isset ( $ _POST [ 'saveNclose' ] ) ) { Message :: reset ( ) ; System :: setCookie ( 'BE_PAGE_OFFSET' , 0 , 0 ) ; $ this -> redirect ( $ this -> getReferer ( ) ) ; } // Reload if ( $ this -> blnIsDbAssisted && $ this -> objActiveRecord !== null ) { $ this -> redirect ( $ this -> addToUrl ( 'id=' . $ this -> urlEncode ( $ this -> objActiveRecord -> path ) ) ) ; } else { $ this -> redirect ( $ this -> addToUrl ( 'id=' . $ this -> urlEncode ( $ this -> strPath . '/' . $ this -> varValue ) . $ this -> strExtension ) ) ; } } // Set the focus if there is an error if ( $ this -> noReload ) { $ return .= ' <script> window.addEvent(\'domready\', function() { Backend.vScrollTo(($(\'' . $ this -> strTable . '\').getElement(\'label.error\').getPosition().y - 20)); }); </script>' ; } return $ return ; } 
public function editAll ( ) { $ return = '' ; if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notEditable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not editable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; <div class="' . $ class . '">' ; $ class = 'tl_box' ; $ formFields = array ( ) ; $ strHash = md5 ( $ id ) ; foreach ( $ this -> strPalette as $ v ) { // Check whether field is excluded if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'exclude' ] ) { continue ; } if ( ! \ in_array ( $ v , $ fields ) ) { continue ; } $ this -> strField = $ v ; $ this -> strInputName = $ v . '_' . $ strHash ; $ formFields [ ] = $ v . '_' . $ strHash ; // Load the current value if ( $ v == 'name' ) { $ objFile = is_dir ( $ this -> strRootDir . '/' . $ id ) ? new Folder ( $ id ) : new File ( $ id ) ; $ this -> strPath = StringUtil :: stripRootDir ( $ objFile -> dirname ) ; $ this -> strExtension = ( $ objFile -> origext != '' ) ? '.' . $ objFile -> origext : '' ; $ this -> varValue = $ objFile -> filename ; // Fix hidden Unix system files if ( strncmp ( $ this -> varValue , '.' , 1 ) === 0 ) { $ this -> strExtension = '' ; } } else { $ this -> varValue = ( $ objModel !== null ) ? $ objModel -> $ v : null ; } // Call load_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'load_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'load_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> varValue = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> varValue , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ this -> varValue = $ callback ( $ this -> varValue , $ this ) ; } } } // Build the current row $ return .= $ this -> row ( ) ; } // Close box $ return .= ' <input type="hidden" name="FORM_FIELDS_' . $ strHash . '[]" value="' . StringUtil :: specialchars ( implode ( ',' , $ formFields ) ) . '"> </div>' ; // Save the record if ( Input :: post ( 'FORM_SUBMIT' ) == $ this -> strTable && ! $ this -> noReload ) { // Call onsubmit_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onsubmit_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onsubmit_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ this ) ; } } } // Create a new version if ( $ this -> blnCreateNewVersion && $ objModel !== null ) { $ objVersions -> create ( ) ; // Call the onversion_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onversion_callback' ] ) ) { @ trigger_error ( 'Using the onversion_callback has been deprecated and will no longer work in Contao 5.0. Use the oncreate_version_callback instead.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onversion_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> strTable , $ objModel -> id , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ this -> strTable , $ objModel -> id , $ this ) ; } } } } // Set the current timestamp (-> DO NOT CHANGE ORDER version - timestamp) if ( $ this -> blnIsDbAssisted && $ objModel !== null ) { $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET tstamp=? WHERE id=?" ) -> execute ( time ( ) , $ objModel -> id ) ; } } } // Submit buttons $ arrButtons = array ( ) ; $ arrButtons [ 'save' ] = '<button type="submit" name="save" id="save" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'save' ] . '</button>' ; $ arrButtons [ 'saveNclose' ] = '<button type="submit" name="saveNclose" id="saveNclose" class="tl_submit" accesskey="c">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'saveNclose' ] . '</button>' ; // Call the buttons_callback (see #4691) if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'edit' ] [ 'buttons_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'edit' ] [ 'buttons_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ arrButtons = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ arrButtons , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ arrButtons = $ callback ( $ arrButtons , $ this ) ; } } } if ( \ count ( $ arrButtons ) < 3 ) { $ strButtons = implode ( ' ' , $ arrButtons ) ; } else { $ strButtons = array_shift ( $ arrButtons ) . ' ' ; $ strButtons .= '<div class="split-button">' ; $ strButtons .= array_shift ( $ arrButtons ) . '<button type="button" id="sbtog">' . Image :: getHtml ( 'navcol.svg' ) . '</button> <ul class="invisible">' ; foreach ( $ arrButtons as $ strButton ) { $ strButtons .= '<li>' . $ strButton . '</li>' ; } $ strButtons .= '</ul></div>' ; } // Add the form $ return = ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="' . $ this -> strTable . '" class="tl_form tl_edit_form" method="post"> <div class="tl_formbody_edit nogrid"> <input type="hidden" name="FORM_SUBMIT" value="' . $ this -> strTable . '"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' . ( $ this -> noReload ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] . '</p>' : '' ) . $ return . ' </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> ' . $ strButtons . ' </div> </div> </form>' ; // Set the focus if there is an error if ( $ this -> noReload ) { $ return .= ' <script> window.addEvent(\'domready\', function() { Backend.vScrollTo(($(\'' . $ this -> strTable . '\').getElement(\'label.error\').getPosition().y - 20)); }); </script>' ; } // Reload the page to prevent _POST variables from being sent twice if ( Input :: post ( 'FORM_SUBMIT' ) == $ this -> strTable && ! $ this -> noReload ) { if ( isset ( $ _POST [ 'saveNclose' ] ) ) { System :: setCookie ( 'BE_PAGE_OFFSET' , 0 , 0 ) ; $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ this -> reload ( ) ; } } // Else show a form to select the fields else { $ options = '' ; $ fields = array ( ) ; // Add fields of the current table $ fields = array_merge ( $ fields , array_keys ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] ) ) ; // Show all non-excluded fields foreach ( $ fields as $ field ) { if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'exclude' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'eval' ] [ 'doNotShow' ] && ( \ strlen ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'inputType' ] ) || \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'input_field_callback' ] ) ) ) { $ options .= ' <input type="checkbox" name="all_fields[]" id="all_' . $ field . '" class="tl_checkbox" value="' . StringUtil :: specialchars ( $ field ) . '"> <label for="all_' . $ field . '" class="tl_checkbox_label">' . ( ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'label' ] [ 0 ] ? : ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ field ] [ 0 ] ? : $ field ) ) . ' <span style="color:#999;padding-left:3px">[' . $ field . ']</span>' ) . '</label><br>' ; } } $ blnIsError = ( $ _POST && empty ( $ _POST [ 'all_fields' ] ) ) ; // Return the select menu $ return .= ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '&amp;fields=1" id="' . $ this -> strTable . '_all" class="tl_form tl_edit_form" method="post"> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="' . $ this -> strTable . '_all"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' . ( $ blnIsError ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] . '</p>' : '' ) . ' <div class="tl_tbox"> <div class="widget"> <fieldset class="tl_checkbox_container"> <legend' . ( $ blnIsError ? ' class="error"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'all_fields' ] [ 0 ] . '<span class="mandatory">*</span></legend> <input type="checkbox" id="check_all" class="tl_checkbox" onclick="Backend.toggleCheckboxes(this)"> <label for="check_all" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label><br>' . $ options . ' </fieldset>' . ( $ blnIsError ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'all_fields' ] . '</p>' : ( ( Config :: get ( 'showHelp' ) && \ strlen ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'all_fields' ] [ 1 ] ) ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'all_fields' ] [ 1 ] . '</p>' : '' ) ) . ' </div> </div> </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> <button type="submit" name="save" id="save" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'continue' ] . '</button> </div> </div> </form>' ; } // Return return ' <div id="tl_buttons"> <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div>' . $ return ; } 
public function source ( ) { $ this -> isValid ( $ this -> intId ) ; if ( is_dir ( $ this -> strRootDir . '/' . $ this -> intId ) ) { throw new InternalServerErrorException ( 'Folder "' . $ this -> intId . '" cannot be edited.' ) ; } elseif ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> intId ) ) { throw new InternalServerErrorException ( 'File "' . $ this -> intId . '" does not exist.' ) ; } $ objFile = new File ( $ this -> intId ) ; <div id="tl_buttons"> <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div> <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_files" class="tl_form tl_edit_form" method="post"> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="tl_files"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"> <div class="tl_tbox"> <div class="widget"> <h3><label for="ctrl_source">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'editor' ] [ 0 ] . '</label></h3> <textarea name="source" id="ctrl_source" class="tl_textarea monospace" rows="12" cols="80" style="height:400px" onfocus="Backend.getScrollOffset()">' . "\n" . htmlspecialchars ( $ strContent ) . '</textarea>' . ( ( Config :: get ( 'showHelp' ) && \ strlen ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'editor' ] [ 1 ] ) ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'editor' ] [ 1 ] . '</p>' : '' ) . ' </div> </div> </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> ' . $ strButtons . ' </div> </div> </form>' . "\n\n" . $ codeEditor ; } 
public function protect ( ) { @ trigger_error ( 'Using DC_Folder::protect() has been deprecated and will no longer work in Contao 5.0. Use Contao\Folder::protect() and Contao\Folder::unprotect() instead.' , E_USER_DEPRECATED ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ this -> intId ) ) { throw new InternalServerErrorException ( 'Resource "' . $ this -> intId . '" is not a directory.' ) ; } 
protected function save ( $ varValue ) { if ( Input :: post ( 'FORM_SUBMIT' ) != $ this -> strTable ) { return ; } $ arrData = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] ; 
public function sync ( ) { if ( ! $ this -> blnIsDbAssisted ) { return '' ; } $ this -> loadLanguageFile ( 'tl_files' ) ; <div id="tl_buttons"> <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div> <div id="sync-results"> <p class="left">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'syncResult' ] , System :: getFormattedNumber ( $ arrCounts [ 'Added' ] , 0 ) , System :: getFormattedNumber ( $ arrCounts [ 'Changed' ] , 0 ) , System :: getFormattedNumber ( $ arrCounts [ 'Unchanged' ] , 0 ) , System :: getFormattedNumber ( $ arrCounts [ 'Moved' ] , 0 ) , System :: getFormattedNumber ( $ arrCounts [ 'Deleted' ] , 0 ) ) . '</p> <p class="right"><input type="checkbox" id="show-hidden" class="tl_checkbox" onclick="Backend.toggleUnchanged()"> <label for="show-hidden">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'syncShowUnchanged' ] . '</label></p> </div> <div id="result-list">' ; // Add the messages foreach ( $ arrMessages as $ strMessage ) { $ return .= "\n " . $ strMessage ; } $ return .= ' </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> <a href="' . $ this -> getReferer ( true ) . '" class="tl_submit" style="display:inline-block">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'continue' ] . '</a> </div> </div>' ; return $ return ; } 
public function ajaxTreeView ( $ strFolder , $ level ) { if ( ! Environment :: get ( 'isAjaxRequest' ) ) { return '' ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ blnClipboard = false ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; 
protected function generateTree ( $ path , $ intMargin , $ mount = false , $ blnProtected = true , $ arrClipboard = null , $ arrFound = array ( ) ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; 
protected function searchMenu ( ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; <div class="tl_search tl_subpanel"> <strong>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'search' ] . ':</strong> <select name="tl_field" class="tl_select' . ( $ active ? ' active' : '' ) . '"> <option value="name">' . ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ 'name' ] [ 'label' ] [ 0 ] ? : ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'name' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'name' ] [ 0 ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'name' ] ) ) . '</option> </select> <span>=</span> <input type="search" name="tl_value" class="tl_text' . ( $ active ? ' active' : '' ) . '" value="' . StringUtil :: specialchars ( $ session [ 'search' ] [ $ this -> strTable ] [ 'value' ] ) . '"> </div>' ; } 
protected function isMounted ( $ strFolder ) { if ( $ strFolder == '' ) { return false ; } if ( empty ( $ this -> arrFilemounts ) ) { return true ; } $ path = $ strFolder ; while ( \ is_array ( $ this -> arrFilemounts ) && substr_count ( $ path , '/' ) > 0 ) { if ( \ in_array ( $ path , $ this -> arrFilemounts ) ) { return true ; } $ path = \ dirname ( $ path ) ; } return false ; } 
protected function isValid ( $ strFile ) { $ strFolder = Input :: get ( 'pid' , true ) ; 
protected function getMD5Folders ( $ strPath ) { $ arrFiles = array ( ) ; foreach ( scan ( $ this -> strRootDir . '/' . $ strPath ) as $ strFile ) { if ( ! is_dir ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) ) { continue ; } $ arrFiles [ substr ( md5 ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) , 0 , 8 ) ] = 1 ; 
public function initPicker ( PickerInterface $ picker ) { $ attributes = parent :: initPicker ( $ picker ) ; if ( null === $ attributes ) { return null ; } $ this -> blnFiles = isset ( $ attributes [ 'files' ] ) && $ attributes [ 'files' ] ; $ this -> blnFilesOnly = isset ( $ attributes [ 'filesOnly' ] ) && $ attributes [ 'filesOnly' ] ; if ( isset ( $ attributes [ 'path' ] ) ) { $ strPath = ( string ) $ attributes [ 'path' ] ; if ( Validator :: isInsecurePath ( $ strPath ) || ! is_dir ( $ this -> strRootDir . '/' . $ strPath ) ) { throw new \ RuntimeException ( 'Invalid path ' . $ strPath ) ; } 
public static function find ( array $ arrOptions ) { $ objBase = DcaExtractor :: getInstance ( $ arrOptions [ 'table' ] ) ; if ( ! $ objBase -> hasRelations ( ) ) { $ strQuery = "SELECT * FROM " . $ arrOptions [ 'table' ] ; } else { $ arrJoins = array ( ) ; $ arrFields = array ( $ arrOptions [ 'table' ] . ".*" ) ; $ intCount = 0 ; foreach ( $ objBase -> getRelations ( ) as $ strKey => $ arrConfig ) { 
public static function count ( array $ arrOptions ) { $ strQuery = "SELECT COUNT(*) AS count FROM " . $ arrOptions [ 'table' ] ; if ( $ arrOptions [ 'column' ] !== null ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } return $ strQuery ; } 
public function generate ( $ strSeparator = ' ' ) { if ( $ this -> intRowsPerPage < 1 ) { return '' ; } $ blnQuery = false ; list ( $ this -> strUrl ) = explode ( '?' , Environment :: get ( 'request' ) , 2 ) ; 
public function getItemsAsString ( $ strSeparator = ' ' ) { $ arrLinks = array ( ) ; foreach ( $ this -> getItemsAsArray ( ) as $ arrItem ) { if ( $ arrItem [ 'href' ] === null ) { $ arrLinks [ ] = sprintf ( '<li><strong class="active">%s</strong></li>' , $ arrItem [ 'page' ] ) ; } else { $ arrLinks [ ] = sprintf ( '<li><a href="%s" class="link" title="%s">%s</a></li>' , $ arrItem [ 'href' ] , $ arrItem [ 'title' ] , $ arrItem [ 'page' ] ) ; } } return implode ( $ strSeparator , $ arrLinks ) ; } 
public function getItemsAsArray ( ) { $ arrLinks = array ( ) ; $ intNumberOfLinks = floor ( $ this -> intNumberOfLinks / 2 ) ; $ intFirstOffset = $ this -> intPage - $ intNumberOfLinks - 1 ; if ( $ intFirstOffset > 0 ) { $ intFirstOffset = 0 ; } $ intLastOffset = $ this -> intPage + $ intNumberOfLinks - $ this -> intTotalPages ; if ( $ intLastOffset < 0 ) { $ intLastOffset = 0 ; } $ intFirstLink = $ this -> intPage - $ intNumberOfLinks - $ intLastOffset ; if ( $ intFirstLink < 1 ) { $ intFirstLink = 1 ; } $ intLastLink = $ this -> intPage + $ intNumberOfLinks - $ intFirstOffset ; if ( $ intLastLink > $ this -> intTotalPages ) { $ intLastLink = $ this -> intTotalPages ; } for ( $ i = $ intFirstLink ; $ i <= $ intLastLink ; $ i ++ ) { if ( $ i == $ this -> intPage ) { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => null , 'title' => null ) ; } else { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => $ this -> linkToPage ( $ i ) , 'title' => StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goToPage' ] , $ i ) ) ) ; } } return $ arrLinks ; } 
protected function linkToPage ( $ intPage ) { if ( $ intPage <= 1 && ! $ this -> blnForceParam ) { return ampersand ( $ this -> strUrl ) ; } else { return ampersand ( $ this -> strUrl ) . $ this -> strVarConnector . $ this -> strParameter . '=' . $ intPage ; } } 
public function generate ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; <li class="tl_folder_top"><div class="tl_left">' . Image :: getHtml ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'list' ] [ 'sorting' ] [ 'icon' ] ? : 'pagemounts.svg' ) . ' ' . $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ 'page' ] [ 0 ] . '</div> <div class="tl_right">&nbsp;</div><div style="clear:both"></div></li><li class="parent" id="' . $ this -> strId . '_parent"><ul>' . $ tree . $ strReset . ' </ul></li></ul>' ; } 
public function generateAjax ( $ id , $ strField , $ level ) { if ( ! Environment :: get ( 'isAjaxRequest' ) ) { return '' ; } $ this -> strField = $ strField ; $ this -> loadDataContainer ( $ this -> strTable ) ; 
protected function renderPagetree ( $ id , $ intMargin , $ protectedPage = false , $ blnNoRecursion = false , $ arrFound = array ( ) ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; $ flag = substr ( $ this -> strField , 0 , 2 ) ; $ node = 'tree_' . $ this -> strTable . '_' . $ this -> strField ; $ xtnode = 'tree_' . $ this -> strTable . '_' . $ this -> strName ; 
protected function getPathNodes ( ) { if ( ! $ this -> varValue ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } foreach ( $ this -> varValue as $ id ) { $ arrPids = $ this -> Database -> getParentRecords ( $ id , 'tl_page' ) ; array_shift ( $ arrPids ) ; 
public function grantsAccess ( ) : bool { $ content = array_filter ( file ( ( string ) $ this -> file ) ) ; foreach ( $ content as $ line ) { if ( $ this -> hasRequireGranted ( $ line ) ) { return true ; } } return false ; } 
private function hasRequireGranted ( string $ line ) : bool { if ( $ this -> isComment ( $ line ) ) { return false ; } return ( false !== stripos ( $ line , 'Allow from all' ) ) || ( false !== stripos ( $ line , 'Require all granted' ) ) ; } 
public function run ( ) { $ table = Input :: get ( 'table' ) ; $ field = Input :: get ( 'field' ) ; System :: loadLanguageFile ( $ table ) ; $ this -> loadDataContainer ( $ table ) ; $ objTemplate = new BackendTemplate ( 'be_help' ) ; $ objTemplate -> rows = array ( ) ; $ objTemplate -> explanation = '' ; $ arrData = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ field ] ; 
public function accept ( ) { 
public function onAuthenticationFailure ( Request $ request , AuthenticationException $ exception ) : Response { if ( null === $ this -> logger ) { return parent :: onAuthenticationFailure ( $ request , $ exception ) ; } if ( $ exception instanceof AccountStatusException && ( $ user = $ exception -> getUser ( ) ) instanceof UserInterface ) { $ username = $ user -> getUsername ( ) ; } else { $ username = $ request -> request -> get ( 'username' ) ; } $ this -> logger -> info ( $ exception -> getMessage ( ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ username ) ] ) ; return parent :: onAuthenticationFailure ( $ request , $ exception ) ; } 
public function generate ( ) { if ( $ this -> singleSRC == '' ) { return '' ; } $ objFile = FilesModel :: findByUuid ( $ this -> singleSRC ) ; if ( $ objFile === null || ! is_file ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ objFile -> path ) ) { return '' ; } $ this -> singleSRC = $ objFile -> path ; $ this -> objFilesModel = $ objFile ; return parent :: generate ( ) ; } 
protected function compile ( ) { $ this -> arrData [ 'floating' ] = '' ; $ this -> addImageToTemplate ( $ this -> Template , $ this -> arrData , null , null , $ this -> objFilesModel ) ; } 
public function generate ( ) { $ reference = new ContentElementReference ( $ this -> objModel , $ this -> strColumn ) ; if ( 'BE' === TL_MODE ) { $ reference -> setBackendScope ( ) ; } return System :: getContainer ( ) -> get ( 'fragment.handler' ) -> render ( $ reference ) ; } 
public function parse ( $ arrAttributes = null ) { if ( TL_MODE == 'BE' ) { $ this -> html = htmlspecialchars ( $ this -> html ) ; } return parent :: parse ( $ arrAttributes ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : int { $ this -> fs = new Filesystem ( ) ; $ this -> io = new SymfonyStyle ( $ input , $ output ) ; $ webDir = $ this -> rootDir . '/' . rtrim ( $ input -> getArgument ( 'target' ) , '/' ) ; $ this -> addHtaccess ( $ webDir ) ; $ this -> addFiles ( $ webDir ) ; $ this -> purgeOldFiles ( $ webDir ) ; return 0 ; } 
private function addHtaccess ( string $ webDir ) : void { $ htaccess = __DIR__ . '/../Resources/skeleton/web/.htaccess' ; if ( ! file_exists ( $ webDir . '/.htaccess' ) ) { $ this -> fs -> copy ( $ htaccess , $ webDir . '/.htaccess' , true ) ; $ this -> io -> writeln ( 'Added the <comment>web/.htaccess</comment> file.' ) ; return ; } $ existingContent = file_get_contents ( $ webDir . '/.htaccess' ) ; 
private function addFiles ( string $ webDir ) : void { $ finder = Finder :: create ( ) -> files ( ) -> in ( __DIR__ . '/../Resources/skeleton/web' ) ; foreach ( $ finder as $ file ) { if ( $ this -> isExistingOptionalFile ( $ file , $ webDir ) ) { continue ; } $ this -> fs -> copy ( $ file -> getPathname ( ) , $ webDir . '/' . $ file -> getRelativePathname ( ) , true ) ; $ this -> io -> writeln ( sprintf ( 'Added the <comment>web/%s</comment> file.' , $ file -> getFilename ( ) ) ) ; } } 
private function purgeOldFiles ( string $ webDir ) : void { if ( file_exists ( $ webDir . '/app_dev.php' ) ) { $ this -> fs -> remove ( $ webDir . '/app_dev.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/app_dev.php</comment> file.' ) ; } if ( file_exists ( $ webDir . '/install.php' ) ) { $ this -> fs -> remove ( $ webDir . '/install.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/install.php</comment> file.' ) ; } } 
private function isExistingOptionalFile ( SplFileInfo $ file , string $ webDir ) : bool { $ path = $ file -> getRelativePathname ( ) ; return 'robots.txt' === $ path && $ this -> fs -> exists ( $ webDir . '/' . $ path ) ; } 
public function checkPreAuth ( UserInterface $ user ) : void { if ( ! $ user instanceof User ) { return ; } $ this -> checkIfAccountIsLocked ( $ user ) ; $ this -> checkIfAccountIsDisabled ( $ user ) ; $ this -> checkIfLoginIsAllowed ( $ user ) ; $ this -> checkIfAccountIsActive ( $ user ) ; } 
private function checkIfLoginIsAllowed ( User $ user ) : void { if ( ! $ user instanceof FrontendUser || $ user -> login ) { return ; } $ ex = new DisabledException ( sprintf ( 'User "%s" is not allowed to log in' , $ user -> username ) ) ; $ ex -> setUser ( $ user ) ; throw $ ex ; } 
private function checkIfAccountIsActive ( User $ user ) : void { $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ start = ( int ) $ user -> start ; $ stop = ( int ) $ user -> stop ; $ time = Date :: floorToMinute ( time ( ) ) ; $ notActiveYet = $ start && $ start > $ time ; $ notActiveAnymore = $ stop && $ stop <= ( $ time + 60 ) ; $ logMessage = '' ; if ( $ notActiveYet ) { $ logMessage = sprintf ( 'The account is not active yet (activation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ start ) ) ; } if ( $ notActiveAnymore ) { $ logMessage = sprintf ( 'The account is not active anymore (deactivation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ stop ) ) ; } if ( '' === $ logMessage ) { return ; } $ ex = new DisabledException ( $ logMessage ) ; $ ex -> setUser ( $ user ) ; throw $ ex ; } 
public function create ( $ path , $ size = null , $ targetPath = null ) : ImageInterface { if ( $ path instanceof ImageInterface ) { $ image = $ path ; } else { $ fileExtension = strtolower ( pathinfo ( $ path , PATHINFO_EXTENSION ) ) ; if ( \ in_array ( $ fileExtension , [ 'svg' , 'svgz' ] , true ) ) { $ imagine = $ this -> imagineSvg ; } else { $ imagine = $ this -> imagine ; } if ( ! \ in_array ( $ fileExtension , $ this -> validExtensions , true ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Image type "%s" was not allowed to be processed' , $ fileExtension ) ) ; } $ image = new Image ( ( string ) $ path , $ imagine , $ this -> filesystem ) ; } if ( $ size instanceof ResizeConfigurationInterface ) { $ resizeConfig = $ size ; $ importantPart = null ; } else { [ $ resizeConfig , $ importantPart ] = $ this -> createConfig ( $ size , $ image ) ; } if ( ! \ is_object ( $ path ) || ! ( $ path instanceof ImageInterface ) ) { if ( null === $ importantPart ) { $ importantPart = $ this -> createImportantPart ( $ image ) ; } $ image -> setImportantPart ( $ importantPart ) ; } if ( null === $ targetPath && $ resizeConfig -> isEmpty ( ) ) { return $ image ; } return $ this -> resizer -> resize ( $ image , $ resizeConfig , ( new ResizeOptions ( ) ) -> setImagineOptions ( $ this -> imagineOptions ) -> setTargetPath ( $ targetPath ) -> setBypassCache ( $ this -> bypassCache ) ) ; } 
public function getImportantPartFromLegacyMode ( ImageInterface $ image , $ mode ) : ImportantPartInterface { if ( 1 !== substr_count ( $ mode , '_' ) ) { throw new \ InvalidArgumentException ( sprintf ( '"%s" is not a legacy resize mode' , $ mode ) ) ; } $ importantPart = [ 0 , 0 , $ image -> getDimensions ( ) -> getSize ( ) -> getWidth ( ) , $ image -> getDimensions ( ) -> getSize ( ) -> getHeight ( ) , ] ; [ $ modeX , $ modeY ] = explode ( '_' , $ mode ) ; if ( 'left' === $ modeX ) { $ importantPart [ 2 ] = 1 ; } elseif ( 'right' === $ modeX ) { $ importantPart [ 0 ] = $ importantPart [ 2 ] - 1 ; $ importantPart [ 2 ] = 1 ; } if ( 'top' === $ modeY ) { $ importantPart [ 3 ] = 1 ; } elseif ( 'bottom' === $ modeY ) { $ importantPart [ 1 ] = $ importantPart [ 3 ] - 1 ; $ importantPart [ 3 ] = 1 ; } return new ImportantPart ( new Point ( $ importantPart [ 0 ] , $ importantPart [ 1 ] ) , new Box ( $ importantPart [ 2 ] , $ importantPart [ 3 ] ) ) ; } 
private function createConfig ( $ size , ImageInterface $ image ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new ResizeConfiguration ( ) ; if ( isset ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ imageModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSize = $ imageModel -> findByPk ( $ size [ 2 ] ) ; if ( null !== $ imageSize ) { $ config -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; } return [ $ config , null ] ; } if ( ! empty ( $ size [ 0 ] ) ) { $ config -> setWidth ( $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ config -> setHeight ( $ size [ 1 ] ) ; } if ( ! isset ( $ size [ 2 ] ) || 1 !== substr_count ( $ size [ 2 ] , '_' ) ) { if ( ! empty ( $ size [ 2 ] ) ) { $ config -> setMode ( $ size [ 2 ] ) ; } return [ $ config , null ] ; } $ config -> setMode ( ResizeConfigurationInterface :: MODE_CROP ) ; return [ $ config , $ this -> getImportantPartFromLegacyMode ( $ image , $ size [ 2 ] ) ] ; } 
private function createImportantPart ( ImageInterface $ image ) : ? ImportantPart { $ filesModel = $ this -> framework -> getAdapter ( FilesModel :: class ) ; $ file = $ filesModel -> findByPath ( $ image -> getPath ( ) ) ; if ( null === $ file || ! $ file -> importantPartWidth || ! $ file -> importantPartHeight ) { return null ; } $ imageSize = $ image -> getDimensions ( ) -> getSize ( ) ; if ( $ file -> importantPartX + $ file -> importantPartWidth > $ imageSize -> getWidth ( ) || $ file -> importantPartY + $ file -> importantPartHeight > $ imageSize -> getHeight ( ) ) { return null ; } return new ImportantPart ( new Point ( ( int ) $ file -> importantPartX , ( int ) $ file -> importantPartY ) , new Box ( ( int ) $ file -> importantPartWidth , ( int ) $ file -> importantPartHeight ) ) ; } 
public function validate ( ) { $ mandatory = $ this -> mandatory ; $ options = $ this -> getPost ( $ this -> strName ) ; 
public function parse ( $ arrAttributes = null ) { $ strClass = 'select' ; if ( $ this -> multiple ) { $ this -> strName .= '[]' ; $ strClass = 'multiselect' ; } 
protected function getOptions ( ) { $ arrOptions = array ( ) ; $ blnHasGroups = false ; 
public function generate ( ) { $ strOptions = '' ; $ blnHasGroups = false ; if ( $ this -> multiple ) { $ this -> strName .= '[]' ; } 
public function prepare ( $ strQuery ) { if ( $ strQuery == '' ) { throw new \ Exception ( 'Empty query string' ) ; } $ this -> strQuery = trim ( $ strQuery ) ; 
public function set ( $ arrParams ) { $ strQuery = '' ; $ arrParams = $ this -> escapeParams ( $ arrParams ) ; 
public function limit ( $ intRows , $ intOffset = 0 ) { if ( $ intRows <= 0 ) { $ intRows = 30 ; } if ( $ intOffset < 0 ) { $ intOffset = 0 ; } if ( strncasecmp ( $ this -> strQuery , 'SELECT' , 6 ) === 0 ) { $ this -> strQuery .= ' LIMIT ' . $ intOffset . ',' . $ intRows ; } else { $ this -> strQuery .= ' LIMIT ' . $ intRows ; } return $ this ; } 
public function execute ( ) { $ arrParams = \ func_get_args ( ) ; if ( ! empty ( $ arrParams ) && \ is_array ( $ arrParams [ 0 ] ) ) { $ arrParams = array_values ( $ arrParams [ 0 ] ) ; } $ this -> replaceWildcards ( $ arrParams ) ; return $ this -> query ( ) ; } 
public function query ( $ strQuery = '' ) { if ( ! empty ( $ strQuery ) ) { $ this -> strQuery = trim ( $ strQuery ) ; } 
protected function replaceWildcards ( $ arrValues ) { $ arrValues = $ this -> escapeParams ( $ arrValues ) ; $ this -> strQuery = preg_replace ( '/(?<!%)%([^bcdufosxX%])/' , '%%$1' , $ this -> strQuery ) ; 
protected function escapeParams ( $ arrValues ) { foreach ( $ arrValues as $ k => $ v ) { switch ( \ gettype ( $ v ) ) { case 'string' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( $ v ) ; break ; case 'boolean' : $ arrValues [ $ k ] = ( $ v === true ) ? 1 : 0 ; break ; case 'object' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; case 'array' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; default : $ arrValues [ $ k ] = $ v ?? 'NULL' ; break ; } } return $ arrValues ; } 
public function send ( $ strUrl , $ strData = null , $ strMethod = null ) { if ( $ strData !== null ) { $ this -> strData = $ strData ; } if ( $ strMethod !== null ) { $ this -> strMethod = $ strMethod ; } $ errstr = '' ; $ errno = null ; $ uri = parse_url ( $ strUrl ) ; switch ( $ uri [ 'scheme' ] ) { case 'http' : $ port = $ uri [ 'port' ] ?? 80 ; $ host = $ uri [ 'host' ] . ( ( $ port != 80 ) ? ':' . $ port : '' ) ; $ fp = @ fsockopen ( $ uri [ 'host' ] , $ port , $ errno , $ errstr , 10 ) ; break ; case 'https' : $ port = $ uri [ 'port' ] ?? 443 ; $ host = $ uri [ 'host' ] . ( ( $ port != 443 ) ? ':' . $ port : '' ) ; $ fp = @ fsockopen ( 'ssl://' . $ uri [ 'host' ] , $ port , $ errno , $ errstr , 15 ) ; break ; default : $ this -> strError = 'Invalid schema ' . $ uri [ 'scheme' ] ; return ; break ; } if ( ! \ is_resource ( $ fp ) ) { $ this -> strError = trim ( $ errno . ' ' . $ errstr ) ; return ; } $ path = $ uri [ 'path' ] ?? '/' ; if ( isset ( $ uri [ 'query' ] ) ) { $ path .= '?' . $ uri [ 'query' ] ; } $ default = array ( 'Host' => 'Host: ' . $ host , 'User-Agent' => 'User-Agent: Contao (+https://contao.org/)' , 'Content-Length' => 'Content-Length: ' . \ strlen ( $ this -> strData ) , 'Connection' => 'Connection: close' ) ; if ( isset ( $ uri [ 'user' ] ) ) { $ default [ 'Authorization' ] = 'Authorization: Basic ' . base64_encode ( $ uri [ 'user' ] . ':' . $ uri [ 'pass' ] ) ; } elseif ( $ this -> strUsername != '' ) { $ default [ 'Authorization' ] = 'Authorization: Basic ' . base64_encode ( $ this -> strUsername . ':' . $ this -> strPassword ) ; } foreach ( $ this -> arrHeaders as $ header => $ value ) { $ default [ $ header ] = $ header . ': ' . $ value ; } $ request = strtoupper ( $ this -> strMethod ) . ' ' . $ path . " HTTP/1.0\r\n" ; $ request .= implode ( "\r\n" , $ default ) ; $ request .= "\r\n\r\n" ; if ( $ this -> strData != '' ) { $ request .= $ this -> strData . "\r\n" ; } $ this -> strRequest = $ request ; fwrite ( $ fp , $ request ) ; $ response = '' ; while ( ! feof ( $ fp ) && ( $ chunk = fread ( $ fp , 1024 ) ) != false ) { $ response .= $ chunk ; } fclose ( $ fp ) ; list ( $ split , $ this -> strResponse ) = explode ( "\r\n\r\n" , $ response , 2 ) ; $ split = preg_split ( "/\r\n|\n|\r/" , $ split ) ; $ this -> arrResponseHeaders = array ( ) ; list ( , $ code , $ text ) = explode ( ' ' , trim ( array_shift ( $ split ) ) , 3 ) ; while ( ( $ line = trim ( array_shift ( $ split ) ) ) != false ) { list ( $ header , $ value ) = explode ( ':' , $ line , 2 ) ; if ( isset ( $ this -> arrResponseHeaders [ $ header ] ) && $ header == 'Set-Cookie' ) { $ this -> arrResponseHeaders [ $ header ] .= ',' . trim ( $ value ) ; } else { $ this -> arrResponseHeaders [ $ header ] = trim ( $ value ) ; } } $ responses = array ( 100 => 'Continue' , 101 => 'Switching Protocols' , 200 => 'OK' , 201 => 'Created' , 202 => 'Accepted' , 203 => 'Non-Authoritative Information' , 204 => 'No Content' , 205 => 'Reset Content' , 206 => 'Partial Content' , 300 => 'Multiple Choices' , 301 => 'Moved Permanently' , 302 => 'Found' , 303 => 'See Other' , 304 => 'Not Modified' , 305 => 'Use Proxy' , 307 => 'Temporary Redirect' , 400 => 'Bad Request' , 401 => 'Unauthorized' , 402 => 'Payment Required' , 403 => 'Forbidden' , 404 => 'Not Found' , 405 => 'Method Not Allowed' , 406 => 'Not Acceptable' , 407 => 'Proxy Authentication Required' , 408 => 'Request Timeout' , 409 => 'Conflict' , 410 => 'Gone' , 411 => 'Length Required' , 412 => 'Precondition Failed' , 413 => 'Request Entity Too Large' , 414 => 'Request-URI Too Large' , 415 => 'Unsupported Media Type' , 416 => 'Requested Range Not Satisfiable' , 417 => 'Expectation Failed' , 500 => 'Internal Server Error' , 501 => 'Not Implemented' , 502 => 'Bad Gateway' , 503 => 'Service Unavailable' , 504 => 'Gateway Timeout' , 505 => 'HTTP Version Not Supported' ) ; if ( ! isset ( $ responses [ $ code ] ) ) { $ code = floor ( $ code / 100 ) * 100 ; } $ this -> intCode = ( int ) $ code ; switch ( $ this -> intCode ) { case 200 : case 304 : 
protected function compile ( ) { global $ objPage ; 
public function supports ( Request $ request , ArgumentMetadata $ argument ) : bool { if ( ! $ this -> scopeMatcher -> isContaoRequest ( $ request ) ) { return false ; } $ this -> framework -> initialize ( ) ; if ( ! is_a ( $ argument -> getType ( ) , Model :: class , true ) ) { return false ; } if ( ! $ argument -> isNullable ( ) && null === $ this -> fetchModel ( $ request , $ argument ) ) { return false ; } return true ; } 
public function resolve ( Request $ request , ArgumentMetadata $ argument ) : \ Generator { yield $ this -> fetchModel ( $ request , $ argument ) ; } 
private function getArgumentName ( Request $ request , ArgumentMetadata $ argument ) : ? string { if ( $ request -> attributes -> has ( $ argument -> getName ( ) ) ) { return $ argument -> getName ( ) ; } $ className = lcfirst ( $ this -> stripNamespace ( $ argument -> getType ( ) ) ) ; if ( $ request -> attributes -> has ( $ className ) ) { return $ className ; } return null ; } 
private function stripNamespace ( string $ fqcn ) : string { if ( false !== ( $ pos = strrpos ( $ fqcn , '\\' ) ) ) { return substr ( $ fqcn , $ pos + 1 ) ; } return $ fqcn ; } 
protected function createTemplate ( Model $ model , string $ templateName ) : Template { if ( isset ( $ this -> options [ 'template' ] ) ) { $ templateName = $ this -> options [ 'template' ] ; } if ( $ model -> customTpl ) { $ templateName = $ model -> customTpl ; } $ template = $ this -> get ( 'contao.framework' ) -> createInstance ( FrontendTemplate :: class , [ $ templateName ] ) ; $ template -> setData ( $ model -> row ( ) ) ; return $ template ; } 
protected function getType ( ) : string { if ( isset ( $ this -> options [ 'type' ] ) ) { return $ this -> options [ 'type' ] ; } $ className = ltrim ( strrchr ( static :: class , '\\' ) , '\\' ) ; if ( 'Controller' === substr ( $ className , - 10 ) ) { $ className = substr ( $ className , 0 , - 10 ) ; } return Container :: underscore ( $ className ) ; } 
protected function compile ( ) { System :: loadLanguageFile ( 'tl_maintenance' ) ; $ this -> Template -> content = '' ; $ this -> Template -> href = $ this -> getReferer ( true ) ; $ this -> Template -> title = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) ; $ this -> Template -> button = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] ; foreach ( $ GLOBALS [ 'TL_MAINTENANCE' ] as $ callback ) { $ this -> import ( $ callback ) ; if ( ! $ this -> $ callback instanceof \ executable ) { throw new \ Exception ( "$callback is not an executable class" ) ; } $ buffer = $ this -> $ callback -> run ( ) ; if ( $ this -> $ callback -> isActive ( ) ) { $ this -> Template -> content = $ buffer ; break ; } else { $ this -> Template -> content .= $ buffer ; } } } 
public function pickerAction ( Request $ request ) : RedirectResponse { $ extras = [ ] ; if ( $ request -> query -> has ( 'extras' ) ) { $ extras = $ request -> query -> get ( 'extras' ) ; if ( ! \ is_array ( $ extras ) ) { throw new BadRequestHttpException ( 'Invalid picker extras' ) ; } } $ config = new PickerConfig ( $ request -> query -> get ( 'context' ) , $ extras , $ request -> query -> get ( 'value' ) ) ; $ picker = $ this -> get ( 'contao.picker.builder' ) -> create ( $ config ) ; if ( null === $ picker ) { throw new BadRequestHttpException ( 'Unsupported picker context' ) ; } return new RedirectResponse ( $ picker -> getCurrentUrl ( ) ) ; } 
public function run ( ) { $ arrJobs = array ( ) ; $ objTemplate = new BackendTemplate ( 'be_purge_data' ) ; $ objTemplate -> isActive = $ this -> isActive ( ) ; $ objTemplate -> message = Message :: generateUnwrapped ( __CLASS__ ) ; 
public function validate ( ) { if ( ! isset ( $ _POST [ $ this -> strCaptchaKey ] ) || ! \ in_array ( Input :: post ( $ this -> strCaptchaKey . '_hash' ) , $ this -> generateHashes ( ( int ) Input :: post ( $ this -> strCaptchaKey ) ) , true ) || ( isset ( $ _POST [ $ this -> strCaptchaKey . '_name' ] ) && Input :: post ( $ this -> strCaptchaKey . '_name' ) ) ) { $ this -> class = 'error' ; $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'captcha' ] ) ; } } 
protected function generateCaptcha ( ) { if ( $ this -> arrCaptcha ) { return ; } $ int1 = random_int ( 1 , 9 ) ; $ int2 = random_int ( 1 , 9 ) ; $ this -> arrCaptcha = array ( 'int1' => $ int1 , 'int2' => $ int2 , 'sum' => $ int1 + $ int2 , 'key' => $ this -> strCaptchaKey , 'hashes' => $ this -> generateHashes ( $ int1 + $ int2 ) ) ; } 
protected function generateHashes ( $ sum ) { 
protected function getQuestion ( ) { $ this -> generateCaptcha ( ) ; $ question = $ GLOBALS [ 'TL_LANG' ] [ 'SEC' ] [ 'question' . random_int ( 1 , 3 ) ] ; $ question = sprintf ( $ question , $ this -> arrCaptcha [ 'int1' ] , $ this -> arrCaptcha [ 'int2' ] ) ; $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ question ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( '&#%s;' , Utf8 :: ord ( $ strCharacter ) ) ; } return $ strEncoded ; } 
public function generateLabel ( ) { if ( $ this -> strLabel == '' ) { return '' ; } return sprintf ( '<label for="ctrl_%s" class="mandatory%s"><span class="invisible">%s </span>%s<span class="mandatory">*</span><span class="invisible"> %s</span></label>' , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mandatory' ] , $ this -> strLabel , $ this -> getQuestion ( ) ) ; } 
public function generate ( ) { return sprintf ( '<input type="text" name="%s" id="ctrl_%s" class="captcha mandatory%s" value="" aria-describedby="captcha_text_%s"%s%s' , $ this -> strCaptchaKey , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , $ this -> strId , $ this -> getAttributes ( ) , $ this -> strTagEnding ) ; } 
public function generateQuestion ( ) { return sprintf ( '<span id="captcha_text_%s" class="captcha_text%s">%s</span>' , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , $ this -> getQuestion ( ) ) ; } 
public function resize ( ImageInterface $ image , ResizeConfigurationInterface $ config , ResizeOptionsInterface $ options ) : ImageInterface { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( $ this -> hasExecuteResizeHook ( ) || $ this -> hasGetImageHook ( ) ) { @ trigger_error ( 'Using the executeResize and getImage hooks has been deprecated and will no longer work in Contao 5.0. Replace the contao.image.resizer service instead.' , E_USER_DEPRECATED ) ; $ this -> legacyImage = null ; $ legacyPath = $ image -> getPath ( ) ; if ( 0 === strpos ( $ legacyPath , $ rootDir . '/' ) || 0 === strpos ( $ legacyPath , $ rootDir . '\\' ) ) { $ legacyPath = substr ( $ legacyPath , \ strlen ( $ rootDir ) + 1 ) ; $ this -> legacyImage = new LegacyImage ( new File ( $ legacyPath ) ) ; $ this -> legacyImage -> setTargetWidth ( $ config -> getWidth ( ) ) ; $ this -> legacyImage -> setTargetHeight ( $ config -> getHeight ( ) ) ; $ this -> legacyImage -> setResizeMode ( $ config -> getMode ( ) ) ; $ this -> legacyImage -> setZoomLevel ( $ config -> getZoomLevel ( ) ) ; if ( ( $ targetPath = $ options -> getTargetPath ( ) ) && ( 0 === strpos ( $ targetPath , $ rootDir . '/' ) || 0 === strpos ( $ targetPath , $ rootDir . '\\' ) ) ) { $ this -> legacyImage -> setTargetPath ( substr ( $ targetPath , \ strlen ( $ rootDir ) + 1 ) ) ; } $ importantPart = $ image -> getImportantPart ( ) ; $ this -> legacyImage -> setImportantPart ( [ 'x' => $ importantPart -> getPosition ( ) -> getX ( ) , 'y' => $ importantPart -> getPosition ( ) -> getY ( ) , 'width' => $ importantPart -> getSize ( ) -> getWidth ( ) , 'height' => $ importantPart -> getSize ( ) -> getHeight ( ) , ] ) ; } } if ( $ this -> legacyImage && $ this -> hasExecuteResizeHook ( ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] as $ callback ) { $ return = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ this -> legacyImage ) ; if ( \ is_string ( $ return ) ) { return $ this -> createImage ( $ image , $ rootDir . '/' . $ return ) ; } } } return parent :: resize ( $ image , $ config , $ options ) ; } 
protected function executeResize ( ImageInterface $ image , ResizeCoordinatesInterface $ coordinates , $ path , ResizeOptionsInterface $ options ) : ImageInterface { if ( $ this -> legacyImage && $ this -> hasGetImageHook ( ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getImage' ] as $ callback ) { $ return = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ this -> legacyImage -> getOriginalPath ( ) , $ this -> legacyImage -> getTargetWidth ( ) , $ this -> legacyImage -> getTargetHeight ( ) , $ this -> legacyImage -> getResizeMode ( ) , $ this -> legacyImage -> getCacheName ( ) , new File ( $ this -> legacyImage -> getOriginalPath ( ) ) , $ this -> legacyImage -> getTargetPath ( ) , $ this -> legacyImage ) ; if ( \ is_string ( $ return ) ) { return $ this -> createImage ( $ image , $ rootDir . '/' . $ return ) ; } } } if ( $ image -> getImagine ( ) instanceof GdImagine ) { $ dimensions = $ image -> getDimensions ( ) ; $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ gdMaxImgWidth = $ config -> get ( 'gdMaxImgWidth' ) ; $ gdMaxImgHeight = $ config -> get ( 'gdMaxImgHeight' ) ; 
public static function findByArchive ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.archives LIKE '%\"" . ( int ) $ intId . "\"%'" ) , null , $ arrOptions ) ; } 
public static function findByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")" ) , null , $ arrOptions ) ; } 
public function appendToSchema ( Schema $ schema ) : void { $ config = $ this -> getSqlDefinitions ( ) ; foreach ( $ config as $ tableName => $ definitions ) { $ table = $ schema -> createTable ( $ tableName ) ; 
private function getSqlDefinitions ( ) : array { $ this -> framework -> initialize ( ) ; $ installer = $ this -> framework -> createInstance ( Installer :: class ) ; $ sqlTarget = $ installer -> getFromDca ( ) ; $ sqlLegacy = $ installer -> getFromFile ( ) ; 
private function getIndexLength ( Table $ table , string $ column ) : ? int { $ col = $ table -> getColumn ( $ column ) ; 
public static function fromFile ( File $ file ) { $ extension = strtolower ( $ file -> extension ) ; $ function = null ; if ( $ extension === 'jpg' ) { $ extension = 'jpeg' ; } if ( \ in_array ( $ extension , array ( 'gif' , 'jpeg' , 'png' ) ) ) { $ function = 'imagecreatefrom' . $ extension ; } if ( $ function === null || ! \ is_callable ( $ function ) ) { throw new \ InvalidArgumentException ( 'Image type "' . $ file -> extension . '" cannot be processed by GD' ) ; } $ image = $ function ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ file -> path ) ; if ( $ image === false ) { throw new \ RuntimeException ( 'Image "' . $ file -> path . '" failed to be processed by GD' ) ; } return new static ( $ image ) ; } 
public static function fromDimensions ( $ width , $ height ) { $ image = imagecreatetruecolor ( $ width , $ height ) ; $ arrGdInfo = gd_info ( ) ; $ strGdVersion = preg_replace ( '/[^0-9.]+/' , '' , $ arrGdInfo [ 'GD Version' ] ) ; 
public function setResource ( $ gdResource ) { if ( ! \ is_resource ( $ gdResource ) || get_resource_type ( $ gdResource ) !== 'gd' ) { throw new \ InvalidArgumentException ( '$gdResource is not a valid GD resource' ) ; } $ this -> gdResource = $ gdResource ; return $ this ; } 
public function saveToFile ( $ path ) { $ arrGdInfo = gd_info ( ) ; $ extension = strtolower ( substr ( $ path , strrpos ( $ path , '.' ) + 1 ) ) ; 
public function copyTo ( self $ gdImage , $ x , $ y , $ width , $ height ) { imagecopyresampled ( $ gdImage -> getResource ( ) , $ this -> gdResource , $ x , $ y , 0 , 0 , $ width , $ height , imagesx ( $ this -> gdResource ) , imagesy ( $ this -> gdResource ) ) ; return $ this ; } 
public function convertToPaletteImage ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return $ this ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; $ transparentColor = null ; if ( $ this -> countColors ( 256 ) <= 256 ) { $ paletteImage = imagecreate ( $ width , $ height ) ; $ colors = array ( ) ; $ isTransparent = false ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ color = imagecolorat ( $ this -> gdResource , $ x , $ y ) ; 
public function countColors ( $ max = null ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return imagecolorstotal ( $ this -> gdResource ) ; } $ colors = array ( ) ; $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ colors [ imagecolorat ( $ this -> gdResource , $ x , $ y ) ] = true ; if ( $ max !== null && \ count ( $ colors ) > $ max ) { break 2 ; } } } return \ count ( $ colors ) ; } 
public function isSemitransparent ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return false ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { 
protected function validator ( $ varInput ) { foreach ( $ varInput as $ k => $ v ) { if ( $ k != 'unit' ) { $ varInput [ $ k ] = parent :: validator ( $ v ) ; } } return $ varInput ; } 
protected function isSelected ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return $ this -> optionSelected ( 1 , 1 ) ; } if ( empty ( $ this -> varValue ) || ! \ is_array ( $ this -> varValue ) ) { return '' ; } return $ this -> optionSelected ( $ arrOption [ 'value' ] , $ this -> varValue [ 'unit' ] ) ; } 
public function getToken ( $ tokenId ) : string { $ this -> assertInitialized ( ) ; if ( empty ( $ this -> tokens [ $ tokenId ] ) ) { throw new TokenNotFoundException ( sprintf ( 'The CSRF token ID "%s" does not exist.' , $ tokenId ) ) ; } $ this -> usedTokens [ $ tokenId ] = true ; return $ this -> tokens [ $ tokenId ] ; } 
public function setToken ( $ tokenId , $ token ) : void { $ this -> assertInitialized ( ) ; $ this -> usedTokens [ $ tokenId ] = true ; $ this -> tokens [ $ tokenId ] = $ token ; } 
public function removeToken ( $ tokenId ) : ? string { $ this -> assertInitialized ( ) ; $ token = null ; if ( isset ( $ this -> tokens [ $ tokenId ] ) ) { $ token = $ this -> tokens [ $ tokenId ] ; $ this -> tokens [ $ tokenId ] = null ; } $ this -> usedTokens [ $ tokenId ] = true ; return $ token ; } 
public function getRouteCollectionForRequest ( Request $ request ) : RouteCollection { $ this -> framework -> initialize ( true ) ; $ pathInfo = rawurldecode ( $ request -> getPathInfo ( ) ) ; 
public function getRouteByName ( $ name ) : Route { $ this -> framework -> initialize ( true ) ; $ ids = $ this -> getPageIdsFromNames ( [ $ name ] ) ; if ( empty ( $ ids ) ) { throw new RouteNotFoundException ( 'Route name does not match a page ID' ) ; } $ pageModel = $ this -> framework -> getAdapter ( PageModel :: class ) ; $ page = $ pageModel -> findByPk ( $ ids [ 0 ] ) ; if ( null === $ page ) { throw new RouteNotFoundException ( sprintf ( 'Page ID "%s" not found' , $ ids [ 0 ] ) ) ; } $ routes = [ ] ; $ this -> addRoutesForPage ( $ page , $ routes ) ; return $ routes [ $ name ] ; } 
public function getRoutesByNames ( $ names ) : array { $ this -> framework -> initialize ( true ) ; $ pageModel = $ this -> framework -> getAdapter ( PageModel :: class ) ; if ( null === $ names ) { $ pages = $ pageModel -> findAll ( ) ; } else { $ ids = $ this -> getPageIdsFromNames ( $ names ) ; if ( empty ( $ ids ) ) { return [ ] ; } $ pages = $ pageModel -> findBy ( 'tl_page.id IN (' . implode ( ',' , $ ids ) . ')' , [ ] ) ; } if ( ! $ pages instanceof Collection ) { return [ ] ; } $ routes = [ ] ; $ this -> addRoutesForPages ( $ pages , $ routes ) ; $ this -> sortRoutes ( $ routes ) ; return $ routes ; } 
private function getAliasCandidates ( string $ pathInfo ) : array { $ pos = strpos ( $ pathInfo , '/' ) ; if ( false === $ pos ) { return [ $ pathInfo ] ; } $ config = $ this -> framework -> getAdapter ( Config :: class ) ; if ( ! $ config -> get ( 'folderUrl' ) ) { return [ substr ( $ pathInfo , 0 , $ pos ) ] ; } $ candidates = [ $ pathInfo ] ; while ( '/' !== $ pathInfo && false !== strpos ( $ pathInfo , '/' ) ) { $ pathInfo = \ dirname ( $ pathInfo ) ; $ candidates [ ] = $ pathInfo ; } return $ candidates ; } 
private function sortRoutes ( array & $ routes , array $ languages = null ) : void { 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ return = '<pre>' . StringUtil :: specialchars ( $ this -> code ) . '</pre>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; } 
protected function compile ( ) { $ this -> code = MarkdownExtra :: defaultTransform ( $ this -> code ) ; $ this -> Template -> content = strip_tags ( $ this -> code , Config :: get ( 'allowedTags' ) ) ; } 
public function attachFile ( $ strFile , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( \ Swift_Attachment :: fromPath ( $ strFile , $ strMime ) -> setFilename ( basename ( $ strFile ) ) ) ; } 
public function attachFileFromString ( $ strContent , $ strFilename , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( new \ Swift_Attachment ( $ strContent , $ strFilename , $ strMime ) ) ; } 
public function sendTo ( ) { $ arrRecipients = $ this -> compileRecipients ( \ func_get_args ( ) ) ; if ( empty ( $ arrRecipients ) ) { return false ; } $ this -> objMessage -> setTo ( $ arrRecipients ) ; $ this -> objMessage -> setCharset ( $ this -> strCharset ) ; 
protected function compileRecipients ( $ arrRecipients ) { $ arrReturn = array ( ) ; foreach ( $ arrRecipients as $ varRecipients ) { if ( ! \ is_array ( $ varRecipients ) ) { $ varRecipients = StringUtil :: splitCsv ( $ varRecipients ) ; } 
public function parse ( ) { $ strBuffer = parent :: parse ( ) ; 
protected function compile ( ) { 
protected function getLocaleString ( ) { $ container = System :: getContainer ( ) ; return 'var Contao={' . 'theme:"' . Backend :: getTheme ( ) . '",' . 'lang:{' . 'close:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'close' ] . '",' . 'collapse:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] . '",' . 'expand:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] . '",' . 'loading:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'loadingData' ] . '",' . 'apply:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'apply' ] . '"' . '},' . 'script_url:"' . $ container -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) . '",' . 'path:"' . Environment :: get ( 'path' ) . '",' . 'request_token:"' . REQUEST_TOKEN . '",' . 'referer_id:"' . $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) . '"' . '};' ; } 
protected function getDateString ( ) { return 'Locale.define("en-US","Date",{' . 'months:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] ) . '"],' . 'days:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] ) . '"],' . 'months_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] ) . '"],' . 'days_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] ) . '"]' . '});' . 'Locale.define("en-US","DatePicker",{' . 'select_a_time:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'select_a_time' ] . '",' . 'use_mouse_wheel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'use_mouse_wheel' ] . '",' . 'time_confirm_button:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'time_confirm_button' ] . '",' . 'apply_range:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'apply_range' ] . '",' . 'cancel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'cancel' ] . '",' . 'week:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'week' ] . '"' . '});' ; } 
public function enhance ( array $ defaults , Request $ request ) : array { if ( ! isset ( $ defaults [ 'pageModel' ] ) || ! $ defaults [ 'pageModel' ] instanceof PageModel ) { return $ defaults ; } $ this -> framework -> initialize ( true ) ; $ input = $ this -> framework -> getAdapter ( Input :: class ) ; if ( $ this -> prependLocale && ! empty ( $ defaults [ '_locale' ] ) ) { $ input -> setGet ( 'language' , $ defaults [ '_locale' ] ) ; } if ( empty ( $ defaults [ 'parameters' ] ) ) { return $ defaults ; } $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ fragments = explode ( '/' , substr ( $ defaults [ 'parameters' ] , 1 ) ) ; 
protected function compile ( ) { if ( TL_MODE == 'BE' ) { $ this -> strTemplate = 'be_wildcard' ; $ this -> Template = new BackendTemplate ( $ this -> strTemplate ) ; } 
public function run ( ) { switch ( Input :: get ( 'p' ) ) { case 'facebook' : return new RedirectResponse ( 'https://www.facebook.com/sharer/sharer.php' . '?u=' . rawurlencode ( Input :: get ( 'u' , true ) ) ) ; case 'twitter' : return new RedirectResponse ( 'https://twitter.com/intent/tweet' . '?url=' . rawurlencode ( Input :: get ( 'u' , true ) ) . '&text=' . rawurlencode ( Input :: get ( 't' , true ) ) ) ; case 'gplus' : return new RedirectResponse ( 'https://plus.google.com/share' . '?url=' . rawurlencode ( Input :: get ( 'u' , true ) ) ) ; } return new RedirectResponse ( '../' ) ; } 
protected function checkAccessToElement ( $ id , $ root , $ blnIsPid = false ) { if ( $ blnIsPid ) { $ objCalendar = $ this -> Database -> prepare ( "SELECT a.id, n.id AS nid FROM tl_calendar_events n, tl_calendar a WHERE n.id=? AND n.pid=a.id" ) -> limit ( 1 ) -> execute ( $ id ) ; } else { $ objCalendar = $ this -> Database -> prepare ( "SELECT a.id, n.id AS nid FROM tl_content c, tl_calendar_events n, tl_calendar a WHERE c.id=? AND c.pid=n.id AND n.pid=a.id" ) -> limit ( 1 ) -> execute ( $ id ) ; } 
protected function compile ( ) { global $ objPage ; $ this -> import ( FrontendUser :: class , 'User' ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ objPage -> language ; System :: loadLanguageFile ( 'tl_member' ) ; $ this -> loadDataContainer ( 'tl_member' ) ; 
public function generate ( $ objPage ) { $ this -> redirect ( $ this -> getForwardUrl ( $ objPage ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; } 
protected function getForwardUrl ( $ objPage ) { if ( $ objPage -> jumpTo ) { $ objNextPage = PageModel :: findPublishedById ( $ objPage -> jumpTo ) ; } else { $ objNextPage = PageModel :: findFirstPublishedRegularByPid ( $ objPage -> id ) ; } 
public function supportsValue ( PickerConfig $ config ) : bool { $ value = $ config -> getValue ( ) ; if ( 'file' === $ config -> getContext ( ) ) { return Validator :: isUuid ( $ value ) ; } return false !== strpos ( $ value , '{{file::' ) || 0 === strpos ( $ value , $ this -> uploadPath ) ; } 
public function getDcaAttributes ( PickerConfig $ config ) : array { if ( 'file' === $ config -> getContext ( ) ) { return $ this -> getFileDcaAttributes ( $ config ) ; } return $ this -> getLinkDcaAttributes ( $ config ) ; } 
public function convertDcaValue ( PickerConfig $ config , $ value ) : string { if ( 'file' === $ config -> getContext ( ) ) { return $ value ; } $ filesAdapter = $ this -> framework -> getAdapter ( FilesModel :: class ) ; $ filesModel = $ filesAdapter -> findByPath ( rawurldecode ( $ value ) ) ; if ( $ filesModel instanceof FilesModel ) { return '{{file::' . StringUtil :: binToUuid ( $ filesModel -> uuid ) . '}}' ; } return $ value ; } 
private function convertValueToPath ( string $ value ) : string { $ filesAdapter = $ this -> framework -> getAdapter ( FilesModel :: class ) ; if ( Validator :: isUuid ( $ value ) && ( $ filesModel = $ filesAdapter -> findByUuid ( $ value ) ) instanceof FilesModel ) { return $ filesModel -> path ; } return $ value ; } 
public function run ( ) { try { $ version = PackageUtil :: getVersion ( 'contao/core-bundle' ) ; } catch ( \ OutOfBoundsException $ e ) { $ version = PackageUtil :: getVersion ( 'contao/contao' ) ; } $ this -> Template -> version = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] . ' ' . $ version ; 
public function adjustPermissions ( $ insertId ) { 
protected function validator ( $ varInput ) { $ strUploadTo = 'system/tmp' ; 
public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } 
public function clearOptInData ( Contao \ DataContainer $ dc ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET addedOn='' WHERE id=?" ) -> execute ( $ dc -> id ) ; } 
public function checkUniqueRecipient ( $ varValue , Contao \ DataContainer $ dc ) { $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=? AND pid=(SELECT pid FROM tl_newsletter_recipients WHERE id=?) AND id!=?" ) -> execute ( $ varValue , $ dc -> id , $ dc -> id ) ; if ( $ objRecipient -> count > 0 ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unique' ] , $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ $ dc -> field ] [ 0 ] ) ) ; } return $ varValue ; } 
public function checkBlacklistedRecipient ( $ varValue , Contao \ DataContainer $ dc ) { $ objBlacklist = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_blacklist WHERE hash=? AND pid=(SELECT pid FROM tl_newsletter_recipients WHERE id=?) AND id!=?" ) -> execute ( md5 ( $ varValue ) , $ dc -> id , $ dc -> id ) ; if ( $ objBlacklist -> count > 0 ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'blacklisted' ] ) ; } return $ varValue ; } 
public function listRecipient ( $ row ) { $ label = Contao \ Idna :: decodeEmail ( $ row [ 'email' ] ) ; if ( $ row [ 'addedOn' ] ) { $ label .= ' <span style="color:#999;padding-left:3px">(' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'subscribed' ] , Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ row [ 'addedOn' ] ) ) . ')</span>' ; } else { $ label .= ' <span style="color:#999;padding-left:3px">(' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'manually' ] . ')</span>' ; } return sprintf ( '<div class="tl_content_left"><div class="list_icon" style="background-image:url(\'%ssystem/themes/%s/icons/%s.svg\')" data-icon="member.svg" data-icon-disabled="member_.svg">%s</div></div>' , Contao \ System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) , Contao \ Backend :: getTheme ( ) , ( $ row [ 'active' ] ? 'member' : 'member_' ) , $ label ) . "\n" ; } 
public function toggleIcon ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( \ strlen ( Contao \ Input :: get ( 'tid' ) ) ) { $ this -> toggleVisibility ( Contao \ Input :: get ( 'tid' ) , ( Contao \ Input :: get ( 'state' ) == 1 ) , ( @ func_get_arg ( 12 ) ? : null ) ) ; $ this -> redirect ( $ this -> getReferer ( ) ) ; } 
public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'asset' !== $ chunks [ 0 ] ) { return false ; } $ url = $ this -> packages -> getUrl ( $ chunks [ 1 ] , $ chunks [ 2 ] ?? null ) ; 
public function edit ( ) { $ return = '' ; $ ajaxId = null ; if ( Environment :: get ( 'isAjaxRequest' ) ) { $ ajaxId = func_get_arg ( 1 ) ; } </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> ' . implode ( ' ' , $ arrButtons ) . ' </div> </div> </form>' ; // Begin the form (-> DO NOT CHANGE THIS ORDER -> this way the onsubmit attribute of the form can be changed by a field) $ return = Message :: generate ( ) . ( $ this -> noReload ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] . '</p>' : '' ) . ' <div id="tl_buttons"> <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div> <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="' . $ this -> strTable . '" class="tl_form tl_edit_form" method="post"' . ( ! empty ( $ this -> onsubmit ) ? ' onsubmit="' . implode ( ' ' , $ this -> onsubmit ) . '"' : '' ) . '> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="' . $ this -> strTable . '"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"> <input type="hidden" name="FORM_FIELDS[]" value="' . StringUtil :: specialchars ( $ this -> strPalette ) . '">' . $ return ; // Reload the page to prevent _POST variables from being sent twice if ( Input :: post ( 'FORM_SUBMIT' ) == $ this -> strTable && ! $ this -> noReload ) { // Call onsubmit_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onsubmit_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onsubmit_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ this ) ; } } } // Reload if ( isset ( $ _POST [ 'saveNclose' ] ) ) { Message :: reset ( ) ; System :: setCookie ( 'BE_PAGE_OFFSET' , 0 , 0 ) ; $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ this -> reload ( ) ; } // Set the focus if there is an error if ( $ this -> noReload ) { $ return .= ' <script> window.addEvent(\'domready\', function() { Backend.vScrollTo(($(\'' . $ this -> strTable . '\').getElement(\'label.error\').getPosition().y - 20)); }); </script>' ; } return $ return ; } 
protected function save ( $ varValue ) { if ( Input :: post ( 'FORM_SUBMIT' ) != $ this -> strTable ) { return ; } $ arrData = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] ; 
public function getPalette ( ) { $ palette = 'default' ; $ strPalette = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'palettes' ] [ $ palette ] ; 
protected function compile ( ) { 
protected function compile ( ) { $ this -> import ( FrontendUser :: class , 'User' ) ; 
public function getResponse ( $ blnCheckRequest = false ) { $ this -> blnCheckRequest = $ blnCheckRequest ; return $ this -> setCacheHeaders ( parent :: getResponse ( ) ) ; } 
protected function compile ( ) { $ this -> keywords = '' ; $ arrKeywords = StringUtil :: trimsplit ( ',' , $ GLOBALS [ 'TL_KEYWORDS' ] ) ; 
public function section ( $ key , $ template = null ) { if ( empty ( $ this -> sections [ $ key ] ) ) { return ; } $ this -> id = $ key ; $ this -> content = $ this -> sections [ $ key ] ; if ( $ template === null ) { $ template = 'block_section' ; foreach ( $ this -> positions as $ position ) { if ( isset ( $ position [ $ key ] [ 'template' ] ) ) { $ template = $ position [ $ key ] [ 'template' ] ; } } } include $ this -> getTemplate ( $ template ) ; } 
public function sections ( $ key = null , $ template = null ) { if ( ! array_filter ( $ this -> sections ) ) { return ; } 
public static function addToUrl ( $ strRequest , $ blnIgnoreParams = false , $ arrUnset = array ( ) ) { return Frontend :: addToUrl ( $ strRequest , $ blnIgnoreParams , $ arrUnset ) ; } 
public function getCustomSections ( $ strKey = null ) { @ trigger_error ( 'Using FrontendTemplate::getCustomSections() has been deprecated and will no longer work in Contao 5.0. Use FrontendTemplate::sections() instead.' , E_USER_DEPRECATED ) ; if ( $ strKey != '' && ! isset ( $ this -> positions [ $ strKey ] ) ) { return '' ; } $ tag = 'div' ; 
private function setCacheHeaders ( Response $ response ) { global $ objPage ; if ( ( $ objPage -> cache === false || $ objPage -> cache < 1 ) && ( $ objPage -> clientCache === false || $ objPage -> clientCache < 1 ) ) { $ response -> headers -> addCacheControlDirective ( 'no-cache' ) ; $ response -> headers -> addCacheControlDirective ( 'no-store' ) ; return $ response -> setPrivate ( ) ; } 
public function generate ( $ objPage ) { $ this -> redirect ( $ this -> replaceInsertTags ( $ objPage -> url , false ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; } 
public function getResponse ( $ objPage ) { return new RedirectResponse ( $ this -> replaceInsertTags ( $ objPage -> url , false ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; } 
protected function compile ( ) { global $ objPage ; $ this -> import ( FrontendUser :: class , 'User' ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ objPage -> language ; System :: loadLanguageFile ( 'tl_member' ) ; $ this -> loadDataContainer ( 'tl_member' ) ; 
protected function compile ( ) { global $ objPage ; $ this -> Template -> articles = '' ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; 
public function showRelatedRecords ( $ data , $ row ) { Contao \ System :: loadLanguageFile ( 'tl_opt_in_related' ) ; Contao \ Controller :: loadDataContainer ( 'tl_opt_in_related' ) ; $ objRelated = $ this -> Database -> prepare ( "SELECT * FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ row [ 'id' ] ) ; while ( $ objRelated -> next ( ) ) { $ arrAdd = array ( ) ; $ arrRow = $ objRelated -> row ( ) ; foreach ( $ arrRow as $ k => $ v ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] ; $ arrAdd [ $ label ] = $ v ; } $ data [ 'tl_opt_in_related' ] [ ] = $ arrAdd ; } return $ data ; } 
public function resendToken ( Contao \ DataContainer $ dc ) { $ model = Contao \ OptInModel :: findByPk ( $ dc -> id ) ; Contao \ System :: getContainer ( ) -> get ( 'contao.opt-in' ) -> find ( $ model -> token ) -> send ( ) ; Contao \ Message :: addConfirmation ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resendToken' ] , $ model -> email ) ) ; Contao \ Controller :: redirect ( $ this -> getReferer ( ) ) ; } 
public function resendButton ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( ! $ row [ 'confirmedOn' ] && ! $ row [ 'invalidatedThrough' ] && $ row [ 'emailSubject' ] && $ row [ 'emailText' ] && $ row [ 'createdOn' ] > strtotime ( '-24 hours' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : '' ; } 
public function parse ( $ arrAttributes = null ) { 
public static function findBySourceParentAndEmail ( $ strSource , $ intParent , $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findOneBy ( array ( "$t.source=? AND $t.parent=? AND $t.email=?" ) , array ( $ strSource , $ intParent , $ strEmail ) , $ arrOptions ) ; } 
public static function findActiveBySourceAndParent ( $ strSource , $ intParent , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.source=? AND $t.parent=? AND $t.active='1'" ) , array ( $ strSource , $ intParent ) , $ arrOptions ) ; } 
public static function findExpiredSubscriptions ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE active='' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn<=? AND o.confirmedOn=0)" ) -> execute ( strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objResult , $ t ) ; } 
public function getStyleSheets ( Contao \ DataContainer $ dc ) { $ intPid = $ dc -> activeRecord -> pid ; if ( Contao \ Input :: get ( 'act' ) == 'overrideAll' ) { $ intPid = Contao \ Input :: get ( 'id' ) ; } $ objStyleSheet = $ this -> Database -> prepare ( "SELECT id, name FROM tl_style_sheet WHERE pid=?" ) -> execute ( $ intPid ) ; if ( $ objStyleSheet -> numRows < 1 ) { return array ( ) ; } $ return = array ( ) ; while ( $ objStyleSheet -> next ( ) ) { $ return [ $ objStyleSheet -> id ] = $ objStyleSheet -> name ; } return $ return ; } 
public function styleSheetLink ( Contao \ DataContainer $ dc ) { return ' <a href="contao/main.php?do=themes&amp;table=tl_style_sheet&amp;id=' . $ dc -> activeRecord -> pid . '&amp;popup=1&amp;nb=1&amp;rt=' . REQUEST_TOKEN . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . Contao \ StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) ) . '\',\'url\':this.href});return false">' . Contao \ Image :: getHtml ( 'edit.svg' ) . '</a>' ; } 
public function checkFramework ( $ value ) { if ( empty ( $ value ) ) { return '' ; } $ array = Contao \ StringUtil :: deserialize ( $ value ) ; if ( empty ( $ array ) || ! \ is_array ( $ array ) ) { return $ value ; } if ( ( $ i = array_search ( 'responsive.css' , $ array ) ) !== false && ! \ in_array ( 'layout.css' , $ array ) ) { array_insert ( $ array , $ i , 'layout.css' ) ; } return $ array ; } 
public function create ( string $ prefix , string $ email , array $ related ) : OptInTokenInterface { if ( $ prefix ) { $ prefix = rtrim ( $ prefix , '-' ) ; } if ( \ strlen ( $ prefix ) > 6 ) { throw new \ InvalidArgumentException ( 'The token prefix must not be longer than 6 characters' ) ; } $ token = bin2hex ( random_bytes ( 12 ) ) ; if ( $ prefix ) { $ token = $ prefix . '-' . substr ( $ token , \ strlen ( $ prefix ) + 1 ) ; } $ optIn = $ this -> framework -> createInstance ( OptInModel :: class ) ; $ optIn -> tstamp = time ( ) ; $ optIn -> token = $ token ; $ optIn -> createdOn = time ( ) ; 
public function find ( string $ identifier ) : ? OptInTokenInterface { $ adapter = $ this -> framework -> getAdapter ( OptInModel :: class ) ; if ( ! $ model = $ adapter -> findByToken ( $ identifier ) ) { return null ; } return new OptInToken ( $ model , $ this -> framework ) ; } 
public function purgeTokens ( ) : void { $ adapter = $ this -> framework -> getAdapter ( OptInModel :: class ) ; if ( ! $ tokens = $ adapter -> findExpiredTokens ( ) ) { return ; } $ adapter = $ this -> framework -> getAdapter ( Model :: class ) ; foreach ( $ tokens as $ token ) { $ delete = true ; $ related = $ token -> getRelatedRecords ( ) ; foreach ( $ related as $ table => $ id ) { $ model = $ this -> framework -> getAdapter ( $ adapter -> getClassFromTable ( $ table ) ) ; 
public function generate ( ) { $ arrUnits = array ( ) ; foreach ( $ this -> arrUnits as $ arrUnit ) { $ arrUnits [ ] = sprintf ( '<option value="%s"%s>%s</option>' , StringUtil :: specialchars ( $ arrUnit [ 'value' ] ) , $ this -> isSelected ( $ arrUnit ) , $ arrUnit [ 'label' ] ) ; } $ arrFields = array ( ) ; $ arrKeys = array ( 'top' , 'right' , 'bottom' , 'left' ) ; if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( ) ; } foreach ( $ arrKeys as $ strKey ) { $ arrFields [ ] = sprintf ( '<input type="text" name="%s[%s]" id="ctrl_%s" class="tl_text_trbl trbl_%s%s" value="%s"%s onfocus="Backend.getScrollOffset()">' , $ this -> strName , $ strKey , $ this -> strId . '_' . $ strKey , $ strKey , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , StringUtil :: specialchars ( @ $ this -> varValue [ $ strKey ] ) , 
public function generate ( ) { if ( $ this -> vimeo == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://vimeo.com/' . $ this -> vimeo . '" target="_blank" rel="noreferrer noopener">vimeo.com/' . $ this -> vimeo . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; } 
protected function compile ( ) { $ size = StringUtil :: deserialize ( $ this -> playerSize ) ; if ( ! \ is_array ( $ size ) || empty ( $ size [ 0 ] ) || empty ( $ size [ 1 ] ) ) { $ this -> Template -> size = ' width="640" height="360"' ; } else { $ this -> Template -> size = ' width="' . $ size [ 0 ] . '" height="' . $ size [ 1 ] . '"' ; } $ params = array ( ) ; $ options = StringUtil :: deserialize ( $ this -> vimeoOptions ) ; $ url = 'https://player.vimeo.com/video/' . $ this -> vimeo ; if ( \ is_array ( $ options ) ) { foreach ( $ options as $ option ) { switch ( $ option ) { case 'vimeo_portrait' : case 'vimeo_title' : case 'vimeo_byline' : $ params [ ] = substr ( $ option , 6 ) . '=0' ; break ; default : $ params [ ] = substr ( $ option , 6 ) . '=1' ; } } } if ( $ this -> playerColor ) { $ params [ ] = 'color=' . $ this -> playerColor ; } if ( ! empty ( $ params ) ) { $ url .= '?' . implode ( '&amp;' , $ params ) ; } if ( $ this -> playerStart > 0 ) { $ url .= '#t=' . ( int ) $ this -> playerStart . 's' ; } $ this -> Template -> src = $ url ; $ this -> Template -> aspect = str_replace ( ':' , '' , $ this -> playerAspect ) ; $ this -> Template -> caption = $ this -> playerCaption ; } 
protected function validator ( $ varInput ) { if ( \ is_array ( $ varInput ) ) { return parent :: validator ( $ varInput ) ; } if ( ! $ this -> multiple ) { 
public function generate ( ) { $ strType = $ this -> hideInput ? 'password' : 'text' ; if ( ! $ this -> multiple ) { 
protected function configure ( ) : void { $ this -> setName ( 'contao:automator' ) -> setDefinition ( [ new InputArgument ( 'task' , InputArgument :: OPTIONAL , sprintf ( "The name of the task:\n - %s" , implode ( "\n - " , $ this -> getCommands ( ) ) ) ) , ] ) -> setDescription ( 'Runs automator tasks on the command line.' ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : int { $ this -> framework -> initialize ( ) ; try { $ this -> runAutomator ( $ input , $ output ) ; } catch ( \ InvalidArgumentException $ e ) { $ output -> writeln ( sprintf ( '%s (see help contao:automator).' , $ e -> getMessage ( ) ) ) ; return 1 ; } return 0 ; } 
private function getTaskFromInput ( InputInterface $ input , OutputInterface $ output ) : string { $ commands = $ this -> getCommands ( ) ; $ task = $ input -> getArgument ( 'task' ) ; if ( null !== $ task ) { if ( ! \ in_array ( $ task , $ commands , true ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid task "%s"' , $ task ) ) ; 
public function validate ( ) { 
public function generate ( ) { return sprintf ( '<input type="file" name="%s" id="ctrl_%s" class="upload%s"%s%s' , $ this -> strName , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , $ this -> getAttributes ( ) , $ this -> strTagEnding ) ; } 
public static function encode ( $ strDomain ) { if ( $ strDomain == '' ) { return '' ; } $ objPunycode = new Punycode ( ) ; try { return $ objPunycode -> encode ( $ strDomain ) ; } catch ( LabelOutOfBoundsException $ e ) { return '' ; } } 
public static function decode ( $ strDomain ) { if ( $ strDomain == '' ) { return '' ; } $ objPunycode = new Punycode ( ) ; try { return $ objPunycode -> decode ( $ strDomain ) ; } catch ( LabelOutOfBoundsException $ e ) { return '' ; } } 
public static function encodeEmail ( $ strEmail ) { if ( $ strEmail == '' ) { return '' ; } if ( strpos ( $ strEmail , '@' ) === false ) { return $ strEmail ; 
public static function decodeEmail ( $ strEmail ) { if ( $ strEmail == '' ) { return '' ; } if ( strpos ( $ strEmail , '@' ) === false ) { return $ strEmail ; 
public static function encodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } 
public static function decodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } 
public function generate ( ) { $ this -> multiSRC = StringUtil :: deserialize ( $ this -> multiSRC ) ; if ( empty ( $ this -> multiSRC ) || ! \ is_array ( $ this -> multiSRC ) ) { return '' ; } $ this -> objFiles = FilesModel :: findMultipleByUuids ( $ this -> multiSRC ) ; if ( $ this -> objFiles === null ) { return '' ; } return parent :: generate ( ) ; } 
protected function compile ( ) { $ images = array ( ) ; $ objFiles = $ this -> objFiles ; 
public function generate ( ) { return sprintf ( '<input type="password" autocomplete="off" name="%s" id="ctrl_%s" class="tl_text tl_password%s" value="%s"%s onfocus="Backend.getScrollOffset()">%s%s' , $ this -> strName , $ this -> strId , ( \ strlen ( $ this -> strClass ) ? ' ' . $ this -> strClass : '' ) , ( ( $ this -> varValue != '' ) ? '*****' : '' ) , $ this -> getAttributes ( ) , $ this -> wizard , ( ( \ strlen ( $ this -> description ) && Config :: get ( 'showHelp' ) && ! $ this -> hasErrors ( ) ) ? "\n " . '<p class="tl_help tl_tip">' . $ this -> description . '</p>' : '' ) ) ; } 
public function generateConfirmationLabel ( ) { return sprintf ( '<label for="ctrl_%s_confirm" class="confirm%s">%s%s%s</label>' , $ this -> strId , ( \ strlen ( $ this -> strClass ) ? ' ' . $ this -> strClass : '' ) , ( $ this -> mandatory ? '<span class="invisible">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mandatory' ] . ' </span>' : '' ) , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'confirm' ] [ 0 ] , ( $ this -> mandatory ? '<span class="mandatory">*</span>' : '' ) ) ; } 
public function generateConfirmation ( ) { return sprintf ( '<input type="password" autocomplete="off" name="%s_confirm" id="ctrl_%s_confirm" class="tl_text tl_password confirm%s" value="%s"%s onfocus="Backend.getScrollOffset()">%s' , $ this -> strName , $ this -> strId , ( \ strlen ( $ this -> strClass ) ? ' ' . $ this -> strClass : '' ) , ( ( $ this -> varValue != '' ) ? '*****' : '' ) , $ this -> getAttributes ( ) , ( ( \ strlen ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'confirm' ] [ 1 ] ) && Config :: get ( 'showHelp' ) ) ? "\n " . '<p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'confirm' ] [ 1 ] . '</p>' : '' ) ) ; } 
public function generate ( ) { $ arrColButtons = array ( 'ccopy' , 'cmovel' , 'cmover' , 'cdelete' ) ; $ arrRowButtons = array ( 'rcopy' , 'rdelete' , 'rdrag' ) ; <table id="ctrl_' . $ this -> strId . '" class="tl_tablewizard"> <thead> <tr>' ; // Add column buttons for ( $ i = 0 , $ c = \ count ( $ this -> varValue [ 0 ] ) ; $ i < $ c ; $ i ++ ) { $ return .= ' <td>' ; // Add column buttons foreach ( $ arrColButtons as $ button ) { $ return .= ' <button type="button" data-command="' . $ button . '" class="tl_tablewizard_img" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_' . $ button ] ) . '">' . Image :: getHtml ( substr ( $ button , 1 ) . '.svg' ) . '</button>' ; } $ return .= '</td>' ; } $ return .= ' <td></td> </tr> </thead> <tbody class="sortable">' ; // Add rows for ( $ i = 0 , $ c = \ count ( $ this -> varValue ) ; $ i < $ c ; $ i ++ ) { $ return .= ' <tr>' ; // Add cells for ( $ j = 0 , $ d = \ count ( $ this -> varValue [ $ i ] ) ; $ j < $ d ; $ j ++ ) { $ return .= ' <td class="tcontainer"><textarea name="' . $ this -> strId . '[' . $ i . '][' . $ j . ']" class="tl_textarea noresize" rows="' . $ this -> intRows . '" cols="' . $ this -> intCols . '"' . $ this -> getAttributes ( ) . '>' . StringUtil :: specialchars ( $ this -> varValue [ $ i ] [ $ j ] ) . '</textarea></td>' ; } $ return .= ' <td>' ; // Add row buttons foreach ( $ arrRowButtons as $ button ) { if ( $ button == 'rdrag' ) { $ return .= ' <button type="button" class="drag-handle" title="' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'move' ] ) . '" aria-hidden="true">' . Image :: getHtml ( 'drag.svg' ) . '</button>' ; } else { $ return .= ' <button type="button" data-command="' . $ button . '" class="tl_tablewizard_img" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_' . $ button ] ) . '">' . Image :: getHtml ( substr ( $ button , 1 ) . '.svg' ) . '</button>' ; } } $ return .= '</td> </tr>' ; } $ return .= ' </tbody> </table> </div> <script>Backend.tableWizard("ctrl_' . $ this -> strId . '")</script>' ; return $ return ; } 
public function importTable ( DataContainer $ dc ) { $ response = System :: getContainer ( ) -> get ( 'contao.controller.backend_csv_import' ) -> importTableWizardAction ( $ dc ) ; if ( $ response instanceof RedirectResponse ) { throw new ResponseException ( $ response ) ; } return $ response -> getContent ( ) ; } 
public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( static :: $ strPk == 'id' ) { return static :: findById ( $ varValue , $ arrOptions ) ; } return parent :: findByPk ( $ varValue , $ arrOptions ) ; } 
public static function findById ( $ intId , array $ arrOptions = array ( ) ) { if ( Validator :: isUuid ( $ intId ) ) { return static :: findByUuid ( $ intId , $ arrOptions ) ; } return static :: findOneBy ( 'id' , $ intId , $ arrOptions ) ; } 
public static function findByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; 
public static function findMultipleByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } if ( Validator :: isUuid ( current ( $ arrIds ) ) ) { return static :: findMultipleByUuids ( $ arrIds , $ arrOptions ) ; } return parent :: findMultipleByIds ( $ arrIds , $ arrOptions ) ; } 
public static function findByUuid ( $ strUuid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; 
public static function findMultipleByUuids ( $ arrUuids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || ! \ is_array ( $ arrUuids ) ) { return null ; } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { 
public static function findByPath ( $ path , array $ arrOptions = array ( ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ path , $ rootDir . '/' , \ strlen ( $ rootDir ) + 1 ) === 0 ) { $ path = substr ( $ path , \ strlen ( $ rootDir ) + 1 ) ; } return static :: findOneBy ( 'path' , $ path , $ arrOptions ) ; } 
public static function findMultipleByPaths ( $ arrPaths , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPaths ) || ! \ is_array ( $ arrPaths ) ) { return null ; } $ t = static :: $ strTable ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.path" , $ arrPaths ) ; } return static :: findBy ( array ( "$t.path IN(" . implode ( ',' , array_fill ( 0 , \ count ( $ arrPaths ) , '?' ) ) . ")" ) , $ arrPaths , $ arrOptions ) ; } 
public static function findMultipleByUuidsAndExtensions ( $ arrUuids , $ arrExtensions , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || empty ( $ arrExtensions ) || ! \ is_array ( $ arrUuids ) || ! \ is_array ( $ arrExtensions ) ) { return null ; } foreach ( $ arrExtensions as $ k => $ v ) { if ( ! preg_match ( '/^[a-z0-9]{2,5}$/i' , $ v ) ) { unset ( $ arrExtensions [ $ k ] ) ; } } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { 
public static function findMultipleFilesByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='file' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; } 
public static function findMultipleFoldersByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='folder' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; } 
public function onPreviewUrlCreate ( PreviewUrlCreateEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || 'news' !== $ event -> getKey ( ) ) { return ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } 
public static function add ( $ strMessage , $ strType , $ strScope = TL_MODE ) { if ( $ strMessage == '' ) { return ; } if ( ! \ in_array ( $ strType , static :: getTypes ( ) ) ) { throw new \ Exception ( "Invalid message type $strType" ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> add ( static :: getFlashBagKey ( $ strType , $ strScope ) , $ strMessage ) ; } 
public static function generate ( $ strScope = TL_MODE ) { $ strMessages = static :: generateUnwrapped ( $ strScope ) ; if ( $ strMessages != '' ) { $ strMessages = '<div class="tl_message">' . $ strMessages . '</div>' ; } return $ strMessages ; } 
public static function generateUnwrapped ( $ strScope = TL_MODE , $ blnRaw = false ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return '' ; } $ strMessages = '' ; $ flashBag = $ session -> getFlashBag ( ) ; foreach ( static :: getTypes ( ) as $ strType ) { $ strClass = strtolower ( $ strType ) ; $ arrMessages = $ flashBag -> get ( static :: getFlashBagKey ( $ strType , $ strScope ) ) ; foreach ( array_unique ( $ arrMessages ) as $ strMessage ) { if ( $ strType == 'TL_RAW' || $ blnRaw ) { $ strMessages .= $ strMessage ; } else { $ strMessages .= '<p class="' . $ strClass . '">' . $ strMessage . '</p>' ; } } } return trim ( $ strMessages ) ; } 
public static function reset ( ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return ; } $ session -> getFlashBag ( ) -> clear ( ) ; } 
public static function hasError ( $ strScope = TL_MODE ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return false ; } return $ session -> getFlashBag ( ) -> has ( static :: getFlashBagKey ( 'error' , $ strScope ) ) ; } 
public static function hasMessages ( $ strScope = TL_MODE ) { return static :: hasError ( $ strScope ) || static :: hasConfirmation ( $ strScope ) || static :: hasNew ( $ strScope ) || static :: hasInfo ( $ strScope ) || static :: hasRaw ( $ strScope ) ; } 
public function getRouteByName ( $ name ) : Route { if ( 'contao_frontend' === $ name || 'contao_index' === $ name ) { return $ this -> frontendLoader -> load ( '.' , 'contao_frontend' ) -> get ( $ name ) ; } if ( 'contao_root' === $ name ) { return new Route ( '/' , [ '_scope' => 'frontend' , '_token_check' => true , '_controller' => 'Contao\CoreBundle\Controller\FrontendController::indexAction' , ] ) ; } if ( 'contao_catch_all' === $ name ) { return new Route ( '/{_url_fragment}' , [ '_scope' => 'frontend' , '_token_check' => true , '_controller' => 'Contao\CoreBundle\Controller\FrontendController::indexAction' , ] , [ '_url_fragment' => '.*' ] ) ; } return $ this -> routeProvider -> getRouteByName ( $ name ) ; } 
public function filter ( RouteCollection $ collection , Request $ request ) : RouteCollection { $ languages = $ request -> getLanguages ( ) ; foreach ( $ collection -> all ( ) as $ name => $ route ) { if ( '.fallback' !== substr ( $ name , - 9 ) && ( $ this -> prependLocale || '.root' !== substr ( $ name , - 5 ) ) ) { continue ; } $ pageModel = $ route -> getDefault ( 'pageModel' ) ; if ( ! $ pageModel instanceof PageModel || $ pageModel -> rootIsFallback || \ in_array ( $ pageModel -> rootLanguage , $ languages , true ) || preg_grep ( '/' . preg_quote ( $ pageModel -> rootLanguage , '/' ) . '_[A-Z]{2}/' , $ languages ) ) { continue ; } $ collection -> remove ( $ name ) ; } return $ collection ; } 
public function getBundles ( ParserInterface $ parser ) : array { return [ BundleConfig :: create ( KnpMenuBundle :: class ) , BundleConfig :: create ( KnpTimeBundle :: class ) , BundleConfig :: create ( SchebTwoFactorBundle :: class ) , BundleConfig :: create ( CmfRoutingBundle :: class ) , BundleConfig :: create ( ContaoCoreBundle :: class ) -> setReplace ( [ 'core' ] ) -> setLoadAfter ( [ FrameworkBundle :: class , SecurityBundle :: class , TwigBundle :: class , MonologBundle :: class , SwiftmailerBundle :: class , DoctrineBundle :: class , DoctrineCacheBundle :: class , KnpMenuBundle :: class , KnpTimeBundle :: class , LexikMaintenanceBundle :: class , NelmioCorsBundle :: class , NelmioSecurityBundle :: class , SchebTwoFactorBundle :: class , CmfRoutingBundle :: class , ContaoManagerBundle :: class , ] ) , ] ; } 
public function getRouteCollection ( LoaderResolverInterface $ resolver , KernelInterface $ kernel ) : ? RouteCollection { return $ resolver -> resolve ( __DIR__ . '/../Resources/config/routing.yml' ) -> load ( __DIR__ . '/../Resources/config/routing.yml' ) ; } 
public function logout ( Request $ request , Response $ response , TokenInterface $ token ) : void { $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof User ) { return ; } if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has logged out' , $ user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ user -> username ) ] ) ; } $ this -> triggerPostLogoutHook ( $ user ) ; } 
public function validate ( ) { $ mandatory = $ this -> mandatory ; $ options = $ this -> getPost ( $ this -> strName ) ; 
public function generate ( ) { $ arrButtons = array ( 'copy' , 'delete' , 'drag' ) ; <thead> <tr> <th>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'ow_value' ] . '</th> <th>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'ow_label' ] . '</th> <th></th> <th></th> <th></th> </tr> </thead> <tbody class="sortable">' ; // Add fields for ( $ i = 0 , $ c = \ count ( $ this -> varValue ) ; $ i < $ c ; $ i ++ ) { $ return .= ' <tr> <td><input type="text" name="' . $ this -> strId . '[' . $ i . '][value]" id="' . $ this -> strId . '_value_' . $ i . '" class="tl_text" value="' . StringUtil :: specialchars ( $ this -> varValue [ $ i ] [ 'value' ] ) . '"></td> <td><input type="text" name="' . $ this -> strId . '[' . $ i . '][label]" id="' . $ this -> strId . '_label_' . $ i . '" class="tl_text" value="' . StringUtil :: specialchars ( $ this -> varValue [ $ i ] [ 'label' ] ) . '"></td> <td><input type="checkbox" name="' . $ this -> strId . '[' . $ i . '][default]" id="' . $ this -> strId . '_default_' . $ i . '" class="fw_checkbox" value="1"' . ( $ this -> varValue [ $ i ] [ 'default' ] ? ' checked="checked"' : '' ) . '> <label for="' . $ this -> strId . '_default_' . $ i . '">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'ow_default' ] . '</label></td> <td><input type="checkbox" name="' . $ this -> strId . '[' . $ i . '][group]" id="' . $ this -> strId . '_group_' . $ i . '" class="fw_checkbox" value="1"' . ( $ this -> varValue [ $ i ] [ 'group' ] ? ' checked="checked"' : '' ) . '> <label for="' . $ this -> strId . '_group_' . $ i . '">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'ow_group' ] . '</label></td>' ; // Add row buttons $ return .= ' <td>' ; foreach ( $ arrButtons as $ button ) { if ( $ button == 'drag' ) { $ return .= ' <button type="button" class="drag-handle" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'move' ] ) . '" aria-hidden="true">' . Image :: getHtml ( 'drag.svg' ) . '</button>' ; } else { $ return .= ' <button type="button" data-command="' . $ button . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'ow_' . $ button ] ) . '">' . Image :: getHtml ( $ button . '.svg' ) . '</button>' ; } } $ return .= '</td> </tr>' ; } return $ return . ' </tbody> </table> <script>Backend.optionsWizard("ctrl_' . $ this -> strId . '")</script>' ; } 
public function getAllOptions ( ) : array { $ this -> loadOptions ( ) ; $ event = new ImageSizesEvent ( $ this -> options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_ALL , $ event ) ; return $ event -> getImageSizes ( ) ; } 
public function getOptionsForUser ( BackendUser $ user ) : array { $ this -> loadOptions ( ) ; if ( $ user -> isAdmin ) { $ event = new ImageSizesEvent ( $ this -> options , $ user ) ; } else { $ options = array_map ( static function ( $ val ) { return is_numeric ( $ val ) ? ( int ) $ val : $ val ; } , StringUtil :: deserialize ( $ user -> imageSizes , true ) ) ; $ event = new ImageSizesEvent ( $ this -> filterOptions ( $ options ) , $ user ) ; } $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_USER , $ event ) ; return $ event -> getImageSizes ( ) ; } 
private function loadOptions ( ) : void { if ( null !== $ this -> options ) { return ; } 
private function filterOptions ( array $ allowedSizes ) : array { if ( empty ( $ allowedSizes ) ) { return [ ] ; } $ filteredSizes = [ ] ; foreach ( $ this -> options as $ group => $ sizes ) { if ( 'image_sizes' === $ group ) { $ this -> filterImageSizes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } else { $ this -> filterResizeModes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } } return $ filteredSizes ; } 
public static function getPageIdFromUrl ( ) { @ trigger_error ( 'Using Frontend::getPageIdFromUrl() has been deprecated and will no longer work in Contao 5.0. Use the Symfony routing instead.' , E_USER_DEPRECATED ) ; $ strRequest = Environment :: get ( 'relativeRequest' ) ; if ( $ strRequest == '' ) { return null ; } 
public static function getRootPageFromUrl ( ) { $ host = Environment :: get ( 'host' ) ; $ logger = System :: getContainer ( ) -> get ( 'monolog.logger.contao' ) ; $ accept_language = Environment :: get ( 'httpAcceptLanguage' ) ; 
public static function addToUrl ( $ strRequest , $ blnIgnoreParams = false , $ arrUnset = array ( ) ) { $ arrGet = $ blnIgnoreParams ? array ( ) : $ _GET ; 
protected function jumpToOrReload ( $ intId , $ strParams = null , $ strForceLang = null ) { if ( $ strForceLang !== null ) { @ trigger_error ( 'Using Frontend::jumpToOrReload() with $strForceLang has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; } global $ objPage ; 
protected function getLoginStatus ( $ strCookie ) { @ trigger_error ( 'Using Frontend::getLoginStatus() has been deprecated and will no longer work in Contao 5.0. Use Symfony security instead.' , E_USER_DEPRECATED ) ; $ objTokenChecker = System :: getContainer ( ) -> get ( 'contao.security.token_checker' ) ; if ( $ strCookie == 'BE_USER_AUTH' && $ objTokenChecker -> hasBackendUser ( ) ) { 
public static function getMetaData ( $ strData , $ strLanguage ) { if ( empty ( $ strLanguage ) ) { return array ( ) ; } $ arrData = StringUtil :: deserialize ( $ strData ) ; 
protected function prepareMetaDescription ( $ strText ) { $ strText = $ this -> replaceInsertTags ( $ strText , false ) ; $ strText = strip_tags ( $ strText ) ; $ strText = str_replace ( "\n" , ' ' , $ strText ) ; $ strText = StringUtil :: substr ( $ strText , 320 ) ; return trim ( $ strText ) ; } 
public static function indexPageIfApplicable ( Response $ objResponse ) { global $ objPage ; if ( $ objPage === null ) { return ; } 
public function generateRss ( ) { $ this -> adjustPublicationDate ( ) ; $ xml = '<?xml version="1.0" encoding="' . Config :: get ( 'characterSet' ) . '"?>' ; $ xml .= '<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/" xmlns:atom="http://www.w3.org/2005/Atom">' ; $ xml .= '<channel>' ; $ xml .= '<title>' . StringUtil :: specialchars ( $ this -> title ) . '</title>' ; $ xml .= '<description>' . StringUtil :: specialchars ( $ this -> description ) . '</description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ this -> link ) . '</link>' ; $ xml .= '<language>' . $ this -> language . '</language>' ; $ xml .= '<pubDate>' . date ( 'r' , $ this -> published ) . '</pubDate>' ; $ xml .= '<generator>Contao Open Source CMS</generator>' ; $ xml .= '<atom:link href="' . StringUtil :: specialchars ( Environment :: get ( 'base' ) . 'share/' . $ this -> strName ) . '.xml" rel="self" type="application/rss+xml" />' ; foreach ( $ this -> arrItems as $ objItem ) { $ xml .= '<item>' ; $ xml .= '<title>' . StringUtil :: specialchars ( strip_tags ( StringUtil :: stripInsertTags ( $ objItem -> title ) ) ) . '</title>' ; $ xml .= '<description><![CDATA[' . preg_replace ( '/[\n\r]+/' , ' ' , $ objItem -> description ) . ']]></description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ objItem -> link ) . '</link>' ; $ xml .= '<pubDate>' . date ( 'r' , $ objItem -> published ) . '</pubDate>' ; 
protected function adjustPublicationDate ( ) { if ( ! empty ( $ this -> arrItems ) && $ this -> arrItems [ 0 ] -> published > $ this -> published ) { $ this -> published = $ this -> arrItems [ 0 ] -> published ; } } 
protected function compile ( ) { $ arrItems = array ( ) ; $ items = StringUtil :: deserialize ( $ this -> listitems , true ) ; $ limit = \ count ( $ items ) - 1 ; for ( $ i = 0 , $ c = \ count ( $ items ) ; $ i < $ c ; $ i ++ ) { $ arrItems [ ] = array ( 'class' => ( ( $ i == 0 ) ? 'first' : ( ( $ i == $ limit ) ? 'last' : '' ) ) , 'content' => $ items [ $ i ] ) ; } $ this -> Template -> items = $ arrItems ; $ this -> Template -> tag = ( $ this -> listtype == 'ordered' ) ? 'ol' : 'ul' ; } 
public function dump ( ) : void { if ( empty ( $ this -> parameters [ 'parameters' ] [ 'secret' ] ) || 'ThisTokenIsNotSoSecretChangeIt' === $ this -> parameters [ 'parameters' ] [ 'secret' ] ) { $ this -> parameters [ 'parameters' ] [ 'secret' ] = bin2hex ( random_bytes ( 32 ) ) ; } if ( isset ( $ this -> parameters [ 'parameters' ] [ 'database_port' ] ) ) { $ this -> parameters [ 'parameters' ] [ 'database_port' ] = ( int ) $ this -> parameters [ 'parameters' ] [ 'database_port' ] ; } $ this -> filesystem -> dumpFile ( $ this -> rootDir . '/app/config/parameters.yml' , "# This file has been auto-generated during installation\n" . Yaml :: dump ( $ this -> getEscapedValues ( ) ) ) ; } 
private function getEscapedValues ( ) : array { $ parameters = [ ] ; foreach ( $ this -> parameters [ 'parameters' ] as $ key => $ value ) { if ( \ is_string ( $ value ) ) { if ( 0 === strncmp ( $ value , '@' , 1 ) ) { $ value = '@' . $ value ; } if ( false !== strpos ( $ value , '%' ) ) { $ value = str_replace ( '%' , '%%' , $ value ) ; } } $ parameters [ $ key ] = $ value ; } return [ 'parameters' => $ parameters ] ; } 
public function getLocale ( ) : string { foreach ( $ this -> getAcceptedLocales ( ) as $ locale ) { if ( file_exists ( $ this -> translationsDir . '/messages.' . $ locale . '.xlf' ) ) { return $ locale ; } } return 'en' ; } 
private function getAcceptedLocales ( ) : array { $ accepted = [ ] ; $ locales = [ ] ; 
private function fetchData ( FileUpload $ uploader , string $ separator , callable $ callback ) : array { $ data = [ ] ; $ files = $ this -> getFiles ( $ uploader ) ; $ delimiter = $ this -> getDelimiter ( $ separator ) ; foreach ( $ files as $ file ) { $ fp = fopen ( $ file , 'r' ) ; while ( false !== ( $ row = fgetcsv ( $ fp , 0 , $ delimiter ) ) ) { $ data = $ callback ( $ data , $ row ) ; } } return $ data ; } 
private function getFiles ( FileUpload $ uploader ) : array { $ files = $ uploader -> uploadTo ( 'system/tmp' ) ; if ( \ count ( $ files ) < 1 ) { throw new \ RuntimeException ( $ this -> translator -> trans ( 'ERR.all_fields' , [ ] , 'contao_default' ) ) ; } foreach ( $ files as & $ file ) { $ extension = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( 'csv' !== $ extension ) { throw new \ RuntimeException ( sprintf ( $ this -> translator -> trans ( 'ERR.filetype' , [ ] , 'contao_default' ) , $ extension ) ) ; } $ file = $ this -> projectDir . '/' . $ file ; } return $ files ; } 
public static function getVersion ( string $ packageName ) : string { $ version = Versions :: getVersion ( $ packageName ) ; return static :: parseVersion ( $ version ) ; } 
public static function getNormalizedVersion ( string $ packageName ) : string { $ chunks = explode ( '.' , static :: getVersion ( $ packageName ) ) ; $ chunks += [ 0 , 0 , 0 ] ; if ( \ count ( $ chunks ) > 3 ) { $ chunks = \ array_slice ( $ chunks , 0 , 3 ) ; } return implode ( '.' , $ chunks ) ; } 
public function generate ( ) { $ arrObjects = array ( 'u' => 'cuser' , 'g' => 'cgroup' , 'w' => 'cworld' ) ; $ return = ' <table id="ctrl_defaultChmod" class="tl_chmod"> <tr> <th></th> <th scope="col">' . $ GLOBALS [ 'TL_LANG' ] [ 'CHMOD' ] [ 'editpage' ] . '</th> <th scope="col">' . $ GLOBALS [ 'TL_LANG' ] [ 'CHMOD' ] [ 'editnavigation' ] . '</th> <th scope="col">' . $ GLOBALS [ 'TL_LANG' ] [ 'CHMOD' ] [ 'deletepage' ] . '</th> <th scope="col">' . $ GLOBALS [ 'TL_LANG' ] [ 'CHMOD' ] [ 'editarticles' ] . '</th> <th scope="col">' . $ GLOBALS [ 'TL_LANG' ] [ 'CHMOD' ] [ 'movearticles' ] . '</th> <th scope="col">' . $ GLOBALS [ 'TL_LANG' ] [ 'CHMOD' ] [ 'deletearticles' ] . '</th> </tr>' ; <tr> <th scope="row">' . $ GLOBALS [ 'TL_LANG' ] [ 'CHMOD' ] [ $ v ] . '</th>' ; // Add checkboxes for ( $ j = 1 ; $ j <= 6 ; $ j ++ ) { $ return .= ' <td><input type="checkbox" name="' . $ this -> strName . '[]" value="' . StringUtil :: specialchars ( $ k . $ j ) . '"' . static :: optionChecked ( $ k . $ j , $ this -> varValue ) . ' onfocus="Backend.getScrollOffset()"></td>' ; } $ return .= ' </tr>' ; } return $ return . ' </table>' ; } 
protected function compile ( ) { $ rows = StringUtil :: deserialize ( $ this -> tableitems , true ) ; $ this -> Template -> id = 'table_' . $ this -> id ; $ this -> Template -> summary = StringUtil :: specialchars ( $ this -> summary ) ; $ this -> Template -> useHeader = $ this -> thead ? true : false ; $ this -> Template -> useFooter = $ this -> tfoot ? true : false ; $ this -> Template -> useLeftTh = $ this -> tleft ? true : false ; $ this -> Template -> sortable = $ this -> sortable ? true : false ; $ arrHeader = array ( ) ; $ arrBody = array ( ) ; $ arrFooter = array ( ) ; 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : void { $ path = $ this -> projectDir . '/.env' ; if ( ! file_exists ( $ path ) ) { return ; } $ vars = ( new Dotenv ( ) ) -> parse ( file_get_contents ( $ path ) ) ; $ key = $ input -> getArgument ( 'key' ) ; if ( ! $ key ) { $ output -> write ( json_encode ( $ vars ) ) ; } if ( isset ( $ vars [ $ key ] ) ) { $ output -> write ( $ vars [ $ key ] ) ; } } 
public function addAttributes ( $ arrAttributes ) { parent :: addAttributes ( $ arrAttributes ) ; if ( $ this -> type != 'number' ) { return ; } foreach ( array ( 'minlength' , 'minval' , 'maxlength' , 'maxval' ) as $ name ) { if ( isset ( $ arrAttributes [ $ name ] ) ) { $ this -> $ name = $ arrAttributes [ $ name ] ; } } } 
public function generate ( ) { return sprintf ( '<input type="%s" name="%s" id="ctrl_%s" class="text%s%s" value="%s"%s%s' , $ this -> type , $ this -> strName , $ this -> strId , ( $ this -> hideInput ? ' password' : '' ) , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , StringUtil :: specialchars ( $ this -> value ) , $ this -> getAttributes ( ) , $ this -> strTagEnding ) ; } 
public function run ( ) : void { SELECT id, scripts FROM tl_layout ' ) ; while ( false !== ( $ layout = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) ) { $ scripts = StringUtil :: deserialize ( $ layout -> scripts ) ; if ( ! empty ( $ scripts ) && \ is_array ( $ scripts ) ) { $ scripts [ ] = 'js_autofocus' ; $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_layout SET scripts = :scripts WHERE id = :id ' ) ; $ stmt -> execute ( [ ':scripts' => serialize ( array_values ( array_unique ( $ scripts ) ) ) , ':id' => $ layout -> id ] ) ; } } $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; if ( $ schemaManager -> tablesExist ( [ 'tl_calendar_events' ] ) ) { $ this -> enableOverwriteMeta ( 'tl_calendar_events' ) ; } if ( $ schemaManager -> tablesExist ( [ 'tl_faq' ] ) ) { $ this -> enableOverwriteMeta ( 'tl_faq' ) ; } if ( $ schemaManager -> tablesExist ( [ 'tl_news' ] ) ) { $ this -> enableOverwriteMeta ( 'tl_news' ) ; } $ this -> connection -> query ( " ALTER TABLE tl_content CHANGE title imageTitle varchar(255) NOT NULL DEFAULT '' " ) ; $ this -> connection -> query ( " ALTER TABLE tl_content ADD overwriteMeta CHAR(1) DEFAULT '' NOT NULL " ) ; $ this -> connection -> query ( " UPDATE tl_content SET overwriteMeta = '1' WHERE alt != '' OR imageTitle != '' OR imageUrl != '' OR caption != '' " ) ; } 
protected function validateForm ( Widget $ objWidget = null ) { 
protected function removeRecipient ( $ strEmail , $ arrRemove ) { 
public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( $ exception -> getPrevious ( ) instanceof ResourceNotFoundException && ! $ this -> hasRootPages ( ) ) { $ exception = new NoRootPageFoundException ( 'No root page found' , 0 , $ exception ) ; } $ class = $ this -> getTargetClass ( $ exception ) ; if ( null === $ class ) { return ; } if ( null !== ( $ httpException = $ this -> convertToHttpException ( $ exception , $ class ) ) ) { $ event -> setException ( $ httpException ) ; } } 
public function generate ( ) { return sprintf ( '<input type="hidden" name="%s" value="%s"%s' , $ this -> strName , StringUtil :: specialchars ( $ this -> varValue ) , $ this -> strTagEnding ) ; } 
public function trans ( $ id , array $ parameters = [ ] , $ domain = null , $ locale = null ) : string { 
private function getFromGlobals ( string $ id ) : ? string { 
private function loadLanguageFile ( string $ name ) : void { $ system = $ this -> framework -> getAdapter ( System :: class ) ; $ system -> loadLanguageFile ( $ name ) ; } 
public function onInitializeSystem ( ) : void { foreach ( $ this -> globals as $ key => $ value ) { if ( \ is_array ( $ value ) && isset ( $ GLOBALS [ $ key ] ) && \ is_array ( $ GLOBALS [ $ key ] ) ) { $ GLOBALS [ $ key ] = array_replace_recursive ( $ GLOBALS [ $ key ] , $ value ) ; } else { $ GLOBALS [ $ key ] = $ value ; } } } 
public function run ( ) { $ objTemplate = new BackendTemplate ( 'be_alerts' ) ; $ objTemplate -> theme = Backend :: getTheme ( ) ; $ objTemplate -> base = Environment :: get ( 'base' ) ; $ objTemplate -> language = $ GLOBALS [ 'TL_LANGUAGE' ] ; $ objTemplate -> title = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'systemMessages' ] ) ; $ objTemplate -> host = Environment :: get ( 'host' ) ; $ objTemplate -> charset = Config :: get ( 'characterSet' ) ; $ objTemplate -> messages = Message :: generateUnwrapped ( ) . Backend :: getSystemMessages ( ) ; $ objTemplate -> noMessages = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'noSystemMessages' ] ; return $ objTemplate -> getResponse ( ) ; } 
public function dump ( $ files , $ cacheFile , array $ options = [ ] ) : void { $ buffer = $ this -> header ; $ type = $ options [ 'type' ] ?? null ; foreach ( ( array ) $ files as $ file ) { $ buffer .= $ this -> loader -> load ( $ file , $ type ) ; } $ this -> filesystem -> dumpFile ( $ this -> cacheDir . '/' . $ cacheFile , $ buffer ) ; } 
public function indexAction ( ) : InitializeControllerResponse { @ trigger_error ( 'Custom entry points are deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ masterRequest = $ this -> get ( 'request_stack' ) -> getMasterRequest ( ) ; if ( null === $ masterRequest ) { throw new \ RuntimeException ( 'The request stack did not contain a master request.' ) ; } $ realRequest = Request :: createFromGlobals ( ) ; 
public static function findByCalendar ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.calendars LIKE '%\"" . ( int ) $ intId . "\"%'" ) , null , $ arrOptions ) ; } 
public static function addNamespace ( $ name ) { @ trigger_error ( 'Using ClassLoader::addNamespace() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ in_array ( $ name , self :: $ namespaces ) ) { return ; } array_unshift ( self :: $ namespaces , $ name ) ; } 
public static function addNamespaces ( $ names ) { @ trigger_error ( 'Using ClassLoader::addNamespaces() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; foreach ( $ names as $ name ) { self :: addNamespace ( $ name ) ; } } 
public static function addClasses ( $ classes ) { @ trigger_error ( 'Using ClassLoader::addClasses() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; foreach ( $ classes as $ class => $ file ) { self :: addClass ( $ class , $ file ) ; } } 
public static function load ( $ class ) { if ( class_exists ( $ class , false ) || interface_exists ( $ class , false ) || trait_exists ( $ class , false ) ) { return ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; 
public static function scanAndRegister ( ) { $ strCacheDir = System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ; 
public static function findPublishedByPidAndTable ( $ intPid , $ strParentTable , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; 
public static function countPublishedByPidAndTable ( $ intPid , $ strParentTable , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : void { $ fs = new Filesystem ( ) ; $ path = $ this -> projectDir . '/.env' ; if ( ! $ fs -> exists ( $ path ) ) { return ; } $ content = '' ; $ lines = file ( $ path , FILE_IGNORE_NEW_LINES ) ; if ( false === $ lines ) { throw new \ RuntimeException ( sprintf ( 'Could not read "%s" file.' , $ path ) ) ; } $ key = $ input -> getArgument ( 'key' ) ; foreach ( $ lines as $ line ) { if ( 0 === strpos ( $ line , $ key . '=' ) ) { continue ; } $ content .= $ line . "\n" ; } if ( empty ( $ content ) ) { $ fs -> remove ( $ path ) ; } else { $ fs -> dumpFile ( $ path , $ content ) ; } } 
public function run ( ) { $ objRouter = System :: getContainer ( ) -> get ( 'router' ) ; 
public function uploadTo ( $ strTarget ) { if ( $ strTarget == '' || Validator :: isInsecurePath ( $ strTarget ) ) { throw new \ InvalidArgumentException ( 'Invalid target path ' . $ strTarget ) ; } $ maxlength_kb = static :: getMaxUploadSize ( ) ; $ maxlength_kb_readable = $ this -> getReadableSize ( $ maxlength_kb ) ; $ arrUploaded = array ( ) ; $ arrFiles = $ this -> getFilesFromGlobal ( ) ; foreach ( $ arrFiles as $ file ) { 
public function generateMarkup ( ) { $ return = ' <div> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple required> </div>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; } 
protected function getFilesFromGlobal ( ) { 
protected function resizeUploadedImage ( $ strImage ) { 
public function getConfiguration ( array $ config , ContainerBuilder $ container ) : Configuration { return new Configuration ( $ container -> getParameter ( 'kernel.project_dir' ) , $ container -> getParameter ( 'kernel.default_locale' ) ) ; } 
public function load ( array $ configs , ContainerBuilder $ container ) : void { $ configuration = new Configuration ( $ container -> getParameter ( 'kernel.project_dir' ) , $ container -> getParameter ( 'kernel.default_locale' ) ) ; $ config = $ this -> processConfiguration ( $ configuration , $ configs ) ; $ loader = new YamlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; static $ files = [ 'commands.yml' , 'listener.yml' , 'services.yml' , ] ; foreach ( $ files as $ file ) { $ loader -> load ( $ file ) ; } $ container -> setParameter ( 'contao.web_dir' , $ config [ 'web_dir' ] ) ; $ container -> setParameter ( 'contao.prepend_locale' , $ config [ 'prepend_locale' ] ) ; $ container -> setParameter ( 'contao.encryption_key' , $ config [ 'encryption_key' ] ) ; $ container -> setParameter ( 'contao.url_suffix' , $ config [ 'url_suffix' ] ) ; $ container -> setParameter ( 'contao.upload_path' , $ config [ 'upload_path' ] ) ; $ container -> setParameter ( 'contao.csrf_token_name' , $ config [ 'csrf_token_name' ] ) ; $ container -> setParameter ( 'contao.pretty_error_screens' , $ config [ 'pretty_error_screens' ] ) ; $ container -> setParameter ( 'contao.error_level' , $ config [ 'error_level' ] ) ; $ container -> setParameter ( 'contao.locales' , $ config [ 'locales' ] ) ; $ container -> setParameter ( 'contao.image.bypass_cache' , $ config [ 'image' ] [ 'bypass_cache' ] ) ; $ container -> setParameter ( 'contao.image.target_dir' , $ config [ 'image' ] [ 'target_dir' ] ) ; $ container -> setParameter ( 'contao.image.valid_extensions' , $ config [ 'image' ] [ 'valid_extensions' ] ) ; $ container -> setParameter ( 'contao.image.imagine_options' , $ config [ 'image' ] [ 'imagine_options' ] ) ; $ container -> setParameter ( 'contao.image.reject_large_uploads' , $ config [ 'image' ] [ 'reject_large_uploads' ] ) ; $ container -> setParameter ( 'contao.security.two_factor.enforce_backend' , $ config [ 'security' ] [ 'two_factor' ] [ 'enforce_backend' ] ) ; if ( isset ( $ config [ 'localconfig' ] ) ) { $ container -> setParameter ( 'contao.localconfig' , $ config [ 'localconfig' ] ) ; } $ this -> setImagineService ( $ config , $ container ) ; $ this -> overwriteImageTargetDir ( $ config , $ container ) ; $ container -> registerForAutoconfiguration ( PickerProviderInterface :: class ) -> addTag ( 'contao.picker_provider' ) ; } 
private function setImagineService ( array $ config , ContainerBuilder $ container ) : void { $ imagineServiceId = $ config [ 'image' ] [ 'imagine_service' ] ; 
private function overwriteImageTargetDir ( array $ config , ContainerBuilder $ container ) : void { if ( ! isset ( $ config [ 'image' ] [ 'target_path' ] ) ) { return ; } $ container -> setParameter ( 'contao.image.target_dir' , $ container -> getParameter ( 'kernel.project_dir' ) . '/' . $ config [ 'image' ] [ 'target_path' ] ) ; @ trigger_error ( 'Using the contao.image.target_path parameter has been deprecated and will no longer work in Contao 5.0. Use the contao.image.target_dir parameter instead.' , E_USER_DEPRECATED ) ; } 
public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; 
public static function findPublishedByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; } 
public static function findFirstPublishedRootByHostAndLanguage ( $ strHost , $ varLanguage , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using PageModel::findFirstPublishedRootByHostAndLanguage() has been deprecated and will no longer work Contao 5.0.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; if ( \ is_array ( $ varLanguage ) ) { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='')" ) ; if ( ! empty ( $ varLanguage ) ) { $ arrColumns [ ] = "($t.language IN('" . implode ( "','" , $ varLanguage ) . "') OR $t.fallback='1')" ; } else { $ arrColumns [ ] = "$t.fallback='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC" . ( ! empty ( $ varLanguage ) ? ", " . $ objDatabase -> findInSet ( "$t.language" , array_reverse ( $ varLanguage ) ) . " DESC" : "" ) . ", $t.sorting" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; } else { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='') AND ($t.language=? OR $t.fallback='1')" ) ; $ arrValues = array ( $ strHost , $ varLanguage ) ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC, $t.fallback" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; } } 
public static function findFirstPublishedByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.type!='root' AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findOneBy ( $ arrColumns , $ intPid , $ arrOptions ) ; } 
public static function findByAliases ( $ arrAliases , array $ arrOptions = array ( ) ) { if ( empty ( $ arrAliases ) || ! \ is_array ( $ arrAliases ) ) { return null ; } 
public static function findPublishedByIdOrAlias ( $ varId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ varId , $ arrOptions ) ; } 
public static function findPublishedSubpagesWithoutGuestsByPid ( $ intPid , $ blnShowHidden = false , $ blnIsSitemap = false ) { $ time = Date :: floorToMinute ( ) ; $ objSubpages = Database :: getInstance ( ) -> prepare ( "SELECT p1.*, (SELECT COUNT(*) FROM tl_page p2 WHERE p2.pid=p1.id AND p2.type!='root' AND p2.type!='error_401' AND p2.type!='error_403' AND p2.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p2.hide='' OR sitemap='map_always')" : " AND p2.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p2.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p2.start='' OR p2.start<='$time') AND (p2.stop='' OR p2.stop>'" . ( $ time + 60 ) . "') AND p2.published='1'" : "" ) . ") AS subpages FROM tl_page p1 WHERE p1.pid=? AND p1.type!='root' AND p1.type!='error_401' AND p1.type!='error_403' AND p1.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p1.hide='' OR sitemap='map_always')" : " AND p1.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p1.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p1.start='' OR p1.start<='$time') AND (p1.stop='' OR p1.stop>'" . ( $ time + 60 ) . "') AND p1.published='1'" : "" ) . " ORDER BY p1.sorting" ) -> execute ( $ intPid ) ; if ( $ objSubpages -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objSubpages , 'tl_page' ) ; } 
public static function findPublishedRegularWithoutGuestsByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( empty ( $ arrOptions [ 'includeRoot' ] ) ) { $ arrColumns [ ] = "$t.type!='root'" ; } if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.id" , $ arrIds ) ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; } 
public static function findPublishedRegularWithoutGuestsByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.type!='root' AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; } 
public static function findPublishedFallbackByHostname ( $ strHost , array $ arrOptions = array ( ) ) { 
public static function findPublishedRootPages ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.type=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , 'root' , $ arrOptions ) ; } 
public static function findParentsById ( $ intId ) { $ arrModels = array ( ) ; while ( $ intId > 0 && ( $ objPage = static :: findByPk ( $ intId ) ) !== null ) { $ intId = $ objPage -> pid ; $ arrModels [ ] = $ objPage ; } if ( empty ( $ arrModels ) ) { return null ; } return static :: createCollection ( $ arrModels , 'tl_page' ) ; } 
public static function findFirstActiveByMemberGroups ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objPage = $ objRegistry -> fetch ( 'tl_page' , $ objResult -> id ) ) { return $ objPage ; } return new static ( $ objResult ) ; } 
public static function findWithDetails ( $ intId ) { $ objPage = static :: findByPk ( $ intId ) ; if ( $ objPage === null ) { return null ; } return $ objPage -> loadDetails ( ) ; } 
public function onRegister ( Registry $ registry ) { parent :: onRegister ( $ registry ) ; 
public function onUnregister ( Registry $ registry ) { parent :: onUnregister ( $ registry ) ; 
public function loadDetails ( ) { 
public function getFrontendUrl ( $ strParams = null , $ strForceLang = null ) { if ( $ strForceLang !== null ) { @ trigger_error ( 'Using PageModel::getFrontendUrl() with $strForceLang has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; } $ this -> loadDetails ( ) ; $ objUrlGenerator = System :: getContainer ( ) -> get ( 'contao.routing.url_generator' ) ; $ strUrl = $ objUrlGenerator -> generate ( ( $ this -> alias ? : $ this -> id ) . $ strParams , array ( '_locale' => ( $ strForceLang ? : $ this -> rootLanguage ) , '_domain' => $ this -> domain , '_ssl' => ( bool ) $ this -> rootUseSSL , ) ) ; 
public function getAbsoluteUrl ( $ strParams = null ) { $ this -> loadDetails ( ) ; $ objUrlGenerator = System :: getContainer ( ) -> get ( 'contao.routing.url_generator' ) ; $ strUrl = $ objUrlGenerator -> generate ( ( $ this -> alias ? : $ this -> id ) . $ strParams , array ( '_locale' => $ this -> rootLanguage , '_domain' => $ this -> domain , '_ssl' => ( bool ) $ this -> rootUseSSL , ) , UrlGeneratorInterface :: ABSOLUTE_URL ) ; $ strUrl = $ this -> applyLegacyLogic ( $ strUrl , $ strParams ) ; return $ strUrl ; } 
public function getSlugOptions ( ) { $ slugOptions = array ( 'locale' => $ this -> language ) ; if ( $ this -> validAliasCharacters ) { $ slugOptions [ 'validChars' ] = $ this -> validAliasCharacters ; } return $ slugOptions ; } 
private function applyLegacyLogic ( $ strUrl , $ strParams ) { 
public function create ( $ path , $ size = null ) : PictureInterface { $ attributes = [ ] ; if ( $ path instanceof ImageInterface ) { $ image = $ path ; } else { $ image = $ this -> imageFactory -> create ( $ path ) ; } if ( \ is_array ( $ size ) && isset ( $ size [ 2 ] ) && \ is_string ( $ size [ 2 ] ) && 1 === substr_count ( $ size [ 2 ] , '_' ) ) { $ image -> setImportantPart ( $ this -> imageFactory -> getImportantPartFromLegacyMode ( $ image , $ size [ 2 ] ) ) ; $ size [ 2 ] = ResizeConfigurationInterface :: MODE_CROP ; } if ( $ size instanceof PictureConfigurationInterface ) { $ config = $ size ; } else { [ $ config , $ attributes ] = $ this -> createConfig ( $ size ) ; } $ picture = $ this -> pictureGenerator -> generate ( $ image , $ config , ( new ResizeOptions ( ) ) -> setImagineOptions ( $ this -> imagineOptions ) -> setBypassCache ( $ this -> bypassCache ) ) ; return $ this -> addImageAttributes ( $ picture , $ attributes ) ; } 
private function createConfig ( $ size ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new PictureConfiguration ( ) ; $ attributes = [ ] ; if ( ! isset ( $ size [ 2 ] ) || ! is_numeric ( $ size [ 2 ] ) ) { $ resizeConfig = new ResizeConfiguration ( ) ; if ( ! empty ( $ size [ 0 ] ) ) { $ resizeConfig -> setWidth ( ( int ) $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ resizeConfig -> setHeight ( ( int ) $ size [ 1 ] ) ; } if ( ! empty ( $ size [ 2 ] ) ) { $ resizeConfig -> setMode ( $ size [ 2 ] ) ; } $ configItem = new PictureConfigurationItem ( ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( $ this -> defaultDensities ) { $ configItem -> setDensities ( $ this -> defaultDensities ) ; } $ config -> setSize ( $ configItem ) ; return [ $ config , $ attributes ] ; } $ imageSizeModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSizes = $ imageSizeModel -> findByPk ( $ size [ 2 ] ) ; $ config -> setSize ( $ this -> createConfigItem ( $ imageSizes ) ) ; if ( $ imageSizes && $ imageSizes -> cssClass ) { $ attributes [ 'class' ] = $ imageSizes -> cssClass ; } $ imageSizeItemModel = $ this -> framework -> getAdapter ( ImageSizeItemModel :: class ) ; $ imageSizeItems = $ imageSizeItemModel -> findVisibleByPid ( $ size [ 2 ] , [ 'order' => 'sorting ASC' ] ) ; if ( null !== $ imageSizeItems ) { $ configItems = [ ] ; foreach ( $ imageSizeItems as $ imageSizeItem ) { $ configItems [ ] = $ this -> createConfigItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ configItems ) ; } return [ $ config , $ attributes ] ; } 
private function createConfigItem ( $ imageSize ) : PictureConfigurationItem { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; if ( null !== $ imageSize ) { $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) -> setSizes ( $ imageSize -> sizes ) -> setDensities ( $ imageSize -> densities ) ; if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } } return $ configItem ; } 
protected function validator ( $ varInput ) { $ varInput [ 2 ] = preg_replace ( '/[^a-z0-9_]+/' , '' , $ varInput [ 2 ] ) ; if ( ! is_numeric ( $ varInput [ 2 ] ) ) { switch ( $ varInput [ 2 ] ) { 
protected function isValidOption ( $ varInput ) { if ( $ varInput == '' ) { return true ; } foreach ( $ this -> arrAvailableOptions as $ strGroup => $ arrValues ) { if ( $ strGroup == 'image_sizes' ) { if ( isset ( $ arrValues [ $ varInput ] ) ) { return true ; } } elseif ( \ in_array ( $ varInput , $ arrValues ) ) { return true ; } } return false ; } 
public function generate ( ) { if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } $ arrFields = array ( ) ; $ arrOptions = array ( ) ; foreach ( $ this -> arrOptions as $ strKey => $ arrOption ) { if ( isset ( $ arrOption [ 'value' ] ) ) { $ arrOptions [ ] = sprintf ( '<option value="%s"%s>%s</option>' , StringUtil :: specialchars ( $ arrOption [ 'value' ] ) , $ this -> optionSelected ( $ arrOption [ 'value' ] , $ this -> varValue [ 2 ] ) , $ arrOption [ 'label' ] ) ; } else { $ arrOptgroups = array ( ) ; foreach ( $ arrOption as $ arrOptgroup ) { $ arrOptgroups [ ] = sprintf ( '<option value="%s"%s>%s</option>' , StringUtil :: specialchars ( $ arrOptgroup [ 'value' ] ) , $ this -> optionSelected ( $ arrOptgroup [ 'value' ] , $ this -> varValue [ 2 ] ) , $ arrOptgroup [ 'label' ] ) ; } $ arrOptions [ ] = sprintf ( '<optgroup label="&nbsp;%s">%s</optgroup>' , StringUtil :: specialchars ( $ strKey ) , implode ( '' , $ arrOptgroups ) ) ; } } $ arrFields [ ] = sprintf ( '<select name="%s[2]" id="ctrl_%s" class="tl_select_interval" onfocus="Backend.getScrollOffset()"%s>%s</select>' , $ this -> strName , $ this -> strId . '_3' , $ this -> getAttribute ( 'disabled' ) , implode ( ' ' , $ arrOptions ) ) ; for ( $ i = 0 ; $ i < 2 ; $ i ++ ) { $ arrFields [ ] = sprintf ( '<input type="text" name="%s[%s]" id="ctrl_%s" class="tl_text_4 tl_imageSize_%s" value="%s"%s onfocus="Backend.getScrollOffset()">' , $ this -> strName , $ i , $ this -> strId . '_' . $ i , $ i , StringUtil :: specialchars ( @ $ this -> varValue [ $ i ] ) , 
public static function symlink ( string $ target , string $ link , string $ rootDir ) : void { static :: validateSymlink ( $ target , $ link , $ rootDir ) ; $ fs = new Filesystem ( ) ; if ( ! $ fs -> isAbsolutePath ( $ target ) ) { $ target = $ rootDir . '/' . $ target ; } if ( ! $ fs -> isAbsolutePath ( $ link ) ) { $ link = $ rootDir . '/' . $ link ; } if ( '\\' === \ DIRECTORY_SEPARATOR ) { $ fs -> symlink ( $ target , $ link ) ; } else { $ fs -> symlink ( rtrim ( $ fs -> makePathRelative ( $ target , \ dirname ( $ link ) ) , '/' ) , $ link ) ; } } 
public static function validateSymlink ( string $ target , string $ link , string $ rootDir ) : void { if ( '' === $ target ) { throw new \ InvalidArgumentException ( 'The symlink target must not be empty.' ) ; } if ( '' === $ link ) { throw new \ InvalidArgumentException ( 'The symlink path must not be empty.' ) ; } if ( false !== strpos ( $ link , '../' ) ) { throw new \ InvalidArgumentException ( 'The symlink path must not be relative.' ) ; } $ fs = new Filesystem ( ) ; if ( $ fs -> exists ( $ rootDir . '/' . $ link ) && ! is_link ( $ rootDir . '/' . $ link ) ) { throw new \ LogicException ( sprintf ( 'The path "%s" exists and is not a symlink.' , $ link ) ) ; } } 
public static function findByEmailAndPids ( $ strEmail , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.email=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) , $ strEmail , $ arrOptions ) ; } 
public static function create ( array $ parameters ) : ? Connection { $ params = [ 'driver' => 'pdo_mysql' , 'host' => $ parameters [ 'parameters' ] [ 'database_host' ] , 'port' => $ parameters [ 'parameters' ] [ 'database_port' ] , 'user' => $ parameters [ 'parameters' ] [ 'database_user' ] , 'password' => $ parameters [ 'parameters' ] [ 'database_password' ] , 'dbname' => $ parameters [ 'parameters' ] [ 'database_name' ] , ] ; try { return DriverManager :: getConnection ( $ params ) ; } catch ( DBALException $ e ) { 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ return = '<pre>' . htmlspecialchars ( $ this -> code ) . '</pre>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; } 
protected function compile ( ) { if ( $ this -> highlight == 'C#' ) { $ this -> highlight = 'csharp' ; } elseif ( $ this -> highlight == 'C++' ) { $ this -> highlight = 'cpp' ; } $ this -> Template -> code = htmlspecialchars ( $ this -> code ) ; $ this -> Template -> cssClass = strtolower ( $ this -> highlight ) ? : 'nohighlight' ; } 
final protected function execute ( InputInterface $ input , OutputInterface $ output ) : int { @ trigger_error ( 'Using the AbstractLockedCommand has been deprecated and will no longer work in Contao 5.0. Use the lock service instead.' , E_USER_DEPRECATED ) ; $ store = new FlockStore ( $ this -> getTempDir ( ) ) ; $ factory = new Factory ( $ store ) ; $ lock = $ factory -> createLock ( $ this -> getName ( ) ) ; if ( ! $ lock -> acquire ( ) ) { $ output -> writeln ( 'The command is already running in another process.' ) ; return 1 ; } if ( ( $ errorCode = $ this -> executeLocked ( $ input , $ output ) ) > 0 ) { $ lock -> release ( ) ; return $ errorCode ; } $ lock -> release ( ) ; return 0 ; } 
private function getTempDir ( ) : string { $ container = $ this -> getContainer ( ) ; $ tmpDir = sys_get_temp_dir ( ) . '/' . md5 ( $ container -> getParameter ( 'kernel.project_dir' ) ) ; if ( ! is_dir ( $ tmpDir ) ) { $ container -> get ( 'filesystem' ) -> mkdir ( $ tmpDir ) ; } return $ tmpDir ; } 
public function onSchemaIndexDefinition ( SchemaIndexDefinitionEventArgs $ event ) : void { 
public function handle ( array $ record ) : bool { if ( ! $ this -> isHandling ( $ record ) ) { return false ; } $ record = $ this -> processRecord ( $ record ) ; $ record [ 'formatted' ] = $ this -> getFormatter ( ) -> format ( $ record ) ; if ( ! isset ( $ record [ 'extra' ] [ 'contao' ] ) || ! ( $ record [ 'extra' ] [ 'contao' ] instanceof ContaoContext ) ) { return false ; } try { $ this -> write ( $ record ) ; } catch ( \ Exception $ e ) { return false ; } $ this -> executeHook ( $ record [ 'message' ] , $ record [ 'extra' ] [ 'contao' ] ) ; return false === $ this -> bubble ; } 
protected function write ( array $ record ) : void { $ this -> createStatement ( ) ; $ date = $ record [ 'datetime' ] ; $ context = $ record [ 'extra' ] [ 'contao' ] ; $ this -> statement -> execute ( [ 'tstamp' => $ date -> format ( 'U' ) , 'text' => StringUtil :: specialchars ( ( string ) $ record [ 'formatted' ] ) , 'source' => ( string ) $ context -> getSource ( ) , 'action' => ( string ) $ context -> getAction ( ) , 'username' => ( string ) $ context -> getUsername ( ) , 'func' => $ context -> getFunc ( ) , 'browser' => StringUtil :: specialchars ( ( string ) $ context -> getBrowser ( ) ) , ] ) ; } 
private function createStatement ( ) : void { if ( null !== $ this -> statement ) { return ; } if ( null === $ this -> container || ! $ this -> container -> has ( $ this -> dbalServiceName ) ) { throw new \ RuntimeException ( 'The container has not been injected or the database service is missing' ) ; } $ connection = $ this -> container -> get ( $ this -> dbalServiceName ) ; $ this -> statement = $ connection -> prepare ( ' INSERT INTO tl_log (tstamp, source, action, username, text, func, browser) VALUES (:tstamp, :source, :action, :username, :text, :func, :browser) ' ) ; } 
private function executeHook ( string $ message , ContaoContext $ context ) : void { if ( null === $ this -> container || ! $ this -> container -> has ( 'contao.framework' ) ) { return ; } $ framework = $ this -> container -> get ( 'contao.framework' ) ; if ( ! $ this -> hasAddLogEntryHook ( ) || ! $ framework -> isInitialized ( ) ) { return ; } @ trigger_error ( 'Using the addLogEntry hook has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ system = $ framework -> getAdapter ( System :: class ) ; 
public function findBy ( $ strColumn , $ varValue ) { if ( parent :: findBy ( $ strColumn , $ varValue ) === false ) { return false ; } $ this -> arrGroups = $ this -> groups ; return true ; } 
public function save ( ) { $ groups = $ this -> groups ; $ this -> arrData [ 'groups' ] = $ this -> arrGroups ; parent :: save ( ) ; $ this -> groups = $ groups ; } 
protected function setUserFromDb ( ) { $ this -> intId = $ this -> id ; 
public static function create ( $ file , $ size = null ) { if ( \ is_string ( $ file ) ) { $ file = new File ( rawurldecode ( $ file ) ) ; } $ imageSize = null ; $ picture = new static ( $ file ) ; 
public function getTemplateData ( ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ image = System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ this -> image -> getOriginalPath ( ) ) ; $ config = new PictureConfiguration ( ) ; $ config -> setSize ( $ this -> getConfigurationItem ( $ this -> imageSize ) ) ; $ sizeItems = array ( ) ; foreach ( $ this -> imageSizeItems as $ imageSizeItem ) { $ sizeItems [ ] = $ this -> getConfigurationItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ sizeItems ) ; $ importantPart = $ this -> image -> getImportantPart ( ) ; $ image -> setImportantPart ( new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ) ; $ container = System :: getContainer ( ) ; $ staticUrl = $ container -> get ( 'contao.assets.files_context' ) -> getStaticUrl ( ) ; $ picture = $ container -> get ( 'contao.image.picture_generator' ) -> generate ( $ image , $ config , ( new ResizeOptions ( ) ) -> setImagineOptions ( $ container -> getParameter ( 'contao.image.imagine_options' ) ) -> setBypassCache ( $ container -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; return array ( 'img' => $ picture -> getImg ( $ rootDir , $ staticUrl ) , 'sources' => $ picture -> getSources ( $ rootDir , $ staticUrl ) , ) ; } 
protected function getConfigurationItem ( $ imageSize ) { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; $ mode = $ imageSize -> resizeMode ; if ( substr_count ( $ mode , '_' ) === 1 ) { $ importantPart = $ this -> image -> setImportantPart ( null ) -> getImportantPart ( ) ; $ mode = explode ( '_' , $ mode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } $ this -> image -> setImportantPart ( $ importantPart ) ; $ mode = ResizeConfiguration :: MODE_CROP ; } $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setZoomLevel ( $ imageSize -> zoom ) ; if ( $ mode ) { $ resizeConfig -> setMode ( $ mode ) ; } $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( isset ( $ imageSize -> sizes ) ) { $ configItem -> setSizes ( $ imageSize -> sizes ) ; } if ( isset ( $ imageSize -> densities ) ) { $ configItem -> setDensities ( $ imageSize -> densities ) ; } if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } return $ configItem ; } 
public function generate ( ) { $ arrOptions = array ( ) ; foreach ( $ this -> arrOptions as $ i => $ arrOption ) { $ arrOptions [ ] = sprintf ( '<input type="radio" name="%s" id="opt_%s" class="tl_radio" value="%s"%s%s onfocus="Backend.getScrollOffset()"> <label for="opt_%s">%s</label>' , $ this -> strName , $ this -> strId . '_' . $ i , StringUtil :: specialchars ( $ arrOption [ 'value' ] ) , $ this -> isChecked ( $ arrOption ) , $ this -> getAttributes ( ) , $ this -> strId . '_' . $ i , $ arrOption [ 'label' ] ) ; } 
protected function validator ( $ varInput ) { $ arrTitles = array ( ) ; $ arrIds = array ( ) ; $ arrSections = array ( ) ; foreach ( $ varInput as $ arrSection ) { 
public function generate ( ) { $ arrButtons = array ( 'copy' , 'delete' , 'drag' ) ; <thead> <tr> <th>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'sw_title' ] . '</th> <th>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'sw_id' ] . '</th> <th>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'sw_template' ] . '</th> <th>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'sw_position' ] . '</th> <th></th> </tr> </thead> <tbody class="sortable">' ; // Add the input fields for ( $ i = 0 , $ c = \ count ( $ this -> varValue ) ; $ i < $ c ; $ i ++ ) { $ return .= ' <tr> <td><input type="text" name="' . $ this -> strId . '[' . $ i . '][title]" id="' . $ this -> strId . '_title_' . $ i . '" class="tl_text" value="' . StringUtil :: specialchars ( $ this -> varValue [ $ i ] [ 'title' ] ) . '"></td> <td><input type="text" name="' . $ this -> strId . '[' . $ i . '][id]" id="' . $ this -> strId . '_id_' . $ i . '" class="tl_text" value="' . StringUtil :: specialchars ( $ this -> varValue [ $ i ] [ 'id' ] ) . '"></td>' ; $ options = '' ; // Add the template foreach ( Template :: getTemplateGroup ( 'block_section_' ) as $ k => $ v ) { $ options .= '<option value="' . StringUtil :: specialchars ( $ k ) . '"' . static :: optionSelected ( $ k , $ this -> varValue [ $ i ] [ 'template' ] ) . '>' . $ v . '</option>' ; } $ return .= ' <td><select name="' . $ this -> strId . '[' . $ i . '][template]" class="tl_select" onfocus="Backend.getScrollOffset()">' . $ options . '</select></td>' ; $ options = '' ; // Add the positions foreach ( array ( 'top' , 'before' , 'main' , 'after' , 'bottom' , 'manual' ) as $ v ) { $ options .= '<option value="' . StringUtil :: specialchars ( $ v ) . '"' . static :: optionSelected ( $ v , $ this -> varValue [ $ i ] [ 'position' ] ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'SECTIONS' ] [ $ v ] . '</option>' ; } $ return .= ' <td><select name="' . $ this -> strId . '[' . $ i . '][position]" class="tl_select" onfocus="Backend.getScrollOffset()">' . $ options . '</select></td> <td>' ; // Add the buttons foreach ( $ arrButtons as $ button ) { if ( $ button == 'drag' ) { $ return .= ' <button type="button" class="drag-handle" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'move' ] ) . '" aria-hidden="true">' . Image :: getHtml ( 'drag.svg' ) . '</button>' ; } else { $ return .= ' <button type="button" data-command="' . $ button . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mw_' . $ button ] ) . '">' . Image :: getHtml ( $ button . '.svg' ) . '</button>' ; } } $ return .= '</td> </tr>' ; } return $ return . ' </tbody> </table> <script>Backend.sectionWizard("ctrl_' . $ this -> strId . '")</script>' ; } 
public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; 
public function setRootType ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: get ( 'act' ) != 'create' ) { return ; } 
public function checkRootType ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue != 'root' && $ dc -> activeRecord -> pid == 0 ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'topLevelRoot' ] ) ; } return $ varValue ; } 
public function showFallbackWarning ( ) { if ( Contao \ Input :: get ( 'act' ) != '' ) { return ; } $ messages = new Contao \ Messages ( ) ; Contao \ Message :: addRaw ( $ messages -> languageFallback ( ) ) ; } 
public function makeRedirectPageMandatory ( Contao \ DataContainer $ dc ) { $ objPage = $ this -> Database -> prepare ( "SELECT * FROM " . $ dc -> table . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objPage -> numRows && $ objPage -> type == 'logout' ) { $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'fields' ] [ 'jumpTo' ] [ 'eval' ] [ 'mandatory' ] = true ; } } 
public function generateSitemap ( ) { $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; if ( empty ( $ session ) || ! \ is_array ( $ session ) ) { return ; } $ this -> import ( 'Contao\Automator' , 'Automator' ) ; foreach ( $ session as $ id ) { $ this -> Automator -> generateSitemap ( $ id ) ; } $ objSession -> set ( 'sitemap_updater' , null ) ; } 
public function scheduleUpdate ( Contao \ DataContainer $ dc ) { 
public function generateAlias ( $ varValue , Contao \ DataContainer $ dc ) { $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> id ) ; $ aliasExists = function ( string $ alias ) use ( $ dc , $ objPage ) : bool { $ objAliasIds = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE alias=? AND id!=?" ) -> execute ( $ alias , $ dc -> id ) ; if ( ! $ objAliasIds -> numRows ) { return false ; } $ strCurrentDomain = $ objPage -> domain ; $ strCurrentLanguage = $ objPage -> rootLanguage ; if ( $ objPage -> type == 'root' ) { $ strCurrentDomain = Contao \ Input :: post ( 'dns' ) ; $ strCurrentLanguage = Contao \ Input :: post ( 'language' ) ; } while ( $ objAliasIds -> next ( ) ) { $ objAliasPage = Contao \ PageModel :: findWithDetails ( $ objAliasIds -> id ) ; if ( $ objAliasPage -> domain != $ strCurrentDomain ) { continue ; } if ( Contao \ Config :: get ( 'addLanguageToUrl' ) && $ objAliasPage -> rootLanguage != $ strCurrentLanguage ) { continue ; } 
public function generateArticle ( Contao \ DataContainer $ dc ) { 
public function purgeSearchIndex ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ objResult = $ this -> Database -> prepare ( "SELECT id FROM tl_search WHERE pid=?" ) -> execute ( $ dc -> id ) ; while ( $ objResult -> next ( ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ this -> Database -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } } 
public function checkFeedAlias ( $ varValue , Contao \ DataContainer $ dc ) { 
public function checkJumpTo ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == $ dc -> id ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'circularReference' ] ) ; } return $ varValue ; } 
public function checkFallback ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == '' ) { return '' ; } $ objPage = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE type='root' AND fallback=1 AND dns=? AND id!=?" ) -> execute ( $ dc -> activeRecord -> dns , $ dc -> activeRecord -> id ) ; if ( $ objPage -> numRows ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'multipleFallback' ] ) ; } return $ varValue ; } 
public function getPageTypes ( Contao \ DataContainer $ dc ) { $ arrOptions = array ( ) ; foreach ( array_keys ( $ GLOBALS [ 'TL_PTY' ] ) as $ pty ) { 
public function getPageLayouts ( ) { $ objLayout = $ this -> Database -> execute ( "SELECT l.id, l.name, t.name AS theme FROM tl_layout l LEFT JOIN tl_theme t ON l.pid=t.id ORDER BY t.name, l.name" ) ; if ( $ objLayout -> numRows < 1 ) { return array ( ) ; } $ return = array ( ) ; while ( $ objLayout -> next ( ) ) { $ return [ $ objLayout -> theme ] [ $ objLayout -> id ] = $ objLayout -> name ; } return $ return ; } 
public function addIcon ( $ row , $ label , Contao \ DataContainer $ dc = null , $ imageAttribute = '' , $ blnReturnImage = false , $ blnProtected = false ) { return Contao \ Backend :: addPageIcon ( $ row , $ label , $ dc , $ imageAttribute , $ blnReturnImage , $ blnProtected ) ; } 
public function copyPageWithSubpages ( $ row , $ href , $ label , $ title , $ icon , $ attributes , $ table ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'closed' ] ) { return '' ; } $ objSubpages = Contao \ PageModel :: findByPid ( $ row [ 'id' ] ) ; return ( $ objSubpages !== null && $ objSubpages -> count ( ) > 0 && $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_PAGE_HIERARCHY , $ row ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } 
public function cutPage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_PAGE_HIERARCHY , $ row ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } 
public function pastePage ( Contao \ DataContainer $ dc , $ row , $ table , $ cr , $ arrClipboard = null ) { $ disablePA = false ; $ disablePI = false ; 
public function deletePage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ root = func_get_arg ( 7 ) ; return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_DELETE_PAGE , $ row ) && ( $ this -> User -> isAdmin || ! \ in_array ( $ row [ 'id' ] , $ root ) ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } 
public function addAliasButton ( $ arrButtons , Contao \ DataContainer $ dc ) { 
protected function compile ( ) { global $ objPage ; $ this -> Template -> event = '' ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; 
private function getDateAndTime ( CalendarEventsModel $ objEvent , PageModel $ objPage , $ intStartTime , $ intEndTime , $ span ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) ; if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> dateFormat , $ intEndTime ) ; } $ strTime = '' ; if ( $ objEvent -> addTime ) { if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> datimFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> datimFormat , $ intEndTime ) ; } elseif ( $ intStartTime == $ intEndTime ) { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) ; } else { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> timeFormat , $ intEndTime ) ; } } return array ( $ strDate , $ strTime ) ; } 
public function run ( ) : void { $ this -> connection -> query ( ' ALTER TABLE tl_layout ADD scripts text NULL ' ) ; SELECT id, addJQuery, jquery, addMooTools, mootools FROM tl_layout WHERE framework != '' " ) ; while ( false !== ( $ layout = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) ) { $ scripts = [ ] ; // Check if j_slider is enabled if ( $ layout -> addJQuery ) { $ jquery = StringUtil :: deserialize ( $ layout -> jquery ) ; if ( ! empty ( $ jquery ) && \ is_array ( $ jquery ) ) { $ key = array_search ( 'j_slider' , $ jquery , true ) ; if ( false !== $ key ) { $ scripts [ ] = 'js_slider' ; unset ( $ jquery [ $ key ] ) ; $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_layout SET jquery = :jquery WHERE id = :id ' ) ; $ stmt -> execute ( [ ':jquery' => serialize ( array_values ( $ jquery ) ) , ':id' => $ layout -> id ] ) ; } } } // Check if moo_slider is enabled if ( $ layout -> addMooTools ) { $ mootools = StringUtil :: deserialize ( $ layout -> mootools ) ; if ( ! empty ( $ mootools ) && \ is_array ( $ mootools ) ) { $ key = array_search ( 'moo_slider' , $ mootools , true ) ; if ( false !== $ key ) { $ scripts [ ] = 'js_slider' ; unset ( $ mootools [ $ key ] ) ; $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_layout SET mootools = :mootools WHERE id = :id ' ) ; $ stmt -> execute ( [ ':mootools' => serialize ( array_values ( $ mootools ) ) , ':id' => $ layout -> id ] ) ; } } } // Enable the js_slider template if ( ! empty ( $ scripts ) ) { $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_layout SET scripts = :scripts WHERE id = :id ' ) ; $ stmt -> execute ( [ ':scripts' => serialize ( array_values ( $ scripts ) ) , ':id' => $ layout -> id ] ) ; } } // Replace moo_slimbox with moo_mediabox $ statement = $ this -> connection -> query ( " SELECT id, mootools FROM tl_layout WHERE framework != '' " ) ; while ( false !== ( $ layout = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) ) { $ mootools = StringUtil :: deserialize ( $ layout -> mootools ) ; if ( ! empty ( $ mootools ) && \ is_array ( $ mootools ) ) { $ key = array_search ( 'moo_slimbox' , $ mootools , true ) ; if ( false !== $ key ) { $ mootools [ ] = 'moo_mediabox' ; unset ( $ mootools [ $ key ] ) ; $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_layout SET mootools = :mootools WHERE id = :id ' ) ; $ stmt -> execute ( [ ':mootools' => serialize ( array_values ( $ mootools ) ) , ':id' => $ layout -> id ] ) ; } } } // Adjust the list of framework style sheets $ statement = $ this -> connection -> query ( " SELECT id, framework FROM tl_layout WHERE framework != '' " ) ; while ( false !== ( $ layout = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) ) { $ framework = StringUtil :: deserialize ( $ layout -> framework ) ; if ( ! empty ( $ framework ) && \ is_array ( $ framework ) ) { $ key = array_search ( 'tinymce.css' , $ framework , true ) ; if ( false !== $ key ) { unset ( $ framework [ $ key ] ) ; $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_layout SET framework = :framework WHERE id = :id ' ) ; $ stmt -> execute ( [ ':framework' => serialize ( array_values ( $ framework ) ) , ':id' => $ layout -> id ] ) ; } } } // Adjust the module types $ this -> connection -> query ( " UPDATE tl_module SET type = 'articlelist' WHERE type = 'articleList' " ) ; $ this -> connection -> query ( " UPDATE tl_module SET type = 'rssReader' WHERE type = 'rss_reader' " ) ; $ this -> connection -> query ( " UPDATE tl_form_field SET type = 'explanation' WHERE type = 'headline' " ) ; } 
public function warmUp ( $ cacheDir ) : void { if ( ! $ this -> isCompleteInstallation ( ) ) { return ; } $ this -> framework -> initialize ( ) ; $ this -> generateConfigCache ( $ cacheDir ) ; $ this -> generateDcaCache ( $ cacheDir ) ; $ this -> generateLanguageCache ( $ cacheDir ) ; $ this -> generateDcaExtracts ( $ cacheDir ) ; $ this -> generateTemplateMapper ( $ cacheDir ) ; } 
public function getAllowedArchives ( ) { if ( $ this -> User -> isAdmin ) { $ objArchive = Contao \ NewsArchiveModel :: findAll ( ) ; } else { $ objArchive = Contao \ NewsArchiveModel :: findMultipleByIds ( $ this -> User -> news ) ; } $ return = array ( ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { $ return [ $ objArchive -> id ] = $ objArchive -> title ; } } return $ return ; } 
public function getAllTables ( ) { $ arrTables = $ this -> Database -> listTables ( ) ; $ arrViews = Contao \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> listViews ( ) ; if ( ! empty ( $ arrViews ) ) { $ arrTables = array_merge ( $ arrTables , array_keys ( $ arrViews ) ) ; natsort ( $ arrTables ) ; } return array_values ( $ arrTables ) ; } 
public function purgeSearchTables ( ) { $ objDatabase = Database :: getInstance ( ) ; 
public function purgeVersionTable ( ) { $ objDatabase = Database :: getInstance ( ) ; 
public function purgeImageCache ( ) { $ container = System :: getContainer ( ) ; $ strTargetPath = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.image.target_dir' ) ) ; $ strRootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; 
public function purgeScriptCache ( ) { 
public function purgePageCache ( ) { $ strCacheDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCacheDir . '/http_cache' ) ; $ objFolder -> purge ( ) ; 
public function purgeInternalCache ( ) { $ container = System :: getContainer ( ) ; $ clearer = $ container -> get ( 'contao.cache.clear_internal' ) ; $ clearer -> clear ( $ container -> getParameter ( 'kernel.cache_dir' ) ) ; 
public function purgeRegistrations ( ) { $ objMember = MemberModel :: findExpiredRegistrations ( ) ; if ( $ objMember === null ) { return ; } while ( $ objMember -> next ( ) ) { $ objMember -> delete ( ) ; } 
public function purgeOptInTokens ( ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optIn -> purgeTokens ( ) ; 
public function purgeXmlFiles ( $ blnReturn = false ) { $ arrFeeds = array ( ) ; $ objDatabase = Database :: getInstance ( ) ; 
public function generateSitemap ( $ intId = 0 ) { $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ this -> purgeXmlFiles ( ) ; 
public function generateXmlFiles ( ) { 
public function generateSymlinks ( ) { $ container = System :: getContainer ( ) ; $ command = $ container -> get ( 'contao.command.symlinks' ) ; $ status = $ command -> run ( new ArgvInput ( array ( ) ) , new NullOutput ( ) ) ; 
public function generateInternalCache ( ) { $ container = System :: getContainer ( ) ; $ warmer = $ container -> get ( 'contao.cache.warm_internal' ) ; $ warmer -> warmUp ( $ container -> getParameter ( 'kernel.cache_dir' ) ) ; 
public function rotateLogs ( ) { @ trigger_error ( 'Using Automator::rotateLogs() has been deprecated and will no longer work in Contao 5.0. Use the logger service instead, which rotates its log files automatically.' , E_USER_DEPRECATED ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrFiles = preg_grep ( '/\.log$/' , scan ( $ rootDir . '/system/logs' ) ) ; foreach ( $ arrFiles as $ strFile ) { $ objFile = new File ( 'system/logs/' . $ strFile . '.9' ) ; 
public static function addFiles ( $ files ) { foreach ( $ files as $ name => $ file ) { self :: addFile ( $ name , $ file ) ; } } 
public static function getPath ( $ template , $ format , $ custom = 'templates' ) { $ file = $ template . '.' . $ format ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; 
public static function getDefaultPath ( $ template , $ format ) { $ file = $ template . '.' . $ format ; $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ files [ $ template ] ) ) { return $ rootDir . '/' . self :: $ files [ $ template ] . '/' . $ file ; } $ strPath = null ; try { 
public static function initialize ( ) { $ objFilesystem = new Filesystem ( ) ; $ container = System :: getContainer ( ) ; $ strCacheDir = $ container -> getParameter ( 'kernel.cache_dir' ) ; 
public static function findPublishedBySourceAndParent ( $ strSource , $ intParent , $ blnDesc = false , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = ( $ blnDesc ? "$t.date DESC" : "$t.date" ) ; } return static :: findBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) , $ arrOptions ) ; } 
public static function countPublishedBySourceAndParent ( $ strSource , $ intParent , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) ) ; } 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ 'form' ] [ 0 ] ) . ' ###' ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> title ; $ objTemplate -> href = 'contao/main.php?do=form&amp;table=tl_form_field&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> customTpl != '' && TL_MODE == 'FE' ) { $ this -> strTemplate = $ this -> customTpl ; } return parent :: generate ( ) ; } 
protected function compile ( ) { $ hasUpload = false ; $ doNotSubmit = false ; $ arrSubmitted = array ( ) ; $ this -> loadDataContainer ( 'tl_form_field' ) ; $ formId = $ this -> formID ? 'auto_' . $ this -> formID : 'auto_form_' . $ this -> id ; $ this -> Template -> fields = '' ; $ this -> Template -> hidden = '' ; $ this -> Template -> formSubmit = $ formId ; $ this -> Template -> method = ( $ this -> method == 'GET' ) ? 'get' : 'post' ; $ this -> initializeSession ( $ formId ) ; $ arrLabels = array ( ) ; 
protected function processFormData ( $ arrSubmitted , $ arrLabels , $ arrFields ) { 
protected function initializeSession ( $ formId ) { if ( Input :: post ( 'FORM_SUBMIT' ) != $ formId ) { return ; } $ arrMessageBox = array ( 'TL_ERROR' , 'TL_CONFIRM' , 'TL_INFO' ) ; $ _SESSION [ 'FORM_DATA' ] = \ is_array ( $ _SESSION [ 'FORM_DATA' ] ) ? $ _SESSION [ 'FORM_DATA' ] : array ( ) ; foreach ( $ arrMessageBox as $ tl ) { if ( \ is_array ( $ _SESSION [ $ formId ] [ $ tl ] ) ) { $ _SESSION [ $ formId ] [ $ tl ] = array_unique ( $ _SESSION [ $ formId ] [ $ tl ] ) ; foreach ( $ _SESSION [ $ formId ] [ $ tl ] as $ message ) { $ objTemplate = new FrontendTemplate ( 'form_message' ) ; $ objTemplate -> message = $ message ; $ objTemplate -> class = strtolower ( $ tl ) ; $ this -> Template -> fields .= $ objTemplate -> parse ( ) . "\n" ; } $ _SESSION [ $ formId ] [ $ tl ] = array ( ) ; } } } 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'rssReader' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } $ this -> objFeed = new \ SimplePie ( ) ; $ arrUrls = StringUtil :: trimsplit ( '[\n\t ]' , trim ( $ this -> rss_feed ) ) ; if ( \ count ( $ arrUrls ) > 1 ) { $ this -> objFeed -> set_feed_url ( $ arrUrls ) ; } else { $ this -> objFeed -> set_feed_url ( $ arrUrls [ 0 ] ) ; } $ this -> objFeed -> set_output_encoding ( Config :: get ( 'characterSet' ) ) ; $ this -> objFeed -> set_cache_location ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/system/tmp' ) ; $ this -> objFeed -> enable_cache ( false ) ; if ( $ this -> rss_cache > 0 ) { $ this -> objFeed -> enable_cache ( true ) ; $ this -> objFeed -> set_cache_duration ( $ this -> rss_cache ) ; } if ( ! $ this -> objFeed -> init ( ) ) { $ this -> log ( 'Error importing RSS feed "' . $ this -> rss_feed . '"' , __METHOD__ , TL_ERROR ) ; return '' ; } $ this -> objFeed -> handle_content_type ( ) ; return parent :: generate ( ) ; } 
protected function compile ( ) { global $ objPage ; if ( $ this -> rss_template != 'rss_default' ) { $ this -> strTemplate = $ this -> rss_template ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ this -> Template -> setData ( $ this -> arrData ) ; } $ this -> Template -> link = $ this -> objFeed -> get_link ( ) ; $ this -> Template -> title = $ this -> objFeed -> get_title ( ) ; $ this -> Template -> language = $ this -> objFeed -> get_language ( ) ; $ this -> Template -> description = $ this -> objFeed -> get_description ( ) ; $ this -> Template -> copyright = $ this -> objFeed -> get_copyright ( ) ; 
protected function validator ( $ varInput ) { $ this -> blnSubmitInput = false ; if ( ! \ strlen ( $ varInput ) && ( \ strlen ( $ this -> varValue ) || ! $ this -> mandatory ) ) { return '' ; } 
public function parse ( $ arrAttributes = null ) { $ this -> confirmLabel = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'confirmation' ] , $ this -> strLabel ) ; return parent :: parse ( $ arrAttributes ) ; } 
public function generateConfirmationLabel ( ) { return sprintf ( '<label for="ctrl_%s_confirm" class="confirm%s">%s%s%s</label>' , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , ( $ this -> mandatory ? '<span class="invisible">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mandatory' ] . ' </span>' : '' ) , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'confirmation' ] , $ this -> strLabel ) , ( $ this -> mandatory ? '<span class="mandatory">*</span>' : '' ) ) ; } 
public function generateConfirmation ( ) { return sprintf ( '<input type="password" name="%s_confirm" id="ctrl_%s_confirm" class="text password confirm%s" value=""%s%s' , $ this -> strName , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , $ this -> getAttributes ( ) , $ this -> strTagEnding ) ; } 
private function isScope ( string $ scope ) : bool { if ( null === $ this -> container || null === ( $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ) ) { return false ; } $ matcher = $ this -> container -> get ( 'contao.routing.scope_matcher' ) ; if ( ContaoCoreBundle :: SCOPE_BACKEND === $ scope ) { return $ matcher -> isBackendRequest ( $ request ) ; } if ( ContaoCoreBundle :: SCOPE_FRONTEND === $ scope ) { return $ matcher -> isFrontendRequest ( $ request ) ; } return false ; } 
protected function createDateRanges ( ) { if ( ! empty ( $ this -> arrRange ) ) { return ; } $ intYear = date ( 'Y' , $ this -> strDate ) ; $ intMonth = date ( 'm' , $ this -> strDate ) ; $ intDay = date ( 'd' , $ this -> strDate ) ; $ this -> arrRange [ 'day' ] [ 'begin' ] = mktime ( 0 , 0 , 0 , $ intMonth , $ intDay , $ intYear ) ; $ this -> arrRange [ 'day' ] [ 'end' ] = mktime ( 23 , 59 , 59 , $ intMonth , $ intDay , $ intYear ) ; $ this -> arrRange [ 'month' ] [ 'begin' ] = mktime ( 0 , 0 , 0 , $ intMonth , 1 , $ intYear ) ; $ this -> arrRange [ 'month' ] [ 'end' ] = mktime ( 23 , 59 , 59 , $ intMonth , date ( 't' , $ this -> strDate ) , $ intYear ) ; $ this -> arrRange [ 'year' ] [ 'begin' ] = mktime ( 0 , 0 , 0 , 1 , 1 , $ intYear ) ; $ this -> arrRange [ 'year' ] [ 'end' ] = mktime ( 23 , 59 , 59 , 12 , 31 , $ intYear ) ; } 
public function getWeekBegin ( $ intStartDay = 0 ) { $ intOffset = date ( 'w' , $ this -> strDate ) - $ intStartDay ; if ( $ intOffset < 0 ) { $ intOffset += 7 ; } return strtotime ( '-' . $ intOffset . ' days' , $ this -> strDate ) ; } 
public static function getRegexp ( $ strFormat = null ) { if ( $ strFormat === null ) { $ strFormat = static :: getNumericDateFormat ( ) ; } if ( ! static :: isNumericFormat ( $ strFormat ) ) { throw new \ Exception ( sprintf ( 'Invalid date format "%s"' , $ strFormat ) ) ; } return preg_replace_callback ( '/[a-zA-Z]/' , function ( $ matches ) { 
public static function getInputFormat ( $ strFormat = null ) { if ( $ strFormat === null ) { $ strFormat = static :: getNumericDateFormat ( ) ; } if ( ! static :: isNumericFormat ( $ strFormat ) ) { throw new \ Exception ( sprintf ( 'Invalid date format "%s"' , $ strFormat ) ) ; } $ arrCharacterMapper = array ( ) ; foreach ( $ GLOBALS [ 'TL_LANG' ] [ 'DATE' ] as $ k => $ v ) { $ arrCharacterMapper [ $ k ] = $ v ; } $ arrInputFormat = array ( ) ; $ arrCharacters = str_split ( $ strFormat ) ; foreach ( $ arrCharacters as $ strCharacter ) { if ( isset ( $ arrCharacterMapper [ $ strCharacter ] ) ) { $ arrInputFormat [ $ strFormat ] .= $ arrCharacterMapper [ $ strCharacter ] ; } else { $ arrInputFormat [ $ strFormat ] .= $ strCharacter ; } } return $ arrInputFormat [ $ strFormat ] ; } 
protected function dateToUnix ( ) { if ( ! static :: isNumericFormat ( $ this -> strFormat ) ) { throw new \ Exception ( sprintf ( 'Invalid date format "%s"' , $ this -> strFormat ) ) ; } $ intCount = 0 ; $ intDay = '' ; $ intMonth = '' ; $ intYear = '' ; $ intHour = '' ; $ intMinute = '' ; $ intSecond = '' ; $ blnMeridiem = false ; $ blnCorrectHour = false ; $ arrCharacterMapper = array ( 'd' => 'intDay' , 'j' => 'intDay' , 'm' => 'intMonth' , 'n' => 'intMonth' , 'y' => 'intYear' , 'Y' => 'intYear' , 'h' => 'intHour' , 'H' => 'intHour' , 'g' => 'intHour' , 'G' => 'intHour' , 'i' => 'intMinute' , 's' => 'intSecond' ) ; $ arrCharacters = str_split ( $ this -> strFormat ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ var = $ arrCharacterMapper [ $ strCharacter ] ?? 'dummy' ; switch ( $ strCharacter ) { case 'a' : case 'A' : $ blnCorrectHour = true ; $ blnMeridiem = ( strtolower ( substr ( $ this -> strDate , $ intCount , 2 ) ) == 'pm' ) ? true : false ; $ intCount += 2 ; break ; case 'd' : case 'm' : case 'y' : case 'h' : case 'H' : case 'i' : case 's' : $ $ var .= substr ( $ this -> strDate , $ intCount , 2 ) ; $ intCount += 2 ; break ; case 'j' : case 'n' : case 'g' : case 'G' : $ $ var .= substr ( $ this -> strDate , $ intCount ++ , 1 ) ; if ( preg_match ( '/[0-9]+/' , substr ( $ this -> strDate , $ intCount , 1 ) ) ) { $ $ var .= substr ( $ this -> strDate , $ intCount ++ , 1 ) ; } break ; case 'Y' : $ $ var .= substr ( $ this -> strDate , $ intCount , 4 ) ; $ intCount += 4 ; break ; default : ++ $ intCount ; break ; } } $ intHour = ( int ) $ intHour ; if ( $ blnMeridiem ) { $ intHour += 12 ; } if ( $ blnCorrectHour && ( $ intHour == 12 || $ intHour == 24 ) ) { $ intHour -= 12 ; } if ( $ intMonth == '' ) { $ intMonth = 1 ; } if ( $ intDay == '' ) { $ intDay = 1 ; } if ( $ intYear == '' ) { $ intYear = 1970 ; } 
public static function formatToJs ( $ strFormat ) { $ chunks = str_split ( $ strFormat ) ; foreach ( $ chunks as $ k => $ v ) { switch ( $ v ) { case 'D' : $ chunks [ $ k ] = 'a' ; break ; case 'j' : $ chunks [ $ k ] = 'e' ; break ; case 'l' : $ chunks [ $ k ] = 'A' ; break ; case 'S' : $ chunks [ $ k ] = 'o' ; break ; case 'F' : $ chunks [ $ k ] = 'B' ; break ; case 'M' : $ chunks [ $ k ] = 'b' ; break ; case 'a' : $ chunks [ $ k ] = 'p' ; break ; case 'A' : $ chunks [ $ k ] = 'p' ; break ; case 'g' : $ chunks [ $ k ] = 'l' ; break ; case 'G' : $ chunks [ $ k ] = 'k' ; break ; case 'h' : $ chunks [ $ k ] = 'I' ; break ; case 'i' : $ chunks [ $ k ] = 'M' ; break ; case 's' : $ chunks [ $ k ] = 'S' ; break ; case 'U' : $ chunks [ $ k ] = 's' ; break ; } } return preg_replace ( '/([a-zA-Z])/' , '%$1' , implode ( '' , $ chunks ) ) ; } 
public static function getNumericDateFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> dateFormat != '' && static :: isNumericFormat ( $ objPage -> dateFormat ) ) { return $ objPage -> dateFormat ; } } return Config :: get ( 'dateFormat' ) ; } 
public static function getNumericTimeFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> timeFormat != '' && static :: isNumericFormat ( $ objPage -> timeFormat ) ) { return $ objPage -> timeFormat ; } } return Config :: get ( 'timeFormat' ) ; } 
public static function getNumericDatimFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> datimFormat != '' && static :: isNumericFormat ( $ objPage -> datimFormat ) ) { return $ objPage -> datimFormat ; } } return Config :: get ( 'datimFormat' ) ; } 
public static function parse ( $ strFormat , $ intTstamp = null ) { $ strModified = str_replace ( array ( 'l' , 'D' , 'F' , 'M' ) , array ( 'w::1' , 'w::2' , 'n::3' , 'n::4' ) , $ strFormat ) ; if ( $ intTstamp === null ) { $ strDate = date ( $ strModified ) ; } elseif ( ! is_numeric ( $ intTstamp ) ) { return '' ; } else { $ strDate = date ( $ strModified , $ intTstamp ) ; } $ strReturn = static :: resolveCustomModifiers ( $ strDate ) ; 
protected static function resolveCustomModifiers ( $ strDate ) { if ( strpos ( $ strDate , '::' ) === false ) { return $ strDate ; } System :: loadLanguageFile ( 'default' ) ; if ( ! $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'dayShortLength' ] ) { $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'dayShortLength' ] = 3 ; } if ( ! $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'monthShortLength' ] ) { $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'monthShortLength' ] = 3 ; } $ strReturn = '' ; $ chunks = preg_split ( "/([0-9]{1,2}::[1-4])/" , $ strDate , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; foreach ( $ chunks as $ chunk ) { list ( $ index , $ flag ) = explode ( '::' , $ chunk ) ; switch ( $ flag ) { case 1 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] [ $ index ] ; break ; case 2 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] [ $ index ] ; break ; case 3 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] [ ( $ index - 1 ) ] ; break ; case 4 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] [ ( $ index - 1 ) ] ; break ; default : $ strReturn .= $ chunk ; break ; } } return $ strReturn ; } 
public function hasOldDatabase ( ) : bool { if ( ! $ this -> hasTable ( 'tl_layout' ) ) { return false ; } $ sql = $ this -> connection -> getDatabasePlatform ( ) -> getListTableColumnsSQL ( 'tl_layout' , $ this -> connection -> getDatabase ( ) ) ; $ columns = $ this -> connection -> fetchAll ( $ sql ) ; foreach ( $ columns as $ column ) { if ( 'sections' === $ column [ 'Field' ] ) { return ! \ in_array ( $ column [ 'Type' ] , [ 'varchar(1022)' , 'blob' ] , true ) ; } } return false ; } 
public function hasConfigurationError ( array & $ context ) : bool { $ row = $ this -> connection -> query ( 'SELECT @@version as Version' ) -> fetch ( \ PDO :: FETCH_OBJ ) ; [ $ version ] = explode ( '-' , $ row -> Version ) ; 
public function getTemplates ( ) : array { $ finder = Finder :: create ( ) -> files ( ) -> name ( '*.sql' ) -> in ( $ this -> rootDir . '/templates' ) ; $ templates = [ ] ; foreach ( $ finder as $ file ) { $ templates [ ] = $ file -> getRelativePathname ( ) ; } return $ templates ; } 
protected function renderNavigation ( $ pid , $ level = 1 , $ host = null , $ language = null ) { 
protected function compile ( ) { $ objFaq = FaqModel :: findPublishedByPids ( $ this -> faq_categories ) ; if ( $ objFaq === null ) { $ this -> Template -> faq = array ( ) ; return ; } $ arrFaq = array_fill_keys ( $ this -> faq_categories , array ( ) ) ; 
protected function generateFaqLink ( $ objFaq ) { $ objCategory = $ objFaq -> getRelated ( 'pid' ) ; $ jumpTo = ( int ) $ objCategory -> jumpTo ; 
public function getMaxUploadFileSize ( ) { $ objResult = Database :: getInstance ( ) -> prepare ( "SELECT MAX(maxlength) AS maxlength FROM tl_form_field WHERE pid=? AND invisible='' AND type='upload' AND maxlength>0" ) -> execute ( $ this -> id ) ; if ( $ objResult -> numRows > 0 && $ objResult -> maxlength > 0 ) { return $ objResult -> maxlength ; } else { return Config :: get ( 'maxFileSize' ) ; } } 
public static function findOneByRelatedTableAndId ( $ strTable , $ intId , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using the Contao\OptInModel::findOneByRelatedTableAndIds() method has been deprecated and will no longer work in Contao 5.0. Use the Contao\OptInModel::findByRelatedTableAndIds() method instead.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId=?)" ) -> execute ( $ strTable , $ intId ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objOptIn ; } return new static ( $ objResult ) ; } 
public static function findByRelatedTableAndIds ( $ strTable , array $ arrIds , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE $t.id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")) ORDER BY $t.createdOn DESC" ) -> execute ( $ strTable , $ arrIds ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ arrModels = array ( ) ; $ objRegistry = Registry :: getInstance ( ) ; while ( $ objResult -> next ( ) ) { if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { $ arrModels [ ] = $ objOptIn ; } else { $ arrModels [ ] = new static ( $ objResult -> row ( ) ) ; } } return static :: createCollection ( $ arrModels , $ t ) ; } 
public function getRelatedRecords ( ) { $ arrRelated = array ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ objRelated = $ objDatabase -> prepare ( "SELECT * FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ this -> id ) ; while ( $ objRelated -> next ( ) ) { $ arrRelated [ $ objRelated -> relTable ] [ ] = $ objRelated -> relId ; } return $ arrRelated ; } 
public function setRelatedRecords ( array $ arrRelated ) { $ objDatabase = Database :: getInstance ( ) ; $ objCount = $ objDatabase -> prepare ( "SELECT COUNT(*) AS count FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ this -> id ) ; if ( $ objCount -> count > 0 ) { throw new \ LogicException ( sprintf ( 'Token "%s" already contains related records' , $ this -> token ) ) ; } foreach ( $ arrRelated as $ strTable => $ arrIds ) { foreach ( $ arrIds as $ intId ) { $ objDatabase -> prepare ( "INSERT INTO tl_opt_in_related (pid, relTable, relId) VALUES (?, ?, ?)" ) -> execute ( $ this -> id , $ strTable , $ intId ) ; } } } 
public function generate ( ) { return sprintf ( '<textarea name="%s" id="ctrl_%s" class="textarea%s" rows="%s" cols="%s"%s>%s</textarea>' , $ this -> strName , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , $ this -> intRows , $ this -> intCols , $ this -> getAttributes ( ) , $ this -> value ) ; } 
public function clear ( $ cacheDir ) : void { $ this -> filesystem -> remove ( $ cacheDir . '/contao/config' ) ; $ this -> filesystem -> remove ( $ cacheDir . '/contao/dca' ) ; $ this -> filesystem -> remove ( $ cacheDir . '/contao/languages' ) ; $ this -> filesystem -> remove ( $ cacheDir . '/contao/sql' ) ; } 
protected function interact ( InputInterface $ input , OutputInterface $ output ) : void { if ( null === $ input -> getArgument ( 'username' ) ) { throw new InvalidArgumentException ( 'Please provide the username as argument.' ) ; } if ( null !== $ input -> getOption ( 'password' ) ) { return ; } $ password = $ this -> askForPassword ( 'Please enter the new password:' , $ input , $ output ) ; $ confirm = $ this -> askForPassword ( 'Please confirm the password:' , $ input , $ output ) ; if ( $ password !== $ confirm ) { throw new RuntimeException ( 'The passwords do not match.' ) ; } $ input -> setOption ( 'password' , $ password ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : int { if ( null === $ input -> getArgument ( 'username' ) || null === $ input -> getOption ( 'password' ) ) { return 1 ; } $ hash = $ this -> validateAndHashPassword ( $ input -> getOption ( 'password' ) ) ; $ affected = $ this -> connection -> update ( 'tl_user' , [ 'password' => $ hash ] , [ 'username' => $ input -> getArgument ( 'username' ) ] ) ; if ( 0 === $ affected ) { throw new InvalidArgumentException ( sprintf ( 'Invalid username: %s' , $ input -> getArgument ( 'username' ) ) ) ; } $ io = new SymfonyStyle ( $ input , $ output ) ; $ io -> success ( 'The password has been changed successfully.' ) ; return 0 ; } 
private function askForPassword ( string $ label , InputInterface $ input , OutputInterface $ output ) : string { $ question = new Question ( $ label ) ; $ question -> setHidden ( true ) ; $ question -> setMaxAttempts ( 3 ) ; $ helper = $ this -> getHelper ( 'question' ) ; return $ helper -> ask ( $ input , $ output , $ question ) ; } 
public function generate ( ) { global $ objPage ; $ obj404 = $ this -> prepare ( ) ; $ objPage = $ obj404 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 404 Not Found' ) ; $ objHandler -> generate ( $ objPage ) ; } 
public function getResponse ( ) { global $ objPage ; $ obj404 = $ this -> prepare ( ) ; $ objPage = $ obj404 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; return $ objHandler -> getResponse ( $ objPage ) -> setStatusCode ( 404 ) ; } 
protected function prepare ( ) { 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'articlenav' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } global $ objPage ; $ this -> objArticles = ArticleModel :: findPublishedWithTeaserByPidAndColumn ( $ objPage -> id , $ this -> strColumn ) ; 
protected function compile ( ) { global $ objPage ; $ intActive = null ; $ articles = array ( ) ; $ intCount = 1 ; foreach ( $ this -> objArticles as $ objArticle ) { $ strAlias = $ objArticle -> alias ? : $ objArticle -> id ; 
public function run ( ) : void { $ statement = $ this -> connection -> query ( " SELECT id, framework FROM tl_layout WHERE framework != '' " ) ; while ( false !== ( $ layout = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) ) { $ framework = '' ; $ tmp = StringUtil :: deserialize ( $ layout -> framework ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { if ( false !== ( $ key = array_search ( 'layout.css' , $ tmp , true ) ) ) { array_insert ( $ tmp , $ key + 1 , 'responsive.css' ) ; } $ framework = serialize ( array_values ( array_unique ( $ tmp ) ) ) ; } $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_layout SET framework = :framework WHERE id = :id ' ) ; $ stmt -> execute ( [ ':framework' => $ framework , ':id' => $ layout -> id ] ) ; } ALTER TABLE tl_layout ADD viewport varchar(255) NOT NULL default '' " ) ; } 
public function onBuild ( MenuEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser ) { return ; } $ factory = $ event -> getFactory ( ) ; $ tree = $ event -> getTree ( ) ; $ modules = $ user -> navigation ( ) ; foreach ( $ modules as $ categoryName => $ categoryData ) { $ categoryNode = $ tree -> getChild ( $ categoryName ) ; if ( ! $ categoryNode ) { $ categoryNode = $ this -> createNode ( $ factory , $ categoryName , $ categoryData ) ; if ( isset ( $ categoryData [ 'class' ] ) && preg_match ( '/\bnode-collapsed\b/' , $ categoryData [ 'class' ] ) ) { $ categoryNode -> setDisplayChildren ( false ) ; } $ tree -> addChild ( $ categoryNode ) ; } 
public function getBasePath ( ) : string { if ( $ this -> debug ) { return '' ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request || '' === ( $ staticUrl = $ this -> getFieldValue ( $ this -> getPageModel ( ) ) ) ) { return '' ; } $ protocol = $ this -> isSecure ( ) ? 'https' : 'http' ; $ relative = preg_replace ( '@https?://@' , '' , $ staticUrl ) ; return sprintf ( '%s://%s%s' , $ protocol , $ relative , $ request -> getBasePath ( ) ) ; } 
public function isSecure ( ) : bool { $ page = $ this -> getPageModel ( ) ; if ( null !== $ page ) { return ( bool ) $ page -> loadDetails ( ) -> rootUseSSL ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request ) { return false ; } return $ request -> isSecure ( ) ; } 
private function getFieldValue ( ? PageModel $ page ) : string { if ( null === $ page ) { return '' ; } return ( string ) $ page -> { $ this -> field } ; } 
public function addTemplateWarning ( ) { if ( Contao \ Input :: get ( 'act' ) && Contao \ Input :: get ( 'act' ) != 'select' ) { return ; } $ objResult = $ this -> Database -> query ( "SELECT COUNT(*) AS cnt FROM tl_user_group WHERE modules LIKE '%\"tpl_editor\"%'" ) ; if ( $ objResult -> cnt > 0 ) { Contao \ Message :: addInfo ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'groupTemplateEditor' ] ) ; } } 
public function getExcludedFields ( ) { $ processed = array ( ) ; $ files = Contao \ System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; Contao \ System :: loadLanguageFile ( $ strTable ) ; $ this -> loadDataContainer ( $ strTable ) ; } $ arrReturn = array ( ) ; 
public function load ( $ blnNoCache = false ) { 
public function run ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; $ objTemplate = new BackendTemplate ( 'be_password' ) ; if ( Input :: post ( 'FORM_SUBMIT' ) == 'tl_password' ) { $ pw = $ request -> request -> get ( 'password' ) ; $ cnf = $ request -> request -> get ( 'confirm' ) ; 
public function unserialize ( $ serialized ) : void { [ $ this -> showUnpublished , $ parentStr ] = unserialize ( $ serialized , [ 'allowed_classes' => true ] ) ; parent :: unserialize ( $ parentStr ) ; } 
public function generate ( ) { 
protected function compile ( ) { global $ objPage ; $ files = array ( ) ; $ auxDate = array ( ) ; $ objFiles = $ this -> objFiles ; $ allowedDownload = StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'allowedDownload' ) ) ) ; 
protected function compile ( ) { if ( TL_MODE == 'BE' ) { $ this -> strTemplate = 'be_wildcard' ; $ this -> Template = new BackendTemplate ( $ this -> strTemplate ) ; $ this -> Template -> title = $ this -> mooHeadline ; } $ classes = StringUtil :: deserialize ( $ this -> mooClasses ) ; $ this -> Template -> toggler = $ classes [ 0 ] ? : 'toggler' ; $ this -> Template -> accordion = $ classes [ 1 ] ? : 'accordion' ; $ this -> Template -> headlineStyle = $ this -> mooStyle ; $ this -> Template -> headline = $ this -> mooHeadline ; } 
public function create ( PickerConfig $ config ) : ? Picker { $ providers = $ this -> providers ; if ( \ is_array ( $ allowed = $ config -> getExtra ( 'providers' ) ) ) { $ providers = array_intersect_key ( $ providers , array_flip ( $ allowed ) ) ; } $ providers = array_filter ( $ providers , static function ( PickerProviderInterface $ provider ) use ( $ config ) : bool { return $ provider -> supportsContext ( $ config -> getContext ( ) ) ; } ) ; if ( empty ( $ providers ) ) { return null ; } return new Picker ( $ this -> menuFactory , $ providers , $ config ) ; } 
public function createFromData ( $ data ) : ? Picker { try { $ config = PickerConfig :: urlDecode ( $ data ) ; } catch ( \ InvalidArgumentException $ e ) { return null ; } return $ this -> create ( $ config ) ; } 
public function supportsContext ( $ context , array $ allowed = null ) : bool { $ providers = $ this -> providers ; if ( null !== $ allowed ) { $ providers = array_intersect_key ( $ providers , array_flip ( $ allowed ) ) ; } foreach ( $ providers as $ provider ) { if ( $ provider -> supportsContext ( $ context ) ) { return true ; } } return false ; } 
public function getUrl ( $ context , array $ extras = [ ] , $ value = '' ) : string { $ providers = ( isset ( $ extras [ 'providers' ] ) && \ is_array ( $ extras [ 'providers' ] ) ) ? $ extras [ 'providers' ] : null ; if ( ! $ this -> supportsContext ( $ context , $ providers ) ) { return '' ; } return $ this -> router -> generate ( 'contao_backend_picker' , compact ( 'context' , 'extras' , 'value' ) ) ; } 
protected function compile ( ) { global $ objPage ; 
public function generate ( ) { if ( empty ( $ this -> arrOptions ) || ! \ is_array ( $ this -> arrOptions ) ) { return '' ; } $ rows = ceil ( \ count ( $ this -> arrOptions ) / $ this -> intCols ) ; $ return = '<table id="ctrl_' . $ this -> strName . '" class="tl_radio_table' . ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) . '">' ; for ( $ i = 0 ; $ i < $ rows ; $ i ++ ) { $ return .= ' <tr>' ; <td><input type="radio" name="' . $ this -> strName . '" id="' . $ this -> strName . '_' . $ i . '_' . $ j . '" class="tl_radio" value="' . StringUtil :: specialchars ( $ value ) . '" onfocus="Backend.getScrollOffset()"' . $ this -> isChecked ( $ this -> arrOptions [ $ j ] ) . $ this -> getAttributes ( ) . '> <label for="' . $ this -> strName . '_' . $ i . '_' . $ j . '">' . $ label . '</label></td>' ; } // Else return an empty cell else { $ return .= ' <td></td>' ; } } // Close row $ return .= ' </tr>' ; } return $ return . ' </table>' ; } 
public function onLogoutSuccess ( Request $ request ) : Response { if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { return $ this -> createRedirectResponse ( $ request , 'contao_backend_login' ) ; } if ( $ targetUrl = $ request -> query -> get ( 'redirect' ) ) { return $ this -> createRedirectResponse ( $ request , $ targetUrl ) ; } if ( $ targetUrl = $ request -> headers -> get ( 'Referer' ) ) { return $ this -> createRedirectResponse ( $ request , $ targetUrl ) ; } return $ this -> clearJwtToken ( $ request , parent :: onLogoutSuccess ( $ request ) ) ; } 
protected function compile ( ) { global $ objPage ; $ limit = null ; $ offset = 0 ; $ intBegin = 0 ; $ intEnd = 0 ; $ intYear = Input :: get ( 'year' ) ; $ intMonth = Input :: get ( 'month' ) ; $ intDay = Input :: get ( 'day' ) ; 
public function run ( ) : void { $ this -> connection -> query ( ' ALTER TABLE tl_content ADD youtubeOptions text NULL ' ) ; $ this -> connection -> query ( ' ALTER TABLE tl_content ADD youtubeStart int(10) unsigned NOT NULL default 0 ' ) ; $ this -> connection -> query ( ' ALTER TABLE tl_content ADD youtubeStop int(10) unsigned NOT NULL default 0 ' ) ; $ this -> connection -> query ( " UPDATE tl_form_field SET type = 'fieldsetStart' WHERE type = 'fieldset' AND fsType = 'fsStart' " ) ; $ this -> connection -> query ( " UPDATE tl_form_field SET type = 'fieldsetStop' WHERE type = 'fieldset' AND fsType = 'fsStop' " ) ; $ columns = $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( 'tl_module' ) ; if ( isset ( $ columns [ 'news_order' ] ) ) { $ this -> connection -> query ( " UPDATE tl_module SET news_order = 'order_date_asc' WHERE news_order = 'ascending' " ) ; $ this -> connection -> query ( " UPDATE tl_module SET news_order = 'order_date_desc' WHERE news_order = 'descending' " ) ; } $ this -> connection -> query ( ' ALTER TABLE tl_layout ADD externalJs BLOB DEFAULT NULL ' ) ; } 
public function generateSqlForm ( ) { @ trigger_error ( 'Using the Installer::generateSqlForm() method has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ count = 0 ; $ return = '' ; $ sql_command = $ this -> compileCommands ( ) ; if ( empty ( $ sql_command ) ) { return '' ; } $ _SESSION [ 'sql_commands' ] = array ( ) ; $ arrOperations = array ( 'CREATE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'CREATE' ] , 'ALTER_ADD' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_ADD' ] , 'ALTER_CHANGE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_CHANGE' ] , 'ALTER_DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_DROP' ] , 'DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'DROP' ] ) ; foreach ( $ arrOperations as $ command => $ label ) { if ( \ is_array ( $ sql_command [ $ command ] ) ) { <tr> <td colspan="2" class="tl_col_0">' . $ label . '</td> </tr>' ; // Check all $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" id="check_all_' . $ count . '" class="tl_checkbox" onclick="Backend.toggleCheckboxElements(this, \'' . strtolower ( $ command ) . '\')"></td> <td class="tl_col_2"><label for="check_all_' . $ count . '" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label></td> </tr>' ; // Fields foreach ( $ sql_command [ $ command ] as $ vv ) { $ key = md5 ( $ vv ) ; $ _SESSION [ 'sql_commands' ] [ $ key ] = $ vv ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" name="sql[]" id="sql_' . $ count . '" class="tl_checkbox ' . strtolower ( $ command ) . '" value="' . $ key . '"' . ( ( stripos ( $ command , 'DROP' ) === false ) ? ' checked="checked"' : '' ) . '></td> <td class="tl_col_2"><pre><label for="sql_' . $ count ++ . '">' . $ vv . '</label></pre></td> </tr>' ; } } } return ' <div id="sql_wrapper"> <table id="sql_table">' . $ return . ' </table> </div>' ; } 
protected function compileCommands ( ) { $ drop = array ( ) ; $ create = array ( ) ; $ return = array ( ) ; $ sql_current = $ this -> getFromDb ( ) ; $ sql_target = $ this -> getFromDca ( ) ; $ sql_legacy = $ this -> getFromFile ( ) ; 
public function getFromDca ( ) { $ return = array ( ) ; $ processed = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; $ objExtract = DcaExtractor :: getInstance ( $ strTable ) ; if ( $ objExtract -> isDbTable ( ) ) { $ return [ $ strTable ] = $ objExtract -> getDbInstallerArray ( ) ; } } ksort ( $ return ) ; 
public function getFromFile ( ) { $ return = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'config' ) -> depth ( 0 ) -> files ( ) -> name ( 'database.sql' ) ; foreach ( $ files as $ file ) { $ return = array_replace_recursive ( $ return , SqlFileParser :: parse ( $ file ) ) ; } ksort ( $ return ) ; 
public function getFromDb ( ) { $ this -> import ( Database :: class , 'Database' ) ; $ tables = preg_grep ( '/^tl_/' , $ this -> Database -> listTables ( null , true ) ) ; if ( empty ( $ tables ) ) { return array ( ) ; } $ return = array ( ) ; $ quote = function ( $ item ) { return '`' . $ item . '`' ; } ; foreach ( $ tables as $ table ) { $ fields = $ this -> Database -> listFields ( $ table , true ) ; foreach ( $ fields as $ field ) { $ name = $ field [ 'name' ] ; $ field [ 'name' ] = $ quote ( $ field [ 'name' ] ) ; if ( $ field [ 'type' ] != 'index' ) { unset ( $ field [ 'index' ] ) ; unset ( $ field [ 'origtype' ] ) ; 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : int { $ this -> framework -> initialize ( ) ; $ strLog = Dbafs :: syncFiles ( ) ; $ output -> writeln ( sprintf ( 'Synchronization complete (see <info>%s</info>).' , $ strLog ) ) ; return 0 ; } 
public function getSQLDeclaration ( array $ fieldDeclaration , AbstractPlatform $ platform ) : string { if ( ! empty ( $ fieldDeclaration [ 'fixed' ] ) ) { return $ platform -> getBinaryTypeDeclarationSQL ( $ fieldDeclaration ) ; } return $ platform -> getBlobTypeDeclarationSQL ( $ fieldDeclaration ) ; } 
public static function getActive ( ) { @ trigger_error ( 'Using ModuleLoader::getActive() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ bundles = array_keys ( System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ) ; foreach ( static :: $ legacy as $ bundleName => $ module ) { if ( \ in_array ( $ bundleName , $ bundles ) ) { $ bundles [ ] = $ module ; } } return $ bundles ; } 
public function add ( $ strFile , $ strVersion = null , $ strMedia = 'all' ) { $ strType = strrchr ( $ strFile , '.' ) ; 
public function addMultiple ( array $ arrFiles , $ strVersion = null , $ strMedia = 'screen' ) { foreach ( $ arrFiles as $ strFile ) { $ this -> add ( $ strFile , $ strVersion , $ strMedia ) ; } } 
public function getFileUrls ( ) { $ return = array ( ) ; $ strTarget = substr ( $ this -> strMode , 1 ) ; foreach ( $ this -> arrFiles as $ arrFile ) { 
public function getCombinedFile ( $ strUrl = null ) { if ( Config :: get ( 'debugMode' ) ) { return $ this -> getDebugMarkup ( ) ; } return $ this -> getCombinedFileUrl ( $ strUrl ) ; } 
protected function getDebugMarkup ( ) { $ return = $ this -> getFileUrls ( ) ; foreach ( $ return as $ k => $ v ) { $ options = StringUtil :: resolveFlaggedUrl ( $ v ) ; $ return [ $ k ] = $ v ; if ( $ options -> mtime ) { $ return [ $ k ] .= '?v=' . substr ( md5 ( $ options -> mtime ) , 0 , 8 ) ; } if ( $ options -> media ) { $ return [ $ k ] .= '" media="' . $ options -> media ; } } if ( $ this -> strMode == self :: JS ) { return implode ( '"></script><script src="' , $ return ) ; } return implode ( '"><link rel="stylesheet" href="' , $ return ) ; } 
protected function getCombinedFileUrl ( $ strUrl = null ) { if ( $ strUrl === null ) { $ strUrl = System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) ; } $ arrPrefix = array ( ) ; $ strTarget = substr ( $ this -> strMode , 1 ) ; foreach ( $ this -> arrFiles as $ arrFile ) { $ arrPrefix [ ] = basename ( $ arrFile [ 'name' ] ) ; } $ strKey = StringUtil :: substr ( implode ( ',' , $ arrPrefix ) , 64 , '...' ) . '-' . substr ( md5 ( $ this -> strKey ) , 0 , 8 ) ; 
protected function handleCss ( $ content , $ arrFile ) { $ content = $ this -> fixPaths ( $ content , $ arrFile ) ; 
protected function handleScssLess ( $ content , $ arrFile ) { if ( $ arrFile [ 'extension' ] == self :: SCSS ) { $ objCompiler = new Compiler ( ) ; $ objCompiler -> setImportPaths ( array ( $ this -> strRootDir . '/' . \ dirname ( $ arrFile [ 'name' ] ) , $ this -> strRootDir . '/vendor/contao-components/compass/css' ) ) ; $ objCompiler -> setFormatter ( ( Config :: get ( 'debugMode' ) ? Expanded :: class : Compressed :: class ) ) ; return $ this -> fixPaths ( $ objCompiler -> compile ( $ content ) , $ arrFile ) ; } else { $ strPath = \ dirname ( $ arrFile [ 'name' ] ) ; $ arrOptions = array ( 'strictMath' => true , 'compress' => ! Config :: get ( 'debugMode' ) , 'import_dirs' => array ( $ this -> strRootDir . '/' . $ strPath => $ strPath ) ) ; $ objParser = new \ Less_Parser ( ) ; $ objParser -> SetOptions ( $ arrOptions ) ; $ objParser -> parse ( $ content ) ; return $ this -> fixPaths ( $ objParser -> getCss ( ) , $ arrFile ) ; } } 
protected function fixPaths ( $ content , $ arrFile ) { $ strName = $ arrFile [ 'name' ] ; 
protected function hasMediaTag ( $ strFile ) { $ return = false ; $ fh = fopen ( $ this -> strRootDir . '/' . $ strFile , 'rb' ) ; while ( ( $ line = fgets ( $ fh ) ) !== false ) { if ( strpos ( $ line , '@media' ) !== false ) { $ return = true ; break ; } } fclose ( $ fh ) ; return $ return ; } 
public function inherit ( ) { $ strBuffer = '' ; 
public function block ( $ name ) { $ this -> arrBlockNames [ ] = $ name ; 
public function endblock ( ) { 
public function insert ( $ name , array $ data = null ) { if ( $ this instanceof Template ) { $ tpl = new static ( $ name ) ; } elseif ( TL_MODE == 'BE' ) { $ tpl = new BackendTemplate ( $ name ) ; } else { $ tpl = new FrontendTemplate ( $ name ) ; } if ( $ data !== null ) { $ tpl -> setData ( $ data ) ; } echo $ tpl -> parse ( ) ; } 
protected function getTemplatePath ( $ strTemplate , $ strFormat = 'html5' , $ blnDefault = false ) { if ( $ blnDefault ) { return TemplateLoader :: getDefaultPath ( $ strTemplate , $ strFormat ) ; } return Controller :: getTemplate ( $ strTemplate ) ; } 
protected function initialize ( ) { if ( static :: $ blnHasLcf === null ) { static :: preload ( ) ; } $ strCacheDir = System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ strCacheDir . '/contao/config/config.php' ) ) { include $ strCacheDir . '/contao/config/config.php' ; } else { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/config.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { $ files = array ( ) ; } foreach ( $ files as $ file ) { include $ file ; } } 
protected function markModified ( ) { 
public function save ( ) { if ( $ this -> strTop == '' ) { $ this -> strTop = '<?php' ; } $ strFile = trim ( $ this -> strTop ) . "\n\n" ; $ strFile .= "### INSTALL SCRIPT START ###\n" ; foreach ( $ this -> arrData as $ k => $ v ) { $ strFile .= "$k = $v\n" ; } $ strFile .= "### INSTALL SCRIPT STOP ###\n" ; $ this -> strBottom = trim ( $ this -> strBottom ) ; if ( $ this -> strBottom != '' ) { $ strFile .= "\n" . $ this -> strBottom . "\n" ; } $ strTemp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; 
public function add ( $ strKey , $ varValue ) { $ this -> markModified ( ) ; $ this -> arrData [ $ strKey ] = $ this -> escape ( $ varValue ) . ';' ; } 
public static function persist ( $ strKey , $ varValue ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> add ( $ strKey , $ varValue ) ; } 
public static function remove ( $ strKey ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> delete ( $ strKey ) ; } 
public static function preload ( ) { 
protected static function loadParameters ( ) { $ container = System :: getContainer ( ) ; if ( $ container === null ) { return ; } if ( $ container -> hasParameter ( 'contao.localconfig' ) && \ is_array ( $ params = $ container -> getParameter ( 'contao.localconfig' ) ) ) { foreach ( $ params as $ key => $ value ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ key ] = $ value ; } } $ arrMap = array ( 'dbHost' => 'database_host' , 'dbPort' => 'database_port' , 'dbUser' => 'database_user' , 'dbPass' => 'database_password' , 'dbDatabase' => 'database_name' , 'smtpHost' => 'mailer_host' , 'smtpUser' => 'mailer_user' , 'smtpPass' => 'mailer_password' , 'smtpPort' => 'mailer_port' , 'smtpEnc' => 'mailer_encryption' , 'addLanguageToUrl' => 'contao.prepend_locale' , 'encryptionKey' => 'contao.encryption_key' , 'urlSuffix' => 'contao.url_suffix' , 'uploadPath' => 'contao.upload_path' , 'debugMode' => 'kernel.debug' , ) ; foreach ( $ arrMap as $ strKey => $ strParam ) { if ( $ container -> hasParameter ( $ strParam ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ strKey ] = $ container -> getParameter ( $ strParam ) ; } } if ( $ container -> hasParameter ( 'contao.image.valid_extensions' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'validImageTypes' ] = implode ( ',' , $ container -> getParameter ( 'contao.image.valid_extensions' ) ) ; } if ( $ container -> hasParameter ( 'contao.image.imagine_options' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'jpgQuality' ] = $ container -> getParameter ( 'contao.image.imagine_options' ) [ 'jpeg_quality' ] ; } } 
protected function escape ( $ varValue ) { if ( is_numeric ( $ varValue ) && ! preg_match ( '/e|^[+-]?0[^.]/' , $ varValue ) && $ varValue < PHP_INT_MAX ) { return $ varValue ; } if ( \ is_bool ( $ varValue ) ) { return $ varValue ? 'true' : 'false' ; } if ( $ varValue == 'true' ) { return 'true' ; } if ( $ varValue == 'false' ) { return 'false' ; } return "'" . str_replace ( '\\"' , '"' , preg_replace ( '/[\n\r\t ]+/' , ' ' , addslashes ( $ varValue ) ) ) . "'" ; } 
public function onKernelRequest ( GetResponseEvent $ event ) : void { $ request = $ event -> getRequest ( ) ; 
public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } 
private function fetchHttpHeaders ( ) : void { $ this -> headers = array_merge ( $ this -> headers , $ this -> headerStorage -> all ( ) ) ; $ this -> headerStorage -> clear ( ) ; } 
public function getFramework ( ) : ContaoFramework { @ trigger_error ( 'Using FrameworkAwareTrait::getFramework() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( null === $ this -> framework ) { throw new \ LogicException ( 'The framework service has not been set.' ) ; } return $ this -> framework ; } 
public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof User ) { return ; } $ session = $ user -> session ; if ( \ is_array ( $ session ) ) { $ sessionBag = $ this -> getSessionBag ( $ event -> getRequest ( ) ) ; $ sessionBag -> replace ( $ session ) ; } 
public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof User ) { return ; } $ sessionBag = $ this -> getSessionBag ( $ event -> getRequest ( ) ) ; $ data = $ sessionBag -> all ( ) ; $ this -> connection -> update ( $ user -> getTable ( ) , [ 'session' => serialize ( $ data ) ] , [ 'id' => $ user -> id ] ) ; } 
private function getSessionBag ( Request $ request ) : SessionBagInterface { if ( ! $ request -> hasSession ( ) || null === ( $ session = $ request -> getSession ( ) ) ) { throw new \ RuntimeException ( 'The request did not contain a session.' ) ; } $ name = 'contao_frontend' ; if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ name = 'contao_backend' ; } return $ session -> getBag ( $ name ) ; } 
public function getAttributes ( $ arrStrip = array ( ) ) { 
public function loadTokenBySeries ( $ series ) : PersistentToken { $ sql = ' SELECT class, username, value, lastUsed FROM tl_remember_me WHERE series=:series ' ; $ values = [ 'series' => hash_hmac ( 'sha256' , $ series , $ this -> secret ) , ] ; $ types = [ 'series' => \ PDO :: PARAM_STR , ] ; $ stmt = $ this -> connection -> executeQuery ( $ sql , $ values , $ types ) ; if ( ! $ row = $ stmt -> fetch ( \ PDO :: FETCH_OBJ ) ) { throw new TokenNotFoundException ( 'No token found.' ) ; } return new PersistentToken ( $ row -> class , $ row -> username , $ series , $ row -> value , new \ DateTime ( $ row -> lastUsed ) ) ; } 
public function deleteTokenBySeries ( $ series ) : void { $ sql = ' DELETE FROM tl_remember_me WHERE series=:series ' ; $ values = [ 'series' => hash_hmac ( 'sha256' , $ series , $ this -> secret ) , ] ; $ types = [ 'series' => \ PDO :: PARAM_STR , ] ; $ this -> connection -> executeUpdate ( $ sql , $ values , $ types ) ; } 
public function updateToken ( $ series , $ tokenValue , \ DateTime $ lastUsed ) : void { $ sql = ' UPDATE tl_remember_me SET value=:value, lastUsed=:lastUsed WHERE series=:series ' ; $ values = [ 'value' => $ tokenValue , 'lastUsed' => $ lastUsed , 'series' => hash_hmac ( 'sha256' , $ series , $ this -> secret ) , ] ; $ types = [ 'value' => \ PDO :: PARAM_STR , 'lastUsed' => DoctrineType :: DATETIME , 'series' => \ PDO :: PARAM_STR , ] ; $ updated = $ this -> connection -> executeUpdate ( $ sql , $ values , $ types ) ; if ( $ updated < 1 ) { throw new TokenNotFoundException ( 'No token found.' ) ; } } 
public function createNewToken ( PersistentTokenInterface $ token ) : void { $ sql = ' INSERT INTO tl_remember_me (class, username, series, value, lastUsed) VALUES (:class, :username, :series, :value, :lastUsed) ' ; $ values = [ 'class' => $ token -> getClass ( ) , 'username' => $ token -> getUsername ( ) , 'series' => hash_hmac ( 'sha256' , $ token -> getSeries ( ) , $ this -> secret ) , 'value' => $ token -> getTokenValue ( ) , 'lastUsed' => $ token -> getLastUsed ( ) , ] ; $ types = [ 'class' => \ PDO :: PARAM_STR , 'username' => \ PDO :: PARAM_STR , 'series' => \ PDO :: PARAM_STR , 'value' => \ PDO :: PARAM_STR , 'lastUsed' => DoctrineType :: DATETIME , ] ; $ this -> connection -> executeUpdate ( $ sql , $ values , $ types ) ; } 
public function generate ( $ objRootPage = null ) { global $ objPage ; $ obj403 = $ this -> prepare ( $ objRootPage ) ; $ objPage = $ obj403 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 403 Forbidden' ) ; $ objHandler -> generate ( $ objPage ) ; } 
public function getResponse ( $ objRootPage = null ) { global $ objPage ; $ obj403 = $ this -> prepare ( $ objRootPage ) ; $ objPage = $ obj403 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; return $ objHandler -> getResponse ( $ objPage ) -> setStatusCode ( 403 ) ; } 
protected function prepare ( $ objRootPage = null ) { 
protected function voteOnAttribute ( $ attribute , $ subject , TokenInterface $ token ) : bool { $ user = $ token -> getUser ( ) ; [ , $ field ] = explode ( '.' , $ attribute , 2 ) ; if ( ! $ user instanceof BackendUser || ( ! is_scalar ( $ subject ) && ! \ is_array ( $ subject ) ) ) { return false ; } return $ user -> hasAccess ( $ subject , $ field ) ; } 
public function generate ( ) { $ this -> import ( Database :: class , 'Database' ) ; $ arrButtons = array ( 'edit' , 'copy' , 'delete' , 'enable' , 'drag' ) ; <thead> <tr> <th>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mw_module' ] . '</th> <th>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mw_column' ] . '</th> <th></th> </tr> </thead> <tbody class="sortable">' ; // Add the input fields for ( $ i = 0 , $ c = \ count ( $ this -> varValue ) ; $ i < $ c ; $ i ++ ) { $ options = '' ; // Add modules foreach ( $ modules as $ v ) { $ options .= '<option value="' . StringUtil :: specialchars ( $ v [ 'id' ] ) . '"' . static :: optionSelected ( $ v [ 'id' ] , $ this -> varValue [ $ i ] [ 'mod' ] ) . '>' . $ v [ 'name' ] . ' [' . $ v [ 'type' ] . ']</option>' ; } $ return .= ' <tr> <td><select name="' . $ this -> strId . '[' . $ i . '][mod]" class="tl_select tl_chosen" onfocus="Backend.getScrollOffset()" onchange="Backend.updateModuleLink(this)">' . $ options . '</select></td>' ; $ options = '' ; // Add columns foreach ( $ cols as $ k => $ v ) { $ options .= '<option value="' . StringUtil :: specialchars ( $ k ) . '"' . static :: optionSelected ( $ k , $ this -> varValue [ $ i ] [ 'col' ] ) . '>' . $ v . '</option>' ; } $ return .= ' <td><select name="' . $ this -> strId . '[' . $ i . '][col]" class="tl_select_column" onfocus="Backend.getScrollOffset()">' . $ options . '</select></td> <td>' ; // Add buttons foreach ( $ arrButtons as $ button ) { if ( $ button == 'edit' ) { $ return .= ' <a href="contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> varValue [ $ i ] [ 'mod' ] . '&amp;popup=1&amp;nb=1&amp;rt=' . REQUEST_TOKEN . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_module' ] ) . '" class="module_link" ' . ( ( $ this -> varValue [ $ i ] [ 'mod' ] > 0 ) ? '' : ' style="display:none"' ) . ' onclick="Backend.openModalIframe({\'title\':\'' . StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_module' ] ) ) . '\',\'url\':this.href});return false">' . Image :: getHtml ( 'edit.svg' ) . '</a>' . Image :: getHtml ( 'edit_.svg' , '' , 'class="module_image"' . ( ( $ this -> varValue [ $ i ] [ 'mod' ] > 0 ) ? ' style="display:none"' : '' ) ) ; } elseif ( $ button == 'drag' ) { $ return .= ' <button type="button" class="drag-handle" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'move' ] ) . '" aria-hidden="true">' . Image :: getHtml ( 'drag.svg' ) . '</button>' ; } elseif ( $ button == 'enable' ) { $ return .= ' <button type="button" data-command="enable" class="mw_enable" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mw_enable' ] ) . '">' . Image :: getHtml ( ( ( $ this -> varValue [ $ i ] [ 'enable' ] ) ? 'visible.svg' : 'invisible.svg' ) ) . '</button><input name="' . $ this -> strId . '[' . $ i . '][enable]" type="checkbox" class="tl_checkbox mw_enable" value="1" onfocus="Backend.getScrollOffset()"' . ( ( $ this -> varValue [ $ i ] [ 'enable' ] ) ? ' checked' : '' ) . '>' ; } else { $ return .= ' <button type="button" data-command="' . $ button . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mw_' . $ button ] ) . '">' . Image :: getHtml ( $ button . '.svg' ) . '</button>' ; } } $ return .= '</td> </tr>' ; } return $ return . ' </tbody> </table> <script>Backend.moduleWizard("ctrl_' . $ this -> strId . '")</script>' ; } 
public function checkAuthentication ( UserInterface $ user , UsernamePasswordToken $ token ) : void { if ( ! $ user instanceof User ) { parent :: checkAuthentication ( $ user , $ token ) ; return ; } try { parent :: checkAuthentication ( $ user , $ token ) ; } catch ( AuthenticationException $ exception ) { if ( ! $ exception instanceof BadCredentialsException ) { throw $ exception ; } if ( ! $ this -> triggerCheckCredentialsHook ( $ user , $ token ) ) { throw $ this -> onBadCredentials ( $ user , $ exception ) ; } } $ user -> loginCount = $ this -> options [ 'login_attempts' ] ; $ user -> save ( ) ; } 
public function onBadCredentials ( User $ user , AuthenticationException $ exception ) : AuthenticationException { -- $ user -> loginCount ; if ( $ user -> loginCount > 0 ) { $ user -> save ( ) ; return new BadCredentialsException ( sprintf ( 'Invalid password submitted for username "%s"' , $ user -> username ) , $ exception -> getCode ( ) , $ exception ) ; } $ user -> locked = time ( ) + $ this -> options [ 'lock_period' ] ; $ user -> loginCount = $ this -> options [ 'login_attempts' ] ; $ user -> save ( ) ; $ lockedSeconds = $ user -> locked - time ( ) ; $ lockedMinutes = ( int ) ceil ( $ lockedSeconds / 60 ) ; $ exception = new LockedException ( $ lockedSeconds , sprintf ( 'User "%s" has been locked for %s minutes' , $ user -> username , $ lockedMinutes ) , 0 , $ exception ) ; $ exception -> setUser ( $ user ) ; return $ exception ; } 
public function replace ( $ strBuffer , $ blnCache = true ) { $ strBuffer = $ this -> doReplace ( $ strBuffer , $ blnCache ) ; 
protected function doReplace ( $ strBuffer , $ blnCache ) { global $ objPage ; 
public function send ( DataContainer $ dc ) { $ objNewsletter = $ this -> Database -> prepare ( "SELECT n.*, c.template AS channelTemplate, c.sender AS channelSender, c.senderName as channelSenderName FROM tl_newsletter n LEFT JOIN tl_newsletter_channel c ON n.pid=c.id WHERE n.id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; <div id="tl_buttons"> <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div> <form action="' . TL_SCRIPT . '" id="tl_newsletter_send" class="tl_form tl_edit_form" method="get"> <div class="tl_formbody_edit tl_newsletter_send"> <input type="hidden" name="do" value="' . Input :: get ( 'do' ) . '"> <input type="hidden" name="table" value="' . Input :: get ( 'table' ) . '"> <input type="hidden" name="key" value="' . Input :: get ( 'key' ) . '"> <input type="hidden" name="id" value="' . Input :: get ( 'id' ) . '"> <input type="hidden" name="token" value="' . $ strToken . '"> <table class="prev_header"> <tr class="row_0"> <td class="col_0">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'from' ] . '</td> <td class="col_1">' . sprintf ( $ sprintf , Idna :: decodeEmail ( $ objNewsletter -> sender ) ) . '</td> </tr> <tr class="row_1"> <td class="col_0">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'subject' ] [ 0 ] . '</td> <td class="col_1">' . $ objNewsletter -> subject . '</td> </tr> <tr class="row_2"> <td class="col_0">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'template' ] [ 0 ] . '</td> <td class="col_1">' . $ objNewsletter -> template . '</td> </tr>' . ( ( ! empty ( $ arrAttachments ) && \ is_array ( $ arrAttachments ) ) ? ' <tr class="row_3"> <td class="col_0">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'attachments' ] . '</td> <td class="col_1">' . implode ( ', ' , $ arrAttachments ) . '</td> </tr>' : '' ) . ' </table>' . ( ! $ objNewsletter -> sendText ? ' <div class="preview_html"> ' . $ html . ' </div>' : '' ) . ' <div class="preview_text"> <pre style="white-space:pre-wrap">' . $ text . '</pre> </div> <fieldset class="tl_tbox nolegend"> <div class="w50 widget"> <h3><label for="ctrl_mpc">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'mailsPerCycle' ] [ 0 ] . '</label></h3> <input type="text" name="mpc" id="ctrl_mpc" value="10" class="tl_text" onfocus="Backend.getScrollOffset()">' . ( ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'mailsPerCycle' ] [ 1 ] && Config :: get ( 'showHelp' ) ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'mailsPerCycle' ] [ 1 ] . '</p>' : '' ) . ' </div> <div class="w50 widget"> <h3><label for="ctrl_timeout">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'timeout' ] [ 0 ] . '</label></h3> <input type="text" name="timeout" id="ctrl_timeout" value="1" class="tl_text" onfocus="Backend.getScrollOffset()">' . ( ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'timeout' ] [ 1 ] && Config :: get ( 'showHelp' ) ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'timeout' ] [ 1 ] . '</p>' : '' ) . ' </div> <div class="w50 widget"> <h3><label for="ctrl_start">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'start' ] [ 0 ] . '</label></h3> <input type="text" name="start" id="ctrl_start" value="0" class="tl_text" onfocus="Backend.getScrollOffset()">' . ( ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'start' ] [ 1 ] && Config :: get ( 'showHelp' ) ) ? ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'start' ] [ 1 ] , $ objNewsletter -> id ) . '</p>' : '' ) . ' </div> <div class="w50 widget"> <h3><label for="ctrl_recipient">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'sendPreviewTo' ] [ 0 ] . '</label></h3> <input type="text" name="recipient" id="ctrl_recipient" value="' . Idna :: decodeEmail ( $ this -> User -> email ) . '" class="tl_text" onfocus="Backend.getScrollOffset()">' . ( isset ( $ _SESSION [ 'TL_PREVIEW_MAIL_ERROR' ] ) ? ' <div class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'email' ] . '</div>' : ( ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'sendPreviewTo' ] [ 1 ] && Config :: get ( 'showHelp' ) ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'sendPreviewTo' ] [ 1 ] . '</p>' : '' ) ) . ' </div> </fieldset> </div>' ; $ return .= ' <div class="tl_formbody_submit"> <div class="tl_submit_container"> <button type="submit" name="preview" class="tl_submit" accesskey="p">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'preview' ] . '</button> <button type="submit" id="send" class="tl_submit" accesskey="s" onclick="return confirm(\'' . str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'sendConfirm' ] ) . '\')">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter' ] [ 'send' ] [ 0 ] . '</button> </div> </div> </form>' ; unset ( $ _SESSION [ 'TL_PREVIEW_MAIL_ERROR' ] ) ; return $ return ; } 
protected function generateEmailObject ( Result $ objNewsletter , $ arrAttachments ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ objNewsletter -> sender ; $ objEmail -> subject = $ objNewsletter -> subject ; 
protected function sendNewsletter ( Email $ objEmail , Result $ objNewsletter , $ arrRecipient , $ text , $ html , $ css = null ) { 
public function importRecipients ( ) { if ( Input :: get ( 'key' ) != 'import' ) { return '' ; } $ objUploader = new FileUpload ( ) ; <div id="tl_buttons"> <a href="' . ampersand ( str_replace ( '&key=import' , '' , Environment :: get ( 'request' ) ) ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div> ' . Message :: generate ( ) . ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_recipients_import" class="tl_form tl_edit_form" method="post" enctype="multipart/form-data"> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="tl_recipients_import"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"> <input type="hidden" name="MAX_FILE_SIZE" value="' . Config :: get ( 'maxFileSize' ) . '"> <fieldset class="tl_tbox nolegend"> <div class="widget w50"> <h3><label for="separator">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'separator' ] [ 0 ] . '</label></h3> <select name="separator" id="separator" class="tl_select" onfocus="Backend.getScrollOffset()"> <option value="comma">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'comma' ] . '</option> <option value="semicolon">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'semicolon' ] . '</option> <option value="tabulator">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tabulator' ] . '</option> <option value="linebreak">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'linebreak' ] . '</option> </select>' . ( ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'separator' ] [ 1 ] != '' ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'separator' ] [ 1 ] . '</p>' : '' ) . ' </div> <div class="widget clr"> <h3>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'source' ] [ 0 ] . '</h3>' . $ objUploader -> generateMarkup ( ) . ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'source' ] [ 1 ] ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'source' ] [ 1 ] . '</p>' : '' ) . ' </div> </fieldset> </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> <button type="submit" name="save" id="save" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'import' ] [ 0 ] . '</button> </div> </div> </form>' ; } 
public function removeSubscriptions ( $ intUser , $ strMode ) { if ( ! $ intUser ) { return ; } 
public function createNewUser ( $ intUser , $ arrData ) { $ arrNewsletters = StringUtil :: deserialize ( $ arrData [ 'newsletter' ] , true ) ; 
public function activateAccount ( $ objUser ) { $ arrNewsletters = StringUtil :: deserialize ( $ objUser -> newsletter , true ) ; 
public function onToggleVisibility ( $ blnDisabled , DataContainer $ dc ) { if ( ! $ dc -> id ) { return $ blnDisabled ; } $ objUser = $ this -> Database -> prepare ( "SELECT email FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objUser -> numRows ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET tstamp=?, active=? WHERE email=?" ) -> execute ( time ( ) , ( $ blnDisabled ? '' : '1' ) , $ objUser -> email ) ; } return $ blnDisabled ; } 
public function synchronize ( $ varValue , $ objUser , $ objModule = null ) { 
public function updateAccount ( ) { $ intUser = Input :: get ( 'id' ) ; 
public function purgeSubscriptions ( ) { $ objRecipient = NewsletterRecipientsModel :: findExpiredSubscriptions ( ) ; if ( $ objRecipient === null ) { return ; } foreach ( $ objRecipient as $ objModel ) { $ objModel -> delete ( ) ; } 
public function getNewsletters ( $ objModule ) { $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter === null ) { return array ( ) ; } $ arrNewsletters = array ( ) ; 
public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; 
protected function validator ( $ varInput ) { if ( $ varInput == '*****' ) { $ this -> blnSubmitInput = false ; return true ; } return parent :: validator ( $ varInput ) ; } 
public function generate ( ) { return sprintf ( '<input type="password" name="%s" id="ctrl_%s" class="tl_text%s" value="%s"%s onfocus="Backend.getScrollOffset()">%s' , $ this -> strName , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , ( ( $ this -> varValue != '' ) ? '*****' : '' ) , $ this -> getAttributes ( ) , $ this -> wizard ) ; } 
public function generate ( ) { if ( $ this -> youtube == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://youtu.be/' . $ this -> youtube . '" target="_blank" rel="noreferrer noopener">youtu.be/' . $ this -> youtube . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; } 
protected function compile ( ) { $ size = StringUtil :: deserialize ( $ this -> playerSize ) ; if ( ! \ is_array ( $ size ) || empty ( $ size [ 0 ] ) || empty ( $ size [ 1 ] ) ) { $ this -> Template -> size = ' width="640" height="360"' ; } else { $ this -> Template -> size = ' width="' . $ size [ 0 ] . '" height="' . $ size [ 1 ] . '"' ; } $ params = array ( ) ; $ options = StringUtil :: deserialize ( $ this -> youtubeOptions ) ; $ domain = 'https://www.youtube.com' ; if ( \ is_array ( $ options ) ) { foreach ( $ options as $ option ) { switch ( $ option ) { case 'youtube_fs' : case 'youtube_rel' : case 'youtube_showinfo' : case 'youtube_controls' : $ params [ ] = substr ( $ option , 8 ) . '=0' ; break ; case 'youtube_hl' : $ params [ ] = substr ( $ option , 8 ) . '=' . substr ( $ GLOBALS [ 'TL_LANGUAGE' ] , 0 , 2 ) ; break ; case 'youtube_iv_load_policy' : $ params [ ] = substr ( $ option , 8 ) . '=3' ; break ; case 'youtube_nocookie' : $ domain = 'https://www.youtube-nocookie.com' ; break ; default : $ params [ ] = substr ( $ option , 8 ) . '=1' ; } } } if ( $ this -> playerStart > 0 ) { $ params [ ] = 'start=' . ( int ) $ this -> playerStart ; } if ( $ this -> playerStop > 0 ) { $ params [ ] = 'end=' . ( int ) $ this -> playerStop ; } $ url = $ domain . '/embed/' . $ this -> youtube ; if ( ! empty ( $ params ) ) { $ url .= '?' . implode ( '&amp;' , $ params ) ; } $ this -> Template -> src = $ url ; $ this -> Template -> aspect = str_replace ( ':' , '' , $ this -> playerAspect ) ; $ this -> Template -> caption = $ this -> playerCaption ; } 
public function run28Update ( ) { 
public function run29Update ( ) { `id` int(10) unsigned NOT NULL auto_increment, `tstamp` int(10) unsigned NOT NULL default 0, `name` varchar(128) NOT NULL default '', `author` varchar(128) NOT NULL default '', `screenshot` varchar(255) NOT NULL default '', `folders` blob NULL, `templates` varchar(255) NOT NULL default '', PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8;" ) ; // Add a PID column to the child tables $ this -> Database -> query ( "ALTER TABLE `tl_module` ADD `pid` int(10) unsigned NOT NULL default 0" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_style_sheet` ADD `pid` int(10) unsigned NOT NULL default 0" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `pid` int(10) unsigned NOT NULL default 0" ) ; $ this -> Database -> query ( "UPDATE tl_module SET pid=1" ) ; $ this -> Database -> query ( "UPDATE tl_style_sheet SET pid=1" ) ; $ this -> Database -> query ( "UPDATE tl_layout SET pid=1" ) ; // Create a theme from the present resources $ this -> Database -> prepare ( "INSERT INTO tl_theme SET tstamp=?, name=?" ) -> execute ( time ( ) , 'Default' ) ; // Adjust the back end user permissions $ this -> Database -> query ( "ALTER TABLE `tl_user` ADD `themes` blob NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_user_group` ADD `themes` blob NULL" ) ; // Adjust the user and group rights $ objUser = $ this -> Database -> execute ( "SELECT id, modules, 'tl_user' AS tbl FROM tl_user WHERE modules!='' UNION SELECT id, modules, 'tl_user_group' AS tbl FROM tl_user_group WHERE modules!=''" ) ; while ( $ objUser -> next ( ) ) { $ modules = StringUtil :: deserialize ( $ objUser -> modules ) ; if ( empty ( $ modules ) || ! \ is_array ( $ modules ) ) { continue ; } $ themes = array ( ) ; foreach ( $ modules as $ k => $ v ) { if ( $ v == 'css' || $ v == 'modules ' || $ v == 'layout' ) { $ themes [ ] = $ v ; unset ( $ modules [ $ k ] ) ; } } if ( ! empty ( $ themes ) ) { $ modules [ ] = 'themes' ; } $ modules = array_values ( $ modules ) ; $ set = array ( 'modules' => ( ! empty ( $ modules ) ? serialize ( $ modules ) : null ) , 'themes' => ( ! empty ( $ themes ) ? serialize ( $ themes ) : null ) ) ; $ this -> Database -> prepare ( "UPDATE " . $ objUser -> tbl . " %s WHERE id=?" ) -> set ( $ set ) -> execute ( $ objUser -> id ) ; } // Featured news if ( $ this -> Database -> fieldExists ( 'news_featured' , 'tl_module' ) ) { $ this -> Database -> query ( "ALTER TABLE `tl_module` CHANGE `news_featured` `news_featured` varchar(16) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE tl_module SET news_featured='featured' WHERE news_featured='1'" ) ; } // Other version 2.9 updates $ this -> Database -> query ( "UPDATE tl_member SET country='gb' WHERE country='uk'" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_module` CHANGE `news_jumpToCurrent` `news_jumpToCurrent` varchar(16) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE tl_module SET news_jumpToCurrent='show_current' WHERE news_jumpToCurrent=1" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_user` ADD `useCE` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE tl_user SET useCE=1" ) ; } 
public function run292Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startTime` `startTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endTime` `endTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startDate` `startDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endDate` `endDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "UPDATE tl_calendar_events SET endDate=null WHERE endDate=0" ) ; } 
public function run210Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_style` ADD `positioning` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_style` SET `positioning`=`size`" ) ; $ this -> Database -> query ( "UPDATE `tl_module` SET `guests`=1 WHERE `type`='lostPassword' OR `type`='registration'" ) ; $ this -> Database -> query ( "UPDATE `tl_news` SET `teaser`=CONCAT('<p>', teaser, '</p>') WHERE `teaser`!='' AND `teaser` NOT LIKE '<p>%'" ) ; } 
public function run300Update ( ) { `id` int(10) unsigned NOT NULL auto_increment, `pid` binary(16) NULL, `tstamp` int(10) unsigned NOT NULL default 0, `uuid` binary(16) NULL, `type` varchar(16) NOT NULL default '', `path` varchar(1022) NOT NULL default '', `extension` varchar(16) NOT NULL default '', `hash` varchar(32) NOT NULL default '', `found` char(1) NOT NULL default '1', `name` varchar(255) NOT NULL default '', `meta` blob NULL, PRIMARY KEY (`id`), KEY `pid` (`pid`), UNIQUE KEY `uuid` (`uuid`), KEY `extension` (`extension`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8;" ) ; // Add the "numberOfItems" field $ this -> Database -> query ( "ALTER TABLE `tl_module` ADD `numberOfItems` smallint(5) unsigned NOT NULL default 0" ) ; $ this -> Database -> query ( "UPDATE `tl_module` SET `numberOfItems`=`rss_numberOfItems` WHERE `rss_numberOfItems`>0" ) ; $ this -> Database -> query ( "UPDATE `tl_module` SET `numberOfItems`=`news_numberOfItems` WHERE `news_numberOfItems`>0" ) ; // Add the "addMooTools" field $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `addMooTools` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_layout` SET `addMooTools`=1 WHERE `mootools`!=''" ) ; // Add the "notified" field $ this -> Database -> query ( "ALTER TABLE `tl_comments` ADD `notified` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_comments` SET `notified`=1" ) ; // Add the "rows" field $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `rows` varchar(8) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_layout` SET `rows`='1rw' WHERE `header`='' AND `footer`=''" ) ; $ this -> Database -> query ( "UPDATE `tl_layout` SET `rows`='2rwh' WHERE `header`!='' AND `footer`=''" ) ; $ this -> Database -> query ( "UPDATE `tl_layout` SET `rows`='2rwf' WHERE `header`='' AND `footer`!=''" ) ; $ this -> Database -> query ( "UPDATE `tl_layout` SET `rows`='3rw' WHERE `header`!='' AND `footer`!=''" ) ; // Update the "mooType" field $ this -> Database -> query ( "UPDATE `tl_content` SET `mooType`='mooStart' WHERE `mooType`='start'" ) ; $ this -> Database -> query ( "UPDATE `tl_content` SET `mooType`='mooStop' WHERE `mooType`='stop'" ) ; $ this -> Database -> query ( "UPDATE `tl_content` SET `mooType`='mooSingle' WHERE `mooType`='single'" ) ; // Add the "framework" field $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `framework` varchar(255) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_layout` SET `framework`='a:2:{i:0;s:10:\"layout.css\";i:1;s:11:\"tinymce.css\";}'" ) ; $ this -> Database -> query ( "UPDATE `tl_layout` SET `framework`='a:1:{i:0;s:10:\"layout.css\";}' WHERE skipTinymce=1" ) ; // Make sure the "skipFramework" field exists (see #4624) if ( $ this -> Database -> fieldExists ( 'skipFramework' , 'tl_layout' ) ) { $ this -> Database -> query ( "UPDATE `tl_layout` SET `framework`='' WHERE skipFramework=1" ) ; } // Add the "ptable" field $ this -> Database -> query ( "ALTER TABLE `tl_content` ADD ptable varchar(64) NOT NULL default ''" ) ; // Create a content element for each news article $ objNews = $ this -> Database -> execute ( "SELECT * FROM tl_news WHERE text!='' AND source='default'" ) ; while ( $ objNews -> next ( ) ) { $ this -> createContentElement ( $ objNews , 'tl_news' , 'text' ) ; } // Create a content element for each event $ objEvents = $ this -> Database -> execute ( "SELECT * FROM tl_calendar_events WHERE details!='' AND source='default'" ) ; while ( $ objEvents -> next ( ) ) { $ this -> createContentElement ( $ objEvents , 'tl_calendar_events' , 'details' ) ; } // Convert the gradient angle syntax (see #4569) if ( $ this -> Database -> fieldExists ( 'gradientAngle' , 'tl_style' ) ) { $ objStyle = $ this -> Database -> execute ( "SELECT id, gradientAngle FROM tl_style WHERE gradientAngle!=''" ) ; while ( $ objStyle -> next ( ) ) { $ angle = '' ; if ( strpos ( $ objStyle -> gradientAngle , 'deg' ) !== false ) { $ angle = ( abs ( 450 - ( int ) $ objStyle -> gradientAngle ) % 360 ) . 'deg' ; } else { switch ( $ objStyle -> gradientAngle ) { case 'top' : $ angle = 'to bottom' ; break ; case 'right' : $ angle = 'to left' ; break ; case 'bottom' : $ angle = 'to top' ; break ; case 'left' : $ angle = 'to right' ; break ; case 'top left' : $ angle = 'to bottom right' ; break ; case 'top right' : $ angle = 'to bottom left' ; break ; case 'bottom left' : $ angle = 'to top right' ; break ; case 'bottom right' : $ angle = 'to top left' ; break ; } } $ this -> Database -> prepare ( "UPDATE tl_style SET gradientAngle=? WHERE id=?" ) -> execute ( $ angle , $ objStyle -> id ) ; } } // Make unlimited recurrences end on 2038-01-01 00:00:00 (see #4862) $ this -> Database -> query ( "UPDATE `tl_calendar_events` SET `repeatEnd`=2145913200 WHERE `recurring`=1 AND `recurrences`=0" ) ; } 
public function run31Update ( ) { 
public function run32Update ( ) { 
public function run33Update ( ) { $ objLayout = $ this -> Database -> query ( "SELECT id, framework FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ strFramework = '' ; $ tmp = StringUtil :: deserialize ( $ objLayout -> framework ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { if ( ( $ key = array_search ( 'layout.css' , $ tmp ) ) !== false ) { array_insert ( $ tmp , $ key + 1 , 'responsive.css' ) ; } $ strFramework = serialize ( array_values ( array_unique ( $ tmp ) ) ) ; } $ this -> Database -> prepare ( "UPDATE tl_layout SET framework=? WHERE id=?" ) -> execute ( $ strFramework , $ objLayout -> id ) ; } 
public function run35Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_member` CHANGE `username` `username` varchar(64) COLLATE utf8_bin NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_member` SET username=NULL WHERE username=''" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_member` DROP INDEX `username`, ADD UNIQUE KEY `username` (`username`)" ) ; } 
public function run40Update ( ) { 
public function scanUploadFolder ( $ strPath = null , $ pid = null ) { if ( $ strPath === null ) { $ strPath = Config :: get ( 'uploadPath' ) ; } $ arrMeta = array ( ) ; $ arrMapper = array ( ) ; $ arrFolders = array ( ) ; $ arrFiles = array ( ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrScan = scan ( $ rootDir . '/' . $ strPath ) ; foreach ( $ arrScan as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ rootDir . '/' . $ strPath . '/' . $ strFile ) ) { $ arrFolders [ ] = $ strPath . '/' . $ strFile ; } else { $ arrFiles [ ] = $ strPath . '/' . $ strFile ; } } 
public function updateFileTreeFields ( ) { $ processed = array ( ) ; $ arrFields = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ strTable = $ file -> getBasename ( '.php' ) ; try { $ this -> loadDataContainer ( $ strTable ) ; } catch ( \ Exception $ e ) { continue ; } 
public static function convertSingleField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; 
public static function convertMultiField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; 
public static function convertOrderField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; 
protected static function generateHelperObject ( $ value ) { $ return = new \ stdClass ( ) ; if ( ! \ is_array ( $ value ) ) { $ return -> value = rtrim ( $ value , "\x00" ) ; $ return -> isUuid = ( \ strlen ( $ value ) == 16 && ! is_numeric ( $ return -> value ) && strncmp ( $ return -> value , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value ) && $ return -> value > 0 ) ; } else { $ return -> value = array_map ( function ( $ var ) { return rtrim ( $ var , "\x00" ) ; } , $ value ) ; $ return -> isUuid = ( \ strlen ( $ value [ 0 ] ) == 16 && ! is_numeric ( $ return -> value [ 0 ] ) && strncmp ( $ return -> value [ 0 ] , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value [ 0 ] ) && $ return -> value [ 0 ] > 0 ) ; } return $ return ; } 
protected function createContentElement ( Result $ objElement , $ strPtable , $ strField ) { $ set = array ( 'pid' => $ objElement -> id , 'ptable' => $ strPtable , 'sorting' => 128 , 'tstamp' => $ objElement -> tstamp , 'type' => 'text' , 'text' => $ objElement -> $ strField , 'addImage' => $ objElement -> addImage , 'singleSRC' => $ objElement -> singleSRC , 'alt' => $ objElement -> alt , 'size' => $ objElement -> size , 'imagemargin' => $ objElement -> imagemargin , 'imageUrl' => $ objElement -> imageUrl , 'fullsize' => $ objElement -> fullsize , 'caption' => $ objElement -> caption , 'floating' => $ objElement -> floating ) ; $ this -> Database -> prepare ( "INSERT INTO tl_content %s" ) -> set ( $ set ) -> execute ( ) ; } 
private function acceptLicense ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_license' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'license.html.twig' ) ; } $ this -> container -> get ( 'contao.install_tool' ) -> persistConfig ( 'licenseAccepted' , true ) ; return $ this -> getRedirectResponse ( ) ; } 
private function setPassword ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_password' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'password.html.twig' ) ; } $ password = $ request -> request -> get ( 'password' ) ; $ confirmation = $ request -> request -> get ( 'confirmation' ) ; 
private function login ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_login' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'login.html.twig' ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ verified = password_verify ( $ request -> request -> get ( 'password' ) , $ installTool -> getConfig ( 'installPassword' ) ) ; if ( ! $ verified ) { $ installTool -> increaseLoginCount ( ) ; return $ this -> render ( 'login.html.twig' , [ 'error' => $ this -> trans ( 'invalid_password' ) , ] ) ; } $ installTool -> resetLoginCount ( ) ; $ this -> container -> get ( 'contao.install_tool_user' ) -> setAuthenticated ( true ) ; return $ this -> getRedirectResponse ( ) ; } 
private function purgeSymfonyCache ( ) : void { $ filesystem = new Filesystem ( ) ; $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; $ ref = new \ ReflectionObject ( $ this -> container ) ; $ containerDir = basename ( \ dirname ( $ ref -> getFileName ( ) ) ) ; $ finder = Finder :: create ( ) -> depth ( 0 ) -> exclude ( $ containerDir ) -> in ( $ cacheDir ) ; foreach ( $ finder as $ file ) { $ filesystem -> remove ( $ file -> getPathname ( ) ) ; } if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } } 
private function warmUpSymfonyCache ( ) : void { $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ cacheDir . '/contao/config/config.php' ) ) { return ; } $ warmer = $ this -> container -> get ( 'cache_warmer' ) ; if ( ! $ this -> getContainerParameter ( 'kernel.debug' ) ) { $ warmer -> enableOptionalWarmers ( ) ; } $ warmer -> warmUp ( $ cacheDir ) ; if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } } 
private function setUpDatabaseConnection ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } 
private function adjustDatabaseTables ( ) : ? RedirectResponse { $ this -> container -> get ( 'contao.install_tool' ) -> handleRunOnce ( ) ; $ installer = $ this -> container -> get ( 'contao.installer' ) ; $ this -> context [ 'sql_form' ] = $ installer -> getCommands ( ) ; $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_database_update' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return null ; } $ sql = $ request -> request -> get ( 'sql' ) ; if ( ! empty ( $ sql ) && \ is_array ( $ sql ) ) { foreach ( $ sql as $ hash ) { $ installer -> execCommand ( $ hash ) ; } } return $ this -> getRedirectResponse ( ) ; } 
private function importExampleWebsite ( ) : ? RedirectResponse { $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ templates = $ installTool -> getTemplates ( ) ; $ this -> context [ 'templates' ] = $ templates ; if ( $ installTool -> getConfig ( 'exampleWebsite' ) ) { $ this -> context [ 'import_date' ] = date ( 'Y-m-d H:i' , $ installTool -> getConfig ( 'exampleWebsite' ) ) ; } $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_template_import' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return null ; } $ template = $ request -> request -> get ( 'template' ) ; if ( '' === $ template || ! \ in_array ( $ template , $ templates , true ) ) { $ this -> context [ 'import_error' ] = $ this -> trans ( 'import_empty_source' ) ; return null ; } try { $ installTool -> importTemplate ( $ template , '1' === $ request -> request -> get ( 'preserve' ) ) ; } catch ( DBALException $ e ) { $ installTool -> persistConfig ( 'exampleWebsite' , null ) ; $ installTool -> logException ( $ e ) ; $ this -> context [ 'import_error' ] = $ this -> trans ( 'import_exception' ) ; return null ; } $ installTool -> persistConfig ( 'exampleWebsite' , time ( ) ) ; return $ this -> getRedirectResponse ( ) ; } 
private function getRedirectResponse ( ) : RedirectResponse { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } return new RedirectResponse ( $ request -> getRequestUri ( ) ) ; } 
private function addDefaultsToContext ( array $ context ) : array { $ context = array_merge ( $ this -> context , $ context ) ; if ( ! isset ( $ context [ 'request_token' ] ) ) { $ context [ 'request_token' ] = $ this -> getRequestToken ( ) ; } if ( ! isset ( $ context [ 'language' ] ) ) { $ context [ 'language' ] = $ this -> container -> get ( 'translator' ) -> getLocale ( ) ; } if ( ! isset ( $ context [ 'ua' ] ) ) { $ context [ 'ua' ] = $ this -> getUserAgentString ( ) ; } if ( ! isset ( $ context [ 'path' ] ) ) { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ context [ 'host' ] = $ request -> getHost ( ) ; $ context [ 'path' ] = $ request -> getBasePath ( ) ; } return $ context ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : int { $ this -> io = new SymfonyStyle ( $ input , $ output ) ; $ this -> webDir = rtrim ( $ input -> getArgument ( 'target' ) , '/' ) ; $ this -> generateSymlinks ( ) ; if ( ! empty ( $ this -> rows ) ) { $ this -> io -> newLine ( ) ; $ this -> io -> table ( [ '' , 'Symlink' , 'Target / Error' ] , $ this -> rows ) ; } return $ this -> statusCode ; } 
private function generateSymlinks ( ) : void { $ fs = new Filesystem ( ) ; 
private function symlink ( string $ target , string $ link ) : void { $ target = strtr ( $ target , '\\' , '/' ) ; $ link = strtr ( $ link , '\\' , '/' ) ; try { SymlinkUtil :: symlink ( $ target , $ link , $ this -> rootDir ) ; $ this -> rows [ ] = [ sprintf ( '<fg=green;options=bold>%s</>' , '\\' === \ DIRECTORY_SEPARATOR ? 'OK' : "\xE2\x9C\x94" 
private function findIn ( string $ path ) : Finder { return Finder :: create ( ) -> ignoreDotFiles ( false ) -> sort ( static function ( SplFileInfo $ a , SplFileInfo $ b ) : int { $ countA = substr_count ( strtr ( $ a -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; $ countB = substr_count ( strtr ( $ b -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; return $ countA <=> $ countB ; } ) -> followLinks ( ) -> in ( $ path ) ; } 
private function filterNestedPaths ( Finder $ finder , string $ prepend ) : array { $ parents = [ ] ; $ files = iterator_to_array ( $ finder ) ; foreach ( $ files as $ key => $ file ) { $ path = rtrim ( strtr ( $ prepend . '/' . $ file -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; if ( ! empty ( $ parents ) ) { $ parent = \ dirname ( $ path ) ; while ( false !== strpos ( $ parent , '/' ) ) { if ( \ in_array ( $ parent , $ parents , true ) ) { $ this -> rows [ ] = [ sprintf ( '<fg=yellow;options=bold>%s</>' , '\\' === \ DIRECTORY_SEPARATOR ? 'WARNING' : '!' ) , $ this -> webDir . '/' . $ path , sprintf ( '<comment>Skipped because %s will be symlinked.</comment>' , $ parent ) , ] ; unset ( $ files [ $ key ] ) ; break ; } $ parent = \ dirname ( $ parent ) ; } } $ parents [ ] = $ path ; } return array_values ( $ files ) ; } 
public function listImageSizeItem ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'media' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; } 
public function create ( ) : ItemInterface { $ tree = $ this -> factory -> createItem ( 'root' ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: BACKEND_MENU_BUILD , new MenuEvent ( $ this -> factory , $ tree ) ) ; return $ tree ; } 
protected function compile ( ) { switch ( $ this -> news_format ) { case 'news_year' : $ this -> compileYearlyMenu ( ) ; break ; default : case 'news_month' : $ this -> compileMonthlyMenu ( ) ; break ; case 'news_day' : $ this -> compileDailyMenu ( ) ; break ; } $ this -> Template -> empty = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'emptyList' ] ; } 
protected function compileDailyMenu ( ) { $ arrData = array ( ) ; $ time = Date :: floorToMinute ( ) ; 
protected function compileDays ( ) { $ arrDays = array ( ) ; for ( $ i = 0 ; $ i < 7 ; $ i ++ ) { $ intCurrentDay = ( $ i + $ this -> news_startDay ) % 7 ; $ arrDays [ $ intCurrentDay ] = $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] [ $ intCurrentDay ] ; } return array_values ( $ arrDays ) ; } 
protected function compileWeeks ( $ arrData ) { $ intDaysInMonth = date ( 't' , $ this -> Date -> monthBegin ) ; $ intFirstDayOffset = date ( 'w' , $ this -> Date -> monthBegin ) - $ this -> news_startDay ; if ( $ intFirstDayOffset < 0 ) { $ intFirstDayOffset += 7 ; } $ intColumnCount = - 1 ; $ intNumberOfRows = ceil ( ( $ intDaysInMonth + $ intFirstDayOffset ) / 7 ) ; $ arrDays = array ( ) ; 
protected function sortOutProtected ( $ arrCalendars ) { if ( empty ( $ arrCalendars ) || ! \ is_array ( $ arrCalendars ) ) { return $ arrCalendars ; } $ this -> import ( FrontendUser :: class , 'User' ) ; $ objCalendar = CalendarModel :: findMultipleByIds ( $ arrCalendars ) ; $ arrCalendars = array ( ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { if ( $ objCalendar -> protected ) { if ( ! FE_USER_LOGGED_IN || ! \ is_array ( $ this -> User -> groups ) ) { continue ; } $ groups = StringUtil :: deserialize ( $ objCalendar -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) || \ count ( array_intersect ( $ groups , $ this -> User -> groups ) ) < 1 ) { continue ; } } $ arrCalendars [ ] = $ objCalendar -> id ; } } return $ arrCalendars ; } 
protected function getAllEvents ( $ arrCalendars , $ intStart , $ intEnd ) { if ( ! \ is_array ( $ arrCalendars ) ) { return array ( ) ; } $ this -> arrEvents = array ( ) ; foreach ( $ arrCalendars as $ id ) { 
protected function addEvent ( $ objEvents , $ intStart , $ intEnd , $ intBegin , $ intLimit , $ intCalendar ) { global $ objPage ; 
protected function getDatesFromFormat ( Date $ objDate , $ strFormat ) { switch ( $ strFormat ) { case 'cal_day' : return array ( $ objDate -> dayBegin , $ objDate -> dayEnd , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_emptyDay' ] ) ; default : case 'cal_month' : return array ( $ objDate -> monthBegin , $ objDate -> monthEnd , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_emptyMonth' ] ) ; case 'cal_year' : return array ( $ objDate -> yearBegin , $ objDate -> yearEnd , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_emptyYear' ] ) ; case 'cal_all' : 
public function onInitialize ( InitializeApplicationEvent $ event ) : void { $ this -> installAssets ( $ event ) ; $ this -> installContao ( $ event ) ; $ this -> createSymlinks ( $ event ) ; } 
private function runCommand ( Command $ command , InputInterface $ input ) : ? string { if ( $ command instanceof ContainerAwareInterface ) { $ command -> setContainer ( $ this -> container ) ; } $ output = new BufferedOutput ( OutputInterface :: VERBOSITY_NORMAL , true ) ; $ status = $ command -> run ( $ input , $ output ) ; if ( $ status > 0 ) { return $ output -> fetch ( ) ; } return null ; } 
public function fetch ( $ strTable , $ varKey , $ strAlias = null ) { $ strClass = Model :: getClassFromTable ( $ strTable ) ; $ strPk = $ strClass :: getPk ( ) ; 
public function fetchByAlias ( $ strTable , $ strAlias , $ varValue ) { if ( isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ) { $ strPk = $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ; if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ; } } return null ; } 
public function register ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; 
public function unregister ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; 
public function isRegistered ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; return isset ( $ this -> arrIdentities [ $ intObjectId ] ) ; } 
public function registerAlias ( Model $ objModel , $ strAlias , $ varValue ) { $ strTable = $ objModel -> getTable ( ) ; $ strPk = $ objModel -> getPk ( ) ; $ varPk = $ objModel -> $ strPk ; if ( isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ) { throw new \ RuntimeException ( "The registry already contains an alias for $strTable::$strPk($varPk) ($strAlias/$varValue)" ) ; } $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] = $ varPk ; } 
public function isRegisteredAlias ( Model $ objModel , $ strAlias , $ varValue ) { $ strTable = $ objModel -> getTable ( ) ; return isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ; } 
protected function compile ( ) { global $ objPage ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ objPage -> language ; System :: loadLanguageFile ( 'tl_member' ) ; $ this -> loadDataContainer ( 'tl_member' ) ; 
protected function createNewUser ( $ arrData ) { $ arrData [ 'tstamp' ] = time ( ) ; $ arrData [ 'login' ] = $ this -> reg_allowLogin ; $ arrData [ 'dateAdded' ] = $ arrData [ 'tstamp' ] ; 
protected function sendActivationMail ( $ arrData ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'reg' , $ arrData [ 'email' ] , array ( 'tl_member' => array ( $ arrData [ 'id' ] ) ) ) ; 
protected function activateAcount ( ) { $ this -> strTemplate = 'mod_message' ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; 
protected function resendActivationMail ( MemberModel $ objMember ) { if ( $ objMember -> disable == '' ) { return ; } $ this -> strTemplate = 'mod_message' ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = null ; $ models = OptInModel :: findByRelatedTableAndIds ( 'tl_member' , array ( $ objMember -> id ) ) ; foreach ( $ models as $ model ) { 
protected function sendAdminNotification ( $ intId , $ arrData ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'adminSubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ strData = "\n\n" ; 
public function onAuthenticationSuccess ( Request $ request , TokenInterface $ token ) : RedirectResponse { $ this -> user = $ token -> getUser ( ) ; if ( ! $ this -> user instanceof User ) { return $ this -> getRedirectResponse ( $ request ) ; } $ this -> user -> lastLogin = $ this -> user -> currentLogin ; $ this -> user -> currentLogin = time ( ) ; $ this -> user -> save ( ) ; if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has logged in' , $ this -> user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ this -> user -> username ) ] ) ; } $ this -> triggerPostLoginHook ( ) ; return $ this -> getRedirectResponse ( $ request ) ; } 
protected function determineTargetUrl ( Request $ request ) : string { if ( ! $ this -> user instanceof FrontendUser ) { return parent :: determineTargetUrl ( $ request ) ; } if ( $ targetUrl = $ this -> getFixedTargetPath ( $ request ) ) { return $ targetUrl ; } $ pageModelAdapter = $ this -> framework -> getAdapter ( PageModel :: class ) ; $ groups = StringUtil :: deserialize ( $ this -> user -> groups , true ) ; $ groupPage = $ pageModelAdapter -> findFirstActiveByMemberGroups ( $ groups ) ; if ( $ groupPage instanceof PageModel ) { return $ groupPage -> getAbsoluteUrl ( ) ; } return parent :: determineTargetUrl ( $ request ) ; } 
public static function findByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; } 
public static function findPublishedByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; } 
public static function findPublishedByPidAndColumn ( $ intPid , $ strColumn , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.inColumn=?" ) ; $ arrValues = array ( $ intPid , $ strColumn ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; } 
public static function initialize ( ) { $ _GET = static :: cleanKey ( $ _GET ) ; $ _POST = static :: cleanKey ( $ _POST ) ; $ _COOKIE = static :: cleanKey ( $ _COOKIE ) ; } 
public static function get ( $ strKey , $ blnDecodeEntities = false , $ blnKeepUnused = false ) { if ( ! isset ( $ _GET [ $ strKey ] ) ) { return null ; } $ strCacheKey = $ blnDecodeEntities ? 'getDecoded' : 'getEncoded' ; if ( ! isset ( static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] ) ) { $ varValue = $ _GET [ $ strKey ] ; $ varValue = static :: decodeEntities ( $ varValue ) ; $ varValue = static :: xssClean ( $ varValue , true ) ; $ varValue = static :: stripTags ( $ varValue ) ; if ( ! $ blnDecodeEntities ) { $ varValue = static :: encodeSpecialChars ( $ varValue ) ; } $ varValue = static :: encodeInsertTags ( $ varValue ) ; static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] = $ varValue ; } 
public static function post ( $ strKey , $ blnDecodeEntities = false ) { $ strCacheKey = $ blnDecodeEntities ? 'postDecoded' : 'postEncoded' ; if ( ! isset ( static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] ) ) { $ varValue = static :: findPost ( $ strKey ) ; if ( $ varValue === null ) { return $ varValue ; } $ varValue = static :: decodeEntities ( $ varValue ) ; $ varValue = static :: xssClean ( $ varValue , true ) ; $ varValue = static :: stripTags ( $ varValue ) ; if ( ! $ blnDecodeEntities ) { $ varValue = static :: encodeSpecialChars ( $ varValue ) ; } if ( ! \ defined ( 'TL_MODE' ) || TL_MODE != 'BE' ) { $ varValue = static :: encodeInsertTags ( $ varValue ) ; } static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] = $ varValue ; } return static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] ; } 
public static function postHtml ( $ strKey , $ blnDecodeEntities = false ) { $ strCacheKey = $ blnDecodeEntities ? 'postHtmlDecoded' : 'postHtmlEncoded' ; if ( ! isset ( static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] ) ) { $ varValue = static :: findPost ( $ strKey ) ; if ( $ varValue === null ) { return $ varValue ; } $ varValue = static :: decodeEntities ( $ varValue ) ; $ varValue = static :: xssClean ( $ varValue ) ; $ varValue = static :: stripTags ( $ varValue , Config :: get ( 'allowedTags' ) ) ; if ( ! $ blnDecodeEntities ) { $ varValue = static :: encodeSpecialChars ( $ varValue ) ; } if ( ! \ defined ( 'TL_MODE' ) || TL_MODE != 'BE' ) { $ varValue = static :: encodeInsertTags ( $ varValue ) ; } static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] = $ varValue ; } return static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] ; } 
public static function postRaw ( $ strKey ) { $ strCacheKey = 'postRaw' ; if ( ! isset ( static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] ) ) { $ varValue = static :: findPost ( $ strKey ) ; if ( $ varValue === null ) { return $ varValue ; } $ varValue = static :: preserveBasicEntities ( $ varValue ) ; $ varValue = static :: xssClean ( $ varValue ) ; if ( ! \ defined ( 'TL_MODE' ) || TL_MODE != 'BE' ) { $ varValue = static :: encodeInsertTags ( $ varValue ) ; } static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] = $ varValue ; } return static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] ; } 
public static function postUnsafeRaw ( $ strKey ) { $ strCacheKey = 'postUnsafeRaw' ; if ( ! isset ( static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] ) ) { $ varValue = static :: findPost ( $ strKey ) ; if ( $ varValue === null ) { return $ varValue ; } static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] = $ varValue ; } return static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] ; } 
public static function cookie ( $ strKey , $ blnDecodeEntities = false ) { if ( ! isset ( $ _COOKIE [ $ strKey ] ) ) { return null ; } $ strCacheKey = $ blnDecodeEntities ? 'cookieDecoded' : 'cookieEncoded' ; if ( ! isset ( static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] ) ) { $ varValue = $ _COOKIE [ $ strKey ] ; $ varValue = static :: decodeEntities ( $ varValue ) ; $ varValue = static :: xssClean ( $ varValue , true ) ; $ varValue = static :: stripTags ( $ varValue ) ; if ( ! $ blnDecodeEntities ) { $ varValue = static :: encodeSpecialChars ( $ varValue ) ; } $ varValue = static :: encodeInsertTags ( $ varValue ) ; static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] = $ varValue ; } return static :: $ arrCache [ $ strCacheKey ] [ $ strKey ] ; } 
public static function setGet ( $ strKey , $ varValue , $ blnAddUnused = false ) { 
public static function setPost ( $ strKey , $ varValue ) { $ strKey = static :: cleanKey ( $ strKey ) ; unset ( static :: $ arrCache [ 'postEncoded' ] [ $ strKey ] ) ; unset ( static :: $ arrCache [ 'postDecoded' ] [ $ strKey ] ) ; unset ( static :: $ arrCache [ 'postHtmlEncoded' ] [ $ strKey ] ) ; unset ( static :: $ arrCache [ 'postHtmlDecoded' ] [ $ strKey ] ) ; unset ( static :: $ arrCache [ 'postRaw' ] [ $ strKey ] ) ; unset ( static :: $ arrCache [ 'postUnsafeRaw' ] [ $ strKey ] ) ; if ( $ varValue === null ) { unset ( $ _POST [ $ strKey ] ) ; } else { $ _POST [ $ strKey ] = $ varValue ; } } 
public static function setCookie ( $ strKey , $ varValue ) { $ strKey = static :: cleanKey ( $ strKey ) ; unset ( static :: $ arrCache [ 'cookieEncoded' ] [ $ strKey ] ) ; unset ( static :: $ arrCache [ 'cookieDecoded' ] [ $ strKey ] ) ; if ( $ varValue === null ) { unset ( $ _COOKIE [ $ strKey ] ) ; } else { $ _COOKIE [ $ strKey ] = $ varValue ; } } 
public static function cleanKey ( $ varValue ) { 
public static function stripTags ( $ varValue , $ strAllowedTags = '' ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } 
public static function xssClean ( $ varValue , $ blnStrictMode = false ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } 
public static function decodeEntities ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } 
public static function preserveBasicEntities ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } 
public static function encodeSpecialChars ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } 
public static function findPost ( $ strKey ) { if ( isset ( $ _POST [ $ strKey ] ) ) { return $ _POST [ $ strKey ] ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getMasterRequest ( ) ; 
protected function compile ( ) { $ this -> Template -> html = ( TL_MODE == 'FE' ) ? $ this -> html : htmlspecialchars ( $ this -> html ) ; } 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'logout' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } 
public function process ( ContainerBuilder $ container ) : void { if ( ! $ this -> hasMigrationsBundle ( $ container ) ) { return ; } $ provider = new Definition ( MigrationsSchemaProvider :: class ) ; $ provider -> addArgument ( new Reference ( 'contao.framework' ) ) ; $ provider -> addArgument ( new Reference ( 'doctrine' ) ) ; $ command = new Definition ( DoctrineMigrationsDiffCommand :: class ) ; $ command -> setArguments ( [ $ provider ] ) ; $ command -> addTag ( 'console.command' ) ; $ command -> setPublic ( true ) ; $ container -> setDefinition ( DoctrineMigrationsDiffCommand :: COMMAND_ID , $ command ) ; 
protected function compileYearlyMenu ( ) { $ arrData = array ( ) ; $ arrAllEvents = $ this -> getAllEvents ( $ this -> cal_calendar , 0 , 2145913200 ) ; foreach ( $ arrAllEvents as $ intDay => $ arrDay ) { foreach ( $ arrDay as $ arrEvents ) { $ arrData [ substr ( $ intDay , 0 , 4 ) ] += \ count ( $ arrEvents ) ; } } 
protected function compileMonthlyMenu ( ) { $ arrData = array ( ) ; $ arrAllEvents = $ this -> getAllEvents ( $ this -> cal_calendar , 0 , 2145913200 ) ; foreach ( $ arrAllEvents as $ intDay => $ arrDay ) { foreach ( $ arrDay as $ arrEvents ) { $ arrData [ substr ( $ intDay , 0 , 4 ) ] [ substr ( $ intDay , 4 , 2 ) ] += \ count ( $ arrEvents ) ; } } 
public function __isset ( $ strKey ) { if ( empty ( $ this -> arrCache ) ) { $ this -> next ( ) ; } return isset ( $ this -> arrCache [ $ strKey ] ) ; } 
public function fetchRow ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = array_values ( $ this -> resultSet [ ++ $ this -> intIndex ] ) ; return $ this -> arrCache ; } 
public function fetchAssoc ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = $ this -> resultSet [ ++ $ this -> intIndex ] ; return $ this -> arrCache ; } 
public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ arrReturn = array ( ) ; while ( ( $ arrRow = $ this -> fetchAssoc ( ) ) !== false ) { if ( $ strKey != 'id' && isset ( $ arrRow [ 'id' ] ) ) { $ arrReturn [ $ arrRow [ 'id' ] ] = $ arrRow [ $ strKey ] ; } else { $ arrReturn [ ] = $ arrRow [ $ strKey ] ; } } return $ arrReturn ; } 
public function fetchAllAssoc ( ) { $ this -> reset ( ) ; $ arrReturn = array ( ) ; while ( ( $ arrRow = $ this -> fetchAssoc ( ) ) !== false ) { $ arrReturn [ ] = $ arrRow ; } return $ arrReturn ; } 
public function fetchField ( $ intOffset = 0 ) { $ arrFields = array_values ( $ this -> resultSet [ $ this -> intIndex ] ) ; return $ arrFields [ $ intOffset ] ; } 
public function first ( ) { $ this -> intIndex = 0 ; $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; } 
public function prev ( ) { if ( $ this -> intIndex < 1 ) { return false ; } $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ -- $ this -> intIndex ] ; return $ this ; } 
public function next ( ) { if ( $ this -> blnDone ) { return false ; } if ( $ this -> fetchAssoc ( ) !== false ) { return $ this ; } $ this -> blnDone = true ; return false ; } 
public function last ( ) { $ this -> intIndex = $ this -> count ( ) - 1 ; $ this -> blnDone = true ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; } 
public function row ( $ blnEnumerated = false ) { if ( empty ( $ this -> arrCache ) ) { $ this -> next ( ) ; } return $ blnEnumerated ? array_values ( $ this -> arrCache ) : $ this -> arrCache ; } 
public function getChannels ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> newsletters ) ) { return array ( ) ; } $ arrChannels = array ( ) ; $ objChannels = $ this -> Database -> execute ( "SELECT id, title FROM tl_newsletter_channel ORDER BY title" ) ; while ( $ objChannels -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objChannels -> id , 'newsletters' ) ) { $ arrChannels [ $ objChannels -> id ] = $ objChannels -> title ; } } return $ arrChannels ; } 
public function listFormFields ( $ arrRow ) { $ arrRow [ 'required' ] = $ arrRow [ 'mandatory' ] ; $ key = $ arrRow [ 'invisible' ] ? 'unpublished' : 'published' ; $ strType = ' <div class="cte_type ' . $ key . '">' . $ GLOBALS [ 'TL_LANG' ] [ 'FFL' ] [ $ arrRow [ 'type' ] ] [ 0 ] . ( $ arrRow [ 'name' ] ? ' (' . $ arrRow [ 'name' ] . ')' : '' ) . '</div> <div class="limit_height' . ( ! Contao \ Config :: get ( 'doNotCollapse' ) ? ' h32' : '' ) . '">' ; $ strClass = $ GLOBALS [ 'TL_FFL' ] [ $ arrRow [ 'type' ] ] ; if ( ! class_exists ( $ strClass ) ) { return '' ; } $ objWidget = new $ strClass ( $ arrRow ) ; $ strWidget = $ objWidget -> parse ( ) ; $ strWidget = preg_replace ( '/ name="[^"]+"/i' , '' , $ strWidget ) ; $ strWidget = str_replace ( array ( ' type="submit"' , ' autofocus' , ' required' ) , array ( ' type="button"' , '' , '' ) , $ strWidget ) ; if ( $ objWidget instanceof FormHidden ) { return $ strType . "\n" . $ objWidget -> value . "\n</div>\n" ; } return $ strType . Contao \ StringUtil :: insertTagToSrc ( $ strWidget ) . ' </div>' . "\n" ; } 
public function getFields ( ) { $ arrFields = $ GLOBALS [ 'TL_FFL' ] ; 
public function toggleVisibility ( $ intId , $ blnVisible , Contao \ DataContainer $ dc = null ) { 
public function generate ( ) { $ arrOptions = array ( ) ; if ( ! $ this -> multiple && \ count ( $ this -> arrOptions ) > 1 ) { $ this -> arrOptions = array ( $ this -> arrOptions [ 0 ] ) ; } 
protected function generateCheckbox ( $ arrOption , $ i ) { return sprintf ( '<input type="checkbox" name="%s" id="opt_%s" class="tl_checkbox" value="%s"%s%s onfocus="Backend.getScrollOffset()"> <label for="opt_%s">%s%s%s</label>' , $ this -> strName . ( $ this -> multiple ? '[]' : '' ) , $ this -> strId . '_' . $ i , ( $ this -> multiple ? StringUtil :: specialchars ( $ arrOption [ 'value' ] ) : 1 ) , $ this -> isChecked ( $ arrOption ) , $ this -> getAttributes ( ) , $ this -> strId . '_' . $ i , ( $ this -> mandatory && ! $ this -> multiple ? '<span class="invisible">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'mandatory' ] . ' </span>' : '' ) , $ arrOption [ 'label' ] , ( $ this -> mandatory && ! $ this -> multiple ? '<span class="mandatory">*</span>' : '' ) ) ; } 
public static function findPublishedByPids ( $ arrPids , $ blnFeatured = null , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( $ blnFeatured === true ) { $ arrColumns [ ] = "$t.featured='1'" ; } elseif ( $ blnFeatured === false ) { $ arrColumns [ ] = "$t.featured=''" ; } 
public static function countPublishedByPids ( $ arrPids , $ blnFeatured = null , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return 0 ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( $ blnFeatured === true ) { $ arrColumns [ ] = "$t.featured='1'" ; } elseif ( $ blnFeatured === false ) { $ arrColumns [ ] = "$t.featured=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , null , $ arrOptions ) ; } 
public static function findPublishedDefaultByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.source='default'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; } 
public static function findPublishedByPid ( $ intId , $ intLimit = 0 , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } if ( $ intLimit > 0 ) { $ arrOptions [ 'limit' ] = $ intLimit ; } return static :: findBy ( $ arrColumns , $ intId , $ arrOptions ) ; } 
public static function findPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; return static :: findBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; } 
public static function countPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; } 
public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } 
public function addPreviewImage ( $ row , $ label ) { if ( $ row [ 'screenshot' ] != '' ) { $ objFile = Contao \ FilesModel :: findByUuid ( $ row [ 'screenshot' ] ) ; if ( $ objFile !== null ) { $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ label = Contao \ Image :: getHtml ( Contao \ System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ objFile -> path , array ( 75 , 50 , 'center_top' ) ) -> getUrl ( $ rootDir ) , '' , 'class="theme_preview"' ) . ' ' . $ label ; } } return $ label ; } 
public function updateStyleSheet ( ) { $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; if ( $ objSession -> get ( 'style_sheet_update_all' ) ) { $ this -> import ( 'Contao\StyleSheets' , 'StyleSheets' ) ; $ this -> StyleSheets -> updateStyleSheets ( ) ; } $ objSession -> set ( 'style_sheet_update_all' , null ) ; } 
protected function doGetTemplateFolders ( $ path , $ level = 0 ) { $ return = array ( ) ; $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ rootDir . '/' . $ path ) as $ file ) { if ( is_dir ( $ rootDir . '/' . $ path . '/' . $ file ) ) { $ return [ $ path . '/' . $ file ] = str_repeat ( ' &nbsp; &nbsp; ' , $ level ) . $ file ; $ return = array_merge ( $ return , $ this -> doGetTemplateFolders ( $ path . '/' . $ file , $ level + 1 ) ) ; } } return $ return ; } 
public function editCss ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> hasAccess ( 'css' , 'themes' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } 
public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( 'html' !== $ request -> getRequestFormat ( ) ) { return ; } if ( ! AcceptHeader :: fromString ( $ request -> headers -> get ( 'Accept' ) ) -> has ( 'text/html' ) ) { return ; } $ this -> handleException ( $ event ) ; } 
private function renderErrorScreenByException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; $ statusCode = $ this -> getStatusCodeForException ( $ exception ) ; $ template = null ; $ this -> logException ( $ exception ) ; 
public function build ( ContainerBuilder $ container ) : void { parent :: build ( $ container ) ; $ container -> addCompilerPass ( new ContaoManagerPass ( ) ) ; $ container -> addCompilerPass ( new SwiftMailerPass ( ) ) ; } 
public function editHeader ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> canEditFieldsOf ( 'tl_faq_category' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } 
public function render ( ) { $ changes = parent :: render ( ) ; if ( empty ( $ changes ) ) { return '' ; } $ html = "\n" . '<div class="change">' ; 
public function addBreadcrumb ( ) { $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; <nav aria-label="' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'breadcrumbMenu' ] . '"> <ul id="tl_breadcrumb"> <li>' . implode ( ' › </li><li>', $ r rLinks) . ' /li> </ul> </nav>' ; } 
public function addNewTemplate ( ) { $ arrAllTemplates = array ( ) ; $ files = Contao \ System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> files ( ) -> name ( '/\.html5$/' ) ; foreach ( $ files as $ file ) { $ strRelpath = Contao \ StringUtil :: stripRootDir ( $ file -> getPathname ( ) ) ; $ strModule = preg_replace ( '@^(vendor/([^/]+/[^/]+)/|system/modules/([^/]+)/).*$@' , '$2$3' , strtr ( $ strRelpath , '\\' , '/' ) ) ; $ arrAllTemplates [ $ strModule ] [ $ strRelpath ] = basename ( $ strRelpath ) ; } $ strError = '' ; <div class="tl_message"> <p class="tl_error">' . $ strError . '</p> </div>' : '' ) . ' <div id="tl_buttons"> <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div> <form action="' . ampersand ( Contao \ Environment :: get ( 'request' ) ) . '" id="tl_create_template" class="tl_form tl_edit_form" method="post"> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="tl_create_template"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"> <div class="tl_tbox cf"> <div class="w50 widget"> <h3><label for="ctrl_original">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_templates' ] [ 'original' ] [ 0 ] . '</label></h3> <select name="original" id="ctrl_original" class="tl_select tl_chosen" onfocus="Backend.getScrollOffset()">' . $ strAllTemplates . '</select>' . ( ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_templates' ] [ 'original' ] [ 1 ] && Contao \ Config :: get ( 'showHelp' ) ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_templates' ] [ 'original' ] [ 1 ] . '</p>' : '' ) . ' </div> <div class="w50 widget"> <h3><label for="ctrl_target">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_templates' ] [ 'target' ] [ 0 ] . '</label></h3> <select name="target" id="ctrl_target" class="tl_select" onfocus="Backend.getScrollOffset()"><option value="templates">templates</option>' . $ this -> getTargetFolders ( 'templates' ) . '</select>' . ( ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_templates' ] [ 'target' ] [ 1 ] && Contao \ Config :: get ( 'showHelp' ) ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_templates' ] [ 'target' ] [ 1 ] . '</p>' : '' ) . ' </div> </div> </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> <button type="submit" name="create" id="create" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_templates' ] [ 'newTpl' ] . '</button> </div> </div> </form>' ; } 
public function compareTemplate ( Contao \ DataContainer $ dc ) { $ objCurrentFile = new Contao \ File ( $ dc -> id ) ; $ strName = $ objCurrentFile -> filename ; $ strExtension = $ objCurrentFile -> extension ; $ arrTemplates = Contao \ TemplateLoader :: getFiles ( ) ; $ blnOverridesAnotherTpl = isset ( $ arrTemplates [ $ strName ] ) ; $ strPrefix = '' ; if ( ( $ pos = strpos ( $ strName , '_' ) ) !== false ) { $ strPrefix = substr ( $ strName , 0 , $ pos + 1 ) ; } $ strBuffer = '' ; $ strCompareName = null ; $ strComparePath = null ; 
public function dragFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return '<button type="button" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</button> ' ; } 
protected function getTargetFolders ( $ strFolder , $ intLevel = 1 ) { $ strFolders = '' ; $ strPath = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFolder ; foreach ( scan ( $ strPath ) as $ strFile ) { if ( ! is_dir ( $ strPath . '/' . $ strFile ) || strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } $ strRelPath = $ strFolder . '/' . $ strFile ; $ strFolders .= sprintf ( '<option value="%s"%s>%s%s</option>' , $ strRelPath , ( ( Contao \ Input :: post ( 'target' ) == $ strRelPath ) ? ' selected="selected"' : '' ) , str_repeat ( ' &nbsp; ' , $ intLevel ) , basename ( $ strRelPath ) ) ; $ strFolders .= $ this -> getTargetFolders ( $ strRelPath , ( $ intLevel + 1 ) ) ; } return $ strFolders ; } 
public function editSource ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return is_file ( Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . rawurldecode ( $ row [ 'id' ] ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } 
public function process ( ContainerBuilder $ container ) : void { static $ services = [ 'assets.packages' , 'fragment.handler' , 'lexik_maintenance.driver.factory' , 'monolog.logger.contao' , 'security.authentication.trust_resolver' , 'security.firewall.map' , 'security.logout_url_generator' , ] ; foreach ( $ services as $ service ) { if ( ! $ container -> hasDefinition ( $ service ) ) { continue ; } $ definition = $ container -> getDefinition ( $ service ) ; $ definition -> setPublic ( true ) ; } static $ aliases = [ 'database_connection' , 'swiftmailer.mailer' , ] ; foreach ( $ aliases as $ alias ) { if ( ! $ container -> hasAlias ( $ alias ) ) { continue ; } $ alias = $ container -> getAlias ( $ alias ) ; $ alias -> setPublic ( true ) ; } } 
protected function hasUser ( ) : bool { $ user = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ user ) { return false ; } return ! ( $ user instanceof AnonymousToken ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : int { $ this -> fs = new Filesystem ( ) ; $ this -> io = new SymfonyStyle ( $ input , $ output ) ; $ this -> webDir = rtrim ( $ input -> getArgument ( 'target' ) , '/' ) ; $ this -> addEmptyDirs ( ) ; $ this -> addIgnoredDirs ( ) ; if ( ! empty ( $ this -> rows ) ) { $ this -> io -> newLine ( ) ; $ this -> io -> listing ( $ this -> rows ) ; } return 0 ; } 
private function getExistingSubpaths ( string $ subpath ) : array { $ paths = [ ] ; foreach ( $ this -> paths as $ path ) { if ( is_dir ( $ dir = $ path . '/' . $ subpath ) ) { $ paths [ ] = $ dir ; } } if ( empty ( $ paths ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The subpath "%s" does not exists.' , $ subpath ) ) ; } return $ paths ; } 
public function run ( ) { $ this -> disableProfiler ( ) ; if ( Environment :: get ( 'isAjaxRequest' ) ) { $ this -> getDatalistOptions ( ) ; } $ objJwtManager = null ; if ( $ objRequest = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ) { $ objJwtManager = $ objRequest -> attributes -> get ( JwtManager :: ATTRIBUTE ) ; } $ blnCanSwitchUser = ( $ this -> User -> isAdmin || ( ! empty ( $ this -> User -> amg ) && \ is_array ( $ this -> User -> amg ) ) ) ; $ objTokenChecker = System :: getContainer ( ) -> get ( 'contao.security.token_checker' ) ; $ strUser = $ objTokenChecker -> getFrontendUsername ( ) ; $ blnShowUnpublished = $ objTokenChecker -> isPreviewMode ( ) ; $ blnDebug = System :: getContainer ( ) -> get ( 'kernel' ) -> isDebug ( ) ; $ blnUpdate = false ; 
protected function getDatalistOptions ( ) { $ strGroups = '' ; if ( ! $ this -> User -> isAdmin ) { 
public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } 
public function showDeletedRecords ( $ data , $ row ) { $ arrData = Contao \ StringUtil :: deserialize ( $ row [ 'data' ] ) ; foreach ( $ arrData as $ strTable => $ arrTableData ) { Contao \ System :: loadLanguageFile ( $ strTable ) ; Contao \ Controller :: loadDataContainer ( $ strTable ) ; foreach ( $ arrTableData as $ arrRow ) { $ arrBuffer = array ( ) ; foreach ( $ arrRow as $ i => $ v ) { if ( \ is_array ( Contao \ StringUtil :: deserialize ( $ v ) ) ) { continue ; } 
public function onGeneratePage ( PageModel $ pageModel , LayoutModel $ layoutModel ) : void { $ calendarfeeds = StringUtil :: deserialize ( $ layoutModel -> calendarfeeds ) ; if ( empty ( $ calendarfeeds ) || ! \ is_array ( $ calendarfeeds ) ) { return ; } $ this -> framework -> initialize ( ) ; $ adapter = $ this -> framework -> getAdapter ( CalendarFeedModel :: class ) ; if ( ! ( $ feeds = $ adapter -> findByIds ( $ calendarfeeds ) ) instanceof Collection ) { return ; } $ template = $ this -> framework -> getAdapter ( Template :: class ) ; $ environment = $ this -> framework -> getAdapter ( Environment :: class ) ; foreach ( $ feeds as $ feed ) { $ GLOBALS [ 'TL_HEAD' ] [ ] = $ template -> generateFeedTag ( sprintf ( '%sshare/%s.xml' , ( $ feed -> feedBase ? : $ environment -> get ( 'base' ) ) , $ feed -> alias ) , $ feed -> format , $ feed -> title ) ; } } 
public function generate ( $ blnNoMarkup = false ) { if ( TL_MODE == 'FE' && ! BE_USER_LOGGED_IN && ( ! $ this -> published || ( $ this -> start != '' && $ this -> start > time ( ) ) || ( $ this -> stop != '' && $ this -> stop < time ( ) ) ) ) { return '' ; } $ this -> type = 'article' ; $ this -> blnNoMarkup = $ blnNoMarkup ; 
protected function compile ( ) { global $ objPage ; $ id = 'article-' . $ this -> id ; 
public function generatePdf ( ) { $ this -> headline = $ this -> title ; $ this -> printable = false ; 
public function getBundles ( ParserInterface $ parser ) { $ configs = [ BundleConfig :: create ( FrameworkBundle :: class ) , BundleConfig :: create ( SecurityBundle :: class ) , BundleConfig :: create ( TwigBundle :: class ) , BundleConfig :: create ( MonologBundle :: class ) , BundleConfig :: create ( SwiftmailerBundle :: class ) , BundleConfig :: create ( DoctrineBundle :: class ) , BundleConfig :: create ( DoctrineCacheBundle :: class ) , BundleConfig :: create ( LexikMaintenanceBundle :: class ) , BundleConfig :: create ( NelmioCorsBundle :: class ) , BundleConfig :: create ( NelmioSecurityBundle :: class ) , BundleConfig :: create ( FOSHttpCacheBundle :: class ) , BundleConfig :: create ( ContaoManagerBundle :: class ) , BundleConfig :: create ( DebugBundle :: class ) -> setLoadInProduction ( false ) , BundleConfig :: create ( WebProfilerBundle :: class ) -> setLoadInProduction ( false ) , ] ; 
public function registerContainerConfiguration ( LoaderInterface $ loader , array $ managerConfig ) : void { $ loader -> load ( static function ( ContainerBuilder $ container ) use ( $ loader ) : void { if ( 'dev' === $ container -> getParameter ( 'kernel.environment' ) ) { $ loader -> load ( '@ContaoManagerBundle/Resources/skeleton/app/config_dev.yml' ) ; } else { $ loader -> load ( '@ContaoManagerBundle/Resources/skeleton/app/config_prod.yml' ) ; } $ container -> setParameter ( 'container.autowiring.strict_mode' , true ) ; $ container -> setParameter ( 'container.dumper.inline_class_loader' , true ) ; } ) ; } 
public function getRouteCollection ( LoaderResolverInterface $ resolver , KernelInterface $ kernel ) : ? RouteCollection { if ( 'dev' !== $ kernel -> getEnvironment ( ) ) { return null ; } $ collections = [ ] ; $ files = [ '_wdt' => '@WebProfilerBundle/Resources/config/routing/wdt.xml' , '_profiler' => '@WebProfilerBundle/Resources/config/routing/profiler.xml' , ] ; foreach ( $ files as $ prefix => $ file ) { $ collection = $ resolver -> resolve ( $ file ) -> load ( $ file ) ; $ collection -> addPrefix ( $ prefix ) ; $ collections [ ] = $ collection ; } $ collection = array_reduce ( $ collections , static function ( RouteCollection $ carry , RouteCollection $ item ) : RouteCollection { $ carry -> addCollection ( $ item ) ; return $ carry ; } , new RouteCollection ( ) ) ; 
public function getExtensionConfig ( $ extensionName , array $ extensionConfigs , PluginContainerBuilder $ container ) : array { switch ( $ extensionName ) { case 'contao' : return $ this -> handlePrependLocale ( $ extensionConfigs , $ container ) ; case 'doctrine' : return $ this -> addDefaultServerVersion ( $ extensionConfigs , $ container ) ; default : return $ extensionConfigs ; } } 
private function handlePrependLocale ( array $ extensionConfigs , ContainerBuilder $ container ) : array { if ( ! $ container -> hasParameter ( 'prepend_locale' ) ) { return $ extensionConfigs ; } foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'prepend_locale' ] ) ) { return $ extensionConfigs ; } } @ trigger_error ( 'Defining the "prepend_locale" parameter in the parameters.yml file has been deprecated and will no longer work in Contao 5.0. Define the "contao.prepend_locale" parameter in the config.yml file instead.' , E_USER_DEPRECATED ) ; $ extensionConfigs [ ] = [ 'prepend_locale' => '%prepend_locale%' , ] ; return $ extensionConfigs ; } 
private function addDefaultServerVersion ( array $ extensionConfigs , ContainerBuilder $ container ) : array { $ params = [ ] ; foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ) ) { $ params [ ] = $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ; } } if ( ! empty ( $ params ) ) { $ params = array_merge ( ... $ params ) ; } $ parameterBag = $ container -> getParameterBag ( ) ; foreach ( $ params as $ key => $ value ) { $ params [ $ key ] = $ parameterBag -> resolveValue ( $ value ) ; } 
public function process ( ContainerBuilder $ container ) : void { $ webDir = $ container -> getParameter ( 'contao.web_dir' ) ; $ managerPath = $ container -> getParameter ( 'contao_manager.manager_path' ) ; if ( null === $ managerPath ) { if ( is_file ( $ webDir . '/contao-manager.phar.php' ) ) { $ managerPath = 'contao-manager.phar.php' ; } } elseif ( ! is_file ( $ webDir . '/' . $ managerPath ) ) { throw new \ LogicException ( sprintf ( 'You have configured "contao_manager.manager_path" but the file "%s" does not exist' , $ webDir . '/' . $ managerPath ) ) ; } $ container -> setParameter ( 'contao_manager.manager_path' , $ managerPath ) ; } 
public static function getTemplate ( $ strTemplate ) { $ strTemplate = basename ( $ strTemplate ) ; 
public static function getTemplateGroup ( $ strPrefix ) { $ arrTemplates = array ( ) ; 
public static function getFrontendModule ( $ intId , $ strColumn = 'main' ) { if ( ! \ is_object ( $ intId ) && ! \ strlen ( $ intId ) ) { return '' ; } global $ objPage ; 
public static function getArticle ( $ varId , $ blnMultiMode = false , $ blnIsInsertTag = false , $ strColumn = 'main' ) { global $ objPage ; if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( ! $ varId ) { return '' ; } $ objRow = ArticleModel :: findByIdOrAliasAndPid ( $ varId , ( ! $ blnIsInsertTag ? $ objPage -> id : null ) ) ; if ( $ objRow === null ) { return false ; } } 
public static function getContentElement ( $ intId , $ strColumn = 'main' ) { if ( \ is_object ( $ intId ) ) { $ objRow = $ intId ; } else { if ( ! \ strlen ( $ intId ) || $ intId < 1 ) { return '' ; } $ objRow = ContentModel :: findByPk ( $ intId ) ; if ( $ objRow === null ) { return '' ; } } 
public static function getForm ( $ varId , $ strColumn = 'main' , $ blnModule = false ) { if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( $ varId == '' ) { return '' ; } $ objRow = FormModel :: findByIdOrAlias ( $ varId ) ; if ( $ objRow === null ) { return '' ; } } $ strClass = $ blnModule ? Module :: findClass ( 'form' ) : ContentElement :: findClass ( 'form' ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Form class "' . $ strClass . '" does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = $ blnModule ? 'mod_' : 'ce_' ; $ objRow -> form = $ objRow -> id ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; 
protected function getSpellcheckerString ( ) { System :: loadLanguageFile ( 'languages' ) ; $ return = array ( ) ; $ langs = scan ( __DIR__ . '/../../languages' ) ; array_unshift ( $ langs , $ GLOBALS [ 'TL_LANGUAGE' ] ) ; foreach ( $ langs as $ lang ) { $ lang = substr ( $ lang , 0 , 2 ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] ) ) { $ return [ $ lang ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] . '=' . $ lang ; } } return '+' . implode ( ',' , array_unique ( $ return ) ) ; } 
public static function getPageStatusIcon ( $ objPage ) { $ sub = 0 ; $ image = $ objPage -> type . '.svg' ; 
public static function isVisibleElement ( Model $ objElement ) { $ blnReturn = true ; 
public static function replaceInsertTags ( $ strBuffer , $ blnCache = true ) { $ objIt = new InsertTags ( ) ; return $ objIt -> replace ( $ strBuffer , $ blnCache ) ; } 
public static function replaceDynamicScriptTags ( $ strBuffer ) { <script> (function(win) { if (!win.parent || typeof(win.parent.postMessage) !== 'function') { return; } win.parent.postMessage({ 'contao.preview': { 'title': win.document.title, 'uri': win.location.href }}, win.location.origin); })(window); </script>" ; } global $ objPage ; $ objLayout = LayoutModel :: findByPk ( $ objPage -> layoutId ) ; $ blnCombineScripts = ( $ objLayout === null ) ? false : $ objLayout -> combineScripts ; $ arrReplace [ '[[TL_BODY]]' ] = $ strScripts ; $ strScripts = '' ; $ objCombiner = new Combiner ( ) ; 
public static function generateMargin ( $ arrValues , $ strType = 'margin' ) { 
public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ query = new Query ( Environment :: get ( 'queryString' ) ) ; 
public static function redirect ( $ strLocation , $ intStatus = 303 ) { $ strLocation = str_replace ( '&amp;' , '&' , $ strLocation ) ; $ strLocation = static :: replaceOldBePaths ( $ strLocation ) ; 
protected static function replaceOldBePaths ( $ strContext ) { $ router = System :: getContainer ( ) -> get ( 'router' ) ; $ generate = function ( $ route ) use ( $ router ) { return substr ( $ router -> generate ( $ route ) , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; } ; $ arrMapper = array ( 'contao/confirm.php' => $ generate ( 'contao_backend_confirm' ) , 'contao/file.php' => $ generate ( 'contao_backend_file' ) , 'contao/help.php' => $ generate ( 'contao_backend_help' ) , 'contao/index.php' => $ generate ( 'contao_backend_login' ) , 'contao/main.php' => $ generate ( 'contao_backend' ) , 'contao/page.php' => $ generate ( 'contao_backend_page' ) , 'contao/password.php' => $ generate ( 'contao_backend_password' ) , 'contao/popup.php' => $ generate ( 'contao_backend_popup' ) , 'contao/preview.php' => $ generate ( 'contao_backend_preview' ) , 'contao/switch.php' => $ generate ( 'contao_backend_switch' ) ) ; return str_replace ( array_keys ( $ arrMapper ) , $ arrMapper , $ strContext ) ; } 
public static function generateFrontendUrl ( array $ arrRow , $ strParams = null , $ strForceLang = null , $ blnFixDomain = false ) { @ trigger_error ( 'Using Controller::generateFrontendUrl() has been deprecated and will no longer work in Contao 5.0. Use the contao.routing.url_generator service or PageModel::getFrontendUrl() instead.' , E_USER_DEPRECATED ) ; if ( ! isset ( $ arrRow [ 'rootId' ] ) ) { $ row = PageModel :: findWithDetails ( $ arrRow [ 'id' ] ) ; $ arrRow [ 'rootId' ] = $ row -> rootId ; foreach ( array ( 'domain' , 'rootLanguage' , 'rootUseSSL' ) as $ key ) { if ( ! isset ( $ arrRow [ $ key ] ) ) { $ arrRow [ $ key ] = $ row -> $ key ; } } } $ arrParams = array ( ) ; 
public static function convertRelativeUrls ( $ strContent , $ strBase = '' , $ blnHrefOnly = false ) { if ( $ strBase == '' ) { $ strBase = Environment :: get ( 'base' ) ; } $ search = $ blnHrefOnly ? 'href' : 'href|src' ; $ arrUrls = preg_split ( '/((' . $ search . ')="([^"]+)")/i' , $ strContent , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; $ strContent = '' ; for ( $ i = 0 , $ c = \ count ( $ arrUrls ) ; $ i < $ c ; $ i += 4 ) { $ strContent .= $ arrUrls [ $ i ] ; if ( ! isset ( $ arrUrls [ $ i + 2 ] ) ) { continue ; } $ strAttribute = $ arrUrls [ $ i + 2 ] ; $ strUrl = $ arrUrls [ $ i + 3 ] ; if ( ! preg_match ( '@^(?:[a-z0-9]+:|#)@i' , $ strUrl ) ) { $ strUrl = $ strBase . ( ( $ strUrl != '/' ) ? $ strUrl : '' ) ; } $ strContent .= $ strAttribute . '="' . $ strUrl . '"' ; } return $ strContent ; } 
public static function sendFileToBrowser ( $ strFile , $ inline = false ) { 
public static function loadDataContainer ( $ strTable , $ blnNoCache = false ) { $ loader = new DcaLoader ( $ strTable ) ; $ loader -> load ( $ blnNoCache ) ; } 
protected function redirectToFrontendPage ( $ intPage , $ strArticle = null , $ blnReturn = false ) { if ( ( $ intPage = ( int ) $ intPage ) <= 0 ) { return '' ; } $ objPage = PageModel :: findWithDetails ( $ intPage ) ; if ( $ objPage === null ) { return '' ; } $ strParams = null ; 
protected function getParentEntries ( $ strTable , $ intId ) { 
protected function eliminateNestedPaths ( $ arrPaths ) { $ arrPaths = array_filter ( $ arrPaths ) ; if ( empty ( $ arrPaths ) || ! \ is_array ( $ arrPaths ) ) { return array ( ) ; } $ nested = array ( ) ; foreach ( $ arrPaths as $ path ) { $ nested [ ] = preg_grep ( '/^' . preg_quote ( $ path , '/' ) . '\/.+/' , $ arrPaths ) ; } if ( ! empty ( $ nested ) ) { $ nested = array_merge ( ... $ nested ) ; } return array_values ( array_diff ( $ arrPaths , $ nested ) ) ; } 
protected function eliminateNestedPages ( $ arrPages , $ strTable = null , $ blnSorting = false ) { if ( empty ( $ arrPages ) || ! \ is_array ( $ arrPages ) ) { return array ( ) ; } if ( ! $ strTable ) { $ strTable = 'tl_page' ; } 
public static function addImageToTemplate ( $ objTemplate , $ arrItem , $ intMaxWidth = null , $ strLightboxId = null , FilesModel $ objModel = null ) { try { $ objFile = new File ( $ arrItem [ 'singleSRC' ] ) ; } catch ( \ Exception $ e ) { $ objFile = null ; } $ imgSize = $ objFile ? $ objFile -> imageSize : false ; $ size = StringUtil :: deserialize ( $ arrItem [ 'size' ] ) ; if ( is_numeric ( $ size ) ) { $ size = array ( 0 , 0 , ( int ) $ size ) ; } elseif ( ! $ size instanceof PictureConfigurationInterface ) { if ( ! \ is_array ( $ size ) ) { $ size = array ( ) ; } $ size += array ( 0 , 0 , 'crop' ) ; } if ( $ intMaxWidth === null ) { $ intMaxWidth = Config :: get ( 'maxImageWidth' ) ; } $ arrMargin = ( TL_MODE == 'BE' ) ? array ( ) : StringUtil :: deserialize ( $ arrItem [ 'imagemargin' ] ) ; 
public static function addEnclosuresToTemplate ( $ objTemplate , $ arrItem , $ strKey = 'enclosure' ) { $ arrEnclosures = StringUtil :: deserialize ( $ arrItem [ $ strKey ] ) ; if ( empty ( $ arrEnclosures ) || ! \ is_array ( $ arrEnclosures ) ) { return ; } $ objFiles = FilesModel :: findMultipleByUuids ( $ arrEnclosures ) ; if ( $ objFiles === null ) { return ; } $ file = Input :: get ( 'file' , true ) ; 
public static function setStaticUrls ( ) { if ( \ defined ( 'TL_FILES_URL' ) ) { return ; } if ( \ func_num_args ( ) > 0 ) { @ trigger_error ( 'Using Controller::setStaticUrls() has been deprecated and will no longer work in Contao 5.0. Use the asset contexts instead.' , E_USER_DEPRECATED ) ; if ( ! isset ( $ GLOBALS [ 'objPage' ] ) ) { $ GLOBALS [ 'objPage' ] = func_get_arg ( 0 ) ; } } \ define ( 'TL_ASSETS_URL' , System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) ) ; \ define ( 'TL_FILES_URL' , System :: getContainer ( ) -> get ( 'contao.assets.files_context' ) -> getStaticUrl ( ) ) ; 
public static function addStaticUrlTo ( $ script , ContaoContext $ context = null ) { 
public static function getPageDetails ( $ intId ) { @ trigger_error ( 'Using Controller::getPageDetails() has been deprecated and will no longer work in Contao 5.0. Use PageModel::findWithDetails() or PageModel->loadDetails() instead.' , E_USER_DEPRECATED ) ; if ( $ intId instanceof PageModel ) { return $ intId -> loadDetails ( ) ; } elseif ( $ intId instanceof Collection ) { $ objPage = $ intId -> current ( ) ; return $ objPage -> loadDetails ( ) ; } elseif ( \ is_object ( $ intId ) ) { $ strKey = __METHOD__ . '-' . $ intId -> id ; 
protected function removeOldFeeds ( $ blnReturn = false ) { @ trigger_error ( 'Using Controller::removeOldFeeds() has been deprecated and will no longer work in Contao 5.0. Use Automator::purgeXmlFiles() instead.' , E_USER_DEPRECATED ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> purgeXmlFiles ( $ blnReturn ) ; } 
protected function resizeImage ( $ image , $ width , $ height , $ mode = '' ) { @ trigger_error ( 'Using Controller::resizeImage() has been deprecated and will no longer work in Contao 5.0. Use Image::resize() instead.' , E_USER_DEPRECATED ) ; return Image :: resize ( $ image , $ width , $ height , $ mode ) ; } 
protected function getImage ( $ image , $ width , $ height , $ mode = '' , $ target = null , $ force = false ) { @ trigger_error ( 'Using Controller::getImage() has been deprecated and will no longer work in Contao 5.0. Use Image::get() instead.' , E_USER_DEPRECATED ) ; return Image :: get ( $ image , $ width , $ height , $ mode , $ target , $ force ) ; } 
public static function generateImage ( $ src , $ alt = '' , $ attributes = '' ) { @ trigger_error ( 'Using Controller::generateImage() has been deprecated and will no longer work in Contao 5.0. Use Image::getHtml() instead.' , E_USER_DEPRECATED ) ; return Image :: getHtml ( $ src , $ alt , $ attributes ) ; } 
protected function prepareForWidget ( $ arrData , $ strName , $ varValue = null , $ strField = '' , $ strTable = '' ) { @ trigger_error ( 'Using Controller::prepareForWidget() has been deprecated and will no longer work in Contao 5.0. Use Widget::getAttributesFromDca() instead.' , E_USER_DEPRECATED ) ; return Widget :: getAttributesFromDca ( $ arrData , $ strName , $ varValue , $ strField , $ strTable ) ; } 
protected function getChildRecords ( $ arrParentIds , $ strTable , $ blnSorting = false , $ arrReturn = array ( ) , $ strWhere = '' ) { @ trigger_error ( 'Using Controller::getChildRecords() has been deprecated and will no longer work in Contao 5.0. Use Database::getChildRecords() instead.' , E_USER_DEPRECATED ) ; return $ this -> Database -> getChildRecords ( $ arrParentIds , $ strTable , $ blnSorting , $ arrReturn , $ strWhere ) ; } 
protected function getParentRecords ( $ intId , $ strTable ) { @ trigger_error ( 'Using Controller::getParentRecords() has been deprecated and will no longer work in Contao 5.0. Use Database::getParentRecords() instead.' , E_USER_DEPRECATED ) ; return $ this -> Database -> getParentRecords ( $ intId , $ strTable ) ; } 
protected function createInitialVersion ( $ strTable , $ intId ) { @ trigger_error ( 'Using Controller::createInitialVersion() has been deprecated and will no longer work in Contao 5.0. Use Versions->initialize() instead.' , E_USER_DEPRECATED ) ; $ objVersions = new Versions ( $ strTable , $ intId ) ; $ objVersions -> initialize ( ) ; } 
protected function createNewVersion ( $ strTable , $ intId ) { @ trigger_error ( 'Using Controller::createNewVersion() has been deprecated and will no longer work in Contao 5.0. Use Versions->create() instead.' , E_USER_DEPRECATED ) ; $ objVersions = new Versions ( $ strTable , $ intId ) ; $ objVersions -> create ( ) ; } 
protected static function braceGlob ( $ pattern ) { 
public static function getInstance ( array $ arrCustomConfig = null ) { $ arrConfig = array ( ) ; if ( \ is_array ( $ arrCustomConfig ) ) { $ arrDefaultConfig = array ( 'dbHost' => Config :: get ( 'dbHost' ) , 'dbPort' => Config :: get ( 'dbPort' ) , 'dbUser' => Config :: get ( 'dbUser' ) , 'dbPass' => Config :: get ( 'dbPass' ) , 'dbDatabase' => Config :: get ( 'dbDatabase' ) ) ; $ arrConfig = array_merge ( $ arrDefaultConfig , $ arrCustomConfig ) ; } 
public function prepare ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> prepare ( $ strQuery ) ; } 
public function query ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> query ( $ strQuery ) ; } 
public function findInSet ( $ strKey , $ varSet , $ blnIsField = false ) { if ( \ is_array ( $ varSet ) ) { $ varSet = implode ( ',' , $ varSet ) ; } if ( $ blnIsField ) { $ varSet = static :: quoteIdentifier ( $ varSet ) ; } else { $ varSet = $ this -> resConnection -> quote ( $ varSet ) ; } return "FIND_IN_SET(" . static :: quoteIdentifier ( $ strKey ) . ", " . $ varSet . ")" ; } 
public function listTables ( $ strDatabase = null , $ blnNoCache = false ) { if ( $ blnNoCache || ! isset ( $ this -> arrCache [ $ strDatabase ] ) ) { $ strOldDatabase = $ this -> resConnection -> getDatabase ( ) ; 
public function tableExists ( $ strTable , $ strDatabase = null , $ blnNoCache = false ) { if ( $ strTable == '' ) { return false ; } return \ in_array ( $ strTable , $ this -> listTables ( $ strDatabase , $ blnNoCache ) ) ; } 
public function listFields ( $ strTable , $ blnNoCache = false ) { if ( $ blnNoCache || ! isset ( $ this -> arrCache [ $ strTable ] ) ) { $ arrReturn = array ( ) ; $ objFields = $ this -> query ( "SHOW FULL COLUMNS FROM $strTable" ) ; while ( $ objFields -> next ( ) ) { $ arrTmp = array ( ) ; $ arrChunks = preg_split ( '/(\([^\)]+\))/' , $ objFields -> Type , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ arrTmp [ 'name' ] = $ objFields -> Field ; $ arrTmp [ 'type' ] = $ arrChunks [ 0 ] ; if ( ! empty ( $ arrChunks [ 1 ] ) ) { $ arrChunks [ 1 ] = str_replace ( array ( '(' , ')' ) , '' , $ arrChunks [ 1 ] ) ; 
public function fieldExists ( $ strField , $ strTable , $ blnNoCache = false ) { if ( $ strField == '' || $ strTable == '' ) { return false ; } foreach ( $ this -> listFields ( $ strTable , $ blnNoCache ) as $ arrField ) { if ( $ arrField [ 'name' ] == $ strField && $ arrField [ 'type' ] != 'index' ) { return true ; } } return false ; } 
public function indexExists ( $ strName , $ strTable , $ blnNoCache = false ) { if ( $ strName == '' || $ strTable == '' ) { return false ; } foreach ( $ this -> listFields ( $ strTable , $ blnNoCache ) as $ arrField ) { if ( $ arrField [ 'name' ] == $ strName && $ arrField [ 'type' ] == 'index' ) { return true ; } } return false ; } 
public function getFieldNames ( $ strTable , $ blnNoCache = false ) { $ arrNames = array ( ) ; $ arrFields = $ this -> listFields ( $ strTable , $ blnNoCache ) ; foreach ( $ arrFields as $ arrField ) { if ( $ arrField [ 'type' ] != 'index' ) { $ arrNames [ ] = $ arrField [ 'name' ] ; } } return $ arrNames ; } 
public function isUniqueValue ( $ strTable , $ strField , $ varValue , $ intId = null ) { $ strQuery = "SELECT * FROM $strTable WHERE " . static :: quoteIdentifier ( $ strField ) . "=?" ; if ( $ intId !== null ) { $ strQuery .= " AND id!=?" ; } $ objUnique = $ this -> prepare ( $ strQuery ) -> limit ( 1 ) -> execute ( $ varValue , $ intId ) ; return $ objUnique -> numRows ? false : true ; } 
public function getChildRecords ( $ arrParentIds , $ strTable , $ blnSorting = false , $ arrReturn = array ( ) , $ strWhere = '' ) { if ( ! \ is_array ( $ arrParentIds ) ) { $ arrParentIds = array ( $ arrParentIds ) ; } if ( empty ( $ arrParentIds ) ) { return $ arrReturn ; } $ arrParentIds = array_map ( '\intval' , $ arrParentIds ) ; $ objChilds = $ this -> query ( "SELECT id, pid FROM " . $ strTable . " WHERE pid IN(" . implode ( ',' , $ arrParentIds ) . ")" . ( $ strWhere ? " AND $strWhere" : "" ) . ( $ blnSorting ? " ORDER BY " . $ this -> findInSet ( 'pid' , $ arrParentIds ) . ", sorting" : "" ) ) ; if ( $ objChilds -> numRows > 0 ) { if ( $ blnSorting ) { $ arrChilds = array ( ) ; $ arrOrdered = array ( ) ; while ( $ objChilds -> next ( ) ) { $ arrChilds [ ] = $ objChilds -> id ; $ arrOrdered [ $ objChilds -> pid ] [ ] = $ objChilds -> id ; } foreach ( array_reverse ( array_keys ( $ arrOrdered ) ) as $ pid ) { $ pos = ( int ) array_search ( $ pid , $ arrReturn ) ; array_insert ( $ arrReturn , $ pos + 1 , $ arrOrdered [ $ pid ] ) ; } $ arrReturn = $ this -> getChildRecords ( $ arrChilds , $ strTable , $ blnSorting , $ arrReturn , $ strWhere ) ; } else { $ arrChilds = $ objChilds -> fetchEach ( 'id' ) ; $ arrReturn = array_merge ( $ arrChilds , $ this -> getChildRecords ( $ arrChilds , $ strTable , $ blnSorting , $ arrReturn , $ strWhere ) ) ; } } return $ arrReturn ; } 
public function getParentRecords ( $ intId , $ strTable ) { $ arrReturn = array ( ) ; 
public function lockTables ( $ arrTables ) { $ arrLocks = array ( ) ; foreach ( $ arrTables as $ table => $ mode ) { $ arrLocks [ ] = $ this -> resConnection -> quoteIdentifier ( $ table ) . ' ' . $ mode ; } $ this -> resConnection -> exec ( 'LOCK TABLES ' . implode ( ', ' , $ arrLocks ) . ';' ) ; } 
public function getSizeOf ( $ strTable ) { $ statement = $ this -> resConnection -> executeQuery ( 'SHOW TABLE STATUS LIKE ' . $ this -> resConnection -> quote ( $ strTable ) ) ; $ status = $ statement -> fetch ( \ PDO :: FETCH_ASSOC ) ; return $ status [ 'Data_length' ] + $ status [ 'Index_length' ] ; } 
public function getUuid ( ) { static $ ids ; if ( empty ( $ ids ) ) { $ statement = $ this -> resConnection -> executeQuery ( implode ( ' UNION ALL ' , array_fill ( 0 , 10 , "SELECT UNHEX(REPLACE(UUID(), '-', '')) AS uuid" ) ) ) ; $ ids = $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; } return array_pop ( $ ids ) ; } 
public static function quoteIdentifier ( $ strName ) { static $ strQuoteCharacter = null ; if ( $ strQuoteCharacter === null ) { $ strQuoteCharacter = System :: getContainer ( ) -> get ( 'database_connection' ) -> getDatabasePlatform ( ) -> getIdentifierQuoteCharacter ( ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : void { $ output -> write ( json_encode ( [ 'version' => Application :: VERSION , 'commands' => $ this -> getCommandNames ( ) , 'features' => $ this -> getFeatures ( ) , ] ) ) ; } 
public function generate ( ) { $ this -> text = StringUtil :: toHtml5 ( $ this -> text ) ; 
public function getModules ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'FE_MOD' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; } 
public function getEditableMemberProperties ( ) { $ return = array ( ) ; Contao \ System :: loadLanguageFile ( 'tl_member' ) ; $ this -> loadDataContainer ( 'tl_member' ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] as $ k => $ v ) { if ( $ v [ 'eval' ] [ 'feEditable' ] ) { $ return [ $ k ] = $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ; } } return $ return ; } 
public function getLayoutSections ( ) { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; 
public function getActivationDefault ( $ varValue ) { if ( ! trim ( $ varValue ) ) { $ varValue = ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] [ 1 ] : $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ; } return $ varValue ; } 
public function getPasswordDefault ( $ varValue ) { if ( ! trim ( $ varValue ) ) { $ varValue = ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] [ 1 ] : $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] ) ; } return $ varValue ; } 
public function setMultiSrcFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> type == 'randomImage' ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'isGallery' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'extensions' ] = Contao \ Config :: get ( 'validImageTypes' ) ; } return $ varValue ; } 
public function setPagesFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> type == 'search' ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'mandatory' ] = false ; unset ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'orderField' ] ) ; } return $ varValue ; } 
public static function get ( $ strKey ) { if ( isset ( static :: $ arrCache [ $ strKey ] ) ) { return static :: $ arrCache [ $ strKey ] ; } if ( \ in_array ( $ strKey , get_class_methods ( __CLASS__ ) ) ) { static :: $ arrCache [ $ strKey ] = static :: $ strKey ( ) ; } else { $ arrChunks = preg_split ( '/([A-Z][a-z]*)/' , $ strKey , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ strServerKey = strtoupper ( implode ( '_' , $ arrChunks ) ) ; static :: $ arrCache [ $ strKey ] = $ _SERVER [ $ strServerKey ] ; } return static :: $ arrCache [ $ strKey ] ; } 
protected static function scriptFilename ( ) { return str_replace ( '//' , '/' , strtr ( ( static :: $ strSapi == 'cgi' || static :: $ strSapi == 'isapi' || static :: $ strSapi == 'cgi-fcgi' || static :: $ strSapi == 'fpm-fcgi' ) && ( @ $ _SERVER [ 'ORIG_PATH_TRANSLATED' ] ? : $ _SERVER [ 'PATH_TRANSLATED' ] ) ? ( @ $ _SERVER [ 'ORIG_PATH_TRANSLATED' ] ? : $ _SERVER [ 'PATH_TRANSLATED' ] ) : ( @ $ _SERVER [ 'ORIG_SCRIPT_FILENAME' ] ? : $ _SERVER [ 'SCRIPT_FILENAME' ] ) , '\\' , '/' ) ) ; } 
protected static function scriptName ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return @ $ _SERVER [ 'ORIG_SCRIPT_NAME' ] ? : $ _SERVER [ 'SCRIPT_NAME' ] ; } return $ request -> getScriptName ( ) ; } 
protected static function documentRoot ( ) { $ strDocumentRoot = '' ; $ arrUriSegments = array ( ) ; $ scriptName = static :: get ( 'scriptName' ) ; $ scriptFilename = static :: get ( 'scriptFilename' ) ; 
protected static function requestUri ( ) { if ( ! empty ( $ _SERVER [ 'REQUEST_URI' ] ) ) { $ arrComponents = parse_url ( $ _SERVER [ 'REQUEST_URI' ] ) ; $ strRequest = $ arrComponents [ 'path' ] . ( isset ( $ arrComponents [ 'query' ] ) ? '?' . $ arrComponents [ 'query' ] : '' ) ; } else { $ strRequest = '/' . preg_replace ( '/^\//' , '' , static :: get ( 'scriptName' ) ) . ( ! empty ( $ _SERVER [ 'QUERY_STRING' ] ) ? '?' . $ _SERVER [ 'QUERY_STRING' ] : '' ) ; } return static :: encodeRequestString ( $ strRequest ) ; } 
protected static function httpAcceptLanguage ( ) { $ arrAccepted = array ( ) ; $ arrLanguages = array ( ) ; 
protected static function httpHost ( ) { if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } else { $ host = $ _SERVER [ 'SERVER_NAME' ] ; if ( $ _SERVER [ 'SERVER_PORT' ] != 80 ) { $ host .= ':' . $ _SERVER [ 'SERVER_PORT' ] ; } } return preg_replace ( '/[^A-Za-z0-9[\].:-]/' , '' , $ host ) ; } 
protected static function ssl ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return false ; } return $ request -> isSecure ( ) ; } 
protected static function url ( ) { $ host = static :: get ( 'httpHost' ) ; $ xhost = static :: get ( 'httpXForwardedHost' ) ; 
protected static function ip ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return '' ; } return $ request -> getClientIp ( ) ; } 
protected static function server ( ) { $ strServer = ! empty ( $ _SERVER [ 'SERVER_ADDR' ] ) ? $ _SERVER [ 'SERVER_ADDR' ] : $ _SERVER [ 'LOCAL_ADDR' ] ; 
protected static function path ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return '' ; } return $ request -> getBasePath ( ) ; } 
protected static function agent ( ) { $ ua = static :: get ( 'httpUserAgent' ) ; $ return = new \ stdClass ( ) ; $ return -> string = $ ua ; $ os = 'unknown' ; $ mobile = false ; $ browser = 'other' ; $ shorty = '' ; $ version = '' ; $ engine = '' ; 
public static function findActiveByEmailAndUsername ( $ strEmail , $ strUsername = null , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "$t.email=? AND $t.login='1' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ) ; if ( $ strUsername !== null ) { $ arrColumns [ ] = "$t.username=?" ; } return static :: findOneBy ( $ arrColumns , array ( $ strEmail , $ strUsername ) , $ arrOptions ) ; } 
public static function findUnactivatedByEmail ( $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE email=? AND disable='1' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn>? AND o.confirmedOn=0)" ) -> limit ( 1 ) -> execute ( $ strEmail , strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objMember = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objMember ; } return new static ( $ objResult ) ; } 
public function run ( ) : void { UPDATE tl_page SET type = 'error_401' WHERE type = 'error_403' " ) ; // Adjust the search module settings (see contao/core-bundle#1462) $ this -> connection -> query ( " UPDATE tl_module SET pages = CONCAT('a:1:{i:0;i:', rootPage, ';}'), rootPage = 0 WHERE type = 'search' AND rootPage != 0 " ) ; // Activate the "overwriteLink" option (see contao/core-bundle#1459) $ this -> connection -> query ( " ALTER TABLE tl_content ADD overwriteLink CHAR(1) DEFAULT '' NOT NULL " ) ; $ this -> connection -> query ( " UPDATE tl_content SET overwriteLink = '1' WHERE linkTitle != '' OR titleText != '' " ) ; // Revert the incorrect version 2.8 update changes $ this -> connection -> query ( ' UPDATE tl_member SET currentLogin = 0 WHERE currentLogin > 0 AND currentLogin = dateAdded ' ) ; // Remove all activation tokens older than one day to prevent accidental // deletion of existing member accounts $ stmt = $ this -> connection -> prepare ( " UPDATE tl_member SET activation = '' WHERE activation != '' AND dateAdded < :dateAdded " ) ; $ stmt -> execute ( [ ':dateAdded' => strtotime ( '-1 day' ) ] ) ; // Update the video element settings (see contao/core-bundle#1348) $ this -> connection -> query ( ' ALTER TABLE tl_content ADD playerOptions text NULL ' ) ; $ this -> connection -> query ( ' ALTER TABLE tl_content ADD vimeoOptions text NULL ' ) ; $ statement = $ this -> connection -> query ( " SELECT id, type, youtubeOptions FROM tl_content WHERE autoplay = '1' " ) ; while ( false !== ( $ element = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) ) { switch ( $ element -> type ) { case 'player' : $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_content SET playerOptions = :options WHERE id = :id ' ) ; $ stmt -> execute ( [ ':options' => serialize ( [ 'player_autoplay' ] ) , ':id' => $ element -> id ] ) ; break ; case 'youtube' : $ options = StringUtil :: deserialize ( $ element -> youtubeOptions ) ; $ options [ ] = 'youtube_autoplay' ; $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_content SET youtubeOptions = :options WHERE id = :id ' ) ; $ stmt -> execute ( [ ':options' => serialize ( $ options ) , ':id' => $ element -> id ] ) ; break ; case 'vimeo' : $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_content SET vimeoOptions = :options WHERE id = :id ' ) ; $ stmt -> execute ( [ ':options' => serialize ( [ 'vimeo_autoplay' ] ) , ':id' => $ element -> id ] ) ; break ; } } $ this -> connection -> query ( ' ALTER TABLE tl_content ADD playerStart int(10) unsigned NOT NULL default 0 ' ) ; $ this -> connection -> query ( 'UPDATE tl_content SET playerStart = youtubeStart' ) ; $ this -> connection -> query ( ' ALTER TABLE tl_content ADD playerStop int(10) unsigned NOT NULL default 0 ' ) ; $ this -> connection -> query ( 'UPDATE tl_content SET playerStop = youtubeStop' ) ; } 
public function process ( ContainerBuilder $ container ) : void { if ( ! $ container -> hasDefinition ( 'contao.framework' ) ) { return ; } $ hooks = $ this -> getHooks ( $ container ) ; if ( empty ( $ hooks ) ) { return ; } 
protected function compile ( ) { 
protected function activateRecipient ( ) { $ this -> Template = new FrontendTemplate ( 'mod_newsletter' ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; 
protected function addRecipient ( $ strEmail , $ arrNew ) { 
public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; 
public function start ( Request $ request , AuthenticationException $ authException = null ) { if ( $ request -> query -> count ( ) < 1 ) { return $ this -> httpUtils -> createRedirectResponse ( $ request , 'contao_backend_login' ) ; } $ url = $ this -> router -> generate ( 'contao_backend_login' , [ 'referer' => base64_encode ( $ request -> getQueryString ( ) ) ] , UrlGeneratorInterface :: ABSOLUTE_URL ) ; return $ this -> httpUtils -> createRedirectResponse ( $ request , $ url ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : int { if ( file_exists ( $ this -> lockFile ) ) { $ output -> writeln ( '<comment>The install tool has been locked already.</comment>' ) ; return 1 ; } $ fs = new Filesystem ( ) ; $ fs -> dumpFile ( $ this -> lockFile , 3 ) ; $ output -> writeln ( '<info>The install tool has been locked.</info>' ) ; return 0 ; } 
public function run ( ) : void { $ this -> connection -> query ( ' ALTER TABLE tl_layout CHANGE sections sections blob NULL ' ) ; $ statement = $ this -> connection -> query ( " SELECT id, sections, sPosition FROM tl_layout WHERE sections != '' " ) ; while ( false !== ( $ layout = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) ) { $ sections = StringUtil :: trimsplit ( ',' , $ layout -> sections ) ; if ( ! empty ( $ sections ) && \ is_array ( $ sections ) ) { $ set = [ ] ; foreach ( $ sections as $ section ) { $ set [ $ section ] = [ 'title' => $ section , 'id' => $ section , 'template' => 'block_section' , 'position' => $ layout -> sPosition , ] ; } $ stmt = $ this -> connection -> prepare ( ' UPDATE tl_layout SET sections = :sections WHERE id = :id ' ) ; $ stmt -> execute ( [ ':sections' => serialize ( array_values ( $ set ) ) , ':id' => $ layout -> id ] ) ; } } $ this -> connection -> query ( " ALTER TABLE tl_layout ADD combineScripts char(1) NOT NULL default '' " ) ; $ this -> connection -> query ( " UPDATE tl_layout SET combineScripts = '1' " ) ; } 
protected function compile ( ) { global $ objPage ; $ arrJumpTo = array ( ) ; $ arrNewsletter = array ( ) ; $ strRequest = ampersand ( Environment :: get ( 'request' ) , true ) ; $ objNewsletter = NewsletterModel :: findSentByPids ( $ this -> nl_channels ) ; if ( $ objNewsletter !== null ) { while ( $ objNewsletter -> next ( ) ) { if ( ! ( $ objTarget = $ objNewsletter -> getRelated ( 'pid' ) ) instanceof NewsletterChannelModel ) { continue ; } $ jumpTo = ( int ) $ objTarget -> jumpTo ; 
public static function getTheme ( ) { $ theme = Config :: get ( 'backendTheme' ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( $ theme != '' && $ theme != 'flexible' && is_dir ( $ rootDir . '/system/themes/' . $ theme ) ) { return $ theme ; } return 'flexible' ; } 
public static function getThemes ( ) { $ arrReturn = array ( ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrThemes = scan ( $ rootDir . '/system/themes' ) ; foreach ( $ arrThemes as $ strTheme ) { if ( strncmp ( $ strTheme , '.' , 1 ) === 0 || ! is_dir ( $ rootDir . '/system/themes/' . $ strTheme ) ) { continue ; } $ arrReturn [ $ strTheme ] = $ strTheme ; } return $ arrReturn ; } 
public static function getTinyMceLanguage ( ) { $ lang = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( $ lang == '' ) { return 'en' ; } $ lang = str_replace ( '-' , '_' , $ lang ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; 
public static function getTinyTemplates ( ) { $ strDir = Config :: get ( 'uploadPath' ) . '/tiny_templates' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strDir ) ) { return '' ; } $ arrFiles = array ( ) ; $ arrTemplates = scan ( $ rootDir . '/' . $ strDir ) ; foreach ( $ arrTemplates as $ strFile ) { if ( strncmp ( '.' , $ strFile , 1 ) !== 0 && is_file ( $ rootDir . '/' . $ strDir . '/' . $ strFile ) ) { $ arrFiles [ ] = '{ title: "' . $ strFile . '", url: "' . $ strDir . '/' . $ strFile . '" }' ; } } return implode ( ",\n" , $ arrFiles ) . "\n" ; } 
public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { 
public static function handleRunOnce ( ) { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/runonce.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } foreach ( $ files as $ file ) { try { include $ file ; } catch ( \ Exception $ e ) { } $ strRelpath = StringUtil :: stripRootDir ( $ file ) ; if ( ! unlink ( $ file ) ) { throw new \ Exception ( "The file $strRelpath cannot be deleted. Please remove the file manually and correct the file permission settings on your server." ) ; } System :: log ( "File $strRelpath ran once and has then been removed successfully" , __METHOD__ , TL_GENERAL ) ; } } 
protected function getBackendModule ( $ module , PickerInterface $ picker = null ) { $ arrModule = array ( ) ; foreach ( $ GLOBALS [ 'BE_MOD' ] as & $ arrGroup ) { if ( isset ( $ arrGroup [ $ module ] ) ) { $ arrModule = & $ arrGroup [ $ module ] ; break ; } } unset ( $ arrGroup ) ; $ this -> import ( BackendUser :: class , 'User' ) ; $ blnAccess = ( isset ( $ arrModule [ 'disablePermissionChecks' ] ) && $ arrModule [ 'disablePermissionChecks' ] === true ) || $ this -> User -> hasAccess ( $ module , 'modules' ) ; 
public static function findSearchablePages ( $ pid = 0 , $ domain = '' , $ blnIsSitemap = false ) { $ objPages = PageModel :: findPublishedByPid ( $ pid , array ( 'ignoreFePreview' => true ) ) ; if ( $ objPages === null ) { return array ( ) ; } $ arrPages = array ( ) ; 
public static function addFileMetaInformationToRequest ( $ strUuid , $ strPtable , $ intPid ) { @ trigger_error ( 'Using Backend::addFileMetaInformationToRequest() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ objFile = FilesModel :: findByUuid ( $ strUuid ) ; if ( $ objFile === null ) { return ; } $ arrMeta = StringUtil :: deserialize ( $ objFile -> meta ) ; if ( empty ( $ arrMeta ) ) { return ; } $ objPage = null ; if ( $ strPtable == 'tl_article' ) { $ objPage = PageModel :: findOneBy ( array ( 'tl_page.id=(SELECT pid FROM tl_article WHERE id=?)' ) , $ intPid ) ; } else { 
public static function addPagesBreadcrumb ( $ strKey = 'tl_page_node' ) { $ objSession = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; <nav aria-label="' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'breadcrumbMenu' ] . '"> <ul id="tl_breadcrumb"> <li>' . implode ( ' › </li><li>', $ r rLinks) . ' /li> </ul> </nav>' ; } 
public static function addPageIcon ( $ row , $ label , DataContainer $ dc = null , $ imageAttribute = '' , $ blnReturnImage = false , $ blnProtected = false ) { if ( $ blnProtected ) { $ row [ 'protected' ] = true ; } $ image = Controller :: getPageStatusIcon ( ( object ) $ row ) ; $ imageAttribute = trim ( $ imageAttribute . ' data-icon="' . Controller :: getPageStatusIcon ( ( object ) array_merge ( $ row , array ( 'published' => '1' ) ) ) . '" data-icon-disabled="' . Controller :: getPageStatusIcon ( ( object ) array_merge ( $ row , array ( 'published' => '' ) ) ) . '"' ) ; 
public static function getSystemMessages ( ) { $ strMessages = '' ; 
public static function addFilesBreadcrumb ( $ strKey = 'tl_files_node' ) { $ objSession = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; <nav aria-label="' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'breadcrumbMenu' ] . '"> <ul id="tl_breadcrumb"> <li>' . implode ( ' › </li><li>', $ r rLinks) . ' /li> </ul> </nav>' ; } 
public static function convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) { $ arrSections = array_flip ( array_values ( array_unique ( $ arrSections ) ) ) ; foreach ( array_keys ( $ arrSections ) as $ k ) { $ arrSections [ $ k ] = $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ k ] ; } asort ( $ arrSections ) ; return $ arrSections ; } 
public static function getDcaPickerWizard ( $ extras , $ table , $ field , $ inputName ) { $ context = 'link' ; $ extras = \ is_array ( $ extras ) ? $ extras : array ( ) ; $ providers = ( isset ( $ extras [ 'providers' ] ) && \ is_array ( $ extras [ 'providers' ] ) ) ? $ extras [ 'providers' ] : null ; if ( isset ( $ extras [ 'context' ] ) ) { $ context = $ extras [ 'context' ] ; unset ( $ extras [ 'context' ] ) ; } $ factory = System :: getContainer ( ) -> get ( 'contao.picker.builder' ) ; if ( ! $ factory -> supportsContext ( $ context , $ providers ) ) { return '' ; } return ' <a href="' . ampersand ( $ factory -> getUrl ( $ context , $ extras ) ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'pagepicker' ] ) . '" id="pp_' . $ inputName . '">' . Image :: getHtml ( ( \ is_array ( $ extras ) && isset ( $ extras [ 'icon' ] ) ? $ extras [ 'icon' ] : 'pickpage.svg' ) , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'pagepicker' ] ) . '</a> <script> $("pp_' . $ inputName . '").addEvent("click", function(e) { e.preventDefault(); Backend.openModalSelector({ "id": "tl_listing", "title": ' . json_encode ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ field ] [ 'label' ] [ 0 ] ) . ', "url": this.href + "&value=" + document.getElementById("ctrl_' . $ inputName . '").value, "callback": function(picker, value) { $("ctrl_' . $ inputName . '").value = value.join(","); }.bind(this) }); }); </script>' ; } 
public function addCustomLayoutSectionReferences ( ) { $ objLayout = $ this -> Database -> getInstance ( ) -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = StringUtil :: deserialize ( $ objLayout -> sections ) ; 
public function createPageList ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( $ this -> User -> isAdmin ) { return $ this -> doCreatePageList ( ) ; } $ return = '' ; $ processed = array ( ) ; foreach ( $ this -> eliminateNestedPages ( $ this -> User -> pagemounts ) as $ page ) { $ objPage = PageModel :: findWithDetails ( $ page ) ; 
protected function doCreatePageList ( $ intId = 0 , $ level = - 1 ) { $ objPages = $ this -> Database -> prepare ( "SELECT id, title, type, dns FROM tl_page WHERE pid=? ORDER BY sorting" ) -> execute ( $ intId ) ; if ( $ objPages -> numRows < 1 ) { return '' ; } ++ $ level ; $ strOptions = '' ; while ( $ objPages -> next ( ) ) { if ( $ objPages -> type == 'root' ) { 
public function createFileList ( $ strFilter = '' , $ filemount = false ) { 
protected function doCreateFileList ( $ strFolder = null , $ level = - 1 , $ strFilter = '' ) { 
public function setImportantPart ( array $ importantPart = null ) { if ( $ importantPart !== null ) { if ( ! isset ( $ importantPart [ 'x' ] ) || ! isset ( $ importantPart [ 'y' ] ) || ! isset ( $ importantPart [ 'width' ] ) || ! isset ( $ importantPart [ 'height' ] ) ) { throw new \ InvalidArgumentException ( 'Malformed array for setting the important part!' ) ; } $ this -> importantPart = array ( 'x' => max ( 0 , min ( $ this -> fileObj -> viewWidth - 1 , ( int ) $ importantPart [ 'x' ] ) ) , 'y' => max ( 0 , min ( $ this -> fileObj -> viewHeight - 1 , ( int ) $ importantPart [ 'y' ] ) ) , ) ; $ this -> importantPart [ 'width' ] = max ( 1 , min ( $ this -> fileObj -> viewWidth - $ this -> importantPart [ 'x' ] , ( int ) $ importantPart [ 'width' ] ) ) ; $ this -> importantPart [ 'height' ] = max ( 1 , min ( $ this -> fileObj -> viewHeight - $ this -> importantPart [ 'y' ] , ( int ) $ importantPart [ 'height' ] ) ) ; } else { $ this -> importantPart = null ; } return $ this ; } 
public function getImportantPart ( ) { if ( $ this -> importantPart ) { return $ this -> importantPart ; } return array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight ) ; } 
public function setZoomLevel ( $ zoomLevel ) { $ zoomLevel = ( int ) $ zoomLevel ; if ( $ zoomLevel < 0 || $ zoomLevel > 100 ) { throw new \ InvalidArgumentException ( 'Zoom level must be between 0 and 100!' ) ; } $ this -> zoomLevel = $ zoomLevel ; return $ this ; } 
public function getResizedPath ( ) { $ path = $ this -> resizedPath ; $ webDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.web_dir' ) ) ; 
public function getCacheName ( ) { $ importantPart = $ this -> getImportantPart ( ) ; $ strCacheKey = substr ( md5 ( '-w' . $ this -> getTargetWidth ( ) . '-h' . $ this -> getTargetHeight ( ) . '-o' . $ this -> getOriginalPath ( ) . '-m' . $ this -> getResizeMode ( ) . '-z' . $ this -> getZoomLevel ( ) . '-x' . $ importantPart [ 'x' ] . '-y' . $ importantPart [ 'y' ] . '-i' . $ importantPart [ 'width' ] . '-e' . $ importantPart [ 'height' ] . '-t' . $ this -> fileObj -> mtime ) , 0 , 8 ) ; return StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.image.target_dir' ) ) . '/' . substr ( $ strCacheKey , - 1 ) . '/' . $ this -> fileObj -> filename . '-' . $ strCacheKey . '.' . $ this -> fileObj -> extension ; } 
public function executeResize ( ) { $ image = $ this -> prepareImage ( ) ; $ resizeConfig = $ this -> prepareResizeConfig ( ) ; if ( ! System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) && $ this -> getTargetPath ( ) && ! $ this -> getForceOverride ( ) && file_exists ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) && $ this -> fileObj -> mtime <= filemtime ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) ) { 
protected function prepareImage ( ) { if ( $ this -> fileObj -> isSvgImage ) { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine_svg' ) ; } else { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine' ) ; } $ image = new NewImage ( $ this -> strRootDir . '/' . $ this -> fileObj -> path , $ imagine , System :: getContainer ( ) -> get ( 'filesystem' ) ) ; $ image -> setImportantPart ( $ this -> prepareImportantPart ( ) ) ; return $ image ; } 
protected function prepareImportantPart ( ) { $ importantPart = $ this -> getImportantPart ( ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ importantPart = array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight , ) ; $ mode = explode ( '_' , $ this -> resizeMode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } } if ( ! $ importantPart [ 'width' ] || ! $ importantPart [ 'height' ] ) { return null ; } return new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ; } 
protected function prepareResizeConfig ( ) { $ resizeConfig = new ResizeConfiguration ( ) ; $ resizeConfig -> setWidth ( $ this -> targetWidth ) ; $ resizeConfig -> setHeight ( $ this -> targetHeight ) ; $ resizeConfig -> setZoomLevel ( $ this -> zoomLevel ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; $ resizeConfig -> setZoomLevel ( 0 ) ; } else { try { $ resizeConfig -> setMode ( $ this -> resizeMode ) ; } catch ( \ InvalidArgumentException $ exception ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; } } return $ resizeConfig ; } 
public function computeResize ( ) { $ resizeCoordinates = System :: getContainer ( ) -> get ( 'contao.image.resize_calculator' ) -> calculate ( $ this -> prepareResizeConfig ( ) , new ImageDimensions ( new Box ( $ this -> fileObj -> viewWidth , $ this -> fileObj -> viewHeight ) , $ this -> fileObj -> viewWidth !== $ this -> fileObj -> width ) , $ this -> prepareImportantPart ( ) ) ; return array ( 'width' => $ resizeCoordinates -> getCropSize ( ) -> getWidth ( ) , 'height' => $ resizeCoordinates -> getCropSize ( ) -> getHeight ( ) , 'target_x' => - $ resizeCoordinates -> getCropStart ( ) -> getX ( ) , 'target_y' => - $ resizeCoordinates -> getCropStart ( ) -> getY ( ) , 'target_width' => $ resizeCoordinates -> getSize ( ) -> getWidth ( ) , 'target_height' => $ resizeCoordinates -> getSize ( ) -> getHeight ( ) , ) ; } 
public static function getPath ( $ src ) { if ( $ src == '' ) { return '' ; } $ src = rawurldecode ( $ src ) ; if ( strpos ( $ src , '/' ) !== false ) { return $ src ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ src , 'icon' , 4 ) === 0 ) { if ( pathinfo ( $ src , PATHINFO_EXTENSION ) == 'svg' ) { return 'assets/contao/images/' . $ src ; } $ filename = pathinfo ( $ src , PATHINFO_FILENAME ) ; 
public static function getHtml ( $ src , $ alt = '' , $ attributes = '' ) { $ src = static :: getPath ( $ src ) ; if ( $ src == '' ) { return '' ; } $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( ! is_file ( $ rootDir . '/' . $ src ) ) { 
public static function resize ( $ image , $ width , $ height , $ mode = '' ) { @ trigger_error ( 'Using Image::resize() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; return static :: get ( $ image , $ width , $ height , $ mode , $ image , true ) ? true : false ; } 
public static function create ( $ image , $ size = null ) { @ trigger_error ( 'Using Image::create() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; if ( \ is_string ( $ image ) ) { $ image = new File ( rawurldecode ( $ image ) ) ; } $ imageObj = new static ( $ image ) ; 
public static function get ( $ image , $ width , $ height , $ mode = '' , $ target = null , $ force = false ) { @ trigger_error ( 'Using Image::get() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; if ( $ image == '' ) { return null ; } try { $ imageObj = static :: create ( $ image , array ( $ width , $ height , $ mode ) ) ; $ imageObj -> setTargetPath ( $ target ) ; $ imageObj -> setForceOverride ( $ force ) ; if ( $ path = $ imageObj -> executeResize ( ) -> getResizedPath ( ) ) { return $ path ; } } catch ( \ Exception $ e ) { System :: log ( 'Image "' . $ image . '" could not be processed: ' . $ e -> getMessage ( ) , __METHOD__ , 'ERROR' ) ; } return null ; } 
public static function getPixelValue ( $ size ) { @ trigger_error ( 'Using Image::getPixelValue() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ value = preg_replace ( '/[^0-9.-]+/' , '' , $ size ) ; $ unit = preg_replace ( '/[^acehimnprtvwx%]/' , '' , $ size ) ; 
public function run ( ) { $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; 
public static function get ( ) { $ container = System :: getContainer ( ) ; return $ container -> get ( 'contao.csrf.token_manager' ) -> getToken ( $ container -> getParameter ( 'contao.csrf_token_name' ) ) -> getValue ( ) ; } 
public static function validate ( $ strToken ) { 
public function __isset ( $ strKey ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } return isset ( $ this -> arrModels [ $ this -> intIndex ] -> $ strKey ) ; } 
public static function createFromDbResult ( Result $ objResult , $ strTable ) { $ arrModels = array ( ) ; $ strClass = Model :: getClassFromTable ( $ strTable ) ; while ( $ objResult -> next ( ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( $ strTable , $ objResult -> { $ strClass :: getPk ( ) } ) ; if ( $ objModel !== null ) { $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; $ arrModels [ ] = $ objModel ; } else { $ arrModels [ ] = new $ strClass ( $ objResult ) ; } } return new static ( $ arrModels , $ strTable ) ; } 
public function row ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } return $ this -> arrModels [ $ this -> intIndex ] -> row ( ) ; } 
public function setRow ( array $ arrData ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ this -> arrModels [ $ this -> intIndex ] -> setRow ( $ arrData ) ; return $ this ; } 
public function save ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ this -> arrModels [ $ this -> intIndex ] -> save ( ) ; return $ this ; } 
public function delete ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } return $ this -> arrModels [ $ this -> intIndex ] -> delete ( ) ; } 
public function getRelated ( $ strKey ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } return $ this -> arrModels [ $ this -> intIndex ] -> getRelated ( $ strKey ) ; } 
public function next ( ) { if ( ! isset ( $ this -> arrModels [ $ this -> intIndex + 1 ] ) ) { return false ; } ++ $ this -> intIndex ; return $ this ; } 
public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ return = array ( ) ; while ( $ this -> next ( ) ) { $ strPk = $ this -> current ( ) -> getPk ( ) ; if ( $ strKey != 'id' && isset ( $ this -> $ strPk ) ) { $ return [ $ this -> $ strPk ] = $ this -> $ strKey ; } else { $ return [ ] = $ this -> $ strKey ; } } return $ return ; } 
public function validator ( $ varInput ) { if ( ! \ is_array ( $ varInput ) ) { return null ; 
public function generate ( ) { $ count = 0 ; $ return = '' ; $ this -> import ( Database :: class , 'Database' ) ; $ this -> import ( BackendUser :: class , 'User' ) ; <li class="' . ( ( $ count % 2 == 0 ) ? 'even' : 'odd' ) . '" data-language="' . $ lang . '">' ; $ return .= '<span class="lang">' . ( $ languages [ $ lang ] ?? $ lang ) . ' ' . Image :: getHtml ( 'delete.svg' , '' , 'class="tl_metawizard_img" title="' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'delete' ] . '" onclick="Backend.metaDelete(this)"' ) . '</span>' ; // Take the fields from the DCA (see #4327) foreach ( $ this -> metaFields as $ field => $ fieldConfig ) { $ return .= '<label for="ctrl_' . $ field . '_' . $ count . '">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'aw_' . $ field ] . '</label> <input type="text" name="' . $ this -> strId . '[' . $ lang . '][' . $ field . ']" id="ctrl_' . $ field . '_' . $ count . '" class="tl_text" value="' . StringUtil :: specialchars ( $ meta [ $ field ] ) . '"' . ( ! empty ( $ fieldConfig [ 'attributes' ] ) ? ' ' . $ fieldConfig [ 'attributes' ] : '' ) . '>' ; // DCA picker if ( isset ( $ fieldConfig [ 'dcaPicker' ] ) && ( \ is_array ( $ fieldConfig [ 'dcaPicker' ] ) || $ fieldConfig [ 'dcaPicker' ] === true ) ) { $ return .= Backend :: getDcaPickerWizard ( $ fieldConfig [ 'dcaPicker' ] , $ this -> strTable , $ this -> strField , $ field . '_' . $ count ) ; } $ return .= '<br>' ; } $ return .= ' </li>' ; unset ( $ languages [ $ lang ] ) ; ++ $ count ; } $ return .= ' </ul>' ; } $ options = array ( '<option value="">-</option>' ) ; // Add the remaining languages foreach ( $ languages as $ k => $ v ) { $ options [ ] = '<option value="' . $ k . '">' . $ v . '</option>' ; } $ return .= ' <div class="tl_metawizard_new"> <select name="' . $ this -> strId . '[language]" class="tl_select tl_chosen" onchange="Backend.toggleAddLanguageButton(this)">' . implode ( '' , $ options ) . '</select> <input type="button" class="tl_submit" disabled value="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'aw_new' ] ) . '" onclick="Backend.metaWizard(this,\'ctrl_' . $ this -> strId . '\')"> </div>' ; return $ return ; } 
public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> tokenChecker -> hasBackendUser ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( $ this -> requestAttribute , true ) ; } 
public function run ( ) { $ objTemplate = new BackendTemplate ( 'be_maintenance_mode' ) ; $ objTemplate -> action = ampersand ( Environment :: get ( 'request' ) ) ; $ objTemplate -> headline = $ GLOBALS [ 'TL_LANG' ] [ 'tl_maintenance' ] [ 'maintenanceMode' ] ; $ objTemplate -> isActive = $ this -> isActive ( ) ; try { $ driver = System :: getContainer ( ) -> get ( 'lexik_maintenance.driver.factory' ) -> getDriver ( ) ; $ isLocked = $ driver -> isExists ( ) ; } catch ( \ Exception $ e ) { return '' ; } 
public function generate ( ) { $ arrButtons = array ( 'copy' , 'delete' , 'drag' ) ; <li><input type="text" name="' . $ this -> strId . '[]" class="tl_text" value="' . StringUtil :: specialchars ( $ this -> varValue [ $ i ] ) . '"' . $ this -> getAttributes ( ) . '> ' ; // Add buttons foreach ( $ arrButtons as $ button ) { if ( $ button == 'drag' ) { $ return .= ' <button type="button" class="drag-handle" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'move' ] ) . '" aria-hidden="true">' . Image :: getHtml ( 'drag.svg' ) . '</button>' ; } else { $ return .= ' <button type="button" data-command="' . $ button . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lw_' . $ button ] ) . '">' . Image :: getHtml ( $ button . '.svg' ) . '</button>' ; } } $ return .= '</li>' ; } return $ return . ' </ul> <script>Backend.listWizard("ctrl_' . $ this -> strId . '")</script>' ; } 
public function importList ( DataContainer $ dc ) { $ response = System :: getContainer ( ) -> get ( 'contao.controller.backend_csv_import' ) -> importListWizardAction ( $ dc ) ; if ( $ response instanceof RedirectResponse ) { throw new ResponseException ( $ response ) ; } return $ response -> getContent ( ) ; } 
public function onSwitchUser ( SwitchUserEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'The token storage did not contain a token.' ) ; } $ sourceUser = $ token -> getUser ( ) ; if ( $ sourceUser instanceof UserInterface ) { $ sourceUser = $ sourceUser -> getUsername ( ) ; } $ targetUser = $ event -> getTargetUser ( ) ; if ( $ targetUser instanceof UserInterface ) { $ targetUser = $ targetUser -> getUsername ( ) ; } $ this -> logger -> info ( sprintf ( 'User "%s" has switched to user "%s"' , $ sourceUser , $ targetUser ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ sourceUser ) ] ) ; } 
public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ this -> tokenStorage -> initialize ( $ this -> getTokensFromCookies ( $ event -> getRequest ( ) -> cookies ) ) ; } 
public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ response = $ event -> getResponse ( ) ; $ isSecure = $ request -> isSecure ( ) ; $ basePath = $ request -> getBasePath ( ) ? : '/' ; foreach ( $ this -> tokenStorage -> getUsedTokens ( ) as $ key => $ value ) { $ cookieKey = $ this -> cookiePrefix . $ key ; 
protected function getRouteParameters ( PickerConfig $ config = null ) : array { $ params = [ 'do' => 'news' ] ; if ( null === $ config || ! $ config -> getValue ( ) || false === strpos ( $ config -> getValue ( ) , '{{news_url::' ) ) { return $ params ; } $ value = str_replace ( [ '{{news_url::' , '}}' ] , '' , $ config -> getValue ( ) ) ; if ( null !== ( $ newsArchiveId = $ this -> getNewsArchiveId ( $ value ) ) ) { $ params [ 'table' ] = 'tl_news' ; $ params [ 'id' ] = $ newsArchiveId ; } return $ params ; } 
private function compileCommands ( ) : void { $ return = [ 'CREATE' => [ ] , 'ALTER_TABLE' => [ ] , 'ALTER_CHANGE' => [ ] , 'ALTER_ADD' => [ ] , 'DROP' => [ ] , 'ALTER_DROP' => [ ] , ] ; $ config = $ this -> connection -> getConfiguration ( ) ; 
private function checkEngineAndCollation ( array & $ sql , Schema $ fromSchema , Schema $ toSchema ) : void { $ tables = $ toSchema -> getTables ( ) ; $ dynamic = $ this -> hasDynamicRowFormat ( ) ; foreach ( $ tables as $ table ) { $ tableName = $ table -> getName ( ) ; $ alterTables = [ ] ; $ deleteIndexes = false ; if ( 0 !== strncmp ( $ tableName , 'tl_' , 3 ) ) { continue ; } $ this -> setLegacyOptions ( $ table ) ; $ tableOptions = $ this -> connection -> query ( "SHOW TABLE STATUS LIKE '" . $ tableName . "'" ) -> fetch ( \ PDO :: FETCH_OBJ ) ; 
private function setLegacyOptions ( Table $ table ) : void { if ( ! $ table -> hasOption ( 'engine' ) ) { $ table -> addOption ( 'engine' , 'MyISAM' ) ; } if ( ! $ table -> hasOption ( 'charset' ) ) { $ table -> addOption ( 'charset' , 'utf8' ) ; } if ( ! $ table -> hasOption ( 'collate' ) ) { $ table -> addOption ( 'collate' , 'utf8_general_ci' ) ; } } 
public function initialize ( ) { if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'enableVersioning' ] ) { return ; } $ objVersion = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_version WHERE fromTable=? AND pid=?" ) -> limit ( 1 ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> count > 0 ) { return ; } $ this -> create ( ) ; } 
public function create ( ) { if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'enableVersioning' ] ) { return ; } 
public function restore ( $ intVersion ) { if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'enableVersioning' ] ) { return ; } $ objData = $ this -> Database -> prepare ( "SELECT * FROM tl_version WHERE fromTable=? AND pid=? AND version=?" ) -> limit ( 1 ) -> execute ( $ this -> strTable , $ this -> intPid , $ intVersion ) ; if ( $ objData -> numRows < 1 ) { return ; } $ data = StringUtil :: deserialize ( $ objData -> data ) ; if ( ! \ is_array ( $ data ) ) { return ; } 
public function compare ( $ blnReturnBuffer = false ) { $ strBuffer = '' ; $ arrVersions = array ( ) ; $ intTo = 0 ; $ intFrom = 0 ; $ objVersions = $ this -> Database -> prepare ( "SELECT * FROM tl_version WHERE pid=? AND fromTable=? ORDER BY version DESC" ) -> execute ( $ this -> intPid , $ this -> strTable ) ; if ( $ objVersions -> numRows < 2 ) { $ strBuffer = '<p>There are no versions of ' . $ this -> strTable . '.id=' . $ this -> intPid . '</p>' ; } else { $ intIndex = 0 ; $ from = array ( ) ; 
public function renderDropdown ( ) { $ objVersion = $ this -> Database -> prepare ( "SELECT tstamp, version, username, active FROM tl_version WHERE fromTable=? AND pid=? ORDER BY version DESC" ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> numRows < 2 ) { return '' ; } $ versions = '' ; while ( $ objVersion -> next ( ) ) { $ versions .= ' <option value="' . $ objVersion -> version . '"' . ( $ objVersion -> active ? ' selected="selected"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] . ' ' . $ objVersion -> version . ' (' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ objVersion -> tstamp ) . ') ' . $ objVersion -> username . '</option>' ; } return ' <div class="tl_version_panel"> <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_version" class="tl_form" method="post" aria-label="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versioning' ] ) . '"> <div class="tl_formbody"> <input type="hidden" name="FORM_SUBMIT" value="tl_version"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"> <select name="version" class="tl_select">' . $ versions . ' </select> <button type="submit" name="showVersion" id="showVersion" class="tl_submit">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'restore' ] . '</button> <a href="' . Backend :: addToUrl ( 'versions=1&amp;popup=1' ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . StringUtil :: specialchars ( str_replace ( "'" , "\\'" , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] , $ this -> intPid , $ this -> strTable ) ) ) . '\',\'url\':this.href});return false">' . Image :: getHtml ( 'diff.svg' ) . '</a> </div> </form> </div> ' ; } 
public static function addToTemplate ( BackendTemplate $ objTemplate ) { $ arrVersions = array ( ) ; $ objUser = BackendUser :: getInstance ( ) ; $ objDatabase = Database :: getInstance ( ) ; 
protected function getEditUrl ( ) { if ( $ this -> strEditUrl !== null ) { return sprintf ( $ this -> strEditUrl , $ this -> intPid ) ; } $ strUrl = Environment :: get ( 'request' ) ; 
protected function getUsername ( ) { if ( $ this -> strUsername !== null ) { return $ this -> strUsername ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> username ; } 
protected function getUserId ( ) { if ( $ this -> intUserId !== null ) { return $ this -> intUserId ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> id ; } 
protected function implodeRecursive ( $ var , $ binary = false ) { if ( ! \ is_array ( $ var ) ) { return $ binary ? StringUtil :: binToUuid ( $ var ) : $ var ; } elseif ( ! \ is_array ( current ( $ var ) ) ) { if ( $ binary ) { $ var = array_map ( function ( $ v ) { return $ v ? StringUtil :: binToUuid ( $ v ) : '' ; } , $ var ) ; } return implode ( ', ' , $ var ) ; } else { $ buffer = '' ; foreach ( $ var as $ k => $ v ) { $ buffer .= $ k . ": " . $ this -> implodeRecursive ( $ v ) . "\n" ; } return trim ( $ buffer ) ; } } 
protected function createIfNotExists ( ) { 
public function truncate ( ) { if ( \ is_resource ( $ this -> resFile ) ) { ftruncate ( $ this -> resFile , 0 ) ; rewind ( $ this -> resFile ) ; } return $ this -> write ( '' ) ; } 
public function delete ( ) { $ return = $ this -> Files -> delete ( $ this -> strFile ) ; 
public function close ( ) { if ( \ is_resource ( $ this -> resFile ) ) { $ this -> Files -> fclose ( $ this -> resFile ) ; } 
public function getContent ( ) { $ strContent = file_get_contents ( $ this -> strRootDir . '/' . ( $ this -> strTmp ? : $ this -> strFile ) ) ; 
public static function putContent ( $ strFile , $ strContent ) { $ objFile = new static ( $ strFile ) ; $ objFile -> write ( $ strContent ) ; $ objFile -> close ( ) ; } 
public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; 
public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; 
public function resizeTo ( $ width , $ height , $ mode = '' ) { if ( ! $ this -> isImage ) { return false ; } $ return = System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ this -> strRootDir . '/' . $ this -> strFile , array ( $ width , $ height , $ mode ) , $ this -> strRootDir . '/' . $ this -> strFile ) -> getUrl ( $ this -> strRootDir ) ; if ( $ return ) { $ this -> arrPathinfo = array ( ) ; $ this -> arrImageSize = array ( ) ; } return $ return ; } 
public function sendToBrowser ( $ filename = '' , $ inline = false ) { $ response = new BinaryFileResponse ( $ this -> strRootDir . '/' . $ this -> strFile ) ; $ response -> setContentDisposition ( $ inline ? ResponseHeaderBag :: DISPOSITION_INLINE : ResponseHeaderBag :: DISPOSITION_ATTACHMENT , $ filename , Utf8 :: toAscii ( $ this -> basename ) ) ; $ response -> headers -> addCacheControlDirective ( 'must-revalidate' ) ; $ response -> headers -> addCacheControlDirective ( 'post-check' , 0 ) ; $ response -> headers -> addCacheControlDirective ( 'pre-check' , 0 ) ; $ response -> headers -> set ( 'Connection' , 'close' ) ; throw new ResponseException ( $ response ) ; } 
protected function fputs ( $ varData , $ strMode ) { if ( ! \ is_resource ( $ this -> resFile ) ) { $ this -> strTmp = 'system/tmp/' . md5 ( uniqid ( mt_rand ( ) , true ) ) ; 
protected function getPathinfo ( ) { $ matches = array ( ) ; $ return = array ( 'dirname' => '' , 'basename' => '' , 'extension' => '' , 'filename' => '' ) ; preg_match ( '%^(.*?)[\\\\/]*(([^/\\\\]*?)(\.([^\.\\\\/]+?)|))[\\\\/\.]*$%m' , $ this -> strFile , $ matches ) ; if ( isset ( $ matches [ 1 ] ) ) { $ return [ 'dirname' ] = $ this -> strRootDir . '/' . $ matches [ 1 ] ; 
public function getResponse ( $ objPage ) { 
public function build ( ContainerBuilder $ container ) : void { parent :: build ( $ container ) ; $ extension = $ container -> getExtension ( 'security' ) ; $ extension -> addSecurityListenerFactory ( new ContaoLoginFactory ( ) ) ; $ container -> addCompilerPass ( new MakeServicesPublicPass ( ) ) ; $ container -> addCompilerPass ( new AddPackagesPass ( ) ) ; $ container -> addCompilerPass ( new AddAssetsPackagesPass ( ) ) ; $ container -> addCompilerPass ( new AddSessionBagsPass ( ) ) ; $ container -> addCompilerPass ( new AddResourcesPathsPass ( ) ) ; $ container -> addCompilerPass ( new DoctrineMigrationsPass ( ) , PassConfig :: TYPE_BEFORE_REMOVING ) ; $ container -> addCompilerPass ( new PickerProviderPass ( ) ) ; $ container -> addCompilerPass ( new RegisterFragmentsPass ( ) ) ; $ container -> addCompilerPass ( new FragmentRendererPass ( 'contao.fragment.handler' ) ) ; $ container -> addCompilerPass ( new MapFragmentsToGlobalsPass ( ) ) ; $ container -> addCompilerPass ( new DataContainerCallbackPass ( ) ) ; $ container -> addCompilerPass ( new RegisterHookListenersPass ( ) , PassConfig :: TYPE_OPTIMIZE ) ; } 
public function hasFrontendUser ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof FrontendUser ; } 
public function hasBackendUser ( ) : bool { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof BackendUser ; } 
public function getFrontendUsername ( ) : ? string { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof FrontendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; } 
public function getBackendUsername ( ) : ? string { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof BackendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; } 
public function isPreviewMode ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return $ token instanceof FrontendPreviewToken && $ token -> showUnpublished ( ) ; } 
public static function findPublishedById ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ; } return static :: findOneBy ( $ arrColumns , $ intId , $ arrOptions ) ; } 
public static function findAllActive ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; return static :: findBy ( array ( "$t.disable='' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "')" ) , null , $ arrOptions ) ; } 
public static function findFirstActiveWithJumpToByIds ( $ arrIds ) { @ trigger_error ( 'Using MemberGroupModel::findFirstActiveWithJumpToByIds() has been deprecated and will no longer work in Contao 5.0. Use PageModel::findFirstActiveByMemberGroups() instead.' , E_USER_DEPRECATED ) ; if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return new static ( $ objResult ) ; } 
public static function substr ( $ strString , $ intNumberOfChars , $ strEllipsis = ' …') { $ strString = preg_replace ( '/[\t\n\r]+/' , ' ' , $ strString ) ; $ strString = strip_tags ( $ strString ) ; if ( Utf8 :: strlen ( $ strString ) <= $ intNumberOfChars ) { return $ strString ; } $ intCharCount = 0 ; $ arrWords = array ( ) ; $ arrChunks = preg_split ( '/\s+/' , $ strString ) ; $ blnAddEllipsis = false ; foreach ( $ arrChunks as $ strChunk ) { $ intCharCount += Utf8 :: strlen ( static :: decodeEntities ( $ strChunk ) ) ; if ( $ intCharCount ++ <= $ intNumberOfChars ) { $ arrWords [ ] = $ strChunk ; continue ; } 
public static function substrHtml ( $ strString , $ intNumberOfChars ) { $ strReturn = '' ; $ intCharCount = 0 ; $ arrOpenTags = array ( ) ; $ arrTagBuffer = array ( ) ; $ arrEmptyTags = array ( 'area' , 'base' , 'br' , 'col' , 'hr' , 'img' , 'input' , 'frame' , 'link' , 'meta' , 'param' ) ; $ strString = preg_replace ( '/[\t\n\r]+/' , ' ' , $ strString ) ; $ strString = strip_tags ( $ strString , Config :: get ( 'allowedTags' ) ) ; $ strString = preg_replace ( '/ +/' , ' ' , $ strString ) ; 
public static function decodeEntities ( $ strString , $ strQuoteStyle = ENT_COMPAT , $ strCharset = null ) { if ( $ strString == '' ) { return '' ; } if ( $ strCharset === null ) { $ strCharset = Config :: get ( 'characterSet' ) ; } $ strString = preg_replace ( '/(&#*\w+)[\x00-\x20]+;/i' , '$1;' , $ strString ) ; $ strString = preg_replace ( '/(&#x*)([0-9a-f]+);/i' , '$1$2;' , $ strString ) ; return html_entity_decode ( $ strString , $ strQuoteStyle , $ strCharset ) ; } 
public static function generateAlias ( $ strString ) { $ strString = static :: decodeEntities ( $ strString ) ; $ strString = static :: restoreBasicEntities ( $ strString ) ; $ strString = static :: standardize ( strip_tags ( $ strString ) ) ; 
public static function prepareSlug ( $ strSlug ) { $ strSlug = static :: stripInsertTags ( $ strSlug ) ; $ strSlug = static :: restoreBasicEntities ( $ strSlug ) ; $ strSlug = static :: decodeEntities ( $ strSlug ) ; return $ strSlug ; } 
public static function censor ( $ strString , $ varWords , $ strReplace = '' ) { foreach ( ( array ) $ varWords as $ strWord ) { $ strString = preg_replace ( '/\b(' . str_replace ( '\*' , '\w*?' , preg_quote ( $ strWord , '/' ) ) . ')\b/i' , $ strReplace , $ strString ) ; } return $ strString ; } 
public static function encodeEmail ( $ strString ) { if ( strpos ( $ strString , '@' ) === false ) { return $ strString ; } $ arrEmails = static :: extractEmail ( $ strString , Config :: get ( 'allowedTags' ) ) ; foreach ( $ arrEmails as $ strEmail ) { $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ strEmail ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( ( random_int ( 0 , 1 ) ? '&#x%X;' : '&#%s;' ) , Utf8 :: ord ( $ strCharacter ) ) ; } $ strString = str_replace ( $ strEmail , $ strEncoded , $ strString ) ; } return str_replace ( 'mailto:' , '&#109;&#97;&#105;&#108;&#116;&#111;&#58;' , $ strString ) ; } 
public static function extractEmail ( $ strString , $ strAllowedTags = '' ) { $ arrEmails = array ( ) ; if ( strpos ( $ strString , '@' ) === false ) { return $ arrEmails ; } 
public static function splitFriendlyEmail ( $ strEmail ) { if ( strpos ( $ strEmail , '<' ) !== false ) { return array_map ( 'trim' , explode ( ' <' , str_replace ( '>' , '' , $ strEmail ) ) ) ; } elseif ( strpos ( $ strEmail , '[' ) !== false ) { return array_map ( 'trim' , explode ( ' [' , str_replace ( ']' , '' , $ strEmail ) ) ) ; } else { return array ( '' , $ strEmail ) ; } } 
public static function highlight ( $ strString , $ strPhrase , $ strOpeningTag = '<strong>' , $ strClosingTag = '</strong>' ) { if ( $ strString == '' || $ strPhrase == '' ) { return $ strString ; } return preg_replace ( '/(' . preg_quote ( $ strPhrase , '/' ) . ')/i' , $ strOpeningTag . '\\1' . $ strClosingTag , $ strString ) ; } 
public static function splitCsv ( $ strString , $ strDelimiter = ',' ) { $ arrValues = preg_split ( '/' . $ strDelimiter . '(?=(?:[^"]*"[^"]*")*(?![^"]*"))/' , $ strString ) ; foreach ( $ arrValues as $ k => $ v ) { $ arrValues [ $ k ] = trim ( $ v , ' "' ) ; } return $ arrValues ; } 
public static function toXhtml ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*)>/i' => '<$1$2 />' , 
public static function toHtml5 ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*) \/>/i' => '<$1$2>' , 
public static function parseSimpleTokens ( $ strString , $ arrData ) { $ strReturn = '' ; $ replaceTokens = function ( $ strSubject ) use ( $ arrData ) { 
public static function srcToInsertTag ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]+)")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 4 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByPath ( $ paths [ $ i + 3 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="{{file::' . static :: binToUuid ( $ file -> uuid ) . '}}"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . '"' ; } } return $ return ; } 
public static function insertTagToSrc ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]*)\{\{file::([^"\}]+)\}\}")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 5 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByUuid ( $ paths [ $ i + 4 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . $ file -> path . '"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . $ paths [ $ i + 4 ] . '"' ; } } return $ return ; } 
public static function sanitizeFileName ( $ strName ) { 
public static function resolveFlaggedUrl ( & $ url ) { $ options = new \ stdClass ( ) ; 
public static function convertEncoding ( $ str , $ to , $ from = null ) { if ( $ str == '' ) { return '' ; } if ( ! $ from ) { $ from = mb_detect_encoding ( $ str , 'ASCII,ISO-2022-JP,UTF-8,EUC-JP,ISO-8859-1' ) ; } if ( $ from == $ to ) { return $ str ; } if ( $ from == 'UTF-8' && $ to == 'ISO-8859-1' ) { return utf8_decode ( $ str ) ; } if ( $ from == 'ISO-8859-1' && $ to == 'UTF-8' ) { return utf8_encode ( $ str ) ; } return mb_convert_encoding ( $ str , $ to , $ from ) ; } 
public static function specialchars ( $ strString , $ blnStripInsertTags = false , $ blnDoubleEncode = false ) { if ( $ blnStripInsertTags ) { $ strString = static :: stripInsertTags ( $ strString ) ; } 
public static function standardize ( $ strString , $ blnPreserveUppercase = false ) { $ arrSearch = array ( '/[^\pN\pL \.\&\/_-]+/u' , '/[ \.\&\/-]+/' ) ; $ arrReplace = array ( '' , '-' ) ; $ strString = html_entity_decode ( $ strString , ENT_QUOTES , $ GLOBALS [ 'TL_CONFIG' ] [ 'characterSet' ] ) ; $ strString = static :: stripInsertTags ( $ strString ) ; $ strString = preg_replace ( $ arrSearch , $ arrReplace , $ strString ) ; if ( is_numeric ( substr ( $ strString , 0 , 1 ) ) ) { $ strString = 'id-' . $ strString ; } if ( ! $ blnPreserveUppercase ) { $ strString = Utf8 :: strtolower ( $ strString ) ; } return trim ( $ strString , '-' ) ; } 
public static function deserialize ( $ varValue , $ blnForceArray = false ) { 
public static function trimsplit ( $ strPattern , $ strString ) { 
public static function stripRootDir ( $ path ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ length = \ strlen ( $ rootDir ) ; if ( strncmp ( $ path , $ rootDir , $ length ) !== 0 || \ strlen ( $ path ) <= $ length || ( $ path [ $ length ] !== '/' && $ path [ $ length ] !== '\\' ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Path "%s" is not inside the Contao root dir "%s"' , $ path , $ rootDir ) ) ; } return ( string ) substr ( $ path , $ length + 1 ) ; } 
public static function findPublishedByParentAndIdOrAlias ( $ varId , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrColumns [ ] = "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ varId , $ arrOptions ) ; } 
public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isBackendMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( null === $ this -> token ) { $ this -> token = $ this -> tokenManager -> refreshToken ( 'contao_referer_id' ) ; } $ request -> attributes -> set ( '_contao_referer_id' , $ this -> token -> getValue ( ) ) ; } 
public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof ResponseException ) { return ; } $ event -> allowCustomResponseCode ( ) ; $ event -> setResponse ( $ exception -> getResponse ( ) ) ; } 
public function addLegend ( string $ name , $ parent , string $ position = self :: POSITION_AFTER , $ hide = false ) : self { $ this -> validatePosition ( $ position ) ; $ this -> legends [ ] = [ 'name' => $ name , 'parents' => ( array ) $ parent , 'position' => $ position , 'hide' => ( bool ) $ hide , ] ; return $ this ; } 
public function addField ( $ name , $ parent , string $ position = self :: POSITION_AFTER , $ fallback = null , $ fallbackPosition = self :: POSITION_APPEND ) : self { $ this -> validatePosition ( $ position ) ; if ( self :: POSITION_BEFORE === $ fallbackPosition || self :: POSITION_AFTER === $ fallbackPosition ) { throw new PalettePositionException ( 'Fallback legend position can only be PREPEND or APPEND' ) ; } $ this -> fields [ ] = [ 'fields' => ( array ) $ name , 'parents' => ( array ) $ parent , 'position' => $ position , 'fallback' => is_scalar ( $ fallback ) ? [ $ fallback ] : $ fallback , 'fallbackPosition' => $ fallbackPosition , ] ; return $ this ; } 
public function removeField ( $ name , string $ legend = null ) : self { $ this -> removes [ ] = [ 'fields' => ( array ) $ name , 'parents' => ( array ) $ legend , ] ; return $ this ; } 
private function explode ( string $ palette ) : array { if ( '' === $ palette ) { return [ ] ; } $ legendCount = 0 ; $ legendMap = [ ] ; $ groups = StringUtil :: trimsplit ( ';' , $ palette ) ; foreach ( $ groups as $ group ) { if ( '' === $ group ) { continue ; } $ hide = false ; $ fields = StringUtil :: trimsplit ( ',' , $ group ) ; if ( preg_match ( '#\{(.+?)(:hide)?\}#' , $ fields [ 0 ] , $ matches ) ) { $ legend = $ matches [ 1 ] ; $ hide = \ count ( $ matches ) > 2 && ':hide' === $ matches [ 2 ] ; array_shift ( $ fields ) ; } else { $ legend = $ legendCount ++ ; } $ legendMap [ $ legend ] = compact ( 'fields' , 'hide' ) ; } return $ legendMap ; } 
private function implode ( array $ config ) : string { $ palette = '' ; foreach ( $ config as $ legend => $ group ) { if ( \ count ( $ group [ 'fields' ] ) < 1 ) { continue ; } if ( '' !== $ palette ) { $ palette .= ';' ; } if ( ! \ is_int ( $ legend ) ) { $ palette .= sprintf ( '{%s%s},' , $ legend , ( $ group [ 'hide' ] ? ':hide' : '' ) ) ; } $ palette .= implode ( ',' , $ group [ 'fields' ] ) ; } return $ palette ; } 
private function applyFallback ( array & $ config , array $ action , bool $ skipLegends = false ) : void { if ( \ is_callable ( $ action [ 'fallback' ] ) ) { $ action [ 'fallback' ] ( $ config , $ action , $ skipLegends ) ; } else { $ this -> applyFallbackPalette ( $ config , $ action ) ; } } 
private function findLegendForField ( array & $ config , string $ field ) { foreach ( $ config as $ legend => $ group ) { if ( \ in_array ( $ field , $ group [ 'fields' ] , true ) ) { return $ legend ; } } return false ; } 
public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } 
public function adjustPermissions ( $ insertId ) { 
public function getAllowedCalendars ( ) { if ( $ this -> User -> isAdmin ) { $ objCalendar = Contao \ CalendarModel :: findAll ( ) ; } else { $ objCalendar = Contao \ CalendarModel :: findMultipleByIds ( $ this -> User -> calendars ) ; } $ return = array ( ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { $ return [ $ objCalendar -> id ] = $ objCalendar -> title ; } } return $ return ; } 
public function addFile ( $ strFile , $ strName = null ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFile ) ) { throw new \ Exception ( "File $strFile does not exist" ) ; } 
public function addString ( $ strData , $ strName , $ intTime = 0 ) { ++ $ this -> intCount ; $ strName = strtr ( $ strName , '\\' , '/' ) ; 
public function close ( ) { 
protected function unixToHex ( $ intTime = 0 ) { $ arrTime = $ intTime ? getdate ( $ intTime ) : getdate ( ) ; $ hexTime = dechex ( ( ( $ arrTime [ 'year' ] - 1980 ) << 25 ) | ( $ arrTime [ 'mon' ] << 21 ) | ( $ arrTime [ 'mday' ] << 16 ) | ( $ arrTime [ 'hours' ] << 11 ) | ( $ arrTime [ 'minutes' ] << 5 ) | ( $ arrTime [ 'seconds' ] >> 1 ) ) ; return pack ( "H*" , $ hexTime [ 6 ] . $ hexTime [ 7 ] . $ hexTime [ 4 ] . $ hexTime [ 5 ] . $ hexTime [ 2 ] . $ hexTime [ 3 ] . $ hexTime [ 0 ] . $ hexTime [ 1 ] ) ; } 
public function run ( ) : void { $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; CREATE TABLE tl_newsletter_recipients_backup LIKE tl_newsletter_recipients ' ) ; $ this -> connection -> query ( ' INSERT tl_newsletter_recipients_backup SELECT * FROM tl_newsletter_recipients ' ) ; } // Find multiple subscriptions for the same channel with the same e-mail address $ duplicates = $ this -> connection -> query ( ' SELECT pid, email FROM tl_newsletter_recipients GROUP BY pid, email HAVING COUNT(*) > 1 ORDER BY pid ' ) ; while ( false !== ( $ duplicate = $ duplicates -> fetch ( \ PDO :: FETCH_OBJ ) ) ) { $ count = 0 ; // Find the oldest, active subscription preferring real subscriptions over imported ones $ subscriptions = $ this -> connection -> prepare ( " SELECT * FROM tl_newsletter_recipients WHERE pid = :pid AND email = :email ORDER BY active = '1' DESC, addedOn != '' DESC, id " ) ; $ subscriptions -> execute ( [ 'pid' => $ duplicate -> pid , ':email' => $ duplicate -> email ] ) ; while ( false !== ( $ subscription = $ subscriptions -> fetch ( \ PDO :: FETCH_OBJ ) ) ) { if ( 0 === $ count ++ ) { continue ; // keep the first subscription } $ delete = $ this -> connection -> prepare ( ' DELETE FROM tl_newsletter_recipients WHERE id = :id ' ) ; $ delete -> execute ( [ 'id' => $ subscription -> id ] ) ; } $ this -> addMessage ( sprintf ( '<li>%s</li>' , $ duplicate -> email ) ) ; } if ( $ this -> hasMessage ( ) ) { $ translator = $ this -> container -> get ( 'translator' ) ; $ this -> prependMessage ( sprintf ( '<h3>%s</h3><p>%s</p><ul>' , $ translator -> trans ( 'duplicate_subscriptions' ) , $ translator -> trans ( 'duplicate_subscriptions_begin' ) ) ) ; $ this -> addMessage ( sprintf ( '</ul><p>%s</p>' , $ translator -> trans ( 'duplicate_subscriptions_end' ) ) ) ; } } 
public function addCommentsToTemplate ( FrontendTemplate $ objTemplate , \ stdClass $ objConfig , $ strSource , $ intParent , $ varNotifies ) { global $ objPage ; $ limit = 0 ; $ offset = 0 ; $ total = 0 ; $ gtotal = 0 ; $ arrComments = array ( ) ; $ objTemplate -> comments = array ( ) ; 
protected function renderCommentForm ( FrontendTemplate $ objTemplate , \ stdClass $ objConfig , $ strSource , $ intParent , $ varNotifies ) { $ this -> import ( FrontendUser :: class , 'User' ) ; 
public function parseBbCode ( $ strComment ) { $ arrSearch = array ( '@\[b\](.*)\[/b\]@Uis' , '@\[i\](.*)\[/i\]@Uis' , '@\[u\](.*)\[/u\]@Uis' , '@\s*\[code\](.*)\[/code\]\s*@Uis' , '@\[color=([^\]" ]+)\](.*)\[/color\]@Uis' , '@\s*\[quote\](.*)\[/quote\]\s*@Uis' , '@\s*\[quote=([^\]]+)\](.*)\[/quote\]\s*@Uis' , '@\[img\]\s*([^\[" ]+\.(jpe?g|png|gif|bmp|tiff?|ico))\s*\[/img\]@i' , '@\[url\]\s*([^\[" ]+)\s*\[/url\]@i' , '@\[url=([^\]" ]+)\](.*)\[/url\]@Uis' , '@\[email\]\s*([^\[" ]+)\s*\[/email\]@i' , '@\[email=([^\]" ]+)\](.*)\[/email\]@Uis' , '@href="(([a-z0-9]+\.)*[a-z0-9]+\.([a-z]{2}|asia|biz|com|info|name|net|org|tel)(/|"))@i' ) ; $ arrReplace = array ( '<strong>$1</strong>' , '<em>$1</em>' , '<span style="text-decoration:underline">$1</span>' , "\n\n" . '<div class="code"><p>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_code' ] . '</p><pre>$1</pre></div>' . "\n\n" , '<span style="color:$1">$2</span>' , "\n\n" . '<blockquote>$1</blockquote>' . "\n\n" , "\n\n" . '<blockquote><p>' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_quote' ] , '$1' ) . '</p>$2</blockquote>' . "\n\n" , '<img src="$1" alt="" />' , '<a href="$1">$1</a>' , '<a href="$1">$2</a>' , '<a href="mailto:$1">$1</a>' , '<a href="mailto:$1">$2</a>' , 'href="http://$1' ) ; $ strComment = preg_replace ( $ arrSearch , $ arrReplace , $ strComment ) ; 
public function convertLineFeeds ( $ strComment ) { $ strComment = nl2br_pre ( $ strComment ) ; 
public function purgeSubscriptions ( ) { $ objNotify = CommentsNotifyModel :: findExpiredSubscriptions ( ) ; if ( $ objNotify === null ) { return ; } while ( $ objNotify -> next ( ) ) { $ objNotify -> delete ( ) ; } 
public static function addCommentsSubscription ( CommentsModel $ objComment ) { $ objNotify = CommentsNotifyModel :: findBySourceParentAndEmail ( $ objComment -> source , $ objComment -> parent , $ objComment -> email ) ; 
public static function changeSubscriptionStatus ( FrontendTemplate $ objTemplate ) { if ( strncmp ( Input :: get ( 'token' ) , 'com-' , 4 ) === 0 ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; 
public static function notifyCommentsSubscribers ( CommentsModel $ objComment ) { 
public function parse ( ) { if ( $ this -> strTemplate == '' ) { return '' ; } 
public function output ( ) { @ trigger_error ( 'Using Template::output() has been deprecated and will no longer work in Contao 5.0. Use Template::getResponse() instead.' , E_USER_DEPRECATED ) ; $ this -> compile ( ) ; header ( 'Content-Type: ' . $ this -> strContentType . '; charset=' . Config :: get ( 'characterSet' ) ) ; echo $ this -> strBuffer ; 
public function getResponse ( ) { $ this -> compile ( ) ; $ response = new Response ( $ this -> strBuffer ) ; $ response -> headers -> set ( 'Content-Type' , $ this -> strContentType . '; charset=' . Config :: get ( 'characterSet' ) ) ; return $ response ; } 
public function route ( $ strName , $ arrParams = array ( ) ) { $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( $ strName , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; return ampersand ( $ strUrl ) ; } 
public function previewRoute ( $ strName , $ arrParams = array ( ) ) { $ objRouter = System :: getContainer ( ) -> get ( 'router' ) ; $ objContext = $ objRouter -> getContext ( ) ; $ objPreviewContext = clone $ objContext ; $ objPreviewContext -> setBaseUrl ( '/preview.php' ) ; $ objRouter -> setContext ( $ objPreviewContext ) ; $ strUrl = $ objRouter -> generate ( $ strName , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; $ objRouter -> setContext ( $ objContext ) ; return ampersand ( $ strUrl ) ; } 
public function trans ( $ strId , array $ arrParams = array ( ) , $ strDomain = 'contao_default' ) { return System :: getContainer ( ) -> get ( 'translator' ) -> trans ( $ strId , $ arrParams , $ strDomain ) ; } 
public function asset ( $ path , $ packageName = null ) { $ url = System :: getContainer ( ) -> get ( 'assets.packages' ) -> getUrl ( $ path , $ packageName ) ; 
public function minifyHtml ( $ strHtml ) { if ( Config :: get ( 'debugMode' ) ) { return $ strHtml ; } 
public static function generateStyleTag ( $ href , $ media = null , $ mtime = false ) { 
public static function generateScriptTag ( $ src , $ async = false , $ mtime = false , $ hash = null , $ crossorigin = null ) { 
public function flushAllData ( ) { @ trigger_error ( 'Using Template::flushAllData() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ function_exists ( 'fastcgi_finish_request' ) ) { fastcgi_finish_request ( ) ; } elseif ( PHP_SAPI !== 'cli' ) { $ status = ob_get_status ( true ) ; $ level = \ count ( $ status ) ; while ( $ level -- > 0 && ( ! empty ( $ status [ $ level ] [ 'del' ] ) || ( isset ( $ status [ $ level ] [ 'flags' ] ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_REMOVABLE ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_FLUSHABLE ) ) ) ) { ob_end_flush ( ) ; } flush ( ) ; } } 
public function generate ( ) { $ objElement = ContentModel :: findByPk ( $ this -> cteAlias ) ; if ( $ objElement === null ) { return '' ; } $ strClass = static :: findClass ( $ objElement -> type ) ; if ( ! class_exists ( $ strClass ) ) { return '' ; } $ objElement -> origId = $ objElement -> id ; $ objElement -> id = $ this -> id ; $ objElement -> typePrefix = 'ce_' ; $ objElement = new $ strClass ( $ objElement ) ; $ cssID = StringUtil :: deserialize ( $ objElement -> cssID , true ) ; 
public static function getInstance ( $ strTable ) { if ( ! isset ( static :: $ arrInstances [ $ strTable ] ) ) { static :: $ arrInstances [ $ strTable ] = new static ( $ strTable ) ; } return static :: $ arrInstances [ $ strTable ] ; } 
public function getDbInstallerArray ( ) { $ return = array ( ) ; 
protected function createExtract ( ) { 
public function importTheme ( ) { $ objUploader = new FileUpload ( ) ; if ( Input :: post ( 'FORM_SUBMIT' ) == 'tl_theme_import' ) { $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! Input :: post ( 'confirm' ) ) { $ arrUploaded = $ objUploader -> uploadTo ( 'system/tmp' ) ; if ( empty ( $ arrUploaded ) ) { Message :: addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'all_fields' ] ) ; $ this -> reload ( ) ; } $ arrFiles = array ( ) ; foreach ( $ arrUploaded as $ strFile ) { <div id="tl_buttons"> <a href="' . ampersand ( str_replace ( '&key=importTheme' , '' , Environment :: get ( 'request' ) ) ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div> <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_theme_import" class="tl_form tl_edit_form" method="post" enctype="multipart/form-data"> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="tl_theme_import"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"> <input type="hidden" name="MAX_FILE_SIZE" value="' . Config :: get ( 'maxFileSize' ) . '"> <div class="tl_tbox"> <div class="widget"> <h3>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_theme' ] [ 'source' ] [ 0 ] . '</h3>' . $ objUploader -> generateMarkup ( ) . ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_theme' ] [ 'source' ] [ 1 ] ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_theme' ] [ 'source' ] [ 1 ] . '</p>' : '' ) . ' </div> </div> </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> <button type="submit" name="save" id="save" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_theme' ] [ 'importTheme' ] [ 0 ] . '</button> </div> </div> </form>' ; } 
protected function compareThemeFiles ( $ arrFiles , $ arrDbFields ) { $ return = Message :: generate ( ) . ' <div id="tl_buttons"> <a href="' . ampersand ( str_replace ( '&key=importTheme' , '' , Environment :: get ( 'request' ) ) ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div> <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_theme_import" class="tl_form tl_edit_form" method="post"> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="tl_theme_import"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"> <input type="hidden" name="confirm" value="1">' ; $ count = 0 ; <div class="tl_' . ( ( $ count ++ < 1 ) ? 't' : '' ) . 'box theme_import"> <h3>' . basename ( $ strFile ) . '</h3> <h4>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_theme' ] [ 'tables_fields' ] . '</h4>' ; // Find the XML file $ objArchive = new ZipReader ( $ strFile ) ; // Continue if there is no XML file if ( $ objArchive -> getFile ( 'theme.xml' ) === false ) { $ return .= "\n " . '<p class="tl_red" style="margin:0">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_theme' ] [ 'missing_xml' ] , basename ( $ strFile ) ) . "</p>\n</div>" ; continue ; } // Open the XML file $ xml = new \ DOMDocument ( ) ; $ xml -> preserveWhiteSpace = false ; $ xml -> loadXML ( $ objArchive -> unzip ( ) ) ; $ tables = $ xml -> getElementsByTagName ( 'table' ) ; $ blnHasError = false ; // Loop through the tables for ( $ i = 0 ; $ i < $ tables -> length ; $ i ++ ) { $ rows = $ tables -> item ( $ i ) -> childNodes ; $ table = $ tables -> item ( $ i ) -> getAttribute ( 'name' ) ; // Skip invalid tables if ( $ table != 'tl_theme' && $ table != 'tl_style_sheet' && $ table != 'tl_style' && $ table != 'tl_module' && $ table != 'tl_layout' && $ table != 'tl_image_size' && $ table != 'tl_image_size_item' ) { continue ; } $ arrFieldNames = array ( ) ; // Loop through the rows for ( $ j = 0 ; $ j < $ rows -> length ; $ j ++ ) { $ fields = $ rows -> item ( $ j ) -> childNodes ; // Loop through the fields for ( $ k = 0 ; $ k < $ fields -> length ; $ k ++ ) { $ arrFieldNames [ $ fields -> item ( $ k ) -> getAttribute ( 'name' ) ] = true ; } } $ arrFieldNames = array_keys ( $ arrFieldNames ) ; // Loop through the fields foreach ( $ arrFieldNames as $ name ) { // Print a warning if a field is missing if ( ! \ in_array ( $ name , $ arrDbFields [ $ table ] ) ) { $ blnHasError = true ; $ return .= "\n " . '<p class="tl_red" style="margin:0">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_theme' ] [ 'missing_field' ] , $ table . '.' . $ name ) . '</p>' ; } } } // Confirmation if ( ! $ blnHasError ) { $ return .= "\n " . '<p class="tl_green" style="margin:0">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_theme' ] [ 'tables_ok' ] . '</p>' ; } // Check the custom templates $ return .= ' <h4>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_theme' ] [ 'custom_templates' ] . '</h4>' ; $ objArchive -> reset ( ) ; $ blnTplExists = false ; // Loop through the archive while ( $ objArchive -> next ( ) ) { if ( strncmp ( $ objArchive -> file_name , 'templates/' , 10 ) !== 0 ) { continue ; } if ( file_exists ( $ this -> strRootDir . '/' . $ objArchive -> file_name ) ) { $ blnTplExists = true ; $ return .= "\n " . '<p class="tl_red" style="margin:0">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_theme' ] [ 'template_exists' ] , $ objArchive -> file_name ) . '</p>' ; } } // Confirmation if ( ! $ blnTplExists ) { $ return .= "\n " . '<p class="tl_green" style="margin:0">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_theme' ] [ 'templates_ok' ] . '</p>' ; } // HOOK: add custom logic if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'compareThemeFiles' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'compareThemeFiles' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'compareThemeFiles' ] as $ callback ) { $ return .= System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ xml , $ objArchive ) ; } } $ return .= ' </div>' ; } // Return the form return $ return . ' </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> <button type="submit" name="save" id="save" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'continue' ] . '</button> </div> </div> </form>' ; } 
protected function extractThemeFiles ( $ arrFiles , $ arrDbFields ) { foreach ( $ arrFiles as $ strZipFile ) { $ xml = null ; 
public function exportTheme ( DataContainer $ dc ) { 
protected function addTableTlTheme ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { 
protected function addTableTlStyleSheet ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { 
protected function addTableTlModule ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { 
protected function addTableTlImageSize ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { 
protected function addTableTlFiles ( \ DOMDocument $ xml , \ DOMElement $ tables , Result $ objTheme , ZipWriter $ objArchive ) { 
protected function addDataRow ( \ DOMDocument $ xml , \ DOMElement $ table , array $ arrRow , array $ arrOrder = array ( ) ) { $ t = $ table -> getAttribute ( 'name' ) ; $ row = $ xml -> createElement ( 'row' ) ; $ row = $ table -> appendChild ( $ row ) ; foreach ( $ arrRow as $ k => $ v ) { $ field = $ xml -> createElement ( 'field' ) ; $ field -> setAttribute ( 'name' , $ k ) ; $ field = $ row -> appendChild ( $ field ) ; if ( $ v === null ) { $ v = 'NULL' ; } 
protected function addFolderToArchive ( ZipWriter $ objArchive , $ strFolder , \ DOMDocument $ xml , \ DOMElement $ table , array $ arrOrder = array ( ) ) { 
protected function addTemplatesToArchive ( ZipWriter $ objArchive , $ strFolder ) { 
public static function addResource ( $ strResource , $ blnUpdateFolders = true ) { $ strUploadPath = Config :: get ( 'uploadPath' ) . '/' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; 
public static function moveResource ( $ strSource , $ strDestination ) { $ objFile = FilesModel :: findByPath ( $ strSource ) ; 
public static function copyResource ( $ strSource , $ strDestination ) { $ objDatabase = Database :: getInstance ( ) ; $ objFile = FilesModel :: findByPath ( $ strSource ) ; 
public static function deleteResource ( $ strResource ) { $ objModel = FilesModel :: findByPath ( $ strResource ) ; 
public static function updateFolderHashes ( $ varResource ) { $ arrPaths = array ( ) ; if ( ! \ is_array ( $ varResource ) ) { $ varResource = array ( $ varResource ) ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ varResource as $ strResource ) { $ arrChunks = explode ( '/' , $ strResource ) ; $ strPath = array_shift ( $ arrChunks ) ; 
public static function syncFiles ( ) { @ ini_set ( 'max_execution_time' , 0 ) ; 
public static function getFolderHash ( $ strPath ) { $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; $ arrHash = array ( ) ; $ objChildren = Database :: getInstance ( ) -> prepare ( "SELECT hash, name FROM tl_files WHERE path LIKE ? AND path NOT LIKE ? ORDER BY name" ) -> execute ( $ strPath . '/%' , $ strPath . '/%/%' ) ; if ( $ objChildren !== null ) { while ( $ objChildren -> next ( ) ) { $ arrHash [ ] = $ objChildren -> hash . $ objChildren -> name ; } } return md5 ( implode ( "\0" , $ arrHash ) ) ; } 
public static function shouldBeSynchronized ( $ strPath ) { if ( ! isset ( static :: $ arrShouldBeSynchronized [ $ strPath ] ) || ! \ is_bool ( static :: $ arrShouldBeSynchronized [ $ strPath ] ) ) { static :: $ arrShouldBeSynchronized [ $ strPath ] = ! static :: isFileSyncExclude ( $ strPath ) ; } return static :: $ arrShouldBeSynchronized [ $ strPath ] ; } 
protected static function isFileSyncExclude ( $ strPath ) { if ( Config :: get ( 'uploadPath' ) == 'templates' ) { return true ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; 
public function onBuild ( MenuEvent $ event ) : void { if ( null === $ this -> managerPath || ! $ this -> isAdminUser ( ) ) { return ; } $ categoryNode = $ event -> getTree ( ) -> getChild ( 'system' ) ; if ( null === $ categoryNode ) { return ; } $ item = $ event -> getFactory ( ) -> createItem ( 'contao_manager' , [ 'label' => 'Contao Manager' , 'attributes' => [ 'title' => 'Contao Manager' , 'href' => '/' . $ this -> managerPath , 'class' => 'navigation contao_manager' , ] , ] ) ; $ categoryNode -> addChild ( $ item ) ; } 
protected function compile ( ) { global $ objPage ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ objPage -> language ; System :: loadLanguageFile ( 'tl_member' ) ; $ this -> loadDataContainer ( 'tl_member' ) ; 
protected function setNewPassword ( ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; 
protected function sendPasswordLink ( $ objMember ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'pw' , $ objMember -> email , array ( 'tl_member' => array ( $ objMember -> id ) ) ) ; 
public function run ( ) { $ objResponse = new Response ( '' , 204 ) ; 
protected function hasToWait ( ) { $ return = true ; 
public static function initializeApplication ( Event $ event ) : void { $ webDir = self :: getWebDir ( $ event ) ; static :: purgeCacheFolder ( ) ; static :: addAppDirectory ( ) ; static :: executeCommand ( 'contao:install-web-dir' , $ event ) ; static :: executeCommand ( 'cache:clear --no-warmup' , $ event ) ; static :: executeCommand ( 'cache:warmup' , $ event ) ; static :: executeCommand ( sprintf ( 'assets:install %s --symlink --relative' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:install %s' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:symlinks %s' , $ webDir ) , $ event ) ; $ event -> getIO ( ) -> write ( '<info>Done! Please open the Contao install tool and make sure the database is up-to-date.</info>' ) ; } 
public function updateStyleSheet ( ) { $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'style_sheet_updater' ) ; if ( empty ( $ session ) || ! \ is_array ( $ session ) ) { return ; } $ this -> import ( 'Contao\StyleSheets' , 'StyleSheets' ) ; foreach ( $ session as $ id ) { $ this -> StyleSheets -> updateStyleSheet ( $ id ) ; } $ objSession -> set ( 'style_sheet_updater' , null ) ; } 
public function scheduleUpdate ( $ id ) { 
public function listStyleSheet ( $ row ) { $ cc = '' ; $ media = Contao \ StringUtil :: deserialize ( $ row [ 'media' ] ) ; if ( $ row [ 'cc' ] != '' ) { $ cc = ' &lt;!--[' . $ row [ 'cc' ] . ']&gt;' ; } if ( $ row [ 'mediaQuery' ] != '' ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . $ row [ 'mediaQuery' ] . $ cc . '</span>' . "</div>\n" ; } elseif ( ! empty ( $ media ) && \ is_array ( $ media ) ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . implode ( ', ' , $ media ) . $ cc . '</span>' . "</div>\n" ; } else { return '<div class="tl_content_left">' . $ row [ 'name' ] . $ cc . "</div>\n" ; } } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : void { $ data = @ json_decode ( $ input -> getArgument ( 'json' ) , true ) ; if ( null === $ data ) { throw new \ RuntimeException ( 'Invalid JSON: ' . json_last_error_msg ( ) ) ; } $ this -> managerConfig -> write ( $ data ) ; } 
public function execute ( InputInterface $ input , OutputInterface $ output ) : ? int { $ application = $ this -> getApplication ( ) ; DoctrineCommandHelper :: setApplicationConnection ( $ application , $ input -> getOption ( 'db-configuration' ) ) ; DoctrineCommand :: configureMigrations ( $ application -> getKernel ( ) -> getContainer ( ) , $ this -> getMigrationConfiguration ( $ input , $ output ) ) ; parent :: execute ( $ input , $ output ) ; return 0 ; } 
public function onInitializeApplication ( ) : void { if ( file_exists ( $ this -> projectDir . '/system/initialize.php' ) ) { return ; } ( new Filesystem ( ) ) -> copy ( __DIR__ . '/../Resources/skeleton/system/initialize.php' , $ this -> projectDir . '/system/initialize.php' , true ) ; } 
protected function compile ( ) { global $ objPage ; if ( ! \ strlen ( $ this -> inColumn ) ) { $ this -> inColumn = 'main' ; } $ id = $ objPage -> id ; $ objTarget = null ; $ this -> Template -> request = Environment :: get ( 'request' ) ; 
protected function compile ( ) { 
public function checkCategory ( $ varValue ) { 
public function scheduleUpdate ( ) { 
public function updateAfterRestore ( $ id , $ table , $ data ) { if ( $ table != 'tl_style' ) { return ; } 
protected function createAuthProvider ( ContainerBuilder $ container , $ id , $ config , $ userProviderId ) : string { $ provider = 'contao.security.authentication_provider.' . $ id ; $ container -> setDefinition ( $ provider , new ChildDefinition ( 'contao.security.authentication_provider' ) ) -> replaceArgument ( 0 , new Reference ( $ userProviderId ) ) -> replaceArgument ( 1 , new Reference ( 'security.user_checker.' . $ id ) ) -> replaceArgument ( 2 , $ id ) -> addArgument ( [ 'lock_period' => $ config [ 'lock_period' ] , 'login_attempts' => $ config [ 'login_attempts' ] , ] ) ; return $ provider ; } 
protected function createListener ( $ container , $ id , $ config , $ userProvider ) : string { $ listenerId = parent :: createListener ( $ container , $ id , $ config , $ userProvider ) ; $ container -> getDefinition ( $ listenerId ) -> replaceArgument ( 7 , array_merge ( $ container -> getDefinition ( $ listenerId ) -> getArgument ( 7 ) , [ 'username_parameter' => 'username' , 'password_parameter' => 'password' ] ) ) ; return $ listenerId ; } 
public function get ( $ strKey ) { 
public function set ( $ strKey , $ varValue ) { 
public function remove ( $ strKey ) { 
public function getData ( ) { $ data = $ this -> sessionBag -> all ( ) ; 
public function setData ( $ arrData ) { if ( ! \ is_array ( $ arrData ) ) { throw new \ Exception ( 'Array required to set session data' ) ; } 
public function appendData ( $ varData ) { if ( \ is_object ( $ varData ) ) { $ varData = get_object_vars ( $ varData ) ; } if ( ! \ is_array ( $ varData ) ) { throw new \ Exception ( 'Array or object required to append session data' ) ; } foreach ( $ varData as $ k => $ v ) { 
public function parse ( $ arrAttributes = null ) { if ( $ this -> imageSubmit && $ this -> singleSRC != '' ) { $ objModel = FilesModel :: findByUuid ( $ this -> singleSRC ) ; if ( $ objModel !== null && is_file ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ objModel -> path ) ) { $ this -> src = $ objModel -> path ; } } return parent :: parse ( $ arrAttributes ) ; } 
public function generate ( ) { if ( $ this -> src ) { return sprintf ( '<input type="image" src="%s" id="ctrl_%s" class="submit%s" title="%s" alt="%s"%s%s' , $ this -> src , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , StringUtil :: specialchars ( $ this -> slabel ) , StringUtil :: specialchars ( $ this -> slabel ) , $ this -> getAttributes ( ) , $ this -> strTagEnding ) ; } 
public function cloneForCurrent ( string $ current ) : self { return new self ( $ this -> context , $ this -> extras , $ this -> value , $ current ) ; } 
public function urlEncode ( ) : string { $ data = json_encode ( $ this ) ; if ( \ function_exists ( 'gzencode' ) && false !== ( $ encoded = @ gzencode ( $ data ) ) ) { $ data = $ encoded ; } return strtr ( base64_encode ( $ data ) , '+/=' , '-_,' ) ; } 
public static function urlDecode ( string $ data ) : self { $ decoded = base64_decode ( strtr ( $ data , '-_,' , '+/=' ) , true ) ; if ( \ function_exists ( 'gzdecode' ) && false !== ( $ uncompressed = @ gzdecode ( $ decoded ) ) ) { $ decoded = $ uncompressed ; } $ json = @ json_decode ( $ decoded , true ) ; if ( null === $ json ) { throw new \ InvalidArgumentException ( 'Invalid JSON data' ) ; } return new self ( $ json [ 'context' ] , $ json [ 'extras' ] , $ json [ 'value' ] , $ json [ 'current' ] ) ; } 
public function createMenuItem ( PickerConfig $ config ) { $ name = $ this -> getName ( ) ; if ( null === $ this -> translator ) { @ trigger_error ( 'Using a picker provider without injecting the translator service has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ label = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ name ] ; } else { $ label = $ this -> translator -> trans ( 'MSC.' . $ name , [ ] , 'contao_default' ) ; } return $ this -> menuFactory -> createItem ( $ name , [ 'label' => $ label ? : $ name , 'linkAttributes' => [ 'class' => $ name ] , 'current' => $ this -> isCurrent ( $ config ) , 'uri' => $ this -> generateUrl ( $ config , true ) , ] ) ; } 
protected function getUser ( ) : BackendUser { if ( null === $ this -> tokenStorage ) { throw new \ RuntimeException ( 'No token storage provided' ) ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'No token provided' ) ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser ) { throw new \ RuntimeException ( 'The token does not contain a back end user object' ) ; } return $ user ; } 
public static function encrypt ( $ varValue , $ strKey = null ) { 
public static function decrypt ( $ varValue , $ strKey = null ) { 
protected static function initialize ( ) { if ( ! \ in_array ( 'mcrypt' , get_loaded_extensions ( ) ) ) { throw new \ Exception ( 'The PHP mcrypt extension is not installed' ) ; } if ( ! self :: $ resTd = mcrypt_module_open ( Config :: get ( 'encryptionCipher' ) , '' , Config :: get ( 'encryptionMode' ) , '' ) ) { throw new \ Exception ( 'Error initializing encryption module' ) ; } } 
public function checkPermission ( ) { switch ( Contao \ Input :: get ( 'act' ) ) { case 'select' : case 'show' : 
public function notifyOfReply ( Contao \ DataContainer $ dc ) { 
protected function isAllowedToEditComment ( $ intParent , $ strSource ) { if ( $ this -> User -> isAdmin ) { return true ; } $ strKey = __METHOD__ . '-' . $ strSource . '-' . $ intParent ; 
public function sendNotifications ( $ varValue ) { if ( $ varValue ) { Contao \ Comments :: notifyCommentsSubscribers ( Contao \ CommentsModel :: findByPk ( Contao \ Input :: get ( 'id' ) ) ) ; } return $ varValue ; } 
public function listComments ( $ arrRow ) { $ title = $ GLOBALS [ 'TL_LANG' ] [ 'tl_comments' ] [ $ arrRow [ 'source' ] ] . ' ' . $ arrRow [ 'parent' ] ; switch ( $ arrRow [ 'source' ] ) { case 'tl_content' : $ objParent = $ this -> Database -> prepare ( "SELECT id, title FROM tl_article WHERE id=(SELECT pid FROM tl_content WHERE id=?)" ) -> execute ( $ arrRow [ 'parent' ] ) ; if ( $ objParent -> numRows ) { $ title .= ' – <a href="contao/main.php?do=article&amp;table=tl_content&amp;id=' . $ b jParent-> id . ' amp;rt=' . R QUEST_TOKEN . ' >' . $ b jParent-> ti tle . ' /a>'; } break ; case 'tl_page' : $ objParent = $ this -> Database -> prepare ( "SELECT id, title FROM tl_page WHERE id=?" ) -> execute ( $ arrRow [ 'parent' ] ) ; if ( $ objParent -> numRows ) { $ title .= ' – <a href="contao/main.php?do=page&amp;act=edit&amp;id=' . $ b jParent-> id . ' amp;rt=' . R QUEST_TOKEN . ' >' . $ b jParent-> ti tle . ' /a>'; } break ; case 'tl_news' : $ objParent = $ this -> Database -> prepare ( "SELECT id, headline FROM tl_news WHERE id=?" ) -> execute ( $ arrRow [ 'parent' ] ) ; if ( $ objParent -> numRows ) { $ title .= ' – <a href="contao/main.php?do=news&amp;table=tl_news&amp;act=edit&amp;id=' . $ b jParent-> id . ' amp;rt=' . R QUEST_TOKEN . ' >' . $ b jParent-> he adline . ' /a>'; } break ; case 'tl_faq' : $ objParent = $ this -> Database -> prepare ( "SELECT id, question FROM tl_faq WHERE id=?" ) -> execute ( $ arrRow [ 'parent' ] ) ; if ( $ objParent -> numRows ) { $ title .= ' – <a href="contao/main.php?do=faq&amp;table=tl_faq&amp;act=edit&amp;id=' . $ b jParent-> id . ' amp;rt=' . R QUEST_TOKEN . ' >' . $ b jParent-> qu estion . ' /a>'; } break ; case 'tl_calendar_events' : $ objParent = $ this -> Database -> prepare ( "SELECT id, title FROM tl_calendar_events WHERE id=?" ) -> execute ( $ arrRow [ 'parent' ] ) ; if ( $ objParent -> numRows ) { $ title .= ' – <a href="contao/main.php?do=calendar&amp;table=tl_calendar_events&amp;act=edit&amp;id=' . $ b jParent-> id . ' amp;rt=' . R QUEST_TOKEN . ' >' . $ b jParent-> ti tle . ' /a>'; } break ; default : <div class="comment_wrap"> <div class="cte_type ' . $ key . '"><a href="mailto:' . Contao \ Idna :: decodeEmail ( $ arrRow [ 'email' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( Contao \ Idna :: decodeEmail ( $ arrRow [ 'email' ] ) ) . '">' . $ arrRow [ 'name' ] . '</a>' . ( ( $ arrRow [ 'website' ] != '' ) ? ' (<a href="' . $ arrRow [ 'website' ] . '" title="' . Contao \ StringUtil :: specialchars ( $ arrRow [ 'website' ] ) . '" target="_blank" rel="noreferrer noopener">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_website' ] . '</a>)' : '' ) . ' – ' . C ntao\D a te:: pa rse(C o ntao\C o nfig:: ge t(' d atimFormat'), $ r rRow[' d ate']) . ' – IP ' . C n ao\Str i ngUtil::sp ec ialchars($ar r R ow['ip ' ]) . ' b >' . $ i l e . ' / iv> <div class="limit_height mark_links' . ( ! Contao \ Config :: get ( 'doNotCollapse' ) ? ' h38' : '' ) . '"> ' . $ arrRow [ 'comment' ] . ' </div> </div>' . "\n " ; } 
public function editComment ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> isAllowedToEditComment ( $ row [ 'parent' ] , $ row [ 'source' ] ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg/i' , '_.svg' , $ icon ) ) . ' ' ; } 
public function invalidateSourceCacheTag ( Contao \ DataContainer $ dc , array $ tags ) { $ commentModel = Contao \ CommentsModel :: findByPk ( $ dc -> id ) ; if ( null !== $ commentModel ) { $ tags [ ] = sprintf ( 'contao.comments.%s.%s' , $ commentModel -> source , $ commentModel -> parent ) ; } return $ tags ; } 
public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoRequest ( $ event -> getRequest ( ) ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( '_locale' , $ this -> getLocale ( $ request ) ) ; } 
private function getLocale ( Request $ request ) : string { if ( null !== $ request -> attributes -> get ( '_locale' ) ) { return $ this -> formatLocaleId ( $ request -> attributes -> get ( '_locale' ) ) ; } return $ request -> getPreferredLanguage ( $ this -> availableLocales ) ; } 
public static function findByHashAndPid ( $ strHash , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findOneBy ( array ( "($t.hash=? AND $t.pid=?)" ) , array ( $ strHash , $ intPid ) , $ arrOptions ) ; } 
public function filter ( RouteCollection $ collection , Request $ request ) : RouteCollection { if ( $ this -> tokenChecker -> hasBackendUser ( ) && $ this -> tokenChecker -> isPreviewMode ( ) ) { return $ collection ; } foreach ( $ collection -> all ( ) as $ name => $ route ) { $ pageModel = $ route -> getDefault ( 'pageModel' ) ; if ( ! $ pageModel instanceof PageModel || $ pageModel -> rootIsPublic ) { continue ; } $ collection -> remove ( $ name ) ; } return $ collection ; } 
public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } 
public function showAll ( ) { $ return = '' ; $ this -> limit = '' ; $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ undoPeriod = ( int ) Config :: get ( 'undoPeriod' ) ; $ logPeriod = ( int ) Config :: get ( 'logPeriod' ) ; 
public function show ( ) { if ( ! \ strlen ( $ this -> intId ) ) { return '' ; } $ objRow = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; if ( $ objRow -> numRows < 1 ) { return '' ; } $ data = array ( ) ; $ row = $ objRow -> row ( ) ; <tr> <td colspan="2" style="height:1em"></td> </tr>' ; } $ separate = true ; $ index = 1 ; // Add the table name $ return .= ' <tr> <td class="tl_folder_top"><span class="tl_label">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'table' ] . ' </span></td> <td class="tl_folder_top">' . $ table . '</td> </tr> ' ; foreach ( $ entries as $ lbl => $ val ) { $ class = ( ( ++ $ index % 2 ) !== 0 ) ? ' class="tl_bg"' : '' ; // Always encode special characters (thanks to Oliver Klee) $ return .= ' <tr> <td' . $ class . '><span class="tl_label">' . $ lbl . ' </span></td> <td' . $ class . '>' . StringUtil :: specialchars ( $ val ) . '</td> </tr>' ; } } } // Return table return $ return . '</table>' ; } 
public function create ( $ set = array ( ) ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not creatable.' ) ; } 
public function cut ( $ blnDoNotRedirect = false ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notSortable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not sortable.' ) ; } $ cr = array ( ) ; 
public function copy ( $ blnDoNotRedirect = false ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not copyable.' ) ; } if ( ! $ this -> intId ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ objSessionBag = $ objSession -> getBag ( 'contao_backend' ) ; $ objRow = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; 
protected function copyChilds ( $ table , $ insertID , $ id , $ parentId ) { $ time = time ( ) ; $ copy = array ( ) ; $ cctable = array ( ) ; $ ctable = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'ctable' ] ; if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'ptable' ] && \ strlen ( Input :: get ( 'childs' ) ) && $ this -> Database -> fieldExists ( 'pid' , $ table ) && $ this -> Database -> fieldExists ( 'sorting' , $ table ) ) { $ ctable [ ] = $ table ; } if ( ! \ is_array ( $ ctable ) ) { return ; } 
public function copyAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not copyable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; if ( isset ( $ arrClipboard [ $ this -> strTable ] ) && \ is_array ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] ) ) { foreach ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] as $ id ) { $ this -> intId = $ id ; $ id = $ this -> copy ( true ) ; Input :: setGet ( 'pid' , $ id ) ; Input :: setGet ( 'mode' , 1 ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; } 
protected function getNewPosition ( $ mode , $ pid = null , $ insertInto = false ) { 
public function delete ( $ blnDoNotRedirect = false ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } if ( ! $ this -> intId ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ delete = array ( ) ; 
public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( \ is_array ( $ ids ) && \ strlen ( $ ids [ 0 ] ) ) { foreach ( $ ids as $ id ) { $ this -> intId = $ id ; $ this -> delete ( true ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; } 
public function deleteChilds ( $ table , $ id , & $ delete ) { $ cctable = array ( ) ; $ ctable = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'ctable' ] ; if ( ! \ is_array ( $ ctable ) ) { return ; } 
public function undo ( ) { $ objRecords = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; 
public function move ( ) { 
public function edit ( $ intId = null , $ ajaxId = null ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notEditable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not editable.' ) ; } if ( $ intId != '' ) { $ this -> intId = $ intId ; } </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> ' . $ strButtons . ' </div> </div> </form>' ; $ strVersionField = '' ; // Store the current version number (see #8412) if ( ( $ intLatestVersion = $ objVersions -> getLatestVersion ( ) ) !== null ) { $ strVersionField = ' <input type="hidden" name="VERSION_NUMBER" value="' . $ intLatestVersion . '">' ; } // Begin the form (-> DO NOT CHANGE THIS ORDER -> this way the onsubmit attribute of the form can be changed by a field) $ return = $ version . Message :: generate ( ) . ( $ this -> noReload ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] . '</p>' : '' ) . ' <div id="tl_buttons">' . ( Input :: get ( 'nb' ) ? '&nbsp;' : ' <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a>' ) . ' </div> <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="' . $ this -> strTable . '" class="tl_form tl_edit_form" method="post" enctype="' . ( $ this -> blnUploadable ? 'multipart/form-data' : 'application/x-www-form-urlencoded' ) . '"' . ( ! empty ( $ this -> onsubmit ) ? ' onsubmit="' . implode ( ' ' , $ this -> onsubmit ) . '"' : '' ) . '> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="' . $ this -> strTable . '"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' . $ strVersionField . ' <input type="hidden" name="FORM_FIELDS[]" value="' . StringUtil :: specialchars ( $ this -> strPalette ) . '">' . $ return ; // Reload the page to prevent _POST variables from being sent twice if ( Input :: post ( 'FORM_SUBMIT' ) == $ this -> strTable && ! $ this -> noReload ) { $ arrValues = $ this -> values ; array_unshift ( $ arrValues , time ( ) ) ; // Trigger the onsubmit_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onsubmit_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onsubmit_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ this ) ; } } } // Save the current version if ( $ this -> blnCreateNewVersion ) { $ objVersions -> create ( ) ; // Call the onversion_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onversion_callback' ] ) ) { @ trigger_error ( 'Using the onversion_callback has been deprecated and will no longer work in Contao 5.0. Use the oncreate_version_callback instead.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onversion_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> strTable , $ this -> intId , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ this -> strTable , $ this -> intId , $ this ) ; } } } } // Set the current timestamp (-> DO NOT CHANGE THE ORDER version - timestamp) if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'dynamicPtable' ] ) { $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET ptable=?, tstamp=? WHERE id=?" ) -> execute ( $ this -> ptable , time ( ) , $ this -> intId ) ; } else { $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET tstamp=? WHERE id=?" ) -> execute ( time ( ) , $ this -> intId ) ; } // Show a warning if the record has been saved by another user (see #8412) if ( $ intLatestVersion !== null && isset ( $ _POST [ 'VERSION_NUMBER' ] ) && $ intLatestVersion > Input :: post ( 'VERSION_NUMBER' ) ) { $ objTemplate = new BackendTemplate ( 'be_conflict' ) ; $ objTemplate -> language = $ GLOBALS [ 'TL_LANGUAGE' ] ; $ objTemplate -> title = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versionConflict' ] ) ; $ objTemplate -> theme = Backend :: getTheme ( ) ; $ objTemplate -> charset = Config :: get ( 'characterSet' ) ; $ objTemplate -> base = Environment :: get ( 'base' ) ; $ objTemplate -> h1 = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versionConflict' ] ; $ objTemplate -> explain1 = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versionConflict1' ] , $ intLatestVersion , Input :: post ( 'VERSION_NUMBER' ) ) ; $ objTemplate -> explain2 = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versionConflict2' ] , $ intLatestVersion + 1 , $ intLatestVersion ) ; $ objTemplate -> diff = $ objVersions -> compare ( true ) ; $ objTemplate -> href = Environment :: get ( 'request' ) ; $ objTemplate -> button = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'continue' ] ; throw new ResponseException ( $ objTemplate -> getResponse ( ) ) ; } // Invalidate cache tags $ this -> invalidateCacheTags ( $ this ) ; // Redirect if ( isset ( $ _POST [ 'saveNclose' ] ) ) { Message :: reset ( ) ; System :: setCookie ( 'BE_PAGE_OFFSET' , 0 , 0 ) ; $ this -> redirect ( $ this -> getReferer ( ) ) ; } elseif ( isset ( $ _POST [ 'saveNedit' ] ) ) { Message :: reset ( ) ; System :: setCookie ( 'BE_PAGE_OFFSET' , 0 , 0 ) ; $ this -> redirect ( $ this -> addToUrl ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'operations' ] [ 'edit' ] [ 'href' ] , false , array ( 's2e' , 'act' , 'mode' , 'pid' ) ) ) ; } elseif ( isset ( $ _POST [ 'saveNback' ] ) ) { Message :: reset ( ) ; System :: setCookie ( 'BE_PAGE_OFFSET' , 0 , 0 ) ; if ( $ this -> ptable == '' ) { $ this -> redirect ( TL_SCRIPT . '?do=' . Input :: get ( 'do' ) ) ; } // TODO: try to abstract this elseif ( ( $ this -> ptable == 'tl_theme' && $ this -> strTable == 'tl_style_sheet' ) || ( $ this -> ptable == 'tl_page' && $ this -> strTable == 'tl_article' ) ) { $ this -> redirect ( $ this -> getReferer ( false , $ this -> strTable ) ) ; } else { $ this -> redirect ( $ this -> getReferer ( false , $ this -> ptable ) ) ; } } elseif ( isset ( $ _POST [ 'saveNcreate' ] ) ) { Message :: reset ( ) ; System :: setCookie ( 'BE_PAGE_OFFSET' , 0 , 0 ) ; $ strUrl = TL_SCRIPT . '?do=' . Input :: get ( 'do' ) ; if ( isset ( $ _GET [ 'table' ] ) ) { $ strUrl .= '&amp;table=' . Input :: get ( 'table' ) ; } // Tree view if ( $ this -> treeView ) { $ strUrl .= '&amp;act=create&amp;mode=1&amp;pid=' . $ this -> intId ; } // Parent view elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) { $ strUrl .= $ this -> Database -> fieldExists ( 'sorting' , $ this -> strTable ) ? '&amp;act=create&amp;mode=1&amp;pid=' . $ this -> intId : '&amp;act=create&amp;mode=2&amp;pid=' . $ this -> activeRecord -> pid ; } // List view else { $ strUrl .= ( $ this -> ptable != '' ) ? '&amp;act=create&amp;mode=2&amp;pid=' . CURRENT_ID : '&amp;act=create' ; } $ this -> redirect ( $ strUrl . '&amp;rt=' . REQUEST_TOKEN ) ; } elseif ( isset ( $ _POST [ 'saveNduplicate' ] ) ) { Message :: reset ( ) ; System :: setCookie ( 'BE_PAGE_OFFSET' , 0 , 0 ) ; $ strUrl = TL_SCRIPT . '?do=' . Input :: get ( 'do' ) ; if ( isset ( $ _GET [ 'table' ] ) ) { $ strUrl .= '&amp;table=' . Input :: get ( 'table' ) ; } // Tree view if ( $ this -> treeView ) { $ strUrl .= '&amp;act=copy&amp;mode=1&amp;id=' . $ this -> intId . '&amp;pid=' . $ this -> intId ; } // Parent view elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) { $ strUrl .= $ this -> Database -> fieldExists ( 'sorting' , $ this -> strTable ) ? '&amp;act=copy&amp;mode=1&amp;pid=' . $ this -> intId . '&amp;id=' . $ this -> intId : '&amp;act=copy&amp;mode=2&amp;pid=' . CURRENT_ID . '&amp;id=' . $ this -> intId ; } // List view else { $ strUrl .= ( $ this -> ptable != '' ) ? '&amp;act=copy&amp;mode=2&amp;pid=' . CURRENT_ID . '&amp;id=' . CURRENT_ID : '&amp;act=copy&amp;id=' . CURRENT_ID ; } $ this -> redirect ( $ strUrl . '&amp;rt=' . REQUEST_TOKEN ) ; } $ this -> reload ( ) ; } // Set the focus if there is an error if ( $ this -> noReload ) { $ return .= ' <script> window.addEvent(\'domready\', function() { Backend.vScrollTo(($(\'' . $ this -> strTable . '\').getElement(\'label.error\').getPosition().y - 20)); }); </script>' ; } return $ return ; } 
public function editAll ( $ intId = null , $ ajaxId = null ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notEditable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not editable.' ) ; } $ return = '' ; $ this -> import ( BackendUser :: class , 'User' ) ; $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; <div class="' . $ class . ' cf">' ; $ class = 'tl_box' ; $ formFields = array ( ) ; // Get the field values $ objRow = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; // Store the active record $ this -> objActiveRecord = $ objRow ; foreach ( $ this -> strPalette as $ v ) { // Check whether field is excluded if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ v ] [ 'exclude' ] ) { continue ; } if ( $ v == '[EOF]' ) { if ( $ blnAjax && Environment :: get ( 'isAjaxRequest' ) ) { return $ strAjax . '<input type="hidden" name="FORM_FIELDS_' . $ id . '[]" value="' . StringUtil :: specialchars ( implode ( ',' , $ formFields ) ) . '">' ; } $ blnAjax = false ; $ return .= "\n " . '</div>' ; continue ; } if ( preg_match ( '/^\[.*\]$/' , $ v ) ) { $ thisId = 'sub_' . substr ( $ v , 1 , - 1 ) . '_' . $ id ; $ blnAjax = ( $ ajaxId == $ thisId && Environment :: get ( 'isAjaxRequest' ) ) ? true : false ; $ return .= "\n " . '<div id="' . $ thisId . '" class="subpal cf">' ; continue ; } if ( ! \ in_array ( $ v , $ fields ) ) { continue ; } $ this -> strField = $ v ; $ this -> strInputName = $ v . '_' . $ this -> intId ; $ formFields [ ] = $ v . '_' . $ this -> intId ; // Set the default value and try to load the current value from DB (see #5252) if ( \ array_key_exists ( 'default' , $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] ) ) { $ this -> varValue = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'default' ] ) ? serialize ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'default' ] ) : $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'default' ] ; } if ( $ objRow -> $ v !== false ) { $ this -> varValue = $ objRow -> $ v ; } // Convert CSV fields (see #2890) if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'eval' ] [ 'multiple' ] && isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'eval' ] [ 'csv' ] ) ) { $ this -> varValue = StringUtil :: trimsplit ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'eval' ] [ 'csv' ] , $ this -> varValue ) ; } // Call load_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'load_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'load_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> varValue = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> varValue , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ this -> varValue = $ callback ( $ this -> varValue , $ this ) ; } } } // Re-set the current value $ this -> objActiveRecord -> { $ this -> strField } = $ this -> varValue ; // Build the row and pass the current palette string (thanks to Tristan Lins) $ blnAjax ? $ strAjax .= $ this -> row ( $ this -> strPalette ) : $ return .= $ this -> row ( $ this -> strPalette ) ; } // Close box $ return .= ' <input type="hidden" name="FORM_FIELDS_' . $ this -> intId . '[]" value="' . StringUtil :: specialchars ( implode ( ',' , $ formFields ) ) . '"> </div>' ; // Save record if ( Input :: post ( 'FORM_SUBMIT' ) == $ this -> strTable && ! $ this -> noReload ) { // Call the onsubmit_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onsubmit_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onsubmit_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ this ) ; } } } // Create a new version if ( $ this -> blnCreateNewVersion ) { $ objVersions -> create ( ) ; // Call the onversion_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onversion_callback' ] ) ) { @ trigger_error ( 'Using the onversion_callback has been deprecated and will no longer work in Contao 5.0. Use the oncreate_version_callback instead.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'onversion_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> strTable , $ this -> intId , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ this -> strTable , $ this -> intId , $ this ) ; } } } } // Set the current timestamp (-> DO NOT CHANGE ORDER version - timestamp) if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'dynamicPtable' ] ) { $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET ptable=?, tstamp=? WHERE id=?" ) -> execute ( $ this -> ptable , time ( ) , $ this -> intId ) ; } else { $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET tstamp=? WHERE id=?" ) -> execute ( time ( ) , $ this -> intId ) ; } } } // Submit buttons $ arrButtons = array ( ) ; $ arrButtons [ 'save' ] = '<button type="submit" name="save" id="save" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'save' ] . '</button>' ; $ arrButtons [ 'saveNclose' ] = '<button type="submit" name="saveNclose" id="saveNclose" class="tl_submit" accesskey="c">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'saveNclose' ] . '</button>' ; // Call the buttons_callback (see #4691) if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'edit' ] [ 'buttons_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'edit' ] [ 'buttons_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ arrButtons = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ arrButtons , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ arrButtons = $ callback ( $ arrButtons , $ this ) ; } } } if ( \ count ( $ arrButtons ) < 3 ) { $ strButtons = implode ( ' ' , $ arrButtons ) ; } else { $ strButtons = array_shift ( $ arrButtons ) . ' ' ; $ strButtons .= '<div class="split-button">' ; $ strButtons .= array_shift ( $ arrButtons ) . '<button type="button" id="sbtog">' . Image :: getHtml ( 'navcol.svg' ) . '</button> <ul class="invisible">' ; foreach ( $ arrButtons as $ strButton ) { $ strButtons .= '<li>' . $ strButton . '</li>' ; } $ strButtons .= '</ul></div>' ; } // Add the form $ return = ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="' . $ this -> strTable . '" class="tl_form tl_edit_form" method="post" enctype="' . ( $ this -> blnUploadable ? 'multipart/form-data' : 'application/x-www-form-urlencoded' ) . '"> <div class="tl_formbody_edit nogrid"> <input type="hidden" name="FORM_SUBMIT" value="' . $ this -> strTable . '"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' . ( $ this -> noReload ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] . '</p>' : '' ) . $ return . ' </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> ' . $ strButtons . ' </div> </div> </form>' ; // Set the focus if there is an error if ( $ this -> noReload ) { $ return .= ' <script> window.addEvent(\'domready\', function() { Backend.vScrollTo(($(\'' . $ this -> strTable . '\').getElement(\'label.error\').getPosition().y - 20)); }); </script>' ; } // Reload the page to prevent _POST variables from being sent twice if ( Input :: post ( 'FORM_SUBMIT' ) == $ this -> strTable && ! $ this -> noReload ) { if ( isset ( $ _POST [ 'saveNclose' ] ) ) { System :: setCookie ( 'BE_PAGE_OFFSET' , 0 , 0 ) ; $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ this -> reload ( ) ; } } // Else show a form to select the fields else { $ options = '' ; $ fields = array ( ) ; // Add fields of the current table $ fields = array_merge ( $ fields , array_keys ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] ) ) ; // Add meta fields if the current user is an administrator if ( $ this -> User -> isAdmin ) { if ( $ this -> Database -> fieldExists ( 'sorting' , $ this -> strTable ) && ! \ in_array ( 'sorting' , $ fields ) ) { array_unshift ( $ fields , 'sorting' ) ; } if ( $ this -> Database -> fieldExists ( 'pid' , $ this -> strTable ) && ! \ in_array ( 'pid' , $ fields ) ) { array_unshift ( $ fields , 'pid' ) ; } } // Show all non-excluded fields foreach ( $ fields as $ field ) { if ( $ field == 'pid' || $ field == 'sorting' || ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'exclude' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'eval' ] [ 'doNotShow' ] && ( \ strlen ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'inputType' ] ) || \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'input_field_callback' ] ) || \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'input_field_callback' ] ) ) ) ) { $ options .= ' <input type="checkbox" name="all_fields[]" id="all_' . $ field . '" class="tl_checkbox" value="' . StringUtil :: specialchars ( $ field ) . '"> <label for="all_' . $ field . '" class="tl_checkbox_label">' . ( ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'label' ] [ 0 ] ? : ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ field ] [ 0 ] ? : $ field ) ) . ' <span style="color:#999;padding-left:3px">[' . $ field . ']</span>' ) . '</label><br>' ; } } $ blnIsError = ( $ _POST && empty ( $ _POST [ 'all_fields' ] ) ) ; // Return the select menu $ return .= ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '&amp;fields=1" id="' . $ this -> strTable . '_all" class="tl_form tl_edit_form" method="post"> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="' . $ this -> strTable . '_all"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' . ( $ blnIsError ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] . '</p>' : '' ) . ' <div class="tl_tbox"> <div class="widget"> <fieldset class="tl_checkbox_container"> <legend' . ( $ blnIsError ? ' class="error"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'all_fields' ] [ 0 ] . '<span class="mandatory">*</span></legend> <input type="checkbox" id="check_all" class="tl_checkbox" onclick="Backend.toggleCheckboxes(this)"> <label for="check_all" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label><br>' . $ options . ' </fieldset>' . ( $ blnIsError ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'all_fields' ] . '</p>' : ( ( Config :: get ( 'showHelp' ) && \ strlen ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'all_fields' ] [ 1 ] ) ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'all_fields' ] [ 1 ] . '</p>' : '' ) ) . ' </div> </div> </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> <button type="submit" name="save" id="save" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'continue' ] . '</button> </div> </div> </form>' ; } // Return return ' <div id="tl_buttons"> <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div>' . $ return ; } 
public function overrideAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notEditable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not editable.' ) ; } $ return = '' ; $ this -> import ( BackendUser :: class , 'User' ) ; $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; <div class="' . $ class . '">' ; foreach ( $ fields as $ v ) { // Check whether field is excluded if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ v ] [ 'exclude' ] ) { continue ; } $ formFields [ ] = $ v ; $ this -> intId = 0 ; $ this -> procedure = array ( 'id=?' ) ; $ this -> values = array ( $ this -> intId ) ; $ this -> strField = $ v ; $ this -> strInputName = $ v ; $ this -> varValue = '' ; // Disable auto-submit $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'eval' ] [ 'submitOnChange' ] = false ; $ return .= $ this -> row ( ) ; } // Close box $ return .= ' <input type="hidden" name="FORM_FIELDS[]" value="' . StringUtil :: specialchars ( implode ( ',' , $ formFields ) ) . '"> </div>' ; // Submit buttons $ arrButtons = array ( ) ; $ arrButtons [ 'save' ] = '<button type="submit" name="save" id="save" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'save' ] . '</button>' ; $ arrButtons [ 'saveNclose' ] = '<button type="submit" name="saveNclose" id="saveNclose" class="tl_submit" accesskey="c">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'saveNclose' ] . '</button>' ; // Call the buttons_callback (see #4691) if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'edit' ] [ 'buttons_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'edit' ] [ 'buttons_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ arrButtons = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ arrButtons , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ arrButtons = $ callback ( $ arrButtons , $ this ) ; } } } if ( \ count ( $ arrButtons ) < 3 ) { $ strButtons = implode ( ' ' , $ arrButtons ) ; } else { $ strButtons = array_shift ( $ arrButtons ) . ' ' ; $ strButtons .= '<div class="split-button">' ; $ strButtons .= array_shift ( $ arrButtons ) . '<button type="button" id="sbtog">' . Image :: getHtml ( 'navcol.svg' ) . '</button> <ul class="invisible">' ; foreach ( $ arrButtons as $ strButton ) { $ strButtons .= '<li>' . $ strButton . '</li>' ; } $ strButtons .= '</ul></div>' ; } // Add the form $ return = ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="' . $ this -> strTable . '" class="tl_form tl_edit_form" method="post" enctype="' . ( $ this -> blnUploadable ? 'multipart/form-data' : 'application/x-www-form-urlencoded' ) . '"> <div class="tl_formbody_edit nogrid"> <input type="hidden" name="FORM_SUBMIT" value="' . $ this -> strTable . '"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' . ( $ this -> noReload ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] . '</p>' : '' ) . $ return . ' </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> ' . $ strButtons . ' </div> </div> </form>' ; // Set the focus if there is an error if ( $ this -> noReload ) { $ return .= ' <script> window.addEvent(\'domready\', function() { Backend.vScrollTo(($(\'' . $ this -> strTable . '\').getElement(\'label.error\').getPosition().y - 20)); }); </script>' ; } // Reload the page to prevent _POST variables from being sent twice if ( Input :: post ( 'FORM_SUBMIT' ) == $ this -> strTable && ! $ this -> noReload ) { if ( isset ( $ _POST [ 'saveNclose' ] ) ) { System :: setCookie ( 'BE_PAGE_OFFSET' , 0 , 0 ) ; $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ this -> reload ( ) ; } } // Else show a form to select the fields else { $ options = '' ; $ fields = array ( ) ; // Add fields of the current table $ fields = array_merge ( $ fields , array_keys ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] ) ) ; // Add meta fields if the current user is an administrator if ( $ this -> User -> isAdmin ) { if ( $ this -> Database -> fieldExists ( 'sorting' , $ this -> strTable ) && ! \ in_array ( 'sorting' , $ fields ) ) { array_unshift ( $ fields , 'sorting' ) ; } if ( $ this -> Database -> fieldExists ( 'pid' , $ this -> strTable ) && ! \ in_array ( 'pid' , $ fields ) ) { array_unshift ( $ fields , 'pid' ) ; } } // Show all non-excluded fields foreach ( $ fields as $ field ) { if ( $ field == 'pid' || $ field == 'sorting' || ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'exclude' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'eval' ] [ 'doNotShow' ] && ( \ strlen ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'inputType' ] ) || \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'input_field_callback' ] ) || \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'input_field_callback' ] ) ) ) ) { $ options .= ' <input type="checkbox" name="all_fields[]" id="all_' . $ field . '" class="tl_checkbox" value="' . StringUtil :: specialchars ( $ field ) . '"> <label for="all_' . $ field . '" class="tl_checkbox_label">' . ( ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'label' ] [ 0 ] ? : ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ field ] [ 0 ] ? : $ field ) ) . ' <span style="color:#999;padding-left:3px">[' . $ field . ']</span>' ) . '</label><br>' ; } } $ blnIsError = ( $ _POST && empty ( $ _POST [ 'all_fields' ] ) ) ; // Return the select menu $ return .= ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '&amp;fields=1" id="' . $ this -> strTable . '_all" class="tl_form tl_edit_form" method="post"> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="' . $ this -> strTable . '_all"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' . ( $ blnIsError ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] . '</p>' : '' ) . ' <div class="tl_tbox"> <div class="widget"> <fieldset class="tl_checkbox_container"> <legend' . ( $ blnIsError ? ' class="error"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'all_fields' ] [ 0 ] . '<span class="mandatory">*</span></legend> <input type="checkbox" id="check_all" class="tl_checkbox" onclick="Backend.toggleCheckboxes(this)"> <label for="check_all" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label><br>' . $ options . ' </fieldset>' . ( $ blnIsError ? ' <p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'all_fields' ] . '</p>' : ( ( Config :: get ( 'showHelp' ) && \ strlen ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'all_fields' ] [ 1 ] ) ) ? ' <p class="tl_help tl_tip">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'all_fields' ] [ 1 ] . '</p>' : '' ) ) . ' </div> </div> </div> <div class="tl_formbody_submit"> <div class="tl_submit_container"> <button type="submit" name="save" id="save" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'continue' ] . '</button> </div> </div> </form>' ; } // Return return ' <div id="tl_buttons"> <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> </div>' . $ return ; } 
protected function save ( $ varValue ) { if ( Input :: post ( 'FORM_SUBMIT' ) != $ this -> strTable ) { return ; } $ arrData = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] ; 
public function getPalette ( ) { $ palette = 'default' ; $ strPalette = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'palettes' ] [ $ palette ] ; 
protected function reviseTable ( ) { $ reload = false ; $ ptable = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ptable' ] ; $ ctable = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ctable' ] ; $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ new_records = $ objSessionBag -> get ( 'new_records' ) ; 
protected function treeView ( ) { $ table = $ this -> strTable ; $ treeClass = 'tl_tree' ; if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 6 ) { $ table = $ this -> ptable ; $ treeClass = 'tl_tree_xtnd' ; System :: loadLanguageFile ( $ table ) ; $ this -> loadDataContainer ( $ table ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ objSessionBag = $ objSession -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; <p class="tl_empty">Table "' . $ table . '" can not be shown as tree, because the "id", "pid" or "sorting" field is missing!</p>' ; } // Return if there is no parent table if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 6 && ! \ strlen ( $ this -> ptable ) ) { return ' <p class="tl_empty">Table "' . $ table . '" can not be shown as extended tree, because there is no parent table!</p>' ; } $ blnClipboard = false ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; // Check the clipboard if ( ! empty ( $ arrClipboard [ $ this -> strTable ] ) ) { $ blnClipboard = true ; $ arrClipboard = $ arrClipboard [ $ this -> strTable ] ; } if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'label' ] ) ) { $ label = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'label' ] ; } elseif ( ( $ do = Input :: get ( 'do' ) ) && isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ do ] ) ) { $ label = $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ do ] [ 0 ] ; } else { $ label = $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ 'page' ] [ 0 ] ; } $ icon = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'list' ] [ 'sorting' ] [ 'icon' ] ? : 'pagemounts.svg' ; $ label = Image :: getHtml ( $ icon ) . ' <label>' . $ label . '</label>' ; // Begin buttons container $ return = Message :: generate ( ) . ' <div id="tl_buttons">' . ( ( Input :: get ( 'act' ) == 'select' ) ? ' <a href="' . $ this -> getReferer ( true ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> ' : ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'backlink' ] ) ? ' <a href="contao/main.php?' . $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'backlink' ] . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> ' : '' ) ) . ( ( Input :: get ( 'act' ) != 'select' && ! $ blnClipboard && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'closed' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] ) ? ' <a href="' . $ this -> addToUrl ( 'act=paste&amp;mode=create' ) . '" class="header_new" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'new' ] [ 1 ] ) . '" accesskey="n" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'new' ] [ 0 ] . '</a> ' : '' ) . ( $ blnClipboard ? ' <a href="' . $ this -> addToUrl ( 'clipboard=1' ) . '" class="header_clipboard" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'clearClipboard' ] ) . '" accesskey="x">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'clearClipboard' ] . '</a> ' : $ this -> generateGlobalButtons ( ) ) . ' </div>' ; $ tree = '' ; $ blnHasSorting = $ this -> Database -> fieldExists ( 'sorting' , $ table ) ; $ arrFound = array ( ) ; if ( ! empty ( $ this -> procedure ) ) { $ fld = ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 6 ) ? 'pid' : 'id' ; if ( $ fld == 'id' ) { $ objRoot = $ this -> Database -> prepare ( "SELECT id FROM " . $ this -> strTable . " WHERE " . implode ( ' AND ' , $ this -> procedure ) . ( $ blnHasSorting ? " ORDER BY sorting" : "" ) ) -> execute ( $ this -> values ) ; } elseif ( $ blnHasSorting ) { $ objRoot = $ this -> Database -> prepare ( "SELECT pid, (SELECT sorting FROM " . $ table . " WHERE " . $ this -> strTable . ".pid=" . $ table . ".id) AS psort FROM " . $ this -> strTable . " WHERE " . implode ( ' AND ' , $ this -> procedure ) . " GROUP BY pid" . ( $ blnHasSorting ? " ORDER BY psort" : "" ) ) -> execute ( $ this -> values ) ; } else { $ objRoot = $ this -> Database -> prepare ( "SELECT pid FROM " . $ this -> strTable . " WHERE " . implode ( ' AND ' , $ this -> procedure ) . " GROUP BY pid" ) -> execute ( $ this -> values ) ; } if ( $ objRoot -> numRows < 1 ) { $ this -> root = array ( ) ; } else { // Respect existing limitations (root IDs) if ( ! empty ( $ this -> root ) ) { $ arrRoot = array ( ) ; while ( $ objRoot -> next ( ) ) { if ( \ count ( array_intersect ( $ this -> root , $ this -> Database -> getParentRecords ( $ objRoot -> $ fld , $ table ) ) ) > 0 ) { $ arrRoot [ ] = $ objRoot -> $ fld ; } } $ arrFound = $ arrRoot ; $ this -> root = $ this -> eliminateNestedPages ( $ arrFound , $ table , $ blnHasSorting ) ; } else { $ arrFound = $ objRoot -> fetchEach ( $ fld ) ; $ this -> root = $ this -> eliminateNestedPages ( $ arrFound , $ table , $ blnHasSorting ) ; } } } // Call a recursive function that builds the tree if ( \ is_array ( $ this -> root ) ) { for ( $ i = 0 , $ c = \ count ( $ this -> root ) ; $ i < $ c ; $ i ++ ) { $ tree .= $ this -> generateTree ( $ table , $ this -> root [ $ i ] , array ( 'p' => $ this -> root [ ( $ i - 1 ) ] , 'n' => $ this -> root [ ( $ i + 1 ) ] ) , $ blnHasSorting , - 20 , ( $ blnClipboard ? $ arrClipboard : false ) , ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 5 && $ blnClipboard && $ this -> root [ $ i ] == $ arrClipboard [ 'id' ] ) , false , false , $ arrFound ) ; } } // Return if there are no records if ( $ tree == '' && Input :: get ( 'act' ) != 'paste' ) { return $ return . ' <p class="tl_empty">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'noResult' ] . '</p>' ; } $ return .= ( ( Input :: get ( 'act' ) == 'select' ) ? ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_select" class="tl_form' . ( ( Input :: get ( 'act' ) == 'select' ) ? ' unselectable' : '' ) . '" method="post" novalidate> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="tl_select"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' : '' ) . ( $ blnClipboard ? ' <div id="paste_hint"> <p>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectNewPosition' ] . '</p> </div>' : '' ) . ' <div class="tl_listing_container tree_view" id="tl_listing">' . ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'list' ] [ 'sorting' ] [ 'breadcrumb' ] ?? '' ) . ( ( Input :: get ( 'act' ) == 'select' || ( $ this -> strPickerFieldType == 'checkbox' ) ) ? ' <div class="tl_select_trigger"> <label for="tl_select_trigger" class="tl_select_label">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</label> <input type="checkbox" id="tl_select_trigger" onclick="Backend.toggleCheckboxes(this)" class="tl_tree_checkbox"> </div>' : '' ) . ' <ul class="tl_listing ' . $ treeClass . ( $ this -> strPickerFieldType ? ' picker unselectable' : '' ) . '"> <li class="tl_folder_top cf"><div class="tl_left">' . $ label . '</div> <div class="tl_right">' ; $ _buttons = '&nbsp;' ; // Show paste button only if there are no root records specified if ( Input :: get ( 'act' ) != 'select' && $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 5 && $ blnClipboard && ( ( empty ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'list' ] [ 'sorting' ] [ 'root' ] ) && $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'list' ] [ 'sorting' ] [ 'root' ] !== false ) || $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'list' ] [ 'sorting' ] [ 'rootPaste' ] ) ) { // Call paste_button_callback (&$dc, $row, $table, $cr, $childs, $previous, $next) if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'paste_button_callback' ] ) ) { $ strClass = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'paste_button_callback' ] [ 0 ] ; $ strMethod = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'paste_button_callback' ] [ 1 ] ; $ this -> import ( $ strClass ) ; $ _buttons = $ this -> $ strClass -> $ strMethod ( $ this , array ( 'id' => 0 ) , $ table , false , $ arrClipboard ) ; } elseif ( \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'paste_button_callback' ] ) ) { $ _buttons = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'paste_button_callback' ] ( $ this , array ( 'id' => 0 ) , $ table , false , $ arrClipboard ) ; } else { $ imagePasteInto = Image :: getHtml ( 'pasteinto.svg' , $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pasteinto' ] [ 0 ] ) ; $ _buttons = '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=2&amp;pid=0' . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pasteinto' ] [ 0 ] ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteInto . '</a> ' ; } } // End table $ return .= $ _buttons . '</div></li>' . $ tree . ' </ul>' . ( $ this -> strPickerFieldType == 'radio' ? ' <div class="tl_radio_reset"> <label for="tl_radio_reset" class="tl_radio_label">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resetSelected' ] . '</label> <input type="radio" name="picker" id="tl_radio_reset" value="" class="tl_tree_radio"> </div>' : '' ) . ' </div>' ; // Close the form if ( Input :: get ( 'act' ) == 'select' ) { // Submit buttons $ arrButtons = array ( ) ; if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notEditable' ] ) { $ arrButtons [ 'edit' ] = '<button type="submit" name="edit" id="edit" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editSelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { $ arrButtons [ 'delete' ] = '<button type="submit" name="delete" id="delete" class="tl_submit" accesskey="d" onclick="return confirm(\'' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'delAllConfirm' ] . '\')">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'deleteSelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { $ arrButtons [ 'copy' ] = '<button type="submit" name="copy" id="copy" class="tl_submit" accesskey="c">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'copySelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notSortable' ] ) { $ arrButtons [ 'cut' ] = '<button type="submit" name="cut" id="cut" class="tl_submit" accesskey="x">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'moveSelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notEditable' ] ) { $ arrButtons [ 'override' ] = '<button type="submit" name="override" id="override" class="tl_submit" accesskey="v">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'overrideSelected' ] . '</button>' ; } // Call the buttons_callback (see #4691) if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'select' ] [ 'buttons_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'select' ] [ 'buttons_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ arrButtons = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ arrButtons , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ arrButtons = $ callback ( $ arrButtons , $ this ) ; } } } if ( \ count ( $ arrButtons ) < 3 ) { $ strButtons = implode ( ' ' , $ arrButtons ) ; } else { $ strButtons = array_shift ( $ arrButtons ) . ' ' ; $ strButtons .= '<div class="split-button">' ; $ strButtons .= array_shift ( $ arrButtons ) . '<button type="button" id="sbtog">' . Image :: getHtml ( 'navcol.svg' ) . '</button> <ul class="invisible">' ; foreach ( $ arrButtons as $ strButton ) { $ strButtons .= '<li>' . $ strButton . '</li>' ; } $ strButtons .= '</ul></div>' ; } $ return .= ' </div> <div class="tl_formbody_submit" style="text-align:right"> <div class="tl_submit_container"> ' . $ strButtons . ' </div> </div> </form>' ; } return $ return ; } 
public function ajaxTreeView ( $ id , $ level ) { if ( ! Environment :: get ( 'isAjaxRequest' ) ) { return '' ; } $ return = '' ; $ table = $ this -> strTable ; $ blnPtable = false ; 
protected function generateTree ( $ table , $ id , $ arrPrevNext , $ blnHasSorting , $ intMargin = 0 , $ arrClipboard = null , $ blnCircularReference = false , $ protectedPage = false , $ blnNoRecursion = false , $ arrFound = array ( ) ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; $ node = ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 6 ) ? $ this -> strTable . '_' . $ table . '_tree' : $ this -> strTable . '_tree' ; 
protected function parentView ( ) { $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ blnClipboard = false ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; $ table = ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 6 ) ? $ this -> ptable : $ this -> strTable ; $ blnHasSorting = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'fields' ] [ 0 ] == 'sorting' ; $ blnMultiboard = false ; <div id="tl_buttons">' . ( Input :: get ( 'nb' ) ? '&nbsp;' : ( $ this -> ptable ? ' <a href="' . $ this -> getReferer ( true , $ this -> ptable ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a>' : ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'backlink' ] ) ? ' <a href="contao/main.php?' . $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'backlink' ] . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a>' : '' ) ) ) . ' ' . ( ( Input :: get ( 'act' ) != 'select' && ! $ blnClipboard && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'closed' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] ) ? ' <a href="' . $ this -> addToUrl ( ( $ blnHasSorting ? 'act=paste&amp;mode=create' : 'act=create&amp;mode=2&amp;pid=' . $ this -> intId ) ) . '" class="header_new" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'new' ] [ 1 ] ) . '" accesskey="n" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'new' ] [ 0 ] . '</a> ' : '' ) . ( $ blnClipboard ? ' <a href="' . $ this -> addToUrl ( 'clipboard=1' ) . '" class="header_clipboard" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'clearClipboard' ] ) . '" accesskey="x">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'clearClipboard' ] . '</a> ' : $ this -> generateGlobalButtons ( ) ) . ' </div>' ; // Get all details of the parent record $ objParent = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> ptable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( CURRENT_ID ) ; if ( $ objParent -> numRows < 1 ) { return $ return ; } $ return .= ( ( Input :: get ( 'act' ) == 'select' ) ? ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_select" class="tl_form' . ( ( Input :: get ( 'act' ) == 'select' ) ? ' unselectable' : '' ) . '" method="post" novalidate> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="tl_select"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' : '' ) . ( $ blnClipboard ? ' <div id="paste_hint"> <p>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectNewPosition' ] . '</p> </div>' : '' ) . ' <div class="tl_listing_container parent_view' . ( $ this -> strPickerFieldType ? ' picker unselectable' : '' ) . '" id="tl_listing"> <div class="tl_header click2edit toggle_select hover-div">' ; // List all records of the child table if ( ! Input :: get ( 'act' ) || Input :: get ( 'act' ) == 'paste' || Input :: get ( 'act' ) == 'select' ) { $ this -> import ( BackendUser :: class , 'User' ) ; // Header $ imagePasteNew = Image :: getHtml ( 'new.svg' , $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pastenew' ] [ 0 ] ) ; $ imagePasteAfter = Image :: getHtml ( 'pasteafter.svg' , $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pasteafter' ] [ 0 ] ) ; $ imageEditHeader = Image :: getHtml ( 'header.svg' , $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'editheader' ] [ 0 ] ) ; $ return .= ' <div class="tl_content_right">' . ( ( Input :: get ( 'act' ) == 'select' || $ this -> strPickerFieldType == 'checkbox' ) ? ' <label for="tl_select_trigger" class="tl_select_label">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</label> <input type="checkbox" id="tl_select_trigger" onclick="Backend.toggleCheckboxes(this)" class="tl_tree_checkbox">' : ( $ blnClipboard ? ' <a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=2&amp;pid=' . $ objParent -> id . ( ! $ blnMultiboard ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pasteafter' ] [ 0 ] ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteAfter . '</a>' : ( ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'config' ] [ 'notEditable' ] && $ this -> User -> canEditFieldsOf ( $ this -> ptable ) ) ? ' <a href="' . preg_replace ( '/&(amp;)?table=[^& ]*/i' , ( ( $ this -> ptable != '' ) ? '&amp;table=' . $ this -> ptable : '' ) , $ this -> addToUrl ( 'act=edit' . ( Input :: get ( 'nb' ) ? '&amp;nc=1' : '' ) ) ) . '" class="edit" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> ptable ] [ 'editmeta' ] [ 1 ] ?? $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'editheader' ] [ 1 ] ) . '">' . $ imageEditHeader . '</a> ' . $ this -> generateHeaderButtons ( $ objParent -> row ( ) , $ this -> ptable ) : '' ) . ( ( $ blnHasSorting && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'closed' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] ) ? ' <a href="' . $ this -> addToUrl ( 'act=create&amp;mode=2&amp;pid=' . $ objParent -> id . '&amp;id=' . $ this -> intId ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pastenew' ] [ 0 ] ) . '">' . $ imagePasteNew . '</a>' : '' ) ) ) . ' </div>' ; // Format header fields $ add = array ( ) ; $ headerFields = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'headerFields' ] ; foreach ( $ headerFields as $ v ) { $ _v = StringUtil :: deserialize ( $ objParent -> $ v ) ; // Translate UUIDs to paths if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'inputType' ] == 'fileTree' ) { $ objFiles = FilesModel :: findMultipleByUuids ( ( array ) $ _v ) ; if ( $ objFiles !== null ) { $ _v = $ objFiles -> fetchEach ( 'path' ) ; } } if ( \ is_array ( $ _v ) ) { $ _v = implode ( ', ' , $ _v ) ; } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'isBoolean' ] || ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'inputType' ] == 'checkbox' && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'multiple' ] ) ) { $ _v = $ _v ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'yes' ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'no' ] ; } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'rgxp' ] == 'date' ) { $ _v = $ _v ? Date :: parse ( Config :: get ( 'dateFormat' ) , $ _v ) : '-' ; } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'rgxp' ] == 'time' ) { $ _v = $ _v ? Date :: parse ( Config :: get ( 'timeFormat' ) , $ _v ) : '-' ; } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'rgxp' ] == 'datim' ) { $ _v = $ _v ? Date :: parse ( Config :: get ( 'datimFormat' ) , $ _v ) : '-' ; } elseif ( $ v == 'tstamp' ) { $ _v = Date :: parse ( Config :: get ( 'datimFormat' ) , $ objParent -> tstamp ) ; } elseif ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'foreignKey' ] ) ) { $ arrForeignKey = explode ( '.' , $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'foreignKey' ] , 2 ) ; $ objLabel = $ this -> Database -> prepare ( "SELECT " . Database :: quoteIdentifier ( $ arrForeignKey [ 1 ] ) . " AS value FROM " . $ arrForeignKey [ 0 ] . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ _v ) ; if ( $ objLabel -> numRows ) { $ _v = $ objLabel -> value ; } } elseif ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'reference' ] [ $ _v ] ) ) { $ _v = $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'reference' ] [ $ _v ] [ 0 ] ; } elseif ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'reference' ] [ $ _v ] ) ) { $ _v = $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'reference' ] [ $ _v ] ; } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'isAssociative' ] || array_is_assoc ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'options' ] ) ) { $ _v = $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'options' ] [ $ _v ] ; } elseif ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'options_callback' ] ) ) { $ strClass = $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'options_callback' ] [ 0 ] ; $ strMethod = $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'options_callback' ] [ 1 ] ; $ this -> import ( $ strClass ) ; $ options_callback = $ this -> $ strClass -> $ strMethod ( $ this ) ; $ _v = $ options_callback [ $ _v ] ; } elseif ( \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'options_callback' ] ) ) { $ options_callback = $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'options_callback' ] ( $ this ) ; $ _v = $ options_callback [ $ _v ] ; } // Add the sorting field if ( $ _v != '' ) { if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'label' ] ) ) { $ key = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'fields' ] [ $ v ] [ 'label' ] ; } else { $ key = $ GLOBALS [ 'TL_LANG' ] [ $ this -> ptable ] [ $ v ] [ 0 ] ?? $ v ; } $ add [ $ key ] = $ _v ; } } // Trigger the header_callback (see #3417) if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'list' ] [ 'sorting' ] [ 'header_callback' ] ) ) { $ strClass = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'list' ] [ 'sorting' ] [ 'header_callback' ] [ 0 ] ; $ strMethod = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'list' ] [ 'sorting' ] [ 'header_callback' ] [ 1 ] ; $ this -> import ( $ strClass ) ; $ add = $ this -> $ strClass -> $ strMethod ( $ add , $ this ) ; } elseif ( \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'list' ] [ 'sorting' ] [ 'header_callback' ] ) ) { $ add = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'list' ] [ 'sorting' ] [ 'header_callback' ] ( $ add , $ this ) ; } // Output the header data $ return .= ' <table class="tl_header_table">' ; foreach ( $ add as $ k => $ v ) { if ( \ is_array ( $ v ) ) { $ v = $ v [ 0 ] ; } $ return .= ' <tr> <td><span class="tl_label">' . $ k . ':</span> </td> <td>' . $ v . '</td> </tr>' ; } $ return .= ' </table> </div>' ; $ orderBy = array ( ) ; $ firstOrderBy = array ( ) ; // Add all records of the current table $ query = "SELECT * FROM " . $ this -> strTable ; if ( \ is_array ( $ this -> orderBy ) && \ strlen ( $ this -> orderBy [ 0 ] ) ) { $ orderBy = $ this -> orderBy ; $ firstOrderBy = preg_replace ( '/\s+.*$/' , '' , $ orderBy [ 0 ] ) ; // Order by the foreign key if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ firstOrderBy ] [ 'foreignKey' ] ) ) { $ key = explode ( '.' , $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ firstOrderBy ] [ 'foreignKey' ] , 2 ) ; $ query = "SELECT *, (SELECT " . Database :: quoteIdentifier ( $ key [ 1 ] ) . " FROM " . $ key [ 0 ] . " WHERE " . $ this -> strTable . "." . Database :: quoteIdentifier ( $ firstOrderBy ) . "=" . $ key [ 0 ] . ".id) AS foreignKey FROM " . $ this -> strTable ; $ orderBy [ 0 ] = 'foreignKey' ; } } elseif ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'fields' ] ) ) { $ orderBy = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'fields' ] ; $ firstOrderBy = preg_replace ( '/\s+.*$/' , '' , $ orderBy [ 0 ] ) ; } $ arrProcedure = $ this -> procedure ; $ arrValues = $ this -> values ; // Support empty ptable fields if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'dynamicPtable' ] ) { $ arrProcedure [ ] = ( $ this -> ptable == 'tl_article' ) ? "(ptable=? OR ptable='')" : "ptable=?" ; $ arrValues [ ] = $ this -> ptable ; } // WHERE if ( ! empty ( $ arrProcedure ) ) { $ query .= " WHERE " . implode ( ' AND ' , $ arrProcedure ) ; } if ( ! empty ( $ this -> root ) && \ is_array ( $ this -> root ) ) { $ query .= ( ! empty ( $ arrProcedure ) ? " AND " : " WHERE " ) . "id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> root ) ) . ")" ; } // ORDER BY if ( ! empty ( $ orderBy ) && \ is_array ( $ orderBy ) ) { $ query .= " ORDER BY " . implode ( ', ' , $ orderBy ) ; } $ objOrderByStmt = $ this -> Database -> prepare ( $ query ) ; // LIMIT if ( \ strlen ( $ this -> limit ) ) { $ arrLimit = explode ( ',' , $ this -> limit ) ; $ objOrderByStmt -> limit ( $ arrLimit [ 1 ] , $ arrLimit [ 0 ] ) ; } $ objOrderBy = $ objOrderByStmt -> execute ( $ arrValues ) ; if ( $ objOrderBy -> numRows < 1 ) { return $ return . ' <p class="tl_empty_parent_view">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'noResult' ] . '</p> </div>' ; } // Call the child_record_callback if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'child_record_callback' ] ) || \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'child_record_callback' ] ) ) { $ strGroup = '' ; $ blnIndent = false ; $ intWrapLevel = 0 ; $ row = $ objOrderBy -> fetchAllAssoc ( ) ; // Make items sortable if ( $ blnHasSorting ) { $ return .= ' <ul id="ul_' . CURRENT_ID . '">' ; } for ( $ i = 0 , $ c = \ count ( $ row ) ; $ i < $ c ; $ i ++ ) { $ this -> current [ ] = $ row [ $ i ] [ 'id' ] ; $ imagePasteAfter = Image :: getHtml ( 'pasteafter.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pasteafter' ] [ 1 ] , $ row [ $ i ] [ 'id' ] ) ) ; $ imagePasteNew = Image :: getHtml ( 'new.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pastenew' ] [ 1 ] , $ row [ $ i ] [ 'id' ] ) ) ; // Decrypt encrypted value foreach ( $ row [ $ i ] as $ k => $ v ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ k ] [ 'eval' ] [ 'encrypt' ] ) { $ row [ $ i ] [ $ k ] = Encryption :: decrypt ( StringUtil :: deserialize ( $ v ) ) ; } } // Make items sortable if ( $ blnHasSorting ) { $ return .= ' <li id="li_' . $ row [ $ i ] [ 'id' ] . '">' ; } // Add the group header if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'disableGrouping' ] && $ firstOrderBy != 'sorting' ) { $ sortingMode = ( \ count ( $ orderBy ) == 1 && $ firstOrderBy == $ orderBy [ 0 ] && $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'flag' ] != '' && $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ firstOrderBy ] [ 'flag' ] == '' ) ? $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'flag' ] : $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ firstOrderBy ] [ 'flag' ] ; $ remoteNew = $ this -> formatCurrentValue ( $ firstOrderBy , $ row [ $ i ] [ $ firstOrderBy ] , $ sortingMode ) ; $ group = $ this -> formatGroupHeader ( $ firstOrderBy , $ remoteNew , $ sortingMode , $ row [ $ i ] ) ; if ( $ group != $ strGroup ) { $ return .= "\n\n" . '<div class="tl_content_header">' . $ group . '</div>' ; $ strGroup = $ group ; } } $ blnWrapperStart = \ in_array ( $ row [ $ i ] [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'start' ] ) ; $ blnWrapperSeparator = \ in_array ( $ row [ $ i ] [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'separator' ] ) ; $ blnWrapperStop = \ in_array ( $ row [ $ i ] [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'stop' ] ) ; $ blnIndentFirst = isset ( $ row [ $ i - 1 ] [ 'type' ] ) && \ in_array ( $ row [ $ i - 1 ] [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'start' ] ) ; $ blnIndentLast = isset ( $ row [ $ i + 1 ] [ 'type' ] ) && \ in_array ( $ row [ $ i + 1 ] [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'stop' ] ) ; // Closing wrappers if ( $ blnWrapperStop ) { if ( -- $ intWrapLevel < 1 ) { $ blnIndent = false ; } } $ return .= ' <div class="tl_content' . ( $ blnWrapperStart ? ' wrapper_start' : '' ) . ( $ blnWrapperSeparator ? ' wrapper_separator' : '' ) . ( $ blnWrapperStop ? ' wrapper_stop' : '' ) . ( $ blnIndent ? ' indent indent_' . $ intWrapLevel : '' ) . ( $ blnIndentFirst ? ' indent_first' : '' ) . ( $ blnIndentLast ? ' indent_last' : '' ) . ( ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'child_record_class' ] != '' ) ? ' ' . $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'child_record_class' ] : '' ) . ( ( $ i % 2 == 0 ) ? ' even' : ' odd' ) . ' click2edit toggle_select hover-div"> <div class="tl_content_right">' ; // Opening wrappers if ( $ blnWrapperStart ) { if ( ++ $ intWrapLevel > 0 ) { $ blnIndent = true ; } } // Edit multiple if ( Input :: get ( 'act' ) == 'select' ) { $ return .= '<input type="checkbox" name="IDS[]" id="ids_' . $ row [ $ i ] [ 'id' ] . '" class="tl_tree_checkbox" value="' . $ row [ $ i ] [ 'id' ] . '">' ; } // Regular buttons else { $ return .= $ this -> generateButtons ( $ row [ $ i ] , $ this -> strTable , $ this -> root , false , null , $ row [ ( $ i - 1 ) ] [ 'id' ] , $ row [ ( $ i + 1 ) ] [ 'id' ] ) ; // Sortable table if ( $ blnHasSorting ) { // Create new button if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'closed' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] ) { $ return .= ' <a href="' . $ this -> addToUrl ( 'act=create&amp;mode=1&amp;pid=' . $ row [ $ i ] [ 'id' ] . '&amp;id=' . $ objParent -> id . ( Input :: get ( 'nb' ) ? '&amp;nc=1' : '' ) ) . '" title="' . StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pastenew' ] [ 1 ] , $ row [ $ i ] [ 'id' ] ) ) . '">' . $ imagePasteNew . '</a>' ; } // Prevent circular references if ( ( $ blnClipboard && $ arrClipboard [ 'mode' ] == 'cut' && $ row [ $ i ] [ 'id' ] == $ arrClipboard [ 'id' ] ) || ( $ blnMultiboard && $ arrClipboard [ 'mode' ] == 'cutAll' && \ in_array ( $ row [ $ i ] [ 'id' ] , $ arrClipboard [ 'id' ] ) ) ) { $ return .= ' ' . Image :: getHtml ( 'pasteafter_.svg' ) ; } // Copy/move multiple elseif ( $ blnMultiboard ) { $ return .= ' <a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=1&amp;pid=' . $ row [ $ i ] [ 'id' ] ) . '" title="' . StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pasteafter' ] [ 1 ] , $ row [ $ i ] [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteAfter . '</a>' ; } // Paste buttons elseif ( $ blnClipboard ) { $ return .= ' <a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=1&amp;pid=' . $ row [ $ i ] [ 'id' ] . '&amp;id=' . $ arrClipboard [ 'id' ] ) . '" title="' . StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'pasteafter' ] [ 1 ] , $ row [ $ i ] [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteAfter . '</a>' ; } // Drag handle if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notSortable' ] ) { $ return .= ' <button type="button" class="drag-handle" title="' . StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'cut' ] [ 1 ] , $ row [ $ i ] [ 'id' ] ) ) . '" aria-hidden="true">' . Image :: getHtml ( 'drag.svg' ) . '</button>' ; } } // Picker if ( $ this -> strPickerFieldType ) { $ return .= $ this -> getPickerInputField ( $ row [ $ i ] [ 'id' ] ) ; } } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'child_record_callback' ] ) ) { $ strClass = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'child_record_callback' ] [ 0 ] ; $ strMethod = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'child_record_callback' ] [ 1 ] ; $ this -> import ( $ strClass ) ; $ return .= '</div>' . $ this -> $ strClass -> $ strMethod ( $ row [ $ i ] ) . '</div>' ; } elseif ( \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'child_record_callback' ] ) ) { $ return .= '</div>' . $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'child_record_callback' ] ( $ row [ $ i ] ) . '</div>' ; } // Make items sortable if ( $ blnHasSorting ) { $ return .= ' </li>' ; } } } } // Make items sortable if ( $ blnHasSorting && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notSortable' ] && Input :: get ( 'act' ) != 'select' ) { $ return .= ' </ul> <script> Backend.makeParentViewSortable("ul_' . CURRENT_ID . '"); </script>' ; } $ return .= ( $ this -> strPickerFieldType == 'radio' ? ' <div class="tl_radio_reset"> <label for="tl_radio_reset" class="tl_radio_label">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resetSelected' ] . '</label> <input type="radio" name="picker" id="tl_radio_reset" value="" class="tl_tree_radio"> </div>' : '' ) . ' </div>' ; // Close form if ( Input :: get ( 'act' ) == 'select' ) { // Submit buttons $ arrButtons = array ( ) ; if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notEditable' ] ) { $ arrButtons [ 'edit' ] = '<button type="submit" name="edit" id="edit" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editSelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { $ arrButtons [ 'delete' ] = '<button type="submit" name="delete" id="delete" class="tl_submit" accesskey="d" onclick="return confirm(\'' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'delAllConfirm' ] . '\')">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'deleteSelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { $ arrButtons [ 'copy' ] = '<button type="submit" name="copy" id="copy" class="tl_submit" accesskey="c">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'copySelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notSortable' ] ) { $ arrButtons [ 'cut' ] = '<button type="submit" name="cut" id="cut" class="tl_submit" accesskey="x">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'moveSelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notEditable' ] ) { $ arrButtons [ 'override' ] = '<button type="submit" name="override" id="override" class="tl_submit" accesskey="v">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'overrideSelected' ] . '</button>' ; } // Call the buttons_callback (see #4691) if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'select' ] [ 'buttons_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'select' ] [ 'buttons_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ arrButtons = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ arrButtons , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ arrButtons = $ callback ( $ arrButtons , $ this ) ; } } } if ( \ count ( $ arrButtons ) < 3 ) { $ strButtons = implode ( ' ' , $ arrButtons ) ; } else { $ strButtons = array_shift ( $ arrButtons ) . ' ' ; $ strButtons .= '<div class="split-button">' ; $ strButtons .= array_shift ( $ arrButtons ) . '<button type="button" id="sbtog">' . Image :: getHtml ( 'navcol.svg' ) . '</button> <ul class="invisible">' ; foreach ( $ arrButtons as $ strButton ) { $ strButtons .= '<li>' . $ strButton . '</li>' ; } $ strButtons .= '</ul></div>' ; } $ return .= ' </div> <div class="tl_formbody_submit" style="text-align:right"> <div class="tl_submit_container"> ' . $ strButtons . ' </div> </div> </form>' ; } return $ return ; } 
protected function listView ( ) { $ table = ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 6 ) ? $ this -> ptable : $ this -> strTable ; $ orderBy = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'fields' ] ; $ firstOrderBy = preg_replace ( '/\s+.*$/' , '' , $ orderBy [ 0 ] ) ; if ( \ is_array ( $ this -> orderBy ) && $ this -> orderBy [ 0 ] != '' ) { $ orderBy = $ this -> orderBy ; $ firstOrderBy = $ this -> firstOrderBy ; } $ query = "SELECT * FROM " . $ this -> strTable ; if ( ! empty ( $ this -> procedure ) ) { $ query .= " WHERE " . implode ( ' AND ' , $ this -> procedure ) ; } if ( ! empty ( $ this -> root ) && \ is_array ( $ this -> root ) ) { $ query .= ( ! empty ( $ this -> procedure ) ? " AND " : " WHERE " ) . "id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> root ) ) . ")" ; } if ( \ is_array ( $ orderBy ) && $ orderBy [ 0 ] != '' ) { foreach ( $ orderBy as $ k => $ v ) { list ( $ key , $ direction ) = explode ( ' ' , $ v , 2 ) ; if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ key ] [ 'eval' ] [ 'findInSet' ] ) { if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ key ] [ 'options_callback' ] ) ) { $ strClass = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ key ] [ 'options_callback' ] [ 0 ] ; $ strMethod = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ key ] [ 'options_callback' ] [ 1 ] ; $ this -> import ( $ strClass ) ; $ keys = $ this -> $ strClass -> $ strMethod ( $ this ) ; } elseif ( \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ key ] [ 'options_callback' ] ) ) { $ keys = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ key ] [ 'options_callback' ] ( $ this ) ; } else { $ keys = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ key ] [ 'options' ] ; } if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ key ] [ 'eval' ] [ 'isAssociative' ] || array_is_assoc ( $ keys ) ) { $ keys = array_keys ( $ keys ) ; } $ orderBy [ $ k ] = $ this -> Database -> findInSet ( $ v , $ keys ) ; } elseif ( \ in_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ key ] [ 'flag' ] , array ( 5 , 6 , 7 , 8 , 9 , 10 ) ) ) { $ orderBy [ $ k ] = "CAST($key AS SIGNED)" . ( $ direction ? " $direction" : "" ) ; <div id="tl_buttons">' . ( ( Input :: get ( 'act' ) == 'select' || $ this -> ptable ) ? ' <a href="' . $ this -> getReferer ( true , $ this -> ptable ) . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> ' : ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'backlink' ] ) ? ' <a href="contao/main.php?' . $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'backlink' ] . '" class="header_back" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBTTitle' ] ) . '" accesskey="b" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backBT' ] . '</a> ' : '' ) ) . ( ( Input :: get ( 'act' ) != 'select' && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'closed' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] ) ? ' <a href="' . ( ( $ this -> ptable != '' ) ? $ this -> addToUrl ( 'act=create' . ( ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] < 4 ) ? '&amp;mode=2' : '' ) . '&amp;pid=' . $ this -> intId ) : $ this -> addToUrl ( 'act=create' ) ) . '" class="header_new" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'new' ] [ 1 ] ) . '" accesskey="n" onclick="Backend.getScrollOffset()">' . $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ 'new' ] [ 0 ] . '</a> ' : '' ) . $ this -> generateGlobalButtons ( ) . ' </div>' ; // Return "no records found" message if ( $ objRow -> numRows < 1 ) { $ return .= ' <p class="tl_empty">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'noResult' ] . '</p>' ; } // List records else { $ result = $ objRow -> fetchAllAssoc ( ) ; $ return .= ( ( Input :: get ( 'act' ) == 'select' ) ? ' <form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_select" class="tl_form' . ( ( Input :: get ( 'act' ) == 'select' ) ? ' unselectable' : '' ) . '" method="post" novalidate> <div class="tl_formbody_edit"> <input type="hidden" name="FORM_SUBMIT" value="tl_select"> <input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '">' : '' ) . ' <div class="tl_listing_container list_view" id="tl_listing">' . ( ( Input :: get ( 'act' ) == 'select' || $ this -> strPickerFieldType == 'checkbox' ) ? ' <div class="tl_select_trigger"> <label for="tl_select_trigger" class="tl_select_label">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</label> <input type="checkbox" id="tl_select_trigger" onclick="Backend.toggleCheckboxes(this)" class="tl_tree_checkbox"> </div>' : '' ) . ' <table class="tl_listing' . ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'showColumns' ] ? ' showColumns' : '' ) . ( $ this -> strPickerFieldType ? ' picker unselectable' : '' ) . '">' ; // Automatically add the "order by" field as last column if we do not have group headers if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'showColumns' ] ) { $ blnFound = false ; // Extract the real key and compare it to $firstOrderBy foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'fields' ] as $ f ) { if ( strpos ( $ f , ':' ) !== false ) { list ( $ f ) = explode ( ':' , $ f , 2 ) ; } if ( $ firstOrderBy == $ f ) { $ blnFound = true ; break ; } } if ( ! $ blnFound ) { $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'fields' ] [ ] = $ firstOrderBy ; } } // Generate the table header if the "show columns" option is active if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'showColumns' ] ) { $ return .= ' <tr>' ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'fields' ] as $ f ) { if ( strpos ( $ f , ':' ) !== false ) { list ( $ f ) = explode ( ':' , $ f , 2 ) ; } $ return .= ' <th class="tl_folder_tlist col_' . $ f . ( ( $ f == $ firstOrderBy ) ? ' ordered_by' : '' ) . '">' . ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ f ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ f ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ f ] [ 'label' ] ) . '</th>' ; } $ return .= ' <th class="tl_folder_tlist tl_right_nowrap"></th> </tr>' ; } // Process result and add label and buttons $ remoteCur = false ; $ groupclass = 'tl_folder_tlist' ; $ eoCount = - 1 ; foreach ( $ result as $ row ) { $ args = array ( ) ; $ this -> current [ ] = $ row [ 'id' ] ; $ showFields = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'list' ] [ 'label' ] [ 'fields' ] ; // Label foreach ( $ showFields as $ k => $ v ) { // Decrypt the value if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'encrypt' ] ) { $ row [ $ v ] = Encryption :: decrypt ( StringUtil :: deserialize ( $ row [ $ v ] ) ) ; } if ( strpos ( $ v , ':' ) !== false ) { list ( $ strKey , $ strTable ) = explode ( ':' , $ v ) ; list ( $ strTable , $ strField ) = explode ( '.' , $ strTable ) ; $ objRef = $ this -> Database -> prepare ( "SELECT " . Database :: quoteIdentifier ( $ strField ) . " FROM " . $ strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ row [ $ strKey ] ) ; $ args [ $ k ] = $ objRef -> numRows ? $ objRef -> $ strField : '' ; } elseif ( \ in_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ v ] [ 'flag' ] , array ( 5 , 6 , 7 , 8 , 9 , 10 ) ) ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'rgxp' ] == 'date' ) { $ args [ $ k ] = $ row [ $ v ] ? Date :: parse ( Config :: get ( 'dateFormat' ) , $ row [ $ v ] ) : '-' ; } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'rgxp' ] == 'time' ) { $ args [ $ k ] = $ row [ $ v ] ? Date :: parse ( Config :: get ( 'timeFormat' ) , $ row [ $ v ] ) : '-' ; } else { $ args [ $ k ] = $ row [ $ v ] ? Date :: parse ( Config :: get ( 'datimFormat' ) , $ row [ $ v ] ) : '-' ; } } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'isBoolean' ] || ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ v ] [ 'inputType' ] == 'checkbox' && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'multiple' ] ) ) { $ args [ $ k ] = $ row [ $ v ] ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'yes' ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'no' ] ; } else { $ row_v = StringUtil :: deserialize ( $ row [ $ v ] ) ; if ( \ is_array ( $ row_v ) ) { $ args_k = array ( ) ; foreach ( $ row_v as $ option ) { $ args_k [ ] = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ v ] [ 'reference' ] [ $ option ] ? : $ option ; } $ args [ $ k ] = implode ( ', ' , $ args_k ) ; } elseif ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ v ] [ 'reference' ] [ $ row [ $ v ] ] ) ) { $ args [ $ k ] = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ v ] [ 'reference' ] [ $ row [ $ v ] ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ v ] [ 'reference' ] [ $ row [ $ v ] ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ v ] [ 'reference' ] [ $ row [ $ v ] ] ; } elseif ( ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ v ] [ 'eval' ] [ 'isAssociative' ] || array_is_assoc ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ v ] [ 'options' ] ) ) && isset ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ v ] [ 'options' ] [ $ row [ $ v ] ] ) ) { $ args [ $ k ] = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ v ] [ 'options' ] [ $ row [ $ v ] ] ; } else { $ args [ $ k ] = $ row [ $ v ] ; } } } // Shorten the label it if it is too long $ label = vsprintf ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'format' ] ? : '%s' , $ args ) ; if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'maxCharacters' ] > 0 && $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'maxCharacters' ] < \ strlen ( strip_tags ( $ label ) ) ) { $ label = trim ( StringUtil :: substrHtml ( $ label , $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'maxCharacters' ] ) ) . ' …'; } // Remove empty brackets (), [], {}, <> and empty tags from the label $ label = preg_replace ( '/\( *\) ?|\[ *\] ?|\{ *\} ?|< *> ?/' , '' , $ label ) ; $ label = preg_replace ( '/<[^>]+>\s*<\/[^>]+>/' , '' , $ label ) ; // Build the sorting groups if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] > 0 ) { $ current = $ row [ $ firstOrderBy ] ; $ orderBy = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'fields' ] ; $ sortingMode = ( \ count ( $ orderBy ) == 1 && $ firstOrderBy == $ orderBy [ 0 ] && $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'flag' ] != '' && $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ firstOrderBy ] [ 'flag' ] == '' ) ? $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'flag' ] : $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ firstOrderBy ] [ 'flag' ] ; $ remoteNew = $ this -> formatCurrentValue ( $ firstOrderBy , $ current , $ sortingMode ) ; // Add the group header if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'showColumns' ] && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'disableGrouping' ] && ( $ remoteNew != $ remoteCur || $ remoteCur === false ) ) { $ eoCount = - 1 ; $ group = $ this -> formatGroupHeader ( $ firstOrderBy , $ remoteNew , $ sortingMode , $ row ) ; $ remoteCur = $ remoteNew ; $ return .= ' <tr> <td colspan="2" class="' . $ groupclass . '">' . $ group . '</td> </tr>' ; $ groupclass = 'tl_folder_list' ; } } $ return .= ' <tr class="' . ( ( ++ $ eoCount % 2 == 0 ) ? 'even' : 'odd' ) . ' click2edit toggle_select hover-row"> ' ; $ colspan = 1 ; // Call the label_callback ($row, $label, $this) if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'label_callback' ] ) || \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'label_callback' ] ) ) { if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'label_callback' ] ) ) { $ strClass = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'label_callback' ] [ 0 ] ; $ strMethod = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'label_callback' ] [ 1 ] ; $ this -> import ( $ strClass ) ; $ args = $ this -> $ strClass -> $ strMethod ( $ row , $ label , $ this , $ args ) ; } elseif ( \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'label_callback' ] ) ) { $ args = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'label_callback' ] ( $ row , $ label , $ this , $ args ) ; } // Handle strings and arrays if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'showColumns' ] ) { $ label = \ is_array ( $ args ) ? implode ( ' ' , $ args ) : $ args ; } elseif ( ! \ is_array ( $ args ) ) { $ args = array ( $ args ) ; $ colspan = \ count ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'fields' ] ) ; } } // Show columns if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'showColumns' ] ) { foreach ( $ args as $ j => $ arg ) { $ return .= '<td colspan="' . $ colspan . '" class="tl_file_list col_' . $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'fields' ] [ $ j ] . ( ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'label' ] [ 'fields' ] [ $ j ] == $ firstOrderBy ) ? ' ordered_by' : '' ) . '">' . ( $ arg ? : '-' ) . '</td>' ; } } else { $ return .= '<td class="tl_file_list">' . $ label . '</td>' ; } // Buttons ($row, $table, $root, $blnCircularReference, $childs, $previous, $next) $ return .= ( ( Input :: get ( 'act' ) == 'select' ) ? ' <td class="tl_file_list tl_right_nowrap"><input type="checkbox" name="IDS[]" id="ids_' . $ row [ 'id' ] . '" class="tl_tree_checkbox" value="' . $ row [ 'id' ] . '"></td>' : ' <td class="tl_file_list tl_right_nowrap">' . $ this -> generateButtons ( $ row , $ this -> strTable , $ this -> root ) . ( $ this -> strPickerFieldType ? $ this -> getPickerInputField ( $ row [ 'id' ] ) : '' ) . '</td>' ) . ' </tr>' ; } // Close the table $ return .= ' </table>' . ( $ this -> strPickerFieldType == 'radio' ? ' <div class="tl_radio_reset"> <label for="tl_radio_reset" class="tl_radio_label">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resetSelected' ] . '</label> <input type="radio" name="picker" id="tl_radio_reset" value="" class="tl_tree_radio"> </div>' : '' ) . ' </div>' ; // Close the form if ( Input :: get ( 'act' ) == 'select' ) { // Submit buttons $ arrButtons = array ( ) ; if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notEditable' ] ) { $ arrButtons [ 'edit' ] = '<button type="submit" name="edit" id="edit" class="tl_submit" accesskey="s">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editSelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { $ arrButtons [ 'delete' ] = '<button type="submit" name="delete" id="delete" class="tl_submit" accesskey="d" onclick="return confirm(\'' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'delAllConfirm' ] . '\')">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'deleteSelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { $ arrButtons [ 'copy' ] = '<button type="submit" name="copy" id="copy" class="tl_submit" accesskey="c">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'copySelected' ] . '</button>' ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notEditable' ] ) { $ arrButtons [ 'override' ] = '<button type="submit" name="override" id="override" class="tl_submit" accesskey="v">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'overrideSelected' ] . '</button>' ; } // Call the buttons_callback (see #4691) if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'select' ] [ 'buttons_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'select' ] [ 'buttons_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ arrButtons = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ arrButtons , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ arrButtons = $ callback ( $ arrButtons , $ this ) ; } } } if ( \ count ( $ arrButtons ) < 3 ) { $ strButtons = implode ( ' ' , $ arrButtons ) ; } else { $ strButtons = array_shift ( $ arrButtons ) . ' ' ; $ strButtons .= '<div class="split-button">' ; $ strButtons .= array_shift ( $ arrButtons ) . '<button type="button" id="sbtog">' . Image :: getHtml ( 'navcol.svg' ) . '</button> <ul class="invisible">' ; foreach ( $ arrButtons as $ strButton ) { $ strButtons .= '<li>' . $ strButton . '</li>' ; } $ strButtons .= '</ul></div>' ; } $ return .= ' </div> <div class="tl_formbody_submit" style="text-align:right"> <div class="tl_submit_container"> ' . $ strButtons . ' </div> </div> </form>' ; } } return $ return ; } 
protected function searchMenu ( ) { $ searchFields = array ( ) ; $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; <div class="tl_search tl_subpanel"> <strong>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'search' ] . ':</strong> <select name="tl_field" class="tl_select' . ( $ active ? ' active' : '' ) . '"> ' . implode ( "\n" , $ options_sorter ) . ' </select> <span>=</span> <input type="search" name="tl_value" class="tl_text' . ( $ active ? ' active' : '' ) . '" value="' . StringUtil :: specialchars ( $ session [ 'search' ] [ $ this -> strTable ] [ 'value' ] ) . '"> </div>' ; } 
protected function sortMenu ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] != 2 && $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] != 4 ) { return '' ; } $ sortingFields = array ( ) ; <div class="tl_sorting tl_subpanel"> <strong>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'sortBy' ] . ':</strong> <select name="tl_sort" id="tl_sort" class="tl_select"> ' . implode ( "\n" , $ options_sorter ) . ' </select> </div>' ; } 
protected function limitMenu ( $ blnOptional = false ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; $ filter = ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) ? $ this -> strTable . '_' . CURRENT_ID : $ this -> strTable ; $ fields = '' ; <option value="' . $ this_limit . '"' . Widget :: optionSelected ( $ this -> limit , $ this_limit ) . '>' . ( $ i * Config :: get ( 'resultsPerPage' ) + 1 ) . ' - ' . $ upper_limit . '</option>' ; } if ( ! $ blnIsMaxResultsPerPage ) { $ options .= ' <option value="all"' . Widget :: optionSelected ( $ this -> limit , null ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'filterAll' ] . '</option>' ; } } // Return if there is only one page if ( $ blnOptional && ( $ this -> total < 1 || $ options_total < 2 ) ) { return '' ; } $ fields = ' <select name="tl_limit" class="tl_select' . ( ( $ session [ 'filter' ] [ $ filter ] [ 'limit' ] != 'all' && $ this -> total > Config :: get ( 'resultsPerPage' ) ) ? ' active' : '' ) . '" onchange="this.form.submit()"> <option value="tl_limit">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'filterRecords' ] . '</option>' . $ options . ' </select> ' ; } return ' <div class="tl_limit tl_subpanel"> <strong>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showOnly' ] . ':</strong> ' . $ fields . ' </div>' ; } 
protected function filterMenu ( $ intFilterPanel ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ fields = '' ; $ sortingFields = array ( ) ; $ session = $ objSessionBag -> all ( ) ; $ filter = ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) ? $ this -> strTable . '_' . CURRENT_ID : $ this -> strTable ; <select name="' . $ field . '" id="' . $ field . '" class="tl_select' . ( isset ( $ session [ 'filter' ] [ $ filter ] [ $ field ] ) ? ' active' : '' ) . '"> <option value="tl_' . $ field . '">' . ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'label' ] ) . '</option> <option value="tl_' . $ field . '">---</option>' ; if ( $ objFields -> numRows ) { $ options = $ objFields -> fetchEach ( $ field ) ; // Sort by day if ( \ in_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'flag' ] , array ( 5 , 6 ) ) ) { ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'flag' ] == 6 ) ? rsort ( $ options ) : sort ( $ options ) ; foreach ( $ options as $ k => $ v ) { if ( $ v === '' ) { $ options [ $ v ] = '-' ; } else { $ options [ $ v ] = Date :: parse ( Config :: get ( 'dateFormat' ) , $ v ) ; } unset ( $ options [ $ k ] ) ; } } // Sort by month elseif ( \ in_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'flag' ] , array ( 7 , 8 ) ) ) { ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'flag' ] == 8 ) ? rsort ( $ options ) : sort ( $ options ) ; foreach ( $ options as $ k => $ v ) { if ( $ v === '' ) { $ options [ $ v ] = '-' ; } else { $ options [ $ v ] = date ( 'Y-m' , $ v ) ; $ intMonth = ( date ( 'm' , $ v ) - 1 ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] [ $ intMonth ] ) ) { $ options [ $ v ] = $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] [ $ intMonth ] . ' ' . date ( 'Y' , $ v ) ; } } unset ( $ options [ $ k ] ) ; } } // Sort by year elseif ( \ in_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'flag' ] , array ( 9 , 10 ) ) ) { ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'flag' ] == 10 ) ? rsort ( $ options ) : sort ( $ options ) ; foreach ( $ options as $ k => $ v ) { if ( $ v === '' ) { $ options [ $ v ] = '-' ; } else { $ options [ $ v ] = date ( 'Y' , $ v ) ; } unset ( $ options [ $ k ] ) ; } } // Manual filter if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'eval' ] [ 'multiple' ] ) { $ moptions = array ( ) ; // TODO: find a more effective solution foreach ( $ options as $ option ) { // CSV lists (see #2890) if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'eval' ] [ 'csv' ] ) ) { $ doptions = StringUtil :: trimsplit ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'eval' ] [ 'csv' ] , $ option ) ; } else { $ doptions = StringUtil :: deserialize ( $ option ) ; } if ( \ is_array ( $ doptions ) ) { $ moptions = array_merge ( $ moptions , $ doptions ) ; } } $ options = $ moptions ; } $ options = array_unique ( $ options ) ; $ options_callback = array ( ) ; // Call the options_callback if ( ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options_callback' ] ) || \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options_callback' ] ) ) && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'reference' ] ) { if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options_callback' ] ) ) { $ strClass = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options_callback' ] [ 0 ] ; $ strMethod = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options_callback' ] [ 1 ] ; $ this -> import ( $ strClass ) ; $ options_callback = $ this -> $ strClass -> $ strMethod ( $ this ) ; } elseif ( \ is_callable ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options_callback' ] ) ) { $ options_callback = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options_callback' ] ( $ this ) ; } // Sort options according to the keys of the callback array $ options = array_intersect ( array_keys ( $ options_callback ) , $ options ) ; } $ options_sorter = array ( ) ; $ blnDate = \ in_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'flag' ] , array ( 5 , 6 , 7 , 8 , 9 , 10 ) ) ; // Options foreach ( $ options as $ kk => $ vv ) { $ value = $ blnDate ? $ kk : $ vv ; // Options callback if ( ! empty ( $ options_callback ) && \ is_array ( $ options_callback ) ) { $ vv = $ options_callback [ $ vv ] ; } // Replace the ID with the foreign key elseif ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'foreignKey' ] ) ) { $ key = explode ( '.' , $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'foreignKey' ] , 2 ) ; $ objParent = $ this -> Database -> prepare ( "SELECT " . Database :: quoteIdentifier ( $ key [ 1 ] ) . " AS value FROM " . $ key [ 0 ] . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ vv ) ; if ( $ objParent -> numRows ) { $ vv = $ objParent -> value ; } } // Replace boolean checkbox value with "yes" and "no" elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'eval' ] [ 'isBoolean' ] || ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'inputType' ] == 'checkbox' && ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'eval' ] [ 'multiple' ] ) ) { $ vv = $ vv ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'yes' ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'no' ] ; } // Get the name of the parent record (see #2703) elseif ( $ field == 'pid' ) { $ this -> loadDataContainer ( $ this -> ptable ) ; $ showFields = $ GLOBALS [ 'TL_DCA' ] [ $ this -> ptable ] [ 'list' ] [ 'label' ] [ 'fields' ] ; if ( ! $ showFields [ 0 ] ) { $ showFields [ 0 ] = 'id' ; } $ objShowFields = $ this -> Database -> prepare ( "SELECT " . Database :: quoteIdentifier ( $ showFields [ 0 ] ) . " FROM " . $ this -> ptable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ vv ) ; if ( $ objShowFields -> numRows ) { $ vv = $ objShowFields -> { $ showFields [ 0 ] } ; } } $ option_label = '' ; // Use reference array if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'reference' ] ) ) { $ option_label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'reference' ] [ $ vv ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'reference' ] [ $ vv ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'reference' ] [ $ vv ] ; } // Associative array elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'eval' ] [ 'isAssociative' ] || array_is_assoc ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options' ] ) ) { $ option_label = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options' ] [ $ vv ] ; } // No empty options allowed if ( ! \ strlen ( $ option_label ) ) { $ option_label = $ vv ? : '-' ; } $ options_sorter [ ' <option value="' . StringUtil :: specialchars ( $ value ) . '"' . ( ( isset ( $ session [ 'filter' ] [ $ filter ] [ $ field ] ) && $ value == $ session [ 'filter' ] [ $ filter ] [ $ field ] ) ? ' selected="selected"' : '' ) . '>' . $ option_label . '</option>' ] = Utf8 :: toAscii ( $ option_label ) ; } // Sort by option values if ( ! $ blnDate ) { natcasesort ( $ options_sorter ) ; if ( \ in_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'flag' ] , array ( 2 , 4 , 12 ) ) ) { $ options_sorter = array_reverse ( $ options_sorter , true ) ; } } $ fields .= "\n" . implode ( "\n" , array_keys ( $ options_sorter ) ) ; } // End select menu $ fields .= ' </select> ' ; // Force a line-break after six elements (see #3777) if ( ( ( $ cnt + 1 ) % 6 ) == 0 ) { $ fields .= '<br>' ; } } return ' <div class="tl_filter tl_subpanel"> <strong>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'filter' ] . ':</strong> ' . $ fields . ' </div>' ; } 
protected function paginationMenu ( ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; $ filter = ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) ? $ this -> strTable . '_' . CURRENT_ID : $ this -> strTable ; list ( $ offset , $ limit ) = explode ( ',' , $ this -> limit ) ; 
protected function formatCurrentValue ( $ field , $ value , $ mode ) { $ remoteNew = $ value ; 
protected function formatGroupHeader ( $ field , $ value , $ mode , $ row ) { static $ lookup = array ( ) ; if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'eval' ] [ 'isAssociative' ] || array_is_assoc ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options' ] ) ) { $ group = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options' ] [ $ value ] ; } elseif ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options_callback' ] ) ) { if ( ! isset ( $ lookup [ $ field ] ) ) { $ strClass = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options_callback' ] [ 0 ] ; $ strMethod = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'options_callback' ] [ 1 ] ; $ this -> import ( $ strClass ) ; $ lookup [ $ field ] = $ this -> $ strClass -> $ strMethod ( $ this ) ; } $ group = $ lookup [ $ field ] [ $ value ] ; } else { $ group = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'reference' ] [ $ value ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'reference' ] [ $ value ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'reference' ] [ $ value ] ; } if ( empty ( $ group ) ) { $ group = \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ $ value ] ) ? $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ $ value ] [ 0 ] : $ GLOBALS [ 'TL_LANG' ] [ $ this -> strTable ] [ $ value ] ; } if ( empty ( $ group ) ) { $ group = $ value ; if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'eval' ] [ 'isBoolean' ] && $ value != '-' ) { $ group = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ field ] [ 'label' ] ; } } 
public function initPicker ( PickerInterface $ picker ) { $ attributes = parent :: initPicker ( $ picker ) ; if ( null === $ attributes ) { return null ; } 
private function canonicalize ( string $ value ) : string { $ resolved = [ ] ; $ chunks = preg_split ( '#([\\\\/]+)#' , $ value , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; for ( $ i = 0 , $ c = \ count ( $ chunks ) ; $ i < $ c ; ++ $ i ) { if ( '.' === $ chunks [ $ i ] ) { ++ $ i ; continue ; } 
public function generateMarkup ( ) { <input type="hidden" name="action" value="fileupload"> <div class="fallback"> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple> </div> <div class="dropzone"> <div class="dz-default dz-message"> <span>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzone' ] . '</span> </div> <span class="dropzone-previews"></span> </div> <script> Dropzone.autoDiscover = false; window.addEvent("domready", function() { new Dropzone("#tl_files", { paramName: "' . $ this -> strName . '", maxFilesize: ' . $ intMaxSize . ', acceptedFiles: "' . $ strAccepted . '", timeout: 0, previewsContainer: ".dropzone-previews", clickable: ".dropzone", dictFileTooBig: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneFileTooBig' ] ) . ', dictInvalidFileType: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneInvalidType' ] ) . ' }).on("addedfile", function() { $$(".dz-message").setStyle("display", "none"); }).on("success", function(file, message) { if (!message) return; var container = $("tl_message"); if (!container) { container = new Element("div", { "id": "tl_message", "class": "tl_message" }).inject($("tl_buttons"), "before"); } container.appendHTML(message); }); $$("div.tl_formbody_submit").setStyle("display", "none"); }); </script>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; } 
public static function findSentByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.sent=1" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; } 
public static function findSentByPids ( $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.sent=1" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; } 
public function checkPermission ( ) { $ bundles = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; 
public function listQuestions ( $ arrRow ) { $ key = $ arrRow [ 'published' ] ? 'published' : 'unpublished' ; $ date = Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ arrRow [ 'tstamp' ] ) ; return ' <div class="cte_type ' . $ key . '">' . $ date . '</div> <div class="limit_height' . ( ! Contao \ Config :: get ( 'doNotCollapse' ) ? ' h40' : '' ) . '"> <h2>' . $ arrRow [ 'question' ] . '</h2> ' . Contao \ StringUtil :: insertTagToSrc ( $ arrRow [ 'answer' ] ) . ' </div>' . "\n" ; } 
protected function compile ( ) { if ( TL_MODE == 'BE' ) { $ this -> strTemplate = 'be_wildcard' ; $ this -> Template = new BackendTemplate ( $ this -> strTemplate ) ; $ this -> Template -> title = $ this -> headline ; } 
public function run ( ) { try { $ version = PackageUtil :: getVersion ( 'contao/core-bundle' ) ; } catch ( \ OutOfBoundsException $ e ) { $ version = PackageUtil :: getVersion ( 'contao/contao' ) ; } $ this -> Template = new BackendTemplate ( 'be_main' ) ; $ this -> Template -> version = $ version ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] ) ) { $ this -> Template -> version = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] . ' ' . $ version ; } $ this -> Template -> main = '' ; 
protected function welcomeScreen ( ) { System :: loadLanguageFile ( 'explain' ) ; $ objTemplate = new BackendTemplate ( 'be_welcome' ) ; $ objTemplate -> messages = Message :: generateUnwrapped ( ) . Backend :: getSystemMessages ( ) ; $ objTemplate -> loginMsg = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'firstLogin' ] ; 
protected function output ( ) { 
private function setImpersonatedLogout ( ) { $ token = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ impersonatorUser = null ; foreach ( $ token -> getRoles ( ) as $ role ) { if ( $ role instanceof SwitchUserRole ) { $ impersonatorUser = $ role -> getSource ( ) -> getUsername ( ) ; break ; } } if ( ! $ impersonatorUser ) { return ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ firewallMap = System :: getContainer ( ) -> get ( 'security.firewall.map' ) ; 
public function process ( ContainerBuilder $ container ) : void { $ packages = [ ] ; foreach ( Versions :: VERSIONS as $ name => $ version ) { $ packages [ $ name ] = PackageUtil :: parseVersion ( $ version ) ; } $ container -> setParameter ( 'kernel.packages' , $ packages ) ; } 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'comments' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; return $ objTemplate -> parse ( ) ; } return parent :: generate ( ) ; } 
protected function compile ( ) { $ this -> import ( Comments :: class , 'Comments' ) ; $ objConfig = new \ stdClass ( ) ; $ objConfig -> perPage = $ this -> com_perPage ; $ objConfig -> order = $ this -> com_order ; $ objConfig -> template = $ this -> com_template ; $ objConfig -> requireLogin = $ this -> com_requireLogin ; $ objConfig -> disableCaptcha = $ this -> com_disableCaptcha ; $ objConfig -> bbcode = $ this -> com_bbcode ; $ objConfig -> moderate = $ this -> com_moderate ; $ this -> Comments -> addCommentsToTemplate ( $ this -> Template , $ objConfig , 'tl_content' , $ this -> id , $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ) ; } 
public function getOptions ( ) : array { $ options = [ ] ; foreach ( self :: DEFAULT_OPTIONS as $ option => $ label ) { $ options [ $ option ] = $ this -> translator -> trans ( 'MSC.validCharacters.' . $ label , [ ] , 'contao_default' ) ; } $ event = new SlugValidCharactersEvent ( $ options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: SLUG_VALID_CHARACTERS , $ event ) ; return $ event -> getOptions ( ) ; } 
public function shouldBeRun ( ) : bool { $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; if ( ! $ schemaManager -> tablesExist ( [ 'tl_layout' ] ) ) { return false ; } $ columns = $ schemaManager -> listTableColumns ( 'tl_layout' ) ; return ! isset ( $ columns [ 'minifymarkup' ] ) ; } 
public function run ( ) : void { $ this -> connection -> query ( " ALTER TABLE tl_layout ADD minifyMarkup char(1) NOT NULL default '' " ) ; UPDATE tl_layout SET minifyMarkup = '1' " ) ; } // Add a .nosync file in every excluded folder if ( ! empty ( $ GLOBALS [ 'TL_CONFIG' ] [ 'fileSyncExclude' ] ) ) { $ fs = $ this -> container -> get ( 'filesystem' ) ; $ uploadPath = $ this -> container -> getParameter ( 'contao.upload_path' ) ; $ rootDir = $ this -> container -> getParameter ( 'kernel.project_dir' ) ; $ folders = array_map ( 'trim' , explode ( ',' , $ GLOBALS [ 'TL_CONFIG' ] [ 'fileSyncExclude' ] ) ) ; foreach ( $ folders as $ folder ) { if ( is_dir ( $ rootDir . '/' . $ uploadPath . '/' . $ folder ) ) { $ fs -> touch ( $ rootDir . '/' . $ uploadPath . '/' . $ folder . '/.nosync' ) ; } } } $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; if ( $ schemaManager -> tablesExist ( [ 'tl_comments_notify' ] ) ) { $ this -> connection -> query ( " ALTER TABLE tl_comments_notify ADD active CHAR(1) DEFAULT '' NOT NULL " ) ; $ this -> connection -> query ( " UPDATE tl_comments_notify SET active = '1' WHERE tokenConfirm = '' " ) ; } } 
public function generate ( ) { $ arrOptions = array ( ) ; $ strClass = 'tl_select' ; if ( $ this -> multiple ) { $ this -> strName .= '[]' ; $ strClass = 'tl_mselect' ; } 
public function parse ( $ arrAttributes = null ) { 
public function generate ( ) { return sprintf ( '<fieldset%s>%s' , ( $ this -> strClass ? ' class="' . $ this -> strClass . '"' : '' ) , ( $ this -> label ? '<legend>' . $ this -> label . '</legend>' : '' ) ) ; } 
protected function compile ( ) { global $ objPage ; $ type = null ; $ pageId = $ objPage -> id ; $ pages = array ( $ objPage ) ; $ items = array ( ) ; 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ condition = $ this -> escapeQuote ( parent :: visit ( $ criterion , $ subVisitor ) ) ; return "{!child of='document_type_id:content' v='document_type_id:content AND {$condition}'}" ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ idSet = array ( ) ; foreach ( $ criterion -> value as $ value ) { foreach ( explode ( '/' , trim ( $ value , '/' ) ) as $ id ) { $ idSet [ $ id ] = true ; } } return '(' . implode ( ' OR ' , array_map ( function ( $ value ) { return 'location_id:"' . $ value . '"' ; } , array_keys ( $ idSet ) ) ) . ')' ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ criterion -> value = ( array ) $ criterion -> value ; $ start = $ criterion -> value [ 0 ] ; $ end = isset ( $ criterion -> value [ 1 ] ) ? $ criterion -> value [ 1 ] : 63510 ; if ( ( $ criterion -> operator === Operator :: LT ) || ( $ criterion -> operator === Operator :: LTE ) ) { $ end = $ start ; $ start = null ; } $ searchFields = $ this -> getSearchFields ( $ criterion , $ criterion -> target , $ this -> fieldTypeIdentifier , $ this -> fieldName ) ; if ( empty ( $ searchFields ) ) { throw new InvalidArgumentException ( '$criterion->target' , "No searchable fields found for the given criterion target '{$criterion->target}'." ) ; } $ location = $ criterion -> valueData ; $ queries = array ( ) ; foreach ( $ searchFields as $ name => $ fieldType ) { 
public function mapContentBlock ( Content $ content ) { $ contentInfo = $ content -> versionInfo -> contentInfo ; $ locations = $ this -> locationHandler -> loadLocationsByContent ( $ contentInfo -> id ) ; $ blockFields = $ this -> getBlockFields ( $ content ) ; $ contentFields = $ this -> getContentFields ( $ content ) ; $ documents = [ ] ; $ locationFieldsMap = [ ] ; foreach ( $ locations as $ location ) { $ locationFieldsMap [ $ location -> id ] = $ this -> getLocationFields ( $ location ) ; } foreach ( array_keys ( $ content -> versionInfo -> names ) as $ languageCode ) { $ blockTranslationFields = $ this -> getBlockTranslationFields ( $ content , $ languageCode ) ; $ translationLocationDocuments = array ( ) ; foreach ( $ locations as $ location ) { $ translationLocationDocuments [ ] = new Document ( array ( 'id' => $ this -> generateLocationDocumentId ( $ location -> id , $ languageCode ) , 'fields' => array_merge ( $ blockFields , $ locationFieldsMap [ $ location -> id ] , $ blockTranslationFields ) , ) ) ; } $ isMainTranslation = ( $ contentInfo -> mainLanguageCode === $ languageCode ) ; $ alwaysAvailable = ( $ isMainTranslation && $ contentInfo -> alwaysAvailable ) ; $ contentTranslationFields = $ this -> getContentTranslationFields ( $ content , $ languageCode ) ; $ documents [ ] = new Document ( array ( 'id' => $ this -> generateContentDocumentId ( $ contentInfo -> id , $ languageCode ) , 'languageCode' => $ languageCode , 'alwaysAvailable' => $ alwaysAvailable , 'isMainTranslation' => $ isMainTranslation , 'fields' => array_merge ( $ blockFields , $ contentFields , $ blockTranslationFields , $ contentTranslationFields ) , 'documents' => $ translationLocationDocuments , ) ) ; } return $ documents ; } 
private function getBlockFields ( Content $ content ) { $ fields = [ ] ; if ( $ this -> blockFieldMapper -> accept ( $ content ) ) { $ fields = $ this -> blockFieldMapper -> mapFields ( $ content ) ; } return $ fields ; } 
private function getBlockTranslationFields ( Content $ content , $ languageCode ) { $ fields = [ ] ; if ( $ this -> blockTranslationFieldMapper -> accept ( $ content , $ languageCode ) ) { $ fields = $ this -> blockTranslationFieldMapper -> mapFields ( $ content , $ languageCode ) ; } return $ fields ; } 
private function getContentFields ( Content $ content ) { $ fields = [ ] ; if ( $ this -> contentFieldMapper -> accept ( $ content ) ) { $ fields = $ this -> contentFieldMapper -> mapFields ( $ content ) ; } return $ fields ; } 
private function getContentTranslationFields ( Content $ content , $ languageCode ) { $ fields = [ ] ; if ( $ this -> contentTranslationFieldMapper -> accept ( $ content , $ languageCode ) ) { $ fields = $ this -> contentTranslationFieldMapper -> mapFields ( $ content , $ languageCode ) ; } return $ fields ; } 
private function getLocationFields ( Location $ location ) { $ fields = [ ] ; if ( $ this -> locationFieldMapper -> accept ( $ location ) ) { $ fields = $ this -> locationFieldMapper -> mapFields ( $ location ) ; } return $ fields ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { return '(' . implode ( ' OR ' , array_map ( function ( $ value ) { return 'content_id_id:"' . $ value . '"' ; } , $ criterion -> value ) ) . ')' ; } 
public function getMaxDepthForContent ( ContentType $ contentType ) : int { if ( isset ( $ this -> contentTypeMap [ $ contentType -> identifier ] ) ) { return $ this -> contentTypeMap [ $ contentType -> identifier ] ; } return $ this -> defaultIndexingDepth ; } 
public function mapField ( $ field , array $ data , FacetBuilder $ facetBuilder = null ) { foreach ( $ this -> visitors as $ visitor ) { if ( $ facetBuilder && $ visitor instanceof FacetFieldVisitor && $ visitor -> canVisit ( $ facetBuilder ) ) { return $ visitor -> mapField ( $ field , $ data , $ facetBuilder ) ; } elseif ( ! $ facetBuilder && $ visitor -> canMap ( $ field ) ) { return $ visitor -> map ( $ field , $ data ) ; } } throw new \ OutOfRangeException ( 'No visitor available for: ' . $ field ) ; } 
public function visitBuilder ( FacetBuilder $ facetBuilder , $ fieldId ) { foreach ( $ this -> visitors as $ visitor ) { if ( $ visitor -> canVisit ( $ facetBuilder ) ) { return $ visitor instanceof FacetFieldVisitor ? $ visitor -> visitBuilder ( $ facetBuilder , $ fieldId ) : $ visitor -> visit ( $ facetBuilder ) ; } } 
public function receive ( Signal $ signal ) { if ( ! $ signal instanceof Signal \ ContentService \ RemoveTranslationSignal ) { return ; } $ contentInfo = $ this -> persistenceHandler -> contentHandler ( ) -> loadContentInfo ( $ signal -> contentId ) ; if ( ! $ contentInfo -> isPublished ) { return ; } $ this -> searchHandler -> indexContent ( $ this -> persistenceHandler -> contentHandler ( ) -> load ( $ contentInfo -> id , $ contentInfo -> currentVersionNo ) ) ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { if ( ! isset ( $ criterion -> criteria [ 0 ] ) || ( count ( $ criterion -> criteria ) > 1 ) ) { throw new \ RuntimeException ( 'Invalid aggregation in LogicalNot criterion.' ) ; } return '(*:* NOT ' . $ subVisitor -> visit ( $ criterion -> criteria [ 0 ] ) . ')' ; } 
public function findContent ( Query $ query , array $ languageFilter = array ( ) ) { $ query = clone $ query ; $ query -> filter = $ query -> filter ? : new Criterion \ MatchAll ( ) ; $ query -> query = $ query -> query ? : new Criterion \ MatchAll ( ) ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_CONTENT ) ; return $ this -> resultExtractor -> extract ( $ this -> gateway -> findContent ( $ query , $ languageFilter ) , $ query -> facetBuilders ) ; } 
public function findSingle ( Criterion $ filter , array $ languageFilter = array ( ) ) { $ query = new Query ( ) ; $ query -> filter = $ filter ; $ query -> query = new Criterion \ MatchAll ( ) ; $ query -> offset = 0 ; $ query -> limit = 1 ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_CONTENT ) ; $ result = $ this -> resultExtractor -> extract ( $ this -> gateway -> findContent ( $ query , $ languageFilter ) ) ; if ( ! $ result -> totalCount ) { throw new NotFoundException ( 'Content' , 'findSingle() found no content for given $filter' ) ; } elseif ( $ result -> totalCount > 1 ) { throw new InvalidArgumentException ( 'totalCount' , 'findSingle() found more then one item for given $filter' ) ; } $ first = reset ( $ result -> searchHits ) ; return $ first -> valueObject ; } 
public function findLocations ( LocationQuery $ query , array $ languageFilter = array ( ) ) { $ query = clone $ query ; $ query -> query = $ query -> query ? : new Criterion \ MatchAll ( ) ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_LOCATION ) ; return $ this -> resultExtractor -> extract ( $ this -> gateway -> findLocations ( $ query , $ languageFilter ) , $ query -> facetBuilders ) ; } 
public function indexContent ( Content $ content ) { $ this -> gateway -> bulkIndexDocuments ( array ( $ this -> mapper -> mapContentBlock ( $ content ) ) ) ; } 
public function bulkIndexContent ( array $ contentObjects ) { $ documents = array ( ) ; foreach ( $ contentObjects as $ content ) { try { $ documents [ ] = $ this -> mapper -> mapContentBlock ( $ content ) ; } catch ( NotFoundException $ ex ) { 
public function deleteContent ( $ contentId , $ versionId = null ) { $ idPrefix = $ this -> mapper -> generateContentDocumentId ( $ contentId ) ; $ this -> gateway -> deleteByQuery ( "_root_:{$idPrefix}*" ) ; } 
private function logWarning ( OutputInterface $ output , ProgressBar $ progress , $ message ) { $ progress -> clear ( ) ; $ this -> logger -> warning ( $ message ) ; $ progress -> display ( ) ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { return 'location_visible_b:' . ( $ criterion -> value [ 0 ] === Criterion \ Visibility :: VISIBLE ? 'true' : 'false' ) ; } 
public function request ( $ method , Endpoint $ endpoint , $ path , Message $ message = null ) { $ message = $ message ? : new Message ( ) ; 
protected function getRequestHeaders ( Message $ message , Endpoint $ endpoint ) { 
protected function getSearchFields ( Criterion $ criterion , $ fieldDefinitionIdentifier , $ fieldTypeIdentifier = null , $ name = null ) { return $ this -> fieldNameResolver -> getFieldTypes ( $ criterion , $ fieldDefinitionIdentifier , $ fieldTypeIdentifier , $ name ) ; } 
protected function mapSearchFieldValue ( $ value , FieldType $ searchFieldType = null ) { if ( null === $ searchFieldType ) { return $ value ; } $ searchField = new SearchField ( 'field' , $ value , $ searchFieldType ) ; $ value = ( array ) $ this -> fieldValueMapper -> map ( $ searchField ) ; return current ( $ value ) ; } 
public function visitBuilder ( FacetBuilder $ facetBuilder , $ fieldId ) { $ field = self :: DOC_FIELD_MAP [ $ facetBuilder -> type ] ; return array ( 'facet.field' => "{!ex=dt key=${fieldId}}$field" , "f.${field}.facet.limit" => $ facetBuilder -> limit , "f.${field}.facet.mincount" => $ facetBuilder -> minCount , ) ; } 
public function extractHit ( $ hit ) { if ( $ hit -> document_type_id === 'content' ) { return $ this -> extractContentInfoFromHit ( $ hit ) ; } if ( $ hit -> document_type_id === 'location' ) { return $ this -> extractLocationFromHit ( $ hit ) ; } throw new RuntimeException ( "Could not extract: document of type '{$hit->document_type_id}' is not handled." ) ; } 
protected function extractContentInfoFromHit ( $ hit ) { $ contentInfo = new ContentInfo ( [ 'id' => ( int ) $ hit -> content_id_id , 'name' => $ hit -> content_name_s , 'contentTypeId' => ( int ) $ hit -> content_type_id_id , 'sectionId' => ( int ) $ hit -> content_section_id_id , 'currentVersionNo' => $ hit -> content_version_no_i , 'isPublished' => true , 'ownerId' => ( int ) $ hit -> content_owner_user_id_id , 'modificationDate' => strtotime ( $ hit -> content_modification_date_dt ) , 'publicationDate' => strtotime ( $ hit -> content_publication_date_dt ) , 'alwaysAvailable' => $ hit -> content_always_available_b , 'remoteId' => $ hit -> content_remote_id_id , 'mainLanguageCode' => $ hit -> content_main_language_code_s , ] ) ; if ( isset ( $ hit -> main_location_id ) ) { $ contentInfo -> mainLocationId = ( int ) $ hit -> main_location_id ; } return $ contentInfo ; } 
protected function extractLocationFromHit ( $ hit ) { return new Location ( array ( 'id' => ( int ) $ hit -> location_id , 'priority' => $ hit -> priority_i , 'hidden' => $ hit -> hidden_b , 'invisible' => $ hit -> invisible_b , 'remoteId' => $ hit -> remote_id_id , 'contentId' => ( int ) $ hit -> content_id_id , 'parentId' => ( int ) $ hit -> parent_id_id , 'pathString' => $ hit -> path_string_id , 'depth' => $ hit -> depth_i , 'sortField' => ( int ) $ hit -> sort_field_id , 'sortOrder' => ( int ) $ hit -> sort_order_id , ) ) ; } 
public function process ( ContainerBuilder $ container ) { if ( ! $ container -> hasDefinition ( 'ezpublish.search.solr.query.content.sort_clause_visitor.aggregate' ) && ! $ container -> hasDefinition ( 'ezpublish.search.solr.query.location.sort_clause_visitor.aggregate' ) ) { return ; } if ( $ container -> hasDefinition ( 'ezpublish.search.solr.query.content.sort_clause_visitor.aggregate' ) ) { $ aggregateContentSortClauseVisitorDefinition = $ container -> getDefinition ( 'ezpublish.search.solr.query.content.sort_clause_visitor.aggregate' ) ; $ visitors = $ container -> findTaggedServiceIds ( 'ezpublish.search.solr.query.content.sort_clause_visitor' ) ; $ this -> addHandlers ( $ aggregateContentSortClauseVisitorDefinition , $ visitors ) ; } if ( $ container -> hasDefinition ( 'ezpublish.search.solr.query.location.sort_clause_visitor.aggregate' ) ) { $ aggregateLocationSortClauseVisitorDefinition = $ container -> getDefinition ( 'ezpublish.search.solr.query.location.sort_clause_visitor.aggregate' ) ; $ visitors = $ container -> findTaggedServiceIds ( 'ezpublish.search.solr.query.location.sort_clause_visitor' ) ; $ this -> addHandlers ( $ aggregateLocationSortClauseVisitorDefinition , $ visitors ) ; } } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ queries = array ( ) ; $ values = ( array ) $ criterion -> value ; foreach ( $ values as $ value ) { $ preparedValue = $ this -> escapeQuote ( $ this -> toString ( $ value ) , true ) ; if ( $ this -> isRegExp ( $ preparedValue ) ) { $ queries [ ] = $ criterion -> target . ':' . $ preparedValue ; } else { $ queries [ ] = $ criterion -> target . ':"' . $ preparedValue . '"' ; } } return '(' . implode ( ' OR ' , $ queries ) . ')' ; } 
public function findContent ( Query $ query , array $ languageSettings = array ( ) ) { $ parameters = $ this -> contentQueryConverter -> convert ( $ query ) ; return $ this -> internalFind ( $ parameters , $ languageSettings ) ; } 
public function findLocations ( Query $ query , array $ languageSettings = array ( ) ) { $ parameters = $ this -> locationQueryConverter -> convert ( $ query ) ; return $ this -> internalFind ( $ parameters , $ languageSettings ) ; } 
protected function internalFind ( array $ parameters , array $ languageSettings = array ( ) ) { $ searchTargets = $ this -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ searchTargets ) ) { $ parameters [ 'shards' ] = $ searchTargets ; } return $ this -> search ( $ parameters ) ; } 
protected function generateQueryString ( array $ parameters ) { $ removedArrayCharacters = preg_replace ( '/%5B[0-9]+%5D=/' , '=' , http_build_query ( $ parameters ) ) ; $ removedDuplicatedEscapingForUrlPath = str_replace ( '%5C%5C%2F' , '%5C%2F' , $ removedArrayCharacters ) ; return $ removedDuplicatedEscapingForUrlPath ; } 
protected function getSearchTargets ( $ languageSettings ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = array ( ) ; $ endpoints = $ this -> endpointResolver -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ endpoints ) ) { foreach ( $ endpoints as $ endpoint ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpoint ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; } 
protected function getAllSearchTargets ( ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = [ ] ; $ searchTargets = $ this -> endpointResolver -> getEndpoints ( ) ; if ( ! empty ( $ searchTargets ) ) { foreach ( $ searchTargets as $ endpointName ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; } 
public function bulkIndexDocuments ( array $ documents ) { $ documentMap = array ( ) ; $ mainTranslationsEndpoint = $ this -> endpointResolver -> getMainLanguagesEndpoint ( ) ; $ mainTranslationsDocuments = array ( ) ; foreach ( $ documents as $ translationDocuments ) { foreach ( $ translationDocuments as $ document ) { $ documentMap [ $ document -> languageCode ] [ ] = $ document ; if ( $ mainTranslationsEndpoint !== null && $ document -> isMainTranslation ) { $ mainTranslationsDocuments [ ] = $ this -> getMainTranslationDocument ( $ document ) ; } } } foreach ( $ documentMap as $ languageCode => $ translationDocuments ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getIndexingTarget ( $ languageCode ) ) , $ translationDocuments ) ; } if ( ! empty ( $ mainTranslationsDocuments ) ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ mainTranslationsEndpoint ) , $ mainTranslationsDocuments ) ; } } 
protected function getMainTranslationDocument ( Document $ document ) { 
public function deleteByQuery ( $ query ) { $ endpoints = $ this -> endpointResolver -> getEndpoints ( ) ; foreach ( $ endpoints as $ endpointName ) { $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) , '/update?wt=json' , new Message ( array ( 'Content-Type' => 'text/xml' , ) , "<delete><query>{$query}</query></delete>" ) ) ; } } 
public function purgeIndex ( ) { $ endpoints = $ this -> endpointResolver -> getEndpoints ( ) ; foreach ( $ endpoints as $ endpointName ) { $ this -> purgeEndpoint ( $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) ) ; } } 
public function commit ( $ flush = false ) { $ payload = $ flush ? '<commit/>' : '<commit softCommit="true"/>' ; foreach ( $ this -> endpointResolver -> getEndpoints ( ) as $ endpointName ) { $ result = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) , '/update' , new Message ( array ( 'Content-Type' => 'text/xml' , ) , $ payload ) ) ; if ( $ result -> headers [ 'status' ] !== 200 ) { throw new RuntimeException ( 'Wrong HTTP status received from Solr: ' . $ result -> headers [ 'status' ] . var_export ( $ result , true ) ) ; } } } 
protected function search ( array $ parameters ) { $ queryString = $ this -> generateQueryString ( $ parameters ) ; $ response = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getEntryEndpoint ( ) ) , '/select' , new Message ( [ 'Content-Type' => 'application/x-www-form-urlencoded' , ] , $ queryString ) ) ; 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ start = $ this -> getSolrTime ( $ criterion -> value [ 0 ] ) ; $ end = isset ( $ criterion -> value [ 1 ] ) ? $ this -> getSolrTime ( $ criterion -> value [ 1 ] ) : null ; if ( ( $ criterion -> operator === Operator :: LT ) || ( $ criterion -> operator === Operator :: LTE ) ) { $ end = $ start ; $ start = null ; } return 'content_modification_date_dt:' . $ this -> getRange ( $ criterion -> operator , $ start , $ end ) ; } 
public function mapField ( $ field , array $ data , FacetBuilder $ facetBuilder ) { return new Facet \ ContentTypeFacet ( array ( 'name' => $ facetBuilder -> name , 'entries' => $ this -> mapData ( $ data ) , ) ) ; } 
public function getEndpoint ( $ name ) { if ( ! isset ( $ this -> endpoint [ $ name ] ) ) { throw new OutOfBoundsException ( "No Endpoint registered for '{$name}'." ) ; } return $ this -> endpoint [ $ name ] ; } 
public function canVisit ( Criterion $ criterion ) { return $ criterion instanceof Criterion \ FieldRelation && ( ( $ criterion -> operator ? : Operator :: IN ) === Operator :: IN || $ criterion -> operator === Operator :: CONTAINS ) ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ searchFields = $ this -> getSearchFields ( $ criterion , $ criterion -> target ) ; if ( empty ( $ searchFields ) ) { throw new InvalidArgumentException ( '$criterion->target' , "No searchable fields found for the given criterion target '{$criterion->target}'." ) ; } $ criterion -> value = ( array ) $ criterion -> value ; $ queries = array ( ) ; foreach ( $ searchFields as $ name => $ fieldType ) { foreach ( $ criterion -> value as $ value ) { $ preparedValues = ( array ) $ this -> mapSearchFieldvalue ( $ value , $ fieldType ) ; foreach ( $ preparedValues as $ prepValue ) { $ queries [ ] = $ name . ':"' . $ this -> escapeQuote ( $ this -> toString ( $ prepValue ) , true ) . '"' ; } } } switch ( $ criterion -> operator ) { case Operator :: CONTAINS : $ op = ' AND ' ; break ; case Operator :: IN : default : $ op = ' OR ' ; } return '(' . implode ( $ op , $ queries ) . ')' ; } 
protected function getSortFieldName ( SortClause $ sortClause , $ contentTypeIdentifier , $ fieldDefinitionIdentifier ) { return $ this -> fieldNameResolver -> getSortFieldName ( $ sortClause , $ contentTypeIdentifier , $ fieldDefinitionIdentifier ) ; } 
public function extract ( $ data , array $ facetBuilders = [ ] ) { $ result = new SearchResult ( array ( 'time' => $ data -> responseHeader -> QTime / 1000 , 'maxScore' => $ data -> response -> maxScore , 'totalCount' => $ data -> response -> numFound , ) ) ; if ( isset ( $ data -> facet_counts ) ) { 
public function hasMultipleEndpoints ( ) { if ( $ this -> hasMultiple !== null ) { return $ this -> hasMultiple ; } $ endpointSet = array_flip ( $ this -> endpointMap ) ; if ( isset ( $ this -> defaultEndpoint ) ) { $ endpointSet [ $ this -> defaultEndpoint ] = true ; } if ( isset ( $ this -> mainLanguagesEndpoint ) ) { $ endpointSet [ $ this -> mainLanguagesEndpoint ] = true ; } return $ this -> hasMultiple = count ( $ endpointSet ) > 1 ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { return 'is_main_location_b:' . ( $ criterion -> value [ 0 ] === Criterion \ Location \ IsMainLocation :: MAIN ? 'true' : 'false' ) ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { if ( ! isset ( $ criterion -> criteria [ 0 ] ) ) { throw new RuntimeException ( 'Invalid aggregation in LogicalAnd criterion.' ) ; } $ subCriteria = array_map ( function ( $ value ) use ( $ subVisitor ) { return $ subVisitor -> visit ( $ value ) ; } , $ criterion -> criteria ) ; if ( count ( $ subCriteria ) === 1 ) { return reset ( $ subCriteria ) ; } return '(' . implode ( ' AND ' , $ subCriteria ) . ')' ; } 
protected function processConnectionConfiguration ( ContainerBuilder $ container , array $ config ) { $ alias = $ this -> getAlias ( ) ; if ( isset ( $ config [ 'default_connection' ] ) ) { $ container -> setParameter ( "{$alias}.default_connection" , $ config [ 'default_connection' ] ) ; } elseif ( ! empty ( $ config [ 'connections' ] ) ) { reset ( $ config [ 'connections' ] ) ; $ container -> setParameter ( "{$alias}.default_connection" , key ( $ config [ 'connections' ] ) ) ; } foreach ( $ config [ 'connections' ] as $ name => $ params ) { $ this -> configureSearchServices ( $ container , $ name , $ params ) ; $ this -> configureBoostMap ( $ container , $ name , $ params ) ; $ this -> configureIndexingDepth ( $ container , $ name , $ params ) ; $ container -> setParameter ( "$alias.connection.$name" , $ params ) ; } foreach ( $ config [ 'endpoints' ] as $ name => $ params ) { $ this -> defineEndpoint ( $ container , $ name , $ params ) ; } 
private function configureSearchServices ( ContainerBuilder $ container , $ connectionName , $ connectionParams ) { $ alias = $ this -> getAlias ( ) ; 
private function configureBoostMap ( ContainerBuilder $ container , $ connectionName , $ connectionParams ) { $ alias = $ this -> getAlias ( ) ; $ boostFactorMap = $ this -> buildBoostFactorMap ( $ connectionParams [ 'boost_factors' ] ) ; $ boostFactorMapId = "{$alias}.connection.{$connectionName}.boost_factor_map_id" ; $ container -> setParameter ( $ boostFactorMapId , $ boostFactorMap ) ; } 
private function configureIndexingDepth ( ContainerBuilder $ container , $ connectionName , $ connectionParams ) { $ alias = $ this -> getAlias ( ) ; $ defaultIndexingDepthId = "{$alias}.connection.{$connectionName}.indexing_depth.default" ; $ contentTypeIndexingDepthMapId = "{$alias}.connection.{$connectionName}.indexing_depth.map" ; $ container -> setParameter ( $ defaultIndexingDepthId , $ connectionParams [ 'indexing_depth' ] [ 'default' ] ) ; $ container -> setParameter ( $ contentTypeIndexingDepthMapId , $ connectionParams [ 'indexing_depth' ] [ 'content_type' ] ) ; } 
protected function defineEndpoint ( ContainerBuilder $ container , $ alias , $ params ) { $ definition = new Definition ( self :: ENDPOINT_CLASS , array ( $ params ) ) ; $ definition -> addTag ( self :: ENDPOINT_TAG , array ( 'alias' => $ alias ) ) ; $ container -> setDefinition ( sprintf ( $ this -> getAlias ( ) . '.endpoints.%s' , $ alias ) , $ definition ) ; } 
protected function buildBoostFactorMap ( array $ config ) { $ boostFactorMap = [ ] ; foreach ( $ config [ 'content_type' ] as $ typeIdentifier => $ factor ) { $ boostFactorMap [ 'content-fields' ] [ $ typeIdentifier ] [ '*' ] = $ factor ; $ boostFactorMap [ 'meta-fields' ] [ $ typeIdentifier ] [ '*' ] = $ factor ; } foreach ( $ config [ 'field_definition' ] as $ typeIdentifier => $ mapping ) { foreach ( $ mapping as $ fieldIdentifier => $ factor ) { $ boostFactorMap [ 'content-fields' ] [ $ typeIdentifier ] [ $ fieldIdentifier ] = $ factor ; } } foreach ( $ config [ 'meta_field' ] as $ typeIdentifier => $ mapping ) { foreach ( $ mapping as $ fieldIdentifier => $ factor ) { $ boostFactorMap [ 'meta-fields' ] [ $ typeIdentifier ] [ $ fieldIdentifier ] = $ factor ; } } return $ boostFactorMap ; } 
public function canVisit ( Criterion $ criterion ) { return $ criterion instanceof Criterion \ Location \ Priority && ( ( $ criterion -> operator ? : Operator :: IN ) === Operator :: IN || $ criterion -> operator === Operator :: EQ ) ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ values = array ( ) ; foreach ( $ criterion -> value as $ value ) { $ values [ ] = 'priority_i:"' . $ value . '"' ; } return '(' . implode ( ' OR ' , $ values ) . ')' ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ searchFields = $ this -> getSearchFields ( $ criterion ) ; if ( empty ( $ searchFields ) ) { throw new InvalidArgumentException ( '$criterion->target' , "No searchable fields found for the given criterion target '{$criterion->target}'." ) ; } $ value = ( array ) $ criterion -> value ; $ queries = array ( ) ; foreach ( $ searchFields as $ name => $ fieldType ) { $ start = $ this -> mapSearchFieldValue ( $ value [ 0 ] , $ fieldType ) ; $ end = isset ( $ value [ 1 ] ) ? $ this -> mapSearchFieldvalue ( $ value [ 1 ] , $ fieldType ) : null ; if ( ( $ criterion -> operator === Operator :: LT ) || ( $ criterion -> operator === Operator :: LTE ) ) { $ end = $ start ; $ start = null ; } $ queries [ ] = $ name . ':' . $ this -> getRange ( $ criterion -> operator , $ start , $ end ) ; } return '(' . implode ( ' OR ' , $ queries ) . ')' ; } 
protected function getRange ( $ operator , $ start , $ end ) { $ startBrace = '[' ; $ startValue = '*' ; $ endValue = '*' ; $ endBrace = ']' ; $ start = '"' . $ this -> escapeQuote ( $ this -> toString ( $ start ) , true ) . '"' ; $ end = '"' . $ this -> escapeQuote ( $ this -> toString ( $ end ) , true ) . '"' ; switch ( $ operator ) { case Operator :: GT : $ startBrace = '{' ; $ endBrace = '}' ; 
protected function escapeExpressions ( $ string , $ allowWildcard = false ) { if ( $ allowWildcard ) { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~?:\\ ' ) ; } else { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~*?:\\ ' ) ; } return preg_replace_callback ( '/([' . $ reservedCharacters . '])/' , function ( $ matches ) { return '\\' . $ matches [ 0 ] ; } , $ string ) ; } 
protected function addEndpointsSection ( ArrayNodeDefinition $ node ) { $ node -> children ( ) -> arrayNode ( 'endpoints' ) -> info ( 'Solr Search Engine endpoint configuration' ) -> useAttributeAsKey ( 'endpoint_name' ) -> performNoDeepMerging ( ) -> prototype ( 'array' ) -> children ( ) 
protected function addConnectionsSection ( ArrayNodeDefinition $ node ) { $ node -> children ( ) -> scalarNode ( 'default_connection' ) -> info ( 'Name of the default connection' ) -> end ( ) -> arrayNode ( 'connections' ) -> info ( 'Solr Search Engine connection configuration' ) -> useAttributeAsKey ( 'connection_name' ) -> performNoDeepMerging ( ) -> prototype ( 'array' ) -> beforeNormalization ( ) -> ifTrue ( function ( $ v ) { return ! empty ( $ v [ 'mapping' ] ) && ! is_array ( $ v [ 'mapping' ] ) ; } ) -> then ( function ( $ v ) { 
public function mapFields ( Content $ content , $ languageCode ) { $ contentType = $ this -> contentTypeHandler -> load ( $ content -> versionInfo -> contentInfo -> contentTypeId ) ; $ maxDepth = $ this -> indexingDepthProvider -> getMaxDepthForContent ( $ contentType ) ; return $ this -> doMapFields ( $ content , $ contentType , $ languageCode , $ maxDepth ) ; } 
private function doMapFields ( Content $ content , ContentType $ contentType , $ languageCode , $ maxDepth , $ depth = 0 ) { $ fields = [ ] ; foreach ( $ content -> fields as $ field ) { if ( $ field -> languageCode !== $ languageCode ) { continue ; } foreach ( $ contentType -> fieldDefinitions as $ fieldDefinition ) { if ( $ fieldDefinition -> id !== $ field -> fieldDefinitionId ) { continue ; } $ fieldType = $ this -> fieldRegistry -> getType ( $ field -> type ) ; $ indexFields = $ fieldType -> getIndexData ( $ field , $ fieldDefinition ) ; foreach ( $ indexFields as $ indexField ) { if ( $ indexField -> value === null ) { continue ; } if ( ! $ indexField -> type instanceof FieldType \ FullTextField || ! $ fieldDefinition -> isSearchable ) { continue ; } $ fields [ ] = new Field ( $ this -> getIndexFieldName ( $ depth ) , $ indexField -> value , $ this -> getIndexFieldType ( $ contentType ) ) ; } } } if ( $ depth < $ maxDepth ) { $ relatedFields = $ this -> doMapRelatedFields ( $ content , $ languageCode , $ maxDepth , $ depth + 1 ) ; foreach ( $ relatedFields as $ field ) { $ fields [ ] = $ field ; } } return $ fields ; } 
private function doMapRelatedFields ( Content $ sourceContent , $ languageCode , $ maxDepth , $ depth ) { $ relations = $ this -> contentHandler -> loadRelations ( $ sourceContent -> versionInfo -> contentInfo -> id ) ; $ relatedContents = $ this -> contentHandler -> loadContentList ( array_map ( function ( Content \ Relation $ relation ) { return $ relation -> destinationContentId ; } , $ relations ) ) ; $ contentTypes = $ this -> contentTypeHandler -> loadContentTypeList ( array_map ( function ( Content $ content ) { return $ content -> versionInfo -> contentInfo -> contentTypeId ; } , $ relatedContents ) ) ; $ fields = [ ] ; foreach ( $ relatedContents as $ relatedContent ) { $ contentTypeId = $ relatedContent -> versionInfo -> contentInfo -> contentTypeId ; $ relatedFields = $ this -> doMapFields ( $ relatedContent , $ contentTypes [ $ contentTypeId ] , $ languageCode , $ maxDepth , $ depth ) ; foreach ( $ relatedFields as $ field ) { $ fields [ ] = $ field ; } } return $ fields ; } 
private function getIndexFieldName ( int $ depth ) : string { if ( $ depth === 0 ) { return self :: $ fieldName ; } return sprintf ( self :: $ relatedContentFieldName , $ depth ) ; } 
private function getIndexFieldType ( ContentType $ contentType ) { $ newFieldType = new FieldType \ TextField ( ) ; $ newFieldType -> boost = $ this -> boostFactorProvider -> getContentMetaFieldBoostFactor ( $ contentType , 'text' ) ; return $ newFieldType ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ contentTypeHandler = $ this -> contentTypeHandler ; return '(' . implode ( ' OR ' , array_map ( function ( $ value ) use ( $ contentTypeHandler ) { return 'content_type_id_id:"' . $ contentTypeHandler -> loadByIdentifier ( $ value ) -> id . '"' ; } , $ criterion -> value ) ) . ')' ; } 
public function getContentFieldBoostFactor ( ContentType $ contentType , FieldDefinition $ fieldDefinition ) { $ typeIdentifier = $ contentType -> identifier ; $ fieldIdentifier = $ fieldDefinition -> identifier ; if ( ! isset ( $ this -> map [ self :: $ keyContentFields ] [ $ typeIdentifier ] ) ) { $ typeIdentifier = self :: $ keyAny ; } if ( ! isset ( $ this -> map [ self :: $ keyContentFields ] [ $ typeIdentifier ] [ $ fieldIdentifier ] ) ) { $ fieldIdentifier = self :: $ keyAny ; } if ( isset ( $ this -> map [ self :: $ keyContentFields ] [ $ typeIdentifier ] [ $ fieldIdentifier ] ) ) { return $ this -> map [ self :: $ keyContentFields ] [ $ typeIdentifier ] [ $ fieldIdentifier ] ; } return $ this -> defaultBoostFactor ; } 
public function getContentMetaFieldBoostFactor ( ContentType $ contentType , $ fieldName ) { $ typeIdentifier = $ contentType -> identifier ; if ( ! isset ( $ this -> map [ self :: $ keyMetaFields ] [ $ typeIdentifier ] ) ) { $ typeIdentifier = self :: $ keyAny ; } if ( ! isset ( $ this -> map [ self :: $ keyMetaFields ] [ $ typeIdentifier ] [ $ fieldName ] ) ) { $ fieldName = self :: $ keyAny ; } if ( isset ( $ this -> map [ self :: $ keyMetaFields ] [ $ typeIdentifier ] [ $ fieldName ] ) ) { return $ this -> map [ self :: $ keyMetaFields ] [ $ typeIdentifier ] [ $ fieldName ] ; } return $ this -> defaultBoostFactor ; } 
public function serialize ( array $ documents ) { $ xmlWriter = new XMLWriter ( ) ; $ xmlWriter -> openMemory ( ) ; $ xmlWriter -> startElement ( 'add' ) ; foreach ( $ documents as $ document ) { if ( empty ( $ document -> documents ) ) { $ document -> documents [ ] = $ this -> getNestedDummyDocument ( $ document -> id ) ; } $ this -> writeDocument ( $ xmlWriter , $ document ) ; } $ xmlWriter -> endElement ( ) ; return $ xmlWriter -> outputMemory ( true ) ; } 
public function canVisit ( Criterion $ criterion ) { return $ criterion instanceof Criterion \ MapLocationDistance && ( ( $ criterion -> operator ? : Operator :: IN ) === Operator :: IN || $ criterion -> operator === Operator :: EQ ) ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ location = $ criterion -> valueData ; $ criterion -> value = ( array ) $ criterion -> value ; $ searchFields = $ this -> getSearchFields ( $ criterion , $ criterion -> target , $ this -> fieldTypeIdentifier , $ this -> fieldName ) ; if ( empty ( $ searchFields ) ) { throw new InvalidArgumentException ( '$criterion->target' , "No searchable fields found for the given criterion target '{$criterion->target}'." ) ; } $ queries = array ( ) ; foreach ( $ criterion -> value as $ value ) { foreach ( $ searchFields as $ name => $ fieldType ) { $ queries [ ] = sprintf ( 'geodist(%s,%F,%F):%s' , $ name , $ location -> latitude , $ location -> longitude , $ value ) ; } } return '(' . implode ( ' OR ' , $ queries ) . ')' ; } 
private function getCoreCriterion ( array $ languageCodes , $ useAlwaysAvailable ) { 
private function getLanguageFilter ( array $ languageCodes ) { $ languageFilters = array ( ) ; foreach ( $ languageCodes as $ languageCode ) { 
private function getAlwaysAvailableFilter ( array $ languageCodes ) { $ conditions = array ( 
private function getExcludedLanguageCodes ( array $ languageCodes , $ selectedLanguageCode = null ) { $ excludedLanguageCodes = array ( ) ; foreach ( $ languageCodes as $ languageCode ) { if ( $ selectedLanguageCode !== null && $ languageCode === $ selectedLanguageCode ) { break ; } $ excludedLanguageCodes [ ] = $ languageCode ; } return $ excludedLanguageCodes ; } 
public function canVisit ( Criterion $ criterion ) { return $ criterion instanceof Criterion \ Field && $ criterion -> operator === Operator :: LIKE ; } 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ searchFields = $ this -> getSearchFields ( $ criterion ) ; if ( empty ( $ searchFields ) ) { throw new InvalidArgumentException ( '$criterion->target' , "No searchable fields found for the given criterion target '{$criterion->target}'." ) ; } $ queries = [ ] ; foreach ( $ searchFields as $ name => $ fieldType ) { $ preparedValue = $ this -> toString ( $ this -> mapSearchFieldValue ( $ criterion -> value , $ fieldType ) ) ; 
private function getIndexFieldType ( ContentType $ contentType , FieldDefinition $ fieldDefinition , FieldType $ fieldType ) { if ( ! $ fieldType instanceof FieldType \ TextField ) { return $ fieldType ; } $ fieldType = clone $ fieldType ; $ fieldType -> boost = $ this -> boostFactorProvider -> getContentFieldBoostFactor ( $ contentType , $ fieldDefinition ) ; return $ fieldType ; } 
private function getFacetParams ( array $ facetBuilders ) { $ facetSets = array_map ( function ( $ facetBuilder ) { return $ this -> facetBuilderVisitor -> visitBuilder ( $ facetBuilder , spl_object_hash ( $ facetBuilder ) ) ; } , $ facetBuilders ) ; $ facetParams = array ( ) ; 
public function visit ( Criterion $ criterion , CriterionVisitor $ subVisitor = null ) { $ tokenSequence = $ this -> tokenizer -> tokenize ( $ criterion -> value ) ; $ syntaxTree = $ this -> parser -> parse ( $ tokenSequence ) ; $ options = [ ] ; if ( $ criterion -> fuzziness < 1 ) { $ options [ 'fuzziness' ] = $ criterion -> fuzziness ; } $ queryString = $ this -> generator -> generate ( $ syntaxTree , $ options ) ; $ queryStringEscaped = $ this -> escapeQuote ( $ queryString ) ; $ queryFields = $ this -> getQueryFields ( $ criterion ) ; return "{!edismax v='{$queryStringEscaped}' qf='{$queryFields}' uf=-*}" ; } 
protected function mapData ( array $ data ) { $ values = array ( ) ; reset ( $ data ) ; while ( $ key = current ( $ data ) ) { $ values [ $ key ] = next ( $ data ) ; next ( $ data ) ; } return $ values ; } 
public static function loadMessagesAndVersions ( $ wsdls ) { $ msgAndVer = [ ] ; foreach ( $ wsdls as $ wsdl ) { $ wsdlIdentifier = self :: makeWsdlIdentifier ( $ wsdl ) ; self :: $ wsdlIds [ $ wsdlIdentifier ] = $ wsdl ; self :: loadWsdlXpath ( $ wsdl , $ wsdlIdentifier ) ; $ operations = self :: $ wsdlDomXpath [ $ wsdlIdentifier ] -> query ( self :: XPATH_ALL_OPERATIONS ) ; if ( $ operations -> length === 0 ) { 
protected static function getMessagesAndVersionsFromImportedWsdl ( $ import , $ wsdlPath , $ wsdlIdentifier ) { $ msgAndVer = [ ] ; $ domXpath = null ; $ importPath = realpath ( dirname ( $ wsdlPath ) ) . DIRECTORY_SEPARATOR . $ import ; $ wsdlContent = file_get_contents ( $ importPath ) ; if ( $ wsdlContent !== false ) { $ domDoc = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ ok = $ domDoc -> loadXML ( $ wsdlContent ) ; if ( $ ok === true ) { $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; $ domXpath -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ importPath . ' import could not be loaded' ) ; } if ( $ domXpath instanceof \ DOMXPath ) { $ nodeList = $ domXpath -> query ( self :: XPATH_ALL_OPERATIONS ) ; $ msgAndVer = array_merge ( $ msgAndVer , self :: loopOperationsWithQuery ( $ nodeList , self :: XPATH_ALT_VERSION_FOR_OPERATION , $ wsdlIdentifier , $ domXpath ) ) ; } return $ msgAndVer ; } 
public static function loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) { if ( ! isset ( self :: $ wsdlDomXpath [ $ wsdlId ] ) || is_null ( self :: $ wsdlDomXpath [ $ wsdlId ] ) ) { $ wsdlContent = file_get_contents ( $ wsdlFilePath ) ; if ( $ wsdlContent !== false ) { self :: $ wsdlDomDoc [ $ wsdlId ] = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; self :: $ wsdlDomDoc [ $ wsdlId ] -> loadXML ( $ wsdlContent ) ; self :: $ wsdlDomXpath [ $ wsdlId ] = new \ DOMXPath ( self :: $ wsdlDomDoc [ $ wsdlId ] ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ wsdlFilePath . ' could not be loaded' ) ; } } } 
protected static function extractMessageVersion ( $ fullVersionString ) { $ marker = strpos ( $ fullVersionString , '_' , strpos ( $ fullVersionString , '_' ) + 1 ) ; $ num = substr ( $ fullVersionString , $ marker + 1 ) ; return str_replace ( '_' , '.' , $ num ) ; } 
public static function exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , $ xpath ) { WsdlAnalyser :: loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) ; return self :: $ wsdlDomXpath [ $ wsdlId ] -> evaluate ( $ xpath ) ; } 
protected static function loopOperationsWithQuery ( $ operations , $ query , $ wsdlIdentifier , $ domXpath ) { $ msgAndVer = [ ] ; foreach ( $ operations as $ operation ) { if ( ! empty ( $ operation -> value ) ) { $ fullVersion = $ domXpath -> evaluate ( sprintf ( $ query , $ operation -> value ) ) ; if ( ! empty ( $ fullVersion ) ) { $ extractedVersion = self :: extractMessageVersion ( $ fullVersion ) ; $ msgAndVer [ $ operation -> value ] = [ 'version' => $ extractedVersion , 'wsdl' => $ wsdlIdentifier ] ; } } } return $ msgAndVer ; } 
public function __doRequest ( $ request , $ location , $ action , $ version , $ oneWay = null ) { if ( ! extension_loaded ( 'xsl' ) ) { throw new Exception ( 'PHP XSL extension is not enabled.' ) ; } $ newRequest = $ this -> transformIncomingRequest ( $ request ) ; return parent :: __doRequest ( $ newRequest , $ location , $ action , $ version , $ oneWay ) ; } 
protected function loadCabinAndBookingClass ( $ criteria ) { foreach ( $ criteria -> cabins as $ cabin ) { $ this -> cabinProduct [ ] = new CabinProduct ( $ cabin ) ; } $ this -> rdb = $ criteria -> bookingCode ; } 
protected function convertTicketType ( $ optionsTicketType ) { $ converted = null ; $ map = [ FarePricePnrWithBookingClassOptions :: TICKET_TYPE_ELECTRONIC => AttributeDetails :: OVERRIDE_ELECTRONIC_TICKET , FarePricePnrWithBookingClassOptions :: TICKET_TYPE_PAPER => AttributeDetails :: OVERRIDE_PAPER_TICKET , FarePricePnrWithBookingClassOptions :: TICKET_TYPE_BOTH => AttributeDetails :: OVERRIDE_BOTH_TICKET , ] ; if ( array_key_exists ( $ optionsTicketType , $ map ) ) { $ converted = $ map [ $ optionsTicketType ] ; } return $ converted ; } 
protected function loadFareBasis ( $ options ) { $ short = AttributeDetails :: OVERRIDE_FAREBASIS ; 
protected function loadFopGroup ( FopCreateFopOptions $ options ) { foreach ( $ options -> fopGroup as $ group ) { if ( $ this instanceof CreateFormOfPayment14 ) { $ this -> fopGroup [ ] = new FopGroup14 ( $ group ) ; } else { $ this -> fopGroup [ ] = new FopGroup ( $ group ) ; } } } 
public function createRequest ( $ messageName , RequestOptionsInterface $ params ) { $ this -> checkMessageIsInWsdl ( $ messageName ) ; $ builder = $ this -> findBuilderForMessage ( $ messageName ) ; if ( $ builder instanceof ConvertInterface ) { return $ builder -> convert ( $ params , $ this -> getActiveVersionFor ( $ messageName ) ) ; } else { throw new \ RuntimeException ( 'No builder found for message ' . $ messageName ) ; } } 
protected function getActiveVersionFor ( $ messageName ) { $ found = null ; if ( isset ( $ this -> messagesAndVersions [ $ messageName ] ) && isset ( $ this -> messagesAndVersions [ $ messageName ] [ 'version' ] ) ) { $ found = $ this -> messagesAndVersions [ $ messageName ] [ 'version' ] ; } return $ found ; } 
protected function findBuilderForMessage ( $ messageName ) { $ builder = null ; if ( array_key_exists ( $ messageName , $ this -> messageBuilders ) && $ this -> messageBuilders [ $ messageName ] instanceof ConvertInterface ) { $ builder = $ this -> messageBuilders [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ builderClass = __NAMESPACE__ . '\\Converter\\' . $ section . '\\' . $ message . "Conv" ; if ( class_exists ( $ builderClass ) ) { $ builder = new $ builderClass ( ) ; $ builder -> setParams ( $ this -> params ) ; $ this -> messageBuilders [ $ messageName ] = $ builder ; } } return $ builder ; } 
public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; 
protected function makeStatusForPotentiallyNonExistent ( $ errorCatNode ) { if ( $ errorCatNode instanceof \ DOMNode ) { $ status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } else { $ status = Result :: STATUS_ERROR ; } return $ status ; } 
protected function addInfant ( $ traveller ) { $ this -> passengerData [ 0 ] -> travellerInformation -> traveller -> quantity = 2 ; if ( $ traveller -> withInfant && is_null ( $ traveller -> infant ) ) { $ this -> makePassengerIfNeeded ( ) ; $ this -> passengerData [ 0 ] -> travellerInformation -> passenger [ 0 ] -> infantIndicator = Passenger :: INF_NOINFO ; } elseif ( $ traveller -> infant instanceof TravellerOptions ) { if ( empty ( $ traveller -> infant -> lastName ) ) { $ this -> makePassengerIfNeeded ( ) ; $ this -> passengerData [ 0 ] -> travellerInformation -> passenger [ 0 ] -> infantIndicator = Passenger :: INF_GIVEN ; $ tmpInfantPassenger = new Passenger ( $ traveller -> infant -> firstName , Passenger :: PASST_INFANT ) ; $ this -> passengerData [ 0 ] -> travellerInformation -> passenger [ ] = $ tmpInfantPassenger ; } else { $ this -> makePassengerIfNeeded ( ) ; $ this -> passengerData [ 0 ] -> travellerInformation -> passenger [ 0 ] -> infantIndicator = Passenger :: INF_FULL ; $ tmpInfant = new PassengerData ( $ traveller -> infant -> lastName ) ; $ tmpInfant -> travellerInformation -> passenger [ ] = new Passenger ( $ traveller -> infant -> firstName , Passenger :: PASST_INFANT ) ; if ( $ traveller -> infant -> dateOfBirth instanceof \ DateTime ) { $ tmpInfant -> dateOfBirth = new DateOfBirth ( $ this -> formatDateOfBirth ( $ traveller -> infant -> dateOfBirth ) ) ; } $ this -> passengerData [ ] = $ tmpInfant ; } } } 
protected function makePassengerIfNeeded ( ) { if ( count ( $ this -> passengerData [ 0 ] -> travellerInformation -> passenger ) < 1 ) { $ this -> passengerData [ 0 ] -> travellerInformation -> passenger [ 0 ] = new Passenger ( null , null ) ; } } 
public function setStatus ( $ newStatus ) { if ( $ this -> isWorseStatus ( $ newStatus , $ this -> status ) ) { $ this -> status = $ newStatus ; } } 
protected function isWorseStatus ( $ newStatus , $ currentStatus ) { $ levels = [ self :: STATUS_UNKNOWN => - 1 , self :: STATUS_OK => 0 , self :: STATUS_INFO => 2 , self :: STATUS_WARN => 5 , self :: STATUS_ERROR => 10 , self :: STATUS_FATAL => 20 , ] ; return ( $ currentStatus === null || $ levels [ $ newStatus ] > $ levels [ $ currentStatus ] ) ; } 
public function setConsumerId ( $ id ) { $ this -> sessionHandler -> setTransactionFlowLink ( true ) ; $ this -> sessionHandler -> setConsumerId ( $ id ) ; } 
public function securityAuthenticate ( ) { $ msgName = 'Security_Authenticate' ; return $ this -> callMessage ( $ msgName , new RequestOptions \ SecurityAuthenticateOptions ( $ this -> authParams ) , [ ] , false ) ; } 
public function pnrRetrieve ( RequestOptions \ PnrRetrieveOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Retrieve' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function pnrSplit ( RequestOptions \ PnrSplitOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Split' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function pnrCreatePnr ( RequestOptions \ PnrCreatePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function pnrAddMultiElements ( RequestOptions \ PnrAddMultiElementsOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function pnrRetrieveAndDisplay ( RequestOptions \ PnrRetrieveAndDisplayOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_RetrieveAndDisplay' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function pnrCancel ( RequestOptions \ PnrCancelOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Cancel' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function pnrDisplayHistory ( RequestOptions \ PnrDisplayHistoryOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_DisplayHistory' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function pnrTransferOwnership ( RequestOptions \ PnrTransferOwnershipOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_TransferOwnership' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function pnrNameChange ( RequestOptions \ PnrNameChangeOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_NameChange' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function queueList ( RequestOptions \ QueueListOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Queue_List' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function queuePlacePnr ( RequestOptions \ QueuePlacePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Queue_PlacePNR' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function pnrIgnore ( RequestOptions \ PnrIgnoreOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Ignore' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function queueRemoveItem ( RequestOptions \ QueueRemoveItemOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Queue_RemoveItem' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function queueMoveItem ( RequestOptions \ QueueMoveItemOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Queue_MoveItem' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function offerCreate ( RequestOptions \ OfferCreateOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Offer_CreateOffer' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function offerVerify ( RequestOptions \ OfferVerifyOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Offer_VerifyOffer' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function offerConfirmAir ( RequestOptions \ OfferConfirmAirOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Offer_ConfirmAirOffer' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function offerConfirmHotel ( RequestOptions \ OfferConfirmHotelOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Offer_ConfirmHotelOffer' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function offerConfirmCar ( RequestOptions \ OfferConfirmCarOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Offer_ConfirmCarOffer' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function fareMasterPricerTravelBoardSearch ( RequestOptions \ FareMasterPricerTbSearch $ options , $ messageOptions = [ ] ) { $ msgName = 'Fare_MasterPricerTravelBoardSearch' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function fareMasterPricerCalendar ( RequestOptions \ FareMasterPricerCalendarOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Fare_MasterPricerCalendar' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function farePricePnrWithBookingClass ( RequestOptions \ FarePricePnrWithBookingClassOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Fare_PricePNRWithBookingClass' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function farePricePnrWithLowerFares ( RequestOptions \ FarePricePnrWithLowerFaresOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Fare_PricePNRWithLowerFares' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function farePricePnrWithLowestFare ( RequestOptions \ FarePricePnrWithLowestFareOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Fare_PricePNRWithLowestFare' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function fareInformativePricingWithoutPnr ( RequestOptions \ FareInformativePricingWithoutPnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Fare_InformativePricingWithoutPNR' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function fareInformativeBestPricingWithoutPnr ( RequestOptions \ FareInformativeBestPricingWithoutPnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Fare_InformativeBestPricingWithoutPNR' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function fareCheckRules ( RequestOptions \ FareCheckRulesOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Fare_CheckRules' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function fareGetFareRules ( RequestOptions \ FareGetFareRulesOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Fare_GetFareRules' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function fareConvertCurrency ( RequestOptions \ FareConvertCurrencyOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Fare_ConvertCurrency' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function airMultiAvailability ( RequestOptions \ AirMultiAvailabilityOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Air_MultiAvailability' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function airSellFromRecommendation ( RequestOptions \ AirSellFromRecommendationOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Air_SellFromRecommendation' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function airFlightInfo ( RequestOptions \ AirFlightInfoOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Air_FlightInfo' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function airRetrieveSeatMap ( RequestOptions \ AirRetrieveSeatMapOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Air_RetrieveSeatMap' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function airRebookAirSegment ( RequestOptions \ AirRebookAirSegmentOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Air_RebookAirSegment' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function commandCryptic ( RequestOptions \ CommandCrypticOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Command_Cryptic' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function miniRuleGetFromPricingRec ( RequestOptions \ MiniRuleGetFromPricingRecOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'MiniRule_GetFromPricingRec' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function miniRuleGetFromPricing ( RequestOptions \ MiniRuleGetFromPricingOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'MiniRule_GetFromPricing' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function miniRuleGetFromETicket ( RequestOptions \ MiniRuleGetFromETicketOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'MiniRule_GetFromETicket' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function infoEncodeDecodeCity ( RequestOptions \ InfoEncodeDecodeCityOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Info_EncodeDecodeCity' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function pointOfRefSearch ( RequestOptions \ PointOfRefSearchOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PointOfRef_Search' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketCreateTSTFromPricing ( RequestOptions \ TicketCreateTstFromPricingOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_CreateTSTFromPricing' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketCreateTSMFromPricing ( RequestOptions \ TicketCreateTsmFromPricingOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_CreateTSMFromPricing' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketCreateTSMFareElement ( RequestOptions \ TicketCreateTsmFareElOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_CreateTSMFareElement' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketCreateTASF ( RequestOptions \ TicketCreateTasfOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_CreateTASF' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketDeleteTST ( RequestOptions \ TicketDeleteTstOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_DeleteTST' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketDeleteTSMP ( RequestOptions \ TicketDeleteTsmpOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_DeleteTSMP' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketDisplayTST ( RequestOptions \ TicketDisplayTstOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_DisplayTST' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketDisplayTSMP ( RequestOptions \ TicketDisplayTsmpOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_DisplayTSMP' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketRetrieveListOfTSM ( RequestOptions \ TicketRetrieveListOfTSMOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_RetrieveListOfTSM' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketDisplayTSMFareElement ( RequestOptions \ TicketDisplayTsmFareElOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_DisplayTSMFareElement' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketCheckEligibility ( RequestOptions \ TicketCheckEligibilityOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_CheckEligibility' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketAtcShopperMasterPricerTravelBoardSearch ( RequestOptions \ TicketAtcShopperMpTbSearchOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_ATCShopperMasterPricerTravelBoardSearch' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketRepricePnrWithBookingClass ( RequestOptions \ TicketRepricePnrWithBookingClassOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_RepricePNRWithBookingClass' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketCancelDocument ( RequestOptions \ TicketCancelDocumentOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_CancelDocument' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketReissueConfirmedPricing ( RequestOptions \ TicketReissueConfirmedPricingOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_ReissueConfirmedPricing' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketProcessEDoc ( RequestOptions \ TicketProcessEDocOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_ProcessEDoc' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketProcessETicket ( RequestOptions \ TicketProcessETicketOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_ProcessETicket' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function docIssuanceIssueTicket ( RequestOptions \ DocIssuanceIssueTicketOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'DocIssuance_IssueTicket' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function docIssuanceIssueMiscellaneousDocuments ( RequestOptions \ DocIssuanceIssueMiscDocOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'DocIssuance_IssueMiscellaneousDocuments' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function docIssuanceIssueCombined ( RequestOptions \ DocIssuanceIssueCombinedOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'DocIssuance_IssueCombined' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function docRefundInitRefund ( RequestOptions \ DocRefundInitRefundOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'DocRefund_InitRefund' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function docRefundIgnoreRefund ( RequestOptions \ DocRefundIgnoreRefundOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'DocRefund_IgnoreRefund' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function docRefundUpdateRefund ( RequestOptions \ DocRefundUpdateRefundOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'DocRefund_UpdateRefund' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function docRefundProcessRefund ( RequestOptions \ DocRefundProcessRefundOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'DocRefund_ProcessRefund' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketInitRefund ( RequestOptions \ TicketInitRefundOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_InitRefund' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketIgnoreRefund ( RequestOptions \ TicketIgnoreRefundOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_IgnoreRefund' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function ticketProcessRefund ( RequestOptions \ TicketProcessRefundOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Ticket_ProcessRefund' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function fopCreateFormOfPayment ( RequestOptions \ FopCreateFopOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'FOP_CreateFormOfPayment' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function fopValidateFOP ( RequestOptions \ FopValidateFopOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'FOP_ValidateFOP' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function priceXplorerExtremeSearch ( RequestOptions \ PriceXplorerExtremeSearchOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PriceXplorer_ExtremeSearch' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function salesReportsDisplayQueryReport ( RequestOptions \ SalesReportsDisplayQueryReportOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'SalesReports_DisplayQueryReport' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function serviceIntegratedPricing ( RequestOptions \ ServiceIntegratedPricingOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Service_IntegratedPricing' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function serviceIntegratedCatalogue ( RequestOptions \ ServiceIntegratedCatalogueOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Service_IntegratedCatalogue' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function salesReportsDisplayDailyOrSummarizedReport ( RequestOptions \ SalesReportsDisplayDailyOrSummarizedReportOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'SalesReports_DisplayDailyOrSummarizedReport' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
public function salesReportsDisplayNetRemitReport ( RequestOptions \ SalesReportsDisplayNetRemitReportOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'SalesReports_DisplayNetRemitReport' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; } 
protected function callMessage ( $ messageName , $ options , $ messageOptions , $ endSession = false ) { $ messageOptions = $ this -> makeMessageOptions ( $ messageOptions , $ endSession ) ; $ this -> lastMessage = $ messageName ; $ sendResult = $ this -> sessionHandler -> sendMessage ( $ messageName , $ this -> requestCreator -> createRequest ( $ messageName , $ options ) , $ messageOptions ) ; $ response = $ this -> responseHandler -> analyzeResponse ( $ sendResult , $ messageName ) ; if ( $ messageOptions [ 'returnXml' ] === false ) { $ response -> responseXml = null ; } return $ response ; } 
protected function makeMessageOptions ( array $ incoming , $ endSession = false ) { $ options = [ 'endSession' => $ endSession , 'returnXml' => $ this -> returnResultXml ] ; if ( array_key_exists ( 'endSession' , $ incoming ) ) { $ options [ 'endSession' ] = $ incoming [ 'endSession' ] ; } if ( array_key_exists ( 'returnXml' , $ incoming ) ) { $ options [ 'returnXml' ] = $ incoming [ 'returnXml' ] ; } return $ options ; } 
protected function loadFromAuthParams ( AuthParams $ authParams ) { $ this -> officeId = $ authParams -> officeId ; $ this -> dutyCode = $ authParams -> dutyCode ; $ this -> organizationId = $ authParams -> organizationId ; $ this -> originatorTypeCode = $ authParams -> originatorTypeCode ; $ this -> userId = $ authParams -> userId ; $ this -> passwordLength = $ authParams -> passwordLength ; $ this -> passwordData = $ authParams -> passwordData ; } 
public function getConsumerId ( $ generate = false ) { if ( is_null ( $ this -> consumerId ) && $ generate ) { $ this -> consumerId = $ this -> generateGuid ( ) ; } return $ this -> consumerId ; } 
protected function prepareForNextMessage ( $ messageName , $ messageOptions ) { if ( $ this -> isAuthenticated === true && is_int ( $ this -> sessionData [ 'sequenceNumber' ] ) ) { $ this -> sessionData [ 'sequenceNumber' ] ++ ; } $ headers = $ this -> createSoapHeaders ( $ this -> sessionData , $ this -> params , $ messageName , $ messageOptions ) ; $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( null ) ; $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( $ headers ) ; } 
protected function handlePostMessage ( $ messageName , $ lastResponse , $ messageOptions , $ result ) { 
protected function createSoapHeaders ( $ sessionData , $ params , $ messageName , $ messageOptions ) { $ headersToSet = [ ] ; $ wsdlId = $ this -> getWsdlIdFor ( $ messageName ) ; $ wsdl = WsdlAnalyser :: $ wsdlIds [ $ wsdlId ] ; 
protected function getEndpointFromWsdl ( $ wsdlFilePath , $ messageName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ messageName ) ; return WsdlAnalyser :: exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , self :: XPATH_ENDPOINT ) ; } 
protected function getActionFromWsdl ( $ wsdlFilePath , $ messageName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ messageName ) ; return WsdlAnalyser :: exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , sprintf ( self :: XPATH_OPERATION_ACTION , $ messageName ) ) ; } 
protected function generateGuid ( ) { mt_srand ( ( double ) microtime ( ) * 10000 ) ; $ charId = strtoupper ( md5 ( uniqid ( rand ( ) , true ) ) ) ; $ hyphen = chr ( 45 ) ; 
protected function generatePasswordDigest ( $ password , $ creationString , $ messageNonce ) { return base64_encode ( sha1 ( $ messageNonce . $ creationString . sha1 ( $ password , true ) , true ) ) ; } 
protected function makeSoapClientOptions ( ) { $ options = $ this -> soapClientOptions ; $ options [ 'classmap' ] = array_merge ( Classmap :: $ soapheader4map , Classmap :: $ map ) ; if ( ! empty ( $ this -> params -> soapClientOptions ) ) { $ options = array_merge ( $ options , $ this -> params -> soapClientOptions ) ; } return $ options ; } 
private function getStatefulStatusCode ( $ messageName , array $ messageOptions ) { 
protected function loadOptionalSegmentInformation ( $ options ) { if ( ! empty ( $ options -> operatingCompany ) ) { $ this -> segmentInformation -> companyDetails -> operatingCompany = $ options -> operatingCompany ; } if ( $ options -> arrivalDate instanceof \ DateTime ) { $ this -> segmentInformation -> flightDate -> setArrivalDate ( $ options -> arrivalDate ) ; } if ( ! empty ( $ options -> groupNumber ) ) { $ this -> segmentInformation -> flightTypeDetails = new FlightTypeDetails ( $ options -> groupNumber ) ; } $ this -> loadAdditionalSegmentDetails ( $ options -> airplaneCode , $ options -> nrOfStops ) ; } 
protected function loadInventory ( $ inventory ) { if ( is_array ( $ inventory ) && count ( $ inventory ) > 0 ) { $ this -> inventory = new Inventory ( ) ; foreach ( $ inventory as $ bookingClass => $ availabilityAmount ) { $ this -> inventory -> bookingClassDetails [ ] = new BookingClassDetails ( $ bookingClass , $ availabilityAmount ) ; } } } 
public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; 
public function setSessionData ( array $ sessionData ) { if ( isset ( $ sessionData [ 'sessionId' ] , $ sessionData [ 'sequenceNumber' ] , $ sessionData [ 'securityToken' ] ) ) { $ this -> sessionData [ 'sessionId' ] = $ sessionData [ 'sessionId' ] ; $ this -> sessionData [ 'sequenceNumber' ] = $ sessionData [ 'sequenceNumber' ] ; $ this -> sessionData [ 'securityToken' ] = $ sessionData [ 'securityToken' ] ; $ this -> isAuthenticated = true ; } else { $ this -> isAuthenticated = false ; } return $ this -> isAuthenticated ; } 
public function getMessagesAndVersions ( ) { if ( empty ( $ this -> messagesAndVersions ) ) { $ this -> messagesAndVersions = WsdlAnalyser :: loadMessagesAndVersions ( $ this -> params -> wsdl ) ; } return $ this -> messagesAndVersions ; } 
protected function getActiveVersionFor ( $ messageName ) { $ msgAndVer = $ this -> getMessagesAndVersions ( ) ; $ found = null ; if ( isset ( $ msgAndVer [ $ messageName ] ) && isset ( $ msgAndVer [ $ messageName ] [ 'version' ] ) ) { $ found = $ msgAndVer [ $ messageName ] [ 'version' ] ; } return $ found ; } 
protected function getWsdlIdFor ( $ messageName ) { $ msgAndVer = $ this -> getMessagesAndVersions ( ) ; if ( isset ( $ msgAndVer [ $ messageName ] ) && isset ( $ msgAndVer [ $ messageName ] [ 'wsdl' ] ) ) { return $ msgAndVer [ $ messageName ] [ 'wsdl' ] ; } return null ; } 
protected function getSoapClient ( $ msgName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ msgName ) ; if ( ! empty ( $ msgName ) ) { if ( ! isset ( $ this -> soapClients [ $ wsdlId ] ) || ! ( $ this -> soapClients [ $ wsdlId ] instanceof \ SoapClient ) ) { $ this -> soapClients [ $ wsdlId ] = $ this -> initSoapClient ( $ wsdlId ) ; } return $ this -> soapClients [ $ wsdlId ] ; } else { return null ; } } 
protected function initSoapClient ( $ wsdlId ) { $ wsdlPath = WsdlAnalyser :: $ wsdlIds [ $ wsdlId ] ; $ client = new Client \ SoapClient ( $ wsdlPath , $ this -> makeSoapClientOptions ( ) , $ this -> params -> logger ) ; return $ client ; } 
protected function executeMethodOnSoapClientForMsg ( $ msgName , $ method ) { $ result = null ; $ soapClient = $ this -> getSoapClient ( $ msgName ) ; if ( $ soapClient instanceof \ SoapClient ) { $ result = $ soapClient -> $ method ( ) ; } return $ result ; } 
protected function makeSegmentNameForRequestElement ( $ elementType , $ element ) { $ elementName = '' ; $ sourceArray = [ 'Contact' => ElementManagementData :: SEGNAME_CONTACT_ELEMENT , 'FormOfPayment' => ElementManagementData :: SEGNAME_FORM_OF_PAYMENT , 'MiscellaneousRemark' => ElementManagementData :: SEGNAME_GENERAL_REMARK , 'ReceivedFrom' => ElementManagementData :: SEGNAME_RECEIVE_FROM , 'ServiceRequest' => ElementManagementData :: SEGNAME_SPECIAL_SERVICE_REQUEST , 'Ticketing' => ElementManagementData :: SEGNAME_TICKETING_ELEMENT , 'AccountingInfo' => ElementManagementData :: SEGNAME_ACCOUNTING_INFORMATION , 'Address' => null , 
protected function analyzeWithErrCodeCategoryMsgQuery ( SendResult $ response , $ qErr , $ qCat , $ qMsg , $ errLevel = null ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ errLevel ) ; } return $ analyzeResponse ; } 
protected function analyzeWithErrorCodeMsgQueryLevel ( SendResult $ response , $ qErr , $ qMsg , $ qLvl , $ lvlToText ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ lvlNodeList = $ domXpath -> query ( $ qLvl ) ; $ level = null ; if ( $ lvlNodeList -> length > 0 ) { if ( array_key_exists ( $ lvlNodeList -> item ( 0 ) -> nodeValue , $ lvlToText ) ) { $ level = $ lvlToText [ $ lvlNodeList -> item ( 0 ) -> nodeValue ] ; } } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ level ) ; } return $ analyzeResponse ; } 
public function analyzeWithErrCodeAndMsgQueryFixedCat ( SendResult $ response , $ qErr , $ qMsg , $ category ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; $ errorMsgNodeList = $ domXpath -> query ( $ qMsg ) ; if ( $ errorCodeNodeList -> length > 0 || $ errorMsgNodeList -> length > 0 ) { $ analyzeResponse -> status = $ category ; $ errorCode = ( $ errorCodeNodeList -> length > 0 ) ? $ errorCodeNodeList -> item ( 0 ) -> nodeValue : null ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorMsgNodeList ) ) ; } return $ analyzeResponse ; } 
protected function analyzeWithErrCodeCategoryMsgNodeName ( SendResult $ response , $ nodeErr , $ nodeCat , $ nodeMsg ) { $ analyzeResponse = new Result ( $ response ) ; $ domDoc = $ this -> loadDomDocument ( $ response -> responseXml ) ; $ errorCodeNode = $ domDoc -> getElementsByTagName ( $ nodeErr ) -> item ( 0 ) ; if ( ! is_null ( $ errorCodeNode ) ) { $ errorCatNode = $ domDoc -> getElementsByTagName ( $ nodeCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } else { $ analyzeResponse -> status = Result :: STATUS_ERROR ; } $ errorCode = $ errorCodeNode -> nodeValue ; $ errorTextNodeList = $ domDoc -> getElementsByTagName ( $ nodeMsg ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ) ; } return $ analyzeResponse ; } 
protected function makeDomXpath ( $ response ) { $ domDoc = $ this -> loadDomDocument ( $ response ) ; $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( self :: XMLNS_PREFIX , $ domDoc -> documentElement -> lookupNamespaceUri ( null ) ) ; return $ domXpath ; } 
protected function makeStatusFromErrorQualifier ( $ qualifier , $ defaultStatus = Result :: STATUS_ERROR ) { $ statusQualMapping = [ 'INF' => Result :: STATUS_INFO , 'WEC' => Result :: STATUS_WARN , 'WZZ' => Result :: STATUS_WARN , 
protected function makeMessageFromMessagesNodeList ( $ errorTextNodeList ) { return implode ( ' - ' , array_map ( function ( $ item ) { return trim ( $ item -> nodeValue ) ; } , iterator_to_array ( $ errorTextNodeList ) ) ) ; } 
public function analyzeResponse ( $ sendResult , $ messageName ) { if ( ! empty ( $ sendResult -> exception ) ) { return $ this -> makeResultForException ( $ sendResult ) ; } $ handler = $ this -> findHandlerForMessage ( $ messageName ) ; if ( $ handler instanceof MessageResponseHandler ) { return $ handler -> analyze ( $ sendResult ) ; } else { return new Result ( $ sendResult , Result :: STATUS_UNKNOWN ) ; } } 
private function findHandlerForMessage ( $ messageName ) { $ handler = null ; if ( array_key_exists ( $ messageName , $ this -> responseHandlers ) && $ this -> responseHandlers [ $ messageName ] instanceof MessageResponseHandler ) { $ handler = $ this -> responseHandlers [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ handlerClass = __NAMESPACE__ . '\\' . $ section . '\\Handler' . $ message ; if ( class_exists ( $ handlerClass ) ) { $ handler = new $ handlerClass ( ) ; $ this -> responseHandlers [ $ messageName ] = $ handler ; } } return $ handler ; } 
protected function loadClientParams ( Params $ params , $ receivedFromIdentifier , $ version ) { if ( $ params -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> authParams ; if ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams instanceof Params \ SessionHandlerParams ) { $ params -> sessionHandlerParams -> authParams = $ this -> authParams ; } } elseif ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams -> authParams instanceof Params \ AuthParams ) { 
protected function loadSessionHandler ( $ sessionHandler , $ params ) { if ( $ sessionHandler instanceof HandlerInterface ) { $ newSessionHandler = $ sessionHandler ; } else { $ newSessionHandler = HandlerFactory :: createHandler ( $ params ) ; } return $ newSessionHandler ; } 
protected function loadRequestCreator ( $ requestCreator , $ params , $ libIdentifier , $ originatorOffice , $ mesVer ) { if ( $ requestCreator instanceof RequestCreatorInterface ) { $ newRequestCreator = $ requestCreator ; } else { $ params -> originatorOfficeId = $ originatorOffice ; $ params -> messagesAndVersions = $ mesVer ; $ newRequestCreator = RequestCreatorFactory :: createRequestCreator ( $ params , $ libIdentifier ) ; } return $ newRequestCreator ; } 
public function extract ( $ soapResponse ) { $ messageBody = null ; $ messageBody = $ this -> getStringBetween ( $ soapResponse , '<SOAP-ENV:Body>' , '</SOAP-ENV:Body>' ) ; if ( empty ( $ messageBody ) || false === $ messageBody ) { $ messageBody = $ this -> getStringBetween ( $ soapResponse , '<soap:Body>' , '</soap:Body>' ) ; } return $ messageBody ; } 
private function getStringBetween ( $ string , $ start , $ end ) { $ startPos = strpos ( $ string , $ start ) + strlen ( $ start ) ; $ endPos = strlen ( $ string ) - strpos ( $ string , $ end ) ; return substr ( $ string , $ startPos , - $ endPos ) ; } 
public static function loadPricingOptionsFromRequestOptions ( $ options ) { $ priceOptions = [ ] ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionForValidatingCarrier ( $ options -> validatingCarrier ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionForCurrencyOverride ( $ options -> currencyOverride ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionFareBasisOverride ( $ options -> pricingsFareBasis ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionFareFamilyOverride ( $ options -> fareFamily ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadCorpNegoFare ( $ options -> corporateNegoFare ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadCorpUniFares ( $ options -> corporateUniFares , $ options -> awardPricing ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadObFees ( $ options -> obFees , $ options -> obFeeRefs ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPaxDiscount ( $ options -> paxDiscountCodes , $ options -> paxDiscountCodeRefs ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPointOverrides ( $ options -> pointOfSaleOverride , $ options -> pointOfTicketingOverride ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPricingLogic ( $ options -> pricingLogic ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadTicketType ( $ options -> ticketType ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadTaxes ( $ options -> taxes ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadExemptTaxes ( $ options -> exemptTaxes ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPastDate ( $ options -> pastDatePricing ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadFormOfPayment ( $ options -> formOfPayment ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadReferences ( $ options -> references ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makeOverrideOptions ( $ options -> overrideOptions , $ priceOptions ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makeOverrideOptionsWithCriteria ( $ options -> overrideOptionsWithCriteria , $ priceOptions ) ) ; 
protected static function makePricingOptionFareFamilyOverride ( $ fareFamily ) { $ opt = [ ] ; if ( $ fareFamily !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_FARE_FAMILY ) ; $ po -> optionDetail = new OptionDetail ( [ [ 'FF' => $ fareFamily ] ] ) ; $ opt [ ] = $ po ; } return $ opt ; } 
protected static function loadCorpNegoFare ( $ corporateNegoFare ) { $ opt = [ ] ; if ( $ corporateNegoFare !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_CORPORATE_NEGOTIATED_FARES ) ; $ po -> optionDetail = new OptionDetail ( $ corporateNegoFare ) ; $ opt [ ] = $ po ; } return $ opt ; } 
protected static function loadCorpUniFares ( $ corporateUniFares , $ awardPricing ) { $ opt = [ ] ; if ( ! empty ( $ corporateUniFares ) ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_CORPORATE_UNIFARES ) ; $ po -> optionDetail = new OptionDetail ( $ corporateUniFares ) ; $ opt [ ] = $ po ; if ( ! empty ( $ awardPricing ) ) { $ opt [ ] = self :: loadAwardPricing ( $ awardPricing ) ; } } return $ opt ; } 
protected static function loadObFees ( $ obFees , $ obFeeRefs ) { $ opt = [ ] ; if ( ! empty ( $ obFees ) ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_OB_FEES ) ; $ po -> penDisInformation = new PenDisInformation ( PenDisInformation :: QUAL_OB_FEES , $ obFees ) ; if ( ! empty ( $ obFeeRefs ) ) { $ po -> paxSegTstReference = new PaxSegTstReference ( $ obFeeRefs ) ; } $ opt [ ] = $ po ; } return $ opt ; } 
protected function loadMopDetails ( MopInfo $ options ) { $ this -> mopDetails = new MopDetails ( ) ; if ( $ this -> checkAnyNotEmpty ( $ options -> fopCode , $ options -> fopStatus ) ) { $ this -> mopDetails -> fopPNRDetails = new FopPNRDetails ( $ options -> fopCode , $ options -> fopStatus ) ; } if ( ! empty ( $ options -> freeFlowText ) ) { $ this -> mopDetails -> oldFopFreeflow = new OldFopFreeflow ( $ options -> freeFlowText , $ options -> freeFlowEncoding ) ; } if ( ! empty ( $ options -> supplementaryData ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_DATA_INFORMATION , $ options -> supplementaryData ) ; } if ( ! empty ( $ options -> supplementarySwitches ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_SWITCH_INFORMATION , $ options -> supplementarySwitches ) ; } } 
protected function loadPaymentModule ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> fopType , $ options -> payMerchant , $ options -> payments , $ options -> installmentsInfo , $ options -> mopPaymentType , $ options -> creditCardInfo , $ options -> fraudScreening , $ options -> payIds , $ options -> paySupData ) ) { if ( $ this instanceof MopDescription14 ) { $ this -> paymentModule = new PaymentModule14 ( $ options -> fopType ) ; } else { $ this -> paymentModule = new PaymentModule ( $ options -> fopType ) ; } $ this -> paymentModule -> loadPaymentData ( $ options ) ; $ this -> loadMopInformation ( $ options ) ; $ this -> loadPaymentSupplementaryData ( $ options ) ; } } 
protected function loadPaymentSupplementaryData ( MopInfo $ options ) { foreach ( $ options -> paySupData as $ paySupData ) { $ this -> paymentModule -> paymentSupplementaryData [ ] = new PaymentSupplementaryData ( $ paySupData -> function , $ paySupData -> data ) ; } } 
protected function loadMopInformation ( MopInfo $ options ) { if ( ! empty ( $ options -> mopPaymentType ) ) { $ this -> checkAndCreateMopInformation ( ) ; $ this -> paymentModule -> mopInformation -> fopInformation = new FopInformation ( $ options -> mopPaymentType ) ; } if ( ! empty ( $ options -> creditCardInfo ) ) { $ this -> checkAndCreateMopInformation ( ) ; $ this -> paymentModule -> mopInformation -> creditCardData = new CreditCardData ( $ options -> creditCardInfo ) ; if ( $ this -> checkAnyNotEmpty ( $ options -> creditCardInfo -> approvalCode , $ options -> creditCardInfo -> threeDSecure ) ) { $ this -> checkAndCreateMopDetailedData ( $ options -> fopType ) ; $ this -> paymentModule -> mopDetailedData -> creditCardDetailedData = new CreditCardDetailedData ( $ options -> creditCardInfo -> approvalCode , $ options -> creditCardInfo -> sourceOfApproval , $ options -> creditCardInfo -> threeDSecure ) ; } } if ( ! empty ( $ options -> invoiceInfo ) ) { $ this -> checkAndCreateMopInformation ( ) ; $ this -> paymentModule -> mopInformation -> invoiceDataGroup = new InvoiceDataGroup ( $ options -> invoiceInfo ) ; } } 
private function checkAndCreateMopDetailedData ( $ fopType ) { if ( is_null ( $ this -> paymentModule -> mopDetailedData ) ) { $ this -> paymentModule -> mopDetailedData = new MopDetailedData ( $ fopType ) ; } } 
public function loadSpecificChanges ( $ changeTicketing , $ changeQueueing , $ changeOptQueueEl ) { if ( $ changeTicketing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_TICKETING_OFFICE ) ; } if ( $ changeQueueing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_QUEUEING_OFFICE ) ; } if ( $ changeOptQueueEl ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_OPT_QUEUE_ELEMENT ) ; } } 
protected function loadGeoCode ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAllNotEmpty ( $ params -> latitude , $ params -> longitude ) ) { $ this -> porFndQryParams -> geoCode = new GeoCode ( $ params -> longitude , $ params -> latitude ) ; } } 
protected function loadCountryStateIata ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> country , $ params -> state , $ params -> iata ) ) { $ this -> porFndQryParams -> area = new Area ( $ params -> country , $ params -> state , $ params -> iata ) ; } } 
protected function loadBusinessId ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> businessCategory , $ params -> businessForeignKey ) ) { $ this -> porFndQryParams -> businessId = new BusinessId ( $ params -> businessCategory , $ params -> businessForeignKey ) ; } } 
public static function generateSomewhatRandomString ( $ length = 22 ) { $ chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz" ; srand ( ( double ) microtime ( ) * 1000000 ) ; $ i = 0 ; $ somewhatRandom = '' ; while ( $ i < $ length ) { $ num = rand ( ) % 60 ; $ tmp = substr ( $ chars , $ num , 1 ) ; $ somewhatRandom = $ somewhatRandom . $ tmp ; $ i ++ ; } return $ somewhatRandom ; } 
public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ queryAllErrorCodes = "//m:generalErrorGroup//m:errorNumber/m:errorDetails/m:errorCode" ; $ queryAllErrorMsg = "//m:generalErrorGroup/m:genrealErrorText/m:freeText" ; $ errorCodeNodeList = $ domXpath -> query ( $ queryAllErrorCodes ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( $ queryAllErrorMsg ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) ) ; } return $ analyzeResponse ; } 
protected function checkAnyNotEmpty ( ) { $ foundNotEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! empty ( $ arg ) ) { $ foundNotEmpty = true ; break ; } } return $ foundNotEmpty ; } 
protected function checkAllNotEmpty ( ) { $ foundEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( empty ( $ arg ) ) { $ foundEmpty = true ; break ; } } return ! $ foundEmpty ; } 
protected function checkAllIntegers ( ) { $ foundNonInt = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! is_int ( $ arg ) ) { $ foundNonInt = true ; break ; } } return ! $ foundNonInt ; } 
protected function checkAnyTrue ( ) { $ foundTrue = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( $ arg === true ) { $ foundTrue = true ; break ; } } return $ foundTrue ; } 
protected static function loadNonceBase ( $ handlerParams ) { if ( empty ( $ handlerParams -> authParams -> nonceBase ) ) { $ handlerParams -> authParams -> nonceBase = SomewhatRandomGenerator :: generateSomewhatRandomString ( ) ; } return $ handlerParams ; } 
protected function loadDepartureDateLimits ( PriceXplorerExtremeSearchOptions $ params ) { if ( $ params -> earliestDepartureDate instanceof \ DateTime || $ params -> latestDepartureDate instanceof \ DateTime ) { $ this -> travelDates = new TravelDates ( $ params -> earliestDepartureDate , $ params -> latestDepartureDate ) ; } } 
protected function loadDestinations ( PriceXplorerExtremeSearchOptions $ params ) { foreach ( $ params -> destinations as $ destination ) { $ this -> itineraryGrp [ ] = new ItineraryGrp ( null , $ destination ) ; } foreach ( $ params -> destinationCountries as $ destinationCountry ) { $ tmpGrp = new ItineraryGrp ( ) ; $ tmpGrp -> locationInfo = new LocationInfo ( LocationInfo :: LOC_COUNTRY ) ; $ tmpGrp -> locationInfo -> locationDescription = new LocationIdentificationType ( ) ; $ tmpGrp -> locationInfo -> locationDescription -> qualifier = LocationIdentificationType :: QUAL_DESTINATION ; $ tmpGrp -> locationInfo -> locationDescription -> code = $ destinationCountry ; $ this -> itineraryGrp [ ] = $ tmpGrp ; } } 
protected function loadDepartureDaysOutIn ( PriceXplorerExtremeSearchOptions $ params ) { if ( ! empty ( $ params -> departureDaysInbound ) ) { $ this -> departureDays [ ] = new DepartureDays ( $ params -> departureDaysInbound , SelectionDetails :: OPT_INBOUND_DEP_DAYS ) ; } if ( ! empty ( $ params -> departureDaysOutbound ) ) { $ this -> departureDays [ ] = new DepartureDays ( $ params -> departureDaysOutbound , SelectionDetails :: OPT_OUTBOUND_DEP_DAYS ) ; } } 
public static function isValidFopType ( $ fopType ) { return ( $ fopType == self :: IDENT_CASH || $ fopType == self :: IDENT_CHECK || $ fopType == self :: IDENT_CREDITCARD || $ fopType == self :: IDENT_MISC ) ; } 
protected function loadFromArray ( array $ params ) { if ( isset ( $ params [ 'returnXml' ] ) && is_bool ( $ params [ 'returnXml' ] ) ) { $ this -> returnXml = $ params [ 'returnXml' ] ; } $ this -> loadRequestCreator ( $ params ) ; $ this -> loadSessionHandler ( $ params ) ; $ this -> loadResponseHandler ( $ params ) ; $ this -> loadAuthParams ( $ params ) ; $ this -> loadSessionHandlerParams ( $ params ) ; $ this -> loadRequestCreatorParams ( $ params ) ; } 
protected function loadSessionHandler ( $ params ) { if ( isset ( $ params [ 'sessionHandler' ] ) && $ params [ 'sessionHandler' ] instanceof Session \ Handler \ HandlerInterface ) { $ this -> sessionHandler = $ params [ 'sessionHandler' ] ; } } 
protected function loadAuthParams ( $ params ) { if ( isset ( $ params [ 'authParams' ] ) ) { if ( $ params [ 'authParams' ] instanceof AuthParams ) { $ this -> authParams = $ params [ 'authParams' ] ; } elseif ( is_array ( $ params [ 'authParams' ] ) ) { $ this -> authParams = new AuthParams ( $ params [ 'authParams' ] ) ; } } } 
protected function loadSessionHandlerParams ( $ params ) { if ( isset ( $ params [ 'sessionHandlerParams' ] ) ) { if ( $ params [ 'sessionHandlerParams' ] instanceof SessionHandlerParams ) { $ this -> sessionHandlerParams = $ params [ 'sessionHandlerParams' ] ; } elseif ( is_array ( $ params [ 'sessionHandlerParams' ] ) ) { $ this -> sessionHandlerParams = new SessionHandlerParams ( $ params [ 'sessionHandlerParams' ] ) ; } } } 
protected function loadRequestCreatorParams ( $ params ) { if ( isset ( $ params [ 'requestCreatorParams' ] ) ) { if ( $ params [ 'requestCreatorParams' ] instanceof RequestCreatorParams ) { $ this -> requestCreatorParams = $ params [ 'requestCreatorParams' ] ; } elseif ( is_array ( $ params [ 'requestCreatorParams' ] ) ) { $ this -> requestCreatorParams = new RequestCreatorParams ( $ params [ 'requestCreatorParams' ] ) ; } } } 
protected function mergeOptions ( $ existingOptions , $ newOptions ) { if ( ! empty ( $ newOptions ) ) { $ existingOptions = array_merge ( $ existingOptions , $ newOptions ) ; } return $ existingOptions ; } 
protected function loadCorpUniFares ( $ corporateUniFares , $ awardPricing ) { $ opt = [ ] ; if ( ! empty ( $ corporateUniFares ) ) { $ po = new PricingOption ( PricingOptionKey :: OPTION_CORPORATE_UNIFARES ) ; $ po -> optionDetail = new OptionDetail ( $ corporateUniFares ) ; $ opt [ ] = $ po ; if ( ! empty ( $ awardPricing ) ) { $ opt [ ] = $ this -> loadAwardPricing ( $ awardPricing ) ; } } return $ opt ; } 
protected function hasPricingOption ( $ optionKey , $ priceOptions ) { $ found = false ; foreach ( $ priceOptions as $ pog ) { if ( $ pog -> pricingOptionKey -> pricingOptionKey === $ optionKey ) { $ found = true ; } } return $ found ; } 
protected function loadArnk ( Segment \ ArrivalUnknown $ segment ) { $ this -> travelProduct = new TravelProduct ( ) ; $ this -> travelProduct -> productDetails = new ProductDetails ( $ segment -> identification ) ; $ this -> messageAction = new MessageAction ( Business :: FUNC_ARNK ) ; } 
public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; 
protected function loadCustomerRefs ( $ dkNumber ) { if ( ! is_null ( $ dkNumber ) ) { $ this -> customerRef = new MasterPricer \ CustomerRef ( ) ; $ this -> customerRef -> customerReferences [ ] = new MasterPricer \ CustomerReferences ( $ dkNumber , MasterPricer \ CustomerReferences :: QUAL_AGENCY_GROUPING_ID ) ; } } 
protected function loadOffers ( PnrCancelOptions $ params ) { if ( ! empty ( $ params -> offers ) ) { $ tmp = new Cancel \ Elements ( Elements :: ENTRY_ELEMENT ) ; foreach ( $ params -> offers as $ offerRef ) { $ tmp -> element [ ] = new Element ( $ offerRef , Element :: IDENT_OFFER_TATTOO ) ; } $ this -> cancelElements [ ] = $ tmp ; } } 
protected function loadFromArray ( array $ params ) { if ( count ( $ params ) > 0 ) { $ this -> officeId = $ params [ 'officeId' ] ; $ this -> originatorTypeCode = ( isset ( $ params [ 'originatorTypeCode' ] ) ) ? $ params [ 'originatorTypeCode' ] : "U" ; $ this -> dutyCode = ( isset ( $ params [ 'dutyCode' ] ) ) ? $ params [ 'dutyCode' ] : "SU" ; $ this -> userId = $ params [ 'userId' ] ; $ this -> organizationId = ( isset ( $ params [ 'organizationId' ] ) ) ? $ params [ 'organizationId' ] : null ; $ this -> passwordLength = ( isset ( $ params [ 'passwordLength' ] ) ) ? $ params [ 'passwordLength' ] : null ; $ this -> passwordData = $ params [ 'passwordData' ] ; if ( isset ( $ params [ 'nonceBase' ] ) ) { $ this -> nonceBase = $ params [ 'nonceBase' ] ; } } } 
protected function loadFromArray ( array $ params ) { if ( count ( $ params ) > 0 ) { if ( isset ( $ params [ 'soapHeaderVersion' ] ) ) { $ this -> soapHeaderVersion = $ params [ 'soapHeaderVersion' ] ; } $ this -> loadWsdl ( $ params ) ; $ this -> loadStateful ( $ params ) ; $ this -> loadLogger ( $ params ) ; $ this -> loadAuthParams ( $ params ) ; $ this -> loadOverrideSoapClient ( $ params ) ; $ this -> loadSoapClientOptions ( $ params ) ; $ this -> loadTransactionFlowLink ( $ params ) ; } } 
protected function loadWsdl ( $ params ) { if ( isset ( $ params [ 'wsdl' ] ) ) { if ( is_string ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = [ $ params [ 'wsdl' ] ] ; } elseif ( is_array ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = $ params [ 'wsdl' ] ; } } } 
protected function loadOverrideSoapClient ( $ params ) { if ( isset ( $ params [ 'overrideSoapClient' ] ) && $ params [ 'overrideSoapClient' ] instanceof \ SoapClient ) { $ this -> overrideSoapClient = $ params [ 'overrideSoapClient' ] ; } if ( isset ( $ params [ 'overrideSoapClientWsdlName' ] ) ) { $ this -> overrideSoapClientWsdlName = $ params [ 'overrideSoapClientWsdlName' ] ; } } 
protected function loadTransactionFlowLink ( $ params ) { if ( isset ( $ params [ 'enableTransactionFlowLink' ] ) && $ params [ 'enableTransactionFlowLink' ] === true ) { $ this -> enableTransactionFlowLink = true ; $ this -> consumerId = ( isset ( $ params [ 'consumerId' ] ) ) ? $ params [ 'consumerId' ] : null ; } } 
protected function prepareForNextMessage ( $ messageName , $ messageOptions ) { if ( ! $ this -> isAuthenticated && $ messageName !== 'Security_Authenticate' ) { throw new InvalidSessionException ( 'No active session' ) ; } $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( null ) ; if ( $ this -> isAuthenticated === true && is_int ( $ this -> sessionData [ 'sequenceNumber' ] ) ) { $ this -> sessionData [ 'sequenceNumber' ] ++ ; $ session = new Client \ Struct \ HeaderV2 \ Session ( $ this -> sessionData [ 'sessionId' ] , $ this -> sessionData [ 'sequenceNumber' ] , $ this -> sessionData [ 'securityToken' ] ) ; $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( new \ SoapHeader ( self :: CORE_WS_V2_SESSION_NS , self :: NODENAME_SESSION , $ session ) ) ; } } 
protected function handlePostMessage ( $ messageName , $ lastResponse , $ messageOptions , $ result ) { if ( $ messageName === "Security_Authenticate" ) { $ this -> sessionData = $ this -> getSessionDataFromHeader ( $ lastResponse ) ; $ this -> isAuthenticated = ( ! empty ( $ this -> sessionData [ 'sessionId' ] ) && ! empty ( $ this -> sessionData [ 'sequenceNumber' ] ) && ! empty ( $ this -> sessionData [ 'securityToken' ] ) ) ; } } 
public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ qPassErrors = "//m:passengerErrorInEnhancedData//m:errorDetails/m:errorCode" ; $ qPassErrorCat = "//m:passengerErrorInEnhancedData//m:errorDetails/m:errorCategory" ; $ qPassErrorMsg = "//m:passengerErrorInEnhancedData//m:freeText" ; $ errorCodeNodeList = $ domXpath -> query ( $ qPassErrors ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qPassErrorCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( $ qPassErrorMsg ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'passenger' ) ; } if ( empty ( $ analyzeResponse -> messages ) && $ analyzeResponse -> status === Result :: STATUS_OK ) { $ analyzeResponse = $ this -> analyzeSimpleResponseErrorCodeAndMessage ( $ response ) ; } return $ analyzeResponse ; } 
protected function getErrorTextFromQueueErrorCode ( $ errorCode ) { $ recognizedErrors = [ '1' => 'Invalid date' , '360' => 'Invalid PNR file address' , '723' => 'Invalid category' , '727' => 'Invalid amount' , '79A' => 'Invalid office identification' , '79B' => 'Already working another queue' , '79C' => 'Not allowed to access queues for specified office identification' , '79D' => 'Queue identifier has not been assigned for specified office identification' , '79E' => 'Attempting to perform a queue function when not associated with a queue' , '79F' => 'Queue placement or add new queue item is not allowed for the specified office and queue' , '911' => 'Unable to process - system error' , '912' => 'Incomplete message - data missing in query' , '913' => 'Item/data not found or data not existing in processing host' , '914' => 'Invalid format/data - data does not match EDIFACT rules' , '915' => 'No action - processing host cannot support function' , '916' => 'EDIFACT version not supported' , '917' => 'EDIFACT message size exceeded' , '918' => 'Enter message in remarks' , '919' => 'No PNR in AAA' , '91A' => 'Inactive queue bank' , '91B' => 'Nickname not found' , '91C' => 'Invalid record locator' , '91D' => 'Invalid format' , '91F' => 'Invalid queue number' , '920' => 'Queue/date range empty' , '921' => 'Target not specified' , '922' => 'Targetted queue has wrong queue type' , '923' => 'Invalid time' , '924' => 'Invalid date range' , '925' => 'Queue number not specified' , '926' => 'Queue category empty' , '927' => 'No items exist' , '928' => 'Queue category not assigned' , '929' => 'No more items' , '92A' => '>ueue category full' ] ; $ errorMessage = ( array_key_exists ( $ errorCode , $ recognizedErrors ) ) ? $ recognizedErrors [ $ errorCode ] : '' ; if ( $ errorMessage === '' ) { $ errorMessage = "QUEUE ERROR '" . $ errorCode . "' (Error message unavailable)" ; } return $ errorMessage ; } 
protected function loadReferences ( $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> passengers , $ params -> segments ) ) { $ this -> psaInformation = new PsaInformation ( ) ; foreach ( $ params -> passengers as $ passenger ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ passenger , RefDetails :: QUAL_PASSENGER ) ; } foreach ( $ params -> segments as $ segment ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ segment , RefDetails :: QUAL_SEGMENT_REFERENCE ) ; } } } 
protected function loadBare ( PnrAddMultiElementsOptions $ params ) { $ tattooCounter = 0 ; if ( ! is_null ( $ params -> actionCode ) ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; } if ( ! is_null ( $ params -> recordLocator ) ) { $ this -> reservationInfo = new AddMultiElements \ ReservationInfo ( $ params -> recordLocator ) ; } if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; if ( ! empty ( $ params -> elements ) ) { $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; } else { $ this -> addReceivedFrom ( $ params -> receivedFrom , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ tattooCounter ) ; } } 
protected function loadCreatePnr ( PnrCreatePnrOptions $ params ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; $ tattooCounter = 0 ; if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; } 
protected function addItineraries ( $ itineraries , $ legacySegments , & $ tattooCounter ) { if ( ! empty ( $ legacySegments ) ) { $ this -> addSegments ( $ legacySegments , $ tattooCounter ) ; } foreach ( $ itineraries as $ itinerary ) { $ this -> addSegments ( $ itinerary -> segments , $ tattooCounter , $ itinerary -> origin , $ itinerary -> destination ) ; } } 
protected function addReceivedFrom ( $ explicitRf , $ doAutoAdd , $ defaultRf , & $ tattooCounter ) { if ( $ this -> dataElementsMaster === null ) { $ this -> dataElementsMaster = new DataElementsMaster ( ) ; } if ( ! empty ( $ explicitRf ) || ( $ doAutoAdd && ! empty ( $ defaultRf ) ) ) { 
public function setArrivalDate ( \ DateTime $ arrivalDate ) { $ this -> arrivalDate = ( $ arrivalDate -> format ( 'dmy' ) !== '000000' ) ? $ arrivalDate -> format ( 'dmy' ) : null ; $ time = $ arrivalDate -> format ( 'Hi' ) ; if ( $ time !== '0000' ) { $ this -> arrivalTime = $ time ; } } 
public function loadPaymentData ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ) { $ this -> paymentData = new PaymentData ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ; } } 
protected function loadAvailabilityOptions ( $ availabilityOptions ) { if ( ! empty ( $ availabilityOptions ) ) { foreach ( $ availabilityOptions as $ type => $ argument ) { $ this -> availabilityOptions -> optionInfo [ ] = new OptionInfo ( $ type , $ argument ) ; } } } 
public static function createRequestCreator ( $ params , $ libIdentifier ) { $ params -> receivedFrom = self :: makeReceivedFrom ( $ params -> receivedFrom , $ libIdentifier ) ; $ theRequestCreator = new Base ( $ params ) ; return $ theRequestCreator ; } 
protected function loadCabin ( $ cabinOptions ) { if ( $ cabinOptions instanceof CabinOptions ) { $ optionDetails = [ ] ; foreach ( $ cabinOptions -> getOptions ( ) as $ cabinOption ) { $ optionDetails [ ] = [ $ cabinOption -> getType ( ) => $ cabinOption -> getClass ( ) ] ; } $ this -> pricingOptionGroup = array_merge ( $ this -> pricingOptionGroup , [ new PricingOptionGroup ( PricingOptionKey :: OPTION_CABIN , $ optionDetails ) ] ) ; } return $ this ; } 
protected function loadFeeIds ( $ feeIds ) { if ( is_null ( $ this -> feeIdDescription ) ) { $ this -> feeIdDescription = new FeeIdDescription ( ) ; } foreach ( $ feeIds as $ feeId ) { $ this -> feeIdDescription -> feeId [ ] = new FeeId ( $ feeId -> type , $ feeId -> number ) ; } } 
protected function loadCurrencyOverride ( $ currency ) { if ( is_string ( $ currency ) && strlen ( $ currency ) === 3 ) { $ this -> addPriceType ( PricingTicketing :: PRICETYPE_OVERRIDE_CURRENCY_CONVERSION ) ; $ this -> conversionRate = new ConversionRate ( $ currency ) ; } } 
protected function addPriceType ( $ type ) { if ( is_null ( $ this -> pricingTickInfo ) ) { $ this -> pricingTickInfo = new PricingTickInfo ( ) ; } if ( is_null ( $ this -> pricingTickInfo -> pricingTicketing ) ) { $ this -> pricingTickInfo -> pricingTicketing = new PricingTicketing ( ) ; } $ this -> pricingTickInfo -> pricingTicketing -> priceType [ ] = $ type ; } 
public static function findMessage ( $ code ) { $ message = null ; if ( array_key_exists ( $ code , self :: $ errorList ) ) { $ message = self :: $ errorList [ $ code ] ; } return $ message ; } 
public static function decodeProcessingLevel ( $ level ) { $ decoded = null ; $ map = [ 0 => 'system' , 1 => 'application' ] ; if ( array_key_exists ( $ level , $ map ) ) { $ decoded = $ map [ $ level ] ; } return $ decoded ; } 
public function isNextTokenAny ( array $ tokens ) { return null !== $ this -> lookahead && in_array ( $ this -> lookahead [ 'type' ] , $ tokens , true ) ; } 
public function moveNext ( ) { $ this -> peek = 0 ; $ this -> token = $ this -> lookahead ; $ this -> lookahead = ( isset ( $ this -> tokens [ $ this -> position ] ) ) ? $ this -> tokens [ $ this -> position ++ ] : null ; return $ this -> lookahead !== null ; } 
public function skipUntil ( $ type ) { while ( $ this -> lookahead !== null && $ this -> lookahead [ 'type' ] !== $ type ) { $ this -> moveNext ( ) ; } } 
public function peek ( ) { if ( isset ( $ this -> tokens [ $ this -> position + $ this -> peek ] ) ) { return $ this -> tokens [ $ this -> position + $ this -> peek ++ ] ; } else { return null ; } } 
public function getLiteral ( $ token ) { $ className = get_class ( $ this ) ; $ reflClass = new \ ReflectionClass ( $ className ) ; $ constants = $ reflClass -> getConstants ( ) ; foreach ( $ constants as $ name => $ value ) { if ( $ value === $ token ) { return $ className . '::' . $ name ; } } return $ token ; } 
public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionaryName = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , $ dictionaryName ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || $ dictionary == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } else { return $ result -> setData ( [ 'status' => true ] ) ; } } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activate_flag = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ oldName = $ this -> getRequest ( ) -> getParam ( 'name' ) ; $ params = [ 'name' => $ this -> getRequest ( ) -> getParam ( 'name' ) , 'shield' => $ this -> getRequest ( ) -> getParam ( 'shield' ) , 'connect_timeout' => $ this -> getRequest ( ) -> getParam ( 'connect_timeout' ) , 'between_bytes_timeout' => $ this -> getRequest ( ) -> getParam ( 'between_bytes_timeout' ) , 'first_byte_timeout' => $ this -> getRequest ( ) -> getParam ( 'first_byte_timeout' ) , ] ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ configureBackend = $ this -> api -> configureBackend ( $ params , $ clone -> number , $ oldName ) ; if ( ! $ configureBackend ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to update Backend configuration.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activate_flag === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Backend ' . $ this -> getRequest ( ) -> getParam ( 'name' ) . ' has been changed in Fastly version ' . $ clone -> number . '*' ) ; } $ comment = [ 'comment' => 'Magento Module updated the "' . $ oldName . '" Backend Configuration' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ dictionaryName = Config :: CONFIG_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ currActiveVersion , $ dictionaryName ) ; if ( ! $ dictionary ) { return $ result -> setData ( [ 'status' => false ] ) ; } $ dictionaryItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; foreach ( $ dictionaryItems as $ item ) { if ( $ item -> item_key == Config :: CONFIG_DICTIONARY_KEY && $ item -> item_value == 1 ) { return $ result -> setData ( [ 'status' => true ] ) ; } } return $ result -> setData ( [ 'status' => false ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ dictionary_o = $ this -> getRequest ( ) -> getParam ( 'dictionary' ) ; $ dictionary = preg_replace ( '/\s+/' , '%20' , $ dictionary_o ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ used = '' ; $ response = $ this -> api -> deleteDictionary ( $ clone -> number , $ dictionary ) ; if ( $ response == false ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to delete dictionary.' ] ) ; } $ validation = $ this -> api -> containerValidateServiceVersion ( $ clone -> number ) ; if ( $ validation -> status == 'error' ) { $ used = $ dictionary ; } if ( $ used != '' ) { throw new LocalizedException ( __ ( 'Failed to validate service, the container "' . $ used . '" may be in use. ' ) ) ; } if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ comment = [ 'comment' => 'Magento Module deleted the "' . $ dictionary_o . '" Dictionary' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ checkIfSettingExists = $ this -> api -> hasSnippet ( $ activeVersion , Config :: WAF_SETTING_NAME ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> config -> getWafAllowByAcl ( ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; if ( ! $ checkIfSettingExists ) { 
private function prepareAcls ( $ allowedAcls ) { $ result = '' ; if ( $ allowedAcls != null ) { $ allowedAclsPieces = explode ( "," , $ allowedAcls ) ; foreach ( $ allowedAclsPieces as $ acl ) { $ result .= ' req.http.Fastly-Client-Ip ~ ' . $ acl . ' ||' ; } } return $ result ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionaries = $ this -> api -> getDictionaries ( $ activeVersion ) ; if ( is_array ( $ dictionaries ) && empty ( $ dictionaries ) ) { return $ result -> setData ( [ 'status' => true , 'dictionaries' => [ ] ] ) ; } if ( ! $ dictionaries ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch dictionaries.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'dictionaries' => $ dictionaries ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function aroundSetHeader ( Http $ subject , callable $ proceed , ... $ args ) 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItemId = $ this -> getRequest ( ) -> getParam ( 'acl_item_id' ) ; $ deleteItem = $ this -> api -> deleteAclItem ( $ aclId , $ aclItemId ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ ioOptions = $ this -> api -> getImageOptimizationDefaultConfigOptions ( $ activeVersion ) -> data -> attributes ; if ( ! $ ioOptions ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch image optimization default config options.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'io_options' => $ ioOptions ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function getCurrentVersion ( array $ versions ) { if ( ! empty ( $ versions ) ) { foreach ( $ versions as $ version ) { if ( $ version -> active ) { return $ activeVersion = $ version -> number ; } } } throw new LocalizedException ( __ ( 'Error fetching current version.' ) ) ; } 
public function getNextVersion ( array $ versions ) { if ( isset ( end ( $ versions ) -> number ) ) { return ( int ) end ( $ versions ) -> number + 1 ; } throw new LocalizedException ( __ ( 'Error fetching next version.' ) ) ; } 
public function checkCurrentVersionActive ( $ versions , $ activeVersion ) { $ current = $ this -> getCurrentVersion ( $ versions ) ; if ( $ current != $ activeVersion ) { throw new LocalizedException ( __ ( 'Active versions mismatch.' ) ) ; } return true ; } 
public function determineVersions ( array $ versions ) { $ activeVersion = null ; $ nextVersion = null ; if ( ! empty ( $ versions ) ) { foreach ( $ versions as $ version ) { if ( $ version -> active ) { $ activeVersion = $ version -> number ; } } $ nextVersion = ( int ) end ( $ versions ) -> number + 1 ; } return [ 'active_version' => $ activeVersion , 'next_version' => $ nextVersion ] ; } 
public function getActiveVersion ( $ service , $ activeVersion ) { $ currActiveVersion = $ this -> determineVersions ( $ service -> versions ) ; if ( $ currActiveVersion [ 'active_version' ] != $ activeVersion ) { throw new LocalizedException ( __ ( 'Active versions mismatch.' ) ) ; } return $ currActiveVersion ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getAuthDictionary ( $ activeVersion ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ user = $ this -> getRequest ( ) -> getParam ( 'auth_user' ) ; $ pass = $ this -> getRequest ( ) -> getParam ( 'auth_pass' ) ; $ key = base64_encode ( $ user . ':' . $ pass ) ; $ this -> api -> upsertDictionaryItem ( $ dictionary -> id , $ key , true ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
private function prepareGAReqData ( ) { if ( ! empty ( $ this -> GAReqData ) ) { return $ this -> GAReqData ; } $ mandatoryReqData = [ ] ; $ mandatoryReqData [ 'v' ] = 1 ; 
public function getWebsiteName ( ) { $ websites = $ this -> storeManager -> getWebsites ( ) ; $ websiteName = 'Not set.' ; foreach ( $ websites as $ website ) { if ( $ website -> getIsDefault ( ) ) { $ websiteName = $ website -> getName ( ) ; } } return $ websiteName ; } 
public function isApiKeyValid ( ) { try { $ apiKey = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_API_KEY ) ; $ serviceId = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_SERVICE_ID ) ; $ isApiKeyValid = $ this -> api -> checkServiceDetails ( true , $ serviceId , $ apiKey ) ; } catch ( \ Exception $ e ) { return false ; } return ( bool ) $ isApiKeyValid ; } 
private function prepareCustomVariables ( ) { if ( $ this -> validationServiceId != null ) { $ serviceId = $ this -> validationServiceId ; } else { $ serviceId = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_SERVICE_ID ) ; } $ customVars = [ 
public function getCountry ( ) { $ countryCode = $ this -> scopeConfig -> getValue ( 'general/country/default' ) ; if ( ! $ countryCode ) { return null ; } $ country = $ this -> countryFactory -> create ( ) -> loadByCode ( $ countryCode ) ; return $ country -> getName ( ) ; } 
public function getSiteLocation ( ) { $ countryId = $ this -> scopeConfig -> getValue ( 'general/store_information/country_id' ) ; if ( $ countryId ) { $ country = $ this -> countryFactory -> create ( ) -> loadByCode ( $ countryId ) ; $ countryName = $ country -> getName ( ) ; } else { $ countryName = 'Unknown country' ; } $ regionId = $ this -> scopeConfig -> getValue ( 'general/store_information/region_id' ) ; $ regionName = 'Unknown region' ; if ( $ regionId ) { $ region = $ this -> regionFactory -> create ( ) ; $ region = $ region -> load ( $ regionId ) ; if ( $ region -> getId ( ) ) { $ regionName = $ region -> getName ( ) ; } } $ postCode = $ this -> scopeConfig -> getValue ( 'general/store_information/postcode' ) ; if ( ! $ postCode ) { $ postCode = 'Unknown zip code' ; } return $ countryName . ' | ' . $ regionName . ' | ' . $ postCode ; } 
public function generateCid ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , 
public function sendInstalledReq ( ) { $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . self :: FASTLY_INSTALLED_FLAG , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . self :: FASTLY_INSTALLED_FLAG , 'dt' => ucfirst ( self :: FASTLY_INSTALLED_FLAG ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams , self :: GA_HITTYPE_PAGEVIEW ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . self :: FASTLY_INSTALLED_FLAG , 'el' => $ this -> getWebsiteName ( ) , 'ev' => 0 , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; } 
public function sendValidationRequest ( $ validatedFlag , $ serviceId = null ) { if ( $ serviceId != null ) { $ this -> validationServiceId = $ serviceId ; } if ( $ validatedFlag ) { $ validationState = self :: FASTLY_VALIDATED_FLAG ; } else { $ validationState = self :: FASTLY_NON_VALIDATED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ validationState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ validationState , 'dt' => ucfirst ( $ validationState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ validationState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; } 
public function sendConfigurationRequest ( $ configuredFlag ) { if ( $ configuredFlag ) { $ configuredState = self :: FASTLY_CONFIGURED_FLAG ; } else { $ configuredState = self :: FASTLY_NOT_CONFIGURED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ configuredState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ configuredState , 'dt' => ucfirst ( $ configuredState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ configuredState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; } 
public function daysFromInstallation ( ) { $ stat = $ this -> statisticRepository -> getStatByAction ( self :: FASTLY_INSTALLED_FLAG ) ; if ( ! $ stat -> getCreatedAt ( ) ) { return null ; } $ installDate = date_create ( $ stat -> getCreatedAt ( ) ) ; $ currentDate = date_create ( $ this -> dateTime -> gmtDate ( ) ) ; $ dateDiff = date_diff ( $ installDate , $ currentDate ) ; return $ dateDiff -> days ; } 
private function sendReqToGA ( $ body = '' , $ method = \ Zend_Http_Client :: POST , $ uri = self :: GA_API_ENDPOINT ) { $ reqGAData = ( array ) $ this -> getGAReqData ( ) ; if ( $ body != '' && is_array ( $ body ) && ! empty ( $ body ) ) { $ body = array_merge ( $ reqGAData , $ body ) ; } try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 10 ) ; $ client -> write ( $ method , $ uri , '1.1' , null , http_build_query ( $ body ) ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; $ client -> close ( ) ; if ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( 'Return status ' . $ responseCode ) ) ; } return true ; } catch ( \ Exception $ e ) { return false ; } } 
protected function _toHtml ( ) 
protected function _construct ( ) 
public function renderCellTemplate ( $ columnName ) { if ( $ columnName == 'store_id' && isset ( $ this -> _columns [ $ columnName ] ) ) { $ options = $ this -> getOptions ( __ ( '-- Select Store --' ) ) ; $ element = $ this -> elementFactory -> create ( 'select' ) ; $ element -> setForm ( $ this -> getForm ( ) ) -> setName ( $ this -> _getCellInputElementName ( $ columnName ) ) -> setHtmlId ( $ this -> _getCellInputElementId ( '<%- _id %>' , $ columnName ) ) -> setValues ( $ options ) ; return str_replace ( "\n" , '' , $ element -> getElementHtml ( ) ) ; } return parent :: renderCellTemplate ( $ columnName ) ; } 
protected function getOptions ( $ label = false ) 
public function toOptionArray ( ) { return [ [ 'value' => \ Fastly \ Cdn \ Model \ Config :: GEOIP_ACTION_DIALOG , 'label' => __ ( 'Dialog' ) , ] , [ 'value' => \ Fastly \ Cdn \ Model \ Config :: GEOIP_ACTION_REDIRECT , 'label' => __ ( 'Redirect' ) ] ] ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ dictionaryId = $ this -> getRequest ( ) -> getParam ( 'dictionary_id' ) ; $ key = $ this -> getRequest ( ) -> getParam ( 'item_key' ) ; if ( $ key == '' ) { return $ result -> setData ( [ 'status' => true ] ) ; } $ deleteItem = $ this -> api -> deleteDictionaryItem ( $ dictionaryId , $ key ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; $ from = $ this -> getRequest ( ) -> getParam ( 'from' ) ; $ to = $ this -> getRequest ( ) -> getParam ( 'to' ) ; $ sampleRate = $ this -> getRequest ( ) -> getParam ( 'sample_rate' ) ; $ region = $ this -> getRequest ( ) -> getParam ( 'region' ) ; if ( ! $ from || ! $ to ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Please enter dates.' ] ) ; } $ fromTimestamp = strtotime ( $ from ) ; $ toTimestamp = strtotime ( $ to ) ; $ parameters = [ ] ; $ parameters [ 'from' ] = $ fromTimestamp ; $ parameters [ 'to' ] = $ toTimestamp ; $ parameters [ 'sample_rate' ] = $ sampleRate ; $ parameters [ 'region' ] = $ region ; $ queryResult = $ this -> api -> queryHistoricStats ( $ parameters ) ; return $ result -> setData ( [ 'status' => true , 'stats' => $ queryResult ] ) ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ comment = $ this -> getRequest ( ) -> getParam ( 'comment_value' ) ; $ negated = 0 ; if ( $ value [ 0 ] == '!' ) { $ negated = 1 ; $ value = ltrim ( $ value , '!' ) ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> determineVersions ( $ service -> versions ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_BLOCKING_PATH , Config :: VCL_BLOCKING_SNIPPET ) ; $ country_codes = $ this -> prepareCountryCodes ( $ this -> request -> getParam ( 'countries' ) ) ; $ acls = $ this -> prepareAcls ( $ this -> request -> getParam ( 'acls' ) ) ; $ blockedItems = $ country_codes . $ acls ; $ strippedBlockedItems = substr ( $ blockedItems , 0 , strrpos ( $ blockedItems , '||' , - 1 ) ) ; $ blockingType = $ this -> request -> getParam ( 'blocking_type' ) ; $ this -> configWriter -> save ( Config :: XML_FASTLY_BLOCKING_TYPE , $ blockingType , 'default' , '0' ) ; 
private function prepareAcls ( $ blockedAcls ) { $ result = '' ; $ aclsArray = [ ] ; $ acls = '' ; if ( $ blockedAcls != null ) { foreach ( $ blockedAcls as $ key => $ value ) { $ aclsArray [ ] = $ value [ 'value' ] ; } $ acls = implode ( ',' , $ aclsArray ) ; } $ this -> configWriter -> save ( Config :: XML_FASTLY_BLOCK_BY_ACL , $ acls , 'default' , '0' ) ; if ( $ acls != '' ) { $ blockedAclsPieces = explode ( "," , $ acls ) ; foreach ( $ blockedAclsPieces as $ acl ) { $ result .= ' req.http.Fastly-Client-Ip ~ ' . $ acl . ' ||' ; } } return $ result ; } 
private function prepareCountryCodes ( $ blockedCountries ) { $ result = '' ; $ countriesArray = [ ] ; $ countries = '' ; if ( $ blockedCountries != null ) { foreach ( $ blockedCountries as $ key => $ value ) { $ countriesArray [ ] = $ value [ 'value' ] ; } $ countries = implode ( ',' , $ countriesArray ) ; } $ this -> configWriter -> save ( Config :: XML_FASTLY_BLOCK_BY_COUNTRY , $ countries , 'default' , '0' ) ; if ( $ countries != '' ) { $ blockedCountriesPieces = explode ( "," , $ countries ) ; foreach ( $ blockedCountriesPieces as $ code ) { $ result .= ' client.geo.country_code == "' . $ code . '" ||' ; } } return $ result ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( 'vcl_snippets_custom' ) ; $ customSnippets = $ read -> read ( $ snippetPath ) ; if ( ! $ customSnippets ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'No snippets found.' ] ) ; } $ snippets = [ ] ; foreach ( $ customSnippets as $ snippet ) { $ snippets [ ] = explode ( '/' , $ snippet ) [ 1 ] ; } return $ result -> setData ( [ 'status' => true , 'snippets' => $ snippets ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function sendPurgeRequest ( $ pattern = '' ) { if ( empty ( $ pattern ) ) { if ( $ this -> config -> canPreserveStatic ( ) ) { $ result = $ this -> api -> cleanBySurrogateKey ( [ 'text' ] ) ; } else { $ result = $ this -> api -> cleanAll ( ) ; } } elseif ( ! is_array ( $ pattern ) && strpos ( $ pattern , 'http' ) === 0 ) { $ result = $ this -> api -> cleanUrl ( $ pattern ) ; } elseif ( is_array ( $ pattern ) ) { $ result = $ this -> api -> cleanBySurrogateKey ( $ pattern ) ; } else { return false ; } return $ result ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( ) ; $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ customSnippetPath = $ read -> getAbsolutePath ( Config :: CUSTOM_SNIPPET_PATH ) ; $ customSnippets = $ this -> config -> getCustomSnippets ( $ customSnippetPath ) ; foreach ( $ snippets as $ key => $ value ) { $ priority = 50 ; if ( $ key == 'hash' ) { $ priority = 80 ; } $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'priority' => $ priority , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } foreach ( $ customSnippets as $ key => $ value ) { $ snippetNameData = $ this -> validateCustomSnippet ( $ key ) ; $ snippetType = $ snippetNameData [ 0 ] ; $ snippetPriority = $ snippetNameData [ 1 ] ; $ snippetShortName = $ snippetNameData [ 2 ] ; $ customSnippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_' . $ snippetShortName , 'type' => $ snippetType , 'priority' => $ snippetPriority , 'content' => $ value , 'dynamic' => '0' ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ customSnippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_pass' , 'statement' => 'req.http.x-pass' , 'type' => 'REQUEST' , 'priority' => 90 ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ request = [ 'action' => 'pass' , 'max_stale_age' => 3600 , 'name' => Config :: FASTLY_MAGENTO_MODULE . '_request' , 'request_condition' => $ createCondition -> name , 'service_id' => $ service -> id , 'version' => $ currActiveVersion ] ; $ this -> api -> createRequest ( $ clone -> number , $ request ) ; $ dictionary = $ this -> setupDictionary ( $ clone -> number , $ currActiveVersion ) ; $ acl = $ this -> setupAcl ( $ clone -> number , $ currActiveVersion ) ; if ( ! $ dictionary || ! $ acl ) { throw new LocalizedException ( __ ( 'Failed to create Containers' ) ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Upload VCL has been initiated and activated in version ' . $ clone -> number . '*' ) ; } $ comment = [ 'comment' => 'Magento Module uploaded VCL' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
private function validateCustomSnippet ( $ customSnippet ) { $ snippetName = str_replace ( ' ' , '' , $ customSnippet ) ; $ snippetNameData = explode ( '_' , $ snippetName , 3 ) ; $ containsEmpty = in_array ( "" , $ snippetNameData , true ) ; $ types = [ 'init' , 'recv' , 'hit' , 'miss' , 'pass' , 'fetch' , 'error' , 'log' , 'deliver' , 'hash' , 'none' ] ; $ exception = 'Failed to upload VCL snippets. Please make sure the custom VCL snippets follow this naming convention: [vcl_snippet_type]_[priority]_[short_name_description].vcl' ; if ( count ( $ snippetNameData ) < 3 ) { throw new LocalizedException ( __ ( $ exception ) ) ; } $ inArray = in_array ( $ snippetNameData [ 0 ] , $ types ) ; $ isNumeric = is_numeric ( $ snippetNameData [ 1 ] ) ; $ isAlphanumeric = preg_match ( '/^[\w]+$/' , $ snippetNameData [ 2 ] ) ; if ( $ containsEmpty || ! $ inArray || ! $ isNumeric || ! $ isAlphanumeric ) { throw new LocalizedException ( __ ( $ exception ) ) ; } return $ snippetNameData ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ wafContent = $ this -> getRequest ( ) -> getParam ( 'content' ) ; $ wafStatus = $ this -> getRequest ( ) -> getParam ( 'status' ) ; $ wafContentType = $ this -> getRequest ( ) -> getParam ( 'content_type' ) ; $ wafResponse = '' ; if ( ! $ wafContent || ! $ wafStatus || ! $ wafContentType ) { throw new LocalizedException ( __ ( 'Please fill in the required fields.' ) ) ; } $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ http_codes = [ 100 => 'Continue' , 101 => 'Switching Protocols' , 102 => 'Processing' , 103 => 'Checkpoint' , 200 => 'OK' , 201 => 'Created' , 202 => 'Accepted' , 203 => 'Non-Authoritative Information' , 204 => 'No Content' , 205 => 'Reset Content' , 206 => 'Partial Content' , 207 => 'Multi-Status' , 300 => 'Multiple Choices' , 301 => 'Moved Permanently' , 302 => 'Found' , 303 => 'See Other' , 304 => 'Not Modified' , 305 => 'Use Proxy' , 306 => 'Switch Proxy' , 307 => 'Temporary Redirect' , 400 => 'Bad Request' , 401 => 'Unauthorized' , 402 => 'Payment Required' , 403 => 'Forbidden' , 404 => 'Not Found' , 405 => 'Method Not Allowed' , 406 => 'Not Acceptable' , 407 => 'Proxy Authentication Required' , 408 => 'Request Timeout' , 409 => 'Conflict' , 410 => 'Gone' , 411 => 'Length Required' , 412 => 'Precondition Failed' , 413 => 'Request Entity Too Large' , 414 => 'Request-URI Too Long' , 415 => 'Unsupported Media Type' , 416 => 'Requested Range Not Satisfiable' , 417 => 'Expectation Failed' , 418 => 'I\'m a teapot' , 422 => 'Unprocessable Entity' , 423 => 'Locked' , 424 => 'Failed Dependency' , 425 => 'Unordered Collection' , 426 => 'Upgrade Required' , 449 => 'Retry With' , 450 => 'Blocked by Windows Parental Controls' , 500 => 'Internal Server Error' , 501 => 'Not Implemented' , 502 => 'Bad Gateway' , 503 => 'Service Unavailable' , 504 => 'Gateway Timeout' , 505 => 'HTTP Version Not Supported' , 506 => 'Variant Also Negotiates' , 507 => 'Insufficient Storage' , 509 => 'Bandwidth Limit Exceeded' , 510 => 'Not Extended' ] ; foreach ( $ http_codes as $ key => $ value ) { if ( $ key == $ wafStatus ) { $ wafResponse = $ value ; break ; } } $ response = [ 'name' => Config :: WAF_PAGE_RESPONSE_OBJECT , 'content' => $ wafContent , 'status' => $ wafStatus , 'content_type' => $ wafContentType , 'response' => $ wafResponse ] ; $ createResponse = $ this -> api -> createResponse ( $ clone -> number , $ response ) ; if ( ! $ createResponse ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create a RESPONSE object.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*New WAF page has updated and activated under config version ' . $ clone -> number . '*' ) ; } $ comment = [ 'comment' => 'Magento Module updated WAF Page html' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ output = $ this -> layoutFactory -> create ( ) -> createBlock ( 'Fastly\Cdn\Block\Dashboard\Tab\Stats\Historic' ) -> toHtml ( ) ; $ resultRaw = $ this -> resultRawFactory -> create ( ) ; return $ resultRaw -> setContents ( $ output ) ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippet = $ this -> getRequest ( ) -> getParam ( 'snippet_id' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ write = $ this -> filesystem -> getDirectoryWrite ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ write -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ snippet ) ; $ snippetName = explode ( '_' , $ snippet ) ; $ snippetName = explode ( '.' , $ snippetName [ 2 ] ) ; $ reqName = Config :: FASTLY_MAGENTO_MODULE . '_' . $ snippetName [ 0 ] ; $ checkIfSnippetExist = $ this -> api -> hasSnippet ( $ activeVersion , $ reqName ) ; if ( $ checkIfSnippetExist ) { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ this -> api -> removeSnippet ( $ clone -> number , $ reqName ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ comment = [ 'comment' => 'Magento Module deleted the ' . $ reqName . ' custom snippet.' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; } if ( $ write -> isExist ( $ snippetPath ) ) { $ write -> delete ( $ snippetPath ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; if ( ! $ service ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Service details.' ] ) ; } return $ result -> $ this -> acl -> determineVersions ( $ service -> versions ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function checkUpdate ( $ currentVersion = null ) { $ lastVersion = $ this -> getLastVersion ( ) ; if ( ! $ lastVersion || version_compare ( $ lastVersion , $ currentVersion , '<=' ) ) { return ; } $ versionPath = Config :: XML_FASTLY_LAST_CHECKED_ISSUED_VERSION ; $ oldValue = $ this -> scopeConfig -> getValue ( $ versionPath ) ; if ( version_compare ( $ oldValue , $ lastVersion , '<' ) ) { $ this -> configWriter -> save ( $ versionPath , $ lastVersion ) ; 
public function getLastVersion ( ) { try { $ url = self :: CHECK_VERSION_URL ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> write ( \ Zend_Http_Client :: GET , $ url , '1.1' ) ; $ responseBody = $ client -> read ( ) ; $ client -> close ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; if ( $ responseCode !== 200 ) { return false ; } $ body = \ Zend_Http_Response :: extractBody ( $ responseBody ) ; $ json = json_decode ( $ body ) ; $ version = ! empty ( $ json -> version ) ? $ json -> version : false ; return $ version ; } catch ( \ Exception $ e ) { $ this -> _logger -> log ( 100 , $ e -> getMessage ( ) . $ url ) ; return false ; } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ dictionaryId = $ this -> getRequest ( ) -> getParam ( 'dictionary_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ key = $ this -> getRequest ( ) -> getParam ( 'item_key' ) ; $ this -> api -> upsertDictionaryItem ( $ dictionaryId , $ key , $ value ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItems = $ this -> api -> aclItemsList ( $ aclId ) ; if ( is_array ( $ aclItems ) && empty ( $ aclItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'aclItems' => [ ] ] ) ; } if ( ! $ aclItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch acl items.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'aclItems' => $ aclItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { try { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { 
public function aroundGetElementByPathParts ( \ Closure $ proceed , array $ pathParts ) { $ result = $ proceed ( $ pathParts ) ; if ( $ this -> isLoaded == true || false ) { return $ result ; } if ( ( $ result instanceof Section ) == false ) { return $ result ; } if ( isset ( $ pathParts [ 0 ] ) == false || $ pathParts [ 0 ] != 'system' ) { return $ result ; } $ this -> isLoaded = true ; $ data = $ result -> getData ( ) ; if ( isset ( $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ) == false ) { return $ result ; } $ original = $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ; $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] = array_merge ( $ original , $ this -> loadModlyData ( ) ) ; $ result -> setData ( $ data , $ this -> scopeDefiner -> getScope ( ) ) ; return $ result ; } 
public function cleanUrl ( $ url ) { $ result = $ this -> _purge ( $ url , 'PURGE' , 'PURGE' ) ; if ( $ result [ 'status' ] ) { $ this -> logger -> execute ( $ url ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishKeyUrlChanges ( ) ) { $ this -> sendWebHook ( '*clean by URL for* ' . $ url ) ; } return $ result ; } 
public function cleanBySurrogateKey ( $ keys ) { $ type = 'clean by key on ' ; $ uri = $ this -> _getApiServiceUri ( ) . 'purge' ; $ num = count ( $ keys ) ; $ result = false ; if ( $ num >= self :: FASTLY_MAX_HEADER_KEY_SIZE ) { $ parts = $ num / self :: FASTLY_MAX_HEADER_KEY_SIZE ; $ additional = ( $ parts > ( int ) $ parts ) ? 1 : 0 ; $ parts = ( int ) $ parts + ( int ) $ additional ; $ chunks = ceil ( $ num / $ parts ) ; $ collection = array_chunk ( $ keys , $ chunks ) ; } else { $ collection = [ $ keys ] ; } foreach ( $ collection as $ keys ) { $ payload = json_encode ( [ 'surrogate_keys' => $ keys ] ) ; $ result = $ this -> _purge ( $ uri , null , \ Zend_Http_Client :: POST , $ payload ) ; if ( $ result [ 'status' ] ) { foreach ( $ keys as $ key ) { $ this -> logger -> execute ( 'surrogate key: ' . $ key ) ; } } $ canPublishKeyUrlChanges = $ this -> config -> canPublishKeyUrlChanges ( ) ; $ canPublishPurgeChanges = $ this -> config -> canPublishPurgeChanges ( ) ; if ( $ this -> config -> areWebHooksEnabled ( ) && ( $ canPublishKeyUrlChanges || $ canPublishPurgeChanges ) ) { $ status = $ result [ 'status' ] ? '' : 'FAILED ' ; $ this -> sendWebHook ( $ status . '*clean by key on ' . join ( " " , $ keys ) . '*' ) ; $ canPublishPurgeByKeyDebugBacktrace = $ this -> config -> canPublishPurgeByKeyDebugBacktrace ( ) ; $ canPublishPurgeDebugBacktrace = $ this -> config -> canPublishPurgeDebugBacktrace ( ) ; if ( $ canPublishPurgeByKeyDebugBacktrace == false && $ canPublishPurgeDebugBacktrace == false ) { return $ result [ 'status' ] ; } $ this -> stackTrace ( $ type . join ( " " , $ keys ) ) ; } } return $ result [ 'status' ] ; } 
public function cleanAll ( ) { 
private function _purge ( $ uri , $ type , $ method = \ Zend_Http_Client :: POST , $ payload = null ) { if ( $ method == 'PURGE' ) { 
public function getCustomerInfo ( ) { $ uri = $ this -> config -> getApiEndpoint ( ) . 'current_customer' ; $ result = $ this -> _fetch ( $ uri ) ; return $ result ; } 
public function checkServiceDetails ( $ test = false , $ serviceId = null , $ apiKey = null ) { if ( ! $ test ) { $ uri = rtrim ( $ this -> _getApiServiceUri ( ) , '/' ) ; $ result = $ this -> _fetch ( $ uri ) ; } else { $ uri = $ this -> config -> getApiEndpoint ( ) . 'service/' . $ serviceId ; $ result = $ this -> _fetch ( $ uri , \ Zend_Http_Client :: GET , null , true , $ apiKey ) ; } if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to check Service details.' ) ) ; } return $ result ; } 
public function cloneVersion ( $ curVersion ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ curVersion . '/clone' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to clone active version.' ) ) ; } return $ result ; } 
public function addComment ( $ version , $ comment ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ comment ) ; return $ result ; } 
public function uploadVcl ( $ version , $ vcl ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/vcl' ; $ result = $ this -> _fetch ( $ url , 'POST' , $ vcl ) ; return $ result ; } 
public function setVclAsMain ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/vcl/' . $ name . '/main' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; } 
public function validateServiceVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/validate' ; $ result = $ this -> _fetch ( $ url , 'GET' ) ; if ( $ result -> status == 'error' ) { throw new LocalizedException ( __ ( 'Failed to validate service version: ' . $ result -> msg ) ) ; } } 
public function activateVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/activate' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; } 
public function uploadSnippet ( $ version , array $ snippet ) { 
public function updateSnippet ( array $ snippet ) { $ url = $ this -> _getApiServiceUri ( ) . 'snippet' . '/' . $ snippet [ 'name' ] ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ snippet ) ; return $ result ; } 
public function hasSnippet ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/snippet/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET , '' , false , null , false ) ; if ( $ result == false ) { return false ; } return true ; } 
public function createCondition ( $ version , array $ condition ) { $ checkIfExists = $ this -> getCondition ( $ version , $ condition [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/condition' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ condition [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ condition ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create a REQUEST condition.' ) ) ; } return $ result ; } 
public function createHeader ( $ version , array $ condition ) { $ checkIfExists = $ this -> getHeader ( $ version , $ condition [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/header' ; if ( $ checkIfExists === false ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ condition [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ condition ) ; return $ result ; } 
public function createResponse ( $ version , array $ response ) { $ checkIfExists = $ this -> getResponse ( $ version , $ response [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/response_object' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ response [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ response ) ; return $ result ; } 
public function getResponse ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/response_object/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; } 
public function createRequest ( $ version , $ request ) { $ checkIfExists = $ this -> getRequest ( $ version , $ request [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ request [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ request ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create the REQUEST object.' ) ) ; } } 
public function getRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET , '' , false , null , false ) ; return $ result ; } 
public function deleteRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to delete the REQUEST object.' ) ) ; } } 
public function getBackends ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; } 
public function configureBackend ( $ params , $ version , $ old_name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend/' . str_replace ( ' ' , '%20' , $ old_name ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ params ) ; return $ result ; } 
public function sendWebHook ( $ message ) { $ url = $ this -> config -> getIncomingWebhookURL ( ) ; $ messagePrefix = $ this -> config -> getWebhookMessagePrefix ( ) ; $ currentUsername = 'System' ; try { if ( $ this -> state -> getAreaCode ( ) == 'adminhtml' ) { $ getUser = $ this -> authSession -> getUser ( ) ; if ( ! empty ( $ getUser ) ) { $ currentUsername = $ getUser -> getUserName ( ) ; } } } catch ( \ Exception $ e ) { $ this -> log -> log ( 100 , 'Failed to retrieve Area Code' ) ; } $ storeName = $ this -> helper -> getStoreName ( ) ; $ storeUrl = $ this -> helper -> getStoreUrl ( ) ; $ text = $ messagePrefix . ' user=' . $ currentUsername . ' ' . $ message . ' on <' . $ storeUrl . '|Store> | ' . $ storeName ; $ headers = [ 'Content-type: application/json' ] ; $ body = json_encode ( [ "text" => $ text , "username" => "fastly-magento-bot" , "icon_emoji" => ":airplane:" ] ) ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_CONNECTTIMEOUT , 2 ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 3 ) ; $ client -> write ( \ Zend_Http_Client :: POST , $ url , '1.1' , $ headers , $ body ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; if ( $ responseCode != 200 ) { $ this -> log -> log ( 100 , 'Failed to send message to the following Webhook: ' . $ url ) ; } $ client -> close ( ) ; } 
public function createDictionary ( $ version , $ params ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/dictionary' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: POST , $ params ) ; return $ result ; } 
public function dictionaryItemsList ( $ dictionaryId ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/items' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; } 
public function getSingleDictionary ( $ version , $ dictionaryName ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/dictionary/' . $ dictionaryName ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; } 
public function getAuthDictionary ( $ version ) { $ name = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> getSingleDictionary ( $ version , $ name ) ; return $ dictionary ; } 
public function checkAuthDictionaryPopulation ( $ version ) { $ dictionary = $ this -> getAuthDictionary ( $ version ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { throw new LocalizedException ( __ ( 'You must add users in order to enable Basic Authentication.' ) ) ; } $ authItems = $ this -> dictionaryItemsList ( $ dictionary -> id ) ; if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { throw new LocalizedException ( __ ( 'You must add users in order to enable Basic Authentication.' ) ) ; } } 
public function createDictionaryItems ( $ dictionaryId , $ params ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/items' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , $ params ) ; return $ result ; } 
public function deleteDictionaryItem ( $ dictionaryId , $ itemKey ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/item/' . urlencode ( $ itemKey ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; } 
public function upsertDictionaryItem ( $ dictionaryId , $ itemKey , $ itemValue ) { $ body = [ 'item_value' => $ itemValue ] ; $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/item/' . urlencode ( $ itemKey ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ body ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create Dictionary item.' ) ) ; } } 
public function getSingleAcl ( $ version , $ acl ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/acl/' . $ acl ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; } 
public function deleteAcl ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/acl/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; } 
public function aclItemsList ( $ aclId ) { $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entries' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; } 
public function upsertAclItem ( $ aclId , $ itemValue , $ negated , $ comment = 'Added by Magento Module' , $ subnet = false ) { $ body = [ 'ip' => $ itemValue , 'negated' => $ negated , 'comment' => $ comment ] ; if ( $ subnet ) { $ body [ 'subnet' ] = $ subnet ; } $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: POST , $ body ) ; return $ result ; } 
public function deleteAclItem ( $ aclId , $ aclItemId ) { $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry/' . $ aclItemId ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; } 
public function updateAclItem ( $ aclId , $ aclItemId , $ itemValue , $ negated , $ comment = '' , $ subnet = false ) { $ body = [ 'ip' => $ itemValue , 'negated' => $ negated , 'comment' => $ comment ] ; if ( $ subnet ) { $ body [ 'subnet' ] = $ subnet ; } $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry/' . $ aclItemId ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , json_encode ( $ body ) ) ; return $ result ; } 
public function queryHistoricStats ( array $ parameters ) { $ uri = $ this -> _getHistoricalEndpoint ( ) . '?region=' . $ parameters [ 'region' ] . '&from=' . $ parameters [ 'from' ] . '&to=' . $ parameters [ 'to' ] . '&by=' . $ parameters [ 'sample_rate' ] ; $ result = $ this -> _fetch ( $ uri ) ; return $ result ; } 
public function checkImageOptimizationStatus ( ) { $ url = $ this -> _getApiServiceUri ( ) . 'dynamic_io_settings' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; } 
public function configureImageOptimizationDefaultConfigOptions ( $ params , $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/io_settings' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , $ params ) ; return $ result ; } 
public function getServiceDetails ( ) { $ url = $ this -> _getApiServiceUri ( ) . 'details' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; } 
public function getWafSettings ( $ id ) { $ url = $ this -> _getWafEndpoint ( ) . $ id ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; } 
private function _fetch ( $ uri , $ method = \ Zend_Http_Client :: GET , $ body = '' , $ test = false , $ testApiKey = null , $ logError = true ) { $ apiKey = ( $ test == true ) ? $ testApiKey : $ this -> config -> getApiKey ( ) ; 
public function aroundDispatch ( FrontController $ subject , callable $ proceed , ... $ args ) 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ req = $ this -> api -> checkImageOptimizationStatus ( ) ; if ( ! $ req ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check image optimization status.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { try { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { 
protected function execute ( InputInterface $ input , OutputInterface $ output ) 
private function isFastlyImageOptimizationEnabled ( ) { if ( $ this -> isFastlyEnabled !== null ) { return $ this -> isFastlyEnabled ; } $ this -> isFastlyEnabled = true ; if ( $ this -> _scopeConfig -> isSetFlag ( Config :: XML_FASTLY_IMAGE_OPTIMIZATIONS ) == false ) { $ this -> isFastlyEnabled = false ; } if ( $ this -> _scopeConfig -> getValue ( PageCacheConfig :: XML_PAGECACHE_TYPE ) !== Config :: FASTLY ) { $ this -> isFastlyEnabled = false ; } return $ this -> isFastlyEnabled ; } 
public function rotate ( $ angle ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { return parent :: rotate ( $ angle ) ; } return $ this -> fastlyRotate ( $ angle ) ; } 
private function fastlyRotate ( $ angle ) { $ angle = ( int ) $ angle ; $ orient = null ; if ( $ angle == 90 ) { $ orient = 'r' ; } if ( $ angle == - 90 || $ angle == 270 ) { $ orient = 'l' ; } if ( $ angle == 180 ) { $ orient = 3 ; } if ( $ orient !== null ) { $ this -> fastlyParameters [ 'orient' ] = $ orient ; } return $ this ; } 
private function fastlyResize ( ) { if ( $ this -> getWidth ( ) === null && $ this -> getHeight ( ) === null ) { return $ this ; } $ this -> adjustSize ( ) ; return $ this ; } 
public function getResizedImageInfo ( ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { return parent :: getResizedImageInfo ( ) ; } 
public function getUrl ( ) { 
public function getForceLossyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ extension = pathinfo ( $ baseFile , PATHINFO_EXTENSION ) ; 
public function getFastlyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ url = $ this -> getBaseFileUrl ( $ baseFile ) ; $ imageQuality = $ this -> _scopeConfig -> getValue ( Config :: XML_FASTLY_IMAGE_OPTIMIZATION_IMAGE_QUALITY ) ; $ this -> setQuality ( $ imageQuality ) ; $ this -> fastlyParameters [ 'quality' ] = $ this -> _quality ; if ( $ this -> _scopeConfig -> isSetFlag ( Config :: XML_FASTLY_IMAGE_OPTIMIZATION_BG_COLOR ) == true ) { $ this -> fastlyParameters [ 'bg-color' ] = implode ( ',' , $ this -> _backgroundColor ) ; } if ( $ this -> _keepAspectRatio == true ) { $ this -> fastlyParameters [ 'fit' ] = 'bounds' ; } $ this -> fastlyUrl = $ url . '?' . $ this -> compileFastlyParameters ( ) ; } 
private function compileFastlyParameters ( ) { if ( isset ( $ this -> fastlyParameters [ 'width' ] ) == false ) { $ this -> fastlyParameters [ 'height' ] = $ this -> _height ; $ this -> fastlyParameters [ 'width' ] = $ this -> _width ; } $ params = [ ] ; foreach ( $ this -> fastlyParameters as $ key => $ value ) { $ params [ ] = $ key . '=' . $ value ; } return implode ( '&' , $ params ) ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activate_flag = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ formData = $ this -> getRequest ( ) -> getParams ( ) ; if ( in_array ( "" , $ formData ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Please fill in the required fields.' ] ) ; } $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ id = $ service -> id . '-' . $ clone -> number . '-imageopto' ; $ params = json_encode ( [ 'data' => [ 'id' => $ id , 'type' => 'io_settings' , 'attributes' => [ 'webp' => $ this -> getRequest ( ) -> getParam ( 'webp' ) , 'webp_quality' => $ this -> getRequest ( ) -> getParam ( 'webp_quality' ) , 'jpeg_type' => $ this -> getRequest ( ) -> getParam ( 'jpeg_type' ) , 'jpeg_quality' => $ this -> getRequest ( ) -> getParam ( 'jpeg_quality' ) , 'upscale' => $ this -> getRequest ( ) -> getParam ( 'upscale' ) , 'resize_filter' => $ this -> getRequest ( ) -> getParam ( 'resize_filter' ) ] ] ] ) ; $ configureIo = $ this -> api -> configureImageOptimizationDefaultConfigOptions ( $ params , $ clone -> number ) ; if ( ! $ configureIo ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to update image optimization default config options.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activate_flag === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Image optimization default config options have been updated*' ) ; } $ comment = [ 'comment' => 'Magento Module updated the Image Optimization Default Configuration' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( Observer $ observer ) 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ checkIfSettingExists = $ this -> api -> hasSnippet ( $ activeVersion , Config :: BLOCKING_SETTING_NAME ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_BLOCKING_PATH , Config :: VCL_BLOCKING_SNIPPET ) ; $ country_codes = $ this -> prepareCountryCodes ( $ this -> config -> getBlockByCountry ( ) ) ; $ acls = $ this -> prepareAcls ( $ this -> config -> getBlockByAcl ( ) ) ; $ blockedItems = $ country_codes . $ acls ; $ strippedBlockedItems = substr ( $ blockedItems , 0 , strrpos ( $ blockedItems , '||' , - 1 ) ) ; if ( ! $ checkIfSettingExists ) { foreach ( $ snippet as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_blocking_' . $ key ; if ( $ this -> api -> hasSnippet ( $ clone -> number , $ name ) == true ) { $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; continue ; } if ( $ strippedBlockedItems === '' ) { $ value = '' ; } else { $ strippedBlockedItems = $ this -> config -> processBlockedItems ( $ strippedBlockedItems ) ; $ value = str_replace ( '####BLOCKED_ITEMS####' , $ strippedBlockedItems , $ value ) ; } $ snippetData = [ 'name' => $ name , 'type' => $ key , 'dynamic' => 1 , 'priority' => 5 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } } else { foreach ( $ snippet as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_blocking_' . $ key ; if ( $ this -> api -> hasSnippet ( $ clone -> number , $ name ) == true ) { $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ checkIfSettingExists , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON Blocking' ] ; if ( $ checkIfSettingExists ) { $ comment = [ 'comment' => 'Magento Module turned OFF Blocking' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
private function prepareAcls ( $ blockedAcls ) { $ result = '' ; if ( $ blockedAcls != null ) { $ blockedAclsPieces = explode ( "," , $ blockedAcls ) ; foreach ( $ blockedAclsPieces as $ acl ) { $ result .= ' req.http.Fastly-Client-Ip ~ ' . $ acl . ' ||' ; } } return $ result ; } 
private function prepareCountryCodes ( $ blockedCountries ) { $ result = '' ; if ( $ blockedCountries != null ) { $ blockedCountriesPieces = explode ( "," , $ blockedCountries ) ; foreach ( $ blockedCountriesPieces as $ code ) { $ result .= ' client.geo.country_code == "' . $ code . '" ||' ; } } return $ result ; } 
public function afterGetType ( Config $ config , $ result ) { if ( ! ( $ config instanceof \ Fastly \ Cdn \ Model \ Config ) ) { if ( $ result == \ Fastly \ Cdn \ Model \ Config :: FASTLY ) { return Config :: VARNISH ; } } return $ result ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ checkIfSettingExists = $ this -> api -> hasSnippet ( $ activeVersion , Config :: FORCE_TLS_SETTING_NAME ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: FORCE_TLS_PATH ) ; if ( ! $ checkIfSettingExists ) { 
public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ customer = $ this -> api -> getCustomerInfo ( ) ; if ( ! $ customer ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true , 'customer' => $ customer ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ enabled = false ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; 
public function upgrade ( ModuleDataSetupInterface $ setup , ModuleContextInterface $ context ) { $ version = $ context -> getVersion ( ) ; if ( ! $ version ) { return ; } $ oldConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/geoip_country_mapping' , ] ; $ newConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/fastly_advanced_configuration/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/fastly_advanced_configuration/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_country_mapping' ] ; $ setup -> startSetup ( ) ; if ( version_compare ( $ version , '1.0.8' , '<=' ) ) { $ this -> upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) ; } if ( version_compare ( $ version , '1.0.9' , '<=' ) ) { $ this -> upgrade109 ( $ setup ) ; } 
private function upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) { foreach ( $ oldConfigPaths as $ key => $ value ) { $ oldValue = $ this -> scopeConfig -> getValue ( $ value ) ; if ( $ oldValue != null ) { $ this -> configWriter -> save ( $ newConfigPaths [ $ key ] , $ oldValue ) ; 
private function upgrade109 ( ModuleDataSetupInterface $ setup ) { $ tableName = $ setup -> getTable ( 'fastly_statistics' ) ; if ( $ setup -> getConnection ( ) -> isTableExists ( $ tableName ) == true ) { $ data = [ 'action' => Statistic :: FASTLY_INSTALLED_FLAG , 'created_at' => $ this -> date -> date ( ) ] ; $ setup -> getConnection ( ) -> insert ( $ tableName , $ data ) ; 
private function upgrade1010 ( $ newConfigPaths ) { $ oldData = $ this -> scopeConfig -> getValue ( $ newConfigPaths [ 'geoip_country_mapping' ] ) ; try { $ oldData = unserialize ( $ oldData ) ; 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ modules = $ this -> manifest -> getAllModlyManifests ( ) ; if ( ! $ modules ) { return $ result -> setData ( [ 'status' => false , 'modules' => '' , 'msg' => 'Use the Refresh button to get the latest modules.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'modules' => $ modules ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function beforeSave ( ) { $ value = $ this -> getValue ( ) ; $ file = $ this -> getFileData ( ) ; if ( ! empty ( $ file ) ) { $ uploadDir = $ this -> _getUploadDir ( ) ; try { $ uploader = $ this -> _uploaderFactory -> create ( [ 'fileId' => $ file ] ) ; $ uploader -> setAllowedExtensions ( $ this -> getAllowedExtensions ( ) ) ; $ uploader -> setAllowRenameFiles ( true ) ; $ uploader -> addValidateCallback ( 'size' , $ this , 'validateMaxSize' ) ; $ result = $ uploader -> save ( $ uploadDir ) ; } catch ( \ Exception $ e ) { throw new \ Magento \ Framework \ Exception \ LocalizedException ( __ ( '%1' , $ e -> getMessage ( ) ) ) ; } $ filename = $ result [ 'file' ] ; if ( $ filename ) { if ( $ this -> _addWhetherScopeInfo ( ) ) { $ filename = $ this -> _prependScopeInfo ( $ filename ) ; } $ this -> setValue ( $ filename ) ; } } else { if ( is_array ( $ value ) && ! empty ( $ value [ 'delete' ] ) ) { $ this -> setValue ( '' ) ; } elseif ( is_array ( $ value ) && ! empty ( $ value [ 'value' ] ) ) { $ this -> setValue ( $ value [ 'value' ] ) ; } else { $ this -> unsValue ( ) ; } } return $ this ; } 
public function canShowBlock ( ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { return true ; } return false ; } 
public function getContentTypeOptions ( ) { $ contentTypes = [ self :: CONTENT_TYPE_HTML => __ ( 'HTML' ) , self :: CONTENT_TYPE_CSS => __ ( 'CSS' ) , self :: CONTENT_TYPE_JS => __ ( 'JavaScript' ) , self :: CONTENT_TYPE_IMAGE => __ ( 'Images' ) ] ; return $ contentTypes ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ aclName = $ this -> getRequest ( ) -> getParam ( 'acl_name' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ params = [ 'name' => $ aclName ] ; $ createAcl = $ this -> api -> createAcl ( $ clone -> number , $ params ) ; if ( ! $ createAcl ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Acl container.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ comment = [ 'comment' => 'Magento Module created the "' . $ aclName . '" ACL' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_AUTH_SNIPPET_PATH ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> hasSnippet ( $ activeVersion , $ name ) ; if ( $ status == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function getAllModules ( ) { $ modules = [ ] ; $ moduleCollection = $ this -> collectionFactory -> create ( ) -> getData ( ) ; foreach ( $ moduleCollection as $ module ) { $ modules [ ] = $ module ; } return $ modules ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ response = $ this -> api -> getResponse ( $ activeVersion , Config :: WAF_PAGE_RESPONSE_OBJECT ) ; if ( ! $ response ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch WAF page Response object.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'wafPageResp' => $ response ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function afterSave ( \ Magento \ Config \ Model \ Config $ subject ) 
public function beforeSave ( \ Magento \ Config \ Model \ Config $ subject ) { $ data = $ subject -> getData ( ) ; if ( ! empty ( $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ) ) { $ currentCacheConfig = $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ; $ oldCacheConfig = $ this -> scopeConfig -> getValue ( \ Magento \ PageCache \ Model \ Config :: XML_PAGECACHE_TYPE ) ; if ( $ oldCacheConfig == \ Fastly \ Cdn \ Model \ Config :: FASTLY && $ currentCacheConfig != $ oldCacheConfig ) { $ this -> purge = true ; } } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ domains = $ this -> api -> getAllDomains ( $ activeVersion ) ; $ storeBaseUrl = $ this -> storeManager -> getStore ( ) -> getBaseUrl ( ) ; if ( ! $ domains ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Domain details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'domains' => $ domains , 'store' => $ storeBaseUrl ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionaryName = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , $ dictionaryName ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || $ dictionary == false || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Basic Authentication cannot be enabled because there are no users assigned to it.' ] ) ; } else { $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Basic Authentication cannot be enabled because there are no users assigned to it.' ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function _getElementHtml ( AbstractElement $ element ) { $ this -> setNamePrefix ( $ element -> getName ( ) ) -> setHtmlId ( $ element -> getHtmlId ( ) ) ; return $ this -> _toHtml ( ) ; } 
public function getValues ( ) { $ values = [ ] ; $ ratios = $ this -> pixelRatios -> toOptionArray ( ) ; foreach ( $ ratios as $ value ) { $ values [ $ value [ 'value' ] ] = $ value [ 'label' ] ; } return $ values ; } 
public function getCheckedValues ( ) { if ( $ this -> values === null ) { $ data = $ this -> config -> getImageOptimizationRatios ( ) ; if ( ! isset ( $ data ) ) { $ data = '' ; } $ this -> values = explode ( ',' , $ data ) ; } return $ this -> values ; } 
public function render ( ) { return [ 'id' => $ this -> getId ( ) , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => 1 , 'label' => $ this -> label , 'comment' => $ this -> comment , '_elementType' => 'group' , 'path' => self :: BASE_CONFIG_PATH , 'children' => $ this -> children ] ; } 
public function addTextInput ( $ id , $ label , $ comment , $ required = true ) { $ this -> children [ $ id ] = [ 'id' => $ id , 'type' => 'text' , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => count ( $ this -> children ) , 'label' => $ label , 'comment' => $ comment , 'validate' => ( $ required == true ) ? 'required-entry' : '' , '_elementType' => 'field' , 'path' => self :: BASE_CONFIG_PATH . '/' . $ this -> id ] ; } 
public function render ( AbstractElement $ element ) { $ element -> unsScope ( ) -> unsCanUseWebsiteValue ( ) -> unsCanUseDefaultValue ( ) ; return parent :: render ( $ element ) ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ snippet = $ this -> getRequest ( ) -> getParam ( 'snippet_id' ) ; $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ snippet ) ; if ( $ read -> isExist ( $ snippetPath ) ) { $ explodeId = explode ( '.' , $ snippet , - 1 ) ; $ snippetParts = explode ( '_' , $ explodeId [ 0 ] , 3 ) ; $ type = $ snippetParts [ 0 ] ; $ priority = $ snippetParts [ 1 ] ; $ name = $ snippetParts [ 2 ] ; $ content = $ read -> readFile ( $ snippetPath ) ; } else { throw new LocalizedException ( __ ( 'Custom snippet not found.' ) ) ; } return $ result -> setData ( [ 'status' => true , 'type' => $ type , 'priority' => $ priority , 'name' => $ name , 'content' => $ content , 'original' => $ snippet ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { try { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { 
private function isHostInDomainList ( $ host ) { $ urlTypes = [ UrlInterface :: URL_TYPE_LINK , UrlInterface :: URL_TYPE_DIRECT_LINK , UrlInterface :: URL_TYPE_WEB , UrlInterface :: URL_TYPE_MEDIA , UrlInterface :: URL_TYPE_STATIC ] ; $ secureScheme = [ true , false ] ; foreach ( $ this -> storeManager -> getStores ( ) as $ store ) { foreach ( $ urlTypes as $ urlType ) { foreach ( $ secureScheme as $ scheme ) { $ shopHost = \ Zend_Uri :: factory ( $ store -> getBaseUrl ( $ urlType , $ scheme ) ) -> getHost ( ) ; if ( $ host === $ shopHost ) { return true ; } } } } return false ; } 
public function execute ( ) { $ resultLayout = null ; try { $ resultLayout = $ this -> resultLayoutFactory -> create ( ) ; $ resultLayout -> addDefaultHandle ( ) ; 
private function getMessageInStoreLocale ( StoreInterface $ emulatedStore ) { $ currentStore = $ this -> storeManager -> getStore ( ) ; 
public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; return $ result -> setData ( [ 'status' => true , 'service' => $ service , 'active_version' => $ this -> vcl -> getCurrentVersion ( $ service -> versions ) , 'next_version' => $ this -> vcl -> getNextVersion ( $ service -> versions ) , ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function aroundSendPurgeRequest ( PurgeCache $ subject , callable $ proceed , ... $ args ) 
public function execute ( Observer $ observer ) { if ( $ this -> fastlyConfig -> isFastlyEnabled ( ) != true ) { return ; } $ event = $ observer -> getEvent ( ) ; $ name = $ event -> getElementName ( ) ; $ layout = $ event -> getLayout ( ) ; $ block = $ layout -> getBlock ( $ name ) ; if ( $ block instanceof AbstractBlock ) { $ blockTtl = $ block -> getTtl ( ) ; if ( isset ( $ blockTtl ) ) { 
public function execute ( \ Magento \ Framework \ Event \ Observer $ observer ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { $ object = $ observer -> getEvent ( ) -> getObject ( ) ; if ( $ object instanceof \ Magento \ Framework \ DataObject \ IdentityInterface && $ this -> canPurgeObject ( $ object ) ) { $ tags = [ ] ; foreach ( $ object -> getIdentities ( ) as $ tag ) { $ tag = $ this -> cacheTags -> convertCacheTags ( $ tag ) ; if ( ! in_array ( $ tag , $ this -> alreadyPurged ) ) { $ tags [ ] = $ tag ; $ this -> alreadyPurged [ ] = $ tag ; } } if ( ! empty ( $ tags ) ) { $ this -> purgeCache -> sendPurgeRequest ( array_unique ( $ tags ) ) ; } } } } 
private function canPurgeObject ( \ Magento \ Framework \ DataObject \ IdentityInterface $ object ) { if ( $ object instanceof \ Magento \ Catalog \ Model \ Category && ! $ this -> config -> canPurgeCatalogCategory ( ) ) { return false ; } if ( $ object instanceof \ Magento \ Catalog \ Model \ Product && ! $ this -> config -> canPurgeCatalogProduct ( ) ) { return false ; } if ( $ object instanceof \ Magento \ Cms \ Model \ Page && ! $ this -> config -> canPurgeCmsPage ( ) ) { return false ; } return true ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , 'magentomodule_basic_auth' ) ; 
public function install ( SchemaSetupInterface $ setup , ModuleContextInterface $ context ) * Create table 'fastly_statistics' */ $ table = $ connection -> newTable ( $ installer -> getTable ( 'fastly_statistics' ) ) -> addColumn ( 'stat_id' , \ Magento \ Framework \ DB \ Ddl \ Table :: TYPE_INTEGER , null , [ 'identity' => true , 'unsigned' => true , 'nullable' => false , 'primary' => true ] , 'Stat id' ) -> addColumn ( 'action' , \ Magento \ Framework \ DB \ Ddl \ Table :: TYPE_TEXT , 30 , [ 'nullable' => false ] , 'Fastly action' ) -> addColumn ( 'sent' , \ Magento \ Framework \ DB \ Ddl \ Table :: TYPE_BOOLEAN , null , [ 'nullable' => false , 'default' => 0 ] , '1 = Curl req. sent | 0 = Curl req. not sent' ) -> addColumn ( 'state' , \ Magento \ Framework \ DB \ Ddl \ Table :: TYPE_BOOLEAN , null , [ 'nullable' => false , 'default' => 0 ] , '1 = configured | 0 = not_configured' ) -> addColumn ( 'created_at' , \ Magento \ Framework \ DB \ Ddl \ Table :: TYPE_DATETIME , null , [ ] , 'Action date' ) ; $ connection -> createTable ( $ table ) ; $ installer -> endSetup ( ) ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> determineVersions ( $ service -> versions ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> request -> getParam ( 'acls' ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; 
private function prepareAcls ( $ allowedAcls ) { $ result = '' ; $ aclsArray = [ ] ; $ acls = '' ; if ( $ allowedAcls != null ) { foreach ( $ allowedAcls as $ key => $ value ) { $ aclsArray [ ] = $ value [ 'value' ] ; } $ acls = implode ( ',' , $ aclsArray ) ; } $ this -> configWriter -> save ( Config :: XML_FASTLY_WAF_ALLOW_BY_ACL , $ acls , 'default' , '0' ) ; if ( $ acls != '' ) { $ allowedAclsPieces = explode ( "," , $ acls ) ; foreach ( $ allowedAclsPieces as $ acl ) { $ result .= ' req.http.Fastly-Client-Ip ~ ' . $ acl . ' ||' ; } } return $ result ; } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ name = $ this -> getRequest ( ) -> getParam ( 'name' ) ; $ type = $ this -> getRequest ( ) -> getParam ( 'type' ) ; $ priority = $ this -> getRequest ( ) -> getParam ( 'priority' ) ; $ vcl = $ this -> getRequest ( ) -> getParam ( 'vcl' ) ; $ validation = $ this -> config -> validateCustomSnippet ( $ name , $ type , $ priority ) ; $ error = $ validation [ 'error' ] ; if ( $ error != null ) { throw new LocalizedException ( __ ( $ error ) ) ; } $ snippetName = $ validation [ 'snippet_name' ] ; $ fileName = $ type . '_' . $ priority . '_' . $ snippetName . '.vcl' ; $ write = $ this -> filesystem -> getDirectoryWrite ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ write -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ fileName ) ; $ write -> writeFile ( $ snippetPath , $ vcl ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ dictionaryId = $ this -> getRequest ( ) -> getParam ( 'dictionary_id' ) ; $ dictionaryItems = $ this -> api -> dictionaryItemsList ( $ dictionaryId ) ; if ( is_array ( $ dictionaryItems ) && empty ( $ dictionaryItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'dictionaryItems' => [ ] ] ) ; } if ( ! $ dictionaryItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch dictionary items.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'dictionaryItems' => $ dictionaryItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function beforeToHtml ( Image $ subject ) { if ( $ this -> config -> isImageOptimizationPixelRatioEnabled ( ) !== true ) { return ; } $ srcSet = [ ] ; $ imageUrl = $ subject -> getData ( 'image_url' ) ; $ pixelRatios = $ this -> config -> getImageOptimizationRatios ( ) ; $ pixelRatiosArray = explode ( ',' , $ pixelRatios ) ; $ glue = ( strpos ( $ imageUrl , '?' ) !== false ) ? '&' : '?' ; # Pixel ratios defaults are based on the table from https: 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , Config :: AUTH_DICTIONARY_NAME ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ backends = $ this -> api -> getBackends ( $ activeVersion ) ; if ( ! $ backends ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Backend details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'backends' => $ backends ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( ) { 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ html = $ this -> getRequest ( ) -> getParam ( 'html' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_ERROR_SNIPPET_PATH , Config :: VCL_ERROR_SNIPPET ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_' . $ key , 'type' => $ key , 'dynamic' => '0' , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_condition' , 'statement' => 'req.http.ResponseObject == "970"' , 'type' => 'REQUEST' , 'priority' => '9' ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ response = [ 'name' => Config :: ERROR_PAGE_RESPONSE_OBJECT , 'request_condition' => $ createCondition -> name , 'content' => $ html , 'status' => "503" , 'content_type' => "text/html; charset=utf-8" , 'response' => "Service Temporarily Unavailable" ] ; $ createResponse = $ this -> api -> createResponse ( $ clone -> number , $ response ) ; if ( ! $ createResponse ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create a RESPONSE object.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*New Error/Maintenance page has updated and activated under config version ' . $ clone -> number . '*' ) ; } $ comment = [ 'comment' => 'Magento Module updated Error Page html' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function afterGenerateXml ( \ Magento \ Framework \ View \ Layout $ subject , $ result ) { * Surface the cacheability of a page. This may expose things like page blocks being set to * cacheable = false which makes the whole page uncacheable */ if ( $ subject -> isCacheable ( ) ) { $ this -> response -> setHeader ( "fastly-page-cacheable" , "YES" ) ; } else { $ this -> response -> setHeader ( "fastly-page-cacheable" , "NO" ) ; } return $ result ; } 
public function afterGetOutput ( \ Magento \ Framework \ View \ Layout $ subject , $ result ) 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ countries = $ this -> countryHelper -> toOptionArray ( ) ; if ( ! $ countries ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Could not fetch list countries.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'countries' => $ countries ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
private function enableFastly ( ) { $ this -> configWriter -> save ( 'system/full_page_cache/caching_application' , Config :: FASTLY ) ; $ this -> output -> writeln ( '<info>Fastly Caching Application Activated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } 
private function disableFastly ( ) { $ this -> configWriter -> save ( 'system/full_page_cache/caching_application' , \ Magento \ PageCache \ Model \ Config :: BUILT_IN ) ; $ this -> output -> writeln ( '<info>Fastly Caching Application Deactivated, default built in Caching mechanism set.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } 
private function setServiceID ( $ serviceId ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_SERVICE_ID , $ serviceId ) ; $ this -> output -> writeln ( '<info>Service ID updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } 
private function setToken ( $ token ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_API_KEY , $ token ) ; $ this -> output -> writeln ( '<info>Token updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } 
private function uploadVcl ( $ activate ) { try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'priority' => 50 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_pass' , 'statement' => 'req.http.x-pass' , 'type' => 'REQUEST' , 'priority' => 90 ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ request = [ 'action' => 'pass' , 'max_stale_age' => 3600 , 'name' => Config :: FASTLY_MAGENTO_MODULE . '_request' , 'request_condition' => $ createCondition -> name , 'service_id' => $ service -> id , 'version' => $ currActiveVersion ] ; $ this -> api -> createRequest ( $ clone -> number , $ request ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; $ msg = 'Successfully uploaded VCL. ' ; if ( $ activate ) { $ this -> api -> activateVersion ( $ clone -> number ) ; $ msg .= 'Activated Version ' . $ clone -> number ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Upload VCL has been initiated and activated in version ' . $ clone -> number . '*' ) ; } $ this -> output -> writeln ( '<info>' . $ msg . '</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } catch ( \ Exception $ e ) { $ msg = $ e -> getMessage ( ) ; $ this -> output -> writeln ( "<error>$msg</error>" , OutputInterface :: OUTPUT_NORMAL ) ; return ; } } 
public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ imageQualityFlag = $ this -> getRequest ( ) -> getParam ( 'image_quality_flag' ) ; $ imageQuality = $ this -> image -> getQuality ( ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ checkIfSettingExists = $ this -> api -> hasSnippet ( $ activeVersion , Config :: IMAGE_SETTING_NAME ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: IO_VCL_SNIPPET_PATH , 'recv.vcl' ) ; if ( ! $ checkIfSettingExists ) { foreach ( $ snippet as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_image_optimization_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'content' => $ value , 'priority' => 10 ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; $ id = $ service -> id . '-' . $ clone -> number . '-imageopto' ; # Make sure we set webp to auto default $ imageParams = [ 'data' => [ 'id' => $ id , 'type' => 'io_settings' , 'attributes' => [ 'webp' => true ] ] ] ; # Set image quality to magento default quality if selected if ( $ imageQualityFlag === 'true' ) { $ imageParams [ 'data' ] [ 'attributes' ] [ 'webp_quality' ] = $ imageQuality ; $ imageParams [ 'data' ] [ 'attributes' ] [ 'jpeg_quality' ] = $ imageQuality ; } $ this -> api -> configureImageOptimizationDefaultConfigOptions ( json_encode ( $ imageParams ) , $ clone -> number ) ; } } else { 
public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippet = Config :: BLOCKING_SETTING_NAME ; $ req = $ this -> api -> hasSnippet ( $ activeVersion , $ snippet ) ; if ( $ req == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function getAllRepoManifests ( ) { $ fastlyEdgeModules = $ this -> config -> getFastlyEdgeModules ( ) ; $ manifests = [ ] ; foreach ( $ fastlyEdgeModules as $ key => $ value ) { $ decodedManifestData = json_decode ( $ value , true ) ; $ manifests [ ] = $ decodedManifestData ; } return $ manifests ; } 
public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ serviceId = $ this -> config -> getServiceId ( ) ; $ apiKey = $ this -> config -> getApiKey ( ) ; if ( $ serviceId == null && $ apiKey == null ) { return $ result -> setData ( [ 'status' => true , 'flag' => false ] ) ; } return $ result -> setData ( [ 'status' => true , 'flag' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } } 
public function execute ( Observer $ observer ) 
public function execute ( \ Magento \ Framework \ Event \ Observer $ observer ) 
public function isImageOptimizationEnabled ( ) { if ( $ this -> isFastlyEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS ) ; } 
public function isImageOptimizationPixelRatioEnabled ( ) { if ( $ this -> isImageOptimizationEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS_PIXEL_RATIO ) ; } 
public function getGeoIpMappingForCountry ( $ countryCode ) { if ( $ mapping = $ this -> _scopeConfig -> getValue ( self :: XML_FASTLY_GEOIP_COUNTRY_MAPPING ) ) { return $ this -> extractMapping ( $ mapping , $ countryCode ) ; } return null ; } 
private function extractMapping ( $ mapping , $ countryCode ) { $ final = null ; $ extractMapping = json_decode ( $ mapping , true ) ; if ( ! $ extractMapping ) { try { $ extractMapping = unserialize ( $ mapping ) ; 
public function getVclFile ( $ vclTemplatePath ) 
public function getVclSnippets ( $ path = '/vcl_snippets' , $ specificFile = null ) { $ snippetsData = [ ] ; $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) . $ path ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; if ( ! $ specificFile ) { $ files = $ directoryRead -> read ( ) ; if ( is_array ( $ files ) ) { foreach ( $ files as $ file ) { if ( substr ( $ file , strpos ( $ file , "." ) + 1 ) !== 'vcl' ) { continue ; } $ snippetFilePath = $ moduleEtcPath . '/' . $ file ; $ snippetFilePath = $ directoryRead -> getRelativePath ( $ snippetFilePath ) ; $ type = explode ( '.' , $ file ) [ 0 ] ; $ snippetsData [ $ type ] = $ directoryRead -> readFile ( $ snippetFilePath ) ; } } } else { $ snippetFilePath = $ moduleEtcPath . '/' . $ specificFile ; $ snippetFilePath = $ directoryRead -> getRelativePath ( $ snippetFilePath ) ; $ type = explode ( '.' , $ specificFile ) [ 0 ] ; $ snippetsData [ $ type ] = $ directoryRead -> readFile ( $ snippetFilePath ) ; } return $ snippetsData ; } 
private function getDesignExceptions ( ) { $ result = '' ; $ tpl = " %s (req.http.user-agent ~ \"%s\") {\n" . " set req.hash += \"%s\";\n" . " }" ; $ expressions = $ this -> _scopeConfig -> getValue ( self :: XML_VARNISH_PAGECACHE_DESIGN_THEME_REGEX , \ Magento \ Store \ Model \ ScopeInterface :: SCOPE_STORE ) ; if ( $ expressions ) { try { $ expressions = unserialize ( $ expressions ) ; 
public function validateCustomSnippet ( $ name , $ type , $ priority ) { $ snippetName = str_replace ( ' ' , '' , $ name ) ; $ types = [ 'init' , 'recv' , 'hit' , 'miss' , 'pass' , 'fetch' , 'error' , 'deliver' , 'log' , 'hash' , 'none' ] ; $ inArray = in_array ( $ type , $ types ) ; $ isNumeric = is_numeric ( $ priority ) ; $ isAlphanumeric = preg_match ( '/^[\w]+$/' , $ snippetName ) ; $ error = null ; if ( ! $ inArray ) { $ error = 'Type value is not recognised.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } if ( ! $ isNumeric ) { $ error = 'Please make sure that the priority value is a number.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } if ( ! $ isAlphanumeric ) { $ error = 'Please make sure that the name value contains only alphanumeric characters.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } return [ 'snippet_name' => $ snippetName , 'error' => $ error ] ; } 
public function processBlockedItems ( $ strippedBlockedItems , $ blockingType = null ) { if ( empty ( $ blockingType ) ) { $ blockingType = $ this -> _scopeConfig -> getValue ( self :: XML_FASTLY_BLOCKING_TYPE ) ; } if ( $ blockingType == '1' ) { $ strippedBlockedItems = '!(' . $ strippedBlockedItems . ')' ; } return $ strippedBlockedItems ; } 
public function buildForm ( array $ form , FormStateInterface $ form_state ) { $ form = parent :: buildForm ( $ form , $ form_state ) ; $ form [ 'google_analytics' ] [ 'ga_account' ] = [ '#description' => t ( 'This ID is unique to each site you want to track separately, and is in the form of UA-xxxxxxx-yy. To get a Web Property ID, <a href=":analytics" target="_blank">register your site with Google Analytics</a>, or if you already have registered your site, go to your Google Analytics Settings page to see the ID next to every site profile. <a href=":webpropertyid" target="_blank">Find more information in the documentation</a>.' , [ ':analytics' => 'http://www.google.com/analytics/' , ':webpropertyid' => Url :: fromUri ( 'https://developers.google.com/analytics/resources/concepts/gaConceptsAccounts' , [ 'fragment' => 'webProperty' ] ) -> toString ( ) , ] ) , '#maxlength' => 20 , '#placeholder' => 'UA-' , '#size' => 15 , '#title' => t ( 'Web Property ID' ) , '#type' => 'textfield' , ] ; return $ form ; } 
public function applyEffect ( ImageInterface $ image ) { $ ratio_adjustment = isset ( $ this -> configuration [ 'ratio_adjustment' ] ) ? floatval ( $ this -> configuration [ 'ratio_adjustment' ] ) : 1 ; $ aspect = $ image -> getWidth ( ) / $ image -> getHeight ( ) ; 
public function transformDimensions ( array & $ dimensions , $ uri ) { if ( ! isset ( $ dimensions [ 'width' ] ) || ! isset ( $ dimensions [ 'height' ] ) ) { 
public function buildConfigurationForm ( array $ form , FormStateInterface $ form_state ) { $ image_styles = image_style_options ( FALSE ) ; $ form [ 'landscape' ] = [ '#type' => 'select' , '#title' => t ( 'Landscape image style' ) , '#options' => $ image_styles , '#default_value' => $ this -> configuration [ 'landscape' ] , '#description' => t ( 'Select the image style for landscape images' ) , '#required' => TRUE , ] ; $ form [ 'portrait' ] = [ '#type' => 'select' , '#title' => t ( 'Portrait' ) , '#options' => $ image_styles , '#default_value' => $ this -> configuration [ 'portrait' ] , '#description' => t ( 'Select the image style for portrait images' ) , '#required' => TRUE , ] ; return $ form ; } 
public function buildForm ( array $ form , FormStateInterface $ form_state , $ node = NULL ) { $ this -> revision = $ this -> nodeStorage -> load ( $ node ) ; $ form = ConfirmFormBase :: buildForm ( $ form , $ form_state ) ; return $ form ; } 
public function submitForm ( array & $ form , FormStateInterface $ form_state ) { 
protected function prepareRevertedRevision ( NodeInterface $ revision , FormStateInterface $ form_state ) { $ revision -> setNewRevision ( ) ; $ revision -> isDefaultRevision ( TRUE ) ; $ revision -> setRevisionTranslationAffected ( TRUE ) ; return $ revision ; } 
public function formElement ( FieldItemListInterface $ items , $ delta , array $ element , array & $ form , FormStateInterface $ form_state ) { $ entity = $ items -> getEntity ( ) ; $ workflow = $ this -> moderationInformation -> getWorkflowForEntity ( $ entity ) ; $ default = $ items -> get ( $ delta ) -> value ? $ workflow -> getTypePlugin ( ) -> getState ( $ items -> get ( $ delta ) -> value ) : $ workflow -> getTypePlugin ( ) -> getInitialState ( $ entity ) ; $ transitions = $ this -> validator -> getValidTransitions ( $ entity , $ this -> currentUser ) ; $ transition_labels = [ ] ; $ default_value = NULL ; foreach ( $ transitions as $ transition ) { $ transition_to_state = $ transition -> to ( ) ; $ transition_labels [ $ transition_to_state -> id ( ) ] = $ transition_to_state -> label ( ) ; if ( $ default -> id ( ) === $ transition_to_state -> id ( ) ) { $ default_value = $ default -> id ( ) ; } } $ element = [ '#type' => 'select' , '#key_column' => $ this -> column , '#options' => $ transition_labels , '#default_value' => $ default_value , '#access' => ! empty ( $ transition_labels ) , '#wrapper_attributes' => [ 'class' => [ 'container-inline' ] , ] , ] ; $ element [ '#element_validate' ] [ ] = [ get_class ( $ this ) , 'validateElement' ] ; return $ element ; } 
public function applies ( RouteMatchInterface $ route_match ) { 
public function build ( RouteMatchInterface $ route_match ) { $ breadcrumb = new Breadcrumb ( ) ; $ breadcrumb -> addCacheContexts ( [ 'route' ] ) ; 
protected function getRequestForPath ( $ path , array $ exclude ) { if ( ! empty ( $ exclude [ $ path ] ) ) { return NULL ; } 
public static function plainText ( $ value ) { $ element = render ( $ value ) ; $ element = strip_tags ( $ element ) ; $ element = html_entity_decode ( $ element , ENT_QUOTES ) ; return $ element ; } 
public function onImport ( ImportEvent $ event ) { $ uuids = [ '0bd5c257-2231-450f-b4c2-ab156af7b78d' , '36b2e2b2-3df0-43eb-a282-d792b0999c07' , '94ad928b-3ec8-4bcb-b617-ab1607bf69cb' , 'bbb1ee17-15f8-46bd-9df5-21c58040d741' , ] ; foreach ( $ event -> getImportedEntities ( ) as $ entity ) { if ( in_array ( $ entity -> uuid ( ) , $ uuids ) ) { $ entity -> moderation_state -> value = 'published' ; $ entity -> save ( ) ; } } } 
public function configDelete ( ConfigCrudEvent $ event ) { $ config = $ event -> getConfig ( ) ; if ( $ config -> getName ( ) === 'views.view.thunder_media' && ( $ media_view = View :: load ( 'media' ) ) ) { $ media_view -> setStatus ( TRUE ) -> save ( ) ; } } 
public function permissions ( ) { $ permissions = [ ] ; foreach ( $ this -> entityTypeManager -> getStorage ( 'taxonomy_vocabulary' ) -> loadMultiple ( ) as $ vocabulary ) { $ permissions += [ 'view published terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View published terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , 'view unpublished terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View unpublished terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , ] ; } return $ permissions ; } 
public function buildForm ( array $ form , FormStateInterface $ form_state ) { $ form = parent :: buildForm ( $ form , $ form_state ) ; $ form [ 'adsense' ] [ 'adsense_basic_id' ] = [ '#type' => 'textfield' , '#title' => t ( 'Site Google AdSense Publisher ID' ) , '#required' => FALSE , '#default_value' => '' , '#pattern' => 'pub-[0-9]+' , '#description' => t ( 'This is the Google AdSense Publisher ID for the site owner. It is used if no other ID is suitable. Get this in your Google Adsense account. It should be similar to %id.' , [ '%id' => 'pub-9999999999999' , ] ) , ] ; return $ form ; } 
public function submitForm ( array $ formValues ) { $ this -> configFactory -> getEditable ( 'adsense.settings' ) -> set ( 'adsense_basic_id' , ( string ) $ formValues [ 'adsense_basic_id' ] ) -> save ( TRUE ) ; } 
protected function checkAccess ( EntityInterface $ entity , $ operation , AccountInterface $ account ) { switch ( $ operation ) { case 'view' : 
public function buildForm ( array $ form , FormStateInterface $ form_state ) { $ form = parent :: buildForm ( $ form , $ form_state ) ; $ form [ 'thunder_liveblog' ] [ 'description' ] = [ '#type' => 'item' , '#markup' => $ this -> t ( 'Register a new account at <a href=":pusher_url" target="_blank">:pusher_url</a>, create a new app and note down your keys and cluster. You can provide them right here or at a later stage on the liveblog settings form.' , [ ':pusher_url' => 'http://pusher.com' ] ) , ] ; $ form [ 'thunder_liveblog' ] [ 'pusher_app_id' ] = [ '#type' => 'textfield' , '#title' => t ( 'App ID' ) , ] ; $ form [ 'thunder_liveblog' ] [ 'pusher_key' ] = [ '#type' => 'textfield' , '#title' => t ( 'Key' ) , ] ; $ form [ 'thunder_liveblog' ] [ 'pusher_secret' ] = [ '#type' => 'textfield' , '#title' => t ( 'Secret' ) , ] ; $ form [ 'thunder_liveblog' ] [ 'pusher_cluster' ] = [ '#type' => 'textfield' , '#title' => t ( 'Cluster' ) , '#description' => t ( 'The cluster name to connect to. Leave empty for the default cluster: mt1 (US east coast)' ) , ] ; return $ form ; } 
public function submitForm ( array $ formValues ) { $ this -> configFactory -> getEditable ( 'liveblog.notification_channel.liveblog_pusher' ) -> set ( 'app_id' , $ formValues [ 'pusher_app_id' ] ) -> set ( 'key' , $ formValues [ 'pusher_key' ] ) -> set ( 'secret' , $ formValues [ 'pusher_secret' ] ) -> set ( 'cluster' , $ formValues [ 'pusher_cluster' ] ) -> save ( TRUE ) ; if ( $ formValues [ 'pusher_app_id' ] && $ formValues [ 'pusher_key' ] && $ formValues [ 'pusher_secret' ] ) { $ this -> configFactory -> getEditable ( 'liveblog.settings' ) -> set ( 'notification_channel' , 'liveblog_pusher' ) -> save ( TRUE ) ; } } 
public static function create ( ContainerInterface $ container ) { return new static ( $ container -> get ( 'current_user' ) , $ container -> get ( 'messenger' ) , $ container -> get ( 'request_stack' ) , $ container -> get ( 'access_check.node.revision' ) , $ container -> has ( 'content_moderation.moderation_information' ) ? $ container -> get ( 'content_moderation.moderation_information' ) : NULL , $ container -> get ( 'entity_type.manager' ) ) ; } 
public function formAlter ( array & $ form , FormStateInterface $ form_state ) { $ form_object = $ form_state -> getFormObject ( ) ; $ entity = $ form_object -> getEntity ( ) ; $ storage = $ this -> entityTypeManager -> getStorage ( $ entity -> getEntityTypeId ( ) ) ; $ latest_revision_id = $ storage -> getLatestTranslationAffectedRevisionId ( $ entity -> id ( ) , $ entity -> language ( ) -> getId ( ) ) ; if ( $ latest_revision_id !== NULL && $ this -> moderationInfo && $ this -> moderationInfo -> hasPendingRevision ( $ entity ) ) { $ this -> messenger -> addWarning ( $ this -> t ( 'This %entity_type has unpublished changes from user %user.' , [ '%entity_type' => $ entity -> get ( 'type' ) -> entity -> label ( ) , '%user' => $ entity -> getRevisionUser ( ) -> label ( ) ] ) ) ; } $ form [ 'actions' ] = array_merge ( $ form [ 'actions' ] , $ this -> actions ( $ entity ) ) ; return $ form ; } 
protected function actions ( $ entity ) { $ storage = $ this -> entityTypeManager -> getStorage ( $ entity -> getEntityTypeId ( ) ) ; $ latest_revision_id = $ storage -> getLatestTranslationAffectedRevisionId ( $ entity -> id ( ) , $ entity -> language ( ) -> getId ( ) ) ; if ( $ latest_revision_id == NULL || ! $ this -> moderationInfo || ! $ this -> moderationInfo -> isModeratedEntity ( $ entity ) ) { return [ ] ; } $ state = $ this -> moderationInfo -> getWorkflowForEntity ( $ entity ) -> getTypePlugin ( ) -> getState ( $ entity -> moderation_state -> value ) ; $ element [ 'status' ] = [ '#type' => 'item' , '#markup' => $ entity -> isNew ( ) || ! $ this -> moderationInfo -> isDefaultRevisionPublished ( $ entity ) ? $ this -> t ( 'of unpublished @entity_type' , [ '@entity_type' => strtolower ( $ entity -> type -> entity -> label ( ) ) ] ) : $ this -> t ( 'of published @entity_type' , [ '@entity_type' => strtolower ( $ entity -> type -> entity -> label ( ) ) ] ) , '#weight' => 200 , '#wrapper_attributes' => [ 'class' => [ 'status' ] , ] , '#access' => ! $ state -> isDefaultRevisionState ( ) , ] ; $ element [ 'moderation_state_current' ] = [ '#type' => 'item' , '#markup' => $ state -> label ( ) , '#weight' => 210 , '#wrapper_attributes' => [ 'class' => [ 'status' , $ state -> id ( ) ] , ] , ] ; if ( $ this -> moderationInfo -> hasPendingRevision ( $ entity ) ) { $ route_info = Url :: fromRoute ( 'node.revision_revert_default_confirm' , [ 'node' => $ entity -> id ( ) , 'node_revision' => $ entity -> getRevisionId ( ) , ] ) ; if ( $ this -> request -> query -> has ( 'destination' ) ) { $ query = $ route_info -> getOption ( 'query' ) ; $ query [ 'destination' ] = $ this -> request -> query -> get ( 'destination' ) ; $ route_info -> setOption ( 'query' , $ query ) ; } $ element [ 'revert_to_default' ] = [ '#type' => 'link' , '#title' => $ this -> t ( 'Revert to default revision' ) , '#access' => $ this -> nodeRevisionAccess -> checkAccess ( $ entity , $ this -> currentUser , 'update' ) , '#weight' => 101 , '#attributes' => [ 'class' => [ 'button' , 'button--danger' ] , ] , ] ; $ element [ 'revert_to_default' ] [ '#url' ] = $ route_info ; } return $ element ; } 
public function getDerivativeDefinitions ( $ base_plugin_definition ) { if ( $ this -> moduleHandler -> moduleExists ( 'content_lock' ) && $ this -> routeProvider -> getRoutesByNames ( [ 'view.locked_content.page_1' ] ) ) { $ this -> derivatives [ "thunder_article.content_lock" ] = [ 'route_name' => "view.locked_content.page_1" , 'title' => $ this -> t ( 'Locked content' ) , 'parent_id' => "system.admin_content" , 'weight' => 2 , ] + $ base_plugin_definition ; } if ( $ this -> moduleHandler -> moduleExists ( 'scheduler' ) && $ this -> routeProvider -> getRoutesByNames ( [ 'view.scheduler_scheduled_content.overview' ] ) ) { 
public function form ( array $ form , FormStateInterface $ form_state ) { $ form = parent :: form ( $ form , $ form_state ) ; 
public function buildForm ( array $ form , FormStateInterface $ form_state ) { 
public function submitForm ( array & $ form , FormStateInterface $ form_state ) { $ installModules = [ ] ; foreach ( $ form_state -> getValues ( ) as $ key => $ value ) { if ( strpos ( $ key , 'install_modules' ) !== FALSE && $ value ) { preg_match ( '/install_modules_(?P<name>\w+)/' , $ key , $ values ) ; $ installModules [ ] = $ values [ 'name' ] ; } } $ buildInfo = $ form_state -> getBuildInfo ( ) ; $ install_state = $ buildInfo [ 'args' ] ; $ install_state [ 0 ] [ 'thunder_additional_modules' ] = $ installModules ; $ install_state [ 0 ] [ 'form_state_values' ] = $ form_state -> getValues ( ) ; $ buildInfo [ 'args' ] = $ install_state ; $ form_state -> setBuildInfo ( $ buildInfo ) ; } 
public function lock ( $ key ) { $ start = microtime ( true ) ; while ( is_null ( $ this -> redisClient -> set ( $ this -> getLockKey ( $ key ) , 'LOCKED' , 'PX' , 3600 , 'NX' ) ) ) { $ passed = ( microtime ( true ) - $ start ) * 1000 ; if ( $ passed > $ this -> lockWaitTimeout ) { throw new LockWaitTimeoutException ( ) ; } usleep ( 100 ) ; } } 
public function lock ( $ key ) { if ( ! isset ( $ this -> locked [ $ key ] ) ) { $ this -> locked [ $ key ] = false ; } $ start = microtime ( true ) ; while ( $ this -> locked [ $ key ] ) { $ passed = ( microtime ( true ) - $ start ) * 1000 ; if ( $ passed > $ this -> lockWaitTimeout ) { throw new LockWaitTimeoutException ( ) ; } } $ this -> locked [ $ key ] = true ; return ; } 
public function throttle ( $ key , $ limit , $ milliseconds ) { $ key = $ this -> getStorageKey ( $ key , $ limit , $ milliseconds ) ; $ wait = 0 ; $ newRatio = $ this -> getNewRatio ( $ key , $ limit , $ milliseconds ) ; if ( $ newRatio > $ milliseconds ) { $ wait = ceil ( $ newRatio - $ milliseconds ) ; } usleep ( $ wait * 1000 ) ; $ this -> storage -> lock ( $ key ) ; $ newRatio = $ this -> getNewRatio ( $ key , $ limit , $ milliseconds ) ; $ this -> setLastRatio ( $ key , $ newRatio ) ; $ this -> setLastRequest ( $ key , microtime ( 1 ) ) ; $ this -> storage -> unlock ( $ key ) ; return $ wait ; } 
public function getEstimate ( $ key , $ limit , $ milliseconds ) { $ key = $ this -> getStorageKey ( $ key , $ limit , $ milliseconds ) ; $ newRatio = $ this -> getNewRatio ( $ key , $ limit , $ milliseconds ) ; $ wait = 0 ; if ( $ newRatio > $ milliseconds ) { $ wait = ceil ( $ newRatio - $ milliseconds ) ; } return $ wait ; } 
protected function getNewRatio ( $ key , $ limit , $ milliseconds ) { $ lastRequest = $ this -> getLastRequest ( $ key ) ? : 0 ; $ lastRatio = $ this -> getLastRatio ( $ key ) ? : 0 ; $ diff = ( microtime ( 1 ) - $ lastRequest ) * 1000 ; $ newRatio = $ lastRatio - $ diff ; $ newRatio = $ newRatio < 0 ? 0 : $ newRatio ; $ newRatio += $ milliseconds / $ limit ; return $ newRatio ; } 
public function lock ( $ key ) { $ key = $ key . "::LOCK" ; $ start = microtime ( true ) ; while ( ! $ this -> memcached -> add ( $ key , true , $ this -> ttl ) ) { $ passed = ( microtime ( true ) - $ start ) * 1000 ; if ( $ passed > $ this -> lockWaitTimeout ) { throw new LockWaitTimeoutException ( ) ; } usleep ( $ this -> sleep ) ; } return ; } 
public function set ( $ key , $ value ) { $ this -> memcached -> set ( $ key , $ value , $ this -> ttl ) ; return ; } 
public function throttle ( $ key , $ limit , $ milliseconds ) { $ wait = $ this -> getEstimate ( $ key , $ limit , $ milliseconds ) ; if ( $ wait > 0 ) { usleep ( $ wait * 1000 ) ; } $ key = $ this -> getStorageKey ( $ key , $ limit , $ milliseconds ) ; $ this -> storage -> lock ( $ key ) ; $ count = $ this -> storage -> get ( $ key ) ; $ count ++ ; $ this -> storage -> set ( $ key , $ count ) ; $ this -> storage -> unlock ( $ key ) ; return $ wait ; } 
public function getEstimate ( $ key , $ limit , $ milliseconds ) { $ key = $ this -> getStorageKey ( $ key , $ limit , $ milliseconds ) ; $ count = $ this -> storage -> get ( $ key ) ; if ( $ count < $ limit ) { return 0 ; } return $ milliseconds - ( ( microtime ( 1 ) * 1000 ) % ( float ) $ milliseconds ) ; } 
protected function getStorageKey ( $ key , $ limit , $ milliseconds ) { $ window = $ milliseconds * ( floor ( ( microtime ( 1 ) * 1000 ) / $ milliseconds ) ) ; $ date = date ( 'YmdHis' , $ window / 1000 ) ; return $ date . '::' . $ key . '::' . $ limit . '::' . $ milliseconds . '::COUNT' ; } 
public function fetchBranches ( bool $ onlyRemote = false ) : array { $ options = $ onlyRemote ? [ 'r' => true ] : [ 'a' => true ] ; $ output = $ this -> gitWorkingCopy -> branch ( $ options ) ; $ branches = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimBranch' ] , $ branches ) ; } 
public function getLogLevelMapping ( string $ eventName ) : string { if ( ! isset ( $ this -> logLevelMappings [ $ eventName ] ) ) { throw new GitException ( sprintf ( 'Unknown event "%s"' , $ eventName ) ) ; } return $ this -> logLevelMappings [ $ eventName ] ; } 
public static function getSubscribedEvents ( ) { return [ GitEvents :: GIT_PREPARE => [ 'onPrepare' , 0 ] , GitEvents :: GIT_OUTPUT => [ 'handleOutput' , 0 ] , GitEvents :: GIT_SUCCESS => [ 'onSuccess' , 0 ] , GitEvents :: GIT_ERROR => [ 'onError' , 0 ] , GitEvents :: GIT_BYPASS => [ 'onBypass' , 0 ] , ] ; } 
public function log ( GitEvent $ gitEvent , string $ message , array $ context = [ ] , ? string $ eventName = null ) : void { 
public function start ( ? callable $ callback = null , array $ env = [ ] ) : void { $ this -> dispatchGitEvent ( GitEvents :: GIT_PREPARE ) ; if ( $ this -> gitCommand -> notBypassed ( ) ) { parent :: start ( $ callback , $ env ) ; } else { $ this -> dispatchGitEvent ( GitEvents :: GIT_BYPASS ) ; } } 
public function isCloned ( ) : bool { if ( $ this -> cloned === null ) { $ gitDir = $ this -> directory ; if ( is_dir ( $ gitDir . '/.git' ) ) { $ gitDir .= '/.git' ; } $ this -> cloned = is_dir ( $ gitDir . '/objects' ) && is_dir ( $ gitDir . '/refs' ) && is_file ( $ gitDir . '/HEAD' ) ; } return $ this -> cloned ; } 
public function run ( string $ command , array $ argsAndOptions = [ ] , bool $ setDirectory = true ) : string { $ command = new GitCommand ( $ command , ... $ argsAndOptions ) ; if ( $ setDirectory ) { $ command -> setDirectory ( $ this -> directory ) ; } return $ this -> gitWrapper -> run ( $ command ) ; } 
public function isUpToDate ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is up-to-date.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha ; } 
public function isAhead ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is ahead.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ localSha = $ this -> run ( 'rev-parse' , [ '@' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha && $ localSha !== $ remoteSha ; } 
public function pushTag ( string $ tag , string $ repository = 'origin' , array $ options = [ ] ) : string { return $ this -> push ( $ repository , 'tag' , $ tag , $ options ) ; } 
public function pushTags ( string $ repository = 'origin' , array $ options = [ ] ) : string { $ options [ 'tags' ] = true ; return $ this -> push ( $ repository , $ options ) ; } 
public function checkoutNewBranch ( string $ branch , array $ options = [ ] ) : string { $ options [ 'b' ] = true ; return $ this -> checkout ( $ branch , $ options ) ; } 
public function addRemote ( string $ name , string $ url , array $ options = [ ] ) : string { $ this -> ensureAddRemoveArgsAreValid ( $ name , $ url ) ; $ args = [ 'add' ] ; 
public function getRemoteUrl ( string $ remote , string $ operation = 'fetch' ) : string { $ argsAndOptions = [ 'get-url' , $ remote ] ; if ( $ operation === 'push' ) { $ argsAndOptions [ ] = '--push' ; } return rtrim ( $ this -> remote ( ... $ argsAndOptions ) ) ; } 
public function cloneRepository ( string $ repository , array $ options = [ ] ) : string { $ argsAndOptions = [ $ repository , $ this -> directory , $ options ] ; return $ this -> run ( 'clone' , $ argsAndOptions , false ) ; } 
public function commit ( ... $ argsAndOptions ) : string { if ( isset ( $ argsAndOptions [ 0 ] ) && is_string ( $ argsAndOptions [ 0 ] ) && ! isset ( $ argsAndOptions [ 1 ] ) ) { $ argsAndOptions [ 0 ] = [ 'm' => $ argsAndOptions [ 0 ] , 'a' => true , ] ; } return $ this -> run ( 'commit' , $ argsAndOptions ) ; } 
public function init ( array $ options = [ ] ) : string { $ argsAndOptions = [ $ this -> directory , $ options ] ; return $ this -> run ( 'init' , $ argsAndOptions , false ) ; } 
public function mv ( string $ source , string $ destination , array $ options = [ ] ) : string { $ argsAndOptions = [ $ source , $ destination , $ options ] ; return $ this -> run ( 'mv' , $ argsAndOptions ) ; } 
public function rm ( string $ filepattern , array $ options = [ ] ) : string { $ args = [ $ filepattern , $ options ] ; return $ this -> run ( 'rm' , $ args ) ; } 
public function show ( string $ object , array $ options = [ ] ) : string { $ args = [ $ object , $ options ] ; return $ this -> run ( 'show' , $ args ) ; } 
public function fetchTags ( ) : array { $ output = $ this -> gitWorkingCopy -> tag ( [ 'l' => true ] ) ; $ tags = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimTags' ] , $ tags ) ; } 
public function setPrivateKey ( string $ privateKey , int $ port = 22 , ? string $ wrapper = null ) : void { if ( $ wrapper === null ) { $ wrapper = __DIR__ . '/../bin/git-ssh-wrapper.sh' ; } if ( ! $ wrapperPath = realpath ( $ wrapper ) ) { throw new GitException ( 'Path to GIT_SSH wrapper script could not be resolved: ' . $ wrapper ) ; } if ( ! $ privateKeyPath = realpath ( $ privateKey ) ) { throw new GitException ( 'Path private key could not be resolved: ' . $ privateKey ) ; } $ this -> setEnvVar ( 'GIT_SSH' , $ wrapperPath ) ; $ this -> setEnvVar ( 'GIT_SSH_KEY' , $ privateKeyPath ) ; $ this -> setEnvVar ( 'GIT_SSH_PORT' , $ port ) ; } 
public function streamOutput ( bool $ streamOutput = true ) : void { if ( $ streamOutput && ! isset ( $ this -> gitOutputListener ) ) { $ this -> gitOutputListener = new GitOutputStreamListener ( ) ; $ this -> addOutputListener ( $ this -> gitOutputListener ) ; } if ( ! $ streamOutput && isset ( $ this -> gitOutputListener ) ) { $ this -> removeOutputListener ( $ this -> gitOutputListener ) ; unset ( $ this -> gitOutputListener ) ; } } 
public static function parseRepositoryName ( string $ repositoryUrl ) : string { $ scheme = parse_url ( $ repositoryUrl , PHP_URL_SCHEME ) ; if ( $ scheme === null ) { $ parts = explode ( '/' , $ repositoryUrl ) ; $ path = end ( $ parts ) ; } else { $ strpos = strpos ( $ repositoryUrl , ':' ) ; $ path = substr ( $ repositoryUrl , $ strpos + 1 ) ; } return basename ( $ path , '.git' ) ; } 
public function init ( string $ directory , array $ options = [ ] ) : GitWorkingCopy { $ git = $ this -> workingCopy ( $ directory ) ; $ git -> init ( $ options ) ; $ git -> setCloned ( true ) ; return $ git ; } 
public function cloneRepository ( string $ repository , ? string $ directory = null , array $ options = [ ] ) : GitWorkingCopy { if ( $ directory === null ) { $ directory = self :: parseRepositoryName ( $ repository ) ; } $ git = $ this -> workingCopy ( $ directory ) ; $ git -> cloneRepository ( $ repository , $ options ) ; $ git -> setCloned ( true ) ; return $ git ; } 
public function git ( string $ commandLine , ? string $ cwd = null ) : string { $ command = new GitCommand ( $ commandLine ) ; $ command -> executeRaw ( is_string ( $ commandLine ) ) ; $ command -> setDirectory ( $ cwd ) ; return $ this -> run ( $ command ) ; } 
public function buildOptions ( ) : array { $ options = [ ] ; foreach ( $ this -> options as $ option => $ values ) { foreach ( ( array ) $ values as $ value ) { 
public function getCommandLine ( ) { if ( $ this -> executeRaw ) { return $ this -> getCommand ( ) ; } $ command = array_merge ( [ $ this -> getCommand ( ) ] , $ this -> buildOptions ( ) , $ this -> args ) ; return array_filter ( $ command , 'strlen' ) ; } 
public function generate ( Finder $ finder ) { foreach ( $ finder as $ file ) { $ mutable = new Mutable ( $ file -> getRealpath ( ) ) ; $ this -> mutables [ ] = $ mutable ; } } 
public function locate ( $ configurationDir ) { $ conf = $ configurationDir . '/phpunit.xml' ; if ( file_exists ( $ conf ) ) { return realpath ( $ conf ) ; } if ( file_exists ( $ conf . '.dist' ) ) { return realpath ( $ conf . '.dist' ) ; } throw new RuntimeException ( 'Unable to locate phpunit.xml(.dist) file. This is required by Humbug.' ) ; } 
public function renderInitialRunFail ( TestSuiteResult $ result ) { $ error = [ ] ; $ error [ ] = 'Tests must be in a fully passing state before Humbug is run.' ; $ error [ ] = 'Incomplete, skipped or risky tests are allowed.' ; if ( $ result -> getExitCode ( ) !== 0 ) { $ error [ ] = 'The testing framework reported an exit code of ' . $ result -> getExitCode ( ) . '.' ; } if ( $ result -> hasFailure ( ) ) { $ error [ ] = 'The testing framework ran into a failure or error. Refer to output below.' ; } if ( $ result -> hasStdOut ( ) ) { $ error [ ] = 'Stdout:' ; $ error = array_merge ( $ error , $ this -> indent ( $ this -> extractFail ( $ result -> getStdOut ( ) ) , true ) ) ; } if ( $ result -> hasStdErr ( ) ) { $ error [ ] = 'Stderr:' ; $ error = array_merge ( $ error , $ this -> indent ( $ result -> getStdErr ( ) , true ) ) ; } foreach ( $ error as $ err ) { $ this -> write ( '<fg=red>' . $ err . '</fg=red>' ) ; } } 
public function renderInitialRunPass ( TestSuiteResult $ result , $ testCount = null ) { $ this -> write ( 'Humbug has completed the initial test run successfully.' ) ; if ( ! is_null ( $ testCount ) ) { $ this -> write ( 'Tests: <fg=cyan>' . $ testCount . '</fg=cyan> ' . 'Line Coverage: <fg=cyan>' . sprintf ( '%3.2f%%' , $ result -> getLineCoverage ( ) ) . '</fg=cyan>' ) ; } } 
public function renderProgressMark ( MutantResult $ result , $ count , $ current , $ eolInterval = 60 ) { $ this -> progressCount ++ ; switch ( $ result -> getResult ( ) ) { case MutantResult :: TIMEOUT : $ this -> write ( '<fg=cyan;options=bold>T</fg=cyan;options=bold>' , false ) ; break ; case MutantResult :: ERROR : $ this -> write ( '<fg=yellow;options=bold>E</fg=yellow;options=bold>' , false ) ; break ; case MutantResult :: ESCAPE : $ this -> write ( '<fg=red;options=bold>M</fg=red;options=bold>' , false ) ; break ; case MutantResult :: KILL : default : $ this -> write ( '<options=bold>.</options=bold>' , false ) ; break ; } if ( ( $ this -> progressCount % $ eolInterval ) == 0 ) { $ counter = str_pad ( $ this -> progressCount , 5 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( ' |' . $ counter . ' (' . str_pad ( $ current , strlen ( $ count ) , ' ' , STR_PAD_LEFT ) . '/' . $ count . ')' . PHP_EOL , false ) ; } } 
public function renderShadowMark ( $ count , $ current , $ eolInterval = 60 ) { $ this -> progressCount ++ ; $ this -> write ( '<fg=blue;options=bold>S</fg=blue;options=bold>' , false ) ; if ( ( $ this -> progressCount % $ eolInterval ) == 0 ) { $ counter = str_pad ( $ this -> progressCount , 5 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( ' |' . $ counter . ' (' . str_pad ( $ current , strlen ( $ count ) , ' ' , STR_PAD_LEFT ) . '/' . $ count . ')' . PHP_EOL , false ) ; } } 
public function renderSummaryReport ( Collector $ collector ) { $ pkills = str_pad ( $ collector -> getKilledCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ pescapes = str_pad ( $ collector -> getEscapeCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ perrors = str_pad ( $ collector -> getErrorCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ ptimeouts = str_pad ( $ collector -> getTimeoutCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ pshadows = str_pad ( $ collector -> getShadowCount ( ) , 8 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( PHP_EOL , false ) ; $ this -> write ( $ collector -> getTotalCount ( ) . ' mutations were generated:' ) ; $ this -> write ( $ pkills . ' mutants were killed' ) ; $ this -> write ( $ pshadows . ' mutants were not covered by tests' ) ; $ this -> write ( $ pescapes . ' covered mutants were not detected' ) ; $ this -> write ( $ perrors . ' fatal errors were encountered' ) ; $ this -> write ( $ ptimeouts . ' time outs were encountered' ) ; $ this -> write ( PHP_EOL , false ) ; $ vanquishedTotal = $ collector -> getVanquishedTotal ( ) ; $ measurableTotal = $ collector -> getMeasurableTotal ( ) ; if ( $ measurableTotal !== 0 ) { $ detectionRateTested = round ( 100 * ( $ vanquishedTotal / $ measurableTotal ) ) ; } else { $ detectionRateTested = 0 ; } if ( $ collector -> getTotalCount ( ) !== 0 ) { $ coveredRate = round ( 100 * ( ( $ measurableTotal ) / $ collector -> getTotalCount ( ) ) ) ; $ detectionRateAll = round ( 100 * ( $ vanquishedTotal / $ collector -> getTotalCount ( ) ) ) ; } else { $ coveredRate = 0 ; $ detectionRateAll = 0 ; } $ this -> write ( 'Metrics:' ) ; $ this -> write ( ' Mutation Score Indicator (MSI): <options=bold>' . $ detectionRateAll . '%</options=bold>' ) ; $ this -> write ( ' Mutation Code Coverage: <options=bold>' . $ coveredRate . '%</options=bold>' ) ; $ this -> write ( ' Covered Code MSI: <options=bold>' . $ detectionRateTested . '%</options=bold>' ) ; $ this -> write ( PHP_EOL , false ) ; $ this -> write ( 'Remember that some mutants will inevitably be harmless (i.e. false positives).' ) ; } 
private function indent ( $ output , $ asArray = false ) { $ lines = explode ( "\n" , $ output ) ; $ out = [ ] ; foreach ( $ lines as $ line ) { $ out [ ] = ' > ' . $ line ; } if ( $ asArray ) { return $ out ; } $ return = implode ( "\n" , $ out ) ; return $ return ; } 
private function extractFail ( $ output ) { if ( preg_match ( '%##teamcity\[testFailed.*\]%' , $ output , $ matches ) ) { preg_match ( "/##teamcity\\[testFailed.*name='(.*)' message='(.*)' details='\\s*(.*)' flowId=.*/" , $ output , $ matches ) ; $ matches = $ this -> replaceEscapedChars ( $ matches ) ; $ fail = sprintf ( 'Test Name: %s' . PHP_EOL . 'Failure Message: %s' . PHP_EOL . 'Trace:' . PHP_EOL . '%s' , $ matches [ 1 ] , $ matches [ 2 ] , $ matches [ 3 ] ) ; return $ fail ; } return 'No failure output was detected by Humbug, but a failure was reported by PHPUnit.' ; } 
public static function mutates ( array & $ tokens , $ index ) { $ t = $ tokens [ $ index ] ; if ( ! is_array ( $ t ) && $ t == '+' ) { $ tokenCount = count ( $ tokens ) ; for ( $ i = $ index + 1 ; $ i < $ tokenCount ; $ i ++ ) { 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( PHP_SAPI !== 'phpdbg' && ! defined ( 'HHVM_VERSION' ) && ! extension_loaded ( 'xdebug' ) ) { $ output -> writeln ( '<error>You need to install and enable xdebug, or use phpdbg, ' . 'in order to allow for code coverage generation.</error>' ) ; return 1 ; } Performance :: upMemProfiler ( ) ; $ this -> validate ( $ input ) ; $ container = $ this -> container = new Container ( $ input -> getOptions ( ) ) ; $ this -> doConfiguration ( $ input ) ; if ( $ this -> isLoggingEnabled ( ) ) { $ this -> removeOldLogFiles ( ) ; } else { $ output -> writeln ( '<error>No log file is specified. Detailed results ' . 'will not be available.</error>' ) ; $ output -> write ( PHP_EOL ) ; } if ( $ input -> getOption ( 'incremental' ) ) { $ output -> writeln ( '<error>Incremental Analysis is an experimental feature and will very likely</error>' ) ; $ output -> writeln ( '<error>yield inaccurate results at this time.</error>' ) ; $ output -> write ( PHP_EOL ) ; } if ( $ this -> textLogFile ) { $ renderer = new Text ( $ output , true ) ; } else { $ renderer = new Text ( $ output ) ; } $ testSuiteRunner = new UnitTestRunner ( $ container -> getAdapter ( ) , $ container -> getAdapter ( ) -> getProcess ( $ container , true ) , $ container -> getTempDirectory ( ) . '/coverage.humbug.txt' ) ; $ testSuiteRunner -> addObserver ( new LoggingObserver ( $ renderer , $ output , new ProgressBarObserver ( $ input , $ output ) ) ) ; $ result = $ testSuiteRunner -> run ( $ container ) ; if ( ! $ result -> isSuccess ( ) ) { return 1 ; } $ output -> write ( PHP_EOL ) ; $ renderer -> renderStaticAnalysisStart ( ) ; $ output -> write ( PHP_EOL ) ; $ incrementalCache = null ; if ( $ input -> getOption ( 'incremental' ) ) { $ incrementalCache = new IncrementalCache ( $ container ) ; } $ mutationTestingRunner = $ this -> builder -> build ( $ container , $ renderer , $ input , $ output ) ; $ mutationTestingRunner -> run ( $ result -> getCoverage ( ) , $ this -> mutableIterator , $ incrementalCache ) ; if ( $ this -> isLoggingEnabled ( ) ) { $ output -> write ( PHP_EOL ) ; } if ( $ input -> getOption ( 'incremental' ) ) { $ incrementalCache -> write ( ) ; } } 
public static function getMutation ( array & $ tokens , $ index ) { $ tokenCount = count ( $ tokens ) ; for ( $ i = $ index + 1 ; $ i < $ tokenCount ; $ i ++ ) { if ( is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == T_WHITESPACE ) { continue ; } elseif ( is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == T_LNUMBER ) { 
private function createConfiguration ( $ sourcesDirs , $ excludeDirs , $ chDir , $ timeout , $ textLogFile , $ jsonLogFile ) { $ source = new \ stdClass ( ) ; $ source -> directories = $ sourcesDirs ; if ( ! empty ( $ excludeDirs ) ) { $ source -> excludes = $ excludeDirs ; } $ configuration = new \ stdClass ( ) ; $ configuration -> source = $ source ; if ( $ chDir ) { $ configuration -> chdir = $ chDir ; } if ( $ timeout ) { $ configuration -> timeout = $ timeout ; } $ logs = $ this -> prepareLogs ( $ textLogFile , $ jsonLogFile ) ; if ( $ logs ) { $ configuration -> logs = $ logs ; } return $ configuration ; } 
private function resolveChDir ( InputInterface $ input , OutputInterface $ output ) { $ configurationLocator = new ConfigurationLocator ( ) ; try { $ configurationLocator -> locate ( '.' ) ; return null ; } catch ( \ RuntimeException $ e ) { $ output -> writeln ( $ e -> getMessage ( ) ) ; $ frameworkConfigurationQuestion = $ this -> createFrameworkConfigurationQuestion ( $ configurationLocator ) ; $ chDir = $ this -> getQuestionHelper ( ) -> ask ( $ input , $ output , $ frameworkConfigurationQuestion ) ; if ( ! $ chDir ) { throw new RuntimeException ( 'Could not create "humbug.json.dist". Cannot locate phpunit.xml(.dist) file.' ) ; } return $ chDir ; } } 
public static function getMutation ( array & $ tokens , $ index ) { $ num = ( integer ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1 ; } elseif ( $ num == 1 ) { $ replace = 0 ; } else { $ replace = $ num + 1 ; } $ tokens [ $ index ] = [ T_LNUMBER , ( string ) $ replace ] ; } 
public static function getTokens ( & $ source ) { $ newline = 0 ; $ tokens = token_get_all ( $ source ) ; $ ntokens = [ ] ; foreach ( $ tokens as $ token ) { $ tname = is_array ( $ token ) ? $ token [ 0 ] : null ; $ tdata = is_array ( $ token ) ? $ token [ 1 ] : $ token ; $ split = preg_split ( "%(\r\n|\n)%" , $ tdata , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; if ( $ tname == T_CONSTANT_ENCAPSED_STRING || substr ( $ tdata , 0 , 2 ) == '/*' ) { $ ntokens [ ] = [ $ tname , $ tdata ] ; foreach ( $ split as $ value ) { if ( $ value == "\r\n" || $ value == "\n" ) { $ newline ++ ; } } continue ; } foreach ( $ split as $ data ) { if ( $ data == "\r\n" || $ data == "\n" ) { $ newline ++ ; $ ntokens [ ] = [ self :: T_NEWLINE , $ data , $ newline ] ; } else { $ ntokens [ ] = is_array ( $ token ) ? [ $ tname , $ data ] : $ data ; } } } return $ ntokens ; } 
public static function reconstructFromTokens ( array & $ tokens ) { $ str = '' ; foreach ( $ tokens as $ token ) { if ( is_string ( $ token ) ) { $ str .= $ token ; } else { $ str .= $ token [ 1 ] ; } } return $ str ; } 
public function generate ( ) { $ source = file_get_contents ( $ this -> getFilename ( ) ) ; $ tokens = Tokenizer :: getTokens ( $ source ) ; $ lineNumber = 1 ; $ methodName = '???' ; $ className = '???' ; $ namespace = '' ; $ inMethod = false ; $ inMethodBlock = false ; $ methodCurlyCount = 0 ; $ tokenCount = count ( $ tokens ) ; foreach ( $ tokens as $ index => $ token ) { if ( is_array ( $ token ) && $ token [ 0 ] == Tokenizer :: T_NEWLINE ) { $ lineNumber = $ token [ 2 ] + 1 ; continue ; } if ( is_array ( $ token ) && $ token [ 0 ] == T_NAMESPACE ) { for ( $ j = $ index + 1 ; $ j < $ tokenCount ; $ j ++ ) { if ( $ tokens [ $ j ] [ 0 ] == T_STRING ) { $ namespace .= '\\' . $ tokens [ $ j ] [ 1 ] ; } elseif ( $ tokens [ $ j ] == '{' || $ tokens [ $ j ] == ';' ) { break ; } } continue ; } if ( is_array ( $ token ) && ( $ token [ 0 ] == T_CLASS || $ token [ 0 ] == T_INTERFACE || $ token [ 0 ] == T_TRAIT ) && $ tokens [ $ index - 1 ] [ 0 ] !== T_DOUBLE_COLON ) { $ className = $ namespace . '\\' . $ tokens [ $ index + 2 ] [ 1 ] ; continue ; } * Limit mutation generation to the interior of methods (for now!) */ if ( true === $ inMethod && false === $ inMethodBlock && $ methodCurlyCount == 0 && ! ( $ token == '{' || ( is_array ( $ token ) && $ token [ 0 ] == T_CURLY_OPEN ) ) ) { continue ; 
public static function getMutation ( array & $ tokens , $ index ) { $ tokenCount = count ( $ tokens ) ; for ( $ i = $ index + 1 ; $ i < $ tokenCount ; $ i ++ ) { if ( is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == T_WHITESPACE ) { continue ; } elseif ( is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == T_VARIABLE && $ tokens [ $ i ] [ 1 ] == '$this' ) { $ tokens [ $ i ] = [ T_STRING , 'null' ] ; break ; } } } 
public static function getMutation ( array & $ tokens , $ index ) { $ replace = [ ] ; $ last = null ; $ tokenCount = count ( $ tokens ) ; for ( $ i = $ index + 1 ; $ i < $ tokenCount ; $ i ++ ) { if ( is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == T_WHITESPACE ) { continue ; } elseif ( ! is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] == '(' ) { 
public static function getMutation ( array & $ tokens , $ index ) { $ num = ( float ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1.0 ; } elseif ( $ num == 1 ) { $ replace = 0.0 ; } elseif ( $ num < 2 ) { $ replace = $ num + 1 ; } else { $ replace = 1.0 ; } $ tokens [ $ index ] = [ T_DNUMBER , sprintf ( "%.2f" , $ replace ) ] ; } 
public function hasOks ( $ output ) { $ result = preg_match_all ( "%##teamcity\[testFinished%" , $ output ) ; if ( $ result ) { $ this -> okCount += $ result ; return $ this -> okCount ; } return false ; } 
public function addEnvironmentVariable ( $ name , $ value ) { $ phpNodeList = $ this -> xpath -> query ( '/phpunit/php' ) ; if ( $ phpNodeList -> length ) { $ phpNode = $ phpNodeList -> item ( 0 ) ; } else { $ phpNode = $ this -> dom -> createElement ( 'php' ) ; $ this -> rootElement -> appendChild ( $ phpNode ) ; } $ env = $ this -> dom -> createElement ( 'env' ) ; $ phpNode -> appendChild ( $ env ) ; $ env -> setAttribute ( 'name' , $ name ) ; $ env -> setAttribute ( 'value' , $ value ) ; } 
public function get ( $ option ) { if ( ! array_key_exists ( $ option , $ this -> inputOptions ) ) { throw new \ InvalidArgumentException ( 'Option "' . $ option . ' not exists' ) ; } return $ this -> inputOptions [ $ option ] ; } 
public function getCacheDirectory ( ) { if ( ! is_null ( $ this -> cacheDirectory ) ) { return $ this -> cacheDirectory ; } if ( defined ( 'PHP_WINDOWS_VERSION_MAJOR' ) ) { if ( ! getenv ( 'APPDATA' ) ) { throw new RuntimeException ( 'The APPDATA environment variable must be set for humbug.' ) ; } $ home = strtr ( getenv ( 'APPDATA' ) , '\\' , '/' ) . '/Humbug' ; } else { if ( ! getenv ( 'HOME' ) ) { throw new RuntimeException ( 'The HOME environment variable must be set for humbug.' ) ; } $ home = rtrim ( getenv ( 'HOME' ) , '/' ) . '/.humbug' ; } $ cache = $ home . '/cache' ; foreach ( [ $ home , $ cache ] as $ dir ) { if ( ! is_dir ( $ dir ) ) { mkdir ( $ dir , 0777 ) ; } } file_put_contents ( $ home . '/.htaccess' , 'Deny from all' ) ; $ this -> cacheDirectory = $ cache ; return $ cache ; } 
public function setTempDirectory ( $ dir ) { $ dir = rtrim ( $ dir , ' \\/' ) ; if ( ! is_dir ( $ dir ) || ! is_readable ( $ dir ) ) { throw new InvalidArgumentException ( 'Invalid cache directory: "' . $ dir . '"' ) ; } $ this -> tempDirectory = $ dir ; return $ this ; } 
public function getTempDirectory ( ) { if ( is_null ( $ this -> tempDirectory ) ) { $ root = sys_get_temp_dir ( ) ; if ( ! is_dir ( $ root . '/humbug' ) ) { mkdir ( $ root . '/humbug' , 0777 , true ) ; } $ this -> tempDirectory = $ root . '/humbug' ; } return $ this -> tempDirectory ; } 
public function setAdapterOptionsFromString ( $ optionString ) { $ this -> adapterOptions = array_merge ( $ this -> adapterOptions , explode ( ' ' , $ optionString ) ) ; return $ this ; } 
public function getAdapter ( ) { if ( is_null ( $ this -> adapter ) ) { $ name = ucfirst ( strtolower ( $ this -> get ( 'adapter' ) ) ) ; $ class = '\\Humbug\\Adapter\\' . $ name ; $ this -> adapter = new $ class ; } return $ this -> adapter ; } 
public function getMutableFiles ( Finder $ finder ) { if ( empty ( $ this -> mutables ) ) { $ generator = $ this -> getGenerator ( ) ; $ generator -> generate ( $ finder ) ; $ this -> mutables = $ generator -> getMutables ( ) ; } return $ this -> mutables ; } 
public function toArray ( ) { return [ 'file' => $ this -> getMutationFileRelativePath ( ) , 'mutator' => $ this -> mutation -> getMutator ( ) , 'class' => $ this -> mutation -> getClass ( ) , 'method' => $ this -> mutation -> getMethod ( ) , 'line' => $ this -> mutation -> getLine ( ) , 'diff' => $ this -> getDiff ( ) , 'tests' => $ this -> testMethods ] ; } 
public static function generate ( $ mutantFile = null , $ bootstrap = '' , $ replacingFile = null ) { $ loadHumbug = '' ; if ( 'phar:' === substr ( __FILE__ , 0 , 5 ) ) { $ loadHumbug = '\Phar::loadPhar(\'' . str_replace ( 'phar: <?php {$loadHumbug} require_once '{$humbugBootstrap}'; use Humbug\StreamWrapper\IncludeInterceptor; IncludeInterceptor::intercept('{$replacingFile}', '{$mutantFile}'); IncludeInterceptor::enable(); PREPEND ; if ( ! empty ( $ bootstrap ) ) { $ buffer = $ prepend . "\nrequire_once '{$bootstrap}';" ; } else { $ buffer = $ prepend ; } file_put_contents ( $ file , $ buffer ) ; } else { if ( ! empty ( $ bootstrap ) ) { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';\nrequire_once '{$bootstrap}';" ; } else { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';" ; } file_put_contents ( $ file , $ buffer ) ; } } 
protected static function getNextToken ( array & $ tokens , $ index , array $ excludeTokens = [ ] ) { $ tokenCount = count ( $ tokens ) ; while ( $ index < $ tokenCount && isset ( $ tokens [ $ index + 1 ] ) && self :: shouldSkip ( $ tokens [ $ index + 1 ] , $ excludeTokens ) ) { $ index ++ ; } if ( ! isset ( $ tokens [ $ index + 1 ] ) ) { return false ; } return is_array ( $ tokens [ $ index + 1 ] ) ? $ tokens [ $ index + 1 ] [ 0 ] : $ tokens [ $ index + 1 ] ; } 
protected static function getPreviousToken ( array & $ tokens , $ index , array $ excludeTokens = [ ] ) { while ( $ index > 0 && isset ( $ tokens [ $ index - 1 ] ) && self :: shouldSkip ( $ tokens [ $ index - 1 ] , $ excludeTokens ) ) { $ index -- ; } if ( ! isset ( $ tokens [ $ index - 1 ] ) ) { return false ; } return is_array ( $ tokens [ $ index - 1 ] ) ? $ tokens [ $ index - 1 ] [ 0 ] : $ tokens [ $ index - 1 ] ; } 
public function run ( Process $ process , AdapterAbstract $ testFrameworkAdapter , \ Closure $ onProgressCallback = null ) { $ hasFailure = false ; $ process -> run ( function ( $ out , $ data ) use ( $ process , $ testFrameworkAdapter , $ onProgressCallback , & $ hasFailure ) { if ( $ out == Process :: ERR ) { $ hasFailure = true ; } if ( ! $ testFrameworkAdapter -> ok ( $ data ) ) { $ hasFailure = true ; } $ oksCount = $ testFrameworkAdapter -> hasOks ( $ data ) ; if ( $ oksCount !== false && $ onProgressCallback ) { $ onProgressCallback ( $ oksCount ) ; } } ) ; $ process -> stop ( ) ; return $ hasFailure ; } 
public static function getMutation ( array & $ tokens , $ index ) { $ tokenCount = count ( $ tokens ) ; for ( $ i = $ index + 1 ; $ i < $ tokenCount ; $ i ++ ) { if ( is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == T_WHITESPACE ) { continue ; } elseif ( is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == T_DNUMBER ) { 
public function getProcess ( Container $ container , $ firstRun = false , $ interceptFile = null , $ mutantFile = null , array $ testSuites = [ ] ) { $ jobopts = [ 'testdir' => $ container -> getTestRunDirectory ( ) , 'basedir' => $ container -> getBaseDirectory ( ) , 'timeout' => $ container -> getTimeout ( ) , 'cachedir' => $ container -> getTempDirectory ( ) , 'command' => $ container -> getAdapterOptions ( ) , 'constraints' => $ container -> getAdapterConstraints ( ) ] ; array_unshift ( $ jobopts [ 'command' ] , '--teamcity' ) ; if ( ! in_array ( '--stop-on-failure' , $ jobopts [ 'command' ] ) ) { array_unshift ( $ jobopts [ 'command' ] , '--stop-on-failure' ) ; } $ xmlConfiguration = $ this -> assembleXmlConfiguration ( $ container , $ firstRun , $ testSuites ) ; $ configFile = $ container -> getTempDirectory ( ) . '/phpunit.humbug.xml' ; file_put_contents ( $ configFile , $ xmlConfiguration -> generateXML ( ) ) ; foreach ( $ jobopts [ 'command' ] as $ key => $ value ) { if ( $ value == '--configuration' || $ value == '-C' ) { unset ( $ jobopts [ 'command' ] [ $ key ] ) ; unset ( $ jobopts [ 'command' ] [ $ key + 1 ] ) ; } elseif ( preg_match ( '%\\-\\-configuration=%' , $ value ) ) { unset ( $ jobopts [ 'command' ] [ $ key ] ) ; } } array_unshift ( $ jobopts [ 'command' ] , '--configuration=' . $ configFile ) ; $ phpunitFinder = new PhpunitExecutableFinder ; $ command = $ phpunitFinder -> find ( ) ; array_unshift ( $ jobopts [ 'command' ] , $ command ) ; $ timeout = 0 ; if ( $ firstRun ) { $ jobopts [ 'command' ] = array_merge ( $ jobopts [ 'command' ] , explode ( ' ' , $ jobopts [ 'constraints' ] ) ) ; } else { $ timeout = $ container -> getTimeout ( ) ; } Job :: generate ( $ mutantFile , $ container -> getBootstrap ( ) , $ interceptFile ) ; $ process = new Process ( implode ( ' ' , $ jobopts [ 'command' ] ) , $ jobopts [ 'testdir' ] , array_replace ( $ _ENV , $ _SERVER ) ) ; $ process -> setTimeout ( $ timeout ) ; return $ process ; } 
private function assembleXmlConfiguration ( Container $ container , $ firstRun = false , array $ testSuites = [ ] ) { $ configurationDir = $ this -> resolveConfigurationDir ( $ container ) ; $ xmlConfigurationBuilder = new XmlConfigurationBuilder ( $ configurationDir ) ; if ( $ firstRun ) { $ xmlConfigurationBuilder -> setPhpCoverage ( $ container -> getTempDirectory ( ) . '/coverage.humbug.php' ) ; $ xmlConfigurationBuilder -> setTextCoverage ( $ container -> getTempDirectory ( ) . '/coverage.humbug.txt' ) ; $ xmlConfigurationBuilder -> setJunitLog ( $ container -> getTempDirectory ( ) . '/junit.humbug.xml' ) ; $ whiteListSrc = $ this -> getWhiteListSrc ( $ container ) ; $ excludeDirs = $ this -> getExcludeDirs ( $ container ) ; $ xmlConfigurationBuilder -> setCoverageFilter ( $ whiteListSrc , $ excludeDirs ) ; $ xmlConfigurationBuilder -> setTimeCollectionListener ( $ this -> getPathToTimeCollectorFile ( $ container ) ) ; } else { $ xmlConfigurationBuilder -> setFilterListener ( $ testSuites , $ this -> getPathToTimeCollectorFile ( $ container ) ) ; } $ xmlConfigurationBuilder -> setAcceleratorListener ( ) ; $ xmlConfiguration = $ xmlConfigurationBuilder -> getConfiguration ( ) ; if ( $ xmlConfiguration -> hasOriginalBootstrap ( ) ) { $ container -> setBootstrap ( $ xmlConfiguration -> getOriginalBootstrap ( ) ) ; } return $ xmlConfiguration ; } 
public static function generateMethod ( MethodReflection $ originalMethod , Bean $ beanMetadata , ? ReflectionType $ beanType , ForceLazyInitProperty $ forceLazyInitProperty , SessionBeansProperty $ sessionBeansProperty , BeanPostProcessorsProperty $ postProcessorsProperty , BeanFactoryConfigurationProperty $ beanFactoryConfigurationProperty , GetParameter $ parameterValuesMethod , WrapBeanAsLazy $ wrapBeanAsLazy ) : MethodGenerator { if ( null === $ beanType ) { throw new InvalidProxiedClassException ( sprintf ( 'Method "%s" on "%s" is missing the return type hint!' , $ originalMethod -> name , $ originalMethod -> class ) ) ; } $ beanType = ( string ) $ beanType ; $ method = static :: fromReflection ( $ originalMethod ) ; $ methodParams = static :: convertMethodParamsToString ( $ beanMetadata -> getParameters ( ) , $ parameterValuesMethod ) ; $ beanId = $ originalMethod -> name ; $ body = '' ; if ( in_array ( $ beanType , [ 'array' , 'callable' , 'bool' , 'float' , 'int' , 'string' ] , true ) ) { 
public static function fromReflection ( MethodReflection $ reflectionMethod ) : MethodGenerator { $ method = parent :: fromReflection ( $ reflectionMethod ) ; $ method -> setParameters ( [ ] ) ; foreach ( $ reflectionMethod -> getParameters ( ) as $ reflectionParameter ) { $ parameter = ParameterGenerator :: fromReflection ( $ reflectionParameter ) ; $ parameter -> setDefaultValue ( null ) ; $ method -> setParameter ( $ parameter ) ; } return $ method ; } 
protected static function generateLazyBeanCode ( string $ padding , string $ beanId , string $ beanType , Bean $ beanMetadata , string $ methodParams , ForceLazyInitProperty $ forceLazyInitProperty , SessionBeansProperty $ sessionBeansProperty , BeanPostProcessorsProperty $ postProcessorsProperty , BeanFactoryConfigurationProperty $ beanFactoryConfigurationProperty ) : string { $ content = '' ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . 'if($this->' . $ sessionBeansProperty -> getName ( ) . '->has("' . $ beanId . '")) {' . PHP_EOL ; if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . ' $sessionInstance = clone $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } else { $ content .= $ padding . ' $sessionInstance = $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } $ content .= $ padding . ' return $sessionInstance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . 'static $instance = null;' . PHP_EOL ; $ content .= $ padding . 'if ($instance !== null) {' . PHP_EOL ; $ content .= $ padding . ' return $instance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } $ content .= $ padding . '$factory = new \\' . LazyBeanFactory :: class . '("' . $ beanId . '", $this->' . $ beanFactoryConfigurationProperty -> getName ( ) . '->getProxyManagerConfiguration());' . PHP_EOL ; $ content .= $ padding . '$initializer = function (&$instance, \\' . LazyLoadingInterface :: class . ' $proxy, $method, array $parameters, &$initializer) {' . PHP_EOL ; $ content .= $ padding . ' try {' . PHP_EOL ; $ content .= $ padding . ' $initializer = null;' . PHP_EOL ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . ' $backupForceLazyInit = $this->' . $ forceLazyInitProperty -> getName ( ) . ';' . PHP_EOL ; $ content .= $ padding . ' $this->' . $ forceLazyInitProperty -> getName ( ) . ' = true;' . PHP_EOL ; } $ content .= $ padding . self :: generateBeanCreationCode ( $ padding . ' ' , $ beanId , $ methodParams , $ postProcessorsProperty ) ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . ' $this->' . $ forceLazyInitProperty -> getName ( ) . ' = $backupForceLazyInit;' . PHP_EOL ; } $ content .= $ padding . ' } catch (\Throwable $e) {' . PHP_EOL ; $ content .= $ padding . ' $message = sprintf(' . PHP_EOL ; $ content .= $ padding . ' \'Either return type declaration missing or unknown for bean with id "' . $ beanId . '": %s\',' . PHP_EOL ; $ content .= $ padding . ' $e->getMessage()' . PHP_EOL ; $ content .= $ padding . ' );' . PHP_EOL ; $ content .= $ padding . ' throw new \\' . BeanException :: class . '($message, 0, $e);' . PHP_EOL ; $ content .= $ padding . ' }' . PHP_EOL ; $ content .= $ padding . ' return true;' . PHP_EOL ; $ content .= $ padding . '};' . PHP_EOL ; $ content .= $ padding . PHP_EOL ; $ content .= $ padding . '$initializer->bindTo($this);' . PHP_EOL ; $ content .= $ padding . '$instance = $factory->createProxy("' . $ beanType . '", $initializer);' . PHP_EOL ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ sessionBeansProperty -> getName ( ) . '->add("' . $ beanId . '", $instance);' . PHP_EOL ; } $ content .= $ padding . 'return $instance;' . PHP_EOL ; return $ content ; } 
protected static function generateBeanCreationCode ( string $ padding , string $ beanId , string $ methodParams , BeanPostProcessorsProperty $ postProcessorsProperty ) : string { $ content = $ padding . '$instance = parent::' . $ beanId . '(' . $ methodParams . ');' . PHP_EOL ; $ content .= $ padding . 'if ($instance instanceof \\' . InitializedBean :: class . ') { ' . PHP_EOL ; $ content .= $ padding . ' $instance->postInitialization();' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; $ content .= PHP_EOL ; $ content .= $ padding . 'foreach ($this->' . $ postProcessorsProperty -> getName ( ) . ' as $postProcessor) { ' . PHP_EOL ; $ content .= $ padding . ' $postProcessor->postProcess($instance, "' . $ beanId . '");' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; return $ content ; } 
protected static function generateNonLazyBeanCode ( string $ padding , string $ beanId , string $ beanType , Bean $ beanMetadata , string $ methodParams , ForceLazyInitProperty $ forceLazyInitProperty , SessionBeansProperty $ sessionBeansProperty , BeanPostProcessorsProperty $ postProcessorsProperty , WrapBeanAsLazy $ wrapBeanAsLazy ) : string { $ content = $ padding . '$backupForceLazyInit = $this->' . $ forceLazyInitProperty -> getName ( ) . ';' . PHP_EOL ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . 'if($this->' . $ sessionBeansProperty -> getName ( ) . '->has("' . $ beanId . '")) {' . PHP_EOL ; if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . ' $sessionInstance = clone $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } else { $ content .= $ padding . ' $sessionInstance = $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $sessionInstance) : $sessionInstance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . 'static $instance = null;' . PHP_EOL ; $ content .= $ padding . 'if ($instance !== null) {' . PHP_EOL ; $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = true;' . PHP_EOL ; } $ content .= self :: generateBeanCreationCode ( $ padding , $ beanId , $ methodParams , $ postProcessorsProperty ) ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = $backupForceLazyInit;' . PHP_EOL ; $ content .= $ padding . '$this->' . $ sessionBeansProperty -> getName ( ) . '->add("' . $ beanId . '", $instance);' . PHP_EOL ; } $ content .= $ padding . 'return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; return $ content ; } 
public static function parseBooleanValue ( $ value ) : bool { if ( \ is_bool ( $ value ) ) { return $ value ; } if ( \ is_string ( $ value ) ) { $ value = \ strtolower ( $ value ) ; return 'true' === $ value ; } if ( \ is_object ( $ value ) || \ is_array ( $ value ) || \ is_callable ( $ value ) ) { return false ; } 
public function get ( string $ beanId ) { if ( ! isset ( $ this -> beans [ $ beanId ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Bean "%s" not defined in store!' , $ beanId ) ) ; } return $ this -> beans [ $ beanId ] ; } 
public static function generateMethod ( MethodReflection $ originalMethod , BeanPostProcessor $ beanPostProcessorMetadata , GetParameter $ parameterValuesMethod ) : MethodGenerator { $ method = static :: fromReflection ( $ originalMethod ) ; $ methodParams = static :: convertMethodParamsToString ( $ beanPostProcessorMetadata -> getParameters ( ) , $ parameterValuesMethod ) ; $ beanId = $ originalMethod -> name ; $ body = 'return parent::' . $ beanId . '(' . $ methodParams . ');' . PHP_EOL ; $ method -> setBody ( $ body ) ; $ method -> setDocBlock ( '{@inheritDoc}' ) ; return $ method ; } 
public function get ( $ id ) { if ( ! is_string ( $ id ) || empty ( $ id ) ) { throw new BeanException ( 'Id must be a non-empty string.' ) ; } $ instance = null ; try { if ( is_callable ( [ $ this -> beanConfig , $ id ] ) ) { $ instance = $ this -> beanConfig -> $ id ( ) ; } elseif ( $ this -> beanConfig -> hasAlias ( $ id ) ) { $ instance = $ this -> beanConfig -> getAlias ( $ id ) ; } } catch ( \ Throwable $ e ) { $ message = sprintf ( 'Exception occurred while instantiating "%s": %s' , $ id , $ e -> getMessage ( ) ) ; throw new BeanException ( $ message , $ e -> getCode ( ) , $ e ) ; } if ( null === $ instance ) { throw new BeanNotFoundException ( sprintf ( '"%s" is not defined!' , $ id ) ) ; } return $ instance ; } 
public function has ( $ id ) { if ( ! is_string ( $ id ) || empty ( $ id ) ) { return false ; } return is_callable ( [ $ this -> beanConfig , $ id ] ) || $ this -> beanConfig -> hasAlias ( $ id ) ; } 
public function setProxyTargetDir ( string $ proxyTargetDir ) : void { if ( ! is_dir ( $ proxyTargetDir ) ) { throw new InvalidArgumentException ( sprintf ( 'Proxy target directory "%s" does not exist!' , $ proxyTargetDir ) , 10 ) ; } if ( ! is_writable ( $ proxyTargetDir ) ) { throw new InvalidArgumentException ( sprintf ( 'Proxy target directory "%s" is not writable!' , $ proxyTargetDir ) , 20 ) ; } $ this -> proxyTargetDir = $ proxyTargetDir ; } 
public function setProxyAutoloader ( AutoloaderInterface $ autoloader ) : void { if ( $ this -> proxyAutoloader instanceof AutoloaderInterface ) { spl_autoload_unregister ( $ this -> proxyAutoloader ) ; } $ this -> proxyAutoloader = $ autoloader ; spl_autoload_register ( $ this -> proxyAutoloader ) ; } 
public function getProxyManagerConfiguration ( ) : Configuration { $ proxyManagerConfiguration = new Configuration ( ) ; $ proxyManagerConfiguration -> setProxiesTargetDir ( $ this -> proxyTargetDir ) ; if ( $ this -> proxyWriterGenerator instanceof GeneratorStrategyInterface ) { $ proxyManagerConfiguration -> setGeneratorStrategy ( $ this -> proxyWriterGenerator ) ; } if ( $ this -> proxyAutoloader instanceof AutoloaderInterface ) { $ proxyManagerConfiguration -> setProxyAutoloader ( $ this -> proxyAutoloader ) ; } return $ proxyManagerConfiguration ; } 
public function createProxy ( string $ className , Closure $ initializer ) : object { $ proxyClassName = $ this -> generateProxy ( $ className ) ; return new $ proxyClassName ( $ this -> beanId , $ initializer ) ; } 
public function createInstance ( BeanFactoryConfiguration $ config , string $ configClassName , array $ parameters = [ ] ) : AliasContainerInterface { $ proxyClassName = $ this -> generateProxy ( $ configClassName ) ; return new $ proxyClassName ( $ config , $ parameters ) ; } 
public function generate ( ReflectionClass $ originalClass , ClassGenerator $ classGenerator ) { CanProxyAssertion :: assertClassCanBeProxied ( $ originalClass , false ) ; $ annotation = null ; $ forceLazyInitProperty = new ForceLazyInitProperty ( ) ; $ sessionBeansProperty = new SessionBeansProperty ( ) ; $ postProcessorsProperty = new BeanPostProcessorsProperty ( ) ; $ parameterValuesProperty = new ParameterValuesProperty ( ) ; $ beanFactoryConfigurationProperty = new BeanFactoryConfigurationProperty ( ) ; $ aliasesProperty = new AliasesProperty ( ) ; $ getParameterMethod = new GetParameter ( $ parameterValuesProperty ) ; $ wrapBeanAsLazyMethod = new WrapBeanAsLazy ( $ beanFactoryConfigurationProperty ) ; try { $ reader = new AnnotationReader ( ) ; $ annotation = $ reader -> getClassAnnotation ( $ originalClass , Configuration :: class ) ; } catch ( Exception $ e ) { throw new InvalidProxiedClassException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } if ( null === $ annotation ) { throw new InvalidProxiedClassException ( sprintf ( '"%s" seems not to be a valid configuration class. @Configuration annotation missing!' , $ originalClass -> name ) ) ; } $ classGenerator -> setExtendedClass ( $ originalClass -> getName ( ) ) ; $ classGenerator -> setImplementedInterfaces ( [ AliasContainerInterface :: class ] ) ; $ classGenerator -> addPropertyFromGenerator ( $ forceLazyInitProperty ) ; $ classGenerator -> addPropertyFromGenerator ( $ sessionBeansProperty ) ; $ classGenerator -> addPropertyFromGenerator ( $ postProcessorsProperty ) ; $ classGenerator -> addPropertyFromGenerator ( $ parameterValuesProperty ) ; $ classGenerator -> addPropertyFromGenerator ( $ beanFactoryConfigurationProperty ) ; $ classGenerator -> addPropertyFromGenerator ( $ aliasesProperty ) ; $ postProcessorMethods = [ ] ; $ parentAliases = [ ] ; $ localAliases = [ ] ; $ methods = $ originalClass -> getMethods ( ReflectionMethod :: IS_PUBLIC | ReflectionMethod :: IS_PROTECTED ) ; foreach ( $ methods as $ method ) { $ methodReflection = new MethodReflection ( $ method -> class , $ method -> name ) ; $ beanAnnotation = $ reader -> getMethodAnnotation ( $ method , Bean :: class ) ; if ( null === $ beanAnnotation ) { $ beanAnnotation = $ reader -> getMethodAnnotation ( $ method , BeanPostProcessor :: class ) ; if ( $ beanAnnotation instanceof BeanPostProcessor ) { $ postProcessorMethods [ ] = $ method -> name ; $ proxyMethod = BeanPostProcessorMethod :: generateMethod ( $ methodReflection , $ beanAnnotation , $ getParameterMethod ) ; $ classGenerator -> addMethodFromGenerator ( $ proxyMethod ) ; continue ; } if ( $ method -> isProtected ( ) ) { continue ; } 
protected static function convertMethodParamsToString ( array $ methodParameters , GetParameter $ parameterValuesMethod ) : string { $ parameters = [ ] ; foreach ( $ methodParameters as $ methodParameter ) { $ defaultValue = $ methodParameter -> getDefaultValue ( ) ; switch ( \ gettype ( $ defaultValue ) ) { case 'string' : $ defaultValue = '"' . $ defaultValue . '"' ; break ; case 'boolean' : $ defaultValue = $ defaultValue ? 'true' : 'false' ; break ; case 'NULL' : $ defaultValue = 'null' ; break ; default : break ; } $ template = empty ( $ defaultValue ) ? '$this->%s("%s", %s)' : '$this->%s("%s", %s, %s)' ; $ required = $ methodParameter -> isRequired ( ) ? 'true' : 'false' ; $ methodName = $ parameterValuesMethod -> getName ( ) ; $ parameters [ ] = \ sprintf ( $ template , $ methodName , $ methodParameter -> getName ( ) , $ required , $ defaultValue ) ; } return \ implode ( ', ' , $ parameters ) ; } 
public function searchAction ( ) { $ requests = $ this -> _getFilteredRequests ( ) ; $ this -> loadLayout ( 'sheep_debug' ) ; $ rootBlock = $ this -> getLayout ( ) -> getBlock ( 'root' ) ; $ rootBlock -> setHeaderTitle ( $ this -> __ ( 'Request profiles' ) ) ; $ profileListBlock = $ this -> getLayout ( ) -> getBlock ( 'sheep_debug_list' ) ; $ profileListBlock -> setData ( 'results' , $ requests ) ; $ this -> renderLayout ( ) ; } 
public function viewAction ( ) { $ token = ( string ) $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) ; return $ this -> _getRefererUrl ( ) ; } $ requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestInfo -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; return $ this -> _getRefererUrl ( ) ; } $ section = $ this -> getRequest ( ) -> getParam ( 'panel' , 'request' ) ; if ( ! in_array ( $ section , array ( 'request' , 'performance' , 'events' , 'db' , 'logging' , 'email' , 'layout' , 'config' ) ) ) { $ section = 'request' ; } Mage :: register ( 'sheep_debug_request_info' , $ requestInfo ) ; $ blockName = 'sheep_debug_' . $ section ; $ blockTemplate = "sheep_debug/view/panel/{$section}.phtml" ; 
public function viewLogAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ log = $ this -> getRequest ( ) -> getParam ( 'log' ) ; if ( ! $ token || ! $ log ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return ; } try { $ content = $ requestProfile -> getLogging ( ) -> getLoggedContent ( $ log ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( $ content ) ; } catch ( Exception $ e ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( 'Unable to retrieve logged content' ) ; } } 
public function purgeProfilesAction ( ) { $ count = $ this -> getService ( ) -> purgeAllProfiles ( ) ; $ this -> getSession ( ) -> addSuccess ( $ this -> __ ( '%d request profiles were deleted' , $ count ) ) ; $ this -> _redirect ( '/' ) ; } 
protected function _getFilteredRequests ( ) { $ requests = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> getCollection ( ) ; $ requests -> setCurPage ( 1 ) ; $ requests -> setPageSize ( Mage :: helper ( 'sheep_debug/filter' ) -> getLimitDefaultValue ( ) ) ; if ( $ sessionId = $ this -> getRequest ( ) -> getParam ( 'session_id' ) ) { $ requests -> addSessionIdFilter ( $ sessionId ) ; } if ( $ ip = $ this -> getRequest ( ) -> getParam ( 'ip' ) ) { $ requests -> addIpFilter ( $ ip ) ; } if ( $ method = $ this -> getRequest ( ) -> getParam ( 'method' ) ) { $ requests -> addHttpMethodFilter ( $ method ) ; } if ( $ limit = $ this -> getRequest ( ) -> getParam ( 'limit' ) ) { $ requests -> setPageSize ( $ limit ) ; } if ( $ path = $ this -> getRequest ( ) -> getParam ( 'path' ) ) { $ requests -> addRequestPathFilter ( $ path ) ; } if ( $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ) { $ requests -> addTokenFilter ( $ token ) ; } if ( $ startDate = $ this -> getRequest ( ) -> getParam ( 'start' ) ) { $ requests -> addAfterFilter ( $ startDate ) ; } if ( $ endDate = $ this -> getRequest ( ) -> getParam ( 'end' ) ) { $ requests -> addEarlierFilter ( $ endDate ) ; } if ( $ page = ( int ) $ this -> getRequest ( ) -> getParam ( 'page' ) ) { $ requests -> setCurPage ( $ page ) ; } $ requests -> addOrder ( 'id' , Varien_Data_Collection_Db :: SORT_ORDER_DESC ) ; return $ requests ; } 
public function getVisiblePanels ( ) { if ( $ this -> visiblePanels === null ) { $ this -> visiblePanels = array ( ) ; $ panels = $ this -> getSortedChildBlocks ( ) ; foreach ( $ panels as $ panel ) { if ( ! $ panel instanceof Sheep_Debug_Block_Panel ) { continue ; } $ this -> visiblePanels [ ] = $ panel ; } } return $ this -> visiblePanels ; } 
public function initLogging ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ this -> logging = Mage :: getModel ( 'sheep_debug/logging' ) ; $ this -> logging -> addFile ( $ helper -> getLogFilename ( $ this -> getStoreId ( ) ) ) ; $ this -> logging -> addFile ( $ helper -> getExceptionLogFilename ( $ this -> getStoreId ( ) ) ) ; Mage :: dispatchEvent ( 'sheep_debug_init_logging' , array ( 'logging' => $ this -> logging ) ) ; $ this -> logging -> startRequest ( ) ; } 
public function getEvents ( ) { if ( $ this -> events === null ) { $ this -> events = array ( ) ; foreach ( $ this -> getTimers ( ) as $ timerName => $ timer ) { if ( strpos ( $ timerName , 'DISPATCH EVENT:' ) === 0 ) { $ this -> events [ str_replace ( 'DISPATCH EVENT:' , '' , $ timerName ) ] = array ( 'name' => str_replace ( 'DISPATCH EVENT:' , '' , $ timerName ) , 'count' => $ timer [ 'count' ] , 'sum' => round ( $ timer [ 'sum' ] * 1000 , 2 ) , 
public function getObservers ( ) { if ( $ this -> observers === null ) { $ this -> observers = array ( ) ; foreach ( $ this -> getTimers ( ) as $ timerName => $ timer ) { if ( strpos ( $ timerName , 'OBSERVER' ) === 0 ) { $ this -> observers [ ] = array ( 'name' => $ timerName , 'count' => $ timer [ 'count' ] , 'sum' => round ( $ timer [ 'sum' ] * 1000 , 2 ) , 
public function initController ( $ controllerAction = null ) { $ controller = Mage :: getModel ( 'sheep_debug/controller' ) ; $ controller -> init ( $ controllerAction ) ; $ this -> action = $ controller ; } 
public function addLayout ( Mage_Core_Model_Layout $ layout , Mage_Core_Model_Design_Package $ design ) { $ this -> getDesign ( ) -> init ( $ layout , $ design ) ; } 
public function addBlock ( Mage_Core_Block_Abstract $ block ) { $ blockInfo = Mage :: getModel ( 'sheep_debug/block' ) ; $ blockInfo -> init ( $ block ) ; $ key = $ blockInfo -> getName ( ) ; return $ this -> blocks [ $ key ] = $ blockInfo ; } 
public function getBlock ( $ blockName ) { if ( ! array_key_exists ( $ blockName , $ this -> blocks ) ) { throw new Exception ( 'Unable to find block with name ' . $ blockName ) ; } return $ this -> blocks [ $ blockName ] ; } 
public function getBlocksAsArray ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ data = array ( ) ; foreach ( $ this -> getBlocks ( ) as $ block ) { $ data [ ] = array ( 'name' => $ block -> getName ( ) , 'class' => $ block -> getClass ( ) , 'template' => $ block -> getTemplateFile ( ) , 'time (ms)' => $ block -> getRenderedDuration ( ) ? $ helper -> formatNumber ( $ block -> getRenderedDuration ( ) , 0 ) : '' , 'count' => $ block -> getRenderedCount ( ) ) ; } return $ data ; } 
public function addCollection ( Varien_Data_Collection_Db $ collection ) { $ info = Mage :: getModel ( 'sheep_debug/collection' ) ; $ info -> init ( $ collection ) ; $ key = $ info -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> collections ) ) { $ this -> collections [ $ key ] = $ info ; } $ this -> collections [ $ key ] -> incrementCount ( ) ; } 
public function getCollectionsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getCollections ( ) as $ collection ) { $ data [ ] = array ( 'type' => $ collection -> getType ( ) , 'class' => $ collection -> getClass ( ) , 'sql' => $ collection -> getQuery ( ) , 'count' => $ collection -> getCount ( ) ) ; } return $ data ; } 
public function addModel ( Mage_Core_Model_Abstract $ model ) { $ modelInfo = Mage :: getModel ( 'sheep_debug/model' ) ; $ modelInfo -> init ( $ model ) ; $ key = $ modelInfo -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> models ) ) { $ this -> models [ $ key ] = $ modelInfo ; } $ this -> models [ $ key ] -> incrementCount ( ) ; } 
public function getModelsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getModels ( ) as $ model ) { $ data [ ] = array ( 'resource_name' => $ model -> getResource ( ) , 'class' => $ model -> getClass ( ) , 'count' => $ model -> getCount ( ) ) ; } return $ data ; } 
public function initQueries ( ) { $ this -> queries = array ( ) ; $ profiler = Mage :: helper ( 'sheep_debug' ) -> getSqlProfiler ( ) ; if ( $ profiler -> getEnabled ( ) && $ profiler instanceof Sheep_Debug_Model_Db_Profiler ) { $ this -> queries = $ profiler -> getQueryModels ( ) ? : array ( ) ; $ this -> setQueryCount ( $ profiler -> getTotalNumQueries ( ) ) ; $ this -> setQueryTime ( $ profiler -> getTotalElapsedSecs ( ) ) ; } } 
public function getSerializedInfo ( ) { return serialize ( array ( 'logging' => $ this -> getLogging ( ) , 'action' => $ this -> getController ( ) , 'design' => $ this -> getDesign ( ) , 'blocks' => $ this -> getBlocks ( ) , 'models' => $ this -> getModels ( ) , 'collections' => $ this -> getCollections ( ) , 'queries' => $ this -> getQueries ( ) , 'timers' => $ this -> getTimers ( ) , 'emails' => $ this -> getEmails ( ) ) ) ; } 
protected function _beforeSave ( ) { parent :: _beforeSave ( ) ; if ( ! $ this -> getId ( ) ) { $ this -> setToken ( $ this -> generateToken ( ) ) ; $ this -> setHttpMethod ( $ this -> getController ( ) -> getHttpMethod ( ) ) ; $ this -> setResponseCode ( $ this -> getController ( ) -> getResponseCode ( ) ) ; $ this -> setIp ( $ this -> getController ( ) -> getRemoteIp ( ) ) ; } $ this -> setRequestPath ( $ this -> getController ( ) -> getRequestOriginalPath ( ) ) ; $ this -> setSessionId ( $ this -> getController ( ) -> getSessionId ( ) ) ; $ this -> setInfo ( $ this -> getSerializedInfo ( ) ) ; return $ this ; } 
protected function _afterLoad ( ) { $ info = $ this -> getUnserializedInfo ( ) ; $ this -> logging = $ info [ 'logging' ] ; $ this -> action = $ info [ 'action' ] ; $ this -> design = $ info [ 'design' ] ; $ this -> blocks = $ info [ 'blocks' ] ; $ this -> models = $ info [ 'models' ] ; $ this -> collections = $ info [ 'collections' ] ; $ this -> queries = $ info [ 'queries' ] ; $ this -> timers = $ info [ 'timers' ] ; $ this -> emails = $ info [ 'emails' ] ; return parent :: _afterLoad ( ) ; } 
public function deleteExpiredRequests ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( ! $ helper -> isEnabled ( ) ) { return 'skipped: module is disabled.' ; } if ( $ helper -> getPersistLifetime ( ) == 0 ) { return 'skipped: lifetime is set to 0' ; } $ expirationDate = $ this -> getExpirationDate ( date ( self :: DATE_FORMAT ) ) ; $ table = $ this -> getRequestsTable ( ) ; $ deleteSql = "DELETE FROM {$table} WHERE date <= '{$expirationDate}'" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return "{$result->rowCount()} requests deleted" ; } 
public function getExpirationDate ( $ currentDate ) { $ numberOfDays = Mage :: helper ( 'sheep_debug' ) -> getPersistLifetime ( ) ; return date ( self :: DATE_FORMAT , strtotime ( "-{$numberOfDays} days {$currentDate}" ) ) ; } 
public function __ ( ) { $ args = func_get_args ( ) ; return $ this -> helper -> useStoreLocale ( ) ? $ this -> parentTranslate ( $ args ) : $ this -> dummyTranslate ( $ args ) ; } 
public function getRequestViewUrl ( $ panel = null , $ token = null ) { $ token = $ token ? : $ this -> getRequestInfo ( ) -> getToken ( ) ; return $ token ? Mage :: helper ( 'sheep_debug/url' ) -> getRequestViewUrl ( $ token , $ panel ) : '#' ; } 
public function formatNumber ( $ number , $ precision = 2 ) { return $ this -> helper -> useStoreLocale ( ) ? $ this -> helper -> formatNumber ( $ number , $ precision ) : number_format ( $ number , $ precision ) ; } 
public function getOptionArray ( array $ data ) { $ options = array ( ) ; foreach ( $ data as $ value ) { $ options [ ] = array ( 'value' => $ value , 'label' => $ value ) ; } return $ options ; } 
public function enableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; } 
public function disableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( false ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was disabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to disable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; } 
public function selectSqlAction ( ) { if ( $ query = $ this -> _initQuery ( ) ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ results = $ helper -> runSql ( $ query -> getQuery ( ) , $ query -> getQueryParams ( ) ) ; $ this -> renderTable ( $ results ) ; } } 
public function stacktraceSqlAction ( ) { if ( $ query = $ this -> _initQuery ( ) ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ stripZendPath = $ helper -> canStripZendDbTrace ( ) ? 'lib/Zend/Db/Adapter' : '' ; $ trimPath = $ helper -> canTrimMagentoBaseDir ( ) ? Mage :: getBaseDir ( ) . DS : '' ; $ html = '<pre>' . Mage :: helper ( 'sheep_debug' ) -> formatStacktrace ( $ query -> getStackTrace ( ) , $ stripZendPath , $ trimPath ) . '</pre>' ; $ this -> getResponse ( ) -> setBody ( $ html ) ; } } 
protected function _initQuery ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ queries = $ requestProfile -> getQueries ( ) ; if ( ! $ queries || ! ( $ index < count ( $ queries ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Query not found' ) ; return null ; } return $ queries [ ( int ) $ index ] ; } 
public function startRendering ( Mage_Core_Block_Abstract $ block ) { if ( $ this -> isRendering ) { 
public function completeRendering ( Mage_Core_Block_Abstract $ block ) { $ this -> isRendering = false ; $ this -> renderedCompletedAt = microtime ( true ) ; $ this -> renderedDuration += ( $ this -> renderedCompletedAt * 1000 - $ this -> renderedAt * 1000 ) ; $ this -> templateFile = $ block instanceof Mage_Core_Block_Template ? $ block -> getTemplateFile ( ) : '' ; self :: $ endRenderingTime = $ this -> renderedCompletedAt ; } 
public function init ( Mage_Core_Model_Layout $ layout , Mage_Core_Model_Design_Package $ designPackage ) { $ this -> area = $ designPackage -> getArea ( ) ; $ this -> packageName = $ designPackage -> getPackageName ( ) ; $ this -> themeLayout = $ designPackage -> getTheme ( 'layout' ) ; $ this -> themeLocale = $ designPackage -> getTheme ( 'locale' ) ; $ this -> themeTemplate = $ designPackage -> getTheme ( 'template' ) ; $ this -> themeSkin = $ designPackage -> getTheme ( 'skin' ) ; $ this -> layoutHandles = $ layout -> getUpdate ( ) -> getHandles ( ) ; $ this -> setLayoutUpdates ( $ layout -> getUpdate ( ) -> asArray ( ) ) ; } 
public function getLayoutUpdates ( ) { if ( $ this -> uncompressedLayoutUpdates === null ) { $ this -> uncompressedLayoutUpdates = $ this -> layoutUpdates ? json_decode ( gzuncompress ( $ this -> layoutUpdates ) , true ) : array ( ) ; } return $ this -> uncompressedLayoutUpdates ; } 
public function getInfoAsArray ( ) { return array ( 'design_area' => $ this -> getArea ( ) , 'package_name' => $ this -> getPackageName ( ) , 'layout_theme' => $ this -> getThemeLayout ( ) , 'template_theme' => $ this -> getThemeTemplate ( ) , 'locale' => $ this -> getThemeLocale ( ) , 'skin' => $ this -> getThemeSkin ( ) ) ; } 
public function getRequestInfo ( ) { if ( $ this -> requestInfo === null ) { $ this -> requestInfo = Mage :: registry ( 'sheep_debug_request_info' ) ; } return $ this -> requestInfo ; } 
public function getFilteredRequestListUrl ( $ filters = array ( ) ) { 
public function renderArrayAsText ( $ array ) { $ values = array ( ) ; foreach ( $ array as $ key => $ value ) { $ values [ ] = $ this -> escapeHtml ( $ key ) . ' = ' . $ this -> renderValue ( $ value ) ; } return implode ( ', ' , $ values ) ; } 
public function renderArray ( $ data , $ noDataLabel = 'No Data' , $ header = null ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ block -> setTemplate ( 'sheep_debug/view/panel/_array.phtml' ) ; $ block -> setData ( 'array' , $ data ) ; $ block -> setData ( 'no_data_label' , $ noDataLabel ) ; $ block -> setData ( 'header' , $ header ) ; return $ block -> toHtml ( ) ; } 
public function renderValue ( $ value ) { $ output = '' ; if ( $ value ) { if ( is_scalar ( $ value ) ) { $ output = $ this -> escapeHtml ( $ value ) ; } else if ( is_array ( $ value ) ) { $ output = $ this -> renderArray ( $ value ) ; } else { return $ this -> escapeHtml ( var_export ( $ value , true ) ) ; } } return $ output ; } 
public function getBlocksAsTree ( ) { $ blocks = $ this -> getRequestInfo ( ) -> getBlocks ( ) ; $ tree = new Varien_Data_Tree ( ) ; $ rootNodes = array ( ) ; foreach ( $ blocks as $ block ) { $ parentNode = $ tree -> getNodeById ( $ block -> getParentName ( ) ) ; $ node = new Varien_Data_Tree_Node ( array ( 'name' => $ block -> getName ( ) , 'class' => $ block -> getClass ( ) , 'template' => $ block -> getTemplateFile ( ) , 'duration' => $ block -> getRenderedDuration ( ) , 'count' => $ block -> getRenderedCount ( ) ) , 'name' , $ tree , $ parentNode ) ; $ tree -> addNode ( $ node , $ parentNode ) ; if ( ! $ parentNode ) { $ rootNodes [ ] = $ node ; } } return $ rootNodes ; } 
public function getBlockTreeHtml ( ) { $ content = '' ; $ rootNodes = $ this -> getBlocksAsTree ( ) ; 
public function renderTreeNode ( Varien_Data_Tree_Node $ node , $ indentLevel = 0 ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ block -> setRequestInfo ( $ this -> getRequestInfo ( ) ) ; $ block -> setTemplate ( 'sheep_debug/view/panel/_block_node.phtml' ) ; $ block -> setNode ( $ node ) ; $ block -> setIndent ( $ indentLevel ) ; return $ block -> toHtml ( ) ; } 
public function getRequestPath ( ) { $ requestPath = '' ; $ server = $ this -> getGlobalServer ( ) ; if ( array_key_exists ( 'REQUEST_URI' , $ server ) ) { $ requestPath = parse_url ( $ server [ 'REQUEST_URI' ] , PHP_URL_PATH ) ; } return $ requestPath ; } 
public function getAllHeaders ( ) { if ( ! function_exists ( 'getallheaders' ) ) { $ libRelativePath = 'lib' . DS . 'getallheaders' . DS . 'getallheaders.php' ; $ polyfillFilepath = Mage :: helper ( 'sheep_debug' ) -> getModuleDirectory ( ) . DS . $ libRelativePath ; require_once ( $ polyfillFilepath ) ; } return function_exists ( 'getallheaders' ) ? getallheaders ( ) : array ( ) ; } 
public function getUrl ( $ path , array $ params = array ( ) ) { $ path = self :: MODULE_ROUTE . $ path ; $ params [ '_store' ] = $ this -> getRouteStoreId ( ) ; $ params [ '_nosid' ] = true ; return $ this -> _getUrl ( $ path , $ params ) ; } 
public function getCurrentStore ( ) { $ currentStore = $ this -> _getApp ( ) -> getStore ( ) ; return sprintf ( '%s / %s' , $ currentStore -> getWebsite ( ) -> getName ( ) , $ currentStore -> getName ( ) ) ; } 
public function getModuleConfigFilePath ( $ moduleName ) { $ config = $ this -> getConfig ( ) ; $ moduleConfig = $ config -> getModuleConfig ( $ moduleName ) ; if ( ! $ moduleConfig ) { throw new Exception ( "Unable to find module '{$moduleName}'" ) ; } return $ config -> getOptions ( ) -> getEtcDir ( ) . DS . 'modules' . DS . $ moduleName . '.xml' ; } 
public function setModuleStatus ( $ moduleName , $ isActive ) { $ moduleConfigFile = $ this -> getModuleConfigFilePath ( $ moduleName ) ; $ configXml = $ this -> loadXmlFile ( $ moduleConfigFile ) ; if ( $ configXml === false ) { throw new Exception ( "Unable to parse module configuration file {$moduleConfigFile}" ) ; } $ configXml -> modules -> { $ moduleName } -> active = $ isActive ? 'true' : 'false' ; 
public function setSqlProfilerStatus ( $ isEnabled ) { $ filePath = $ this -> getLocalXmlFilePath ( ) ; $ xml = $ this -> loadXmlFile ( $ filePath ) ; if ( $ xml === false ) { throw new Exception ( "Unable to parse local.xml configuration file: {$filePath}" ) ; } $ connectionNode = $ xml -> global -> resources -> default_setup -> connection ; if ( $ isEnabled ) { $ connectionNode -> profiler = '1' ; } else { unset ( $ connectionNode -> profiler ) ; } if ( $ this -> saveXml ( $ xml , $ filePath ) === false ) { throw new Exception ( "Unable to save {$filePath}: check if web server user has write permission" ) ; } } 
public function setFPCDebug ( $ status ) { if ( ! Mage :: helper ( 'sheep_debug' ) -> isMagentoEE ( ) ) { throw new Exception ( 'Cannot enable FPC debug for this Magento version.' ) ; } $ this -> getConfig ( ) -> saveConfig ( 'system/page_cache/debug' , ( int ) $ status ) ; } 
public function setTemplateHints ( $ status ) { $ this -> deleteTemplateHintsDbConfigs ( ) ; $ config = $ this -> getConfig ( ) ; $ config -> saveConfig ( 'dev/debug/template_hints' , ( int ) $ status ) ; $ config -> saveConfig ( 'dev/debug/template_hints_blocks' , ( int ) $ status ) ; } 
public function searchConfig ( $ query ) { $ configArray = array ( ) ; $ configArray = Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ this -> getConfig ( ) -> getNode ( ) , $ configArray ) ; $ results = array ( ) ; $ configKeys = array_keys ( $ configArray ) ; foreach ( $ configKeys as $ configKey ) { if ( strpos ( $ configKey , $ query ) !== FALSE ) { $ results [ $ configKey ] = $ configArray [ $ configKey ] ; } } return $ results ; } 
public function deleteTemplateHintsDbConfigs ( ) { $ configTable = Mage :: getResourceModel ( 'core/config' ) -> getMainTable ( ) ; $ db = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ db -> delete ( $ configTable , "path like 'dev/debug/template_hints%'" ) ; } 
public function purgeAllProfiles ( ) { $ table = Mage :: getResourceModel ( 'sheep_debug/requestInfo' ) -> getMainTable ( ) ; $ deleteSql = "DELETE FROM {$table}" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return $ result -> rowCount ( ) ; } 
public function getFileUpdatesWithHandle ( $ handle , $ storeId , $ area ) { $ updateFiles = Mage :: helper ( 'sheep_debug' ) -> getLayoutUpdatesFiles ( $ storeId , $ area ) ; $ designPackage = Mage :: getModel ( 'core/design_package' ) ; $ designPackage -> setStore ( $ storeId ) ; $ designPackage -> setArea ( $ area ) ; $ designPackageName = $ designPackage -> getPackageName ( ) ; $ layoutTheme = $ designPackage -> getTheme ( 'layout' ) ; 
public function getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) { $ databaseHandles = array ( ) ; $ designPackage = Mage :: getModel ( 'core/design_package' ) ; $ designPackage -> setStore ( $ storeId ) ; $ designPackage -> setArea ( $ area ) ; $ layoutResourceModel = Mage :: getResourceModel ( 'core/layout' ) ; $ bind = array ( 'store_id' => $ storeId , 'area' => $ area , 'package' => $ designPackage -> getPackageName ( ) , 'theme' => $ designPackage -> getTheme ( 'layout' ) , 'layout_update_handle' => $ handle ) ; $ readAdapter = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_read' ) ; $ select = $ readAdapter -> select ( ) -> from ( array ( 'layout_update' => $ layoutResourceModel -> getMainTable ( ) ) , array ( 'layout_update_id' , 'xml' ) ) -> join ( array ( 'link' => $ layoutResourceModel -> getTable ( 'core/layout_link' ) ) , 'link.layout_update_id=layout_update.layout_update_id' , '' ) -> where ( 'link.store_id IN (0, :store_id)' ) -> where ( 'link.area = :area' ) -> where ( 'link.package = :package' ) -> where ( 'link.theme = :theme' ) -> where ( 'layout_update.handle = :layout_update_handle' ) -> order ( 'layout_update.sort_order ' . Varien_Db_Select :: SQL_ASC ) ; $ result = $ readAdapter -> fetchAssoc ( $ select , $ bind ) ; if ( count ( $ result ) ) { foreach ( $ result as $ dbLayoutUpdate ) { $ databaseHandles [ $ dbLayoutUpdate [ 'layout_update_id' ] ] = $ dbLayoutUpdate [ 'xml' ] ; } } return $ databaseHandles ; } 
public function init ( Varien_Data_Collection_Db $ collection ) { $ this -> class = get_class ( $ collection ) ; $ this -> type = $ collection instanceof Mage_Eav_Model_Entity_Collection_Abstract ? self :: TYPE_EAV : self :: TYPE_FLAT ; $ this -> query = $ collection -> getSelectSql ( true ) ; $ this -> count = 0 ; } 
public function viewHandleAction ( ) { $ area = $ this -> getRequest ( ) -> getParam ( 'area' ) ; $ storeId = ( int ) $ this -> getRequest ( ) -> getParam ( 'store' ) ; $ handle = $ this -> getRequest ( ) -> getParam ( 'handle' ) ; $ updatesByFile = $ this -> getService ( ) -> getFileUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ databaseUpdates = $ this -> getService ( ) -> getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' , '' , array ( 'template' => 'sheep_debug/view/panel/_layout_updates.phtml' , 'file_updates' => $ updatesByFile , 'db_updates' => $ databaseUpdates ) ) ; $ this -> getResponse ( ) -> setBody ( $ block -> toHtml ( ) ) ; } 
public function layoutUpdatesAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; } $ layoutUpdates = $ requestProfile -> getDesign ( ) -> getLayoutUpdates ( ) ; $ this -> renderArray ( $ layoutUpdates , 'No Data' , array ( '#' , 'XML' ) ) ; } 
public function getHttpMethodsSelect ( ) { $ options = $ this -> getHttpMethodOptions ( ) ; array_unshift ( $ options , array ( 'value' => '' , 'label' => 'Any' ) ) ; $ select = $ this -> getLayout ( ) -> createBlock ( 'core/html_select' ) ; $ select -> setName ( 'method' ) -> setId ( 'method' ) -> setValue ( $ this -> getRequest ( ) -> getParam ( 'method' ) ) -> setOptions ( $ options ) ; return $ select -> getHtml ( ) ; } 
public function getLimitOptionsSelect ( ) { $ filterHelper = Mage :: helper ( 'sheep_debug/filter' ) ; $ select = $ this -> getLayout ( ) -> createBlock ( 'core/html_select' ) ; $ select -> setName ( 'limit' ) -> setId ( 'limit' ) -> setValue ( $ this -> getRequest ( ) -> getParam ( 'limit' , $ filterHelper -> getLimitDefaultValue ( ) ) ) -> setOptions ( $ this -> getOptionArray ( $ filterHelper -> getLimitValues ( ) ) ) ; return $ select -> getHtml ( ) ; } 
public function getRange ( $ logFile ) { if ( ! array_key_exists ( $ logFile , $ this -> ranges ) ) { throw new Exception ( 'Invalid log file' ) ; } return $ this -> ranges [ $ logFile ] ; } 
public function startRequest ( ) { foreach ( $ this -> files as $ logFile ) { $ logFilePath = $ this -> getLogFilePath ( $ logFile ) ; $ this -> ranges [ $ logFile ] = array ( 'start' => $ this -> getLastFilePosition ( $ logFilePath ) , 'end' => 0 ) ; } } 
public function getLogging ( ) { $ logging = array ( ) ; foreach ( $ this -> files as $ logFile ) { $ logging [ $ logFile ] = $ this -> getLoggedContent ( $ logFile ) ; } return $ logging ; } 
public function getLastFilePosition ( $ filePath ) { if ( ! file_exists ( $ filePath ) ) { return 0 ; } $ f = fopen ( $ filePath , 'r' ) ; fseek ( $ f , - 1 , SEEK_END ) ; return ftell ( $ f ) ; } 
public function getLoggedContent ( $ logFile ) { if ( ! array_key_exists ( $ logFile , $ this -> ranges ) ) { throw new Exception ( 'Invalid log file' ) ; } return $ this -> getContent ( $ this -> getLogFilePath ( $ logFile ) , $ this -> ranges [ $ logFile ] [ 'start' ] , $ this -> ranges [ $ logFile ] [ 'end' ] ) ; } 
public function getTotalLineCount ( ) { if ( $ this -> logLineCount === null ) { $ this -> logLineCount = 0 ; foreach ( $ this -> getFiles ( ) as $ log ) { $ this -> logLineCount += $ this -> getLineCount ( $ log ) ; } } return $ this -> logLineCount ; } 
public function getContent ( $ filePath , $ startPosition , $ endPosition ) { if ( ! file_exists ( $ filePath ) ) { return '' ; } 
public function preDispatch ( ) { parent :: preDispatch ( ) ; if ( ! Mage :: helper ( 'sheep_debug' ) -> isAllowed ( ) ) { $ this -> setFlag ( '' , 'no-dispatch' , true ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; } } 
public function renderArray ( array $ data , $ noDataLabel = 'No Data' , $ header = null ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ html = $ block -> renderArray ( $ data , $ noDataLabel , $ header ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( $ html ) ; } 
public function renderTable ( array $ data , array $ fields = array ( ) , $ noDataLabel = 'No Data' ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ html = $ block -> renderArrayFields ( $ data , $ fields , $ noDataLabel ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( $ html ) ; } 
public function getExtensionStatus ( ) { $ status = array ( ) ; $ extensions = $ this -> getExtensionRequirements ( ) ; foreach ( $ extensions as $ extension ) { $ status [ $ extension ] = extension_loaded ( $ extension ) ; } return $ status ; } 
public function getModules ( ) { $ items = array ( ) ; $ items [ ] = array ( 'module' => 'Magento' , 'codePool' => 'core' , 'active' => true , 'version' => $ this -> getMagentoVersion ( ) ) ; $ modulesConfig = Mage :: getConfig ( ) -> getModuleConfig ( ) ; foreach ( $ modulesConfig as $ node ) { foreach ( $ node as $ module => $ data ) { $ items [ ] = array ( 'module' => $ module , 'codePool' => ( string ) $ data -> codePool , 'active' => $ data -> active == 'true' , 'version' => ( string ) $ data -> version ) ; } } return $ items ; } 
public function init ( Mage_Core_Model_Abstract $ model ) { $ this -> class = get_class ( $ model ) ; $ this -> resource = $ model -> getResourceName ( ) ; $ this -> count = 0 ; } 
public function getRequestFilters ( Mage_Core_Controller_Request_Http $ request ) { if ( ! $ this -> requestFilterValues ) { $ filters = $ this -> getFilterParams ( ) ; $ this -> requestFilterValues = array ( ) ; foreach ( $ filters as $ filter ) { $ param = $ request -> getParam ( $ filter , null ) ; if ( $ param !== null ) { $ this -> requestFilterValues [ $ filter ] = $ param ; } } } return $ this -> requestFilterValues ; } 
public function enableAction ( ) { $ moduleName = ( string ) $ this -> getRequest ( ) -> getParam ( 'module' ) ; try { $ this -> getService ( ) -> setModuleStatus ( $ moduleName , true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'Module was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable module: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; } 
public function getCategory ( $ timerName ) { $ category = self :: CORE_CATEGORY ; if ( strpos ( $ timerName , 'mage::dispatch' ) === 0 || strpos ( $ timerName , 'column.phtml' ) > 0 ) { $ category = self :: SECTION ; } else if ( strpos ( $ timerName , 'Model_Resource' ) > 0 ) { $ category = self :: DB_CATEGORY ; } else if ( strpos ( $ timerName , 'EAV' ) === 0 || strpos ( $ timerName , '_LOAD_ATTRIBUTE_' ) === 0 || strpos ( $ timerName , '__EAV_' ) === 0 ) { $ category = self :: EAV_CATEGORY ; } else if ( strpos ( $ timerName , 'CORE::create_object_of' ) === 0 ) { $ category = self :: CORE_CATEGORY ; } else if ( strpos ( $ timerName , 'OBSERVER' ) === 0 || strpos ( $ timerName , 'DISPATCH EVENT' ) === 0 ) { $ category = self :: EVENT_CATEGORY ; } else if ( strpos ( $ timerName , 'BLOCK' ) === 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , 'init_config' ) === 0 ) { $ category = self :: CONFIG_CATEGORY ; } else if ( strpos ( $ timerName , 'layout/' ) === 0 || strpos ( $ timerName , 'layout_' ) > 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , 'Mage_Core_Model_Design' ) === 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , '.phtml' ) > 0 ) { $ category = self :: LAYOUT_CATEGORY ; } return $ category ; } 
public function convertTimers ( Sheep_Debug_Model_RequestInfo $ request ) { if ( ! $ request -> getTimers ( ) ) { return array ( ) ; } $ requestData = array ( ) ; $ requestData [ 'id' ] = $ request -> getToken ( ) ; $ requestData [ 'left' ] = 0 ; $ requestData [ 'events' ] = array ( ) ; $ currentTime = 0 ; foreach ( $ request -> getTimers ( ) as $ name => $ timer ) { if ( ! $ timer [ 'sum' ] ) { continue ; } 
public function searchGroupClassAction ( ) { if ( ! $ this -> getRequest ( ) -> isPost ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 405 ) ; return ; } $ uri = ( string ) $ this -> getRequest ( ) -> getPost ( 'uri' ) ; $ groupType = $ this -> getRequest ( ) -> getPost ( 'group' ) ; $ groupTypes = array ( $ groupType ) ; if ( $ groupType == 'all' ) { $ groupTypes = array ( 'model' , 'block' , 'helper' ) ; } $ items = array ( ) ; if ( $ uri ) { foreach ( $ groupTypes as $ type ) { $ items [ $ type ] [ 'class' ] = Mage :: getConfig ( ) -> getGroupedClassName ( $ type , $ uri ) ; $ items [ $ type ] [ 'filepath' ] = mageFindClassFile ( $ items [ $ type ] [ 'class' ] ) ; } $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/array' ) ; $ block -> setTemplate ( 'sheep_debug/grouped_class_search.phtml' ) ; $ block -> assign ( 'items' , $ items ) ; $ this -> getResponse ( ) -> setBody ( $ block -> toHtml ( ) ) ; } else { $ this -> getResponse ( ) -> setBody ( $ this -> __ ( 'Please fill in a search query' ) ) ; } } 
public function flushCacheAction ( ) { try { $ this -> getService ( ) -> flushCache ( ) ; $ this -> getSession ( ) -> addSuccess ( 'Cache flushed.' ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Cache cannot be flushed: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; } 
public function enableFPCDebugAction ( ) { try { $ this -> getService ( ) -> setFPCDebug ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; $ message = $ this -> __ ( 'FPC debug was enabled' ) ; $ this -> getSession ( ) -> addSuccess ( $ message ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'FPC debug cannot be enabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; } 
public function enableTemplateHintsAction ( ) { try { $ this -> getService ( ) -> setTemplateHints ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; 
public function disableTranslateAction ( ) { try { $ this -> getService ( ) -> setTranslateInline ( 0 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Translate inline cannot be disabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; } 
public function getBodyAction ( ) { if ( $ email = $ this -> _initEmail ( ) ) { $ this -> getResponse ( ) -> setHeader ( 'Content-Type' , $ email -> getIsPlain ( ) ? 'text/plain' : 'text/html' ) ; $ this -> getResponse ( ) -> setBody ( $ email -> getBody ( ) ) ; } } 
protected function _initEmail ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ emails = $ requestProfile -> getEmails ( ) ; if ( ! $ emails || ! ( $ index < count ( $ emails ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'E-mail not found' ) ; return null ; } return $ emails [ ( int ) $ index ] ; } 
public function getRequestInfo ( ) { if ( $ this -> requestInfo === null ) { $ this -> requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) ; } return $ this -> requestInfo ; } 
public function startProfiling ( ) { 
public function updateProfiling ( ) { $ requestInfo = $ this -> getRequestInfo ( ) ; if ( ! $ requestInfo -> getIsStarted ( ) ) { return ; } $ helper = Mage :: helper ( 'sheep_debug' ) ; 
public function saveProfiling ( ) { if ( ! $ this -> canCollect ( ) || ! Mage :: helper ( 'sheep_debug' ) -> canPersist ( ) ) { return ; } if ( Mage :: helper ( 'sheep_debug' ) -> hasDisablePersistenceCookie ( ) ) { return ; } if ( ! $ this -> getRequestInfo ( ) -> getIsStarted ( ) ) { return ; } $ this -> getRequestInfo ( ) -> save ( ) ; } 
public function onActionPreDispatch ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ action = $ observer -> getData ( 'controller_action' ) ; 
public function onLayoutGenerate ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ layout = $ observer -> getData ( 'layout' ) ; $ requestInfo = $ this -> getRequestInfo ( ) ; 
public function onBlockToHtml ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ block = $ observer -> getData ( 'block' ) ; 
public function onBlockToHtmlAfter ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ block = $ observer -> getData ( 'block' ) ; 
public function onCollectionLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ collection = $ observer -> getData ( 'collection' ) ; $ this -> getRequestInfo ( ) -> addCollection ( $ collection ) ; } 
public function onModelLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ model = $ observer -> getData ( 'object' ) ; $ this -> getRequestInfo ( ) -> addModel ( $ model ) ; } 
public function onControllerFrontSendResponseAfter ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ front = $ observer -> getData ( 'front' ) ; $ this -> updateProfiling ( ) ; $ this -> getRequestInfo ( ) -> getController ( ) -> addResponseInfo ( $ front -> getResponse ( ) ) ; } 
public function onWebsiteRestriction ( Varien_Event_Observer $ observer ) { $ controller = $ observer -> getController ( ) ; $ result = $ observer -> getResult ( ) ; $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( $ helper -> canShowToolbar ( ) && $ controller instanceof Sheep_Debug_Controller_Front_Action ) { $ result -> setShouldProceed ( false ) ; } } 
public function canCaptureBlock ( $ block ) { $ blockClass = get_class ( $ block ) ; if ( ! $ this -> canCaptureCoreBlocks ( ) && strpos ( $ blockClass , 'Mage_' ) === 0 ) { return false ; } 
public function init ( Zend_Db_Profiler_Query $ profilerQuery , $ stacktrace = '' ) { $ this -> queryType = $ profilerQuery -> getQueryType ( ) ; $ this -> query = $ profilerQuery -> getQuery ( ) ; $ this -> queryParams = $ profilerQuery -> getQueryParams ( ) ; $ this -> elapsedSecs = $ profilerQuery -> getElapsedSecs ( ) ; $ this -> stacktrace = $ stacktrace ; } 
public function send ( ) { try { $ this -> captureEmail ( ) ; } catch ( Exception $ e ) { Mage :: logException ( $ e ) ; } return $ this -> parentSend ( ) ; } 
public function captureEmail ( ) { $ email = Mage :: getModel ( 'sheep_debug/email' ) ; $ email -> setFromEmail ( $ this -> getFromEmail ( ) ) ; $ email -> setFromName ( $ this -> getFromName ( ) ) ; $ email -> setToEmail ( $ this -> getToEmail ( ) ) ; $ email -> setToName ( $ this -> getToName ( ) ) ; $ email -> setSubject ( $ this -> getSubject ( ) ) ; $ email -> setIsPlain ( $ this -> getType ( ) != 'html' ) ; $ email -> setBody ( $ this -> getBody ( ) ) ; $ email -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; $ email -> setIsAccepted ( true ) ; 
public function replaceProfiler ( ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ currentProfile = $ connection -> getProfiler ( ) ; if ( $ currentProfile ) { 
public function queryEnd ( $ queryId ) { $ result = $ this -> parentQueryEnd ( $ queryId ) ; if ( $ this -> captureStacktraces ) { $ this -> stackTraces [ $ queryId ] = $ this -> getStackTrace ( ) ; } return $ result ; } 
public function getQueryModels ( ) { $ queries = array ( ) ; foreach ( $ this -> _queryProfiles as $ queryId => $ queryProfile ) { $ queryModel = Mage :: getModel ( 'sheep_debug/query' ) ; $ stacktrace = array_key_exists ( $ queryId , $ this -> stackTraces ) ? $ this -> stackTraces [ $ queryId ] : '' ; $ queryModel -> init ( $ queryProfile , $ stacktrace ) ; $ queries [ ] = $ queryModel ; } return $ queries ; } 
public function initFromAction ( $ action ) { if ( ! $ action ) { return ; } $ request = $ action -> getRequest ( ) ; $ this -> httpMethod = $ request -> getMethod ( ) ; $ this -> requestOriginalPath = $ request -> getOriginalPathInfo ( ) ; $ this -> requestPath = $ request -> getPathInfo ( ) ; $ this -> remoteIp = Mage :: helper ( 'core/http' ) -> getRemoteAddr ( ) ; $ this -> routeName = $ request -> getRouteName ( ) ; $ this -> module = $ request -> getControllerModule ( ) ; $ this -> class = get_class ( $ action ) ; $ this -> action = $ action -> getActionMethodName ( $ request -> getActionName ( ) ) ; } 
public function initFromGlobals ( ) { $ helper = Mage :: helper ( 'sheep_debug/http' ) ; $ this -> httpMethod = $ helper -> getHttpMethod ( ) ; $ this -> requestPath = $ this -> requestOriginalPath = $ helper -> getRequestPath ( ) ; $ this -> remoteIp = $ helper -> getRemoteAddr ( ) ; $ this -> serverParameters = $ helper -> getGlobalServer ( ) ; $ this -> requestHeaders = $ helper -> getAllHeaders ( ) ; $ this -> cookies = $ helper -> getGlobalCookie ( ) ; $ this -> session = $ helper -> getGlobalSession ( ) ; $ this -> getParameters = $ helper -> getGlobalGet ( ) ; $ this -> postParameters = $ helper -> getGlobalPost ( ) ; } 
public function addResponseInfo ( Mage_Core_Controller_Response_Http $ httpResponse ) { $ this -> responseCode = $ httpResponse -> getHttpResponseCode ( ) ; $ this -> responseHeaders = array ( ) ; $ headers = $ httpResponse -> getHeaders ( ) ; foreach ( $ headers as $ header ) { $ this -> responseHeaders [ $ header [ 'name' ] ] = $ header [ 'value' ] ; } } 
public function downloadAction ( ) { $ type = $ this -> getRequest ( ) -> getParam ( 'type' , 'xml' ) ; $ configNode = Mage :: app ( ) -> getConfig ( ) -> getNode ( ) ; switch ( $ type ) { case 'txt' ; $ this -> downloadAsText ( $ configNode ) ; break ; case 'xml' : default : $ this -> downloadAsXml ( $ configNode ) ; } } 
public function downloadAsText ( Mage_Core_Model_Config_Element $ configNode ) { $ items = array ( ) ; Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ configNode , $ items ) ; $ content = '' ; foreach ( $ items as $ key => $ value ) { $ content .= "$key = $value\n" ; } $ this -> _prepareDownloadResponse ( 'config.txt' , $ content , 'text/plain' ) ; } 
public function parentSend ( $ email , $ name = null , array $ variables = array ( ) ) { return parent :: send ( $ email , $ name , $ variables ) ; } 
public function send ( $ email , $ name = null , array $ variables = array ( ) ) { 
public function addEmailToProfile ( $ email , $ name , $ variables , $ result , Zend_Mail $ mail ) { $ emailCapture = Mage :: getModel ( 'sheep_debug/email' ) ; $ subject = $ this -> decodeSubject ( $ mail -> getSubject ( ) ) ; $ body = $ this -> getContent ( $ mail ) ; $ emailCapture -> setFromName ( $ this -> getSenderName ( ) ) ; $ emailCapture -> setFromEmail ( $ this -> getSenderEmail ( ) ) ; $ emailCapture -> setToEmail ( $ email ) ; $ emailCapture -> setToName ( $ name ) ; $ emailCapture -> setSubject ( $ subject ) ; $ emailCapture -> setIsPlain ( $ this -> isPlain ( ) ) ; $ emailCapture -> setBody ( $ body ) ; $ emailCapture -> setIsAccepted ( $ result ) ; $ emailCapture -> setVariables ( $ variables ) ; $ emailCapture -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) -> addEmail ( $ emailCapture ) ; } 
public function getContent ( Zend_Mail $ mail ) { $ hasQueue = $ this -> hasQueue ( ) ; if ( $ hasQueue && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageBody ( ) ; } $ mimePart = $ this -> isPlain ( ) ? $ mail -> getBodyText ( ) : $ mail -> getBodyHtml ( ) ; return $ mimePart ? $ this -> getPartDecodedContent ( $ mimePart ) : '' ; } 
public function getPartDecodedContent ( Zend_Mime_Part $ mimePart ) { 
public function decodeSubject ( $ subject ) { if ( $ this -> hasQueue ( ) && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageParameters ( 'subject' ) ; } return base64_decode ( substr ( $ subject , strlen ( '=?utf-8?B?' ) , - 1 * strlen ( '?=' ) ) ) ; } 
public function getModuleVersion ( ) { $ moduleConfig = $ this -> getConfig ( ) -> getModuleConfig ( $ this -> getModuleName ( ) ) ; return ( string ) $ moduleConfig -> version ; } 
public function runSql ( $ query , $ queryParams = array ( ) ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ statement = $ connection -> query ( $ query , $ queryParams ) ; return $ statement -> fetchAll ( PDO :: FETCH_ASSOC ) ; } 
public function xml2array ( $ xml , array & $ arr , $ parentKey = '' ) { if ( ! $ xml ) { return ; } if ( count ( $ xml -> children ( ) ) == 0 ) { $ arr [ $ parentKey ] = ( string ) $ xml ; } else { foreach ( $ xml -> children ( ) as $ key => $ item ) { $ key = $ parentKey ? $ parentKey . DS . $ key : $ key ; $ this -> xml2array ( $ item , $ arr , $ key ) ; } } return $ arr ; } 
public function formatNumber ( $ number , $ precision = 2 ) { $ locale = Mage :: app ( ) -> getLocale ( ) -> getLocale ( ) ; return Zend_Locale_Format :: toNumber ( $ number , array ( 'locale' => $ locale , 'precision' => $ precision ) ) ; } 
public function formatMemorySize ( $ size , $ precision = 2 ) { $ sizes = array ( " Bytes" , " KB" , " MB" , " GB" , " TB" , " PB" , " EB" , " ZB" , " YB" ) ; if ( $ size == 0 ) { return $ this -> __ ( 'n/a' ) ; } else { $ value = round ( $ size / pow ( 1000 , ( $ i = floor ( log ( $ size , 1000 ) ) ) ) , $ precision ) ; $ unitIndex = ( int ) $ i ; return $ this -> __ ( '%s%s' , $ this -> formatNumber ( $ value , $ precision ) , $ sizes [ $ unitIndex ] ) ; } } 
public function formatStacktrace ( array $ trace , $ stripFilepath = '' , $ trimPath = '' ) { $ out = '' ; foreach ( $ trace as $ index => $ row ) { if ( $ stripFilepath && isset ( $ row [ 'file' ] ) && strpos ( $ row [ 'file' ] , $ stripFilepath ) !== false ) { continue ; } if ( $ trimPath && isset ( $ row [ 'file' ] ) ) { $ row [ 'file' ] = str_replace ( $ trimPath , '' , $ row [ 'file' ] ) ; } if ( isset ( $ row [ 'file' ] ) ) { $ out .= "[$index] {$row['file']}:{$row['line']}\n" ; } else { 
public static function sortModelCmp ( $ a , $ b ) { if ( $ a -> getCount ( ) == $ b -> getCount ( ) ) return 0 ; return ( $ a -> getCount ( ) < $ b -> getCount ( ) ) ? 1 : - 1 ; } 
public function getLayoutUpdatesFiles ( $ storeId , $ designArea ) { $ updatesRoot = $ this -> getConfig ( ) -> getNode ( $ designArea . '/layout/updates' ) ; 
public function getBlockName ( Mage_Core_Block_Abstract $ block ) { $ blockName = $ block -> getParentBlock ( ) ? "{$block->getParentBlock()->getNameInLayout()}_{$block->getNameInLayout()}" : "{$block->getNameInLayout()}" ; if ( $ block -> getBlockAlias ( ) ) { $ blockName .= "_{$block->getBlockAlias()}" ; } return $ blockName ; } 
public function fire ( ) { $ filePath = $ this -> stringToType ( $ this -> option ( 'filepath' ) ) ; $ this -> filePath = ( is_string ( $ filePath ) ) ? base_path ( $ filePath ) : null ; $ allKeys = $ this -> editor -> load ( $ this -> filePath ) -> getKeys ( ) ; $ output = [ ] ; foreach ( $ allKeys as $ key => $ info ) { $ data = [ 'key' => $ key , 'export' => ( $ info [ 'export' ] ) ? 'true' : 'false' , 'value' => $ info [ 'value' ] , 'comment' => $ info [ 'comment' ] , 'line' => $ info [ 'line' ] ] ; $ output [ ] = $ data ; } $ total = count ( $ output ) ; $ headers = [ 'Key' , 'Use export' , 'Value' , 'Comment' , 'In line' ] ; $ this -> line ( 'Loading keys in your file...' ) ; $ this -> line ( '' ) ; $ this -> table ( $ headers , $ output ) ; $ this -> line ( '' ) ; $ this -> info ( "You have total {$total} keys in your file" ) ; } 
protected function stringToType ( $ string ) { if ( is_string ( $ string ) ) { switch ( true ) { case ( $ string == 'null' || $ string == 'NULL' ) : $ string = null ; break ; case ( $ string == 'true' || $ string == 'TRUE' ) : $ string = true ; break ; case ( $ string == 'false' || $ string == 'FALSE' ) : $ string = false ; break ; default : break ; } } return $ string ; } 
public function fire ( ) { $ filePath = $ this -> stringToType ( $ this -> option ( 'filepath' ) ) ; $ this -> filePath = ( is_string ( $ filePath ) ) ? base_path ( $ filePath ) : null ; $ this -> line ( 'Backing up your file...' ) ; $ backup = $ this -> editor -> load ( $ this -> filePath ) -> backup ( ) -> getLatestBackup ( ) ; $ this -> info ( "Your file was backed up successfully at path [{$backup['filepath']}]." ) ; } 
public function fire ( ) { $ headers = [ 'File name' , 'File path' , 'Created at' ] ; $ backups = ( $ this -> option ( 'latest' ) ) ? [ $ this -> editor -> getLatestBackup ( ) ] : $ this -> editor -> getBackups ( ) ; if ( $ this -> option ( 'latest' ) ) { $ latest = $ this -> editor -> getLatestBackup ( ) ; if ( ! is_null ( $ latest ) ) { $ backups = [ $ latest ] ; $ total = 1 ; } else { $ total = 0 ; } } else { $ backups = $ this -> editor -> getBackups ( ) ; $ total = count ( $ backups ) ; } $ this -> line ( 'Loading backup files...' ) ; $ this -> line ( '' ) ; if ( $ total == 0 ) { $ this -> info ( "You have not any backup file" ) ; } elseif ( $ total == 1 ) { $ this -> table ( $ headers , $ backups ) ; $ this -> line ( '' ) ; $ this -> info ( "There is 1 backup file found from your request" ) ; } else { $ this -> table ( $ headers , $ backups ) ; $ this -> line ( '' ) ; $ this -> info ( "There are {$total} backup files found from your request" ) ; } } 
public function fire ( ) { $ this -> transferInputsToProperties ( ) ; if ( ! $ this -> confirmToProceed ( ) ) { return false ; } $ this -> line ( 'Setting key in your file...' ) ; $ this -> editor -> load ( $ this -> filePath , $ this -> forceRestore , $ this -> restorePath ) ; $ this -> editor -> setKey ( $ this -> key , $ this -> value , $ this -> comment , $ this -> exportKey ) ; $ this -> editor -> save ( ) ; $ this -> info ( "The key [{$this->key}] is setted successfully with value [{$this->value}]." ) ; } 
protected function transferInputsToProperties ( ) { $ filePath = $ this -> stringToType ( $ this -> option ( 'filepath' ) ) ; $ this -> filePath = ( is_string ( $ filePath ) ) ? base_path ( $ filePath ) : null ; $ this -> forceRestore = $ this -> option ( 'restore' ) ; $ restorePath = $ this -> stringToType ( $ this -> option ( 'restore-path' ) ) ; $ this -> restorePath = ( is_string ( $ restorePath ) ) ? base_path ( $ restorePath ) : null ; $ this -> key = $ this -> argument ( 'key' ) ; $ this -> value = $ this -> stringToType ( $ this -> argument ( 'value' ) ) ; $ this -> comment = $ this -> stringToType ( $ this -> argument ( 'comment' ) ) ; $ this -> exportKey = $ this -> option ( 'export-key' ) ; } 
public function fire ( ) { $ this -> transferInputsToProperties ( ) ; if ( ! $ this -> confirmToProceed ( ) ) { return false ; } $ this -> line ( 'Restoring your file...' ) ; $ this -> editor -> load ( $ this -> filePath ) -> restore ( $ this -> restorePath ) ; $ this -> info ( "Your file is restored successfully" ) ; } 
protected function transferInputsToProperties ( ) { $ filePath = $ this -> stringToType ( $ this -> option ( 'filepath' ) ) ; $ this -> filePath = ( is_string ( $ filePath ) ) ? base_path ( $ filePath ) : null ; $ restorePath = $ this -> stringToType ( $ this -> option ( 'restore-path' ) ) ; $ this -> restorePath = ( is_string ( $ restorePath ) ) ? base_path ( $ restorePath ) : null ; } 
protected function ensureFileIsWritable ( $ filePath ) { if ( ( is_file ( $ filePath ) && ! is_writable ( $ filePath ) ) || ( ! is_file ( $ filePath ) && ! is_writable ( dirname ( $ filePath ) ) ) ) { throw new UnableWriteToFileException ( sprintf ( 'Unable to write to the file at %s.' , $ filePath ) ) ; } } 
public function appendSetter ( $ key , $ value = null , $ comment = null , $ export = false ) { $ line = $ this -> formatter -> formatSetterLine ( $ key , $ value , $ comment , $ export ) ; return $ this -> appendLine ( $ line ) ; } 
public function updateSetter ( $ key , $ value = null , $ comment = null , $ export = false ) { $ pattern = "/^(export\h)?\h*{$key}=.*/m" ; $ line = $ this -> formatter -> formatSetterLine ( $ key , $ value , $ comment , $ export ) ; $ this -> buffer = preg_replace ( $ pattern , $ line , $ this -> buffer ) ; return $ this ; } 
public function deleteSetter ( $ key ) { $ pattern = "/^(export\h)?\h*{$key}=.*\n/m" ; $ this -> buffer = preg_replace ( $ pattern , null , $ this -> buffer ) ; return $ this ; } 
public function save ( $ filePath ) { $ this -> ensureFileIsWritable ( $ filePath ) ; file_put_contents ( $ filePath , $ this -> buffer ) ; return $ this ; } 
protected function ensureFileIsReadable ( ) { if ( ! is_readable ( $ this -> filePath ) || ! is_file ( $ this -> filePath ) ) { throw new UnableReadFileException ( sprintf ( 'Unable to read the file at %s.' , $ this -> filePath ) ) ; } } 
public function lines ( ) { $ content = [ ] ; $ lines = $ this -> readLinesFromFile ( ) ; foreach ( $ lines as $ row => $ line ) { $ data = [ 'line' => $ row + 1 , 'raw_data' => $ line , 'parsed_data' => $ this -> formatter -> parseLine ( $ line ) ] ; $ content [ ] = $ data ; } return $ content ; } 
public function formatSetterLine ( $ key , $ value = null , $ comment = null , $ export = false ) { $ forceQuotes = ( strlen ( $ comment ) > 0 && strlen ( trim ( $ value ) ) == 0 ) ; $ value = $ this -> formatValue ( $ value , $ forceQuotes ) ; $ key = $ this -> formatKey ( $ key ) ; $ comment = $ this -> formatComment ( $ comment ) ; $ export = $ export ? 'export ' : '' ; $ line = "{$export}{$key}={$value}{$comment}" ; return $ line ; } 
public function normaliseValue ( $ value , $ quote = '' ) { if ( strlen ( $ quote ) == 0 ) { return trim ( $ value ) ; } $ value = str_replace ( "\\$quote" , $ quote , $ value ) ; $ value = str_replace ( '\\\\' , '\\' , $ value ) ; return $ value ; } 
public function parseLine ( $ line ) { $ output = [ 'type' => null , 'export' => null , 'key' => null , 'value' => null , 'comment' => null , ] ; if ( $ this -> isEmpty ( $ line ) ) { $ output [ 'type' ] = 'empty' ; } elseif ( $ this -> isComment ( $ line ) ) { $ output [ 'type' ] = 'comment' ; $ output [ 'comment' ] = $ this -> normaliseComment ( $ line ) ; } elseif ( $ this -> looksLikeSetter ( $ line ) ) { list ( $ key , $ data ) = array_map ( 'trim' , explode ( '=' , $ line , 2 ) ) ; $ export = $ this -> isExportKey ( $ key ) ; $ key = $ this -> normaliseKey ( $ key ) ; $ data = trim ( $ data ) ; if ( ! $ data && $ data !== '0' ) { $ value = '' ; $ comment = '' ; } else { if ( $ this -> beginsWithAQuote ( $ data ) ) { %1$s # match a quote at the start of the data ( # capturing sub-pattern used (?: # we do not need to capture this [^%1$s\\\\] # any character other than a quote or backslash |\\\\\\\\ # or two backslashes together |\\\\%1$s # or an escaped quote e.g \" )* # as many characters that match the previous rules ) # end of the capturing sub-pattern %1$s # and the closing quote (.*)$ # and discard any string after the closing quote /mx' , $ quote ) ; $ value = preg_replace ( $ regexPattern , '$1' , $ data ) ; $ extant = preg_replace ( $ regexPattern , '$2' , $ data ) ; $ value = $ this -> normaliseValue ( $ value , $ quote ) ; $ comment = ( $ this -> isComment ( $ extant ) ) ? $ this -> normaliseComment ( $ extant ) : '' ; } else { $ parts = explode ( ' #' , $ data , 2 ) ; $ value = $ this -> normaliseValue ( $ parts [ 0 ] ) ; $ comment = ( isset ( $ parts [ 1 ] ) ) ? $ this -> normaliseComment ( $ parts [ 1 ] ) : '' ; // Unquoted values cannot contain whitespace if ( preg_match ( '/\s+/' , $ value ) > 0 ) { throw new InvalidValueException ( 'Dotenv values containing spaces must be surrounded by quotes.' ) ; } } } $ output [ 'type' ] = 'setter' ; $ output [ 'export' ] = $ export ; $ output [ 'key' ] = $ key ; $ output [ 'value' ] = $ value ; $ output [ 'comment' ] = $ comment ; } else { $ output [ 'type' ] = 'unknown' ; } return $ output ; } 
public function load ( $ filePath = null , $ restoreIfNotFound = false , $ restorePath = null ) { $ this -> resetContent ( ) ; if ( ! is_null ( $ filePath ) ) { $ this -> filePath = $ filePath ; } else { if ( method_exists ( $ this -> app , 'environmentPath' ) && method_exists ( $ this -> app , 'environmentFile' ) ) { $ this -> filePath = $ this -> app -> environmentPath ( ) . '/' . $ this -> app -> environmentFile ( ) ; } else { $ this -> filePath = __DIR__ . '/../../../../../../.env' ; } } $ this -> reader -> load ( $ this -> filePath ) ; if ( file_exists ( $ this -> filePath ) ) { $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; } elseif ( $ restoreIfNotFound ) { return $ this -> restore ( $ restorePath ) ; } else { return $ this ; } } 
protected function resetContent ( ) { $ this -> filePath = null ; $ this -> reader -> load ( null ) ; $ this -> writer -> setBuffer ( null ) ; } 
public function getKeys ( $ keys = [ ] ) { $ allKeys = $ this -> reader -> keys ( ) ; return array_filter ( $ allKeys , function ( $ key ) use ( $ keys ) { if ( ! empty ( $ keys ) ) { return in_array ( $ key , $ keys ) ; } return true ; } , ARRAY_FILTER_USE_KEY ) ; } 
public function keyExists ( $ key ) { $ allKeys = $ this -> getKeys ( ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return true ; } return false ; } 
public function getValue ( $ key ) { $ allKeys = $ this -> getKeys ( [ $ key ] ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return $ allKeys [ $ key ] [ 'value' ] ; } throw new KeyNotFoundException ( 'Requested key not found in your file.' ) ; } 
public function setKeys ( $ data ) { foreach ( $ data as $ setter ) { if ( array_key_exists ( 'key' , $ setter ) ) { $ key = $ this -> formatter -> formatKey ( $ setter [ 'key' ] ) ; $ value = array_key_exists ( 'value' , $ setter ) ? $ setter [ 'value' ] : null ; $ comment = array_key_exists ( 'comment' , $ setter ) ? $ setter [ 'comment' ] : null ; $ export = array_key_exists ( 'export' , $ setter ) ? $ setter [ 'export' ] : false ; if ( ! is_file ( $ this -> filePath ) || ! $ this -> keyExists ( $ key ) ) { $ this -> writer -> appendSetter ( $ key , $ value , $ comment , $ export ) ; } else { $ oldInfo = $ this -> getKeys ( [ $ key ] ) ; $ comment = is_null ( $ comment ) ? $ oldInfo [ $ key ] [ 'comment' ] : $ comment ; $ this -> writer -> updateSetter ( $ key , $ value , $ comment , $ export ) ; } } } return $ this ; } 
public function setKey ( $ key , $ value = null , $ comment = null , $ export = false ) { $ data = [ compact ( 'key' , 'value' , 'comment' , 'export' ) ] ; return $ this -> setKeys ( $ data ) ; } 
public function deleteKeys ( $ keys = [ ] ) { foreach ( $ keys as $ key ) { $ this -> writer -> deleteSetter ( $ key ) ; } return $ this ; } 
public function save ( ) { if ( is_file ( $ this -> filePath ) && $ this -> autoBackup ) { $ this -> backup ( ) ; } $ this -> writer -> save ( $ this -> filePath ) ; return $ this ; } 
public function backup ( ) { if ( ! is_file ( $ this -> filePath ) ) { throw new FileNotFoundException ( "File does not exist at path {$this->filePath}" ) ; return false ; } copy ( $ this -> filePath , $ this -> backupPath . self :: BACKUP_FILENAME_PREFIX . date ( 'Y_m_d_His' ) . self :: BACKUP_FILENAME_SUFFIX ) ; return $ this ; } 
public function getBackups ( ) { $ backups = array_diff ( scandir ( $ this -> backupPath ) , array ( '..' , '.' ) ) ; $ output = [ ] ; foreach ( $ backups as $ backup ) { $ filenamePrefix = preg_quote ( self :: BACKUP_FILENAME_PREFIX , '/' ) ; $ filenameSuffix = preg_quote ( self :: BACKUP_FILENAME_SUFFIX , '/' ) ; $ filenameRegex = '/^' . $ filenamePrefix . '(\d{4})_(\d{2})_(\d{2})_(\d{2})(\d{2})(\d{2})' . $ filenameSuffix . '$/' ; $ datetime = preg_replace ( $ filenameRegex , '$1-$2-$3 $4:$5:$6' , $ backup ) ; $ data = [ 'filename' => $ backup , 'filepath' => $ this -> backupPath . $ backup , 'created_at' => $ datetime , ] ; $ output [ ] = $ data ; } return $ output ; } 
public function restore ( $ filePath = null ) { if ( is_null ( $ filePath ) ) { $ latestBackup = $ this -> getLatestBackup ( ) ; if ( is_null ( $ latestBackup ) ) { throw new NoBackupAvailableException ( "There are no available backups!" ) ; } $ filePath = $ latestBackup [ 'filepath' ] ; } if ( ! is_file ( $ filePath ) ) { throw new FileNotFoundException ( "File does not exist at path {$filePath}" ) ; } copy ( $ filePath , $ this -> filePath ) ; $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; } 
public function deleteBackups ( $ filePaths = [ ] ) { if ( empty ( $ filePaths ) ) { $ allBackups = $ this -> getBackups ( ) ; foreach ( $ allBackups as $ backup ) { $ filePaths [ ] = $ backup [ 'filepath' ] ; } } foreach ( $ filePaths as $ filePath ) { if ( is_file ( $ filePath ) ) { unlink ( $ filePath ) ; } } return $ this ; } 
public function boot ( ) { $ packageConfigPath = __DIR__ . '/../../config/config.php' ; $ appConfigPath = config_path ( 'dotenv-editor.php' ) ; $ this -> mergeConfigFrom ( $ packageConfigPath , 'dotenv-editor' ) ; $ this -> publishes ( [ $ packageConfigPath => $ appConfigPath , ] , 'config' ) ; } 
public function fire ( ) { $ this -> transferInputsToProperties ( ) ; if ( ! $ this -> confirmToProceed ( ) ) { return false ; } $ this -> line ( 'Deleting key in your file...' ) ; $ this -> editor -> load ( $ this -> filePath ) -> deleteKey ( $ this -> key ) -> save ( ) ; $ this -> info ( "The key [{$this->key}] is deletted successfully." ) ; } 
protected function transferInputsToProperties ( ) { $ filePath = $ this -> stringToType ( $ this -> option ( 'filepath' ) ) ; $ this -> filePath = ( is_string ( $ filePath ) ) ? base_path ( $ filePath ) : null ; $ this -> key = $ this -> argument ( 'key' ) ; } 
public static function linearUnitFactory ( $ name , $ toNativeUnitFactor ) { return new static ( $ name , function ( $ valueInNativeUnit ) use ( $ toNativeUnitFactor ) { return $ valueInNativeUnit / $ toNativeUnitFactor ; } , function ( $ valueInThisUnit ) use ( $ toNativeUnitFactor ) { return $ valueInThisUnit * $ toNativeUnitFactor ; } ) ; } 
public static function addUnit ( UnitOfMeasureInterface $ unit ) { if ( static :: unitNameOrAliasesAlreadyRegistered ( $ unit ) ) { throw new Exception \ DuplicateUnitNameOrAlias ( [ ':labels' => implode ( ', ' , array_merge ( [ $ unit -> getName ( ) ] , $ unit -> getAliases ( ) ) ) ] ) ; } static :: $ unitDefinitions [ ] = $ unit ; } 
public static function getUnit ( $ unit ) { 
protected static function unitNameOrAliasesAlreadyRegistered ( UnitOfMeasureInterface $ unit ) { 
protected static function addMissingSIPrefixedUnits ( UnitOfMeasure $ siUnit , $ toBaseSiUnitFactor , $ namePattern , array $ aliasPatterns = [ ] ) { $ siPrefixes = [ [ 'abbr_prefix' => 'Y' , 'long_prefix' => 'yotta' , 'factor' => 1e24 ] , [ 'abbr_prefix' => 'Z' , 'long_prefix' => 'zetta' , 'factor' => 1e21 ] , [ 'abbr_prefix' => 'E' , 'long_prefix' => 'exa' , 'factor' => 1e18 ] , [ 'abbr_prefix' => 'P' , 'long_prefix' => 'peta' , 'factor' => 1e15 ] , [ 'abbr_prefix' => 'T' , 'long_prefix' => 'tera' , 'factor' => 1e12 ] , [ 'abbr_prefix' => 'G' , 'long_prefix' => 'giga' , 'factor' => 1e9 ] , [ 'abbr_prefix' => 'M' , 'long_prefix' => 'mega' , 'factor' => 1e6 ] , [ 'abbr_prefix' => 'k' , 'long_prefix' => 'kilo' , 'factor' => 1e3 ] , [ 'abbr_prefix' => 'h' , 'long_prefix' => 'hecto' , 'factor' => 1e2 ] , [ 'abbr_prefix' => 'da' , 'long_prefix' => 'deca' , 'factor' => 1e1 ] , [ 'abbr_prefix' => '' , 'long_prefix' => '' , 'factor' => 1 ] , [ 'abbr_prefix' => 'd' , 'long_prefix' => 'deci' , 'factor' => 1e-1 ] , [ 'abbr_prefix' => 'c' , 'long_prefix' => 'centi' , 'factor' => 1e-2 ] , [ 'abbr_prefix' => 'm' , 'long_prefix' => 'milli' , 'factor' => 1e-3 ] , [ 'abbr_prefix' => 'µ', 'long_prefix' => 'micro' , 'factor' => 1e-6 ] , [ 'abbr_prefix' => 'n' , 'long_prefix' => 'nano' , 'factor' => 1e-9 ] , [ 'abbr_prefix' => 'p' , 'long_prefix' => 'pico' , 'factor' => 1e-12 ] , [ 'abbr_prefix' => 'f' , 'long_prefix' => 'femto' , 'factor' => 1e-15 ] , [ 'abbr_prefix' => 'a' , 'long_prefix' => 'atto' , 'factor' => 1e-18 ] , [ 'abbr_prefix' => 'z' , 'long_prefix' => 'zepto' , 'factor' => 1e-21 ] , [ 'abbr_prefix' => 'y' , 'long_prefix' => 'yocto' , 'factor' => 1e-24 ] , ] ; 
public function boot ( Router $ router , Kernel $ kernel ) { $ this -> publishes ( [ __DIR__ . '/../Config/brandenburg.php' => config_path ( 'brandenburg.php' ) , ] , 'brandenburg-config' ) ; if ( ! $ this -> app -> make ( Config :: class ) -> get ( 'brandenburg.ignoreMigrations' , false ) ) { $ this -> loadMigrationsFrom ( __DIR__ . '/../Database/Migrations' ) ; } else { $ this -> publishes ( [ __DIR__ . '/../Database/Migrations' => database_path ( 'migrations' ) , ] , 'brandenburg-migrations' ) ; } $ this -> registerPolicy ( ) ; } 
public function hasRoleWithPermission ( $ permission ) { return $ this -> roles -> contains ( function ( $ role ) use ( $ permission ) { return $ role -> getPermissions -> contains ( 'permission_slug' , $ permission ) ; } ) ; } 
public function assignRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> attach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> attach ( $ role ) ; } 
public function removeRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> detach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> detach ( $ role ) ; } 
public function setRolesById ( $ roles ) { $ roles = is_array ( $ roles ) ? $ roles : [ $ roles ] ; return $ this -> roles ( ) -> sync ( $ roles ) ; } 
public function setPermissions ( array $ permissions ) { if ( ! $ this -> id ) { $ this -> save ( ) ; } $ this -> revokeAll ( ) ; collect ( $ permissions ) -> map ( function ( $ permission ) { $ this -> grant ( $ permission ) ; } ) ; } 
public function grant ( $ permission ) { if ( $ this -> hasPermission ( $ permission ) ) { return true ; } if ( ! array_key_exists ( $ permission , Gate :: abilities ( ) ) ) { abort ( 403 , 'Unknown permission' ) ; } return Permission :: create ( [ 'role_id' => $ this -> id , 'permission_slug' => $ permission , ] ) ; return false ; } 
public function setPermissionsAttribute ( array $ permissions ) { if ( ! $ this -> id ) { $ this -> save ( ) ; } $ this -> revokeAll ( ) ; collect ( $ permissions ) -> map ( function ( $ permission ) { if ( ! in_array ( $ permission , Policy :: all ( ) ) ) { return ; } $ this -> grant ( $ permission ) ; } ) ; } 
public function withFile ( $ file ) { $ stream = Psr7 \ stream_for ( $ file ) ; $ this -> file = $ stream ; return $ this ; } 
public static function encodeURI ( $ url ) { $ unescaped = array ( '%2D' => '-' , '%5F' => '_' , '%2E' => '.' , '%21' => '!' , '%7E' => '~' , '%2A' => '*' , '%27' => "'" , '%28' => '(' , '%29' => ')' ) ; $ reserved = array ( '%3B' => ';' , '%2C' => ',' , '%2F' => '/' , '%3F' => '?' , '%3A' => ':' , '%40' => '@' , '%26' => '&' , '%3D' => '=' , '%2B' => '+' , '%24' => '$' ) ; $ score = array ( '%23' => '#' ) ; return strtr ( rawurlencode ( $ url ) , array_merge ( $ reserved , $ unescaped , $ score ) ) ; } 
public static function getHeaderSign ( $ serviceConfig , $ method , $ path , $ contentMd5 = null ) { $ gmtDate = gmdate ( 'D, d M Y H:i:s \G\M\T' ) ; $ policy = null ; $ sign = self :: getBodySignature ( $ serviceConfig , $ method , $ path , $ gmtDate , $ policy , $ contentMd5 ) ; $ headers = array ( 'Authorization' => $ sign , 'Date' => $ gmtDate , 'User-agent' => 'Php-Sdk/' . $ serviceConfig -> getVersion ( ) ) ; return $ headers ; } 
public static function getPurgeSignHeader ( Config $ serviceConfig , $ urlString ) { $ gmtDate = gmdate ( 'D, d M Y H:i:s \G\M\T' ) ; $ sign = md5 ( "$urlString&{$serviceConfig->serviceName}&$gmtDate&{$serviceConfig->operatorPassword}" ) ; return array ( 'Authorization' => "UpYun {$serviceConfig->serviceName}:{$serviceConfig->operatorName}:$sign" , 'Date' => $ gmtDate , 'User-agent' => 'Php-Sdk/' . $ serviceConfig -> getVersion ( ) . ' (purge api)' ) ; } 
public static function getBodySignature ( Config $ serviceConfig , $ method , $ uri , $ date = null , $ policy = null , $ contentMd5 = null ) { $ data = array ( $ method , $ uri ) ; if ( $ date ) { $ data [ ] = $ date ; } if ( $ policy ) { $ data [ ] = $ policy ; } if ( $ contentMd5 ) { $ data [ ] = $ contentMd5 ; } $ signature = base64_encode ( hash_hmac ( 'sha1' , implode ( '&' , $ data ) , $ serviceConfig -> operatorPassword , true ) ) ; return 'UPYUN ' . $ serviceConfig -> operatorName . ':' . $ signature ; } 
public function release ( $ version ) { $ package = 'upyun/sdk' ; $ name = 'php-sdk' ; $ collection = $ this -> collectionBuilder ( ) ; $ workingPath = __DIR__ . DIRECTORY_SEPARATOR . $ collection -> workDir ( "release" ) ; $ collection -> taskExec ( "composer create-project {$package} {$name} {$version}" ) -> dir ( $ workingPath ) -> arg ( '--prefer-dist' ) -> arg ( '--no-dev' ) -> arg ( '-vvv' ) -> taskExec ( 'composer dump-autoload --optimize' ) -> dir ( $ workingPath . DIRECTORY_SEPARATOR . $ name ) -> arg ( '-vvv' ) ; $ collection -> run ( ) ; $ zipFile = "release/{$name}-{$version}.zip" ; $ this -> _remove ( $ zipFile ) ; $ this -> taskPack ( $ zipFile ) -> addDir ( "php-sdk" , __DIR__ . "/release/php-sdk" ) -> run ( ) ; $ this -> _deleteDir ( "release/$name" ) ; } 
private function pointUpload ( $ path , $ stream , $ params ) { $ req = new Rest ( $ this -> config ) ; $ headers = array ( ) ; if ( is_array ( $ params ) ) { foreach ( $ params as $ key => $ val ) { $ headers [ 'X-Upyun-Meta-' . $ key ] = $ val ; } } $ res = $ req -> request ( 'PUT' , $ path ) -> withHeaders ( array_merge ( array ( 'X-Upyun-Multi-Stage' => 'initiate' , 'X-Upyun-Multi-Type' => Psr7 \ mimetype_from_filename ( $ path ) , 'X-Upyun-Multi-Length' => $ stream -> getSize ( ) , ) , $ headers ) ) -> send ( ) ; if ( $ res -> getStatusCode ( ) !== 204 ) { throw new \ Exception ( 'init request failed when poinit upload!' ) ; } $ init = Util :: getHeaderParams ( $ res -> getHeaders ( ) ) ; $ uuid = $ init [ 'x-upyun-multi-uuid' ] ; $ blockSize = 1024 * 1024 ; $ partId = 0 ; do { $ fileBlock = $ stream -> read ( $ blockSize ) ; $ res = $ req -> request ( 'PUT' , $ path ) -> withHeaders ( array ( 'X-Upyun-Multi-Stage' => 'upload' , 'X-Upyun-Multi-Uuid' => $ uuid , 'X-Upyun-Part-Id' => $ partId ) ) -> withFile ( Psr7 \ stream_for ( $ fileBlock ) ) -> send ( ) ; if ( $ res -> getStatusCode ( ) !== 204 ) { throw new \ Exception ( 'upload request failed when poinit upload!' ) ; } $ data = Util :: getHeaderParams ( $ res -> getHeaders ( ) ) ; $ partId = $ data [ 'x-upyun-next-part-id' ] ; } while ( $ partId != - 1 ) ; $ res = $ req -> request ( 'PUT' , $ path ) -> withHeaders ( array ( 'X-Upyun-Multi-Uuid' => $ uuid , 'X-Upyun-Multi-Stage' => 'complete' ) ) -> send ( ) ; if ( $ res -> getStatusCode ( ) != 204 && $ res -> getStatusCode ( ) != 201 ) { throw new \ Exception ( 'end request failed when poinit upload!' ) ; } return $ res ; } 
private function concurrentPointUpload ( $ path , $ stream , $ params ) { $ req = new Rest ( $ this -> config ) ; $ headers = array ( ) ; if ( is_array ( $ params ) ) { foreach ( $ params as $ key => $ val ) { $ headers [ 'X-Upyun-Meta-' . $ key ] = $ val ; } } $ res = $ req -> request ( 'PUT' , $ path ) -> withHeaders ( array_merge ( array ( 'X-Upyun-Multi-Disorder' => 'true' , 'X-Upyun-Multi-Stage' => 'initiate' , 'X-Upyun-Multi-Type' => Psr7 \ mimetype_from_filename ( $ path ) , 'X-Upyun-Multi-Length' => $ stream -> getSize ( ) , ) , $ headers ) ) -> send ( ) ; if ( $ res -> getStatusCode ( ) !== 204 ) { throw new \ Exception ( 'init request failed when poinit upload!' ) ; } $ init = Util :: getHeaderParams ( $ res -> getHeaders ( ) ) ; $ uuid = $ init [ 'x-upyun-multi-uuid' ] ; $ requests = function ( $ req , $ path , $ stream , $ uuid ) { $ blockSize = 1024 * 1024 ; $ total = ceil ( $ stream -> getSize ( ) / $ blockSize ) ; for ( $ i = 0 ; $ i < $ total ; $ i ++ ) { $ fileBlock = $ stream -> read ( $ blockSize ) ; yield $ req -> request ( 'PUT' , $ path ) -> withHeaders ( array ( 'X-Upyun-Multi-Stage' => 'upload' , 'X-Upyun-Multi-Uuid' => $ uuid , 'X-Upyun-Part-Id' => $ i ) ) -> withFile ( Psr7 \ stream_for ( $ fileBlock ) ) -> toRequest ( ) ; } } ; $ client = new Client ( [ 'timeout' => $ this -> config -> timeout , ] ) ; $ pool = new Pool ( $ client , $ requests ( $ req , $ path , $ stream , $ uuid ) , [ 'concurrency' => $ this -> config -> concurrency , 'fulfilled' => function ( $ res ) { if ( $ res -> getStatusCode ( ) !== 204 ) { throw new \ Exception ( 'upload request failed when poinit upload!' ) ; } } , 'rejected' => function ( ) { throw new \ Exception ( 'upload request failed when poinit upload!' ) ; } , ] ) ; $ promise = $ pool -> promise ( ) ; $ promise -> wait ( ) ; $ res = $ req -> request ( 'PUT' , $ path ) -> withHeaders ( array ( 'X-Upyun-Multi-Uuid' => $ uuid , 'X-Upyun-Multi-Stage' => 'complete' ) ) -> send ( ) ; if ( $ res -> getStatusCode ( ) != 204 && $ res -> getStatusCode ( ) != 201 ) { throw new \ Exception ( 'end request failed when poinit upload!' ) ; } return $ res ; } 
public function write ( $ path , $ content , $ params = array ( ) , $ withAsyncProcess = false ) { if ( ! $ content ) { throw new \ Exception ( 'write content can not be empty.' ) ; } $ upload = new Uploader ( $ this -> config ) ; $ response = $ upload -> upload ( $ path , $ content , $ params , $ withAsyncProcess ) ; if ( $ withAsyncProcess ) { return $ response ; } return Util :: getHeaderParams ( $ response -> getHeaders ( ) ) ; } 
public function read ( $ path , $ saveHandler = null , $ params = array ( ) ) { $ req = new Rest ( $ this -> config ) ; $ response = $ req -> request ( 'GET' , $ path ) -> withHeaders ( $ params ) -> send ( ) ; $ params = Util :: getHeaderParams ( $ response -> getHeaders ( ) ) ; if ( ! isset ( $ params [ 'x-upyun-list-iter' ] ) ) { if ( is_resource ( $ saveHandler ) ) { Psr7 \ copy_to_stream ( $ response -> getBody ( ) , Psr7 \ stream_for ( $ saveHandler ) ) ; return true ; } else { return $ response -> getBody ( ) -> getContents ( ) ; } } else { $ files = Util :: parseDir ( $ response -> getBody ( ) -> getContents ( ) ) ; return array ( 'files' => $ files , 'is_end' => $ params [ 'x-upyun-list-iter' ] === 'g2gCZAAEbmV4dGQAA2VvZg' , 'iter' => $ params [ 'x-upyun-list-iter' ] ) ; } } 
public function has ( $ path ) { $ req = new Rest ( $ this -> config ) ; try { $ req -> request ( 'HEAD' , $ path ) -> send ( ) ; } catch ( GuzzleHttp \ Exception \ BadResponseException $ e ) { $ statusCode = $ e -> getResponse ( ) -> getStatusCode ( ) ; if ( $ statusCode === 404 ) { return false ; } else { throw $ e ; } } return true ; } 
public function info ( $ path , $ otherHeaders = array ( ) ) { $ req = new Rest ( $ this -> config ) ; $ response = $ req -> request ( 'HEAD' , $ path ) -> send ( ) ; return Util :: getHeaderParams ( $ response -> getHeaders ( ) , $ otherHeaders ) ; } 
public function getMimetype ( $ path ) { $ params = $ this -> info ( $ path , array ( 'content-type' ) ) ; if ( isset ( $ params [ 'content-type' ] ) ) { return explode ( ';' , $ params [ 'content-type' ] ) [ 0 ] ; } return '' ; } 
public function delete ( $ path , $ async = false ) { $ req = new Rest ( $ this -> config ) ; $ req -> request ( 'DELETE' , $ path ) ; if ( $ async ) { $ req -> withHeader ( 'x-upyun-async' , 'true' ) ; } $ res = $ req -> send ( ) ; return $ res -> getStatusCode ( ) === 200 ; } 
public function createDir ( $ path ) { $ path = rtrim ( $ path , '/' ) . '/' ; $ req = new Rest ( $ this -> config ) ; $ res = $ req -> request ( 'POST' , $ path ) -> withHeader ( 'folder' , 'true' ) -> send ( ) ; return $ res -> getStatusCode ( ) === 200 ; } 
public function usage ( $ path = '/' ) { $ path = rtrim ( $ path , '/' ) . '/' ; $ req = new Rest ( $ this -> config ) ; $ response = $ req -> request ( 'GET' , $ path . '?usage' ) -> send ( ) ; return $ response -> getBody ( ) -> getContents ( ) ; } 
public function purge ( $ urls ) { $ urlString = $ urls ; if ( is_array ( $ urls ) ) { $ urlString = implode ( "\n" , $ urls ) ; } $ client = new Client ( [ 'timeout' => $ this -> config -> timeout ] ) ; $ response = $ client -> request ( 'POST' , Config :: ED_PURGE , [ 'headers' => Signature :: getPurgeSignHeader ( $ this -> config , $ urlString ) , 'form_params' => [ 'purge' => $ urlString ] ] ) ; $ result = json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; return $ result [ 'invalid_domain_of_url' ] ; } 
public function process ( $ tasks , $ type , $ source = '' ) { $ video = new Api \ Pretreat ( $ this -> config ) ; $ options = array ( ) ; switch ( $ type ) { case self :: $ PROCESS_TYPE_MEDIA : $ options [ 'accept' ] = 'json' ; $ options [ 'source' ] = $ source ; break ; case self :: $ PROCESS_TYPE_ZIP : $ options [ 'app_name' ] = 'compress' ; break ; case self :: $ PROCESS_TYPE_UNZIP : $ options [ 'app_name' ] = 'depress' ; break ; case self :: $ PROCESS_TYPE_SYNC_FILE : $ options [ 'app_name' ] = 'spiderman' ; break ; case self :: $ PROCESS_TYPE_CONVERT : $ options [ 'app_name' ] = 'uconvert' ; break ; case self :: $ PROCESS_TYPE_STITCH : $ options [ 'app_name' ] = 'jigsaw' ; break ; default : throw new \ Exception ( 'upyun - not support process type.' ) ; } return $ video -> process ( $ tasks , $ options ) ; } 
public function queryProcessStatus ( $ taskIds ) { $ video = new Api \ Pretreat ( $ this -> config ) ; return $ video -> query ( $ taskIds , '/status/' ) ; } 
public function queryProcessResult ( $ taskIds ) { $ video = new Api \ Pretreat ( $ this -> config ) ; return $ video -> query ( $ taskIds , '/result/' ) ; } 
public function m3u8Concat ( $ files , $ saveAs ) { $ p = new Api \ SyncVideo ( $ this -> config ) ; return $ p -> process ( [ 'm3u8s' => $ files , 'save_as' => $ saveAs , ] , '/m3u8er/concat' ) ; } 
public function m3u8Clip ( $ file , $ saveAs , $ slice = array ( ) , $ isInclude = true , $ index = false ) { $ p = new Api \ SyncVideo ( $ this -> config ) ; $ params = [ 'm3u8' => $ file , 'save_as' => $ saveAs , 'index' => $ index , ] ; if ( $ isInclude ) { $ params [ 'include' ] = $ slice ; } else { $ params [ 'exclude' ] = $ slice ; } return $ p -> process ( $ params , '/m3u8er/clip' ) ; } 
public function m3u8Meta ( $ file ) { $ p = new Api \ SyncVideo ( $ this -> config ) ; return $ p -> process ( [ 'm3u8' => $ file , ] , '/m3u8er/get_meta' ) ; } 
public function snapshot ( $ file , $ saveAs , $ point , $ size = '' , $ format = '' ) { $ p = new Api \ SyncVideo ( $ this -> config ) ; $ params = [ 'source' => $ file , 'save_as' => $ saveAs , 'point' => $ point , ] ; if ( $ size ) { $ params [ 'size' ] = $ size ; } if ( $ format ) { $ params [ 'format' ] = $ format ; } return $ p -> process ( $ params , '/snapshot' ) ; } 
public function avMeta ( $ file ) { $ p = new Api \ SyncVideo ( $ this -> config ) ; return $ p -> process ( [ 'source' => $ file , ] , '/avmeta/get_meta' ) ; } 
protected function getBackground ( array $ setColor = [ ] ) { if ( $ setColor ) { return imagecolorallocate ( $ this -> resource , $ setColor [ 0 ] , $ setColor [ 1 ] , $ setColor [ 2 ] ) ; } return imagecolorallocatealpha ( $ this -> resource , 0 , 0 , 0 , 127 ) ; } 
public function generate ( $ width , $ height ) { $ sparkline = imagecreatetruecolor ( $ width , $ height ) ; imagealphablending ( $ sparkline , false ) ; imagecopyresampled ( $ sparkline , $ this -> resource , 0 , 0 , 0 , 0 , $ width , $ height , $ this -> width , $ this -> height ) ; imagesavealpha ( $ sparkline , true ) ; imagedestroy ( $ this -> resource ) ; return $ sparkline ; } 
protected function colorHexToRGB ( $ color ) { if ( ! $ this -> checkColorHex ( $ color ) ) { throw new \ InvalidArgumentException ( 'Invalid hexadecimal value ' . $ color ) ; } $ color = mb_strtolower ( $ color ) ; $ color = ltrim ( $ color , '#' ) ; if ( mb_strlen ( $ color ) === static :: HEXADECIMAL_ALIAS_LENGTH ) { $ color = $ color [ 0 ] . $ color [ 0 ] . $ color [ 1 ] . $ color [ 1 ] . $ color [ 2 ] . $ color [ 2 ] ; } $ color = hexdec ( $ color ) ; return [ 0xFF & ( $ color >> 0x10 ) , 
protected function paddingStringToArray ( $ padding ) { $ parts = explode ( ' ' , $ padding ) ; switch ( count ( $ parts ) ) { case static :: CSS_PADDING_ONE : $ value = ( float ) $ parts [ 0 ] ; return [ $ value , $ value , $ value , $ value ] ; break ; case static :: CSS_PADDING_TWO : $ verticalValue = ( float ) $ parts [ 0 ] ; $ horizontalValue = ( float ) $ parts [ 1 ] ; return [ $ verticalValue , $ horizontalValue , $ verticalValue , $ horizontalValue ] ; case static :: CSS_PADDING_THREE : $ parts [ 3 ] = $ parts [ 1 ] ; return $ parts ; case static :: CSS_PADDING : return $ parts ; default : throw new \ InvalidArgumentException ( 'Invalid padding format' ) ; } } 
public function setPadding ( $ padding ) { list ( $ top , $ right , $ bottom , $ left ) = $ this -> paddingStringToArray ( $ padding ) ; $ this -> padding [ 'top' ] = $ top ; $ this -> padding [ 'right' ] = $ right ; $ this -> padding [ 'bottom' ] = $ bottom ; $ this -> padding [ 'left' ] = $ left ; } 
protected function getDataForChartElements ( array $ data , $ height ) { $ max = $ this -> getMaxValue ( ) ; $ minHeight = 1 * $ this -> ratioComputing ; $ maxHeight = $ height - $ minHeight ; foreach ( $ data as $ i => $ value ) { $ value = ( int ) $ value ; if ( $ value <= 0 ) { $ value = 0 ; } if ( $ value > 0 ) { $ value = round ( ( $ value / $ max ) * $ height ) ; } $ data [ $ i ] = max ( $ minHeight , min ( $ value , $ maxHeight ) ) ; } return $ data ; } 
protected function getChartElements ( array $ data ) { $ count = count ( $ data ) ; $ step = $ this -> getStepWidth ( $ count ) ; $ height = $ this -> getInnerNormalizedHeight ( ) ; $ normalizedPadding = $ this -> getNormalizedPadding ( ) ; $ data = $ this -> getDataForChartElements ( $ data , $ height ) ; $ pictureX1 = $ pictureX2 = $ normalizedPadding [ 'left' ] ; $ pictureY1 = $ normalizedPadding [ 'top' ] + $ height - $ data [ 0 ] ; $ polygon = [ ] ; $ line = [ ] ; 
public function getServerValue ( $ key ) { if ( isset ( $ this -> server [ $ key ] ) ) { return $ this -> server [ $ key ] ; } return null ; } 
static public function create ( stdClass $ data ) { $ obj = new self ( ) ; $ vars = get_object_vars ( $ obj ) ; foreach ( $ data as $ property => $ value ) { if ( array_key_exists ( $ property , $ vars ) ) { $ obj -> $ property = $ value ; } } return $ obj ; } 
public function create ( Transaction $ transaction ) { $ createTransactionService = new CreateTransactionService ( $ this -> store , $ transaction , $ this -> logger ) ; $ createTransactionService -> platform ( $ this -> platform , $ this -> platformVersion ) ; return $ createTransactionService -> execute ( ) ; } 
public function cancel ( Transaction $ transaction ) { $ cancelTransactionService = new CancelTransactionService ( $ this -> store , $ transaction , $ this -> logger ) ; $ cancelTransactionService -> platform ( $ this -> platform , $ this -> platformVersion ) ; return $ cancelTransactionService -> execute ( ) ; } 
public function capture ( Transaction $ transaction ) { $ captureTransactionService = new CaptureTransactionService ( $ this -> store , $ transaction , $ this -> logger ) ; $ captureTransactionService -> platform ( $ this -> platform , $ this -> platformVersion ) ; return $ captureTransactionService -> execute ( ) ; } 
public function get ( $ tid ) { $ getTransactionService = new GetTransactionService ( $ this -> store , null , $ this -> logger ) ; $ getTransactionService -> platform ( $ this -> platform , $ this -> platformVersion ) ; $ getTransactionService -> setTid ( $ tid ) ; return $ getTransactionService -> execute ( ) ; } 
public function getByReference ( $ reference ) { $ getTransactionService = new GetTransactionService ( $ this -> store , null , $ this -> logger ) ; $ getTransactionService -> platform ( $ this -> platform , $ this -> platformVersion ) ; $ getTransactionService -> setReference ( $ reference ) ; return $ getTransactionService -> execute ( ) ; } 
public function getRefunds ( $ tid ) { $ getTransactionService = new GetTransactionService ( $ this -> store , null , $ this -> logger ) ; $ getTransactionService -> platform ( $ this -> platform , $ this -> platformVersion ) ; $ getTransactionService -> setTid ( $ tid ) ; $ getTransactionService -> setRefund ( true ) ; return $ getTransactionService -> execute ( ) ; } 
public function zero ( Transaction $ transaction ) { $ amount = ( int ) $ transaction -> getAmount ( ) ; $ capture = ( bool ) $ transaction -> getCapture ( ) ; $ transaction -> setAmount ( 0 ) ; $ transaction -> capture ( ) ; $ transaction = $ this -> create ( $ transaction ) ; $ transaction -> setAmount ( $ amount ) ; $ transaction -> capture ( $ capture ) ; return $ transaction ; } 
public function addFlight ( Flight $ flight ) { if ( $ this -> flight === null ) { $ this -> flight = [ ] ; } $ this -> flight [ ] = $ flight ; return $ this ; } 
public function addDocument ( $ type , $ number ) { if ( $ this -> documents === null ) { $ this -> documents = [ ] ; } $ document = new stdClass ( ) ; $ document -> type = $ type ; $ document -> number = $ number ; $ this -> documents [ ] = $ document ; return $ this ; } 
public function phone ( $ ddd , $ number , $ type = Phone :: CELLPHONE ) { return $ this -> setPhone ( new Phone ( $ ddd , $ number , $ type ) ) ; } 
public function addUrl ( $ url , $ kind = Url :: CALLBACK ) { if ( $ this -> urls == null ) { $ this -> urls = [ ] ; } $ this -> urls [ ] = new Url ( $ url , $ kind ) ; return $ this ; } 
public function antifraud ( Environment $ environment ) { $ cart = new Cart ( ) ; $ cart -> setEnvironment ( $ environment ) ; $ this -> setAntifraudRequired ( true ) ; $ this -> setCart ( $ cart ) ; return $ cart ; } 
public function additional ( $ gateway = null , $ module = null ) { $ this -> additional = new Additional ( ) ; $ this -> additional -> setGateway ( $ gateway ) ; $ this -> additional -> setModule ( $ module ) ; return $ this ; } 
public function creditCard ( $ cardNumber , $ cardCvv , $ expirationMonth , $ expirationYear , $ holderName ) { return $ this -> setCard ( $ cardNumber , $ cardCvv , $ expirationMonth , $ expirationYear , $ holderName , Transaction :: CREDIT ) ; } 
public function setCard ( $ cardNumber , $ securityCode , $ expirationMonth , $ expirationYear , $ cardHolderName , $ kind ) { $ this -> setCardNumber ( $ cardNumber ) ; $ this -> setSecurityCode ( $ securityCode ) ; $ this -> setExpirationMonth ( $ expirationMonth ) ; $ this -> setExpirationYear ( $ expirationYear ) ; $ this -> setCardHolderName ( $ cardHolderName ) ; $ this -> setKind ( $ kind ) ; return $ this ; } 
public function debitCard ( $ cardNumber , $ cardCvv , $ expirationMonth , $ expirationYear , $ holderName ) { $ this -> capture ( true ) ; return $ this -> setCard ( $ cardNumber , $ cardCvv , $ expirationMonth , $ expirationYear , $ holderName , Transaction :: DEBIT ) ; } 
public function capture ( $ capture = true ) { if ( ! $ capture && $ this -> kind === Transaction :: DEBIT ) { throw new InvalidArgumentException ( 'Debit transactions will always be captured' ) ; } $ this -> capture = $ capture ; return $ this ; } 
public function setIata ( $ code , $ departureTax ) { $ this -> iata = new Iata ( ) ; $ this -> iata -> setCode ( $ code ) ; $ this -> iata -> setDepartureTax ( $ departureTax ) ; return $ this ; } 
public function mcc ( $ softDescriptor , $ paymentFacilitatorID , SubMerchant $ subMerchant ) { $ this -> setSoftDescriptor ( $ softDescriptor ) ; $ this -> setPaymentFacilitatorID ( $ paymentFacilitatorID ) ; $ this -> setSubMerchant ( $ subMerchant ) ; return $ this ; } 
public function threeDSecure ( $ onFailure = ThreeDSecure :: DECLINE_ON_FAILURE , $ embed = true , $ directoryServerTransactionId = "" , $ threeDIndicator = "1" ) { $ threeDSecure = new ThreeDSecure ( ) ; $ threeDSecure -> setOnFailure ( $ onFailure ) ; $ threeDSecure -> setEmbedded ( $ embed ) ; $ threeDSecure -> setThreeDIndicator ( $ threeDIndicator ) ; $ threeDSecure -> setDirectoryServerTransactionId ( $ directoryServerTransactionId ) ; $ this -> threeDSecure = $ threeDSecure ; return $ this ; } 
public function addPassenger ( Passenger $ passenger ) { if ( $ this -> passenger === null ) { $ this -> passenger = [ ] ; } $ this -> passenger [ ] = $ passenger ; return $ this ; } 
protected function parseResponse ( $ response , $ statusCode ) { $ previous = null ; if ( $ this -> transaction === null ) { $ this -> transaction = new Transaction ( ) ; } try { $ this -> transaction -> jsonUnserialize ( $ response ) ; } catch ( InvalidArgumentException $ e ) { $ previous = $ e ; } if ( ( int ) $ statusCode >= 400 ) { throw new RedeException ( $ this -> transaction -> getReturnMessage ( ) , $ this -> transaction -> getReturnCode ( ) , $ previous ) ; } return $ this -> transaction ; } 
protected function sendRequest ( $ body = null , $ method = 'GET' ) { $ userAgent = sprintf ( 'User-Agent: %s' , sprintf ( eRede :: USER_AGENT , phpversion ( ) , $ this -> store -> getFiliation ( ) , php_uname ( 's' ) , php_uname ( 'r' ) , php_uname ( 'm' ) ) ) ; if ( ! empty ( $ this -> platform ) && ! empty ( $ this -> platformVersion ) ) { $ userAgent .= sprintf ( ' %s/%s' , $ this -> platform , $ this -> platformVersion ) ; } if ( is_resource ( $ this -> curl ) ) { curl_close ( $ this -> curl ) ; } $ curlVersion = curl_version ( ) ; if ( is_array ( $ curlVersion ) ) { $ userAgent .= sprintf ( ' curl/%s %s' , isset ( $ curlVersion [ 'version' ] ) ? $ curlVersion [ 'version' ] : '' , isset ( $ curlVersion [ 'ssl_version' ] ) ? $ curlVersion [ 'ssl_version' ] : '' ) ; } $ headers = [ str_replace ( ' ' , ' ' , $ userAgent ) , 'Accept: application/json' ] ; $ this -> curl = curl_init ( $ this -> store -> getEnvironment ( ) -> getEndpoint ( $ this -> getService ( ) ) ) ; curl_setopt ( $ this -> curl , CURLOPT_USERPWD , sprintf ( '%s:%s' , $ this -> store -> getFiliation ( ) , $ this -> store -> getToken ( ) ) ) ; if ( ! defined ( 'CURL_SSLVERSION_TLSv1_2' ) ) { define ( 'CURL_SSLVERSION_TLSv1_2' , 6 ) ; if ( $ this -> logger !== null ) { $ this -> logger -> alert ( 'Atenção, por motivos de segurança, recomendamos fortemente que você atualize a versão do seu PHP.'); } } curl_setopt ( $ this -> curl , CURLOPT_SSLVERSION , CURL_SSLVERSION_TLSv1_2 ) ; curl_setopt ( $ this -> curl , CURLOPT_SSL_VERIFYPEER , true ) ; switch ( $ method ) { case 'GET' : break ; case 'POST' : curl_setopt ( $ this -> curl , CURLOPT_POST , true ) ; break ; default : curl_setopt ( $ this -> curl , CURLOPT_CUSTOMREQUEST , $ method ) ; } if ( $ body !== null ) { curl_setopt ( $ this -> curl , CURLOPT_POSTFIELDS , $ body ) ; $ headers [ ] = 'Content-Type: application/json; charset=utf8' ; } else { $ headers [ ] = 'Content-Length: 0' ; } curl_setopt ( $ this -> curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ this -> curl , CURLOPT_HTTPHEADER , $ headers ) ; if ( $ this -> logger !== null ) { $ this -> logger -> debug ( trim ( sprintf ( "Request Rede\n%s %s\n%s\n\n%s" , $ method , $ this -> store -> getEnvironment ( ) -> getEndpoint ( $ this -> getService ( ) ) , implode ( "\n" , $ headers ) , preg_replace ( '/"(cardnumber|securitycode)":"[^"]+"/i' , '"\1":"***"' , $ body ) ) ) ) ; } $ response = curl_exec ( $ this -> curl ) ; $ statusCode = curl_getinfo ( $ this -> curl , CURLINFO_HTTP_CODE ) ; if ( $ this -> logger !== null ) { $ this -> logger -> debug ( sprintf ( "Response Rede\nStatus Code: %s\n\n%s" , $ statusCode , $ response ) ) ; } if ( curl_errno ( $ this -> curl ) ) { throw new RuntimeException ( 'Curl error: ' . curl_error ( $ this -> curl ) ) ; } curl_close ( $ this -> curl ) ; $ this -> curl = null ; return $ this -> parseResponse ( $ response , $ statusCode ) ; } 
public function address ( $ type = Address :: BOTH ) { $ address = new Address ( ) ; if ( $ type & Address :: BILLING == Address :: BILLING ) { $ this -> setBillingAddress ( $ address ) ; } if ( $ type & Address :: SHIPPING == Address :: SHIPPING ) { $ this -> setShippingAddress ( $ address ) ; } return $ address ; } 
public function addItem ( Item $ item ) { if ( $ this -> items == null ) { $ this -> items = [ ] ; } $ this -> items [ ] = $ item ; return $ this ; } 
public function addShippingAddress ( Address $ shippingAddress ) { if ( $ this -> shipping == null ) { $ this -> shipping = [ ] ; } $ this -> shipping [ ] = $ shippingAddress ; return $ this ; } 
public function consumer ( $ name , $ email , $ cpf ) { $ consumer = new Consumer ( $ name , $ email , $ cpf ) ; $ this -> setConsumer ( $ consumer ) ; return $ consumer ; } 
public function isPromise ( $ value , $ strict = false ) { $ isStrictPromise = $ value instanceof PromiseInterface ; if ( $ strict ) { return $ isStrictPromise ; } return $ isStrictPromise || is_callable ( [ $ value , 'then' ] ) ; } 
public function await ( $ promise = null , $ unwrap = false ) { if ( null === $ promise ) { return null ; } $ wait = true ; $ resolvedValue = null ; $ exception = null ; if ( ! static :: isPromise ( $ promise ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "%s" method must be called with a Promise ("then" method).' , __METHOD__ ) ) ; } $ promise -> then ( function ( $ values ) use ( & $ resolvedValue , & $ wait ) { $ resolvedValue = $ values ; $ wait = false ; } , function ( $ reason ) use ( & $ exception , & $ wait ) { $ exception = $ reason ; $ wait = false ; } ) ; if ( $ exception instanceof \ Exception ) { if ( ! $ unwrap ) { return $ exception ; } throw $ exception ; } return $ resolvedValue ; } 
public function create ( & $ resolve = null , & $ reject = null , callable $ canceller = null ) { $ queue = \ GuzzleHttp \ Promise \ queue ( ) ; $ promise = new Promise ( [ $ queue , 'run' ] , $ canceller ) ; $ reject = [ $ promise , 'reject' ] ; $ resolve = [ $ promise , 'resolve' ] ; return $ promise ; } 
public function createAll ( $ promisesOrValues ) { $ promise = empty ( $ promisesOrValues ) ? $ this -> createFulfilled ( $ promisesOrValues ) : \ GuzzleHttp \ Promise \ all ( $ promisesOrValues ) ; return $ promise ; } 
public function load ( $ key ) { $ this -> checkKey ( $ key , __METHOD__ ) ; 
public function loadMany ( $ keys ) { if ( ! is_array ( $ keys ) && ! $ keys instanceof \ Traversable ) { throw new \ InvalidArgumentException ( sprintf ( 'The "%s" method must be called with Array<key> but got: %s.' , __METHOD__ , gettype ( $ keys ) ) ) ; } return $ this -> getPromiseAdapter ( ) -> createAll ( array_map ( function ( $ key ) { return $ this -> load ( $ key ) ; } , $ keys ) ) ; } 
public function clear ( $ key ) { $ this -> checkKey ( $ key , __METHOD__ ) ; $ cacheKey = $ this -> getCacheKeyFromKey ( $ key ) ; $ this -> promiseCache -> clear ( $ cacheKey ) ; return $ this ; } 
public function prime ( $ key , $ value ) { $ this -> checkKey ( $ key , __METHOD__ ) ; $ cacheKey = $ this -> getCacheKeyFromKey ( $ key ) ; 
public static function await ( $ promise = null , $ unwrap = true ) { self :: awaitInstances ( ) ; if ( null === $ promise ) { return null ; } if ( is_callable ( [ $ promise , 'then' ] ) ) { $ isPromiseCompleted = false ; $ resolvedValue = null ; $ rejectedReason = null ; $ promise -> then ( function ( $ value ) use ( & $ isPromiseCompleted , & $ resolvedValue ) { $ isPromiseCompleted = true ; $ resolvedValue = $ value ; } , function ( $ reason ) use ( & $ isPromiseCompleted , & $ rejectedReason ) { $ isPromiseCompleted = true ; $ rejectedReason = $ reason ; } ) ; 
protected function getCacheKeyFromKey ( $ key ) { $ cacheKeyFn = $ this -> options -> getCacheKeyFn ( ) ; $ cacheKey = $ cacheKeyFn ? $ cacheKeyFn ( $ key ) : $ key ; return $ cacheKey ; } 
private function dispatchQueue ( ) { 
private function failedDispatch ( $ queue , \ Exception $ error ) { foreach ( $ queue as $ index => $ data ) { $ this -> clear ( $ data [ 'key' ] ) ; $ data [ 'reject' ] ( $ error ) ; } } 
public function create ( & $ resolve = null , & $ reject = null , callable $ canceller = null ) { $ promise = $ this -> webonyxPromiseAdapter -> create ( function ( $ res , $ rej ) use ( & $ resolve , & $ reject ) { $ resolve = $ res ; $ reject = $ rej ; } ) ; $ this -> cancellers [ spl_object_hash ( $ promise ) ] = $ canceller ; return $ promise ; } 
public function isPromise ( $ value , $ strict = false ) { if ( $ value instanceof Promise ) { $ value = $ value -> adoptedPromise ; } $ isStrictPromise = $ value instanceof SyncPromise ; if ( $ strict ) { return $ isStrictPromise ; } return $ isStrictPromise || is_callable ( [ $ value , 'then' ] ) ; } 
public function await ( $ promise = null , $ unwrap = false ) { if ( null === $ promise ) { Deferred :: runQueue ( ) ; SyncPromise :: runQueue ( ) ; $ this -> cancellers = [ ] ; return null ; } $ promiseAdapter = $ this -> getWebonyxPromiseAdapter ( ) ; $ resolvedValue = null ; $ exception = null ; if ( ! $ this -> isPromise ( $ promise ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "%s" method must be called with a Promise ("then" method).' , __METHOD__ ) ) ; } try { $ resolvedValue = $ promiseAdapter -> wait ( $ promise ) ; } catch ( \ Exception $ reason ) { $ exception = $ reason ; } if ( $ exception instanceof \ Exception ) { if ( ! $ unwrap ) { return $ exception ; } throw $ exception ; } $ hash = spl_object_hash ( $ promise ) ; unset ( $ this -> cancellers [ $ hash ] ) ; return $ resolvedValue ; } 
public function cancel ( $ promise ) { $ hash = spl_object_hash ( $ promise ) ; if ( ! $ this -> isPromise ( $ promise ) || ! isset ( $ this -> cancellers [ $ hash ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "%s" method must be called with a compatible Promise.' , __METHOD__ ) ) ; } $ canceller = $ this -> cancellers [ $ hash ] ; unset ( $ this -> cancellers [ $ hash ] ) ; $ adoptedPromise = $ promise ; if ( $ promise instanceof Promise ) { $ adoptedPromise = $ promise -> adoptedPromise ; } try { $ canceller ( [ $ adoptedPromise , 'resolve' ] , [ $ adoptedPromise , 'reject' ] ) ; } catch ( \ Exception $ reason ) { $ adoptedPromise -> reject ( $ reason ) ; } } 
public function parseText ( $ text , $ findMatchingTemplate = false ) { $ this -> logger -> info ( sprintf ( 'Parsing: %s' , $ text ) ) ; $ text = $ this -> prepareText ( $ text ) ; $ matchedTemplates = $ this -> getTemplates ( $ text , $ findMatchingTemplate ) ; foreach ( $ matchedTemplates as $ templatePath => $ templateContent ) { $ this -> logger -> debug ( sprintf ( 'Parsing against template: %s' , $ templatePath ) ) ; $ templatePattern = $ this -> prepareTemplate ( $ templateContent ) ; $ extractedData = $ this -> extractData ( $ text , $ templatePattern ) ; if ( $ extractedData ) { $ this -> logger -> info ( sprintf ( 'Data extracted: %s' , json_encode ( $ extractedData ) ) ) ; return $ extractedData ; } } return null ; } 
protected function getTemplates ( $ text , $ findMatchingTemplate ) { if ( $ findMatchingTemplate ) { return $ this -> findTemplate ( $ text ) ; } $ templates = [ ] ; foreach ( $ this -> directoryIterator as $ fileInfo ) { if ( ! is_file ( $ fileInfo -> getPathname ( ) ) ) { continue ; } $ templates [ $ fileInfo -> getPathname ( ) ] = file_get_contents ( $ fileInfo -> getPathname ( ) ) ; } return $ templates ; } 
protected function createTemplatesDirIterator ( $ templatesDir ) { if ( empty ( $ templatesDir ) || ! is_dir ( $ templatesDir ) ) { throw new \ Exception ( 'Invalid templates directory provided' ) ; } $ this -> directoryIterator = new DirectoryIterator ( rtrim ( $ templatesDir , '/' ) ) ; } 
protected function prepareTemplate ( $ templateTxt ) { $ patterns = [ '/\\\{%(.*)%\\\}/U' , 
protected function extractData ( $ text , $ template ) { 
protected function findTemplate ( $ text ) { $ matchedTemplate = [ ] ; $ maxMatch = - 1 ; foreach ( $ this -> directoryIterator as $ fileInfo ) { $ templateContent = file_get_contents ( $ fileInfo -> getPathname ( ) ) ; similar_text ( $ text , $ templateContent , $ matchPercentage ) ; 
public function PhpSerial ( ) { setlocale ( LC_ALL , "en_US" ) ; $ sysName = php_uname ( ) ; if ( substr ( $ sysName , 0 , 5 ) === "Linux" ) { $ this -> _os = "linux" ; if ( $ this -> _exec ( "stty" ) === 0 ) { register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } else { trigger_error ( "No stty availible, unable to run." , E_USER_ERROR ) ; } } elseif ( substr ( $ sysName , 0 , 6 ) === "Darwin" ) { $ this -> _os = "osx" ; register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } elseif ( substr ( $ sysName , 0 , 7 ) === "Windows" ) { $ this -> _os = "windows" ; register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } else { trigger_error ( "Host OS is neither osx, linux nor windows, unable " . "to run." , E_USER_ERROR ) ; exit ( ) ; } } 
public function deviceSet ( $ device ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { if ( $ this -> _os === "linux" ) { if ( preg_match ( "@^COM(\\d+):?$@i" , $ device , $ matches ) ) { $ device = "/dev/ttyS" . ( $ matches [ 1 ] - 1 ) ; } if ( $ this -> _exec ( "stty -F " . $ device ) === 0 ) { $ this -> _device = $ device ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } } elseif ( $ this -> _os === "osx" ) { if ( $ this -> _exec ( "stty -f " . $ device ) === 0 ) { $ this -> _device = $ device ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } } elseif ( $ this -> _os === "windows" ) { if ( preg_match ( "@^COM(\\d+):?$@i" , $ device , $ matches ) and $ this -> _exec ( exec ( "mode " . $ device . " xon=on BAUD=9600" ) ) === 0 ) { $ this -> _winDevice = "COM" . $ matches [ 1 ] ; $ this -> _device = "\\.com" . $ matches [ 1 ] ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } } trigger_error ( "Specified serial port is not valid" , E_USER_WARNING ) ; return false ; } else { trigger_error ( "You must close your device before to set an other " . "one" , E_USER_WARNING ) ; return false ; } } 
public function deviceOpen ( $ mode = "r+b" ) { if ( $ this -> _dState === SERIAL_DEVICE_OPENED ) { trigger_error ( "The device is already opened" , E_USER_NOTICE ) ; return true ; } if ( $ this -> _dState === SERIAL_DEVICE_NOTSET ) { trigger_error ( "The device must be set before to be open" , E_USER_WARNING ) ; return false ; } if ( ! preg_match ( "@^[raw]\\+?b?$@" , $ mode ) ) { trigger_error ( "Invalid opening mode : " . $ mode . ". Use fopen() modes." , E_USER_WARNING ) ; return false ; } $ this -> _dHandle = @ fopen ( $ this -> _device , $ mode ) ; if ( $ this -> _dHandle !== false ) { stream_set_blocking ( $ this -> _dHandle , 0 ) ; $ this -> _dState = SERIAL_DEVICE_OPENED ; return true ; } $ this -> _dHandle = null ; trigger_error ( "Unable to open the device" , E_USER_WARNING ) ; return false ; } 
public function deviceClose ( ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { return true ; } if ( fclose ( $ this -> _dHandle ) ) { $ this -> _dHandle = null ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } trigger_error ( "Unable to close the device" , E_USER_ERROR ) ; return false ; } 
public function confBaudRate ( $ rate ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set the baud rate : the device is " . "either not set or opened" , E_USER_WARNING ) ; return false ; } $ validBauds = array ( 110 => 11 , 150 => 15 , 300 => 30 , 600 => 60 , 1200 => 12 , 2400 => 24 , 4800 => 48 , 9600 => 96 , 19200 => 19 , 38400 => 38400 , 57600 => 57600 , 115200 => 115200 ) ; if ( isset ( $ validBauds [ $ rate ] ) ) { if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . ( int ) $ rate , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . ( int ) $ rate , $ out ) ; } elseif ( $ this -> _os === "windows" ) { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " BAUD=" . $ validBauds [ $ rate ] , $ out ) ; } else { return false ; } if ( $ ret !== 0 ) { trigger_error ( "Unable to set baud rate: " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; } return true ; } else { return false ; } } 
public function confParity ( $ parity ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set parity : the device is either not set or opened" , E_USER_WARNING ) ; return false ; } $ args = array ( "none" => "-parenb" , "odd" => "parenb parodd" , "even" => "parenb -parodd" , ) ; if ( ! isset ( $ args [ $ parity ] ) ) { trigger_error ( "Parity mode not supported" , E_USER_WARNING ) ; return false ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . $ args [ $ parity ] , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . $ args [ $ parity ] , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " PARITY=" . $ parity { 0 } , $ out ) ; } if ( $ ret === 0 ) { return true ; } trigger_error ( "Unable to set parity : " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; } 
public function confCharacterLength ( $ int ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set length of a character : the device " . "is either not set or opened" , E_USER_WARNING ) ; return false ; } $ int = ( int ) $ int ; if ( $ int < 5 ) { $ int = 5 ; } elseif ( $ int > 8 ) { $ int = 8 ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " cs" . $ int , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " cs" . $ int , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " DATA=" . $ int , $ out ) ; } if ( $ ret === 0 ) { return true ; } trigger_error ( "Unable to set character length : " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; } 
public function confStopBits ( $ length ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set the length of a stop bit : the " . "device is either not set or opened" , E_USER_WARNING ) ; return false ; } if ( $ length != 1 and $ length != 2 and $ length != 1.5 and ! ( $ length == 1.5 and $ this -> _os === "linux" ) ) { trigger_error ( "Specified stop bit length is invalid" , E_USER_WARNING ) ; return false ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . ( ( $ length == 1 ) ? "-" : "" ) . "cstopb" , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . ( ( $ length == 1 ) ? "-" : "" ) . "cstopb" , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " STOP=" . $ length , $ out ) ; } if ( $ ret === 0 ) { return true ; } trigger_error ( "Unable to set stop bit length : " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; } 
public function confFlowControl ( $ mode ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set flow control mode : the device is " . "either not set or opened" , E_USER_WARNING ) ; return false ; } $ linuxModes = array ( "none" => "clocal -crtscts -ixon -ixoff" , "rts/cts" => "-clocal crtscts -ixon -ixoff" , "xon/xoff" => "-clocal -crtscts ixon ixoff" ) ; $ windowsModes = array ( "none" => "xon=off octs=off rts=on" , "rts/cts" => "xon=off octs=on rts=hs" , "xon/xoff" => "xon=on octs=off rts=on" , ) ; if ( $ mode !== "none" and $ mode !== "rts/cts" and $ mode !== "xon/xoff" ) { trigger_error ( "Invalid flow control mode specified" , E_USER_ERROR ) ; return false ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " " . $ windowsModes [ $ mode ] , $ out ) ; } if ( $ ret === 0 ) { return true ; } else { trigger_error ( "Unable to set flow control : " . $ out [ 1 ] , E_USER_ERROR ) ; return false ; } } 
public function setSetserialFlag ( $ param , $ arg = "" ) { if ( ! $ this -> _ckOpened ( ) ) { return false ; } $ return = exec ( "setserial " . $ this -> _device . " " . $ param . " " . $ arg . " 2>&1" ) ; if ( $ return { 0 } === "I" ) { trigger_error ( "setserial: Invalid flag" , E_USER_WARNING ) ; return false ; } elseif ( $ return { 0 } === "/" ) { trigger_error ( "setserial: Error with device file" , E_USER_WARNING ) ; return false ; } else { return true ; } } 
public function sendMessage ( $ str , $ waitForReply = 0.1 ) { $ this -> _buffer .= $ str ; if ( $ this -> autoFlush === true ) { $ this -> serialflush ( ) ; } usleep ( ( int ) ( $ waitForReply * 1000000 ) ) ; } 
public function readPort ( $ count = 0 ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { trigger_error ( "Device must be opened to read it" , E_USER_WARNING ) ; return false ; } if ( $ this -> _os === "linux" || $ this -> _os === "osx" ) { 
public function serialflush ( ) { if ( ! $ this -> _ckOpened ( ) ) { return false ; } if ( fwrite ( $ this -> _dHandle , $ this -> _buffer ) !== false ) { $ this -> _buffer = "" ; return true ; } else { $ this -> _buffer = "" ; trigger_error ( "Error while sending message" , E_USER_WARNING ) ; return false ; } } 
public function isAuthorized ( ) { $ hasSession = Yii :: $ app -> session -> has ( $ this -> sessionParam ) ; $ sessionVal = Yii :: $ app -> session -> get ( $ this -> sessionParam ) ; return ( $ hasSession && ! empty ( $ sessionVal ) ) ; } 
public function getApp ( ) { if ( ! self :: $ _app instanceof Factory ) { self :: $ _app = Factory :: officialAccount ( Yii :: $ app -> params [ 'wechatConfig' ] ) ; } return self :: $ _app ; } 
public function getPayment ( ) { if ( ! self :: $ _payment instanceof Factory ) { self :: $ _payment = Factory :: payment ( Yii :: $ app -> params [ 'wechatPaymentConfig' ] ) ; } return self :: $ _payment ; } 
public function getMiniProgram ( ) { if ( ! self :: $ _miniProgram instanceof Factory ) { self :: $ _miniProgram = Factory :: miniProgram ( Yii :: $ app -> params [ 'wechatMiniProgramConfig' ] ) ; } return self :: $ _miniProgram ; } 
public function getOpenPlatform ( ) { if ( ! self :: $ _openPlatform instanceof Factory ) { self :: $ _openPlatform = Factory :: openPlatform ( Yii :: $ app -> params [ 'wechatOpenPlatformConfig' ] ) ; } return self :: $ _openPlatform ; } 
public function getWork ( ) { if ( ! self :: $ _work instanceof Factory ) { self :: $ _work = Factory :: work ( Yii :: $ app -> params [ 'wechatWorkConfig' ] ) ; } return self :: $ _work ; } 
public function getOpenWork ( ) { if ( ! self :: $ _openWork instanceof Factory ) { self :: $ _openWork = Factory :: openWork ( Yii :: $ app -> params [ 'wechatOpenWorkConfig' ] ) ; } return self :: $ _openWork ; } 
public function getUser ( ) { if ( ! $ this -> isAuthorized ( ) ) { return new WechatUser ( ) ; } if ( ! self :: $ _user instanceof WechatUser ) { $ userInfo = Yii :: $ app -> session -> get ( $ this -> sessionParam ) ; $ config = $ userInfo ? json_decode ( $ userInfo , true ) : [ ] ; self :: $ _user = new WechatUser ( $ config ) ; } return self :: $ _user ; } 
public function load ( array $ configs , ContainerBuilder $ container ) { $ mainConfig = $ this -> getConfiguration ( $ configs , $ container ) ; $ config = $ this -> processConfiguration ( $ mainConfig , $ configs ) ; $ loader = new XmlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; $ loader -> load ( 'acl.xml' ) ; if ( class_exists ( Application :: class ) ) { $ loader -> load ( 'console.xml' ) ; } if ( isset ( $ config [ 'cache' ] [ 'id' ] ) ) { $ container -> setAlias ( 'security.acl.cache' , $ config [ 'cache' ] [ 'id' ] ) ; } $ container -> getDefinition ( 'security.acl.voter.basic_permissions' ) -> addArgument ( $ config [ 'voter' ] [ 'allow_if_object_identity_unavailable' ] ) ; 
public function getConfigTreeBuilder ( ) { $ tb = new TreeBuilder ( ) ; $ rootNode = $ tb -> root ( 'acl' ) ; $ rootNode -> children ( ) -> scalarNode ( 'connection' ) -> defaultNull ( ) -> info ( 'any name configured in doctrine.dbal section' ) -> end ( ) -> arrayNode ( 'cache' ) -> addDefaultsIfNotSet ( ) -> children ( ) -> scalarNode ( 'id' ) -> end ( ) -> scalarNode ( 'prefix' ) -> defaultValue ( 'sf_acl_' ) -> end ( ) -> end ( ) -> end ( ) -> scalarNode ( 'provider' ) -> end ( ) -> arrayNode ( 'tables' ) -> addDefaultsIfNotSet ( ) -> children ( ) -> scalarNode ( 'class' ) -> defaultValue ( 'acl_classes' ) -> end ( ) -> scalarNode ( 'entry' ) -> defaultValue ( 'acl_entries' ) -> end ( ) -> scalarNode ( 'object_identity' ) -> defaultValue ( 'acl_object_identities' ) -> end ( ) -> scalarNode ( 'object_identity_ancestors' ) -> defaultValue ( 'acl_object_identity_ancestors' ) -> end ( ) -> scalarNode ( 'security_identity' ) -> defaultValue ( 'acl_security_identities' ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'voter' ) -> addDefaultsIfNotSet ( ) -> children ( ) -> booleanNode ( 'allow_if_object_identity_unavailable' ) -> defaultTrue ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; return $ tb ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { try { $ this -> schema -> addToSchema ( $ this -> connection -> getSchemaManager ( ) -> createSchema ( ) ) ; } catch ( SchemaException $ e ) { $ output -> writeln ( 'Aborting: ' . $ e -> getMessage ( ) ) ; return 1 ; } foreach ( $ this -> schema -> toSql ( $ this -> connection -> getDatabasePlatform ( ) ) as $ sql ) { $ this -> connection -> exec ( $ sql ) ; } $ output -> writeln ( 'ACL tables have been initialized successfully.' ) ; } 
public function performRequest ( $ method , $ path , array $ params = [ ] ) { $ request = $ this -> buildRequest ( $ method , $ path , $ params ) ; try { $ response = $ this -> httpClient -> send ( $ request ) ; $ content = json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; } catch ( ClientException $ ex ) { if ( $ ex -> getResponse ( ) -> getStatusCode ( ) == 401 ) { if ( $ this -> isPsr7Version ( ) ) { $ uri = $ request -> getUri ( ) ; } else { $ uri = $ request -> getUrl ( ) ; } $ message = sprintf ( 'Unauthorized %s Request to %s' , $ request -> getMethod ( ) , $ uri ) ; throw new UnauthorizedRequestException ( $ message ) ; } throw $ ex ; } return $ this -> createResponseFromData ( $ content ) ; } 
public function buildRequest ( $ method , $ path , array $ params = [ ] ) { $ body = ArrayUtils :: get ( $ params , 'body' , null ) ; $ query = ArrayUtils :: get ( $ params , 'query' , null ) ; $ options = [ ] ; if ( in_array ( $ method , [ 'POST' , 'PUT' , 'PATCH' ] ) && $ body ) { $ options [ 'body' ] = $ body ; } if ( $ query ) { $ options [ 'query' ] = $ query ; } return $ this -> createRequest ( $ method , $ path , $ options ) ; } 
public function createRequest ( $ method , $ path , $ options ) { if ( $ this -> isPsr7Version ( ) ) { $ headers = [ 'Content-Type' => 'application/json' , 'Authorization' => 'Bearer ' . $ this -> getAccessToken ( ) , ] ; $ body = ArrayUtils :: get ( $ options , 'body' , null ) ; $ uri = UriResolver :: resolve ( new Uri ( $ this -> getBaseEndpoint ( ) . '/' ) , new Uri ( $ path ) ) ; if ( $ body ) { $ body = json_encode ( $ body ) ; } if ( ArrayUtils :: has ( $ options , 'query' ) ) { $ query = $ options [ 'query' ] ; if ( is_array ( $ query ) ) { $ query = http_build_query ( $ query , null , '&' , PHP_QUERY_RFC3986 ) ; } if ( ! is_string ( $ query ) ) { throw new \ InvalidArgumentException ( 'query must be a string or array' ) ; } $ uri = $ uri -> withQuery ( $ query ) ; } $ request = new Request ( $ method , $ uri , $ headers , $ body ) ; } else { $ options [ 'auth' ] = [ $ this -> accessToken , '' ] ; $ request = $ this -> httpClient -> createRequest ( $ method , $ path , $ options ) ; $ query = ArrayUtils :: get ( $ options , 'query' ) ; if ( $ query ) { $ q = $ request -> getQuery ( ) ; foreach ( $ query as $ key => $ value ) { $ q -> set ( $ key , $ value ) ; } } } return $ request ; } 
protected function parseFile ( ) { $ attributes = [ ] ; $ path = $ this -> path ; if ( file_exists ( $ path ) ) { $ ext = pathinfo ( $ path , PATHINFO_EXTENSION ) ; $ mimeType = mime_content_type ( $ path ) ; $ attributes [ 'name' ] = pathinfo ( $ path , PATHINFO_FILENAME ) . '.' . $ ext ; $ attributes [ 'type' ] = $ mimeType ; $ content = file_get_contents ( $ path ) ; $ base64 = 'data:' . $ mimeType . ';base64,' . base64_encode ( $ content ) ; $ attributes [ 'data' ] = $ base64 ; } else { throw new \ Exception ( sprintf ( 'File %s not found' , $ path ) ) ; } return $ attributes ; } 
protected function createResponseFromData ( $ data ) { if ( isset ( $ data [ 'rows' ] ) || ( isset ( $ data [ 'data' ] ) && ArrayUtils :: isNumericKeys ( $ data [ 'data' ] ) ) ) { $ response = new EntryCollection ( $ data ) ; } else { $ response = new Entry ( $ data ) ; } return $ response ; } 
protected function pickMetadata ( $ data ) { $ metadata = [ ] ; if ( ArrayUtils :: has ( $ data , 'rows' ) ) { $ metadata = ArrayUtils :: omit ( $ data , 'rows' ) ; } else if ( ArrayUtils :: has ( $ data , 'meta' ) ) { $ metadata = ArrayUtils :: get ( $ data , 'meta' ) ; } return new Entry ( $ metadata ) ; } 
protected function pickRows ( $ data ) { $ rows = [ ] ; if ( ArrayUtils :: has ( $ data , 'rows' ) ) { $ rows = ArrayUtils :: get ( $ data , 'rows' , [ ] ) ; } else if ( ArrayUtils :: has ( $ data , 'data' ) ) { $ rows = ArrayUtils :: get ( $ data , 'data' , [ ] ) ; } return $ rows ; } 
public static function create ( $ userToken , $ options = [ ] ) { if ( static :: $ instance == null ) { static :: $ instance = new static ; } if ( ! is_array ( $ userToken ) ) { $ newClient = static :: $ instance -> createRemoteClient ( $ userToken , $ options ) ; } else { $ options = $ userToken ; $ newClient = static :: $ instance -> createLocalClient ( $ options ) ; } return $ newClient ; } 
public function createLocalClient ( array $ options ) { $ this -> container = $ container = new Container ( ) ; $ options = ArrayUtils :: defaults ( $ this -> defaultConfig , $ options ) ; $ container -> set ( 'config' , new Config ( $ options ) ) ; $ dbConfig = ArrayUtils :: get ( $ options , 'database' , [ ] ) ; $ config = ArrayUtils :: omit ( $ options , 'database' ) ; 
protected function getTableGateway ( $ tableName ) { if ( ! array_key_exists ( $ tableName , $ this -> tableGateways ) ) { $ acl = TableSchema :: getAclInstance ( ) ; $ this -> tableGateways [ $ tableName ] = new RelationalTableGateway ( $ tableName , $ this -> connection , $ acl ) ; } return $ this -> tableGateways [ $ tableName ] ; } 
public function rename ( $ key , $ newkey ) { if ( $ key === $ newkey ) { throw new Exception ( 'ERR source and destination objects are the same' ) ; } elseif ( ! $ this -> storage -> hasKey ( $ key ) ) { throw new Exception ( 'ERR no such key' ) ; } if ( $ this -> storage -> hasKey ( $ newkey ) ) { $ this -> del ( $ newkey ) ; } $ this -> storage -> rename ( $ key , $ newkey ) ; return true ; } 
public function type ( $ key ) { if ( ! $ this -> storage -> hasKey ( $ key ) ) { return 'none' ; } $ value = $ this -> storage -> get ( $ key ) ; if ( is_string ( $ value ) ) { return 'string' ; } elseif ( $ value instanceof \ SplDoublyLinkedList ) { return 'list' ; } else { throw new UnexpectedValueException ( 'Unknown datatype encountered' ) ; } } 
public function client ( $ subcommand ) { $ n = func_num_args ( ) ; $ subcommand = strtolower ( $ subcommand ) ; if ( $ subcommand === 'list' && $ n === 1 ) { $ ret = '' ; foreach ( $ this -> getAllClients ( ) as $ client ) { $ ret .= $ client -> getDescription ( ) . "\n" ; } return $ ret ; } elseif ( $ subcommand === 'kill' && $ n === 2 ) { $ this -> getClientByIp ( func_get_arg ( 1 ) ) -> end ( ) ; return true ; } elseif ( $ subcommand === 'getname' && $ n === 1 ) { return $ this -> getClient ( ) -> getName ( ) ; } elseif ( $ subcommand === 'setname' && $ n === 2 ) { $ this -> getClient ( ) -> setName ( func_get_arg ( 1 ) ) ; return true ; } throw new InvalidArgumentException ( 'ERR Syntax error, try CLIENT (LIST | KILL ip:port | GETNAME | SETNAME connection-name)' ) ; } 
public function config ( $ subcommand ) { $ n = func_num_args ( ) ; $ subcommand = strtolower ( $ subcommand ) ; if ( $ subcommand === 'get' ) { if ( $ n !== 2 ) { throw new InvalidArgumentException ( 'ERR Wrong number of arguments for CONFIG get' ) ; } $ pattern = func_get_arg ( 1 ) ; $ ret = array ( ) ; foreach ( $ this -> getConfig ( ) as $ name => $ value ) { if ( fnmatch ( $ pattern , $ name ) ) { $ ret [ ] = $ name ; $ ret [ ] = $ value ; } } return $ ret ; } elseif ( $ subcommand === 'set' ) { if ( $ n !== 3 ) { throw new InvalidArgumentException ( 'ERR Wrong number of arguments for CONFIG set' ) ; } $ this -> getConfig ( ) -> set ( func_get_arg ( 1 ) , func_get_arg ( 2 ) ) ; return true ; } throw new InvalidArgumentException ( 'ERR CONFIG subcommand must be one of GET, SET' ) ; } 
public function auth ( $ password ) { if ( $ this -> getConfig ( ) -> get ( 'requirepass' ) === '' ) { throw new UnexpectedValueException ( 'ERR Client sent AUTH, but no password is set' ) ; } if ( $ this -> getConfig ( ) -> get ( 'requirepass' ) !== $ password ) { throw new UnexpectedValueException ( 'ERR invalid password' ) ; } $ business = $ this -> getClient ( ) -> getBusiness ( ) ; if ( $ business instanceof AuthInvoker ) { $ this -> getClient ( ) -> setBusiness ( $ business -> getSuccessfulInvoker ( ) ) ; } return true ; } 
public function quit ( ) { 
public function set ( $ key , $ value ) { if ( func_num_args ( ) > 2 ) { $ args = func_get_args ( ) ; array_shift ( $ args ) ; array_shift ( $ args ) ; $ px = null ; $ ex = null ; $ xx = false ; $ nx = false ; for ( $ i = 0 , $ n = count ( $ args ) ; $ i < $ n ; ++ $ i ) { $ arg = strtoupper ( $ args [ $ i ] ) ; if ( $ arg === 'XX' ) { $ xx = true ; } elseif ( $ arg === 'NX' ) { $ nx = true ; } elseif ( $ arg === 'EX' || $ arg === 'PX' ) { if ( ! isset ( $ args [ $ i + 1 ] ) ) { throw new InvalidArgumentException ( 'ERR syntax error' ) ; } $ num = $ this -> coerceInteger ( $ args [ ++ $ i ] ) ; if ( $ num <= 0 ) { throw new InvalidArgumentException ( 'ERR invalid expire time in SETEX' ) ; } if ( $ arg === 'EX' ) { $ ex = $ num ; } else { $ px = $ num ; } } else { throw new InvalidArgumentException ( 'ERR syntax error' ) ; } } if ( $ nx && $ this -> storage -> hasKey ( $ key ) ) { return null ; } if ( $ xx && ! $ this -> storage -> hasKey ( $ key ) ) { return null ; } if ( $ ex !== null ) { $ px += $ ex * 1000 ; } if ( $ px !== null ) { return $ this -> psetex ( $ key , $ px , $ value ) ; } } $ this -> storage -> setString ( $ key , $ value ) ; return true ; } 
public function setex ( $ key , $ seconds , $ value ) { return $ this -> psetex ( $ key , $ this -> coerceInteger ( $ seconds ) * 1000 , $ value ) ; } 
public function psetex ( $ key , $ milliseconds , $ value ) { $ milliseconds = $ this -> coerceInteger ( $ milliseconds ) ; $ this -> storage -> setString ( $ key , $ value ) ; $ this -> storage -> setTimeout ( $ key , microtime ( true ) + ( $ milliseconds / 1000 ) ) ; return true ; } 
public function mset ( $ key0 , $ value0 ) { $ n = func_num_args ( ) ; if ( $ n & 1 ) { throw new Exception ( 'ERR wrong number of arguments for \'mset\' command' ) ; } $ args = func_get_args ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i += 2 ) { $ this -> storage -> setString ( $ args [ $ i ] , $ args [ $ i + 1 ] ) ; } return true ; } 
public function send ( MessageInterface $ message ) { $ response = $ this -> doSend ( $ message ) ; 
private function doSend ( MessageInterface $ message ) { $ content = $ this -> format ( $ message ) ; $ headers = $ this -> getHeaders ( ) ; $ files = $ this -> getFiles ( $ message ) ; if ( ! empty ( $ files ) ) { 
protected function determineFileType ( $ path ) { if ( ! function_exists ( 'finfo_open' ) ) { 
protected function format ( MessageInterface $ message ) { $ parameters = [ 'From' => $ this -> buildSenderField ( $ message -> getFrom ( ) ) , 'To' => $ this -> buildRecipientsField ( $ message -> getTo ( ) ) , 'Cc' => $ this -> buildRecipientsField ( $ message -> getCc ( ) ) , 'Bcc' => $ this -> buildRecipientsField ( $ message -> getBcc ( ) ) , 'Subject' => $ message -> getSubject ( ) , 'Headers' => $ message -> getHeaders ( ) , 'HTMLPart' => $ message -> getHtml ( ) , 'TextPart' => $ message -> getText ( ) , 'ReplyTo' => $ this -> buildSenderField ( $ message -> getReplyTo ( ) ) , ] ; $ attachments = $ this -> processAttachments ( $ message ) ; if ( $ attachments ) { if ( $ attachments [ 'attached' ] ) { $ parameters [ 'Attachments' ] = $ attachments [ 'attached' ] ; } if ( $ attachments [ 'inlined' ] ) { $ parameters [ 'InlinedAttachments' ] = $ attachments [ 'inlined' ] ; } } if ( $ message instanceof MetadataAwareInterface ) { $ parameters [ 'EventPayload' ] = $ message -> getMetadata ( ) ; } if ( $ message instanceof TaggableInterface ) { $ parameters [ 'MonitoringCategory' ] = $ message -> getTag ( ) ; } return json_encode ( [ 'Messages' => [ array_filter ( $ parameters ) ] ] ) ; } 
protected function handle ( ResponseInterface $ response ) { $ statusCode = $ response -> getStatusCode ( ) ; $ httpException = new HttpException ( $ statusCode , $ response -> getReasonPhrase ( ) ) ; if ( ! in_array ( $ statusCode , [ 400 , 401 , 403 ] , true ) ) { throw $ httpException ; } $ error = json_decode ( ( string ) $ response -> getBody ( ) , true ) ; if ( isset ( $ error [ 'ErrorMessage' ] ) ) { throw new ApiException ( $ error [ 'ErrorMessage' ] , $ httpException ) ; } $ errorMessages = [ ] ; foreach ( $ error [ 'Messages' ] as $ message ) { if ( 'error' !== $ message [ 'Status' ] ) { continue ; } foreach ( $ message [ 'Errors' ] as $ mailError ) { $ errorMessages [ ] = $ mailError [ 'ErrorMessage' ] ; } } throw new ApiException ( implode ( ', ' , $ errorMessages ) , $ httpException ) ; } 
protected function buildSenderField ( $ identity ) { if ( null === $ identity ) { return [ ] ; } if ( is_string ( $ identity ) ) { return [ 'Email' => $ identity , ] ; } $ sender = [ 'Email' => $ identity -> getEmail ( ) , ] ; if ( null !== $ name = $ identity -> getName ( ) ) { $ sender [ 'Name' ] = $ name ; } return $ sender ; } 
protected function buildRecipientsField ( $ identities ) { if ( null === $ identities ) { return [ ] ; } if ( is_string ( $ identities ) ) { return [ [ 'Email' => $ identities , ] , ] ; } $ identities = ( array ) $ identities ; $ recipients = [ ] ; foreach ( $ identities as $ identity ) { if ( is_string ( $ identity ) ) { $ recipients [ ] = [ 'Email' => $ identity , ] ; continue ; } $ recipient = [ 'Email' => $ identity -> getEmail ( ) , ] ; if ( null !== $ name = $ identity -> getName ( ) ) { $ recipient [ 'Name' ] = $ name ; } $ recipients [ ] = $ recipient ; } return $ recipients ; } 
protected function format ( MessageInterface $ message ) { $ from = $ this -> normalizeIdentity ( $ message -> getFrom ( ) ) ; $ parameters = [ 'options' => [ 'transactional' => $ this -> transactional , ] , 'content' => [ 'from' => [ 'name' => $ from -> getName ( ) , 'email' => $ from -> getEmail ( ) , ] , 'subject' => $ message -> getSubject ( ) , 'text' => $ message -> getText ( ) , 'html' => $ message -> getHtml ( ) , ] , ] ; if ( $ message -> getReplyTo ( ) ) { $ parameters [ 'content' ] [ 'reply_to' ] = $ message -> getReplyTo ( ) ; } if ( count ( $ message -> getHeaders ( ) ) ) { $ parameters [ 'content' ] [ 'headers' ] = $ message -> getHeaders ( ) ; } if ( $ message instanceof AttachmentsAwareInterface ) { foreach ( $ message -> getAttachments ( ) as $ attachment ) { $ inline = $ attachment -> getId ( ) !== null ; $ parameters [ 'content' ] [ $ inline ? 'inline_images' : 'attachments' ] [ ] = [ 'type' => $ attachment -> getType ( ) , 'name' => $ inline ? $ attachment -> getId ( ) : $ attachment -> getName ( ) , 'data' => base64_encode ( $ this -> getAttachmentContent ( $ attachment ) ) , ] ; } } if ( $ message instanceof MetadataAwareInterface ) { $ metadata = array_filter ( $ message -> getMetadata ( ) ) ; if ( count ( $ metadata ) ) { $ parameters [ 'metadata' ] = $ metadata ; } } $ tags = [ ] ; if ( $ message instanceof TaggableInterface ) { $ tags = ( array ) $ message -> getTag ( ) ; } $ normalizedTo = $ this -> normalizeIdentities ( $ message -> getTo ( ) ) ; $ normalizedCc = $ this -> normalizeIdentities ( $ message -> getCc ( ) ) ; $ normalizedBcc = $ this -> normalizeIdentities ( $ message -> getBcc ( ) ) ; $ toIdentityString = IdentityUtils :: buildIdentityString ( $ normalizedTo ) ; $ merged = array_merge ( $ normalizedTo , $ normalizedCc , $ normalizedBcc ) ; foreach ( $ merged as $ recipient ) { $ parameters [ 'recipients' ] [ ] = [ 'address' => [ 'email' => $ recipient -> getEmail ( ) , 'header_to' => $ toIdentityString , ] , 'tags' => $ tags , ] ; } if ( count ( $ normalizedCc ) ) { $ parameters [ 'content' ] [ 'headers' ] [ 'CC' ] = IdentityUtils :: buildIdentityString ( $ normalizedCc ) ; } return json_encode ( $ parameters ) ; } 
protected function handle ( ResponseInterface $ response ) { $ httpException = new HttpException ( $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) ; 
protected function format ( MessageInterface $ message ) { $ headers = array_filter ( array_merge ( $ message -> getHeaders ( ) , [ 'Reply-To' => $ message -> getReplyTo ( ) ] ) ) ; $ from = $ this -> normalizeIdentity ( $ message -> getFrom ( ) ) ; $ to = [ ] ; foreach ( $ this -> normalizeIdentities ( $ message -> getTo ( ) ) as $ recipient ) { $ to [ ] = [ 'email' => $ recipient -> getEmail ( ) , 'name' => $ recipient -> getName ( ) , 'type' => 'to' ] ; } foreach ( $ this -> normalizeIdentities ( $ message -> getCc ( ) ) as $ recipient ) { $ to [ ] = [ 'email' => $ recipient -> getEmail ( ) , 'name' => $ recipient -> getName ( ) , 'type' => 'cc' ] ; } foreach ( $ this -> normalizeIdentities ( $ message -> getBcc ( ) ) as $ recipient ) { $ to [ ] = [ 'email' => $ recipient -> getEmail ( ) , 'name' => $ recipient -> getName ( ) , 'type' => 'bcc' ] ; } $ tags = [ ] ; if ( $ message instanceof TaggableInterface ) { $ tags = ( array ) $ message -> getTag ( ) ; } $ metadata = [ ] ; if ( $ message instanceof MetadataAwareInterface ) { $ metadata = array_filter ( $ message -> getMetadata ( ) ) ; } $ images = [ ] ; $ attachments = [ ] ; if ( $ message instanceof AttachmentsAwareInterface ) { list ( $ attachments , $ images ) = $ this -> processAttachments ( $ message -> getAttachments ( ) ) ; } $ parameters = [ 'key' => $ this -> getServerToken ( ) , 'message' => array_filter ( [ 'from_email' => $ from -> getEmail ( ) , 'from_name' => $ from -> getName ( ) , 'to' => $ to , 'subject' => $ message -> getSubject ( ) , 'headers' => $ headers , 'text' => $ message -> getText ( ) , 'html' => $ message -> getHtml ( ) , 'tags' => $ tags , 'metadata' => $ metadata , 'attachments' => $ attachments , 'images' => $ images , ] ) , ] ; if ( $ this -> subaccount ) { $ parameters [ 'message' ] [ 'subaccount' ] = $ this -> subaccount ; } return json_encode ( $ parameters ) ; } 
protected function handle ( ResponseInterface $ response ) { $ httpException = new HttpException ( $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) ; $ error = json_decode ( ( string ) $ response -> getBody ( ) ) ; throw new ApiException ( $ error -> message , $ httpException , $ error -> code ) ; } 
protected function handle ( ResponseInterface $ response ) { $ httpException = new HttpException ( $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) ; 
protected function format ( MessageInterface $ message ) { $ personalization = [ 'to' => $ this -> formatRecipients ( $ message -> getTo ( ) ) , 'cc' => $ this -> formatRecipients ( $ message -> getCc ( ) ) , 'bcc' => $ this -> formatRecipients ( $ message -> getBcc ( ) ) , 'subject' => $ message -> getSubject ( ) , ] ; if ( $ headers = $ message -> getHeaders ( ) ) { $ personalization [ 'headers' ] = $ headers ; } if ( empty ( $ personalization [ 'cc' ] ) ) { unset ( $ personalization [ 'cc' ] ) ; } if ( empty ( $ personalization [ 'bcc' ] ) ) { unset ( $ personalization [ 'bcc' ] ) ; } $ content = [ [ 'type' => 'text/plain' , 'value' => $ message -> getText ( ) ] , [ 'type' => 'text/html' , 'value' => $ message -> getHtml ( ) ] , ] ; foreach ( $ content as $ i => $ c ) { if ( empty ( $ c [ 'value' ] ) ) { unset ( $ content [ $ i ] ) ; } } $ parameters = [ 'personalizations' => [ $ personalization ] , 'from' => $ this -> formatRecipients ( $ message -> getFrom ( ) ) [ 0 ] , 'reply_to' => $ this -> formatRecipients ( $ message -> getReplyTo ( ) ) , 'content' => array_values ( $ content ) , ] ; if ( empty ( $ parameters [ 'reply_to' ] ) ) { unset ( $ parameters [ 'reply_to' ] ) ; } else { $ parameters [ 'reply_to' ] = $ parameters [ 'reply_to' ] [ 0 ] ; } if ( $ message instanceof AttachmentsAwareInterface ) { $ attachments = $ message -> getAttachments ( ) ; if ( ! empty ( $ attachments ) ) { $ parameters [ 'attachments' ] = $ this -> processAttachments ( $ attachments ) ; } } if ( $ message instanceof TaggableInterface ) { $ parameters [ 'categories' ] = ( array ) $ message -> getTag ( ) ; } if ( $ message instanceof MetadataAwareInterface ) { $ metadata = array_filter ( $ message -> getMetadata ( ) ) ; if ( ! empty ( $ metadata ) ) { if ( isset ( $ parameters [ 'custom_args' ] ) ) { $ parameters [ 'custom_args' ] = array_merge ( $ parameters [ 'custom_args' ] , $ metadata ) ; } else { $ parameters [ 'custom_args' ] = $ metadata ; } } } return json_encode ( $ parameters ) ; } 
protected function processAttachments ( array $ attachments ) { $ attachments = AttachmentUtils :: processAttachments ( $ attachments ) ; $ processedAttachments = [ ] ; foreach ( $ attachments as $ name => $ attachment ) { $ item = [ 'content' => base64_encode ( file_get_contents ( $ attachment -> getPath ( ) ) ) , 'type' => $ attachment -> getType ( ) , 'filename' => $ attachment -> getName ( ) , ] ; $ id = $ attachment -> getId ( ) ; if ( ! empty ( $ id ) ) { $ item [ 'disposition' ] = 'inline' ; $ item [ 'content_id' ] = $ id ; } $ processedAttachments [ ] = $ item ; } return $ processedAttachments ; } 
private function formatRecipients ( $ recipients ) { $ data = [ ] ; foreach ( $ this -> normalizeIdentities ( $ recipients ) as $ recipient ) { $ item = [ 'email' => $ recipient -> getEmail ( ) , 'name' => $ recipient -> getName ( ) , ] ; if ( empty ( $ item [ 'name' ] ) ) { unset ( $ item [ 'name' ] ) ; } $ data [ ] = $ item ; } return $ data ; } 
public static function normalizeIdentities ( $ identities ) { if ( is_array ( $ identities ) ) { $ identities = array_map ( [ __CLASS__ , 'normalizeIdentity' ] , $ identities ) ; } if ( null === $ identities ) { return [ ] ; } if ( is_string ( $ identities ) ) { $ identities = [ self :: normalizeIdentity ( $ identities ) ] ; } if ( ! is_array ( $ identities ) && $ identities instanceof IdentityInterface ) { $ identities = [ $ identities ] ; } return $ identities ; } 
public static function buildIdentityString ( $ identities ) { if ( null === $ identities ) { return '' ; } if ( is_string ( $ identities ) ) { return $ identities ; } if ( $ identities instanceof IdentityInterface ) { $ identities = [ $ identities ] ; } $ stringIdentities = [ ] ; foreach ( $ identities as $ identity ) { if ( null === $ identity -> getName ( ) ) { $ stringIdentities [ ] = $ identity -> getEmail ( ) ; continue ; } $ stringIdentities [ ] = sprintf ( '%s <%s>' , $ identity -> getName ( ) , $ identity -> getEmail ( ) ) ; } return implode ( ',' , $ stringIdentities ) ; } 
protected function getFiles ( MessageInterface $ message ) { if ( ! ( $ message instanceof AttachmentsAwareInterface ) ) { return [ ] ; } 
protected function format ( MessageInterface $ message ) { 
protected function processAttachments ( array $ attachments ) { $ processedAttachments = [ ] ; $ inline = [ ] ; foreach ( $ attachments as $ attachment ) { $ path = $ attachment -> getPath ( ) ; $ id = $ attachment -> getId ( ) ; if ( isset ( $ id ) ) { 
public static function processAttachments ( array $ attachments ) { $ processed = [ ] ; foreach ( $ attachments as $ attachment ) { if ( ! ( $ attachment instanceof Attachment ) ) { throw new \ InvalidArgumentException ( 'Attachments must implement Stampie\\Attachment' ) ; } $ name = $ attachment -> getName ( ) ; if ( isset ( $ processed [ $ name ] ) ) { 
public static function findUniqueName ( $ name , array $ claimed ) { $ ext = pathinfo ( $ name , \ PATHINFO_EXTENSION ) ; $ basename = substr ( $ name , 0 , - strlen ( '.' . $ ext ) ) ; $ i = 0 ; while ( in_array ( $ name , $ claimed ) ) { $ i ++ ; $ name = $ basename . '-' . $ i . '.' . $ ext ; } return $ name ; } 
protected function handle ( ResponseInterface $ response ) { $ httpException = new HttpException ( $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) ; 
protected function format ( MessageInterface $ message ) { $ headers = [ ] ; foreach ( $ message -> getHeaders ( ) as $ name => $ value ) { $ headers [ ] = [ 'Name' => $ name , 'Value' => $ value ] ; } $ parameters = [ 'From' => $ this -> buildIdentityString ( $ message -> getFrom ( ) ) , 'To' => $ this -> buildIdentityString ( $ message -> getTo ( ) ) , 'Subject' => $ message -> getSubject ( ) , 'Headers' => $ headers , 'HtmlBody' => $ message -> getHtml ( ) , 'TextBody' => $ message -> getText ( ) , 'ReplyTo' => $ message -> getReplyTo ( ) , ] ; if ( $ message instanceof TaggableInterface ) { $ tag = $ message -> getTag ( ) ; if ( is_array ( $ tag ) ) { $ tag = reset ( $ tag ) ; } $ parameters [ 'Tag' ] = $ tag ; } if ( $ message instanceof AttachmentsAwareInterface ) { $ attachments = $ this -> processAttachments ( $ message -> getAttachments ( ) ) ; if ( $ attachments ) { $ parameters [ 'Attachments' ] = $ attachments ; } } return json_encode ( array_filter ( $ parameters ) ) ; } 
protected function processAttachments ( array $ attachments ) { $ attachments = AttachmentUtils :: processAttachments ( $ attachments ) ; $ processedAttachments = [ ] ; foreach ( $ attachments as $ name => $ attachment ) { $ item = [ 'Name' => $ name , 'Content' => base64_encode ( $ this -> getAttachmentContent ( $ attachment ) ) , 'ContentType' => $ attachment -> getType ( ) , ] ; $ id = $ attachment -> getId ( ) ; if ( isset ( $ id ) ) { $ item [ 'ContentID' ] = $ id ; } $ processedAttachments [ ] = $ item ; } return $ processedAttachments ; } 
private function locateClosure ( array & $ data ) { try { $ locator = new ClosureLocatorVisitor ( $ data [ 'reflection' ] ) ; $ fileAst = $ this -> getFileAst ( $ data [ 'reflection' ] ) ; $ fileTraverser = new NodeTraverser ; $ fileTraverser -> addVisitor ( new NameResolver ) ; $ fileTraverser -> addVisitor ( $ locator ) ; $ fileTraverser -> traverse ( $ fileAst ) ; } catch ( ParserError $ e ) { 
protected function determineContext ( array & $ data ) { 
private function getFileAst ( \ ReflectionFunction $ reflection ) { $ fileName = $ reflection -> getFileName ( ) ; if ( ! file_exists ( $ fileName ) ) { throw new ClosureAnalysisException ( "The file containing the closure, \"{$fileName}\" did not exist." ) ; } return $ this -> getParser ( ) -> parse ( file_get_contents ( $ fileName ) ) ; } 
public static function wrapClosures ( & $ data , SerializerInterface $ serializer ) { if ( $ data instanceof \ Closure ) { 
public function analyze ( \ Closure $ closure ) { $ data = [ 'reflection' => new \ ReflectionFunction ( $ closure ) , 'code' => null , 'hasThis' => false , 'context' => [ ] , 'hasRefs' => false , 'binding' => null , 'scope' => null , 'isStatic' => $ this -> isClosureStatic ( $ closure ) , ] ; $ this -> determineCode ( $ data ) ; $ this -> determineContext ( $ data ) ; $ this -> determineBinding ( $ data ) ; return $ data ; } 
public function bindTo ( $ newthis , $ newscope = 'static' ) { return new self ( $ this -> closure -> bindTo ( $ newthis , $ newscope ) , $ this -> serializer ) ; } 
public function serialize ( ) { try { $ this -> data = $ this -> data ? : $ this -> serializer -> getData ( $ this -> closure , true ) ; return serialize ( $ this -> data ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Serialization of closure failed: ' . $ e -> getMessage ( ) , E_USER_NOTICE ) ; 
public function unserialize ( $ serialized ) { 
private function getLicenses ( $ url ) { $ licenses = array ( ) ; $ data = json_decode ( file_get_contents ( $ url ) , true ) ; foreach ( $ data [ 'licenses' ] as $ info ) { $ licenses [ $ info [ 'licenseId' ] ] = array ( trim ( $ info [ 'name' ] ) , $ info [ 'isOsiApproved' ] , $ info [ 'isDeprecatedLicenseId' ] ) ; } uksort ( $ licenses , 'strcasecmp' ) ; return $ licenses ; } 
private function getExceptions ( $ url ) { $ exceptions = array ( ) ; $ data = json_decode ( file_get_contents ( $ url ) , true ) ; foreach ( $ data [ 'exceptions' ] as $ info ) { $ exceptions [ $ info [ 'licenseExceptionId' ] ] = array ( trim ( $ info [ 'name' ] ) ) ; } uksort ( $ exceptions , 'strcasecmp' ) ; return $ exceptions ; } 
public function getLicenseByIdentifier ( $ identifier ) { $ key = strtolower ( $ identifier ) ; if ( ! isset ( $ this -> licenses [ $ key ] ) ) { return ; } list ( $ identifier , $ name , $ isOsiApproved , $ isDeprecatedLicenseId ) = $ this -> licenses [ $ key ] ; return array ( $ name , $ isOsiApproved , 'https://spdx.org/licenses/' . $ identifier . '.html#licenseText' , $ isDeprecatedLicenseId , ) ; } 
public function getExceptionByIdentifier ( $ identifier ) { $ key = strtolower ( $ identifier ) ; if ( ! isset ( $ this -> exceptions [ $ key ] ) ) { return ; } list ( $ identifier , $ name ) = $ this -> exceptions [ $ key ] ; return array ( $ name , 'https://spdx.org/licenses/' . $ identifier . '.html#licenseExceptionText' , ) ; } 
public function getIdentifierByName ( $ name ) { foreach ( $ this -> licenses as $ licenseData ) { if ( $ licenseData [ 1 ] === $ name ) { return $ licenseData [ 0 ] ; } } foreach ( $ this -> exceptions as $ licenseData ) { if ( $ licenseData [ 1 ] === $ name ) { return $ licenseData [ 0 ] ; } } } 
public function validate ( $ license ) { if ( is_array ( $ license ) ) { $ count = count ( $ license ) ; if ( $ count !== count ( array_filter ( $ license , 'is_string' ) ) ) { throw new \ InvalidArgumentException ( 'Array of strings expected.' ) ; } $ license = $ count > 1 ? '(' . implode ( ' OR ' , $ license ) . ')' : ( string ) reset ( $ license ) ; } if ( ! is_string ( $ license ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Array or String expected, %s given.' , gettype ( $ license ) ) ) ; } return $ this -> isValidLicenseString ( $ license ) ; } 
private function isValidLicenseString ( $ license ) { if ( isset ( $ this -> licenses [ strtolower ( $ license ) ] ) ) { return true ; } $ licenses = $ this -> getLicensesExpression ( ) ; $ exceptions = $ this -> getExceptionsExpression ( ) ; $ regex = <<<REGEX { (?(DEFINE) # idstring: 1*( ALPHA / DIGIT / - / . ) (?<idstring>[\pL\pN.-]{1,}) # license-id: taken from list (?<licenseid>${licenses}) # license-exception-id: taken from list (?<licenseexceptionid>${exceptions}) # license-ref: [DocumentRef-1*(idstring):]LicenseRef-1*(idstring) (?<licenseref>(?:DocumentRef-(?&idstring):)?LicenseRef-(?&idstring)) # simple-expresssion: license-id / license-id+ / license-ref (?<simple_expression>(?&licenseid)\+? | (?&licenseid) | (?&licenseref)) # compound-expression: 1*( # simple-expression / # simple-expression WITH license-exception-id / # compound-expression AND compound-expression / # compound-expression OR compound-expression # ) / ( compound-expression ) ) (?<compound_head> (?&simple_expression) ( \s+ WITH \s+ (?&licenseexceptionid))? | \( \s* (?&compound_expression) \s* \) ) (?<compound_expression> (?&compound_head) (?: \s+ (?:AND|OR) \s+ (?&compound_expression))? ) # license-expression: 1*1(simple-expression / compound-expression) (?<license_expression>(?&compound_expression) | (?&simple_expression)) ) # end of define ^(NONE | NOASSERTION | (?&license_expression))$ }xi REGEX ; $ match = preg_match ( $ regex , $ license ) ; if ( 0 === $ match ) { return false ; } if ( false === $ match ) { throw new \ RuntimeException ( 'Regex failed to compile/run.' ) ; } return true ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ questionHelper = $ this -> getQuestionHelper ( ) ; $ bundle = $ this -> createBundleObject ( $ input ) ; $ questionHelper -> writeSection ( $ output , 'Bundle generation' ) ; $ generator = $ this -> getGenerator ( ) ; $ output -> writeln ( sprintf ( '> Generating a sample bundle skeleton into <info>%s</info>' , $ this -> makePathRelative ( $ bundle -> getTargetDirectory ( ) ) ) ) ; $ generator -> generateBundle ( $ bundle ) ; $ errors = array ( ) ; $ runner = $ questionHelper -> getRunner ( $ output , $ errors ) ; 
protected function createBundleObject ( InputInterface $ input ) { foreach ( array ( 'namespace' , 'dir' ) as $ option ) { if ( null === $ input -> getOption ( $ option ) ) { throw new \ RuntimeException ( sprintf ( 'The "%s" option must be provided.' , $ option ) ) ; } } $ shared = $ input -> getOption ( 'shared' ) ; $ namespace = Validators :: validateBundleNamespace ( $ input -> getOption ( 'namespace' ) , $ shared ) ; if ( ! $ bundleName = $ input -> getOption ( 'bundle-name' ) ) { $ bundleName = strtr ( $ namespace , array ( '\\' => '' ) ) ; } $ bundleName = Validators :: validateBundleName ( $ bundleName ) ; $ dir = $ input -> getOption ( 'dir' ) ; if ( null === $ input -> getOption ( 'format' ) ) { $ input -> setOption ( 'format' , 'annotation' ) ; } $ format = Validators :: validateFormat ( $ input -> getOption ( 'format' ) ) ; 
public function addResource ( Bundle $ bundle ) { 
private function findLastImportedPath ( $ yamlContents ) { $ data = Yaml :: parse ( $ yamlContents ) ; if ( ! isset ( $ data [ 'imports' ] ) ) { return false ; } 
public function addBundle ( $ bundle ) { if ( ! $ this -> getFilename ( ) ) { return false ; } $ src = file ( $ this -> getFilename ( ) ) ; $ method = $ this -> reflected -> getMethod ( 'registerBundles' ) ; $ lines = array_slice ( $ src , $ method -> getStartLine ( ) - 1 , $ method -> getEndLine ( ) - $ method -> getStartLine ( ) + 1 ) ; 
protected function makePathRelative ( $ absolutePath ) { $ projectRootDir = dirname ( $ this -> getContainer ( ) -> getParameter ( 'kernel.root_dir' ) ) ; return str_replace ( $ projectRootDir . '/' , '' , realpath ( $ absolutePath ) ? : $ absolutePath ) ; } 
protected function peek ( $ nb = 1 ) { $ i = 0 ; $ tokens = $ this -> tokens ; while ( $ token = array_shift ( $ tokens ) ) { if ( is_array ( $ token ) && in_array ( $ token [ 0 ] , array ( T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ) ) ) { continue ; } ++ $ i ; if ( $ i == $ nb ) { return $ token ; } } } 
public function generate ( BundleInterface $ bundle , $ entity , $ format , array $ fields ) { 
public function generate ( BundleInterface $ bundle , $ entity , ClassMetadataInfo $ metadata , $ format , $ routePrefix , $ needWriteActions , $ forceOverwrite ) { $ this -> routePrefix = $ routePrefix ; $ this -> routeNamePrefix = self :: getRouteNamePrefix ( $ routePrefix ) ; $ this -> actions = $ needWriteActions ? array ( 'index' , 'show' , 'new' , 'edit' , 'delete' ) : array ( 'index' , 'show' ) ; if ( count ( $ metadata -> identifier ) != 1 ) { throw new \ RuntimeException ( 'The CRUD generator does not support entity classes with multiple or no primary keys.' ) ; } $ this -> entity = $ entity ; $ entity = str_replace ( '\\' , '/' , $ entity ) ; $ entityParts = explode ( '/' , $ entity ) ; $ entityName = end ( $ entityParts ) ; $ this -> entitySingularized = lcfirst ( Inflector :: singularize ( $ entityName ) ) ; $ this -> entityPluralized = lcfirst ( Inflector :: pluralize ( $ entityName ) ) ; $ this -> bundle = $ bundle ; $ this -> metadata = $ metadata ; $ this -> setFormat ( $ format ) ; $ this -> generateControllerClass ( $ forceOverwrite ) ; $ dir = sprintf ( '%s/Resources/views/%s' , $ this -> rootDir , strtolower ( $ entity ) ) ; if ( ! file_exists ( $ dir ) ) { self :: mkdir ( $ dir ) ; } $ this -> generateIndexView ( $ dir ) ; if ( in_array ( 'show' , $ this -> actions ) ) { $ this -> generateShowView ( $ dir ) ; } if ( in_array ( 'new' , $ this -> actions ) ) { $ this -> generateNewView ( $ dir ) ; } if ( in_array ( 'edit' , $ this -> actions ) ) { $ this -> generateEditView ( $ dir ) ; } $ this -> generateTestClass ( ) ; $ this -> generateConfiguration ( ) ; } 
protected function generateIndexView ( $ dir ) { $ this -> renderFile ( 'crud/views/index.html.twig.twig' , $ dir . '/index.html.twig' , array ( 'bundle' => $ this -> bundle -> getName ( ) , 'entity' => $ this -> entity , 'entity_pluralized' => $ this -> entityPluralized , 'entity_singularized' => $ this -> entitySingularized , 'identifier' => $ this -> metadata -> identifier [ 0 ] , 'fields' => $ this -> metadata -> fieldMappings , 'actions' => $ this -> actions , 'record_actions' => $ this -> getRecordActions ( ) , 'route_prefix' => $ this -> routePrefix , 'route_name_prefix' => $ this -> routeNamePrefix , ) ) ; } 
protected function generateShowView ( $ dir ) { $ this -> renderFile ( 'crud/views/show.html.twig.twig' , $ dir . '/show.html.twig' , array ( 'bundle' => $ this -> bundle -> getName ( ) , 'entity' => $ this -> entity , 'entity_singularized' => $ this -> entitySingularized , 'identifier' => $ this -> metadata -> identifier [ 0 ] , 'fields' => $ this -> metadata -> fieldMappings , 'actions' => $ this -> actions , 'route_prefix' => $ this -> routePrefix , 'route_name_prefix' => $ this -> routeNamePrefix , ) ) ; } 
public static function validateBundleNamespace ( $ namespace , $ requireVendorNamespace = true ) { if ( ! preg_match ( '/Bundle$/' , $ namespace ) ) { throw new \ InvalidArgumentException ( 'The namespace must end with Bundle.' ) ; } $ namespace = strtr ( $ namespace , '/' , '\\' ) ; if ( ! preg_match ( '/^(?:[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*\\\?)+$/' , $ namespace ) ) { throw new \ InvalidArgumentException ( 'The namespace contains invalid characters.' ) ; } 
protected function generateForm ( $ bundle , $ entity , $ metadata , $ forceOverwrite = false ) { $ this -> getFormGenerator ( $ bundle ) -> generate ( $ bundle , $ entity , $ metadata [ 0 ] , $ forceOverwrite ) ; } 
public function addResource ( $ bundle , $ format , $ prefix = '/' , $ path = 'routing' ) { $ current = '' ; $ code = sprintf ( "%s:\n" , $ this -> getImportedResourceYamlKey ( $ bundle , $ prefix ) ) ; if ( file_exists ( $ this -> file ) ) { $ current = file_get_contents ( $ this -> file ) ; 
public function hasResourceInAnnotation ( $ bundle ) { if ( ! file_exists ( $ this -> file ) ) { return false ; } $ config = Yaml :: parse ( file_get_contents ( $ this -> file ) ) ; $ search = sprintf ( '@%s/Controller/' , $ bundle ) ; foreach ( $ config as $ resource ) { if ( array_key_exists ( 'resource' , $ resource ) ) { return $ resource [ 'resource' ] === $ search ; } } return false ; } 
private static function parseToken ( array $ token , array $ args , $ locale ) { if ( ! isset ( $ args [ $ param = trim ( $ token [ 0 ] ) ] ) ) { return '{' . $ param . '}' ; } $ arg = $ args [ $ param ] ; $ type = isset ( $ token [ 1 ] ) ? trim ( $ token [ 1 ] ) : 'none' ; switch ( $ type ) { case 'date' : selectStyle = (selector '{' message '}')+ */ if ( ! isset ( $ token [ 2 ] ) ) { throw new \ DomainException ( 'Message pattern is invalid.' ) ; } $ select = self :: tokenizePattern ( $ token [ 2 ] ) ; $ c = \ count ( $ select ) ; $ message = false ; for ( $ i = 0 ; 1 + $ i < $ c ; ++ $ i ) { if ( \ is_array ( $ select [ $ i ] ) || ! \ is_array ( $ select [ 1 + $ i ] ) ) { throw new \ DomainException ( 'Message pattern is invalid.' ) ; } $ selector = trim ( $ select [ $ i ++ ] ) ; if ( false === $ message && 'other' === $ selector || $ selector == $ arg ) { $ message = implode ( ',' , $ select [ $ i ] ) ; } } if ( false !== $ message ) { return self :: parseTokens ( self :: tokenizePattern ( $ message ) , $ args , $ locale ) ; } break ; case 'plural' : pluralStyle = [offsetValue] (selector '{' message '}')+ offsetValue = "offset:" number selector = explicitValue | keyword explicitValue = '=' number keyword = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+ message: see MessageFormat */ if ( ! isset ( $ token [ 2 ] ) ) { throw new \ DomainException ( 'Message pattern is invalid.' ) ; } $ plural = self :: tokenizePattern ( $ token [ 2 ] ) ; $ c = \ count ( $ plural ) ; $ message = false ; $ offset = 0 ; for ( $ i = 0 ; 1 + $ i < $ c ; ++ $ i ) { if ( \ is_array ( $ plural [ $ i ] ) || ! \ is_array ( $ plural [ 1 + $ i ] ) ) { throw new \ DomainException ( 'Message pattern is invalid.' ) ; } $ selector = trim ( $ plural [ $ i ++ ] ) ; if ( 1 === $ i && 0 === strncmp ( $ selector , 'offset:' , 7 ) ) { $ pos = strpos ( str_replace ( array ( "\n" , "\r" , "\t" ) , ' ' , $ selector ) , ' ' , 7 ) ; $ offset = ( int ) trim ( substr ( $ selector , 7 , $ pos - 7 ) ) ; $ selector = trim ( substr ( $ selector , 1 + $ pos , \ strlen ( $ selector ) ) ) ; } if ( false === $ message && 'other' === $ selector || '=' === $ selector [ 0 ] && ( int ) substr ( $ selector , 1 , \ strlen ( $ selector ) ) === $ arg || 'one' === $ selector && 1 == $ arg - $ offset ) { $ message = implode ( ',' , str_replace ( '#' , $ arg - $ offset , $ plural [ $ i ] ) ) ; } } if ( false !== $ message ) { return self :: parseTokens ( self :: tokenizePattern ( $ message ) , $ args , $ locale ) ; } break ; } throw new \ DomainException ( 'Message pattern is invalid.' ) ; } 
public static function hrtime ( $ asNum = false ) { $ ns = \ microtime ( false ) ; $ s = \ substr ( $ ns , 11 ) - self :: $ startAt ; $ ns = 1E9 * ( float ) $ ns ; if ( $ asNum ) { $ ns += $ s * 1E9 ; return \ PHP_INT_SIZE === 4 ? $ ns : ( int ) $ ns ; } return array ( $ s , ( int ) $ ns ) ; } 
public function register ( ) { $ this -> app -> singleton ( 'GooglePlaces' , function ( $ app ) { $ key = isset ( $ app [ 'config' ] [ 'google.places.key' ] ) ? $ app [ 'config' ] [ 'google.places.key' ] : null ; $ verifySSL = isset ( $ app [ 'config' ] [ 'google.places.verify_ssl' ] ) ? $ app [ 'config' ] [ 'google.places.verify_ssl' ] : true ; $ headers = isset ( $ app [ 'config' ] [ 'google.places.headers' ] ) ? $ app [ 'config' ] [ 'google.places.headers' ] : [ ] ; return new PlacesApi ( $ key , $ verifySSL , $ headers ) ; } ) ; } 
public function setLogger ( LoggerInterface $ logger ) { if ( $ this -> transport instanceof LoggerAwareInterface ) { $ this -> transport -> setLogger ( $ logger ) ; } } 
public function selectColumns ( $ columns ) { if ( ! is_array ( $ columns ) ) { $ columns = func_get_args ( ) ; } $ this -> request -> setParam ( 'selectColumns' , $ this -> request -> getModule ( ) . '(' . implode ( ',' , $ columns ) . ')' ) ; return $ this ; } 
public function uploadFromPath ( $ path ) { $ file = new FormUpload ( $ path ) ; $ this -> request -> setParam ( 'content' , $ file ) ; return $ this ; } 
private function encodeRecord ( $ record , $ childName , & $ xml ) { foreach ( $ record as $ key => $ value ) { if ( $ value instanceof \ DateTime ) { if ( $ value -> format ( 'His' ) === '000000' ) { $ value = $ value -> format ( 'm/d/Y' ) ; } else { $ value = $ value -> format ( 'Y-m-d H:i:s' ) ; } } $ keyValue = $ xml -> addChild ( $ childName ) ; $ keyValue -> addAttribute ( 'val' , $ key ) ; if ( is_array ( $ value ) ) { $ this -> parseNestedValues ( $ value , $ keyValue ) ; } else { $ keyValue [ 0 ] = $ value ; } } } 
private function parse ( $ content ) { if ( $ this -> method == 'downloadFile' ) { return $ this -> parseResponseDownloadFile ( $ content ) ; } $ xml = new SimpleXMLElement ( $ content ) ; if ( isset ( $ xml -> error ) ) { throw new Exception \ ZohoErrorException ( new ZohoError ( ( string ) $ xml -> error -> code , ( string ) $ xml -> error -> message ) ) ; } if ( isset ( $ xml -> nodata ) ) { throw new Exception \ NoDataException ( new ZohoError ( ( string ) $ xml -> nodata -> code , ( string ) $ xml -> nodata -> message ) ) ; } if ( $ this -> method == 'getFields' ) { return $ this -> parseResponseGetFields ( $ xml ) ; } if ( $ this -> method == 'deleteRecords' ) { return $ this -> parseResponseDeleteRecords ( $ xml ) ; } if ( $ this -> method == 'uploadFile' ) { return $ this -> parseResponseUploadFile ( $ xml ) ; } if ( $ this -> method == 'deleteFile' ) { return $ this -> parseResponseDeleteFile ( $ xml ) ; } if ( $ this -> method == 'getDeletedRecordIds' ) { return $ this -> parseResponseGetDeletedRecordIds ( $ xml ) ; } if ( $ this -> method == 'convertLead' ) { return $ this -> parseResponseConvertLead ( $ xml ) ; } if ( $ this -> method == 'updateRelatedRecords' ) { return $ this -> parseUpdateRelatedRecords ( $ xml ) ; } if ( isset ( $ xml -> result -> { $ this -> module } ) ) { return $ this -> parseResponseGetRecords ( $ xml ) ; } if ( isset ( $ xml -> result -> row -> success ) || isset ( $ xml -> result -> row -> error ) ) { return $ this -> parseResponsePostRecordsMultiple ( $ xml ) ; } throw new Exception \ UnexpectedValueException ( 'Xml doesn\'t contain expected fields' ) ; } 
public function where ( $ field , $ value ) { $ this -> wheres [ $ field ] = $ value ; $ this -> parseQueries ( ) ; return $ this ; } 
public function orWhere ( $ field , $ value ) { $ this -> orWheres [ ] = array ( $ field => $ value ) ; $ this -> parseQueries ( ) ; return $ this ; } 
public function boot ( ) { $ this -> publishes ( [ $ this -> configuration => config_path ( 'hijri-dates.php' ) ] , 'config' ) ; $ this -> publishes ( [ $ this -> translations => resource_path ( 'lang/vendor/hijri-dates/' ) ] , 'translation' ) ; $ this -> mergeConfigFrom ( $ this -> configuration , 'hijri-dates' ) ; $ this -> loadTranslationsFrom ( $ this -> translations , 'hijri-dates' ) ; $ translation = Config :: get ( 'hijri-dates.translation' ) ; Date :: setTranslation ( new $ translation ) ; Date :: setToStringFormat ( Config :: get ( 'hijri-dates.toStringFormat' ) ) ; Date :: setDefaultNumbers ( Config :: get ( 'hijri-dates.numeric_system' ) ) ; Hijri :: setDefaultAdjustment ( Config :: get ( 'hijri-dates.adjustment' ) ) ; } 
public function initSMTP ( ) { $ f3 = \ Base :: instance ( ) ; $ this -> smtp = new \ SMTP ( $ f3 -> get ( 'mailer.smtp.host' ) , $ f3 -> get ( 'mailer.smtp.port' ) , $ f3 -> get ( 'mailer.smtp.scheme' ) , $ f3 -> get ( 'mailer.smtp.user' ) , $ f3 -> get ( 'mailer.smtp.pw' ) ) ; if ( ! $ f3 -> devoid ( 'mailer.errors_to' , $ errors_to ) ) $ this -> setErrors ( $ errors_to ) ; if ( ! $ f3 -> devoid ( 'mailer.reply_to' , $ reply_to ) ) $ this -> setReply ( $ reply_to ) ; if ( ! $ f3 -> devoid ( 'mailer.from_mail' , $ from_mail ) ) { if ( $ f3 -> devoid ( 'mailer.from_name' , $ from_name ) ) $ from_name = NULL ; $ this -> setFrom ( $ from_mail , $ from_name ) ; } } 
protected function encode ( $ str ) { if ( empty ( $ str ) || $ this -> charset == 'UTF-8' ) return $ str ; if ( extension_loaded ( 'iconv' ) ) $ out = @ iconv ( "UTF-8" , $ this -> charset . "//IGNORE" , $ str ) ; if ( ! isset ( $ out ) || ! $ out ) $ out = extension_loaded ( 'mbstring' ) ? mb_convert_encoding ( $ str , $ this -> charset , "UTF-8" ) : utf8_decode ( $ str ) ; return $ out ? : $ str ; } 
protected function encodeHeader ( $ str ) { if ( extension_loaded ( 'iconv' ) ) { $ out = iconv_mime_encode ( 'Subject' , $ str , [ 'input-charset' => 'UTF-8' , 'output-charset' => $ this -> charset ] ) ; $ out = substr ( $ out , strlen ( 'Subject: ' ) ) ; } elseif ( extension_loaded ( 'mbstring' ) ) { mb_internal_encoding ( 'UTF-8' ) ; $ out = mb_encode_mimeheader ( $ str , $ this -> charset , 'B' , static :: $ EOL , strlen ( 'Subject: ' ) ) ; } else $ out = wordwrap ( $ str , 65 , static :: $ EOL ) ; return $ out ; } 
public function set ( $ key , $ val ) { $ this -> smtp -> set ( $ key , $ this -> encode ( $ val ) ) ; } 
public function setFrom ( $ email , $ title = null ) { $ this -> set ( 'From' , $ this -> buildMail ( $ email , $ title ) ) ; } 
public function setReply ( $ email , $ title = null ) { $ this -> set ( 'Reply-To' , $ this -> buildMail ( $ email , $ title ) ) ; } 
public function setErrors ( $ email , $ title = null ) { $ this -> set ( 'Sender' , $ this -> buildMail ( $ email , $ title ) ) ; } 
public function reset ( $ key = null ) { if ( $ key ) { $ key = ucfirst ( $ key ) ; $ this -> smtp -> clear ( $ key ) ; if ( isset ( $ this -> recipients [ $ key ] ) ) unset ( $ this -> recipients [ $ key ] ) ; } else { $ this -> recipients = array ( ) ; $ this -> initSMTP ( ) ; } } 
public function setHTML ( $ message ) { $ f3 = \ Base :: instance ( ) ; 
public function setContent ( $ data , $ mime , $ charset = NULL ) { if ( ! $ charset ) $ charset = $ this -> charset ; $ this -> message [ $ mime ] = [ 'content' => $ data , 'type' => $ mime . '; ' . $ charset ] ; } 
public function attachFile ( $ path , $ alias = null , $ cid = null ) { $ this -> smtp -> attach ( $ path , $ alias , $ cid ) ; } 
public function send ( $ subject , $ mock = false , $ log = 'verbose' ) { foreach ( $ this -> recipients as $ key => $ rcpts ) { $ mails = array ( ) ; foreach ( $ rcpts as $ mail => $ title ) $ mails [ ] = $ this -> buildMail ( $ mail , $ title ) ; $ this -> set ( $ key , implode ( ', ' , $ mails ) ) ; } $ this -> smtp -> set ( 'Subject' , $ this -> encodeHeader ( $ this -> encode ( $ subject ) ) ) ; $ body = '' ; $ hash = uniqid ( NULL , TRUE ) ; $ multipart = count ( $ this -> message ) > 1 ; if ( $ multipart ) $ this -> smtp -> set ( 'Content-Type' , 'multipart/alternative; boundary="' . $ hash . '"' ) ; $ i = 0 ; foreach ( $ this -> message as $ msg ) { if ( $ multipart ) { $ body .= '--' . $ hash . static :: $ EOL ; $ body .= 'Content-Type: ' . $ msg [ 'type' ] . static :: $ EOL . static :: $ EOL ; } else $ this -> smtp -> set ( 'Content-Type' , $ msg [ 'type' ] ) ; $ body .= $ msg [ 'content' ] . static :: $ EOL . static :: $ EOL ; } if ( $ multipart ) $ body .= '--' . $ hash . '--' . static :: $ EOL ; $ success = $ this -> smtp -> send ( $ this -> encode ( $ body ) , $ log , $ mock ) ; $ f3 = \ Base :: instance ( ) ; if ( ! $ success && $ f3 -> exists ( 'mailer.on.failure' , $ fail_handler ) ) $ f3 -> call ( $ fail_handler , array ( $ this , $ this -> smtp -> log ( ) ) ) ; return $ success ; } 
public function save ( $ filename ) { $ f3 = \ Base :: instance ( ) ; $ lines = explode ( "\n" , $ this -> smtp -> log ( ) ) ; $ start = false ; $ out = '' ; for ( $ i = 0 , $ max = count ( $ lines ) ; $ i < $ max ; $ i ++ ) { if ( ! $ start && preg_match ( '/^354.*?$/' , $ lines [ $ i ] , $ matches ) ) { $ start = true ; continue ; } elseif ( preg_match ( '/^250.*?$\s^QUIT/m' , $ lines [ $ i ] . ( $ i + 1 < $ max ? "\n" . $ lines [ $ i + 1 ] : '' ) , $ matches ) ) break ; if ( $ start ) $ out .= $ lines [ $ i ] . "\n" ; } if ( $ out ) { $ path = $ f3 -> get ( 'mailer.storage_path' ) ; if ( ! is_dir ( $ path ) ) mkdir ( $ path , 0777 , true ) ; $ f3 -> write ( $ path . $ filename , $ out ) ; } } 
static public function ping ( \ Base $ f3 , $ params ) { $ hash = $ params [ 'hash' ] ; 
static public function jump ( \ Base $ f3 , $ params ) { $ target = $ f3 -> get ( 'GET.target' ) ; 
static public function initTracking ( ) { $ f3 = \ Base :: instance ( ) ; if ( ! $ f3 -> exists ( 'mailer.ping_route' , $ ping_route ) ) $ ping_route = '/mailer-ping/@hash.png' ; $ f3 -> route ( 'GET ' . $ ping_route , '\Mailer::ping' ) ; if ( ! $ f3 -> exists ( 'mailer.jump_route' , $ jump_route ) ) $ jump_route = '/mailer-jump' ; $ f3 -> route ( 'GET ' . $ jump_route , '\Mailer::jump' ) ; } 
public function setLayout ( $ layout ) { if ( $ layout === "" || $ layout === null ) { $ this -> layout = null ; } else { $ layoutPath = $ this -> templatePath . $ layout ; if ( ! is_file ( $ layoutPath ) ) { throw new \ RuntimeException ( "Layout template `$layout` does not exist" ) ; } $ this -> layout = $ layoutPath ; } } 
public function getAttribute ( $ key ) { if ( ! isset ( $ this -> attributes [ $ key ] ) ) { return false ; } return $ this -> attributes [ $ key ] ; } 
public function fetch ( $ template , array $ data = [ ] ) { if ( isset ( $ data [ 'template' ] ) ) { throw new \ InvalidArgumentException ( "Duplicate template key found" ) ; } if ( ! is_file ( $ this -> templatePath . $ template ) ) { throw new \ RuntimeException ( "View cannot render `$template` because the template does not exist" ) ; } $ data = array_merge ( $ this -> attributes , $ data ) ; try { ob_start ( ) ; $ this -> protectedIncludeScope ( $ this -> templatePath . $ template , $ data ) ; $ output = ob_get_clean ( ) ; if ( $ this -> layout !== null ) { ob_start ( ) ; $ data [ 'content' ] = $ output ; $ this -> protectedIncludeScope ( $ this -> layout , $ data ) ; $ output = ob_get_clean ( ) ; } } catch ( \ Throwable $ e ) { 
public function setConsumer ( $ consumerKey , $ consumerSecret ) { $ this -> apiKey = $ consumerKey ; $ this -> requestHandler -> setConsumer ( $ consumerKey , $ consumerSecret ) ; } 
public function follow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/follow' , $ options , false ) ; } 
public function unfollow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/unfollow' , $ options , false ) ; } 
public function like ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/like' , $ options , false ) ; } 
public function unlike ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/unlike' , $ options , false ) ; } 
public function deletePost ( $ blogName , $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; $ path = $ this -> blogPath ( $ blogName , '/post/delete' ) ; return $ this -> postRequest ( $ path , $ options , false ) ; } 
public function reblogPost ( $ blogName , $ postId , $ reblogKey , $ options = null ) { $ params = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; $ params = array_merge ( $ options ? : array ( ) , $ params ) ; $ path = $ this -> blogPath ( $ blogName , '/post/reblog' ) ; return $ this -> postRequest ( $ path , $ params , false ) ; } 
public function editPost ( $ blogName , $ postId , $ data ) { $ data [ 'id' ] = $ postId ; $ path = $ this -> blogPath ( $ blogName , '/post/edit' ) ; return $ this -> postRequest ( $ path , $ data , false ) ; } 
public function createPost ( $ blogName , $ data ) { $ path = $ this -> blogPath ( $ blogName , '/post' ) ; return $ this -> postRequest ( $ path , $ data , false ) ; } 
public function getTaggedPosts ( $ tag , $ options = null ) { if ( ! $ options ) { $ options = array ( ) ; } $ options [ 'tag' ] = $ tag ; return $ this -> getRequest ( 'v2/tagged' , $ options , true ) ; } 
public function getBlogInfo ( $ blogName ) { $ path = $ this -> blogPath ( $ blogName , '/info' ) ; return $ this -> getRequest ( $ path , null , true ) ; } 
public function getBlogAvatar ( $ blogName , $ size = null ) { $ path = $ this -> blogPath ( $ blogName , '/avatar' ) ; if ( $ size ) { $ path .= "/$size" ; } return $ this -> getRedirect ( $ path , null , true ) ; } 
public function getBlogLikes ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/likes' ) ; return $ this -> getRequest ( $ path , $ options , true ) ; } 
public function getBlogFollowers ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/followers' ) ; return $ this -> getRequest ( $ path , $ options , false ) ; } 
public function getBlogPosts ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/posts' ) ; if ( $ options && isset ( $ options [ 'type' ] ) ) { $ path .= '/' . $ options [ 'type' ] ; unset ( $ options [ 'type' ] ) ; } return $ this -> getRequest ( $ path , $ options , true ) ; } 
public function getRequest ( $ path , $ options , $ addApiKey ) { $ response = $ this -> makeRequest ( 'GET' , $ path , $ options , $ addApiKey ) ; return $ this -> parseResponse ( $ response ) ; } 
public function postRequest ( $ path , $ options , $ addApiKey ) { if ( isset ( $ options [ 'source' ] ) && is_array ( $ options [ 'source' ] ) ) { $ sources = $ options [ 'source' ] ; unset ( $ options [ 'source' ] ) ; foreach ( $ sources as $ i => $ source ) { $ options [ "source[$i]" ] = $ source ; } } $ response = $ this -> makeRequest ( 'POST' , $ path , $ options , $ addApiKey ) ; return $ this -> parseResponse ( $ response ) ; } 
private function parseResponse ( $ response ) { $ response -> json = json_decode ( $ response -> body ) ; if ( $ response -> status < 400 ) { return $ response -> json -> response ; } else { throw new RequestException ( $ response ) ; } } 
private function getRedirect ( $ path , $ options , $ addApiKey ) { $ response = $ this -> makeRequest ( 'GET' , $ path , $ options , $ addApiKey ) ; if ( $ response -> status === 301 || $ response -> status === 302 ) { return $ response -> headers [ 'Location' ] [ 0 ] ; } return null ; } 
private function makeRequest ( $ method , $ path , $ options , $ addApiKey ) { if ( $ addApiKey ) { $ options = array_merge ( array ( 'api_key' => $ this -> apiKey ) , $ options ? : array ( ) ) ; } return $ this -> requestHandler -> request ( $ method , $ path , $ options ) ; } 
public function setConsumer ( $ key , $ secret ) { $ this -> consumer = new \ Eher \ OAuth \ Consumer ( $ key , $ secret ) ; } 
public function setToken ( $ token , $ secret ) { $ this -> token = new \ Eher \ OAuth \ Token ( $ token , $ secret ) ; } 
public function request ( $ method , $ path , $ options ) { 
public function decode ( $ data ) { $ decodedData = json_decode ( $ data , true ) ; 
public function pauseSession ( AssessmentTestSession $ session ) { $ session -> updateDuration ( ) ; return $ this -> getDeliveryExecution ( $ session ) -> setState ( DeliveryExecution :: STATE_PAUSED ) ; } 
public function resumeSession ( AssessmentTestSession $ session ) { $ deliveryExecutionState = $ this -> getSessionState ( $ session ) ; if ( $ deliveryExecutionState === DeliveryExecution :: STATE_PAUSED ) { $ this -> updateTimeReference ( $ session ) ; $ this -> getDeliveryExecution ( $ session ) -> setState ( DeliveryExecution :: STATE_ACTIVE ) ; } } 
public function getSessionState ( AssessmentTestSession $ session ) { $ deliveryExecution = $ this -> getDeliveryExecution ( $ session ) ; return $ deliveryExecution -> getState ( ) -> getUri ( ) ; } 
public function updateTimeReference ( AssessmentTestSession $ session , \ DateTime $ time = null ) { if ( $ time === null ) { $ time = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; } $ itemSession = $ session -> getCurrentAssessmentItemSession ( ) ; if ( $ itemSession ) { $ itemSession -> setTimeReference ( $ time ) ; $ session -> updateDuration ( ) ; } } 
public function getSessionDescription ( \ taoQtiTest_helpers_TestSession $ session ) { if ( $ session -> isRunning ( ) ) { $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ progressScope = isset ( $ config [ 'progress-indicator-scope' ] ) ? $ config [ 'progress-indicator-scope' ] : 'test' ; $ progress = $ this -> getSessionProgress ( $ session ) ; $ itemPosition = $ progress [ $ progressScope ] ; $ itemCount = $ progress [ $ progressScope . 'Length' ] ; $ format = $ this -> hasOption ( self :: OPTION_STATE_FORMAT ) ? $ this -> getOption ( self :: OPTION_STATE_FORMAT ) : __ ( '%s - item %p/%c' ) ; $ map = array ( '%s' => $ session -> getCurrentAssessmentSection ( ) -> getTitle ( ) , '%p' => $ itemPosition , '%c' => $ itemCount ) ; return strtr ( $ format , $ map ) ; } else { return __ ( 'finished' ) ; } } 
protected function getSessionProgress ( \ taoQtiTest_helpers_TestSession $ session ) { if ( $ session -> isRunning ( ) !== false ) { $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ categories = [ ] ; if ( isset ( $ config [ 'progress-indicator' ] ) && $ config [ 'progress-indicator' ] == 'categories' ) { $ categories = $ config [ 'progress-categories' ] ; } $ route = $ session -> getRoute ( ) ; $ routeItems = $ route -> getAllRouteItems ( ) ; $ offset = $ route -> getRouteItemPosition ( $ routeItems [ 0 ] ) ; $ offsetPart = 0 ; $ offsetSection = 0 ; $ lastPart = null ; $ lastSection = null ; $ positions = [ ] ; $ lengthParts = [ ] ; $ lengthSections = [ ] ; $ sectionIndex = 0 ; $ partIndex = 0 ; 
public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ data = $ this -> getTreeResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; return $ this -> formatTreeData ( $ data ) ; } 
private function formatTreeData ( array $ treeData ) { return array_map ( function ( $ data ) { $ formatted = [ 'categories' => $ this -> getCategoryService ( ) -> getItemCategories ( new \ core_kernel_classes_Resource ( $ data [ 'uri' ] ) ) ] ; if ( isset ( $ data [ 'children' ] ) ) { $ formatted [ 'children' ] = $ this -> formatTreeData ( $ data [ 'children' ] ) ; } return array_merge ( $ data , $ formatted ) ; } , $ treeData ) ; } 
protected function putInCache ( $ key , $ userId , $ callId , $ data , $ state = self :: STATE_ALIGNED ) { $ this -> cache [ $ key ] = [ 'userId' => $ userId , 'callId' => $ callId , 'state' => $ state , 'data' => $ data ] ; } 
protected function exists ( $ key ) { return isset ( $ this -> cache [ $ key ] ) && in_array ( $ this -> cache [ $ key ] [ 'state' ] , [ self :: STATE_ALIGNED , self :: STATE_PENDING_WRITE ] ) ; } 
protected function persistCacheEntry ( $ key ) { $ success = true ; if ( isset ( $ this -> cache [ $ key ] ) ) { $ cache = $ this -> cache [ $ key ] ; switch ( $ cache [ 'state' ] ) { case self :: STATE_PENDING_WRITE : $ success = $ this -> getStorage ( ) -> set ( $ cache [ 'userId' ] , $ cache [ 'callId' ] , $ cache [ 'data' ] ) ; if ( ! $ success ) { throw new \ common_exception_Error ( 'Can\'t write into test runner state storage at ' . static :: class ) ; } $ this -> cache [ $ key ] [ 'state' ] = self :: STATE_ALIGNED ; break ; case self :: STATE_PENDING_DELETE : $ success = $ this -> getStorage ( ) -> del ( $ cache [ 'userId' ] , $ cache [ 'callId' ] ) ; if ( $ success ) { unset ( $ this -> cache [ $ key ] ) ; } break ; } } return $ success ; } 
public function set ( $ userId , $ callId , $ data ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ cache = $ this -> getFromCache ( $ key ) ; if ( is_null ( $ cache ) || $ cache != $ data ) { $ this -> putInCache ( $ key , $ userId , $ callId , $ data , self :: STATE_PENDING_WRITE ) ; } return true ; } 
public function get ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { $ data = $ this -> getStorage ( ) -> get ( $ userId , $ callId ) ; $ state = is_null ( $ data ) ? self :: STATE_NOT_FOUND : self :: STATE_ALIGNED ; $ this -> putInCache ( $ key , $ userId , $ callId , $ data , $ state ) ; } return $ this -> getFromCache ( $ key ) ; } 
public function has ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { return $ this -> getStorage ( ) -> has ( $ userId , $ callId ) ; } return $ this -> exists ( $ key ) ; } 
public function del ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ this -> putInCache ( $ key , $ userId , $ callId , null , self :: STATE_PENDING_DELETE ) ; return true ; } 
public function persist ( $ userId = null , $ callId = null ) { if ( $ userId && $ callId ) { $ keys = [ $ this -> getCacheKey ( $ userId , $ callId ) ] ; } else { $ keys = array_keys ( $ this -> cache ) ; } $ success = true ; foreach ( $ keys as $ key ) { if ( ! $ this -> persistCacheEntry ( $ key ) ) { $ success = false ; } } return $ success ; } 
protected function packTimeLine ( & $ timeLine ) { $ epoch = $ this -> getEpoch ( ) ; $ data = [ self :: STORAGE_KEY_TIMELINE_INDEX => [ ] , self :: STORAGE_KEY_TIMELINE_TAGS => [ ] , self :: STORAGE_KEY_TIMELINE_POINTS => [ ] , self :: STORAGE_KEY_TIMELINE_EPOCH => $ epoch , ] ; 
protected function unpackTimeLine ( & $ data ) { $ timeLine = new QtiTimeLine ( ) ; 
public function encode ( $ data ) { if ( is_array ( $ data ) ) { $ encodedData = [ self :: STORAGE_KEY_FORMAT => $ this -> getFormat ( ) , self :: STORAGE_KEY_VERSION => $ this -> getVersion ( ) , ] ; foreach ( $ data as $ key => & $ value ) { if ( $ value instanceof TimeLine ) { $ encodedData [ $ key ] = $ this -> packTimeLine ( $ value ) ; } else { $ encodedData [ $ key ] = & $ value ; } } return json_encode ( $ encodedData ) ; } return json_encode ( $ data ) ; } 
public function decode ( $ data ) { $ decodedData = json_decode ( $ data , true ) ; 
protected function init ( ) { $ this -> wetRun = ( boolean ) $ this -> getOption ( 'wetRun' ) ; $ this -> report = new Report ( Report :: TYPE_INFO , 'Starting recompile deliveries' ) ; } 
protected function recompileItems ( ) { $ extManager = $ this -> getServiceLocator ( ) -> get ( \ common_ext_ExtensionsManager :: SERVICE_ID ) ; if ( $ extManager -> isInstalled ( 'taoDeliveryRdf' ) === true && $ extManager -> isEnabled ( 'taoDeliveryRdf' ) === true ) { $ compiledDeliveryClass = $ this -> getClass ( DeliveryAssemblyService :: CLASS_URI ) ; if ( $ compiledDeliveryClass -> exists ( ) === true ) { foreach ( $ compiledDeliveryClass -> getInstances ( true ) as $ compiledDelivery ) { try { $ this -> getAssessmentsFromDelivery ( $ compiledDelivery ) ; } catch ( \ Exception $ e ) { $ this -> report -> add ( new Report ( Report :: TYPE_WARNING , "Delivery {$compiledDelivery->getUri()} was skipped with message: '{$e->getMessage()}'" ) ) ; } } } } else { $ this -> report -> add ( new Report ( Report :: TYPE_WARNING , "Extension taoDeliveryRdf is not installed. No compilation environment is available." ) ) ; } } 
protected function getAssessmentsFromDelivery ( \ core_kernel_classes_Resource $ compiledDelivery ) { $ unionAssignmentService = $ this -> getServiceLocator ( ) -> get ( UnionAssignmentService :: SERVICE_ID ) ; $ runtime = $ unionAssignmentService -> getRuntime ( $ compiledDelivery ) ; $ inputParameters = \ tao_models_classes_service_ServiceCallHelper :: getInputValues ( $ runtime , [ ] ) ; $ testDefinition = \ taoQtiTest_helpers_Utils :: getTestDefinition ( $ inputParameters [ 'QtiTestCompilation' ] ) ; $ assessmentItemRefs = $ testDefinition -> getComponentsByClassName ( 'assessmentItemRef' ) ; $ this -> report -> add ( new Report ( Report :: TYPE_INFO , "Starting to recompile items for delivery {$compiledDelivery->getLabel()} with identifier {$compiledDelivery->getUri()}:" ) ) ; $ count = 0 ; foreach ( $ assessmentItemRefs as $ assessmentItemRef ) { $ directoryIds = explode ( '|' , $ assessmentItemRef -> getHref ( ) ) ; $ item = $ this -> getResource ( $ directoryIds [ 0 ] ) ; $ properties = [ ] ; foreach ( $ item -> getRdfTriples ( ) as $ triple ) { $ properties [ $ triple -> predicate ] = $ triple -> object ; } if ( $ properties ) { $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 2 ] ) ; $ languages = $ item -> getUsedLanguages ( $ this -> getProperty ( \ taoItems_models_classes_ItemsService :: PROPERTY_ITEM_CONTENT ) ) ; foreach ( $ languages as $ lang ) { $ path = $ lang . DIRECTORY_SEPARATOR . QtiJsonItemCompiler :: METADATA_FILE_NAME ; if ( ! $ directory -> has ( $ path ) ) { $ this -> writeMetadata ( $ item , $ directory , $ path , $ properties ) ; $ count ++ ; } } } } $ this -> report -> add ( new Report ( Report :: TYPE_INFO , "Was updated {$count} items." ) ) ; } 
protected function saveToolStates ( ) { $ toolStateParameter = 'toolStates' ; if ( $ this -> hasRequestParameter ( $ toolStateParameter ) ) { 
protected function getToolStates ( ) { $ toolStates = $ this -> getRunnerService ( ) -> getToolsStates ( $ this -> getServiceContext ( ) ) ; array_walk ( $ toolStates , function ( & $ toolState ) { $ toolState = json_decode ( $ toolState ) ; } ) ; return $ toolStates ; } 
public function init ( ) { 
protected function initCompilationDirectory ( ) { $ fileStorage = \ tao_models_classes_service_FileStorage :: singleton ( ) ; $ directoryIds = explode ( '|' , $ this -> getTestCompilationUri ( ) ) ; $ directories = array ( 'private' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 0 ] ) , 'public' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 1 ] ) ) ; $ this -> compilationDirectory = $ directories ; } 
protected function initStorage ( ) { $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ this -> getTestExecutionUri ( ) ) ; $ testResource = new \ core_kernel_classes_Resource ( $ this -> getTestDefinitionUri ( ) ) ; $ sessionManager = new \ taoQtiTest_helpers_SessionManager ( $ resultStore , $ testResource ) ; $ seeker = new BinaryAssessmentTestSeeker ( $ this -> getTestDefinition ( ) ) ; $ userUri = $ this -> getUserUri ( ) ; $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ storageClassName = $ config [ 'test-session-storage' ] ; $ this -> storage = new $ storageClassName ( $ sessionManager , $ seeker , $ userUri ) ; $ this -> sessionManager = $ sessionManager ; } 
protected function retrieveItemIndex ( ) { $ this -> itemIndex = new QtiTestCompilerIndex ( ) ; try { $ directories = $ this -> getCompilationDirectory ( ) ; $ data = $ directories [ 'private' ] -> read ( taoQtiTest_models_classes_QtiTestService :: TEST_COMPILED_INDEX ) ; if ( $ data ) { $ this -> itemIndex -> unserialize ( $ data ) ; } } catch ( \ Exception $ e ) { \ common_Logger :: d ( 'Ignoring file not found exception for Items Index' ) ; } } 
public function getItemIndexValue ( $ id , $ name ) { return $ this -> itemIndex -> getItemValue ( $ id , \ common_session_SessionManager :: getSession ( ) -> getInterfaceLanguage ( ) , $ name ) ; } 
public function getCatEngine ( RouteItem $ routeItem = null ) { $ compiledDirectory = $ this -> getCompilationDirectory ( ) [ 'private' ] ; $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ compiledDirectory ) ; $ routeItem = $ routeItem ? $ routeItem : $ this -> getTestSession ( ) -> getRoute ( ) -> current ( ) ; $ sectionId = $ routeItem -> getAssessmentSection ( ) -> getIdentifier ( ) ; $ catEngine = false ; if ( isset ( $ adaptiveSectionMap [ $ sectionId ] ) ) { $ catEngine = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getEngine ( $ adaptiveSectionMap [ $ sectionId ] [ 'endpoint' ] ) ; } return $ catEngine ; } 
public function getCatSession ( RouteItem $ routeItem = null ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getCatSession ( $ this -> getTestSession ( ) , $ this -> getCompilationDirectory ( ) [ 'private' ] , $ routeItem ) ; } 
public function persistCatSession ( $ catSession , RouteItem $ routeItem = null ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> persistCatSession ( $ catSession , $ this -> getTestSession ( ) , $ this -> getCompilationDirectory ( ) [ 'private' ] , $ routeItem ) ; } 
public function persistSeenCatItemIds ( $ seenCatItemId ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ items = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> getCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-seen-item-ids' ) ; if ( ! $ items ) { $ items = [ ] ; } else { $ items = json_decode ( $ items ) ; } if ( ! in_array ( $ seenCatItemId , $ items ) ) { $ items [ ] = $ seenCatItemId ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-seen-item-ids' , json_encode ( $ items ) ) ; } 
public function getLastCatItemOutput ( ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ itemOutput = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> getCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' ) ; $ output = [ ] ; if ( ! is_null ( $ itemOutput ) ) { $ rawData = json_decode ( $ itemOutput , true ) ; foreach ( $ rawData as $ result ) { $ itemResult = ItemResult :: restore ( $ result ) ; $ output [ $ itemResult -> getItemRefId ( ) ] = $ itemResult ; } } return $ output ; } 
public function persistLastCatItemOutput ( array $ lastCatItemOutput ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' , json_encode ( $ lastCatItemOutput ) ) ; } 
public function isAdaptive ( AssessmentItemRef $ currentAssessmentItemRef = null ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> isAdaptive ( $ this -> getTestSession ( ) , $ currentAssessmentItemRef ) ; } 
public function containsAdaptive ( ) { $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ this -> getCompilationDirectory ( ) [ 'private' ] ) ; return ! empty ( $ adaptiveSectionMap ) ; } 
public function selectAdaptiveNextItem ( ) { $ lastItemId = $ this -> getCurrentCatItemId ( ) ; $ lastOutput = $ this -> getLastCatItemOutput ( ) ; $ catSession = $ this -> getCatSession ( ) ; $ preSelection = $ catSession -> getTestMap ( ) ; try { if ( ! $ this -> syncingMode ) { $ selection = $ catSession -> getTestMap ( array_values ( $ lastOutput ) ) ; if ( ! $ this -> saveAdaptiveResults ( $ catSession ) ) { \ common_Logger :: w ( 'Unable to save CatService results.' ) ; } $ isShadowItem = false ; } else { $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } } catch ( CatEngineException $ e ) { \ common_Logger :: e ( 'Error during CatEngine processing. ' . $ e -> getMessage ( ) ) ; $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } $ event = new SelectAdaptiveNextItemEvent ( $ this -> getTestSession ( ) , $ lastItemId , $ preSelection , $ selection , $ isShadowItem ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ this -> persistCatSession ( $ catSession ) ; if ( is_array ( $ selection ) && count ( $ selection ) > 0 ) { \ common_Logger :: d ( "New CAT item selection is '" . implode ( ', ' , $ selection ) . "'." ) ; return $ selection [ 0 ] ; } else { \ common_Logger :: d ( 'No new CAT item selection.' ) ; return null ; } } 
public function getCurrentAssessmentItemRef ( ) { if ( $ this -> isAdaptive ( ) ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAssessmentItemRefByIdentifier ( $ this -> getCompilationDirectory ( ) [ 'private' ] , $ this -> getCurrentCatItemId ( ) ) ; } else { return $ this -> getTestSession ( ) -> getCurrentAssessmentItemRef ( ) ; } } 
public function getCurrentPosition ( ) { $ route = $ this -> getTestSession ( ) -> getRoute ( ) ; $ routeCount = $ route -> count ( ) ; $ routeItemPosition = $ route -> getPosition ( ) ; $ currentRouteItem = $ route -> getRouteItemAt ( $ routeItemPosition ) ; $ finalPosition = 0 ; for ( $ i = 0 ; $ i < $ routeCount ; $ i ++ ) { $ routeItem = $ route -> getRouteItemAt ( $ i ) ; if ( $ routeItem !== $ currentRouteItem ) { if ( ! $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition ++ ; } else { $ finalPosition += count ( $ this -> getShadowTest ( $ routeItem ) ) ; } } else { if ( $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition += array_search ( $ this -> getCurrentCatItemId ( $ routeItem ) , $ this -> getShadowTest ( $ routeItem ) ) ; } break ; } } return $ finalPosition ; } 
public function canMoveBackward ( ) { $ moveBack = false ; $ session = $ this -> getTestSession ( ) ; if ( $ this -> isAdaptive ( ) ) { $ positionInCatSession = array_search ( $ this -> getCurrentCatItemId ( ) , $ this -> getShadowTest ( ) ) ; if ( $ positionInCatSession === 0 ) { 
protected function saveAdaptiveResults ( CatSession $ catSession ) { $ testResult = $ catSession -> getTestResult ( ) ; $ testResult = empty ( $ testResult ) ? [ ] : [ $ testResult ] ; return $ this -> storeResult ( array_merge ( $ testResult , $ catSession -> getItemResults ( ) ) ) ; } 
protected function storeResult ( array $ results ) { $ runnerService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerService :: SERVICE_ID ) ; $ success = true ; try { foreach ( $ results as $ result ) { if ( ! $ result instanceof AbstractResult ) { throw new \ common_Exception ( __FUNCTION__ . ' requires a CAT result to store it.' ) ; } $ variables = $ this -> convertCatVariables ( $ result -> getVariables ( ) ) ; if ( empty ( $ variables ) ) { \ common_Logger :: t ( 'No Cat result variables to store.' ) ; continue ; } if ( $ result instanceof ItemResult ) { $ itemId = $ result -> getItemRefId ( ) ; $ itemUri = $ this -> getItemUriFromRefId ( $ itemId ) ; } else { $ itemUri = $ itemId = null ; $ sectionId = $ this -> getTestSession ( ) -> getRoute ( ) -> current ( ) -> getAssessmentSection ( ) -> getIdentifier ( ) ; foreach ( $ variables as $ variable ) { $ variable -> setIdentifier ( $ sectionId . '-' . $ variable -> getIdentifier ( ) ) ; } } if ( ! $ runnerService -> storeVariables ( $ this , $ itemUri , $ variables , $ itemId ) ) { $ success = false ; } } } catch ( \ Exception $ e ) { \ common_Logger :: w ( 'An error has occurred during CAT result storing: ' . $ e -> getMessage ( ) ) ; $ success = false ; } return $ success ; } 
protected function convertCatVariables ( array $ variables ) { $ runnerService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerService :: SERVICE_ID ) ; $ convertedVariables = [ ] ; foreach ( $ variables as $ variable ) { switch ( $ variable -> getVariableType ( ) ) { case ResultVariable :: TRACE_VARIABLE : $ getVariableMethod = 'getTraceVariable' ; break ; case ResultVariable :: RESPONSE_VARIABLE : $ getVariableMethod = 'getResponseVariable' ; break ; case ResultVariable :: OUTCOME_VARIABLE : $ getVariableMethod = 'getOutcomeVariable' ; break ; case ResultVariable :: TEMPLATE_VARIABLE : default : $ getVariableMethod = null ; break ; } if ( is_null ( $ getVariableMethod ) ) { \ common_Logger :: w ( 'Variable of type ' . $ variable -> getVariableType ( ) . ' is not implemented in ' . __METHOD__ ) ; throw new \ common_exception_NotImplemented ( ) ; } $ convertedVariables [ ] = call_user_func_array ( array ( $ runnerService , $ getVariableMethod ) , array ( $ variable -> getId ( ) , $ variable -> getValue ( ) ) ) ; } return $ convertedVariables ; } 
protected function getItemUriFromRefId ( $ itemId ) { $ ref = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAssessmentItemRefByIdentifier ( $ this -> getCompilationDirectory ( ) [ 'private' ] , $ itemId ) ; return explode ( '|' , $ ref -> getHref ( ) ) [ 0 ] ; } 
public function process ( QtiRunnerServiceContext $ context , array $ data = [ ] ) { return $ this -> getServiceManager ( ) -> get ( SynchronisationService :: SERVICE_ID ) -> process ( $ data , $ context ) ; } 
public function process ( ) { $ this -> validate ( ) ; $ ref = ( $ this -> getRequestParameter ( 'ref' ) === false ) ? null : $ this -> getRequestParameter ( 'ref' ) ; $ direction = $ this -> getRequestParameter ( 'direction' ) ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( false ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ serviceContext -> getTestSession ( ) -> initItemTimer ( $ this -> getTime ( ) ) ; $ result = $ this -> getRunnerService ( ) -> move ( $ serviceContext , $ direction , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { 
protected function initServiceContext ( ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> getRunnerService ( ) -> check ( $ serviceContext ) ; return $ serviceContext -> init ( ) ; } 
protected function endItemTimer ( $ timestamp = null ) { if ( $ this -> getRequestParameter ( 'itemDuration' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemDuration = $ this -> getRequestParameter ( 'itemDuration' ) ; return $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ timestamp ) ; } return false ; } 
protected function saveItemState ( ) { if ( $ this -> getRequestParameter ( 'itemDefinition' ) && $ this -> getRequestParameter ( 'itemState' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemIdentifier = $ this -> getRequestParameter ( 'itemDefinition' ) ; $ state = $ this -> getRequestParameter ( 'itemState' ) ? json_decode ( $ this -> getRequestParameter ( 'itemState' ) , true ) : new \ stdClass ( ) ; return $ this -> getRunnerService ( ) -> setItemState ( $ serviceContext , $ itemIdentifier , $ state ) ; } return false ; } 
protected function saveItemResponses ( $ emptyAllowed = true ) { if ( $ this -> getRequestParameter ( 'itemDefinition' ) && $ this -> getRequestParameter ( 'itemResponse' ) ) { $ itemDefinition = $ this -> getRequestParameter ( 'itemDefinition' ) ; $ serviceContext = $ this -> getServiceContext ( ) ; $ itemResponse = $ this -> getRequestParameter ( 'itemResponse' ) ? json_decode ( $ this -> getRequestParameter ( 'itemResponse' ) , true ) : null ; if ( ! is_null ( $ itemResponse ) && ! empty ( $ itemDefinition ) ) { $ responses = $ this -> getRunnerService ( ) -> parsesItemResponse ( $ serviceContext , $ itemDefinition , $ itemResponse ) ; 
protected function getItemRef ( $ itemIdentifier ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ mapService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerMap :: SERVICE_ID ) ; return $ mapService -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; } 
public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> timeout ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { 
public function getRubrics ( RunnerServiceContext $ context , AssessmentItemRef $ itemRef = null ) { $ session = $ context -> getTestSession ( ) ; $ routeItem = null ; if ( ! is_null ( $ itemRef ) ) { try { $ routeItem = $ session -> getRoute ( ) -> getRouteItemsByAssessmentItemRef ( $ itemRef ) ; if ( $ routeItem ) { $ routeItem = $ routeItem [ 0 ] ; } } catch ( OutOfBoundsException $ obe ) { \ common_Logger :: d ( "Could not retrieve the route for item '${itemRef}'." ) ; } } else { $ routeItem = $ session -> getRoute ( ) -> current ( ) ; } return implode ( '' , $ this -> getRubricBlock ( $ routeItem , $ session , $ context -> getCompilationDirectory ( ) ) ) ; } 
public function process ( ) { $ this -> validate ( ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> pause ( $ serviceContext ) ; $ response = [ 'success' => $ result ] ; } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; } 
public function move ( RunnerServiceContext $ context , $ ref ) { QtiRunnerNavigation :: checkTimedSectionExit ( $ context , $ context -> getItemPositionInRoute ( $ ref ) ) ; $ catItemId = '' ; $ pos = $ context -> getItemPositionInRoute ( intval ( $ ref ) , $ catItemId ) ; if ( $ context -> isAdaptive ( ) ) { 
public function processInput ( QtiRunnerServiceContext $ context , array $ input ) { $ responses = [ ] ; foreach ( $ input as $ data ) { if ( ! is_array ( $ data ) || ! isset ( $ data [ 'channel' ] ) || ! isset ( $ data [ 'message' ] ) ) { throw new \ common_exception_InconsistentData ( 'Wrong message chunk received by the bidirectional communication service: either channel or message content is missing!' ) ; } if ( $ this -> hasChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ) { $ channel = $ this -> getChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ; 
public function processOutput ( QtiRunnerServiceContext $ context ) { $ messages = [ ] ; $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; if ( is_array ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] ) ) { foreach ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] as $ outputChannelName => $ outputChannelClass ) { $ channel = $ this -> getChannel ( $ outputChannelName , self :: CHANNEL_TYPE_OUTPUT ) ; $ message = $ this -> processChannel ( $ channel , $ context ) ; if ( $ message !== null ) { $ messages [ ] = [ 'channel' => $ channel -> getName ( ) , 'message' => $ message , ] ; } } } return $ messages ; } 
protected function hasChannel ( $ channelName , $ channelType ) { $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; return isset ( $ channels [ $ channelType ] [ $ channelName ] ) ; } 
public static function getCatInfo ( AssessmentTest $ test , $ namespace = '' ) { if ( $ namespace === '' ) { $ namespace = CatService :: QTI_2X_ADAPTIVE_XML_NAMESPACE ; } $ info = [ ] ; foreach ( $ test -> getComponentsByClassName ( 'assessmentSection' ) as $ assessmentSection ) { if ( ( $ selection = $ assessmentSection -> getSelection ( ) ) !== null && ( ( $ xmlExtension = $ selection -> getXml ( ) ) ) !== null ) { $ xpath = new \ DOMXPath ( $ xmlExtension ) ; $ xpath -> registerNamespace ( 'ais' , $ namespace ) ; 
public static function isAssessmentSectionAdaptive ( AssessmentSection $ section , $ namespace = '' ) { if ( $ namespace === '' ) { $ namespace = CatService :: QTI_2X_ADAPTIVE_XML_NAMESPACE ; } $ isAdaptive = false ; if ( ( $ selection = $ section -> getSelection ( ) ) !== null && ( ( $ xmlExtension = $ selection -> getXml ( ) ) ) !== null ) { $ xpath = new \ DOMXPath ( $ xmlExtension ) ; $ xpath -> registerNamespace ( 'ais' , $ namespace ) ; if ( $ xpath -> query ( './/ais:adaptiveItemSelection' , $ xmlExtension ) -> length > 0 ) { $ isAdaptive = true ; } } return $ isAdaptive ; } 
protected function buildConfig ( ) { if ( $ this -> hasOption ( self :: OPTION_CONFIG ) ) { 
public function getConfigValue ( $ name ) { $ config = $ this -> getConfig ( ) ; $ path = explode ( '.' , ( string ) $ name ) ; foreach ( $ path as $ entry ) { if ( isset ( $ config [ $ entry ] ) ) { $ config = & $ config [ $ entry ] ; } else { return null ; } } return $ config ; } 
protected function buildOptions ( RunnerServiceContext $ context ) { $ session = $ context -> getTestSession ( ) ; 
public function getEngine ( $ endpoint ) { if ( $ this -> isInitialCall == true ) { $ endpointCached = $ endpoint . '-init' ; } else { $ endpointCached = $ endpoint ; } if ( ! isset ( $ this -> engines [ $ endpointCached ] ) ) { $ endPoints = $ this -> getOption ( self :: OPTION_ENGINE_ENDPOINTS ) ; if ( ! empty ( $ endPoints [ $ endpoint ] ) ) { $ engineOptions = $ endPoints [ $ endpoint ] ; $ class = $ engineOptions [ self :: OPTION_ENGINE_CLASS ] ; $ args = $ engineOptions [ self :: OPTION_ENGINE_ARGS ] ; $ args = $ this -> alterTimeoutCallValue ( $ args ) ; $ url = isset ( $ engineOptions [ self :: OPTION_ENGINE_URL ] ) ? $ engineOptions [ self :: OPTION_ENGINE_URL ] : $ endpoint ; array_unshift ( $ args , $ endpoint ) ; try { $ this -> engines [ $ endpointCached ] = new $ class ( $ url , $ this -> getCatEngineVersion ( $ args ) , $ this -> getCatEngineClient ( $ args ) ) ; } catch ( \ Exception $ e ) { \ common_Logger :: e ( 'Fail to connect to CAT endpoint : ' . $ e -> getMessage ( ) ) ; throw new CatEngineNotFoundException ( 'CAT Engine for endpoint "' . $ endpoint . '" is misconfigured.' , $ endpoint , 0 , $ e ) ; } } } if ( empty ( $ this -> engines [ $ endpointCached ] ) ) { 
public function getAssessmentItemRefByIdentifier ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , $ identifier ) { $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-item-ref-${identifier}" ; return $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , "${filename}" ) ; } 
public function getAssessmentItemRefByIdentifiers ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , array $ identifiers ) { $ assessmentItemRefs = [ ] ; foreach ( $ identifiers as $ identifier ) { $ assessmentItemRefs [ ] = $ this -> getAssessmentItemRefByIdentifier ( $ privateCompilationDirectory , $ identifier ) ; } return $ assessmentItemRefs ; } 
public function getAssessmentItemRefsByPlaceholder ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , AssessmentItemRef $ placeholder ) { $ urlinfo = parse_url ( $ placeholder -> getHref ( ) ) ; $ adaptiveSectionId = ltrim ( $ urlinfo [ 'path' ] , '/' ) ; $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-section-${adaptiveSectionId}" ; $ component = $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , $ filename ) ; return $ component -> getComponentsByClassName ( 'assessmentItemRef' ) -> getArrayCopy ( ) ; } 
public function getAdaptiveAssessmentSectionInfo ( AssessmentTest $ test , \ tao_models_classes_service_StorageDirectory $ compilationDirectory , $ basePath , $ qtiAssessmentSectionIdentifier ) { $ info = CatUtils :: getCatInfo ( $ test ) ; $ adaptiveInfo = [ 'qtiSectionIdentifier' => $ qtiAssessmentSectionIdentifier , 'adaptiveSectionIdentifier' => false , 'adaptiveEngineRef' => false ] ; if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] ) ) { if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ) ) { $ adaptiveInfo [ 'adaptiveEngineRef' ] = $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ; } if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) { $ adaptiveInfo [ 'adaptiveSectionIdentifier' ] = trim ( $ compilationDirectory -> read ( "./${basePath}/" . $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) ; } } return ( ! isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ) || ! isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) ? false : $ adaptiveInfo ; } 
public function validateAdaptiveAssessmentSection ( SectionPartCollection $ sectionsParts , $ ref , $ testAdminId ) { $ engine = $ this -> getEngine ( $ ref ) ; $ adaptSection = $ engine -> setupSection ( $ testAdminId ) ; 
public function isAssessmentSectionAdaptive ( AssessmentSection $ section ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; return count ( $ assessmentItemRefs ) === 1 && $ this -> isAdaptivePlaceholder ( $ assessmentItemRefs [ 0 ] ) ; } 
protected function getCatEngineClient ( array $ options = [ ] ) { if ( ! isset ( $ options [ self :: OPTION_ENGINE_CLIENT ] ) ) { throw new \ InvalidArgumentException ( 'No API client provided. Cannot connect to endpoint.' ) ; } $ client = $ options [ self :: OPTION_ENGINE_CLIENT ] ; if ( is_array ( $ client ) ) { $ clientClass = isset ( $ client [ 'class' ] ) ? $ client [ 'class' ] : null ; $ clientOptions = isset ( $ client [ 'options' ] ) ? $ client [ 'options' ] : array ( ) ; if ( ! is_a ( $ clientClass , ClientInterface :: class , true ) ) { throw new \ InvalidArgumentException ( 'Client has to implement ClientInterface interface.' ) ; } $ client = new $ clientClass ( $ clientOptions ) ; } elseif ( is_object ( $ client ) ) { if ( ! is_a ( $ client , ClientInterface :: class ) ) { throw new \ InvalidArgumentException ( 'Client has to implement ClientInterface interface.' ) ; } } else { throw new \ InvalidArgumentException ( 'Client is misconfigured.' ) ; } $ this -> propagate ( $ client ) ; return $ client ; } 
public function getCatSection ( AssessmentTestSession $ testSession , \ tao_models_classes_service_StorageDirectory $ compilationDirectory , RouteItem $ routeItem = null ) { $ routeItem = $ routeItem ? $ routeItem : $ testSession -> getRoute ( ) -> current ( ) ; $ sectionId = $ routeItem -> getAssessmentSection ( ) -> getIdentifier ( ) ; if ( ! isset ( $ this -> catSection [ $ sectionId ] ) || $ this -> isInitialCall === true ) { 
public function getCatSession ( AssessmentTestSession $ testSession , \ tao_models_classes_service_StorageDirectory $ compilationDirectory , RouteItem $ routeItem = null ) { if ( $ catSection = $ this -> getCatSection ( $ testSession , $ compilationDirectory , $ routeItem ) ) { $ catSectionId = $ catSection -> getSectionId ( ) ; if ( ! isset ( $ this -> catSession [ $ catSectionId ] ) ) { 
public function persistCatSession ( $ catSession , AssessmentTestSession $ testSession , \ tao_models_classes_service_StorageDirectory $ compilationDirectory , RouteItem $ routeItem = null ) { if ( $ catSection = $ this -> getCatSection ( $ testSession , $ compilationDirectory , $ routeItem ) ) { $ catSectionId = $ catSection -> getSectionId ( ) ; $ this -> catSession [ $ catSectionId ] = $ catSession ; $ sessionId = $ testSession -> getSessionId ( ) ; $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ catSectionId , 'cat-session' , json_encode ( $ this -> catSession [ $ catSectionId ] ) ) ; } } 
protected function alterTimeoutCallValue ( array $ options ) { $ timeoutValue = null ; if ( $ this -> isInitialCall === true ) { if ( $ this -> hasOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ; } } else { if ( $ this -> hasOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ; } } if ( ! is_null ( $ timeoutValue ) ) { $ options [ self :: OPTION_ENGINE_CLIENT ] [ 'options' ] [ 'http_client_options' ] [ 'timeout' ] = $ timeoutValue ; } return $ options ; } 
public function process ( ) { $ this -> validate ( ) ; $ itemRef = $ this -> hasRequestParameter ( 'itemDefinition' ) ? $ this -> getItemRef ( $ this -> getRequestParameter ( 'itemDefinition' ) ) : null ; $ traceData = json_decode ( html_entity_decode ( $ this -> getRequestParameter ( 'traceData' ) ) , true ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ stored = 0 ; $ size = count ( $ traceData ) ; foreach ( $ traceData as $ variableIdentifier => $ variableValue ) { if ( $ this -> getRunnerService ( ) -> storeTraceVariable ( $ serviceContext , $ itemRef , $ variableIdentifier , $ variableValue ) ) { $ stored ++ ; } } $ response = [ 'success' => $ stored == $ size ] ; common_Logger :: d ( 'Stored "' . $ stored . '/' . $ size . '" trace variables' ) ; $ eventManager = $ this -> getServiceLocator ( ) -> get ( EventManager :: SERVICE_ID ) ; $ event = new TraceVariableStored ( $ serviceContext -> getTestSession ( ) -> getSessionId ( ) , $ traceData ) ; $ eventManager -> trigger ( $ event ) ; } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; } 
public function move ( RunnerServiceContext $ context , $ ref ) { $ session = $ context -> getTestSession ( ) ; $ session -> skip ( ) ; $ session -> moveNext ( ) ; return true ; } 
public function store ( $ data ) { $ this -> cache [ $ this -> testSessionId ] = & $ data ; $ encodedData = $ this -> getStorageFormat ( ) -> encode ( $ data ) ; $ this -> getStorageService ( ) -> set ( $ this -> getUserKey ( ) , $ this -> getStorageKey ( ) , $ encodedData ) ; \ common_Logger :: d ( sprintf ( 'QtiTimer: Stored %d bytes into state storage' , strlen ( $ encodedData ) ) ) ; return $ this ; } 
public function load ( ) { if ( ! isset ( $ this -> cache [ $ this -> testSessionId ] ) ) { $ encodedData = $ this -> getStorageService ( ) -> get ( $ this -> getUserKey ( ) , $ this -> getStorageKey ( ) ) ; \ common_Logger :: d ( sprintf ( 'QtiTimer: Loaded %d bytes from state storage' , strlen ( $ encodedData ) ) ) ; $ this -> cache [ $ this -> testSessionId ] = $ this -> getStorageFormat ( ) -> decode ( $ encodedData ) ; } return $ this -> cache [ $ this -> testSessionId ] ; } 
public function process ( $ data , $ serviceContext ) { if ( empty ( $ data ) ) { throw new \ common_exception_InconsistentData ( 'No action to check. Processing action requires data.' ) ; } 
public function getAvailableActions ( ) { return is_array ( $ this -> getOption ( self :: ACTIONS_OPTION ) ) ? $ this -> getOption ( self :: ACTIONS_OPTION ) : [ ] ; } 
protected function resolve ( $ data ) { if ( ! isset ( $ data [ 'action' ] ) || ! isset ( $ data [ 'timestamp' ] ) || ! isset ( $ data [ 'parameters' ] ) || ! is_array ( $ data [ 'parameters' ] ) ) { throw new \ common_exception_InconsistentData ( 'Action parameters have to contain "action", "timestamp" and "parameters" fields.' ) ; } $ availableActions = $ this -> getAvailableActions ( ) ; $ actionName = $ data [ 'action' ] ; $ actionClass = null ; 
public function process ( ) { $ this -> validate ( ) ; $ itemIdentifier = $ this -> hasRequestParameter ( 'itemDefinition' ) ? $ this -> getRequestParameter ( 'itemDefinition' ) : null ; if ( ! is_array ( $ itemIdentifier ) ) { $ itemIdentifier = [ $ itemIdentifier ] ; } try { if ( ! $ this -> getRunnerService ( ) -> getTestConfig ( ) -> getConfigValue ( 'itemCaching.enabled' ) ) { common_Logger :: w ( 'Attempt to disclose the next items without the configuration' ) ; throw new common_exception_Unauthorized ( ) ; } $ response = [ ] ; foreach ( $ itemIdentifier as $ itemId ) { 
protected function getItemData ( $ itemIdentifier ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemRef = $ this -> getRunnerService ( ) -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; $ itemData = $ this -> getRunnerService ( ) -> getItemData ( $ serviceContext , $ itemRef ) ; $ baseUrl = $ this -> getRunnerService ( ) -> getItemPublicUrl ( $ serviceContext , $ itemRef ) ; $ itemState = $ this -> getRunnerService ( ) -> getItemState ( $ serviceContext , $ itemIdentifier ) ; if ( $ itemState === null || ! count ( $ itemState ) ) { $ itemState = new stdClass ( ) ; } return [ 'baseUrl' => $ baseUrl , 'itemData' => $ itemData , 'itemState' => $ itemState , 'itemIdentifier' => $ itemIdentifier , ] ; } 
public function getStateMessage ( $ testSession ) { if ( $ testSession instanceof AssessmentTestSession ) { switch ( $ testSession -> getState ( ) ) { case AssessmentTestSessionState :: SUSPENDED : return $ this -> getPausedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: CLOSED : return $ this -> getTerminatedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: INITIAL : return $ this -> getInitialStateMessage ( $ testSession ) ; default : return $ this -> getRunningStateMessages ( $ testSession ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerMessageService' , 'getStateMessage' , 0 , 'qtism\runtime\tests\AssessmentTestSession' , $ testSession ) ; } } 
public function getItems ( RunnerServiceContext $ serviceContext ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ serviceContext ) ; $ runnerService = $ this -> getRunnerService ( ) ; $ testMap = $ runnerService -> getTestMap ( $ serviceContext ) ; $ items = [ ] ; foreach ( $ this -> getItemIdentifiersFromTestMap ( $ testMap ) as $ itemIdentifier ) { $ itemRef = $ runnerService -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; $ items [ $ itemIdentifier ] = [ 'baseUrl' => $ runnerService -> getItemPublicUrl ( $ serviceContext , $ itemRef ) , 'itemData' => $ this -> getItemData ( $ serviceContext , $ itemRef ) , 'itemState' => $ runnerService -> getItemState ( $ serviceContext , $ itemIdentifier ) , 'itemIdentifier' => $ itemIdentifier , 'portableElements' => $ runnerService -> getItemPortableElements ( $ serviceContext , $ itemRef ) , ] ; } return $ items ; } 
private function getItemData ( RunnerServiceContext $ context , $ itemRef ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ context ) ; $ itemData = $ this -> getRunnerService ( ) -> getItemData ( $ context , $ itemRef ) ; $ itemDataVariable = $ this -> getRunnerService ( ) -> getItemVariableElementsData ( $ context , $ itemRef ) ; $ responses = $ itemData [ 'data' ] [ 'responses' ] ; foreach ( array_keys ( $ responses ) as $ responseId ) { if ( array_key_exists ( $ responseId , $ itemDataVariable ) ) { $ itemData [ 'data' ] [ 'responses' ] [ $ responseId ] = array_merge ( ... [ $ responses [ $ responseId ] , $ itemDataVariable [ $ responseId ] , ] ) ; } } return $ itemData ; } 
private function getSubIdentifiersRecursively ( $ array , $ identifiers ) { $ identifier = array_shift ( $ identifiers ) ; if ( count ( $ identifiers ) > 0 ) { $ result = [ ] ; foreach ( $ array [ $ identifier ] as $ key => $ value ) { $ result [ ] = $ this -> getSubIdentifiersRecursively ( $ array [ $ identifier ] [ $ key ] , $ identifiers ) ; } return array_merge ( ... $ result ) ; } return array_keys ( $ array [ $ identifier ] ) ; } 
public function getStorage ( ) { if ( ! $ this -> storage ) { $ this -> storage = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storage ; } 
public function load ( ) { $ storage = $ this -> getStorage ( ) ; if ( $ storage ) { $ data = $ storage -> get ( $ this -> userId , $ this -> getStorageKey ( ) ) ; if ( $ data ) { $ this -> state = json_decode ( $ data , true ) ; } else { $ this -> state = [ ] ; } $ success = is_array ( $ this -> state ) ; } else { $ success = false ; } return $ success ; } 
public function save ( ) { $ storage = $ this -> getStorage ( ) ; if ( $ storage ) { $ success = $ storage -> set ( $ this -> userId , $ this -> getStorageKey ( ) , json_encode ( $ this -> state ) ) ; } else { $ success = false ; } return $ success ; } 
public function setItemFlag ( $ itemRef , $ flag ) { $ this -> state [ self :: VAR_REVIEW ] [ $ itemRef ] = $ flag ; return $ this ; } 
public function getItemFlag ( $ itemRef ) { return isset ( $ this -> state [ self :: VAR_REVIEW ] ) && isset ( $ this -> state [ self :: VAR_REVIEW ] [ $ itemRef ] ) ? $ this -> state [ self :: VAR_REVIEW ] [ $ itemRef ] : false ; } 
public function getStoreId ( ) { return isset ( $ this -> state [ self :: VAR_STORE_ID ] ) ? $ this -> state [ self :: VAR_STORE_ID ] : false ; } 
public function addEvent ( $ eventName , $ data = null ) { $ eventId = uniqid ( 'event' , true ) ; $ this -> state [ self :: VAR_EVENTS_QUEUE ] [ $ eventId ] = [ 'id' => $ eventId , 'timestamp' => microtime ( true ) , 'user' => \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) , 'type' => $ eventName , 'data' => $ data , ] ; return $ eventId ; } 
public function getEvents ( ) { if ( isset ( $ this -> state [ self :: VAR_EVENTS_QUEUE ] ) ) { $ events = $ this -> state [ self :: VAR_EVENTS_QUEUE ] ; } else { $ events = [ ] ; } return $ events ; } 
public function removeEvents ( $ ids = [ ] ) { $ removed = false ; if ( isset ( $ this -> state [ self :: VAR_EVENTS_QUEUE ] ) ) { foreach ( $ ids as $ id ) { if ( isset ( $ this -> state [ self :: VAR_EVENTS_QUEUE ] [ $ id ] ) ) { unset ( $ this -> state [ self :: VAR_EVENTS_QUEUE ] [ $ id ] ) ; $ removed = true ; } } } return $ removed ; } 
public function getItemHrefIndex ( ) { if ( isset ( $ this -> state [ self :: VAR_HREF_INDEX ] ) ) { $ table = $ this -> state [ self :: VAR_HREF_INDEX ] ; } else { $ table = [ ] ; } return $ table ; } 
public function setCatValue ( $ assessmentSectionId , $ key , $ value ) { $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] = $ value ; return $ this ; } 
public function getCatValue ( $ assessmentSectionId , $ key ) { return ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) ? $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] : null ; } 
public function removeCatValue ( $ assessmentSectionId , $ key ) { if ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) { unset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ; } return $ this ; } 
public function getStorageService ( ) { if ( ! $ this -> storageService ) { $ this -> storageService = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storageService ; } 
public function persist ( $ testSessionId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> save ( ) ; $ this -> getStorageService ( ) -> persist ( $ extendedState -> getUserId ( ) , $ extendedState -> getStorageKey ( ) ) ; } 
public function setItemFlag ( $ testSessionId , $ itemRef , $ flag ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setItemFlag ( $ itemRef , $ flag ) ; $ extendedState -> save ( ) ; } 
public function getItemFlag ( $ testSessionId , $ itemRef ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; return $ extendedState -> getItemFlag ( $ itemRef ) ; } 
public function setStoreId ( $ testSessionId , $ storeId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setStoreId ( $ storeId ) ; $ extendedState -> save ( ) ; } 
public function addEvent ( $ testSessionId , $ eventName , $ data = null ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ eventId = $ extendedState -> addEvent ( $ eventName , $ data ) ; $ extendedState -> save ( ) ; return $ eventId ; } 
public function removeEvents ( $ testSessionId , $ ids = [ ] ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> removeEvents ( $ ids ) ; $ extendedState -> save ( ) ; } 
public function clearEvents ( $ testSessionId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> clearEvents ( ) ; $ extendedState -> save ( ) ; } 
public function storeItemHrefIndex ( $ testSessionId , $ table ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setItemHrefIndex ( $ table ) ; $ extendedState -> save ( ) ; } 
public function setCatValue ( $ testSessionId , $ assessmentSectionId , $ key , $ value ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setCatValue ( $ assessmentSectionId , $ key , $ value ) ; $ extendedState -> save ( ) ; } 
public function getCatValue ( $ testSessionId , $ assessmentSectionId , $ key ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; return $ extendedState -> getCatValue ( $ assessmentSectionId , $ key ) ; } 
public function removeCatValue ( $ testSessionId , $ assessmentSectionId , $ key ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> removeCatValue ( $ assessmentSectionId , $ key ) ; $ extendedState -> save ( ) ; } 
public function toArray ( ) { $ data = [ ] ; foreach ( $ this -> points as $ point ) { $ data [ ] = $ point -> toArray ( ) ; } return $ data ; } 
public function fromArray ( $ data ) { $ this -> points = [ ] ; if ( is_array ( $ data ) ) { foreach ( $ data as $ dataPoint ) { $ point = new TimePoint ( ) ; $ point -> fromArray ( $ dataPoint ) ; $ this -> points [ ] = $ point ; } } } 
public function unserialize ( $ serialized ) { $ this -> points = unserialize ( $ serialized ) ; if ( ! is_array ( $ this -> points ) ) { throw new InvalidDataException ( 'The provided serialized data are invalid!' ) ; } } 
public function remove ( $ tag , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; $ removed = 0 ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { unset ( $ this -> points [ $ idx ] ) ; $ removed ++ ; } } return $ removed ; } 
public function filter ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { 
public function find ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { 
public function compute ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ lastTimestamp = 0 ) { 
protected function computeRange ( $ range ) { 
protected function fixRange ( $ range , $ lastTimestamp = null ) { $ fixedRange = [ ] ; $ last = null ; $ open = false ; foreach ( $ range as $ point ) { if ( $ this -> isStartPoint ( $ point ) ) { 
protected function cloneTimePoint ( TimePoint $ point , $ type , $ timestamp = null ) { if ( is_null ( $ timestamp ) ) { $ timestamp = $ point -> getTimestamp ( ) ; } \ common_Logger :: d ( "Create missing TimePoint at " . $ timestamp ) ; return new TimePoint ( $ point -> getTags ( ) , $ timestamp , $ type , $ point -> getTarget ( ) ) ; } 
protected function isStartPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_START ) ; } 
protected function isEndPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_END ) ; } 
protected function getRangeDuration ( $ start , $ end ) { 
private function loadItemData ( $ itemRef , $ path ) { $ cacheKey = $ itemRef . $ path ; if ( ! empty ( $ cacheKey ) && isset ( $ this -> dataCache [ $ itemRef . $ path ] ) ) { return $ this -> dataCache [ $ itemRef . $ path ] ; } $ directoryIds = explode ( '|' , $ itemRef ) ; if ( count ( $ directoryIds ) < 3 ) { if ( is_scalar ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . strval ( $ itemRef ) ; } elseif ( is_object ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . get_class ( $ itemRef ) ; } else { $ itemRefInfo = gettype ( $ itemRef ) ; } throw new \ common_exception_InconsistentData ( "The itemRef (value = '${itemRefInfo}') is not formatted correctly." ) ; } $ itemUri = $ directoryIds [ 0 ] ; $ userDataLang = \ common_session_SessionManager :: getSession ( ) -> getDataLanguage ( ) ; $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 2 ] ) ; if ( $ directory -> has ( $ userDataLang ) ) { $ lang = $ userDataLang ; } elseif ( $ directory -> has ( DEFAULT_LANG ) ) { \ common_Logger :: d ( $ userDataLang . ' is not part of compilation directory for item : ' . $ itemUri . ' use ' . DEFAULT_LANG ) ; $ lang = DEFAULT_LANG ; } else { throw new \ common_Exception ( 'item : ' . $ itemUri . 'is neither compiled in ' . $ userDataLang . ' nor in ' . DEFAULT_LANG ) ; } try { $ content = $ directory -> read ( $ lang . DIRECTORY_SEPARATOR . $ path ) ; $ assetService = $ this -> getServiceManager ( ) -> get ( ItemAssetsReplacement :: SERVICE_ID ) ; $ jsonContent = json_decode ( $ content , true ) ; $ jsonAssets = [ ] ; if ( isset ( $ jsonContent [ 'assets' ] ) ) { foreach ( $ jsonContent [ 'assets' ] as $ type => $ assets ) { foreach ( $ assets as $ key => $ asset ) { $ jsonAssets [ $ type ] [ $ key ] = $ assetService -> postProcessAssets ( $ asset ) ; } } $ jsonContent [ "assets" ] = $ jsonAssets ; } $ this -> dataCache [ $ cacheKey ] = $ jsonContent ; return $ this -> dataCache [ $ cacheKey ] ; } catch ( \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } catch ( \ League \ Flysystem \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } } 
public function getServiceContext ( $ testDefinitionUri , $ testCompilationUri , $ testExecutionUri , $ userUri = null ) { 
public function persist ( QtiRunnerServiceContext $ context ) { $ testSession = $ context -> getTestSession ( ) ; $ sessionId = $ testSession -> getSessionId ( ) ; \ common_Logger :: d ( "Persisting QTI Assessment Test Session '${sessionId}'..." ) ; $ context -> getStorage ( ) -> persist ( $ testSession ) ; if ( $ this -> isTerminated ( $ context ) ) { $ userId = \ common_session_SessionManager :: getSession ( ) -> getUser ( ) -> getIdentifier ( ) ; $ eventManager = $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) ; $ eventManager -> trigger ( new AfterAssessmentTestSessionClosedEvent ( $ testSession , $ userId ) ) ; } } 
public function init ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; 
public function getRubrics ( RunnerServiceContext $ context , AssessmentItemRef $ itemRef = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ rubricHelper = $ this -> getServiceLocator ( ) -> get ( QtiRunnerRubric :: SERVICE_ID ) ; return $ rubricHelper -> getRubrics ( $ context , $ itemRef ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getRubrics' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } } 
public function getItemHref ( RunnerServiceContext $ context , $ itemRef ) { $ mapService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerMap :: SERVICE_ID ) ; return $ mapService -> getItemHref ( $ context , $ itemRef ) ; } 
public function getItemData ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { return $ this -> loadItemData ( $ itemRef , QtiJsonItemCompiler :: ITEM_FILE_NAME ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemData' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } } 
public function getItemState ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; $ state = is_null ( $ userUri ) ? null : $ serviceService -> get ( $ userUri , $ stateId ) ; if ( $ state ) { $ state = json_decode ( $ state , true ) ; if ( is_null ( $ state ) ) { throw new \ common_exception_InconsistentData ( 'Unable to decode the state for the item ' . $ itemRef ) ; } } return $ state ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } } 
public function setItemState ( RunnerServiceContext $ context , $ itemRef , $ state ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; if ( ! isset ( $ state ) ) { $ state = '' ; } return is_null ( $ userUri ) ? false : $ serviceService -> set ( $ userUri , $ stateId , json_encode ( $ state ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'setItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } } 
public function parsesItemResponse ( RunnerServiceContext $ context , $ itemRef , $ response ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ currentItem = $ context -> getCurrentAssessmentItemRef ( ) ; $ responses = new State ( ) ; if ( $ currentItem === false ) { $ msg = "Trying to store item variables but the state of the test session is INITIAL or CLOSED.\n" ; $ msg .= "Session state value: " . $ session -> getState ( ) . "\n" ; $ msg .= "Session ID: " . $ session -> getSessionId ( ) . "\n" ; $ msg .= "JSON Payload: " . mb_substr ( json_encode ( $ response ) , 0 , 1000 ) ; \ common_Logger :: e ( $ msg ) ; } $ filler = new \ taoQtiCommon_helpers_PciVariableFiller ( $ currentItem , $ this -> getServiceManager ( ) -> get ( QtiFlysystemFileManager :: SERVICE_ID ) ) ; if ( is_array ( $ response ) ) { foreach ( $ response as $ id => $ responseData ) { try { $ var = $ filler -> fill ( $ id , $ responseData ) ; 
public function emptyResponse ( RunnerServiceContext $ context , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ similar = 0 ; foreach ( $ responses as $ responseVariable ) { $ value = $ responseVariable -> getValue ( ) ; $ default = $ responseVariable -> getDefaultValue ( ) ; 
public function storeItemResponse ( RunnerServiceContext $ context , $ itemRef , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ this -> getCurrentAssessmentSession ( $ context ) ; try { \ common_Logger :: t ( 'Responses sent from the client-side. The Response Processing will take place.' ) ; if ( $ context -> isAdaptive ( ) ) { $ session -> beginItemSession ( ) ; $ session -> beginAttempt ( ) ; $ session -> endAttempt ( $ responses ) ; $ assessmentItem = $ session -> getAssessmentItem ( ) ; $ assessmentItemIdentifier = $ assessmentItem -> getIdentifier ( ) ; $ score = $ session -> getVariable ( 'SCORE' ) ; $ output = $ context -> getLastCatItemOutput ( ) ; if ( $ score !== null ) { $ output [ $ assessmentItemIdentifier ] = new ItemResult ( $ assessmentItemIdentifier , new ResultVariable ( $ score -> getIdentifier ( ) , BaseType :: getNameByConstant ( $ score -> getBaseType ( ) ) , $ score -> getValue ( ) -> getValue ( ) , null , $ score -> getCardinality ( ) ) , microtime ( true ) ) ; } else { \ common_Logger :: i ( "No 'SCORE' outcome variable for item '${assessmentItemIdentifier}' involved in an adaptive section." ) ; } $ context -> persistLastCatItemOutput ( $ output ) ; 
public function displayFeedbacks ( RunnerServiceContext $ context ) { $ displayFeedbacks = false ; if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getCurrentSubmissionMode ( ) !== SubmissionMode :: SIMULTANEOUS ) { $ displayFeedbacks = true ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'displayFeedbacks' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ displayFeedbacks ; } 
public function hasFeedbacks ( RunnerServiceContext $ context , $ itemRef ) { $ hasFeedbacks = false ; $ displayFeedbacks = $ this -> displayFeedbacks ( $ context ) ; if ( $ displayFeedbacks ) { $ feedbacks = $ this -> getFeedbacks ( $ context , $ itemRef ) ; foreach ( $ feedbacks as $ entry ) { if ( isset ( $ entry [ 'feedbackRules' ] ) ) { if ( count ( $ entry [ 'feedbackRules' ] ) > 0 ) { $ hasFeedbacks = true ; } break ; } } } return $ hasFeedbacks ; } 
public function getItemSession ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ currentItem = $ session -> getCurrentAssessmentItemRef ( ) ; $ currentOccurrence = $ session -> getCurrentAssessmentItemRefOccurence ( ) ; $ itemSession = $ session -> getAssessmentItemSessionStore ( ) -> getAssessmentItemSession ( $ currentItem , $ currentOccurrence ) ; $ stateOutput = new \ taoQtiCommon_helpers_PciStateOutput ( ) ; foreach ( $ itemSession -> getAllVariables ( ) as $ var ) { $ stateOutput -> addVariable ( $ var ) ; } $ output = $ stateOutput -> getOutput ( ) ; 
public function move ( RunnerServiceContext $ context , $ direction , $ scope , $ ref ) { $ result = true ; if ( $ context instanceof QtiRunnerServiceContext ) { try { $ result = QtiRunnerNavigation :: move ( $ direction , $ scope , $ context , $ ref ) ; if ( $ result ) { $ this -> continueInteraction ( $ context ) ; } } catch ( AssessmentTestSessionException $ e ) { switch ( $ e -> getCode ( ) ) { case AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW : case AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW : $ this -> onTimeout ( $ context , $ e ) ; break ; } } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'move' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; } 
public function skip ( RunnerServiceContext $ context , $ scope , $ ref ) { return $ this -> move ( $ context , 'skip' , $ scope , $ ref ) ; } 
public function timeout ( RunnerServiceContext $ context , $ scope , $ ref , $ late = false ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Select next item before timeout" ) ; $ context -> selectAdaptiveNextItem ( ) ; } try { $ session -> closeTimer ( $ ref , $ scope ) ; if ( $ late ) { if ( $ scope == 'assessmentTest' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW ; } else if ( $ scope == 'testPart' ) { $ code = AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW ; } else if ( $ scope == 'assessmentSection' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW ; } else { $ code = AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW ; } throw new AssessmentTestSessionException ( "Maximum duration of ${scope} '${ref}' not respected." , $ code ) ; } else { $ session -> checkTimeLimits ( false , true , false ) ; } } catch ( AssessmentTestSessionException $ e ) { $ this -> onTimeout ( $ context , $ e ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'timeout' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; } 
public function finish ( RunnerServiceContext $ context , $ finalState = DeliveryExecution :: STATE_FINISHED ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ executionUri = $ context -> getTestExecutionUri ( ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ executionService = ServiceProxy :: singleton ( ) ; $ deliveryExecution = $ executionService -> getDeliveryExecution ( $ executionUri ) ; if ( $ deliveryExecution -> getUserIdentifier ( ) == $ userUri ) { \ common_Logger :: i ( "Finishing the delivery execution {$executionUri}" ) ; $ result = $ deliveryExecution -> setState ( $ finalState ) ; } else { \ common_Logger :: w ( "Non owner {$userUri} tried to finish deliveryExecution {$executionUri}" ) ; $ result = false ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ executionUri ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'finish' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; } 
public function pause ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> suspend ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'pause' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; } 
public function resume ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> resume ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'resume' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; } 
public function check ( RunnerServiceContext $ context ) { $ state = $ context -> getTestSession ( ) -> getState ( ) ; if ( $ state == AssessmentTestSessionState :: CLOSED ) { throw new QtiRunnerClosedException ( ) ; } return true ; } 
public function isItemCompleted ( RunnerServiceContext $ context , $ routeItem , $ itemSession , $ partially = true ) { if ( $ context instanceof QtiRunnerServiceContext && $ context -> isAdaptive ( ) ) { $ itemIdentifier = $ context -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ itemState = $ this -> getItemState ( $ context , $ itemIdentifier ) ; if ( $ itemState !== null ) { 
public function getItemPublicUrl ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ directoryIds = explode ( '|' , $ itemRef ) ; $ userDataLang = \ common_session_SessionManager :: getSession ( ) -> getDataLanguage ( ) ; $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 1 ] ) ; 
public function comment ( RunnerServiceContext $ context , $ comment ) { 
protected function continueInteraction ( RunnerServiceContext $ context ) { $ continue = false ; $ session = $ context -> getTestSession ( ) ; if ( $ session -> isRunning ( ) === true && $ session -> isTimeout ( ) === false ) { $ event = new QtiContinueInteractionEvent ( $ context , $ this ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; $ continue = true ; } else { $ this -> finish ( $ context ) ; } return $ continue ; } 
protected function onTimeout ( RunnerServiceContext $ context , AssessmentTestSessionException $ timeOutException ) { $ session = $ context -> getTestSession ( ) ; $ event = new TestTimeoutEvent ( $ session , $ timeOutException -> getCode ( ) , true ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ isLinear = $ session -> getCurrentNavigationMode ( ) === NavigationMode :: LINEAR ; switch ( $ timeOutException -> getCode ( ) ) { case AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW : \ common_Logger :: i ( 'TIMEOUT: closing the assessment test session' ) ; $ session -> endTestSession ( ) ; break ; case AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next test part' ) ; $ session -> moveNextTestPart ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment test part' ) ; $ session -> closeTestPart ( ) ; } break ; case AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next assessment section' ) ; $ session -> moveNextAssessmentSection ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment section session' ) ; $ session -> closeAssessmentSection ( ) ; } break ; case AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next item' ) ; $ session -> moveNextAssessmentItem ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment item session' ) ; $ session -> closeAssessmentItem ( ) ; } break ; } $ event = new TestTimeoutEvent ( $ session , $ timeOutException -> getCode ( ) , false ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ this -> continueInteraction ( $ context ) ; } 
protected function buildTimeConstraints ( RunnerServiceContext $ context ) { $ constraints = [ ] ; $ session = $ context -> getTestSession ( ) ; foreach ( $ session -> getRegularTimeConstraints ( ) as $ constraint ) { if ( $ constraint -> getMaximumRemainingTime ( ) != false || $ constraint -> getMinimumRemainingTime ( ) != false ) { $ constraints [ ] = $ constraint ; } } return $ constraints ; } 
public function storeTraceVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getTraceVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; } 
public function getTraceVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_TraceVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setTrace ( $ variableValue ) ; return $ metaVariable ; } 
public function storeOutcomeVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getOutcomeVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; } 
public function getOutcomeVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_OutcomeVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setValue ( $ variableValue ) ; return $ metaVariable ; } 
public function storeResponseVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getResponseVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; } 
public function getResponseVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_ResponseVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setValue ( $ variableValue ) ; return $ metaVariable ; } 
public function storeVariables ( QtiRunnerServiceContext $ context , $ itemUri , $ metaVariables , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariables ( $ testUri , $ itemUri , $ metaVariables , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariables ( $ testUri , $ metaVariables , $ sessionId ) ; } return true ; } 
protected function storeVariable ( QtiRunnerServiceContext $ context , $ itemUri , \ taoResultServer_models_classes_Variable $ metaVariable , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariable ( $ testUri , $ itemUri , $ metaVariable , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariable ( $ testUri , $ metaVariable , $ sessionId ) ; } return true ; } 
protected function getTransmissionId ( QtiRunnerServiceContext $ context , $ itemId = null ) { if ( is_null ( $ itemId ) ) { $ itemId = $ context -> getCurrentAssessmentItemRef ( ) ; } elseif ( $ itemId != $ context -> getCurrentAssessmentItemRef ( ) ) { throw new \ common_exception_NotImplemented ( 'Item variables can be stored only for the current item' ) ; } $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ currentOccurrence = $ context -> getTestSession ( ) -> getCurrentAssessmentItemRefOccurence ( ) ; return $ sessionId . '.' . $ itemId . '.' . $ currentOccurrence ; } 
public function assertQtiRunnerServiceContext ( RunnerServiceContext $ context ) { if ( ! $ context instanceof QtiRunnerServiceContext ) { throw new \ common_exception_InvalidArgumentType ( __CLASS__ , __FUNCTION__ , 0 , QtiRunnerServiceContext :: class , $ context ) ; } } 
public function startTimer ( RunnerServiceContext $ context , $ timestamp = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INTERACTING ) { $ session -> startItemTimer ( $ timestamp ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'startTimer' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; } 
public function endTimer ( RunnerServiceContext $ context , $ duration = null , $ timestamp = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ session -> endItemTimer ( $ duration , $ timestamp ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'endTimer' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; } 
public function switchClientStoreId ( RunnerServiceContext $ context , $ receivedStoreId ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ sessionId = $ session -> getSessionId ( ) ; $ stateService = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) ; $ lastStoreId = $ stateService -> getStoreId ( $ sessionId ) ; if ( $ lastStoreId == false || $ lastStoreId != $ receivedStoreId ) { $ stateService -> setStoreId ( $ sessionId , $ receivedStoreId ) ; } return $ lastStoreId ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'switchClientStoreId' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } } 
public function getCurrentAssessmentSession ( RunnerServiceContext $ context ) { if ( $ context -> isAdaptive ( ) ) { return new AssessmentItemSession ( $ context -> getCurrentAssessmentItemRef ( ) , new SessionManager ( ) ) ; } else { return $ context -> getTestSession ( ) ; } } 
private function isThemeSwitcherEnabled ( ) { $ extensionsManager = $ this -> getServiceLocator ( ) -> get ( \ common_ext_ExtensionsManager :: SERVICE_ID ) ; $ config = $ extensionsManager -> getExtensionById ( "taoTests" ) -> getConfig ( "test_runner_plugin_registry" ) ; return array_key_exists ( self :: TOOL_ITEM_THEME_SWITCHER_KEY , $ config ) && $ config [ self :: TOOL_ITEM_THEME_SWITCHER_KEY ] [ "active" ] === true ; } 
private function getCurrentThemeId ( ) { $ themeService = $ this -> getServiceLocator ( ) -> get ( ThemeService :: SERVICE_ID ) ; return $ themeService -> getTheme ( ) -> getId ( ) ; } 
protected function getItemHrefIndexFile ( QtiRunnerServiceContext $ context , $ itemIdentifier ) { $ compilationDirectory = $ context -> getCompilationDirectory ( ) [ 'private' ] ; return $ compilationDirectory -> getFile ( \ taoQtiTest_models_classes_QtiTestCompiler :: buildHrefIndexPath ( $ itemIdentifier ) ) ; } 
protected function hasItemHrefIndexFile ( QtiRunnerServiceContext $ context , $ itemIdentifier ) { 
public function getItemHref ( QtiRunnerServiceContext $ context , $ itemIdentifier ) { $ href = false ; $ indexFile = $ this -> getItemHrefIndexFile ( $ context , $ itemIdentifier ) ; if ( $ indexFile -> exists ( ) ) { $ href = $ indexFile -> read ( ) ; } else { if ( ! isset ( $ this -> itemHrefIndex ) ) { $ storage = $ this -> getServiceLocator ( ) -> get ( ExtendedStateService :: SERVICE_ID ) ; $ this -> itemHrefIndex = $ storage -> loadItemHrefIndex ( $ context -> getTestExecutionUri ( ) ) ; } if ( isset ( $ this -> itemHrefIndex [ $ itemIdentifier ] ) ) { $ href = $ this -> itemHrefIndex [ $ itemIdentifier ] ; } } return $ href ; } 
public function getMap ( RunnerServiceContext $ context , RunnerConfig $ config ) { return $ this -> getScopedMap ( $ context , $ config , RunnerMap :: SCOPE_TEST ) ; } 
public function getScopedMap ( RunnerServiceContext $ context , RunnerConfig $ config , $ scope = RunnerMap :: SCOPE_SECTION ) { if ( ! ( $ context instanceof QtiRunnerServiceContext ) ) { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerMap' , 'getMap' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } $ map = [ 'scope' => $ scope , 'parts' => [ ] ] ; 
protected function updateStats ( & $ target , $ itemInfos ) { if ( ! isset ( $ target [ 'stats' ] ) ) { $ target [ 'stats' ] = [ 'questions' => 0 , 'answered' => 0 , 'flagged' => 0 , 'viewed' => 0 , 'total' => 0 , 'questionsViewed' => 0 , ] ; } if ( empty ( $ itemInfos [ 'informational' ] ) ) { $ target [ 'stats' ] [ 'questions' ] ++ ; if ( ! empty ( $ itemInfos [ 'answered' ] ) ) { $ target [ 'stats' ] [ 'answered' ] ++ ; } if ( ! empty ( $ itemInfos [ 'viewed' ] ) ) { $ target [ 'stats' ] [ 'questionsViewed' ] ++ ; } } if ( ! empty ( $ itemInfos [ 'flagged' ] ) ) { $ target [ 'stats' ] [ 'flagged' ] ++ ; } if ( ! empty ( $ itemInfos [ 'viewed' ] ) ) { $ target [ 'stats' ] [ 'viewed' ] ++ ; } $ target [ 'stats' ] [ 'total' ] ++ ; } 
protected function getRouteItemAssessmentItemRefs ( RunnerServiceContext $ context , RouteItem $ routeItem , & $ catSession ) { $ catService = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) ; $ compilationDirectory = $ context -> getCompilationDirectory ( ) [ 'private' ] ; $ itemRefs = [ ] ; $ catSession = false ; if ( $ context -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ catSession = $ context -> getCatSession ( $ routeItem ) ; $ itemRefs = $ catService -> getAssessmentItemRefByIdentifiers ( $ compilationDirectory , $ context -> getShadowTest ( $ routeItem ) ) ; } else { $ itemRefs [ ] = $ routeItem -> getAssessmentItemRef ( ) ; } return $ itemRefs ; } 
protected function getOffsetPosition ( RunnerServiceContext $ context , RouteItem $ currentRouteItem ) { $ session = $ context -> getTestSession ( ) ; $ route = $ session -> getRoute ( ) ; $ routeCount = $ route -> count ( ) ; $ finalPosition = 0 ; for ( $ i = 0 ; $ i < $ routeCount ; $ i ++ ) { $ routeItem = $ route -> getRouteItemAt ( $ i ) ; if ( $ routeItem !== $ currentRouteItem ) { if ( ! $ context -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition ++ ; } else { $ finalPosition += count ( $ context -> getShadowTest ( $ routeItem ) ) ; } } else { break ; } } return $ finalPosition ; } 
private function getTimeConstraint ( TestSession $ session , QtiComponent $ source , $ navigationMode ) { $ constraint = new QtiTimeConstraint ( $ source , $ session -> getTimerDuration ( $ source -> getIdentifier ( ) ) , $ navigationMode , true , true , $ session -> getTimerTarget ( ) ) ; $ constraint -> setTimer ( $ session -> getTimer ( ) ) ; return $ constraint ; } 
private function getItemLabel ( RunnerServiceContext $ context , $ itemUri , $ useTitle = false ) { $ label = '' ; if ( $ useTitle ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'title' ) ; } if ( ! $ label ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'label' ) ; } if ( ! $ label ) { $ item = new \ core_kernel_classes_Resource ( $ itemUri ) ; $ label = $ item -> getLabel ( ) ; } return $ label ; } 
public static function getNavigator ( $ direction , $ scope ) { $ className = __NAMESPACE__ . '\QtiRunnerNavigation' . ucfirst ( $ direction ) . ucfirst ( $ scope ) ; if ( class_exists ( $ className ) ) { $ navigator = new $ className ( ) ; if ( $ navigator instanceof RunnerNavigation ) { return $ navigator ; } else { throw new \ common_exception_InconsistentData ( 'Navigator must be an instance of RunnerNavigation' ) ; } } else { throw new \ common_exception_NotImplemented ( 'The action is invalid!' ) ; } } 
public static function checkTimedSectionExit ( RunnerServiceContext $ context , $ nextPosition ) { $ timerConfig = $ context -> getTestConfig ( ) -> getConfigValue ( 'timer' ) ; if ( empty ( $ timerConfig [ 'keepUpToTimeout' ] ) ) { $ session = $ context -> getTestSession ( ) ; $ route = $ session -> getRoute ( ) ; $ section = $ session -> getCurrentAssessmentSection ( ) ; $ limits = $ section -> getTimeLimits ( ) ; 
public function getItemClasses ( ) { $ itemClass = $ this -> getClass ( self :: ITEM_ROOT_CLASS_URI ) ; return $ this -> getResourceService ( ) -> getAllClasses ( $ itemClass ) ; } 
public function getQtiItems ( \ core_kernel_classes_Class $ itemClass , $ format = 'list' , $ search = '' , $ offset = 0 , $ limit = 30 ) { $ propertyFilters = [ ] ; if ( $ this -> hasOption ( self :: ITEM_MODEL_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_MODEL_URI ] = $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) ; } if ( $ this -> hasOption ( self :: ITEM_CONTENT_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_CONTENT_URI ] = '*' ; } if ( is_string ( $ search ) && strlen ( trim ( $ search ) ) > 0 ) { $ propertyFilters [ self :: LABEL_URI ] = $ search ; } if ( is_array ( $ search ) ) { foreach ( $ search as $ uri => $ value ) { if ( is_string ( $ uri ) && ( is_string ( $ value ) && strlen ( trim ( $ value ) ) > 0 ) || ( is_array ( $ value ) && count ( $ value ) > 0 ) ) { $ propertyFilters [ $ uri ] = $ value ; } } } $ result = [ ] ; 
public function move ( RunnerServiceContext $ context , $ ref ) { $ session = $ context -> getTestSession ( ) ; $ nextPosition = $ session -> getRoute ( ) -> getPosition ( ) + 1 ; if ( $ context -> isAdaptive ( ) ) { $ context -> selectAdaptiveNextItem ( ) ; $ currentCatItemId = $ context -> getCurrentCatItemId ( ) ; $ shadowTest = $ context -> getShadowTest ( ) ; $ search = array_search ( $ currentCatItemId , $ shadowTest ) ; if ( $ search === count ( $ shadowTest ) - 1 ) { QtiRunnerNavigation :: checkTimedSectionExit ( $ context , $ nextPosition ) ; $ session -> moveNext ( ) ; } else { $ nextCatItemId = $ shadowTest [ $ search + 1 ] ; $ context -> persistCurrentCatItemId ( $ nextCatItemId ) ; $ context -> persistSeenCatItemIds ( $ nextCatItemId ) ; } } else { QtiRunnerNavigation :: checkTimedSectionExit ( $ context , $ nextPosition ) ; $ session -> moveNext ( ) ; 
public function useClientContainer ( ) { if ( $ this -> hasOption ( self :: OPTION_CLIENT_TESTRUNNER ) ) { return $ this -> getOption ( self :: OPTION_CLIENT_TESTRUNNER ) ; } else { 
protected function getRemainingTimeFrom ( QtiDuration $ duration ) { if ( ! is_null ( $ duration ) ) { $ remaining = clone $ duration ; if ( $ this -> getApplyExtraTime ( ) && $ this -> timer ) { 
public function getMaximumRemainingTime ( ) { if ( ( $ timeLimits = $ this -> getSource ( ) -> getTimeLimits ( ) ) !== null && ( $ maxTime = $ timeLimits -> getMaxTime ( ) ) !== null ) { return $ this -> getRemainingTimeFrom ( $ maxTime ) ; } return false ; } 
public function getMinimumRemainingTime ( ) { if ( ( $ timeLimits = $ this -> getSource ( ) -> getTimeLimits ( ) ) !== null && ( $ minTime = $ timeLimits -> getMinTime ( ) ) !== null ) { return $ this -> getRemainingTimeFrom ( $ minTime ) ; } return false ; } 
private function durationToMs ( $ duration ) { if ( ! is_null ( $ duration ) && $ duration instanceof QtiDuration ) { return TestRunnerUtils :: getDurationWithMicroseconds ( $ duration ) ; } return false ; } 
public function jsonSerialize ( ) { $ source = $ this -> getSource ( ) ; $ timeLimits = $ source -> getTimeLimits ( ) ; if ( ! is_null ( $ timeLimits ) ) { $ identifier = $ source -> getIdentifier ( ) ; $ maxTime = $ timeLimits -> getMaxTime ( ) ; $ minTime = $ timeLimits -> getMinTime ( ) ; $ maxTimeRemaining = $ this -> getMaximumRemainingTime ( ) ; $ minTimeRemaining = $ this -> getMinimumRemainingTime ( ) ; if ( $ maxTimeRemaining !== false || $ minTimeRemaining !== false ) { $ label = method_exists ( $ source , 'getTitle' ) ? $ source -> getTitle ( ) : $ identifier ; $ extraTime = [ ] ; if ( ! is_null ( $ this -> getTimer ( ) ) && $ source -> getTimeLimits ( ) -> hasMaxTime ( ) ) { $ timer = $ this -> getTimer ( ) ; $ maxTimeSeconds = $ source -> getTimeLimits ( ) -> getMaxTime ( ) -> getSeconds ( true ) ; $ extraTime = [ 'total' => $ timer -> getExtraTime ( $ maxTimeSeconds ) , 'consumed' => $ timer -> getConsumedExtraTime ( $ identifier , $ maxTimeSeconds , $ this -> timerTarget ) , 'remaining' => $ timer -> getRemainingExtraTime ( $ identifier , $ maxTimeSeconds , $ this -> timerTarget ) , ] ; } $ labelFormatter = ServiceManager :: getServiceManager ( ) -> get ( TimerLabelFormatterService :: SERVICE_ID ) ; return [ 'label' => $ labelFormatter -> format ( $ label ) , 'source' => $ identifier , 'qtiClassName' => $ source -> getQtiClassName ( ) , 'extraTime' => $ extraTime , 'allowLateSubmission' => $ this -> allowLateSubmission ( ) , 'minTime' => $ this -> durationToMs ( $ minTime ) , 'minTimeRemaining' => $ this -> durationToMs ( $ minTimeRemaining ) , 'maxTime' => $ this -> durationToMs ( $ maxTime ) , 'maxTimeRemaining' => $ this -> durationToMs ( $ maxTimeRemaining ) , ] ; } } return null ; } 
public function move ( RunnerServiceContext $ context , $ ref ) { $ session = $ context -> getTestSession ( ) ; $ nextPosition = $ session -> getRoute ( ) -> getPosition ( ) - 1 ; if ( $ context -> isAdaptive ( ) ) { $ shadowTest = $ context -> getShadowTest ( ) ; $ currentCatItemId = $ context -> getCurrentCatItemId ( ) ; $ search = array_search ( $ currentCatItemId , $ shadowTest ) ; 
public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ itemDuration = null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = $ this -> getRequestParameter ( 'start' ) !== false ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ this -> getTime ( ) ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> skip ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { 
public function start ( $ tags , $ timestamp ) { 
public function end ( $ tags , $ timestamp ) { 
public function getFirstTimestamp ( $ tags ) { 
public function getLastTimestamp ( $ tags ) { 
public function getLastRegisteredTimestamp ( ) { $ points = $ this -> timeLine -> getPoints ( ) ; $ length = count ( $ points ) ; $ last = false ; if ( $ length ) { $ last = end ( $ points ) -> getTimestamp ( ) ; } return $ last ; } 
public function adjust ( $ tags , $ duration ) { 
public function compute ( $ tags , $ target ) { 
public function timeout ( $ timeLimit , $ tags , $ target ) { $ duration = $ this -> compute ( $ tags , $ target ) ; return $ duration >= $ timeLimit ; } 
public function toArray ( ) { return [ self :: STORAGE_KEY_TIME_LINE => $ this -> timeLine , self :: STORAGE_KEY_EXTRA_TIME => $ this -> extraTime , self :: STORAGE_KEY_EXTENDED_TIME => $ this -> extendedTime , self :: STORAGE_KEY_CONSUMED_EXTRA_TIME => $ this -> consumedExtraTime , ] ; } 
public function save ( ) { if ( ! $ this -> storage ) { throw new InvalidStorageException ( 'A storage must be defined in order to store the data!' ) ; } $ this -> storage -> store ( $ this -> toArray ( ) ) ; return $ this ; } 
public function load ( ) { if ( ! $ this -> storage ) { throw new InvalidStorageException ( 'A storage must be defined in order to store the data!' ) ; } $ data = $ this -> storage -> load ( ) ; if ( isset ( $ data ) ) { if ( ! is_array ( $ data ) ) { $ data = [ self :: STORAGE_KEY_TIME_LINE => $ data , ] ; } if ( isset ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ) { $ this -> timeLine = $ this -> unserializeTimeLine ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ; } else { $ this -> timeLine = new QtiTimeLine ( ) ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ) ) { $ this -> extraTime = $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ; } else { $ this -> extraTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ) ) { $ this -> extendedTime = $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ; } else { $ this -> extendedTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ) ) { $ this -> consumedExtraTime = $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ; } else { $ this -> consumedExtraTime = 0 ; } if ( ! $ this -> timeLine instanceof TimeLine ) { throw new InvalidDataException ( 'The storage did not provide acceptable data when loading!' ) ; } } return $ this ; } 
public function getExtraTime ( $ maxTime = 0 ) { if ( $ maxTime && $ this -> getExtendedTime ( ) ) { $ secondsNew = $ maxTime * $ this -> getExtendedTime ( ) ; $ extraTime = $ secondsNew - $ maxTime ; $ this -> setExtraTime ( $ extraTime ) ; return $ extraTime ; } return $ this -> extraTime ; } 
public function setConsumedExtraTime ( $ time ) { $ this -> consumedExtraTime = max ( $ this -> consumedExtraTime , floatval ( $ time ) ) ; return $ this ; } 
public function getConsumedExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { if ( $ maxTime ) { $ totalConsumed = $ this -> compute ( $ tags , $ target ) ; $ consumedExtraTime = $ totalConsumed - $ maxTime < 0 ? 0 : $ totalConsumed - $ maxTime ; $ this -> setConsumedExtraTime ( $ consumedExtraTime ) -> save ( ) ; } return $ this -> consumedExtraTime ; } 
public function getRemainingExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { return max ( 0 , $ this -> getExtraTime ( $ maxTime ) - $ this -> getConsumedExtraTime ( $ tags , $ maxTime , $ target ) ) ; } 
protected function checkTimestampCoherence ( $ points , $ timestamp ) { foreach ( $ points as $ point ) { if ( $ point -> getTimestamp ( ) > $ timestamp ) { throw new InconsistentRangeException ( 'A new TimePoint cannot be set before an existing one!' ) ; } } } 
protected function isRangeOpen ( $ range ) { $ nb = count ( $ range ) ; return $ nb && ( $ nb % 2 ) && ( $ range [ $ nb - 1 ] -> getType ( ) == TimePoint :: TYPE_START ) ; } 
protected function getRange ( $ tags ) { $ range = $ this -> timeLine -> find ( $ tags , TimePoint :: TARGET_SERVER ) ; TimePoint :: sort ( $ range ) ; return $ range ; } 
protected function binaryPopCount ( $ value ) { $ value -= ( ( $ value >> 1 ) & 0x55555555 ) ; $ value = ( ( ( $ value >> 2 ) & 0x33333333 ) + ( $ value & 0x33333333 ) ) ; $ value = ( ( ( $ value >> 4 ) + $ value ) & 0x0f0f0f0f ) ; $ value += ( $ value >> 8 ) ; $ value += ( $ value >> 16 ) ; return $ value & 0x0000003f ; } 
public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ result = $ this -> getListResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; array_map ( function ( $ item ) { return array_merge ( $ item , [ 'categories' => $ this -> getCategoryService ( ) -> getItemCategories ( $ this -> getResource ( $ item [ 'uri' ] ) ) ] ) ; } , $ result [ 'nodes' ] ) ; return $ result ; } 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { if ( ! isset ( $ parameters [ 1 ] ) ) { return ; } $ matched_parameter = $ this -> strip_quotes ( $ parameters [ 1 ] [ 'raw' ] ) ; $ first_param_token = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , $ parameters [ 1 ] [ 'start' ] , ( $ parameters [ 1 ] [ 'end' ] + 1 ) , true ) ; if ( isset ( $ this -> target_functions [ $ matched_content ] [ $ matched_parameter ] ) ) { $ this -> throw_prohibited_error ( $ first_param_token , array ( $ matched_parameter ) ) ; return ; } 
public function process ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; if ( preg_match ( self :: IFRAME_REGEX , $ tokens [ $ stackPtr ] [ 'content' ] , $ matches ) > 0 ) { $ phpcsFile -> addError ( 'Usage of the iframe HTML element is prohibited. Found: %s' , $ stackPtr , 'Found' , array ( $ matches [ 1 ] ) ) ; } } 
public function register ( ) { $ tokens = Tokens :: $ textStringTokens ; $ tokens [ ] = T_STRING ; 
public function process ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; $ token = $ tokens [ $ stackPtr ] ; $ content = trim ( strtolower ( $ token [ 'content' ] ) ) ; * The check can have false positives like artisteers but chances of that happening * in a valid theme is low. */ if ( false === strpos ( $ content , $ generated_theme ) ) { continue ; } $ phpcsFile -> addError ( 'Auto generated themes are not allowed in the theme directory. Found: %s' , $ stackPtr , 'AutoGeneratedFound' , array ( $ generated_theme ) ) ; } } 
public function register ( ) { $ targets = Tokens :: $ textStringTokens ; 
public function process_token ( $ stackPtr ) { $ file_name = $ this -> phpcsFile -> getFileName ( ) ; $ file_extension = substr ( strrchr ( $ file_name , '.' ) , 1 ) ; if ( 'css' === $ file_extension ) { if ( \ T_STYLE === $ this -> tokens [ $ stackPtr ] [ 'code' ] ) { return $ this -> process_css_style ( $ stackPtr ) ; } } elseif ( isset ( Tokens :: $ textStringTokens [ $ this -> tokens [ $ stackPtr ] [ 'code' ] ] ) ) { if ( ! isset ( $ this -> in_style [ $ file_name ] ) ) { $ this -> in_style [ $ file_name ] = false ; } if ( ! isset ( $ this -> in_target_selector [ $ file_name ] ) ) { $ this -> in_target_selector [ $ file_name ] = false ; } return $ this -> process_text_for_style ( $ stackPtr , $ file_name ) ; } else { return parent :: process_token ( $ stackPtr ) ; } } 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { $ error = false ; switch ( $ matched_content ) { case 'show_admin_bar' : $ error = true ; if ( true === $ this -> remove_only ) { if ( 'true' === $ parameters [ 1 ] [ 'raw' ] ) { $ error = false ; } } break ; case 'add_filter' : $ filter_name = $ this -> strip_quotes ( $ parameters [ 1 ] [ 'raw' ] ) ; if ( 'show_admin_bar' !== $ filter_name ) { break ; } $ error = true ; if ( true === $ this -> remove_only && isset ( $ parameters [ 2 ] [ 'raw' ] ) ) { if ( '__return_true' === $ this -> strip_quotes ( $ parameters [ 2 ] [ 'raw' ] ) ) { $ error = false ; } } break ; default : 
public function process_text_for_style ( $ stackPtr , $ file_name ) { $ content = trim ( $ this -> tokens [ $ stackPtr ] [ 'content' ] ) ; 
protected function process_css_style ( $ stackPtr ) { if ( ! isset ( $ this -> target_css_properties [ $ this -> tokens [ $ stackPtr ] [ 'content' ] ] ) ) { 
protected function validate_css_property_value ( $ value , $ compare_type , $ compare_value ) { switch ( $ compare_type ) { case '!=' : return $ value !== $ compare_value ; case '>' : return $ value > $ compare_value ; default : return false ; } } 
public function process_token ( $ stackPtr ) { $ has_class_function = $ this -> phpcsFile -> findNext ( array ( T_CLASS , T_FUNCTION ) , ( $ stackPtr + 1 ) ) ; if ( false === $ has_class_function ) { * Otherwise, check whether any of the TGMPA classes or function names are encountered. * * Will detect TGMPA, even when: * - the class and function prefix has been changed * - the file has been split up into several files * - the file is combined with other code */ if ( false === $ is_tgmpa ) { while ( false !== $ has_class_function ) { $ name = $ this -> phpcsFile -> getDeclarationName ( $ has_class_function ) ; if ( ! empty ( $ name ) ) { if ( isset ( $ this -> tgmpa_classes_functions [ $ name ] ) ) { $ is_tgmpa = true ; break ; } elseif ( strpos ( $ name , '_Plugin_Activation' ) !== false ) { 
protected function detect_manual_editing ( $ version ) { 
protected function get_docblock_tags ( $ comment_opener ) { $ tags = array ( ) ; $ opener = $ this -> tokens [ $ comment_opener ] ; if ( ! isset ( $ opener [ 'comment_tags' ] ) ) { return $ tags ; } $ closer = null ; if ( isset ( $ opener [ 'comment_closer' ] ) ) { $ closer = $ opener [ 'comment_closer' ] ; } $ tag_count = count ( $ opener [ 'comment_tags' ] ) ; for ( $ i = 0 ; $ i < $ tag_count ; $ i ++ ) { $ tag_token = $ opener [ 'comment_tags' ] [ $ i ] ; $ tag = trim ( $ this -> tokens [ $ tag_token ] [ 'content' ] , '@' ) ; $ search_end = $ closer ; if ( ( $ i + 1 ) < $ tag_count ) { $ search_end = $ opener [ 'comment_tags' ] [ ( $ i + 1 ) ] ; } $ value_token = $ this -> phpcsFile -> findNext ( T_DOC_COMMENT_STRING , ( $ tag_token + 1 ) , $ search_end ) ; $ tags [ $ tag ] = trim ( $ this -> tokens [ $ value_token ] [ 'content' ] ) ; unset ( $ tag_token , $ tag , $ search_end , $ value ) ; } return $ tags ; } 
protected function update_current_version ( ) { if ( defined ( 'PHP_CODESNIFFER_IN_TESTS' ) || true === $ this -> gh_call_made ) { return ; } $ api_url = self :: GITHUB_TGMPA_API_URL ; $ oauth_token = false ; if ( '' !== $ this -> github_oauth_token && is_string ( $ this -> github_oauth_token ) ) { $ oauth_token = $ this -> github_oauth_token ; } elseif ( false !== getenv ( 'GITHUB_OAUTH_TOKEN' ) ) { $ oauth_token = getenv ( 'GITHUB_OAUTH_TOKEN' ) ; } if ( false !== $ oauth_token ) { $ api_url .= sprintf ( self :: GITHUB_API_OAUTH_QUERY , $ oauth_token ) ; } $ stream_options = array ( 'http' => array ( 'method' => 'GET' , 'user_agent' => 'WordPress-Coding-Standards/Theme-Review-Sniffs' , 'protocol_version' => 1.1 , ) , ) ; $ stream_context = stream_context_create ( $ stream_options ) ; $ response = file_get_contents ( $ api_url , false , $ stream_context ) ; $ headers = $ this -> parse_response_headers ( $ http_response_header ) ; 
private function parse_response_headers ( $ headers ) { $ head = array ( ) ; foreach ( $ headers as $ key => $ value ) { $ tag = explode ( ':' , $ value , 2 ) ; if ( isset ( $ tag [ 1 ] ) ) { $ head [ trim ( $ tag [ 0 ] ) ] = trim ( $ tag [ 1 ] ) ; } else { $ head [ ] = $ value ; if ( preg_match ( '`HTTP/[0-9\.]+\s+([0-9]+)`' , $ value , $ out ) ) { $ head [ 'response_code' ] = intval ( $ out [ 1 ] ) ; } } } return $ head ; } 
public function process ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; $ token = $ tokens [ $ stackPtr ] ; $ file_name = basename ( $ phpcsFile -> getFileName ( ) ) ; if ( ! isset ( $ this -> file_whitelist [ $ file_name ] ) ) { $ phpcsFile -> addWarning ( 'Check that %s is not being used to load template files. "get_template_part()" should be used to load template files.' , $ stackPtr , 'FileIncludeFound' , array ( $ token [ 'content' ] ) ) ; } } 
public function process ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; $ content = $ tokens [ $ stackPtr ] [ 'content' ] ; $ filename = $ phpcsFile -> getFileName ( ) ; 
public function register ( ) { 
public function process ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; $ token = $ tokens [ $ stackPtr ] ; if ( preg_match ( $ this -> favicon_regex , $ token [ 'content' ] ) > 0 ) { $ phpcsFile -> addError ( 'Code for favicon found. Favicons are handled by the "Site Icon" setting in the customizer since WP version 4.3.' , $ stackPtr , 'NoFavicon' ) ; } } 
public function process ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; if ( '$_SESSION' === $ tokens [ $ stackPtr ] [ 'content' ] ) { $ phpcsFile -> addError ( 'Usage of $_SESSION variable is prohibited.' , $ stackPtr , 'SessionVarsProhibited' ) ; } } 
private static function chunk ( $ binaryString , $ bits ) { $ binaryString = chunk_split ( $ binaryString , $ bits , ' ' ) ; if ( substr ( $ binaryString , ( strlen ( $ binaryString ) ) - 1 ) == ' ' ) { $ binaryString = substr ( $ binaryString , 0 , strlen ( $ binaryString ) - 1 ) ; } return explode ( ' ' , $ binaryString ) ; } 
public static function encode ( $ string ) { if ( strlen ( $ string ) == 0 ) { 
public static function decode ( $ base32String ) { 
function createOAuth2AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/oauth2/token_from_oauth1" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ parts = RequestUtil :: parseResponseJson ( $ response -> body ) ; if ( ! array_key_exists ( 'token_type' , $ parts ) || ! is_string ( $ parts [ 'token_type' ] ) ) { throw new Exception_BadResponse ( "Missing \"token_type\" field." ) ; } $ tokenType = $ parts [ 'token_type' ] ; if ( ! array_key_exists ( 'access_token' , $ parts ) || ! is_string ( $ parts [ 'access_token' ] ) ) { throw new Exception_BadResponse ( "Missing \"access_token\" field." ) ; } $ accessToken = $ parts [ 'access_token' ] ; if ( $ tokenType !== "Bearer" && $ tokenType !== "bearer" ) { throw new Exception_BadResponse ( "Unknown \"token_type\"; expecting \"Bearer\", got " . Util :: q ( $ tokenType ) ) ; } return $ accessToken ; } 
function disableOAuth1AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; } 
private function doPost ( $ oauth1AccessToken , $ path ) { 
static function checkArg ( $ argName , $ argValue ) { if ( ! ( $ argValue instanceof self ) ) Checker :: throwError ( $ argName , $ argValue , __CLASS__ ) ; } 
static function loadFromJsonFileWithRaw ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new AppInfoLoadException ( "File doesn't exist: \"$path\"" ) ; } $ str = Util :: stripUtf8Bom ( file_get_contents ( $ path ) ) ; $ jsonArr = json_decode ( $ str , true , 10 ) ; if ( is_null ( $ jsonArr ) ) { throw new AppInfoLoadException ( "JSON parse error: \"$path\"" ) ; } $ appInfo = self :: loadFromJson ( $ jsonArr ) ; return array ( $ jsonArr , $ appInfo ) ; } 
static function loadFromJson ( $ jsonArr ) { if ( ! is_array ( $ jsonArr ) ) { throw new AppInfoLoadException ( "Expecting JSON object, got something else" ) ; } $ requiredKeys = array ( "key" , "secret" ) ; foreach ( $ requiredKeys as $ key ) { if ( ! array_key_exists ( $ key , $ jsonArr ) ) { throw new AppInfoLoadException ( "Missing field \"$key\"" ) ; } if ( ! is_string ( $ jsonArr [ $ key ] ) ) { throw new AppInfoLoadException ( "Expecting field \"$key\" to be a string" ) ; } } 
static function checkArgOrNull ( $ argName , $ argValue ) { if ( $ argValue === null ) return ; if ( ! ( $ argValue instanceof self ) ) Checker :: throwError ( $ argName , $ argValue , __CLASS__ ) ; } 
function disableAccessToken ( ) { $ response = $ this -> doPost ( $ this -> apiHost , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; } 
function getAccountInfo ( ) { $ response = $ this -> doGet ( $ this -> apiHost , "1/account/info" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; } 
function getFile ( $ path , $ outStream , $ rev = null ) { Path :: checkArgNonRoot ( "path" , $ path ) ; Checker :: argResource ( "outStream" , $ outStream ) ; Checker :: argStringNonEmptyOrNull ( "rev" , $ rev ) ; $ url = $ this -> buildUrlForGetOrPut ( $ this -> contentHost , $ this -> appendFilePath ( "1/files" , $ path ) , array ( "rev" => $ rev ) ) ; $ curl = $ this -> mkCurl ( $ url ) ; $ metadataCatcher = new DropboxMetadataHeaderCatcher ( $ curl -> handle ) ; $ streamRelay = new CurlStreamRelay ( $ curl -> handle , $ outStream ) ; $ response = $ curl -> exec ( ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) { $ response -> body = $ streamRelay -> getErrorBody ( ) ; throw RequestUtil :: unexpectedStatus ( $ response ) ; } return $ metadataCatcher -> getMetadata ( ) ; } 
function uploadFile ( $ path , $ writeMode , $ inStream , $ numBytes = null ) { Path :: checkArgNonRoot ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; Checker :: argResource ( "inStream" , $ inStream ) ; Checker :: argNatOrNull ( "numBytes" , $ numBytes ) ; 
function uploadFileFromString ( $ path , $ writeMode , $ data ) { Path :: checkArgNonRoot ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; Checker :: argString ( "data" , $ data ) ; return $ this -> _uploadFile ( $ path , $ writeMode , function ( Curl $ curl ) use ( $ data ) { $ curl -> set ( CURLOPT_CUSTOMREQUEST , "PUT" ) ; $ curl -> set ( CURLOPT_POSTFIELDS , $ data ) ; $ curl -> addHeader ( "Content-Type: application/octet-stream" ) ; } ) ; } 
function uploadFileChunked ( $ path , $ writeMode , $ inStream , $ numBytes = null , $ chunkSize = null ) { if ( $ chunkSize === null ) { $ chunkSize = self :: $ DEFAULT_CHUNK_SIZE ; } Path :: checkArgNonRoot ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; Checker :: argResource ( "inStream" , $ inStream ) ; Checker :: argNatOrNull ( "numBytes" , $ numBytes ) ; Checker :: argIntPositive ( "chunkSize" , $ chunkSize ) ; return $ this -> _uploadFileChunked ( $ path , $ writeMode , $ inStream , $ numBytes , $ chunkSize ) ; } 
private function _uploadFileChunked ( $ path , $ writeMode , $ inStream , $ numBytes , $ chunkSize ) { Path :: checkArg ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; Checker :: argResource ( "inStream" , $ inStream ) ; Checker :: argNatOrNull ( "numBytes" , $ numBytes ) ; Checker :: argNat ( "chunkSize" , $ chunkSize ) ; 
private static function readFully ( $ inStream , $ numBytes ) { Checker :: argNat ( "numBytes" , $ numBytes ) ; $ full = '' ; $ bytesRemaining = $ numBytes ; while ( ! feof ( $ inStream ) && $ bytesRemaining > 0 ) { $ part = fread ( $ inStream , $ bytesRemaining ) ; if ( $ part === false ) throw new StreamReadException ( "Error reading from \$inStream." ) ; $ full .= $ part ; $ bytesRemaining -= strlen ( $ part ) ; } return $ full ; } 
function chunkedUploadStart ( $ data ) { Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( ) , $ data ) ; if ( $ response -> statusCode === 404 ) { throw new Exception_BadResponse ( "Got a 404, but we didn't send up an 'upload_id'" ) ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) throw new Exception_BadResponse ( "Got an offset-correcting 400 response, but we didn't send an offset" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ uploadId , $ byteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ len = strlen ( $ data ) ; if ( $ byteOffset !== $ len ) throw new Exception_BadResponse ( "We sent $len bytes, but server returned an offset of $byteOffset" ) ; return $ uploadId ; } 
function chunkedUploadContinue ( $ uploadId , $ byteOffset , $ data ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Checker :: argNat ( "byteOffset" , $ byteOffset ) ; Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( "upload_id" => $ uploadId , "offset" => $ byteOffset ) , $ data ) ; if ( $ response -> statusCode === 404 ) { 
function chunkedUploadFinish ( $ uploadId , $ path , $ writeMode ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Path :: checkArgNonRoot ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; $ params = array_merge ( array ( "upload_id" => $ uploadId ) , $ writeMode -> getExtraParams ( ) ) ; $ response = $ this -> doPost ( $ this -> contentHost , $ this -> appendFilePath ( "1/commit_chunked_upload" , $ path ) , $ params ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; } 
function getMetadataWithChildrenIfChanged ( $ path , $ previousFolderHash ) { Path :: checkArg ( "path" , $ path ) ; Checker :: argStringNonEmpty ( "previousFolderHash" , $ previousFolderHash ) ; $ params = array ( "list" => "true" , "file_limit" => "25000" , "hash" => $ previousFolderHash ) ; $ response = $ this -> doGet ( $ this -> apiHost , $ this -> appendFilePath ( "1/metadata" , $ path ) , $ params ) ; if ( $ response -> statusCode === 304 ) return array ( false , null ) ; if ( $ response -> statusCode === 404 ) return array ( true , null ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ metadata = RequestUtil :: parseResponseJson ( $ response -> body ) ; if ( array_key_exists ( "is_deleted" , $ metadata ) && $ metadata [ "is_deleted" ] ) { return array ( true , null ) ; } return array ( true , $ metadata ) ; } 
function getDelta ( $ cursor = null , $ pathPrefix = null ) { Checker :: argStringNonEmptyOrNull ( "cursor" , $ cursor ) ; Path :: checkArgOrNull ( "pathPrefix" , $ pathPrefix ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/delta" , array ( "cursor" => $ cursor , "path_prefix" => $ pathPrefix ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; } 
function getRevisions ( $ path , $ limit = null ) { Path :: checkArgNonRoot ( "path" , $ path ) ; Checker :: argIntPositiveOrNull ( "limit" , $ limit ) ; $ response = $ this -> doGet ( $ this -> apiHost , $ this -> appendFilePath ( "1/revisions" , $ path ) , array ( "rev_limit" => $ limit ) ) ; if ( $ response -> statusCode === 406 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; } 
function restoreFile ( $ path , $ rev ) { Path :: checkArgNonRoot ( "path" , $ path ) ; Checker :: argStringNonEmpty ( "rev" , $ rev ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/restore" , $ path ) , array ( "rev" => $ rev ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; } 
function searchFileNames ( $ basePath , $ query , $ limit = null , $ includeDeleted = false ) { Path :: checkArg ( "basePath" , $ basePath ) ; Checker :: argStringNonEmpty ( "query" , $ query ) ; Checker :: argNatOrNull ( "limit" , $ limit ) ; Checker :: argBool ( "includeDeleted" , $ includeDeleted ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/search" , $ basePath ) , array ( "query" => $ query , "file_limit" => $ limit , "include_deleted" => $ includeDeleted , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; } 
function createShareableLink ( $ path ) { Path :: checkArg ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/shares" , $ path ) , array ( "short_url" => "false" , ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; return self :: getField ( $ j , "url" ) ; } 
function createTemporaryDirectLink ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/media" , $ path ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; $ url = self :: getField ( $ j , "url" ) ; $ expires = self :: parseDateTime ( self :: getField ( $ j , "expires" ) ) ; return array ( $ url , $ expires ) ; } 
function getThumbnail ( $ path , $ format , $ size ) { Path :: checkArgNonRoot ( "path" , $ path ) ; Checker :: argString ( "format" , $ format ) ; Checker :: argString ( "size" , $ size ) ; if ( ! in_array ( $ format , array ( "jpeg" , "png" ) ) ) { throw new \ InvalidArgumentException ( "Invalid 'format': " . Util :: q ( $ format ) ) ; } if ( ! in_array ( $ size , array ( "xs" , "s" , "m" , "l" , "xl" ) ) ) { throw new \ InvalidArgumentException ( "Invalid 'size': " . Util :: q ( $ size ) ) ; } $ url = $ this -> buildUrlForGetOrPut ( $ this -> contentHost , $ this -> appendFilePath ( "1/thumbnails" , $ path ) , array ( "size" => $ size , "format" => $ format ) ) ; $ curl = $ this -> mkCurl ( $ url ) ; $ metadataCatcher = new DropboxMetadataHeaderCatcher ( $ curl -> handle ) ; $ curl -> set ( CURLOPT_RETURNTRANSFER , true ) ; $ response = $ curl -> exec ( ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ metadata = $ metadataCatcher -> getMetadata ( ) ; return array ( $ metadata , $ response -> body ) ; } 
function copyFromCopyRef ( $ copyRef , $ toPath ) { Checker :: argStringNonEmpty ( "copyRef" , $ copyRef ) ; Path :: checkArgNonRoot ( "toPath" , $ toPath ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/copy" , array ( "root" => "auto" , "from_copy_ref" => $ copyRef , "to_path" => $ toPath , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; } 
function createFolder ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/create_folder" , array ( "root" => "auto" , "path" => $ path , ) ) ; if ( $ response -> statusCode === 403 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; } 
function move ( $ fromPath , $ toPath ) { Path :: checkArgNonRoot ( "fromPath" , $ fromPath ) ; Path :: checkArgNonRoot ( "toPath" , $ toPath ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/move" , array ( "root" => "auto" , "from_path" => $ fromPath , "to_path" => $ toPath , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; } 
function buildUrlForGetOrPut ( $ host , $ path , $ params = null ) { return RequestUtil :: buildUrlForGetOrPut ( $ this -> userLocale , $ host , $ path , $ params ) ; } 
function doGet ( $ host , $ path , $ params = null ) { Checker :: argString ( "host" , $ host ) ; Checker :: argString ( "path" , $ path ) ; return RequestUtil :: doGet ( $ this -> clientIdentifier , $ this -> accessToken , $ this -> userLocale , $ host , $ path , $ params ) ; } 
static function parseDateTime ( $ apiDateTimeString ) { $ dt = \ DateTime :: createFromFormat ( self :: $ dateTimeFormat , $ apiDateTimeString ) ; if ( $ dt === false ) throw new Exception_BadResponse ( "Bad date/time from server: " . Util :: q ( $ apiDateTimeString ) ) ; return $ dt ; } 
public static function q ( $ string ) { # HACK: "self::SPECIAL_ESCAPE_OUT[...]" is not valid syntax in PHP 5.3, so put # it in a local variable first. $ special_escape_out = self :: SPECIAL_ESCAPE_OUT ; $ r = "\"" ; $ len = \ strlen ( $ string ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ c = $ string [ $ i ] ; $ escape_i = \ strpos ( self :: SPECIAL_ESCAPE_IN , $ c ) ; if ( $ escape_i !== false ) { // Characters with a special escape code. $ r .= "\\" ; $ r .= $ special_escape_out [ $ escape_i ] ; } else if ( $ c >= "\x20" and $ c <= "\x7e" ) { // Printable characters. $ r .= $ c ; } else { // Generic hex escape code. $ r .= "\\x" ; $ r .= \ bin2hex ( $ c ) ; } } $ r .= "\"" ; return $ r ; } 
public static function stripUtf8Bom ( $ string ) { if ( strlen ( $ string ) == 0 ) return $ string ; if ( \ substr_compare ( $ string , "\xEF\xBB\xBF" , 0 , 3 ) === 0 ) { $ string = \ substr ( $ string , 3 ) ; } return $ string ; } 
public static function startsWith ( $ s , $ prefix , $ caseInsensitive = false ) { 
public static function stripPrefix ( $ s , $ prefix , $ caseInsensitive = false ) { 
static function loadFromJson ( $ jsonObj ) { 
static function loadFromJsonFile ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new AuthInfoLoadException ( "File doesn't exist: \"$path\"" ) ; } $ str = Util :: stripUtf8Bom ( file_get_contents ( $ path ) ) ; $ jsonArr = json_decode ( $ str , true , 10 ) ; if ( is_null ( $ jsonArr ) ) { throw new AuthInfoLoadException ( "JSON parse error: \"$path\"" ) ; } return self :: loadFromJson ( $ jsonArr ) ; } 
private static function loadFromJson ( $ jsonArr ) { if ( ! is_array ( $ jsonArr ) ) { throw new AuthInfoLoadException ( "Expecting JSON object, found something else" ) ; } 
function start ( $ urlState = null , $ forceReapprove = false ) { Checker :: argStringOrNull ( "urlState" , $ urlState ) ; $ csrfToken = self :: encodeCsrfToken ( Security :: getRandomBytes ( 16 ) ) ; $ state = $ csrfToken ; if ( $ urlState !== null ) { $ state .= "|" ; $ state .= $ urlState ; } $ this -> csrfTokenStore -> set ( $ csrfToken ) ; return $ this -> _getAuthorizeUrl ( $ this -> redirectUri , $ state , $ forceReapprove ) ; } 
function finish ( $ queryParams ) { Checker :: argArray ( "queryParams" , $ queryParams ) ; $ csrfTokenFromSession = $ this -> csrfTokenStore -> get ( ) ; Checker :: argStringOrNull ( "this->csrfTokenStore->get()" , $ csrfTokenFromSession ) ; 
static function findError ( $ path ) { Checker :: argStringNonEmpty ( "path" , $ path ) ; $ matchResult = preg_match ( '%^(?: [\x09\x0A\x0D\x20-\x7E] # ASCII | [\xC2-\xDF][\x80-\xBF] # non-overlong 2-byte | \xE0[\xA0-\xBF][\x80-\xBD] # excluding overlongs, FFFE, and FFFF | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2} # straight 3-byte | \xED[\x80-\x9F][\x80-\xBF] # excluding surrogates )*$%xs' , $ path ) ; if ( $ matchResult !== 1 ) { return "must be valid UTF-8; BMP only, no surrogates, no U+FFFE or U+FFFF" ; } if ( $ path [ 0 ] !== "/" ) return "must start with \"/\"" ; $ l = strlen ( $ path ) ; if ( $ l === 1 ) return null ; 
static function getName ( $ path ) { Checker :: argStringNonEmpty ( "path" , $ path ) ; if ( $ path [ 0 ] !== "/" ) { throw new \ InvalidArgumentException ( "'path' must start with \"/\"" ) ; } $ l = strlen ( $ path ) ; if ( $ l === 1 ) return null ; if ( $ path [ $ l - 1 ] === "/" ) { throw new \ InvalidArgumentException ( "'path' must not end with \"/\"" ) ; } $ lastSlash = strrpos ( $ path , "/" ) ; return substr ( $ path , $ lastSlash + 1 ) ; } 
static function checkArg ( $ argName , $ value ) { Checker :: argStringNonEmpty ( $ argName , $ value ) ; $ error = self :: findError ( $ value ) ; if ( $ error !== null ) throw new \ InvalidArgumentException ( "'$argName': bad path: $error: " . Util :: q ( $ value ) ) ; } 
static function checkArgNonRoot ( $ argName , $ value ) { Checker :: argStringNonEmpty ( $ argName , $ value ) ; $ error = self :: findErrorNonRoot ( $ value ) ; if ( $ error !== null ) throw new \ InvalidArgumentException ( "'$argName': bad path: $error: " . Util :: q ( $ value ) ) ; } 
static function doPost ( $ clientIdentifier , $ accessToken , $ userLocale , $ host , $ path , $ params = null ) { Checker :: argStringNonEmpty ( "accessToken" , $ accessToken ) ; $ url = self :: buildUri ( $ host , $ path ) ; if ( $ params === null ) $ params = array ( ) ; $ params [ 'locale' ] = $ userLocale ; $ curl = self :: mkCurlWithOAuth ( $ clientIdentifier , $ url , $ accessToken ) ; $ curl -> set ( CURLOPT_POST , true ) ; $ curl -> set ( CURLOPT_POSTFIELDS , self :: buildPostBody ( $ params ) ) ; $ curl -> set ( CURLOPT_RETURNTRANSFER , true ) ; return $ curl -> exec ( ) ; } 
static function doPostWithSpecificAuth ( $ clientIdentifier , $ authHeaderValue , $ userLocale , $ host , $ path , $ params = null ) { Checker :: argStringNonEmpty ( "authHeaderValue" , $ authHeaderValue ) ; $ url = self :: buildUri ( $ host , $ path ) ; if ( $ params === null ) $ params = array ( ) ; $ params [ 'locale' ] = $ userLocale ; $ curl = self :: mkCurlWithAuth ( $ clientIdentifier , $ url , $ authHeaderValue ) ; $ curl -> set ( CURLOPT_POST , true ) ; $ curl -> set ( CURLOPT_POSTFIELDS , self :: buildPostBody ( $ params ) ) ; $ curl -> set ( CURLOPT_RETURNTRANSFER , true ) ; return $ curl -> exec ( ) ; } 
static function doGet ( $ clientIdentifier , $ accessToken , $ userLocale , $ host , $ path , $ params = null ) { Checker :: argStringNonEmpty ( "accessToken" , $ accessToken ) ; $ url = self :: buildUrlForGetOrPut ( $ userLocale , $ host , $ path , $ params ) ; $ curl = self :: mkCurlWithOAuth ( $ clientIdentifier , $ url , $ accessToken ) ; $ curl -> set ( CURLOPT_HTTPGET , true ) ; $ curl -> set ( CURLOPT_RETURNTRANSFER , true ) ; return $ curl -> exec ( ) ; } 
static function runWithRetry ( $ maxRetries , $ action ) { Checker :: argNat ( "maxRetries" , $ maxRetries ) ; $ retryDelay = 1 ; $ numRetries = 0 ; while ( true ) { try { return $ action ( ) ; } 
static function useExternalPaths ( ) { if ( ! self :: $ useExternalFile and self :: $ paths !== null ) { throw new \ Exception ( "You called \"useExternalFile\" too late. The SDK already used the root " . "certificate file (probably to make an API call)." ) ; } self :: $ useExternalFile = true ; } 
static function getPaths ( ) { if ( self :: $ paths === null ) { if ( self :: $ useExternalFile ) { try { $ baseFolder = sys_get_temp_dir ( ) ; $ file = self :: createExternalCaFile ( $ baseFolder ) ; $ folder = self :: createExternalCaFolder ( $ baseFolder ) ; } catch ( \ Exception $ ex ) { throw new \ Exception ( "Unable to create external root certificate file and folder: " . $ ex -> getMessage ( ) ) ; } } else { if ( substr ( __DIR__ , 0 , 7 ) === 'phar://' ) { throw new \ Exception ( "The code appears to be running in a PHAR. You need to call \\Dropbox\\RootCertificates\\useExternalPaths() before making any API calls." ) ; } $ file = __DIR__ . self :: $ originalPath ; $ folder = \ dirname ( $ file ) ; } self :: $ paths = array ( $ file , $ folder ) ; } return self :: $ paths ; } 
private static function createExternalCaFolder ( $ baseFolder ) { 
private static function createExternalCaFile ( $ baseFolder ) { $ path = \ tempnam ( $ baseFolder , "dropbox-php-sdk-trusted-certs" ) ; if ( $ path === false ) { throw new \ Exception ( "Couldn't create temp file in folder " . Util :: q ( $ baseFolder ) . "." ) ; } \ register_shutdown_function ( function ( ) use ( $ path ) { \ unlink ( $ path ) ; } ) ; 
static function stringEquals ( $ a , $ b ) { 
static function getRandomBytes ( $ numBytes ) { Checker :: argIntPositive ( "numBytes" , $ numBytes ) ; 
public function getCountAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> itemCount , 2 ) ; } 
public function getTotalPriceAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> totalPrice , 2 ) ; } 
public function getTotalTaxAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> totalTax + ( $ this -> totalPrice * Config :: get ( 'shop.tax' ) ) , 2 ) ; } 
public function getTotalShippingAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> totalShipping , 2 ) ; } 
public function getTotalAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return $ this -> totalPrice + $ this -> totalTax + $ this -> totalShipping ; } 
private function runCalculations ( ) { if ( ! empty ( $ this -> shopCalculations ) ) return $ this -> shopCalculations ; $ cacheKey = $ this -> calculationsCacheKey ; if ( Config :: get ( 'shop.cache_calculations' ) && Cache :: has ( $ cacheKey ) ) { $ this -> shopCalculations = Cache :: get ( $ cacheKey ) ; return $ this -> shopCalculations ; } $ this -> shopCalculations = DB :: table ( $ this -> table ) -> select ( [ DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.quantity) as itemCount' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.price * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalPrice' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.tax * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalTax' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.shipping * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalShipping' ) ] ) -> join ( Config :: get ( 'shop.item_table' ) , Config :: get ( 'shop.item_table' ) . '.' . ( $ this -> table == Config :: get ( 'shop.order_table' ) ? 'order_id' : $ this -> table . '_id' ) , '=' , $ this -> table . '.id' ) -> where ( $ this -> table . '.id' , $ this -> attributes [ 'id' ] ) -> first ( ) ; if ( Config :: get ( 'shop.cache_calculations' ) ) { Cache :: put ( $ cacheKey , $ this -> shopCalculations , Config :: get ( 'shop.cache_calculations_minutes' ) ) ; } return $ this -> shopCalculations ; } 
private function resetCalculations ( ) { $ this -> shopCalculations = null ; if ( Config :: get ( 'shop.cache_calculations' ) ) { Cache :: forget ( $ this -> calculationsCacheKey ) ; } } 
public function setCallbacks ( $ order ) { $ this -> callbackSuccess = route ( config ( 'shop.callback_route' ) , [ 'status' => 'success' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; $ this -> callbackFail = route ( config ( 'shop.callback_route' ) , [ 'status' => 'fail' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; } 
public function fire ( ) { $ this -> laravel -> view -> addNamespace ( 'laravel-shop' , substr ( __DIR__ , 0 , - 8 ) . 'views' ) ; $ cartTable = Config :: get ( 'shop.cart_table' ) ; $ itemTable = Config :: get ( 'shop.item_table' ) ; $ couponTable = Config :: get ( 'shop.coupon_table' ) ; $ orderStatusTable = Config :: get ( 'shop.order_status_table' ) ; $ orderTable = Config :: get ( 'shop.order_table' ) ; $ transactionTable = Config :: get ( 'shop.transaction_table' ) ; 
protected function createMigration ( $ data ) { $ migrationFile = base_path ( '/database/migrations' ) . '/' . date ( 'Y_m_d_His' ) . '_shop_setup_tables.php' ; $ usersTable = Config :: get ( 'auth.table' ) ; $ userModel = Config :: get ( 'auth.model' ) ; $ userKeyName = ( new $ userModel ( ) ) -> getKeyName ( ) ; $ data = array_merge ( $ data , compact ( 'usersTable' , 'userKeyName' ) ) ; $ output = $ this -> laravel -> view -> make ( 'laravel-shop::generators.migration' ) -> with ( $ data ) -> render ( ) ; if ( ! file_exists ( $ migrationFile ) && $ fs = fopen ( $ migrationFile , 'x' ) ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; return true ; } return false ; } 
protected function createSeeder ( $ data ) { $ seederFile = base_path ( '/database/seeds' ) . '/LaravelShopSeeder.php' ; $ output = $ this -> laravel -> view -> make ( 'laravel-shop::generators.seeder' ) -> with ( $ data ) -> render ( ) ; if ( ! file_exists ( $ seederFile ) && $ fs = fopen ( $ seederFile , 'x' ) ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; return true ; } return false ; } 
public function getDisplayNameAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> displayName ; return isset ( $ this -> itemName ) ? $ this -> attributes [ $ this -> itemName ] : ( array_key_exists ( 'name' , $ this -> attributes ) ? $ this -> attributes [ 'name' ] : '' ) ; } 
public function getShopUrlAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> shopUrl ; if ( ! property_exists ( $ this , 'itemRouteName' ) && ! property_exists ( $ this , 'itemRouteParams' ) ) return '#' ; $ params = [ ] ; foreach ( array_keys ( $ this -> attributes ) as $ attribute ) { if ( in_array ( $ attribute , $ this -> itemRouteParams ) ) $ params [ $ attribute ] = $ this -> attributes [ $ attribute ] ; } return empty ( $ this -> itemRouteName ) ? '#' : \ route ( $ this -> itemRouteName , $ params ) ; } 
public function getWasPurchasedAttribute ( ) { if ( Auth :: guest ( ) ) return false ; return Auth :: user ( ) -> orders ( ) -> whereSKU ( $ this -> attributes [ 'sku' ] ) -> whereStatusIn ( config ( 'shop.order_status_purchase' ) ) -> count ( ) > 0 ; } 
public function onCharge ( $ order ) { $ this -> statusCode = 'pending' ; $ this -> detail = 'pending response, token:' . $ this -> token ; return parent :: onCharge ( $ order ) ; } 
public function onCallbackFail ( $ order , $ data = null ) { $ this -> statusCode = 'failed' ; $ this -> detail = 'failed callback' ; $ this -> didCallback = true ; } 
public function add ( $ item , $ quantity = 1 , $ quantityReset = false ) { if ( ! is_array ( $ item ) && ! $ item -> isShoppable ) return ; 
public function remove ( $ item , $ quantity = 0 ) { 
public function hasItem ( $ sku , $ requireAll = false ) { if ( is_array ( $ sku ) ) { foreach ( $ sku as $ skuSingle ) { $ hasItem = $ this -> hasItem ( $ skuSingle ) ; if ( $ hasItem && ! $ requireAll ) { return true ; } elseif ( ! $ hasItem && $ requireAll ) { return false ; } } 
public function scopeWhereCurrent ( $ query ) { if ( Auth :: guest ( ) ) return $ query ; return $ query -> whereUser ( Auth :: user ( ) -> shopId ) ; } 
public function scopeFindByUser ( $ query , $ userId ) { if ( empty ( $ userId ) ) return ; $ cart = $ query -> whereUser ( $ userId ) -> first ( ) ; if ( empty ( $ cart ) ) { $ cart = call_user_func ( Config :: get ( 'shop.cart' ) . '::create' , [ 'user_id' => $ userId ] ) ; } return $ cart ; } 
public function placeOrder ( $ statusCode = null ) { if ( empty ( $ statusCode ) ) $ statusCode = Config :: get ( 'shop.order_status_placement' ) ; 
public function clear ( ) { DB :: table ( Config :: get ( 'shop.item_table' ) ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> delete ( ) ; $ this -> resetCalculations ( ) ; return $ this ; } 
private function getItem ( $ sku ) { $ className = Config :: get ( 'shop.item' ) ; $ item = new $ className ( ) ; return $ item -> where ( 'sku' , $ sku ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> first ( ) ; } 
public function scopeWhereUser ( $ query , $ userId ) { return $ query -> join ( Config :: get ( 'shop.order_table' ) , Config :: get ( 'shop.order_table' ) . '.id' , '=' , Config :: get ( 'shop.transaction_table' ) . '.order_id' ) -> where ( Config :: get ( 'shop.order_table' ) . '.user_id' , $ userId ) ; } 
public function boot ( Router $ router ) { parent :: boot ( $ router ) ; 
public function map ( Router $ router ) { $ router -> group ( [ 'namespace' => 'Amsgames\LaravelShop\Http\Controllers' ] , function ( $ router ) { $ router -> group ( [ 'prefix' => 'shop' ] , function ( $ router ) { $ router -> get ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; $ router -> post ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; } ) ; } ) ; } 
public function scopeWhereSKU ( $ query , $ sku ) { return $ query -> join ( config ( 'shop.item_table' ) , config ( 'shop.item_table' ) . '.order_id' , '=' , $ this -> table . '.id' ) -> where ( config ( 'shop.item_table' ) . '.sku' , $ sku ) ; } 
public function scopeFindByUser ( $ query , $ userId , $ statusCode = null ) { if ( ! empty ( $ status ) ) { $ query = $ query -> whereStatus ( $ status ) ; } return $ query -> whereUser ( $ userId ) -> get ( ) ; } 
public function placeTransaction ( $ gateway , $ transactionId , $ detail = null , $ token = null ) { return call_user_func ( Config :: get ( 'shop.transaction' ) . '::create' , [ 'order_id' => $ this -> attributes [ 'id' ] , 'gateway' => $ gateway , 'transaction_id' => $ transactionId , 'detail' => $ detail , 'token' => $ token , ] ) ; } 
protected function process ( Request $ request ) { $ validator = Validator :: make ( [ 'order_id' => $ request -> get ( 'order_id' ) , 'status' => $ request -> get ( 'status' ) , 'shoptoken' => $ request -> get ( 'shoptoken' ) , ] , [ 'order_id' => 'required|exists:' . config ( 'shop.order_table' ) . ',id' , 'status' => 'required|in:success,fail' , 'shoptoken' => 'required|exists:' . config ( 'shop.transaction_table' ) . ',token,order_id,' . $ request -> get ( 'order_id' ) , ] ) ; if ( $ validator -> fails ( ) ) { abort ( 404 ) ; } $ order = call_user_func ( config ( 'shop.order' ) . '::find' , $ request -> get ( 'order_id' ) ) ; $ transaction = $ order -> transactions ( ) -> where ( 'token' , $ request -> get ( 'shoptoken' ) ) -> first ( ) ; Shop :: callback ( $ order , $ transaction , $ request -> get ( 'status' ) , $ request -> all ( ) ) ; $ transaction -> token = null ; $ transaction -> save ( ) ; return redirect ( ) -> route ( config ( 'shop.callback_redirect_route' ) , [ 'orderId' => $ order -> id ] ) ; } 
public static function setGateway ( $ gatewayKey ) { if ( ! array_key_exists ( $ gatewayKey , Config :: get ( 'shop.gateways' ) ) ) throw new ShopException ( 'Invalid gateway.' ) ; static :: $ gatewayKey = $ gatewayKey ; static :: $ gateway = static :: instanceGateway ( ) ; Session :: push ( 'shop.gateway' , $ gatewayKey ) ; } 
public static function getGateway ( ) { $ gateways = Session :: get ( 'shop.gateway' ) ; return $ gateways && count ( $ gateways ) > 0 ? $ gateways [ count ( $ gateways ) - 1 ] : null ; } 
public static function checkout ( $ cart = null ) { $ success = true ; try { if ( empty ( static :: $ gatewayKey ) ) { throw new ShopException ( 'Payment gateway not selected.' ) ; } if ( empty ( $ cart ) ) $ cart = Auth :: user ( ) -> cart ; static :: $ gateway -> onCheckout ( $ cart ) ; } catch ( ShopException $ e ) { static :: setException ( $ e ) ; $ success = false ; } catch ( CheckoutException $ e ) { static :: $ exception = $ e ; $ success = false ; } catch ( GatewayException $ e ) { static :: $ exception = $ e ; $ success = false ; } if ( $ cart ) \ event ( new CartCheckout ( $ cart -> id , $ success ) ) ; return $ success ; } 
public static function placeOrder ( $ cart = null ) { try { if ( empty ( static :: $ gatewayKey ) ) throw new ShopException ( 'Payment gateway not selected.' ) ; if ( empty ( $ cart ) ) $ cart = Auth :: user ( ) -> cart ; $ order = $ cart -> placeOrder ( ) ; $ statusCode = $ order -> statusCode ; \ event ( new OrderPlaced ( $ order -> id ) ) ; static :: $ gateway -> setCallbacks ( $ order ) ; if ( static :: $ gateway -> onCharge ( $ order ) ) { $ order -> statusCode = static :: $ gateway -> getTransactionStatusCode ( ) ; $ order -> save ( ) ; 
public static function callback ( $ order , $ transaction , $ status , $ data = null ) { $ statusCode = $ order -> statusCode ; try { if ( in_array ( $ status , [ 'success' , 'fail' ] ) ) { static :: $ gatewayKey = $ transaction -> gateway ; static :: $ gateway = static :: instanceGateway ( ) ; if ( $ status == 'success' ) { static :: $ gateway -> onCallbackSuccess ( $ order , $ data ) ; $ order -> statusCode = static :: $ gateway -> getTransactionStatusCode ( ) ; 
public static function format ( $ value ) { return preg_replace ( [ '/:symbol/' , '/:price/' , '/:currency/' ] , [ Config :: get ( 'shop.currency_symbol' ) , $ value , Config :: get ( 'shop.currency' ) ] , Config :: get ( 'shop.display_price_format' ) ) ; } 
protected static function checkStatusChange ( $ order , $ prevStatusCode ) { if ( ! empty ( $ prevStatusCode ) && $ order -> statusCode != $ prevStatusCode ) \ event ( new OrderStatusChanged ( $ order -> id , $ order -> statusCode , $ prevStatusCode ) ) ; } 
public function up ( ) { Schema :: create ( 'job_statuses' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> string ( 'job_id' ) -> index ( ) -> nullable ( ) ; $ table -> string ( 'type' ) -> index ( ) ; $ table -> string ( 'queue' ) -> index ( ) -> nullable ( ) ; $ table -> integer ( 'attempts' ) -> default ( 0 ) ; $ table -> integer ( 'progress_now' ) -> default ( 0 ) ; $ table -> integer ( 'progress_max' ) -> default ( 0 ) ; $ table -> string ( 'status' , 16 ) -> default ( \ Imtigger \ LaravelJobStatus \ JobStatus :: STATUS_QUEUED ) -> index ( ) ; $ table -> longText ( 'input' ) -> nullable ( ) ; $ table -> longText ( 'output' ) -> nullable ( ) ; $ table -> timestamps ( ) ; $ table -> timestamp ( 'started_at' ) -> nullable ( ) ; $ table -> timestamp ( 'finished_at' ) -> nullable ( ) ; } ) ; } 
protected function preserveLines ( $ data , bool $ reverse ) { $ search = [ "\n" , "\r" ] ; $ replace = [ '\\n' , '\\r' ] ; if ( $ reverse ) { $ search = [ '\\n' , '\\r' ] ; $ replace = [ "\n" , "\r" ] ; } if ( is_string ( $ data ) ) { $ data = str_replace ( $ search , $ replace , $ data ) ; } elseif ( is_array ( $ data ) ) { foreach ( $ data as & $ value ) { $ value = $ this -> preserveLines ( $ value , $ reverse ) ; } unset ( $ value ) ; } return $ data ; } 
public function encode ( $ data ) : string { $ result = json_encode ( $ data ) ; if ( json_last_error ( ) === JSON_ERROR_NONE ) { return $ result ; } throw new Exception ( json_last_error_msg ( ) ) ; } 
public function decode ( string $ data ) { $ result = json_decode ( $ data , $ this -> assoc ) ; if ( json_last_error ( ) === JSON_ERROR_NONE ) { return $ result ; } throw new Exception ( json_last_error_msg ( ) ) ; } 
public function getPath ( ) : string { return $ this -> config -> getDir ( ) . $ this -> getName ( ) . $ this -> config -> getExt ( ) ; } 
protected function openFile ( int $ mode ) : SplFileObject { $ path = $ this -> getPath ( ) ; if ( ! is_file ( $ path ) && ! @ touch ( $ path ) ) { throw new Exception ( 'Could not create file: ' . $ path ) ; } if ( ! is_readable ( $ path ) || ! is_writable ( $ path ) ) { throw new Exception ( 'File does not have permission for read and write: ' . $ path ) ; } if ( $ this -> getConfig ( ) -> useGzip ( ) ) { $ path = 'compress.zlib://' . $ path ; } $ res = $ this -> fileAccessMode [ $ mode ] ; $ file = new SplFileObject ( $ path , $ res [ 'mode' ] ) ; if ( $ mode === self :: FILE_READ ) { $ file -> setFlags ( SplFileObject :: DROP_NEW_LINE | SplFileObject :: SKIP_EMPTY | SplFileObject :: READ_AHEAD ) ; } if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( $ res [ 'operation' ] ) ) { $ file = null ; throw new Exception ( 'Could not lock file: ' . $ path ) ; } return $ file ; } 
protected function closeFile ( SplFileObject & $ file ) { if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( LOCK_UN ) ) { $ file = null ; throw new Exception ( 'Could not unlock file' ) ; } $ file = null ; } 
public function readFromFile ( ) : \ Generator { $ file = $ this -> openFile ( static :: FILE_READ ) ; try { foreach ( $ file as $ line ) { yield new Line ( $ line ) ; } } finally { $ this -> closeFile ( $ file ) ; } } 
public function appendToFile ( string $ line ) { $ file = $ this -> openFile ( static :: FILE_APPEND ) ; $ file -> fwrite ( $ line ) ; $ this -> closeFile ( $ file ) ; } 
public function writeTempToFile ( SplTempFileObject & $ tmpFile ) { $ file = $ this -> openFile ( static :: FILE_WRITE ) ; foreach ( $ tmpFile as $ line ) { $ file -> fwrite ( $ line ) ; } $ this -> closeFile ( $ file ) ; $ tmpFile = null ; } 
public function setConfig ( Config $ config ) { $ this -> config = $ config ; $ this -> getDatabase ( ) -> setConfig ( $ config ) ; } 
public function get ( string $ key ) { Validation :: validateKey ( $ key ) ; 
public function set ( string $ key , $ data ) { Validation :: validateKey ( $ key ) ; 
public function delete ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , false ) ; } } 
public function flush ( ) { $ this -> getDatabase ( ) -> flushFile ( ) ; 
public function getKeys ( ) : array { $ keys = [ ] ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { $ keys [ ] = $ line -> getKey ( ) ; } return $ keys ; } 
public function getAll ( ) : array { $ data = [ ] ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { $ data [ $ line -> getKey ( ) ] = $ this -> decodeData ( $ line -> getData ( ) ) ; } return $ data ; } 
protected function replace ( string $ key , $ data ) { 
protected function normalizeConfig ( array $ config ) : array { $ defaultConfig = [ 'dir' => getcwd ( ) , 'ext' => '.dat' , 'gzip' => false , 'cache' => true , 'formatter' => null , 'swap_memory_limit' => 2097152 , 
public function setDir ( string $ dir ) { if ( ! is_dir ( $ dir ) ) { throw new Exception ( 'Directory does not exist: ' . $ dir ) ; } $ this -> config [ 'dir' ] = rtrim ( $ dir , '/\\' ) . DIRECTORY_SEPARATOR ; } 
public function setExt ( string $ ext ) { if ( substr ( $ ext , 0 , 1 ) !== '.' ) { $ ext = '.' . $ ext ; } $ this -> config [ 'ext' ] = $ ext ; } 
public function setCache ( $ cache ) { if ( ! is_bool ( $ cache ) && ! $ cache instanceof CacheInterface ) { throw new Exception ( 'Cache must be a boolean or an instance of Flintstone\Cache\CacheInterface' ) ; } if ( $ cache === true ) { $ cache = new ArrayCache ( ) ; } $ this -> config [ 'cache' ] = $ cache ; } 
public function setFormatter ( $ formatter ) { if ( $ formatter === null ) { $ formatter = new SerializeFormatter ( ) ; } if ( ! $ formatter instanceof FormatterInterface ) { throw new Exception ( 'Formatter must be an instance of Flintstone\Formatter\FormatterInterface' ) ; } $ this -> config [ 'formatter' ] = $ formatter ; } 
public function selectRender ( ViewEvent $ e ) { if ( $ this -> isForceRender ( ) ) { return $ this -> renderer ; } $ model = $ e -> getModel ( ) ; if ( $ model instanceof TwigModel ) { return $ this -> renderer ; } return null ; } 
public function add ( $ name , $ path ) : MapLoader { if ( $ this -> exists ( $ name ) ) { throw new LoaderError ( sprintf ( 'Name "%s" already exists in map' , $ name ) ) ; } $ this -> map [ $ name ] = $ path ; return $ this ; } 
public function isFresh ( $ name , $ time ) : bool { if ( ! $ this -> exists ( $ name ) ) { throw new LoaderError ( sprintf ( 'Unable to find template "%s" from template map' , $ name ) ) ; } if ( ! file_exists ( $ this -> map [ $ name ] ) ) { throw new LoaderError ( sprintf ( 'Unable to open file "%s" from template map' , $ this -> map [ $ name ] ) ) ; } return filemtime ( $ this -> map [ $ name ] ) <= $ time ; } 
public function getSourceContext ( $ name ) : Source { if ( ! $ this -> exists ( $ name ) ) { throw new LoaderError ( sprintf ( 'Unable to find template "%s" from template map' , $ name ) ) ; } if ( ! file_exists ( $ this -> map [ $ name ] ) ) { throw new LoaderError ( sprintf ( 'Unable to open file "%s" from template map' , $ this -> map [ $ name ] ) ) ; } $ content = file_get_contents ( $ this -> map [ $ name ] ) ; $ source = new Source ( $ content , $ name , $ this -> map [ $ name ] ) ; return $ source ; } 
public function onBootstrap ( EventInterface $ e ) { $ app = $ e -> getApplication ( ) ; $ container = $ app -> getServiceManager ( ) ; $ config = $ container -> get ( 'Configuration' ) ; $ env = $ container -> get ( Environment :: class ) ; $ name = static :: MODULE_NAME ; $ options = $ envOptions = empty ( $ config [ $ name ] ) ? [ ] : $ config [ $ name ] ; $ extensions = empty ( $ options [ 'extensions' ] ) ? [ ] : $ options [ 'extensions' ] ; $ renderer = $ container -> get ( TwigRenderer :: class ) ; 
public static function build ( $ name ) { $ callable = function ( $ env , ... $ args ) use ( $ name ) { $ extension = $ env -> getExtension ( Extension :: class ) ; $ plugin = $ extension -> getRenderer ( ) -> plugin ( $ name ) ; if ( is_callable ( $ plugin ) ) { 
public function plugin ( $ name , array $ options = null ) { $ helper = $ this -> getTwigHelpers ( ) -> setRenderer ( $ this ) ; if ( $ helper -> has ( $ name ) ) { return $ helper -> get ( $ name , $ options ) ; } return $ this -> getHelperPluginManager ( ) -> get ( $ name , $ options ) ; } 
public function render ( $ nameOrModel , $ values = null ) : string { $ model = $ nameOrModel ; if ( $ model instanceof ModelInterface ) { $ nameOrModel = $ model -> getTemplate ( ) ; if ( empty ( $ nameOrModel ) ) { throw new DomainException ( sprintf ( '%s: received View Model argument, but template is empty' , __METHOD__ ) ) ; } $ options = $ model -> getOptions ( ) ; $ options = empty ( $ options ) ? [ ] : $ options ; foreach ( $ options as $ setting => $ value ) { $ method = 'set' . $ setting ; if ( method_exists ( $ this , $ method ) ) { $ this -> $ method ( $ value ) ; } unset ( $ method , $ setting , $ value ) ; } $ helper = $ this -> plugin ( ViewModel :: class ) ; $ helper -> setCurrent ( $ model ) ; $ values = $ model -> getVariables ( ) ; } if ( ! $ this -> canRender ( $ nameOrModel ) ) { throw new RuntimeException ( sprintf ( '%s: Unable to render template "%s"; resolver could not resolve to a file' , __METHOD__ , $ nameOrModel ) ) ; } if ( $ model instanceof ModelInterface && $ model -> hasChildren ( ) && $ this -> canRenderTrees ( ) ) { if ( ! isset ( $ values [ $ model -> captureTo ( ) ] ) ) { $ values [ $ model -> captureTo ( ) ] = '' ; } foreach ( $ model -> getChildren ( ) as $ child ) { $ result = $ this -> render ( $ child , $ values ) ; if ( $ this -> isForceStandalone ( ) || $ child -> terminate ( ) ) { return $ result ; } $ child -> setOption ( 'has_parent' , true ) ; if ( $ child -> isAppend ( ) ) { $ values [ $ child -> captureTo ( ) ] .= $ result ; } else { $ values [ $ child -> captureTo ( ) ] = $ result ; } } } $ template = $ this -> getResolver ( ) -> resolve ( $ nameOrModel , $ this ) ; return $ template -> render ( ( array ) $ values ) ; } 
public function setView ( View $ view ) : TwigRenderer { $ this -> view = $ view ; $ view -> getEventManager ( ) ; return $ this ; } 
function Header ( ) { // Logo $ this -> Image ( 'logo.png' , 10 , 6 , 30 ) ; // Arial bold 15 $ this -> SetFont ( 'Arial' , 'B' , 15 ) ; // Move to the right $ this -> Cell ( 80 ) ; // Title $ this -> Cell ( 30 , 10 , 'Title' , 1 , 0 , 'C' ) ; // Line break $ this -> Ln ( 20 ) ; } 
public function register ( ) { $ configPath = __DIR__ . '/config/fpdf.php' ; $ this -> mergeConfigFrom ( $ configPath , 'fpdf' ) ; $ this -> app -> call ( [ $ this , 'registerFpdf' ] ) ; } 
function LoadData ( $ file ) { // Read file lines $ lines = file ( $ file ) ; $ data = array ( ) ; foreach ( $ lines as $ line ) $ data [ ] = explode ( ';' , trim ( $ line ) ) ; return $ data ; } 
function BasicTable ( $ header , $ data ) { // Header foreach ( $ header as $ col ) $ this -> Cell ( 40 , 7 , $ col , 1 ) ; $ this -> Ln ( ) ; // Data foreach ( $ data as $ row ) { foreach ( $ row as $ col ) $ this -> Cell ( 40 , 6 , $ col , 1 ) ; $ this -> Ln ( ) ; } } 
function ImprovedTable ( $ header , $ data ) { // Column widths $ w = array ( 40 , 35 , 40 , 45 ) ; // Header for ( $ i = 0 ; $ i < count ( $ header ) ; $ i ++ ) $ this -> Cell ( $ w [ $ i ] , 7 , $ header [ $ i ] , 1 , 0 , 'C' ) ; $ this -> Ln ( ) ; // Data foreach ( $ data as $ row ) { $ this -> Cell ( $ w [ 0 ] , 6 , $ row [ 0 ] , 'LR' ) ; $ this -> Cell ( $ w [ 1 ] , 6 , $ row [ 1 ] , 'LR' ) ; $ this -> Cell ( $ w [ 2 ] , 6 , number_format ( $ row [ 2 ] ) , 'LR' , 0 , 'R' ) ; $ this -> Cell ( $ w [ 3 ] , 6 , number_format ( $ row [ 3 ] ) , 'LR' , 0 , 'R' ) ; $ this -> Ln ( ) ; } // Closing line $ this -> Cell ( array_sum ( $ w ) , 0 , '' , 'T' ) ; } 
function FancyTable ( $ header , $ data ) { // Colors, line width and bold font $ this -> SetFillColor ( 255 , 0 , 0 ) ; $ this -> SetTextColor ( 255 ) ; $ this -> SetDrawColor ( 128 , 0 , 0 ) ; $ this -> SetLineWidth ( .3 ) ; $ this -> SetFont ( '' , 'B' ) ; // Header $ w = array ( 40 , 35 , 40 , 45 ) ; for ( $ i = 0 ; $ i < count ( $ header ) ; $ i ++ ) $ this -> Cell ( $ w [ $ i ] , 7 , $ header [ $ i ] , 1 , 0 , 'C' , true ) ; $ this -> Ln ( ) ; // Color and font restoration $ this -> SetFillColor ( 224 , 235 , 255 ) ; $ this -> SetTextColor ( 0 ) ; $ this -> SetFont ( '' ) ; // Data $ fill = false ; foreach ( $ data as $ row ) { $ this -> Cell ( $ w [ 0 ] , 6 , $ row [ 0 ] , 'LR' , 0 , 'L' , $ fill ) ; $ this -> Cell ( $ w [ 1 ] , 6 , $ row [ 1 ] , 'LR' , 0 , 'L' , $ fill ) ; $ this -> Cell ( $ w [ 2 ] , 6 , number_format ( $ row [ 2 ] ) , 'LR' , 0 , 'R' , $ fill ) ; $ this -> Cell ( $ w [ 3 ] , 6 , number_format ( $ row [ 3 ] ) , 'LR' , 0 , 'R' , $ fill ) ; $ this -> Ln ( ) ; $ fill = ! $ fill ; } // Closing line $ this -> Cell ( array_sum ( $ w ) , 0 , '' , 'T' ) ; } 
private function readDataFromPendingClient ( $ socket , int $ length , PendingSocketClient $ state ) { $ data = \ fread ( $ socket , $ length ) ; if ( $ data === false || $ data === '' ) { return null ; } $ data = $ state -> receivedDataBuffer . $ data ; if ( \ strlen ( $ data ) < $ length ) { $ state -> receivedDataBuffer = $ data ; return null ; } $ state -> receivedDataBuffer = '' ; Loop :: cancel ( $ state -> readWatcher ) ; return $ data ; } 
public function read ( ) : Promise { if ( $ this -> initialRead ) { throw new PendingReadError ; } if ( $ this -> error ) { return new Failure ( $ this -> error ) ; } if ( $ this -> resourceStream ) { return $ this -> resourceStream -> read ( ) ; } if ( $ this -> shouldClose ) { return new Success ; 
public function start ( ) : Promise { if ( $ this -> handle ) { throw new StatusError ( "Process has already been started." ) ; } return call ( function ( ) { $ this -> handle = $ this -> processRunner -> start ( $ this -> command , $ this -> cwd , $ this -> env , $ this -> options ) ; return $ this -> pid = yield $ this -> handle -> pidDeferred -> promise ( ) ; } ) ; } 
public function join ( ) : Promise { if ( ! $ this -> handle ) { throw new StatusError ( "Process has not been started." ) ; } return $ this -> processRunner -> join ( $ this -> handle ) ; } 
public function signal ( int $ signo ) { if ( ! $ this -> isRunning ( ) ) { throw new StatusError ( "Process is not running." ) ; } $ this -> processRunner -> signal ( $ this -> handle , $ signo ) ; } 
public function getStdin ( ) : ProcessOutputStream { if ( ! $ this -> handle || $ this -> handle -> status === ProcessStatus :: STARTING ) { throw new StatusError ( "Process has not been started or has not completed starting." ) ; } return $ this -> handle -> stdin ; } 
public function getStdout ( ) : ProcessInputStream { if ( ! $ this -> handle || $ this -> handle -> status === ProcessStatus :: STARTING ) { throw new StatusError ( "Process has not been started or has not completed starting." ) ; } return $ this -> handle -> stdout ; } 
public function getStderr ( ) : ProcessInputStream { if ( ! $ this -> handle || $ this -> handle -> status === ProcessStatus :: STARTING ) { throw new StatusError ( "Process has not been started or has not completed starting." ) ; } return $ this -> handle -> stderr ; } 
public function twitter ( ) { if ( is_null ( $ this -> title ) ) { $ this -> title = config ( 'laravel-share.services.twitter.text' ) ; } $ base = config ( 'laravel-share.services.twitter.uri' ) ; $ url = $ base . '?text=' . urlencode ( $ this -> title ) . '&url=' . $ this -> url ; $ this -> buildLink ( 'twitter' , $ url ) ; return $ this ; } 
public function linkedin ( $ summary = '' ) { $ base = config ( 'laravel-share.services.linkedin.uri' ) ; $ mini = config ( 'laravel-share.services.linkedin.extra.mini' ) ; $ url = $ base . '?mini=' . $ mini . '&url=' . $ this -> url . '&title=' . urlencode ( $ this -> title ) . '&summary=' . urlencode ( $ summary ) ; $ this -> buildLink ( 'linkedin' , $ url ) ; return $ this ; } 
protected function buildLink ( $ provider , $ url ) { $ fontAwesomeVersion = config ( 'laravel-share.fontAwesomeVersion' , 4 ) ; $ this -> html .= trans ( "laravel-share::laravel-share-fa$fontAwesomeVersion.$provider" , [ 'url' => $ url , 'class' => key_exists ( 'class' , $ this -> options ) ? $ this -> options [ 'class' ] : '' , 'id' => key_exists ( 'id' , $ this -> options ) ? $ this -> options [ 'id' ] : '' , ] ) ; } 
protected function setPrefixAndSuffix ( $ prefix , $ suffix ) { if ( ! is_null ( $ prefix ) ) { $ this -> prefix = $ prefix ; } if ( ! is_null ( $ suffix ) ) { $ this -> suffix = $ suffix ; } } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { try { $ output -> writeln ( '<info>Starting Expirian data update.</info>' ) ; $ integrationHelper = $ this -> getContainer ( ) -> get ( 'mautic.helper.integration' ) ; $ enhancerHelper = new EnhancerHelper ( $ integrationHelper ) ; $ correctAddress = $ enhancerHelper -> getIntegration ( 'CorrectAddress' ) ; $ settings = $ correctAddress -> getIntegrationSettings ( ) -> getFeatureSettings ( ) ; $ keys = $ correctAddress -> getKeys ( ) ; if ( function_exists ( 'ssh2_connect' ) ) { $ sconn = call_user_func ( 'ssh2_connect' , $ settings [ CAI :: CA_REMOTE_HOST ] ) ; call_user_func ( 'ssh2_auth_password' , $ sconn , $ keys [ CAI :: CA_REMOTE_USER ] , $ keys [ CAI :: CA_REMOTE_PSWD ] ) ; $ sftp = call_user_func ( 'ssh2_sftp' , $ sconn ) ; } else { throw new \ Exception ( 'Required ssh2 extension is not installed' , - 1 ) ; } $ output -> writeln ( '<info>SFTP connection established, downloading data file</info>' ) ; $ source = 'ssh2.sftp://' . intval ( $ sftp ) . $ settings [ CAI :: CA_REMOTE_PATH ] . '/' . $ settings [ CAI :: CA_REMOTE_FILE ] ; $ buffer = tempnam ( sys_get_temp_dir ( ) , 'ca_' . \ date ( 'Y-m-d' ) ) ; if ( file_exists ( $ buffer ) ) { unlink ( $ buffer ) ; } $ dest = $ buffer . '.zip' ; $ rfp = fopen ( $ source , 'r' ) ; $ wfp = fopen ( $ dest , 'w' ) ; $ reads = 0 ; do { if ( ! fwrite ( $ wfp , fread ( $ rfp , 8388608 ) ) ) { break ; } ++ $ reads ; if ( 0 === ( $ reads % 100 ) ) { $ output -> write ( '.' ) ; } } while ( true ) ; $ output -> writeln ( '<info>Copied data archive to ' . $ dest . ' on local filesystem.</info>' ) ; 
protected function cleanDir ( $ dirName ) { if ( file_exists ( $ dirName ) ) { if ( is_dir ( $ dirName ) ) { $ rm_path = new \ RecursiveDirectoryIterator ( $ dirName , \ RecursiveDirectoryIterator :: SKIP_DOTS ) ; $ rm_ls = new \ RecursiveIteratorIterator ( $ rm_path , \ RecursiveIteratorIterator :: CHILD_FIRST ) ; foreach ( $ rm_ls as $ rm_file ) { $ rm_file -> isDir ( ) ? rmdir ( $ rm_file -> getRealPath ( ) ) : unlink ( $ rm_file -> getRealPath ( ) ) ; } rmdir ( $ dirName ) ; } else { unlink ( $ dirName ) ; } } else { mkdir ( $ dirName , 0755 , true ) ; rmdir ( $ dirName ) ; } return true ; } 
public function updateReferenceTable ( GenderNameModel $ model ) { $ this -> emptyReferenceTable ( ) ; $ em = $ this -> getEntityManager ( ) ; $ preppedData = $ model -> prepareGenderNameData ( ) ; $ batchSize = 200 ; $ count = 0 ; echo 'Inserting data' . PHP_EOL ; foreach ( $ preppedData as $ datum ) { $ record = new PluginEnhancerGenderName ( ) ; $ record -> setName ( $ datum [ 'name' ] ) -> setGender ( $ datum [ 'gender' ] ) -> setProbability ( $ datum [ 'probability' ] ) -> setCount ( $ datum [ 'count' ] ) ; $ em -> persist ( $ record ) ; ++ $ count ; if ( 0 === ( $ count % $ batchSize ) ) { $ em -> flush ( ) ; $ em -> clear ( ) ; } } $ em -> flush ( ) ; $ em -> clear ( ) ; } 
public function getResult ( $ ipAddress , $ userAgent ) { $ record = $ this -> getRepository ( ) -> findByIpAndUserAgent ( $ ipAddress , $ userAgent ) ; if ( null === $ record || 'failed' === $ record -> getResult ( ) ) { 
public function doEnhancement ( Lead $ lead ) { $ persist = false ; if ( ! empty ( $ lead ) ) { $ settings = $ this -> getIntegrationSettings ( ) -> getFeatureSettings ( ) ; $ contactFieldMapping = $ settings [ 'leadFields' ] ; $ keys = $ this -> getKeys ( ) ; $ params = [ 'apikey' => $ keys [ 'apikey' ] , 'domain' => $ keys [ 'server' ] , 'type' => 'json' , ] ; foreach ( $ contactFieldMapping as $ integrationFieldName => $ mauticFieldName ) { $ fieldToUpdate = $ integrationFieldName . '_valid' ; 
protected function makeCall ( $ service , $ params , $ fieldKey , $ fieldValue ) { 
protected function getResponseStatus ( $ response , $ fieldKey ) { $ status = null ; 
public function doEnhancement ( Lead $ lead ) { $ persist = false ; if ( $ lead -> getFieldValue ( self :: CERT_URL_FIELD ) && ! $ lead -> getFieldValue ( 'trusted_form_created_at' ) ) { $ trustedFormClaim = $ lead -> getFieldValue ( self :: CERT_URL_FIELD ) ; $ parts = parse_url ( $ trustedFormClaim ) ; if ( 'https' !== $ parts [ 'scheme' ] || self :: CERT_REAL_HOST !== $ parts [ 'host' ] ) { $ this -> logger -> warning ( 'Not Processing Suspicious TrustedForm URL: ' . $ trustedFormClaim ) ; return false ; } $ parameters = $ this -> getFingers ( $ lead ) ; if ( $ lead -> getId ( ) ) { $ parameters [ 'reference' ] = '' . $ lead -> getId ( ) ; $ identifier = $ lead -> getId ( ) ; } else { $ identifier = $ lead -> getEmail ( ) ; } $ utmData = $ lead -> getUtmTags ( ) ; 
protected function getFingers ( Lead $ lead ) { $ fingers = [ ] ; 
public function doEnhancement ( Lead $ lead ) { if ( ! empty ( $ lead ) ) { $ settings = $ this -> getIntegrationSettings ( ) -> getFeatureSettings ( ) ; if ( ! $ lead -> getFieldValue ( $ settings [ 'random_field_name' ] ) ) { $ lead -> addUpdatedField ( $ settings [ 'random_field_name' ] , rand ( 1 , 100 ) ) ; return true ; } } return false ; } 
public function doEnhancement ( Lead $ lead ) { $ save = false ; if ( ! empty ( $ lead ) ) { 
public function doEnhancement ( Lead $ lead ) { $ save = false ; $ this -> logger -> info ( 'AgeFromBirthdate:doEnhancemet' ) ; 
public function doEnhancement ( Lead $ lead ) { $ keys = $ this -> getKeys ( ) ; $ query = [ 'username' => $ keys [ 'username' ] , 'password' => $ keys [ 'password' ] , 'svcid' => $ keys [ 'serviceId' ] , 'elems' => $ this -> getNeustarElementId ( ) , 'version' => '1.0' , 'transid' => '1' , ] ; foreach ( $ this -> getNeustarServiceKeys ( ) as $ serviceKey ) { $ query [ 'key' . $ serviceKey ] = $ this -> getServiceIdData ( $ lead , $ serviceKey ) ; } $ settings = $ this -> getIntegrationSettings ( ) -> getFeatureSettings ( ) ; $ neustarClient = new Client ( ) ; $ neustarResponse = $ neustarClient -> request ( 'GET' , $ settings [ 'endpoint' ] , [ 'query' => $ query , 'timeout' => 3 , 'connect_timeout' => 2 ] ) ; return $ this -> processResponse ( $ lead , $ neustarResponse ) ; } 
protected function domDocumentArray ( $ root ) { $ result = [ ] ; if ( $ root -> hasAttributes ( ) ) { foreach ( $ root -> attributes as $ attribute ) { $ result [ '@attributes' ] [ $ attribute -> name ] = $ attribute -> value ; } } if ( $ root -> hasChildNodes ( ) ) { if ( 1 == $ root -> childNodes -> length ) { $ child = $ root -> childNodes -> item ( 0 ) ; if ( in_array ( $ child -> nodeType , [ XML_TEXT_NODE , XML_CDATA_SECTION_NODE ] ) && ! empty ( $ child -> nodeValue ) ) { $ result [ '_value' ] = $ child -> nodeValue ; return 1 == count ( $ result ) ? $ result [ '_value' ] : $ result ; } } $ groups = [ ] ; foreach ( $ root -> childNodes as $ child ) { if ( ! isset ( $ result [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = $ this -> domDocumentArray ( $ child ) ; } else { if ( ! isset ( $ groups [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = [ $ result [ $ child -> nodeName ] ] ; $ groups [ $ child -> nodeName ] = 1 ; } $ result [ $ child -> nodeName ] [ ] = $ this -> domDocumentArray ( $ child ) ; } } } return $ result ; } 
public function doEnhancement ( Lead $ lead ) { $ phone = preg_replace ( '/\D+/' , '' , $ lead -> getPhone ( ) ) ; if ( empty ( $ phone ) ) { $ phone = preg_replace ( '/\D+/' , '' , $ lead -> getMobile ( ) ) ; } $ phone = substr ( $ phone , - 10 ) ; if ( 10 === strlen ( $ phone ) ) { $ lead -> addUpdatedField ( 'ptp_area_code' , substr ( $ phone , - 10 , 3 ) ) ; $ lead -> addUpdatedField ( 'ptp_prefix' , substr ( $ phone , - 7 , 3 ) ) ; $ lead -> addUpdatedField ( 'ptp_line_number' , substr ( $ phone , - 4 , 4 ) ) ; return true ; } return false ; } 
public function getFormLeadFields ( $ settings = [ ] ) { static $ fields = [ ] ; if ( empty ( $ fields ) ) { $ name = $ this -> getName ( ) ; $ available = $ this -> getAvailableLeadFields ( $ settings ) ; if ( empty ( $ available ) || ! is_array ( $ available ) ) { return [ ] ; } foreach ( $ available as $ field => $ details ) { $ label = empty ( $ details [ 'label' ] ) ? false : $ details [ 'label' ] ; $ matchedFieldName = $ this -> matchFieldName ( $ field ) ; switch ( $ details [ 'type' ] ) { case 'string' : case 'boolean' : $ fields [ $ matchedFieldName ] = ( ! $ label ) ? $ this -> translator -> transConditional ( "mautic.integration.common.{$matchedFieldName}" , "mautic.integration.{$name}.{$matchedFieldName}.label" ) : $ label ; break ; case 'object' : if ( isset ( $ details [ 'fields' ] ) ) { foreach ( $ details [ 'fields' ] as $ property ) { $ matchedFieldName = $ this -> matchFieldName ( $ field , $ property ) ; $ fields [ $ matchedFieldName ] = ( ! $ label ) ? $ this -> translator -> transConditional ( "mautic.integration.common.{$matchedFieldName}" , "mautic.integration.{$name}.{$matchedFieldName}.label" ) : $ label ; } } else { $ fields [ $ field ] = ( ! $ label ) ? $ this -> translator -> transConditional ( "mautic.integration.common.{$matchedFieldName}" , "mautic.integration.{$name}.{$matchedFieldName}.label" ) : $ label ; } break ; case 'array_object' : if ( 'urls' == $ field || 'url' == $ field ) { foreach ( $ details [ 'fields' ] as $ property ) { $ fields [ "{$property}Urls" ] = ( ! $ label ) ? $ this -> translator -> transConditional ( "mautic.integration.common.{$property}Urls" , "mautic.integration.{$name}.{$property}Urls" ) : $ label ; } } elseif ( isset ( $ details [ 'fields' ] ) ) { foreach ( $ details [ 'fields' ] as $ property ) { $ matchedFieldName = $ this -> matchFieldName ( $ field , $ property ) ; $ fields [ $ matchedFieldName ] = ( ! $ label ) ? $ this -> translator -> transConditional ( "mautic.integration.common.{$matchedFieldName}" , "mautic.integration.{$name}.{$matchedFieldName}.label" ) : $ label ; } } else { $ fields [ $ matchedFieldName ] = ( ! $ label ) ? $ this -> translator -> transConditional ( "mautic.integration.common.{$matchedFieldName}" , "mautic.integration.{$name}.{$matchedFieldName}.label" ) : $ label ; } break ; } } if ( $ this -> sortFieldsAlphabetically ( ) ) { uasort ( $ fields , 'strnatcmp' ) ; } } return $ fields ; } 
public function pushLead ( Lead & $ lead , array $ config = [ ] ) { $ this -> logger -> debug ( 'Pushing to Enhancer ' . $ this -> getName ( ) , $ config ) ; if ( ! $ this -> getIntegrationSettings ( ) -> getIsPublished ( ) ) { return true ; } $ this -> config = $ config ; $ this -> isPush = true ; try { if ( $ this -> doEnhancement ( $ lead ) ) { $ this -> saveLead ( $ lead ) ; } } catch ( \ Exception $ exception ) { $ this -> logIntegrationError ( new ApiErrorException ( 'There was an issue using enhancer: ' . $ this -> getName ( ) , 0 , $ exception ) , $ lead ) ; } $ event = new MauticEnhancerEvent ( $ this , $ lead , $ this -> getCampaign ( ) ) ; $ this -> dispatcher -> dispatch ( MauticEnhancerEvents :: ENHANCER_COMPLETED , $ event ) ; 
public function makeRequest ( $ url , $ parameters = [ ] , $ method = 'GET' , $ settings = [ ] ) { 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { try { $ model = $ this -> getContainer ( ) -> get ( 'mautic.enhancer.model.citystatepostalcode' ) ; if ( $ model -> updateReferenceTable ( ) ) { $ output -> writeln ( 'Reference data successfully loaded. CityStateFromPostalCode is ready for use.' ) ; return true ; } } catch ( \ Exception $ e ) { $ output -> write ( 'CityStatePostalCode: ' . $ e -> getMessage ( ) ) ; } $ output -> writeln ( 'Failed to load reference table. CityStateFromPostalCode is not ready.' ) ; return false ; } 
public function doAutoRunEnhancements ( LeadEvent $ event ) { $ lead = $ event -> getLead ( ) ; if ( $ lead && ( null !== $ lead -> getDateIdentified ( ) || ! $ lead -> isAnonymous ( ) ) ) { 
public function doPostSaveEnhancements ( LeadEvent $ event ) { $ integrations = $ this -> enhancerHelper -> getEnhancerIntegrations ( ) ; foreach ( $ integrations as $ integration ) { if ( $ integration -> isConfigured ( ) && $ integration -> getIntegrationSettings ( ) -> getIsPublished ( ) ) { $ keys = $ integration -> getKeys ( ) ; if ( $ keys [ 'autorun_enabled' ] ) { try { $ lead = $ event -> getLead ( ) ; $ integration -> doEnhancement ( $ lead ) ; } catch ( \ Exception $ exception ) { $ e = new ApiErrorException ( 'There was an issue using enhancer: ' . $ integration -> getName ( ) , 0 , $ exception ) ; if ( ! empty ( $ lead ) ) { $ e -> setContact ( $ lead ) ; } throw $ e ; } } } } } 
public function doEnhancement ( Lead $ lead ) { $ persist = false ; $ leadCity = $ lead -> getCity ( ) ; $ leadState = $ lead -> getState ( ) ; $ leadCounty = $ lead -> getFieldValue ( 'county' ) ; 
private function countryNameToISO3166 ( $ countryName ) { foreach ( explode ( ',' , self :: COUNTRIES ) as $ countryCode ) { $ generatedCountryName = \ Locale :: getDisplayRegion ( '-' . $ countryCode , 'EN' ) ; if ( 0 === strcasecmp ( $ countryName , $ generatedCountryName ) ) { return $ countryCode ; break ; } } return '' ; } 
public function doEnhancement ( Lead $ lead ) { $ didEnhnacement = false ; if ( ! empty ( $ lead ) ) { $ ipAddresses = $ lead -> getIpAddresses ( ) -> getKeys ( ) ; if ( count ( $ ipAddresses ) ) { $ ipAddress = array_pop ( $ ipAddresses ) ; $ utmTags = $ lead -> getUtmTags ( ) ; if ( count ( $ utmTags ) ) { $ utmTag = array_pop ( $ utmTags ) ; $ userAgent = $ utmTag -> getUserAgent ( ) ; } else { $ settings = $ this -> getIntegrationSettings ( ) -> getFeatureSettings ( ) ; $ userAgent = $ settings [ 'default_user_agent' ] ; } $ result = $ this -> getModel ( ) -> getResult ( $ ipAddress , $ userAgent ) ; $ lead -> addUpdatedField ( 'anura_result' , $ result ) ; $ didEnhnacement = true ; } } return $ didEnhnacement ; } 
public function getRecord ( $ phone , $ ageMinutes , $ cacheOnly = false ) { $ record = $ this -> getRepository ( ) -> findByPhone ( $ phone ) ; if ( null === $ record || $ record -> getDateAdded ( ) -> getTimestamp ( ) > ( time ( ) - ( $ ageMinutes * 60 ) ) ) { 
public function buildEnhancerFields ( PluginIntegrationEvent $ event ) { $ integration = $ event -> getIntegration ( ) ; if ( in_array ( $ integration -> getName ( ) , EnhancerHelper :: IntegrationNames ( ) ) ) { $ integration -> buildEnhancerFields ( ) ; } } 
public function getGender ( $ name ) { if ( $ record = $ this -> getRepository ( ) -> findOneBy ( [ 'name' => strtoupper ( $ name ) ] ) ) { return $ record -> getGender ( ) ; } else { $ gender = null ; try { $ url = 'https://api.genderize.io/?name=' . urlencode ( $ name ) ; $ ch = curl_init ( $ url ) ; $ curlOptions = [ CURLOPT_RETURNTRANSFER => 1 , CURLOPT_CONNECTTIMEOUT => 1 , CURLOPT_TIMEOUT => 30 , ] ; curl_setopt_array ( $ ch , $ curlOptions ) ; $ result = curl_exec ( $ ch ) ; if ( false !== $ result ) { $ result = json_decode ( $ result , true ) ; if ( isset ( $ result [ 'gender' ] ) ) { $ gender = 'female' === $ result [ 'gender' ] ? 'F' : 'M' ; 
public function doEnhancement ( Lead $ lead ) { $ result = false ; $ leadAddress1 = $ lead -> getAddress1 ( ) ; $ leadAddress2 = $ lead -> getAddress2 ( ) ; $ leadZipCode = $ lead -> getZipcode ( ) ; $ combined = trim ( $ leadAddress1 ) . '|' . trim ( $ leadAddress2 ) . '|' . trim ( $ leadZipCode ) ; $ leadCorrected = $ lead -> getFieldValue ( 'address_valid' ) ; if ( strlen ( $ combined ) < 6 ) { $ this -> getLogger ( ) -> debug ( 'Correct Address: Not enough address data to enhance contact ' . $ lead -> getId ( ) ) ; 
protected function callCorrectA ( $ addressData ) { $ return = false ; $ settings = $ this -> getIntegrationSettings ( ) -> getFeatureSettings ( ) ; if ( ! file_exists ( $ settings [ self :: CA_CORRECTA_CMD ] ) ) { $ this -> getLogger ( ) -> error ( 'Correct Address: Could not find executable ' . $ settings [ self :: CA_CORRECTA_CMD ] ) ; } else { $ pipes = [ ] ; $ process = proc_open ( $ settings [ self :: CA_CORRECTA_CMD ] , [ [ 'pipe' , 'r' ] , 
protected function getServiceIdData ( Lead $ lead , $ serviceId = '875' ) { $ xmlDoc = new \ DOMDocument ( '1.0' ) ; $ xmlDoc -> preserveWhiteSpace = false ; $ root = $ xmlDoc -> createElement ( 'Contact' ) ; $ name = $ xmlDoc -> createElement ( 'Name' ) ; $ name -> setAttribute ( 'type' , 'C' ) ; $ name -> appendChild ( $ xmlDoc -> createElement ( 'First' , $ lead -> getFirstname ( ) ) ) ; $ name -> appendChild ( $ xmlDoc -> createElement ( 'Last' , $ lead -> getLastname ( ) ) ) ; $ names = $ xmlDoc -> createElement ( 'Names' ) ; $ names -> appendChild ( $ name ) ; $ root -> appendChild ( $ names ) ; if ( $ lead -> getAddress1 ( ) ) { $ address = $ xmlDoc -> createElement ( 'Address' ) ; $ address -> setAttribute ( 'score' , '1' ) ; $ address -> appendChild ( $ xmlDoc -> createElement ( 'Street' , $ lead -> getAddress1 ( ) ) ) ; $ address -> appendChild ( $ xmlDoc -> createElement ( 'City' , $ lead -> getCity ( ) ) ) ; $ address -> appendChild ( $ xmlDoc -> createElement ( 'ST' , $ lead -> getState ( ) ) ) ; $ address -> appendChild ( $ xmlDoc -> createElement ( 'postal' , $ lead -> getZipcode ( ) ) ) ; $ addresses = $ xmlDoc -> createElement ( 'Addresses' ) ; $ addresses -> appendChild ( $ address ) ; $ root -> appendChild ( $ addresses ) ; } $ phone = preg_replace ( '/\D+/' , '' , $ lead -> getPhone ( ) ) ; if ( empty ( $ phone ) ) { $ phone = preg_replace ( '/\D+/' , '' , $ lead -> getMobile ( ) ) ; } $ phone = substr ( $ phone , - 10 ) ; if ( 10 === strlen ( $ phone ) ) { $ phone = $ xmlDoc -> createElement ( 'Phone' , $ phone ) ; $ phone -> setAttribute ( 'score' , '1' ) ; $ phone -> setAttribute ( 'appends' , 'validation,mobile,active' ) ; $ phones = $ xmlDoc -> createElement ( 'Phones' ) ; $ phones -> appendChild ( $ phone ) ; $ root -> appendChild ( $ phones ) ; } if ( $ lead -> getEmail ( ) ) { $ email = $ xmlDoc -> createElement ( 'eMail' , $ lead -> getEmail ( ) ) ; $ email -> setAttribute ( 'score' , '1' ) ; $ emails = $ xmlDoc -> createElement ( 'eMailAddresses' ) ; $ emails -> appendChild ( $ email ) ; $ root -> appendChild ( $ emails ) ; } $ xmlDoc -> appendChild ( $ root ) ; return $ xmlDoc -> saveXML ( ) ; } 
public function updateReferenceTable ( CityStatePostalCodeModel $ model ) { if ( false !== ( $ fp = $ model -> fetchAllCountriesZip ( ) ) ) { $ this -> emptyReferenceTable ( ) ; $ this -> createReferenceTable ( ) ; $ em = $ this -> getEntityManager ( ) ; $ batchSize = 500 ; $ count = 0 ; while ( ! feof ( $ fp ) ) { $ data = explode ( "\t" , trim ( fgets ( $ fp ) ) ) ; list ( $ country , $ postalCode , $ city , $ stateProvince , $ state , $ county , $ a , $ b , $ c , $ latitude , $ longitude ) = array_slice ( $ data , 0 , 11 ) ; if ( ! $ country || ! $ postalCode ) { continue ; } $ record = new PluginEnhancerCityStatePostalCode ( ) ; $ record -> setCountry ( $ country ) -> setPostalCode ( $ postalCode ) -> setCity ( $ city ) -> setStateProvince ( $ stateProvince ) -> setCounty ( $ county ) -> setLatitude ( $ latitude ) -> setLongitude ( $ longitude ) ; $ em -> persist ( $ record ) ; ++ $ count ; if ( 0 === ( $ count % $ batchSize ) ) { $ em -> flush ( ) ; $ em -> clear ( ) ; } } $ em -> flush ( ) ; $ em -> clear ( ) ; } } 
public function doEnhancement ( Lead $ lead ) { $ gender = $ lead -> getFieldValue ( 'gender' ) ; if ( ! $ gender or $ this -> isPush ) { try { $ oldGender = $ gender ; $ gender = $ this -> getIntegrationModel ( ) -> getGender ( $ lead -> getFirstname ( ) ) ; } catch ( \ Exception $ e ) { return false ; } if ( $ gender ) { $ lead -> addUpdatedField ( 'gender' , $ gender , $ oldGender ) ; return true ; } } return false ; } 
public function doEnhancement ( Lead $ lead ) { if ( ! empty ( $ lead ) ) { if ( $ lead -> getFieldValue ( 'alcazar_lrn' ) || ! $ lead -> getPhone ( ) ) { return false ; } $ phone = $ lead -> getPhone ( ) ; $ phone = preg_replace ( '/[^0-9]/' , '' , $ phone ) ; if ( 10 === strlen ( $ phone ) ) { $ phone = '1' . $ phone ; } if ( 11 !== strlen ( $ phone ) ) { return false ; } $ keys = $ this -> getKeys ( ) ; $ params = [ 'key' => $ keys [ 'apikey' ] , 'tn' => $ phone , ] ; $ features = $ this -> getIntegrationSettings ( ) -> getFeatureSettings ( ) ; foreach ( $ features as $ param => $ value ) { if ( 'ani' === $ param ) { 
public function doEnhancement ( Lead $ lead ) { $ persist = false ; if ( ! empty ( $ lead ) ) { $ algo = $ lead -> getFieldValue ( 'fourleaf_algo' ) ; $ email = $ lead -> getEmail ( ) ; if ( $ algo || ! $ email ) { return false ; } $ keys = $ this -> getKeys ( ) ; 
public function doEnhancement ( Lead $ lead ) { $ persist = false ; if ( ! empty ( $ lead ) ) { $ settings = $ this -> getIntegrationSettings ( ) -> getFeatureSettings ( ) ; $ originalConsentUrlField = $ settings [ 'original_consent_url' ] ; $ existingCleanValue = $ lead -> getFieldValue ( 'consent_url_clean' ) ; try { $ fieldValue = $ lead -> getFieldValue ( $ originalConsentUrlField ) ; if ( ! empty ( $ fieldValue ) ) { 
public static function getContent ( $ image ) { switch ( true ) { case self :: isUrl ( $ image ) : return self :: getOnlineImageContent ( $ image ) ; case self :: isImage ( $ image ) : return file_get_contents ( $ image ) ; case self :: isResource ( $ image ) : return stream_get_contents ( $ image ) ; case self :: isSplFileInfo ( $ image ) : return file_get_contents ( $ image -> getRealPath ( ) ) ; case self :: isString ( $ image ) : 
public static function isImage ( $ file ) { try { $ level = error_reporting ( E_ERROR | E_PARSE ) ; $ isImage = self :: isFile ( $ file ) && getimagesize ( $ file ) !== false ; error_reporting ( $ level ) ; return $ isImage ; } catch ( Exception $ e ) { return false ; } } 
public function setHeaders ( array $ headers = [ ] ) { $ originHeaders = empty ( $ this -> headers ) ? [ ] : $ this -> headers ; $ this -> headers = array_merge ( $ originHeaders , $ headers ) ; return $ this ; } 
public function post ( $ url , $ params = [ ] ) { $ key = is_array ( $ params ) ? 'form_params' : 'body' ; return $ this -> request ( 'POST' , $ url , [ $ key => $ params ] ) ; } 
public function upload ( $ url , array $ files = [ ] , array $ params = [ ] , array $ queries = [ ] ) { $ multipart = [ ] ; foreach ( $ files as $ name => $ file ) { $ paths = is_array ( $ file ) ? $ file : [ $ file ] ; foreach ( $ paths as $ path ) { $ multipart [ ] = [ 'name' => $ name , 'contents' => FileConverter :: getContent ( $ path ) ] ; } } foreach ( $ params as $ name => $ contents ) { $ multipart [ ] = compact ( 'name' , 'contents' ) ; } return $ this -> request ( 'POST' , $ url , [ 'multipart' => $ multipart , 'query' => $ queries ] ) ; } 
public function request ( $ method , $ url , $ options = [ ] ) { $ method = strtoupper ( $ method ) ; $ options = array_merge ( self :: $ defaults , [ 'headers' => $ this -> headers ] , $ options ) ; return $ this -> getClient ( ) -> request ( $ method , $ url , $ options ) ; } 
public function json ( $ url , $ options = [ ] , $ encodeOption = JSON_UNESCAPED_UNICODE , $ queries = [ ] ) { is_array ( $ options ) && $ options = json_encode ( $ options , $ encodeOption ) ; return $ this -> setHeaders ( [ 'content-type' => 'application/json' ] ) -> request ( 'POST' , $ url , [ 'query' => $ queries , 'body' => $ options ] ) ; } 
public function getClient ( ) { if ( empty ( $ this -> client ) || ! ( $ this -> client instanceof HttpClient ) ) { $ this -> client = new HttpClient ( ) ; } return $ this -> client ; } 
public function parseJson ( $ body ) { if ( $ body instanceof ResponseInterface ) { $ body = $ body -> getBody ( ) ; } if ( $ body instanceof StreamInterface ) { $ body = $ body -> getContents ( ) ; } if ( empty ( $ body ) ) { return false ; } $ contents = json_decode ( $ body , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new Exception ( 'Failed to parse JSON: ' . json_last_error_msg ( ) ) ; } return $ contents ; } 
public function appendSignature ( array $ params = [ ] , $ timestamp = '' , $ noncestr = '' ) { $ params += [ 'app_id' => $ this -> appId , 'time_stamp' => $ timestamp ? : time ( ) , 'nonce_str' => $ noncestr ? : md5 ( uniqid ( ) ) ] ; if ( isset ( $ params [ 'app_key' ] ) ) { unset ( $ params [ 'app_key' ] ) ; } ksort ( $ params ) ; $ params [ 'sign' ] = strtoupper ( md5 ( http_build_query ( $ params + [ 'app_key' => $ this -> appKey ] ) ) ) ; return $ params ; } 
public function idcard ( $ image , array $ options = [ ] ) { if ( ! isset ( $ options [ 'card_type' ] ) || ! in_array ( $ options [ 'card_type' ] , [ 0 , 1 ] , true ) ) { $ options [ 'card_type' ] = 0 ; } return $ this -> request ( self :: URL_OCR_IDCARD , $ image , $ options ) ; } 
public function driverlicen ( $ image , array $ options = [ ] ) { if ( ! isset ( $ options [ 'type' ] ) || ! in_array ( $ options [ 'type' ] , [ 0 , 1 ] , true ) ) { $ options [ 'type' ] = 0 ; } return $ this -> request ( self :: URL_OCR_DRIVERLICEN , $ image , $ options ) ; } 
protected function request ( $ url , $ image , array $ options = [ ] ) { try { $ image = is_array ( $ image ) ? $ image [ 0 ] : $ image ; $ params = array_merge ( $ options , [ 'image' => FileConverter :: toBase64Encode ( $ image ) ] ) ; $ params = $ this -> authorization -> appendSignature ( $ params ) ; $ http = new HTTP ( ) ; $ response = $ http -> setHeaders ( [ 'Content-Type' => 'application/x-www-form-urlencoded' ] ) -> request ( 'POST' , $ url , [ 'form_params' => $ params ] ) ; } catch ( ClientException $ ce ) { $ response = $ response -> getBody ( ) ; } return $ http -> parseJson ( $ response ) ; } 
public function idcard ( $ images , array $ options = [ ] ) { $ options [ 'side' ] = empty ( $ options [ 'side' ] ) ? 'face' : $ options [ 'side' ] ; return $ this -> request ( self :: OCR_IDCARD , $ images , $ options ) ; } 
public function driverLicense ( $ images , array $ options = [ ] ) { $ options [ 'side' ] = empty ( $ options [ 'side' ] ) ? 'face' : $ options [ 'side' ] ; return $ this -> request ( self :: OCR_DRIVER_LICENSE , $ images , $ options ) ; } 
public function trainTicket ( $ images , array $ options = [ ] ) { $ this -> simpleRequestBody = true ; return $ this -> request ( self :: OCR_TRAIN_TICKET , $ images , $ options ) ; } 
public function general ( $ images , array $ options = [ ] ) { $ this -> simpleRequestBody = true ; return $ this -> request ( self :: OCR_GENERAL , $ images , $ options ) ; } 
public function request ( $ url , $ images , array $ options = [ ] ) { $ httpClient = ( new Http ) -> setHeaders ( $ this -> appcode -> getAppCodeHeader ( ) ) ; try { $ response = $ httpClient -> json ( $ url , $ this -> getFixedFormat ( $ images , $ options ) ) ; } catch ( \ GuzzleHttp \ Exception \ ClientException $ e ) { if ( $ e -> hasResponse ( ) ) { $ response = $ e -> getResponse ( ) ; } } 
public function getFixedFormat ( $ images , array $ options = [ ] ) { 
public function generalBasic ( $ images , array $ options = [ ] ) { $ this -> supportUrl = true ; return $ this -> request ( self :: GENERAL_BASIC , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function accurateBasic ( $ images , array $ options = [ ] ) { $ this -> supportUrl = false ; return $ this -> request ( self :: ACCURATE_BASIC , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function general ( $ images , array $ options = [ ] ) { $ this -> supportUrl = true ; return $ this -> request ( self :: GENERAL , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function accurate ( $ images , array $ options = [ ] ) { $ this -> supportUrl = false ; return $ this -> request ( self :: ACCURATE , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function generalEnhanced ( $ images , array $ options = [ ] ) { $ this -> supportUrl = true ; return $ this -> request ( self :: GENERAL_ENHANCED , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function webimage ( $ images , array $ options = [ ] ) { $ this -> supportUrl = true ; return $ this -> request ( self :: WEBIMAGE , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function idcard ( $ images , array $ options = [ ] ) { $ this -> supportUrl = false ; return $ this -> request ( self :: IDCARD , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function bankcard ( $ images , array $ options = [ ] ) { $ this -> supportUrl = false ; return $ this -> request ( self :: BANKCARD , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function drivingLicense ( $ images , array $ options = [ ] ) { $ this -> supportUrl = false ; return $ this -> request ( self :: DRIVING_LICENSE , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function vehicleLicense ( $ images , array $ options = [ ] ) { $ this -> supportUrl = false ; return $ this -> request ( self :: VEHICLE_LICENSE , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function licensePlate ( $ images , array $ options = [ ] ) { $ this -> supportUrl = false ; return $ this -> request ( self :: LICENSE_PLATE , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function businessLicense ( $ images , array $ options = [ ] ) { $ this -> supportUrl = false ; return $ this -> request ( self :: BUSINESS_LICENSE , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
public function receipt ( $ images , array $ options = [ ] ) { $ this -> supportUrl = false ; return $ this -> request ( self :: RECEIPT , $ this -> buildRequestParam ( $ images , $ options ) ) ; } 
protected function request ( $ url , array $ options = [ ] ) { $ httpClient = new Http ; try { $ response = $ httpClient -> request ( 'POST' , $ url , [ 'form_params' => $ options , 'query' => [ $ this -> accessToken -> getQueryName ( ) => $ this -> accessToken -> getAccessToken ( true ) ] ] ) ; } catch ( \ GuzzleHttp \ Exception \ ClientException $ e ) { if ( $ e -> hasResponse ( ) ) { $ response = $ e -> getResponse ( ) ; } else { throw $ e ; } } return $ httpClient -> parseJson ( $ response ) ; } 
protected function buildRequestParam ( $ images , $ options = [ ] ) { 
public function register ( Container $ pimple ) { $ pimple [ 'tencentai.auth' ] = function ( $ app ) { return new Authorization ( $ app [ 'config' ] -> get ( 'ocrs.tencentai.app_id' ) , $ app [ 'config' ] -> get ( 'ocrs.tencentai.app_key' ) ) ; } ; $ pimple [ 'tencentai' ] = function ( $ app ) { return new OCRManager ( $ app [ 'tencentai.auth' ] ) ; } ; } 
protected function registerProviders ( ) { foreach ( array_merge ( $ this -> providers , $ this [ 'config' ] -> get ( 'providers' , [ ] ) ) as $ provider ) { $ this -> register ( new $ provider ) ; } } 
protected function signature ( ) { $ signatureKey = $ this -> buildSignatureKey ( ) ; $ sing = hash_hmac ( 'SHA1' , $ signatureKey , $ this -> secretKey , true ) ; return base64_encode ( $ sing . $ signatureKey ) ; } 
protected function buildSignatureKey ( ) { $ signatures = [ 'a' => $ this -> appId , 'b' => $ this -> bucket , 'k' => $ this -> secretId , 'e' => time ( ) + 2592000 , 't' => time ( ) , 'r' => rand ( ) , 'u' => '0' , 'f' => '' ] ; return http_build_query ( $ signatures ) ; } 
public function getAccessToken ( $ forceRefresh = false ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ cached = $ this -> getCache ( ) -> fetch ( $ cacheKey ) ; if ( empty ( $ cached ) || $ forceRefresh ) { $ token = $ this -> getTokenFormApi ( ) ; $ this -> getCache ( ) -> save ( $ cacheKey , $ token [ $ this -> tokenSucessKey ] , $ token [ 'expires_in' ] ) ; return $ token [ $ this -> tokenSucessKey ] ; } return $ cached ; } 
protected function getTokenFormApi ( ) { $ http = $ this -> getHttp ( ) ; $ token = $ http -> parseJson ( $ http -> post ( self :: API_TOKEN_URI , [ 'grant_type' => 'client_credentials' , 'client_id' => $ this -> getAppKey ( ) , 'client_secret' => $ this -> getSecretKey ( ) ] ) ) ; if ( empty ( $ token [ $ this -> tokenSucessKey ] ) ) { throw new RuntimeException ( 'Request AccessToken fail. response: ' . json_encode ( $ token , JSON_UNESCAPED_UNICODE ) ) ; } return $ token ; } 
public function getCacheKey ( ) { if ( is_null ( $ this -> cacheKey ) ) { return $ this -> prefix . $ this -> appKey ; } return $ this -> cacheKey ; } 
public function namecard ( $ images , array $ options = [ ] ) { return $ this -> request ( self :: OCR_NAMECARD , $ images , $ options , true ) ; } 
public function idcard ( $ images , array $ options = [ ] ) { return $ this -> request ( self :: OCR_IDCARD , $ images , $ options , true ) ; } 
public function drivingLicence ( $ images , array $ options = [ ] ) { $ options [ 'type' ] = isset ( $ options [ 'type' ] ) ? $ options [ 'type' ] : 0 ; return $ this -> request ( self :: OCR_DRIVINGLICENCE , $ images , $ options ) ; } 
protected function appendAppIdAndBucketIfEmpty ( array $ options = [ ] ) { $ options [ 'appid' ] = empty ( $ options [ 'appid' ] ) ? $ this -> authorization -> getAppId ( ) : $ options [ 'appid' ] ; $ options [ 'bucket' ] = empty ( $ options [ 'bucket' ] ) ? $ this -> authorization -> getBucket ( ) : $ options [ 'bucket' ] ; return $ options ; } 
protected function request ( $ url , $ images , array $ options = [ ] , $ requestType = false ) { $ http = ( new Http ) -> setHeaders ( [ 'Authorization' => $ this -> authorization -> getAuthorization ( ) ] ) ; 
public function register ( Container $ pimple ) { $ pimple [ 'baidu.auth' ] = function ( $ app ) { return new AccessToken ( $ app [ 'config' ] -> get ( 'ocrs.baidu.app_key' ) , $ app [ 'config' ] -> get ( 'ocrs.baidu.secret_key' ) , $ app [ 'cache' ] ) ; } ; $ pimple [ 'baidu' ] = function ( $ app ) { return new OCRManager ( $ app [ 'baidu.auth' ] ) ; } ; } 
public function register ( Container $ pimple ) { $ pimple [ 'aliyun.auth' ] = function ( $ app ) { return new AppCode ( $ app [ 'config' ] -> get ( 'ocrs.aliyun.appcode' ) ) ; } ; $ pimple [ 'aliyun' ] = function ( $ app ) { return new OCRManager ( $ app [ 'aliyun.auth' ] ) ; } ; } 
public function set ( $ key , $ value ) { Arr :: set ( $ this -> configs , $ key , $ value ) ; return $ this ; } 
protected function initFromSpecString ( $ specString ) { $ pattern = '/ ( (?:[a-zA-Z0-9-]+) (?: \| (?:[a-zA-Z0-9-]+) )? ) # option attribute operators ([:+?])? # value types (?:=(boolean|string|number|date|file|dir|url|email|ip|ipv6|ipv4))? /x' ; $ ret = preg_match ( $ pattern , $ specString , $ regs ) ; if ( $ ret === false || $ ret === 0 ) { throw new Exception ( 'Incorrect spec string' ) ; } $ orig = $ regs [ 0 ] ; $ name = $ regs [ 1 ] ; $ attributes = isset ( $ regs [ 2 ] ) ? $ regs [ 2 ] : null ; $ type = isset ( $ regs [ 3 ] ) ? $ regs [ 3 ] : null ; $ short = null ; $ long = null ; 
public function pushValue ( $ value ) { $ value = $ this -> _preprocessValue ( $ value ) ; $ this -> value [ ] = $ value ; $ this -> callTrigger ( ) ; } 
public function renderReadableSpec ( $ renderHint = true ) { $ c1 = '' ; if ( $ this -> short && $ this -> long ) { $ c1 = sprintf ( '-%s, --%s' , $ this -> short , $ this -> long ) ; } else if ( $ this -> short ) { $ c1 = sprintf ( '-%s' , $ this -> short ) ; } else if ( $ this -> long ) { $ c1 = sprintf ( '--%s' , $ this -> long ) ; } if ( $ renderHint ) { return $ c1 . $ this -> renderValueHint ( ) ; } return $ c1 ; } 
public function isa ( $ type , $ option = null ) { 
public function getValidValues ( ) { if ( $ this -> validValues ) { if ( is_callable ( $ this -> validValues ) ) { return call_user_func ( $ this -> validValues ) ; } return $ this -> validValues ; } return ; } 
public function getSuggestions ( ) { if ( $ this -> suggestions ) { if ( is_callable ( $ this -> suggestions ) ) { return call_user_func ( $ this -> suggestions ) ; } return $ this -> suggestions ; } return ; } 
public function anyOfOptions ( OptionCollection $ options ) { $ name = $ this -> getOptionName ( ) ; $ keys = $ options -> keys ( ) ; return in_array ( $ name , $ keys ) ; } 
public function add ( ) { $ num = func_num_args ( ) ; $ args = func_get_args ( ) ; $ first = $ args [ 0 ] ; if ( $ first instanceof Option ) { $ this -> addOption ( $ first ) ; } else if ( is_string ( $ first ) ) { $ specString = $ args [ 0 ] ; $ desc = isset ( $ args [ 1 ] ) ? $ args [ 1 ] : null ; $ key = isset ( $ args [ 2 ] ) ? $ args [ 2 ] : null ; 
public function get ( $ id ) { if ( isset ( $ this -> data [ $ id ] ) ) { return $ this -> data [ $ id ] ; } else if ( isset ( $ this -> longOptions [ $ id ] ) ) { return $ this -> longOptions [ $ id ] ; } else if ( isset ( $ this -> shortOptions [ $ id ] ) ) { return $ this -> shortOptions [ $ id ] ; } } 
protected function consumeOptionToken ( Option $ spec , $ arg , $ next , & $ success = false ) { 
protected function pushOptionValue ( Option $ spec , $ arg , $ next ) { if ( $ next && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> pushValue ( $ next -> arg ) ; } } 
public function parse ( array $ argv ) { $ result = new OptionResult ( ) ; list ( $ argv , $ extra ) = $ this -> preprocessingArguments ( $ argv ) ; $ len = count ( $ argv ) ; 
public function advance ( ) { if ( $ this -> index >= $ this -> length ) { throw new LogicException ( "Argument index out of bounds." ) ; } return $ this -> argv [ $ this -> index ++ ] ; } 
public function renderOption ( Option $ opt ) { $ c1 = '' ; if ( $ opt -> short && $ opt -> long ) { $ c1 = sprintf ( '-%s, --%s' , $ opt -> short , $ opt -> long ) ; } else if ( $ opt -> short ) { $ c1 = sprintf ( '-%s' , $ opt -> short ) ; } else if ( $ opt -> long ) { $ c1 = sprintf ( '--%s' , $ opt -> long ) ; } $ c1 .= $ opt -> renderValueHint ( ) ; return $ c1 ; } 
public function render ( OptionCollection $ options ) { # echo "* Available options:\n"; $ lines = array ( ) ; foreach ( $ options as $ option ) { $ c1 = $ this -> renderOption ( $ option ) ; $ lines [ ] = "\t" . $ c1 ; $ lines [ ] = wordwrap ( "\t\t" . $ option -> desc , $ this -> screenWidth , "\n\t\t" ) ; # wrap text $ lines [ ] = '' ; } return implode ( "\n" , $ lines ) ; } 
public function generate ( Payment $ payment ) { $ paymentMethodIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ payment -> getPaymentMethodIdentifier ( ) , 'objectType' => PaymentMethod :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ paymentMethodIdentity ) { throw new NotFoundException ( 'payment method not mapped' ) ; } $ currencyIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ payment -> getCurrencyIdentifier ( ) , 'objectType' => Currency :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ currencyIdentity ) { throw new NotFoundException ( 'currency not mapped' ) ; } $ paymentParams = [ 'amount' => $ payment -> getAmount ( ) , 'exchangeRatio' => 1 , 'mopId' => $ paymentMethodIdentity -> getAdapterIdentifier ( ) , 'currency' => $ currencyIdentity -> getAdapterIdentifier ( ) , 'type' => 'credit' , 'transactionType' => 2 , 'status' => 2 , ] ; $ paymentParams [ 'properties' ] = [ [ 'typeId' => 23 , 'value' => 4 , ] , [ 'typeId' => 11 , 'value' => $ payment -> getAccountHolder ( ) , ] , [ 'typeId' => 1 , 'value' => $ payment -> getTransactionReference ( ) , ] , [ 'typeId' => 3 , 'value' => $ payment -> getTransactionReference ( ) , ] , ] ; return $ paymentParams ; } 
public function generate ( Payment $ payment ) { $ paymentParams = $ this -> parentRequestGenerator -> generate ( $ payment ) ; $ data = $ payment -> getPaymentData ( ) ; if ( ! ( $ data instanceof PayPalInstallmentPaymentData ) ) { return $ paymentParams ; } $ paymentParams [ 'properties' ] [ ] = [ 'typeId' => 22 , 'value' => json_encode ( [ 'currency' => $ data -> getCurrency ( ) , 'financingCosts' => $ data -> getFinancingCosts ( ) , 'totalCostsIncludeFinancing' => $ data -> getTotalCostsIncludeFinancing ( ) , ] ) , ] ; return $ paymentParams ; } 
public function generate ( Payment $ payment ) { $ paymentParams = $ this -> parentRequestGenerator -> generate ( $ payment ) ; $ data = $ payment -> getPaymentData ( ) ; if ( ! ( $ data instanceof PayPalPlusInvoicePaymentData ) ) { return $ paymentParams ; } $ paymentParams [ 'properties' ] [ ] = [ 'typeId' => 22 , 'value' => json_encode ( [ 'accountHolder' => $ data -> getAccountHolderName ( ) , 'bankName' => $ data -> getBankName ( ) , 'bic' => $ data -> getBankIdentifierCode ( ) , 'iban' => $ data -> getInternationalBankAccountNumber ( ) , 'paymentDue' => $ data -> getPaymentDueDate ( ) -> format ( DATE_W3C ) , 'referenceNumber' => $ data -> getReferenceNumber ( ) , ] ) , ] ; return $ paymentParams ; } 
public function findBy ( array $ criteria ) { $ params = array_merge ( $ criteria , [ 'with' => implode ( ',' , self :: $ includes ) , ] ) ; return iterator_to_array ( $ this -> client -> getIterator ( 'items/variations' , $ params ) ) ; } 
private function getTranslation ( $ snippet ) { $ snippetManager = $ this -> container -> get ( 'snippets' ) ; $ namespace = 'backend/plentyconnector/main' ; return $ snippetManager -> getNamespace ( $ namespace ) -> get ( $ snippet ) ; } 
private function getAttributeKey ( Attribute $ attribute ) { $ key = iconv ( 'UTF-8' , 'ASCII//TRANSLIT' , $ attribute -> getKey ( ) ) ; $ attribute_key = strtolower ( preg_replace ( '/[A-Z]/' , '_\\0' , lcfirst ( $ key ) ) ) ; return $ this -> prefix . $ attribute_key ; } 
private function getAttributesAsArray ( array $ attributes = [ ] ) { $ result = [ ] ; foreach ( $ attributes as $ attribute ) { $ key = $ this -> getAttributeKey ( $ attribute ) ; $ result [ $ key ] = $ attribute -> getValue ( ) ; } return $ result ; } 
public function parse ( array $ entry ) { if ( ! $ this -> isValidOrder ( $ entry ) ) { return [ ] ; } $ taxFree = $ entry [ 'taxFree' ] || $ entry [ 'net' ] ; $ orderItems = array_filter ( array_map ( function ( array $ orderItem ) use ( $ taxFree ) { return $ this -> orderItemResponseParser -> parse ( $ orderItem , $ taxFree ) ; } , $ entry [ 'details' ] ) ) ; $ orderItems [ ] = $ this -> getShippingCosts ( $ entry ) ; $ billingAddress = $ this -> orderAddressParser -> parse ( $ entry [ 'billing' ] ) ; $ shippingAddress = $ this -> orderAddressParser -> parse ( $ entry [ 'shipping' ] ) ; if ( null === $ billingAddress || null === $ shippingAddress ) { $ this -> logger -> warning ( 'could not parse address, order: ' . $ entry [ 'number' ] ) ; return [ ] ; } if ( null === $ entry [ 'customer' ] ) { $ this -> logger -> warning ( 'could not find customer, order: ' . $ entry [ 'number' ] ) ; return [ ] ; } $ customer = $ this -> customerParser -> parse ( $ entry [ 'customer' ] ) ; if ( null === $ customer ) { $ this -> logger -> warning ( 'could not parse customer, order: ' . $ entry [ 'number' ] ) ; return [ ] ; } $ customer -> setMobilePhoneNumber ( $ billingAddress -> getMobilePhoneNumber ( ) ) ; $ customer -> setPhoneNumber ( $ billingAddress -> getPhoneNumber ( ) ) ; $ orderStatusIdentifier = $ this -> getConnectorIdentifier ( $ entry [ 'orderStatusId' ] , OrderStatus :: TYPE ) ; $ paymentStatusIdentifier = $ this -> getConnectorIdentifier ( $ entry [ 'paymentStatusId' ] , PaymentStatus :: TYPE ) ; $ paymentMethodIdentifier = $ this -> getConnectorIdentifier ( $ entry [ 'paymentId' ] , PaymentMethod :: TYPE ) ; $ shippingProfileIdentifier = $ this -> getConnectorIdentifier ( $ entry [ 'dispatchId' ] , ShippingProfile :: TYPE ) ; $ shopIdentifier = $ this -> getConnectorIdentifier ( $ entry [ 'languageSubShop' ] [ 'id' ] , Shop :: TYPE ) ; $ shopwareCurrencyIdentifier = $ this -> currencyDataProvider -> getCurrencyIdentifierByCode ( $ entry [ 'currency' ] ) ; $ currencyIdentifier = $ this -> getConnectorIdentifier ( $ shopwareCurrencyIdentifier , Currency :: TYPE ) ; $ orderIdentity = $ this -> identityService -> findOneOrCreate ( ( string ) $ entry [ 'id' ] , ShopwareAdapter :: NAME , Order :: TYPE ) ; $ isMappedOrderIdentity = $ this -> identityService -> isMappedIdentity ( $ orderIdentity -> getObjectIdentifier ( ) , $ orderIdentity -> getObjectType ( ) , $ orderIdentity -> getAdapterName ( ) ) ; if ( $ isMappedOrderIdentity ) { return [ ] ; } $ order = new Order ( ) ; $ order -> setIdentifier ( $ orderIdentity -> getObjectIdentifier ( ) ) ; $ order -> setOrderNumber ( $ entry [ 'number' ] ) ; $ order -> setOrderItems ( $ orderItems ) ; $ order -> setAttributes ( $ this -> getAttributes ( $ entry [ 'attribute' ] ) ) ; $ order -> setBillingAddress ( $ billingAddress ) ; $ order -> setShippingAddress ( $ shippingAddress ) ; $ order -> setComments ( $ this -> getComments ( $ entry ) ) ; $ order -> setCustomer ( $ customer ) ; $ order -> setOrderTime ( DateTimeImmutable :: createFromMutable ( $ entry [ 'orderTime' ] ) ) ; $ order -> setOrderStatusIdentifier ( $ orderStatusIdentifier ) ; $ order -> setPaymentStatusIdentifier ( $ paymentStatusIdentifier ) ; $ order -> setPaymentMethodIdentifier ( $ paymentMethodIdentifier ) ; $ order -> setShippingProfileIdentifier ( $ shippingProfileIdentifier ) ; $ order -> setCurrencyIdentifier ( $ currencyIdentifier ) ; $ order -> setShopIdentifier ( $ shopIdentifier ) ; return [ $ order ] ; } 
private function isValidOrder ( array $ entry ) { $ shopIdentity = $ this -> identityService -> findOneOrThrow ( ( string ) $ entry [ 'languageSubShop' ] [ 'id' ] , ShopwareAdapter :: NAME , Shop :: TYPE ) ; $ isMappedIdentity = $ this -> identityService -> isMappedIdentity ( $ shopIdentity -> getObjectIdentifier ( ) , $ shopIdentity -> getObjectType ( ) , $ shopIdentity -> getAdapterName ( ) ) ; if ( ! $ isMappedIdentity ) { return false ; } if ( empty ( $ entry [ 'billing' ] ) ) { $ this -> logger -> warning ( 'empty order billing address - order: ' . $ entry [ 'number' ] ) ; return false ; } if ( empty ( $ entry [ 'details' ] ) ) { $ this -> logger -> warning ( 'empty order positions - order: ' . $ entry [ 'number' ] ) ; return false ; } if ( empty ( $ entry [ 'shipping' ] ) ) { $ this -> logger -> warning ( 'empty order shipping address - order: ' . $ entry [ 'number' ] ) ; return false ; } $ shippingProfileIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ entry [ 'dispatchId' ] , 'adapterName' => ShopwareAdapter :: NAME , 'objectType' => ShippingProfile :: TYPE , ] ) ; if ( null === $ shippingProfileIdentity ) { $ this -> logger -> warning ( 'no shipping profile was selected for order: ' . $ entry [ 'number' ] ) ; return false ; } return true ; } 
private function getComments ( $ entry ) { $ comments = [ ] ; if ( $ entry [ 'internalComment' ] ) { $ comment = new Comment ( ) ; $ comment -> setType ( Comment :: TYPE_INTERNAL ) ; $ comment -> setComment ( $ entry [ 'internalComment' ] ) ; $ comments [ ] = $ comment ; } if ( $ entry [ 'customerComment' ] ) { $ comment = new Comment ( ) ; $ comment -> setType ( Comment :: TYPE_CUSTOMER ) ; $ comment -> setComment ( $ entry [ 'customerComment' ] ) ; $ comments [ ] = $ comment ; } return $ comments ; } 
private function getShippingCostsVatRateIdentifier ( array $ entry ) { $ taxRateId = $ this -> getMaxTaxRateFromOrderItems ( $ entry ) ; $ taxModel = $ this -> taxRepository -> findOneBy ( [ 'tax' => $ taxRateId ] ) ; $ taxRateId = $ taxModel -> getId ( ) ; if ( isset ( $ entry [ 'dispatch' ] [ 'taxCalculation' ] ) && $ entry [ 'dispatch' ] [ 'taxCalculation' ] > 0 ) { $ taxRateId = $ entry [ 'dispatch' ] [ 'taxCalculation' ] ; } $ identity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ taxRateId , 'adapterName' => ShopwareAdapter :: NAME , 'objectType' => VatRate :: TYPE , ] ) ; if ( null === $ identity ) { throw new NotFoundException ( 'missing tax rate mapping - ' . $ taxRateId ) ; } return $ identity -> getObjectIdentifier ( ) ; } 
private function getShippingCosts ( array $ entry ) { $ shippingCosts = $ this -> getShippingAmount ( $ entry ) ; $ vatRateIdentifier = $ this -> getShippingCostsVatRateIdentifier ( $ entry ) ; $ orderItem = new OrderItem ( ) ; $ orderItem -> setType ( OrderItem :: TYPE_SHIPPING_COSTS ) ; $ orderItem -> setQuantity ( 1.0 ) ; $ orderItem -> setName ( 'ShippingCosts' ) ; $ orderItem -> setNumber ( 'ShippingCosts' ) ; $ orderItem -> setPrice ( $ shippingCosts ) ; $ orderItem -> setVatRateIdentifier ( $ vatRateIdentifier ) ; return $ orderItem ; } 
private function getShippingAmount ( array $ entry ) { $ isShippingBruttoAndNettoSame = 1 === $ entry [ 'taxFree' ] && $ entry [ 'taxFree' ] == $ entry [ 'net' ] ; if ( $ isShippingBruttoAndNettoSame ) { return $ entry [ 'invoiceShippingNet' ] + $ entry [ 'invoiceShippingNet' ] * $ this -> getMaxTaxRateFromOrderItems ( $ entry ) / 100 ; } return ( float ) $ entry [ 'invoiceShipping' ] ; } 
public function execute ( $ command , callable $ next ) { if ( ! ( $ command instanceof TransferObjectCommand ) ) { return $ next ( $ command ) ; } $ object = $ command -> getPayload ( ) ; $ this -> validator -> validate ( $ object ) ; return $ next ( $ command ) ; } 
public function find ( $ id ) { $ criteria = [ 'with' => self :: $ includes , ] ; return $ this -> client -> request ( 'GET' , 'orders/' . $ id , $ criteria ) ; } 
public function findAll ( array $ criteria = [ ] ) { $ criteria = array_merge ( $ criteria , [ 'with' => self :: $ includes , ] ) ; return $ this -> client -> getIterator ( 'orders' , $ criteria ) ; } 
public function findBy ( array $ criteria = [ ] ) { $ criteria = array_merge ( $ criteria , [ 'with' => self :: $ includes , ] ) ; return $ this -> client -> getIterator ( 'orders' , $ criteria ) ; } 
public function findOneBy ( array $ criteria = [ ] ) { $ result = iterator_to_array ( $ this -> findBy ( $ criteria ) ) ; if ( ! empty ( $ result ) ) { $ result = array_shift ( $ result ) ; } return $ result ; } 
public function toArray ( ) { return [ 'adapterName' => $ this -> adapterName , 'objectType' => $ this -> objectType , 'commandType' => $ this -> commandType , 'priority' => $ this -> priority , 'payload' => $ this -> payload , ] ; } 
public function handle ( CommandInterface $ command ) { $ bundle = $ command -> getPayload ( ) ; $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ bundle -> getIdentifier ( ) , 'objectType' => Bundle :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; $ this -> bundleHelper -> registerBundleModels ( ) ; $ repository = $ this -> entityManager -> getRepository ( BundleModel :: class ) ; if ( null === $ identity ) { $ existingBundle = $ repository -> findOneBy ( [ 'number' => $ bundle -> getNumber ( ) ] ) ; if ( null !== $ existingBundle ) { $ identity = $ this -> identityService -> insert ( $ bundle -> getIdentifier ( ) , Bundle :: TYPE , ( string ) $ existingBundle -> getId ( ) , ShopwareAdapter :: NAME ) ; } } else { $ existingBundle = $ repository -> find ( $ identity -> getAdapterIdentifier ( ) ) ; if ( null === $ existingBundle ) { $ this -> identityService -> remove ( $ identity ) ; $ identity = null ; } } if ( null === $ identity ) { $ bundleModel = new BundleModel ( ) ; $ bundleModel -> setDisplayGlobal ( true ) ; $ bundleModel -> setSells ( 0 ) ; $ bundleModel -> setCreated ( ) ; $ bundleModel -> setType ( 1 ) ; $ bundleModel -> setDiscountType ( 'abs' ) ; $ bundleModel -> setQuantity ( 0 ) ; $ bundleModel -> setShowName ( false ) ; } else { $ bundleModel = $ repository -> find ( $ identity -> getAdapterIdentifier ( ) ) ; foreach ( $ bundleModel -> getPrices ( ) as $ price ) { $ this -> entityManager -> remove ( $ price ) ; } foreach ( $ bundleModel -> getArticles ( ) as $ article ) { $ this -> entityManager -> remove ( $ article ) ; } $ this -> entityManager -> flush ( ) ; } try { $ mainVariant = $ this -> getMainVariant ( $ bundle ) ; } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; return false ; } if ( null === $ mainVariant ) { return false ; } $ mainArticle = $ mainVariant -> getArticle ( ) ; $ this -> active = $ mainArticle -> getActive ( ) ; $ bundleModel -> setName ( $ bundle -> getName ( ) ) ; $ bundleModel -> setValidFrom ( $ bundle -> getAvailableFrom ( ) ) ; $ bundleModel -> setValidTo ( $ bundle -> getAvailableTo ( ) ) ; $ bundleModel -> setLimited ( $ bundle -> hasStockLimitation ( ) ) ; $ bundleModel -> setQuantity ( $ this -> getBundleStock ( $ bundle -> getNumber ( ) ) ) ; $ bundleModel -> setNumber ( $ bundle -> getNumber ( ) ) ; $ bundleModel -> setArticle ( $ mainArticle ) ; $ bundleModel -> setCustomerGroups ( $ this -> getCustomerGroups ( $ bundle ) ) ; $ bundleModel -> setPrices ( $ this -> getPrices ( $ bundle , $ bundleModel ) ) ; $ bundleModel -> setPosition ( $ bundle -> getPosition ( ) ) ; $ bundleModel -> setArticles ( $ this -> getArticles ( $ bundle , $ bundleModel , $ mainVariant ) ) ; $ bundleModel -> setActive ( $ this -> active ) ; $ this -> entityManager -> persist ( $ bundleModel ) ; $ this -> entityManager -> flush ( ) ; $ this -> entityManager -> clear ( ) ; return true ; } 
private function getCustomerGroupFromPrice ( Price $ price ) { $ repository = $ this -> entityManager -> getRepository ( GroupModel :: class ) ; if ( null === $ price -> getCustomerGroupIdentifier ( ) ) { return $ repository -> findOneBy ( [ 'key' => 'EK' ] ) ; } $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ price -> getCustomerGroupIdentifier ( ) , 'objectType' => CustomerGroup :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ identity ) { return null ; } return $ repository -> find ( $ identity -> getAdapterIdentifier ( ) ) ; } 
private function getCustomerGroups ( Bundle $ bundle ) { $ result = [ ] ; foreach ( $ bundle -> getPrices ( ) as $ price ) { $ group = $ this -> getCustomerGroupFromPrice ( $ price ) ; if ( null === $ group ) { continue ; } $ result [ $ group -> getKey ( ) ] = $ group ; } return new ArrayCollection ( $ result ) ; } 
private function getPrices ( Bundle $ bundle , BundleModel $ bundleModel ) { $ prices = [ ] ; foreach ( $ bundle -> getPrices ( ) as $ price ) { $ group = $ this -> getCustomerGroupFromPrice ( $ price ) ; if ( null === $ group ) { continue ; } $ netPrice = $ price -> getPrice ( ) * ( 100 / ( $ bundleModel -> getArticle ( ) -> getTax ( ) -> getTax ( ) + 100 ) ) ; $ priceModel = new PriceModel ( ) ; $ priceModel -> setBundle ( $ bundleModel ) ; $ priceModel -> setCustomerGroup ( $ group ) ; $ priceModel -> setPrice ( $ netPrice ) ; $ this -> entityManager -> persist ( $ priceModel ) ; $ prices [ ] = $ priceModel ; } return new ArrayCollection ( $ prices ) ; } 
private function getArticles ( Bundle $ bundle , BundleModel $ bundleModel , DetailModel $ mainVariant ) { $ repository = $ this -> entityManager -> getRepository ( DetailModel :: class ) ; $ result = [ ] ; foreach ( $ bundle -> getBundleProducts ( ) as $ bundleProduct ) { if ( $ mainVariant -> getNumber ( ) === $ bundleProduct -> getNumber ( ) ) { continue ; } $ detail = $ repository -> findOneBy ( [ 'number' => $ bundleProduct -> getNumber ( ) ] ) ; if ( null === $ detail ) { $ this -> logger -> error ( 'bundle product not found => number: ' . $ bundleProduct -> getNumber ( ) ) ; $ this -> active = false ; continue ; } $ product = new Article ( ) ; $ product -> setQuantity ( $ bundleProduct -> getAmount ( ) ) ; $ product -> setArticleDetail ( $ detail ) ; $ product -> setPosition ( $ bundleProduct -> getPosition ( ) ) ; $ product -> setBundle ( $ bundleModel ) ; $ this -> entityManager -> persist ( $ product ) ; $ result [ ] = $ product ; } return new ArrayCollection ( $ result ) ; } 
private function getMainVariant ( Bundle $ bundle ) { $ repository = $ this -> entityManager -> getRepository ( DetailModel :: class ) ; foreach ( $ bundle -> getBundleProducts ( ) as $ bundleProduct ) { $ detail = $ repository -> findOneBy ( [ 'number' => $ bundleProduct -> getNumber ( ) ] ) ; if ( null === $ detail ) { throw new NotFoundException ( 'bundle main product not found' ) ; continue ; } return $ detail ; } return null ; } 
private function getBundleStock ( $ bundleNumber ) { $ repository = $ this -> entityManager -> getRepository ( DetailModel :: class ) ; $ detail = $ repository -> findOneBy ( [ 'number' => $ bundleNumber ] ) ; if ( null === $ detail ) { return 0 ; } return $ detail -> getInStock ( ) ; } 
public function handle ( CommandInterface $ command ) { $ mediaCategory = $ command -> getPayload ( ) ; $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ mediaCategory -> getIdentifier ( ) , 'objectType' => MediaCategory :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; $ albumRepository = $ this -> entityManager -> getRepository ( Album :: class ) ; $ settingsRepository = $ this -> entityManager -> getRepository ( Settings :: class ) ; $ parent = $ albumRepository -> findOneBy ( [ 'name' => 'PlentyConnector' , ] ) ; $ parentSettings = $ settingsRepository -> findOneBy ( [ 'albumId' => Album :: ALBUM_ARTICLE , ] ) ; if ( null === $ parent ) { $ parent = new Album ( ) ; $ parent -> setName ( 'PlentyConnector' ) ; $ parent -> setPosition ( 10 ) ; $ settings = new Settings ( ) ; $ settings -> setAlbum ( $ parent ) ; $ settings -> setCreateThumbnails ( $ parentSettings -> getCreateThumbnails ( ) ) ; $ settings -> setThumbnailSize ( $ parentSettings -> getThumbnailSize ( ) ) ; $ settings -> setIcon ( 'sprite-pictures' ) ; $ settings -> setThumbnailHighDpi ( $ parentSettings -> isThumbnailHighDpi ( ) ) ; $ settings -> setThumbnailQuality ( $ parentSettings -> getThumbnailQuality ( ) ) ; $ settings -> setThumbnailHighDpiQuality ( $ parentSettings -> getThumbnailHighDpiQuality ( ) ) ; $ parent -> setSettings ( $ settings ) ; $ this -> entityManager -> persist ( $ settings ) ; $ this -> entityManager -> persist ( $ parent ) ; $ this -> entityManager -> flush ( ) ; } if ( null === $ identity ) { $ this -> createNewAlbum ( $ mediaCategory , $ parent , $ parentSettings ) ; return true ; } $ album = $ albumRepository -> find ( $ identity -> getAdapterIdentifier ( ) ) ; if ( null !== $ album ) { $ album -> setName ( $ mediaCategory -> getName ( ) ) ; $ this -> entityManager -> persist ( $ album ) ; $ this -> entityManager -> flush ( ) ; } else { $ this -> createNewAlbum ( $ mediaCategory , $ parent , $ parentSettings ) ; } return true ; } 
public function handle ( QueryInterface $ query ) { $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ query -> getObjectIdentifier ( ) , 'objectType' => Order :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ identity ) { return [ ] ; } $ orderData = $ this -> api -> find ( $ identity -> getAdapterIdentifier ( ) ) ; $ order = $ this -> responseParser -> parse ( $ orderData ) ; return array_filter ( $ order ) ; } 
public function parse ( array $ entry ) { if ( empty ( $ entry [ 'details' ] ) ) { $ this -> logger -> warning ( 'category without details' ) ; return [ ] ; } if ( $ entry [ 'right' ] !== 'all' ) { $ this -> logger -> warning ( 'unsupported category rights' ) ; return [ ] ; } $ categoryIdentity = $ this -> identityService -> findOneOrCreate ( ( string ) $ entry [ 'id' ] , PlentymarketsAdapter :: NAME , Category :: TYPE ) ; if ( null !== $ entry [ 'parentCategoryId' ] ) { $ parentIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ entry [ 'parentCategoryId' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Category :: TYPE , ] ) ; if ( null === $ parentIdentity ) { $ this -> logger -> warning ( 'parent category was not found' , [ 'category' => $ categoryIdentity -> getObjectIdentifier ( ) ] ) ; return [ ] ; } $ parentCategoryIdentifier = $ parentIdentity -> getObjectIdentifier ( ) ; } else { $ parentCategoryIdentifier = null ; } if ( empty ( $ entry [ 'clients' ] ) ) { return [ ] ; } $ shopIdentifiers = [ ] ; foreach ( $ entry [ 'clients' ] as $ client ) { if ( empty ( $ client [ 'plentyId' ] ) ) { continue ; } $ identity = $ this -> getShopIdentity ( $ client [ 'plentyId' ] ) ; if ( null === $ identity ) { continue ; } $ shopIdentifiers [ ] = $ identity -> getObjectIdentifier ( ) ; } foreach ( $ entry [ 'details' ] as $ key => $ detail ) { $ isDefaultPlentyId = $ key === 0 ; $ isPlentyIdEnabled = in_array ( $ entry [ 'details' ] [ $ key ] [ 'plentyId' ] , array_column ( $ entry [ 'clients' ] , 'plentyId' ) ) ; if ( ! $ isPlentyIdEnabled && ! $ isDefaultPlentyId ) { unset ( $ entry [ 'details' ] [ $ key ] ) ; continue ; } } $ validDetails = array_values ( array_filter ( $ entry [ 'details' ] , function ( array $ detail ) { if ( empty ( $ detail [ 'plentyId' ] ) ) { return false ; } $ identity = $ this -> getShopIdentity ( $ detail [ 'plentyId' ] ) ; return ! ( null === $ identity ) ; } ) ) ; if ( empty ( $ validDetails ) ) { $ validDetails = $ entry [ 'details' ] ; } $ result = [ ] ; $ category = new Category ( ) ; $ category -> setIdentifier ( $ categoryIdentity -> getObjectIdentifier ( ) ) ; $ category -> setParentIdentifier ( $ parentCategoryIdentifier ) ; $ category -> setShopIdentifiers ( $ shopIdentifiers ) ; $ category -> setImageIdentifiers ( $ this -> getImages ( $ validDetails [ '0' ] , $ result ) ) ; $ category -> setName ( $ validDetails [ '0' ] [ 'name' ] ) ; $ category -> setActive ( true ) ; $ category -> setPosition ( ( int ) $ validDetails [ '0' ] [ 'position' ] ) ; $ category -> setDescription ( $ validDetails [ '0' ] [ 'shortDescription' ] ) ; $ category -> setLongDescription ( $ validDetails [ '0' ] [ 'description' ] ) ; $ category -> setMetaTitle ( $ validDetails [ '0' ] [ 'metaTitle' ] ) ; $ category -> setMetaDescription ( $ validDetails [ '0' ] [ 'metaDescription' ] ) ; $ category -> setMetaKeywords ( $ validDetails [ '0' ] [ 'metaKeywords' ] ) ; $ category -> setMetaRobots ( $ this -> getMetaRobots ( $ validDetails [ '0' ] [ 'metaRobots' ] ) ) ; $ category -> setTranslations ( $ this -> getTranslations ( $ validDetails , $ result ) ) ; $ category -> setAttributes ( $ this -> getAttributes ( $ validDetails ) ) ; return array_merge ( $ result , [ $ category ] ) ; } 
private function getShopIdentity ( $ plentyId ) { $ identity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ plentyId , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Shop :: TYPE , ] ) ; if ( null === $ identity ) { $ this -> logger -> notice ( 'shop not found' , [ 'shop' => $ plentyId ] ) ; return null ; } $ isMappedIdentity = $ this -> identityService -> isMappedIdentity ( $ identity -> getObjectIdentifier ( ) , $ identity -> getObjectType ( ) , $ identity -> getAdapterName ( ) ) ; if ( ! $ isMappedIdentity ) { return null ; } return $ identity ; } 
private function getImages ( array $ detail , & $ result ) { $ imageIdentifiers = [ ] ; $ images = [ ] ; if ( ! empty ( $ detail [ 'imagePath' ] ) ) { $ images [ ] = $ detail [ 'imagePath' ] ; } if ( ! empty ( $ detail [ 'image2Path' ] ) ) { $ images [ ] = $ detail [ 'image2Path' ] ; } foreach ( $ images as $ image ) { try { $ media = $ this -> mediaResponseParser -> parse ( [ 'mediaCategory' => MediaCategoryHelper :: CATEGORY , 'id' => sha1 ( json_encode ( $ image ) ) , 'link' => $ this -> getBaseUrl ( ) . 'documents/' . $ image , 'name' => $ detail [ 'name' ] , 'alternateName' => $ detail [ 'name' ] , ] ) ; $ result [ $ media -> getIdentifier ( ) ] = $ media ; $ imageIdentifiers [ ] = $ media -> getIdentifier ( ) ; } catch ( Exception $ exception ) { $ this -> logger -> notice ( 'error while processing category image' , [ 'name' => $ detail [ 'name' ] ] ) ; } } return $ imageIdentifiers ; } 
private function getTranslations ( array $ details , & $ result ) { $ translations = [ ] ; foreach ( $ details as $ detail ) { $ languageIdentifier = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ detail [ 'lang' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null === $ languageIdentifier ) { continue ; } $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'imageIdentifiers' , 'value' => $ this -> getImages ( $ detail , $ result ) , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'name' , 'value' => $ detail [ 'name' ] , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'description' , 'value' => $ detail [ 'shortDescription' ] , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'longDescription' , 'value' => $ detail [ 'description' ] , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'metaTitle' , 'value' => $ detail [ 'metaTitle' ] , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'metaDescription' , 'value' => $ detail [ 'metaDescription' ] , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'metaKeywords' , 'value' => $ detail [ 'metaKeywords' ] , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'metaRobots' , 'value' => $ this -> getMetaRobots ( $ detail [ 'metaRobots' ] ) , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'plentyId' , 'value' => $ detail [ 'plentyId' ] , ] ) ; } return $ translations ; } 
private function getSecondCategoryDescriptionAsAttribute ( $ categoryDetails ) { $ translations = [ ] ; foreach ( $ categoryDetails as $ categoryDetail ) { $ languageIdentifier = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ categoryDetail [ 'lang' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null === $ languageIdentifier ) { continue ; } $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'value' , 'value' => $ categoryDetail [ 'description2' ] , ] ) ; } $ attribute = new Attribute ( ) ; $ attribute -> setKey ( 'secondCategoryDescription' ) ; $ attribute -> setValue ( ( string ) $ categoryDetails [ 0 ] [ 'description2' ] ) ; $ attribute -> setTranslations ( $ translations ) ; return $ attribute ; } 
public function handle ( CommandInterface $ command ) { $ payment = $ command -> getPayload ( ) ; $ data = $ payment -> getPaymentData ( ) ; if ( ! ( $ data instanceof AmazonPayPaymentData ) ) { return $ this -> parentCommandHandler -> handle ( $ command ) ; } $ orderIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ payment -> getOrderIdentifer ( ) , 'objectType' => Order :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ orderIdentity ) { throw new NotFoundException ( 'could not find order for amazon payment handling - ' . $ payment -> getOrderIdentifer ( ) ) ; } $ amazonPayDataParams = [ 'key' => $ data -> getKey ( ) , 'order_reference_id' => $ data -> getTransactionId ( ) , 'order_id' => $ orderIdentity -> getAdapterIdentifier ( ) , ] ; $ this -> client -> request ( 'POST' , 'amazon-shopware-connect' , $ amazonPayDataParams , null , null , [ 'foreign' => true ] ) ; return true ; } 
public function handle ( QueryInterface $ query ) { $ result = [ ] ; $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ query -> getObjectIdentifier ( ) , 'objectType' => MediaCategory :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ identity ) { return [ ] ; } $ caegories = $ this -> mediaCategoryHelper -> getCategories ( ) ; if ( array_key_exists ( $ identity -> getAdapterIdentifier ( ) , $ caegories ) ) { $ result [ ] = $ this -> responseParser -> parse ( $ caegories [ $ identity -> getAdapterIdentifier ( ) ] ) ; } return array_filter ( $ result ) ; } 
public function logCommandReceived ( $ command ) { $ message = $ this -> getRecievedMessage ( $ command ) ; $ payload = $ this -> getPayload ( $ command ) ; $ this -> logger -> log ( $ this -> commandReceivedLevel , $ message , $ payload ) ; } 
public function logCommandProcessed ( $ command , $ returnValue ) { $ message = $ this -> getProcessedMessage ( $ command ) ; $ payload = $ this -> getPayload ( $ command ) ; $ this -> logger -> log ( $ this -> commandSucceededLevel , $ message , $ payload ) ; } 
public function logCommandFailed ( $ command , Exception $ exception ) { $ message = $ this -> getFailedMessage ( $ command ) ; $ payload = $ this -> getPayload ( $ command ) ; $ payload = array_merge ( $ payload , [ 'exception' => $ exception ] ) ; $ this -> logger -> log ( $ this -> commandFailedLevel , $ message , $ payload ) ; } 
private function getPayload ( $ command ) { if ( ! ( $ command instanceof CommandInterface ) && ! ( $ command instanceof QueryInterface ) ) { return [ ] ; } $ payload = $ command -> toArray ( ) ; return $ this -> preparePayload ( $ payload ) ; } 
private function preparePayload ( array $ payload ) { return array_map ( function ( $ payload ) { if ( ! ( $ payload instanceof TransferObjectInterface ) ) { return $ payload ; } return $ payload -> getIdentifier ( ) ; } , $ payload ) ; } 
public function parse ( array $ entry ) { $ identity = $ this -> identityService -> findOneOrCreate ( ( string ) $ entry [ 'id' ] , PlentymarketsAdapter :: NAME , Manufacturer :: TYPE ) ; $ manufacturer = new Manufacturer ( ) ; $ manufacturer -> setIdentifier ( $ identity -> getObjectIdentifier ( ) ) ; $ manufacturer -> setName ( $ entry [ 'name' ] ) ; if ( ! empty ( $ entry [ 'url' ] ) ) { $ manufacturer -> setLink ( $ entry [ 'url' ] ) ; } $ result = [ ] ; if ( ! empty ( $ entry [ 'logo' ] ) ) { try { $ media = $ this -> mediaResponseParser -> parse ( [ 'mediaCategory' => MediaCategoryHelper :: MANUFACTURER , 'id' => $ entry [ 'id' ] , 'link' => $ entry [ 'logo' ] , 'name' => $ entry [ 'name' ] , 'alternateName' => $ entry [ 'name' ] , ] ) ; $ manufacturer -> setLogoIdentifier ( $ media -> getIdentifier ( ) ) ; $ result [ ] = $ media ; } catch ( Exception $ exception ) { $ this -> logger -> notice ( 'error while processing manufacturer logo' , [ 'name' => $ entry [ 'name' ] , 'url' => $ entry [ 'logo' ] , ] ) ; } } $ result [ ] = $ manufacturer ; return $ result ; } 
public function parse ( array $ entry ) { $ entry [ 'salutation' ] = strtolower ( $ entry [ 'salutation' ] ) ; $ countryIdentitiy = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ entry [ 'country' ] [ 'id' ] , 'adapterName' => ShopwareAdapter :: NAME , 'objectType' => Country :: TYPE , ] ) ; if ( null === $ countryIdentitiy ) { throw new NotFoundException ( 'country mapping missing - ' . json_encode ( $ entry ) ) ; } if ( $ entry [ 'salutation' ] === 'mr' || $ entry [ 'salutation' ] === 'herr' ) { $ gender = Customer :: GENDER_MALE ; } elseif ( $ entry [ 'salutation' ] === 'ms' || $ entry [ 'salutation' ] === 'frau' ) { $ gender = Customer :: GENDER_FEMALE ; } else { $ gender = null ; } $ params = [ 'gender' => $ gender , 'firstname' => $ entry [ 'firstName' ] , 'lastname' => $ entry [ 'lastName' ] , 'street' => $ entry [ 'street' ] , 'postalCode' => $ entry [ 'zipCode' ] , 'city' => $ entry [ 'city' ] , 'countryIdentifier' => $ countryIdentitiy -> getObjectIdentifier ( ) , 'vatId' => ! empty ( $ entry [ 'vatId' ] ) ? $ entry [ 'vatId' ] : null , ] ; if ( ! empty ( $ entry [ 'attribute' ] ) ) { $ params [ 'attributes' ] = $ this -> getAttributes ( $ entry [ 'attribute' ] ) ; } if ( ! empty ( $ entry [ 'department' ] ) ) { $ params [ 'department' ] = $ entry [ 'department' ] ; } if ( ! empty ( $ entry [ 'title' ] ) ) { $ params [ 'title' ] = $ entry [ 'title' ] ; } if ( ! empty ( $ entry [ 'company' ] ) ) { $ params [ 'company' ] = $ entry [ 'company' ] ; } if ( ! empty ( trim ( $ entry [ 'additionalAddressLine1' ] ) ) ) { $ params [ 'additional' ] = $ entry [ 'additionalAddressLine1' ] ; } if ( isset ( $ entry [ 'phone' ] ) && ! empty ( trim ( $ entry [ 'phone' ] ) ) ) { $ params [ 'phoneNumber' ] = $ entry [ 'phone' ] ; } return Address :: fromArray ( $ params ) ; } 
private function filterActiveDefinitions ( array $ definitions ) { return array_filter ( $ definitions , function ( Definition $ definition ) { if ( ! $ definition -> isActive ( ) ) { return false ; } return true ; } ) ; } 
private function filterMatchingDefinitions ( array $ definitions , $ objectType ) { return array_filter ( $ definitions , function ( Definition $ definition ) use ( $ objectType ) { return strtolower ( $ definition -> getObjectType ( ) ) === strtolower ( $ objectType ) || null === $ objectType ; } ) ; } 
private function sortDefinitions ( array $ definitions ) { usort ( $ definitions , function ( Definition $ definitionLeft , Definition $ definitionRight ) { if ( $ definitionLeft -> getPriority ( ) === $ definitionRight -> getPriority ( ) ) { return 0 ; } return ( $ definitionLeft -> getPriority ( ) > $ definitionRight -> getPriority ( ) ) ? - 1 : 1 ; } ) ; return $ definitions ; } 
public function validate ( $ object , array $ parents = [ ] ) { $ validators = array_filter ( $ this -> validators , function ( ValidatorInterface $ validator ) use ( $ object ) { return $ validator -> supports ( $ object ) ; } ) ; try { array_walk ( $ validators , function ( ValidatorInterface $ validator ) use ( $ object ) { $ validator -> validate ( $ object ) ; } ) ; $ parents [ ] = $ object ; $ methods = get_class_methods ( $ object ) ; if ( empty ( $ methods ) ) { return ; } $ methods = array_filter ( $ methods , function ( $ method ) { return 0 === stripos ( $ method , 'get' ) ; } ) ; foreach ( $ methods as $ method ) { if ( $ object instanceof DateTimeZone ) { continue ; } $ result = $ object -> $ method ( ) ; if ( is_array ( $ result ) ) { foreach ( $ result as $ item ) { $ this -> validate ( $ item , $ parents ) ; } } else { $ this -> validate ( $ result , $ parents ) ; } } } catch ( InvalidArgumentException $ exception ) { throw InvalidDataException :: fromObject ( $ object , $ exception -> getMessage ( ) , $ exception -> getPropertyPath ( ) , $ parents ) ; } } 
public function getClassProperties ( ) { return [ 'identifier' => $ this -> getIdentifier ( ) , 'name' => $ this -> getName ( ) , 'logoIdentifier' => $ this -> getLogoIdentifier ( ) , 'link' => $ this -> getLink ( ) , 'attributes' => $ this -> getAttributes ( ) , ] ; } 
public function getClassProperties ( ) { return [ 'type' => $ this -> getType ( ) , 'quantity' => $ this -> getQuantity ( ) , 'name' => $ this -> getName ( ) , 'number' => $ this -> getNumber ( ) , 'price' => $ this -> getPrice ( ) , 'vatRateIdentifier' => $ this -> getVatRateIdentifier ( ) , 'attributes' => $ this -> getAttributes ( ) , ] ; } 
public function generate ( OrderItem $ orderItem , Order $ order ) { $ itemParams = $ this -> parentOrderItemRequestGenerator -> generate ( $ orderItem , $ order ) ; $ customerGroupIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getCustomer ( ) -> getCustomerGroupIdentifier ( ) , 'adapterName' => ShopwareAdapter :: NAME , 'objectType' => CustomerGroup :: TYPE , ] ) ; if ( null === $ customerGroupIdentity ) { throw new RuntimeException ( 'could not find customer group identity of bundle' ) ; } $ bundle = $ this -> getBundle ( $ orderItem -> getNumber ( ) , $ customerGroupIdentity -> getAdapterIdentifier ( ) ) ; if ( empty ( $ bundle ) ) { return $ itemParams ; } $ vatIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ orderItem -> getVatRateIdentifier ( ) , 'adapterName' => ShopwareAdapter :: NAME , 'objectType' => VatRate :: TYPE , ] ) ; if ( null === $ vatIdentity ) { throw new RuntimeException ( 'could not find vat identity of bundle' ) ; } $ taxRepository = $ this -> entityManager -> getRepository ( Tax :: class ) ; $ taxModel = $ taxRepository -> find ( $ vatIdentity -> getAdapterIdentifier ( ) ) ; if ( null === $ taxModel ) { throw new RuntimeException ( 'could not find shopware vat model of bundle' ) ; } $ itemParams [ 'orderItemName' ] = $ bundle [ 'name' ] ; $ itemParams [ 'amounts' ] [ 0 ] [ 'priceOriginalGross' ] = $ bundle [ 'price' ] * ( 1 + ( $ taxModel -> getTax ( ) / 100 ) ) ; return $ itemParams ; } 
private function getBundle ( $ articleNumber , $ customerGroupId ) { try { $ query = ' SELECT * FROM s_articles_bundles AS bundle LEFT JOIN s_articles_bundles_prices AS bundlePrice ON bundle.id = bundlePrice.bundle_id WHERE bundle.ordernumber = :articleNumber AND bundlePrice.customer_group_id = :customerGroupId ' ; return $ this -> entityManager -> getConnection ( ) -> fetchAssoc ( $ query , [ ':articleNumber' => $ articleNumber , ':customerGroupId' => $ customerGroupId , ] ) ; } catch ( Exception $ exception ) { return [ ] ; } } 
public function getClassProperties ( ) { return [ 'company' => $ this -> getCompany ( ) , 'department' => $ this -> getDepartment ( ) , 'gender' => $ this -> getGender ( ) , 'title' => $ this -> getTitle ( ) , 'firstname' => $ this -> getFirstname ( ) , 'lastname' => $ this -> getLastname ( ) , 'street' => $ this -> getStreet ( ) , 'additional' => $ this -> getAdditional ( ) , 'postalCode' => $ this -> getPostalCode ( ) , 'city' => $ this -> getCity ( ) , 'countryIdentifier' => $ this -> getCountryIdentifier ( ) , 'vatId' => $ this -> getVatId ( ) , 'phoneNumber' => $ this -> getPhoneNumber ( ) , 'mobilePhoneNumber' => $ this -> getMobilePhoneNumber ( ) , 'attributes' => $ this -> getAttributes ( ) , ] ; } 
public function handle ( CommandInterface $ command ) { $ category = $ command -> getPayload ( ) ; $ validIdentities = [ ] ; foreach ( $ category -> getShopIdentifiers ( ) as $ shopIdentifier ) { $ shopIdentities = $ this -> identityService -> findBy ( [ 'objectIdentifier' => ( string ) $ shopIdentifier , 'objectType' => Shop :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( empty ( $ shopIdentities ) ) { continue ; } foreach ( $ shopIdentities as $ shopIdentity ) { $ identity = $ this -> handleCategory ( $ category , $ shopIdentity ) ; if ( null === $ identity ) { continue ; } $ identifier = $ identity -> getObjectIdentifier ( ) ; $ validIdentities [ $ identifier ] = $ identifier ; } } $ this -> handleOrphanedCategories ( $ category , $ validIdentities ) ; return true ; } 
private function handleCategory ( Category $ category , Identity $ shopIdentity ) { $ deepCopy = new DeepCopy ( ) ; $ category = $ deepCopy -> copy ( $ category ) ; $ shop = $ this -> shopRepository -> find ( $ shopIdentity -> getAdapterIdentifier ( ) ) ; if ( null === $ shop ) { return null ; } $ this -> prepareCategory ( $ category ) ; $ mainCategory = $ shop -> getCategory ( ) ; if ( null === $ mainCategory ) { throw new InvalidArgumentException ( 'shop without main cateogry assignment' ) ; } $ shopLocale = $ shop -> getLocale ( ) ; if ( null === $ shopLocale ) { throw new InvalidArgumentException ( 'shop without locale assignment' ) ; } $ languageIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ shopLocale -> getId ( ) , 'adapterName' => ShopwareAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null !== $ languageIdentity ) { $ translatedCategory = $ this -> translationHelper -> translate ( $ languageIdentity -> getObjectIdentifier ( ) , $ category ) ; $ translatedAttributes = [ ] ; if ( null !== $ translatedCategory ) { foreach ( $ translatedCategory -> getAttributes ( ) as $ attribute ) { $ translatedAttributes [ ] = $ this -> translationHelper -> translate ( $ languageIdentity -> getObjectIdentifier ( ) , $ attribute ) ; } $ translatedCategory -> setAttributes ( $ translatedAttributes ) ; $ category = $ translatedCategory ; } } if ( null === $ category -> getParentIdentifier ( ) ) { $ parentCategory = $ mainCategory -> getId ( ) ; } else { $ parentCategoryIdentities = $ this -> identityService -> findBy ( [ 'objectIdentifier' => ( string ) $ category -> getParentIdentifier ( ) , 'objectType' => Category :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; $ possibleIdentities = array_filter ( $ parentCategoryIdentities , function ( Identity $ identity ) use ( $ mainCategory ) { return $ this -> validIdentity ( $ identity , $ mainCategory ) ; } ) ; $ parentCategoryIdentity = null ; if ( ! empty ( $ possibleIdentities ) ) { $ parentCategoryIdentity = array_shift ( $ possibleIdentities ) ; } if ( null === $ parentCategoryIdentity ) { throw new InvalidArgumentException ( 'missing parent category - ' . $ category -> getParentIdentifier ( ) ) ; } $ parentCategory = $ parentCategoryIdentity -> getAdapterIdentifier ( ) ; } $ categoryIdentities = $ this -> identityService -> findBy ( [ 'objectIdentifier' => $ category -> getIdentifier ( ) , 'objectType' => Category :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; $ possibleIdentities = array_filter ( $ categoryIdentities , function ( Identity $ identity ) use ( $ mainCategory ) { return $ this -> validIdentity ( $ identity , $ mainCategory ) ; } ) ; $ categoryIdentity = null ; if ( ! empty ( $ possibleIdentities ) ) { $ categoryIdentity = array_shift ( $ possibleIdentities ) ; } $ resource = $ this -> getCategoryResource ( ) ; if ( null !== $ categoryIdentity ) { try { $ resource -> getOne ( $ categoryIdentity -> getAdapterIdentifier ( ) ) ; } catch ( NotFoundException $ exception ) { $ categoryIdentity = null ; } } if ( null === $ categoryIdentity ) { $ existingCategory = $ this -> findExistingCategory ( $ category , $ parentCategory ) ; if ( null !== $ existingCategory ) { $ categoryIdentity = $ this -> identityService -> insert ( ( string ) $ category -> getIdentifier ( ) , Category :: TYPE , ( string ) $ existingCategory , ShopwareAdapter :: NAME ) ; } } $ params = [ 'active' => $ category -> getActive ( ) , 'position' => $ category -> getPosition ( ) , 'name' => $ category -> getName ( ) , 'parent' => $ parentCategory , 'metaTitle' => $ category -> getMetaTitle ( ) , 'metaKeywords' => $ category -> getMetaKeywords ( ) , 'metaDescription' => $ category -> getMetaDescription ( ) , 'cmsHeadline' => $ category -> getDescription ( ) , 'cmsText' => $ category -> getLongDescription ( ) , ] ; if ( ! empty ( $ category -> getImageIdentifiers ( ) ) ) { $ mediaIdentifiers = $ category -> getImageIdentifiers ( ) ; $ mediaIdentifier = array_shift ( $ mediaIdentifiers ) ; $ mediaIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ mediaIdentifier , 'objectType' => Media :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ mediaIdentity ) { throw new IdentityNotFoundException ( 'media not found - ' . $ mediaIdentifier ) ; } $ params [ 'media' ] [ 'mediaId' ] = $ mediaIdentity -> getAdapterIdentifier ( ) ; } if ( null !== $ categoryIdentity ) { try { $ resource -> getOne ( $ categoryIdentity -> getAdapterIdentifier ( ) ) ; } catch ( NotFoundException $ exception ) { $ this -> identityService -> remove ( $ categoryIdentity ) ; $ categoryIdentity = null ; } } if ( null === $ categoryIdentity ) { $ categoryModel = $ resource -> create ( $ params ) ; $ categoryIdentity = $ this -> identityService -> insert ( ( string ) $ category -> getIdentifier ( ) , Category :: TYPE , ( string ) $ categoryModel -> getId ( ) , ShopwareAdapter :: NAME ) ; } else { $ categoryModel = $ resource -> update ( $ categoryIdentity -> getAdapterIdentifier ( ) , $ params ) ; } $ this -> attributePersister -> saveCategoryAttributes ( $ categoryModel , $ category -> getAttributes ( ) ) ; $ this -> translationDataPersister -> writeCategoryTranslations ( $ category ) ; return $ categoryIdentity ; } 
private function findExistingCategory ( Category $ category , $ parentCategory ) { $ existingCategory = $ this -> categoryRepository -> findOneBy ( [ 'name' => $ category -> getName ( ) , 'parentId' => $ parentCategory , ] ) ; if ( null === $ existingCategory ) { return null ; } return $ existingCategory -> getId ( ) ; } 
private function validIdentity ( Identity $ categoryIdentity , CategoryModel $ shopMainCategory ) { try { $ existingCategory = $ this -> categoryRepository -> find ( $ categoryIdentity -> getAdapterIdentifier ( ) ) ; if ( null === $ existingCategory ) { return false ; } $ extractedCategoryPath = array_filter ( explode ( '|' , $ existingCategory -> getPath ( ) ) ) ; if ( in_array ( $ shopMainCategory -> getId ( ) , $ extractedCategoryPath ) ) { return true ; } return false ; } catch ( Exception $ exception ) { return false ; } } 
public function handle ( CommandInterface $ command ) { $ shopLocaleId = $ this -> shopDataProvider -> getDefaultShop ( ) -> getLocale ( ) -> getId ( ) ; $ languageIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ shopLocaleId , 'adapterName' => ShopwareAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; $ product = $ command -> getPayload ( ) ; if ( null !== $ languageIdentity ) { $ translated = $ this -> translationHelper -> translate ( $ languageIdentity -> getObjectIdentifier ( ) , $ product ) ; if ( null !== $ translated ) { $ product = $ translated ; } } $ params = $ this -> productRequestGenerator -> generate ( $ product ) ; if ( empty ( $ params ) ) { return false ; } $ articleResource = $ this -> getArticleResource ( ) ; $ productIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ product -> getIdentifier ( ) , 'objectType' => Product :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; $ variationRepository = $ this -> entityManager -> getRepository ( Detail :: class ) ; $ mainVariation = $ variationRepository -> findOneBy ( [ 'number' => $ product -> getNumber ( ) ] ) ; if ( null === $ mainVariation && null !== $ productIdentity ) { $ mainVariation = $ variationRepository -> findOneBy ( [ 'articleId' => $ productIdentity -> getAdapterIdentifier ( ) , 'kind' => 1 ] ) ; } if ( null === $ productIdentity ) { if ( null === $ mainVariation ) { $ productModel = $ articleResource -> create ( $ params ) ; } else { $ this -> correctMainDetailAssignment ( $ mainVariation ) ; foreach ( $ mainVariation -> getImages ( ) as $ image ) { if ( null !== $ image ) { $ this -> translationDataPersister -> removeMediaTranslation ( $ image ) ; } } $ productModel = $ articleResource -> update ( $ mainVariation -> getArticleId ( ) , $ params ) ; } $ this -> identityService -> insert ( $ product -> getIdentifier ( ) , Product :: TYPE , ( string ) $ productModel -> getId ( ) , ShopwareAdapter :: NAME ) ; } else { try { $ articleRepository = $ this -> entityManager -> getRepository ( ArticleModel :: class ) ; $ productModel = $ articleRepository -> find ( $ productIdentity -> getAdapterIdentifier ( ) ) ; if ( null === $ mainVariation ) { $ variationResource = $ this -> getVariationResource ( ) ; $ mainVariation = $ variationResource -> create ( [ 'articleId' => $ productIdentity -> getAdapterIdentifier ( ) , 'number' => $ product -> getNumber ( ) , 'active' => true , ] ) ; } foreach ( $ productModel -> getImages ( ) as $ image ) { if ( null !== $ image ) { $ this -> translationDataPersister -> removeMediaTranslation ( $ image ) ; } } $ this -> correctMainDetailAssignment ( $ mainVariation ) ; $ productModel = $ articleResource -> update ( $ productModel -> getId ( ) , $ params ) ; } catch ( NotFoundException $ exception ) { $ productModel = $ articleResource -> create ( $ params ) ; $ this -> identityService -> update ( $ productIdentity , [ 'adapterIdentifier' => ( string ) $ productModel -> getId ( ) , ] ) ; } $ this -> attributeDataPersister -> saveProductDetailAttributes ( $ productModel -> getMainDetail ( ) , $ product -> getAttributes ( ) ) ; $ this -> translationDataPersister -> writeProductTranslations ( $ product ) ; } return true ; } 
public function handle ( QueryInterface $ query ) { $ elements = $ this -> unitApi -> findAll ( ) ; foreach ( $ elements as $ element ) { $ result = $ this -> responseParser -> parse ( $ element ) ; if ( null === $ result ) { continue ; } yield $ result ; } } 
public function parse ( array $ entry ) { $ identity = $ this -> identityService -> findOneOrCreate ( ( string ) $ entry [ 'id' ] , PlentymarketsAdapter :: NAME , Unit :: TYPE ) ; 
public function getClassProperties ( ) { return [ 'reference' => $ this -> getReference ( ) , 'bank_name' => $ this -> getBankName ( ) , 'account_holder' => $ this -> getAccountHolder ( ) , 'iban' => $ this -> getIban ( ) , 'bic' => $ this -> getBic ( ) , 'amount' => $ this -> getAmount ( ) , 'due_date' => $ this -> getDueDate ( ) , ] ; } 
public function parse ( array $ product ) { $ result = [ ] ; if ( empty ( $ product [ 'texts' ] ) ) { $ this -> logger -> notice ( 'the product has no text fieds and will be skipped' , [ 'product id' => $ product [ 'id' ] , ] ) ; return [ ] ; } $ mainVariation = $ this -> variationHelper -> getMainVariation ( $ product [ 'variations' ] ) ; if ( empty ( $ mainVariation ) ) { return [ ] ; } $ identity = $ this -> identityService -> findOneOrCreate ( ( string ) $ product [ 'id' ] , PlentymarketsAdapter :: NAME , Product :: TYPE ) ; $ candidatesForProcessing = $ this -> variationResponseParser -> parse ( $ product ) ; if ( empty ( $ candidatesForProcessing ) ) { return [ ] ; } $ variations = array_filter ( $ candidatesForProcessing , function ( TransferObjectInterface $ object ) { return $ object instanceof Variation ; } ) ; if ( empty ( $ variations ) ) { return [ ] ; } $ productObject = new Product ( ) ; $ productObject -> setIdentifier ( $ identity -> getObjectIdentifier ( ) ) ; $ productObject -> setName ( ( string ) $ product [ 'texts' ] [ 0 ] [ 'name1' ] ) ; $ productObject -> setActive ( $ this -> getActive ( $ variations , $ mainVariation ) ) ; $ productObject -> setNumber ( $ this -> variationHelper -> getMainVariationNumber ( $ mainVariation , $ variations ) ) ; $ productObject -> setBadges ( $ this -> getBadges ( $ product ) ) ; $ productObject -> setShopIdentifiers ( $ this -> variationHelper -> getShopIdentifiers ( $ mainVariation ) ) ; $ productObject -> setManufacturerIdentifier ( $ this -> getManufacturerIdentifier ( $ product ) ) ; $ productObject -> setCategoryIdentifiers ( $ this -> getCategories ( $ mainVariation ) ) ; $ productObject -> setDefaultCategoryIdentifiers ( $ this -> getDafaultCategories ( $ mainVariation ) ) ; $ productObject -> setShippingProfileIdentifiers ( $ this -> getShippingProfiles ( $ product ) ) ; $ productObject -> setImages ( $ this -> getImages ( $ product , $ product [ 'texts' ] , $ result ) ) ; $ productObject -> setVatRateIdentifier ( $ this -> getVatRateIdentifier ( $ mainVariation ) ) ; $ productObject -> setDescription ( ( string ) $ product [ 'texts' ] [ 0 ] [ 'shortDescription' ] ) ; $ productObject -> setLongDescription ( ( string ) $ product [ 'texts' ] [ 0 ] [ 'description' ] ) ; $ productObject -> setMetaTitle ( ( string ) $ product [ 'texts' ] [ 0 ] [ 'name1' ] ) ; $ productObject -> setMetaDescription ( ( string ) $ product [ 'texts' ] [ 0 ] [ 'metaDescription' ] ) ; $ productObject -> setMetaKeywords ( ( string ) $ product [ 'texts' ] [ 0 ] [ 'keywords' ] ) ; $ productObject -> setMetaRobots ( 'INDEX, FOLLOW' ) ; $ productObject -> setLinkedProducts ( $ this -> getLinkedProducts ( $ product ) ) ; $ productObject -> setProperties ( $ this -> getProperties ( $ mainVariation ) ) ; $ productObject -> setTranslations ( $ this -> getProductTranslations ( $ product [ 'texts' ] ) ) ; $ productObject -> setAvailableFrom ( $ this -> getAvailableFrom ( $ mainVariation ) ) ; $ productObject -> setAvailableTo ( $ this -> getAvailableTo ( $ mainVariation ) ) ; $ productObject -> setCreatedAt ( $ this -> getCreatedAt ( $ mainVariation ) ) ; $ productObject -> setAttributes ( $ this -> getAttributes ( $ product ) ) ; $ productObject -> setVariantConfiguration ( $ this -> getVariantConfiguration ( $ variations ) ) ; $ result [ $ productObject -> getIdentifier ( ) ] = $ productObject ; $ candidatesForProcessing = $ this -> addProductAttributesToVariation ( $ productObject , $ candidatesForProcessing ) ; return array_merge ( $ result , $ candidatesForProcessing ) ; } 
private function addProductAttributesToVariation ( Product $ product , array $ candidatesForProcessing = [ ] ) { return array_map ( function ( TransferObjectInterface $ object ) use ( $ product ) { if ( ! ( $ object instanceof Variation ) ) { return $ object ; } $ object -> setAttributes ( array_merge ( $ object -> getAttributes ( ) , $ product -> getAttributes ( ) ) ) ; return $ object ; } , $ candidatesForProcessing ) ; } 
private function getVatRateIdentifier ( array $ variation ) { $ vatRateIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ variation [ 'vatId' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => VatRate :: TYPE , ] ) ; if ( null === $ vatRateIdentity ) { throw new NotFoundException ( 'missing mapping for vat rate' ) ; } return $ vatRateIdentity -> getObjectIdentifier ( ) ; } 
private function getManufacturerIdentifier ( array $ product ) { $ manufacturerIdentity = $ this -> identityService -> findOneOrCreate ( ( string ) $ product [ 'manufacturerId' ] , PlentymarketsAdapter :: NAME , Manufacturer :: TYPE ) ; if ( null === $ manufacturerIdentity ) { throw new NotFoundException ( 'missing mapping for manufacturer' ) ; } return $ manufacturerIdentity -> getObjectIdentifier ( ) ; } 
private function getShippingProfiles ( array $ product ) { $ shippingProfiles = [ ] ; foreach ( $ product [ 'itemShippingProfiles' ] as $ profile ) { $ profileIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ profile [ 'profileId' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => ShippingProfile :: TYPE , ] ) ; if ( null === $ profileIdentity ) { continue ; } $ shippingProfiles [ ] = $ profileIdentity -> getObjectIdentifier ( ) ; } return $ shippingProfiles ; } 
private function getImages ( array $ product , array $ texts , array & $ result ) { $ images = [ ] ; foreach ( $ product [ 'itemImages' ] as $ entry ) { $ images [ ] = $ this -> imageResponseParser -> parseImage ( $ entry , $ texts , $ result ) ; } return array_filter ( $ images ) ; } 
private function getDafaultCategories ( array $ mainVariation ) { $ defaultCategories = [ ] ; foreach ( $ mainVariation [ 'variationDefaultCategory' ] as $ category ) { $ categoryIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ category [ 'branchId' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Category :: TYPE , ] ) ; if ( null === $ categoryIdentity ) { $ this -> logger -> notice ( 'missing mapping for category' , [ 'category' => $ category ] ) ; continue ; } $ defaultCategories [ ] = $ categoryIdentity -> getObjectIdentifier ( ) ; } return $ defaultCategories ; } 
private function getProductTranslations ( array $ texts ) { $ translations = [ ] ; foreach ( $ texts as $ text ) { $ languageIdentifier = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ text [ 'lang' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null === $ languageIdentifier ) { continue ; } $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'name' , 'value' => $ text [ 'name1' ] , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'description' , 'value' => $ text [ 'metaDescription' ] , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'longDescription' , 'value' => $ text [ 'description' ] , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'metaTitle' , 'value' => $ text [ 'name1' ] , ] ) ; $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'metaKeywords' , 'value' => $ text [ 'keywords' ] , ] ) ; } return $ translations ; } 
private function getLinkedProducts ( array $ product ) { $ result = [ ] ; foreach ( $ product [ 'itemCrossSelling' ] as $ linkedProduct ) { if ( $ linkedProduct [ 'relationship' ] === 'Similar' ) { $ type = LinkedProduct :: TYPE_SIMILAR ; } elseif ( $ linkedProduct [ 'relationship' ] === 'Accessory' ) { $ type = LinkedProduct :: TYPE_ACCESSORY ; } elseif ( $ linkedProduct [ 'relationship' ] === 'ReplacementPart' ) { $ type = LinkedProduct :: TYPE_REPLACEMENT ; } else { continue ; } $ productIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ linkedProduct [ 'crossItemId' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Product :: TYPE , ] ) ; if ( null === $ productIdentity ) { $ this -> logger -> notice ( 'linked product not found' , [ 'linkedProduct' => $ linkedProduct ] ) ; continue ; } $ result [ ] = LinkedProduct :: fromArray ( [ 'type' => $ type , 'productIdentifier' => $ productIdentity -> getObjectIdentifier ( ) , ] ) ; } return $ result ; } 
private function getProperties ( array $ mainVariation ) { $ result = [ ] ; $ properties = $ mainVariation [ 'variationProperties' ] ; foreach ( $ properties as $ property ) { if ( ! $ property [ 'property' ] [ 'isSearchable' ] ) { continue ; } $ backendName = $ property [ 'property' ] [ 'backendName' ] ; $ values = [ ] ; $ translations = [ ] ; if ( $ property [ 'property' ] [ 'valueType' ] === 'empty' && null !== $ property [ 'property' ] [ 'propertyGroupId' ] ) { $ propertyGroupNames = $ this -> itemsPropertiesGroupsNamesApi -> findOne ( $ property [ 'property' ] [ 'propertyGroupId' ] ) ; if ( empty ( $ propertyGroupNames [ 0 ] [ 'name' ] ) ) { continue ; } $ backendName = $ propertyGroupNames [ 0 ] [ 'name' ] ; foreach ( $ propertyGroupNames as $ name ) { $ languageIdentifier = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ name [ 'lang' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null === $ languageIdentifier ) { continue ; } $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'name' , 'value' => $ name [ 'name' ] , ] ) ; } $ propertyNames = $ this -> itemsPropertiesNamesApi -> findOne ( $ property [ 'property' ] [ 'id' ] ) ; $ valueTranslations = [ ] ; foreach ( $ propertyNames as $ name ) { $ languageIdentifier = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ name [ 'lang' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null === $ languageIdentifier ) { continue ; } $ valueTranslations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'value' , 'value' => $ name [ 'name' ] , ] ) ; } $ values [ ] = Value :: fromArray ( [ 'value' => ( string ) $ property [ 'property' ] [ 'backendName' ] , 'translations' => $ valueTranslations , ] ) ; } elseif ( $ property [ 'property' ] [ 'valueType' ] === 'text' ) { if ( empty ( $ property [ 'names' ] [ 0 ] [ 'value' ] ) ) { continue ; } $ valueTranslations = [ ] ; foreach ( $ property [ 'names' ] as $ name ) { $ languageIdentifier = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ name [ 'lang' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null === $ languageIdentifier ) { continue ; } $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'name' , 'value' => $ property [ 'property' ] [ 'backendName' ] , ] ) ; $ valueTranslations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'value' , 'value' => $ name [ 'value' ] , ] ) ; } $ values [ ] = Value :: fromArray ( [ 'value' => ( string ) $ property [ 'names' ] [ 0 ] [ 'value' ] , 'translations' => $ valueTranslations , ] ) ; } elseif ( $ property [ 'property' ] [ 'valueType' ] === 'selection' ) { if ( null === $ property [ 'propertySelectionId' ] ) { continue ; } $ valueTranslations = [ ] ; foreach ( $ property [ 'propertySelection' ] as $ selection ) { $ languageIdentifier = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ selection [ 'lang' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null === $ languageIdentifier ) { continue ; } $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'name' , 'value' => $ property [ 'property' ] [ 'backendName' ] , ] ) ; $ valueTranslations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'value' , 'value' => $ selection [ 'name' ] , ] ) ; } $ values [ ] = Value :: fromArray ( [ 'value' => ( string ) $ property [ 'propertySelection' ] [ 0 ] [ 'name' ] , 'translations' => $ valueTranslations , ] ) ; } elseif ( $ property [ 'property' ] [ 'valueType' ] === 'int' ) { if ( null === $ property [ 'valueInt' ] ) { continue ; } $ values [ ] = Value :: fromArray ( [ 'value' => ( string ) $ property [ 'valueInt' ] , ] ) ; } elseif ( $ property [ 'property' ] [ 'valueType' ] === 'float' ) { if ( null === $ property [ 'valueFloat' ] ) { continue ; } $ values [ ] = Value :: fromArray ( [ 'value' => ( string ) $ property [ 'valueFloat' ] , ] ) ; } elseif ( $ property [ 'property' ] [ 'valueType' ] === 'file' ) { $ this -> logger -> notice ( 'file properties are not supported' , [ 'variation' , $ mainVariation [ 'id' ] ] ) ; continue ; } $ result [ ] = Property :: fromArray ( [ 'name' => $ backendName , 'values' => $ values , 'translations' => $ translations , ] ) ; } return $ result ; } 
private function getActive ( array $ variations , array $ mainVariation ) { $ checkActiveMainVariation = json_decode ( $ this -> configService -> get ( 'check_active_main_variation' ) ) ; if ( $ checkActiveMainVariation && ! $ mainVariation [ 'isActive' ] ) { return false ; } foreach ( $ variations as $ variation ) { if ( $ variation -> getActive ( ) ) { return true ; } } return false ; } 
private function getVariantConfiguration ( array $ variations = [ ] ) { $ properties = [ [ ] ] ; foreach ( $ variations as $ variation ) { $ properties [ ] = $ variation -> getProperties ( ) ; } return array_merge ( ... $ properties ) ; } 
private function getAttributes ( array $ product ) { $ attributes = [ ] ; for ( $ i = 0 ; $ i < 20 ; ++ $ i ) { $ key = 'free' . ( $ i + 1 ) ; if ( ! array_key_exists ( $ key , $ product ) ) { continue ; } $ attributes [ ] = Attribute :: fromArray ( [ 'key' => $ key , 'value' => ( string ) $ product [ $ key ] , ] ) ; } $ attributes [ ] = $ this -> getShortDescriptionAsAttribute ( $ product ) ; $ attributes [ ] = $ this -> getTechnicalDataAsAttribute ( $ product ) ; $ attributes [ ] = $ this -> getAgeRestrictionAsAttribute ( $ product ) ; $ attributes [ ] = $ this -> getSecondProductNameAsAttribute ( $ product ) ; $ attributes [ ] = $ this -> getThirdProductNameAsAttribute ( $ product ) ; $ attributes [ ] = $ this -> getItemIdAsAttribute ( $ product ) ; return $ attributes ; } 
private function getThirdProductNameAsAttribute ( array $ product ) { $ translations = [ ] ; foreach ( $ product [ 'texts' ] as $ text ) { $ languageIdentifier = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ text [ 'lang' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null === $ languageIdentifier ) { continue ; } $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'value' , 'value' => $ text [ 'name3' ] , ] ) ; } $ attribute = new Attribute ( ) ; $ attribute -> setKey ( 'thirdProductName' ) ; $ attribute -> setValue ( ( string ) $ product [ 'texts' ] [ 0 ] [ 'name3' ] ) ; $ attribute -> setTranslations ( $ translations ) ; return $ attribute ; } 
private function getAgeRestrictionAsAttribute ( array $ product ) { $ attribute = new Attribute ( ) ; $ attribute -> setKey ( 'ageRestriction' ) ; $ attribute -> setValue ( ( string ) $ product [ 'ageRestriction' ] ) ; return $ attribute ; } 
private function getItemIdAsAttribute ( array $ product ) { $ attribute = new Attribute ( ) ; $ attribute -> setKey ( 'itemId' ) ; $ attribute -> setValue ( ( string ) $ product [ 'id' ] ) ; return $ attribute ; } 
private function getBadges ( array $ product ) { if ( $ product [ 'storeSpecial' ] === 3 ) { $ badge = new Badge ( ) ; $ badge -> setType ( Badge :: TYPE_HIGHLIGHT ) ; return [ $ badge ] ; } return [ ] ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ this -> outputHandler -> initialize ( $ input , $ output ) ; $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ input -> getArgument ( 'identifier' ) , ] ) ; if ( null === $ identity ) { $ this -> outputHandler -> writeLine ( 'could not find identity for identifier' ) ; return ; } $ i = 1 ; $ definitions = $ this -> definitionProvider -> getConnectorDefinitions ( $ identity -> getObjectType ( ) ) ; foreach ( $ definitions as $ definition ) { $ result = $ this -> serviceBus -> handle ( new FetchTransferObjectQuery ( $ definition -> getOriginAdapterName ( ) , $ definition -> getObjectType ( ) , QueryType :: ONE , $ input -> getArgument ( 'identifier' ) ) ) ; if ( ! $ result ) { $ this -> outputHandler -> writeLine ( 'could not find TransferObject' ) ; continue ; } foreach ( $ result as $ item ) { $ this -> outputHandler -> writeLine ( ) ; $ this -> outputHandler -> writeLine ( sprintf ( 'TransferObject %s:' , $ i ++ ) ) ; $ this -> outputHandler -> writeLine ( json_encode ( $ item , JSON_PRETTY_PRINT ) ) ; } } } 
public function get ( $ key , $ default = null ) { $ storage = reset ( $ this -> storages ) ; $ result = $ storage -> get ( $ key ) ; if ( $ result !== null ) { return $ result ; } return $ default ; } 
public function set ( $ key , $ value ) { $ storage = reset ( $ this -> storages ) ; $ storage -> set ( $ key , $ value ) ; } 
public function findOneBy ( array $ criteria = [ ] ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) ; $ queryBuilder -> from ( $ this -> table , 'identity' ) ; $ queryBuilder -> select ( [ 'identity.objectIdentifier' , 'identity.objectType' , 'identity.adapterIdentifier' , 'identity.adapterName' , ] ) ; $ queryBuilder -> setMaxResults ( 1 ) ; foreach ( $ criteria as $ key => $ value ) { $ queryBuilder -> andWhere ( $ queryBuilder -> expr ( ) -> eq ( $ key , ':' . $ key ) ) ; $ queryBuilder -> setParameter ( ':' . $ key , $ value ) ; } $ result = $ queryBuilder -> execute ( ) -> fetch ( ) ; if ( ! empty ( $ result ) ) { return Identity :: fromArray ( [ 'objectIdentifier' => $ result [ 'objectIdentifier' ] , 'objectType' => $ result [ 'objectType' ] , 'adapterIdentifier' => $ result [ 'adapterIdentifier' ] , 'adapterName' => $ result [ 'adapterName' ] , ] ) ; } return null ; } 
public function findBy ( array $ criteria = [ ] ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) ; $ queryBuilder -> from ( $ this -> table , 'identity' ) ; $ queryBuilder -> select ( [ 'identity.objectIdentifier' , 'identity.objectType' , 'identity.adapterIdentifier' , 'identity.adapterName' , ] ) ; foreach ( $ criteria as $ key => $ value ) { $ queryBuilder -> andWhere ( $ queryBuilder -> expr ( ) -> eq ( $ key , ':' . $ key ) ) ; $ queryBuilder -> setParameter ( ':' . $ key , $ value ) ; } $ result = $ queryBuilder -> execute ( ) -> fetchAll ( ) ; return array_map ( function ( array $ result ) { return Identity :: fromArray ( [ 'objectIdentifier' => $ result [ 'objectIdentifier' ] , 'objectType' => $ result [ 'objectType' ] , 'adapterIdentifier' => $ result [ 'adapterIdentifier' ] , 'adapterName' => $ result [ 'adapterName' ] , ] ) ; } , $ result ) ; } 
public function insert ( Identity $ identity ) { $ this -> connection -> insert ( $ this -> table , [ 'adapterIdentifier' => $ identity -> getAdapterIdentifier ( ) , 'adapterName' => $ identity -> getAdapterName ( ) , 'objectIdentifier' => $ identity -> getObjectIdentifier ( ) , 'objectType' => $ identity -> getObjectType ( ) , ] ) ; } 
public function update ( Identity $ identity , array $ data = [ ] ) { $ this -> connection -> update ( $ this -> table , $ data , [ 'adapterIdentifier' => $ identity -> getAdapterIdentifier ( ) , 'adapterName' => $ identity -> getAdapterName ( ) , 'objectIdentifier' => $ identity -> getObjectIdentifier ( ) , 'objectType' => $ identity -> getObjectType ( ) , ] ) ; } 
public function remove ( Identity $ identity ) { $ this -> connection -> delete ( $ this -> table , [ 'adapterIdentifier' => $ identity -> getAdapterIdentifier ( ) , 'adapterName' => $ identity -> getAdapterName ( ) , 'objectIdentifier' => $ identity -> getObjectIdentifier ( ) , 'objectType' => $ identity -> getObjectType ( ) , ] ) ; } 
public function parseImage ( array $ entry , array $ texts , array & $ result ) { try { if ( ! empty ( $ entry [ 'names' ] [ 0 ] [ 'name' ] ) ) { $ name = $ entry [ 'names' ] [ 0 ] [ 'name' ] ; } else { $ name = $ texts [ 0 ] [ 'name1' ] ; } $ alternate = $ name ; if ( ! empty ( $ entry [ 'names' ] [ 0 ] [ 'alternate' ] ) ) { $ alternate = $ entry [ 'names' ] [ 0 ] [ 'alternate' ] ; } $ media = $ this -> mediaResponseParser -> parse ( [ 'mediaCategory' => MediaCategoryHelper :: PRODUCT , 'id' => $ entry [ 'id' ] , 'link' => $ entry [ 'url' ] , 'filename' => $ entry [ 'cleanImageName' ] , 'name' => $ name , 'hash' => $ entry [ 'md5Checksum' ] , 'alternateName' => $ alternate , 'translations' => $ this -> getMediaTranslations ( $ entry , $ texts ) , ] ) ; $ result [ $ media -> getIdentifier ( ) ] = $ media ; $ linkedShops = array_filter ( $ entry [ 'availabilities' ] , function ( array $ availabilitiy ) { return $ availabilitiy [ 'type' ] === 'mandant' ; } ) ; $ shopIdentifiers = array_map ( function ( $ shop ) { $ shopIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ shop [ 'value' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Shop :: TYPE , ] ) ; if ( null === $ shopIdentity ) { return null ; } return $ shopIdentity -> getObjectIdentifier ( ) ; } , $ linkedShops ) ; $ image = new Image ( ) ; $ image -> setMediaIdentifier ( $ media -> getIdentifier ( ) ) ; $ image -> setShopIdentifiers ( array_filter ( $ shopIdentifiers ) ) ; $ image -> setPosition ( ( int ) $ entry [ 'position' ] ) ; $ image -> setName ( $ name ) ; $ image -> setTranslations ( $ media -> getTranslations ( ) ) ; return $ image ; } catch ( Exception $ exception ) { $ this -> logger -> notice ( 'error when parsing product image' , [ 'id' => $ entry [ 'id' ] , 'url' => $ entry [ 'url' ] , ] ) ; } return null ; } 
private function getMediaTranslations ( array $ image , array $ productTexts ) { $ translations = [ ] ; foreach ( $ image [ 'names' ] as $ text ) { $ languageIdentifier = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ text [ 'lang' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null === $ languageIdentifier ) { continue ; } if ( ! empty ( $ text [ 'name' ] ) ) { $ name = $ text [ 'name' ] ; } else { $ name = '' ; foreach ( $ productTexts as $ productText ) { if ( $ text [ 'lang' ] === $ productText [ 'lang' ] ) { $ name = $ productText [ 'name1' ] ; } } } $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'name' , 'value' => $ name , ] ) ; if ( ! empty ( $ text [ 'alternate' ] ) ) { $ alternate = $ text [ 'alternate' ] ; } else { $ alternate = '' ; foreach ( $ productTexts as $ productText ) { if ( $ text [ 'lang' ] === $ productText [ 'lang' ] ) { $ alternate = $ productText [ 'name1' ] ; } } } $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'alternateName' , 'value' => $ alternate , ] ) ; } return $ translations ; } 
public function addFieldAsAttribute ( AttributableInterface $ object , $ fieldName ) { if ( ! method_exists ( $ object , 'getAttributes' ) ) { return ; } $ method = 'get' . ucfirst ( $ fieldName ) ; if ( ! method_exists ( $ object , $ method ) ) { return ; } $ fieldValue = $ object -> $ method ( ) ; if ( null === $ fieldValue ) { return ; } $ attribute = new Attribute ( ) ; $ attribute -> setKey ( $ fieldName ) ; $ attribute -> setValue ( $ fieldValue ) ; if ( $ object instanceof TranslateableInterface ) { $ translations = $ object -> getTranslations ( ) ; $ newTranslations = [ ] ; foreach ( $ translations as $ translation ) { if ( $ fieldName === $ translation -> getProperty ( ) ) { $ newTranslation = clone $ translation ; $ newTranslation -> setProperty ( 'value' ) ; $ newTranslations [ ] = $ newTranslation ; } } $ attribute -> setTranslations ( $ newTranslations ) ; } $ this -> validator -> validate ( $ attribute ) ; $ object -> setAttributes ( array_merge ( $ object -> getAttributes ( ) , [ $ attribute ] ) ) ; } 
private function getPayPalUnifiedInstallmentData ( $ paymentId ) { try { $ query = 'SELECT * FROM swag_payment_paypal_unified_financing_information WHERE payment_id = ?' ; return $ this -> connection -> fetchAssoc ( $ query , [ $ paymentId ] ) ; } catch ( Exception $ exception ) { return false ; } } 
public function generate ( Variation $ variation ) { $ unitIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ variation -> getUnitIdentifier ( ) , 'objectType' => Unit :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ unitIdentity ) { throw new NotFoundException ( 'Missing unit mapping - ' . $ variation -> getNumber ( ) ) ; } $ productIdentitiy = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ variation -> getProductIdentifier ( ) , 'objectType' => Product :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ productIdentitiy ) { throw new NotFoundException ( 'Missing product for variation - ' . $ variation -> getProductIdentifier ( ) ) ; } $ shopwareVariation = [ 'articleId' => $ productIdentitiy -> getAdapterIdentifier ( ) , 'number' => $ variation -> getNumber ( ) , 'position' => $ variation -> getPosition ( ) , 'unitId' => $ unitIdentity -> getAdapterIdentifier ( ) , 'active' => $ variation -> getActive ( ) , 'kind' => $ variation -> isMain ( ) ? 1 : 2 , 'isMain' => $ variation -> isMain ( ) , 'lastStock' => $ variation -> hasStockLimitation ( ) , 'standard' => $ variation -> isMain ( ) , 'shippingtime' => $ variation -> getShippingTime ( ) , 'prices' => $ this -> getPrices ( $ variation ) , 'supplierNumber' => $ variation -> getModel ( ) , 'purchasePrice' => $ variation -> getPurchasePrice ( ) , 'weight' => $ variation -> getWeight ( ) , 'len' => $ variation -> getLength ( ) , 'height' => $ variation -> getHeight ( ) , 'width' => $ variation -> getWidth ( ) , 'images' => $ this -> getImages ( $ variation ) , 'purchaseUnit' => $ variation -> getContent ( ) , 'referenceUnit' => $ variation -> getReferenceAmount ( ) , 'minPurchase' => $ variation -> getMinimumOrderQuantity ( ) , 'purchaseSteps' => $ variation -> getIntervalOrderQuantity ( ) , 'maxPurchase' => $ variation -> getMaximumOrderQuantity ( ) , '__options_prices' => [ 'replace' => true ] , '__options_images' => [ 'replace' => true ] , ] ; $ releaseData = $ variation -> getReleaseDate ( ) ; if ( null !== $ releaseData ) { $ shopwareVariation [ 'releaseDate' ] = $ releaseData -> format ( DATE_W3C ) ; } $ configuratorOptions = $ this -> getConfiguratorOptions ( $ variation ) ; if ( ! empty ( $ configuratorOptions ) ) { $ shopwareVariation [ 'configuratorOptions' ] = $ configuratorOptions ; } $ barcodes = array_filter ( $ variation -> getBarcodes ( ) , function ( Barcode $ barcode ) { return $ barcode -> getType ( ) === Barcode :: TYPE_GTIN13 ; } ) ; if ( ! empty ( $ barcodes ) ) { $ barcode = array_shift ( $ barcodes ) ; $ shopwareVariation [ 'ean' ] = $ barcode -> getCode ( ) ; } return $ shopwareVariation ; } 
private function getPrices ( Variation $ variation ) { $ prices = [ ] ; foreach ( $ variation -> getPrices ( ) as $ price ) { if ( null === $ price -> getCustomerGroupIdentifier ( ) ) { $ customerGroupKey = 'EK' ; } else { $ customerGroupIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ price -> getCustomerGroupIdentifier ( ) , 'objectType' => CustomerGroup :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ customerGroupIdentity ) { continue ; } $ customerGroupKey = $ this -> customerGroupDataProvider -> getCustomerGroupKeyByShopwareIdentifier ( $ customerGroupIdentity -> getAdapterIdentifier ( ) ) ; if ( null === $ customerGroupKey ) { continue ; } } $ prices [ ] = [ 'customerGroupKey' => $ customerGroupKey , 'price' => $ price -> getPrice ( ) , 'pseudoPrice' => $ price -> getPseudoPrice ( ) , 'from' => $ price -> getFromAmount ( ) , 'to' => $ price -> getToAmount ( ) , ] ; } return $ prices ; } 
private function getImages ( Variation $ variation ) { $ images = [ ] ; foreach ( $ variation -> getImages ( ) as $ image ) { $ shopIdentifiers = array_filter ( $ image -> getShopIdentifiers ( ) , function ( $ shop ) { $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ shop , 'objectType' => Shop :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; return $ identity !== null ; } ) ; if ( empty ( $ shopIdentifiers ) ) { continue ; } $ imageIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ image -> getMediaIdentifier ( ) , 'objectType' => Media :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ imageIdentity ) { continue ; } $ images [ ] = [ 'mediaId' => $ imageIdentity -> getAdapterIdentifier ( ) , 'position' => $ image -> getPosition ( ) , ] ; } return $ images ; } 
private function getConfiguratorOptions ( Variation $ variation ) { $ configuratorOptions = [ ] ; foreach ( $ variation -> getProperties ( ) as $ property ) { foreach ( $ property -> getValues ( ) as $ value ) { $ configuratorOptions [ ] = [ 'groupId' => null , 'group' => $ property -> getName ( ) , 'optionId' => null , 'option' => $ value -> getValue ( ) , ] ; } } return $ configuratorOptions ; } 
public function parse ( array $ product ) { $ bundleVariations = array_filter ( $ product [ 'variations' ] , function ( array $ variation ) { return $ variation [ 'bundleType' ] === 'bundle' ; } ) ; if ( empty ( $ bundleVariations ) ) { return [ ] ; } $ bundles = [ ] ; foreach ( $ bundleVariations as $ bundle ) { if ( empty ( $ this -> variationHelper -> getShopIdentifiers ( $ bundle ) ) ) { continue ; } $ bundles [ ] = $ this -> parseBundle ( $ bundle , $ product ) ; } return array_filter ( $ bundles ) ; } 
private function parseBundle ( array $ variation , array $ product ) { $ identity = $ this -> identityService -> findOneOrCreate ( ( string ) $ variation [ 'id' ] , PlentymarketsAdapter :: NAME , Bundle :: TYPE ) ; $ productIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ product [ 'id' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Product :: TYPE , ] ) ; if ( null === $ productIdentity ) { $ this -> logger -> notice ( 'product not found' , [ 'bundle' => $ variation ] ) ; return null ; } $ bundle = new Bundle ( ) ; $ bundle -> setIdentifier ( $ identity -> getObjectIdentifier ( ) ) ; $ bundle -> setName ( $ product [ 'texts' ] [ 0 ] [ 'name1' ] ) ; $ bundle -> setNumber ( $ variation [ 'number' ] ) ; $ bundle -> setPosition ( $ variation [ 'position' ] ) ; $ bundle -> setStockLimitation ( ( bool ) $ variation [ 'stockLimitation' ] ) ; $ bundle -> setPrices ( $ this -> priceResponseParser -> parse ( $ variation ) ) ; $ bundle -> setVatRateIdentifier ( $ this -> getVatRateIdentifier ( $ variation ) ) ; $ bundle -> setProductIdentifier ( $ productIdentity -> getObjectIdentifier ( ) ) ; $ bundle -> setAvailableFrom ( $ this -> getAvailableFrom ( $ variation ) ) ; $ bundle -> setAvailableTo ( $ this -> getAvailableTo ( $ variation ) ) ; $ bundle -> setBundleProducts ( $ this -> getBundleProducts ( $ variation ) ) ; $ bundle -> setTranslations ( $ this -> getTranslations ( $ product ) ) ; return $ bundle ; } 
private function getTranslations ( array $ product ) { $ translations = [ ] ; foreach ( $ product [ 'texts' ] as $ text ) { $ languageIdentifier = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ text [ 'lang' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null === $ languageIdentifier ) { continue ; } $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'name' , 'value' => $ text [ 'name1' ] , ] ) ; } return $ translations ; } 
private function getBundleProducts ( array $ variation ) { $ url = 'items/' . $ variation [ 'itemId' ] . '/variations/' . $ variation [ 'id' ] . '/variation_bundles' ; $ elements = $ this -> client -> request ( 'GET' , $ url ) ; $ this -> addProductNumberToResponse ( $ elements ) ; $ result = [ ] ; foreach ( $ elements as $ element ) { $ bundleProduct = new BundleProduct ( ) ; $ bundleProduct -> setAmount ( ( float ) $ element [ 'componentQuantity' ] ) ; $ bundleProduct -> setNumber ( $ element [ 'number' ] ) ; $ result [ ] = $ bundleProduct ; } return $ result ; } 
public function parse ( array $ entry ) { $ identity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ entry [ 'id' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Order :: TYPE , ] ) ; if ( ! $ identity ) { return [ ] ; } $ shopIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ entry [ 'plentyId' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Shop :: TYPE , ] ) ; if ( null === $ shopIdentity ) { $ this -> logger -> notice ( 'unknown shop' ) ; return [ ] ; } $ isMappedShopIdentity = $ this -> identityService -> isMappedIdentity ( $ shopIdentity -> getObjectIdentifier ( ) , $ shopIdentity -> getObjectType ( ) , $ shopIdentity -> getAdapterName ( ) ) ; if ( ! $ isMappedShopIdentity ) { return [ ] ; } $ orderNumber = $ this -> getOrdernumber ( $ entry ) ; if ( null === $ orderNumber ) { return [ ] ; } $ shippingProfileIdentity = $ this -> getShippingProfileIdentity ( $ entry ) ; if ( null === $ shippingProfileIdentity ) { $ this -> logger -> notice ( 'no shipping profile found' , [ 'entry' => $ entry ] ) ; return [ ] ; } $ currencyIdentity = $ this -> getCurrencyIdentity ( $ entry ) ; if ( null === $ currencyIdentity ) { $ this -> logger -> notice ( 'no currency found' , [ 'entry' => $ entry ] ) ; return [ ] ; } $ paymentMethodIdentity = $ this -> getPaymentMethodIdentity ( $ entry ) ; if ( null === $ paymentMethodIdentity ) { $ this -> logger -> notice ( 'no payment method found' , [ 'entry' => $ entry ] ) ; return [ ] ; } $ paymentStatusIdentity = $ this -> getPaymentStatusIdentity ( $ entry ) ; if ( null === $ paymentStatusIdentity ) { $ this -> logger -> notice ( 'no payment status found' , [ 'entry' => $ entry ] ) ; return [ ] ; } $ oderStatusIdentity = $ this -> getOrderStatusIdentity ( $ entry ) ; if ( null === $ oderStatusIdentity ) { $ this -> logger -> notice ( 'no order status found' , [ 'entry' => $ entry ] ) ; return [ ] ; } $ entry [ 'customerData' ] = $ this -> getCustomerData ( $ entry ) ; if ( empty ( $ entry [ 'customerData' ] ) ) { $ this -> logger -> notice ( 'no customer found' , [ 'entry' => $ entry ] ) ; return [ ] ; } $ entry [ 'billingAddressData' ] = $ this -> getBillingAddressData ( $ entry ) ; if ( empty ( $ entry [ 'billingAddressData' ] ) ) { $ this -> logger -> notice ( 'no billing address found' , [ 'entry' => $ entry ] ) ; return [ ] ; } $ entry [ 'shippingAddressData' ] = $ this -> getShippingAddressData ( $ entry ) ; if ( empty ( $ entry [ 'shippingAddressData' ] ) ) { $ this -> logger -> notice ( 'no shipping address found' , [ 'entry' => $ entry ] ) ; return [ ] ; } $ customer = $ this -> getCustomer ( $ entry ) ; if ( null === $ customer ) { $ this -> logger -> notice ( 'no customer found' , [ 'entry' => $ entry ] ) ; return [ ] ; } $ order = new Order ( ) ; $ order -> setIdentifier ( $ identity -> getObjectIdentifier ( ) ) ; $ order -> setOrderNumber ( $ orderNumber ) ; $ order -> setOrderTime ( $ this -> getOrderTime ( $ entry ) ) ; $ order -> setCustomer ( $ customer ) ; $ order -> setOrderItems ( $ this -> getOrderItems ( $ entry ) ) ; $ order -> setShopIdentifier ( $ shopIdentity -> getObjectIdentifier ( ) ) ; $ order -> setCurrencyIdentifier ( $ currencyIdentity -> getObjectIdentifier ( ) ) ; $ order -> setOrderStatusIdentifier ( $ oderStatusIdentity -> getObjectIdentifier ( ) ) ; $ order -> setPaymentStatusIdentifier ( $ paymentStatusIdentity -> getObjectIdentifier ( ) ) ; $ order -> setPaymentMethodIdentifier ( $ paymentMethodIdentity -> getObjectIdentifier ( ) ) ; $ order -> setShippingProfileIdentifier ( $ shippingProfileIdentity -> getObjectIdentifier ( ) ) ; $ order -> setComments ( $ this -> getComments ( $ entry ) ) ; $ order -> setPackages ( $ this -> getPackages ( $ entry ) ) ; $ order -> setAttributes ( [ ] ) ; $ billingAddress = $ this -> getBillingAddress ( $ entry ) ; if ( null !== $ billingAddress ) { $ order -> setBillingAddress ( $ billingAddress ) ; } $ shippingAddress = $ this -> getShippingAddress ( $ entry ) ; if ( null !== $ shippingAddress ) { $ order -> setShippingAddress ( $ shippingAddress ) ; } return [ $ order ] ; } 
private function getBillingAddressData ( array $ entry ) { $ billingAddress = array_filter ( $ entry [ 'addresses' ] , function ( array $ address ) { return $ address [ 'pivot' ] [ 'typeId' ] === 1 ; } ) ; if ( empty ( $ billingAddress ) ) { return [ ] ; } return array_shift ( $ billingAddress ) ; } 
private function getShippingAddressData ( array $ entry ) { $ shippingAddress = array_filter ( $ entry [ 'addresses' ] , function ( array $ address ) { return $ address [ 'pivot' ] [ 'typeId' ] === 2 ; } ) ; if ( empty ( $ shippingAddress ) ) { return [ ] ; } return array_shift ( $ shippingAddress ) ; } 
private function getCustomerData ( array $ entry ) { $ relations = array_filter ( $ entry [ 'relations' ] , function ( array $ relation ) { return $ relation [ 'referenceType' ] === 'contact' ; } ) ; if ( empty ( $ relations ) ) { return [ ] ; } $ relation = array_shift ( $ relations ) ; return $ this -> customerApi -> find ( $ relation [ 'referenceId' ] ) ; } 
private function getOrdernumber ( array $ entry ) { $ property = array_filter ( $ entry [ 'properties' ] , function ( array $ property ) { return $ property [ 'typeId' ] === 7 ; } ) ; if ( ! empty ( $ property ) ) { $ property = array_shift ( $ property ) ; return $ property [ 'value' ] ; } return null ; } 
private function getLanguageIdentity ( array $ entry ) { $ property = array_filter ( $ entry [ 'properties' ] , function ( array $ property ) { return $ property [ 'typeId' ] === 6 ; } ) ; if ( ! empty ( $ property ) ) { $ property = array_shift ( $ property ) ; return $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ property [ 'value' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; } return null ; } 
private function getComments ( array $ entry ) { $ result = [ ] ; foreach ( $ entry [ 'comments' ] as $ data ) { $ comment = new Comment ( ) ; $ comment -> setComment ( ( string ) $ data [ 'text' ] ) ; $ comment -> setType ( $ data [ 'text' ] ? Comment :: TYPE_CUSTOMER : Comment :: TYPE_INTERNAL ) ; $ result [ ] = $ comment ; } return $ result ; } 
private function getCustomer ( array $ entry ) { $ languageIdentity = $ this -> getLanguageIdentity ( $ entry ) ; if ( null === $ languageIdentity ) { $ this -> logger -> info ( 'language of customer not found' , [ 'entry' => $ entry , ] ) ; return null ; } $ cutomerGroupIdentity = $ this -> getCustomerGroupIdentity ( $ entry [ 'customerData' ] ) ; if ( null === $ cutomerGroupIdentity ) { $ this -> logger -> info ( 'customer group not found' , [ 'entry' => $ entry , ] ) ; return null ; } $ shopIdentity = $ this -> getShopIdentity ( $ entry [ 'customerData' ] ) ; if ( null === $ shopIdentity ) { $ this -> logger -> info ( 'customer shop not found' , [ 'entry' => $ entry , ] ) ; return null ; } $ customer = new Customer ( ) ; $ customer -> setType ( Customer :: TYPE_NORMAL ) ; $ customer -> setNumber ( $ entry [ 'customerData' ] [ 'number' ] ) ; $ customer -> setEmail ( $ this -> getMail ( $ entry ) ) ; $ customer -> setLanguageIdentifier ( $ languageIdentity -> getObjectIdentifier ( ) ) ; $ customer -> setCustomerGroupIdentifier ( $ cutomerGroupIdentity -> getObjectIdentifier ( ) ) ; $ customer -> setGender ( $ entry [ 'customerData' ] [ 'gender' ] === 'male' ? Customer :: GENDER_MALE : Customer :: GENDER_FEMALE ) ; $ customer -> setFirstname ( $ entry [ 'customerData' ] [ 'firstName' ] ) ; $ customer -> setLastname ( $ entry [ 'customerData' ] [ 'lastName' ] ) ; $ customer -> setPhoneNumber ( $ this -> getPhoneNumber ( $ entry ) ) ; $ customer -> setMobilePhoneNumber ( $ this -> getMobilePhoneNumber ( $ entry ) ) ; $ customer -> setShopIdentifier ( $ shopIdentity -> getObjectIdentifier ( ) ) ; return $ customer ; } 
private function getShopIdentity ( array $ plentyCustomer ) { return $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ plentyCustomer [ 'plentyId' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Shop :: TYPE , ] ) ; } 
private function getCustomerGroupIdentity ( array $ plentyCustomer ) { return $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ plentyCustomer [ 'classId' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => CustomerGroup :: TYPE , ] ) ; } 
private function getShippingProfileIdentity ( array $ entry ) { foreach ( $ entry [ 'properties' ] as $ orderProperty ) { if ( $ orderProperty [ 'typeId' ] !== 2 ) { continue ; } if ( ! empty ( $ orderProperty [ 'value' ] ) ) { return $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ orderProperty [ 'value' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => ShippingProfile :: TYPE , ] ) ; } } return null ; } 
private function getCurrencyIdentity ( array $ entry ) { if ( empty ( $ entry [ 'amounts' ] ) ) { return null ; } $ amount = array_shift ( $ entry [ 'amounts' ] ) ; return $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ amount [ 'currency' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Currency :: TYPE , ] ) ; } 
private function getPaymentMethodIdentity ( array $ entry ) { $ property = array_filter ( $ entry [ 'properties' ] , function ( array $ property ) { return $ property [ 'typeId' ] === 3 ; } ) ; if ( ! empty ( $ property ) ) { $ property = array_shift ( $ property ) ; return $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ property [ 'value' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => PaymentMethod :: TYPE , ] ) ; } return null ; } 
private function getPaymentStatusIdentity ( array $ entry ) { $ property = array_filter ( $ entry [ 'properties' ] , function ( array $ property ) { return $ property [ 'typeId' ] === 4 ; } ) ; if ( ! empty ( $ property ) ) { 
private function getOrderStatusIdentity ( array $ entry ) { return $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ entry [ 'statusId' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => OrderStatus :: TYPE , ] ) ; } 
private function getOrderTime ( array $ entry ) { $ date = array_filter ( $ entry [ 'dates' ] , function ( array $ property ) { return $ property [ 'typeId' ] === 2 ; } ) ; if ( ! empty ( $ date ) ) { $ date = array_shift ( $ date ) ; return DateTimeImmutable :: createFromFormat ( DATE_W3C , $ date [ 'date' ] ) ; } return new DateTimeImmutable ( ) ; } 
private function getBillingAddress ( array $ entry ) { if ( empty ( $ entry [ 'billingAddressData' ] ) ) { return null ; } $ countryIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ entry [ 'billingAddressData' ] [ 'countryId' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Country :: TYPE , ] ) ; if ( null === $ countryIdentity ) { $ this -> logger -> error ( 'country not found' ) ; return null ; } $ street = $ entry [ 'billingAddressData' ] [ 'address1' ] . ' ' . $ entry [ 'billingAddressData' ] [ 'address2' ] . ' ' . $ entry [ 'billingAddressData' ] [ 'address3' ] ; $ address = new Address ( ) ; $ address -> setGender ( Customer :: GENDER_MALE ) ; $ address -> setFirstname ( $ entry [ 'billingAddressData' ] [ 'name2' ] ) ; $ address -> setLastname ( $ entry [ 'billingAddressData' ] [ 'name3' ] ) ; $ address -> setStreet ( trim ( $ street ) ) ; $ address -> setPostalCode ( $ entry [ 'billingAddressData' ] [ 'postalCode' ] ) ; $ address -> setCity ( $ entry [ 'billingAddressData' ] [ 'town' ] ) ; $ address -> setCountryIdentifier ( $ countryIdentity -> getObjectIdentifier ( ) ) ; $ address -> setPhoneNumber ( $ this -> getPhoneNumber ( $ entry ) ) ; $ address -> setMobilePhoneNumber ( $ this -> getMobilePhoneNumber ( $ entry ) ) ; return $ address ; } 
private function getPhoneNumber ( array $ entry ) { $ options = array_filter ( $ entry [ 'customerData' ] [ 'options' ] , function ( array $ option ) { return $ option [ 'typeId' ] === 1 && $ option [ 'subTypeId' ] === 4 ; } ) ; if ( ! empty ( $ options ) ) { $ option = array_shift ( $ options ) ; return $ option [ 'value' ] ; } return null ; } 
private function getMobilePhoneNumber ( array $ entry ) { $ options = array_filter ( $ entry [ 'customerData' ] [ 'options' ] , function ( array $ option ) { return $ option [ 'typeId' ] === 1 && $ option [ 'subTypeId' ] === 2 ; } ) ; if ( ! empty ( $ options ) ) { $ option = array_shift ( $ options ) ; return $ option [ 'value' ] ; } return null ; } 
private function getMail ( array $ entry ) { if ( empty ( $ entry [ 'billingAddressData' ] [ 'options' ] ) ) { return null ; } $ options = array_filter ( $ entry [ 'billingAddressData' ] [ 'options' ] , function ( array $ option ) { return $ option [ 'typeId' ] === 5 ; } ) ; if ( empty ( $ options ) ) { return null ; } $ option = array_shift ( $ options ) ; return $ option [ 'value' ] ; } 
private function getPackages ( array $ entry ) { $ numbers = $ this -> client -> request ( 'GET' , 'orders/' . $ entry [ 'id' ] . '/packagenumbers' ) ; $ shippingDate = array_filter ( $ entry [ 'dates' ] , function ( array $ date ) { return $ date [ 'typeId' ] === 8 ; } ) ; $ result = [ ] ; foreach ( $ numbers as $ number ) { $ package = new Package ( ) ; $ package -> setShippingCode ( ( string ) $ number ) ; $ package -> setShippingProvider ( ) ; if ( ! empty ( $ shippingDate ) ) { $ shippingDate = array_shift ( $ shippingDate ) ; $ package -> setShippingTime ( DateTimeImmutable :: createFromFormat ( DATE_ATOM , $ shippingDate [ 'date' ] ) ) ; } $ result [ ] = $ package ; } return $ result ; } 
private function getOrderItems ( array $ entry ) { $ result = [ ] ; foreach ( $ entry [ 'orderItems' ] as $ item ) { $ number = $ this -> getNumberFromVariation ( $ item [ 'itemVariationId' ] ) ; $ orderItem = new OrderItem ( ) ; $ orderItem -> setQuantity ( ( float ) $ item [ 'quantity' ] ) ; $ orderItem -> setName ( $ item [ 'orderItemName' ] ) ; $ orderItem -> setNumber ( $ number ) ; $ orderItem -> setPrice ( $ this -> getOrderItemPrice ( $ item ) ) ; $ orderItem -> setAttributes ( [ ] ) ; $ result [ ] = $ orderItem ; } return $ result ; } 
private function getNumberFromVariation ( $ variationId ) { static $ variations ; if ( ! isset ( $ variations [ $ variationId ] ) ) { $ response = $ this -> client -> request ( 'GET' , 'items/variations' , [ 'id' => $ variationId ] ) ; if ( empty ( $ response ) ) { $ variations [ $ variationId ] = null ; return $ variations [ $ variationId ] ; } $ variation = array_shift ( $ response ) ; $ variations [ $ variationId ] = $ variation [ 'number' ] ; } return $ variations [ $ variationId ] ; } 
public function findChanged ( DateTimeImmutable $ startTimestamp ) { $ elements = iterator_to_array ( $ this -> client -> getIterator ( 'categories' , [ 'with' => 'details,clients' , 'type' => 'item' , 'updatedAt' => $ startTimestamp -> format ( DATE_W3C ) , 'lang' => $ this -> languageHelper -> getLanguagesQueryString ( ) , ] ) ) ; $ this -> sortCategories ( $ elements ) ; return $ elements ; } 
public function current ( ) { $ element = $ this -> data [ $ this -> index ] ; unset ( $ this -> data [ $ this -> index ] ) ; return $ element ; } 
public function next ( ) { ++ $ this -> index ; if ( ! $ this -> isLastPage && ! $ this -> valid ( ) ) { $ this -> offset += $ this -> limit ; $ this -> loadPage ( $ this -> criteria , $ this -> limit , $ this -> offset ) ; } } 
public function rewind ( ) { $ this -> loadPage ( $ this -> criteria , $ this -> limit ) ; $ this -> offset = 0 ; $ this -> index = 0 ; } 
public function handle ( QueryInterface $ query ) { $ elements = $ this -> mediaCategoryHelper -> getCategories ( ) ; $ this -> outputHandler -> startProgressBar ( count ( $ elements ) ) ; foreach ( $ elements as $ element ) { try { $ result = $ this -> responseParser -> parse ( $ element ) ; } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; $ result = null ; } if ( null !== $ result ) { yield $ result ; } $ this -> outputHandler -> advanceProgressBar ( ) ; } $ this -> outputHandler -> finishProgressBar ( ) ; } 
public function handle ( QueryInterface $ query ) { $ elements = $ this -> client -> request ( 'GET' , 'orders/shipping/presets' ) ; foreach ( $ elements as $ element ) { $ result = $ this -> responseParser -> parse ( $ element ) ; if ( null === $ result ) { continue ; } yield $ result ; } } 
public function handle ( CommandInterface $ command ) { $ variation = $ command -> getPayload ( ) ; $ productIdentitiy = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ variation -> getProductIdentifier ( ) , 'objectType' => Product :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ productIdentitiy ) { return false ; } $ variationIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ variation -> getIdentifier ( ) , 'objectType' => Variation :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; $ variationResource = $ this -> getVariationResource ( ) ; $ variationParams = $ this -> variationRequestGenerator -> generate ( $ variation ) ; $ variationRepository = $ this -> entityManager -> getRepository ( Detail :: class ) ; if ( null === $ variationIdentity ) { $ variationModel = $ variationRepository -> findOneBy ( [ 'number' => $ variation -> getNumber ( ) ] ) ; if ( null === $ variationModel ) { $ variationModel = $ variationResource -> create ( $ variationParams ) ; } else { $ variationModel = $ variationResource -> update ( $ variationModel -> getId ( ) , $ variationParams ) ; } $ this -> identityService -> insert ( $ variation -> getIdentifier ( ) , Variation :: TYPE , ( string ) $ variationModel -> getId ( ) , ShopwareAdapter :: NAME ) ; } else { $ variationModel = $ variationRepository -> find ( $ variationIdentity -> getAdapterIdentifier ( ) ) ; if ( null === $ variationModel ) { $ variationModel = $ variationRepository -> findOneBy ( [ 'number' => $ variation -> getNumber ( ) ] ) ; } if ( null === $ variationModel ) { $ variationModel = $ variationResource -> create ( $ variationParams ) ; } else { $ variationModel = $ variationResource -> update ( $ variationModel -> getId ( ) , $ variationParams ) ; } $ this -> identityService -> update ( $ variationIdentity , [ 'adapterIdentifier' => ( string ) $ variationModel -> getId ( ) , ] ) ; } $ this -> correctProductAssignment ( $ variationModel , $ productIdentitiy ) ; $ this -> correctMainDetailAssignment ( $ variationModel , $ variation ) ; $ this -> attributeDataPersister -> saveProductDetailAttributes ( $ variationModel , $ variation -> getAttributes ( ) ) ; return true ; } 
private function correctProductAssignment ( $ variationModel , $ productIdentitiy ) { if ( null === $ variationModel ) { return ; } if ( ( int ) $ productIdentitiy -> getAdapterIdentifier ( ) === $ variationModel -> getArticle ( ) -> getId ( ) ) { return ; } $ this -> entityManager -> getConnection ( ) -> update ( 's_articles_details' , [ 'articleID' => $ productIdentitiy -> getAdapterIdentifier ( ) ] , [ 'id' => $ variationModel -> getId ( ) ] ) ; $ this -> logger -> notice ( 'migrated variation from existing product to connector handeled product.' , [ 'variation' => $ variationModel -> getNumber ( ) , 'old shopware product id' => $ variationModel -> getArticle ( ) -> getId ( ) , 'new shopware product id' => $ productIdentitiy -> getAdapterIdentifier ( ) , ] ) ; } 
public function execute ( $ command , callable $ next ) { if ( ! self :: $ active ) { return $ next ( $ command ) ; } if ( $ command instanceof HandleBacklogElementCommand ) { $ command = $ command -> getPayload ( ) ; return $ next ( $ command ) ; } if ( $ command instanceof CommandInterface ) { $ this -> backlogService -> enqueue ( $ command ) ; $ this -> logCommandEnqueued ( $ command ) ; return true ; } return $ next ( $ command ) ; } 
public function getClassProperties ( ) { return [ 'identifier' => $ this -> getIdentifier ( ) , 'orderIdentifier' => $ this -> getOrderIdentifer ( ) , 'amount' => $ this -> getAmount ( ) , 'shopIdentifier' => $ this -> getShopIdentifier ( ) , 'currencyIdentifier' => $ this -> getCurrencyIdentifier ( ) , 'paymentMethodIdentifier' => $ this -> getPaymentMethodIdentifier ( ) , 'transactionReference' => $ this -> getTransactionReference ( ) , 'accountHolder' => $ this -> getAccountHolder ( ) , 'paymentData' => $ this -> getPaymentData ( ) , 'attributes' => $ this -> getAttributes ( ) , ] ; } 
private function getAttributes ( array $ attributeData ) { $ attributes = [ ] ; foreach ( $ attributeData as $ key => $ value ) { if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof DateTimeInterface ) { $ strValue = $ value -> format ( 'Y-m-d H:i:s' ) ; } else { $ strValue = ( string ) $ value ; } $ attribute = new Attribute ( ) ; $ attribute -> setKey ( ( string ) $ key ) ; $ attribute -> setValue ( $ strValue ) ; $ attributes [ ] = $ attribute ; } return $ attributes ; } 
private function getKlarnaPclassId ( $ klarnaShopId , $ countryIso ) { try { $ query = 'SELECT id FROM s_klarna_pclasses WHERE eid = :klarnaShopId AND country = :country' ; return $ this -> connection -> fetchColumn ( $ query , [ 'klarnaShopId' => $ klarnaShopId , 'country' => $ this -> getKlarnaCountryId ( $ countryIso ) , ] ) ; } catch ( Exception $ exception ) { return '' ; } } 
private function getKlarnaCountryId ( $ country ) { switch ( $ country ) { case 'DE' : return self :: DE ; case 'AT' : return self :: AT ; case 'DK' : return self :: DK ; case 'FI' : return self :: FI ; case 'NL' : return self :: NL ; case 'NO' : return self :: NO ; case 'SE' : return self :: SE ; default : return 0 ; } } 
public function execute ( $ command , callable $ next ) { if ( null === $ this -> handlers ) { return $ next ( $ command ) ; } if ( ! ( $ command instanceof CommandInterface ) ) { return $ next ( $ command ) ; } $ handlers = array_filter ( $ this -> handlers , function ( CommandHandlerInterface $ handler ) use ( $ command ) { return $ handler -> supports ( $ command ) ; } ) ; if ( 0 === count ( $ handlers ) ) { throw NotFoundException :: fromCommand ( $ command ) ; } foreach ( $ handlers as $ handler ) { $ handler -> handle ( $ command ) ; } return $ next ( $ command ) ; } 
public function getOpenOrders ( ) { $ filter = [ [ 'property' => 'status' , 'expression' => '=' , 'value' => Status :: ORDER_STATE_OPEN , ] , ] ; $ orders = $ this -> orderResource -> getList ( 0 , null , $ filter ) ; return $ orders [ 'data' ] ; } 
public function getOrderDetails ( $ identifier ) { $ order = $ this -> orderResource -> getOne ( $ identifier ) ; $ order [ 'shopId' ] = $ this -> getCorrectSubShopIdentifier ( $ identifier ) ; return $ this -> removeOrphanedShopArray ( $ order ) ; } 
public function handle ( QueryInterface $ query ) { $ lastCangedTime = $ this -> getChangedDateTime ( ) ; $ currentDateTime = $ this -> getCurrentDateTime ( ) ; $ stocks = $ this -> client -> getIterator ( 'stockmanagement/stock' , [ 'updatedAtFrom' => $ lastCangedTime -> format ( DATE_W3C ) , 'updatedAtTo' => $ currentDateTime -> format ( DATE_W3C ) , 'columns' => [ 'variationId' ] , ] ) ; $ this -> outputHandler -> startProgressBar ( count ( $ stocks ) ) ; foreach ( $ this -> getAffectedVariations ( $ stocks ) as $ variationIdentifierGroup ) { if ( empty ( $ variationIdentifierGroup ) ) { continue ; } $ elements = $ this -> client -> getIterator ( 'items/variations' , [ 'with' => 'stock' , 'id' => implode ( ',' , $ variationIdentifierGroup ) , ] ) ; foreach ( $ elements as $ element ) { $ stock = null ; try { $ stock = $ this -> responseParser -> parse ( $ element ) ; } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } if ( $ stock !== null ) { yield $ stock ; } $ this -> outputHandler -> advanceProgressBar ( ) ; } } $ this -> outputHandler -> finishProgressBar ( ) ; $ this -> setChangedDateTime ( $ currentDateTime ) ; } 
public function handle ( CommandInterface $ command ) { $ identifier = $ command -> getPayload ( ) ; $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ identifier , 'objectType' => Variation :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ identity ) { $ this -> logger -> notice ( 'no matching identity found' , [ 'command' => $ command ] ) ; return false ; } $ repository = $ this -> entityManager -> getRepository ( Detail :: class ) ; $ variation = $ repository -> find ( $ identity -> getAdapterIdentifier ( ) ) ; if ( null !== $ variation ) { $ this -> entityManager -> remove ( $ variation ) ; $ this -> entityManager -> flush ( ) ; } else { $ this -> logger -> notice ( 'identity removed but the object was not found' , [ 'command' => $ command ] ) ; } $ identities = $ this -> identityService -> findBy ( [ 'objectIdentifier' => $ identifier , ] ) ; array_walk ( $ identities , function ( Identity $ identity ) { $ this -> identityService -> remove ( $ identity ) ; } ) ; return true ; } 
public function getMappingInformation ( $ objectType = null ) { Assertion :: nullOrString ( $ objectType ) ; $ definitions = $ this -> definitionProvider -> getMappingDefinitions ( $ objectType ) ; if ( empty ( $ definitions ) ) { $ this -> logger -> notice ( 'No mappingdefinition found' ) ; } $ result = [ ] ; foreach ( $ definitions as $ definition ) { $ mapping = new Mapping ( ) ; $ mapping -> setOriginAdapterName ( $ definition -> getOriginAdapterName ( ) ) ; $ mapping -> setOriginTransferObjects ( $ this -> query ( $ definition , $ definition -> getOriginAdapterName ( ) ) ) ; $ mapping -> setDestinationAdapterName ( $ definition -> getDestinationAdapterName ( ) ) ; $ mapping -> setDestinationTransferObjects ( $ this -> query ( $ definition , $ definition -> getDestinationAdapterName ( ) ) ) ; $ mapping -> setObjectType ( $ definition -> getObjectType ( ) ) ; $ this -> validator -> validate ( $ mapping ) ; $ result [ ] = $ mapping ; } return $ result ; } 
private function query ( Definition $ definition , $ adapterName ) { $ originQuery = $ this -> queryFactory -> create ( $ adapterName , $ definition -> getObjectType ( ) , QueryType :: ALL ) ; $ objects = $ this -> serviceBus -> handle ( $ originQuery ) ; if ( empty ( $ objects ) ) { $ objects = [ ] ; } $ result = [ ] ; foreach ( $ objects as $ object ) { if ( $ object -> getType ( ) !== $ definition -> getObjectType ( ) ) { continue ; } $ result [ ] = $ object ; } return $ result ; } 
public function supports ( QueryInterface $ query ) { return $ query instanceof FetchTransferObjectQuery && $ query -> getAdapterName ( ) === PlentymarketsAdapter :: NAME && $ query -> getObjectType ( ) === Order :: TYPE && $ query -> getQueryType ( ) === QueryType :: ALL ; } 
public function handle ( QueryInterface $ query ) { $ elements = $ this -> api -> findAll ( ) ; $ this -> outputHandler -> startProgressBar ( count ( $ elements ) ) ; foreach ( $ elements as $ element ) { try { $ result = $ this -> responseParser -> parse ( $ element ) ; } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; $ result = null ; } if ( empty ( $ result ) ) { $ result = [ ] ; } $ result = array_filter ( $ result ) ; foreach ( $ result as $ parsedElement ) { yield $ parsedElement ; } $ this -> outputHandler -> advanceProgressBar ( ) ; } $ this -> outputHandler -> finishProgressBar ( ) ; } 
public function handle ( QueryInterface $ query ) { $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ query -> getObjectIdentifier ( ) , 'objectType' => Category :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ identity ) { return [ ] ; } $ elements = $ this -> client -> request ( 'GET' , 'categories/' . $ identity -> getAdapterIdentifier ( ) , [ 'with' => 'details,clients' , 'type' => 'item' , 'lang' => $ this -> languageHelper -> getLanguagesQueryString ( ) , ] ) ; if ( empty ( $ elements ) ) { return [ ] ; } $ element = array_shift ( $ elements ) ; $ parsedElements = $ this -> categoryResponseParser -> parse ( $ element ) ; return array_filter ( $ parsedElements ) ; } 
public function execute ( $ command , callable $ next ) { $ this -> formatter -> logCommandReceived ( $ command ) ; $ returnValue = false ; try { $ returnValue = $ next ( $ command ) ; $ this -> formatter -> logCommandProcessed ( $ command , $ returnValue ) ; return $ returnValue ; } catch ( Exception $ exception ) { $ this -> formatter -> logCommandFailed ( $ command , $ exception ) ; } return $ returnValue ; } 
public function handle ( QueryInterface $ query ) { $ lastCangedTime = $ this -> getChangedDateTime ( ) ; $ currentDateTime = $ this -> getCurrentDateTime ( ) ; $ elements = $ this -> api -> findChangedVariations ( $ lastCangedTime , $ currentDateTime ) ; $ this -> outputHandler -> startProgressBar ( count ( $ elements ) ) ; foreach ( $ elements as $ element ) { try { $ result = $ this -> responseParser -> parse ( $ element ) ; } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; $ result = null ; } if ( empty ( $ result ) ) { $ result = [ ] ; } $ result = array_filter ( $ result ) ; foreach ( $ result as $ parsedElement ) { yield $ parsedElement ; } $ this -> outputHandler -> advanceProgressBar ( ) ; } $ this -> outputHandler -> finishProgressBar ( ) ; $ this -> setChangedDateTime ( $ currentDateTime ) ; } 
public static function fromQuery ( QueryInterface $ query ) { $ name = substr ( strrchr ( get_class ( $ query ) , '\\' ) , 1 ) ; $ message = 'No matching query handler found: ' . $ name ; return new self ( $ message ) ; } 
public function getClassProperties ( ) { return [ 'identifier' => $ this -> getIdentifier ( ) , 'productIdentifier' => $ this -> getProductIdentifier ( ) , 'active' => $ this -> getActive ( ) , 'main' => $ this -> isMain ( ) , 'number' => $ this -> getNumber ( ) , 'name' => $ this -> getName ( ) , 'position' => $ this -> getPosition ( ) , 'barcodes' => $ this -> getBarcodes ( ) , 'model' => $ this -> getModel ( ) , 'images' => $ this -> getImages ( ) , 'prices' => $ this -> getPrices ( ) , 'purchasePrice' => $ this -> getPurchasePrice ( ) , 'unitIdentifier' => $ this -> getUnitIdentifier ( ) , 'content' => $ this -> getContent ( ) , 'referenceAmount' => $ this -> getReferenceAmount ( ) , 'stockLimitation' => $ this -> hasStockLimitation ( ) , 'maximumOrderQuantity' => $ this -> getMaximumOrderQuantity ( ) , 'minimumOrderQuantity' => $ this -> getMinimumOrderQuantity ( ) , 'intervalOrderQuantity' => $ this -> getIntervalOrderQuantity ( ) , 'shippingTime' => $ this -> getShippingTime ( ) , 'releaseDate' => $ this -> getReleaseDate ( ) , 'width' => $ this -> getWidth ( ) , 'height' => $ this -> getHeight ( ) , 'length' => $ this -> getLength ( ) , 'weight' => $ this -> getWeight ( ) , 'properties' => $ this -> getProperties ( ) , 'attributes' => $ this -> getAttributes ( ) , ] ; } 
public function handle ( $ queryType , $ objectType = null , $ identifier = null ) { Assertion :: inArray ( $ queryType , QueryType :: getAllTypes ( ) ) ; Assertion :: nullOrString ( $ objectType ) ; if ( $ queryType === QueryType :: ONE ) { Assertion :: notNull ( $ identifier ) ; Assertion :: uuid ( $ identifier ) ; } $ definitions = $ this -> definitionProvider -> getConnectorDefinitions ( $ objectType ) ; if ( empty ( $ definitions ) ) { $ this -> logger -> notice ( 'No connectordefinition found' ) ; } array_walk ( $ definitions , function ( Definition $ definition ) use ( $ queryType , $ identifier ) { $ this -> handleDefinition ( $ definition , $ queryType , $ identifier ) ; } ) ; } 
public function getClassProperties ( ) { return [ 'identifier' => $ this -> getIdentifier ( ) , 'name' => $ this -> getName ( ) , 'active' => $ this -> isActive ( ) , 'shopIdentifiers' => $ this -> getShopIdentifiers ( ) , 'manufacturerIdentifier' => $ this -> getManufacturerIdentifier ( ) , 'categoryIdentifiers' => $ this -> getCategoryIdentifiers ( ) , 'defaultCategoryIdentifiers' => $ this -> getDefaultCategoryIdentifiers ( ) , 'shippingProfileIdentifiers' => $ this -> getShippingProfileIdentifiers ( ) , 'vatRateIdentifier' => $ this -> getVatRateIdentifier ( ) , 'description' => $ this -> getDescription ( ) , 'longDescription' => $ this -> getLongDescription ( ) , 'metaTitle' => $ this -> getMetaTitle ( ) , 'metaDescription' => $ this -> getMetaDescription ( ) , 'metaKeywords' => $ this -> getMetaKeywords ( ) , 'metaRobots' => $ this -> getMetaRobots ( ) , 'linkedProducts' => $ this -> getLinkedProducts ( ) , 'documents' => $ this -> getDocuments ( ) , 'properties' => $ this -> getProperties ( ) , 'availableFrom' => $ this -> getAvailableFrom ( ) , 'availableTo' => $ this -> getAvailableTo ( ) , 'variantConfiguration' => $ this -> getVariantConfiguration ( ) , 'badges' => $ this -> getBadges ( ) , 'translations' => $ this -> getTranslations ( ) , 'attributes' => $ this -> getAttributes ( ) , ] ; } 
public function supports ( QueryInterface $ query ) { return $ query instanceof FetchTransferObjectQuery && $ query -> getAdapterName ( ) === ShopwareAdapter :: NAME && $ query -> getObjectType ( ) === OrderStatus :: TYPE && $ query -> getQueryType ( ) === QueryType :: ALL ; } 
public function handle ( QueryInterface $ query ) { $ elements = $ this -> createOrderStatusQuery ( ) -> getArrayResult ( ) ; foreach ( $ elements as $ element ) { $ result = $ this -> responseParser -> parse ( $ element ) ; if ( null === $ result ) { continue ; } yield $ result ; } } 
public function parse ( array $ entry ) { $ identity = $ this -> identityService -> findOneOrCreate ( ( string ) $ entry [ 'id' ] , ShopwareAdapter :: NAME , PaymentStatus :: TYPE ) ; if ( ! empty ( $ entry [ 'name' ] ) ) { $ name = $ entry [ 'name' ] ; } else { $ name = $ entry [ 'id' ] ; } return PaymentStatus :: fromArray ( [ 'identifier' => $ identity -> getObjectIdentifier ( ) , 'name' => ( string ) $ name , ] ) ; } 
public function getCurrencyIdentifierByCode ( $ code ) { $ currencyRepository = $ this -> entityManager -> getRepository ( Currency :: class ) ; $ currencyModel = $ currencyRepository -> findOneBy ( [ 'currency' => $ code ] ) ; if ( null === $ currencyModel ) { throw new InvalidArgumentException ( 'invalid currency code' ) ; } return $ currencyModel -> getId ( ) ; } 
public function generate ( Payment $ payment ) { $ paymentParams = $ this -> parentRequestGenerator -> generate ( $ payment ) ; $ data = $ payment -> getPaymentData ( ) ; if ( ! ( $ data instanceof PayPalUnifiedPaymentData ) ) { return $ paymentParams ; } $ paymentParams [ 'properties' ] [ ] = [ 'typeId' => 22 , 'value' => json_encode ( [ 'accountHolder' => $ data -> getAccountHolder ( ) , 'bankName' => $ data -> getBankName ( ) , 'bic' => $ data -> getBic ( ) , 'iban' => $ data -> getIban ( ) , 'paymentDue' => $ data -> getDueDate ( ) -> format ( DATE_W3C ) , 'referenceNumber' => $ data -> getReference ( ) , ] ) , ] ; return $ paymentParams ; } 
private function collectObjectIdentifiers ( Definition $ definition ) { $ this -> outputHandler -> writeLine ( sprintf ( 'checking transfer objects for existence: Type: %s, %s -> %s' , $ definition -> getObjectType ( ) , $ definition -> getOriginAdapterName ( ) , $ definition -> getDestinationAdapterName ( ) ) ) ; $ objects = $ this -> serviceBus -> handle ( $ this -> queryFactory -> create ( $ definition -> getOriginAdapterName ( ) , $ definition -> getObjectType ( ) , QueryType :: ALL ) ) ; $ found = false ; if ( empty ( $ objects ) ) { return false ; } foreach ( $ objects as $ transferObject ) { if ( false === $ found ) { $ found = true ; } $ this -> elements [ ] = [ 'objectIdentifier' => $ transferObject -> getIdentifier ( ) , 'adapterName' => $ definition -> getDestinationAdapterName ( ) , 'type' => $ transferObject -> getType ( ) , ] ; } return ! ( false === $ found ) ; } 
private function findOrphanedIdentitiesByGroup ( array $ group ) { $ identifiers = array_column ( $ group , 'objectIdentifier' ) ; $ allIdentities = $ this -> identityService -> findBy ( [ 'adapterName' => $ group [ 0 ] [ 'adapterName' ] , 'objectType' => $ group [ 0 ] [ 'type' ] , ] ) ; return array_filter ( $ allIdentities , function ( Identity $ identity ) use ( $ identifiers ) { return ! in_array ( $ identity -> getObjectIdentifier ( ) , $ identifiers , true ) ; } ) ; } 
public function generate ( Media $ media ) { $ params = [ 'album' => Album :: ALBUM_ARTICLE , 'file' => $ media -> getLink ( ) , 'description' => $ media -> getAlternateName ( ) ? : $ media -> getName ( ) ? : $ media -> getFilename ( ) , ] ; if ( null !== $ media -> getMediaCategoryIdentifier ( ) ) { $ params [ 'album' ] = $ this -> dataProvider -> getAlbumIdentifierFromMediaObject ( $ media ) ; } return $ params ; } 
public function getArticleImage ( Identity $ mediaIdentity , $ articleId ) { return $ this -> articleImageRepository -> findOneBy ( [ 'articleId' => $ articleId , 'media' => $ mediaIdentity -> getAdapterIdentifier ( ) , ] ) ; } 
public function generate ( OrderItem $ orderItem , Order $ order ) { $ shippingProfileIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getShippingProfileIdentifier ( ) , 'objectType' => ShippingProfile :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ shippingProfileIdentity ) { throw new NotFoundException ( 'shipping profile not mapped' ) ; } $ currencyIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getCurrencyIdentifier ( ) , 'objectType' => Currency :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ currencyIdentity ) { throw new NotFoundException ( 'currency profile not mapped' ) ; } $ itemParams = [ ] ; if ( $ orderItem -> getType ( ) === OrderItem :: TYPE_PRODUCT ) { $ typeId = 1 ; } elseif ( $ orderItem -> getType ( ) === OrderItem :: TYPE_DISCOUNT ) { $ typeId = 4 ; } elseif ( $ orderItem -> getType ( ) === OrderItem :: TYPE_VOUCHER ) { $ typeId = 4 ; } elseif ( $ orderItem -> getType ( ) === OrderItem :: TYPE_COUPON ) { $ typeId = 5 ; } elseif ( $ orderItem -> getType ( ) === OrderItem :: TYPE_PAYMENT_SURCHARGE ) { $ typeId = 7 ; } elseif ( $ orderItem -> getType ( ) === OrderItem :: TYPE_SHIPPING_COSTS ) { $ typeId = 6 ; } else { throw new RuntimeException ( 'unsupported type' ) ; } 
private function getVariationIdentifier ( OrderItem $ orderItem ) { if ( $ this -> configService -> get ( 'variation_number_field' , 'number' ) === 'number' ) { return $ this -> getVariationIdentifierFromNumber ( $ orderItem -> getNumber ( ) ) ; } return $ this -> getVariationIdentifierByIdentifier ( $ orderItem -> getNumber ( ) ) ; } 
private function getVariationIdentifierByIdentifier ( $ identifier ) { $ variations = $ this -> client -> request ( 'GET' , 'items/variations' , [ 'id' => $ identifier ] ) ; if ( ! empty ( $ variations ) ) { $ variation = array_shift ( $ variations ) ; return $ variation [ 'id' ] ; } return 0 ; } 
private function getVariationIdentifierFromNumber ( $ number ) { $ variations = $ this -> client -> request ( 'GET' , 'items/variations' , [ 'numberExact' => $ number ] ) ; if ( ! empty ( $ variations ) ) { $ variation = array_shift ( $ variations ) ; return $ variation [ 'id' ] ; } return 0 ; } 
private function isCouponItem ( OrderItem $ orderItem ) { return $ orderItem -> getType ( ) === OrderItem :: TYPE_VOUCHER || $ orderItem -> getType ( ) === OrderItem :: TYPE_COUPON ; } 
public function handle ( CommandInterface $ command ) { $ order = $ command -> getPayload ( ) ; $ orderIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getIdentifier ( ) , 'objectType' => Order :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ orderIdentity ) { return false ; } $ params = [ 'details' => [ ] , ] ; $ package = $ this -> getPackage ( $ order ) ; if ( null !== $ package ) { $ this -> addShippingProviderAttribute ( $ order , $ package ) ; $ params [ 'trackingCode' ] = $ package -> getShippingCode ( ) ; } $ orderStatusIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getOrderStatusIdentifier ( ) , 'objectType' => OrderStatus :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null !== $ orderStatusIdentity ) { $ params [ 'orderStatusId' ] = $ orderStatusIdentity -> getAdapterIdentifier ( ) ; } else { $ this -> logger -> notice ( 'order status not mapped' , [ 'order' => $ order ] ) ; } $ paymentStatusIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getPaymentStatusIdentifier ( ) , 'objectType' => PaymentStatus :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null !== $ paymentStatusIdentity ) { $ params [ 'paymentStatusId' ] = $ paymentStatusIdentity -> getAdapterIdentifier ( ) ; if ( ( int ) $ paymentStatusIdentity -> getAdapterIdentifier ( ) === Status :: PAYMENT_STATE_COMPLETELY_PAID ) { $ params [ 'cleareddate' ] = new DateTime ( 'now' ) ; } } else { $ this -> logger -> notice ( 'payment status not mapped' , [ 'order' => $ order ] ) ; } $ resource = $ this -> getOrderResource ( ) ; $ orderModel = $ resource -> update ( $ orderIdentity -> getAdapterIdentifier ( ) , $ params ) ; $ this -> attributePersister -> saveOrderAttributes ( $ orderModel , $ order -> getAttributes ( ) ) ; return true ; } 
private function getPackage ( Order $ order ) { $ packages = $ order -> getPackages ( ) ; if ( empty ( $ packages ) ) { return null ; } return array_shift ( $ packages ) ; } 
public function onRunCronjobSynchronize ( Args $ args ) { try { $ this -> connector -> handle ( QueryType :: CHANGED ) ; } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } catch ( Throwable $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } $ args -> setReturn ( true ) ; return true ; } 
public function onRunCronjobProcessBacklog ( Args $ args ) { try { $ counter = 0 ; while ( $ counter < 200 && $ command = $ this -> backlogService -> dequeue ( ) ) { ++ $ counter ; $ this -> serviceBus -> handle ( $ command ) ; } } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } catch ( Throwable $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } $ args -> setReturn ( true ) ; return true ; } 
public function onRunCronjobCleanup ( Args $ args ) { try { $ this -> cleanupService -> cleanup ( ) ; } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } catch ( Throwable $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } $ args -> setReturn ( true ) ; return true ; } 
public static function fromArray ( array $ params = [ ] ) { $ object = new static ( ) ; foreach ( $ params as $ key => $ value ) { $ method = 'set' . ucfirst ( $ key ) ; if ( method_exists ( $ object , $ method ) ) { $ object -> $ method ( $ value ) ; } } return $ object ; } 
public static function fromParams ( $ method , $ path , $ options ) { $ string = 'The response was null. Method: %s, Path: %s, options: %s' ; $ message = sprintf ( $ string , $ method , $ path , json_encode ( $ options ) ) . "\n" ; return new static ( $ message ) ; } 
public function getShopIdentifiers ( array $ variation ) { $ identifiers = [ ] ; foreach ( ( array ) $ variation [ 'variationClients' ] as $ client ) { $ identity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ client [ 'plentyId' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Shop :: TYPE , ] ) ; if ( null === $ identity ) { $ this -> logger -> notice ( 'shop not found' , $ client ) ; continue ; } $ isMappedIdentity = $ this -> identityService -> isMappedIdentity ( $ identity -> getObjectIdentifier ( ) , $ identity -> getObjectType ( ) , $ identity -> getAdapterName ( ) ) ; if ( ! $ isMappedIdentity ) { continue ; } $ identifiers [ ] = $ identity -> getObjectIdentifier ( ) ; } return $ identifiers ; } 
public function getMainVariation ( array $ variations ) { $ mainVariation = array_filter ( $ variations , function ( $ variation ) { return $ variation [ 'isMain' ] === true ; } ) ; if ( empty ( $ mainVariation ) ) { return [ ] ; } return reset ( $ mainVariation ) ; } 
public function getMainVariationNumber ( array $ mainVariation , array $ variations = [ ] ) { $ found = false ; $ mainVariationNumber = ( string ) $ mainVariation [ 'id' ] ; if ( $ this -> configService -> get ( 'variation_number_field' , 'number' ) === 'number' ) { $ mainVariationNumber = ( string ) $ mainVariation [ 'number' ] ; } foreach ( $ variations as $ variation ) { if ( $ variation -> getNumber ( ) === $ mainVariationNumber ) { $ found = true ; break ; } } if ( $ found ) { $ checkActiveMainVariation = json_decode ( $ this -> configService -> get ( 'check_active_main_variation' ) ) ; if ( ! $ checkActiveMainVariation && ! $ mainVariation [ 'isActive' ] ) { foreach ( $ variations as $ variation ) { if ( $ variation -> getActive ( ) ) { return $ variation -> getNumber ( ) ; } } } return $ mainVariationNumber ; } foreach ( $ variations as $ variation ) { if ( $ variation -> getActive ( ) ) { return $ variation -> getNumber ( ) ; } } return $ mainVariationNumber ; } 
public function parse ( array $ variation ) { $ variationIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ variation [ 'id' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Variation :: TYPE , ] ) ; if ( null === $ variationIdentity ) { return null ; } $ stockIdentity = $ this -> identityService -> findOneOrCreate ( ( string ) $ variationIdentity -> getAdapterIdentifier ( ) , PlentymarketsAdapter :: NAME , Stock :: TYPE ) ; $ stock = new Stock ( ) ; $ stock -> setIdentifier ( $ stockIdentity -> getObjectIdentifier ( ) ) ; $ stock -> setVariationIdentifier ( $ variationIdentity -> getObjectIdentifier ( ) ) ; $ stock -> setStock ( $ this -> getStock ( $ variation ) ) ; return $ stock ; } 
private function getStock ( $ variation ) { $ arrayStocks = [ ] ; $ itemWarehouse = ( int ) $ this -> configService -> get ( 'item_warehouse' , 0 ) ; static $ warehouses ; if ( null === $ warehouses ) { $ warehouses = $ this -> client -> request ( 'GET' , 'stockmanagement/warehouses' ) ; $ warehouses = array_filter ( $ warehouses , function ( array $ warehouse ) { return $ warehouse [ 'typeId' ] === self :: SALES_WAREHOUSE ; } ) ; $ warehouses = array_column ( $ warehouses , 'id' ) ; } foreach ( $ variation [ 'stock' ] as $ stock ) { if ( ! in_array ( $ stock [ 'warehouseId' ] , $ warehouses , true ) ) { continue ; } if ( $ itemWarehouse !== 0 && $ stock [ 'warehouseId' ] !== $ itemWarehouse ) { continue ; } if ( $ stock [ 'variationId' ] !== $ variation [ 'id' ] ) { continue ; } $ arrayStocks [ ] = $ stock [ 'netStock' ] ; } return ( float ) array_sum ( $ arrayStocks ) ; } 
public function parse ( array $ entry ) { $ entry [ 'salutation' ] = strtolower ( $ entry [ 'salutation' ] ) ; $ shopIdentifier = $ this -> getIdentifier ( ( string ) $ entry [ 'shopId' ] , Shop :: TYPE ) ; $ languageIdentifier = $ this -> getLanguageIdentifier ( $ entry ) ; if ( null === $ languageIdentifier ) { $ this -> logger -> warning ( 'no customer language found' ) ; return null ; } $ customerGroup = $ this -> getCustomerGroup ( $ entry ) ; if ( null === $ customerGroup ) { $ this -> logger -> warning ( 'no customer group found' ) ; return null ; } $ customerGroupIdentifier = $ this -> getIdentifier ( ( string ) $ customerGroup -> getId ( ) , CustomerGroup :: TYPE ) ; if ( $ entry [ 'salutation' ] === 'mr' || $ entry [ 'salutation' ] === 'herr' ) { $ gender = Customer :: GENDER_MALE ; } elseif ( $ entry [ 'salutation' ] === 'ms' || $ entry [ 'salutation' ] === 'frau' ) { $ gender = Customer :: GENDER_FEMALE ; } else { $ gender = null ; } if ( empty ( $ entry [ 'birthday' ] ) ) { $ birthday = null ; } else { $ birthday = DateTimeImmutable :: createFromMutable ( $ entry [ 'birthday' ] ) ; if ( ! ( $ birthday instanceof DateTimeImmutable ) ) { $ birthday = null ; } } if ( empty ( $ entry [ 'title' ] ) ) { $ entry [ 'title' ] = null ; } $ customer = new Customer ( ) ; $ customer -> setBirthday ( $ birthday ) ; $ customer -> setType ( $ this -> getCustomerTypeId ( $ entry [ 'accountMode' ] ) ) ; $ customer -> setEmail ( $ entry [ 'email' ] ) ; $ customer -> setFirstname ( $ entry [ 'firstname' ] ) ; $ customer -> setLastname ( $ entry [ 'lastname' ] ) ; $ customer -> setNumber ( $ entry [ 'number' ] ) ; $ customer -> setGender ( $ gender ) ; $ customer -> setTitle ( $ entry [ 'title' ] ) ; $ customer -> setShopIdentifier ( $ shopIdentifier ) ; $ customer -> setLanguageIdentifier ( $ languageIdentifier ) ; $ customer -> setCustomerGroupIdentifier ( $ customerGroupIdentifier ) ; $ newsletterRepository = $ this -> entityManager -> getRepository ( Address :: class ) ; $ newsletter = $ newsletterRepository -> findOneBy ( [ 'email' => $ entry [ 'email' ] ] ) ; if ( $ newsletter !== null ) { $ customer -> setNewsletter ( true ) ; if ( null !== $ newsletter -> getAdded ( ) ) { $ customer -> setNewsletterAgreementDate ( DateTimeImmutable :: createFromMutable ( $ newsletter -> getAdded ( ) ) ) ; } } return $ customer ; } 
private function getCustomerGroup ( array $ entry ) { $ customerGroupRepository = $ this -> entityManager -> getRepository ( GroupModel :: class ) ; return $ customerGroupRepository -> findOneBy ( [ 'key' => $ entry [ 'groupKey' ] ] ) ; } 
private function getLanguageIdentifier ( array $ entry ) { $ shopRepository = $ this -> entityManager -> getRepository ( ShopModel :: class ) ; $ customerShop = $ shopRepository -> find ( $ entry [ 'languageId' ] ) ; if ( null === $ customerShop ) { return null ; } $ languageIdentifier = $ this -> getIdentifier ( ( string ) $ customerShop -> getLocale ( ) -> getId ( ) , Language :: TYPE ) ; if ( null === $ languageIdentifier ) { return null ; } return $ languageIdentifier ; } 
private function getCustomerTypeId ( $ shopwareId ) { switch ( $ shopwareId ) { case CustomerModel :: ACCOUNT_MODE_CUSTOMER : return Customer :: TYPE_NORMAL ; case CustomerModel :: ACCOUNT_MODE_FAST_LOGIN : return Customer :: TYPE_GUEST ; } throw new InvalidArgumentException ( 'Unknown customer type ' . $ shopwareId ) ; } 
private function getIdentifier ( $ entry , $ type ) { return $ this -> identityService -> findOneOrThrow ( ( string ) $ entry , ShopwareAdapter :: NAME , $ type ) -> getObjectIdentifier ( ) ; } 
public function generate ( Product $ product ) { $ groups = [ ] ; foreach ( $ product -> getVariantConfiguration ( ) as $ property ) { $ propertyName = $ property -> getName ( ) ; $ groups [ $ propertyName ] [ 'name' ] = $ propertyName ; $ groups [ $ propertyName ] [ 'position' ] = $ property -> getPosition ( ) ; foreach ( $ property -> getValues ( ) as $ value ) { $ propertyValue = $ value -> getValue ( ) ; $ groups [ $ propertyName ] [ 'options' ] [ $ propertyValue ] [ 'name' ] = $ propertyValue ; $ groups [ $ propertyName ] [ 'options' ] [ $ propertyValue ] [ 'position' ] = $ value -> getPosition ( ) ; } } if ( empty ( $ groups ) ) { return [ ] ; } return [ 'name' => $ product -> getName ( ) , 'type' => ( int ) $ this -> configService -> get ( 'product_configurator_type' , 0 ) , 'groups' => $ groups , ] ; } 
public function getLanguageIdentifiers ( TranslateableInterface $ object ) { $ languages = [ ] ; foreach ( $ object -> getTranslations ( ) as $ translation ) { $ languageIdentifier = $ translation -> getLanguageIdentifier ( ) ; if ( isset ( $ languages [ $ languageIdentifier ] ) ) { continue ; } $ languages [ $ languageIdentifier ] = $ languageIdentifier ; } return $ languages ; } 
public function translate ( $ languageIdentifier , TranslateableInterface $ object ) { $ deepCopy = new DeepCopy ( ) ; $ object = $ deepCopy -> copy ( $ object ) ; $ translations = array_filter ( $ object -> getTranslations ( ) , function ( Translation $ translation ) use ( $ languageIdentifier ) { return $ translation -> getLanguageIdentifier ( ) === $ languageIdentifier ; } ) ; if ( empty ( $ translations ) ) { return $ object ; } foreach ( $ translations as $ translation ) { $ method = 'set' . ucfirst ( $ translation -> getProperty ( ) ) ; if ( method_exists ( $ object , $ method ) ) { $ object -> $ method ( $ translation -> getValue ( ) ) ; } } return $ object ; } 
public function handle ( QueryInterface $ query ) { $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ query -> getObjectIdentifier ( ) , 'objectType' => Product :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ identity ) { return [ ] ; } $ product = $ this -> itemApi -> findOne ( $ identity -> getAdapterIdentifier ( ) ) ; $ result = $ this -> responseParser -> parse ( $ product ) ; return array_filter ( $ result ) ; } 
public function generate ( Address $ address , Order $ order , $ addressType = 0 ) { $ countryIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ address -> getCountryIdentifier ( ) , 'objectType' => Country :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ countryIdentity ) { throw new RuntimeException ( 'country not mapped' ) ; } try { $ splitResult = AddressSplitter :: splitAddress ( $ address -> getStreet ( ) ) ; $ address1 = $ splitResult [ 'streetName' ] ; $ address2 = $ splitResult [ 'houseNumber' ] ; $ address3 = trim ( $ splitResult [ 'additionToAddress1' ] . ' ' . $ splitResult [ 'additionToAddress2' ] ) ; } catch ( Exception $ exception ) { $ address1 = $ address -> getStreet ( ) ; $ address2 = '' ; $ address3 = '' ; } $ params = [ 'name1' => trim ( $ address -> getCompany ( ) . ' ' . $ address -> getDepartment ( ) ) , 'name2' => $ address -> getFirstname ( ) , 'name3' => $ address -> getLastname ( ) , 'gender' => $ address -> getGender ( ) , 'postalCode' => $ address -> getPostalCode ( ) , 'town' => $ address -> getCity ( ) , 'countryId' => $ countryIdentity -> getAdapterIdentifier ( ) , 'typeId' => $ addressType , ] ; if ( 0 === strcasecmp ( $ address1 , 'Packstation' ) ) { $ params = array_merge ( $ params , [ 'isPackstation' => true , 'address1' => 'PACKSTATION' , 'address2' => $ address2 , 'options' => [ [ 'typeId' => 5 , 'value' => $ order -> getCustomer ( ) -> getEmail ( ) , ] , ] , ] ) ; if ( null !== $ address -> getAdditional ( ) ) { $ params [ 'options' ] [ ] = [ 'typeId' => 6 , 'value' => $ address -> getAdditional ( ) , ] ; } } elseif ( 0 === strcasecmp ( $ address1 , 'Postfiliale' ) ) { $ params = array_merge ( $ params , [ 'isPostfiliale' => true , 'address1' => 'POSTFILIALE' , 'address2' => $ address2 , 'options' => [ [ 'typeId' => 5 , 'value' => $ order -> getCustomer ( ) -> getEmail ( ) , ] , ] , ] ) ; if ( null !== $ address -> getAdditional ( ) ) { $ params [ 'options' ] [ ] = [ 'typeId' => 6 , 'value' => $ address -> getAdditional ( ) , ] ; } } else { $ params = array_merge ( $ params , [ 'address1' => $ address1 , 'address2' => $ address2 , 'address3' => $ address -> getAdditional ( ) , 'address4' => $ address3 , 'options' => [ [ 'typeId' => 5 , 'value' => $ order -> getCustomer ( ) -> getEmail ( ) , ] , ] , ] ) ; } if ( null !== $ order -> getCustomer ( ) -> getPhoneNumber ( ) ) { $ params [ 'options' ] [ ] = [ 'typeId' => 4 , 'value' => $ order -> getCustomer ( ) -> getPhoneNumber ( ) , ] ; } if ( null !== $ address -> getVatId ( ) ) { $ params [ 'options' ] [ ] = [ 'typeId' => 1 , 'value' => $ address -> getVatId ( ) , ] ; } return $ params ; } 
public function getAlbumIdentifierFromMediaObject ( Media $ media ) { $ mediaCategoryIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ media -> getMediaCategoryIdentifier ( ) , 'objectType' => MediaCategory :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ mediaCategoryIdentity ) { throw new NotFoundException ( 'missing media category for adapter' ) ; } return $ mediaCategoryIdentity -> getAdapterIdentifier ( ) ; } 
public function getMediaHashForMediaObject ( Media $ media ) { $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ media -> getIdentifier ( ) , 'objectType' => Media :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ identity ) { return '' ; } $ attributes = $ this -> dataLoader -> load ( 's_media_attributes' , $ identity -> getAdapterIdentifier ( ) ) ; if ( empty ( $ attributes ) ) { return '' ; } foreach ( $ attributes as $ key => $ value ) { if ( $ key !== 'plenty_connector_hash' ) { continue ; } return $ value ; } return '' ; } 
public function parse ( array $ element ) { $ paymentIdentifier = $ this -> identityService -> findOneOrCreate ( ( string ) $ element [ 'id' ] , ShopwareAdapter :: NAME , Payment :: TYPE ) ; $ isMappedPaymentIdentity = $ this -> identityService -> isMappedIdentity ( $ paymentIdentifier -> getObjectIdentifier ( ) , $ paymentIdentifier -> getObjectType ( ) , $ paymentIdentifier -> getAdapterName ( ) ) ; if ( $ isMappedPaymentIdentity ) { $ this -> logger -> notice ( 'paymentidentity' . $ paymentIdentifier -> getObjectIdentifier ( ) . ' ist not mapped' ) ; return [ ] ; } if ( empty ( $ element [ 'paymentStatus' ] ) ) { return [ ] ; } if ( Status :: PAYMENT_STATE_COMPLETELY_PAID !== $ element [ 'paymentStatus' ] [ 'id' ] ) { return [ ] ; } if ( empty ( $ element [ 'transactionId' ] ) ) { $ element [ 'transactionId' ] = $ paymentIdentifier -> getObjectIdentifier ( ) ; } $ shopIdentity = $ this -> identityService -> findOneOrThrow ( ( string ) $ element [ 'shopId' ] , ShopwareAdapter :: NAME , Shop :: TYPE ) ; $ isMappedShopIdentity = $ this -> identityService -> isMappedIdentity ( $ shopIdentity -> getObjectIdentifier ( ) , $ shopIdentity -> getObjectType ( ) , $ shopIdentity -> getAdapterName ( ) ) ; if ( ! $ isMappedShopIdentity ) { $ this -> logger -> warning ( 'shopidentity' . $ shopIdentity -> getObjectIdentifier ( ) . ' ist not mapped' ) ; return [ ] ; } $ shopwareCurrencyIdentifier = $ this -> currencyDataProvider -> getCurrencyIdentifierByCode ( $ element [ 'currency' ] ) ; $ currencyIdentifier = $ this -> getConnectorIdentifier ( $ shopwareCurrencyIdentifier , Currency :: TYPE ) ; $ payment = new Payment ( ) ; $ payment -> setIdentifier ( $ paymentIdentifier -> getObjectIdentifier ( ) ) ; $ payment -> setShopIdentifier ( $ shopIdentity -> getObjectIdentifier ( ) ) ; $ payment -> setOrderIdentifer ( $ this -> getConnectorIdentifier ( $ element [ 'id' ] , Order :: TYPE ) ) ; $ payment -> setAmount ( $ element [ 'invoiceAmount' ] ) ; $ payment -> setAccountHolder ( $ this -> getAccountHolder ( $ element ) ) ; $ payment -> setCurrencyIdentifier ( $ currencyIdentifier ) ; $ payment -> setPaymentMethodIdentifier ( $ this -> getConnectorIdentifier ( $ element [ 'paymentId' ] , PaymentMethod :: TYPE ) ) ; $ payment -> setTransactionReference ( $ element [ 'transactionId' ] ) ; return [ $ payment ] ; } 
private function getAccountHolder ( array $ element ) { $ firstName = ! empty ( $ element [ 'billing' ] [ 'firstName' ] ) ? $ element [ 'billing' ] [ 'firstName' ] : '' ; $ lastName = ! empty ( $ element [ 'billing' ] [ 'lastName' ] ) ? $ element [ 'billing' ] [ 'lastName' ] : '' ; return trim ( sprintf ( '%s %s' , $ firstName , $ lastName ) ) ; } 
public function calculate ( array $ variation ) { if ( empty ( self :: $ units ) ) { self :: $ units = array_filter ( $ this -> itemUnitApi -> findAll ( ) , function ( array $ unit ) { return array_key_exists ( $ unit [ 'unitOfMeasurement' ] , self :: $ convertionMatrix ) ; } ) ; } $ variationUnit = $ this -> getUnitOfVariation ( $ variation ) ; if ( null === $ variationUnit ) { return 1.0 ; } $ modifier = self :: $ convertionMatrix [ $ variationUnit ] [ 'conversion' ] ; $ content = $ variation [ 'unit' ] [ 'content' ] * $ modifier ; if ( $ content <= 0.25 && 5 !== $ variation [ 'unit' ] [ 'unitId' ] && 2 !== $ variation [ 'unit' ] [ 'unitId' ] ) { return 0.1 / $ modifier ; } return 1.0 / $ modifier ; } 
private function getUnitOfVariation ( array $ variation ) { foreach ( self :: $ units as $ unit ) { if ( ( int ) $ unit [ 'id' ] === ( int ) $ variation [ 'unit' ] [ 'unitId' ] ) { return $ unit [ 'unitOfMeasurement' ] ; } } return null ; } 
public function supports ( CommandInterface $ command ) { return $ command instanceof TransferObjectCommand && $ command -> getAdapterName ( ) === ShopwareAdapter :: NAME && $ command -> getObjectType ( ) === Product :: TYPE && $ command -> getCommandType ( ) === CommandType :: REMOVE ; } 
public function handle ( CommandInterface $ command ) { $ identifier = $ command -> getPayload ( ) ; $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ identifier , 'objectType' => Product :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ identity ) { $ this -> logger -> notice ( 'no matching identity found' , [ 'command' => $ command ] ) ; return false ; } try { $ resource = $ this -> getArticleResource ( ) ; $ resource -> delete ( $ identity -> getAdapterIdentifier ( ) ) ; } catch ( Exception $ exception ) { $ this -> logger -> notice ( 'identity removed but the object was not found' , [ 'command' => $ command ] ) ; } $ identities = $ this -> identityService -> findBy ( [ 'objectIdentifier' => $ identifier , ] ) ; array_walk ( $ identities , function ( Identity $ identity ) { $ this -> identityService -> remove ( $ identity ) ; } ) ; return true ; } 
protected function write ( array $ record ) { if ( $ this -> isProcessing ) { return ; } $ this -> isProcessing = true ; call_user_func ( $ this -> handler , $ record ) ; $ this -> isProcessing = false ; } 
public function handle ( QueryInterface $ query ) { $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ query -> getObjectIdentifier ( ) , 'objectType' => Bundle :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ identity ) { return [ ] ; } $ variation = $ this -> variationApi -> findBy ( [ 'id' => $ identity -> getAdapterIdentifier ( ) ] ) ; if ( empty ( $ variation ) ) { return [ ] ; } $ variation = array_shift ( $ variation ) ; $ product = $ this -> itemApi -> findOne ( $ variation [ 'itemId' ] ) ; $ result = $ this -> responseParser -> parse ( $ product ) ; return array_filter ( $ result ) ; } 
public function handle ( CommandInterface $ command ) { $ order = $ command -> getPayload ( ) ; $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getIdentifier ( ) , 'objectType' => Order :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( $ identity !== null ) { return true ; } if ( $ this -> isExistingOrder ( $ order ) ) { return true ; } $ result = $ this -> handleOrder ( $ order ) ; if ( $ result ) { $ this -> handleComments ( $ order ) ; } return true ; } 
private function handleOrder ( Order $ order ) { $ params = $ this -> orderRequestGenerator -> generate ( $ order ) ; $ result = $ this -> client -> request ( 'post' , 'orders' , $ params ) ; $ this -> identityService -> insert ( $ order -> getIdentifier ( ) , Order :: TYPE , ( string ) $ result [ 'id' ] , PlentymarketsAdapter :: NAME ) ; return true ; } 
private function isExistingOrder ( Order $ order ) { $ shopIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getShopIdentifier ( ) , 'objectType' => Shop :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ shopIdentity ) { throw new NotFoundException ( 'shop not mapped' ) ; } $ result = $ this -> client -> request ( 'GET' , 'orders' , [ 'externalOrderId' => $ order -> getOrderNumber ( ) , ] ) ; $ result = array_filter ( $ result , function ( array $ order ) use ( $ shopIdentity ) { return ( int ) $ order [ 'plentyId' ] === $ shopIdentity -> getAdapterIdentifier ( ) ; } ) ; if ( ! empty ( $ result ) ) { return true ; } return false ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ all = ( bool ) $ input -> getOption ( 'all' ) ; if ( ( bool ) $ input -> getOption ( 'disableBacklog' ) ) { BacklogCommandHandlerMiddleware :: $ active = false ; } $ objectType = $ input -> getArgument ( 'objectType' ) ; $ objectIdentifier = $ input -> getArgument ( 'objectIdentifier' ) ; if ( method_exists ( $ this -> logger , 'pushHandler' ) ) { $ this -> logger -> pushHandler ( new ConsoleHandler ( $ output ) ) ; } $ this -> outputHandler -> initialize ( $ input , $ output ) ; try { if ( $ objectIdentifier ) { $ queryType = QueryType :: ONE ; BacklogCommandHandlerMiddleware :: $ active = false ; } else { $ queryType = $ all ? QueryType :: ALL : QueryType :: CHANGED ; } $ this -> connector -> handle ( $ queryType , $ objectType , $ objectIdentifier ) ; } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } catch ( Throwable $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ this -> outputHandler -> initialize ( $ input , $ output ) ; $ info = $ this -> backlogService -> getInfo ( ) ; $ this -> outputHandler -> createTable ( [ 'info' , 'value' ] , [ [ 'amount enqueued' , $ info [ 'amount_enqueued' ] ] , ] ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( method_exists ( $ this -> logger , 'pushHandler' ) ) { $ this -> logger -> pushHandler ( new ConsoleHandler ( $ output ) ) ; } $ amount = ( int ) $ input -> getArgument ( 'amount' ) ; $ this -> outputHandler -> initialize ( $ input , $ output ) ; $ this -> outputHandler -> startProgressBar ( $ amount ) ; try { $ counter = 0 ; while ( $ counter < $ amount && $ command = $ this -> backlogService -> dequeue ( ) ) { ++ $ counter ; $ this -> serviceBus -> handle ( $ command ) ; $ this -> outputHandler -> advanceProgressBar ( ) ; } } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } catch ( Throwable $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } $ this -> outputHandler -> finishProgressBar ( ) ; } 
public function handle ( QueryInterface $ query ) { $ elements = $ this -> client -> getIterator ( 'items/variations' , [ 'with' => 'stock' , ] ) ; $ this -> outputHandler -> startProgressBar ( count ( $ elements ) ) ; foreach ( $ elements as $ element ) { $ stock = null ; try { $ stock = $ this -> responseParser -> parse ( $ element ) ; } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } if ( $ stock !== null ) { yield $ stock ; } $ this -> outputHandler -> advanceProgressBar ( ) ; } $ this -> outputHandler -> finishProgressBar ( ) ; } 
public function getLanguagesQueryString ( ) { $ languages = [ ] ; foreach ( $ this -> getLanguages ( ) as $ language ) { $ languageIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ language [ 'id' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( $ languageIdentity === null ) { continue ; } $ isMapped = $ this -> identityService -> isMappedIdentity ( $ languageIdentity -> getObjectIdentifier ( ) , Language :: TYPE , PlentymarketsAdapter :: NAME ) ; if ( $ isMapped ) { $ languages [ ] = $ language [ 'id' ] ; } } return implode ( ',' , $ languages ) ; } 
public function writeProductTranslations ( Product $ product ) { $ productIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ product -> getIdentifier ( ) , 'objectType' => Product :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ productIdentity ) { return ; } foreach ( $ this -> translationHelper -> getLanguageIdentifiers ( $ product ) as $ languageIdentifier ) { $ translatedProduct = $ this -> translationHelper -> translate ( $ languageIdentifier , $ product ) ; $ languageIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ languageIdentifier , 'objectType' => Language :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ languageIdentity ) { $ this -> logger -> notice ( 'language not mapped - ' . $ languageIdentifier ) ; continue ; } $ translation = [ 'name' => $ translatedProduct -> getName ( ) , 'description' => $ translatedProduct -> getDescription ( ) , 'descriptionLong' => $ translatedProduct -> getLongDescription ( ) , 'metaTitle' => $ translatedProduct -> getMetaTitle ( ) , 'metaDescription' => $ translatedProduct -> getMetaDescription ( ) , 'keywords' => $ translatedProduct -> getMetaKeywords ( ) , ] ; foreach ( $ product -> getAttributes ( ) as $ attribute ) { $ translatedAttribute = $ this -> translationHelper -> translate ( $ languageIdentifier , $ attribute ) ; $ key = '__attribute_plenty_connector' . ucfirst ( $ attribute -> getKey ( ) ) ; $ attribute_key = strtolower ( preg_replace ( '/[A-Z]/' , '_\\0' , lcfirst ( $ key ) ) ) ; $ translation [ $ attribute_key ] = $ translatedAttribute -> getValue ( ) ; } $ this -> writeTranslations ( 'article' , ( int ) $ productIdentity -> getAdapterIdentifier ( ) , $ translation , $ languageIdentity ) ; } foreach ( $ product -> getProperties ( ) as $ property ) { $ this -> writeGroupTranslations ( $ property , 'propertyoption' ) ; foreach ( $ property -> getValues ( ) as $ value ) { $ this -> writeValueTranslations ( $ value , 'propertyvalue' ) ; } } foreach ( $ product -> getVariantConfiguration ( ) as $ variantConfiguration ) { $ this -> writeGroupTranslations ( $ variantConfiguration , 'configuratorgroup' ) ; foreach ( $ variantConfiguration -> getValues ( ) as $ value ) { $ this -> writeValueTranslations ( $ value , 'configuratoroption' ) ; } } foreach ( $ product -> getImages ( ) as $ articleImage ) { $ this -> writeMediaTranslations ( $ articleImage , $ productIdentity -> getAdapterIdentifier ( ) ) ; } } 
public function onControllerBackendPlentyConnector ( Enlight_Event_EventArgs $ args ) { $ this -> template -> addTemplateDir ( $ this -> pluginDirectory . '/Resources/Views/' ) ; return $ this -> pluginDirectory . '/Controller/Backend/PlentyConnector.php' ; } 
public function uninstall ( UninstallContext $ context ) { if ( ! $ context -> keepUserData ( ) ) { $ this -> schemaTool -> dropSchema ( $ this -> models ) ; } } 
public static function fromCommand ( CommandInterface $ command ) { $ name = substr ( strrchr ( get_class ( $ command ) , '\\' ) , 1 ) ; $ message = 'No matching command handler found: ' . $ name ; return new self ( $ message ) ; } 
public function create ( $ adapterName , $ objectType , $ queryType , $ payload = null ) { Assertion :: string ( $ adapterName ) ; Assertion :: string ( $ objectType ) ; Assertion :: inArray ( $ queryType , QueryType :: getAllTypes ( ) ) ; if ( $ queryType === QueryType :: ONE ) { Assertion :: uuid ( $ payload ) ; } $ query = null ; switch ( $ queryType ) { case QueryType :: ONE : $ query = new FetchTransferObjectQuery ( $ adapterName , $ objectType , $ queryType , $ payload ) ; break ; case QueryType :: CHANGED : $ query = new FetchTransferObjectQuery ( $ adapterName , $ objectType , $ queryType ) ; break ; case QueryType :: ALL : $ query = new FetchTransferObjectQuery ( $ adapterName , $ objectType , $ queryType ) ; break ; } if ( null === $ query ) { throw MissingQueryException :: fromObjectData ( $ objectType , $ queryType ) ; } return $ query ; } 
public static function fromObject ( $ object , $ message , $ propertyPath , array $ parents = [ ] ) { $ newMessage = '' ; foreach ( $ parents as $ parent ) { if ( $ parent instanceof ValueObjectInterface ) { $ newMessage .= get_class ( $ parent ) . ' ' ; } if ( $ parent instanceof TransferObjectInterface ) { $ newMessage .= get_class ( $ parent ) . ' ObjectIdentifier: ' . $ parent -> getIdentifier ( ) ; } } if ( $ object instanceof ValueObjectInterface ) { $ newMessage .= ' ' . $ message . ' Path: ' . $ propertyPath ; } if ( $ object instanceof TransferObjectInterface ) { $ newMessage .= ' ObjectIdentifier: ' . $ object -> getIdentifier ( ) . ' Message: ' . $ message . ' Path: ' . $ propertyPath ; } $ newMessage = trim ( $ newMessage ) ; return new self ( $ newMessage ) ; } 
public function getCategories ( ) { return [ $ this :: MANUFACTURER => [ 'id' => $ this :: MANUFACTURER , 'name' => 'Manufacturer' , ] , $ this :: PRODUCT => [ 'id' => $ this :: PRODUCT , 'name' => 'Products' , ] , $ this :: CATEGORY => [ 'id' => $ this :: CATEGORY , 'name' => 'Categories' , ] , ] ; } 
public function getIterator ( $ path , array $ criteria = [ ] , Closure $ prepareFunction = null ) { return new Iterator ( $ path , $ this , $ criteria , $ prepareFunction ) ; } 
public function getTotal ( $ path , array $ criteria = [ ] ) { $ options = [ 'plainResponse' => true , ] ; $ response = $ this -> request ( 'GET' , $ path , $ criteria , null , null , $ options ) ; if ( isset ( $ response [ 'totalsCount' ] ) ) { return ( int ) $ response [ 'totalsCount' ] ; } if ( isset ( $ response [ 'entries' ] ) ) { $ response = $ response [ 'entries' ] ; } return count ( $ response ) ; } 
public function request ( $ method , $ path , array $ params = [ ] , $ limit = null , $ offset = null , array $ options = [ ] ) { Assertion :: nullOrInteger ( $ limit ) ; Assertion :: nullOrInteger ( $ offset ) ; Assertion :: isArray ( $ options ) ; if ( $ this -> isLoginRequired ( $ path ) ) { $ this -> login ( ) ; } try { $ requestUrl = $ this -> getUrl ( $ path , $ options ) ; $ response = $ this -> curlRequest ( $ requestUrl , $ method , $ path , $ params , $ limit , $ offset ) ; if ( null === $ response ) { throw InvalidResponseException :: fromParams ( $ method , $ path , $ options ) ; } $ this -> retries = 0 ; return $ this -> prepareResponse ( $ limit , $ offset , $ options , $ response ) ; } catch ( Exception $ exception ) { return $ this -> handleRequestException ( $ exception , $ method , $ path , $ params , $ limit , $ offset ) ; } catch ( Throwable $ exception ) { return $ this -> handleRequestException ( $ exception , $ method , $ path , $ params , $ limit , $ offset ) ; } } 
private function curlRequest ( $ requestUrl , $ method , $ path , $ params , $ limit , $ offset ) { $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , $ this -> getUserAgent ( ) ) ; curl_setopt ( $ curl , CURLOPT_HTTPHEADER , $ this -> getHeaders ( $ path ) ) ; curl_setopt ( $ curl , CURLOPT_FOLLOWLOCATION , true ) ; curl_setopt ( $ curl , CURLOPT_TIMEOUT , 60 ) ; curl_setopt ( $ curl , CURLOPT_CONNECTTIMEOUT , 60 ) ; $ headers = [ ] ; curl_setopt ( $ curl , CURLOPT_HEADERFUNCTION , function ( $ curl , $ header ) use ( & $ headers ) { if ( stripos ( $ header , 'X-Plenty' ) === false ) { return strlen ( $ header ) ; } $ name = substr ( $ header , 0 , strpos ( $ header , ':' ) ) ; $ value = substr ( $ header , strpos ( $ header , ':' ) + 1 ) ; $ headers [ $ name ] = ( int ) trim ( $ value ) ; return strlen ( $ header ) ; } ) ; if ( null !== $ limit ) { $ params [ 'itemsPerPage' ] = ( int ) $ limit ; } if ( null !== $ offset ) { $ params [ 'page' ] = $ this -> getPage ( $ limit , $ offset ) ; } $ method = strtoupper ( $ method ) ; if ( $ method === 'POST' ) { curl_setopt ( $ curl , CURLOPT_POST , true ) ; curl_setopt ( $ curl , CURLOPT_POSTFIELDS , json_encode ( $ params , JSON_PRETTY_PRINT ) ) ; } elseif ( $ method === 'GET' ) { $ requestUrl = $ requestUrl . '?' . http_build_query ( $ params ) ; } curl_setopt ( $ curl , CURLOPT_URL , $ requestUrl ) ; $ response = curl_exec ( $ curl ) ; $ info = curl_getinfo ( $ curl ) ; $ errno = curl_errno ( $ curl ) ; if ( $ errno !== CURLE_OK ) { throw new RuntimeException ( 'curl client error:' . $ errno ) ; } $ this -> handeRateLimits ( $ headers ) ; if ( $ info [ 'http_code' ] === 401 ) { throw new LoginExpiredException ( ) ; } if ( $ info [ 'http_code' ] === 200 ) { $ json = json_decode ( $ response , true ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw InvalidResponseException :: fromParams ( $ method , $ path , $ params ) ; } return $ json ; } throw new RuntimeException ( 'client error' ) ; } 
private function getPage ( $ limit , $ offset ) { $ page = 1.0 ; if ( null !== $ offset ) { $ page = ( floor ( $ offset / $ limit ) + 1 ) ; } return ( int ) $ page ; } 
private function getUrl ( $ path , array $ options = [ ] ) { Assertion :: string ( $ path ) ; Assertion :: notBlank ( $ path ) ; if ( ! isset ( $ options [ 'base_uri' ] ) && ! isset ( $ options [ 'foreign' ] ) ) { $ base_uri = $ this -> getBaseUri ( $ this -> configService -> get ( 'rest_url' ) ) ; } elseif ( $ options [ 'foreign' ] ) { $ base_uri = str_replace ( '/rest' , '' , $ this -> getBaseUri ( $ this -> configService -> get ( 'rest_url' ) ) ) ; } else { $ base_uri = $ this -> getBaseUri ( $ options [ 'base_uri' ] ) ; } return $ base_uri . $ path ; } 
private function getBaseUri ( $ url ) { if ( null === $ url ) { throw new InvalidCredentialsException ( 'invalid creddentials' ) ; } $ parts = parse_url ( $ url ) ; if ( empty ( $ parts [ 'scheme' ] ) ) { $ parts [ 'scheme' ] = 'http' ; } return sprintf ( '%s://%s/%s/' , $ parts [ 'scheme' ] , $ parts [ 'host' ] , 'rest' ) ; } 
private function getHeaders ( $ path ) { $ headers = [ 'Content-Type: application/json' , 'Accept: application/x.plentymarkets.v1+json' , 'cache-control: no-cache' , 'user-agent: ' . $ this -> getUserAgent ( ) , ] ; if ( 'login' !== $ path ) { $ headers [ ] = 'Authorization: Bearer ' . $ this -> accessToken ; } return $ headers ; } 
private function handleRequestException ( Throwable $ exception , $ method , $ path , array $ params , $ limit , $ offset ) { if ( $ this -> retries >= 4 ) { $ this -> retries = 0 ; throw $ exception ; } ++ $ this -> retries ; if ( $ exception instanceof LoginExpiredException ) { $ this -> accessToken = null ; } if ( $ exception instanceof LimitReachedException ) { if ( $ exception -> getRetryAfter ( ) > 60 * 15 ) { $ this -> logger -> error ( 'rate limit reached and retry after value is too high, aborting' ) ; } else { $ this -> logger -> warning ( sprintf ( 'rate limit reached, retrying in %s seconds' , $ exception -> getRetryAfter ( ) ) ) ; sleep ( $ exception -> getRetryAfter ( ) ) ; } } else { sleep ( 10 ) ; } return $ this -> request ( $ method , $ path , $ params , $ limit , $ offset ) ; } 
private function prepareResponse ( $ limit , $ offset , array $ options , array $ response ) { if ( ! isset ( $ options [ 'plainResponse' ] ) || ! $ options [ 'plainResponse' ] ) { 
public function factory ( $ originAdapterName , $ destinationAdapterName , $ objectType , $ priority = null ) { $ definition = new Definition ( ) ; $ definition -> setOriginAdapterName ( $ originAdapterName ) ; $ definition -> setDestinationAdapterName ( $ destinationAdapterName ) ; $ definition -> setObjectType ( $ objectType ) ; $ definition -> setPriority ( $ priority ) ; $ this -> validator -> validate ( $ definition ) ; return $ definition ; } 
public function findOneOrThrow ( $ adapterIdentifier , $ adapterName , $ objectType ) { Assertion :: string ( $ adapterIdentifier ) ; Assertion :: notBlank ( $ adapterIdentifier ) ; Assertion :: string ( $ adapterName ) ; Assertion :: notBlank ( $ adapterName ) ; Assertion :: string ( $ objectType ) ; Assertion :: notBlank ( $ objectType ) ; $ identity = $ this -> findOneBy ( [ 'objectType' => $ objectType , 'adapterIdentifier' => $ adapterIdentifier , 'adapterName' => $ adapterName , ] ) ; if ( null === $ identity ) { throw new NotFoundException ( printf ( 'Could not find identity for %s with identifier %s in %s.' , $ objectType , $ adapterIdentifier , $ adapterName ) ) ; } $ this -> validator -> validate ( $ identity ) ; return $ identity ; } 
public function findOneOrCreate ( $ adapterIdentifier , $ adapterName , $ objectType ) { Assertion :: string ( $ adapterIdentifier ) ; Assertion :: notBlank ( $ adapterIdentifier ) ; Assertion :: string ( $ adapterName ) ; Assertion :: notBlank ( $ adapterName ) ; Assertion :: string ( $ objectType ) ; Assertion :: notBlank ( $ objectType ) ; $ identity = $ this -> findOneBy ( [ 'objectType' => $ objectType , 'adapterIdentifier' => $ adapterIdentifier , 'adapterName' => $ adapterName , ] ) ; if ( null === $ identity ) { $ objectIdentifier = Uuid :: uuid4 ( ) -> toString ( ) ; $ identity = $ this -> insert ( $ objectIdentifier , $ objectType , ( string ) $ adapterIdentifier , $ adapterName ) ; } $ this -> validator -> validate ( $ identity ) ; return $ identity ; } 
public function findOneBy ( array $ criteria = [ ] ) { Assertion :: isArray ( $ criteria ) ; $ storage = reset ( $ this -> storages ) ; $ identity = $ storage -> findOneBy ( $ criteria ) ; if ( $ identity !== null ) { $ this -> validator -> validate ( $ identity ) ; return $ identity ; } return null ; } 
public function insert ( $ objectIdentifier , $ objectType , $ adapterIdentifier , $ adapterName ) { $ identity = Identity :: fromArray ( [ 'objectIdentifier' => $ objectIdentifier , 'objectType' => $ objectType , 'adapterIdentifier' => $ adapterIdentifier , 'adapterName' => $ adapterName , ] ) ; $ this -> validator -> validate ( $ identity ) ; $ storage = reset ( $ this -> storages ) ; $ storage -> insert ( $ identity ) ; return $ identity ; } 
public function findBy ( array $ criteria = [ ] ) { Assertion :: isArray ( $ criteria ) ; $ storage = reset ( $ this -> storages ) ; $ identities = $ storage -> findBy ( $ criteria ) ; array_walk ( $ identities , function ( Identity $ identity ) { $ this -> validator -> validate ( $ identity ) ; } ) ; return $ identities ; } 
public function update ( Identity $ identity , array $ params = [ ] ) { $ this -> validator -> validate ( $ identity ) ; $ newIdentity = clone $ identity ; if ( ! empty ( $ params [ 'objectIdentifier' ] ) ) { $ newIdentity -> setObjectIdentifier ( $ params [ 'objectIdentifier' ] ) ; } if ( ! empty ( $ params [ 'objectType' ] ) ) { $ newIdentity -> setAdapterName ( $ params [ 'objectType' ] ) ; } if ( ! empty ( $ params [ 'adapterIdentifier' ] ) ) { $ newIdentity -> setAdapterIdentifier ( $ params [ 'adapterIdentifier' ] ) ; } if ( ! empty ( $ params [ 'adapterName' ] ) ) { $ newIdentity -> setObjectType ( $ params [ 'adapterName' ] ) ; } $ this -> validator -> validate ( $ newIdentity ) ; $ storage = reset ( $ this -> storages ) ; $ storage -> update ( $ identity , $ params ) ; return $ newIdentity ; } 
public function remove ( Identity $ identity ) { $ this -> validator -> validate ( $ identity ) ; $ storage = reset ( $ this -> storages ) ; $ storage -> remove ( $ identity ) ; } 
public function isMappedIdentity ( $ objectIdentifier , $ objectType , $ adapterName ) { $ identities = $ this -> findBy ( [ 'objectIdentifier' => $ objectIdentifier , 'objectType' => $ objectType , ] ) ; $ otherIdentities = array_filter ( $ identities , function ( Identity $ identity ) use ( $ adapterName ) { return $ identity -> getAdapterName ( ) !== $ adapterName ; } ) ; if ( empty ( $ otherIdentities ) ) { return false ; } return true ; } 
public function parse ( array $ product ) { $ productIdentitiy = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ product [ 'id' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Product :: TYPE , ] ) ; if ( null === $ productIdentitiy ) { return [ ] ; } $ variations = $ product [ 'variations' ] ; $ mainVariation = $ this -> variationHelper -> getMainVariation ( $ variations ) ; if ( empty ( $ mainVariation ) ) { return [ ] ; } if ( Product :: MULTIPACK === $ product [ 'itemType' ] ) { $ variations = array_filter ( $ variations , function ( array $ variation ) { return $ variation [ 'isMain' ] ; } ) ; } if ( count ( $ variations ) > 1 ) { $ variations = array_filter ( $ variations , function ( array $ variation ) { return ! empty ( $ variation [ 'variationAttributeValues' ] ) ; } ) ; } usort ( $ variations , function ( array $ a , array $ b ) { if ( ( int ) $ a [ 'position' ] === ( int ) $ b [ 'position' ] ) { return 0 ; } return ( ( int ) $ a [ 'position' ] < ( int ) $ b [ 'position' ] ) ? - 1 : 1 ; } ) ; $ result = [ ] ; foreach ( $ variations as $ variation ) { $ identity = $ this -> identityService -> findOneOrCreate ( ( string ) $ variation [ 'id' ] , PlentymarketsAdapter :: NAME , Variation :: TYPE ) ; $ variationObject = new Variation ( ) ; $ variationObject -> setIdentifier ( $ identity -> getObjectIdentifier ( ) ) ; $ variationObject -> setProductIdentifier ( $ productIdentitiy -> getObjectIdentifier ( ) ) ; $ variationObject -> setActive ( ( bool ) $ variation [ 'isActive' ] ) ; $ variationObject -> setNumber ( $ this -> getVariationNumber ( $ variation ) ) ; $ variationObject -> setStockLimitation ( $ this -> getStockLimitation ( $ variation ) ) ; $ variationObject -> setBarcodes ( $ this -> getBarcodes ( $ variation ) ) ; $ variationObject -> setPosition ( ( int ) $ variation [ 'position' ] ) ; $ variationObject -> setModel ( ( string ) $ variation [ 'model' ] ) ; $ variationObject -> setImages ( $ this -> getVariationImages ( $ product [ 'texts' ] , $ variation , $ result ) ) ; $ variationObject -> setPrices ( $ this -> priceResponseParser -> parse ( $ variation ) ) ; $ variationObject -> setPurchasePrice ( ( float ) $ variation [ 'purchasePrice' ] ) ; $ variationObject -> setUnitIdentifier ( $ this -> getUnitIdentifier ( $ variation ) ) ; $ variationObject -> setContent ( ( float ) $ variation [ 'unit' ] [ 'content' ] ) ; $ variationObject -> setReferenceAmount ( $ this -> referenceAmountCalculator -> calculate ( $ variation ) ) ; $ variationObject -> setMaximumOrderQuantity ( ( float ) $ variation [ 'maximumOrderQuantity' ] ) ; $ variationObject -> setMinimumOrderQuantity ( ( float ) $ variation [ 'minimumOrderQuantity' ] ) ; $ variationObject -> setIntervalOrderQuantity ( ( float ) $ variation [ 'intervalOrderQuantity' ] ) ; $ variationObject -> setReleaseDate ( $ this -> getReleaseDate ( $ variation ) ) ; $ variationObject -> setShippingTime ( $ this -> getShippingTime ( $ variation ) ) ; $ variationObject -> setWidth ( ( int ) $ variation [ 'widthMM' ] ) ; $ variationObject -> setHeight ( ( int ) $ variation [ 'heightMM' ] ) ; $ variationObject -> setLength ( ( int ) $ variation [ 'lengthMM' ] ) ; $ variationObject -> setWeight ( $ this -> getVariationWeight ( $ variation ) ) ; $ variationObject -> setProperties ( $ this -> getVariationProperties ( $ variation ) ) ; $ stockObject = $ this -> stockResponseParser -> parse ( $ variation ) ; if ( null === $ stockObject ) { continue ; } $ importVariationsWithoutStock = json_decode ( $ this -> configService -> get ( 'import_variations_without_stock' , true ) ) ; if ( ! $ importVariationsWithoutStock && empty ( $ stockObject -> getStock ( ) ) ) { continue ; } $ result [ $ variationObject -> getIdentifier ( ) ] = $ variationObject ; $ result [ $ stockObject -> getIdentifier ( ) ] = $ stockObject ; } $ variations = array_filter ( $ result , function ( TransferObjectInterface $ object ) { return $ object instanceof Variation ; } ) ; $ mainVariationNumber = $ this -> variationHelper -> getMainVariationNumber ( $ mainVariation , $ variations ) ; foreach ( $ variations as & $ variation ) { if ( $ variation -> getNumber ( ) === $ mainVariationNumber ) { $ variation -> setIsMain ( true ) ; $ checkActiveMainVariation = json_decode ( $ this -> configService -> get ( 'check_active_main_variation' ) ) ; if ( $ checkActiveMainVariation && ! $ mainVariation [ 'isActive' ] ) { $ variation -> setActive ( false ) ; } break ; } } return $ result ; } 
private function getVariationImages ( array $ texts , array $ variation , array & $ result ) { $ images = [ ] ; foreach ( ( array ) $ variation [ 'images' ] as $ entry ) { $ images [ ] = $ this -> imageResponseParser -> parseImage ( $ entry , $ texts , $ result ) ; } return array_filter ( $ images ) ; } 
private function getUnitIdentifier ( array $ variation ) { if ( empty ( $ variation [ 'unit' ] ) ) { return null ; } 
private function getShippingTime ( array $ variation ) { static $ shippingConfigurations ; if ( null === $ shippingConfigurations ) { $ shippingConfigurations = $ this -> availabilitiesApi -> findAll ( ) ; } $ shippingConfiguration = array_filter ( $ shippingConfigurations , function ( array $ configuration ) use ( $ variation ) { return $ configuration [ 'id' ] === $ variation [ 'availability' ] ; } ) ; if ( empty ( $ shippingConfiguration ) ) { return 0 ; } $ shippingConfiguration = array_shift ( $ shippingConfiguration ) ; if ( empty ( $ shippingConfiguration [ 'averageDays' ] ) ) { return 0 ; } return ( int ) $ shippingConfiguration [ 'averageDays' ] ; } 
private function getBarcodes ( array $ variation ) { static $ barcodeMapping ; if ( null === $ barcodeMapping ) { $ systemBarcodes = $ this -> itemBarcodeApi -> findAll ( ) ; foreach ( $ systemBarcodes as $ systemBarcode ) { $ typeMapping = [ 'GTIN_13' => Barcode :: TYPE_GTIN13 , 'GTIN_128' => Barcode :: TYPE_GTIN128 , 'UPC' => Barcode :: TYPE_UPC , 'ISBN' => Barcode :: TYPE_ISBN , ] ; if ( array_key_exists ( $ systemBarcode [ 'type' ] , $ typeMapping ) ) { $ barcodeMapping [ $ systemBarcode [ 'id' ] ] = $ typeMapping [ $ systemBarcode [ 'type' ] ] ; } } $ barcodeMapping = array_filter ( $ barcodeMapping ) ; } $ barcodes = array_filter ( $ variation [ 'variationBarcodes' ] , function ( array $ barcode ) use ( $ barcodeMapping ) { return array_key_exists ( $ barcode [ 'barcodeId' ] , $ barcodeMapping ) ; } ) ; $ barcodes = array_map ( function ( array $ barcode ) use ( $ barcodeMapping ) { $ barcodeObject = new Barcode ( ) ; $ barcodeObject -> setType ( $ barcodeMapping [ $ barcode [ 'barcodeId' ] ] ) ; $ barcodeObject -> setCode ( $ barcode [ 'code' ] ) ; return $ barcodeObject ; } , $ barcodes ) ; return $ barcodes ; } 
private function getVariationProperties ( array $ variation ) { static $ attributes ; $ result = [ ] ; foreach ( ( array ) $ variation [ 'variationAttributeValues' ] as $ attributeValue ) { if ( ! isset ( $ attributes [ $ attributeValue [ 'attributeId' ] ] ) ) { $ attributes [ $ attributeValue [ 'attributeId' ] ] = $ this -> itemAttributesApi -> findOne ( $ attributeValue [ 'attributeId' ] ) ; } $ values = $ attributes [ $ attributeValue [ 'attributeId' ] ] [ 'values' ] ; $ attributes [ $ attributeValue [ 'attributeId' ] ] [ 'values' ] = [ ] ; foreach ( ( array ) $ values as $ value ) { $ attributes [ $ attributeValue [ 'attributeId' ] ] [ 'values' ] [ $ value [ 'id' ] ] = $ value ; } if ( ! isset ( $ attributes [ $ attributeValue [ 'attributeId' ] ] [ 'values' ] [ $ attributeValue [ 'valueId' ] ] [ 'valueNames' ] ) ) { continue ; } $ propertyNames = $ attributes [ $ attributeValue [ 'attributeId' ] ] [ 'attributeNames' ] ; $ propertyPosition = $ attributes [ $ attributeValue [ 'attributeId' ] ] [ 'position' ] ; $ valueNames = $ attributes [ $ attributeValue [ 'attributeId' ] ] [ 'values' ] [ $ attributeValue [ 'valueId' ] ] [ 'valueNames' ] ; $ valuePosition = $ attributes [ $ attributeValue [ 'attributeId' ] ] [ 'values' ] [ $ attributeValue [ 'valueId' ] ] [ 'position' ] ; $ value = Value :: fromArray ( [ 'value' => $ valueNames [ 0 ] [ 'name' ] , 'position' => $ valuePosition , 'translations' => $ this -> getVariationPropertyValueTranslations ( $ valueNames ) , ] ) ; $ result [ ] = Property :: fromArray ( [ 'name' => $ propertyNames [ 0 ] [ 'name' ] , 'position' => $ propertyPosition , 'values' => [ $ value ] , 'translations' => $ this -> getVariationPropertyTranslations ( $ propertyNames ) , ] ) ; } return $ result ; } 
private function getVariationPropertyTranslations ( array $ names ) { $ translations = [ ] ; foreach ( $ names as $ name ) { $ languageIdentifier = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => $ name [ 'lang' ] , 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Language :: TYPE , ] ) ; if ( null === $ languageIdentifier ) { continue ; } $ translations [ ] = Translation :: fromArray ( [ 'languageIdentifier' => $ languageIdentifier -> getObjectIdentifier ( ) , 'property' => 'name' , 'value' => $ name [ 'name' ] , ] ) ; } return $ translations ; } 
public function handle ( QueryInterface $ query ) { $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ query -> getObjectIdentifier ( ) , 'objectType' => Manufacturer :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ identity ) { return [ ] ; } $ element = $ this -> client -> request ( 'GET' , 'items/manufacturers/' . $ identity -> getAdapterIdentifier ( ) ) ; $ result = $ this -> manufacturerResponseParser -> parse ( $ element ) ; return array_filter ( $ result ) ; } 
public function execute ( $ query , callable $ next ) { if ( null === $ this -> handlers ) { return $ next ( $ query ) ; } if ( ! ( $ query instanceof QueryInterface ) ) { return $ next ( $ query ) ; } $ handlers = array_filter ( $ this -> handlers , function ( QueryHandlerInterface $ handler ) use ( $ query ) { return $ handler -> supports ( $ query ) ; } ) ; if ( 0 === count ( $ handlers ) ) { throw NotFoundException :: fromQuery ( $ query ) ; } $ handler = array_shift ( $ handlers ) ; $ response = $ handler -> handle ( $ query ) ; if ( null !== $ response ) { return $ response ; } return $ next ( $ query ) ; } 
public function parse ( array $ entry , $ taxFree = false ) { if ( empty ( $ entry [ 'attribute' ] ) ) { $ entry [ 'attribute' ] = [ ] ; } return OrderItem :: fromArray ( [ 'type' => $ this -> getItemType ( $ entry [ 'mode' ] ) , 'quantity' => ( float ) $ entry [ 'quantity' ] , 'name' => $ entry [ 'articleName' ] , 'number' => $ entry [ 'articleNumber' ] , 'price' => $ this -> getPrice ( $ entry , $ taxFree ) , 'vatRateIdentifier' => $ this -> getVatRateIdentifier ( $ entry ) , 'attributes' => $ this -> getAttributes ( $ entry [ 'attribute' ] ) , ] ) ; } 
private function getVatRateIdentifier ( array $ entry ) { $ taxModel = $ this -> taxRepository -> findOneBy ( [ 'tax' => $ entry [ 'taxRate' ] ] ) ; if ( null === $ taxModel ) { throw new InvalidArgumentException ( 'no matching tax rate found - ' . $ entry [ 'taxRate' ] ) ; } $ entry [ 'taxId' ] = $ taxModel -> getId ( ) ; $ vatRateIdentity = $ this -> identityService -> findOneBy ( [ 'adapterIdentifier' => ( string ) $ entry [ 'taxId' ] , 'adapterName' => ShopwareAdapter :: NAME , 'objectType' => VatRate :: TYPE , ] ) ; if ( null === $ vatRateIdentity ) { throw new NotFoundException ( 'missing vat rate identity for taxId ' . $ entry [ 'taxId' ] ) ; } return $ vatRateIdentity -> getObjectIdentifier ( ) ; } 
private function getItemType ( $ mode ) { switch ( $ mode ) { case self :: ITEM_TYPE_ID_VOUCHER : return OrderItem :: TYPE_VOUCHER ; case self :: ITEM_TYPE_ID_DISCOUNT : return OrderItem :: TYPE_DISCOUNT ; case self :: ITEM_TYPE_ID_SURCHARGE : if ( json_decode ( $ this -> configService -> get ( 'surcharge_as_product' ) , false ) ) { return OrderItem :: TYPE_PRODUCT ; } return OrderItem :: TYPE_PAYMENT_SURCHARGE ; default : return OrderItem :: TYPE_PRODUCT ; } } 
public function handle ( CommandInterface $ command ) { $ media = $ command -> getPayload ( ) ; if ( $ media -> getHash ( ) === $ this -> mediaDataProvider -> getMediaHashForMediaObject ( $ media ) ) { return true ; } $ this -> attributeHelper -> addFieldAsAttribute ( $ media , 'alternateName' ) ; $ this -> attributeHelper -> addFieldAsAttribute ( $ media , 'name' ) ; $ this -> attributeHelper -> addFieldAsAttribute ( $ media , 'filename' ) ; $ this -> attributeHelper -> addFieldAsAttribute ( $ media , 'hash' ) ; $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ media -> getIdentifier ( ) , 'objectType' => Media :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; $ resource = $ this -> getMediaResource ( ) ; if ( null !== $ identity ) { try { $ resource -> delete ( $ identity -> getAdapterIdentifier ( ) ) ; } catch ( MediaNotFoundException $ exception ) { 
public function findOne ( $ productId ) { $ result = $ this -> client -> request ( 'GET' , 'items/' . $ productId , [ 'lang' => $ this -> languageHelper -> getLanguagesQueryString ( ) , 'with' => implode ( ',' , self :: $ includes ) , ] ) ; if ( empty ( $ result ) ) { return $ result ; } $ result [ 'variations' ] = $ this -> itemsVariationsApi -> findBy ( [ 'itemId' => $ result [ 'id' ] , 'plentyId' => implode ( ',' , $ this -> variationHelper -> getMappedPlentyClientIds ( ) ) , ] ) ; return $ result ; } 
public function findChanged ( DateTimeImmutable $ startTimestamp , DateTimeImmutable $ endTimestamp ) { $ start = $ startTimestamp -> format ( DATE_W3C ) ; $ end = $ endTimestamp -> format ( DATE_W3C ) ; return $ this -> client -> getIterator ( 'items' , [ 'lang' => $ this -> languageHelper -> getLanguagesQueryString ( ) , 'updatedBetween' => $ start . ',' . $ end , 'with' => implode ( ',' , self :: $ includes ) , ] , function ( array $ elements ) { $ this -> addAdditionalData ( $ elements ) ; return $ elements ; } ) ; } 
public function getClassProperties ( ) { return [ 'identifier' => $ this -> getIdentifier ( ) , 'orderNumber' => $ this -> getOrderNumber ( ) , 'orderTime' => $ this -> getOrderTime ( ) , 'customer' => $ this -> getCustomer ( ) , 'billingAddress' => $ this -> getBillingAddress ( ) , 'shoppingAddress' => $ this -> getShippingAddress ( ) , 'orderItems' => $ this -> getOrderItems ( ) , 'shopIdentifier' => $ this -> getShopIdentifier ( ) , 'currentyIdentifier' => $ this -> getCurrencyIdentifier ( ) , 'orderStatusIdentifier' => $ this -> getOrderStatusIdentifier ( ) , 'paymentStatusIdentifier' => $ this -> getPaymentStatusIdentifier ( ) , 'paymentMethodIdentifier' => $ this -> getPaymentMethodIdentifier ( ) , 'shippingProfileIdentifier' => $ this -> getShippingProfileIdentifier ( ) , 'comments' => $ this -> getComments ( ) , 'packages' => $ this -> getPackages ( ) , 'attributes' => $ this -> getAttributes ( ) , ] ; } 
public function parse ( array $ entry , $ taxFree = false ) { if ( OrderItemResponseParser :: ITEM_TYPE_ID_SURCHARGE === $ entry [ 'mode' ] ) { if ( null !== $ this -> modelManager -> getRepository ( Value :: class ) -> findOneBy ( [ 'ordernumber' => $ entry [ 'articleNumber' ] ] ) || null !== $ this -> modelManager -> getRepository ( Option :: class ) -> findOneBy ( [ 'ordernumber' => $ entry [ 'articleNumber' ] ] ) ) { $ entry [ 'mode' ] = OrderItem :: TYPE_PRODUCT ; } } return $ this -> parentOrderItemResponseParser -> parse ( $ entry , $ taxFree ) ; } 
public function handle ( CommandInterface $ command ) { $ identifier = $ command -> getPayload ( ) ; $ this -> bundleHelper -> registerBundleModels ( ) ; $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ identifier , 'objectType' => Bundle :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ identity ) { $ this -> logger -> notice ( 'no matching identity found' , [ 'command' => $ command ] ) ; return false ; } $ repository = $ this -> entityManager -> getRepository ( BundleModel :: class ) ; $ bundleModel = $ repository -> find ( $ identity -> getAdapterIdentifier ( ) ) ; if ( null === $ bundleModel ) { $ this -> logger -> notice ( 'identity removed but the object was not found' , [ 'command' => $ command ] ) ; return false ; } $ this -> entityManager -> remove ( $ bundleModel ) ; $ this -> entityManager -> flush ( ) ; $ identities = $ this -> identityService -> findBy ( [ 'objectIdentifier' => $ identifier , ] ) ; array_walk ( $ identities , function ( Identity $ identity ) { $ this -> identityService -> remove ( $ identity ) ; } ) ; return true ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( method_exists ( $ this -> logger , 'pushHandler' ) ) { $ this -> logger -> pushHandler ( new ConsoleHandler ( $ output ) ) ; } $ this -> outputHandler -> initialize ( $ input , $ output ) ; $ objectType = $ input -> getArgument ( 'objectType' ) ; try { $ mapping = $ this -> mappingService -> getMappingInformation ( $ objectType ) ; foreach ( $ mapping as $ entry ) { $ this -> outputHandler -> writeLine ( $ entry -> getObjectType ( ) ) ; $ headers = [ $ entry -> getOriginAdapterName ( ) , $ entry -> getDestinationAdapterName ( ) , ] ; $ rows = [ ] ; foreach ( $ entry -> getOriginTransferObjects ( ) as $ object ) { $ targetIdentifier = array_filter ( $ entry -> getDestinationTransferObjects ( ) , function ( TransferObjectInterface $ targetObject ) use ( $ object ) { return $ object -> getIdentifier ( ) === $ targetObject -> getIdentifier ( ) ; } ) ; if ( ! empty ( $ targetIdentifier ) ) { $ targetIdentifier = array_shift ( $ targetIdentifier ) ; if ( method_exists ( $ targetIdentifier , 'getName' ) ) { $ targetIdentifier = $ targetIdentifier -> getName ( ) ; } else { $ targetIdentifier = $ targetIdentifier -> getIdentifier ( ) ; } } else { $ targetIdentifier = '' ; } if ( method_exists ( $ object , 'getName' ) ) { $ objectIdentifier = $ object -> getName ( ) ; } else { $ objectIdentifier = $ object -> getIdentifier ( ) ; } $ rows [ ] = [ $ objectIdentifier , $ targetIdentifier , ] ; } $ this -> outputHandler -> createTable ( $ headers , $ rows ) ; } } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } catch ( Throwable $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } } 
public function handle ( QueryInterface $ query ) { $ elements = $ this -> languageHelper -> getLanguages ( ) ; foreach ( $ elements as $ element ) { $ result = $ this -> responseParser -> parse ( $ element ) ; if ( null === $ result ) { continue ; } yield $ result ; } } 
public function parse ( array $ entry ) { if ( empty ( $ entry [ 'id' ] ) ) { $ entry [ 'id' ] = $ entry [ 'statusId' ] ; } if ( empty ( $ entry [ 'id' ] ) ) { return null ; } $ identity = $ this -> identityService -> findOneOrCreate ( ( string ) $ entry [ 'id' ] , PlentymarketsAdapter :: NAME , OrderStatus :: TYPE ) ; return OrderStatus :: fromArray ( [ 'identifier' => $ identity -> getObjectIdentifier ( ) , 'name' => $ this -> getName ( $ entry ) , ] ) ; } 
private function getName ( $ entry ) { if ( empty ( $ entry [ 'names' ] ) ) { return $ entry [ 'id' ] ; } $ names = $ entry [ 'names' ] ; if ( ! empty ( $ names ) ) { return array_shift ( $ names ) ; } return $ entry [ 'id' ] ; } 
public function getClassProperties ( ) { return [ 'type' => $ this -> getType ( ) , 'number' => $ this -> getNumber ( ) , 'email' => $ this -> getEmail ( ) , 'newsletter' => $ this -> getNewsletter ( ) , 'newsletterAgreementDate' => $ this -> getNewsletterAgreementDate ( ) , 'languageIdentifier' => $ this -> getLanguageIdentifier ( ) , 'customerGroupIdentifier' => $ this -> getCustomerGroupIdentifier ( ) , 'gender' => $ this -> getGender ( ) , 'title' => $ this -> getTitle ( ) , 'firstname' => $ this -> getFirstname ( ) , 'lastname' => $ this -> getLastname ( ) , 'birthday' => $ this -> getBirthday ( ) , 'phoneNumber' => $ this -> getPhoneNumber ( ) , 'mobilePhoneNumber' => $ this -> getMobilePhoneNumber ( ) , 'shopIdentifier' => $ this -> getShopIdentifier ( ) , ] ; } 
private function getConstantsByName ( $ name ) { $ reflection = new ReflectionClass ( __CLASS__ ) ; $ constants = $ reflection -> getConstants ( ) ; $ result = [ ] ; foreach ( $ constants as $ key => $ constant ) { if ( false !== stripos ( $ key , $ name ) ) { $ result [ $ key ] = $ constant ; } } return $ result ; } 
public function getClassProperties ( ) { return [ 'identifier' => $ this -> getIdentifier ( ) , 'name' => $ this -> getName ( ) , 'active' => $ this -> getActive ( ) , 'parentIdentifiers' => $ this -> getParentIdentifier ( ) , 'shopIdentifiers' => $ this -> getShopIdentifiers ( ) , 'imageIdentifiers' => $ this -> getImageIdentifiers ( ) , 'position' => $ this -> getPosition ( ) , 'description' => $ this -> getDescription ( ) , 'longDescription' => $ this -> getLongDescription ( ) , 'metaTitle' => $ this -> getMetaTitle ( ) , 'metaDescription' => $ this -> getMetaDescription ( ) , 'metaKeywords' => $ this -> getMetaKeywords ( ) , 'metaRobots' => $ this -> getMetaRobots ( ) , 'translations' => $ this -> getTranslations ( ) , 'attributes' => $ this -> getAttributes ( ) , ] ; } 
public function getClassProperties ( ) { return [ 'reference_number' => $ this -> getReferenceNumber ( ) , 'instruction_type' => $ this -> getInstructionType ( ) , 'bank_name' => $ this -> getBankName ( ) , 'account_holder_name' => $ this -> getAccountHolderName ( ) , 'international_bank_account_number' => $ this -> getInternationalBankAccountNumber ( ) , 'bank_identifier_code' => $ this -> getBankIdentifierCode ( ) , 'amountValue' => $ this -> getAmountValue ( ) , 'amount_currency' => $ this -> getAmountCurrency ( ) , 'payment_due_date' => $ this -> getPaymentDueDate ( ) , ] ; } 
public function generate ( Customer $ customer , Order $ order ) { $ shopIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getShopIdentifier ( ) , 'objectType' => Shop :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ shopIdentity ) { throw new NotFoundException ( 'shop not mapped - ' . $ order -> getShopIdentifier ( ) ) ; } $ languageIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ customer -> getLanguageIdentifier ( ) , 'objectType' => Language :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ languageIdentity ) { throw new NotFoundException ( 'language not found - ' . $ customer -> getLanguageIdentifier ( ) ) ; } $ customerGroupIdentitiy = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ customer -> getCustomerGroupIdentifier ( ) , 'objectType' => CustomerGroup :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; $ customerParams = [ 'number' => $ customer -> getNumber ( ) , 'typeId' => 1 , 'firstName' => $ customer -> getFirstname ( ) , 'lastName' => $ customer -> getLastname ( ) , 'gender' => $ customer -> getGender ( ) === Customer :: GENDER_MALE ? 'male' : 'female' , 'lang' => $ languageIdentity -> getAdapterIdentifier ( ) , 'singleAccess' => $ customer -> getType ( ) === Customer :: TYPE_GUEST , 'plentyId' => $ shopIdentity -> getAdapterIdentifier ( ) , 'newsletterAllowanceAt' => '' , 'lastOrderAt' => $ order -> getOrderTime ( ) -> format ( DATE_W3C ) , 'options' => [ ] , 'referrerId' => 1 , ] ; if ( null !== $ customerGroupIdentitiy ) { $ customerParams [ 'classId' ] = ( int ) $ customerGroupIdentitiy -> getAdapterIdentifier ( ) ; } if ( null !== $ customer -> getBirthday ( ) ) { $ customerParams [ 'birthdayAt' ] = $ customer -> getBirthday ( ) -> format ( DATE_W3C ) ; } if ( $ customer -> getNewsletter ( ) ) { if ( null !== $ customer -> getNewsletterAgreementDate ( ) ) { $ customerParams [ 'newsletterAllowanceAt' ] = $ customer -> getNewsletterAgreementDate ( ) -> format ( DATE_W3C ) ; } else { $ customerParams [ 'newsletterAllowanceAt' ] = $ order -> getOrderTime ( ) -> format ( DATE_W3C ) ; } } if ( null !== $ customer -> getPhoneNumber ( ) ) { $ customerParams [ 'options' ] [ ] = [ 'typeId' => 1 , 'subTypeId' => 4 , 'value' => $ customer -> getPhoneNumber ( ) , 'priority' => 0 , ] ; } if ( null !== $ customer -> getMobilePhoneNumber ( ) ) { $ customerParams [ 'options' ] [ ] = [ 'typeId' => 1 , 'subTypeId' => 2 , 'value' => $ customer -> getMobilePhoneNumber ( ) , 'priority' => 0 , ] ; } if ( ! empty ( $ customer -> getEmail ( ) ) ) { $ customerParams [ 'options' ] [ ] = [ 'typeId' => 2 , 'subTypeId' => 4 , 'value' => $ customer -> getEmail ( ) , 'priority' => 0 , ] ; } return $ customerParams ; } 
public function generate ( Order $ order ) { $ shopIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getShopIdentifier ( ) , 'objectType' => Shop :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ shopIdentity ) { throw new NotFoundException ( 'shop not mapped' ) ; } $ languageIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getCustomer ( ) -> getLanguageIdentifier ( ) , 'objectType' => Language :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ languageIdentity ) { throw new NotFoundException ( 'language not mapped' ) ; } $ params = [ 'typeId' => 1 , 'plentyId' => $ shopIdentity -> getAdapterIdentifier ( ) , ] ; $ plentyCustomer = $ this -> handleCustomer ( $ order ) ; $ params [ 'relations' ] = [ [ 'referenceType' => 'contact' , 'referenceId' => $ plentyCustomer [ 'id' ] , 'relation' => 'receiver' , ] , ] ; $ params [ 'addressRelations' ] = [ ] ; $ billingAddress = $ this -> createAddress ( $ order -> getBillingAddress ( ) , $ order , $ plentyCustomer ) ; if ( ! empty ( $ billingAddress ) ) { $ params [ 'addressRelations' ] [ ] = [ 'typeId' => 1 , 'addressId' => $ billingAddress [ 'id' ] , ] ; } $ shippingAddress = $ this -> createAddress ( $ order -> getShippingAddress ( ) , $ order , $ plentyCustomer , 2 ) ; if ( ! empty ( $ shippingAddress ) ) { $ params [ 'addressRelations' ] [ ] = [ 'typeId' => 2 , 'addressId' => $ shippingAddress [ 'id' ] , ] ; } $ paymentMethodIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getPaymentMethodIdentifier ( ) , 'objectType' => PaymentMethod :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ paymentMethodIdentity ) { throw new NotFoundException ( 'missing payment method mapping' ) ; } $ shippingProfileIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ order -> getShippingProfileIdentifier ( ) , 'objectType' => ShippingProfile :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ shippingProfileIdentity ) { throw new NotFoundException ( 'shipping profile not mapped' ) ; } $ params [ 'properties' ] = [ [ 'typeId' => 6 , 'value' => ( string ) $ languageIdentity -> getAdapterIdentifier ( ) , ] , [ 'typeId' => 7 , 'value' => ( string ) $ order -> getOrderNumber ( ) , ] , [ 'typeId' => 3 , 'value' => ( string ) $ paymentMethodIdentity -> getAdapterIdentifier ( ) , ] , [ 'typeId' => 2 , 'value' => ( string ) $ shippingProfileIdentity -> getAdapterIdentifier ( ) , ] , ] ; $ vouchers = array_filter ( $ order -> getOrderItems ( ) , function ( OrderItem $ item ) { return $ item -> getType ( ) === OrderItem :: TYPE_VOUCHER ; } ) ; $ voucher = null ; if ( ! empty ( $ vouchers ) ) { $ voucher = array_shift ( $ vouchers ) ; } if ( null !== $ voucher ) { $ params [ 'properties' ] [ ] = [ 'typeId' => 18 , 'value' => ( string ) $ voucher -> getNumber ( ) , ] ; $ params [ 'properties' ] [ ] = [ 'typeId' => 19 , 'value' => 'fixed' , ] ; } $ params [ 'dates' ] = [ [ 'typeId' => 2 , 'date' => $ order -> getOrderTime ( ) -> format ( DATE_W3C ) , ] , ] ; $ params [ 'orderItems' ] = [ ] ; foreach ( $ order -> getOrderItems ( ) as $ orderItem ) { $ params [ 'orderItems' ] [ ] = $ this -> orderItemRequestGenerator -> generate ( $ orderItem , $ order ) ; } return $ params ; } 
private function createAddress ( Address $ address , Order $ order , array $ plentyCustomer , $ addressType = 1 ) { $ params = $ this -> addressReuqestGenerator -> generate ( $ address , $ order , $ addressType ) ; return $ this -> client -> request ( 'POST' , 'accounts/contacts/' . $ plentyCustomer [ 'id' ] . '/addresses' , $ params ) ; } 
private function findCustomer ( $ mail ) { $ customerResult = $ this -> client -> request ( 'GET' , 'accounts/contacts' , [ 'contactEmail' => $ mail , ] ) ; if ( empty ( $ customerResult ) ) { return null ; } $ possibleCustomers = array_filter ( $ customerResult , function ( $ entry ) { return $ entry [ 'singleAccess' ] !== '1' ; } ) ; if ( empty ( $ possibleCustomers ) ) { return null ; } return array_shift ( $ possibleCustomers ) ; } 
private function handleCustomer ( Order $ order ) { $ customer = $ order -> getCustomer ( ) ; $ plentyCustomer = false ; if ( $ customer -> getType ( ) === Customer :: TYPE_NORMAL ) { $ plentyCustomer = $ this -> findCustomer ( $ customer -> getEmail ( ) ) ; } $ customerParams = $ this -> customerRequestGenerator -> generate ( $ customer , $ order ) ; if ( ! $ plentyCustomer ) { $ plentyCustomer = $ this -> client -> request ( 'POST' , 'accounts/contacts' , $ customerParams ) ; } else { $ this -> client -> request ( 'PUT' , 'accounts/contacts/' . $ plentyCustomer [ 'id' ] , $ customerParams ) ; } return $ plentyCustomer ; } 
public function enqueue ( CommandInterface $ command ) { $ storage = reset ( $ this -> storages ) ; $ storage -> enqueue ( $ command ) ; } 
public function parse ( array $ entry ) { $ identity = $ this -> identityService -> findOneOrCreate ( ( string ) $ entry [ 'id' ] , ShopwareAdapter :: NAME , Country :: TYPE ) ; return Country :: fromArray ( [ 'identifier' => $ identity -> getObjectIdentifier ( ) , 'name' => $ entry [ 'name' ] , ] ) ; } 
public function parse ( array $ element ) { $ payments = $ this -> parentResponseParser -> parse ( $ element ) ; foreach ( $ payments as $ payment ) { if ( ! ( $ payment instanceof Payment ) ) { continue ; } $ this -> addAmazonPay ( $ payment , $ element ) ; } return $ payments ; } 
private function getAmazonPayData ( $ ordernumber ) { try { $ query = 'SELECT * FROM s_order_attributes WHERE orderID = ?' ; return $ this -> connection -> fetchAssoc ( $ query , [ $ ordernumber ] ) ; } catch ( Exception $ exception ) { return false ; } } 
public function generate ( Payment $ payment ) { $ paymentParams = $ this -> parentRequestGenerator -> generate ( $ payment ) ; $ data = $ payment -> getPaymentData ( ) ; if ( ! ( $ data instanceof KlarnaPaymentData ) ) { return $ paymentParams ; } $ paymentParams [ 'properties' ] [ ] = [ 'typeId' => 2 , 'value' => $ data -> getTransactionId ( ) . '_' . $ data -> getPclassId ( ) . '_' . $ data -> getShopId ( ) , ] ; return $ paymentParams ; } 
public function handle ( CommandInterface $ command ) { $ manufacturer = $ command -> getPayload ( ) ; $ params = [ 'name' => $ manufacturer -> getName ( ) , ] ; if ( null !== $ manufacturer -> getLink ( ) ) { $ params [ 'link' ] = $ manufacturer -> getLink ( ) ; } if ( null !== $ manufacturer -> getLogoIdentifier ( ) ) { $ mediaIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ manufacturer -> getLogoIdentifier ( ) , 'objectType' => Media :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null !== $ mediaIdentity ) { $ params [ 'image' ] = [ 'mediaId' => $ mediaIdentity -> getAdapterIdentifier ( ) , ] ; } } $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ manufacturer -> getIdentifier ( ) , 'objectType' => Manufacturer :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ identity ) { $ existingManufacturer = $ this -> findExistingManufacturer ( $ manufacturer ) ; if ( null !== $ existingManufacturer ) { $ identity = $ this -> identityService -> insert ( ( string ) $ manufacturer -> getIdentifier ( ) , Manufacturer :: TYPE , ( string ) $ existingManufacturer [ 'id' ] , ShopwareAdapter :: NAME ) ; } } if ( $ identity ) { try { $ this -> resource -> getOne ( $ identity -> getAdapterIdentifier ( ) ) ; } catch ( ManufacturerNotFoundException $ exception ) { $ this -> identityService -> remove ( $ identity ) ; $ identity = null ; } } if ( null === $ identity ) { $ manufacturerModel = $ this -> resource -> create ( $ params ) ; $ this -> identityService -> insert ( ( string ) $ manufacturer -> getIdentifier ( ) , Manufacturer :: TYPE , ( string ) $ manufacturerModel -> getId ( ) , ShopwareAdapter :: NAME ) ; } else { $ manufacturerModel = $ this -> resource -> update ( $ identity -> getAdapterIdentifier ( ) , $ params ) ; } $ this -> attributePersister -> saveManufacturerAttributes ( $ manufacturerModel , $ manufacturer -> getAttributes ( ) ) ; return true ; } 
private function findExistingManufacturer ( Manufacturer $ manufacturer ) { $ result = $ this -> resource -> getList ( 0 , 1 , [ 'supplier.name' => $ manufacturer -> getName ( ) , ] ) ; if ( 0 === count ( $ result [ 'data' ] ) ) { return null ; } return array_shift ( $ result [ 'data' ] ) ; } 
public function getClassProperties ( ) { return [ 'identifier' => $ this -> getIdentifier ( ) , 'active' => $ this -> isActive ( ) , 'productIdentifier' => $ this -> getProductIdentifier ( ) , 'name' => $ this -> getName ( ) , 'number' => $ this -> getNumber ( ) , 'position' => $ this -> getPosition ( ) , 'stock' => $ this -> getStock ( ) , 'stockLimitation' => $ this -> hasStockLimitation ( ) , 'prices' => $ this -> getPrices ( ) , 'vatRateIdentifier' => $ this -> getVatRateIdentifier ( ) , 'availableFrom' => $ this -> getAvailableFrom ( ) , 'availableTo' => $ this -> getAvailableTo ( ) , 'bundleProducts' => $ this -> getBundleProducts ( ) , 'attributes' => $ this -> getAttributes ( ) , 'translations' => $ this -> getTranslations ( ) , ] ; } 
public function parse ( array $ element ) { $ payments = $ this -> parentResponseParser -> parse ( $ element ) ; if ( ! $ this -> hasSepaPaymentInstance ( $ element ) ) { return $ payments ; } if ( empty ( $ payments ) ) { $ identifier = $ this -> getIdentifier ( $ element [ 'id' ] , Payment :: TYPE ) ; $ payment = new Payment ( ) ; $ payment -> setOrderIdentifer ( $ this -> getIdentifier ( $ element [ 'id' ] , Order :: TYPE ) ) ; $ payment -> setIdentifier ( $ identifier ) ; $ payment -> setShopIdentifier ( $ this -> getIdentifier ( $ element [ 'shopId' ] , Shop :: TYPE ) ) ; $ payment -> setTransactionReference ( $ identifier ) ; $ payment -> setCurrencyIdentifier ( $ this -> getIdentifier ( $ this -> getCurrencyId ( $ element [ 'currency' ] ) , Currency :: TYPE ) ) ; $ payment -> setPaymentMethodIdentifier ( $ this -> getIdentifier ( $ element [ 'paymentId' ] , PaymentMethod :: TYPE ) ) ; $ payments = [ $ payment ] ; } foreach ( $ payments as $ payment ) { if ( ! ( $ payment instanceof Payment ) ) { continue ; } $ payment -> setPaymentData ( $ this -> getSepaPaymentData ( $ element ) ) ; } return $ payments ; } 
private function getCurrencyId ( $ currency ) { $ currencyRepository = Shopware ( ) -> Models ( ) -> getRepository ( CurrencyModel :: class ) ; $ model = $ currencyRepository -> findOneBy ( [ 'currency' => $ currency ] ) ; if ( null === $ model ) { throw new InvalidArgumentException ( 'could not find currency model by currency: ' . $ currency ) ; } return $ model -> getId ( ) ; } 
private function getSepaPaymentData ( array $ element ) { $ paymentInstance = array_shift ( $ element [ 'paymentInstances' ] ) ; $ sepaPaymentData = new SepaPaymentData ( ) ; $ sepaPaymentData -> setAccountOwner ( $ paymentInstance [ 'accountHolder' ] ) ; $ sepaPaymentData -> setIban ( $ paymentInstance [ 'iban' ] ) ; $ sepaPaymentData -> setBic ( $ paymentInstance [ 'bic' ] ) ; return $ sepaPaymentData ; } 
private function hasSepaPaymentInstance ( array $ element ) { if ( empty ( $ element [ 'paymentInstances' ] ) ) { return false ; } $ paymentInstance = array_shift ( $ element [ 'paymentInstances' ] ) ; if ( empty ( $ paymentInstance [ 'iban' ] ) ) { return false ; } if ( empty ( $ paymentInstance [ 'bic' ] ) ) { return false ; } return true ; } 
public function getAll ( ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) ; $ queryBuilder -> from ( $ this -> table , 'config' ) ; $ queryBuilder -> select ( [ 'config.name' , 'config.value' , ] ) ; $ configElements = $ queryBuilder -> execute ( ) -> fetchAll ( ) ; $ result = [ ] ; foreach ( $ configElements as $ element ) { $ result [ $ element [ 'name' ] ] = $ element [ 'value' ] ; } return $ result ; } 
public function get ( $ name ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) ; $ queryBuilder -> from ( $ this -> table , 'config' ) ; $ queryBuilder -> select ( [ 'config.value' , ] ) ; $ queryBuilder -> andWhere ( 'config.name = :name' ) ; $ queryBuilder -> setParameter ( ':name' , $ name ) ; $ configValue = $ queryBuilder -> execute ( ) -> fetchColumn ( ) ; if ( ! $ configValue ) { return null ; } return $ configValue ; } 
public function set ( $ name , $ value ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) ; $ queryBuilder -> from ( $ this -> table , 'config' ) -> select ( [ 'config.name' ] ) -> where ( 'config.name = :name' ) -> setParameter ( ':name' , $ name ) ; $ configElement = $ queryBuilder -> execute ( ) -> fetchColumn ( ) ; if ( $ value instanceof DateTimeInterface ) { $ value = $ value -> format ( DATE_W3C ) ; } if ( ! empty ( $ configElement ) ) { $ this -> connection -> update ( $ this -> table , [ 'value' => $ value , ] , [ 'name' => $ name , ] ) ; } else { $ this -> connection -> insert ( $ this -> table , [ 'name' => $ name , 'value' => $ value , ] ) ; } } 
public function handle ( CommandInterface $ command ) { $ payment = $ command -> getPayload ( ) ; $ data = $ payment -> getPaymentData ( ) ; if ( ! ( $ data instanceof SepaPaymentData ) ) { return $ this -> parentCommandHandler -> handle ( $ command ) ; } $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ payment -> getIdentifier ( ) , 'objectType' => Payment :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null !== $ identity ) { return true ; } $ orderIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ payment -> getOrderIdentifer ( ) , 'objectType' => Order :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ orderIdentity ) { throw new NotFoundException ( 'could not find order for bank account handling - ' . $ payment -> getOrderIdentifer ( ) ) ; } $ contactId = $ this -> getContactIdentifier ( $ orderIdentity ) ; if ( null === $ contactId ) { throw new NotFoundException ( 'could not find contact for bank account handling - ' . $ payment -> getOrderIdentifer ( ) ) ; } $ bankAccounts = $ this -> client -> request ( 'GET' , 'accounts/contacts/' . $ contactId . '/banks' ) ; $ possibleBankAccounts = array_filter ( $ bankAccounts , function ( array $ bankAccount ) use ( $ data , $ orderIdentity ) { return $ bankAccount [ 'iban' ] === $ data -> getIban ( ) && $ bankAccount [ 'orderId' ] === ( int ) $ orderIdentity -> getAdapterIdentifier ( ) ; } ) ; if ( ! empty ( $ possibleBankAccounts ) ) { $ possibleBankAccounts = array_shift ( $ possibleBankAccounts ) ; $ this -> identityService -> insert ( $ payment -> getIdentifier ( ) , Payment :: TYPE , ( string ) $ possibleBankAccounts [ 'id' ] , PlentymarketsAdapter :: NAME ) ; return true ; } $ sepaPaymentDataParams = [ 'lastUpdateBy' => 'import' , 'accountOwner' => $ data -> getAccountOwner ( ) , 'iban' => $ data -> getIban ( ) , 'bic' => $ data -> getBic ( ) , 'orderId' => $ orderIdentity -> getAdapterIdentifier ( ) , 'contactId' => $ contactId , ] ; $ paymentResult = $ this -> client -> request ( 'POST' , 'accounts/contacts/banks' , $ sepaPaymentDataParams ) ; $ this -> identityService -> insert ( $ payment -> getIdentifier ( ) , Payment :: TYPE , ( string ) $ paymentResult [ 'id' ] , PlentymarketsAdapter :: NAME ) ; return true ; } 
private function getContactIdentifier ( Identity $ orderIdentity ) { $ order = $ this -> client -> request ( 'GET' , 'orders/' . $ orderIdentity -> getAdapterIdentifier ( ) ) ; $ relations = array_filter ( $ order [ 'relations' ] , function ( array $ relation ) { return $ relation [ 'referenceType' ] === 'contact' ; } ) ; if ( empty ( $ relations ) ) { return null ; } $ contactRelation = array_shift ( $ relations ) ; return $ contactRelation [ 'referenceId' ] ; } 
public function getClassProperties ( ) { return [ 'identifier' => $ this -> getIdentifier ( ) , 'mediaCategoryIdentifier' => $ this -> getMediaCategoryIdentifier ( ) , 'link' => $ this -> getLink ( ) , 'filename' => $ this -> getFilename ( ) , 'hash' => $ this -> getHash ( ) , 'name' => $ this -> getName ( ) , 'alternateName' => $ this -> getAlternateName ( ) , 'translations' => $ this -> getTranslations ( ) , 'attributes' => $ this -> getAttributes ( ) , ] ; } 
public function parse ( array $ entry ) { Assertion :: url ( $ entry [ 'link' ] ) ; if ( empty ( $ entry [ 'filename' ] ) ) { $ entry [ 'filename' ] = basename ( $ entry [ 'link' ] ) ; } if ( empty ( $ entry [ 'name' ] ) ) { $ entry [ 'name' ] = null ; } if ( empty ( $ entry [ 'alternateName' ] ) ) { $ entry [ 'alternateName' ] = null ; } if ( ! array_key_exists ( 'translations' , $ entry ) ) { $ entry [ 'translations' ] = [ ] ; } if ( ! array_key_exists ( 'attributes' , $ entry ) ) { $ entry [ 'attributes' ] = [ ] ; } if ( array_key_exists ( 'mediaCategory' , $ entry ) ) { $ mediaCategories = $ this -> categoryHelper -> getCategories ( ) ; $ mediaCategoryIdentity = $ this -> identityService -> findOneOrCreate ( ( string ) $ mediaCategories [ $ entry [ 'mediaCategory' ] ] [ 'id' ] , PlentymarketsAdapter :: NAME , MediaCategory :: TYPE ) ; $ entry [ 'mediaCategoryIdentifier' ] = $ mediaCategoryIdentity -> getObjectIdentifier ( ) ; } else { $ entry [ 'mediaCategoryIdentifier' ] = null ; } $ entry [ 'hash' ] = sha1 ( json_encode ( $ entry ) ) ; 
public function parse ( array $ variation ) { $ temporaryPrices = $ this -> getPricesAsSortedArray ( $ variation [ 'variationSalesPrices' ] ) ; $ prices = [ ] ; foreach ( $ temporaryPrices as $ customerGroup => $ priceArray ) { if ( ! isset ( $ priceArray [ 'default' ] ) ) { continue ; } if ( $ customerGroup === 'default' ) { $ customerGroup = null ; } foreach ( ( array ) $ priceArray [ 'default' ] as $ salesPrice ) { $ priceObject = new Price ( ) ; $ priceObject -> setPrice ( $ salesPrice [ 'price' ] ) ; $ priceObject -> setCustomerGroupIdentifier ( $ customerGroup ) ; $ priceObject -> setFromAmount ( $ salesPrice [ 'from' ] ) ; $ this -> addPseudoPrice ( $ priceObject , $ priceArray ) ; $ prices [ ] = $ priceObject ; } } foreach ( $ prices as $ price ) { $ possibleScalePrices = array_filter ( $ prices , function ( Price $ possiblePrice ) use ( $ price ) { return $ possiblePrice -> getCustomerGroupIdentifier ( ) === $ price -> getCustomerGroupIdentifier ( ) && spl_object_hash ( $ price ) !== spl_object_hash ( $ possiblePrice ) ; } ) ; if ( empty ( $ possibleScalePrices ) ) { continue ; } usort ( $ possibleScalePrices , function ( Price $ possibleScalePriceLeft , Price $ possibleScalePriceright ) { if ( $ possibleScalePriceLeft -> getFromAmount ( ) === $ possibleScalePriceright -> getFromAmount ( ) ) { return 0 ; } if ( $ possibleScalePriceLeft -> getFromAmount ( ) > $ possibleScalePriceright -> getFromAmount ( ) ) { return 1 ; } return - 1 ; } ) ; foreach ( $ possibleScalePrices as $ possibleScalePrice ) { if ( $ possibleScalePrice -> getFromAmount ( ) > $ price -> getFromAmount ( ) ) { $ price -> setToAmount ( $ possibleScalePrice -> getFromAmount ( ) - 1 ) ; break ; } } } return $ prices ; } 
private function checkIfOriginIsInReferrers ( $ orderOrigin , array $ referrers ) { foreach ( $ referrers as $ referrer ) { if ( $ referrer [ 'referrerId' ] === $ orderOrigin ) { return true ; } } return false ; } 
private function getPricesAsSortedArray ( array $ variationSalesPrices = [ ] ) { $ priceConfigurations = $ this -> getPriceConfigurations ( ) ; if ( empty ( $ priceConfigurations ) ) { $ this -> logger -> notice ( 'no valid price configuration found' ) ; return [ ] ; } static $ customerGroups ; if ( null === $ customerGroups ) { $ customerGroups = array_keys ( $ this -> itemsAccountsContacsClasses -> findAll ( ) ) ; } $ temporaryPrices = [ ] ; foreach ( $ variationSalesPrices as $ price ) { $ priceConfiguration = $ this -> filterPriceConfiguration ( $ priceConfigurations , $ price ) ; if ( empty ( $ priceConfiguration ) ) { 
private function getPriceConfigurations ( ) { static $ priceConfigurations ; if ( null === $ priceConfigurations ) { $ priceConfigurations = $ this -> itemsSalesPricesApi -> findAll ( ) ; $ shopIdentities = $ this -> identityService -> findBy ( [ 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Shop :: TYPE , ] ) ; $ shopIdentities = array_filter ( $ shopIdentities , function ( Identity $ identity ) { $ isMappedIdentity = $ this -> identityService -> isMappedIdentity ( $ identity -> getObjectIdentifier ( ) , $ identity -> getObjectType ( ) , $ identity -> getAdapterName ( ) ) ; if ( ! $ isMappedIdentity ) { return false ; } return true ; } ) ; if ( empty ( $ shopIdentities ) ) { $ priceConfigurations = [ ] ; return $ priceConfigurations ; } $ priceConfigurations = array_filter ( $ priceConfigurations , function ( $ priceConfiguration ) use ( $ shopIdentities ) { foreach ( $ shopIdentities as $ identity ) { foreach ( ( array ) $ priceConfiguration [ 'clients' ] as $ client ) { if ( $ client [ 'plentyId' ] === - 1 || $ identity -> getAdapterIdentifier ( ) === ( string ) $ client [ 'plentyId' ] ) { return true ; } } } return false ; } ) ; if ( empty ( $ priceConfigurations ) ) { $ this -> logger -> notice ( 'no valid price configuration found' ) ; } } return $ priceConfigurations ; } 
private function filterPriceConfiguration ( $ priceConfigurations , $ price ) { $ orderOrigin = ( int ) $ this -> configService -> get ( 'order_origin' ) ; $ priceConfiguration = array_filter ( $ priceConfigurations , function ( $ configuration ) use ( $ price ) { return $ configuration [ 'id' ] === $ price [ 'salesPriceId' ] ; } ) ; if ( 'true' === $ this -> configService -> get ( 'check_price_origin' ) ) { $ priceConfiguration = array_filter ( $ priceConfiguration , function ( $ configuration ) use ( $ price , $ orderOrigin ) { if ( $ this -> checkIfOriginIsInReferrers ( $ orderOrigin , ( array ) $ configuration [ 'referrers' ] ) ) { return $ configuration [ 'id' ] === $ price [ 'salesPriceId' ] ; } return false ; } ) ; } return $ priceConfiguration ; } 
public function enqueue ( CommandInterface $ command ) { $ serializedCommand = serialize ( $ command ) ; $ hash = md5 ( $ serializedCommand ) ; if ( $ this -> entryExists ( $ hash ) ) { return ; } $ this -> connection -> insert ( $ this -> table , [ 'payload' => $ serializedCommand , 'hash' => $ hash , 'priority' => $ command -> getPriority ( ) , 'time' => ( new DateTime ( 'now' ) ) -> format ( DATE_W3C ) , 'status' => BacklogService :: STATUS_OPEN , ] ) ; } 
public function dequeue ( ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) ; $ queryBuilder -> from ( $ this -> table , 'backlog' ) ; $ queryBuilder -> andWhere ( 'backlog.status = :status' ) ; $ queryBuilder -> setParameter ( ':status' , BacklogService :: STATUS_OPEN ) ; $ queryBuilder -> addOrderBy ( 'priority' , 'DESC' ) ; $ queryBuilder -> addOrderBy ( 'id' , 'ASC' ) ; $ queryBuilder -> setMaxResults ( 1 ) ; $ queryBuilder -> select ( '*' ) ; $ backlog = $ queryBuilder -> execute ( ) -> fetch ( PDO :: FETCH_ASSOC ) ; if ( empty ( $ backlog ) ) { return null ; } $ affectedRows = $ this -> connection -> update ( $ this -> table , [ 'status' => BacklogService :: STATUS_PROCESSED , ] , [ 'id' => $ backlog [ 'id' ] , ] ) ; if ( $ affectedRows !== 1 ) { return null ; } $ affectedRows = $ this -> connection -> delete ( $ this -> table , [ 'id' => $ backlog [ 'id' ] , ] ) ; if ( $ affectedRows !== 1 ) { return null ; } $ command = unserialize ( $ backlog [ 'payload' ] , [ 'allowed_classes' => true , ] ) ; if ( ! ( $ command instanceof CommandInterface ) ) { return null ; } return new HandleBacklogElementCommand ( $ command ) ; } 
private function entryExists ( $ hash ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) ; $ queryBuilder -> from ( $ this -> table , 'backlog' ) ; $ queryBuilder -> andWhere ( 'backlog.hash = :hash' ) ; $ queryBuilder -> setParameter ( ':hash' , $ hash ) ; $ queryBuilder -> setMaxResults ( 1 ) ; $ queryBuilder -> select ( 'backlog.id' ) ; $ backlog = $ queryBuilder -> execute ( ) -> fetch ( PDO :: FETCH_ASSOC ) ; if ( ! empty ( $ backlog ) ) { return true ; } return false ; } 
public function supports ( QueryInterface $ query ) { return $ query instanceof FetchTransferObjectQuery && $ query -> getAdapterName ( ) === ShopwareAdapter :: NAME && $ query -> getObjectType ( ) === Payment :: TYPE && $ query -> getQueryType ( ) === QueryType :: ONE ; } 
public function handle ( QueryInterface $ query ) { $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ query -> getObjectIdentifier ( ) , 'objectType' => Payment :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ identity ) { return [ ] ; } $ order = $ this -> dataProvider -> getOrderDetails ( $ identity -> getAdapterIdentifier ( ) ) ; $ order = $ this -> responseParser -> parse ( $ order ) ; return array_filter ( $ order ) ; } 
public function parse ( array $ entry ) { foreach ( $ entry [ 'details' ] as $ key => $ item ) { if ( ! isset ( $ item [ 'attribute' ] [ 'bundlePackageId' ] ) ) { continue ; } if ( $ item [ 'mode' ] !== 10 ) { unset ( $ entry [ 'details' ] [ $ key ] ) ; continue ; } $ entry [ 'details' ] [ $ key ] [ 'bundle' ] = 1 ; } return $ this -> parentOrderResponseParser -> parse ( $ entry ) ; } 
public function handle ( CommandInterface $ command ) { $ stock = $ command -> getPayload ( ) ; $ variationIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ stock -> getVariationIdentifier ( ) , 'objectType' => Variation :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ variationIdentity ) { $ this -> logger -> notice ( 'could not find variation identity - ' . $ stock -> getVariationIdentifier ( ) ) ; return false ; } $ this -> identityService -> findOneOrCreate ( $ variationIdentity -> getAdapterIdentifier ( ) , ShopwareAdapter :: NAME , Stock :: TYPE ) ; $ variationRespository = $ this -> entityManager -> getRepository ( Detail :: class ) ; $ variation = $ variationRespository -> find ( $ variationIdentity -> getAdapterIdentifier ( ) ) ; if ( null === $ variation ) { $ this -> logger -> notice ( 'could not find variation - ' . $ stock -> getVariationIdentifier ( ) ) ; return false ; } $ variation -> setInStock ( $ stock -> getStock ( ) ) ; $ this -> entityManager -> persist ( $ variation ) ; $ this -> entityManager -> flush ( ) ; $ this -> entityManager -> clear ( ) ; return true ; } 
public function handle ( CommandInterface $ command ) { $ payment = $ command -> getPayload ( ) ; $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ payment -> getIdentifier ( ) , 'objectType' => Payment :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null !== $ identity ) { return true ; } $ orderIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ payment -> getOrderIdentifer ( ) , 'objectType' => Order :: TYPE , 'adapterName' => PlentymarketsAdapter :: NAME , ] ) ; if ( null === $ orderIdentity ) { $ this -> logger -> notice ( 'order was not exported before payment handling' ) ; return false ; } $ paymentResult = $ this -> findOrCreatePlentyPayment ( $ payment ) ; if ( ( int ) $ orderIdentity -> getAdapterIdentifier ( ) === ( int ) $ paymentResult [ 'order' ] [ 'orderId' ] ) { return true ; } $ this -> client -> request ( 'POST' , 'payment/' . $ paymentResult [ 'id' ] . '/order/' . $ orderIdentity -> getAdapterIdentifier ( ) ) ; return true ; } 
private function findOrCreatePlentyPayment ( Payment $ payment ) { $ plentyPayments = $ this -> fetchPlentyPayments ( $ payment ) ; if ( $ plentyPayments ) { $ paymentResult = $ plentyPayments [ 0 ] ; $ this -> logger -> debug ( 'payment with the same transaction id "' . $ paymentResult [ 'id' ] . '" already exists.' ) ; } else { $ paymentResult = $ this -> createPlentyPayment ( $ payment ) ; } $ this -> identityService -> insert ( $ payment -> getIdentifier ( ) , Payment :: TYPE , ( string ) $ paymentResult [ 'id' ] , PlentymarketsAdapter :: NAME ) ; return $ paymentResult ; } 
private function fetchPlentyPayments ( $ payment ) { $ url = 'payments/property/1/' . $ payment -> getTransactionReference ( ) ; $ payments = $ this -> client -> request ( 'GET' , $ url ) ; if ( empty ( $ payments ) ) { return false ; } $ payments = array_filter ( $ payments , function ( array $ payment ) { return ! $ payment [ 'deleted' ] ; } ) ; return $ payments ; } 
private function createPlentyPayment ( Payment $ payment ) { $ params = $ this -> requestGenerator -> generate ( $ payment ) ; return $ this -> client -> request ( 'POST' , 'payments' , $ params ) ; } 
public function getClassProperties ( ) { return [ 'price' => $ this -> getPrice ( ) , 'pseudoPrice' => $ this -> getPseudoPrice ( ) , 'customerGroupIdentifier' => $ this -> getCustomerGroupIdentifier ( ) , 'fromAmount' => $ this -> getFromAmount ( ) , 'toAmount' => $ this -> getToAmount ( ) , ] ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( method_exists ( $ this -> logger , 'pushHandler' ) ) { $ this -> logger -> pushHandler ( new ConsoleHandler ( $ output ) ) ; } $ this -> outputHandler -> initialize ( $ input , $ output ) ; try { $ this -> cleanupService -> cleanup ( ) ; } catch ( Exception $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } catch ( Throwable $ exception ) { $ this -> logger -> error ( $ exception -> getMessage ( ) ) ; } } 
public function generate ( Payment $ payment ) { $ paymentParams = $ this -> parentRequestGenerator -> generate ( $ payment ) ; $ data = $ payment -> getPaymentData ( ) ; if ( ! ( $ data instanceof PayPalUnifiedInstallmentPaymentData ) ) { return $ paymentParams ; } $ paymentParams [ 'properties' ] [ ] = [ 'typeId' => 22 , 'value' => json_encode ( [ 'financingCosts' => $ data -> getFeeAmount ( ) , 'totalCostsIncludeFinancing' => $ data -> getTotalCost ( ) , 'monthlyPayment' => $ data -> getMonthlyPayment ( ) , 'term' => $ data -> getTerm ( ) , ] ) , ] ; return $ paymentParams ; } 
public function generate ( Product $ product ) { $ this -> addShippingProfilesAsAttributes ( $ product ) ; $ shopIdentifiers = array_filter ( $ product -> getShopIdentifiers ( ) , function ( $ identifier ) { $ shopIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ identifier , 'objectType' => Shop :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; return null !== $ shopIdentity ; } ) ; if ( empty ( $ shopIdentifiers ) ) { return [ ] ; } $ vatIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ product -> getVatRateIdentifier ( ) , 'objectType' => VatRate :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ vatIdentity ) { throw new InvalidArgumentException ( 'vat rate not mapped - ' . $ product -> getVatRateIdentifier ( ) ) ; } $ manufacturerIdentity = $ this -> identityService -> findOneBy ( [ 'adapterName' => ShopwareAdapter :: NAME , 'objectType' => Manufacturer :: TYPE , 'objectIdentifier' => $ product -> getManufacturerIdentifier ( ) , ] ) ; if ( null === $ manufacturerIdentity ) { throw new InvalidArgumentException ( 'manufacturer is missing - ' . $ product -> getManufacturerIdentifier ( ) ) ; } $ propertyData = $ this -> getPropertyData ( $ product ) ; $ params = [ 'filterGroupId' => $ propertyData [ 'filterGroupId' ] , 'propertyValues' => $ propertyData [ 'propertyValues' ] , 'mainDetail' => [ 'number' => $ product -> getNumber ( ) , ] , 'availableFrom' => $ product -> getAvailableFrom ( ) , 'availableTo' => $ product -> getAvailableTo ( ) , 'name' => $ product -> getName ( ) , 'description' => $ product -> getMetaDescription ( ) , 'descriptionLong' => ! empty ( $ product -> getLongDescription ( ) ) ? $ product -> getLongDescription ( ) : $ product -> getDescription ( ) , 'categories' => $ this -> getCategories ( $ product ) , 'seoCategories' => $ this -> getSeoCategories ( $ product ) , 'taxId' => $ vatIdentity -> getAdapterIdentifier ( ) , 'notification' => $ this -> configService -> get ( 'item_notification' ) === 'true' ? 1 : 0 , 'active' => $ product -> isActive ( ) , 'highlight' => $ this -> getHighlightFlag ( $ product ) , 'images' => $ this -> getImages ( $ product ) , 'similar' => $ this -> getLinkedProducts ( $ product ) , 'related' => $ this -> getLinkedProducts ( $ product , LinkedProduct :: TYPE_ACCESSORY ) , 'metaTitle' => $ product -> getMetaTitle ( ) , 'keywords' => $ product -> getMetaKeywords ( ) , 'changed' => ( new DateTime ( 'now' ) ) -> format ( 'Y-m-d H:i:s' ) , 'supplierId' => $ manufacturerIdentity -> getAdapterIdentifier ( ) , '__options_categories' => [ 'replace' => true ] , '__options_seoCategories' => [ 'replace' => true ] , '__options_similar' => [ 'replace' => true ] , '__options_related' => [ 'replace' => true ] , '__options_images' => [ 'replace' => true ] , ] ; $ configuratorSet = $ this -> configuratorSetRequestGenerator -> generate ( $ product ) ; if ( ! empty ( $ configuratorSet ) ) { $ params [ 'configuratorSet' ] = $ configuratorSet ; } return $ params ; } 
private function getLinkedProducts ( Product $ product , $ type = LinkedProduct :: TYPE_SIMILAR ) { $ result = [ ] ; foreach ( $ product -> getLinkedProducts ( ) as $ linkedProduct ) { if ( $ linkedProduct -> getType ( ) === $ type ) { $ productIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ linkedProduct -> getProductIdentifier ( ) , 'objectType' => Product :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ productIdentity ) { continue ; } $ productRepository = $ this -> entityManager -> getRepository ( Article :: class ) ; $ productExists = $ productRepository -> find ( $ productIdentity -> getAdapterIdentifier ( ) ) ; if ( ! $ productExists ) { continue ; } $ result [ $ productIdentity -> getAdapterIdentifier ( ) ] = [ 'id' => $ productIdentity -> getAdapterIdentifier ( ) , 'number' => null , 'position' => $ linkedProduct -> getPosition ( ) , 'cross' => false , ] ; } } return $ result ; } 
private function getPropertyData ( Product $ product ) { $ groupRepository = $ this -> entityManager -> getRepository ( GroupModel :: class ) ; $ propertyGroup = $ groupRepository -> findOneBy ( [ 'name' => 'PlentyConnector' ] ) ; if ( null === $ propertyGroup ) { $ propertyGroup = new GroupModel ( ) ; $ propertyGroup -> setName ( 'PlentyConnector' ) ; $ propertyGroup -> setPosition ( 1 ) ; $ propertyGroup -> setComparable ( true ) ; $ propertyGroup -> setSortMode ( 1 ) ; $ this -> entityManager -> persist ( $ propertyGroup ) ; $ this -> entityManager -> flush ( ) ; $ this -> entityManager -> clear ( ) ; } $ result = [ ] ; $ result [ 'filterGroupId' ] = $ propertyGroup -> getId ( ) ; $ result [ 'propertyValues' ] = [ ] ; foreach ( $ product -> getProperties ( ) as $ property ) { foreach ( $ property -> getValues ( ) as $ value ) { $ result [ 'propertyValues' ] [ ] = [ 'option' => [ 'name' => $ property -> getName ( ) , ] , 'value' => $ value -> getValue ( ) , ] ; } } return $ result ; } 
private function getImages ( Product $ product ) { $ images = [ ] ; foreach ( $ product -> getImages ( ) as $ image ) { $ shopIdentifiers = array_filter ( $ image -> getShopIdentifiers ( ) , function ( $ shop ) { $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ shop , 'objectType' => Shop :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; return $ identity !== null ; } ) ; if ( empty ( $ shopIdentifiers ) ) { continue ; } $ imageIdentity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => $ image -> getMediaIdentifier ( ) , 'objectType' => Media :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ imageIdentity ) { $ this -> logger -> notice ( 'image is missing - ' . $ image -> getMediaIdentifier ( ) ) ; return false ; } $ images [ ] = [ 'mediaId' => $ imageIdentity -> getAdapterIdentifier ( ) , 'position' => $ image -> getPosition ( ) , ] ; } return $ images ; } 
private function getCategories ( Product $ product ) { $ categoryRepository = $ this -> entityManager -> getRepository ( CategoryModel :: class ) ; $ shopRepository = $ this -> entityManager -> getRepository ( ShopModel :: class ) ; $ shopCategories = [ ] ; foreach ( $ product -> getShopIdentifiers ( ) as $ shopIdentifier ) { $ identities = $ this -> identityService -> findBy ( [ 'objectIdentifier' => ( string ) $ shopIdentifier , 'objectType' => Shop :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( $ identities === null ) { continue ; } foreach ( $ identities as $ identity ) { $ shop = $ shopRepository -> find ( $ identity -> getAdapterIdentifier ( ) ) ; if ( $ shop !== null ) { $ shopCategories [ ] = $ shop -> getCategory ( ) -> getId ( ) ; } } } $ this -> categories = [ ] ; foreach ( $ product -> getCategoryIdentifiers ( ) as $ categoryIdentifier ) { $ categoryIdentities = $ this -> identityService -> findBy ( [ 'objectIdentifier' => $ categoryIdentifier , 'objectType' => Category :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; foreach ( $ categoryIdentities as $ categoryIdentity ) { if ( in_array ( $ categoryIdentity -> getAdapterIdentifier ( ) , array_column ( $ this -> categories , 'id' ) , true ) ) { continue ; } $ category = $ categoryRepository -> find ( $ categoryIdentity -> getAdapterIdentifier ( ) ) ; if ( null === $ category ) { continue ; } $ extractedCategoryPath = array_filter ( explode ( '|' , $ category -> getPath ( ) ) ) ; $ matchedShopCategories = array_intersect ( $ extractedCategoryPath , $ shopCategories ) ; if ( empty ( $ matchedShopCategories ) ) { continue ; } $ this -> categories [ ] = [ 'id' => $ categoryIdentity -> getAdapterIdentifier ( ) , ] ; } } return $ this -> categories ; } 
private function getHighlightFlag ( Product $ product ) { foreach ( $ product -> getBadges ( ) as $ badge ) { if ( $ badge -> getType ( ) === Badge :: TYPE_HIGHLIGHT ) { return 1 ; } } return 0 ; } 
public function handle ( CommandInterface $ command ) { $ identifier = $ command -> getPayload ( ) ; $ identity = $ this -> identityService -> findOneBy ( [ 'objectIdentifier' => ( string ) $ identifier , 'objectType' => Stock :: TYPE , 'adapterName' => ShopwareAdapter :: NAME , ] ) ; if ( null === $ identity ) { $ this -> logger -> notice ( 'no matching identity found' , [ 'command' => $ command ] ) ; return false ; } $ identities = $ this -> identityService -> findBy ( [ 'objectIdentifier' => $ identifier , ] ) ; array_walk ( $ identities , function ( Identity $ identity ) { $ this -> identityService -> remove ( $ identity ) ; } ) ; return true ; } 
public function getCustomerGroupKeyByShopwareIdentifier ( $ identifier ) { $ group = $ this -> repository -> find ( $ identifier ) ; if ( null === $ group ) { return null ; } return $ group -> getKey ( ) ; } 
public function create ( $ adapterName , $ objectType , $ commandType , $ priority , $ payload ) { Assertion :: string ( $ adapterName ) ; Assertion :: string ( $ objectType ) ; Assertion :: inArray ( $ commandType , CommandType :: getAllTypes ( ) ) ; Assertion :: integer ( $ priority ) ; if ( $ commandType === CommandType :: HANDLE ) { Assertion :: isInstanceOf ( $ payload , TransferObjectInterface :: class ) ; } if ( $ commandType === CommandType :: REMOVE ) { Assertion :: uuid ( $ payload ) ; } $ command = null ; switch ( $ commandType ) { case CommandType :: HANDLE : $ command = new TransferObjectCommand ( $ adapterName , $ objectType , $ commandType , $ priority , $ payload ) ; break ; case CommandType :: REMOVE : $ command = new TransferObjectCommand ( $ adapterName , $ objectType , $ commandType , $ priority , $ payload ) ; break ; } if ( null === $ command ) { throw MissingCommandException :: fromObjectData ( $ objectType , $ commandType ) ; } return $ command ; } 
public function status ( $ token ) { $ data = array ( 'token' => $ token , ) ; $ ch = $ this -> __initRequest ( 'from_url/status' , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; return $ data ; } 
private function fromUrlOld ( $ url , $ check_status = true , $ timeout = 1 , $ max_attempts = 5 ) { Helper :: deprecate ( '2.0.0' , '3.0.0' , 'This version of method `fromUrl($url, $check_status, $timeout, $max_attempts)` is deprecated please use `fromUrl($url, $options)` instead' ) ; return $ this -> fromUrlNew ( $ url , array ( 'check_status' => $ check_status , 'timeout' => $ timeout , 'max_attempts' => $ max_attempts , ) ) ; } 
private function fromUrlNew ( $ url , $ options = array ( ) ) { $ default_options = array ( 'store' => 'auto' , 'filename' => null , 'check_status' => true , 'timeout' => 1 , 'max_attempts' => 5 , ) ; $ params = array_merge ( $ default_options , $ options ) ; $ check_status = $ params [ 'check_status' ] ; $ timeout = $ params [ 'timeout' ] ; $ max_attempts = $ params [ 'max_attempts' ] ; $ requestData = array ( '_' => time ( ) , 'source_url' => $ url , 'pub_key' => $ this -> api -> getPublicKey ( ) , 'store' => $ params [ 'store' ] , ) ; if ( $ params [ 'filename' ] ) { $ requestData [ 'filename' ] = $ params [ 'filename' ] ; } $ ch = $ this -> __initRequest ( 'from_url' , $ requestData ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; $ token = $ data -> token ; if ( $ check_status ) { $ success = false ; $ attempts = 0 ; while ( ! $ success ) { $ data = $ this -> status ( $ token ) ; if ( $ data -> status == 'success' ) { $ success = true ; } if ( $ data -> status == 'error' ) { throw new \ Exception ( 'Upload is not successful: ' . $ data -> error ) ; } if ( $ attempts == $ max_attempts && $ data -> status != 'success' ) { throw new \ Exception ( 'Max attempts reached, upload is not successful' ) ; } sleep ( $ timeout ) ; $ attempts ++ ; } } else { return $ token ; } $ uuid = $ data -> uuid ; return new File ( $ uuid , $ this -> api ) ; } 
public function fromPath ( $ path , $ mime_type = false ) { if ( function_exists ( 'curl_file_create' ) ) { if ( $ mime_type ) { $ f = curl_file_create ( $ path , $ mime_type ) ; } else { $ f = curl_file_create ( $ path ) ; } } else { if ( $ mime_type ) { $ f = '@' . $ path . ';type=' . $ mime_type ; } else { $ f = '@' . $ path ; } } $ data = array ( 'UPLOADCARE_PUB_KEY' => $ this -> api -> getPublicKey ( ) , 'file' => $ f , ) ; $ ch = $ this -> __initRequest ( 'base' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; $ uuid = $ data -> file ; return new File ( $ uuid , $ this -> api ) ; } 
public function fromResource ( $ fp ) { $ tmpfile = tempnam ( sys_get_temp_dir ( ) , 'ucr' ) ; $ temp = fopen ( $ tmpfile , 'w' ) ; while ( ! feof ( $ fp ) ) { fwrite ( $ temp , fread ( $ fp , 8192 ) ) ; } fclose ( $ temp ) ; fclose ( $ fp ) ; return $ this -> fromPath ( $ tmpfile ) ; } 
public function fromContent ( $ content , $ mime_type ) { $ tmpfile = tempnam ( sys_get_temp_dir ( ) , 'ucr' ) ; $ temp = fopen ( $ tmpfile , 'w' ) ; fwrite ( $ temp , $ content ) ; fclose ( $ temp ) ; return $ this -> fromPath ( $ tmpfile , $ mime_type ) ; } 
public function createGroup ( $ files ) { $ data = array ( 'pub_key' => $ this -> api -> getPublicKey ( ) , ) ; foreach ( $ files as $ i => $ file ) { $ data [ "files[$i]" ] = $ file -> getUrl ( ) ; } $ ch = $ this -> __initRequest ( 'group' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ resp = $ this -> __runRequest ( $ ch ) ; $ group = $ this -> api -> getGroup ( $ resp -> id ) ; return $ group ; } 
private function __initRequest ( $ type , $ data = null ) { $ url = sprintf ( 'https://%s/%s/' , $ this -> host , $ type ) ; if ( is_array ( $ data ) ) { $ url = sprintf ( '%s?%s' , $ url , http_build_query ( $ data ) ) ; } $ ch = curl_init ( $ url ) ; return $ ch ; } 
private function __setHeaders ( $ ch ) { curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'User-Agent: ' . $ this -> api -> getUserAgentHeader ( ) , ) ) ; } 
private function __runRequest ( $ ch ) { $ data = curl_exec ( $ ch ) ; $ ch_info = curl_getinfo ( $ ch ) ; if ( $ data === false ) { throw new \ Exception ( curl_error ( $ ch ) ) ; } elseif ( $ ch_info [ 'http_code' ] != 200 ) { throw new \ Exception ( 'Unexpected HTTP status code ' . $ ch_info [ 'http_code' ] . '.' . curl_error ( $ ch ) ) ; } curl_close ( $ ch ) ; return json_decode ( $ data ) ; } 
public function getScriptTag ( $ version = null , $ async = false , $ full = true ) { $ async_attr = $ async ? 'async="true"' : '' ; $ result = <<<EOT <script>UPLOADCARE_PUBLIC_KEY = "{$this->api->getPublicKey()}";</script> <script {$async_attr} src="{$this->getScriptSrc($version, $full)}" charset="UTF-8"></script> EOT ; return $ result ; } 
public function getScriptSrc ( $ version = null , $ full = true ) { if ( ! $ version ) { $ version = self :: VERSION ; } if ( $ full ) { $ tail = "uploadcare.full.min.js" ; } else { $ tail = "uploadcare.min.js" ; } return sprintf ( $ this -> api -> getCdnUri ( ) . '/libs/widget/%s/' . $ tail , $ version ) ; } 
public function getIntegrationData ( ) { $ integrationData = '' ; $ framework = $ this -> api -> getFramework ( ) ; if ( $ framework ) { $ integrationData .= $ framework ; } $ extension = $ this -> api -> getExtension ( ) ; if ( $ extension ) { $ integrationData .= '; ' . $ extension ; } return $ integrationData ; } 
public function getInputTag ( $ name , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<input type="hidden" role="uploadcare-uploader" name="%s" data-upload-url-base="" data-integration="%s" %s />' , $ name , $ this -> getIntegrationData ( ) , join ( ' ' , $ to_compile ) ) ; } 
public static function dateTimeString ( $ datetime ) { if ( $ datetime === null ) { return null ; } if ( is_object ( $ datetime ) && ! ( $ datetime instanceof \ DateTime ) ) { throw new \ Exception ( 'Only \DateTime objects allowed' ) ; } if ( is_string ( $ datetime ) ) { $ datetime = new \ DateTime ( $ datetime ) ; } return $ datetime -> format ( "Y-m-d\TH:i:s.uP" ) ; } 
public function getGroupsChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'group_list' , 'GET' , $ options ) ; $ groups_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ groups_raw as $ group_raw ) { $ resultArr [ ] = new Group ( $ group_raw -> id , $ this ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; } 
public function getFilesChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'file_list' , 'GET' , $ options ) ; $ files_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ resultArr [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; } 
public function getFileList ( $ options = array ( ) ) { $ options = array_replace ( array ( 'from' => null , 'to' => null , 'limit' => null , 'request_limit' => null , 'stored' => $ this -> defaultFilters [ 'file' ] [ 'stored' ] , 'removed' => $ this -> defaultFilters [ 'file' ] [ 'removed' ] , 'reversed' => false , ) , $ options ) ; if ( ! empty ( $ options [ 'from' ] ) && ! empty ( $ options [ 'to' ] ) ) { throw new \ Exception ( 'Only one of "from" and "to" arguments is allowed' ) ; } $ options [ 'from' ] = self :: dateTimeString ( $ options [ 'from' ] ) ; $ options [ 'to' ] = self :: dateTimeString ( $ options [ 'to' ] ) ; foreach ( $ this -> defaultFilters [ 'file' ] as $ k => $ v ) { if ( ! is_null ( $ options [ $ k ] ) ) { $ options [ $ k ] = self :: booleanString ( $ options [ $ k ] ) ; } } return new FileIterator ( $ this , $ options ) ; } 
public function getGroupList ( $ options = array ( ) ) { $ options = array_replace ( array ( 'from' => null , 'to' => null , 'limit' => null , 'request_limit' => null , 'reversed' => false , ) , $ options ) ; if ( ! empty ( $ options [ 'from' ] ) && ! empty ( $ options [ 'to' ] ) ) { throw new \ Exception ( 'Only one of "from" and "to" arguments is allowed' ) ; } $ options [ 'from' ] = self :: dateTimeString ( $ options [ 'from' ] ) ; $ options [ 'to' ] = self :: dateTimeString ( $ options [ 'to' ] ) ; return new GroupIterator ( $ this , $ options ) ; } 
public function copyFile ( $ source , $ target = null ) { Helper :: deprecate ( '2.0.0' , '3.0.0' , 'Use createLocalCopy() or createRemoteCopy() instead' ) ; if ( ! $ target ) { return $ this -> createLocalCopy ( $ source ) ; } else { return $ this -> createRemoteCopy ( $ source , $ target ) ; } } 
public function createLocalCopy ( $ source , $ store = true ) { $ data = $ this -> __preparedRequest ( 'file_copy' , 'POST' , array ( ) , array ( 'source' => $ source , 'store' => $ store ) ) ; if ( array_key_exists ( 'result' , ( array ) $ data ) == true ) { if ( $ data -> type == 'file' ) { return new File ( ( string ) $ data -> result -> uuid , $ this ) ; } else { return ( string ) $ data -> result ; } } else { return ( string ) $ data -> detail ; } } 
public function createRemoteCopy ( $ source , $ target , $ make_public = true , $ pattern = null ) { if ( ! $ target ) { throw new \ Exception ( '$target parameter should not be empty.' ) ; } $ paramArr = array ( 'source' => $ source , 'target' => $ target , 'make_public' => $ make_public ) ; if ( $ pattern ) { $ paramArr [ 'pattern' ] = $ pattern ; } $ data = $ this -> __preparedRequest ( 'file_copy' , 'POST' , array ( ) , $ paramArr ) ; if ( array_key_exists ( 'result' , ( array ) $ data ) == true ) { return ( string ) $ data -> result ; } else { return ( string ) $ data -> detail ; } } 
public function __batchProcessFiles ( $ filesUuidArr , $ request_type ) { $ filesChunkedArr = array_chunk ( $ filesUuidArr , $ this -> batchFilesChunkSize ) ; $ filesArr = array ( ) ; $ problemsArr = array ( ) ; $ lastStatus = '' ; foreach ( $ filesChunkedArr as $ chunk ) { $ res = $ this -> __batchProcessFilesChunk ( $ chunk , $ request_type ) ; $ lastStatus = $ res [ 'status' ] ; if ( $ lastStatus == "ok" ) { $ problemsObj = $ res [ 'problems' ] ; if ( count ( get_object_vars ( $ problemsObj ) ) > 0 ) { $ problemsArr [ ] = $ problemsObj ; } $ filesArr = array_merge ( $ filesArr , $ res [ 'files' ] ) ; } else { throw new \ Exception ( 'Error process multiple files' , $ res ) ; } } return array ( 'status' => $ lastStatus , 'files' => $ filesArr , 'problems' => $ problemsArr , ) ; } 
public function __batchProcessFilesChunk ( $ filesUuidArr , $ request_type ) { if ( count ( $ filesUuidArr ) > $ this -> batchFilesChunkSize ) { throw new \ Exception ( 'Files number should not exceed ' . $ this -> batchFilesChunkSize . ' items per request.' ) ; } $ data = $ this -> __preparedRequest ( 'files_storage' , $ request_type , array ( ) , $ filesUuidArr ) ; $ files_raw = ( array ) $ data -> result ; $ result = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ result [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return array ( 'status' => ( string ) $ data -> status , 'files' => $ result , 'problems' => $ data -> problems , ) ; } 
public function request ( $ method , $ path , $ data = array ( ) , $ headers = array ( ) ) { $ ch = curl_init ( sprintf ( 'https://%s%s' , $ this -> api_host , $ path ) ) ; $ this -> __setRequestType ( $ ch , $ method ) ; $ this -> __setHeaders ( $ ch , $ headers , $ data ) ; $ response = curl_exec ( $ ch ) ; if ( $ response === false ) { throw new \ Exception ( curl_error ( $ ch ) ) ; } $ ch_info = curl_getinfo ( $ ch ) ; $ header_size = curl_getinfo ( $ ch , CURLINFO_HEADER_SIZE ) ; $ header = substr ( $ response , 0 , $ header_size ) ; $ body = substr ( $ response , $ header_size ) ; $ error = false ; if ( $ method == 'DELETE' ) { if ( $ ch_info [ 'http_code' ] != 302 && $ ch_info [ 'http_code' ] != 200 ) { $ error = true ; } } else { if ( ! ( ( $ ch_info [ 'http_code' ] >= 200 ) && ( $ ch_info [ 'http_code' ] < 300 ) ) ) { $ error = true ; } } if ( $ ch_info [ 'http_code' ] == 429 ) { $ exception = new ThrottledRequestException ( ) ; $ response_headers = Helper :: parseHttpHeaders ( $ header ) ; $ exception -> setResponseHeaders ( $ response_headers ) ; throw $ exception ; } if ( $ error ) { $ errorInfo = array_filter ( array ( curl_error ( $ ch ) , $ body ) ) ; throw new \ Exception ( 'Request returned unexpected http code ' . $ ch_info [ 'http_code' ] . '. ' . join ( ', ' , $ errorInfo ) ) ; } curl_close ( $ ch ) ; if ( ! defined ( 'PHPUNIT_UPLOADCARE_TESTSUITE' ) && ( $ this -> public_key == 'demopublic_key' || $ this -> secret_key == 'demoprivatekey' ) ) { trigger_error ( 'You are using the demo account. Please get an Uploadcare account at https://uploadcare.com/accounts/create/' , E_USER_WARNING ) ; } return json_decode ( $ body ) ; } 
public function __preparedRequest ( $ type , $ request_type = 'GET' , $ params = array ( ) , $ data = array ( ) , $ retry_throttled = null ) { $ retry_throttled = $ retry_throttled ? : $ this -> retry_throttled ; $ path = $ this -> __getPath ( $ type , $ params ) ; while ( true ) { try { return $ this -> request ( $ request_type , $ path , $ data ) ; } catch ( ThrottledRequestException $ exception ) { if ( $ retry_throttled > 0 ) { sleep ( $ exception -> getTimeout ( ) ) ; $ retry_throttled -- ; continue ; } else { throw $ exception ; } } } return null ; } 
private function __preparePagedParams ( $ data , $ reverse , $ resultArr ) { $ nextParamsArr = parse_url ( $ data -> next ) ; $ prevParamsArr = parse_url ( $ data -> previous ) ; $ nextParamsArr = array_replace ( array ( 'query' => null ) , $ nextParamsArr ) ; $ prevParamsArr = array_replace ( array ( 'query' => null ) , $ prevParamsArr ) ; parse_str ( parse_url ( ! $ reverse ? $ data -> next : $ data -> previous , PHP_URL_QUERY ) , $ params ) ; if ( $ reverse ) { $ resultArr = array_reverse ( $ resultArr ) ; } return array ( 'nextParams' => $ reverse ? $ prevParamsArr : $ nextParamsArr , 'prevParams' => ! $ reverse ? $ prevParamsArr : $ nextParamsArr , 'params' => $ params , 'data' => $ resultArr , ) ; } 
private function __getQueryString ( $ queryAr = array ( ) , $ prefixIfNotEmpty = '' ) { $ queryAr = array_filter ( $ queryAr ) ; array_walk ( $ queryAr , function ( & $ val , $ key ) { $ val = urlencode ( $ key ) . '=' . urlencode ( $ val ) ; } ) ; return $ queryAr ? $ prefixIfNotEmpty . join ( '&' , $ queryAr ) : '' ; } 
private function __getPath ( $ type , $ params = array ( ) ) { switch ( $ type ) { case 'root' : return '/' ; case 'account' : return '/account/' ; case 'file_list' : return '/files/' . $ this -> __getQueryString ( $ params , '?' ) ; case 'file_storage' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/files/%s/storage/' , $ params [ 'uuid' ] ) ; case 'file_copy' : return '/files/' ; case 'files_storage' : return '/files/storage/' ; case 'file' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/files/%s/' , $ params [ 'uuid' ] ) ; case 'group_list' : return '/groups/' . $ this -> __getQueryString ( $ params , '?' ) ; case 'group' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/groups/%s/' , $ params [ 'uuid' ] ) ; case 'group_storage' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/groups/%s/storage/' , $ params [ 'uuid' ] ) ; default : throw new \ Exception ( 'No api url type is provided for request "' . $ type . '". Use store, or appropriate constants.' ) ; } } 
private function __setRequestType ( $ ch , $ type = 'GET' ) { $ this -> current_method = strtoupper ( $ type ) ; switch ( $ type ) { case 'GET' : break ; case 'POST' : curl_setopt ( $ ch , CURLOPT_POST , true ) ; break ; case 'PUT' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'PUT' ) ; break ; case 'DELETE' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'DELETE' ) ; break ; case 'HEAD' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'HEAD' ) ; curl_setopt ( $ ch , CURLOPT_NOBODY , true ) ; break ; case 'OPTIONS' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'OPTIONS' ) ; break ; default : throw new \ Exception ( 'No request type is provided for request. Use post, put, delete, get or appropriate constants.' ) ; } } 
public function getUserAgentHeader ( ) { 
private function __setHeaders ( $ ch , $ add_headers = array ( ) , $ data = array ( ) ) { $ content_length = 0 ; $ rawContent = '' ; if ( count ( $ data ) ) { $ rawContent = utf8_encode ( json_encode ( $ data ) ) ; $ content_length = strlen ( $ rawContent ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ rawContent ) ; } 
public function updateInfo ( ) { $ this -> cached_data = ( array ) $ this -> api -> __preparedRequest ( 'file' , 'GET' , array ( 'uuid' => $ this -> uuid ) ) ; return $ this -> cached_data ; } 
public function copy ( $ target = null ) { Helper :: deprecate ( '2.0.0' , '3.0.0' , 'Use createLocalCopy() or createRemoteCopy() instead' ) ; return $ this -> api -> copyFile ( $ this -> getUrl ( ) , $ target ) ; } 
public function createRemoteCopy ( $ target , $ make_public = true , $ pattern = '${default}' ) { return $ this -> api -> createRemoteCopy ( $ this -> getUrl ( ) , $ target , $ make_public , $ pattern ) ; } 
public function getUrl ( $ postfix = null ) { $ url = sprintf ( '%s%s' , $ this -> api -> getCdnUri ( ) , $ this -> getPath ( $ postfix ) ) ; return $ url ; } 
public function getPath ( $ postfix = null ) { $ url = sprintf ( '/%s/' , $ this -> uuid ) ; if ( $ this -> default_effects ) { $ url = sprintf ( '%s-/%s' , $ url , $ this -> default_effects ) ; } if ( $ this -> filename && $ postfix === null ) { $ postfix = $ this -> filename ; } $ operations = array ( ) ; foreach ( $ this -> operations as $ i => $ operation_item ) { $ part = array ( ) ; foreach ( array_keys ( $ operation_item ) as $ operation_type ) { $ operation_params = $ operation_item [ $ operation_type ] ; $ part [ ] = $ operation_type ; switch ( $ operation_type ) { case 'crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; $ part = $ this -> __addPartFillColor ( $ part , $ operation_params ) ; break ; case 'resize' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'scale_crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; break ; case 'effect' : $ part = $ this -> __addPartEffect ( $ part , $ operation_params ) ; break ; case 'preview' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'custom' : $ part = array ( $ operation_params ) ; break ; } $ part_str = join ( '/' , $ part ) ; $ operations [ ] = $ part_str ; } } if ( count ( $ operations ) ) { $ operations_part = join ( '/-/' , $ operations ) ; return $ url . '-/' . $ operations_part . '/' . $ postfix ; } else { return $ url . $ postfix ; } } 
public function getImgTag ( $ postfix = null , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<img src="%s" %s />' , $ this -> getUrl ( ) , join ( ' ' , $ to_compile ) ) ; } 
public function crop ( $ width , $ height , $ center = false , $ fill_color = false ) { if ( ! $ width || ! $ height ) { throw new \ Exception ( 'Please provide both $width and $height' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'crop' ] = array ( 'width' => $ width , 'height' => $ height , 'center' => $ center , 'fill_color' => $ fill_color , ) ; return $ result ; } 
public function resize ( $ width = false , $ height = false ) { if ( ! $ width && ! $ height ) { throw new \ Exception ( 'Please, provide at least $width or $height for resize' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'resize' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; } 
public function preview ( $ width , $ height ) { if ( ! $ width || ! $ height ) { throw new \ Exception ( 'Please, provide both width and height for preview' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'preview' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; } 
public function scaleCrop ( $ width , $ height , $ center = false ) { if ( ! $ width || ! $ height ) { throw new \ Exception ( 'Please, provide both $width and $height' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'scale_crop' ] = array ( 'width' => $ width , 'height' => $ height , 'center' => $ center , ) ; return $ result ; } 
public function effect ( $ effect ) { if ( ! $ effect ) { return $ this ; } $ result = clone $ this ; $ result -> operations [ ] [ 'effect' ] = $ effect ; return $ result ; } 
public function op ( $ operation ) { if ( ! $ operation ) { return $ this ; } $ result = clone $ this ; $ result -> operations [ ] [ 'custom' ] = $ operation ; return $ result ; } 
private function exists ( $ offset = null ) { return isset ( $ this -> container [ $ offset !== null ? $ offset : $ this -> position ] ) ; } 
private function isFullyLoaded ( ) { return $ this -> fullyLoaded || ( $ this -> limit && count ( $ this -> container ) >= $ this -> limit ) ; } 
private function loadChunk ( ) { $ portion = $ this -> pdGetDataChunk ( $ this -> api , $ this -> options , $ this -> reverse ) ; $ this -> options = $ portion [ 'params' ] ; $ this -> nextPageParams = $ portion [ 'nextParams' ] ; $ this -> prevPageParams = $ portion [ 'prevParams' ] ; if ( $ portion [ 'data' ] ) { $ this -> container = array_merge ( $ this -> container , $ portion [ 'data' ] ) ; } if ( ! count ( $ portion [ 'params' ] ) ) { $ this -> fullyLoaded = true ; } } 
public function getFiles ( ) { $ result = array ( ) ; foreach ( $ this -> data [ 'files' ] as $ file ) { if ( $ file ) { $ result [ ] = new File ( $ file -> uuid , $ this -> api , $ file ) ; } } return $ result ; } 
public function flush ( $ args , $ assoc_args ) { 
public function structure ( $ args , $ assoc_args ) { global $ wp_rewrite ; 
public function list_ ( $ args , $ assoc_args ) { global $ wp_rewrite ; $ rules = get_option ( 'rewrite_rules' ) ; if ( ! $ rules ) { $ rules = [ ] ; WP_CLI :: warning ( 'No rewrite rules.' ) ; } self :: check_skip_plugins_themes ( ) ; $ defaults = [ 'source' => '' , 'match' => '' , 'format' => 'table' , 'fields' => 'match,query,source' , ] ; $ assoc_args = array_merge ( $ defaults , $ assoc_args ) ; $ rewrite_rules_by_source = [ ] ; $ rewrite_rules_by_source [ 'post' ] = $ wp_rewrite -> generate_rewrite_rules ( $ wp_rewrite -> permalink_structure , EP_PERMALINK ) ; $ rewrite_rules_by_source [ 'date' ] = $ wp_rewrite -> generate_rewrite_rules ( $ wp_rewrite -> get_date_permastruct ( ) , EP_DATE ) ; $ rewrite_rules_by_source [ 'root' ] = $ wp_rewrite -> generate_rewrite_rules ( $ wp_rewrite -> root . '/' , EP_ROOT ) ; $ rewrite_rules_by_source [ 'comments' ] = $ wp_rewrite -> generate_rewrite_rules ( $ wp_rewrite -> root . $ wp_rewrite -> comments_base , EP_COMMENTS , true , true , true , false ) ; $ rewrite_rules_by_source [ 'search' ] = $ wp_rewrite -> generate_rewrite_rules ( $ wp_rewrite -> get_search_permastruct ( ) , EP_SEARCH ) ; $ rewrite_rules_by_source [ 'author' ] = $ wp_rewrite -> generate_rewrite_rules ( $ wp_rewrite -> get_author_permastruct ( ) , EP_AUTHORS ) ; $ rewrite_rules_by_source [ 'page' ] = $ wp_rewrite -> page_rewrite_rules ( ) ; 
private static function apache_modules ( ) { $ mods = WP_CLI :: get_config ( 'apache_modules' ) ; if ( ! empty ( $ mods ) && ! function_exists ( 'apache_get_modules' ) ) { global $ is_apache ; 
private static function check_skip_plugins_themes ( ) { $ skipped = [ ] ; if ( WP_CLI :: get_config ( 'skip-plugins' ) ) { $ skipped [ ] = 'plugins' ; } if ( WP_CLI :: get_config ( 'skip-themes' ) ) { $ skipped [ ] = 'themes' ; } if ( empty ( $ skipped ) ) { return ; } $ skipped = implode ( ' and ' , $ skipped ) ; WP_CLI :: warning ( sprintf ( "Some rewrite rules may be missing because %s weren't loaded." , $ skipped ) ) ; } 
public function attach ( EventManagerInterface $ events , $ priority = 1 ) { $ this -> listeners [ ] = $ events -> attach ( AnnotationBuilder :: EVENT_CONFIGURE_FIELD , [ $ this , 'handleFilterField' ] ) ; $ this -> listeners [ ] = $ events -> attach ( AnnotationBuilder :: EVENT_CONFIGURE_FIELD , [ $ this , 'handleTypeField' ] ) ; $ this -> listeners [ ] = $ events -> attach ( AnnotationBuilder :: EVENT_CONFIGURE_FIELD , [ $ this , 'handleValidatorField' ] ) ; $ this -> listeners [ ] = $ events -> attach ( AnnotationBuilder :: EVENT_CONFIGURE_FIELD , [ $ this , 'handleRequiredField' ] ) ; $ this -> listeners [ ] = $ events -> attach ( AnnotationBuilder :: EVENT_EXCLUDE_FIELD , [ $ this , 'handleExcludeField' ] ) ; $ this -> listeners [ ] = $ events -> attach ( AnnotationBuilder :: EVENT_CONFIGURE_ASSOCIATION , [ $ this , 'handleToOne' ] ) ; $ this -> listeners [ ] = $ events -> attach ( AnnotationBuilder :: EVENT_CONFIGURE_ASSOCIATION , [ $ this , 'handleToMany' ] ) ; $ this -> listeners [ ] = $ events -> attach ( AnnotationBuilder :: EVENT_CONFIGURE_ASSOCIATION , [ $ this , 'handleRequiredAssociation' ] ) ; $ this -> listeners [ ] = $ events -> attach ( AnnotationBuilder :: EVENT_EXCLUDE_ASSOCIATION , [ $ this , 'handleExcludeAssociation' ] ) ; } 
protected function prepareEvent ( EventInterface $ event ) { foreach ( [ 'elementSpec' , 'inputSpec' ] as $ type ) { if ( ! $ event -> getParam ( $ type ) ) { $ event -> setParam ( $ type , new ArrayObject ( ) ) ; } } $ elementSpec = $ event -> getParam ( 'elementSpec' ) ; $ inputSpec = $ event -> getParam ( 'inputSpec' ) ; if ( ! isset ( $ elementSpec [ 'spec' ] ) ) { $ elementSpec [ 'spec' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'filters' ] ) ) { $ inputSpec [ 'filters' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'validators' ] ) ) { $ inputSpec [ 'validators' ] = [ ] ; } } 
public function init ( ModuleManagerInterface $ manager ) { 
public function collect ( MvcEvent $ mvcEvent ) { if ( ! $ this -> classMetadataFactory ) { return ; } $ metadata = $ this -> classMetadataFactory -> getAllMetadata ( ) ; $ this -> classes = [ ] ; foreach ( $ metadata as $ class ) { $ this -> classes [ $ class -> getName ( ) ] = $ class ; } ksort ( $ this -> classes ) ; } 
public function unserialize ( $ serialized ) { $ data = unserialize ( $ serialized ) ; $ this -> name = $ data [ 'name' ] ; $ this -> classes = $ data [ 'classes' ] ; } 
public function generateFromMetadata ( array $ metadata ) { $ this -> metadata = $ metadata ; $ this -> visitedAssociations = [ ] ; $ str = [ ] ; foreach ( $ metadata as $ class ) { $ parent = $ this -> getParent ( $ class ) ; if ( $ parent ) { $ str [ ] = $ this -> getClassString ( $ parent ) . '^' . $ this -> getClassString ( $ class ) ; } $ associations = $ class -> getAssociationNames ( ) ; if ( empty ( $ associations ) && ! isset ( $ this -> visitedAssociations [ $ class -> getName ( ) ] ) ) { $ str [ ] = $ this -> getClassString ( $ class ) ; continue ; } foreach ( $ associations as $ associationName ) { if ( $ parent && in_array ( $ associationName , $ parent -> getAssociationNames ( ) ) ) { continue ; } if ( $ this -> visitAssociation ( $ class -> getName ( ) , $ associationName ) ) { $ str [ ] = $ this -> getAssociationString ( $ class , $ associationName ) ; } } } return implode ( ',' , $ str ) ; } 
private function getClassString ( ClassMetadata $ class ) { $ this -> visitAssociation ( $ class -> getName ( ) ) ; $ className = $ class -> getName ( ) ; $ classText = '[' . str_replace ( '\\' , '.' , $ className ) ; $ fields = [ ] ; $ parent = $ this -> getParent ( $ class ) ; $ parentFields = $ parent ? $ parent -> getFieldNames ( ) : [ ] ; foreach ( $ class -> getFieldNames ( ) as $ fieldName ) { if ( in_array ( $ fieldName , $ parentFields ) ) { continue ; } if ( $ class -> isIdentifier ( $ fieldName ) ) { $ fields [ ] = '+' . $ fieldName ; } else { $ fields [ ] = $ fieldName ; } } if ( ! empty ( $ fields ) ) { $ classText .= '|' . implode ( ';' , $ fields ) ; } $ classText .= ']' ; return $ classText ; } 
private function getClassByName ( $ className ) { if ( ! isset ( $ this -> classByNames [ $ className ] ) ) { foreach ( $ this -> metadata as $ class ) { if ( $ class -> getName ( ) === $ className ) { $ this -> classByNames [ $ className ] = $ class ; break ; } } } return $ this -> classByNames [ $ className ] ?? null ; } 
private function visitAssociation ( $ className , $ association = null ) { if ( null === $ association ) { if ( isset ( $ this -> visitedAssociations [ $ className ] ) ) { return false ; } $ this -> visitedAssociations [ $ className ] = [ ] ; return true ; } if ( isset ( $ this -> visitedAssociations [ $ className ] [ $ association ] ) ) { return false ; } if ( ! isset ( $ this -> visitedAssociations [ $ className ] ) ) { $ this -> visitedAssociations [ $ className ] = [ ] ; } $ this -> visitedAssociations [ $ className ] [ $ association ] = true ; return true ; } 
private function getFormFactory ( ContainerInterface $ services ) { $ elements = null ; if ( $ services -> has ( 'FormElementManager' ) ) { $ elements = $ services -> get ( 'FormElementManager' ) ; } return new Factory ( $ elements ) ; } 
public function setEventManager ( EventManagerInterface $ events ) { parent :: setEventManager ( $ events ) ; ( new ElementAnnotationsListener ( $ this -> objectManager ) ) -> attach ( $ this -> getEventManager ( ) ) ; return $ this ; } 
public function getFormSpecification ( $ entity ) { $ formSpec = parent :: getFormSpecification ( $ entity ) ; $ metadata = $ this -> objectManager -> getClassMetadata ( is_object ( $ entity ) ? get_class ( $ entity ) : $ entity ) ; $ inputFilter = $ formSpec [ 'input_filter' ] ; $ formElements = [ Element \ ObjectSelect :: class , Element \ ObjectMultiCheckbox :: class , Element \ ObjectRadio :: class , ] ; foreach ( $ formSpec [ 'elements' ] as $ key => $ elementSpec ) { $ name = $ elementSpec [ 'spec' ] [ 'name' ] ?? null ; $ isFormElement = ( isset ( $ elementSpec [ 'spec' ] [ 'type' ] ) && in_array ( $ elementSpec [ 'spec' ] [ 'type' ] , $ formElements ) ) ; if ( ! $ name ) { continue ; } if ( ! isset ( $ inputFilter [ $ name ] ) ) { $ inputFilter [ $ name ] = new \ ArrayObject ( ) ; } $ params = [ 'metadata' => $ metadata , 'name' => $ name , 'elementSpec' => $ elementSpec , 'inputSpec' => $ inputFilter [ $ name ] , ] ; if ( $ this -> checkForExcludeElementFromMetadata ( $ metadata , $ name ) ) { $ elementSpec = $ formSpec [ 'elements' ] ; unset ( $ elementSpec [ $ key ] ) ; $ formSpec [ 'elements' ] = $ elementSpec ; if ( isset ( $ inputFilter [ $ name ] ) ) { unset ( $ inputFilter [ $ name ] ) ; } $ formSpec [ 'input_filter' ] = $ inputFilter ; continue ; } if ( $ metadata -> hasField ( $ name ) || ( ! $ metadata -> hasAssociation ( $ name ) && $ isFormElement ) ) { $ this -> getEventManager ( ) -> trigger ( static :: EVENT_CONFIGURE_FIELD , $ this , $ params ) ; } elseif ( $ metadata -> hasAssociation ( $ name ) ) { $ this -> getEventManager ( ) -> trigger ( static :: EVENT_CONFIGURE_ASSOCIATION , $ this , $ params ) ; } } $ formSpec [ 'options' ] = [ 'prefer_form_input_filter' => true ] ; return $ formSpec ; } 
public function getItems ( $ offset , $ itemCountPerPage ) { $ this -> paginator -> getQuery ( ) -> setFirstResult ( $ offset ) -> setMaxResults ( $ itemCountPerPage ) ; return $ this -> paginator -> getIterator ( ) ; } 
public function createService ( ServiceLocatorInterface $ serviceLocator ) { if ( $ serviceLocator instanceof AbstractPluginManager ) { $ serviceLocator = $ serviceLocator -> getServiceLocator ( ) ? : $ serviceLocator ; } return $ this ( $ serviceLocator , YumlController :: class ) ; } 
public function indexAction ( ) { $ request = $ this -> getRequest ( ) ; $ this -> httpClient -> setMethod ( Request :: METHOD_POST ) ; $ this -> httpClient -> setParameterPost ( [ 'dsl_text' => $ request -> getPost ( 'dsl_text' ) ] ) ; $ response = $ this -> httpClient -> send ( ) ; if ( ! $ response -> isSuccess ( ) ) { throw new \ UnexpectedValueException ( 'HTTP Request failed' ) ; } $ redirect = $ this -> plugin ( 'redirect' ) ; return $ redirect -> toUrl ( 'https://yuml.me/' . $ response -> getBody ( ) ) ; } 
public function webImage ( $ path ) { $ directory = $ this -> webDir . '/' ; return $ this -> imageHandling -> open ( $ directory . $ path ) ; } 
protected function getFilename ( $ filename ) { $ callback = $ this -> fileCallback ; if ( null === $ callback || substr ( $ filename , 0 , 1 ) == '/' ) { return $ filename ; } return $ callback ( $ filename ) ; } 
public function open ( $ file ) { if ( strlen ( $ file ) >= 1 && $ file [ 0 ] == '@' ) { try { if ( $ this -> fileLocator instanceof FileLocatorInterface ) { $ file = $ this -> fileLocator -> locate ( $ file ) ; } else { $ this -> fileLocator -> locateResource ( $ file ) ; } } catch ( \ InvalidArgumentException $ exception ) { if ( $ this -> throwException || false == $ this -> fallbackImage ) { throw $ exception ; } $ file = $ this -> fallbackImage ; } } return $ this -> createInstance ( $ file ) ; } 
private function createInstance ( $ file , $ w = null , $ h = null ) { $ container = $ this -> container ; $ webDir = $ container -> getParameter ( 'gregwar_image.web_dir' ) ; $ handlerClass = $ this -> handlerClass ; $ image = new $ handlerClass ( $ file , $ w , $ h , $ this -> throwException , $ this -> fallbackImage ) ; $ image -> setCacheDir ( $ this -> cacheDirectory ) ; $ image -> setCacheDirMode ( $ this -> cacheDirMode ) ; $ image -> setActualCacheDir ( $ webDir . '/' . $ this -> cacheDirectory ) ; if ( $ container -> has ( 'templating.helper.assets' ) ) { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ container -> get ( 'templating.helper.assets' ) -> getUrl ( $ file ) ; } ) ; } else { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ this -> assetsPackages -> getUrl ( $ file ) ; } ) ; } return $ image ; } 
public function getRemind ( ) { if ( \ Session :: has ( 'message' ) ) { $ message = \ Session :: get ( 'message' ) ; } else { $ message = \ Lang :: get ( 'panel::fields.enterEmail' ) ; } return \ View :: make ( 'panelViews::passwordReminder' ) -> with ( 'message' , $ message ) -> with ( 'mesType' , \ Session :: get ( 'mesType' ) ) ; } 
public function postRemind ( ) { \ App :: make ( 'route' ) ; \ Config :: set ( 'auth.defaults.passwords' , 'panel' ) ; $ response = \ Password :: sendResetLink ( Input :: only ( 'email' ) , function ( $ message ) { $ message -> subject ( 'Password Reminder' ) ; } ) ; switch ( $ response ) { case PasswordBrokerContract :: INVALID_USER : return \ Redirect :: back ( ) -> with ( 'message' , \ Lang :: get ( $ response ) ) -> with ( 'mesType' , 'error' ) ; case PasswordBrokerContract :: RESET_LINK_SENT : return \ Redirect :: back ( ) -> with ( 'message' , \ Lang :: get ( $ response ) ) -> with ( 'mesType' , 'info' ) ; } } 
public function getChangePassword ( ) { $ demo = false ; if ( \ Config :: get ( 'panel.demo' ) == true ) { $ demo = true ; } return \ View :: make ( 'panelViews::passwordChange' ) -> with ( 'demo_status' , $ demo ) ; } 
public function postChangePassword ( ) { $ user = Admin :: find ( \ Auth :: guard ( 'panel' ) -> user ( ) -> id ) ; $ password = Input :: only ( 'current_password' ) ; $ new_password = Input :: only ( 'password' ) ; $ retype_password = Input :: only ( 'password_confirmation' ) ; $ user_password = \ Auth :: guard ( 'panel' ) -> user ( ) -> password ; 
public static function getItems ( ) { if ( ! self :: $ dashboardItems ) { self :: $ dashboardItems = \ App :: call ( self :: class . '@create' ) ; } return self :: $ dashboardItems ; } 
private function showLink ( $ link ) { if ( ! $ link [ 'show_menu' ] ) return false ; $ user = \ Auth :: guard ( 'panel' ) -> user ( ) ; return $ user -> hasRole ( 'super' ) || $ user -> hasPermission ( '/' . $ link [ 'url' ] . '/all' ) ; } 
public function create ( AppHelper $ appHelper , LinkRepository $ linkRepository ) { 
protected function getDefaultNamespace ( $ rootNamespace ) { $ controllersPath = \ Config :: get ( 'panel.controllers' ) ; if ( isset ( $ controllersPath ) && $ controllersPath != NULL ) { return $ controllersPath ; } else { return $ rootNamespace . '\Http\Controllers' ; } } 
public function handle ( ) { $ this -> info ( ' [ ServerFireTeam Panel Crud Generator ] ' ) ; $ crudName = $ this -> argument ( 'name' ) ; $ this -> call ( 'panel:createmodel' , [ 'name' => $ crudName ] ) ; $ this -> call ( 'panel:createcontroller' , [ 'name' => $ crudName ] ) ; Link :: create ( [ 'url' => $ crudName , 'display' => $ crudName . 's' , 'show_menu' => true , ] ) ; if ( ! \ Schema :: hasTable ( $ crudName ) ) { $ this -> info ( ' The Table Corresponding to this Model does not exist in Database!! ' ) ; $ this -> info ( ' Please Create this table ' ) ; } } 
public function up ( ) { Schema :: create ( 'links' , function ( $ table ) { $ table -> increments ( 'id' ) ; $ table -> string ( 'display' ) ; $ table -> string ( 'url' ) ; $ table -> timestamps ( ) ; 
public function up ( ) { Schema :: create ( 'roles' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> string ( 'name' ) ; $ table -> string ( 'label' ) -> nullable ( ) ; $ table -> timestamps ( ) ; } ) ; Schema :: create ( 'permissions' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> string ( 'name' ) ; $ table -> string ( 'label' ) -> nullable ( ) ; $ table -> timestamps ( ) ; } ) ; Schema :: create ( 'permission_role' , function ( Blueprint $ table ) { $ table -> integer ( 'permission_id' ) -> unsigned ( ) ; $ table -> integer ( 'role_id' ) -> unsigned ( ) ; $ table -> foreign ( 'permission_id' ) -> references ( 'id' ) -> on ( 'permissions' ) -> onDelete ( 'cascade' ) ; $ table -> foreign ( 'role_id' ) -> references ( 'id' ) -> on ( 'roles' ) -> onDelete ( 'cascade' ) ; $ table -> primary ( [ 'permission_id' , 'role_id' ] ) ; } ) ; Schema :: create ( 'admin_role' , function ( Blueprint $ table ) { $ table -> integer ( 'role_id' ) -> unsigned ( ) ; $ table -> integer ( 'admin_id' ) -> unsigned ( ) ; $ table -> foreign ( 'role_id' ) -> references ( 'id' ) -> on ( 'roles' ) -> onDelete ( 'cascade' ) ; $ table -> foreign ( 'admin_id' ) -> references ( 'id' ) -> on ( 'admins' ) -> onDelete ( 'cascade' ) ; $ table -> primary ( [ 'role_id' , 'admin_id' ] ) ; } ) ; 
public function down ( ) { Schema :: table ( 'admin_role' , function ( $ table ) { $ table -> dropForeign ( [ 'role_id' ] ) ; $ table -> dropForeign ( [ 'admin_id' ] ) ; } ) ; Schema :: drop ( 'admin_role' ) ; Schema :: drop ( 'permission_role' ) ; Schema :: drop ( 'permissions' ) ; Schema :: drop ( 'roles' ) ; } 
public function postLogin ( ) { $ userdata = array ( 'email' => Input :: get ( 'email' ) , 'password' => Input :: get ( 'password' ) ) ; 
public function getModel ( $ entity ) { if ( \ Links :: isMain ( $ entity ) ) { $ modelClass = 'Serverfireteam\\Panel\\' . $ entity ; } else { if ( ! empty ( \ Config :: get ( 'panel.modelPath' ) ) ) { $ modelClass = $ this -> getNameSpace ( ) . \ Config :: get ( 'panel.modelPath' ) . '\\' . $ entity ; } else { $ modelClass = $ this -> getNameSpace ( ) . $ entity ; } } return $ modelClass ; } 
public function handle ( $ request , Closure $ next ) { if ( is_null ( \ Auth :: guard ( 'panel' ) -> user ( ) ) ) { $ message = session ( 'message' , Lang :: get ( 'panel::fields.enterEmail' ) ) ; return redirect ( '/panel/login' ) -> with ( 'message' , $ message ) -> with ( 'mesType' , 'message' ) ; } return $ next ( $ request ) ; } 
public function hasRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles -> contains ( 'name' , $ role ) ; } return ! ! $ role -> intersect ( $ this -> roles ) -> count ( ) ; } 
public function hasPermission ( $ permission ) { $ permission = Permission :: whereName ( $ permission ) -> first ( ) ; if ( is_null ( $ permission ) ) { return false ; } return $ this -> hasRole ( $ permission -> roles ) ; } 
public function authenticate ( ) { $ user = $ this -> findUser ( ) ; if ( $ user === false ) { return new AuthenticationResult ( AuthenticationResult :: FAILURE_IDENTITY_NOT_FOUND , array ( ) , array ( 'User not found.' ) ) ; } $ validationResult = $ this -> passwordValidator -> isValid ( $ this -> credential , $ user [ $ this -> credentialColumn ] , $ user [ $ this -> identityColumn ] ) ; if ( $ validationResult -> isValid ( ) ) { 
private function findUser ( ) { $ sql = sprintf ( 'SELECT * FROM %s WHERE %s = :identity' , $ this -> getTableName ( ) , $ this -> getIdentityColumn ( ) ) ; $ stmt = $ this -> db -> prepare ( $ sql ) ; $ stmt -> execute ( array ( 'identity' => $ this -> getIdentity ( ) ) ) ; 
private function getRole ( $ identity = null ) { if ( is_object ( $ identity ) ) { return $ identity -> getRole ( ) ; } if ( is_array ( $ identity ) && isset ( $ identity [ 'role' ] ) ) { return $ identity [ 'role' ] ; } return 'guest' ; } 
public function authenticate ( $ identity , $ credential ) { $ adapter = $ this -> auth -> getAdapter ( ) ; $ adapter -> setIdentity ( $ identity ) ; $ adapter -> setCredential ( $ credential ) ; return $ this -> auth -> authenticate ( ) ; } 
protected function writeProgress ( string $ progress ) : void { $ this -> numTestsRun ++ ; if ( $ this -> hasReplacementSymbol ( $ progress ) ) { $ progress = static :: $ symbols [ $ progress ] ; } $ padding = str_pad ( $ this -> numTestsRun , strlen ( $ this -> numTests ) , ' ' , STR_PAD_LEFT ) ; $ this -> write ( "({$padding}/{$this->numTests}) {$progress} {$this->testRow}" . PHP_EOL ) ; } 
public function addError ( Test $ test , \ Throwable $ e , float $ time ) : void { $ this -> buildTestRow ( get_class ( $ test ) , $ test -> getName ( ) , $ time , 'fg-red' ) ; parent :: addError ( $ test , $ e , $ time ) ; } 
public function addFailure ( Test $ test , AssertionFailedError $ e , float $ time ) : void { $ this -> buildTestRow ( get_class ( $ test ) , $ test -> getName ( ) , $ time , 'fg-red' ) ; parent :: addFailure ( $ test , $ e , $ time ) ; } 
public function addWarning ( Test $ test , Warning $ e , float $ time ) : void { $ this -> buildTestRow ( get_class ( $ test ) , $ test -> getName ( ) , $ time , 'fg-yellow' ) ; parent :: addWarning ( $ test , $ e , $ time ) ; } 
public function sendResetLinkEmail ( Request $ request ) { $ this -> validateEmail ( $ request ) ; $ user = $ this -> broker ( ) -> getUser ( $ request -> only ( 'email' ) ) ; 
public function redirectAfterConfirmationPath ( ) { if ( method_exists ( $ this , 'redirectConfirmationTo' ) ) { return $ this -> redirectConfirmationTo ( ) ; } return property_exists ( $ this , 'redirectConfirmationTo' ) ? $ this -> redirectConfirmationTo : route ( 'login' ) ; } 
public function redirectAfterRegistrationPath ( ) { if ( method_exists ( $ this , 'redirectAfterRegistrationTo' ) ) { return $ this -> redirectAfterRegistrationTo ( ) ; } return property_exists ( $ this , 'redirectAfterRegistrationTo' ) ? $ this -> redirectAfterRegistrationTo : route ( 'login' ) ; } 
public function redirectAfterResendConfirmationPath ( ) { if ( method_exists ( $ this , 'redirectAfterResendConfirmationTo' ) ) { return $ this -> redirectAfterResendConfirmationTo ( ) ; } return property_exists ( $ this , 'redirectAfterResendConfirmationTo' ) ? $ this -> redirectAfterResendConfirmationTo : route ( 'login' ) ; } 
public function confirm ( $ confirmation_code ) { $ model = $ this -> guard ( ) -> getProvider ( ) -> createModel ( ) ; $ user = $ model -> where ( 'confirmation_code' , $ confirmation_code ) -> firstOrFail ( ) ; $ user -> confirmation_code = null ; $ user -> confirmed_at = now ( ) ; $ user -> save ( ) ; event ( new Confirmed ( $ user ) ) ; return $ this -> confirmed ( $ user ) ? : redirect ( $ this -> redirectAfterConfirmationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_successful' ) ) ; } 
public function resendConfirmation ( Request $ request ) { $ model = $ this -> guard ( ) -> getProvider ( ) -> createModel ( ) ; $ user = $ model -> findOrFail ( $ request -> session ( ) -> pull ( 'confirmation_user_id' ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return redirect ( $ this -> redirectAfterResendConfirmationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_resent' ) ) ; } 
public function register ( Request $ request ) { $ this -> validator ( $ request -> all ( ) ) -> validate ( ) ; event ( new Registered ( $ user = $ this -> create ( $ request -> all ( ) ) ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return $ this -> registered ( $ request , $ user ) ? : redirect ( $ this -> redirectAfterRegistrationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_info' ) ) ; } 
protected function sendConfirmationToUser ( $ user ) { 
protected function attemptLogin ( Request $ request ) { if ( $ this -> guard ( ) -> validate ( $ this -> credentials ( $ request ) ) ) { $ user = $ this -> guard ( ) -> getLastAttempted ( ) ; if ( ! is_null ( $ user -> confirmed_at ) ) { return $ this -> baseAttemptLogin ( $ request ) ; } session ( [ 'confirmation_user_id' => $ user -> getKey ( ) ] ) ; throw ValidationException :: withMessages ( [ 'confirmation' => [ __ ( 'confirmation::confirmation.not_confirmed' , [ 'resend_link' => route ( 'auth.resend_confirmation' ) ] ) ] ] ) ; } return false ; } 
public function toMail ( $ notifiable ) { return ( new MailMessage ) -> subject ( __ ( 'confirmation::confirmation.confirmation_subject' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_subject_title' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_body' ) ) -> action ( __ ( 'confirmation::confirmation.confirmation_button' ) , url ( "register/confirm/$notifiable->confirmation_code" ) ) ; } 
public function removeDotSegments ( $ path ) { $ new_path = '' ; while ( ! empty ( $ path ) ) { 
public function urlDecodeUnreservedChars ( $ string ) { $ string = rawurldecode ( $ string ) ; $ string = rawurlencode ( $ string ) ; $ string = str_replace ( array ( '%2F' , '%3A' , '%40' ) , array ( '/' , ':' , '@' ) , $ string ) ; return $ string ; } 
private function parseStr ( $ string ) { $ params = array ( ) ; $ pairs = explode ( '&' , $ string ) ; foreach ( $ pairs as $ pair ) { if ( ! $ pair ) { continue ; } $ var = explode ( '=' , $ pair , 2 ) ; $ val = ( isset ( $ var [ 1 ] ) ? $ var [ 1 ] : '' ) ; if ( isset ( $ params [ $ var [ 0 ] ] ) ) { if ( is_array ( $ params [ $ var [ 0 ] ] ) ) { $ params [ $ var [ 0 ] ] [ ] = $ val ; } else { $ params [ $ var [ 0 ] ] = array ( $ params [ $ var [ 0 ] ] , $ val ) ; } } else { $ params [ $ var [ 0 ] ] = $ val ; } } return $ params ; } 
public function get ( $ arguments = [ ] ) { try { $ this -> makeRequest ( $ arguments ) ; } catch ( ConnectException $ e ) { $ url = $ e -> getRequest ( ) -> getUrl ( ) ; return $ this -> errorResponse ( $ e -> getCode ( ) , $ e -> getMessage ( ) , $ url ) ; } catch ( RequestException $ e ) { $ url = $ e -> getRequest ( ) -> getUrl ( ) ; $ status = $ e -> getCode ( ) ; $ response = $ e -> getResponse ( ) ; $ reason = $ e -> getMessage ( ) ; if ( ! is_null ( $ response ) ) { $ reason = $ response -> getReasonPhrase ( ) ; } return $ this -> errorResponse ( $ status , $ reason , $ url ) ; } return $ this -> parseBlueprint ( $ this -> schemaBlueprint ) ; } 
protected function makeRequest ( $ arguments = [ ] ) { $ defaults = $ this -> getDefaultOptions ( ) ; $ arguments = array_merge ( $ defaults , $ arguments ) ; $ client = $ this -> resource -> getGuzzle ( ) ; $ request = $ client -> createRequest ( $ this -> getMethod ( ) , $ this -> url , $ arguments ) ; $ response = $ client -> send ( $ request ) ; $ this -> setResponse ( $ response ) ; $ this -> setContent ( ( string ) $ response -> getBody ( ) ) ; } 
public function apply ( $ node , ApistMethod $ method ) { if ( is_array ( $ node ) ) { return $ this -> applyToArray ( $ node , $ method ) ; } if ( $ this -> methodName === 'else' ) { if ( is_bool ( $ node ) ) $ node = ! $ node ; $ this -> methodName = 'then' ; } $ filter = new ApistFilter ( $ node , $ method ) ; if ( method_exists ( $ filter , $ this -> methodName ) ) { return call_user_func_array ( [ $ filter , $ this -> methodName ] , $ this -> arguments ) ; } if ( $ this -> isResourceMethod ( $ method ) ) { return $ this -> callResourceMethod ( $ method , $ node ) ; } if ( $ this -> isNodeMethod ( $ node ) ) { return $ this -> callNodeMethod ( $ node ) ; } if ( $ this -> isGlobalFunction ( ) ) { return $ this -> callGlobalFunction ( $ node ) ; } throw new \ InvalidArgumentException ( "Method '{$this->methodName}' was not found" ) ; } 
public function getValue ( ApistMethod $ method , Crawler $ rootNode = null ) { if ( is_null ( $ rootNode ) ) { $ rootNode = $ method -> getCrawler ( ) ; } $ result = $ rootNode -> filter ( $ this -> selector ) ; return $ this -> applyResultCallbackChain ( $ result , $ method ) ; } 
protected function applyResultCallbackChain ( Crawler $ node , ApistMethod $ method ) { if ( empty ( $ this -> resultMethodChain ) ) { $ this -> addCallback ( 'text' ) ; } $ traceStack = [ ] ; foreach ( $ this -> resultMethodChain as $ resultCallback ) { try { $ traceStack [ ] = $ resultCallback ; $ node = $ resultCallback -> apply ( $ node , $ method ) ; } catch ( InvalidArgumentException $ e ) { if ( $ method -> getResource ( ) -> isSuppressExceptions ( ) ) { return null ; } $ message = $ this -> createExceptionMessage ( $ e , $ traceStack ) ; throw new InvalidArgumentException ( $ message , 0 , $ e ) ; } } return $ node ; } 
protected function loadFromYml ( $ file ) { $ this -> parser = new Parser ( $ file ) ; $ this -> parser -> load ( $ this ) ; } 
public function selectForm ( $ selected = null , $ placeholder = null , array $ selectAttributes = [ ] , array $ optionAttributes = [ ] ) { $ selectAttributesString = '' ; foreach ( $ selectAttributes as $ key => $ value ) { $ selectAttributesString = $ selectAttributesString . " " . $ key . "='" . $ value . "'" ; } $ optionAttributesString = '' ; foreach ( $ optionAttributes as $ key => $ value ) { $ optionAttributesString = $ optionAttributesString . " " . $ key . "='" . $ value . "'" ; } $ string = "<select" . $ selectAttributesString . ">\n" ; if ( isset ( $ placeholder ) && ( empty ( $ selected ) ) ) { $ placeholder = "<option value='' disabled selected>{$placeholder}</option>" ; } else { $ placeholder = null ; } $ string = $ string . $ placeholder ; foreach ( $ this -> timezoneList as $ key => $ value ) { if ( $ selected == $ value ) { $ selectedString = "selected='" . $ value . "'" ; } else { $ selectedString = '' ; } $ string = $ string . "<option value='" . $ value . "'" . $ optionAttributesString . " " . $ selectedString . ">" . $ key . "</option>\n" ; } $ string = $ string . "</select>" ; return $ string ; } 
public function convertFromUTC ( $ timestamp , $ timezone , $ format = 'Y-m-d H:i:s' ) { $ date = new DateTime ( $ timestamp , new DateTimeZone ( 'UTC' ) ) ; $ date -> setTimezone ( new DateTimeZone ( $ timezone ) ) ; return $ date -> format ( $ format ) ; } 
public function convertToUTC ( $ timestamp , $ timezone , $ format = 'Y-m-d H:i:s' ) { $ date = new DateTime ( $ timestamp , new DateTimeZone ( $ timezone ) ) ; $ date -> setTimezone ( new DateTimeZone ( 'UTC' ) ) ; return $ date -> format ( $ format ) ; } 
public function lock ( Output $ output ) { # If this command doesn't require locking then don't do anything if ( ! $ this -> lock ) { return ; } $ this -> lock = $ this -> getApplication ( ) -> getLockFactory ( ) -> createLock ( $ this -> getName ( ) ) ; if ( ! $ this -> lock -> acquire ( ) ) { $ output -> error ( "Another instance of this command (" . $ this -> getName ( ) . ") is currently running" ) ; exit ( Application :: STATUS_LOCKED ) ; } } 
public function timeout ( int $ timeout ) : bool { $ application = $ this -> getApplication ( ) ; if ( ! $ application instanceof Application ) { return false ; } # Check if the application is currently allowing time limiting or not if ( ! $ application -> timeLimit ( ) ) { return false ; } $ endTime = $ this -> startTime + $ timeout ; return ( time ( ) > $ endTime ) ; } 
public function loadCommands ( string $ path , string $ namespace = "" , string $ suffix = "Command" ) : Application { $ commands = [ ] ; # Get the realpath so we can strip it from the start of the filename $ realpath = ( string ) realpath ( $ path ) ; $ finder = ( new Finder ( ) ) -> files ( ) -> in ( $ path ) -> name ( "/[A-Z].*{$suffix}.php/" ) ; foreach ( $ finder as $ file ) { # Get the realpath of the file and ensure the class is loaded $ filename = ( string ) $ file -> getRealPath ( ) ; require_once $ filename ; # Convert the filename to a class $ class = $ filename ; $ class = str_replace ( $ realpath , "" , $ class ) ; $ class = str_replace ( ".php" , "" , $ class ) ; $ class = str_replace ( "/" , "\\" , $ class ) ; # Convert the class name to a command name $ command = $ class ; if ( substr ( $ command , 0 , 1 ) == "\\" ) { $ command = substr ( $ command , 1 ) ; } $ command = ( string ) preg_replace_callback ( "/^([A-Z])(.*){$suffix}$/" , function ( $ match ) { return strtolower ( $ match [ 1 ] ) . $ match [ 2 ] ; } , $ command ) ; $ command = preg_replace_callback ( "/(\\\\)?([A-Z])/" , function ( $ match ) { $ result = ( $ match [ 1 ] ) ? ":" : "-" ; $ result .= strtolower ( $ match [ 2 ] ) ; return $ result ; } , $ command ) ; $ class = $ namespace . $ class ; # Don't attempt create things we can't instantiate $ reflected = new \ ReflectionClass ( $ class ) ; if ( ! $ reflected -> isInstantiable ( ) ) { continue ; } $ commands [ ] = new $ class ( $ command ) ; } if ( count ( $ commands ) < 1 ) { throw new \ InvalidArgumentException ( "No commands were found in the path (" . $ path . ")" ) ; } $ this -> addCommands ( $ commands ) ; return $ this ; } 
public function run ( InputInterface $ input = null , OutputInterface $ output = null ) { if ( $ input === null ) { # Allow namespace contents to be listed when they are entered with a trailing colon if ( isset ( $ _SERVER [ "argv" ] [ 1 ] ) && substr ( $ _SERVER [ "argv" ] [ 1 ] , - 1 ) === ":" ) { # Re-create the argv contents to simulate the user running the list command $ argv = [ $ _SERVER [ "argv" ] [ 0 ] ] ; $ argv [ ] = "list" ; $ argv [ ] = substr ( $ _SERVER [ "argv" ] [ 1 ] , 0 , - 1 ) ; $ argv += array_slice ( $ _SERVER [ "argv" ] , 2 , count ( $ _SERVER [ "argv" ] ) - 2 ) ; $ _SERVER [ "argv" ] = $ argv ; } $ input = new ArgvInput ( ) ; } if ( $ output === null ) { $ output = new Output ( ) ; } parent :: run ( $ input , $ output ) ; } 
protected function configureIO ( InputInterface $ input , OutputInterface $ output ) { parent :: configureIO ( $ input , $ output ) ; if ( $ input -> hasParameterOption ( "--no-time-limit" ) ) { $ this -> timeLimit = false ; } else { $ this -> timeLimit = true ; } # In quiet mode, don't display resource info by default if ( $ output -> isQuiet ( ) ) { $ this -> showResourceInfo = false ; } if ( $ input -> hasParameterOption ( "--show-resource-info" ) ) { $ this -> showResourceInfo = true ; } elseif ( $ input -> hasParameterOption ( "--hide-resource-info" ) ) { $ this -> showResourceInfo = false ; } if ( $ output -> isVeryVerbose ( ) ) { $ handler = new \ NunoMaduro \ Collision \ Handler ( ) ; $ handler -> setOutput ( $ output ) ; $ provider = new \ NunoMaduro \ Collision \ Provider ( null , $ handler ) ; $ provider -> register ( ) ; $ this -> setCatchExceptions ( false ) ; } } 
public function setLockStore ( StoreInterface $ store ) : Factory { $ this -> lockFactory = new Factory ( $ store ) ; return $ this -> lockFactory ; } 
public function getLockFactory ( ) : Factory { if ( $ this -> lockFactory !== null ) { return $ this -> lockFactory ; } if ( ! is_dir ( $ this -> lockPath ) ) { ( new Filesystem ( ) ) -> mkdir ( $ this -> lockPath ) ; } $ store = new FlockStore ( $ this -> lockPath ) ; return $ this -> setLockStore ( $ store ) ; } 
public function setLockPath ( string $ path ) : Application { if ( ! is_dir ( $ path ) ) { ( new Filesystem ( ) ) -> mkdir ( $ path ) ; } if ( ! $ realpath = realpath ( $ path ) ) { throw new \ InvalidArgumentException ( "The directory (" . $ path . ") is unavailable" ) ; } $ this -> lockPath = $ realpath ; return $ this ; } 
public function runCommand ( string $ command , array $ options , InputInterface $ current , OutputInterface $ output ) : int { # The first input argument must be the command name array_unshift ( $ options , $ command ) ; $ input = new ArrayInput ( $ options ) ; if ( ! $ current -> isInteractive ( ) ) { $ input -> setInteractive ( false ) ; } $ command = $ this -> get ( $ command ) ; return $ this -> doRunCommand ( $ command , $ input , $ output ) ; } 
public function format ( ) : string { foreach ( $ this -> times as $ unit => $ value ) { if ( $ this -> time >= $ value ) { $ time = floor ( $ this -> time / $ value * 100 ) / 100 ; return "{$time} {$unit}" ; } } return round ( $ this -> time * 1000 ) . " ms" ; } 
public function build ( ) { if ( $ this -> totalItems == 0 || $ this -> totalPages == 1 ) { return array ( ) ; } $ output = array ( ) ; 
private function buildContributorsList ( array $ issues ) : array { $ contributors = [ ] ; foreach ( $ issues as $ issue ) { foreach ( $ issue -> getContributors ( ) as $ contributor ) { $ contributors [ $ contributor ] = $ contributor ; } } return array_values ( $ contributors ) ; } 
public function groupIssues ( array $ issues , ChangelogConfig $ changelogConfig ) : array { $ this -> linkIssues ( $ issues ) ; return $ this -> groupIssuesByLabels ( $ issues , $ changelogConfig ) ; } 
private function groupIssuesByLabels ( array $ issues , ChangelogConfig $ changelogConfig ) : array { $ issueGroups = [ ] ; foreach ( $ this -> getIssuesToGroup ( $ issues ) as $ issue ) { $ groupName = $ this -> generateIssueGroupName ( $ issue , $ changelogConfig ) ; if ( ! isset ( $ issueGroups [ $ groupName ] ) ) { $ issueGroups [ $ groupName ] = new IssueGroup ( $ groupName ) ; } $ issueGroups [ $ groupName ] -> addIssue ( $ issue ) ; } return $ issueGroups ; } 
private function getIssuesToGroup ( array $ issues ) : array { return array_filter ( $ issues , static function ( Issue $ issue ) : bool { return ( ! $ issue -> isPullRequest ( ) && $ issue -> getLinkedPullRequest ( ) !== null ) === false ; } ) ; } 
public function boot ( ) { $ this -> publishes ( [ __DIR__ . '/../config/failed-job-monitor.php' => config_path ( 'failed-job-monitor.php' ) , ] , 'config' ) ; $ this -> app -> make ( FailedJobNotifier :: class ) -> register ( ) ; } 
public function finishedCrawling ( ) { $ this -> consoleOutput -> writeln ( '' ) ; $ this -> consoleOutput -> writeln ( 'Crawling summary' ) ; $ this -> consoleOutput -> writeln ( '----------------' ) ; ksort ( $ this -> crawledUrls ) ; foreach ( $ this -> crawledUrls as $ statusCode => $ urls ) { $ colorTag = $ this -> getColorTagForStatusCode ( $ statusCode ) ; $ count = count ( $ urls ) ; if ( is_numeric ( $ statusCode ) ) { $ this -> consoleOutput -> writeln ( "<{$colorTag}>Crawled {$count} url(s) with statuscode {$statusCode}</{$colorTag}>" ) ; } if ( $ statusCode == static :: UNRESPONSIVE_HOST ) { $ this -> consoleOutput -> writeln ( "<{$colorTag}>{$count} url(s) did have unresponsive host(s)</{$colorTag}>" ) ; } } $ this -> consoleOutput -> writeln ( '' ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ baseUrl = $ input -> getArgument ( 'url' ) ; $ crawlProfile = $ input -> getOption ( 'dont-crawl-external-links' ) ? new CrawlInternalUrls ( $ baseUrl ) : new CrawlAllUrls ( ) ; $ output -> writeln ( "Start scanning {$baseUrl}" ) ; $ output -> writeln ( '' ) ; $ crawlLogger = new CrawlLogger ( $ output ) ; if ( $ input -> getOption ( 'output' ) ) { $ outputFile = $ input -> getOption ( 'output' ) ; if ( file_exists ( $ outputFile ) ) { $ helper = $ this -> getHelper ( 'question' ) ; $ question = new ConfirmationQuestion ( "The output file `{$outputFile}` already exists. Overwrite it? (y/n)" , false ) ; if ( ! $ helper -> ask ( $ input , $ output , $ question ) ) { $ output -> writeln ( 'Aborting...' ) ; return 0 ; } } $ crawlLogger -> setOutputFile ( $ input -> getOption ( 'output' ) ) ; } $ clientOptions = [ RequestOptions :: TIMEOUT => $ input -> getOption ( 'timeout' ) , RequestOptions :: VERIFY => ! $ input -> getOption ( 'skip-verification' ) , RequestOptions :: ALLOW_REDIRECTS => false , ] ; $ clientOptions = array_merge ( $ clientOptions , $ input -> getOption ( 'options' ) ) ; if ( $ input -> getOption ( 'user-agent' ) ) { $ clientOptions [ RequestOptions :: HEADERS ] [ 'user-agent' ] = $ input -> getOption ( 'user-agent' ) ; } $ crawler = Crawler :: create ( $ clientOptions ) -> setConcurrency ( $ input -> getOption ( 'concurrency' ) ) -> setCrawlObserver ( $ crawlLogger ) -> setCrawlProfile ( $ crawlProfile ) ; if ( $ input -> getOption ( 'ignore-robots' ) ) { $ crawler -> ignoreRobots ( ) ; } $ crawler -> startCrawling ( $ baseUrl ) ; return 0 ; } 
public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; $ this -> original = $ this -> fields ; $ this -> fieldsAreFetched = true ; return $ this -> fields ; } 
public function fill ( $ fields ) { if ( ! is_array ( $ fields ) ) { return ; } if ( isset ( $ fields [ 'ID' ] ) ) { $ this -> id = $ fields [ 'ID' ] ; } $ this -> fields = $ fields ; $ this -> fieldsAreFetched = true ; if ( method_exists ( $ this , 'afterFill' ) ) { $ this -> afterFill ( ) ; } $ this -> original = $ this -> fields ; } 
public function update ( array $ fields = [ ] ) { $ keys = [ ] ; foreach ( $ fields as $ key => $ value ) { array_set ( $ this -> fields , $ key , $ value ) ; $ keys [ ] = $ key ; } return $ this -> save ( $ keys ) ; } 
protected function normalizeFieldsForSave ( $ selectedFields ) { $ fields = [ ] ; if ( $ this -> fields === null ) { return [ ] ; } foreach ( $ this -> fields as $ field => $ value ) { if ( ! $ this -> fieldShouldNotBeSaved ( $ field , $ value , $ selectedFields ) ) { $ fields [ $ field ] = $ value ; } } return $ fields ? : null ; } 
public function getRelation ( $ name , $ throwException = true ) { $ getter = $ name ; try { $ relation = $ this -> $ getter ( ) ; } catch ( \ BadMethodCallException $ e ) { if ( $ throwException ) { throw new \ InvalidArgumentException ( get_class ( $ this ) . ' has no relation named "' . $ name . '".' , 0 , $ e ) ; } return null ; } if ( ! $ relation instanceof BaseQuery ) { if ( $ throwException ) { throw new \ InvalidArgumentException ( get_class ( $ this ) . ' has no relation named "' . $ name . '".' ) ; } return null ; } return $ relation ; } 
protected function createRelationQuery ( $ class , $ foreignKey , $ localKey , $ multiple ) { $ query = $ class :: query ( ) ; $ query -> foreignKey = $ localKey ; $ query -> localKey = $ foreignKey ; $ query -> primaryModel = $ this ; $ query -> multiple = $ multiple ; return $ query ; } 
protected function getValueFromLanguageField ( $ field ) { $ key = $ field . '_' . $ this -> getCurrentLanguage ( ) ; return isset ( $ this -> fields [ $ key ] ) ? $ this -> fields [ $ key ] : null ; } 
public static function registerEloquent ( ) { $ capsule = self :: bootstrapIlluminateDatabase ( ) ; class_alias ( Capsule :: class , 'DB' ) ; if ( $ _COOKIE [ "show_sql_stat" ] == "Y" ) { Capsule :: enableQueryLog ( ) ; $ em = \ Bitrix \ Main \ EventManager :: getInstance ( ) ; $ em -> addEventHandler ( 'main' , 'OnAfterEpilog' , [ IlluminateQueryDebugger :: class , 'onAfterEpilogHandler' ] ) ; } static :: addEventListenersForHelpersHighloadblockTables ( $ capsule ) ; } 
protected static function bootstrapIlluminatePagination ( ) { if ( class_exists ( BladeProvider :: class ) ) { Paginator :: viewFactoryResolver ( function ( ) { return BladeProvider :: getViewFactory ( ) ; } ) ; } Paginator :: $ defaultView = 'pagination.default' ; Paginator :: $ defaultSimpleView = 'pagination.simple-default' ; Paginator :: currentPathResolver ( function ( ) { return $ GLOBALS [ 'APPLICATION' ] -> getCurPage ( ) ; } ) ; Paginator :: currentPageResolver ( function ( $ pageName = 'page' ) { $ page = $ _GET [ $ pageName ] ; if ( filter_var ( $ page , FILTER_VALIDATE_INT ) !== false && ( int ) $ page >= 1 ) { return $ page ; } return 1 ; } ) ; } 
protected static function bootstrapIlluminateDatabase ( ) { $ config = self :: getBitrixDbConfig ( ) ; $ capsule = new Capsule ( self :: instantiateServiceContainer ( ) ) ; $ capsule -> addConnection ( [ 'driver' => 'mysql' , 'host' => $ config [ 'host' ] , 'database' => $ config [ 'database' ] , 'username' => $ config [ 'login' ] , 'password' => $ config [ 'password' ] , 'charset' => 'utf8' , 'collation' => 'utf8_unicode_ci' , 'prefix' => '' , 'strict' => false , ] ) ; if ( class_exists ( Dispatcher :: class ) ) { $ capsule -> setEventDispatcher ( new Dispatcher ( ) ) ; } $ capsule -> setAsGlobal ( ) ; $ capsule -> bootEloquent ( ) ; static :: $ illuminateDatabaseIsUsed = true ; return $ capsule ; } 
protected static function instantiateServiceContainer ( ) { $ container = Container :: getInstance ( ) ; if ( ! $ container ) { $ container = new Container ( ) ; Container :: setInstance ( $ container ) ; } return $ container ; } 
private static function addEventListenersForHelpersHighloadblockTables ( Capsule $ capsule ) { $ dispatcher = $ capsule -> getEventDispatcher ( ) ; if ( ! $ dispatcher ) { return ; } $ dispatcher -> listen ( [ 'eloquent.deleted: *' ] , function ( $ event , $ payload ) { $ model = $ payload [ 0 ] ; if ( empty ( $ model -> multipleHighloadBlockFields ) ) { return ; } $ modelTable = $ model -> getTable ( ) ; foreach ( $ model -> multipleHighloadBlockFields as $ multipleHighloadBlockField ) { if ( ! empty ( $ model [ 'ID' ] ) ) { $ tableName = $ modelTable . '_' . strtolower ( $ multipleHighloadBlockField ) ; DB :: table ( $ tableName ) -> where ( 'ID' , $ model [ 'ID' ] ) -> delete ( ) ; } } } ) ; $ dispatcher -> listen ( [ 'eloquent.updated: *' , 'eloquent.created: *' ] , function ( $ event , $ payload ) { $ model = $ payload [ 0 ] ; if ( empty ( $ model -> multipleHighloadBlockFields ) ) { return ; } $ dirty = $ model -> getDirty ( ) ; $ modelTable = $ model -> getTable ( ) ; foreach ( $ model -> multipleHighloadBlockFields as $ multipleHighloadBlockField ) { if ( isset ( $ dirty [ $ multipleHighloadBlockField ] ) && ! empty ( $ model [ 'ID' ] ) ) { $ tableName = $ modelTable . '_' . strtolower ( $ multipleHighloadBlockField ) ; if ( substr ( $ event , 0 , 16 ) === 'eloquent.updated' ) { DB :: table ( $ tableName ) -> where ( 'ID' , $ model [ 'ID' ] ) -> delete ( ) ; } $ unserializedValues = unserialize ( $ dirty [ $ multipleHighloadBlockField ] ) ; if ( ! $ unserializedValues ) { continue ; } $ newRows = [ ] ; foreach ( $ unserializedValues as $ unserializedValue ) { $ newRows [ ] = [ 'ID' => $ model [ 'ID' ] , 'VALUE' => $ unserializedValue , ] ; } if ( $ newRows ) { DB :: table ( $ tableName ) -> insert ( $ newRows ) ; } } } } ) ; } 
protected static function internalCreate ( $ fields ) { $ model = new static ( null , $ fields ) ; if ( $ model -> onBeforeSave ( ) === false || $ model -> onBeforeCreate ( ) === false ) { return false ; } $ bxObject = static :: instantiateObject ( ) ; $ id = static :: internalDirectCreate ( $ bxObject , $ model -> fields ) ; $ model -> setId ( $ id ) ; $ result = $ id ? true : false ; $ model -> setEventErrorsOnFail ( $ result , $ bxObject ) ; $ model -> onAfterCreate ( $ result ) ; $ model -> onAfterSave ( $ result ) ; $ model -> resetEventErrors ( ) ; $ model -> throwExceptionOnFail ( $ result , $ bxObject ) ; return $ model ; } 
public function delete ( ) { if ( $ this -> onBeforeDelete ( ) === false ) { return false ; } $ result = static :: $ bxObject -> delete ( $ this -> id ) ; $ this -> setEventErrorsOnFail ( $ result , static :: $ bxObject ) ; $ this -> onAfterDelete ( $ result ) ; $ this -> resetEventErrors ( ) ; $ this -> throwExceptionOnFail ( $ result , static :: $ bxObject ) ; return $ result ; } 
public function save ( $ selectedFields = [ ] ) { $ fieldsSelectedForSave = is_array ( $ selectedFields ) ? $ selectedFields : func_get_args ( ) ; $ this -> fieldsSelectedForSave = $ fieldsSelectedForSave ; if ( $ this -> onBeforeSave ( ) === false || $ this -> onBeforeUpdate ( ) === false ) { $ this -> fieldsSelectedForSave = [ ] ; return false ; } else { $ this -> fieldsSelectedForSave = [ ] ; } $ fields = $ this -> normalizeFieldsForSave ( $ fieldsSelectedForSave ) ; $ result = $ fields === null ? true : $ this -> internalUpdate ( $ fields , $ fieldsSelectedForSave ) ; $ this -> setEventErrorsOnFail ( $ result , static :: $ bxObject ) ; $ this -> onAfterUpdate ( $ result ) ; $ this -> onAfterSave ( $ result ) ; $ this -> resetEventErrors ( ) ; $ this -> throwExceptionOnFail ( $ result , static :: $ bxObject ) ; return $ result ; } 
protected function fieldShouldNotBeSaved ( $ field , $ value , $ selectedFields ) { $ blacklistedFields = [ 'ID' , 'IBLOCK_ID' , 'GROUPS' , ] ; return ( ! empty ( $ selectedFields ) && ! in_array ( $ field , $ selectedFields ) ) || in_array ( $ field , $ blacklistedFields ) || ( $ field [ 0 ] === '~' ) || ( substr ( $ field , 0 , 9 ) === 'PROPERTY_' ) || ( is_array ( $ this -> original ) && array_key_exists ( $ field , $ this -> original ) && $ this -> original [ $ field ] === $ value ) ; } 
public function with ( $ with ) { $ with = is_string ( $ with ) ? func_get_args ( ) : $ with ; if ( empty ( $ this -> with ) ) { $ this -> with = $ with ; } elseif ( ! empty ( $ with ) ) { foreach ( $ with as $ name => $ value ) { if ( is_int ( $ name ) ) { 
protected function filterByModels ( $ models ) { $ values = [ ] ; foreach ( $ models as $ model ) { if ( ( $ value = $ model [ $ this -> foreignKey ] ) !== null ) { if ( is_array ( $ value ) ) { $ values = array_merge ( $ values , $ value ) ; } else { $ values [ ] = $ value ; } } } $ values = array_filter ( $ values ) ; if ( empty ( $ values ) ) { $ this -> stopQuery ( ) ; } $ primary = $ this -> localKey ; if ( preg_match ( '/^PROPERTY_(.*)_VALUE$/' , $ primary , $ matches ) && ! empty ( $ matches [ 1 ] ) ) { $ primary = 'PROPERTY_' . $ matches [ 1 ] ; } $ values = array_unique ( $ values , SORT_REGULAR ) ; if ( count ( $ values ) == 1 ) { $ values = current ( $ values ) ; } else { $ this -> prepareMultiFilter ( $ primary , $ values ) ; } $ this -> filter ( [ $ primary => $ values ] ) ; $ this -> select [ ] = $ primary ; } 
public function findWith ( $ with , & $ models ) { 
public function populateRelation ( $ name , & $ primaryModels ) { $ this -> filterByModels ( $ primaryModels ) ; $ models = $ this -> getList ( ) ; Helpers :: assocModels ( $ primaryModels , $ models , $ this -> foreignKey , $ this -> localKey , $ name , $ this -> multiple ) ; return $ models ; } 
protected function loadModels ( ) { $ queryType = 'UserQuery::getList' ; $ sort = $ this -> sort ; $ filter = $ this -> normalizeFilter ( ) ; $ params = [ 'SELECT' => $ this -> propsMustBeSelected ( ) ? [ 'UF_*' ] : ( $ this -> normalizeUfSelect ( ) ? : false ) , 'NAV_PARAMS' => $ this -> navigation , 'FIELDS' => $ this -> normalizeSelect ( ) , ] ; $ selectGroups = $ this -> groupsMustBeSelected ( ) ; $ keyBy = $ this -> keyBy ; $ callback = function ( ) use ( $ sort , $ filter , $ params , $ selectGroups ) { $ users = [ ] ; $ rsUsers = $ this -> bxObject -> getList ( $ sort , $ sortOrder = false , $ filter , $ params ) ; while ( $ arUser = $ this -> performFetchUsingSelectedMethod ( $ rsUsers ) ) { if ( $ selectGroups ) { $ arUser [ 'GROUP_ID' ] = $ this -> bxObject -> getUserGroup ( $ arUser [ 'ID' ] ) ; } $ this -> addItemToResultsUsingKeyBy ( $ users , new $ this -> modelName ( $ arUser [ 'ID' ] , $ arUser ) ) ; } return new Collection ( $ users ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'sort' , 'filter' , 'params' , 'selectGroups' , 'keyBy' ) , $ callback ) ; } 
public function count ( ) { if ( $ this -> queryShouldBeStopped ) { return 0 ; } $ queryType = 'UserQuery::count' ; $ filter = $ this -> normalizeFilter ( ) ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> getList ( $ order = 'ID' , $ by = 'ASC' , $ filter , [ 'NAV_PARAMS' => [ 'nTopCount' => 0 , ] , ] ) -> NavRecordCount ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'filter' ) , $ callback ) ; } 
protected function groupsMustBeSelected ( ) { return in_array ( 'GROUPS' , $ this -> select ) || in_array ( 'GROUP_ID' , $ this -> select ) || in_array ( 'GROUPS_ID' , $ this -> select ) ; } 
protected function normalizeFilter ( ) { $ this -> substituteField ( $ this -> filter , 'GROUPS' , 'GROUPS_ID' ) ; $ this -> substituteField ( $ this -> filter , 'GROUP_ID' , 'GROUPS_ID' ) ; return $ this -> filter ; } 
public function count ( ) { $ className = $ this -> bxObject -> getClassName ( ) ; $ queryType = 'D7Query::count' ; $ filter = $ this -> filter ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> getCount ( $ filter ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'className' , 'filter' , 'queryType' ) , $ callback ) ; } 
protected function loadModels ( ) { $ params = [ 'select' => $ this -> select , 'filter' => $ this -> filter , 'group' => $ this -> group , 'order' => $ this -> sort , 'limit' => $ this -> limit , 'offset' => $ this -> offset , 'runtime' => $ this -> runtime , ] ; if ( $ this -> cacheTtl && $ this -> cacheJoins ) { $ params [ 'cache' ] = [ 'ttl' => $ this -> cacheTtl , 'cache_joins' => true ] ; } $ className = $ this -> bxObject -> getClassName ( ) ; $ queryType = 'D7Query::getList' ; $ keyBy = $ this -> keyBy ; $ callback = function ( ) use ( $ className , $ params ) { $ rows = [ ] ; $ result = $ this -> bxObject -> getList ( $ params ) ; while ( $ row = $ result -> fetch ( ) ) { $ this -> addItemToResultsUsingKeyBy ( $ rows , new $ this -> modelName ( $ row [ 'ID' ] , $ row ) ) ; } return new Collection ( $ rows ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'className' , 'params' , 'queryType' , 'keyBy' ) , $ callback ) ; } 
public function getList ( ) { if ( ! is_null ( $ this -> primaryModel ) ) { 
public function getById ( $ id ) { if ( ! $ id || $ this -> queryShouldBeStopped ) { return false ; } $ this -> sort = [ ] ; $ this -> filter [ 'ID' ] = $ id ; return $ this -> getList ( ) -> first ( null , false ) ; } 
public function sort ( $ by , $ order = 'ASC' ) { $ this -> sort = is_array ( $ by ) ? $ by : [ $ by => $ order ] ; return $ this ; } 
public function addFilter ( $ filters ) { foreach ( $ filters as $ field => $ value ) { $ this -> filter [ $ field ] = $ value ; } return $ this ; } 
public function paginate ( $ perPage = 15 , $ pageName = 'page' ) { $ page = Paginator :: resolveCurrentPage ( $ pageName ) ; $ total = $ this -> count ( ) ; $ results = $ this -> forPage ( $ page , $ perPage ) -> getList ( ) ; return new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page , [ 'path' => Paginator :: resolveCurrentPath ( ) , 'pageName' => $ pageName , ] ) ; } 
public function simplePaginate ( $ perPage = 15 , $ pageName = 'page' ) { $ page = Paginator :: resolveCurrentPage ( $ pageName ) ; $ results = $ this -> forPage ( $ page , $ perPage + 1 ) -> getList ( ) ; return new Paginator ( $ results , $ perPage , $ page , [ 'path' => Paginator :: resolveCurrentPath ( ) , 'pageName' => $ pageName , ] ) ; } 
protected function addItemToResultsUsingKeyBy ( & $ results , BaseBitrixModel $ object ) { $ item = $ object -> fields ; if ( ! array_key_exists ( $ this -> keyBy , $ item ) ) { throw new LogicException ( "Field {$this->keyBy} is not found in object" ) ; } $ keyByValue = $ item [ $ this -> keyBy ] ; if ( ! isset ( $ results [ $ keyByValue ] ) ) { $ results [ $ keyByValue ] = $ object ; } else { $ oldFields = $ results [ $ keyByValue ] -> fields ; foreach ( $ oldFields as $ field => $ oldValue ) { 
protected function propsMustBeSelected ( ) { return in_array ( 'PROPS' , $ this -> select ) || in_array ( 'PROPERTIES' , $ this -> select ) || in_array ( 'PROPERTY_VALUES' , $ this -> select ) ; } 
protected function rememberInCache ( $ key , $ minutes , Closure $ callback ) { $ minutes = ( double ) $ minutes ; if ( $ minutes <= 0 ) { return $ callback ( ) ; } $ cache = Cache :: createInstance ( ) ; if ( $ cache -> initCache ( $ minutes * 60 , $ key , '/bitrix-models' ) ) { $ vars = $ cache -> getVars ( ) ; return ! empty ( $ vars [ 'isCollection' ] ) ? new Collection ( $ vars [ 'cache' ] ) : $ vars [ 'cache' ] ; } $ cache -> startDataCache ( ) ; $ result = $ callback ( ) ; 
protected static function buildBuckets ( $ models , $ linkKey , $ multiple ) { $ buckets = [ ] ; foreach ( $ models as $ model ) { $ key = $ model [ $ linkKey ] ; if ( is_scalar ( $ key ) ) { $ buckets [ $ key ] [ ] = $ model ; } elseif ( is_array ( $ key ) ) { foreach ( $ key as $ k ) { $ k = static :: normalizeModelKey ( $ k ) ; $ buckets [ $ k ] [ ] = $ model ; } } else { $ key = static :: normalizeModelKey ( $ key ) ; $ buckets [ $ key ] [ ] = $ model ; } } if ( ! $ multiple ) { foreach ( $ buckets as $ i => $ bucket ) { $ buckets [ $ i ] = reset ( $ bucket ) ; } } return $ buckets ; } 
protected function loadModels ( ) { $ queryType = 'SectionQuery::getList' ; $ sort = $ this -> sort ; $ filter = $ this -> normalizeFilter ( ) ; $ countElements = $ this -> countElements ; $ select = $ this -> normalizeSelect ( ) ; $ navigation = $ this -> navigation ; $ keyBy = $ this -> keyBy ; $ callback = function ( ) use ( $ sort , $ filter , $ countElements , $ select , $ navigation ) { $ sections = [ ] ; $ rsSections = $ this -> bxObject -> getList ( $ sort , $ filter , $ countElements , $ select , $ navigation ) ; while ( $ arSection = $ this -> performFetchUsingSelectedMethod ( $ rsSections ) ) { 
public function count ( ) { if ( $ this -> queryShouldBeStopped ) { return 0 ; } $ queryType = 'SectionQuery::count' ; $ filter = $ this -> normalizeFilter ( ) ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> getCount ( $ filter ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'filter' ) , $ callback ) ; } 
protected function normalizeSelect ( ) { if ( $ this -> fieldsMustBeSelected ( ) ) { $ this -> select = array_merge ( $ this -> standardFields , $ this -> select ) ; } if ( $ this -> propsMustBeSelected ( ) ) { $ this -> select [ ] = 'IBLOCK_ID' ; $ this -> select [ ] = 'UF_*' ; } $ this -> select [ ] = 'ID' ; return $ this -> clearSelectArray ( ) ; } 
public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ groupBackup = isset ( $ this -> fields [ 'GROUP_ID' ] ) ? $ this -> fields [ 'GROUP_ID' ] : null ; $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; if ( $ groupBackup ) { $ this -> fields [ 'GROUP_ID' ] = $ groupBackup ; } $ this -> fieldsAreFetched = true ; $ this -> original = $ this -> fields ; return $ this -> fields ; } 
public function refreshGroups ( ) { if ( $ this -> id === null ) { return [ ] ; } global $ USER ; $ this -> fields [ 'GROUP_ID' ] = $ this -> isCurrent ( ) ? $ USER -> getUserGroupArray ( ) : static :: $ bxObject -> getUserGroup ( $ this -> id ) ; $ this -> groupsAreFetched = true ; return $ this -> fields [ 'GROUP_ID' ] ; } 
public function substituteGroup ( $ old , $ new ) { $ groups = $ this -> getGroups ( ) ; if ( ( $ key = array_search ( $ old , $ groups ) ) !== false ) { unset ( $ groups [ $ key ] ) ; } if ( ! in_array ( $ new , $ groups ) ) { $ groups [ ] = $ new ; } $ this -> fields [ 'GROUP_ID' ] = $ groups ; } 
protected static function internalCreate ( $ fields ) { $ model = new static ( null , $ fields ) ; if ( $ model -> onBeforeSave ( ) === false || $ model -> onBeforeCreate ( ) === false ) { return false ; } $ resultObject = static :: instantiateAdapter ( ) -> add ( $ model -> fields ) ; $ result = $ resultObject -> isSuccess ( ) ; if ( $ result ) { $ model -> setId ( $ resultObject -> getId ( ) ) ; } $ model -> setEventErrorsOnFail ( $ resultObject ) ; $ model -> onAfterCreate ( $ result ) ; $ model -> onAfterSave ( $ result ) ; $ model -> throwExceptionOnFail ( $ resultObject ) ; return $ model ; } 
public function delete ( ) { if ( $ this -> onBeforeDelete ( ) === false ) { return false ; } $ resultObject = static :: instantiateAdapter ( ) -> delete ( $ this -> id ) ; $ result = $ resultObject -> isSuccess ( ) ; $ this -> setEventErrorsOnFail ( $ resultObject ) ; $ this -> onAfterDelete ( $ result ) ; $ this -> resetEventErrors ( ) ; $ this -> throwExceptionOnFail ( $ resultObject ) ; return $ result ; } 
public function save ( $ selectedFields = [ ] ) { $ fieldsSelectedForSave = is_array ( $ selectedFields ) ? $ selectedFields : func_get_args ( ) ; $ this -> fieldsSelectedForSave = $ fieldsSelectedForSave ; if ( $ this -> onBeforeSave ( ) === false || $ this -> onBeforeUpdate ( ) === false ) { $ this -> fieldsSelectedForSave = [ ] ; return false ; } else { $ this -> fieldsSelectedForSave = [ ] ; } $ fields = $ this -> normalizeFieldsForSave ( $ fieldsSelectedForSave ) ; $ resultObject = $ fields === null ? new UpdateResult ( ) : static :: instantiateAdapter ( ) -> update ( $ this -> id , $ fields ) ; $ result = $ resultObject -> isSuccess ( ) ; $ this -> setEventErrorsOnFail ( $ resultObject ) ; $ this -> onAfterUpdate ( $ result ) ; $ this -> onAfterSave ( $ result ) ; $ this -> throwExceptionOnFail ( $ resultObject ) ; return $ result ; } 
protected function fieldShouldNotBeSaved ( $ field , $ value , $ selectedFields ) { return ( ! empty ( $ selectedFields ) && ! in_array ( $ field , $ selectedFields ) ) || $ field === 'ID' ; } 
protected function loadModels ( ) { $ sort = $ this -> sort ; $ filter = $ this -> normalizeFilter ( ) ; $ groupBy = $ this -> groupBy ; $ navigation = $ this -> navigation ; $ select = $ this -> normalizeSelect ( ) ; $ queryType = 'ElementQuery::getList' ; $ fetchUsing = $ this -> fetchUsing ; $ keyBy = $ this -> keyBy ; list ( $ select , $ chunkQuery ) = $ this -> multiplySelectForMaxJoinsRestrictionIfNeeded ( $ select ) ; $ callback = function ( ) use ( $ sort , $ filter , $ groupBy , $ navigation , $ select , $ chunkQuery ) { if ( $ chunkQuery ) { $ itemsChunks = [ ] ; foreach ( $ select as $ chunkIndex => $ selectForChunk ) { $ rsItems = $ this -> bxObject -> GetList ( $ sort , $ filter , $ groupBy , $ navigation , $ selectForChunk ) ; while ( $ arItem = $ this -> performFetchUsingSelectedMethod ( $ rsItems ) ) { $ this -> addItemToResultsUsingKeyBy ( $ itemsChunks [ $ chunkIndex ] , new $ this -> modelName ( $ arItem [ 'ID' ] , $ arItem ) ) ; } } $ items = $ this -> mergeChunks ( $ itemsChunks ) ; } else { $ items = [ ] ; $ rsItems = $ this -> bxObject -> GetList ( $ sort , $ filter , $ groupBy , $ navigation , $ select ) ; while ( $ arItem = $ this -> performFetchUsingSelectedMethod ( $ rsItems ) ) { $ this -> addItemToResultsUsingKeyBy ( $ items , new $ this -> modelName ( $ arItem [ 'ID' ] , $ arItem ) ) ; } } return new Collection ( $ items ) ; } ; $ cacheKeyParams = compact ( 'sort' , 'filter' , 'groupBy' , 'navigation' , 'select' , 'queryType' , 'keyBy' , 'fetchUsing' ) ; return $ this -> handleCacheIfNeeded ( $ cacheKeyParams , $ callback ) ; } 
public function count ( ) { if ( $ this -> queryShouldBeStopped ) { return 0 ; } $ filter = $ this -> normalizeFilter ( ) ; $ queryType = "ElementQuery::count" ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> GetList ( false , $ filter , [ ] ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'filter' , 'queryType' ) , $ callback ) ; } 
protected function fetchAllPropsForSelect ( ) { $ props = [ ] ; $ rsProps = static :: $ cIblockObject -> GetProperties ( $ this -> iblockId ) ; while ( $ prop = $ rsProps -> Fetch ( ) ) { $ props [ ] = 'PROPERTY_' . $ prop [ 'CODE' ] ; } return $ props ; } 
protected static function getCachedIblockPropertiesData ( ) { $ iblockId = static :: iblockId ( ) ; if ( ! empty ( self :: $ iblockPropertiesData [ $ iblockId ] ) ) { return self :: $ iblockPropertiesData [ $ iblockId ] ; } $ props = [ ] ; $ dbRes = CIBlock :: GetProperties ( $ iblockId , [ ] , [ ] ) ; while ( $ property = $ dbRes -> Fetch ( ) ) { $ props [ $ property [ 'CODE' ] ] = $ property ; } return self :: $ iblockPropertiesData [ $ iblockId ] = $ props ; } 
public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ sectionsBackup = isset ( $ this -> fields [ 'IBLOCK_SECTION' ] ) ? $ this -> fields [ 'IBLOCK_SECTION' ] : null ; $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; if ( ! empty ( $ sectionsBackup ) ) { $ this -> fields [ 'IBLOCK_SECTION' ] = $ sectionsBackup ; } $ this -> fieldsAreFetched = true ; $ this -> original = $ this -> fields ; return $ this -> fields ; } 
public function refreshSections ( ) { if ( $ this -> id === null ) { return [ ] ; } $ this -> fields [ 'IBLOCK_SECTION' ] = [ ] ; $ dbSections = static :: $ bxObject -> getElementGroups ( $ this -> id , true ) ; while ( $ section = $ dbSections -> Fetch ( ) ) { $ this -> fields [ 'IBLOCK_SECTION' ] [ ] = $ section ; } $ this -> sectionsAreFetched = true ; return $ this -> fields [ 'IBLOCK_SECTION' ] ; } 
public function getSection ( $ load = false ) { $ fields = $ this -> getFields ( ) ; if ( ! $ load ) { return $ fields [ 'IBLOCK_SECTION_ID' ] ; } $ sectionModel = static :: sectionModel ( ) ; if ( ! $ fields [ 'IBLOCK_SECTION_ID' ] ) { return false ; } return $ sectionModel :: query ( ) -> getById ( $ fields [ 'IBLOCK_SECTION_ID' ] ) -> toArray ( ) ; } 
public function section ( $ load = false ) { $ fields = $ this -> getFields ( ) ; $ sectionModel = static :: sectionModel ( ) ; return $ load ? $ sectionModel :: query ( ) -> getById ( $ fields [ 'IBLOCK_SECTION_ID' ] ) : new $ sectionModel ( $ fields [ 'IBLOCK_SECTION_ID' ] ) ; } 
public function saveProps ( $ selected = [ ] ) { $ propertyValues = $ this -> constructPropertyValuesForSave ( $ selected ) ; if ( empty ( $ propertyValues ) ) { return false ; } $ bxMethod = empty ( $ selected ) ? 'setPropertyValues' : 'setPropertyValuesEx' ; static :: $ bxObject -> $ bxMethod ( $ this -> id , static :: iblockId ( ) , $ propertyValues ) ; return true ; } 
protected function normalizePropertyFormat ( ) { if ( empty ( $ this -> fields [ 'PROPERTIES' ] ) ) { return ; } foreach ( $ this -> fields [ 'PROPERTIES' ] as $ code => $ prop ) { $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE' ] = $ prop [ 'VALUE' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_VALUE' ] = $ prop [ '~VALUE' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ 'DESCRIPTION' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ '~DESCRIPTION' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE_ID' ] = $ prop [ 'PROPERTY_VALUE_ID' ] ; } } 
protected function constructPropertyValuesForSave ( $ selectedFields = [ ] ) { $ propertyValues = [ ] ; $ saveOnlySelected = ! empty ( $ selectedFields ) ; $ iblockPropertiesData = static :: getCachedIblockPropertiesData ( ) ; if ( $ saveOnlySelected ) { foreach ( $ selectedFields as $ code ) { 
public function fetchUsing ( $ methodAndParams ) { 
protected function performFetchUsingSelectedMethod ( $ rsItems ) { return $ this -> fetchUsing [ 'method' ] === 'GetNext' ? $ rsItems -> GetNext ( $ this -> fetchUsing [ 'params' ] [ 0 ] , $ this -> fetchUsing [ 'params' ] [ 1 ] ) : $ rsItems -> Fetch ( ) ; } 
public function offsetExists ( $ offset ) { return $ this -> getAccessor ( $ offset ) || $ this -> getAccessorForLanguageField ( $ offset ) ? true : isset ( $ this -> fields [ $ offset ] ) ; } 
public function offsetGet ( $ offset ) { $ fieldValue = isset ( $ this -> fields [ $ offset ] ) ? $ this -> fields [ $ offset ] : null ; $ accessor = $ this -> getAccessor ( $ offset ) ; if ( $ accessor ) { return $ this -> $ accessor ( $ fieldValue ) ; } $ accessorForLanguageField = $ this -> getAccessorForLanguageField ( $ offset ) ; if ( $ accessorForLanguageField ) { return $ this -> $ accessorForLanguageField ( $ offset ) ; } return $ fieldValue ; } 
private function getAccessor ( $ field ) { $ method = 'get' . camel_case ( $ field ) . 'Attribute' ; return method_exists ( $ this , $ method ) ? $ method : false ; } 
private function getAccessorForLanguageField ( $ field ) { $ method = 'getValueFromLanguageField' ; return in_array ( $ field , $ this -> languageAccessors ) && method_exists ( $ this , $ method ) ? $ method : false ; } 
public function toArray ( ) { $ array = $ this -> fields ; foreach ( $ this -> appends as $ accessor ) { if ( isset ( $ this [ $ accessor ] ) ) { $ array [ $ accessor ] = $ this [ $ accessor ] ; } } foreach ( $ this -> related as $ key => $ value ) { if ( is_object ( $ value ) && method_exists ( $ value , 'toArray' ) ) { $ array [ $ key ] = $ value -> toArray ( ) ; } elseif ( is_null ( $ value ) || $ value === false ) { $ array [ $ key ] = $ value ; } } if ( count ( $ this -> getVisible ( ) ) > 0 ) { $ array = array_intersect_key ( $ array , array_flip ( $ this -> getVisible ( ) ) ) ; } if ( count ( $ this -> getHidden ( ) ) > 0 ) { $ array = array_diff_key ( $ array , array_flip ( $ this -> getHidden ( ) ) ) ; } return $ array ; } 
public function getAttribute ( $ key ) { if ( in_array ( $ key , $ this -> multipleHighloadBlockFields ) ) { return unserialize ( $ this -> attributes [ $ key ] ) ; } return parent :: getAttribute ( $ key ) ; } 
public function setAttribute ( $ key , $ value ) { if ( in_array ( $ key , $ this -> multipleHighloadBlockFields ) ) { $ this -> attributes [ $ key ] = serialize ( $ value ) ; return $ this ; } parent :: setAttribute ( $ key , $ value ) ; return $ this ; } 
public function getDirectChildren ( array $ filter = [ ] ) { return static :: query ( ) -> filter ( $ filter ) -> filter ( [ 'SECTION_ID' => $ this -> id ] ) -> select ( 'ID' ) -> getList ( ) -> transform ( function ( $ section ) { return ( int ) $ section [ 'ID' ] ; } ) -> all ( ) ; } 
public function getAllChildren ( array $ filter = [ ] , $ sort = [ 'LEFT_MARGIN' => 'ASC' ] ) { if ( ! isset ( $ this -> fields [ 'LEFT_MARGIN' ] ) || ! isset ( $ this -> fields [ 'RIGHT_MARGIN' ] ) ) { $ this -> refresh ( ) ; } return static :: query ( ) -> sort ( $ sort ) -> filter ( $ filter ) -> filter ( [ '!ID' => $ this -> id , '>LEFT_MARGIN' => $ this -> fields [ 'LEFT_MARGIN' ] , '<RIGHT_MARGIN' => $ this -> fields [ 'RIGHT_MARGIN' ] , ] ) -> select ( 'ID' ) -> getList ( ) -> transform ( function ( $ section ) { return ( int ) $ section [ 'ID' ] ; } ) -> all ( ) ; } 
protected function recordThat ( AggregateChanged $ event ) : void { $ this -> version += 1 ; $ this -> recordedEvents [ ] = $ event -> withVersion ( $ this -> version ) ; $ this -> apply ( $ event ) ; } 
public function getAggregateRoot ( string $ aggregateId ) { if ( ! $ this -> disableIdentityMap && isset ( $ this -> identityMap [ $ aggregateId ] ) ) { return $ this -> identityMap [ $ aggregateId ] ; } if ( $ this -> snapshotStore ) { $ eventSourcedAggregateRoot = $ this -> loadFromSnapshotStore ( $ aggregateId ) ; if ( $ eventSourcedAggregateRoot && ! $ this -> disableIdentityMap ) { 
protected function determineStreamName ( string $ aggregateId ) : StreamName { if ( $ this -> oneStreamPerAggregate ) { if ( null === $ this -> streamName ) { $ prefix = $ this -> aggregateType -> toString ( ) ; } else { $ prefix = $ this -> streamName -> toString ( ) ; } return new StreamName ( $ prefix . '-' . $ aggregateId ) ; } if ( null === $ this -> streamName ) { return new StreamName ( 'event_stream' ) ; } return $ this -> streamName ; } 
protected function enrichEventMetadata ( Message $ domainEvent , string $ aggregateId ) : Message { $ domainEvent = $ domainEvent -> withAddedMetadata ( '_aggregate_id' , $ aggregateId ) ; $ domainEvent = $ domainEvent -> withAddedMetadata ( '_aggregate_type' , $ this -> aggregateType -> toString ( ) ) ; return $ domainEvent ; } 
public function extractAggregateVersion ( $ eventSourcedAggregateRoot ) : int { if ( null === $ this -> versionExtractor ) { $ this -> versionExtractor = function ( ) : int { return $ this -> version ; } ; } return $ this -> versionExtractor -> call ( $ eventSourcedAggregateRoot ) ; } 
public function extractAggregateId ( $ anEventSourcedAggregateRoot ) : string { if ( null === $ this -> aggregateIdExtractor ) { $ this -> aggregateIdExtractor = function ( ) : string { return $ this -> aggregateId ( ) ; } ; } return $ this -> aggregateIdExtractor -> call ( $ anEventSourcedAggregateRoot ) ; } 
public function reconstituteAggregateFromHistory ( AggregateType $ aggregateType , Iterator $ historyEvents ) { if ( null === $ this -> aggregateReconstructor ) { $ this -> aggregateReconstructor = function ( $ historyEvents ) { return static :: reconstituteFromHistory ( $ historyEvents ) ; } ; } $ arClass = $ aggregateType -> toString ( ) ; if ( ! \ class_exists ( $ arClass ) ) { throw new RuntimeException ( \ sprintf ( 'Aggregate root class %s cannot be found' , $ arClass ) ) ; } return ( $ this -> aggregateReconstructor -> bindTo ( null , $ arClass ) ) ( $ historyEvents ) ; } 
public function extractPendingStreamEvents ( $ anEventSourcedAggregateRoot ) : array { if ( null === $ this -> pendingEventsExtractor ) { $ this -> pendingEventsExtractor = function ( ) : array { return $ this -> popRecordedEvents ( ) ; } ; } return $ this -> pendingEventsExtractor -> call ( $ anEventSourcedAggregateRoot ) ; } 
public function replayStreamEvents ( $ anEventSourcedAggregateRoot , Iterator $ events ) : void { if ( null === $ this -> replayStreamEvents ) { $ this -> replayStreamEvents = function ( $ events ) : void { $ this -> replay ( $ events ) ; } ; } $ this -> replayStreamEvents -> call ( $ anEventSourcedAggregateRoot , $ events ) ; } 
public static function fromAggregateRoot ( $ eventSourcedAggregateRoot ) : AggregateType { if ( ! \ is_object ( $ eventSourcedAggregateRoot ) ) { throw new Exception \ AggregateTypeException ( \ sprintf ( 'Aggregate root must be an object but type of %s given' , \ gettype ( $ eventSourcedAggregateRoot ) ) ) ; } if ( $ eventSourcedAggregateRoot instanceof AggregateTypeProvider ) { return $ eventSourcedAggregateRoot -> aggregateType ( ) ; } $ self = new static ( ) ; $ self -> aggregateType = \ get_class ( $ eventSourcedAggregateRoot ) ; return $ self ; } 
public static function fromAggregateRootClass ( string $ aggregateRootClass ) : AggregateType { if ( ! \ class_exists ( $ aggregateRootClass ) ) { throw new Exception \ InvalidArgumentException ( \ sprintf ( 'Aggregate root class %s can not be found' , $ aggregateRootClass ) ) ; } $ self = new static ( ) ; $ self -> aggregateType = $ aggregateRootClass ; return $ self ; } 
public static function fromString ( string $ aggregateTypeString ) : AggregateType { if ( empty ( $ aggregateTypeString ) ) { throw new Exception \ InvalidArgumentException ( 'AggregateType must be a non empty string' ) ; } $ self = new static ( ) ; $ self -> aggregateType = $ aggregateTypeString ; return $ self ; } 
public function assert ( $ aggregateRoot ) : void { $ otherAggregateType = self :: fromAggregateRoot ( $ aggregateRoot ) ; if ( ! $ this -> equals ( $ otherAggregateType ) ) { throw new Exception \ AggregateTypeException ( \ sprintf ( 'Aggregate types must be equal. %s != %s' , $ this -> toString ( ) , $ otherAggregateType -> toString ( ) ) ) ; } } 
public function reconstituteAggregateFromHistory ( AggregateType $ aggregateType , Iterator $ historyEvents ) { if ( ! $ aggregateRootClass = $ aggregateType -> mappedClass ( ) ) { $ aggregateRootClass = $ aggregateType -> toString ( ) ; } return $ this -> getAggregateRootDecorator ( ) -> fromHistory ( $ aggregateRootClass , $ historyEvents ) ; } 
public function replayStreamEvents ( $ anEventSourcedAggregateRoot , Iterator $ events ) : void { $ this -> getAggregateRootDecorator ( ) -> replayStreamEvents ( $ anEventSourcedAggregateRoot , $ events ) ; } 
protected function replay ( Iterator $ historyEvents ) : void { foreach ( $ historyEvents as $ pastEvent ) { $ this -> version = $ pastEvent -> version ( ) ; $ this -> apply ( $ pastEvent ) ; } } 
public function extend ( $ module ) : void { if ( is_object ( $ module ) || class_exists ( $ module ) ) { $ this -> modules [ ] = $ module ; } else { throw ApplicationException :: forInvalidModule ( $ module ) ; } } 
public function add ( Route $ route ) : void { if ( $ route instanceof Route ) { $ name = $ route -> getName ( ) ; } else { $ name = Route :: generateNameFromPath ( $ route -> getPath ( ) ) ; } $ baseRoute = new SymfonyRoute ( $ route -> getPath ( ) ) ; $ baseRoute -> setMethods ( $ route -> getMethods ( ) ) ; $ this -> routeCollection -> add ( $ name , $ baseRoute ) ; $ this -> routes [ $ name ] = $ route ; } 
public function find ( string $ method , string $ path ) : Route { $ matcher = new UrlMatcher ( $ this -> routeCollection , new RequestContext ( '/' , $ method ) ) ; try { $ route = $ matcher -> match ( $ path ) ; } catch ( ResourceNotFoundException $ exception ) { throw RouterException :: noRouteMatchesRequestedUri ( $ path , $ method ) ; } catch ( SymfonyMethodNotAllowedException $ exception ) { throw RouterException :: methodNotAllowed ( $ path , $ exception -> getAllowedMethods ( ) ) ; } $ routeName = $ route [ '_route' ] ; unset ( $ route [ '_route' ] ) ; return $ this -> routes [ $ routeName ] -> withAttributes ( $ route ) ; } 
public function run ( HttpServer $ server = null ) : void { $ this -> startup ( ) ; if ( $ server ) { $ server -> addListener ( $ this ) ; $ server -> start ( ) ; } else { $ response = $ this -> handle ( ServerRequest :: fromGlobals ( ) ) ; $ this -> emitter -> emit ( $ response ) ; if ( $ response instanceof Response ) { $ response -> end ( ) ; } } $ this -> shutdown ( ) ; } 
public function use ( $ middleware ) : void { if ( ! is_subclass_of ( $ middleware , MiddlewareInterface :: class ) ) { if ( ! is_callable ( $ middleware ) ) { throw new ApplicationException ( sprintf ( 'Middleware must be either class or object that implements `%s`' , MiddlewareInterface :: class ) ) ; } $ middleware = new CallableMiddleware ( $ middleware ) ; } $ this -> middleware [ ] = $ middleware ; } 
public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ next ) : ResponseInterface { $ route = $ this -> router -> find ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; $ controller = $ route -> getController ( ) ; if ( $ request instanceof ServerRequest ) { $ request = $ request -> withAttributes ( $ route -> getAttributes ( ) ) ; } if ( is_string ( $ controller ) && class_exists ( $ controller ) && is_subclass_of ( $ controller , Controller :: class ) ) { $ instance = $ this -> resolver -> resolve ( $ controller ) ; return $ instance ( $ request ) ; } if ( is_callable ( $ controller ) ) { $ response = $ controller ( $ request ) ; if ( ! $ response instanceof ResponseInterface ) { throw ControllerException :: forInvalidReturnValue ( ) ; } return $ response ; } throw ControllerException :: forMissingController ( $ route -> getPath ( ) ) ; } 
public function handle ( ServerRequestInterface $ request ) : ResponseInterface { $ response = $ this -> getMiddlewarePipe ( ) -> handle ( $ request ) ; return $ response ; } 
public function onRequest ( Client $ client , ServerRequestInterface $ request , ResponseInterface $ response ) : ResponseInterface { return $ this -> handle ( $ request ) ; } 
public function get ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: get ( $ route ) ) ; } 
public function post ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: post ( $ route ) ) ; } 
public function put ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: put ( $ route ) ) ; } 
public function patch ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: patch ( $ route ) ) ; } 
public function delete ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: delete ( $ route ) ) ; } 
public function options ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: options ( $ route ) ) ; } 
public function head ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: head ( $ route ) ) ; } 
public function get ( string $ key , $ default = null ) { $ result = $ this -> lookup ( $ key ) ; return $ result === null ? $ default : $ this -> fetchConstants ( $ result ) ; } 
public function merge ( Config $ config ) : Config { $ this -> config = array_merge_recursive ( $ this -> config , $ config -> config ) ; return $ this ; } 
public function extract ( string $ namespace ) : Config { $ extracted = $ this -> get ( $ namespace ) ; if ( ! is_array ( $ extracted ) ) { throw ConfigException :: forExtractionFailure ( $ namespace ) ; } return new self ( $ extracted ) ; } 
public function set ( string $ key , $ value ) : void { $ key = explode ( '.' , $ key ) ; $ last = array_pop ( $ key ) ; $ result = & $ this -> config ; foreach ( $ key as $ part ) { if ( ! isset ( $ result [ $ part ] ) || ! is_array ( $ result [ $ part ] ) ) { $ result [ $ part ] = [ ] ; } $ result = & $ result [ $ part ] ; } $ result [ $ last ] = $ value ; } 
public function boot ( ) { $ token = $ this -> app -> make ( 'config' ) -> get ( 'services.discord.token' ) ; $ this -> app -> when ( Discord :: class ) -> needs ( '$token' ) -> give ( $ token ) ; $ this -> app -> when ( SetupCommand :: class ) -> needs ( '$token' ) -> give ( $ token ) ; } 
public function handle ( ) { if ( ! $ this -> token ) { $ this -> error ( 'You must paste your Discord token (App Bot User token) into your `services.php` config file.' ) ; $ this -> error ( 'View the README for more info: https://github.com/laravel-notification-channels/discord#installation' ) ; return - 1 ; } if ( ! $ this -> confirm ( 'Is the bot already added to your server?' ) ) { $ clientId = $ this -> ask ( 'What is your Discord app client ID?' ) ; $ this -> warn ( 'Add the bot to your server by visiting this link: https://discordapp.com/oauth2/authorize?&client_id=' . $ clientId . '&scope=bot&permissions=0' ) ; if ( ! $ this -> confirm ( 'Continue?' , true ) ) { return - 1 ; } } $ this -> warn ( "Attempting to identify the bot with Discord's websocket gateway..." ) ; $ this -> gateway = $ this -> getGateway ( ) ; $ this -> warn ( "Connecting to '$this->gateway'..." ) ; $ client = $ this -> getSocket ( $ this -> gateway ) ; 
public function getGateway ( ) { $ gateway = $ this -> gateway ; try { $ response = $ this -> guzzle -> get ( 'https://discordapp.com/api/gateway' , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , ] ) ; $ gateway = Arr :: get ( json_decode ( $ response -> getBody ( ) , true ) , 'url' , $ gateway ) ; } catch ( Exception $ e ) { $ this -> warn ( "Could not get a websocket gateway address, defaulting to '{$gateway}'." ) ; } return $ gateway ; } 
public static function serviceRespondedWithAnHttpError ( ResponseInterface $ response ) { $ message = "Discord responded with an HTTP error: {$response->getStatusCode()}" ; if ( $ error = Arr :: get ( json_decode ( $ response -> getBody ( ) , true ) , 'message' ) ) { $ message .= ": $error" ; } return new static ( $ message ) ; } 
protected function request ( $ verb , $ endpoint , array $ data ) { $ url = rtrim ( $ this -> baseUrl , '/' ) . '/' . ltrim ( $ endpoint , '/' ) ; try { $ response = $ this -> httpClient -> request ( $ verb , $ url , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , 'json' => $ data , ] ) ; } catch ( RequestException $ exception ) { if ( $ response = $ exception -> getResponse ( ) ) { throw CouldNotSendNotification :: serviceRespondedWithAnHttpError ( $ response ) ; } throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } catch ( Exception $ exception ) { throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } $ body = json_decode ( $ response -> getBody ( ) , true ) ; if ( Arr :: get ( $ body , 'code' , 0 ) > 0 ) { throw CouldNotSendNotification :: serviceRespondedWithAnApiError ( $ body ) ; } return $ body ; } 
public function send ( $ notifiable , Notification $ notification ) { if ( ! $ channel = $ notifiable -> routeNotificationFor ( 'discord' ) ) { return ; } $ message = $ notification -> toDiscord ( $ notifiable ) ; return $ this -> discord -> send ( $ channel , [ 'content' => $ message -> body , 'embed' => $ message -> embed , ] ) ; } 
public function send ( Receiver $ receiver , Notification $ notification , bool $ sandbox = false ) : void { $ this -> protocol -> send ( $ receiver , $ notification , $ sandbox ) ; } 
public function withTitle ( string $ title ) : Alert { $ cloned = clone $ this ; $ cloned -> titleLocalized = new Localized ( '' ) ; $ cloned -> title = $ title ; return $ cloned ; } 
public function withLocalizedTitle ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> title = '' ; $ cloned -> titleLocalized = $ localized ; return $ cloned ; } 
public function withBody ( string $ body ) : Alert { $ cloned = clone $ this ; $ cloned -> bodyLocalized = new Localized ( '' ) ; $ cloned -> body = $ body ; return $ cloned ; } 
public function withBodyLocalized ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> body = '' ; $ cloned -> bodyLocalized = $ localized ; return $ cloned ; } 
public function withActionLocalized ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> actionLocalized = $ localized ; return $ cloned ; } 
public function withLaunchImage ( string $ launchImage ) : Alert { $ cloned = clone $ this ; $ cloned -> launchImage = $ launchImage ; return $ cloned ; } 
private static function includeConfigurationFile ( ) { static $ included = false ; if ( $ included ) { 
public function visit ( Notification $ notification , Request $ request ) : Request { $ apnId = $ notification -> getApnId ( ) ; if ( $ apnId ) { $ request = $ request -> withHeader ( 'apns-id' , $ apnId -> getValue ( ) ) ; } return $ request ; } 
public function visit ( Notification $ notification , Request $ request ) : Request { $ expiration = $ notification -> getExpiration ( ) ; if ( $ expiration ) { $ request = $ request -> withHeader ( 'apns-expiration' , ( string ) $ expiration -> getValue ( ) ) ; } return $ request ; } 
public function getPath ( ) : string { if ( $ this -> certificateFilePath ) { $ this -> removeTemporaryFile ( $ this -> certificateFilePath ) ; } $ this -> certificateFilePath = $ this -> createTemporaryFile ( ) ; file_put_contents ( $ this -> certificateFilePath , $ this -> content ) ; return $ this -> certificateFilePath ; } 
public function withAlert ( Alert $ alert ) : Aps { $ cloned = clone $ this ; $ cloned -> alert = $ alert ; return $ cloned ; } 
public function withCategory ( string $ category ) : Aps { $ cloned = clone $ this ; $ cloned -> category = $ category ; return $ cloned ; } 
public function withSound ( string $ sound ) : Aps { $ cloned = clone $ this ; $ cloned -> sound = $ sound ; return $ cloned ; } 
public function withBadge ( int $ badge ) : Aps { $ cloned = clone $ this ; $ cloned -> badge = ( int ) $ badge ; return $ cloned ; } 
public function withContentAvailable ( bool $ contentAvailable ) : Aps { $ cloned = clone $ this ; $ cloned -> contentAvailable = $ contentAvailable ; return $ cloned ; } 
public function withMutableContent ( bool $ mutableContent ) : Aps { $ cloned = clone $ this ; $ cloned -> mutableContent = $ mutableContent ; return $ cloned ; } 
public function withThreadId ( string $ threadId ) : Aps { $ cloned = clone $ this ; $ cloned -> threadId = $ threadId ; return $ cloned ; } 
public static function resolve ( ) : SignatureGeneratorInterface { self :: addDefaultResolvers ( ) ; foreach ( self :: $ resolvers as $ resolver ) { if ( $ generator = $ resolver ( ) ) { return $ generator ; } } throw new \ LogicException ( 'Cannot resolve available JWT Signature Generator.' ) ; } 
private static function addDefaultResolvers ( ) : void { static $ added = false ; if ( $ added ) { return ; } $ added = true ; self :: addResolver ( [ __CLASS__ , 'tryResolveByWebTokenJwtSystem' ] ) ; self :: addResolver ( [ __CLASS__ , 'tryResolveBySpomkyLabsJoseSystem' ] ) ; } 
private static function tryResolveByWebTokenJwtSystem ( ) : ? WebTokenJwtSignatureGenerator { $ requiredClasses = [ WebTokenComponentJws :: class , WebTokenComponentJwk :: class , WebTokenComponentJWKFactory :: class , ] ; foreach ( $ requiredClasses as $ requiredClass ) { if ( ! class_exists ( $ requiredClass ) ) { return null ; } } return new WebTokenJwtSignatureGenerator ( ) ; } 
private static function tryResolveBySpomkyLabsJoseSystem ( ) : ? SpomkyLabsJoseSignatureGenerator { $ requiredClasses = [ JWKFactory :: class , JWSFactory :: class , ] ; foreach ( $ requiredClasses as $ requiredClass ) { if ( ! class_exists ( $ requiredClass ) ) { return null ; } } return new SpomkyLabsJoseSignatureGenerator ( ) ; } 
private function createTemporaryFile ( ) : string { $ tmpDir = $ this -> tmpDir ; $ tmpFileName = md5 ( uniqid ( ( string ) mt_rand ( ) , true ) ) . '.p8' ; $ tmpFilePath = $ tmpDir . '/' . $ tmpFileName ; $ errorCode = $ errorMessage = null ; set_error_handler ( function ( $ errCode , $ errMessage ) use ( & $ errorCode , & $ errorMessage ) { $ errorCode = $ errCode ; $ errorMessage = $ errMessage ; } ) ; if ( ! file_exists ( $ tmpDir ) ) { mkdir ( $ tmpDir , 0600 , true ) ; if ( $ errorCode || $ errorMessage ) { restore_error_handler ( ) ; 
public function withAps ( Aps $ aps ) : Payload { $ cloned = clone $ this ; $ cloned -> aps = $ aps ; return $ cloned ; } 
public function withCustomData ( string $ name , $ value ) : Payload { if ( $ value && ! is_array ( $ value ) && ! is_scalar ( $ value ) && ! $ value instanceof \ JsonSerializable ) { throw new \ InvalidArgumentException ( sprintf ( 'The custom data value should be a scalar or \JsonSerializable instance, but "%s" given.' , is_object ( $ value ) ? get_class ( $ value ) : gettype ( $ value ) ) ) ; } $ cloned = clone $ this ; $ cloned -> customData [ $ name ] = $ value ; return $ cloned ; } 
public function withHeader ( string $ name , string $ value ) : Request { $ cloned = clone $ this ; $ cloned -> headers [ $ name ] = $ value ; return $ cloned ; } 
public function withHeaders ( array $ headers ) : Request { $ cloned = clone $ this ; foreach ( $ headers as $ name => $ value ) { $ cloned = $ cloned -> withHeader ( $ name , $ value ) ; } return $ cloned ; } 
public function withCertificate ( string $ certificate ) : Request { $ cloned = clone $ this ; $ cloned -> certificate = $ certificate ; return $ cloned ; } 
public function withCertificatePassPhrase ( string $ passPhrase ) : Request { $ cloned = clone $ this ; $ cloned -> certificatePassPhrase = $ passPhrase ; return $ cloned ; } 
public function add ( HttpProtocolVisitorInterface $ visitor , int $ priority = 0 ) : void { $ this -> visitors -> insert ( $ visitor , $ priority ) ; } 
public function visit ( Notification $ notification , Request $ request ) : Request { 
public function authenticate ( Request $ request ) : Request { $ request = $ request -> withCertificate ( $ this -> certificate -> getPath ( ) ) ; $ request = $ request -> withCertificatePassPhrase ( $ this -> certificate -> getPassPhrase ( ) ) ; return $ request ; } 
public function send ( Receiver $ receiver , Notification $ notification , bool $ sandbox ) : void { try { $ this -> doSend ( $ receiver , $ notification , $ sandbox ) ; } catch ( HttpSenderException $ e ) { $ this -> httpSender -> close ( ) ; throw $ e ; } } 
private function doSend ( Receiver $ receiver , Notification $ notification , bool $ sandbox ) : void { $ payloadEncoded = $ this -> payloadEncoder -> encode ( $ notification -> getPayload ( ) ) ; $ uri = $ this -> uriFactory -> create ( $ receiver -> getToken ( ) , $ sandbox ) ; $ request = new Request ( $ uri , $ payloadEncoded ) ; $ headers = [ 'content-type' => 'application/json' , 'accept' => 'application/json' , 'apns-topic' => $ receiver -> getTopic ( ) , ] ; $ request = $ request -> withHeaders ( $ headers ) ; $ request = $ this -> authenticator -> authenticate ( $ request ) ; $ request = $ this -> visitor -> visit ( $ notification , $ request ) ; $ response = $ this -> httpSender -> send ( $ request ) ; if ( $ response -> getStatusCode ( ) !== 200 ) { throw $ this -> exceptionFactory -> create ( $ response ) ; } } 
public function addVisitor ( HttpProtocolVisitorInterface $ visitor , int $ priority = 0 ) : Http20Builder { $ this -> visitors -> insert ( $ visitor , $ priority ) ; return $ this ; } 
public function addDefaultVisitors ( ) : Http20Builder { if ( $ this -> addedDefaultVisitors ) { return $ this ; } $ this -> addedDefaultVisitors = true ; $ this -> addVisitor ( new AddExpirationHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddPriorityHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddApnIdHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddCollapseIdHeaderVisitor ( ) ) ; return $ this ; } 
public function buildProtocol ( ) : ProtocolInterface { $ chainVisitor = $ this -> createChainVisitor ( ) ; return new HttpProtocol ( $ this -> authenticator , $ this -> httpSender , $ this -> payloadEncoder , $ this -> uriFactory , $ chainVisitor , $ this -> exceptionFactory ) ; } 
private function createChainVisitor ( ) : HttpProtocolChainVisitor { $ chainVisitors = new HttpProtocolChainVisitor ( ) ; $ visitors = clone $ this -> visitors ; $ priority = 0 ; foreach ( $ visitors as $ visitor ) { $ chainVisitors -> add ( $ visitor , ++ $ priority ) ; } return $ chainVisitors ; } 
public function create ( DeviceToken $ deviceToken , bool $ sandbox ) : string { $ uri = 'https://api.push.apple.com/3/device/%s' ; if ( $ sandbox ) { $ uri = 'https://api.development.push.apple.com/3/device/%s' ; } return sprintf ( $ uri , $ deviceToken ) ; } 
public function generate ( JwtInterface $ jwt ) : string { $ jwk = JWKFactory :: createFromKeyFile ( $ jwt -> getPath ( ) , '' , [ 'kid' => $ jwt -> getKey ( ) , ] ) ; $ claims = [ 'iss' => $ jwt -> getTeamId ( ) , 'iat' => time ( ) , ] ; $ header = [ 'alg' => 'ES256' , 'kid' => $ jwk -> get ( 'kid' ) , ] ; $ payload = $ this -> jsonConverter -> encode ( $ claims ) ; $ jws = $ this -> jwsBuilder -> create ( ) -> withPayload ( $ payload ) -> addSignature ( $ jwk , $ header ) -> build ( ) ; return $ this -> serializer -> serialize ( $ jws ) ; } 
public function withPayload ( Payload $ payload ) : Notification { $ cloned = clone $ this ; $ cloned -> payload = $ payload ; return $ cloned ; } 
public function withApnId ( ApnId $ apnId = null ) : Notification { $ cloned = clone $ this ; $ cloned -> apnId = $ apnId ; return $ cloned ; } 
public function withPriority ( Priority $ priority = null ) : Notification { $ cloned = clone $ this ; $ cloned -> priority = $ priority ; return $ cloned ; } 
public function withExpiration ( Expiration $ expiration = null ) : Notification { $ cloned = clone $ this ; $ cloned -> expiration = $ expiration ; return $ cloned ; } 
public function withCollapseId ( CollapseId $ collapseId = null ) : Notification { $ cloned = clone $ this ; $ cloned -> collapseId = $ collapseId ; return $ cloned ; } 
public function generate ( JwtInterface $ jwt ) : string { $ jwk = JWKFactory :: createFromKeyFile ( $ jwt -> getPath ( ) , '' , [ 'kid' => $ jwt -> getKey ( ) , 'alg' => 'ES256' , 'use' => 'sig' , ] ) ; $ payload = [ 'iss' => $ jwt -> getTeamId ( ) , 'iat' => time ( ) , ] ; $ header = [ 'alg' => 'ES256' , 'kid' => $ jwk -> get ( 'kid' ) , ] ; return JWSFactory :: createJWSToCompactJSON ( $ payload , $ jwk , $ header ) ; } 
public function send ( Request $ request ) : Response { $ this -> initializeCurlResource ( ) ; $ this -> prepareCurlResourceByRequest ( $ request ) ; $ content = curl_exec ( $ this -> resource ) ; if ( false === $ content ) { throw new HttpSenderException ( sprintf ( 'cURL Error [%d]: %s' , ( int ) curl_errno ( $ this -> resource ) , ( string ) curl_error ( $ this -> resource ) ) ) ; } $ statusCode = ( int ) curl_getinfo ( $ this -> resource , CURLINFO_HTTP_CODE ) ; return new Response ( $ statusCode , ( string ) $ content ) ; } 
private function initializeCurlResource ( ) : void { if ( ! $ this -> resource ) { $ this -> resource = curl_init ( ) ; curl_setopt ( $ this -> resource , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_POST , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_HTTP_VERSION , 3 ) ; } } 
private function prepareCurlResourceByRequest ( Request $ request ) : void { curl_setopt ( $ this -> resource , CURLOPT_URL , $ request -> getUrl ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_POSTFIELDS , $ request -> getContent ( ) ) ; if ( $ request -> getCertificate ( ) ) { curl_setopt ( $ this -> resource , CURLOPT_SSLCERT , $ request -> getCertificate ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_SSLCERTPASSWD , $ request -> getCertificatePassPhrase ( ) ) ; } $ inlineHeaders = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ inlineHeaders [ ] = sprintf ( '%s: %s' , $ name , $ value ) ; } curl_setopt ( $ this -> resource , CURLOPT_HTTPHEADER , $ inlineHeaders ) ; } 
public function visit ( Notification $ notification , Request $ request ) : Request { $ collapseId = $ notification -> getCollapseId ( ) ; if ( $ collapseId ) { $ request = $ request -> withHeader ( 'apns-collapse-id' , $ collapseId -> getValue ( ) ) ; } return $ request ; } 
public function authenticate ( Request $ request ) : Request { $ now = new \ DateTimeImmutable ( ) ; if ( ! $ this -> jws || $ this -> jwsValidTo < $ now ) { $ this -> jws = $ this -> signatureGenerator -> generate ( $ this -> jwt ) ; $ this -> jwsValidTo = $ this -> jwsLifetime ? ( $ now ) -> add ( $ this -> jwsLifetime ) : $ this -> jwsValidTo ; } $ request = $ request -> withHeader ( 'authorization' , sprintf ( 'bearer %s' , $ this -> jws ) ) ; return $ request ; } 
public function visit ( Notification $ notification , Request $ request ) : Request { $ priority = $ notification -> getPriority ( ) ; if ( $ priority ) { $ request = $ request -> withHeader ( 'apns-priority' , ( string ) $ priority -> getValue ( ) ) ; } return $ request ; } 
public function create ( Response $ response ) : SendNotificationException { $ content = $ response -> getContent ( ) ; if ( ! $ content ) { return new MissingContentInResponseException ( ) ; } $ json = json_decode ( $ content , true ) ; if ( null === $ json ) { return new InvalidResponseException ( sprintf ( 'Can not parse JSON in response. Error: %d - %s' , json_last_error ( ) , json_last_error_msg ( ) ) ) ; } if ( ! array_key_exists ( 'reason' , $ json ) ) { return new MissingErrorReasonInResponseException ( ) ; } $ reason = $ json [ 'reason' ] ; return $ this -> createByReason ( $ reason , $ json ) ; } 
private function createByReason ( string $ reason , array $ json ) : SendNotificationException { $ reason = strtolower ( $ reason ) ; switch ( $ reason ) { case 'badcollapseid' : return new BadCollapseIdException ( ) ; case 'baddevicetoken' : return new BadDeviceTokenException ( ) ; case 'badexpirationdate' : return new BadExpirationDateException ( ) ; case 'badmessageid' : return new BadMessageIdException ( ) ; case 'badpriority' : return new BadPriorityException ( ) ; case 'badtopic' : return new BadTopicException ( ) ; case 'devicetokennotfortopic' : return new DeviceTokenNotForTopicException ( ) ; case 'duplicateheaders' : return new DuplicateHeadersException ( ) ; case 'idletimeout' : return new IdleTimeoutException ( ) ; case 'missingdevicetoken' : return new MissingDeviceTokenException ( ) ; case 'missingtopic' : return new MissingTopicException ( ) ; case 'payloadempty' : return new PayloadEmptyException ( ) ; case 'topicdisallowed' : return new TopicDisallowedException ( ) ; case 'badcertificate' : return new BadCertificateException ( ) ; case 'badcertificateenvironment' : return new BadCertificateEnvironmentException ( ) ; case 'expiredprovidertoken' : return new ExpiredProviderTokenException ( ) ; case 'forbidden' : return new ForbiddenException ( ) ; case 'invalidprovidertoken' : return new InvalidProviderTokenException ( ) ; case 'missingprovidertoken' : return new MissingProviderTokenException ( ) ; case 'badpath' : return new BadPathException ( ) ; case 'methodnotallowed' : return new MethodNotAllowedException ( ) ; case 'unregistered' : $ timestamp = array_key_exists ( 'timestamp' , $ json ) ? $ json [ 'timestamp' ] : 0 ; $ lastConfirmed = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; $ lastConfirmed -> setTimestamp ( $ timestamp ) ; return new UnregisteredException ( $ lastConfirmed ) ; case 'payloadtoolarge' : return new PayloadTooLargeException ( ) ; case 'toomanyprovidertokenupdates' : return new TooManyProviderTokenUpdatesException ( ) ; case 'toomanyrequests' : return new TooManyRequestsException ( ) ; case 'internalservererror' : return new InternalServerErrorException ( ) ; case 'serviceunavailable' : return new ServiceUnavailableException ( ) ; case 'shutdown' : return new ShutdownException ( ) ; default : return new UndefinedErrorException ( ) ; } } 
public function encode ( Payload $ payload ) : string { $ data = [ 'aps' => $ this -> convertApsToArray ( $ payload -> getAps ( ) ) , ] ; $ data = array_merge ( $ payload -> getCustomData ( ) , $ data ) ; return json_encode ( $ data ) ; } 
private function convertApsToArray ( Aps $ aps ) : array { $ data = [ 'alert' => $ this -> convertAlertToArray ( $ aps -> getAlert ( ) ) , ] ; if ( $ aps -> getSound ( ) ) { $ data [ 'sound' ] = $ aps -> getSound ( ) ; } if ( $ aps -> getBadge ( ) !== null ) { $ data [ 'badge' ] = $ aps -> getBadge ( ) ; } if ( $ aps -> getCategory ( ) ) { $ data [ 'category' ] = $ aps -> getCategory ( ) ; } if ( $ aps -> isContentAvailable ( ) ) { $ data [ 'content-available' ] = 1 ; } if ( $ aps -> isMutableContent ( ) ) { $ data [ 'mutable-content' ] = 1 ; } if ( $ aps -> getThreadId ( ) ) { $ data [ 'thread-id' ] = $ aps -> getThreadId ( ) ; } return $ data ; } 
private function convertAlertToArray ( Alert $ alert ) : array { $ data = [ ] ; if ( $ alert -> getBodyLocalized ( ) -> getKey ( ) ) { $ data [ 'loc-key' ] = $ alert -> getBodyLocalized ( ) -> getKey ( ) ; $ data [ 'loc-args' ] = $ alert -> getBodyLocalized ( ) -> getArgs ( ) ; } else { $ data [ 'body' ] = $ alert -> getBody ( ) ; } if ( $ alert -> getTitleLocalized ( ) -> getKey ( ) ) { $ data [ 'title-loc-key' ] = $ alert -> getTitleLocalized ( ) -> getKey ( ) ; $ data [ 'title-loc-args' ] = $ alert -> getTitleLocalized ( ) -> getArgs ( ) ; } elseif ( $ alert -> getTitle ( ) ) { $ data [ 'title' ] = $ alert -> getTitle ( ) ; } if ( $ alert -> getActionLocalized ( ) -> getKey ( ) ) { $ data [ 'action-loc-key' ] = $ alert -> getActionLocalized ( ) -> getKey ( ) ; } if ( $ alert -> getLaunchImage ( ) ) { $ data [ 'launch-image' ] = $ alert -> getLaunchImage ( ) ; } return $ data ; } 
public function getValue ( string $ mailableClass , string $ argumentName , string $ argumentType = '' , $ defaultValue = null ) { if ( $ argumentType === 'int' ) { return $ defaultValue ?? $ this -> faker -> numberBetween ( 1 , 100 ) ; } if ( $ argumentType === 'string' ) { return $ defaultValue ?? $ this -> faker -> sentence ( ) ; } if ( $ argumentType === 'bool' ) { $ defaultValue = ( $ defaultValue == 'false' ? false : $ defaultValue ) ; return $ defaultValue ?? $ this -> faker -> boolean ( 50 ) ; } try { $ argumentValue = app ( $ argumentType ) ; } catch ( Exception $ exception ) { throw CouldNotDetermineValue :: create ( $ argumentType , $ argumentName , $ exception ) ; } if ( $ argumentValue instanceof Model ) { return $ this -> getModelInstance ( $ mailableClass , $ argumentName , $ argumentValue , $ id = $ defaultValue ) ; } return $ argumentValue ; } 
protected function getModelInstance ( string $ mailableClass , string $ argumentName , Model $ model , $ id ) : Model { $ modelInstance = $ id ? $ model -> find ( $ id ) : $ model -> first ( ) ; if ( ! $ modelInstance ) { throw CouldNotDetermineValue :: noModelInstanceFound ( $ model ) ; } return $ modelInstance ; } 
public function up ( ) { Schema :: table ( 'ltm_translations' , function ( Blueprint $ table ) { $ table -> dropColumn ( 'source' ) ; } ) ; Schema :: table ( 'ltm_translations' , function ( Blueprint $ table ) { $ table -> text ( 'source' ) -> nullable ( ) ; $ table -> boolean ( 'is_auto_added' ) -> default ( 0 ) ; } ) ; } 
public function down ( ) { Schema :: table ( 'ltm_translations' , function ( Blueprint $ table ) { $ table -> dropColumn ( 'source' ) ; $ table -> dropColumn ( 'is_auto_added' ) ; } ) ; Schema :: table ( 'ltm_translations' , function ( Blueprint $ table ) { $ table -> string ( 'source' , 256 ) -> nullable ( ) ; } ) ; } 
public function handle ( $ request , Closure $ next ) { $ translationManager = App :: make ( ManagerServiceProvider :: PACKAGE ) ; $ response = $ next ( $ request ) ; $ translationManager -> afterRoute ( $ request , $ response ) ; return $ response ; } 
public function cachedTranslation ( $ namespace , $ group , $ transKey , $ locale ) { $ group = self :: fixGroup ( $ group ) ; $ group = $ namespace && $ namespace !== '*' ? $ namespace . '::' . $ group : $ group ; $ cacheKey = $ this -> cacheKey ( $ transKey , $ locale ) ; $ value = $ group && array_key_exists ( $ group , $ this -> cache ( ) ) && array_key_exists ( $ cacheKey , $ this -> cache [ $ group ] ) ? $ this -> cache [ $ group ] [ $ cacheKey ] : null ; return $ value ; } 
public function cachedTranslations ( $ namespace , $ group , $ locale , $ translations = null ) { $ group = self :: fixGroup ( $ group ) ; $ group = $ namespace && $ namespace !== '*' ? $ namespace . '::' . $ group : $ group ; $ translations = $ translations ? : [ ] ; $ values = $ group && array_key_exists ( $ group , $ this -> cache ( ) ) ? $ this -> cache [ $ group ] : null ; if ( $ values ) { $ localePrefix = "$locale:" ; $ prefixLen = strlen ( $ localePrefix ) ; foreach ( $ values as $ key => $ translation ) { if ( str_starts_with ( $ key , $ localePrefix ) ) { $ transKey = substr ( $ key , $ prefixLen ) ; $ translations [ $ transKey ] = $ translation ; } } } return $ translations ; } 
public function missingKey ( $ namespace , $ group , $ key , $ locale = null , $ useLottery = true , $ findOrNew = false ) { if ( ! $ useLottery || $ this -> config ( self :: LOG_MISSING_KEYS_KEY ) ) { 
public static function getDiffOpcodes ( $ from , $ to , $ granularities = null ) { $ diff = new FineDiff ( $ from , $ to , $ granularities ) ; return $ diff -> getOpcodes ( ) ; } 
public static function getDiffOpsFromOpcodes ( $ opcodes ) { $ diffops = new FineDiffOps ( ) ; FineDiff :: renderFromOpcodes ( null , $ opcodes , array ( $ diffops , 'appendOpcode' ) ) ; return $ diffops -> edits ; } 
public static function renderFromOpcodes ( $ from , $ opcodes , $ callback ) { if ( ! is_callable ( $ callback ) ) { return ; } $ opcodes_len = strlen ( $ opcodes ) ; $ from_offset = $ opcodes_offset = 0 ; while ( $ opcodes_offset < $ opcodes_len ) { $ opcode = substr ( $ opcodes , $ opcodes_offset , 1 ) ; $ opcodes_offset ++ ; $ n = intval ( substr ( $ opcodes , $ opcodes_offset ) ) ; if ( $ n ) { $ opcodes_offset += strlen ( strval ( $ n ) ) ; } else { $ n = 1 ; } if ( $ opcode === 'c' ) { 
private function doDiff ( $ from_text , $ to_text ) { $ this -> last_edit = false ; $ this -> stackpointer = 0 ; $ this -> from_text = $ from_text ; $ this -> from_offset = 0 ; 
private function _processGranularity ( $ from_segment , $ to_segment ) { $ delimiters = $ this -> granularityStack [ $ this -> stackpointer ++ ] ; $ has_next_stage = $ this -> stackpointer < count ( $ this -> granularityStack ) ; foreach ( FineDiff :: doFragmentDiff ( $ from_segment , $ to_segment , $ delimiters ) as $ fragment_edit ) { 
private static function doFragmentDiff ( $ from_text , $ to_text , $ delimiters ) { 
private static function doCharDiff ( $ from_text , $ to_text ) { $ result = array ( ) ; $ jobs = array ( array ( 0 , strlen ( $ from_text ) , 0 , strlen ( $ to_text ) ) ) ; while ( $ job = array_pop ( $ jobs ) ) { 
private static function extractFragments ( $ text , $ delimiters ) { 
private static function renderToTextFromOpcode ( $ opcode , $ from , $ from_offset , $ from_len ) { if ( $ opcode === 'c' || $ opcode === 'i' ) { echo substr ( $ from , $ from_offset , $ from_len ) ; } } 
public static function dbValue ( $ value , $ nullValue = 'NULL' ) { if ( $ value === null ) { return $ nullValue ; } if ( is_string ( $ value ) ) { return '\'' . str_replace ( '\'' , '\'\'' , $ value ) . '\'' ; } if ( is_bool ( $ value ) ) { return $ value ? '1' : '0' ; } return $ value ; } 
protected function adjustTranslationTable ( $ sql ) { $ adjustedSql = $ this -> tableRenameNeeded ? str_replace ( ' ltm_translations ' , ' ' . $ this -> tableName . ' ' , $ sql ) : $ sql ; return $ adjustedSql ; } 
public function getInsertTranslationsElement ( $ translation , $ timeStamp ) { return '(' . self :: dbValue ( $ translation -> status , Translation :: STATUS_SAVED ) . ',' . self :: dbValue ( $ translation -> locale ) . ',' . self :: dbValue ( $ translation -> group ) . ',' . self :: dbValue ( $ translation -> key ) . ',' . self :: dbValue ( $ translation -> value ) . ',' . self :: dbValue ( $ translation -> created_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> updated_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> source ) . ',' . self :: dbValue ( $ translation -> saved_value ) . ',' . self :: dbValue ( $ translation -> is_deleted , 0 ) . ',' . self :: dbValue ( $ translation -> was_used , 0 ) . ')' ; } 
public function up ( ) { Schema :: create ( 'ltm_user_locales' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> integer ( 'user_id' , false , true ) ; $ table -> text ( 'locales' ) -> nullable ( ) ; $ table -> index ( [ 'user_id' ] , 'ix_ltm_user_locales_user_id' ) ; $ table -> timestamps ( ) ; } ) ; } 
public function changeConnectionName ( $ connection ) { if ( ! array_key_exists ( $ connection , $ this -> connectionList ) ) $ connection = '' ; $ resolvedConnection = $ this -> manager -> getResolvedConnectionName ( $ connection ) ; if ( $ resolvedConnection != $ this -> getConnectionName ( ) ) { 
public function getSearch ( ) { $ q = Request :: get ( 'q' ) ; $ translations = $ this -> computeSearch ( $ q , $ this -> transLocales -> displayLocales ) ; $ numTranslations = count ( $ translations ) ; return View :: make ( $ this -> packagePrefix . 'search' ) -> with ( 'controller' , ManagerServiceProvider :: CONTROLLER_PREFIX . get_class ( $ this ) ) -> with ( 'userLocales' , TranslationLocales :: packLocales ( $ this -> transLocales -> userLocales ) ) -> with ( 'package' , $ this -> package ) -> with ( 'translations' , $ translations ) -> with ( 'numTranslations' , $ numTranslations ) ; } 
public function getPublish ( $ group ) { if ( $ group && $ group != '*' ) { $ this -> manager -> exportTranslations ( $ group ) ; } else { $ this -> manager -> exportAllTranslations ( ) ; } $ errors = $ this -> manager -> errors ( ) ; event ( new TranslationsPublished ( $ group , $ errors ) ) ; return Response :: json ( array ( 'status' => $ errors ? 'errors' : 'ok' , 'errors' => $ errors ) ) ; } 
public static function apiRoutes ( $ disableReactUI ) { 
public function postMissingKeys ( ) { $ missingKeys = Request :: json ( 'missingKeys' ) ; 
public function postEdit ( $ group ) { if ( ! in_array ( $ group , $ this -> manager -> config ( Manager :: EXCLUDE_GROUPS_KEY ) ) ) { $ name = Request :: get ( 'name' ) ; $ value = Request :: get ( 'value' ) ; list ( $ locale , $ key ) = explode ( '|' , $ name , 2 ) ; if ( $ this -> isLocaleEnabled ( $ locale ) ) { $ translation = $ this -> manager -> firstOrNewTranslation ( array ( 'locale' => $ locale , 'group' => $ group , 'key' => $ key , ) ) ; $ markdownSuffix = $ this -> manager -> config ( Manager :: MARKDOWN_KEY_SUFFIX ) ; $ isMarkdownKey = $ markdownSuffix != '' && ends_with ( $ key , $ markdownSuffix ) && $ key !== $ markdownSuffix ; if ( ! $ isMarkdownKey ) { 
public function handle ( ) { $ group = $ this -> argument ( 'group' ) ; if ( $ group && $ group != '*' ) { $ this -> manager -> exportTranslations ( $ group ) ; } else { $ this -> manager -> exportAllTranslations ( ) ; } $ errors = $ this -> manager -> errors ( ) ; event ( new TranslationsPublished ( $ group , $ errors ) ) ; $ this -> info ( "Done writing language files for " . ( ( $ group == '*' ) ? 'ALL groups' : $ group . " group" ) ) ; } 
public function up ( ) { $ prefix = \ Config :: get ( 'laravel-translation-manager::config.table_prefix' , '' ) ; Schema :: table ( $ prefix . 'ltm_user_locales' , function ( Blueprint $ table ) use ( $ prefix ) { $ table -> dropIndex ( 'ix_ltm_user_locales_user_id' ) ; $ table -> unique ( 'user_id' , 'ixk_user_id_users_id' ) ; $ table -> text ( 'ui_settings' ) -> nullable ( ) ; } ) ; } 
public function down ( ) { $ prefix = \ Config :: get ( 'laravel-translation-manager::config.table_prefix' , '' ) ; Schema :: table ( $ prefix . 'ltm_user_locales' , function ( Blueprint $ table ) use ( $ prefix ) { $ table -> dropColumn ( 'ui_settings' ) ; $ table -> dropUnique ( 'ixk_user_id_users_id' ) ; $ table -> index ( [ 'user_id' ] , 'ix_ltm_user_locales_user_id' ) ; } ) ; } 
public function boot ( Router $ router ) { $ resources = __DIR__ . '/../resources/' ; $ this -> loadViewsFrom ( $ resources . 'views' , self :: PACKAGE ) ; $ this -> loadTranslationsFrom ( $ resources . 'lang' , self :: PACKAGE ) ; $ this -> publishes ( [ $ resources . 'views' => base_path ( 'resources/views/vendor/' . self :: PACKAGE ) , ] , 'views' ) ; $ this -> publishes ( [ $ resources . 'lang' => base_path ( 'resources/lang/vendor/' . self :: PACKAGE ) , ] , 'lang' ) ; $ this -> publishes ( [ __DIR__ . '/../public' => public_path ( 'vendor/' . self :: PACKAGE ) , ] , 'public' ) ; $ migrationPath = __DIR__ . '/../database/migrations' ; $ this -> publishes ( [ $ migrationPath => base_path ( 'database/migrations' ) , ] , 'migrations' ) ; $ config = $ this -> app [ 'config' ] -> get ( self :: PACKAGE . '.route' , [ ] ) ; $ config [ 'namespace' ] = 'Vsch\TranslationManager' ; 
public function formatForExport ( $ trans , $ options = null ) { $ text = "<?php\n\nreturn " . ( ( $ options & self :: OPT_USE_SHORT_ARRAY ) ? "[\n" : "array(\n" ) ; 
public function register ( ) { $ this -> registerLoader ( ) ; $ db_driver = config ( 'database.default' ) ; if ( $ db_driver === 'pgsql' ) { $ translatorRepository = 'Vsch\TranslationManager\Repositories\PostgresTranslatorRepository' ; } else { $ translatorRepository = 'Vsch\TranslationManager\Repositories\MysqlTranslatorRepository' ; } $ this -> app -> bind ( 'Vsch\TranslationManager\Repositories\Interfaces\ITranslatorRepository' , $ translatorRepository ) ; $ this -> app -> singleton ( 'translator' , function ( $ app ) { $ loader = $ app [ 'translation.loader' ] ; 
public function getLocale ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'lang_locale' ; $ queuedCookieLocale = \ Cookie :: queued ( $ key , null ) ; $ locale = getSupportedLocale ( $ queuedCookieLocale != null ? $ queuedCookieLocale -> getValue ( ) : \ Cookie :: get ( $ key , '' ) ) ; parent :: setLocale ( $ locale ) ; 
public function setLocale ( $ locale ) { if ( $ this -> useCookies ) { Cookie :: queue ( $ this -> cookiePrefix . 'lang_locale' , $ locale ) ; } parent :: setLocale ( $ locale ) ; } 
public function getShowUnpublished ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'show_unpublished' ; $ queuedCookie = \ Cookie :: queued ( $ key , null ) ; $ showUnpublished = $ queuedCookie != null ? $ queuedCookie -> getValue ( ) : \ Cookie :: get ( $ key , false ) ; $ this -> useDB = $ showUnpublished ? 2 : 1 ; $ this -> cookiesLoaded = true ; } return $ this -> useDB === 2 ; } 
public function setShowUnpublished ( $ showUnpublished ) { if ( $ this -> useCookies ) { Cookie :: queue ( $ this -> cookiePrefix . 'show_unpublished' , $ showUnpublished ) ; } $ this -> useDB = $ showUnpublished ? 2 : 1 ; } 
public function getFromJson ( $ key , array $ replace = [ ] , $ locale = null , $ useDB = null ) { 
public function get ( $ key , array $ replace = array ( ) , $ locale = null , $ fallback = true , $ useDB = null ) { $ inplaceEditMode = $ this -> manager -> config ( 'inplace_edit_mode' ) ; list ( $ namespace , $ group , $ item ) = $ this -> parseKey ( $ key ) ; if ( $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 2 ) { if ( ! in_array ( $ key , $ this -> usedKeys ) ) { $ this -> usedKeys [ ] = $ key ; } } if ( ! $ this -> suspendInPlaceEdit && $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 1 ) { $ this -> notifyUsingGroupItem ( $ namespace , $ group , $ item , $ locale ) ; return $ this -> inPlaceEditLink ( null , true , $ key , $ locale ) ; } if ( $ useDB === null ) $ useDB = $ this -> useDB ; if ( $ useDB && $ useDB !== 2 ) { $ augmentedGroup = $ this -> manager -> getAugmentedGroup ( $ namespace , $ group ) ; $ result = $ this -> manager -> cachedTranslation ( '' , $ augmentedGroup , $ item , $ locale ? : $ this -> locale ( ) ) ; if ( $ result ) { $ this -> notifyUsingGroupItem ( '' , $ augmentedGroup , $ item , $ locale ) ; return $ this -> processResult ( $ result , $ replace ) ; } } if ( $ useDB == 2 ) { if ( $ this -> manager && $ group && $ item && ! $ this -> manager -> excludedPageEditGroup ( $ group ) ) { $ t = $ this -> manager -> missingKey ( $ namespace , $ group , $ item , $ locale , $ this -> isUseLottery ( ) , true ) ; if ( $ t ) { $ result = $ t -> value ? : $ key ; if ( $ t -> isDirty ( ) ) { unset ( $ t -> diff ) ; 
public function getEditableLinksOnly ( ) { $ inplaceEditMode = $ this -> manager -> config ( 'inplace_edit_mode' ) ; if ( $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 2 ) { $ keyDiv = '<div id="keys" style="padding:5px; padding-top:0; white-space: nowrap;">' . PHP_EOL . '<b>Keys</b><br>' . PHP_EOL ; $ textDiv = '<div id="keytexts" style="padding:5px; padding-top:0; white-space: nowrap;">' . PHP_EOL . '<b>Translations</b><br>' . PHP_EOL ; $ sorted = $ this -> usedKeys ; sort ( $ sorted ) ; foreach ( $ sorted as $ key ) { $ keyDiv .= $ key . '<br>' . PHP_EOL ; $ textDiv .= $ this -> getInPlaceEditLink ( $ key , [ ] , $ this -> locale , $ this -> useDB ) . '<br>' . PHP_EOL ; } $ keyDiv .= '</div>' . PHP_EOL ; $ textDiv .= '</div>' . PHP_EOL ; 
public function getWebUITranslations ( ) { $ TITLE_SAVE_CHANGES = $ this -> get ( $ this -> package . '::messages.title-save-changes' ) ; $ TITLE_CANCEL_CHANGES = $ this -> get ( $ this -> package . '::messages.title-cancel-changes' ) ; $ TITLE_TRANSLATE = $ this -> get ( $ this -> package . '::messages.title-translate' ) ; $ TITLE_CONVERT_KEY = $ this -> get ( $ this -> package . '::messages.title-convert-key' ) ; $ TITLE_GENERATE_PLURALS = $ this -> get ( $ this -> package . '::messages.title-generate-plurals' ) ; $ TITLE_CLEAN_HTML_MARKDOWN = $ this -> get ( $ this -> package . '::messages.title-clean-html-markdown' ) ; $ TITLE_CAPITALIZE = $ this -> get ( $ this -> package . '::messages.title-capitalize' ) ; $ TITLE_LOWERCASE = $ this -> get ( $ this -> package . '::messages.title-lowercase' ) ; $ TITLE_CAPITALIZE_FIRST_WORD = $ this -> get ( $ this -> package . '::messages.title-capitalize-first-word' ) ; $ TITLE_SIMULATED_COPY = $ this -> get ( $ this -> package . '::messages.title-simulated-copy' ) ; $ TITLE_SIMULATED_PASTE = $ this -> get ( $ this -> package . '::messages.title-simulated-paste' ) ; $ TITLE_RESET_EDITOR = $ this -> get ( $ this -> package . '::messages.title-reset-editor' ) ; $ TITLE_LOAD_LAST = $ this -> get ( $ this -> package . '::messages.title-load-last' ) ; return <<<HTML <script> var TITLE_SAVE_CHANGES = "$TITLE_SAVE_CHANGES"; var TITLE_CANCEL_CHANGES = "$TITLE_CANCEL_CHANGES"; var TITLE_TRANSLATE = "$TITLE_TRANSLATE"; var TITLE_CONVERT_KEY = "$TITLE_CONVERT_KEY"; var TITLE_GENERATE_PLURALS = "$TITLE_GENERATE_PLURALS"; var TITLE_CLEAN_HTML_MARKDOWN = "$TITLE_CLEAN_HTML_MARKDOWN"; var TITLE_CAPITALIZE = "$TITLE_CAPITALIZE"; var TITLE_LOWERCASE = "$TITLE_LOWERCASE"; var TITLE_CAPITALIZE_FIRST_WORD = "$TITLE_CAPITALIZE_FIRST_WORD"; var TITLE_SIMULATED_COPY = "$TITLE_SIMULATED_COPY"; var TITLE_SIMULATED_PASTE = "$TITLE_SIMULATED_PASTE"; var TITLE_RESET_EDITOR = "$TITLE_RESET_EDITOR"; var TITLE_LOAD_LAST = "$TITLE_LOAD_LAST"; </script> HTML ; } 
public function getEditableLinks ( ) { $ inplaceEditMode = $ this -> manager -> config ( 'inplace_edit_mode' ) ; if ( $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 2 ) { return getEditableTranslationsButton ( ) . $ this -> getEditableLinksOnly ( ) ; } return null ; } 
public function choice ( $ key , $ number , array $ replace = array ( ) , $ locale = null , $ useDB = null ) { $ inplaceEditMode = $ this -> manager -> config ( 'inplace_edit_mode' ) ; if ( $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 2 ) { if ( ! in_array ( $ key , $ this -> usedKeys ) ) { $ this -> usedKeys [ ] = $ key ; } } if ( ! $ this -> suspendInPlaceEdit && $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 1 ) { return $ this -> get ( $ key , $ replace , $ locale , true , $ useDB ) ; } else { if ( $ useDB !== null ) { $ oldUseDB = $ this -> useDB ; $ this -> useDB = $ useDB ; $ retVal = parent :: choice ( $ key , $ number , $ replace , $ locale ) ; $ this -> useDB = $ oldUseDB ; return $ retVal ; } else { return parent :: choice ( $ key , $ number , $ replace , $ locale ) ; } } } 
public function parse ( $ input , $ itemCallback , $ assoc = true ) { $ this -> checkCallback ( $ itemCallback ) ; $ stream = $ this -> openStream ( $ input ) ; try { $ listener = new Listener ( $ itemCallback , $ assoc ) ; $ this -> parser = new \ JsonStreamingParser \ Parser ( $ stream , $ listener , $ this -> getOption ( 'line_ending' ) , $ this -> getOption ( 'emit_whitespace' ) ) ; $ this -> parser -> parse ( ) ; } catch ( \ Exception $ e ) { $ this -> gzipSupported ? gzclose ( $ stream ) : fclose ( $ stream ) ; throw $ e ; } $ this -> gzipSupported ? gzclose ( $ stream ) : fclose ( $ stream ) ; } 
protected function openStream ( $ input ) { if ( is_resource ( $ input ) ) { return $ input ; } if ( ! is_file ( $ input ) ) { throw new \ Exception ( 'File does not exist: ' . $ input ) ; } $ stream = $ this -> gzipSupported ? @ gzopen ( $ input , 'r' ) : @ fopen ( $ input , 'r' ) ; if ( false === $ stream ) { throw new \ Exception ( 'Unable to open file for read: ' . $ input ) ; } return $ stream ; } 
public static function login ( $ email , $ password , $ challenge = '' , $ code = '' ) { $ requestParams = [ 'includePerms' => 'false' , 
public static function refresh ( $ refresh_token ) { $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'refresh_token' , 'refresh_token' => $ refresh_token , 'includePerms' => "false" , 
public function id ( $ id ) { foreach ( $ this -> items as $ item ) { if ( $ item -> itemId == $ id ) return $ item ; } return null ; } 
private function parseItems ( $ items ) { $ actual = [ ] ; foreach ( $ items as $ key => $ item ) { if ( strpos ( $ item -> templateId , "Quest:" ) !== false ) continue ; $ newItem = $ item ; $ newItem -> itemId = $ key ; 
public function get ( $ platform , $ type ) { if ( $ platform !== Platform :: PC && $ platform !== Platform :: PS4 && $ platform !== Platform :: XBOX1 ) throw new \ Exception ( 'Please select a platform' ) ; if ( $ type !== Mode :: DUO && $ type !== Mode :: SOLO && $ type !== Mode :: SQUAD ) { throw new \ Exception ( 'Please select a game mode' ) ; } try { $ data_cohort = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_API . "game/v2/leaderboards/cohort/$this->in_app_id?playlist={$platform}_m0{$type}" , $ this -> access_token , array ( 'Content-Type: application/json' ) ) ; $ data = FortniteClient :: sendFortnitePostRequest ( FortniteClient :: FORTNITE_API . "leaderboards/type/global/stat/br_placetop1_{$platform}_m0{$type}/window/weekly?ownertype=1&itemsPerPage=50" , $ this -> access_token , $ data_cohort -> cohortAccounts ) ; $ entries = $ data -> entries ; $ ids = array ( ) ; foreach ( $ entries as $ entry ) { $ entry -> accountId = str_replace ( "-" , "" , $ entry -> accountId ) ; array_push ( $ ids , $ entry -> accountId ) ; } $ accounts = $ this -> account -> getDisplayNamesFromID ( $ ids ) ; foreach ( $ entries as $ entry ) { foreach ( $ accounts as $ account ) { if ( $ entry -> accountId === $ account -> id ) { $ entry -> displayName = $ account -> displayName ?? null ; break ; } } } $ leaderboard = [ ] ; foreach ( $ entries as $ key => $ stat ) { $ leaderboard [ $ key ] = new FortniteLeaderboard ( $ stat ) ; } return $ leaderboard ; } catch ( GuzzleException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) { throw new LeaderboardNotFoundException ( 'Could not get leaderboards.' ) ; } throw $ e ; } } 
private function fetch ( $ account_id ) { if ( ! $ account_id ) return null ; $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_API . 'stats/accountId/' . $ account_id . '/bulk/window/alltime' , $ this -> access_token ) ; 
public function lookup ( $ username ) { try { $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_PERSONA_API . 'public/account/lookup?q=' . urlencode ( $ username ) , $ this -> access_token ) ; return new self ( $ this -> access_token , $ data -> id ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) throw new UserNotFoundException ( 'User ' . $ username . ' was not found.' ) ; throw $ e ; 
private function parseStatItem ( $ stat ) : array { 
private function fetch ( ) { $ data = FortniteClient :: sendFortnitePostRequest ( FortniteClient :: FORTNITE_API . 'game/v2/profile/' . $ this -> account_id . '/client/QueryProfile?profileId=athena&rvn=-1' , $ this -> access_token , new \ StdClass ( ) ) ; return $ data -> profileChanges [ 0 ] -> profile ; } 
public function getFriends ( ) { $ data = FortniteClient :: sendUnrealClientGetRequest ( FortniteClient :: EPIC_FRIENDS_ENDPOINT . $ this -> account_id , $ this -> access_token , true ) ; return $ data ; } 
public static function sendUnrealClientGetRequest ( $ endpoint , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; 
public static function sendUnrealClientPostRequest ( $ endpoint , $ params = null , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( [ 'http_errors' => false ] ) ; try { $ response = $ client -> post ( $ endpoint , [ 'form_params' => $ params , 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization , 'X-Epic-Device-ID' => self :: generateDeviceId ( ) ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; 
public static function sendFortniteGetRequest ( $ endpoint , $ access_token , $ extra_headers = array ( ) ) { $ client = new Client ( ) ; $ headers = [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ; $ headers = array_merge ( $ headers , $ extra_headers ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => $ headers ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; 
public static function sendFortnitePostRequest ( $ endpoint , $ access_token , $ params = null ) { $ client = new Client ( ) ; try { $ response = $ client -> post ( $ endpoint , [ 'json' => $ params , 'headers' => [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; 
protected function getHierarchyKey ( $ key , & $ pathKey = null ) { if ( ! $ this -> isHierarchyKey ( $ key ) ) { return $ key ; } $ key = $ this -> explodeKey ( $ key ) ; $ keyString = '' ; 
private function explodeKey ( $ string ) { list ( $ key , $ tag ) = explode ( AbstractCachePool :: SEPARATOR_TAG , $ string . AbstractCachePool :: SEPARATOR_TAG ) ; if ( $ key === HierarchicalPoolInterface :: HIERARCHY_SEPARATOR ) { $ parts = [ 'root' ] ; } else { $ parts = explode ( HierarchicalPoolInterface :: HIERARCHY_SEPARATOR , $ key ) ; 
public static function findByAttribute ( $ attribute , $ searchValue ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> select ( 'samaccountname' ) -> where ( $ attribute , '=' , $ searchValue ) -> get ( ) ; $ userObjectReturn = null ; if ( count ( $ userObjectsFound ) == 1 ) { $ userObjectReturn = static :: findByUsername ( $ userObjectsFound [ 0 ] [ 'samaccountname' ] [ 0 ] ) ; } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } return $ userObjectReturn ; } 
public static function findByUsername ( $ username ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'findByUsername' , static :: YII2_PROFILE_NAME . 'findByUsername' ) ; } $ userObjectDb = static :: findOne ( [ 'username' => $ username ] ) ; //Create user if not found in db if ( $ userObjectDb == null ) { //Just create to get synchronisation options $ userObjectDb = new static ( ) ; if ( static :: getSyncOptions ( 'ON_LOGIN_CREATE_USER' , $ userObjectDb -> individualSyncOptions ) == true ) { $ userObjectDb = static :: createNewUser ( $ username ) ; } else { $ userObjectDb = null ; } } else { //Refresh group assignments of user if found in database if ( static :: getSyncOptions ( 'ON_LOGIN_REFRESH_GROUP_ASSIGNMENTS' , $ userObjectDb -> individualSyncOptions ) == true ) { $ userObjectDb -> updateGroupAssignment ( ) ; } //Refresh account status of user if found in database if ( static :: getSyncOptions ( 'ON_LOGIN_REFRESH_LDAP_ACCOUNT_STATUS' , $ userObjectDb -> individualSyncOptions ) == true && static :: getSyncOptions ( 'ON_REQUEST_REFRESH_LDAP_ACCOUNT_STATUS' , $ userObjectDb -> individualSyncOptions ) == false ) { $ userObjectDb -> updateAccountStatus ( ) ; } } $ checkedUserObjectDB = static :: checkAllowedToLogin ( $ userObjectDb ) ; if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'findByUsername' , static :: YII2_PROFILE_NAME . 'findByUsername' ) ; } return $ checkedUserObjectDB ; } 
public static function checkAllowedToLogin ( $ userObjectDb ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'checkAllowedToLogin' , static :: YII2_PROFILE_NAME . 'checkAllowedToLogin' ) ; } $ userInstanceAfterLogin = null ; if ( $ userObjectDb != null && $ userObjectDb -> username != null && $ userObjectDb -> getId ( ) != null ) { //Refresh account status on every request? if ( static :: getSyncOptions ( 'ON_REQUEST_REFRESH_LDAP_ACCOUNT_STATUS' , $ userObjectDb -> individualSyncOptions ) == true ) { $ userObjectDb -> updateAccountStatus ( ) ; } //Login only possible if a role is assigned which matches the LOGIN_POSSIBLE_WITH_ROLE_ASSIGNED_MATCHING_REGEX regex if ( $ userObjectDb -> status == static :: STATUS_ENABLED && static :: getGroupAssigmentOptions ( 'LOGIN_POSSIBLE_WITH_ROLE_ASSIGNED_MATCHING_REGEX' , $ userObjectDb -> individualGroupAssignmentOptions ) != null ) { $ rolesAssignedToUser = Yii :: $ app -> authManager -> getRolesByUser ( $ userObjectDb -> getId ( ) ) ; foreach ( $ rolesAssignedToUser as $ role ) { if ( preg_match ( static :: getGroupAssigmentOptions ( 'LOGIN_POSSIBLE_WITH_ROLE_ASSIGNED_MATCHING_REGEX' , $ userObjectDb -> individualGroupAssignmentOptions ) , $ role -> name ) == true ) { $ userInstanceAfterLogin = $ userObjectDb ; break ; } } } //Login possible if no role is assigned if ( $ userObjectDb -> status == static :: STATUS_ENABLED && static :: getGroupAssigmentOptions ( 'LOGIN_POSSIBLE_WITH_ROLE_ASSIGNED_MATCHING_REGEX' , $ userObjectDb -> individualGroupAssignmentOptions ) == null ) { $ userInstanceAfterLogin = $ userObjectDb ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'checkAllowedToLogin' , static :: YII2_PROFILE_NAME . 'checkAllowedToLogin' ) ; } return $ userInstanceAfterLogin ; } 
public function validatePassword ( $ password ) { //is yii2 profiling enabled? if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'LDAP validatePassword function' , static :: YII2_PROFILE_NAME . 'validatePassword' ) ; } $ passwordValid = static :: getAdldapProvider ( ) -> auth ( ) -> attempt ( $ this -> username , $ password ) ; if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'LDAP validatePassword function' , static :: YII2_PROFILE_NAME . 'validatePassword' ) ; } return $ passwordValid ; } 
public static function createNewUser ( $ username , $ individualGroupAssignmentOptions = null ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } $ userObjectDb = new static ( ) ; //Username has to be set before a LDAP query $ userObjectDb -> username = $ username ; $ userObjectDb -> setIndividualGroupAssignmentOptions ( $ individualGroupAssignmentOptions ) ; //Check if user exists in LDAP. if ( $ userObjectDb -> queryLdapUserObject ( ) == null ) { $ userObjectDb = null ; } else { $ roles = $ userObjectDb -> updateGroupAssignment ( ) ; //When a group is needed for login and no roles are assigned to user, don't create one if ( count ( $ roles ) > 0 || static :: getGroupAssigmentOptions ( 'LOGIN_POSSIBLE_WITH_ROLE_ASSIGNED_MATCHING_REGEX' , $ userObjectDb -> individualGroupAssignmentOptions ) == null ) { $ userObjectDb -> generateAuthKey ( ) ; $ userObjectDb -> updateAccountStatus ( ) ; $ userObjectDb -> save ( ) ; } else { $ userObjectDb = null ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } return $ userObjectDb ; } 
public static function createOrRefreshUser ( $ username , $ individualGroupAssignmentOptions = null ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'createOrRefreshUser' , static :: YII2_PROFILE_NAME . 'createOrRefreshUser' ) ; } $ userObjectDb = static :: findOne ( [ 'username' => $ username ] ) ; //Create user if not found in db if ( $ userObjectDb == null ) { $ userObjectDb = static :: createNewUser ( $ username , $ individualGroupAssignmentOptions ) ; } else { $ userObjectDb -> setIndividualGroupAssignmentOptions ( $ individualGroupAssignmentOptions ) ; $ userObjectDb -> updateAccountStatus ( ) ; $ userObjectDb -> updateGroupAssignment ( ) ; } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'createOrRefreshUser' , static :: YII2_PROFILE_NAME . 'createOrRefreshUser' ) ; } return $ userObjectDb ; } 
public function updateAccountStatus ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'LDAP updateAccountStatus function' , static :: YII2_PROFILE_NAME . 'updateAccountStatus' ) ; } $ ldapUser = $ this -> queryLdapUserObject ( ) ; if ( $ ldapUser == null ) { //If no user is found in LDAP, disable in database. $ this -> status = static :: STATUS_DISABLED ; } else { //Query account status from active directory $ ldapAccountState = $ ldapUser -> getUserAccountControl ( ) ; $ disabledUser = ( $ ldapAccountState & AccountControl :: ACCOUNTDISABLE ) === AccountControl :: ACCOUNTDISABLE ; $ lockedUser = ( $ ldapAccountState & AccountControl :: LOCKOUT ) === AccountControl :: LOCKOUT ; $ pwExpired = ( $ ldapAccountState & AccountControl :: PASSWORD_EXPIRED ) === AccountControl :: PASSWORD_EXPIRED ; if ( $ disabledUser == true || $ lockedUser == true || $ pwExpired == true ) { $ this -> status = static :: STATUS_DISABLED ; } else { $ this -> status = static :: STATUS_ENABLED ; } } $ this -> save ( ) ; if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'LDAP updateAccountStatus function' , static :: YII2_PROFILE_NAME . 'updateAccountStatus' ) ; } return $ this -> status ; } 
public function updateGroupAssignment ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'updateGroupAssignment' , static :: YII2_PROFILE_NAME . 'updateGroupAssignment' ) ; } $ ldapGroupsAssignedToUser = $ this -> getGroupsAssignedInLdap ( ) ; //Query LDAP groups assigned to user $ yiiRolesAssignedToUser = Yii :: $ app -> authManager -> getRolesByUser ( $ this -> getId ( ) ) ; //Get all roles assigned to user $ yiiAvailableRoles = Yii :: $ app -> authManager -> getRoles ( ) ; //Get all avaliable roles in yii2 //Map groups from LDAP to roles and add to user object. if ( static :: getGroupAssigmentOptions ( 'ADD_GROUPS_FROM_LDAP_MATCHING_REGEX' , $ this -> individualGroupAssignmentOptions ) == true ) { foreach ( $ ldapGroupsAssignedToUser as $ gn ) { if ( preg_match ( static :: getGroupAssigmentOptions ( 'REGEX_GROUP_MATCH_IN_LDAP' , $ this -> individualGroupAssignmentOptions ) , $ gn ) == true ) { if ( array_key_exists ( $ gn , $ yiiAvailableRoles ) && ! array_key_exists ( $ gn , $ yiiRolesAssignedToUser ) ) { if ( $ this -> isNewRecord ) { $ this -> generateAuthKey ( ) ; $ this -> updateAccountStatus ( ) ; $ this -> save ( ) ; //Save to db to get id from database } $ auth = Yii :: $ app -> authManager ; $ role = $ auth -> getRole ( $ gn ) ; $ auth -> assign ( $ role , $ this -> getId ( ) ) ; } } } } //Remove all roles from user object which are not in LDAP if ( static :: getGroupAssigmentOptions ( 'REMOVE_ALL_GROUPS_NOT_FOUND_IN_LDAP' , $ this -> individualGroupAssignmentOptions ) == true && static :: getGroupAssigmentOptions ( 'REMOVE_ONLY_GROUPS_MATCHING_REGEX' , $ this -> individualGroupAssignmentOptions ) == false ) { foreach ( $ yiiRolesAssignedToUser as $ role ) { if ( in_array ( $ role -> name , $ ldapGroupsAssignedToUser ) == false ) { $ auth = Yii :: $ app -> authManager ; $ auth -> revoke ( $ role , $ this -> getId ( ) ) ; } } } //Remove all roles from user object which are matching the regex and are not in LDAP if ( static :: getGroupAssigmentOptions ( 'REMOVE_ONLY_GROUPS_MATCHING_REGEX' , $ this -> individualGroupAssignmentOptions ) == true ) { foreach ( $ yiiRolesAssignedToUser as $ role ) { $ roleName = $ role -> name ; if ( preg_match ( static :: getGroupAssigmentOptions ( 'REGEX_GROUP_MATCH_IN_LDAP' , $ this -> individualGroupAssignmentOptions ) , $ roleName ) == true && in_array ( $ roleName , $ ldapGroupsAssignedToUser ) == false ) { $ auth = Yii :: $ app -> authManager ; $ auth -> revoke ( $ role , $ this -> getId ( ) ) ; } } } $ rolesAfterUpdate = Yii :: $ app -> authManager -> getRolesByUser ( $ this -> getId ( ) ) ; if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'updateGroupAssignment' , static :: YII2_PROFILE_NAME . 'updateGroupAssignment' ) ; } //Return assigned roles. return $ rolesAfterUpdate ; } 
public function getGroupsAssignedInLdap ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } $ ldapUser = $ this -> queryLdapUserObject ( ) ; $ ldapGroupsConverted = [ ] ; //start with empty array of groups if ( $ ldapUser != null ) { //check for nested groups? if ( static :: getGroupAssigmentOptions ( 'SEARCH_NESTED_GROUPS' , $ this -> individualGroupAssignmentOptions ) == true ) { //$ldapGroups=$ldapUser->getGroups(['cn'], $recursive=true); //alternate Query, but slower //1.2.840.113556.1.4.1941 = Specical OID to resolve chains $ ldapGroups = static :: getAdldapProvider ( ) -> search ( ) -> rawFilter ( '(member:1.2.840.113556.1.4.1941:=' . $ ldapUser -> getDn ( ) . ')' ) -> select ( 'cn' ) -> raw ( ) -> get ( ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } //get cn of each group foreach ( $ ldapGroups as $ groupDn ) { if ( is_array ( $ groupDn ) && array_key_exists ( 'cn' , $ groupDn ) ) { array_push ( $ ldapGroupsConverted , $ groupDn [ 'cn' ] [ 0 ] ) ; } } } else { //get attribute memberof $ ldapGroups = $ ldapUser -> getAttribute ( 'memberof' ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } //get first part of dn foreach ( $ ldapGroups as $ groupDn ) { $ n = Utilities :: explodeDn ( $ groupDn ) [ 0 ] ; array_push ( $ ldapGroupsConverted , $ n ) ; } } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } return $ ldapGroupsConverted ; } 
public function queryLdapUserObject ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } if ( $ this -> ldapUserObject == null ) { if ( $ this -> username == null ) { throw new \ yii \ base \ Exception ( 'Please set username attribute before calling queryLdapUserObject() function.' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> where ( 'sAMAccountname' , '=' , $ this -> username ) -> get ( ) ; if ( count ( $ userObjectsFound ) != 1 ) { $ this -> ldapUserObject = null ; } else { $ this -> ldapUserObject = $ userObjectsFound [ 0 ] ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } return $ this -> ldapUserObject ; } 
private function getAdldap2Provider ( ) { if ( isset ( Yii :: $ app -> params [ 'yii2-adldap-providername' ] ) ) { $ provider = Yii :: $ app -> ad -> getProvider ( Yii :: $ app -> params [ 'yii2-adldap-providername' ] ) ; } else { $ provider = Yii :: $ app -> ad -> getDefaultProvider ( ) ; } return $ provider ; } 
public static function getAdldapProvider ( ) { if ( static :: getExtensionOptions ( 'adldap-providername' ) != '__USE_DEFAULT_PROVIDER__' ) { $ provider = Yii :: $ app -> ad -> getProvider ( static :: getExtensionOptions ( 'adldap-providername' ) ) ; } else { $ provider = Yii :: $ app -> ad -> getDefaultProvider ( ) ; } return $ provider ; } 
public static function getSyncOptions ( $ optionName , $ individualSyncOptions = null ) { //try object specific settings if ( $ individualSyncOptions != null && is_array ( $ individualSyncOptions ) && array_key_exists ( $ optionName , $ individualSyncOptions ) ) { return $ individualSyncOptions [ $ optionName ] ; } //try yii2 params else if ( isset ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] [ $ optionName ] ; } //default from distribution else if ( array_key_exists ( $ optionName , static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK ) ) { return static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK [ $ optionName ] ; } //Exception else { throw new \ yii \ base \ Exception ( 'Sync-option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } } 
public static function getGroupAssigmentOptions ( $ optionName , $ individualGroupAssignmentOptions = null ) { //try object specific settings if ( $ individualGroupAssignmentOptions != null && is_array ( $ individualGroupAssignmentOptions ) && array_key_exists ( $ optionName , $ individualGroupAssignmentOptions ) ) { return $ individualGroupAssignmentOptions [ $ optionName ] ; } //try yii2 params else if ( isset ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] [ $ optionName ] ; } //default from distribution else if ( array_key_exists ( $ optionName , static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX ) ) { return static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX [ $ optionName ] ; } //Exception else { throw new \ yii \ base \ Exception ( 'Group-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } } 
public static function getExtensionOptions ( $ optionName ) { //try yii2 params if ( isset ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && is_array ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) ) { return Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] [ $ optionName ] ; } //default from distribution else if ( array_key_exists ( $ optionName , static :: EXTENSION_OPTIONS_DEFAULT ) ) { return static :: EXTENSION_OPTIONS_DEFAULT [ $ optionName ] ; } //Exception else { throw new \ yii \ base \ Exception ( 'Extension-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } } 
public function getPasswordExpiryDate ( ) { if ( $ this -> username == null ) { throw new \ yii \ base \ Exception ( 'Please set username attribute before calling getPasswordExpiryDate() function.' ) ; } $ result = static :: getAdldapProvider ( ) -> search ( ) -> select ( [ 'msDS-UserPasswordExpiryTimeComputed' ] ) -> where ( 'samaccountname' , '=' , $ this -> username ) -> get ( ) ; return $ result [ 0 ] -> getFirstAttribute ( 'msds-userpasswordexpirytimecomputed' ) ; } 
public function init ( ) { if ( ! isset ( $ this -> adLdapInstance ) ) { $ this -> adLdapInstance = new Adldap ( ) ; } foreach ( $ this -> providers as $ providerName => $ prodivderSettings ) { $ config = new \ Adldap \ Connections \ Provider ( $ prodivderSettings [ 'config' ] ) ; $ this -> adLdapInstance -> addProvider ( $ config , $ providerName ) ; if ( array_key_exists ( 'schema' , $ prodivderSettings ) && is_object ( $ prodivderSettings [ 'schema' ] ) ) { $ this -> adLdapInstance -> getProvider ( $ providerName ) -> setSchema ( $ prodivderSettings [ 'schema' ] ) ; } if ( $ prodivderSettings [ 'autoconnect' ] == true ) { $ this -> adLdapInstance -> connect ( $ providerName ) ; } } $ providers = $ this -> adLdapInstance -> getProviders ( ) ; if ( array_key_exists ( $ this -> defaultProvider , $ providers ) ) { $ this -> adLdapInstance -> setDefaultProvider ( $ this -> defaultProvider ) ; } else { throw new \ yii \ base \ Exception ( "The given defaultprovder with the name " . $ this -> defaultProvider . " could not be found. See https://github.com/edvler/yii2-adldap-module/blob/master/readme.md" ) ; } } 
public function actionCreateExampleRole ( ) { $ auth = Yii :: $ app -> authManager ; 
public function actionImportAllUsers ( ) { \ Yii :: warning ( "-- Starting import from Active Directory --" ) ; $ results = \ Yii :: $ app -> ad -> getDefaultProvider ( ) -> search ( ) -> select ( "samaccountname" ) -> where ( 'objectClass' , '=' , 'user' ) -> where ( 'objectCategory' , '=' , 'person' ) -> paginate ( 999 ) ; $ userNamesToAdd = [ ] ; foreach ( $ results -> getResults ( ) as $ ldapUser ) { $ accountName = $ ldapUser -> getAttribute ( "samaccountname" , 0 ) ; if ( $ accountName != null ) { array_push ( $ userNamesToAdd , $ accountName ) ; } } $ c = 0 ; \ Yii :: warning ( "-- Found " . count ( $ userNamesToAdd ) . " users --" ) ; foreach ( $ userNamesToAdd as $ userName ) { $ c ++ ; \ Yii :: warning ( "-- Working on user " . $ userName . " --" ) ; $ userObject = \ Edvlerblog \ Adldap2 \ model \ UserDbLdap :: createOrRefreshUser ( $ userName ) ; if ( $ userObject != null ) { \ Yii :: warning ( "User " . $ userName . " created" ) ; } else { \ Yii :: warning ( "User " . $ userName . " NOT created" ) ; } } \ Yii :: warning ( "-- End import from Active Directory --" ) ; } 
public function handle ( ) { $ path = ( ( $ this -> option ( 'path' ) ) ? $ this -> option ( 'path' ) : app_path ( ) ) . '/' ; $ model = $ this -> argument ( 'model' ) ; $ files = $ this -> getFiles ( $ model ) ; foreach ( $ files as $ file ) { $ file_path = $ path . $ file ; if ( $ this -> writeable ( $ file_path ) ) { $ this -> write ( $ file , $ file_path ) ; $ this -> info ( $ file . ' saved to ' . $ file_path ) ; } } } 
protected function writeable ( $ file_path ) { if ( $ this -> option ( 'force' ) ) { return true ; } return ( ! file_exists ( $ file_path ) || $ this -> confirmable ( $ file_path ) ) ; } 
protected function write ( $ file , $ file_path ) { if ( ! is_dir ( dirname ( $ file_path ) ) ) { mkdir ( dirname ( $ file_path ) , 0755 , true ) ; } file_put_contents ( $ file_path , file_get_contents ( dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'templates' . DIRECTORY_SEPARATOR . $ file . '.txt' ) ) ; } 
public function update ( array $ attributes , $ id ) { $ defaults = [ "{$this->getRelationName()}" => [ ] ] ; $ attributes = array_merge ( $ defaults , $ attributes ) ; $ model = parent :: update ( $ attributes , $ id ) ; $ model -> { $ this -> getShortRelationName ( ) } ( ) -> sync ( $ attributes [ "{$this->getRelationName()}" ] ) ; return $ this -> parserResult ( $ model ) ; } 
public function index ( ) { $ users = $ this -> gateway -> paginate ( $ this -> config -> get ( 'entrust-gui.pagination.users' ) ) ; return view ( 'entrust-gui::users.index' , compact ( 'users' ) ) ; } 
public function create ( ) { $ user_class = $ this -> config -> get ( 'auth.model' ) ; $ user = new $ user_class ; $ roles = $ this -> role -> lists ( 'name' , 'id' ) ; return view ( 'entrust-gui::users.create' , compact ( 'user' , 'roles' ) ) ; } 
public function store ( ) { try { $ user = $ this -> gateway -> create ( $ this -> request ) ; } catch ( ValidationException $ e ) { return redirect ( route ( 'entrust-gui::users.create' ) ) -> withErrors ( $ e -> getErrors ( ) ) -> withInput ( ) ; } return redirect ( route ( 'entrust-gui::users.index' ) ) -> withSuccess ( trans ( 'entrust-gui::users.created' ) ) ; } 
public function edit ( $ id ) { $ user = $ this -> gateway -> find ( $ id ) ; $ roles = $ this -> role -> lists ( 'name' , 'id' ) ; return view ( 'entrust-gui::users.edit' , compact ( 'user' , 'roles' ) ) ; } 
public function update ( $ id ) { try { $ this -> gateway -> update ( $ this -> request , $ id ) ; } catch ( ValidationException $ e ) { return back ( ) -> withErrors ( $ e -> getErrors ( ) ) -> withInput ( ) ; } return redirect ( route ( 'entrust-gui::users.index' ) ) -> withSuccess ( trans ( 'entrust-gui::users.updated' ) ) ; } 
public function destroy ( $ id ) { if ( ! config ( 'entrust-gui.users.deletable' ) ) { abort ( 404 ) ; } $ this -> gateway -> delete ( $ id ) ; return redirect ( route ( 'entrust-gui::users.index' ) ) -> withSuccess ( trans ( 'entrust-gui::users.destroyed' ) ) ; } 
public function create ( $ request ) { $ data = $ request -> all ( ) ; $ user = $ this -> repository -> create ( $ data ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ user ) ) ; return $ user ; } 
public function update ( $ request , $ id ) { $ data = $ request -> except ( 'password' , 'password_confirmation' ) ; if ( $ request -> has ( 'password' ) ) { $ data [ 'password' ] = $ request -> get ( 'password' ) ; $ data [ 'password_confirmation' ] = $ request -> get ( 'password_confirmation' ) ; } $ user = $ this -> repository -> update ( $ data , $ id ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'UpdatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ user ) ) ; return $ user ; } 
public function delete ( $ id ) { $ model = $ this -> repository -> find ( $ id ) ; $ this -> repository -> delete ( $ id ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'DeletedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ model ) ) ; } 
public function boot ( ) { $ this -> loadViewsFrom ( realpath ( __DIR__ . '/../views' ) , 'entrust-gui' ) ; $ this -> setupRoutes ( $ this -> app -> router ) ; $ this -> loadTranslationsFrom ( realpath ( __DIR__ . '/../translations' ) , 'entrust-gui' ) ; 
public function register ( ) { $ this -> app -> register ( 'Zizaco\Entrust\EntrustServiceProvider' ) ; $ this -> app -> register ( 'Prettus\Repository\Providers\RepositoryServiceProvider' ) ; $ this -> app -> bind ( 'Acoustep\EntrustGui\Repositories\UserRepository' , 'Acoustep\EntrustGui\Repositories\UserRepositoryEloquent' ) ; $ this -> app -> bind ( 'Acoustep\EntrustGui\Repositories\RoleRepository' , 'Acoustep\EntrustGui\Repositories\RoleRepositoryEloquent' ) ; $ this -> app -> bind ( 'Acoustep\EntrustGui\Repositories\PermissionRepository' , 'Acoustep\EntrustGui\Repositories\PermissionRepositoryEloquent' ) ; $ this -> registerCommands ( ) ; } 
public function index ( ) { $ models = $ this -> gateway -> paginate ( $ this -> config -> get ( 'entrust-gui.pagination.' . $ this -> resource ) ) ; return view ( 'entrust-gui::' . $ this -> resource . '.index' , compact ( "models" ) ) ; } 
public function create ( ) { $ model_class = $ this -> config -> get ( 'entrust.' . str_singular ( $ this -> resource ) ) ; $ model = new $ model_class ; $ relations = $ this -> relation -> lists ( 'name' , 'id' ) ; return view ( 'entrust-gui::' . $ this -> resource . '.create' , compact ( 'model' , 'relations' ) ) ; } 
public function store ( ) { try { $ this -> gateway -> create ( $ this -> request ) ; } catch ( ValidationException $ e ) { return back ( ) -> withErrors ( $ e -> getErrors ( ) ) -> withInput ( ) ; } return redirect ( route ( 'entrust-gui::' . $ this -> resource . '.index' ) ) -> withSuccess ( trans ( 'entrust-gui::' . $ this -> resource . '.created' ) ) ; } 
public function edit ( $ id ) { $ model = $ this -> gateway -> find ( $ id ) ; $ relations = $ this -> relation -> lists ( 'name' , 'id' ) ; return view ( 'entrust-gui::' . $ this -> resource . '.edit' , compact ( 'model' , 'relations' ) ) ; } 
public function destroy ( $ id ) { $ this -> gateway -> delete ( $ id ) ; return redirect ( route ( 'entrust-gui::' . $ this -> resource . '.index' ) ) -> withSuccess ( trans ( 'entrust-gui::' . $ this -> resource . '.destroyed' ) ) ; } 
public function handle ( $ request , Closure $ next ) { if ( $ this -> auth -> guest ( ) ) { if ( $ request -> ajax ( ) ) { return $ this -> response -> make ( 'Unauthorized.' , 401 ) ; } else { return $ this -> redirect -> guest ( $ this -> config -> get ( 'entrust-gui.unauthorized-url' , 'auth/login' ) ) ; } } elseif ( ! $ request -> user ( ) -> hasRole ( $ this -> config -> get ( 'entrust-gui.middleware-role' ) ) ) { return $ this -> response -> make ( 'Unauthorized.' , 401 ) ; 
public function create ( array $ attributes ) { $ defaults = [ 'roles' => [ ] ] ; $ attributes = array_merge ( $ defaults , $ attributes ) ; $ model = parent :: create ( $ attributes ) ; if ( ! in_array ( 'Esensi\Model\Contracts\HashingModelInterface' , class_implements ( $ model ) ) ) { throw new Exception ( "User model must implement Esensi\Model\Contracts\HashingModelInterface. Revert to 0.3.* or see upgrade guide for details." ) ; } $ model -> roles ( ) -> sync ( $ attributes [ 'roles' ] ) ; return $ this -> parserResult ( $ model ) ; } 
public function update ( array $ attributes , $ id ) { $ defaults = [ 'roles' => [ ] ] ; $ attributes = array_merge ( $ defaults , $ attributes ) ; $ model = $ this -> find ( $ id ) ; if ( ! in_array ( 'Esensi\Model\Contracts\HashingModelInterface' , class_implements ( $ model ) ) ) { throw new Exception ( "User model must implement Esensi\Model\Contracts\HashingModelInterface. Revert to 0.3.* or see upgrade guide for details." ) ; } if ( ! array_key_exists ( 'password' , $ attributes ) ) { $ model -> fill ( $ attributes ) ; if ( Config :: get ( 'entrust-gui.confirmable' ) === true ) { $ model -> password_confirmation = $ model -> password ; } $ model -> saveWithoutHashing ( ) ; } else { $ model = parent :: update ( $ attributes , $ id ) ; } $ model -> roles ( ) -> sync ( $ attributes [ 'roles' ] ) ; return $ this -> parserResult ( $ model ) ; } 
public function create ( $ request ) { $ model = $ this -> repository -> create ( $ request -> all ( ) ) ; $ model -> { $ this -> getShortRelationName ( ) } ( ) -> sync ( $ request -> get ( $ this -> getRelationName ( ) , [ ] ) ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ model ) ) ; return $ model ; } 
public function update ( $ request , $ id ) { $ model = $ this -> repository -> update ( $ request -> all ( ) , $ id ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'UpdatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ model ) ) ; return $ model ; } 
protected function registerRepository ( ) { $ this -> app -> singleton ( CachingRepository :: class , function ( Container $ app ) { $ repo = new GitHubRepository ( GuzzleFactory :: make ( ) , $ app -> config -> get ( 'emoji.token' ) ) ; $ cache = $ app -> cache -> store ( $ app -> config -> get ( 'emoji.connection' ) ) ; $ key = $ app -> config -> get ( 'emoji.key' , 'emoji' ) ; $ life = ( int ) $ app -> config -> get ( 'emoji.life' , 10080 ) ; return new CachingRepository ( $ repo , $ cache , $ key , $ life ) ; } ) ; $ this -> app -> alias ( CachingRepository :: class , RepositoryInterface :: class ) ; } 
protected function registerParser ( ) { $ this -> app -> singleton ( EmojiParser :: class , function ( Container $ app ) { return new EmojiParser ( $ app -> make ( RepositoryInterface :: class ) ) ; } ) ; } 
public function parse ( InlineParserContext $ inlineContext ) { $ cursor = $ inlineContext -> getCursor ( ) ; $ previous = $ cursor -> peek ( - 1 ) ; if ( $ previous !== null && $ previous !== ' ' ) { return false ; } $ saved = $ cursor -> saveState ( ) ; $ cursor -> advance ( ) ; $ handle = $ cursor -> match ( '/^[a-z0-9\+\-_]+:/' ) ; if ( ! $ handle ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ next = $ cursor -> peek ( 0 ) ; if ( $ next !== null && $ next !== ' ' ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ key = substr ( $ handle , 0 , - 1 ) ; if ( $ this -> map === null ) { $ this -> map = $ this -> repo -> get ( ) ; } if ( ! array_key_exists ( $ key , $ this -> map ) ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ inline = new Image ( $ this -> map [ $ key ] , $ key ) ; $ inline -> data [ 'attributes' ] = [ 'class' => 'emoji' , 'data-emoji' => $ key ] ; $ inlineContext -> getContainer ( ) -> appendChild ( $ inline ) ; return true ; } 
public function get ( ) { try { $ headers = [ 'Accept' => self :: ACCEPT_HEADER ] ; if ( $ this -> token ) { $ headers [ 'Authorization' ] = "token {$this->token}" ; } $ response = $ this -> client -> request ( 'get' , self :: API_URL , [ 'headers' => $ headers ] ) ; return ( array ) json_decode ( ( string ) $ response -> getBody ( ) , true ) ; } catch ( Exception $ e ) { throw new FetchException ( $ e ) ; } } 
public function get ( ) { try { return $ this -> cache -> remember ( $ this -> key , $ this -> life , function ( ) { return $ this -> repo -> get ( ) ; } ) ; } catch ( FetchException $ e ) { throw $ e ; } catch ( Exception $ e ) { throw new FetchException ( $ e ) ; } } 
protected static function boot ( ) { parent :: boot ( ) ; if ( ! isset ( static :: $ attributeMutator ) ) { if ( function_exists ( 'app' ) && app ( ) -> bound ( 'eloquence.mutator' ) ) { static :: $ attributeMutator = app ( 'eloquence.mutator' ) ; } else { static :: $ attributeMutator = new Mutator ; } } } 
protected function set ( $ key , $ value , $ group = 'default' ) { $ this -> setMetaKey ( $ key ) ; $ this -> setValue ( $ value ) ; $ this -> setMetaGroup ( $ group ) ; } 
public function getValue ( ) { if ( $ this -> hasMutator ( $ this -> attributes [ 'meta_value' ] , 'getter' , $ this -> attributes [ 'meta_type' ] ) ) { return $ this -> mutateValue ( $ this -> attributes [ 'meta_value' ] , 'getter' ) ; } return $ this -> castValue ( ) ; } 
protected function castValue ( ) { $ value = $ this -> attributes [ 'meta_value' ] ; $ validTypes = [ 'boolean' , 'integer' , 'float' , 'double' , 'array' , 'object' , 'null' ] ; if ( in_array ( $ this -> attributes [ 'meta_type' ] , $ validTypes ) ) { settype ( $ value , $ this -> attributes [ 'meta_type' ] ) ; } return $ value ; } 
public function setMetaGroup ( $ group = null ) { if ( ! preg_match ( '/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/' , $ group ) && $ group !== null ) { throw new InvalidArgumentException ( "Provided group [{$group}] is not valid variable name." ) ; } $ this -> attributes [ 'meta_group' ] = $ group ; } 
protected function setType ( $ value ) { $ this -> attributes [ 'meta_type' ] = $ this -> hasMutator ( $ value , 'setter' ) ? $ this -> getMutatedType ( $ value , 'setter' ) : $ this -> getValueType ( $ value ) ; } 
public function setValue ( $ value ) { $ this -> setType ( $ value ) ; if ( $ this -> hasMutator ( $ value , 'setter' ) ) { $ value = $ this -> mutateValue ( $ value , 'setter' ) ; } elseif ( ! $ this -> isStringable ( $ value ) && ! is_null ( $ value ) ) { throw new InvalidTypeException ( "Unsupported meta value type [{$this->getValueType($value)}]." ) ; } $ this -> attributes [ 'meta_value' ] = $ value ; } 
protected function mutateValue ( $ value , $ dir = 'setter' ) { $ mutator = $ this -> getMutator ( $ value , $ dir , $ this -> attributes [ 'meta_type' ] ) ; if ( method_exists ( $ this , $ mutator ) ) { return $ this -> { $ mutator } ( $ value ) ; } return static :: $ attributeMutator -> mutate ( $ value , $ mutator ) ; } 
protected function getValueType ( $ value ) { $ type = is_object ( $ value ) ? get_class ( $ value ) : gettype ( $ value ) ; 
protected function getMutatedType ( $ value , $ dir = 'setter' ) { foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ this -> getValueType ( $ value ) == $ mutated || $ value instanceof $ mutated ) { return $ mutated ; } } } 
protected function hasMutator ( $ value , $ dir = 'setter' , $ type = null ) { return ( bool ) $ this -> getMutator ( $ value , $ dir , $ type ) ; } 
protected function getMutator ( $ value , $ dir = 'setter' , $ type = null ) { $ type = $ type ? : $ this -> getValueType ( $ value ) ; foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ type == $ mutated || $ value instanceof $ mutated ) { return $ mutator ; } } } 
public function castToString ( ) { if ( $ this -> attributes [ 'meta_type' ] == 'array' ) { return $ this -> attributes [ 'meta_value' ] ; } $ value = $ this -> getValue ( ) ; if ( $ this -> isStringable ( $ value ) || is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } return '' ; } 
public function getAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( is_null ( $ value ) ) { $ value = $ this -> getMeta ( $ key ) ; } return $ next ( $ value , $ args ) ; } ; } 
public function setAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ this -> hasColumn ( $ key ) && $ this -> allowsMeta ( $ key ) && ! $ this -> hasSetMutator ( $ key ) ) { return $ this -> setMeta ( $ key , $ value ) ; } return $ next ( $ value , $ args ) ; } ; } 
public function toArray ( ) { return function ( $ next , $ attributes ) { unset ( $ attributes [ 'meta_attributes' ] , $ attributes [ 'metaAttributes' ] ) ; $ attributes = array_merge ( $ attributes , $ this -> getMetaAttributesArray ( ) ) ; return $ next ( $ attributes ) ; } ; } 
public function replicate ( ) { return function ( $ next , $ copy , $ args ) { $ metaAttributes = $ args -> get ( 'original' ) -> getMetaAttributes ( ) -> replicate ( $ args -> get ( 'except' ) ) ; $ copy -> setRelation ( 'metaAttributes' , $ metaAttributes ) ; return $ next ( $ copy , $ args ) ; } ; } 
public function __issetHook ( ) { return function ( $ next , $ isset , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ isset ) { $ isset = ( bool ) $ this -> hasMeta ( $ key ) ; } return $ next ( $ isset , $ args ) ; } ; } 
public function __unsetHook ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( $ this -> hasMeta ( $ key ) ) { return $ this -> setMeta ( $ key , null ) ; } return $ next ( $ value , $ args ) ; } ; } 
public function queryHook ( ) { return function ( $ next , $ query , $ bag ) { $ method = $ bag -> get ( 'method' ) ; $ args = $ bag -> get ( 'args' ) ; $ column = $ args -> get ( 'column' ) ; if ( ! $ this -> hasColumn ( $ column ) && $ this -> allowsMeta ( $ column ) && $ this -> isMetaQueryable ( $ method ) ) { return call_user_func_array ( [ $ this , 'metaQuery' ] , [ $ query , $ method , $ args ] ) ; } if ( in_array ( $ method , [ 'select' , 'addSelect' ] ) ) { call_user_func_array ( [ $ this , 'metaSelect' ] , [ $ query , $ args ] ) ; } return $ next ( $ query , $ bag ) ; } ; } 
public function set ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { return $ this -> setInstance ( $ key ) ; } if ( $ this -> has ( $ key ) ) { $ this -> update ( $ key , $ value , $ group ) ; } else { $ this -> items [ $ key ] = $ this -> newAttribute ( $ key , $ value , $ group ) ; } return $ this ; } 
protected function setInstance ( Attribute $ attribute ) { if ( $ this -> has ( $ attribute -> getMetaKey ( ) ) ) { $ this -> update ( $ attribute ) ; } else { $ this -> items [ $ attribute -> getMetaKey ( ) ] = $ attribute ; } return $ this ; } 
protected function update ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { $ value = $ key -> getValue ( ) ; $ group = $ key -> getMetaGroup ( ) ; $ key = $ key -> getMetaKey ( ) ; } $ this -> get ( $ key ) -> setValue ( $ value ) ; $ this -> get ( $ key ) -> setMetaGroup ( $ group ) ; return $ this ; } 
public function forget ( $ key ) { if ( $ attribute = $ this -> get ( $ key ) ) { $ attribute -> setValue ( null ) ; } return $ this ; } 
public function replicate ( $ except = null ) { $ except = $ except ? array_combine ( $ except , $ except ) : [ ] ; $ attributes = [ ] ; foreach ( array_diff_key ( $ this -> items , $ except ) as $ attribute ) { $ attributes [ ] = $ attribute -> replicate ( ) ; } return new static ( $ attributes ) ; } 
protected function metaQuery ( Builder $ query , $ method , ArgumentBag $ args ) { if ( in_array ( $ method , [ 'pluck' , 'value' , 'aggregate' , 'orderBy' , 'lists' ] ) ) { return $ this -> metaJoinQuery ( $ query , $ method , $ args ) ; } return $ this -> metaHasQuery ( $ query , $ method , $ args ) ; } 
protected function metaSelect ( Builder $ query , ArgumentBag $ args ) { $ columns = $ args -> get ( 'columns' ) ; foreach ( $ columns as $ key => $ column ) { list ( $ column , $ alias ) = $ this -> extractColumnAlias ( $ column ) ; if ( $ this -> hasColumn ( $ column ) ) { $ select = "{$this->getTable()}.{$column}" ; if ( $ column !== $ alias ) { $ select .= " as {$alias}" ; } $ columns [ $ key ] = $ select ; } elseif ( is_string ( $ column ) && $ column != '*' && strpos ( $ column , '.' ) === false ) { $ table = $ this -> joinMeta ( $ query , $ column ) ; $ columns [ $ key ] = "{$table}.meta_value as {$alias}" ; } } $ args -> set ( 'columns' , $ columns ) ; } 
protected function metaJoinQuery ( Builder $ query , $ method , ArgumentBag $ args ) { $ alias = $ this -> joinMeta ( $ query , $ args -> get ( 'column' ) ) ; 
protected function orderByMeta ( Builder $ query , $ args , $ alias ) { $ query -> with ( 'metaAttributes' ) -> getQuery ( ) -> orderBy ( "{$alias}.meta_value" , $ args -> get ( 'direction' ) ) ; return $ query ; } 
protected function pluckMeta ( Builder $ query , ArgumentBag $ args , $ alias ) { list ( $ column , $ key ) = [ $ args -> get ( 'column' ) , $ args -> get ( 'key' ) ] ; $ query -> select ( "{$alias}.meta_value as {$column}" ) ; if ( ! is_null ( $ key ) ) { $ this -> metaSelectListsKey ( $ query , $ key ) ; } return $ query -> callParent ( 'pluck' , $ args -> all ( ) ) ; } 
protected function metaSelectListsKey ( Builder $ query , $ key ) { if ( strpos ( $ key , '.' ) !== false ) { return $ query -> addSelect ( $ key ) ; } elseif ( $ this -> hasColumn ( $ key ) ) { return $ query -> addSelect ( $ this -> getTable ( ) . '.' . $ key ) ; } $ alias = $ this -> joinMeta ( $ query , $ key ) ; return $ query -> addSelect ( "{$alias}.meta_value as {$key}" ) ; } 
protected function joinMeta ( Builder $ query , $ column ) { $ query -> prefixColumnsForJoin ( ) ; $ alias = $ this -> generateMetaAlias ( ) ; $ table = ( new Attribute ) -> getTable ( ) ; $ query -> leftJoin ( "{$table} as {$alias}" , function ( $ join ) use ( $ alias , $ column ) { $ join -> on ( "{$alias}.metable_id" , '=' , $ this -> getQualifiedKeyName ( ) ) -> where ( "{$alias}.metable_type" , '=' , $ this -> getMorphClass ( ) ) -> where ( "{$alias}.meta_key" , '=' , $ column ) ; } ) ; return $ alias ; } 
protected function metaHasQuery ( Builder $ query , $ method , ArgumentBag $ args ) { $ boolean = $ this -> getMetaBoolean ( $ args ) ; $ operator = $ this -> getMetaOperator ( $ method , $ args ) ; if ( in_array ( $ method , [ 'whereBetween' , 'where' ] ) ) { $ this -> unbindNumerics ( $ args ) ; } return $ query -> has ( 'metaAttributes' , $ operator , 1 , $ boolean , $ this -> getMetaWhereConstraint ( $ method , $ args ) ) -> with ( 'metaAttributes' ) ; } 
protected function getMetaOperator ( $ method , ArgumentBag $ args ) { if ( $ not = $ args -> get ( 'not' ) ) { $ args -> set ( 'not' , false ) ; } return ( $ not ^ $ this -> isWhereNull ( $ method , $ args ) ) ? '<' : '>=' ; } 
protected function unbindNumerics ( ArgumentBag $ args ) { if ( ( $ value = $ args -> get ( 'value' ) ) && ( is_int ( $ value ) || is_float ( $ value ) ) ) { $ args -> set ( 'value' , $ this -> raw ( $ value ) ) ; } elseif ( $ values = $ args -> get ( 'values' ) ) { foreach ( $ values as $ key => $ value ) { if ( is_int ( $ value ) || is_float ( $ value ) ) { $ values [ $ key ] = $ this -> raw ( $ value ) ; } } $ args -> set ( 'values' , $ values ) ; } } 
protected function getMetaWhereConstraint ( $ method , ArgumentBag $ args ) { $ column = $ args -> get ( 'column' ) ; $ args -> set ( 'column' , 'meta_value' ) ; if ( $ method === 'whereBetween' ) { return $ this -> getMetaBetweenConstraint ( $ column , $ args -> get ( 'values' ) ) ; } return function ( $ query ) use ( $ column , $ method , $ args ) { $ query -> where ( 'meta_key' , $ column ) ; if ( $ args -> get ( 'value' ) || $ args -> get ( 'values' ) ) { call_user_func_array ( [ $ query , $ method ] , $ args -> all ( ) ) ; } } ; } 
protected function getMetaBetweenConstraint ( $ column , array $ values ) { $ min = $ values [ 0 ] ; $ max = $ values [ 1 ] ; return function ( $ query ) use ( $ column , $ min , $ max ) { $ query -> where ( 'meta_key' , $ column ) -> where ( 'meta_value' , '>=' , $ min ) -> where ( 'meta_value' , '<=' , $ max ) ; } ; } 
protected function saveMeta ( ) { foreach ( $ this -> getMetaAttributes ( ) as $ attribute ) { if ( is_null ( $ attribute -> getValue ( ) ) ) { $ attribute -> delete ( ) ; } else { $ this -> metaAttributes ( ) -> save ( $ attribute ) ; } } } 
public function allowsMeta ( $ key ) { $ allowed = $ this -> getAllowedMeta ( ) ; return empty ( $ allowed ) || in_array ( $ key , $ allowed ) ; } 
public function setMeta ( $ key , $ value , $ group = null ) { $ this -> getMetaAttributes ( ) -> set ( $ key , $ value , $ group ) ; } 
protected function loadMetaAttributes ( ) { if ( ! array_key_exists ( 'metaAttributes' , $ this -> relations ) ) { $ this -> reloadMetaAttributes ( ) ; } $ attributes = $ this -> getRelation ( 'metaAttributes' ) ; if ( ! $ attributes instanceof AttributeBag ) { $ this -> setRelation ( 'metaAttributes' , ( new Attribute ) -> newBag ( $ attributes -> all ( ) ) ) ; } } 
public static function setFakeMacAddress ( $ interface , $ mac = null ) { 
public static function getCurrentMacAddress ( $ interface ) { $ ifconfig = self :: runCommand ( "ifconfig {$interface}" ) ; preg_match ( "/" . self :: $ valid_mac . "/i" , $ ifconfig , $ ifconfig ) ; if ( isset ( $ ifconfig [ 0 ] ) ) { return trim ( strtoupper ( $ ifconfig [ 0 ] ) ) ; } return false ; } 
public function getSettingsResponse ( ) { $ url = \ craft \ helpers \ UrlHelper :: cpUrl ( 'settings/sitemap' ) ; return \ Craft :: $ app -> controller -> redirect ( $ url ) ; } 
public function registerCpUrlRules ( RegisterUrlRulesEvent $ event ) { 
public function init ( ) { parent :: init ( ) ; self :: $ plugin = $ this ; * Logging in Craft involves using one of the following methods: * * Craft::trace(): record a message to trace how a piece of code runs. This is mainly for development use. * Craft::info(): record a message that conveys some useful information. * Craft::warning(): record a warning message that indicates something unexpected has happened. * Craft::error(): record a fatal error that should be investigated as soon as possible. * * Unless `devMode` is on, only Craft::warning() & Craft::error() will log to `craft/storage/logs/web.log` * * It's recommended that you pass in the magic constant `__METHOD__` as the second parameter, which sets * the category to the method (prefixed with the fully qualified class name) where the constant appears. * * To enable the Yii debug toolbar, go to your user account in the AdminCP and check the * [] Show the debug toolbar on the front end & [] Show the debug toolbar on the Control Panel * * http://www.yiiframework.com/doc-2.0/guide-runtime-logging.html */ Craft :: info ( Craft :: t ( 'sitemap' , '{name} plugin loaded' , [ 'name' => $ this -> name ] ) , __METHOD__ ) ; } 
public function actionIndex ( ) { try { 
protected function createTables ( ) { $ tablesCreated = false ; 
protected function createIndexes ( ) { 
public function actionIndex ( ) : craft \ web \ Response { $ this -> requireLogin ( ) ; $ routeParameters = Craft :: $ app -> getUrlManager ( ) -> getRouteParams ( ) ; $ source = ( isset ( $ routeParameters [ 'source' ] ) ? $ routeParameters [ 'source' ] : 'CpSection' ) ; 
public function actionSaveSitemap ( ) : craft \ web \ Response { $ this -> requirePostRequest ( ) ; $ this -> requireAdmin ( ) ; $ request = Craft :: $ app -> getRequest ( ) ; 
public function serialize ( $ data ) { if ( $ this -> serializer ) { return \ json_decode ( $ this -> serializer -> serialize ( $ data , 'json' ) , true ) ; } return $ data ; } 
public function parserHttpRequest ( HttpRequest $ httpRequest ) { $ json = \ json_decode ( $ httpRequest -> getContent ( ) , true ) ; if ( JSON_ERROR_NONE !== \ json_last_error ( ) ) { throw new Exceptions \ ParseException ( ) ; } $ createJsonRequest = function ( $ json ) use ( $ httpRequest ) { $ id = null ; $ method = null ; $ params = [ ] ; if ( \ is_array ( $ json ) ) { $ id = \ array_key_exists ( 'id' , $ json ) ? $ json [ 'id' ] : null ; $ method = \ array_key_exists ( 'method' , $ json ) ? $ json [ 'method' ] : null ; $ params = \ array_key_exists ( 'params' , $ json ) ? $ json [ 'params' ] : [ ] ; } $ request = new JsonRequest ( $ method , $ params , $ id ) ; $ request -> headers ( ) -> add ( $ httpRequest -> headers -> all ( ) ) ; return $ request ; } ; 
public function handleHttpRequest ( HttpRequest $ httpRequest ) { * @param JsonResponse|JsonResponse[] $jsonResponse */ $ collect = function ( $ jsonResponse ) use ( & $ collect , $ httpRequest , $ httpResponse ) { if ( \ is_array ( $ jsonResponse ) ) { foreach ( $ jsonResponse as $ value ) { $ collect ( $ value ) ; } } else { if ( $ jsonResponse -> isError ( ) ) { $ this -> collectException ( $ httpRequest , $ httpResponse , new Exceptions \ ErrorException ( $ jsonResponse -> getErrorMessage ( ) , $ jsonResponse -> getErrorCode ( ) , $ jsonResponse -> getErrorData ( ) , $ jsonResponse -> getId ( ) ) ) ; } } } ; $ collect ( $ jsonResponses ) ; } 
public function createHttpResponseFromException ( \ Exception $ exception ) { $ httpResponse = HttpResponse :: create ( ) ; $ json = [ ] ; $ json [ 'jsonrpc' ] = '2.0' ; $ json [ 'error' ] = [ ] ; if ( $ exception instanceof Exceptions \ ErrorException ) { $ json [ 'error' ] [ 'code' ] = $ exception -> getCode ( ) ; $ json [ 'error' ] [ 'message' ] = $ exception -> getMessage ( ) ; if ( $ exception -> getData ( ) ) { $ json [ 'error' ] [ 'data' ] = $ exception -> getData ( ) ; } $ json [ 'id' ] = $ exception -> getId ( ) ; } else { $ json [ 'error' ] [ 'code' ] = - 32603 ; $ json [ 'error' ] [ 'message' ] = 'Internal error' ; $ json [ 'id' ] = null ; } $ httpResponse -> headers -> set ( 'Content-Type' , 'application/json' ) ; $ httpResponse -> setContent ( \ json_encode ( $ json ) ) ; $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; $ this -> dispatch ( Event \ HttpResponseEvent :: EVENT , new Event \ HttpResponseEvent ( $ httpResponse ) ) ; return $ httpResponse ; } 
private function collectException ( $ httpRequest , $ httpResponse , $ exception ) { if ( $ this -> profiler ) { $ collector = new ExceptionDataCollector ( ) ; $ collector -> collect ( $ httpRequest , $ httpResponse , $ exception ) ; $ this -> profiler -> add ( $ collector ) ; } } 
public function process ( ContainerBuilder $ container ) { $ taggedMethods = $ container -> findTaggedServiceIds ( MethodInterface :: class ) ; 
public function loadClassMetadata ( \ ReflectionClass $ reflectionClass ) : ? array { $ method = $ this -> reader -> getClassAnnotation ( $ reflectionClass , Mapping \ Method :: class ) ; if ( null === $ method ) { return null ; } $ meta = [ ] ; if ( empty ( $ method -> value ) ) { throw new InvalidMappingException ( \ sprintf ( '@Method annotation must have name in class "%s", @Method("method name")' , $ reflectionClass -> getName ( ) ) ) ; } $ meta [ 'method' ] = $ method -> value ; $ meta [ 'class' ] = $ reflectionClass -> getName ( ) ; $ meta [ 'file' ] = $ reflectionClass -> getFileName ( ) ; 
public function handlerAction ( Request $ request , $ version = 'default' ) { return $ this -> handlerRegistry -> get ( $ version ) -> handleHttpRequest ( $ request ) ; } 
public function isDebug ( ) { if ( null !== $ this -> container && $ this -> container -> has ( 'kernel' ) ) { return $ this -> container -> get ( 'kernel' ) -> isDebug ( ) ; } return true ; } 
public function serialize ( $ data ) { if ( ! $ this -> serializer || \ is_numeric ( $ data ) || \ is_string ( $ data ) || empty ( $ data ) || $ data instanceof \ JsonSerializable ) { return $ data ; } return $ this -> getSerializer ( ) -> serialize ( $ data ) ; } 
public function createJsonResponseFromException ( \ Exception $ exception , JsonRequest $ jsonRequest = null ) { $ jsonResponse = new JsonResponse ( ) ; if ( $ exception instanceof Exceptions \ ErrorException ) { $ jsonResponse -> setErrorCode ( 0 !== $ exception -> getCode ( ) ? $ exception -> getCode ( ) : - 32603 ) ; $ jsonResponse -> setErrorMessage ( ! empty ( $ exception -> getMessage ( ) ) ? $ exception -> getMessage ( ) : 'Internal error' ) ; $ jsonResponse -> setErrorData ( $ exception -> getData ( ) ) ; } else { $ jsonResponse -> setErrorCode ( 0 !== $ exception -> getCode ( ) ? $ exception -> getCode ( ) : - 32603 ) ; $ jsonResponse -> setErrorMessage ( ! empty ( $ exception -> getMessage ( ) ) ? $ exception -> getMessage ( ) : 'Internal error' ) ; } if ( $ jsonRequest ) { $ jsonResponse -> setId ( $ jsonRequest -> getId ( ) ) ; } return $ jsonResponse ; } 
public function handleJsonRequest ( $ jsonRequest ) { 
private function isCacheSupport ( JsonRequest $ jsonRequest ) { try { return $ jsonRequest -> getId ( ) && null !== $ this -> getMethod ( $ jsonRequest ) -> getCache ( ) && ! $ this -> isDebug ( ) && $ this -> getCache ( ) ; } catch ( \ Exception $ e ) { return false ; } } 
private function getMethod ( $ jsonRequest ) : MethodMetaData { $ method = $ jsonRequest -> getMethod ( ) ; if ( false === $ this -> mapper -> hasMethod ( $ method ) ) { throw new Exceptions \ MethodNotFoundException ( $ jsonRequest -> getMethod ( ) ) ; } return $ this -> mapper -> getMethod ( $ method ) ; } 
private function executeJsonRequest ( MethodMetaData $ methodMetaData , JsonRequest $ jsonRequest ) { $ method = clone $ this -> container -> get ( $ methodMetaData -> getMethod ( ) ) ; 
public function build ( ContainerBuilder $ container ) { parent :: build ( $ container ) ; $ container -> addCompilerPass ( new RegisterListenersPass ( 'rpc.server.event_dispatcher' , 'rpc.server.event_listener' , 'rpc.server.event_subscriber' ) ) ; 
public function load ( array $ configs , ContainerBuilder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this -> processConfiguration ( $ configuration , $ configs ) ; $ loader = new Loader \ XmlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; $ loader -> load ( 'services.xml' ) ; if ( false === isset ( $ config [ 'mapping' ] ) ) { throw new \ RuntimeException ( __CLASS__ . ': mapping can\'t be empty' ) ; } $ errorCode = empty ( $ config [ 'error_code' ] ) ? 200 : $ config [ 'error_code' ] ; /** * Cache. */ $ cacheId = empty ( $ config [ 'cache' ] ) ? 'rpc.server.cache' : $ config [ 'cache' ] ; if ( ! $ container -> hasDefinition ( $ cacheId ) ) { $ cacheDefinition = new Definition ( 'Doctrine\Common\Cache\FilesystemCache' , [ '%kernel.cache_dir%/rpc' , '' ] ) ; $ cacheDefinition -> setPublic ( true ) ; $ container -> setDefinition ( $ cacheId , $ cacheDefinition ) ; } /** * Serializer. */ $ serializerId = empty ( $ config [ 'serializer' ] ) ? 'rpc.server.serializer' : $ config [ 'serializer' ] ; if ( ! $ container -> hasDefinition ( $ serializerId ) ) { $ serializerDefinition = new Definition ( BaseSerializer :: class , [ new Reference ( 'serializer' , ContainerInterface :: NULL_ON_INVALID_REFERENCE ) ] ) ; $ serializerDefinition -> setPublic ( true ) ; $ container -> setDefinition ( $ serializerId , $ serializerDefinition ) ; } /** * Registry. */ $ registry = new Definition ( HttpHandlerRegistry :: class ) ; /** * Mapping. * * @param string $name * @param array|string $paths */ $ createMapping = function ( $ name , $ paths ) use ( $ cacheId , $ serializerId , $ container , $ errorCode , $ registry ) { $ name = empty ( $ name ) ? 'default' : $ name ; $ mapperId = 'rpc.server.mapper.' . $ name ; $ this -> prepareMethods ( $ mapperId , $ paths , $ container ) ; $ mapper = new Definition ( Mapper :: class ) ; $ mapper -> setPublic ( true ) -> addTag ( MapperInterface :: class ) ; // Tag it for access from another place // Json Handler $ jsonHandlerId = empty ( $ name ) ? 'rpc.server.json_handler' : 'rpc.server.json_handler.' . $ name ; $ jsonHandler = new Definition ( JsonHandler :: class , [ new Reference ( $ mapperId ) , new Reference ( $ serializerId ) ] ) ; $ jsonHandler -> setPublic ( true ) ; $ jsonHandler -> addMethodCall ( 'setEventDispatcher' , [ new Reference ( 'rpc.server.event_dispatcher' , ContainerInterface :: NULL_ON_INVALID_REFERENCE ) ] ) ; $ jsonHandler -> addMethodCall ( 'setCache' , [ new Reference ( $ cacheId , ContainerInterface :: NULL_ON_INVALID_REFERENCE ) ] ) ; $ jsonHandler -> addMethodCall ( 'setContainer' , [ new Reference ( 'service_container' ) ] ) ; // Http handler $ httpHandlerId = empty ( $ name ) ? 'rpc.server.http_handler' : 'rpc.server.http_handler.' . $ name ; $ httpHandler = new Definition ( HttpHandler :: class , [ new Reference ( $ jsonHandlerId ) , $ errorCode ] ) ; $ httpHandler -> setPublic ( true ) ; $ httpHandler -> addMethodCall ( 'setEventDispatcher' , [ new Reference ( 'rpc.server.event_dispatcher' , ContainerInterface :: NULL_ON_INVALID_REFERENCE ) ] ) ; $ httpHandler -> addMethodCall ( 'setProfiler' , [ new Reference ( 'profiler' , ContainerInterface :: NULL_ON_INVALID_REFERENCE ) ] ) ; // Set definitions $ container -> setDefinition ( $ mapperId , $ mapper ) ; $ container -> setDefinition ( $ jsonHandlerId , $ jsonHandler ) ; $ container -> setDefinition ( $ httpHandlerId , $ httpHandler ) ; // Add http handler to registry $ registry -> addMethodCall ( 'add' , [ $ name , new Reference ( $ httpHandlerId ) ] ) ; } ; $ mapping = $ config [ 'mapping' ] ; foreach ( ( array ) $ mapping as $ key => $ value ) { if ( \ is_numeric ( $ key ) ) { $ createMapping ( null , $ value ) ; } elseif ( \ is_string ( $ key ) && ! empty ( $ value ) ) { $ createMapping ( $ key , ( array ) $ value ) ; } } $ container -> setDefinition ( HttpHandlerRegistry :: class , $ registry ) ; } 
public function get ( $ name ) { if ( ! isset ( $ this -> httpHandlers [ $ name ] ) ) { throw new \ Exception ( "HttpHandler {$name} not found" ) ; } return $ this -> httpHandlers [ $ name ] ; } 
protected function getMethodPath ( $ name ) { $ methodDir = $ this -> getContainer ( ) -> getParameter ( 'kernel.root_dir' ) . '/Method' ; return $ methodDir . '/' . $ this -> classify ( $ name ) . '.php' ; } 
protected function renderFile ( $ template , $ target , $ parameters ) { if ( ! \ is_dir ( \ dirname ( $ target ) ) ) { \ mkdir ( \ dirname ( $ target ) , 0777 , true ) ; } return \ file_put_contents ( $ target , $ this -> render ( $ template , $ parameters ) ) ; } 
protected function getTableNames ( ) { $ schemas = DB :: getConfig ( 'used_schemas' ) ? : [ DB :: getConfig ( 'schema' ) ] ; $ schemaCount = count ( $ schemas ) ; $ binds = implode ( ',' , array_fill ( 0 , $ schemaCount , '?' ) ) ; return collect ( DB :: select ( "SELECT schemaname || '.' || tablename AS table FROM pg_catalog.pg_tables WHERE schemaname IN (" . $ binds . ')' , $ schemas ) ) -> pluck ( 'table' ) -> reject ( function ( $ value , $ key ) { $ tableName = explode ( '.' , $ value ) [ 1 ] ; return $ tableName === 'spatial_ref_sys' ; } ) ; } 
public function handle ( ) { $ database = $ this -> input -> getOption ( 'database' ) ; $ path = $ this -> input -> getOption ( 'path' ) ; if ( ! $ this -> confirmToProceed ( ) ) { return ; } $ this -> info ( 'Dropping all tables...' ) ; event ( new DroppingTables ( ) ) ; if ( $ database !== null ) { DB :: setDefaultConnection ( $ database ) ; } $ this -> getTableDropper ( ) -> dropAllTables ( ) ; event ( new DroppedTables ( ) ) ; $ this -> info ( 'Running migrations...' ) ; $ this -> call ( 'migrate' , [ '--database' => $ database , '--path' => $ path , '--force' => true , ] ) ; if ( $ this -> option ( 'seed' ) ) { $ this -> info ( 'Running seeders...' ) ; $ this -> call ( 'db:seed' , [ '--force' => true ] ) ; } $ this -> comment ( 'All done!' ) ; } 
public function getResourceOwnerDetailsUrl ( AccessToken $ token ) { $ uri = new Uri ( $ this -> urlResourceOwnerDetails ) ; return ( string ) Uri :: withQueryValue ( $ uri , 'access_token' , ( string ) $ token ) ; } 
public function register ( ) { $ configPath = __DIR__ . '/../config/omnipay.php' ; $ this -> publishes ( [ $ configPath => config_path ( 'omnipay.php' ) ] ) ; $ this -> app -> singleton ( 'omnipay' , function ( $ app ) { $ defaults = $ app [ 'config' ] -> get ( 'omnipay.defaults' , array ( ) ) ; return new GatewayManager ( $ app , new GatewayFactory , $ defaults ) ; } ) ; } 
public function getWeather ( $ postal_code , $ country_code = NULL ) { try { $ url = "https://home.nest.com/api/0.1/weather/forecast/$postal_code" ; if ( ! empty ( $ country_code ) ) { $ url .= ",$country_code" ; } $ weather = $ this -> doGET ( $ url ) ; } catch ( RuntimeException $ ex ) { 
public function getUserLocations ( ) { $ this -> prepareForGet ( ) ; $ structures = ( array ) $ this -> last_status -> structure ; $ user_structures = array ( ) ; $ class_name = get_class ( $ this ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ structures as $ struct_id => $ structure ) { 
public function getDeviceSchedule ( $ serial_number = NULL ) { $ this -> prepareForGet ( ) ; $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ schedule_days = $ this -> last_status -> schedule -> { $ serial_number } -> days ; $ schedule = array ( ) ; foreach ( ( array ) $ schedule_days as $ day => $ scheduled_events ) { $ events = array ( ) ; foreach ( $ scheduled_events as $ scheduled_event ) { if ( $ scheduled_event -> entry_type == 'setpoint' ) { $ events [ ( int ) $ scheduled_event -> time ] = ( object ) array ( 'time' => $ scheduled_event -> time / 60 , 
public function getNextScheduledEvent ( $ serial_number = NULL ) { $ schedule = $ this -> getDeviceSchedule ( $ serial_number ) ; $ next_event = FALSE ; $ time = date ( 'H' ) * 60 + date ( 'i' ) ; for ( $ i = 0 , $ day = date ( 'D' ) ; $ i ++ < 7 ; $ day = date ( 'D' , strtotime ( "+ $i days" ) ) ) { if ( isset ( $ schedule [ $ day ] ) ) { foreach ( $ schedule [ $ day ] as $ event ) { if ( $ event -> time > $ time ) { return $ event ; } } } $ time = 0 ; } return $ next_event ; } 
public function getDeviceInfo ( $ serial_number = NULL ) { $ this -> prepareForGet ( ) ; $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ topaz as $ protect ) { if ( $ serial_number == $ protect -> serial_number ) { 
public function setTargetTemperatureMode ( $ mode , $ temperature = NULL , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; if ( $ temperature !== NULL ) { if ( $ mode == TARGET_TEMP_MODE_RANGE ) { if ( ! is_array ( $ temperature ) || count ( $ temperature ) != 2 || ! is_numeric ( $ temperature [ 0 ] ) || ! is_numeric ( $ temperature [ 1 ] ) ) { echo "Error: when using TARGET_TEMP_MODE_RANGE, you need to set the target temperatures (second argument of setTargetTemperatureMode) using an array of two numeric values.\n" ; return FALSE ; } $ temp_low = $ this -> temperatureInCelsius ( $ temperature [ 0 ] , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temperature [ 1 ] , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } elseif ( $ mode != TARGET_TEMP_MODE_OFF ) { 
public function setTargetTemperature ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } 
public function setTargetTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } 
public function setEcoMode ( $ mode , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = array ( ) ; $ data [ 'mode' ] = $ mode ; $ data [ 'touched_by' ] = 4 ; $ data [ 'mode_update_timestamp' ] = time ( ) ; $ data = json_encode ( array ( 'eco' => $ data ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; } 
public function setAwayTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { return $ this -> setEcoTemperatures ( $ temp_low , $ temp_high , $ serial_number ) ; } 
public function setEcoTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = array ( ) ; if ( $ temp_low === FALSE ) { $ data [ 'away_temperature_low_enabled' ] = FALSE ; } elseif ( $ temp_low != NULL ) { $ data [ 'away_temperature_low_enabled' ] = TRUE ; $ data [ 'away_temperature_low' ] = $ temp_low ; } if ( $ temp_high === FALSE ) { $ data [ 'away_temperature_high_enabled' ] = FALSE ; } elseif ( $ temp_high != NULL ) { $ data [ 'away_temperature_high_enabled' ] = TRUE ; $ data [ 'away_temperature_high' ] = $ temp_high ; } $ data = json_encode ( $ data ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; } 
public function setFanMode ( $ mode , $ serial_number = NULL ) { $ duty_cycle = NULL ; $ timer = NULL ; if ( is_array ( $ mode ) ) { $ modes = $ mode ; $ mode = $ modes [ 0 ] ; if ( count ( $ modes ) > 1 ) { if ( $ mode == FAN_MODE_MINUTES_PER_HOUR ) { $ duty_cycle = ( int ) $ modes [ 1 ] ; } else { $ timer = ( int ) $ modes [ 1 ] ; } } else { throw new Exception ( "setFanMode(array \$mode[, ...]) needs at least a mode and a value in the \$mode array." ) ; } } elseif ( ! is_string ( $ mode ) ) { throw new Exception ( "setFanMode() can only take a string or an array as it's first parameter." ) ; } return $ this -> _setFanMode ( $ mode , $ duty_cycle , $ timer , $ serial_number ) ; } 
public function setFanModeMinutesPerHour ( $ mode , $ serial_number = NULL ) { $ modes = explode ( ',' , $ mode ) ; $ mode = $ modes [ 0 ] ; $ duty_cycle = $ modes [ 1 ] ; return $ this -> _setFanMode ( $ mode , $ duty_cycle , NULL , $ serial_number ) ; } 
public function setFanModeOnWithTimer ( $ mode , $ serial_number = NULL ) { $ modes = explode ( ',' , $ mode ) ; $ mode = $ modes [ 0 ] ; $ timer = ( int ) $ modes [ 1 ] ; return $ this -> _setFanMode ( $ mode , NULL , $ timer , $ serial_number ) ; } 
public function cancelFanModeOnWithTimer ( $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'fan_timer_timeout' => 0 ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; } 
public function setFanEveryDaySchedule ( $ start_hour , $ end_hour , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'fan_duty_start_time' => $ start_hour * 3600 , 'fan_duty_end_time' => $ end_hour * 3600 ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; } 
public function setAway ( $ away_mode , $ serial_number = NULL , $ eco_when_away = TRUE ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'away' => $ away_mode , 'away_timestamp' => time ( ) , 'away_setter' => 0 ) ) ; $ structure_id = $ this -> getDeviceInfo ( $ serial_number ) -> location ; if ( $ away_mode == AWAY_MODE_ON && $ eco_when_away ) { $ this -> setEcoMode ( ECO_MODE_MANUAL , $ serial_number ) ; } else { $ this -> setEcoMode ( ECO_MODE_SCHEDULE , $ serial_number ) ; } return $ this -> doPOST ( "/v2/put/structure." . $ structure_id , $ data ) ; } 
public function useEcoTempWhenAway ( $ enabled , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'auto_away_enable' => $ enabled ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; } 
public function setDualFuelBreakpoint ( $ breakpoint , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; if ( ! is_string ( $ breakpoint ) ) { $ breakpoint = $ this -> temperatureInCelsius ( $ breakpoint , $ serial_number ) ; $ data = json_encode ( array ( 'dual_fuel_breakpoint_override' => 'none' , 'dual_fuel_breakpoint' => $ breakpoint ) ) ; } else { $ data = json_encode ( array ( 'dual_fuel_breakpoint_override' => $ breakpoint ) ) ; } return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; } 
public function enableHumidifier ( $ enabled , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'target_humidity_enabled' => ( ( boolean ) $ enabled ) ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; } 
public function setHumidity ( $ humidity , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'target_humidity' => ( ( double ) $ humidity ) ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; } 
public function temperatureInCelsius ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature - 32 ) / 1.8 ; } return $ temperature ; } 
public function temperatureInUserScale ( $ temperature_in_celsius , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature_in_celsius * 1.8 ) + 32 ; } return $ temperature_in_celsius ; } 
public function getDeviceTemperatureScale ( $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; return $ this -> last_status -> device -> { $ serial_number } -> temperature_scale ; } 
public function getDevices ( $ type = DEVICE_TYPE_THERMOSTAT ) { $ this -> prepareForGet ( ) ; if ( $ type == DEVICE_TYPE_PROTECT ) { $ protects = array ( ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ topaz as $ protect ) { $ protects [ ] = $ protect -> serial_number ; } return $ protects ; } $ devices_serials = array ( ) ; foreach ( $ this -> last_status -> user -> { $ this -> userid } -> structures as $ structure ) { list ( , $ structure_id ) = explode ( '.' , $ structure ) ; foreach ( $ this -> last_status -> structure -> { $ structure_id } -> devices as $ device ) { list ( , $ device_serial ) = explode ( '.' , $ device ) ; $ devices_serials [ ] = $ device_serial ; } } return $ devices_serials ; } 
protected function getDefaultSerial ( $ serial_number ) { if ( empty ( $ serial_number ) ) { $ devices_serials = $ this -> getDevices ( ) ; if ( count ( $ devices_serials ) == 0 ) { $ devices_serials = $ this -> getDevices ( DEVICE_TYPE_PROTECT ) ; } $ serial_number = $ devices_serials [ 0 ] ; } return $ serial_number ; } 
protected function getDeviceNetworkInfo ( $ serial_number = NULL ) { $ this -> prepareForGet ( ) ; $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ connection_info = $ this -> last_status -> track -> { $ serial_number } ; return ( object ) array ( 'online' => $ connection_info -> online , 'last_connection' => date ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'last_connection_UTC' => gmdate ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'wan_ip' => @ $ connection_info -> last_ip , 'local_ip' => $ this -> last_status -> device -> { $ serial_number } -> local_ip , 'mac_address' => $ this -> last_status -> device -> { $ serial_number } -> mac_address ) ; } 
protected function doRequest ( $ method , $ url , $ data_fields = NULL , $ with_retry = TRUE ) { $ ch = curl_init ( ) ; if ( $ url [ 0 ] == '/' ) { $ url = $ this -> transport_url . $ url ; } $ headers = array ( 'X-nl-protocol-version: ' . self :: PROTOCOL_VERSION ) ; if ( isset ( $ this -> userid ) ) { $ headers [ ] = 'X-nl-user-id: ' . $ this -> userid ; $ headers [ ] = 'Authorization: Basic ' . $ this -> access_token ; } if ( is_array ( $ data_fields ) ) { $ data = array ( ) ; foreach ( $ data_fields as $ k => $ v ) { $ data [ ] = "$k=" . urlencode ( $ v ) ; } $ data = implode ( '&' , $ data ) ; } elseif ( is_string ( $ data_fields ) ) { $ data = $ data_fields ; } curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , $ method ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_HEADER , FALSE ) ; curl_setopt ( $ ch , CURLOPT_AUTOREFERER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_USERAGENT , self :: USER_AGENT ) ; curl_setopt ( $ ch , CURLOPT_COOKIEJAR , $ this -> cookie_file ) ; curl_setopt ( $ ch , CURLOPT_COOKIEFILE , $ this -> cookie_file ) ; if ( $ method == 'POST' ) { if ( ! isset ( $ data ) ) { throw new RuntimeException ( "Error: You need to specify \$data when sending a POST." ) ; } curl_setopt ( $ ch , CURLOPT_POST , TRUE ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ data ) ; $ headers [ ] = 'Content-length: ' . strlen ( $ data ) ; } curl_setopt ( $ ch , CURLOPT_HTTPHEADER , $ headers ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , TRUE ) ; 
protected static function getCURLCerts ( ) { $ url = 'https://curl.haxx.se/ca/cacert.pem' ; $ certs = @ file_get_contents ( $ url ) ; if ( ! $ certs ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , TRUE ) ; 
protected static function secureTouch ( $ fname ) { if ( file_exists ( $ fname ) ) { return ; } $ temp = tempnam ( sys_get_temp_dir ( ) , 'NEST' ) ; rename ( $ temp , $ fname ) ; } 
public function add ( $ item ) { $ this -> validateItem ( $ item , $ this -> type ) ; $ items = $ this -> items ; $ items [ ] = $ item ; $ col = new static ( $ this -> type ) ; $ col -> setItemsFromTrustedSource ( $ items ) ; return $ col ; } 
public function find ( callable $ condition ) { $ index = $ this -> findIndex ( $ condition ) ; return $ index === - 1 ? false : $ this -> items [ $ index ] ; } 
public function findIndex ( callable $ condition ) { $ index = - 1 ; for ( $ i = 0 , $ collectionLength = count ( $ this -> items ) ; $ i < $ collectionLength ; $ i ++ ) { if ( $ condition ( $ this -> at ( $ i ) ) ) { $ index = $ i ; break ; } } return $ index ; } 
public function indexExists ( $ index ) { if ( ! is_int ( $ index ) ) { throw new InvalidArgumentException ( 'Index must be an integer' ) ; } if ( $ index < 0 ) { throw new InvalidArgumentException ( 'Index must be a non-negative integer' ) ; } return $ index < $ this -> count ( ) ; } 
public function filter ( callable $ condition ) { $ items = [ ] ; foreach ( $ this -> items as $ item ) { if ( $ condition ( $ item ) ) { $ items [ ] = $ item ; } } $ col = new static ( $ this -> type ) ; $ col -> setItemsFromTrustedSource ( $ items ) ; return $ col ; } 
public function findLast ( callable $ condition ) { $ index = $ this -> findLastIndex ( $ condition ) ; return $ index === - 1 ? false : $ this -> items [ $ index ] ; } 
public function findLastIndex ( callable $ condition ) { $ index = - 1 ; for ( $ i = count ( $ this -> items ) - 1 ; $ i >= 0 ; $ i -- ) { if ( $ condition ( $ this -> items [ $ i ] ) ) { $ index = $ i ; break ; } } return $ index ; } 
public function slice ( $ start , $ end ) { if ( $ start < 0 || ! is_int ( $ start ) ) { throw new InvalidArgumentException ( 'Start must be a non-negative integer' ) ; } if ( $ end < 0 || ! is_int ( $ end ) ) { throw new InvalidArgumentException ( 'End must be a positive integer' ) ; } if ( $ start > $ end ) { throw new InvalidArgumentException ( 'End must be greater than start' ) ; } if ( $ end > $ this -> count ( ) + 1 ) { throw new InvalidArgumentException ( 'End must be less than the count of the items in the Collection' ) ; } $ length = $ end - $ start + 1 ; $ subsetItems = array_slice ( $ this -> items , $ start , $ length ) ; $ col = new static ( $ this -> type ) ; $ col -> setItemsFromTrustedSource ( $ subsetItems ) ; return $ col ; } 
public function insert ( $ index , $ item ) { $ this -> validateIndex ( $ index ) ; $ this -> validateItem ( $ item , $ this -> type ) ; $ partA = array_slice ( $ this -> items , 0 , $ index ) ; $ partB = array_slice ( $ this -> items , $ index , count ( $ this -> items ) ) ; $ partA [ ] = $ item ; $ items = array_merge ( $ partA , $ partB ) ; $ col = new static ( $ this -> type ) ; $ col -> setItemsFromTrustedSource ( $ items ) ; return $ col ; } 
public function insertRange ( $ index , array $ items ) { $ this -> validateIndex ( $ index ) ; $ this -> validateItems ( $ items , $ this -> type ) ; 
public function without ( callable $ condition ) { $ inverse = function ( $ item ) use ( $ condition ) { return ! $ condition ( $ item ) ; } ; return $ this -> filter ( $ inverse ) ; } 
public function removeAt ( $ index ) { $ this -> validateIndex ( $ index ) ; $ items = $ this -> items ; $ partA = array_slice ( $ items , 0 , $ index ) ; $ partB = array_slice ( $ items , $ index + 1 , count ( $ items ) ) ; $ items = array_merge ( $ partA , $ partB ) ; $ col = new static ( $ this -> type ) ; $ col -> setItemsFromTrustedSource ( $ items ) ; return $ col ; } 
public function reverse ( ) { $ items = array_reverse ( $ this -> items ) ; $ col = new static ( $ this -> type ) ; $ col -> setItemsFromTrustedSource ( $ items ) ; return $ col ; } 
public function sort ( callable $ callback ) { $ items = $ this -> items ; usort ( $ items , $ callback ) ; $ col = new static ( $ this -> type ) ; $ col -> setItemsFromTrustedSource ( $ items ) ; return $ col ; } 
public function every ( callable $ condition ) { $ response = true ; foreach ( $ this -> items as $ item ) { $ result = $ condition ( $ item ) ; if ( $ result === false ) { $ response = false ; break ; } } return $ response ; } 
public function dropRight ( $ num ) { return $ num !== $ this -> count ( ) ? $ this -> slice ( 0 , $ this -> count ( ) - $ num - 1 ) : $ this -> clear ( ) ; } 
public function dropWhile ( callable $ condition ) { $ count = $ this -> countWhileTrue ( $ condition ) ; return $ count ? $ this -> drop ( $ count ) : $ this ; } 
public function take ( $ num ) { if ( $ num > $ this -> count ( ) ) { $ num = $ this -> count ( ) ; } return $ this -> slice ( 0 , $ num - 1 ) ; } 
public function takeRight ( $ num ) { if ( $ num > $ this -> count ( ) ) { $ num = $ this -> count ( ) ; } return $ this -> slice ( $ this -> count ( ) - $ num , $ this -> count ( ) ) ; } 
public function takeWhile ( callable $ condition ) { $ count = $ this -> countWhileTrue ( $ condition ) ; return $ count ? $ this -> take ( $ count ) : $ this -> clear ( ) ; } 
public function map ( callable $ callable ) { $ items = [ ] ; $ type = null ; foreach ( $ this -> items as $ item ) { $ result = $ callable ( $ item ) ; if ( null === $ type ) { $ type = gettype ( $ result ) ; if ( $ type === 'object' ) { $ type = get_class ( $ result ) ; } } $ items [ ] = $ result ; } if ( null === $ type ) { $ type = $ this -> type ; } $ col = new static ( $ type ) ; $ col -> setItemsFromTrustedSource ( $ items ) ; return $ col ; } 
public function reduceRight ( callable $ callable , $ initial = null ) { $ reverse = array_reverse ( $ this -> items ) ; return array_reduce ( $ reverse , $ callable , $ initial ) ; } 
public function shuffle ( ) { $ items = $ this -> items ; shuffle ( $ items ) ; $ col = new static ( $ this -> type ) ; $ col -> setItemsFromTrustedSource ( $ items ) ; return $ col ; } 
public function merge ( $ items ) { if ( $ items instanceof CollectionInterface ) { $ items = $ items -> toArray ( ) ; } if ( ! is_array ( $ items ) ) { throw new InvalidArgumentException ( 'Merge must be given array or Collection' ) ; } $ this -> validateItems ( $ items , $ this -> type ) ; $ newItems = array_merge ( $ this -> items , $ items ) ; $ col = new static ( $ this -> type ) ; $ col -> setItemsFromTrustedSource ( $ newItems ) ; return $ col ; } 
public function get ( $ key ) { return array_key_exists ( $ key , $ this -> storage ) ? $ this -> storage [ $ key ] : null ; } 
public function delete ( $ key ) { $ storage = $ this -> storage ; if ( array_key_exists ( $ key , $ this -> storage ) ) { unset ( $ storage [ $ key ] ) ; } return new static ( $ this -> keyType , $ this -> valType , $ storage ) ; } 
public function filter ( callable $ condition ) { $ storage = [ ] ; foreach ( $ this -> storage as $ key => $ value ) { if ( $ condition ( $ key , $ value ) ) { $ storage [ $ key ] = $ value ; } } return new static ( $ this -> keyType , $ this -> valType , $ storage ) ; } 
public function without ( callable $ condition ) { $ inverse = function ( $ k , $ v ) use ( $ condition ) { return ! $ condition ( $ k , $ v ) ; } ; return $ this -> filter ( $ inverse ) ; } 
public function add ( $ key , $ value ) { $ storage = $ this -> storage ; $ storage [ $ key ] = $ value ; return new static ( $ this -> keyType , $ this -> valType , $ storage ) ; } 
public function map ( callable $ callable ) { $ items = [ ] ; $ keyType = null ; $ valType = null ; foreach ( $ this -> storage as $ key => $ val ) { list ( $ k , $ v ) = $ callable ( $ key , $ val ) ; if ( ! isset ( $ keyType ) && ! isset ( $ valType ) ) { $ keyType = gettype ( $ k ) ; $ valType = gettype ( $ v ) ; } $ items [ $ k ] = $ v ; } if ( null === $ keyType && null === $ valType ) { $ keyType = $ this -> keyType ; $ valType = $ this -> valType ; } return new static ( $ keyType , $ valType , $ items ) ; } 
public function merge ( $ newItems ) { if ( $ newItems instanceof self ) { $ newItems = $ newItems -> toArray ( ) ; } if ( ! is_array ( $ newItems ) ) { throw new \ InvalidArgumentException ( 'Combine must be a Dictionary or an array' ) ; } $ items = array_merge ( $ this -> storage , $ newItems ) ; return new static ( $ this -> keyType , $ this -> valType , $ items ) ; } 
protected function validateItems ( array $ items , $ type ) { foreach ( $ items as $ item ) { $ this -> validateItem ( $ item , $ type ) ; } } 
private function line ( $ name ) { if ( '(request-target)' == $ name ) { return $ this -> requestTargetLine ( ) ; } else { return sprintf ( '%s: %s' , $ name , $ this -> headerValue ( $ name ) ) ; } } 
private function headerValue ( $ name ) { if ( $ this -> message -> hasHeader ( $ name ) ) { $ header = $ this -> message -> getHeader ( $ name ) ; return end ( $ header ) ; } else { throw new SignedHeaderNotPresentException ( "Header '$name' not in message" ) ; } } 
public function fetch ( $ keyId ) { if ( isset ( $ this -> keys [ $ keyId ] ) ) { return $ this -> keys [ $ keyId ] ; } else { throw new KeyStoreException ( "Key '$keyId' not found" ) ; } } 
private function signingKey ( ) { if ( isset ( $ this -> signingKeyId ) ) { return $ this -> keyStore ( ) -> fetch ( $ this -> signingKeyId ) ; } else { throw new Exception ( 'no implicit or specified signing key' ) ; } } 
private function parameter ( $ name ) { $ parameters = $ this -> parameters ( ) ; if ( ! isset ( $ parameters [ $ name ] ) ) { throw new Exception ( "Signature parameters does not contain '$name'" ) ; } return $ parameters [ $ name ] ; } 
private function parameters ( ) { if ( ! isset ( $ this -> _parameters ) ) { $ parser = new SignatureParametersParser ( $ this -> signatureHeader ( ) ) ; $ this -> _parameters = $ parser -> parse ( ) ; } return $ this -> _parameters ; } 
private function signatureHeader ( ) { if ( $ signature = $ this -> fetchHeader ( 'Signature' ) ) { return $ signature ; } elseif ( $ authorization = $ this -> fetchHeader ( 'Authorization' ) ) { return substr ( $ authorization , strlen ( 'Signature ' ) ) ; } else { throw new Exception ( 'HTTP message has no Signature or Authorization header' ) ; } } 
public function sign ( $ message ) { $ signatureParameters = $ this -> signatureParameters ( $ message ) ; $ message = $ message -> withAddedHeader ( 'Signature' , $ signatureParameters -> string ( ) ) ; $ message = $ message -> withAddedHeader ( 'Authorization' , 'Signature ' . $ signatureParameters -> string ( ) ) ; return $ message ; } 
private function addDigest ( $ message ) { if ( ! array_search ( 'digest' , $ this -> headerList -> names ) ) { $ this -> headerList -> names [ ] = 'digest' ; } $ message = $ message -> withoutHeader ( 'Digest' ) -> withHeader ( 'Digest' , 'SHA-256=' . base64_encode ( hash ( 'sha256' , $ message -> getBody ( ) , true ) ) ) ; return $ message ; } 
private function signatureParameters ( $ message ) { return new SignatureParameters ( $ this -> key , $ this -> algorithm , $ this -> headerList , $ this -> signature ( $ message ) ) ; } 
private function signature ( $ message ) { return new Signature ( $ message , $ this -> key , $ this -> algorithm , $ this -> headerList ) ; } 
private function pairsToAssociative ( $ pairs ) { $ result = [ ] ; foreach ( $ pairs as $ pair ) { $ result [ $ pair [ 0 ] ] = $ pair [ 1 ] ; } return $ result ; } 
private function pair ( $ segment ) { $ segmentPattern = '/\A(keyId|algorithm|headers|signature)="(.*)"\z/' ; $ matches = [ ] ; $ result = preg_match ( $ segmentPattern , $ segment , $ matches ) ; if ( 1 !== $ result ) { throw new SignatureParseException ( "Signature parameters segment '$segment' invalid" ) ; } array_shift ( $ matches ) ; return $ matches ; } 
private function validateAllKeysArePresent ( $ result ) { 
private function generateProperties ( array $ colSchema , string $ tplDir ) : array { $ entityConfig = [ 'tplFilename' => 'property' , 'tplDir' => $ tplDir , ] ; 
private function generateGetters ( array $ colSchema , string $ tplDir ) : string { $ getterName = sprintf ( 'get%s' , ucfirst ( $ colSchema [ 'mappingName' ] ) ) ; $ config = [ 'tplFilename' => 'getter' , 'tplDir' => $ tplDir , ] ; $ data = [ 'returnType' => $ colSchema [ 'phpType' ] , 'methodName' => sprintf ( 'get%s' , $ getterName ) , 'property' => $ colSchema [ 'mappingName' ] , ] ; $ gen = new FileGenerator ( $ config ) ; return $ gen -> render ( $ data ) ; } 
private function generateSetters ( array $ colSchema , string $ tplDir ) : string { $ setterName = sprintf ( 'set%s' , ucfirst ( $ colSchema [ 'mappingName' ] ) ) ; $ config = [ 'tplFilename' => 'setter' , 'tplDir' => $ tplDir , ] ; $ data = [ 'type' => $ colSchema [ 'phpType' ] , 'methodName' => $ setterName , 'paramName' => $ colSchema [ 'mappingVar' ] , 'property' => $ colSchema [ 'mappingName' ] , ] ; $ gen = new FileGenerator ( $ config ) ; return $ gen -> render ( $ data ) ; } 
private function transferDefaultType ( string $ type , string $ primaryKey , $ default ) { if ( ! empty ( $ primaryKey ) ) { return null ; } if ( $ default === null ) { return null ; } $ default = trim ( $ default ) ; switch ( $ type ) { case Types :: INT : case Types :: NUMBER : $ default = ( int ) $ default ; break ; case Types :: BOOL : $ default = ( bool ) $ default ; break ; case Types :: FLOAT : $ default = ( float ) $ default ; break ; default : $ default = sprintf ( '"%s"' , $ default ) ; break ; } return $ default ; } 
public function getSchemaTableData ( string $ driver , string $ db , string $ inc , string $ exc , string $ tablePrefix ) : array { $ schemaDao = $ this -> getSchemaDao ( $ driver ) ; $ schemas = $ schemaDao -> getTableSchema ( $ db , $ inc , $ exc ) ; foreach ( $ schemas as & $ schema ) { if ( empty ( $ tablePrefix ) ) { $ mapping = $ schema [ 'name' ] ; } else { $ mapping = StringHelper :: replaceFirst ( $ tablePrefix , '' , $ schema [ 'name' ] ) ; } $ schema [ 'mapping' ] = ucfirst ( StringHelper :: camel ( $ mapping ) ) ; } return $ schemas ; } 
public function getSchemaColumnsData ( string $ driver , string $ db , string $ table , string $ fieldPrefix ) : array { $ schemaDao = $ this -> getSchemaDao ( $ driver ) ; list ( $ mapingTypes , $ phpTypes ) = $ this -> getSchemaTypes ( $ driver ) ; $ columnSchemas = $ schemaDao -> getColumnsSchema ( $ db , $ table ) ; foreach ( $ columnSchemas as & $ columnSchema ) { $ type = $ columnSchema [ 'type' ] ; if ( empty ( $ fieldPrefix ) ) { $ mappingName = $ columnSchema [ 'name' ] ; } else { $ mappingName = StringHelper :: replaceFirst ( $ fieldPrefix , '' , $ columnSchema [ 'name' ] ) ; } $ columnSchema [ 'mappingName' ] = StringHelper :: camel ( $ mappingName ) ; $ columnSchema [ 'mappingVar' ] = sprintf ( '$%s' , $ columnSchema [ 'mappingName' ] ) ; $ columnSchema [ 'mappingType' ] = $ mapingTypes [ $ type ] ?? '' ; $ columnSchema [ 'phpType' ] = $ phpTypes [ $ type ] ?? '' ; } return $ columnSchemas ; } 
private function getSchemaDao ( string $ driver ) : SchemaInterface { if ( $ driver == Driver :: MYSQL ) { return \ bean ( MysqlSchemaDao :: class ) ; } throw new \ RuntimeException ( sprintf ( 'The %s driver does not support!' , $ driver ) ) ; } 
private function getSchemaTypes ( string $ driver ) : array { if ( $ driver == Driver :: MYSQL ) { return [ MysqlSchema :: $ typeMap , MysqlSchema :: $ phpMap ] ; } if ( $ driver == Driver :: PGSQL ) { return [ PgsqlSchema :: $ typeMap , PgsqlSchema :: $ phpMap ] ; } throw new \ RuntimeException ( sprintf ( 'The %s schema does not support!' , $ driver ) ) ; } 
public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ handler ) : ResponseInterface { 
public function events ( Request $ request ) : array { 
public function swoole ( ) : array { [ $ code , $ return , $ error ] = Sys :: run ( 'php --ri swoole' ) ; if ( $ code ) { return [ 'code' => 404 , 'msg' => $ error ] ; } 
public function config ( Request $ request ) { if ( $ key = $ request -> query ( 'key' ) ) { return \ config ( $ key ) ; } return \ bean ( 'config' ) -> toArray ( ) ; } 
public function pools ( Request $ request ) : array { if ( $ name = $ request -> query ( 'name' ) ) { if ( ! App :: hasPool ( $ name ) ) { return [ ] ; } $ poolConfig = App :: getPool ( $ name ) -> getPoolConfig ( ) ; return $ poolConfig -> toArray ( ) ; } return PoolCollector :: getCollector ( ) ; } 
public function events ( Request $ request ) : array { $ em = \ bean ( 'eventManager' ) ; if ( $ event = \ trim ( $ request -> query ( 'name' ) ) ) { if ( ! $ queue = $ em -> getListenerQueue ( $ event ) ) { return [ 'msg' => 'event name is invalid: ' . $ event ] ; } $ classes = [ ] ; foreach ( $ queue -> getIterator ( ) as $ listener ) { $ classes [ ] = \ get_class ( $ listener ) ; } return $ classes ; } return $ em -> getListenedEvents ( ) ; } 
public function httpMiddles ( Request $ request ) : array { $ dispatcher = \ bean ( 'serverDispatcher' ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; 
public function rpcMiddles ( Request $ request ) : array { $ beanName = 'serviceDispatcher' ; if ( ! \ Swoft :: hasBean ( $ beanName ) ) { return [ ] ; } $ dispatcher = \ bean ( $ beanName ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; 
public function getTableSchema ( string $ db , string $ inc , string $ exc ) : array { $ query = Query :: table ( 'information_schema.`tables`' ) -> where ( 'TABLE_SCHEMA' , $ db ) -> where ( 'TABLE_TYPE' , 'BASE TABLE' ) ; if ( ! empty ( $ inc ) ) { $ query = $ query -> whereIn ( 'TABLE_NAME' , explode ( ',' , $ inc ) ) ; } if ( ! empty ( $ exc ) ) { $ query = $ query -> whereNotIn ( 'TABLE_NAME' , explode ( ',' , $ exc ) ) ; } $ columns = [ 'TABLE_NAME' => 'name' , 'TABLE_COMMENT' => 'comment' , ] ; return $ query -> get ( $ columns ) -> getResult ( ) ; } 
public function getColumnsSchema ( string $ db , string $ table ) : array { $ query = Query :: table ( 'information_schema.`columns`' ) -> where ( 'TABLE_SCHEMA' , $ db ) -> where ( 'TABLE_NAME' , $ table ) ; $ columns = [ 'COLUMN_NAME' => 'name' , 'DATA_TYPE' => 'type' , 'COLUMN_DEFAULT' => 'default' , 'COLUMN_KEY' => 'key' , 'IS_NULLABLE' => 'nullable' , 'COLUMN_TYPE' => 'columnType' , 'COLUMN_COMMENT' => 'columnComment' , 'CHARACTER_MAXIMUM_LENGTH' => 'length' , ] ; return $ query -> get ( $ columns ) -> getResult ( ) ; } 
public function initApp ( ) : void { $ tmpDir = \ Swoft :: getAlias ( '@runtime' ) ; $ names = [ 'logs' , 'uploadfiles' ] ; \ output ( ) -> writeln ( 'Create runtime directories: ' . \ implode ( ',' , $ names ) ) ; foreach ( $ names as $ name ) { DirHelper :: make ( $ tmpDir . '/' . $ name ) ; } \ output ( ) -> writeln ( '<success>OK</success>' ) ; } 
public function env ( Output $ output ) : void { $ info = [ 
public function check ( Output $ output ) : void { 
public static function wrap ( $ condition , string $ msg = null , $ showOnFalse = false ) : array { $ result = $ condition ? '<success>Yes</success>' : '<red>No</red>' ; $ des = '' ; if ( $ msg ) { if ( $ showOnFalse ) { $ des = ! $ condition ? " ($msg)" : '' ; } else { $ des = " ($msg)" ; } } return [ ( bool ) $ condition , $ result . $ des ] ; } 
public function all ( bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> all ( ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; } 
public function get ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> input ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; } 
public function only ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = [ ] ; foreach ( ( array ) $ keys as $ key ) { $ values [ $ key ] = $ this -> get ( $ key , null , $ trim , $ clean ) ; } return $ values ; } 
public function except ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> except ( ( array ) $ keys ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; } 
public function map ( array $ keys , bool $ trim = true , bool $ clean = true ) { $ values = $ this -> only ( array_keys ( $ keys ) , $ trim , $ clean ) ; $ new = [ ] ; foreach ( $ keys as $ key => $ value ) { $ new [ $ value ] = array_get ( $ values , $ key ) ; } return $ new ; } 
public function old ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> old ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; } 
public function clean ( $ value , bool $ trim = true , bool $ clean = true ) { if ( is_bool ( $ value ) || is_int ( $ value ) || is_float ( $ value ) ) { return $ value ; } $ final = null ; if ( $ value !== null ) { if ( is_array ( $ value ) ) { $ all = $ value ; $ final = [ ] ; foreach ( $ all as $ key => $ value ) { if ( $ value !== null ) { $ final [ $ key ] = $ this -> clean ( $ value , $ trim , $ clean ) ; } } } else { if ( $ value !== null ) { $ final = $ this -> process ( ( string ) $ value , $ trim , $ clean ) ; } } } return $ final ; } 
protected function process ( string $ value , bool $ trim = true , bool $ clean = true ) { if ( $ trim ) { $ value = trim ( $ value ) ; } if ( $ clean ) { $ value = $ this -> security -> clean ( $ value ) ; } return $ value ; } 
protected function registerBinput ( ) { $ this -> app -> singleton ( 'binput' , function ( Container $ app ) { $ request = $ app [ 'request' ] ; $ security = $ app [ 'security' ] ; $ binput = new Binput ( $ request , $ security ) ; $ app -> refresh ( 'request' , $ binput , 'setRequest' ) ; return $ binput ; } ) ; $ this -> app -> alias ( 'binput' , Binput :: class ) ; } 
public static function init ( ) { 
private static function initStaticValues ( ) { if ( self :: $ utmCookieName === null ) { self :: $ utmCookieName = 'utm' ; } self :: $ utmCookie = [ 'utm_campaign' => null , 'utm_medium' => null , 'utm_source' => null , 'utm_term' => null , 'utm_content' => null ] ; if ( self :: $ lifetime === null ) { self :: $ lifetime = new DateInterval ( self :: DEFAULT_UTM_COOKIE_LIFETIME ) ; } if ( self :: $ overwrite === null ) { self :: $ overwrite = true ; } } 
public static function get ( ? string $ key = null ) { self :: init ( ) ; if ( $ key === null ) { return self :: $ utmCookie ; } else { if ( mb_strpos ( $ key , 'utm_' ) !== 0 ) { $ key = 'utm_' . $ key ; } if ( false === array_key_exists ( $ key , self :: $ utmCookie ) ) { throw new UnexpectedValueException ( sprintf ( 'Argument $key has unexpecte value "%s". Utm value with key "%s" does not exists.' , $ key , $ key ) ) ; } else { return self :: $ utmCookie [ $ key ] ; } } } 
private static function save ( array $ utmCookieSave ) { $ expire = new DateTime ( ) ; $ expire -> add ( self :: $ lifetime ) ; foreach ( $ utmCookieSave as $ key => $ value ) { setcookie ( self :: $ utmCookieName . '[' . $ key . ']' , $ value , $ expire -> getTimestamp ( ) , self :: $ path , self :: $ domain , self :: $ secure , self :: $ httpOnly ) ; } self :: $ utmCookie = $ utmCookieSave ; } 
public function populate ( EnvironmentInterface $ environment ) { $ metaModel = $ this -> factory -> getMetaModel ( $ environment -> getDataDefinition ( ) -> getName ( ) ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { $ event = new PopulateAttributeEvent ( $ metaModel , $ attribute , $ environment ) ; 
public function handle ( GetPropertyOptionsEvent $ event ) { if ( ( 'tl_metamodel_dca' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'backendsection' !== $ event -> getPropertyName ( ) ) ) { return ; } $ event -> setOptions ( array_keys ( $ GLOBALS [ 'BE_MOD' ] ) ) ; } 
protected function getTemplate ( $ strTemplate , $ strFormat = 'html5' , $ blnFailIfNotFound = false ) { $ strTemplate = basename ( $ strTemplate ) ; $ strCustom = 'templates' ; 
protected function callParseTemplateHook ( ) { if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ objCallback -> $ strMethod ( $ this ) ; } } } 
public function parse ( $ strOutputFormat , $ blnFailIfNotFound = false ) { if ( $ this -> strTemplate == '' ) { return '' ; } <!-- TEMPLATE START: $strRelPath --> $strBuffer <!-- TEMPLATE END: $strRelPath --> EOF ; } return $ strBuffer ; } 
public static function render ( $ strTemplate , $ strOutputFormat , $ arrTplData , $ blnFailIfNotFound = false ) { $ objTemplate = new self ( $ strTemplate ) ; $ objTemplate -> setData ( $ arrTplData ) ; return $ objTemplate -> parse ( $ strOutputFormat , $ blnFailIfNotFound ) ; } 
public function block ( $ strName ) { $ this -> arrBlockNames [ ] = $ strName ; 
public function insert ( $ strName , array $ arrData = null ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new \ BackendTemplate ( $ strName ) ; } else { $ objTemplate = new \ FrontendTemplate ( $ strName ) ; } if ( $ arrData !== null ) { $ objTemplate -> setData ( $ arrData ) ; } echo $ objTemplate -> parse ( $ this -> getFormat ( ) ) ; } 
public function purge ( ) { foreach ( $ GLOBALS [ 'TL_PURGE' ] [ 'folders' ] [ 'metamodels_assets' ] [ 'affected' ] as $ folderName ) { 
public function handle ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModel ( $ environment ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; $ type = $ model -> getProperty ( 'type' ) ; $ parameterValue = ( \ is_array ( $ model -> getProperty ( 'value' ) ) ? implode ( ', ' , $ model -> getProperty ( 'value' ) ) : $ model -> getProperty ( 'value' ) ) ; $ name = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.conditionnames.' . $ type , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; $ event -> setLabel ( $ this -> getLabelText ( $ type ) ) -> setArgs ( [ $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/filter_default.png' , $ name , '' , 'bundles/metamodelscore/images/icons/filter_default.png' ) , $ name , $ attribute ? $ attribute -> getName ( ) : '' . $ model -> getProperty ( 'attr_id' ) , $ parameterValue ] ) ; } 
protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { return $ event -> getEnvironment ( ) -> getInputProvider ( ) -> hasParameter ( 'mode' ) ? parent :: wantToHandle ( $ event ) && ( 'select' === $ event -> getEnvironment ( ) -> getInputProvider ( ) -> getParameter ( 'act' ) ) : parent :: wantToHandle ( $ event ) ; } 
private function getLabelText ( $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc.' . $ type , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc.' . $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc._default_' , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc._default_' ) { return $ type ; } } return $ label ; } 
public function handleDecode ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'languages' ) ) { return ; } $ langValues = ( array ) $ event -> getValue ( ) ; $ output = [ ] ; foreach ( $ langValues as $ langCode => $ subValue ) { if ( is_array ( $ subValue ) ) { $ output [ ] = array_merge ( $ subValue , [ 'langcode' => $ langCode ] ) ; } } $ event -> setValue ( $ output ) ; } 
public function handleEncode ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'languages' ) ) { return ; } $ langValues = ( array ) $ event -> getValue ( ) ; $ hasFallback = false ; $ output = [ ] ; foreach ( $ langValues as $ subValue ) { $ langCode = $ subValue [ 'langcode' ] ; unset ( $ subValue [ 'langcode' ] ) ; 
public function boot ( ) { $ environment = System :: getContainer ( ) -> get ( 'contao.framework' ) -> getAdapter ( Environment :: class ) ; $ script = explode ( '?' , $ environment -> get ( 'relativeRequest' ) , 2 ) [ 0 ] ; 
private function tryDispatch ( $ eventName , MetaModelsBootEvent $ event ) { $ dispatcher = System :: getContainer ( ) -> get ( 'event_dispatcher' ) ; if ( $ dispatcher -> hasListeners ( $ eventName ) ) { 
public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getProperty ( ) ) ) { return ; } $ values = $ event -> getValue ( ) ; $ index = 0 ; $ time = time ( ) ; foreach ( array_keys ( $ values ) as $ key ) { $ values [ $ key ] [ 'sorting' ] = $ index ; $ values [ $ key ] [ 'tstamp' ] = $ time ; $ index += 128 ; } $ event -> setValue ( $ values ) ; } 
public static function getSubscribedServices ( ) { return [ Connection :: class => Connection :: class , Input :: class => Input :: class , InsertTags :: class => InsertTags :: class , Session :: class => Session :: class , 
public function get ( $ strKey ) { return isset ( $ this -> data [ $ strKey ] ) ? $ this -> data [ $ strKey ] : null ; } 
public function prepareRules ( IFilter $ objFilter , $ arrFilterUrl ) { $ this -> filterParameters = $ arrFilterUrl ; $ this -> queryString = $ this -> get ( 'customsql' ) ; $ this -> queryParameter = [ ] ; $ objFilter -> addFilterRule ( $ this -> getFilterRule ( ) ) ; unset ( $ this -> filterParameters ) ; unset ( $ this -> queryString ) ; unset ( $ this -> queryParameter ) ; } 
public function getParameters ( ) { $ arrParams = [ ] ; preg_match_all ( '@\{\{param::filter\?([^}]*)\}\}@' , $ this -> get ( 'customsql' ) , $ arrMatches ) ; foreach ( $ arrMatches [ 1 ] as $ strQuery ) { parse_str ( $ strQuery , $ arrArgs ) ; if ( isset ( $ arrArgs [ 'name' ] ) ) { $ arrName = ( array ) $ arrArgs [ 'name' ] ; $ arrParams [ ] = $ arrName [ 0 ] ; } } return $ arrParams ; } 
private function getFilterRule ( ) { $ this -> compile ( ) ; return new SimpleQuery ( $ this -> queryString , $ this -> queryParameter , 'id' , $ this -> container -> get ( Connection :: class ) ) ; } 
private function addParameters ( $ parameters ) { if ( empty ( $ parameters ) ) { return ; } $ this -> queryParameter = array_merge ( $ this -> queryParameter , $ parameters ) ; } 
private function parseTable ( ) { $ this -> queryString = str_replace ( '{{table}}' , $ this -> collection -> getMetaModel ( ) -> getTableName ( ) , $ this -> queryString ) ; } 
private function getValueFromServiceContainer ( $ valueName , $ arguments ) { if ( ! empty ( $ arguments [ 'service' ] ) ) { $ serviceName = $ arguments [ 'service' ] ; } else { $ serviceName = $ valueName ; } $ service = $ this -> container -> get ( IMetaModelsServiceContainer :: class ) -> getService ( $ serviceName ) ; if ( is_callable ( $ service ) ) { return call_user_func ( $ service , $ valueName , $ arguments ) ; } return 'NULL' ; } 
private function getValueFromSource ( $ source , $ valueName , $ arguments ) { switch ( strtolower ( $ source ) ) { case 'get' : return $ this -> container -> get ( Input :: class ) -> get ( $ valueName ) ; case 'post' : return $ this -> container -> get ( Input :: class ) -> post ( $ valueName ) ; case 'cookie' : return $ this -> container -> get ( Input :: class ) -> cookie ( $ valueName ) ; case 'session' : return $ this -> container -> get ( Session :: class ) -> get ( $ valueName ) ; case 'filter' : if ( is_array ( $ this -> filterParameters ) ) { if ( array_key_exists ( $ valueName , $ this -> filterParameters ) ) { return $ this -> filterParameters [ $ valueName ] ; } return null ; } break ; case 'container' : 
private function convertParameterAggregate ( $ var , $ arguments ) { 
public function convertParameter ( $ arrMatch ) { list ( $ strSource , $ strQuery ) = explode ( '?' , $ arrMatch [ 1 ] , 2 ) ; parse_str ( $ strQuery , $ arrArgs ) ; $ arrName = ( array ) $ arrArgs [ 'name' ] ; $ var = $ this -> getValueFromSource ( $ strSource , array_shift ( $ arrName ) , $ arrArgs ) ; $ index = 0 ; $ count = count ( $ arrName ) ; while ( $ index < $ count && is_array ( $ var ) ) { $ var = $ var [ $ arrName [ $ index ++ ] ] ; } if ( $ index != $ count || $ var === null ) { if ( array_key_exists ( 'default' , $ arrArgs ) && ( null !== $ arrArgs [ 'default' ] ) ) { $ this -> addParameter ( $ arrArgs [ 'default' ] ) ; return '?' ; } else { return 'NULL' ; } } 
private function getRow ( $ rowId , $ table ) { return ( object ) $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ table ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ rowId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; } 
public function generate ( FilterUrl $ filterUrl ) { $ jumpTo = $ filterUrl -> getPage ( ) ; 
public function getCurrentFilterUrl ( $ options = null ) : FilterUrl { $ this -> addFromCurrentRequest ( $ filterUrl = new FilterUrl ( ) , $ options ) ; return $ filterUrl ; } 
public function addFromCurrentRequest ( FilterUrl $ filterUrl , $ options = null ) : void { if ( null === $ options ) { $ options = [ 'postAsSlug' => [ ] , 'postAsGet' => [ ] , 'preserveGet' => true ] ; } $ request = $ this -> requestStack -> getMasterRequest ( ) ; if ( isset ( $ options [ 'preserveGet' ] ) ) { foreach ( $ request -> query -> all ( ) as $ name => $ value ) { $ filterUrl -> setGet ( $ name , $ value ) ; } } if ( null === $ fragments = $ this -> determineFragments ( $ request ) ) { return ; } $ filterUrl -> setPageValue ( 'alias' , $ fragments [ 0 ] ) ; 
private function determineFragments ( Request $ request ) : ? array { if ( null === $ requestUri = $ this -> strippedUri ( $ request ) ) { return null ; } $ fragments = null ; 
private function strippedUri ( Request $ request ) : ? string { 
private function getFolderUrlFragments ( string $ alias , string $ host , string $ locale = null ) : ? array { 
private function getPageCandidates ( string $ alias ) { $ aliases = [ $ alias ] ; 
private function getPageIdFromUrlHook ( ? array $ fragments ) : ? array { if ( ! ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) ) ) { return $ fragments ; } foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] as $ callback ) { $ fragments = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ fragments ) ; } return $ fragments ; } 
private function extractPostData ( FilterUrl $ filterUrl , $ options , Request $ request ) : void { if ( empty ( $ options [ 'postAsSlug' ] ) && empty ( $ options [ 'postAsGet' ] ) ) { return ; } foreach ( $ request -> request -> all ( ) as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsSlug' ] ) ) { $ filterUrl -> setSlug ( $ name , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsGet' ] ) ) { $ filterUrl -> setGet ( $ name , $ value ) ; } } } 
public function process ( ContainerBuilder $ container ) { $ this -> collectAttributeFactories ( $ container ) ; $ this -> collectFilterFactories ( $ container ) ; $ this -> collectPropertyConditionFactories ( $ container ) ; } 
private function collectAttributeFactories ( $ container ) { $ attributeFactory = $ container -> getDefinition ( 'metamodels.attribute_factory' ) ; foreach ( array_keys ( $ container -> findTaggedServiceIds ( self :: TAG_ATTRIBUTE_FACTORY ) ) as $ factory ) { $ attributeFactory -> addMethodCall ( 'addTypeFactory' , [ new Reference ( $ factory ) ] ) ; } } 
private function collectFilterFactories ( $ container ) { $ attributeFactory = $ container -> getDefinition ( 'metamodels.filter_setting_factory' ) ; foreach ( array_keys ( $ container -> findTaggedServiceIds ( self :: TAG_FILTER_FACTORY ) ) as $ factory ) { $ attributeFactory -> addMethodCall ( 'addTypeFactory' , [ new Reference ( $ factory ) ] ) ; } } 
private function collectPropertyConditionFactories ( $ container ) { $ factories = $ container -> getDefinition ( 'metamodels.core_bundle.dc_general.property_condition_factories' ) ; $ args = $ factories -> getArgument ( 0 ) ; foreach ( $ container -> findTaggedServiceIds ( self :: TAG_PROPERTY_CONDITION_FACTORY ) as $ factory => $ tags ) { foreach ( $ tags as $ tag ) { $ args [ $ tag [ 'type' ] ] = new Reference ( $ factory ) ; } } $ factories -> setArgument ( 0 , $ args ) ; } 
public function isValidColumnName ( $ strColName ) { return $ this -> isValidMySQLIdentifier ( $ strColName ) && ! $ this -> isReservedWord ( $ strColName ) && ! $ this -> isReserveColumnPostFix ( $ strColName ) ; } 
public function checkColumnName ( $ strColName , $ blnAllowSystemCol = false ) { if ( ! $ this -> isValidColumnName ( $ strColName ) ) { throw InvalidColumnNameException :: invalidCharacters ( $ strColName ) ; } if ( ( ! $ blnAllowSystemCol ) && $ this -> isSystemColumn ( $ strColName ) ) { throw InvalidColumnNameException :: systemColumn ( $ strColName ) ; } } 
public function checkTableExists ( $ strTableName ) { $ this -> checkTablename ( $ strTableName ) ; if ( ! $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ strTableName ] ) ) { throw TableDoesNotExistException :: withName ( $ strTableName ) ; } } 
public function checkTableDoesNotExist ( $ strTableName ) { $ this -> checkTablename ( $ strTableName ) ; if ( $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ strTableName ] ) ) { throw TableExistsException :: withName ( $ strTableName ) ; } } 
public function createTable ( $ strTableName ) { $ this -> checkTableDoesNotExist ( $ strTableName ) ; $ this -> connection -> query ( sprintf ( self :: STATEMENT_CREATE_TABLE , $ strTableName ) ) ; } 
public function renameTable ( $ strTableName , $ strNewTableName ) { $ this -> checkTableExists ( $ strTableName ) ; $ this -> checkTableDoesNotExist ( $ strNewTableName ) ; $ this -> connection -> query ( sprintf ( self :: STATEMENT_RENAME_TABLE , $ strTableName , $ strNewTableName ) ) ; } 
public function deleteTable ( $ strTableName ) { $ this -> checkTableExists ( $ strTableName ) ; $ this -> connection -> query ( sprintf ( self :: STATEMENT_DROP_TABLE , $ strTableName ) ) ; } 
public function addIndex ( $ strTableName , $ strIndexType , $ strColName ) { $ this -> checkColumnExists ( $ strTableName , $ strColName ) ; $ this -> connection -> query ( sprintf ( self :: STATEMENT_ADD_INDEX_COLUMN , $ strTableName , $ strIndexType , $ strColName ) ) ; } 
public function checkColumnExists ( $ strTableName , $ strColName , $ blnAllowSystemCol = false ) { $ this -> checkTableExists ( $ strTableName ) ; $ this -> checkColumnName ( $ strColName , $ blnAllowSystemCol ) ; if ( ! $ this -> fieldExists ( $ strTableName , $ strColName ) ) { throw ColumnDoesNotExistException :: withName ( $ strColName , $ strTableName ) ; } } 
public function checkColumnDoesNotExist ( $ strTableName , $ strColName , $ blnAllowSystemCol = false ) { $ this -> checkTableExists ( $ strTableName ) ; $ this -> checkColumnName ( $ strColName , $ blnAllowSystemCol ) ; if ( $ this -> fieldExists ( $ strColName , $ strTableName ) ) { throw ColumnExistsException :: withName ( $ strColName , $ strTableName ) ; } } 
public function createColumn ( $ strTableName , $ strColumnName , $ strType , $ blnAllowSystemCol = false ) { $ this -> checkColumnDoesNotExist ( $ strTableName , $ strColumnName , $ blnAllowSystemCol ) ; $ this -> connection -> query ( sprintf ( self :: STATEMENT_CREATE_COLUMN , $ strTableName , $ strColumnName , $ strType ) ) ; } 
public function renameColumn ( $ strTableName , $ strColumnName , $ strNewColumnName , $ strNewType , $ blnAllowSystemCol = false ) { if ( $ strColumnName != $ strNewColumnName ) { $ this -> checkColumnExists ( $ strTableName , $ strColumnName , $ blnAllowSystemCol ) ; $ this -> checkColumnDoesNotExist ( $ strTableName , $ strNewColumnName , $ blnAllowSystemCol ) ; } $ this -> connection -> query ( sprintf ( self :: STATEMENT_RENAME_COLUMN , $ strTableName , $ strColumnName , $ strNewColumnName , $ strNewType ) ) ; } 
public function dropColumn ( $ strTableName , $ strColumnName , $ blnAllowSystemCol = false ) { $ this -> checkColumnExists ( $ strTableName , $ strColumnName , $ blnAllowSystemCol ) ; $ this -> connection -> query ( sprintf ( self :: STATEMENT_DROP_COLUMN , $ strTableName , $ strColumnName ) ) ; } 
public function setVariantSupport ( $ strTableName , $ blnVariantSupport ) { if ( $ blnVariantSupport ) { if ( $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ strTableName ] ) && ( ! $ this -> fieldExists ( $ strTableName , 'varbase' ) ) ) { $ this -> createColumn ( $ strTableName , 'varbase' , 'char(1) NOT NULL default \'\'' , true ) ; $ this -> createColumn ( $ strTableName , 'vargroup' , 'int(11) NOT NULL default 0' , true ) ; 
private function fieldExists ( $ strTableName , $ strColumnName ) { $ columns = $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ strTableName ) ; return isset ( $ columns [ $ strColumnName ] ) ; } 
public function generateAjax ( $ folder , $ strField , $ level , $ mount = false ) { return parent :: generateAjax ( $ folder , $ this -> strField , $ level , $ mount ) ; } 
public function handle ( GetPropertyOptionsEvent $ event ) { if ( ( 'tl_metamodel_filtersetting' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'type' !== $ event -> getPropertyName ( ) ) ) { return ; } $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ options = [ ] ; foreach ( $ this -> filterFactory -> getTypeNames ( ) as $ filter ) { $ options [ $ filter ] = $ translator -> translate ( 'typenames.' . $ filter , 'tl_metamodel_filtersetting' ) ; } $ event -> setOptions ( $ options ) ; } 
public function onKernelRequest ( GetResponseEvent $ event ) { if ( ! $ this -> scopeMatcher -> isBackendMasterRequest ( $ event ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } $ localMenu = & $ GLOBALS [ 'BE_MOD' ] ; $ this -> buildBackendModules ( $ localMenu ) ; $ this -> injectChildTables ( $ localMenu ) ; } 
private function buildBackendModules ( & $ localMenu ) { foreach ( $ this -> viewCombination -> getStandalone ( ) as $ metaModelName => $ screen ) { $ section = $ screen [ 'meta' ] [ 'backendsection' ] ; if ( ! isset ( $ localMenu [ $ section ] ) ) { $ localMenu [ $ section ] = [ ] ; } if ( ! isset ( $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] ) ) { $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] = [ 'tables' => [ ] ] ; } $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] [ 'callback' ] = Module :: class ; array_unshift ( $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] [ 'tables' ] , $ metaModelName ) ; } } 
private function injectChildTables ( & $ localMenu ) { $ parented = $ this -> viewCombination -> getParented ( ) ; $ lastCount = count ( $ parented ) ; while ( $ parented ) { foreach ( $ parented as $ metaModelName => $ child ) { foreach ( $ localMenu as $ groupName => $ modules ) { foreach ( $ modules as $ moduleName => $ module ) { if ( isset ( $ module [ 'tables' ] ) && in_array ( $ child [ 'meta' ] [ 'ptable' ] , $ module [ 'tables' ] ) ) { $ localMenu [ $ groupName ] [ $ moduleName ] [ 'tables' ] [ ] = $ metaModelName ; unset ( $ parented [ $ metaModelName ] ) ; break ; } } } } 
public function getJumpTo ( ) { if ( ! isset ( $ this -> arrJumpTo ) ) { $ page = $ GLOBALS [ 'objPage' ] ; $ this -> setJumpTo ( $ page -> row ( ) ) ; if ( $ this -> metamodel_jumpTo ) { 
protected function compile ( ) { $ objFilter = new FrontendFilter ( $ this -> getConnection ( ) , $ this -> getFilterUrlBuilder ( ) ) ; $ arrFilter = $ objFilter -> getMetaModelFrontendFilter ( $ this ) ; $ this -> Template -> setData ( array_merge ( $ this -> Template -> getData ( ) , $ arrFilter ) ) ; $ this -> Template -> submit = $ arrFilter [ 'submit' ] ; } 
private function getFilterFactory ( ) : IFilterSettingFactory { if ( null === $ this -> filterFactory ) { return $ this -> filterFactory = System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ; } return $ this -> filterFactory ; } 
private function getFilterUrlBuilder ( ) : FilterUrlBuilder { if ( null === $ this -> filterUrlBuilder ) { return $ this -> filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; } return $ this -> filterUrlBuilder ; } 
private function getFilterForComparingOperator ( $ attribute , IFilter $ filter , $ operation ) { if ( $ attribute ) { switch ( $ operation [ 'operation' ] ) { case '=' : $ filter -> addFilterRule ( new SearchAttribute ( $ attribute , $ operation [ 'value' ] , $ this -> getMetaModel ( ) -> getAvailableLanguages ( ) ? : array ( ) ) ) ; return ; case '>' : $ filter -> addFilterRule ( new GreaterThan ( $ attribute , $ operation [ 'value' ] ) ) ; return ; case '<' : $ filter -> addFilterRule ( new LessThan ( $ attribute , $ operation [ 'value' ] ) ) ; return ; default : throw new \ RuntimeException ( 'Error processing filter array - unknown operation ' . var_export ( $ operation [ 'operation' ] , true ) , 1 ) ; } } $ columns = $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ this -> getMetaModel ( ) -> getTableName ( ) ) ; if ( $ columns [ $ operation [ 'property' ] ] ) { 
private function getFilterForInList ( IFilter $ filter , $ operation ) { 
private function getFilterForLike ( $ attribute , IFilter $ filter , $ operation ) { if ( $ attribute ) { $ filter -> addFilterRule ( new SearchAttribute ( $ attribute , $ operation [ 'value' ] , $ this -> getMetaModel ( ) -> getAvailableLanguages ( ) ? : array ( ) ) ) ; return ; } $ columns = $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ this -> getMetaModel ( ) -> getTableName ( ) ) ; if ( $ columns [ $ operation [ 'property' ] ] ) { 
protected function buildNativeSqlProcedure ( FilterBuilderSql $ procedure , $ children ) { $ skipped = array ( ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ tableName = $ metaModel -> getTableName ( ) ; foreach ( $ children as $ child ) { 
protected function optimizedFilter ( $ filterRule , $ children , $ operation ) { $ procedure = new FilterBuilderSql ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ operation , $ this -> connection ) ; $ skipped = $ this -> buildNativeSqlProcedure ( $ procedure , $ children ) ; if ( ! $ procedure -> isEmpty ( ) ) { $ filterRule -> addChild ( $ this -> getMetaModel ( ) -> getEmptyFilter ( ) -> addFilterRule ( $ procedure -> build ( ) ) ) ; } return $ skipped ; } 
protected function getAndOrFilter ( IFilter $ filter , $ operation ) { if ( ! $ operation [ 'children' ] ) { return ; } if ( $ operation [ 'operation' ] == 'AND' ) { $ filterRule = new ConditionAnd ( ) ; } else { $ filterRule = new ConditionOr ( ) ; } $ filter -> addFilterRule ( $ filterRule ) ; $ children = $ this -> optimizedFilter ( $ filterRule , $ operation [ 'children' ] , $ operation [ 'operation' ] ) ; foreach ( $ children as $ child ) { $ subFilter = $ this -> getMetaModel ( ) -> getEmptyFilter ( ) ; $ filterRule -> addChild ( $ subFilter ) ; $ this -> calculateSubfilter ( $ child , $ subFilter ) ; } } 
protected function getAttributeFromFilterOperation ( $ operation ) { $ attribute = null ; if ( ! empty ( $ operation [ 'property' ] ) ) { $ attribute = $ this -> getMetaModel ( ) -> getAttribute ( $ operation [ 'property' ] ) ; } if ( $ attribute === null ) { throw new \ InvalidArgumentException ( 'Attribute ' . $ operation [ 'property' ] . ' not found.' ) ; } return $ attribute ; } 
private function calculateSubfilter ( $ operation , IFilter $ filter ) { if ( ! is_array ( $ operation ) ) { throw new \ RuntimeException ( 'Error Processing subfilter: ' . var_export ( $ operation , true ) , 1 ) ; } switch ( $ operation [ 'operation' ] ) { case 'AND' : case 'OR' : $ this -> getAndOrFilter ( $ filter , $ operation ) ; break ; case '=' : case '>' : case '<' : $ this -> getFilterForComparingOperator ( $ this -> getAttributeFromFilterOperation ( $ operation ) , $ filter , $ operation ) ; break ; case 'IN' : $ this -> getFilterForInList ( $ filter , $ operation ) ; break ; case 'LIKE' : $ this -> getFilterForLike ( $ this -> getAttributeFromFilterOperation ( $ operation ) , $ filter , $ operation ) ; break ; default : throw new \ RuntimeException ( 'Error processing filter array - unknown operation ' . var_export ( $ operation , true ) , 1 ) ; } } 
public function build ( ) { $ filter = $ this -> getMetaModel ( ) -> getEmptyFilter ( ) ; if ( $ this -> configuration -> getFilter ( ) ) { $ this -> calculateSubfilter ( array ( 'operation' => 'AND' , 'children' => $ this -> configuration -> getFilter ( ) ) , $ filter ) ; } return $ filter ; } 
public function getOptions ( GetPropertyOptionsEvent $ event ) { if ( ( 'tl_metamodel_filtersetting' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'attr_id' !== $ event -> getPropertyName ( ) ) ) { return ; } $ result = [ ] ; $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> filterFactory -> createCollection ( $ model -> getProperty ( 'fid' ) ) -> getMetaModel ( ) ; $ typeFactory = $ this -> filterFactory -> getTypeFactory ( $ model -> getProperty ( 'type' ) ) ; $ typeFilter = null ; if ( $ typeFactory ) { $ typeFilter = $ typeFactory -> getKnownAttributeTypes ( ) ; } foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { $ typeName = $ attribute -> get ( 'type' ) ; if ( $ typeFilter && ( ! in_array ( $ typeName , $ typeFilter ) ) ) { continue ; } $ strSelectVal = $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ; $ result [ $ strSelectVal ] = $ attribute -> getName ( ) . ' [' . $ typeName . ']' ; } $ event -> setOptions ( $ result ) ; } 
public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ( 'tl_metamodel_filtersetting' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'attr_id' !== $ event -> getProperty ( ) ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> filterFactory -> createCollection ( $ model -> getProperty ( 'fid' ) ) -> getMetaModel ( ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ value = substr ( $ value , strlen ( $ metaModel -> getTableName ( ) . '_' ) ) ; $ attribute = $ metaModel -> getAttribute ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ attribute -> get ( 'id' ) ) ; } } 
public function createButton ( GetOperationButtonEvent $ event ) { if ( 'createvariant' !== $ event -> getCommand ( ) -> getName ( ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metamodel = $ model -> getItem ( ) -> getMetaModel ( ) ; if ( ! $ metamodel -> hasVariants ( ) || $ model -> getProperty ( 'varbase' ) === '0' ) { $ event -> setHtml ( '' ) ; } } 
public function handleCreateVariantAction ( ActionEvent $ event ) { if ( false === $ this -> scopeMatcher -> currentScopeIsBackend ( ) || 'createvariant' !== $ event -> getAction ( ) -> getName ( ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ view = $ environment -> getView ( ) ; $ dataProvider = $ environment -> getDataProvider ( ) ; $ inputProvider = $ environment -> getInputProvider ( ) ; $ modelId = $ inputProvider -> hasParameter ( 'id' ) ? ModelId :: fromSerialized ( $ inputProvider -> getParameter ( 'id' ) ) : null ; $ model = $ dataProvider -> createVariant ( $ dataProvider -> getEmptyConfig ( ) -> setId ( $ modelId -> getId ( ) ) ) ; if ( $ model == null ) { throw new \ RuntimeException ( sprintf ( 'Could not find model with id %s for creating a variant.' , $ modelId ) ) ; } $ metaModel = $ this -> factory -> getMetaModel ( $ model -> getProviderName ( ) ) ; if ( ! $ metaModel || ! $ metaModel -> hasVariants ( ) ) { return ; } $ preFunction = function ( $ environment , $ model ) { $ copyEvent = new PreCreateModelEvent ( $ environment , $ model ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ copyEvent :: NAME , $ copyEvent ) ; } ; $ postFunction = function ( $ environment , $ model ) { $ copyEvent = new PostCreateModelEvent ( $ environment , $ model ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ copyEvent :: NAME , $ copyEvent ) ; } ; if ( ! $ view instanceof BackendViewInterface ) { throw new \ InvalidArgumentException ( 'Invalid view registered in environment.' ) ; } $ editMask = new EditMask ( $ view , $ model , null , $ preFunction , $ postFunction , $ this -> breadcrumb ( $ environment ) ) ; $ event -> setResponse ( $ editMask -> execute ( ) ) ; } 
public function presetVariantBase ( PreEditModelEvent $ event ) { $ model = $ event -> getModel ( ) ; 
protected function breadcrumb ( EnvironmentInterface $ environment ) { $ event = new GetBreadcrumbEvent ( $ environment ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ event :: NAME , $ event ) ; $ arrReturn = $ event -> getElements ( ) ; if ( ! is_array ( $ arrReturn ) || count ( $ arrReturn ) == 0 ) { return null ; } $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/ccadcgeneral/css/generalBreadcrumb.css' ; $ objTemplate = new ContaoBackendViewTemplate ( 'dcbe_general_breadcrumb' ) ; $ objTemplate -> elements = $ arrReturn ; return $ objTemplate -> parse ( ) ; } 
public function setServiceContainer ( IMetaModelsServiceContainer $ serviceContainer , $ deprecationNotice = true ) { if ( $ deprecationNotice ) { 
public function createAttribute ( $ information , $ metaModel ) { $ event = new CreateAttributeEvent ( $ information , $ metaModel ) ; $ this -> eventDispatcher -> dispatch ( CreateAttributeEvent :: NAME , $ event ) ; if ( $ event -> getAttribute ( ) ) { return $ event -> getAttribute ( ) ; } $ factory = $ this -> getTypeFactory ( $ information [ 'type' ] ) ; if ( ! $ factory ) { return null ; } return $ factory -> createInstance ( $ information , $ metaModel ) ; } 
public function addTypeFactory ( IAttributeTypeFactory $ typeFactory ) { $ typeName = $ typeFactory -> getTypeName ( ) ; if ( isset ( $ this -> typeFactories [ $ typeName ] ) ) { throw new \ RuntimeException ( 'Attribute type ' . $ typeName . ' is already registered.' ) ; } $ this -> typeFactories [ $ typeName ] = $ typeFactory ; return $ this ; } 
public function getTypeFactory ( $ typeFactory ) { return isset ( $ this -> typeFactories [ ( string ) $ typeFactory ] ) ? $ this -> typeFactories [ ( string ) $ typeFactory ] : null ; } 
public function attributeTypeMatchesFlags ( $ name , $ flags ) { $ factory = $ this -> getTypeFactory ( $ name ) ; 
public function getTypeNames ( $ flags = false ) { if ( $ flags === false ) { $ flags = self :: FLAG_ALL ; } $ result = array ( ) ; foreach ( array_keys ( $ this -> typeFactories ) as $ name ) { if ( ! $ this -> attributeTypeMatchesFlags ( $ name , $ flags ) ) { continue ; } $ result [ ] = $ name ; } return $ result ; } 
public function collectAttributeInformation ( IMetaModel $ metaModel ) { $ event = new CollectMetaModelAttributeInformationEvent ( $ metaModel ) ; $ this -> eventDispatcher -> dispatch ( $ event :: NAME , $ event ) ; return $ event -> getAttributeInformation ( ) ; } 
public function createAttributesForMetaModel ( $ metaModel ) { $ attributes = array ( ) ; foreach ( $ this -> collectAttributeInformation ( $ metaModel ) as $ information ) { $ attribute = $ this -> createAttribute ( $ information , $ metaModel ) ; if ( $ attribute ) { $ attributes [ ] = $ attribute ; } } return $ attributes ; } 
public function getIconForType ( $ type ) { return isset ( $ this -> typeFactories [ ( string ) $ type ] ) ? $ this -> typeFactories [ ( string ) $ type ] -> getTypeIcon ( ) : null ; } 
public function getBreadcrumb ( GetBreadcrumbEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ elements = $ this -> storeFactory -> createStore ( ) ; $ this -> getBreadcrumbElements ( $ environment , $ elements ) ; $ event -> setElements ( $ elements -> getElements ( ) ) ; $ event -> stopPropagation ( ) ; } 
protected function getBreadcrumbElements ( EnvironmentInterface $ environment , BreadcrumbStore $ elements ) { if ( $ this -> parent ) { $ this -> parent -> getBreadcrumbElements ( $ environment , $ elements ) ; } } 
protected function extractIdFrom ( EnvironmentInterface $ environment , $ parameterName = 'pid' ) { $ parameter = $ environment -> getInputProvider ( ) -> getParameter ( $ parameterName ) ; return ModelId :: fromSerialized ( $ parameter ) -> getId ( ) ; } 
public function checkPurge ( AbstractModelAwareEvent $ event ) { $ table = $ event -> getModel ( ) -> getProviderName ( ) ; if ( ( $ table == 'tl_metamodel' ) || ( $ table == 'tl_metamodel_dca' ) || ( $ table == 'tl_metamodel_dca_sortgroup' ) || ( $ table == 'tl_metamodel_dcasetting' ) || ( $ table == 'tl_metamodel_dcasetting_condition' ) || ( $ table == 'tl_metamodel_attribute' ) || ( $ table == 'tl_metamodel_filter' ) || ( $ table == 'tl_metamodel_filtersetting' ) || ( $ table == 'tl_metamodel_rendersettings' ) || ( $ table == 'tl_metamodel_rendersetting' ) || ( $ table == 'tl_metamodel_dca_combine' ) ) { $ this -> purger -> purge ( ) ; } } 
protected function build ( IMetaModelDataDefinition $ container ) { $ this -> container = $ container ; $ this -> definition = $ this -> getOrCreateDefinition ( ) ; $ this -> inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; $ this -> metaModel = $ this -> factory -> getMetaModel ( $ container -> getName ( ) ) ; $ this -> parseListing ( ) ; $ this -> container = null ; $ this -> definition = null ; $ this -> inputScreen = null ; $ this -> metaModel = null ; } 
private function getOrCreateDefinition ( ) { if ( $ this -> container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ this -> container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; if ( ! $ view instanceof Contao2BackendViewDefinitionInterface ) { throw new DcGeneralInvalidArgumentException ( 'Configured BackendViewDefinition does not implement Contao2BackendViewDefinitionInterface.' ) ; } return $ view ; } $ this -> container -> setDefinition ( Contao2BackendViewDefinitionInterface :: NAME , $ view = new Contao2BackendViewDefinition ( ) ) ; return $ view ; } 
private function parseListing ( ) { $ listing = $ this -> definition -> getListingConfig ( ) ; if ( null === $ listing -> getRootLabel ( ) ) { $ listing -> setRootLabel ( $ this -> metaModel -> get ( 'name' ) ) ; } if ( null === $ listing -> getRootIcon ( ) ) { $ listing -> setRootIcon ( $ this -> iconBuilder -> getBackendIcon ( $ this -> inputScreen [ 'meta' ] [ 'backendicon' ] ) ) ; } $ this -> parseListSorting ( $ listing ) ; $ this -> parseListLabel ( $ listing ) ; $ listing -> setShowColumns ( ( bool ) $ this -> inputScreen [ 'meta' ] [ 'showColumns' ] ) ; } 
private function parseListSorting ( ListingConfigInterface $ listing ) { if ( null === $ this -> inputScreen ) { return ; } $ definitions = $ listing -> getGroupAndSortingDefinition ( ) ; foreach ( $ this -> inputScreen [ 'groupSort' ] as $ information ) { $ definition = $ definitions -> add ( ) ; $ definition -> setName ( $ information [ 'name' ] ) ; if ( $ information [ 'isdefault' ] && ! $ definitions -> hasDefault ( ) ) { $ definitions -> markDefault ( $ definition ) ; } $ this -> handleSorting ( $ information , $ definition ) ; $ groupType = $ this -> convertRenderGroupType ( $ information [ 'rendergrouptype' ] ) ; if ( $ groupType !== GroupAndSortingInformationInterface :: GROUP_NONE && $ information [ 'col_name' ] ) { $ propertyInformation = $ definition -> add ( 0 ) ; $ propertyInformation -> setProperty ( $ information [ 'col_name' ] ) -> setGroupingMode ( $ groupType ) -> setGroupingLength ( $ information [ 'rendergrouplen' ] ) -> setSortingMode ( $ information [ 'rendersort' ] ) ; } } } 
private function handleSorting ( $ information , GroupAndSortingDefinitionInterface $ definition ) { if ( $ information [ 'ismanualsort' ] ) { $ definition -> add ( ) -> setManualSorting ( ) -> setProperty ( 'sorting' ) -> setSortingMode ( GroupAndSortingInformationInterface :: SORT_ASC ) ; return ; } if ( $ information [ 'col_name' ] ) { $ definition -> add ( ) -> setProperty ( $ information [ 'col_name' ] ) -> setSortingMode ( $ information [ 'rendersort' ] ) ; } } 
private function convertRenderGroupType ( $ type ) { $ lookup = [ 'char' => GroupAndSortingInformationInterface :: GROUP_CHAR , 'digit' => GroupAndSortingInformationInterface :: GROUP_DIGIT , 'day' => GroupAndSortingInformationInterface :: GROUP_DAY , 'weekday' => GroupAndSortingInformationInterface :: GROUP_WEEKDAY , 'week' => GroupAndSortingInformationInterface :: GROUP_WEEK , 'month' => GroupAndSortingInformationInterface :: GROUP_MONTH , 'year' => GroupAndSortingInformationInterface :: GROUP_YEAR , ] ; if ( array_key_exists ( $ type , $ lookup ) ) { return $ lookup [ $ type ] ; } return GroupAndSortingInformationInterface :: GROUP_NONE ; } 
private function parseListLabel ( ListingConfigInterface $ listing ) { $ providerName = $ this -> container -> getBasicDefinition ( ) -> getDataProvider ( ) ; if ( ! $ listing -> hasLabelFormatter ( $ providerName ) ) { $ formatter = new DefaultModelFormatterConfig ( ) ; $ listing -> setLabelFormatter ( $ providerName , $ formatter ) ; } else { $ formatter = $ listing -> getLabelFormatter ( $ providerName ) ; } $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ this -> metaModel , $ this -> container -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; $ formatter -> setPropertyNames ( array_merge ( $ formatter -> getPropertyNames ( ) , $ renderSetting -> getSettingNames ( ) ) ) ; $ formatter -> setFormat ( str_repeat ( '%s ' , count ( $ formatter -> getPropertyNames ( ) ) ) ) ; } 
protected function getLegend ( $ name , $ palette , $ prevLegend = null ) { if ( strpos ( $ name , '+' ) === 0 ) { $ name = substr ( $ name , 1 ) ; } if ( ! $ palette -> hasLegend ( $ name ) ) { $ palette -> addLegend ( new Legend ( $ name ) , $ prevLegend ) ; } return $ palette -> getLegend ( $ name ) ; } 
protected function getProperty ( $ name , $ legend ) { foreach ( $ legend -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) === $ name ) { return $ property ; } } $ property = new Property ( $ name ) ; $ legend -> addProperty ( $ property ) ; return $ property ; } 
public function handle ( PreDuplicateModelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ model -> getProviderName ( ) ) ; if ( ! $ metaModel || ! $ metaModel -> hasVariants ( ) ) { return ; } 
public function handle ( CreateMetaModelEvent $ event ) { if ( null === $ metaModel = $ event -> getMetaModel ( ) ) { return ; } foreach ( $ this -> attributeFactory -> createAttributesForMetaModel ( $ metaModel ) as $ attribute ) { $ metaModel -> addAttribute ( $ attribute ) ; } } 
public function getMetaModelFrontendFilter ( HybridFilterBlock $ objFilterConfig ) { $ this -> objFilterConfig = $ objFilterConfig ; $ this -> formId .= $ this -> objFilterConfig -> id ; return $ this -> getFilters ( ) ; } 
protected function getJumpToUrl ( $ arrParams ) { 
protected function redirectPost ( $ arrParams ) { 
protected function getParams ( ) { 
protected function renderWidget ( $ widget , $ filterOptions ) { $ filter = $ widget ; $ templateName = $ filter [ 'raw' ] [ 'eval' ] [ 'template' ] ; $ template = new \ FrontendTemplate ( $ templateName ? $ templateName : 'mm_filteritem_default' ) ; $ template -> setData ( $ filter ) ; $ template -> submit = $ filterOptions -> isAutoSubmit ( ) ; $ filter [ 'value' ] = $ template -> parse ( ) ; return $ filter ; } 
protected function checkRedirect ( $ widgets , $ wantedParameter , $ allParameter ) { 
protected function getFrontendFilterOptions ( ) { $ objFrontendFilterOptions = new FrontendFilterOptions ( ) ; $ objFrontendFilterOptions -> setAutoSubmit ( $ this -> objFilterConfig -> metamodel_fef_autosubmit ? true : false ) ; $ objFrontendFilterOptions -> setHideClearFilter ( $ this -> objFilterConfig -> metamodel_fef_hideclearfilter ? true : false ) ; $ objFrontendFilterOptions -> setShowCountValues ( $ this -> objFilterConfig -> metamodel_available_values ? true : false ) ; return $ objFrontendFilterOptions ; } 
protected function getFilters ( ) { $ filterOptions = $ this -> getFrontendFilterOptions ( ) ; $ jumpToInformation = $ this -> objFilterConfig -> getJumpTo ( ) ; $ filterSetting = $ this -> objFilterConfig -> getFilterCollection ( ) ; $ wantedNames = $ this -> getWantedNames ( ) ; $ this -> buildParameters ( $ other = new FilterUrl ( $ jumpToInformation ) , $ all = new FilterUrl ( $ jumpToInformation ) , $ wantedNames ) ; 
protected function buildParameters ( FilterUrl $ other , FilterUrl $ all , array $ wantedNames ) : void { $ current = $ this -> filterUrlBuilder -> getCurrentFilterUrl ( [ 'postAsSlug' => $ wantedNames , 'postAsGet' => [ ] , 'preserveGet' => true ] ) ; foreach ( $ current -> getSlugParameters ( ) as $ name => $ value ) { $ all -> setSlug ( $ name , $ value ) ; if ( ! in_array ( $ name , $ wantedNames ) ) { $ other -> setSlug ( $ name , $ value ) ; } } foreach ( $ current -> getGetParameters ( ) as $ name => $ value ) { $ all -> setGet ( $ name , $ value ) ; if ( ! in_array ( $ name , $ wantedNames ) ) { $ other -> setGet ( $ name , $ value ) ; } } } 
protected function generateElement ( $ table , $ content , $ replace , $ elementId ) { $ sql = sprintf ( 'SELECT * FROM %s WHERE id=? AND type="metamodels_frontendclearall"' , $ table ) ; $ statement = $ this -> connection -> prepare ( $ sql ) ; $ statement -> bindValue ( 1 , $ elementId ) ; $ statement -> execute ( ) ; $ objDbResult = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ; 
public function generateClearAll ( $ strContent , $ strTemplate ) { if ( substr ( $ strTemplate , 0 , 3 ) === 'fe_' ) { if ( preg_match_all ( '#\[\[\[metamodelfrontendfilterclearall::(ce|mod)::([^\]]*)\]\]\]#' , $ strContent , $ arrMatches , PREG_SET_ORDER ) ) { foreach ( $ arrMatches as $ arrMatch ) { switch ( $ arrMatch [ 1 ] ) { case 'ce' : $ strContent = $ this -> generateContentElement ( $ strContent , $ arrMatch [ 0 ] , $ arrMatch [ 2 ] ) ; break ; case 'mod' : $ strContent = $ this -> generateModule ( $ strContent , $ arrMatch [ 0 ] , $ arrMatch [ 2 ] ) ; break ; default : throw new \ RuntimeException ( 'Unexpected element determinator encountered: ' . $ arrMatch [ 1 ] ) ; } } } } return $ strContent ; } 
public function isNestedType ( ) { if ( ! isset ( $ this -> isNestedType ) ) { $ this -> isNestedType = in_array ( 'MetaModels\Filter\Setting\IWithChildren' , class_implements ( $ this -> typeClass , true ) ) ; } return $ this -> isNestedType ; } 
protected function setMaxChildren ( $ maxChildren ) { if ( ! $ this -> isNestedType ( ) ) { throw new \ LogicException ( 'Filter setting ' . $ this -> typeClass . ' can not handle children.' ) ; } $ this -> maxChildren = $ maxChildren ; return $ this ; } 
protected function allowAttributeTypes ( $ initialType1toN = null ) { if ( is_array ( $ initialType1toN ) ) { $ this -> attributeTypes = $ initialType1toN ; } else { $ this -> attributeTypes = func_get_args ( ) ; } return $ this ; } 
public function addKnownAttributeType ( $ typeName ) { if ( ! is_array ( $ this -> attributeTypes ) ) { throw new \ LogicException ( 'Filter setting ' . $ this -> typeClass . ' can not handle attributes.' ) ; } $ this -> attributeTypes [ $ typeName ] = $ typeName ; return $ this ; } 
public function prepareRules ( IFilter $ objFilter , $ arrFilterUrl ) { if ( $ this -> get ( 'items' ) ) { $ arrItems = explode ( ',' , ( string ) $ this -> get ( 'items' ) ) ; } else { $ arrItems = array ( ) ; } $ objFilter -> addFilterRule ( new FilterRuleIdList ( $ arrItems ) ) ; } 
protected function createEmptyDataFor ( IAttribute $ attribute , $ parentId , $ activate , $ sort ) { return [ 'dcatype' => 'attribute' , 'tl_class' => '' , 'attr_id' => $ attribute -> get ( 'id' ) , 'pid' => $ parentId , 'sorting' => $ sort , 'tstamp' => time ( ) , 'published' => $ activate ? '1' : '' ] ; } 
public function handle ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ options = [ ] ; foreach ( $ this -> conditionFactory -> getTypeNames ( ) as $ condition ) { $ options [ $ condition ] = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.conditionnames.' . $ condition , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; } $ event -> setOptions ( $ options ) ; } 
public function getTypeOfAttribute ( $ value ) { if ( ! isset ( self :: $ attributeTypes [ $ value ] ) ) { $ statement = $ this -> connection -> prepare ( 'SELECT type FROM tl_metamodel_attribute WHERE id=? LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ value ) ; $ statement -> execute ( ) ; self :: $ attributeTypes [ $ value ] = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) -> type ; } return self :: $ attributeTypes [ $ value ] ; } 
public function getMatchCount ( ModelInterface $ model = null , PropertyValueBag $ input = null ) { if ( $ input && $ input -> hasPropertyValue ( 'attr_id' ) ) { $ value = $ input -> getPropertyValue ( 'attr_id' ) ; } elseif ( $ model ) { $ value = $ model -> getProperty ( 'attr_id' ) ; } else { return false ; } return ( $ this -> getTypeOfAttribute ( $ value ) == $ this -> getAttributeType ( ) ) ? $ this -> getWeight ( ) : false ; } 
public static function withName ( $ columnName , $ tableName , $ code = 0 , $ previous = null ) { return new static ( sprintf ( 'Column "%s" already exists on table "%s' , $ columnName , $ tableName ) , $ code , $ previous ) ; } 
protected function getMetaModelFromModel ( ModelInterface $ model ) { if ( ! ( ( $ model -> getProviderName ( ) == 'tl_metamodel_dca_sortgroup' ) && $ model -> getProperty ( 'pid' ) ) ) { throw new DcGeneralInvalidArgumentException ( sprintf ( 'Model must originate from tl_metamodel_dca_sortgroup and be saved, this one originates from %s ' . 'and has pid %s' , $ model -> getProviderName ( ) , $ model -> getProperty ( 'pid' ) ) ) ; } $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'pid' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchColumn ( ) ; $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; return $ this -> factory -> getMetaModel ( $ tableName ) ; } 
public function match ( ModelInterface $ model = null , PropertyValueBag $ input = null , PropertyInterface $ property = null , LegendInterface $ legend = null ) { if ( $ property === null ) { return false ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; if ( $ metaModel -> hasVariants ( ) && ! $ nativeItem -> isVariantBase ( ) ) { return ! in_array ( $ property -> getName ( ) , array_keys ( $ metaModel -> getInVariantAttributes ( ) ) ) ; } return true ; } 
public function getOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ objMetaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ flags = IAttributeFactory :: FLAG_ALL_UNTRANSLATED ; if ( $ objMetaModel -> isTranslated ( ) ) { $ flags |= IAttributeFactory :: FLAG_INCLUDE_TRANSLATED ; } $ options = [ ] ; $ optionsTrans = [ ] ; foreach ( $ this -> attributeFactory -> getTypeNames ( $ flags ) as $ attributeType ) { 
protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) ) { return false ; } if ( $ event -> getPropertyName ( ) !== 'type' ) { return false ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> get ( 'act' , null ) === 'select' && ! $ event -> getModel ( ) -> getId ( ) ) { return false ; } return true ; } 
protected function validator ( $ varInput ) { if ( is_array ( $ varInput ) ) { $ value = array ( ) ; foreach ( $ varInput as $ key => $ input ) { $ value [ $ key ] = parent :: validator ( $ input ) ; } return $ value ; } return parent :: validator ( trim ( $ varInput ) ) ; } 
public function generate ( ) { $ return = '' ; for ( $ i = 0 ; $ i < $ this -> size ; $ i ++ ) { $ return .= sprintf ( '<input type="%s" name="%s[]" id="ctrl_%s_%s" class="text%s%s" value="%s"%s%s' , 'text' , $ this -> strName , $ this -> strId , $ i , '' , ( strlen ( $ this -> strClass ) ? ' ' . $ this -> strClass : '' ) , StringUtil :: specialchars ( $ this -> varValue [ $ i ] ) , $ this -> getAttributes ( ) , $ this -> strTagEnding ) ; } return $ return ; } 
public function handleDelete ( PreDeleteModelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } try { $ this -> tableManipulator -> checkTableExists ( $ tableName = $ event -> getModel ( ) -> getProperty ( 'tableName' ) ) ; } catch ( \ Exception $ exception ) { 
public function handleUpdate ( PostPersistModelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ old = $ event -> getOriginalModel ( ) ; $ new = $ event -> getModel ( ) ; $ oldTable = $ old ? $ old -> getProperty ( 'tableName' ) : null ; $ newTable = $ new -> getProperty ( 'tableName' ) ; 
public function removeButton ( GetSelectModeButtonsEvent $ event ) { if ( ( 'tl_metamodel_dcasetting' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'select' !== $ event -> getEnvironment ( ) -> getInputProvider ( ) -> getParameter ( 'act' ) ) ) { return ; } $ buttons = $ event -> getButtons ( ) ; unset ( $ buttons [ 'override' ] ) ; $ event -> setButtons ( $ buttons ) ; } 
public function addMetaModelNames ( $ metaModelNames ) { $ this -> metaModelNames = array_unique ( array_merge ( $ this -> metaModelNames , $ metaModelNames ) ) ; return $ this ; } 
public function load ( array $ configs , ContainerBuilder $ container ) { $ loader = new YamlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; foreach ( self :: $ files as $ file ) { $ loader -> load ( $ file ) ; } $ config = $ this -> processConfiguration ( $ this -> getConfiguration ( $ configs , $ container ) , $ configs ) ; $ this -> buildCacheService ( $ container , $ config ) ; $ container -> setParameter ( 'metamodels.resource_dir' , __DIR__ . '/../Resources' ) ; $ container -> setParameter ( 'metamodels.assets_dir' , $ config [ 'assets_dir' ] ) ; $ container -> setParameter ( 'metamodels.assets_web' , $ config [ 'assets_web' ] ) ; $ this -> buildPickerService ( $ container ) ; } 
private function buildCacheService ( ContainerBuilder $ container , array $ config ) { 
private function buildPickerService ( ContainerBuilder $ container ) { $ pickerService = $ container -> getDefinition ( 'metamodels.controller.picker' ) ; $ configs = $ pickerService -> getArgument ( 2 ) ; 
public function handle ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ tableName = $ model -> getProperty ( 'tableName' ) ; if ( ! ( $ model && ! empty ( $ tableName ) && $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ tableName ] ) ) ) { return ; } <span class="name"> <img src="bundles/metamodelscore/images/icons/%1$s" /> %2$s <span style="color:#b3b3b3; padding-left:3px">(%3$s)</span> <span style="color:#b3b3b3; padding-left:3px">[%4$s]</span> </span>' ) -> setArgs ( [ $ image , $ label , $ tableName , $ this -> translator -> trans ( $ transId , [ $ count ] , 'contao_tl_metamodel' ) ] ) ; } 
public static function createFromQueryBuilder ( QueryBuilder $ builder , $ columnName = 'id' ) { return new self ( $ builder -> getSQL ( ) , $ builder -> getParameters ( ) , $ columnName , $ builder -> getConnection ( ) , $ builder -> getParameterTypes ( ) ) ; } 
public function getMatchingIds ( ) { $ matches = $ this -> connection -> executeQuery ( $ this -> queryString , $ this -> params , $ this -> types ) ; $ ids = [ ] ; foreach ( $ matches -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ value ) { $ ids [ ] = $ value [ $ this -> idColumn ] ; } return $ ids ; } 
private function sanitizeConnection ( $ connection ) { if ( $ connection instanceof Connection ) { return $ connection ; } 
public function getServiceContainer ( ) { 
public function setServiceContainer ( $ serviceContainer , $ deprecationNotice = true ) { if ( $ deprecationNotice ) { 
protected function tryUnserialize ( $ value ) { if ( ! is_array ( $ value ) && 0 === strpos ( $ value , 'a:' ) && is_array ( $ unSerialized = unserialize ( $ value , [ 'allowed_classes' => false ] ) ) ) { return $ unSerialized ; } return $ value ; } 
public function addAttribute ( IAttribute $ objAttribute ) { if ( ! $ this -> hasAttribute ( $ objAttribute -> getColName ( ) ) ) { $ this -> arrAttributes [ $ objAttribute -> getColName ( ) ] = $ objAttribute ; } return $ this ; } 
protected function getAttributeImplementing ( $ interface ) { $ result = array ( ) ; foreach ( $ this -> getAttributes ( ) as $ colName => $ attribute ) { if ( $ attribute instanceof $ interface ) { $ result [ $ colName ] = $ attribute ; } } return $ result ; } 
protected function getMatchingIds ( $ objFilter ) { if ( $ objFilter ) { $ arrFilteredIds = $ objFilter -> getMatchingIds ( ) ; if ( $ arrFilteredIds !== null ) { return $ arrFilteredIds ; } } 
protected function fetchRows ( $ arrIds , $ arrAttrOnly = array ( ) ) { $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ query = $ builder -> select ( '*' ) -> from ( $ this -> getTableName ( ) ) -> where ( $ builder -> expr ( ) -> in ( 'id' , ':values' ) ) -> setParameter ( 'values' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'FIELD(id, :values)' ) -> execute ( ) ; 
protected function fetchTranslatedAttributeValues ( ITranslated $ attribute , $ ids ) { $ attributeData = $ attribute -> getTranslatedDataFor ( $ ids , $ this -> getActiveLanguage ( ) ) ; $ missing = array_diff ( $ ids , array_keys ( $ attributeData ) ) ; if ( $ missing ) { $ attributeData += $ attribute -> getTranslatedDataFor ( $ missing , $ this -> getFallbackLanguage ( ) ) ; } return $ attributeData ; } 
protected function fetchAdditionalAttributes ( $ ids , $ result , $ attrOnly = array ( ) ) { $ attributes = $ this -> getAttributeByNames ( $ attrOnly ) ; $ attributeNames = array_intersect ( array_keys ( $ attributes ) , array_keys ( array_merge ( $ this -> getComplexAttributes ( ) , $ this -> getTranslatedAttributes ( ) ) ) ) ; foreach ( $ attributeNames as $ attributeName ) { $ attribute = $ attributes [ $ attributeName ] ; $ attributeName = $ attribute -> getColName ( ) ; 
protected function getItemsWithId ( $ arrIds , $ arrAttrOnly = array ( ) ) { $ arrIds = array_unique ( array_filter ( $ arrIds ) ) ; if ( ! $ arrIds ) { return new Items ( array ( ) ) ; } if ( ! $ arrAttrOnly ) { $ arrAttrOnly = array_keys ( $ this -> getAttributes ( ) ) ; } $ arrResult = $ this -> fetchRows ( $ arrIds , $ arrAttrOnly ) ; 
protected function copyFilter ( $ objFilter ) { if ( $ objFilter ) { $ objNewFilter = $ objFilter -> createCopy ( ) ; } else { $ objNewFilter = $ this -> getEmptyFilter ( ) ; } return $ objNewFilter ; } 
public function get ( $ strKey ) { 
public function getInVariantAttributes ( ) { $ arrAttributes = $ this -> getAttributes ( ) ; if ( ! $ this -> hasVariants ( ) ) { return $ arrAttributes ; } 
public function getFallbackLanguage ( ) { if ( $ this -> isTranslated ( ) ) { foreach ( $ this -> arrData [ 'languages' ] as $ strLangCode => $ arrData ) { if ( $ arrData [ 'isfallback' ] ) { return $ strLangCode ; } } } return null ; } 
public function getAttributeById ( $ intId ) { foreach ( $ this -> getAttributes ( ) as $ objAttribute ) { if ( $ objAttribute -> get ( 'id' ) === $ intId ) { return $ objAttribute ; } } return null ; } 
protected function getAttributeByNames ( $ attrNames = array ( ) ) { if ( empty ( $ attrNames ) ) { return $ this -> arrAttributes ; } $ result = array ( ) ; foreach ( $ attrNames as $ attributeName ) { $ result [ $ attributeName ] = $ this -> arrAttributes [ $ attributeName ] ; } return $ result ; } 
public function findById ( $ intId , $ arrAttrOnly = array ( ) ) { if ( ! $ intId ) { return null ; } $ objItems = $ this -> getItemsWithId ( array ( $ intId ) , $ arrAttrOnly ) ; if ( $ objItems && $ objItems -> first ( ) ) { return $ objItems -> getItem ( ) ; } return null ; } 
public function findByFilter ( $ objFilter , $ strSortBy = '' , $ intOffset = 0 , $ intLimit = 0 , $ strSortOrder = 'ASC' , $ arrAttrOnly = array ( ) ) { return $ this -> getItemsWithId ( $ this -> getIdsFromFilter ( $ objFilter , $ strSortBy , $ intOffset , $ intLimit , $ strSortOrder ) , $ arrAttrOnly ) ; } 
public function getIdsFromFilter ( $ objFilter , $ strSortBy = '' , $ intOffset = 0 , $ intLimit = 0 , $ strSortOrder = 'ASC' ) { if ( [ ] === $ arrFilteredIds = array_filter ( $ this -> getMatchingIds ( $ objFilter ) ) ) { return [ ] ; } 
public function getCount ( $ objFilter ) { $ arrFilteredIds = $ this -> getMatchingIds ( $ objFilter ) ; if ( 0 === count ( $ arrFilteredIds ) ) { return 0 ; } $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; return $ builder -> select ( 'COUNT(id)' ) -> from ( $ this -> getTableName ( ) ) -> where ( $ builder -> expr ( ) -> in ( 'id' , ':values' ) ) -> setParameter ( 'values' , $ arrFilteredIds , Connection :: PARAM_STR_ARRAY ) -> execute ( ) -> fetch ( \ PDO :: FETCH_COLUMN ) ; } 
public function findVariantBase ( $ objFilter ) { $ objNewFilter = $ this -> copyFilter ( $ objFilter ) ; $ idList = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'id' ) -> from ( $ this -> getTableName ( ) ) -> where ( 'varbase=1' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; $ objNewFilter -> addFilterRule ( new StaticIdList ( $ idList ) ) ; return $ this -> findByFilter ( $ objNewFilter ) ; } 
public function findVariantsWithBase ( $ arrIds , $ objFilter ) { if ( ! $ arrIds ) { 
public function getAttributeOptions ( $ strAttribute , $ objFilter = null ) { $ objAttribute = $ this -> getAttribute ( $ strAttribute ) ; if ( $ objAttribute ) { if ( $ objFilter ) { $ arrFilteredIds = $ this -> getMatchingIds ( $ objFilter ) ; $ arrFilteredIds = $ objAttribute -> sortIds ( $ arrFilteredIds , 'ASC' ) ; return $ objAttribute -> getFilterOptions ( $ arrFilteredIds , true ) ; } else { return $ objAttribute -> getFilterOptions ( null , true ) ; } } return array ( ) ; } 
protected function saveSimpleColumn ( $ strColumn , $ arrIds , $ varData ) { if ( is_array ( $ varData ) ) { $ varData = serialize ( $ varData ) ; } $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ builder -> update ( $ this -> getTableName ( ) , 'v2' ) -> set ( 'v2.' . $ strColumn , is_array ( $ varData ) ? serialize ( $ varData ) : $ varData ) -> where ( $ builder -> expr ( ) -> in ( 'v2.id' , ':ids' ) ) -> setParameter ( 'ids' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> execute ( ) ; } 
protected function saveAttribute ( $ objAttribute , $ arrIds , $ varData , $ strLangCode ) { 
protected function updateVariants ( $ item , $ activeLanguage , $ allIds , $ baseAttributes = false ) { foreach ( $ this -> getAttributes ( ) as $ strAttributeId => $ objAttribute ) { 
protected function createNewItem ( $ item ) { $ data = [ 'tstamp' => $ item -> get ( 'tstamp' ) ] ; $ isNewItem = false ; if ( $ this -> hasVariants ( ) ) { 
public function saveItem ( $ objItem , $ timestamp = null ) { if ( null === $ timestamp ) { 
public function delete ( IItem $ objItem ) { $ arrIds = array ( $ objItem -> get ( 'id' ) ) ; 
public function prepareFilter ( $ intFilterSettings , $ arrFilterUrl ) { 
public function getView ( $ intViewId = 0 ) { 
private function getConnection ( ) { if ( $ this -> connection ) { return $ this -> connection ; } $ reflection = new \ ReflectionProperty ( \ Contao \ Database :: class , 'resConnection' ) ; $ reflection -> setAccessible ( true ) ; return $ this -> connection = $ reflection -> getValue ( $ this -> getDatabase ( ) ) ; } 
private function saveBaseColumns ( IItem $ item , $ timestamp ) { $ isNew = false ; $ item -> set ( 'tstamp' , $ timestamp ) ; if ( ! $ item -> get ( 'id' ) ) { $ isNew = true ; $ this -> createNewItem ( $ item ) ; } 
public function getInputScreenRenderMode ( $ value ) { if ( ! isset ( self :: $ stateBuffer [ $ value ] ) ) { $ statement = $ this -> connection -> prepare ( 'SELECT rendermode FROM tl_metamodel_dca WHERE id=? LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ value ) ; $ statement -> execute ( ) ; self :: $ stateBuffer [ $ value ] = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) -> rendermode ; } return self :: $ stateBuffer [ $ value ] ; } 
public function match ( ModelInterface $ model = null , PropertyValueBag $ input = null , PropertyInterface $ property = null , LegendInterface $ legend = null ) { if ( $ input && $ input -> hasPropertyValue ( 'pid' ) ) { $ value = $ input -> getPropertyValue ( 'pid' ) ; } elseif ( $ model ) { $ value = $ model -> getProperty ( 'pid' ) ; } else { return false ; } return $ this -> getInputScreenRenderMode ( $ value ) == $ this -> getRenderMode ( ) ; } 
public function getCombinationsForUser ( $ userGroups , $ userType ) { $ userType = strtolower ( $ userType ) ; if ( 'fe' !== $ userType && 'be' !== $ userType ) { throw new \ InvalidArgumentException ( 'Unknown user type: ' . $ userType ) ; } return $ this -> getCombinationsFromDatabase ( $ userGroups , $ userType ) ; } 
private function getCombinationsFromDatabase ( $ userGroups , $ userType ) { if ( empty ( $ userGroups ) ) { return null ; } $ builder = $ this -> connection -> createQueryBuilder ( ) ; $ combinations = $ builder -> select ( '*' ) -> from ( 'tl_metamodel_dca_combine' ) -> where ( $ builder -> expr ( ) -> in ( $ userType . '_group' , ':groupList' ) ) -> setParameter ( 'groupList' , $ userGroups , Connection :: PARAM_STR_ARRAY ) -> orWhere ( $ userType . '_group=0' ) -> orderBy ( 'pid' ) -> addOrderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ 'byName' => [ ] , 'byId' => [ ] ] ; foreach ( $ combinations as $ combination ) { $ metaModelId = $ combination [ 'pid' ] ; if ( isset ( $ result [ 'byId' ] [ $ metaModelId ] ) ) { continue ; } $ name = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; $ result [ 'byId' ] [ $ metaModelId ] = $ result [ 'byName' ] [ $ name ] = [ 'dca_id' => $ combination [ 'dca_id' ] , 'view_id' => $ combination [ 'view_id' ] ] ; } return $ result ; } 
protected function getLabelParameters ( EnvironmentInterface $ environment , ModelInterface $ model ) { if ( $ model -> getProperty ( 'type' ) == 'simplelookup' ) { return $ this -> getLabelParametersWithAttributeAndUrlParam ( $ environment , $ model ) ; } return $ this -> getLabelParametersNormal ( $ environment , $ model ) ; } 
public function delete ( $ varItem ) { 
protected function setLanguage ( $ language = '' ) { $ previousLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( ! empty ( $ language ) && ( $ GLOBALS [ 'TL_LANGUAGE' ] !== $ language ) ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ language ; } return $ previousLanguage ; } 
protected function getMetaModel ( ) { if ( ! $ this -> metaModel ) { if ( $ this -> metaModel === null ) { throw new \ RuntimeException ( 'No MetaModel instance set for ' . $ this -> strTable ) ; } } return $ this -> metaModel ; } 
public function fetch ( ConfigInterface $ objConfig ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; if ( $ objConfig -> getId ( ) !== null ) { $ modelId = $ objConfig -> getId ( ) ; } else { $ filter = $ this -> prepareFilter ( $ objConfig ) ; $ ids = $ this -> getIdsFromFilter ( $ filter , $ objConfig ) ; $ modelId = reset ( $ ids ) ; } $ objItem = $ modelId ? $ this -> getMetaModel ( ) -> findById ( $ modelId , $ objConfig -> getFields ( ) ? : array ( ) ) : null ; $ this -> setLanguage ( $ backupLanguage ) ; if ( ! $ objItem ) { return null ; } return new Model ( $ objItem ) ; } 
public function setBaseConfig ( array $ arrConfig ) { if ( ! $ arrConfig [ 'source' ] ) { throw new \ RuntimeException ( 'Missing table name.' ) ; } $ this -> strTable = $ arrConfig [ 'source' ] ; $ this -> metaModel = $ arrConfig [ 'metaModel' ] ; } 
public function getEmptyModel ( ) { if ( ! isset ( $ this -> dispatcher ) ) { 
protected function prepareFilter ( ConfigInterface $ configuration ) { if ( null === $ this -> connection ) { 
protected function extractSorting ( $ config ) { $ sorting = $ config -> getSorting ( ) ; $ sortBy = key ( $ sorting ) ; $ sortDir = current ( $ sorting ) ? : DCGE :: MODEL_SORTING_ASC ; return array ( $ sortBy , $ sortDir ) ; } 
protected function getIdsFromFilter ( $ filter , $ config ) { $ sorting = $ this -> extractSorting ( $ config ) ; return $ this -> getMetaModel ( ) -> getIdsFromFilter ( $ filter , $ sorting [ 0 ] , $ config -> getStart ( ) , $ config -> getAmount ( ) , strtoupper ( $ sorting [ 1 ] ) ) ; } 
protected function getItemsFromFilter ( $ filter , $ config ) { $ sorting = $ this -> extractSorting ( $ config ) ; return $ this -> getMetaModel ( ) -> findByFilter ( $ filter , $ sorting [ 0 ] , $ config -> getStart ( ) , $ config -> getAmount ( ) , strtoupper ( $ sorting [ 1 ] ) , $ config -> getFields ( ) ? : array ( ) ) ; } 
public function fetchAll ( ConfigInterface $ objConfig ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; $ filter = $ this -> prepareFilter ( $ objConfig ) ; if ( $ objConfig -> getIdOnly ( ) ) { $ this -> setLanguage ( $ backupLanguage ) ; return $ this -> getIdsFromFilter ( $ filter , $ objConfig ) ; } $ items = $ this -> getItemsFromFilter ( $ filter , $ objConfig ) ; $ collection = $ this -> getEmptyCollection ( ) ; foreach ( $ items as $ objItem ) { $ collection -> push ( new Model ( $ objItem ) ) ; } $ this -> setLanguage ( $ backupLanguage ) ; return $ collection ; } 
public function getFilterOptions ( ConfigInterface $ objConfig ) { $ arrProperties = $ objConfig -> getFields ( ) ; if ( count ( $ arrProperties ) <> 1 ) { throw new \ RuntimeException ( 'objConfig must contain exactly one property to be retrieved.' ) ; } $ objFilter = $ this -> prepareFilter ( $ objConfig ) ; $ arrValues = $ this -> getMetaModel ( ) -> getAttribute ( $ arrProperties [ 0 ] ) -> getFilterOptions ( $ objFilter -> getMatchingIds ( ) , true ) ; $ objCollection = new DefaultFilterOptionCollection ( ) ; foreach ( $ arrValues as $ strKey => $ strValue ) { $ objCollection -> add ( $ strKey , $ strValue ) ; } return $ objCollection ; } 
public function getCount ( ConfigInterface $ objConfig ) { $ objFilter = $ this -> prepareFilter ( $ objConfig ) ; return $ this -> getMetaModel ( ) -> getCount ( $ objFilter ) ; } 
public function isUniqueValue ( $ strField , $ varNew , $ intId = null ) { $ attribute = $ this -> getMetaModel ( ) -> getAttribute ( $ strField ) ; if ( $ attribute ) { $ matchingIds = $ this -> prepareFilter ( $ this -> getEmptyConfig ( ) -> setFilter ( array ( array ( 'operation' => '=' , 'property' => $ attribute -> getColName ( ) , 'value' => $ varNew ) ) ) ) -> getMatchingIds ( ) ; return ( count ( $ matchingIds ) == 0 ) || ( $ matchingIds == array ( $ intId ) ) ; } return false ; } 
public function resetFallback ( $ strField ) { 
public function save ( ModelInterface $ objItem , $ timestamp = null ) { if ( null === $ timestamp ) { 
public function saveEach ( CollectionInterface $ objItems , $ timestamp = 0 ) { if ( null === $ timestamp ) { 
public function sameModels ( $ objModel1 , $ objModel2 ) { if ( ! ( $ objModel1 instanceof Model && $ objModel2 instanceof Model ) ) { throw new \ InvalidArgumentException ( 'Passed models are not valid.' ) ; } $ objNative1 = $ objModel1 -> getItem ( ) ; $ objNative2 = $ objModel2 -> getItem ( ) ; if ( $ objNative1 -> getMetaModel ( ) === $ objNative2 -> getMetaModel ( ) ) { return true ; } foreach ( $ objNative1 -> getMetaModel ( ) -> getAttributes ( ) as $ objAttribute ) { if ( $ objNative1 -> get ( $ objAttribute -> getColName ( ) ) != $ objNative2 -> get ( $ objAttribute -> getColName ( ) ) ) { return false ; } } return true ; } 
public function createVariant ( ConfigInterface $ objConfig ) { $ objItem = $ this -> getMetaModel ( ) -> findById ( $ objConfig -> getId ( ) ) -> varCopy ( ) ; if ( ! $ objItem ) { return null ; } $ model = new Model ( $ objItem ) ; $ model -> setMeta ( $ model :: IS_CHANGED , true ) ; return $ model ; } 
public function getLanguages ( $ mixID ) { if ( ! $ this -> getMetaModel ( ) -> isTranslated ( ) ) { return null ; } $ collection = new DefaultLanguageInformationCollection ( ) ; foreach ( $ this -> getMetaModel ( ) -> getAvailableLanguages ( ) as $ langCode ) { list ( $ langCode , $ country ) = explode ( '_' , $ langCode , 2 ) ; $ collection -> add ( new DefaultLanguageInformation ( $ langCode , $ country ? : null ) ) ; } if ( count ( $ collection ) > 0 ) { return $ collection ; } return null ; } 
public function getFallbackLanguage ( $ mixID ) { if ( $ this -> getMetaModel ( ) -> isTranslated ( ) ) { $ langCode = $ this -> getMetaModel ( ) -> getFallbackLanguage ( ) ; list ( $ langCode , $ country ) = explode ( '_' , $ langCode , 2 ) ; return new DefaultLanguageInformation ( $ langCode , $ country ? : null ) ; } return null ; } 
public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values , [ 'allowed_classes' => false ] ) ) ; } 
public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ values = Helper :: encodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( $ values ) ; } 
public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) -> getName ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_langcode' , [ ] , 'contao_tl_metamodel_attribute' ) , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_value' , [ ] , 'contao_tl_metamodel_attribute' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) -> getName ( ) ) , true ) ) ; } 
public function prepareSubPalettes ( BuildDataDefinitionEvent $ event ) { $ container = $ event -> getContainer ( ) ; if ( $ container -> getName ( ) !== 'tl_metamodel_filtersetting' ) { return ; } foreach ( $ this -> filterFactory -> getTypeNames ( ) as $ filterType ) { $ paletteName = $ filterType . '_palettes' ; if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_metamodel_filtersetting' ] [ $ paletteName ] ) ) { continue ; } $ palettes = $ container -> getPalettesDefinition ( ) ; $ typeLegends = $ GLOBALS [ 'TL_DCA' ] [ 'tl_metamodel_filtersetting' ] [ $ paletteName ] ; foreach ( $ palettes -> getPalettes ( ) as $ palette ) { $ this -> createConditionsForPalette ( $ palette , $ typeLegends ) ; } } } 
private function createConditionsForPalette ( PaletteInterface $ palette , array $ typeLegends ) { $ conditions = [ ] ; foreach ( $ typeLegends as $ value => $ legends ) { 
private function getLegend ( PaletteInterface $ palette , $ legendName ) { if ( $ palette -> hasLegend ( $ legendName ) ) { return $ palette -> getLegend ( $ legendName ) ; } $ legend = new Legend ( $ legendName ) ; $ palette -> addLegend ( $ legend ) ; return $ legend ; } 
private function getConditionChain ( LegendInterface $ legend , $ propertyName , array & $ conditions ) { 
private function getLegendProperty ( LegendInterface $ legend , $ propertyName ) { if ( $ legend -> hasProperty ( $ propertyName ) ) { $ property = $ legend -> getProperty ( $ propertyName ) ; } else { $ property = new Property ( $ propertyName ) ; $ legend -> addProperty ( $ property ) ; } return $ property ; } 
private function getVisibleCondition ( $ property ) { $ condition = $ property -> getVisibleCondition ( ) ; if ( $ condition instanceof PropertyConditionChain ) { return $ condition ; } $ conditionChain = new PropertyConditionChain ( ) ; $ property -> setVisibleCondition ( $ conditionChain ) ; if ( $ condition ) { $ conditionChain -> addCondition ( $ condition ) ; } return $ conditionChain ; } 
protected function populate ( EnvironmentInterface $ environment ) { $ translator = $ environment -> getTranslator ( ) ; if ( ! ( $ translator instanceof TranslatorChain ) ) { $ translatorChain = new TranslatorChain ( ) ; $ translatorChain -> add ( $ translator ) ; $ environment -> setTranslator ( $ translatorChain ) ; } else { $ translatorChain = $ translator ; } $ translatorChain -> add ( $ translator = new StaticTranslator ( ) ) ; 
private function mapTranslations ( $ array , $ domain , StaticTranslator $ translator , $ baseKey = '' ) { foreach ( $ array as $ key => $ value ) { $ newKey = ( $ baseKey ? $ baseKey . '.' : '' ) . $ key ; if ( is_array ( $ value ) ) { $ this -> mapTranslations ( $ value , $ domain , $ translator , $ newKey ) ; } else { $ translator -> setValue ( $ newKey , $ value , $ domain ) ; } } } 
private function addInputScreenTranslations ( StaticTranslator $ translator , $ inputScreen , $ containerName ) { $ currentLocale = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ inputScreen [ 'legends' ] as $ legendName => $ legendInfo ) { foreach ( $ legendInfo [ 'label' ] as $ langCode => $ label ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName , $ langCode ) ; if ( $ currentLocale === $ langCode ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName ) ; } } } } 
public function handle ( GetPropertyOptionsEvent $ event ) { if ( ( 'tl_metamodel_filtersetting' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'defaultid' !== $ event -> getPropertyName ( ) ) ) { return ; } $ model = $ event -> getModel ( ) ; if ( ! ( $ attributeId = $ model -> getProperty ( 'attr_id' ) ) ) { return ; } if ( null === $ metaModel = $ this -> filterFactory -> createCollection ( $ model -> getProperty ( 'fid' ) ) -> getMetaModel ( ) ) { return ; } if ( null === $ attribute = $ metaModel -> getAttributeById ( $ attributeId ) ) { return ; } $ event -> setOptions ( $ this -> getOptions ( $ attribute , $ model -> getProperty ( 'onlyused' ) ? true : false ) ) ; } 
private function getOptions ( $ attribute , $ onlyUsed ) { 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'metamodels' ) ; $ rootNode -> children ( ) -> booleanNode ( 'enable_cache' ) -> defaultValue ( ! $ this -> debug ) -> end ( ) -> scalarNode ( 'cache_dir' ) -> defaultValue ( '%kernel.cache_dir%' . DIRECTORY_SEPARATOR . 'metamodels' ) -> end ( ) -> scalarNode ( 'assets_dir' ) -> cannotBeEmpty ( ) -> defaultValue ( $ this -> resolvePath ( $ this -> rootDir . '/assets/metamodels' ) ) -> validate ( ) -> always ( function ( $ value ) { return $ this -> resolvePath ( $ value ) ; } ) -> end ( ) -> end ( ) -> scalarNode ( 'assets_web' ) -> cannotBeEmpty ( ) -> defaultValue ( 'assets/metamodels' ) -> end ( ) -> end ( ) ; return $ treeBuilder ; } 
private function resolvePath ( $ value ) { $ path = Path :: canonicalize ( $ value ) ; if ( '\\' === DIRECTORY_SEPARATOR ) { $ path = str_replace ( '/' , '\\' , $ path ) ; } return $ path ; } 
public function setServiceContainer ( IMetaModelsServiceContainer $ serviceContainer , $ deprecationNotice = true ) { if ( $ deprecationNotice ) { 
public function collectAttributeSettings ( IMetaModel $ metaModel , $ renderSetting ) { $ attributeRows = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_rendersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' ) -> setParameter ( 'pid' , $ renderSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ attributeRows -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ attributeRow ) { $ attribute = $ metaModel -> getAttributeById ( $ attributeRow [ 'attr_id' ] ) ; if ( ! $ attribute ) { continue ; } $ attributeSetting = $ renderSetting -> getSetting ( $ attribute -> getColName ( ) ) ; if ( ! $ attributeSetting ) { $ attributeSetting = $ attribute -> getDefaultRenderSettings ( ) ; } foreach ( $ attributeRow as $ strKey => $ varValue ) { if ( $ varValue ) { $ attributeSetting -> set ( $ strKey , StringUtil :: deserialize ( $ varValue ) ) ; } } $ renderSetting -> setSetting ( $ attribute -> getColName ( ) , $ attributeSetting ) ; } } 
protected function internalCreateRenderSetting ( IMetaModel $ metaModel , $ settingId ) { $ row = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_rendersettings' ) -> where ( 'pid=:pid' ) -> andWhere ( 'id=:id' ) -> setParameter ( 'pid' , $ metaModel -> get ( 'id' ) ) -> setParameter ( 'id' , $ settingId ? : 0 ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( ! $ row ) { $ row = [ ] ; } $ renderSetting = new Collection ( $ metaModel , $ row , $ this -> eventDispatcher , $ this -> filterFactory , $ this -> filterUrlBuilder ) ; if ( $ renderSetting -> get ( 'id' ) ) { $ this -> collectAttributeSettings ( $ metaModel , $ renderSetting ) ; } return $ renderSetting ; } 
public function createCollection ( IMetaModel $ metaModel , $ settingId = '' ) { $ tableName = $ metaModel -> getTableName ( ) ; if ( ! isset ( $ this -> renderSettings [ $ tableName ] ) ) { $ this -> renderSettings [ $ tableName ] = array ( ) ; } if ( ! isset ( $ this -> renderSettings [ $ tableName ] [ $ settingId ] ) ) { $ this -> renderSettings [ $ tableName ] [ $ settingId ] = $ this -> internalCreateRenderSetting ( $ metaModel , $ settingId ) ; } return $ this -> renderSettings [ $ tableName ] [ $ settingId ] ; } 
protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! $ this -> scopeDeterminator -> currentScopeIsBackend ( ) ) { return false ; } $ environment = $ event -> getEnvironment ( ) ; if ( 'tl_metamodel_rendersetting' !== $ environment -> getDataDefinition ( ) -> getName ( ) ) { return false ; } if ( $ event instanceof AbstractModelAwareEvent ) { if ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== $ event -> getModel ( ) -> getProviderName ( ) ) { return false ; } } return true ; } 
public function buildCondition ( array $ configuration , IMetaModel $ metaModel ) { return new PropertyValueCondition ( $ this -> attributeIdToName ( $ metaModel , $ configuration [ 'attr_id' ] ) , $ configuration [ 'value' ] ) ; } 
public function fixupModules ( DataContainer $ dataContainer ) { if ( ! class_exists ( 'tl_user_group' , false ) ) { throw new \ RuntimeException ( 'data container is not loaded!' ) ; } $ original = new \ tl_user_group ( ) ; $ modules = $ original -> getModules ( ) ; 
private function buildLanguageString ( $ name , $ screen , $ locale ) { if ( isset ( $ screen [ 'label' ] [ $ locale ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ $ locale ] ; return ; } $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ '' ] ; } 
public function match ( ModelInterface $ model = null , PropertyValueBag $ input = null , PropertyInterface $ property = null , LegendInterface $ legend = null ) { if ( ! $ model || ! $ model -> getProperty ( 'attr_id' ) ) { return false ; } $ metaModel = $ this -> getMetaModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( ! $ attribute ) { return false ; } return $ attribute -> get ( 'type' ) === $ this -> filterType ; } 
private function getMetaModel ( ModelInterface $ model ) { $ filterSetting = $ this -> filterFactory -> createCollection ( $ model -> getProperty ( 'fid' ) ) ; return $ filterSetting -> getMetaModel ( ) ; } 
public function handle ( BuildDataDefinitionEvent $ event ) { if ( ( $ event -> getContainer ( ) -> getName ( ) !== 'tl_metamodel_rendersetting' ) ) { return ; } $ palettes = $ event -> getContainer ( ) -> getPalettesDefinition ( ) ; foreach ( $ palettes -> getPalettes ( ) as $ palette ) { if ( $ palette -> getName ( ) !== 'default' ) { $ paletteCondition = $ palette -> getCondition ( ) ; if ( ! ( $ paletteCondition instanceof ConditionChainInterface ) || ( $ paletteCondition -> getConjunction ( ) !== PaletteConditionChain :: OR_CONJUNCTION ) ) { $ paletteCondition = new PaletteConditionChain ( $ paletteCondition ? array ( $ paletteCondition ) : array ( ) , PaletteConditionChain :: OR_CONJUNCTION ) ; $ palette -> setCondition ( $ paletteCondition ) ; } $ paletteCondition -> addCondition ( new PaletteCondition ( $ palette -> getName ( ) , 1 , $ this -> connection ) ) ; } $ this -> buildMetaPaletteConditions ( $ palette , ( array ) $ GLOBALS [ 'TL_DCA' ] [ 'tl_metamodel_rendersetting' ] [ 'metapalettes' ] ) ; } } 
private function buildMetaPaletteConditions ( $ palette , $ metaPalettes ) { foreach ( $ metaPalettes as $ typeName => $ paletteInfo ) { if ( 'default' === $ typeName ) { continue ; } if ( preg_match ( '#^(\w+) extends (\w+)$#' , $ typeName , $ matches ) ) { $ typeName = $ matches [ 1 ] ; } foreach ( $ paletteInfo as $ legendName => $ properties ) { foreach ( $ properties as $ propertyName ) { $ condition = new AttributeByIdIsOfType ( $ typeName , $ this -> connection , 'attr_id' ) ; $ legend = $ this -> getLegend ( $ legendName , $ palette ) ; $ property = $ this -> getProperty ( $ propertyName , $ legend ) ; $ this -> addCondition ( $ property , $ condition ) ; } } } } 
public function getTypeNames ( ) { $ names = $ this -> factories -> ids ( ) ; if ( [ ] !== $ fallback = $ this -> fallbackFactory -> getIds ( ) ) { $ names = array_unique ( array_merge ( $ fallback , $ names ) ) ; } return $ names ; } 
public function supportsNesting ( $ conditionType ) { $ factory = $ this -> factories -> has ( $ conditionType ) ? $ this -> getFactory ( $ conditionType ) : null ; return ( $ factory instanceof NestablePropertyConditionFactoryInterface ) || ( bool ) $ this -> fallbackFactory -> supportsNesting ( $ conditionType ) ; } 
public function maxChildren ( $ conditionType ) { $ factory = $ this -> factories -> has ( $ conditionType ) ? $ this -> getFactory ( $ conditionType ) : null ; if ( ! $ factory instanceof NestablePropertyConditionFactoryInterface ) { if ( null !== $ value = $ this -> fallbackFactory -> maxChildren ( $ conditionType ) ) { return $ value ; } return 0 ; } return $ factory -> maxChildren ( ) ; } 
public function supportsAttribute ( $ conditionType , $ attribute ) { $ factory = $ this -> factories -> has ( $ conditionType ) ? $ this -> getFactory ( $ conditionType ) : null ; return ( ( $ factory instanceof AttributeAwarePropertyConditionFactoryInterface ) && $ factory -> supportsAttribute ( $ attribute ) ) || ( bool ) $ this -> fallbackFactory -> supportsAttribute ( $ conditionType , $ attribute ) ; } 
public function createCondition ( array $ configuration , IMetaModel $ metaModel ) { if ( ! isset ( $ configuration [ 'type' ] ) ) { throw new \ InvalidArgumentException ( 'No type given in configuration' ) ; } if ( ! $ this -> factories -> has ( $ typeName = $ configuration [ 'type' ] ) ) { if ( $ result = $ this -> fallbackFactory -> createCondition ( $ configuration , $ metaModel ) ) { return $ result ; } throw new \ InvalidArgumentException ( 'Unknown type: ' . $ typeName ) ; } return $ this -> getFactory ( $ typeName ) -> buildCondition ( $ configuration , $ metaModel ) ; } 
public function run ( ) { $ template = new BackendTemplate ( 'be_dcastylepicker' ) ; $ template -> main = '' ; $ template -> headline = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodelspicker' ] ; $ inputName = Input :: get ( 'inputName' ) ; if ( ! preg_match ( '~^[a-z\-_0-9]+$~i' , $ inputName ) ) { throw new RuntimeException ( 'Field-Parameter ERROR!' ) ; } $ template -> field = $ inputName ; $ template -> items = $ GLOBALS [ Input :: get ( 'item' ) ] ; if ( ! strlen ( $ template -> headline ) ) { $ template -> headline = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; } $ template -> theme = Backend :: getTheme ( ) ; $ template -> base = Environment :: get ( 'base' ) ; $ template -> language = $ GLOBALS [ 'TL_LANGUAGE' ] ; $ template -> title = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; $ template -> charset = $ GLOBALS [ 'TL_CONFIG' ] [ 'characterSet' ] ; $ template -> pageOffset = Input :: cookie ( 'BE_PAGE_OFFSET' ) ; $ template -> error = ( Input :: get ( 'act' ) == 'error' ) ? $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] : '' ; $ template -> skipNavigation = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'skipNavigation' ] ; $ template -> request = ampersand ( Environment :: get ( 'request' ) ) ; $ template -> top = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backToTop' ] ; $ template -> be27 = ! $ GLOBALS [ 'TL_CONFIG' ] [ 'oldBeTheme' ] ; $ template -> expandNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] ; $ template -> collapseNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] ; $ template -> strField = Input :: get ( 'fld' ) ; $ template -> output ( ) ; } 
public function handle ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getPropertyName ( ) !== 'template' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( ! $ attribute ) { return ; } $ event -> setOptions ( $ this -> templateList -> getTemplatesForBase ( 'mm_attr_' . $ attribute -> get ( 'type' ) ) ) ; } 
protected function getParamName ( ) { if ( $ this -> get ( 'urlparam' ) ) { return $ this -> get ( 'urlparam' ) ; } $ objAttribute = $ this -> getFilteredAttribute ( ) ; if ( $ objAttribute ) { return $ objAttribute -> getColName ( ) ; } return null ; } 
protected function getLabel ( ) { if ( null === ( $ attribute = $ this -> getFilteredAttribute ( ) ) ) { return null ; } if ( $ label = $ this -> get ( 'label' ) ) { return $ label ; } return $ attribute -> getName ( ) ; } 
protected function getParameterFilterOptions ( $ objAttribute , $ arrIds , & $ arrCount = null ) { $ arrOptions = $ objAttribute -> getFilterOptions ( $ this -> get ( 'onlypossible' ) ? $ arrIds : null , ( bool ) $ this -> get ( 'onlyused' ) , $ arrCount ) ; 
public function prepareRules ( IFilter $ objFilter , $ arrFilterUrl ) { $ objMetaModel = $ this -> getMetaModel ( ) ; $ objAttribute = $ this -> getFilteredAttribute ( ) ; $ strParam = $ this -> getParamName ( ) ; if ( $ objAttribute && $ strParam ) { if ( $ arrFilterValue = $ this -> determineFilterValue ( $ arrFilterUrl , $ strParam ) ) { if ( $ objMetaModel -> isTranslated ( ) && $ this -> get ( 'all_langs' ) ) { $ arrLanguages = $ objMetaModel -> getAvailableLanguages ( ) ; } else { $ arrLanguages = array ( $ objMetaModel -> getActiveLanguage ( ) ) ; } $ objFilterRule = new FilterRuleSimpleLookup ( $ objAttribute , $ arrFilterValue , $ arrLanguages ) ; $ objFilter -> addFilterRule ( $ objFilterRule ) ; return ; } 
public function generateFilterUrlFrom ( IItem $ objItem , IRenderSettings $ objRenderSetting ) { if ( $ attribute = $ this -> getFilteredAttribute ( ) ) { return [ $ this -> getParamName ( ) => $ attribute -> getFilterUrlValue ( $ objItem -> get ( $ attribute -> getColName ( ) ) ) ] ; } return [ ] ; } 
public function getParameterDCA ( ) { 
public function getParameterFilterWidgets ( $ arrIds , $ arrFilterUrl , $ arrJumpTo , FrontendFilterOptions $ objFrontendFilterOptions ) { 
protected function getFilteredAttribute ( ) { if ( ! ( $ attributeId = $ this -> get ( 'attr_id' ) ) ) { return null ; } if ( $ attribute = $ this -> getMetaModel ( ) -> getAttributeById ( $ attributeId ) ) { return $ attribute ; } return null ; } 
private function determineFilterValue ( $ filterValues , $ valueName ) { if ( ! isset ( $ filterValues [ $ valueName ] ) && $ this -> get ( 'defaultid' ) ) { return $ this -> get ( 'defaultid' ) ; } return $ filterValues [ $ valueName ] ; } 
public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ image = '<img src="' . $ this -> attributeFactory -> getIconForType ( $ type ) . '" />' ; $ metaModel = $ this -> getMetaModelByModelPid ( $ model ) ; $ attribute = $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ metaModel ) ; if ( ! $ attribute ) { $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> <strong>%s</strong><br /> </div>' ) -> setArgs ( array ( $ translator -> translate ( 'error_unknown_attribute.0' , 'tl_metamodel_attribute' ) , $ type , $ translator -> translate ( 'error_unknown_attribute.1' , 'tl_metamodel_attribute' , array ( $ type ) ) , ) ) ; return ; } $ colName = $ attribute -> getColName ( ) ; $ name = $ attribute -> getName ( ) ; $ arrDescription = StringUtil :: deserialize ( $ attribute -> get ( 'description' ) ) ; if ( is_array ( $ arrDescription ) ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getActiveLanguage ( ) ] ; if ( ! $ description ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; } } else { $ description = $ arrDescription ? : $ attribute -> getName ( ) ; } $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong> - %s </div>' ) -> setArgs ( array ( $ colName , $ type , $ image , $ name , $ description ) ) ; } 
protected function compile ( ) { $ blnActiveParam = false ; $ arrPage = $ GLOBALS [ 'objPage' ] -> row ( ) ; $ arrGetParameters = array ( ) ; foreach ( array_keys ( $ _GET ) as $ mixGetKey ) { if ( in_array ( $ mixGetKey , $ GLOBALS [ 'MM_FILTER_PARAMS' ] ) ) { $ blnActiveParam = true ; continue ; } $ arrGetParameters [ $ mixGetKey ] = \ Input :: get ( $ mixGetKey , false , true ) ; } 
public function generateReal ( ) { 
protected function getJumpToUrl ( $ arrParams ) { $ strFilterAction = '' ; foreach ( $ arrParams as $ strName => $ varParam ) { 
protected function getBreadcrumbElements ( EnvironmentInterface $ environment , BreadcrumbStore $ elements ) { if ( ! $ elements -> hasId ( 'tl_metamodel_dcasetting' ) ) { $ elements -> setId ( 'tl_metamodel_dcasetting' , $ this -> extractIdFrom ( $ environment , 'pid' ) ) ; } parent :: getBreadcrumbElements ( $ environment , $ elements ) ; $ builder = UrlBuilder :: fromUrl ( $ elements -> getUri ( ) ) -> setQueryParameter ( 'do' , 'metamodels' ) -> setQueryParameter ( 'table' , 'tl_metamodel_dcasetting_condition' ) -> setQueryParameter ( 'pid' , ModelId :: fromValues ( 'tl_metamodel_dcasetting' , $ elements -> getId ( 'tl_metamodel_dcasetting' ) ) -> getSerialized ( ) ) -> unsetQueryParameter ( 'act' ) -> unsetQueryParameter ( 'id' ) ; $ elements -> push ( ampersand ( $ builder -> getUrl ( ) ) , sprintf ( $ elements -> getLabel ( 'tl_metamodel_dcasetting_condition' ) , $ this -> getConditionAttribute ( $ elements -> getId ( 'tl_metamodel_dcasetting' ) ) ) , 'bundles/metamodelscore/images/icons/dca_condition.png' ) ; } 
private function getConditionAttribute ( $ settingId ) { $ setting = $ this -> getRow ( $ settingId , 'tl_metamodel_dcasetting' ) ; if ( $ setting -> dcatype == 'attribute' ) { $ attribute = ( object ) $ this -> getRow ( $ setting -> attr_id , 'tl_metamodel_attribute' ) ; $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ attribute -> pid ) ; $ attribute = $ this -> factory -> getMetaModel ( $ metaModelName ) -> getAttributeById ( $ attribute -> id ) ; if ( $ attribute ) { return $ attribute -> getName ( ) ; } } else { $ title = StringUtil :: deserialize ( $ setting -> legendtitle , true ) ; return isset ( $ title [ $ GLOBALS [ 'TL_LANGUAGE' ] ] ) ? $ title [ $ GLOBALS [ 'TL_LANGUAGE' ] ] : current ( $ title ) ; } return 'unknown ' . $ setting -> dcatype ; } 
public function handle ( BuildDataDefinitionEvent $ event ) { if ( ( $ event -> getContainer ( ) -> getName ( ) !== 'tl_metamodel_dcasetting' ) ) { return ; } $ palettes = $ event -> getContainer ( ) -> getPalettesDefinition ( ) ; $ legend = null ; $ subSelectPalettes = $ this -> getSubSelectPalettes ( ) ; foreach ( $ palettes -> getPalettes ( ) as $ palette ) { $ condition = new PropertyValueCondition ( 'dcatype' , 'attribute' ) ; $ legend = $ this -> getLegend ( 'functions' , $ palette , $ legend ) ; $ property = $ this -> getProperty ( 'readonly' , $ legend ) ; $ this -> addCondition ( $ property , $ condition ) ; $ legend = $ this -> getLegend ( 'title' , $ palette , $ legend ) ; $ property = $ this -> getProperty ( 'attr_id' , $ legend ) ; $ this -> addCondition ( $ property , $ condition ) ; $ condition = new PropertyValueCondition ( 'dcatype' , 'legend' ) ; $ legend = $ this -> getLegend ( 'title' , $ palette ) ; $ property = $ this -> getProperty ( 'legendtitle' , $ legend ) ; $ this -> addCondition ( $ property , $ condition ) ; $ property = $ this -> getProperty ( 'legendhide' , $ legend ) ; $ this -> addCondition ( $ property , $ condition ) ; foreach ( $ subSelectPalettes as $ typeName => $ paletteInfo ) { foreach ( $ paletteInfo as $ legendName => $ properties ) { foreach ( $ properties as $ propertyName ) { $ condition = new AttributeByIdIsOfType ( $ typeName , $ this -> connection , 'attr_id' ) ; $ legend = $ this -> getLegend ( $ legendName , $ palette ) ; $ property = $ this -> getProperty ( $ propertyName , $ legend ) ; $ this -> addCondition ( $ property , $ condition ) ; } } } } } 
public function handle ( GetPasteButtonEvent $ event ) { $ model = $ event -> getModel ( ) ; if ( ( 'tl_metamodel_filtersetting' !== $ model -> getProviderName ( ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ model = $ event -> getModel ( ) ; $ clipboard = $ environment -> getClipboard ( ) ; $ filter = Filter :: create ( ) -> andModelIs ( ModelId :: fromModel ( $ model ) ) -> andActionIs ( ItemInterface :: CUT ) ; 
public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getProperty ( ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ dataProvider = $ environment -> getDataProvider ( ) ; $ properties = $ environment -> getDataDefinition ( ) -> getPropertiesDefinition ( ) ; $ values = ( array ) $ event -> getValue ( ) ; foreach ( $ values as $ row => $ current ) { $ values [ $ row ] = $ this -> updateValues ( $ current , $ properties , $ dataProvider ) ; } $ event -> setValue ( $ values ) ; } 
private function updateValues ( array & $ values , PropertiesDefinitionInterface $ properties , DataProviderInterface $ dataProvider ) { foreach ( $ values as $ propertyName => $ propertyValue ) { if ( ( $ dataProvider -> getIdProperty ( ) === $ propertyName ) || ( $ dataProvider -> getGroupColumnProperty ( ) === $ propertyName ) || ( $ dataProvider -> getSortingColumnProperty ( ) === $ propertyName ) || ( $ dataProvider -> getTimeStampProperty ( ) === $ propertyName ) || ! $ properties -> hasProperty ( $ propertyName ) ) { continue ; } $ values [ $ propertyName ] = ModelManipulator :: sanitizeValue ( $ properties -> getProperty ( $ propertyName ) , $ propertyValue ) ; } return $ values ; } 
public function buildCondition ( array $ configuration , IMetaModel $ metaModel ) { 
public function handle ( GetOperationButtonEvent $ event ) { if ( ! $ event -> getEnvironment ( ) -> getDataDefinition ( ) instanceof IMetaModelDataDefinition ) { return ; } $ command = $ event -> getCommand ( ) ; if ( $ command -> getName ( ) === 'cut' ) { $ sortingProperty = ViewHelpers :: getManualSortingProperty ( $ event -> getEnvironment ( ) ) ; if ( ! $ sortingProperty ) { $ event -> setDisabled ( true ) ; } } } 
public function match ( ModelInterface $ model = null , PropertyValueBag $ input = null , PropertyInterface $ property = null , LegendInterface $ legend = null ) { $ propertyName = $ this -> getTablePropertyName ( ) ; if ( $ input && $ input -> hasPropertyValue ( $ propertyName ) ) { $ value = $ input -> getPropertyValue ( $ propertyName ) ; } elseif ( $ model ) { $ value = $ model -> getProperty ( $ propertyName ) ; } else { return false ; } return $ this -> desiredValue == ( substr ( $ value , 0 , 3 ) === 'mm_' ) ; } 
public function addListener ( $ eventName , $ listener , $ priority = 200 ) { $ dispatcher = $ this -> getServiceContainer ( ) -> getEventDispatcher ( ) ; $ dispatcher -> addListener ( $ eventName , $ listener , $ priority ) ; return $ this ; } 
protected function getMetaModelById ( $ modelId ) { $ services = $ this -> getServiceContainer ( ) ; $ modelFactory = $ services -> getFactory ( ) ; $ name = $ modelFactory -> translateIdToMetaModelName ( $ modelId ) ; return $ modelFactory -> getMetaModel ( $ name ) ; } 
public static function calculateConditions ( IMetaModelDataDefinition $ container , array $ inputScreen ) { if ( $ container -> hasDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ) { $ definition = $ container -> getDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ; } else { $ definition = new DefaultModelRelationshipDefinition ( ) ; $ container -> setDefinition ( ModelRelationshipDefinitionInterface :: NAME , $ definition ) ; } if ( ! $ definition instanceof ModelRelationshipDefinitionInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } $ instance = new static ( ) ; $ instance -> container = $ container ; $ instance -> inputScreen = $ inputScreen ; $ instance -> definition = $ definition ; $ instance -> calculate ( ) ; } 
protected function addParentCondition ( ) { if ( $ this -> inputScreen [ 'meta' ] [ 'rendertype' ] === 'standalone' ) { return ; } $ setter = [ [ 'to_field' => 'pid' , 'from_field' => 'id' ] ] ; $ inverse = [ ] ; $ relationship = $ this -> definition -> getChildCondition ( $ this -> inputScreen [ 'meta' ] [ 'ptable' ] , $ this -> container -> getName ( ) ) ; if ( ! $ relationship instanceof ParentChildConditionInterface ) { $ relationship = new ParentChildCondition ( ) ; $ relationship -> setSourceName ( $ this -> inputScreen [ 'meta' ] [ 'ptable' ] ) -> setDestinationName ( $ this -> container -> getName ( ) ) ; $ this -> definition -> addChildCondition ( $ relationship ) ; } else { $ setter = array_merge_recursive ( $ setter , $ relationship -> getSetters ( ) ) ; $ inverse = array_merge_recursive ( $ inverse , $ relationship -> getInverseFilterArray ( ) ) ; } 
protected function addHierarchicalConditions ( ) { 
protected function getRootCondition ( ) { $ rootProvider = $ this -> container -> getName ( ) ; if ( ( $ relationship = $ this -> definition -> getRootCondition ( ) ) === null ) { $ relationship = new RootCondition ( ) ; $ relationship -> setSourceName ( $ rootProvider ) ; $ this -> definition -> setRootCondition ( $ relationship ) ; } return $ relationship ; } 
private function buildWhere ( QueryBuilder $ queryBuilder , $ mixIds , $ mixLangCode = '' ) { $ queryBuilder -> andWhere ( 'att_id = :att_id' ) -> setParameter ( 'att_id' , $ this -> get ( 'id' ) ) ; if ( ! empty ( $ mixIds ) ) { if ( is_array ( $ mixIds ) ) { $ queryBuilder -> andWhere ( 'item_id IN (:item_ids)' ) -> setParameter ( 'item_ids' , $ mixIds , Connection :: PARAM_STR_ARRAY ) ; } else { $ queryBuilder -> andWhere ( 'item_id = :item_id' ) -> setParameter ( 'item_id' , $ mixIds ) ; } } if ( ! empty ( $ mixLangCode ) ) { if ( is_array ( $ mixLangCode ) ) { $ queryBuilder -> andWhere ( 'langcode IN (:langcode)' ) -> setParameter ( 'langcode' , $ mixLangCode , Connection :: PARAM_STR_ARRAY ) ; } else { $ queryBuilder -> andWhere ( 'langcode = :langcode' ) -> setParameter ( 'langcode' , $ mixLangCode ) ; } } } 
protected function getSetValues ( $ arrValue , $ intId , $ strLangCode ) { if ( ( $ arrValue !== null ) && ! is_array ( $ arrValue ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid value provided: %s' , var_export ( $ arrValue , true ) ) ) ; } return array ( 'tstamp' => time ( ) , 'value' => ( string ) $ arrValue [ 'value' ] , 'att_id' => $ this -> get ( 'id' ) , 'langcode' => $ strLangCode , 'item_id' => $ intId , ) ; } 
public function getDataFor ( $ arrIds ) { $ strActiveLanguage = $ this -> getMetaModel ( ) -> getActiveLanguage ( ) ; $ strFallbackLanguage = $ this -> getMetaModel ( ) -> getFallbackLanguage ( ) ; $ arrReturn = $ this -> getTranslatedDataFor ( $ arrIds , $ strActiveLanguage ) ; 
private function determineLanguages ( ) { $ languages = $ this -> getMetaModel ( ) -> getAvailableLanguages ( ) ; if ( $ languages === null ) { throw new \ RuntimeException ( 'MetaModel ' . $ this -> getMetaModel ( ) -> getName ( ) . ' does not seem to be translated.' ) ; } return $ languages ; } 
public function setDataFor ( $ arrValues ) { foreach ( $ this -> determineLanguages ( ) as $ strLangCode ) { $ this -> setTranslatedDataFor ( $ arrValues , $ strLangCode ) ; } } 
public function unsetDataFor ( $ arrIds ) { foreach ( $ this -> determineLanguages ( ) as $ strLangCode ) { $ this -> unsetValueFor ( $ arrIds , $ strLangCode ) ; } } 
public function searchForInLanguages ( $ strPattern , $ arrLanguages = array ( ) ) { $ optionizer = $ this -> getOptionizer ( ) ; $ procedure = $ optionizer [ 'value' ] . ' LIKE :pattern' ; $ strPattern = str_replace ( array ( '*' , '?' ) , array ( '%' , '_' ) , $ strPattern ) ; $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) -> select ( 'DISTINCT item_id' ) -> from ( $ this -> getValueTable ( ) ) -> andWhere ( $ procedure ) -> setParameter ( 'pattern' , $ strPattern ) ; $ this -> buildWhere ( $ queryBuilder , null , $ arrLanguages ) ; $ filterRule = SimpleQuery :: createFromQueryBuilder ( $ queryBuilder , 'item_id' ) ; return $ filterRule -> getMatchingIds ( ) ; } 
public function sortIds ( $ idList , $ strDirection ) { $ langSet = sprintf ( '\'%s\',\'%s\'' , $ this -> getMetaModel ( ) -> getActiveLanguage ( ) , $ this -> getMetaModel ( ) -> getFallbackLanguage ( ) ) ; $ statement = $ this -> connection -> executeQuery ( sprintf ( 'SELECT t1.item_id FROM %1$s AS t1 RIGHT JOIN %1$s ON (t1.id = (SELECT t2.id FROM %1$s AS t2 WHERE (t2.att_id=%2$s) AND langcode IN (%3$s) AND (t2.item_id=t1.item_id) ORDER BY FIELD(t2.langcode,%3$s) LIMIT 1 )) WHERE t1.id IS NOT NULL AND (t1.item_id IN (?)) GROUP BY t1.id ORDER BY t1.value %4$s' , 
public function getFilterOptions ( $ idList , $ usedOnly , & $ arrCount = null ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ this -> getValueTable ( ) ) ; $ this -> buildWhere ( $ queryBuilder , $ idList , $ this -> getMetaModel ( ) -> getActiveLanguage ( ) ) ; $ statement = $ queryBuilder -> execute ( ) ; $ arrOptionizer = $ this -> getOptionizer ( ) ; $ arrReturn = array ( ) ; while ( $ objValue = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ arrReturn [ $ objValue -> { $ arrOptionizer [ 'key' ] } ] = $ objValue -> { $ arrOptionizer [ 'value' ] } ; } return $ arrReturn ; } 
public function setTranslatedDataFor ( $ arrValues , $ strLangCode ) { 
protected function fetchExistingIdsFor ( $ idList , $ langCode ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) -> select ( 'item_id' ) -> from ( $ this -> getValueTable ( ) ) ; $ this -> buildWhere ( $ queryBuilder , $ idList , $ langCode ) ; $ statement = $ queryBuilder -> execute ( ) ; return $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; } 
public function getTranslatedDataFor ( $ arrIds , $ strLangCode ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ this -> getValueTable ( ) ) ; $ this -> buildWhere ( $ queryBuilder , $ arrIds , $ strLangCode ) ; $ statement = $ queryBuilder -> execute ( ) ; $ arrReturn = array ( ) ; while ( $ value = $ statement -> fetch ( \ PDO :: FETCH_ASSOC ) ) { $ arrReturn [ $ value [ 'item_id' ] ] = $ value ; } return $ arrReturn ; } 
public function unsetValueFor ( $ arrIds , $ strLangCode ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) -> delete ( $ this -> getValueTable ( ) ) ; $ this -> buildWhere ( $ queryBuilder , $ arrIds , $ strLangCode ) ; $ queryBuilder -> execute ( ) ; } 
public function handle ( GetPasteButtonEvent $ event ) { $ this -> circularReference = $ event -> isCircularReference ( ) ; $ this -> environment = $ event -> getEnvironment ( ) ; $ this -> provider = $ this -> environment -> getDataProvider ( ) ; $ this -> providerName = $ this -> provider -> getEmptyModel ( ) -> getProviderName ( ) ; $ clipboard = $ this -> environment -> getClipboard ( ) ; $ this -> currentModel = $ event -> getModel ( ) ; $ this -> disablePI = true ; $ this -> disablePA = true ; 
public function handleRoot ( GetPasteRootButtonEvent $ event ) { $ this -> environment = $ event -> getEnvironment ( ) ; $ this -> provider = $ this -> environment -> getDataProvider ( ) ; $ this -> providerName = $ this -> provider -> getEmptyModel ( ) -> getProviderName ( ) ; $ clipboard = $ this -> environment -> getClipboard ( ) ; $ this -> currentModel = null ; $ this -> disablePI = false ; 
private function getModelById ( $ modelId ) { if ( $ modelId === null ) { return null ; } $ provider = $ this -> environment -> getDataProvider ( ) ; $ config = $ provider -> getEmptyConfig ( ) -> setId ( $ modelId ) ; return $ provider -> fetch ( $ config ) ; } 
private function hasVariants ( ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> providerName ) ; if ( $ metaModel === null ) { throw new \ RuntimeException ( sprintf ( 'Could not find a MetaModels with the name %s' , $ this -> providerName ) ) ; } return $ metaModel -> hasVariants ( ) ; } 
private function checkForAction ( $ clipboard , $ action ) { 
private function checkEmpty ( $ action ) { if ( $ this -> hasVariants ( ) && $ this -> currentModel !== null ) { $ this -> disablePA = false ; } elseif ( $ action == 'create' ) { $ this -> disablePA = false ; $ this -> disablePI = false ; } } 
private function checkForRoot ( $ containedModel , $ action ) { if ( $ this -> hasVariants ( ) && $ action == 'cut' && $ containedModel -> getProperty ( 'varbase' ) == 0 ) { $ this -> disablePI = true ; } } 
private function checkForModel ( $ containedModel , $ action ) { if ( ! $ this -> circularReference ) { if ( $ this -> hasVariants ( ) ) { $ this -> checkModelWithVariants ( $ containedModel ) ; } $ this -> checkModelWithoutVariants ( $ containedModel ) ; } elseif ( $ this -> currentModel == null && $ containedModel -> getProperty ( 'varbase' ) == 0 ) { $ this -> disablePA = true ; } else { $ this -> disablePA = false ; 
private function checkModelWithVariants ( $ containedModel ) { 
private function checkModelWithoutVariants ( $ containedModel ) { $ parentDefinition = $ this -> environment -> getDataDefinition ( ) -> getBasicDefinition ( ) -> getParentDataProvider ( ) ; $ this -> disablePA = ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getProperty ( 'pid' ) ) ; $ this -> disablePI = ( $ this -> circularReference ) || ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getId ( ) ) ; } 
public function getMetaModel ( EnvironmentInterface $ interface ) { $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'd.pid' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel_dcasetting' , 's' , '(d.id=s.pid)' ) -> where ( '(s.id=:id)' ) -> setParameter ( 'id' , ModelId :: fromSerialized ( $ interface -> getInputProvider ( ) -> getParameter ( 'pid' ) ) -> getId ( ) ) -> execute ( ) ; if ( $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId = $ metaModelId -> fetchColumn ( ) ) ) { return $ this -> factory -> getMetaModel ( $ tableName ) ; } throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelId ) ; } 
public function getFactory ( ) { 
public function getAttributeFactory ( ) { 
public function getFilterFactory ( ) { 
public function getRenderSettingFactory ( ) { 
public function getEventDispatcher ( ) { 
public function getDatabase ( ) { 
public function getCache ( ) { 
public function setService ( $ service , $ serviceName = null ) { 
public function getService ( $ serviceName ) { 
protected function build ( IMetaModelDataDefinition $ container ) { if ( null === ( $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ) ) { return ; } $ metaModel = $ this -> factory -> getMetaModel ( $ container -> getName ( ) ) ; $ variantHandling = $ metaModel -> hasVariants ( ) ; $ palettesDefinition = $ this -> getOrCreatePaletteDefinition ( $ container ) ; $ properties = $ container -> getPropertiesDefinition ( ) ; $ palettesDefinition -> addPalette ( $ palette = new Palette ( ) ) ; $ palette -> setName ( 'default' ) -> setCondition ( new DefaultPaletteCondition ( ) ) ; foreach ( $ inputScreen [ 'legends' ] as $ legendName => $ legendInfo ) { $ legend = new Legend ( $ legendName ) ; $ legend -> setInitialVisibility ( ! $ legendInfo [ 'hide' ] ) ; $ palette -> addLegend ( $ legend ) ; $ legendConditions = $ this -> buildCondition ( $ legendInfo [ 'condition' ] , $ metaModel ) ; foreach ( $ legendInfo [ 'properties' ] as $ property ) { $ legend -> addProperty ( $ this -> createProperty ( $ properties -> getProperty ( $ property [ 'name' ] ) , $ property [ 'name' ] , $ variantHandling , $ this -> buildCondition ( $ property [ 'condition' ] , $ metaModel ) , $ legendConditions ) ) ; } } } 
private function getOrCreatePaletteDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDefinition ( PalettesDefinitionInterface :: NAME ) ) { return $ container -> getDefinition ( PalettesDefinitionInterface :: NAME ) ; } $ container -> setDefinition ( PalettesDefinitionInterface :: NAME , $ palettesDefinition = new DefaultPalettesDefinition ( ) ) ; return $ palettesDefinition ; } 
private function createProperty ( PropertyInterface $ property , $ propertyName , $ variantHandling , ConditionInterface $ condition = null , ConditionInterface $ legendCondition = null ) { $ paletteProperty = new Property ( $ propertyName ) ; $ extra = $ property -> getExtra ( ) ; $ chain = new PropertyConditionChain ( ) ; $ paletteProperty -> setEditableCondition ( $ chain ) ; if ( isset ( $ extra [ 'readonly' ] ) ) { $ chain -> addCondition ( new BooleanCondition ( $ extra [ 'readonly' ] ) ) ; } $ chain = new PropertyConditionChain ( ) ; $ paletteProperty -> setVisibleCondition ( $ chain ) ; 
private function buildCondition ( $ condition , $ metaModel ) { if ( null === $ condition ) { return null ; } return $ this -> conditionFactory -> createCondition ( $ condition , $ metaModel ) ; } 
public function generate ( ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/metamodelscore/css/style.css' ; $ arrModule = $ GLOBALS [ 'BE_MOD' ] [ 'metamodels' ] [ 'metamodels' ] ; 
public function handle ( PostPersistModelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ old = $ event -> getOriginalModel ( ) ; $ new = $ event -> getModel ( ) ; $ oldInstance = $ old -> getProperty ( 'pid' ) ? $ this -> createAttributeInstance ( $ old ) : null ; $ newInstance = $ this -> createAttributeInstance ( $ new ) ; 
private function isAttributeNameOrTypeChanged ( ModelInterface $ new , ModelInterface $ old ) { return ( $ old -> getProperty ( 'type' ) !== $ new -> getProperty ( 'type' ) ) || ( $ old -> getProperty ( 'colname' ) !== $ new -> getProperty ( 'colname' ) ) ; } 
protected function translateLegend ( $ legend , $ metaModel ) { $ arrLegend = StringUtil :: deserialize ( $ legend [ 'legendtitle' ] ) ; if ( is_array ( $ arrLegend ) ) { 
protected function translateProperty ( $ property , $ metaModel , $ legend ) { $ attribute = $ metaModel -> getAttributeById ( $ property [ 'attr_id' ] ) ; 
protected function applyLegendConditions ( $ attributeId , $ activeLegendId ) { 
protected function translateRows ( $ rows ) { $ metaModel = $ this -> getMetaModel ( ) ; $ activeLegend = $ this -> translateLegend ( array ( 'legendtitle' => $ metaModel -> getName ( ) , 'legendhide' => false ) , $ metaModel ) ; $ activeLegendId = null ; 
protected function transformCondition ( $ condition ) { $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ event = new CreatePropertyConditionEvent ( $ condition , $ this -> getMetaModel ( ) ) ; $ dispatcher -> dispatch ( CreatePropertyConditionEvent :: NAME , $ event ) ; if ( $ event -> getInstance ( ) === null ) { throw new \ RuntimeException ( sprintf ( 'Condition of type %s could not be transformed to an instance.' , $ condition [ 'type' ] ) ) ; } return $ event -> getInstance ( ) ; } 
protected function transformConditions ( $ conditions ) { 
protected function transformGroupSort ( $ rows ) { foreach ( $ rows as $ row ) { $ this -> groupSort [ ] = new InputScreenGroupingAndSorting ( $ row , $ this ) ; } } 
public function getPropertyNames ( ) { $ result = array ( ) ; foreach ( $ this -> getLegends ( ) as $ legend ) { $ result = array_merge ( $ result , $ legend [ 'properties' ] ) ; } return $ result ; } 
public function getConditionsFor ( $ name ) { $ property = $ this -> propertyMap2 [ $ name ] ; return isset ( $ this -> conditions [ $ property ] ) ? $ this -> conditions [ $ property ] : null ; } 
public function getMetaModel ( ) { if ( null === $ this -> data ) { throw new \ RuntimeException ( 'No input screen data available, did you forget to define the view combinations?' ) ; } $ factory = $ this -> container -> getFactory ( ) ; $ metaModel = $ factory -> getMetaModel ( $ factory -> translateIdToMetaModelName ( $ this -> data [ 'pid' ] ) ) ; if ( $ metaModel === null ) { throw new \ RuntimeException ( 'Could not retrieve MetaModel with id ' . $ this -> data [ 'pid' ] ) ; } return $ metaModel ; } 
public function populate ( EnvironmentInterface $ environment ) { foreach ( [ $ environment -> getDataDefinition ( ) , $ environment -> getParentDataDefinition ( ) , $ environment -> getRootDataDefinition ( ) ] as $ definition ) { if ( ! $ definition instanceof ContainerInterface ) { continue ; } $ this -> injectServiceContainerIntoDataDrivers ( $ definition -> getDataProviderDefinition ( ) , $ environment ) ; } } 
private function injectServiceContainerIntoDataDrivers ( $ providerDefinitions , $ environment ) { foreach ( $ providerDefinitions as $ provider ) { $ providerInstance = $ environment -> getDataProvider ( $ provider -> getName ( ) ) ; if ( $ providerInstance instanceof Driver ) { $ initialization = $ provider -> getInitializationData ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ initialization [ 'source' ] ) ; $ providerInstance -> setBaseConfig ( array_merge ( $ initialization , [ 'metaModel' => $ metaModel ] ) ) ; $ providerInstance -> setDispatcher ( $ this -> dispatcher ) ; $ providerInstance -> setConnection ( $ this -> connection ) ; } } } 
protected function process ( $ table , $ metaModelName , $ parentId , Request $ request ) { $ this -> knownAttributes = $ this -> fetchExisting ( $ table , $ parentId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( ! $ metaModel ) { throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelName ) ; } if ( $ request -> request -> has ( 'add' ) || $ request -> request -> has ( 'saveNclose' ) ) { $ this -> perform ( $ table , $ request , $ metaModel , $ parentId ) ; 
protected function render ( $ table , $ metaModel , Request $ request ) { $ fields = $ this -> generateForm ( $ table , $ metaModel , $ request ) ; return [ 'action' => '' , 'requestToken' => REQUEST_TOKEN , 'href' => $ this -> getReferer ( $ request , $ table , true ) , 'backBt' => $ this -> translator -> trans ( 'MSC.backBT' , [ ] , 'contao_default' ) , 'add' => $ this -> translator -> trans ( 'MSC.continue' , [ ] , 'contao_default' ) , 'saveNclose' => $ this -> translator -> trans ( 'MSC.saveNclose' , [ ] , 'contao_default' ) , 'activate' => $ this -> translator -> trans ( $ table . '.addAll_activate' , [ ] , 'contao_' . $ table ) , 'headline' => $ this -> translator -> trans ( $ table . '.addall.1' , [ ] , 'contao_' . $ table ) , 'selectAll' => $ this -> translator -> trans ( 'MSC.selectAll' , [ ] , 'contao_default' ) , 'cacheMessage' => '' , 'updateMessage' => '' , 'hasCheckbox' => count ( $ fields ) > 0 , 'fields' => $ fields , ] ; } 
private function fetchExisting ( $ table , $ parentId ) { 
private function generateForm ( $ table , $ metaModel , Request $ request ) { $ fields = [ ] ; 
private function checkboxCaption ( $ key , $ table , IAttribute $ attribute ) { return $ this -> translator -> trans ( $ table . '.' . $ key , [ $ attribute -> getName ( ) ] , 'contao_' . $ table ) ; } 
private function perform ( $ table , Request $ request , $ metaModel , $ parentId ) { $ activate = ( bool ) $ request -> request -> get ( 'activate' ) ; $ query = $ this -> connection -> createQueryBuilder ( ) -> insert ( $ table ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( $ this -> knowsAttribute ( $ attribute ) || ! ( $ this -> accepts ( $ attribute ) && $ this -> isAttributeSubmitted ( $ attribute -> get ( 'id' ) , $ request ) ) ) { continue ; } $ data = [ ] ; foreach ( $ this -> createEmptyDataFor ( $ attribute , $ parentId , $ activate , $ this -> startSort ) as $ key => $ value ) { $ data [ $ key ] = ':' . $ key ; $ query -> setParameter ( $ key , $ value ) ; } $ query -> values ( $ data ) -> execute ( ) ; $ this -> startSort += 128 ; } $ this -> purger -> purge ( ) ; } 
private function getReferer ( Request $ request , $ table , $ encodeAmp = false ) { $ uri = $ this -> systemAdapter -> getReferer ( $ encodeAmp , $ table ) ; 
public function purge ( ) { $ fileSystem = new Filesystem ( ) ; $ fileSystem -> remove ( $ this -> cacheDir ) ; $ this -> logger -> log ( LogLevel :: INFO , 'Purged the MetaModels cache' , [ 'contao' => new ContaoContext ( __METHOD__ , TL_CRON ) ] ) ; } 
public function handle ( GetPropertyOptionsEvent $ event ) { if ( ( 'tl_metamodel_dca' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rendermode' !== $ event -> getPropertyName ( ) ) ) { return ; } $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ options = [ 'flat' => $ translator -> translate ( 'rendermodes.flat' , 'tl_metamodel_dca' ) , 'hierarchical' => $ translator -> translate ( 'rendermodes.hierarchical' , 'tl_metamodel_dca' ) , ] ; if ( 'ctable' === $ event -> getModel ( ) -> getProperty ( 'rendertype' ) ) { $ options [ 'parented' ] = $ translator -> translate ( 'rendermodes.parented' , 'tl_metamodel_dca' ) ; } $ event -> setOptions ( $ options ) ; } 
public function setPageValue ( string $ name , $ value ) : self { if ( empty ( $ value ) ) { unset ( $ this -> page [ $ name ] ) ; return $ this ; } $ this -> page [ $ name ] = $ value ; return $ this ; } 
public function setGet ( string $ name , string $ value ) : self { if ( empty ( $ value ) ) { unset ( $ this -> getParameters [ $ name ] ) ; return $ this ; } $ this -> getParameters [ $ name ] = $ value ; return $ this ; } 
public function setSlug ( string $ name , string $ value ) : self { if ( empty ( $ value ) ) { unset ( $ this -> slugParameters [ $ name ] ) ; return $ this ; } $ this -> slugParameters [ $ name ] = $ value ; return $ this ; } 
public function handle ( GetPropertyOptionsEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && ( $ event -> getPropertyName ( ) === 'rte' ) ) ) { return ; } $ configs = [ ] ; 
public function generate ( ) { 
protected function getFilterParameters ( $ objItemRenderer ) { $ filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; $ filterUrl = $ filterUrlBuilder -> getCurrentFilterUrl ( ) ; $ result = [ ] ; foreach ( $ objItemRenderer -> getFilterSettings ( ) -> getParameters ( ) as $ name ) { if ( $ filterUrl -> hasSlug ( $ name ) ) { $ result [ $ name ] = $ filterUrl -> getSlug ( $ name ) ; } 
protected function compile ( ) { $ objItemRenderer = new ItemList ( ) ; $ this -> Template -> searchable = ! $ this -> metamodel_donotindex ; $ sorting = $ this -> metamodel_sortby ; $ direction = $ this -> metamodel_sortby_direction ; if ( $ this -> metamodel_sort_override ) { if ( \ Input :: get ( 'orderBy' ) ) { $ sorting = \ Input :: get ( 'orderBy' ) ; } if ( \ Input :: get ( 'orderDir' ) ) { $ direction = \ Input :: get ( 'orderDir' ) ; } } $ objItemRenderer -> setServiceContainerFallback ( function ( ) { return $ this -> getServiceContainer ( ) ; } ) -> setFactory ( System :: getContainer ( ) -> get ( 'metamodels.factory' ) ) -> setFilterFactory ( System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ) -> setRenderSettingFactory ( System :: getContainer ( ) -> get ( 'metamodels.render_setting_factory' ) ) -> setEventDispatcher ( System :: getContainer ( ) -> get ( 'event_dispatcher' ) ) -> setMetaModel ( $ this -> metamodel , $ this -> metamodel_rendersettings ) -> setLimit ( $ this -> metamodel_use_limit , $ this -> metamodel_offset , $ this -> metamodel_limit ) -> setPageBreak ( $ this -> perPage ) -> setSorting ( $ sorting , $ direction ) -> setFilterSettings ( $ this -> metamodel_filtering ) -> setFilterParameters ( StringUtil :: deserialize ( $ this -> metamodel_filterparams , true ) , $ this -> getFilterParameters ( $ objItemRenderer ) ) -> setMetaTags ( $ this -> metamodel_meta_title , $ this -> metamodel_meta_description ) ; 
public function buildCondition ( array $ configuration , IMetaModel $ metaModel ) { $ children = [ ] ; if ( ! empty ( $ configuration [ 'children' ] ) ) { foreach ( $ configuration [ 'children' ] as $ child ) { $ children [ ] = $ this -> convertCondition ( $ child , $ metaModel ) ; } } return $ this -> createCondition ( $ children ) ; } 
protected function isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { 
protected function getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { 
protected function addUrlParameter ( $ url , $ name , $ value ) { 
protected function buildFilterUrl ( $ fragments , $ searchKey ) { 
protected function prepareFrontendFilterOptions ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , $ blnAutoSubmit ) { $ arrOptions = array ( ) ; if ( ! isset ( $ arrWidget [ 'options' ] ) ) { return $ arrOptions ; } $ filterUrl = new FilterUrl ( $ arrJumpTo ) ; foreach ( $ arrFilterUrl as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ filterUrl -> setSlug ( $ name , ( string ) $ value ) ; } $ parameterName = $ arrWidget [ 'eval' ] [ 'urlparam' ] ; if ( $ arrWidget [ 'eval' ] [ 'includeBlankOption' ] ) { $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , '' ) ; $ arrOptions [ ] = array ( 'key' => '' , 'value' => ( $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] ? $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] : $ GLOBALS [ 'TL_LANG' ] [ 'metamodels_frontendfilter' ] [ 'do_not_filter' ] ) , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , '' ) ) , 'active' => $ blnActive , 'class' => 'doNotFilter' . ( $ blnActive ? ' active' : '' ) , ) ; } foreach ( $ arrWidget [ 'options' ] as $ strKeyOption => $ strOption ) { $ strValue = $ this -> getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ arrOptions [ ] = array ( 'key' => $ strKeyOption , 'value' => $ strOption , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , $ strValue ) ) , 'active' => $ blnActive , 'class' => StringUtil :: standardize ( $ strKeyOption ) . ( $ blnActive ? ' active' : '' ) ) ; } return $ arrOptions ; } 
protected function prepareFrontendFilterWidget ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , FrontendFilterOptions $ objFrontendFilterOptions ) { $ strClass = $ GLOBALS [ 'TL_FFL' ] [ $ arrWidget [ 'inputType' ] ] ; 
protected function validateWidget ( $ widget , $ value ) { if ( null === $ value ) { return ; } $ widget -> setInputCallback ( function ( ) use ( $ value ) { return $ value ; } ) ; $ widget -> validate ( ) ; } 
public function getName ( ) { if ( is_array ( $ this -> arrData [ 'name' ] ) ) { return $ this -> getLangValue ( $ this -> get ( 'name' ) ) ? : $ this -> getColName ( ) ; } return $ this -> arrData [ 'name' ] ? : $ this -> getColName ( ) ; } 
protected function getLangValue ( $ arrValues , $ strLangCode = null ) { if ( ! ( $ this -> getMetaModel ( ) -> isTranslated ( ) && is_array ( $ arrValues ) ) ) { return $ arrValues ; } if ( $ strLangCode === null ) { return $ this -> getLangValue ( $ arrValues , $ this -> getMetaModel ( ) -> getActiveLanguage ( ) ) ; } if ( array_key_exists ( $ strLangCode , $ arrValues ) ) { return $ arrValues [ $ strLangCode ] ; } 
public function hookAdditionalFormatters ( $ arrBaseFormatted , $ arrRowData , $ strOutputFormat , $ objSettings ) { $ arrResult = $ arrBaseFormatted ; if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ arrResult = $ objCallback -> $ strMethod ( $ this , $ arrResult , $ arrRowData , $ strOutputFormat , $ objSettings ) ; } } return $ arrResult ; } 
protected function prepareTemplate ( Template $ objTemplate , $ arrRowData , $ objSettings ) { $ objTemplate -> setData ( array ( 'attribute' => $ this , 'settings' => $ objSettings , 'row' => $ arrRowData , 'raw' => $ arrRowData [ $ this -> getColName ( ) ] , 'additional_class' => $ objSettings -> get ( 'additional_class' ) ? ' ' . $ objSettings -> get ( 'additional_class' ) : '' ) ) ; } 
public function get ( $ strKey ) { return isset ( $ this -> arrData [ $ strKey ] ) ? $ this -> arrData [ $ strKey ] : null ; } 
public function set ( $ strKey , $ varValue ) { if ( in_array ( $ strKey , $ this -> getAttributeSettingNames ( ) ) ) { if ( ! is_array ( $ varValue ) && ( substr ( $ varValue , 0 , 2 ) == 'a:' ) ) { $ unSerialized = unserialize ( $ varValue ) ; } if ( isset ( $ unSerialized ) && is_array ( $ unSerialized ) ) { $ this -> arrData [ $ strKey ] = $ unSerialized ; } else { $ this -> arrData [ $ strKey ] = $ varValue ; } } return $ this ; } 
private function setLanguageStrings ( ) { 
private function getBaseDefinition ( ) { $ this -> setLanguageStrings ( ) ; $ tableName = $ this -> getMetaModel ( ) -> getTableName ( ) ; $ definition = array ( ) ; if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] [ 'fields' ] [ $ this -> getColName ( ) ] ) ) { $ definition = $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] [ 'fields' ] [ $ this -> getColName ( ) ] ; } return array_replace_recursive ( array ( 'label' => & $ GLOBALS [ 'TL_LANG' ] [ $ tableName ] [ $ this -> getColName ( ) ] , 'eval' => array ( ) ) , $ definition ) ; } 
protected function getOverrideValue ( $ name , $ overrides ) { if ( $ this -> isAllowedValue ( $ name ) && isset ( $ overrides [ $ name ] ) ) { return $ overrides [ $ name ] ; } return $ this -> get ( $ name ) ; } 
private function setBaseEval ( $ fieldDefinition , $ overrides ) { if ( $ this -> isAllowedValue ( 'isunique' ) ) { $ fieldDefinition [ 'eval' ] [ 'unique' ] = ( bool ) $ this -> getOverrideValue ( 'isunique' , $ overrides ) ; } foreach ( array ( 'tl_class' , 'mandatory' , 'alwaysSave' , 'chosen' , 'allowHtml' , 'preserveTags' , 'decodeEntities' , 'rte' , 'rows' , 'cols' , 'spaceToUnderscore' , 'includeBlankOption' , 'submitOnChange' , 'readonly' ) as $ name ) { if ( empty ( $ fieldDefinition [ 'eval' ] [ $ name ] ) && ( $ value = $ this -> getOverrideValue ( $ name , $ overrides ) ) ) { $ fieldDefinition [ 'eval' ] [ $ name ] = $ value ; } } 
public function getFieldDefinition ( $ arrOverrides = array ( ) ) { $ arrFieldDef = $ this -> setBaseEval ( $ this -> getBaseDefinition ( ) , $ arrOverrides ) ; if ( $ this -> isAllowedValue ( 'trailingSlash' ) ) { $ trailingSlash = $ this -> getOverrideValue ( 'trailingSlash' , $ arrOverrides ) ; if ( $ trailingSlash != 2 ) { $ arrFieldDef [ 'eval' ] [ 'trailingSlash' ] = ( bool ) $ arrOverrides [ 'trailingSlash' ] ; } } 
public function getItemDCA ( $ arrOverrides = array ( ) ) { $ arrReturn = array ( 'fields' => array_merge ( array ( $ this -> getColName ( ) => $ this -> getFieldDefinition ( $ arrOverrides ) ) , ( array ) $ GLOBALS [ 'TL_DCA' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ 'fields' ] [ $ this -> getColName ( ) ] ) , ) ; return $ arrReturn ; } 
public function parseValue ( $ arrRowData , $ strOutputFormat = 'text' , $ objSettings = null ) { $ arrResult = array ( 'raw' => $ arrRowData [ $ this -> getColName ( ) ] , ) ; if ( $ objSettings && $ objSettings -> get ( 'template' ) ) { $ strTemplate = $ objSettings -> get ( 'template' ) ; $ objTemplate = new Template ( $ strTemplate ) ; $ this -> prepareTemplate ( $ objTemplate , $ arrRowData , $ objSettings ) ; 
protected function build ( IMetaModelDataDefinition $ container ) { $ this -> inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; 
private function ensureSubmitElement ( $ panelRows ) { 
private function parsePanelRow ( $ fields , PanelRowInterface $ panelRow ) { 
private function parsePanelFilter ( PanelRowInterface $ row ) { foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'filter' ] ) ) { $ element = new DefaultFilterElementInformation ( ) ; $ element -> setPropertyName ( $ value [ 'col_name' ] ) ; if ( ! $ row -> hasElement ( $ element -> getName ( ) ) ) { $ row -> addElement ( $ element ) ; } } } } 
private function parsePanelSort ( PanelRowInterface $ row ) { if ( ! $ row -> hasElement ( 'sort' ) ) { $ element = new DefaultSortElementInformation ( ) ; $ row -> addElement ( $ element ) ; } } 
private function parsePanelSearch ( PanelRowInterface $ row ) { if ( $ row -> hasElement ( 'search' ) ) { $ element = $ row -> getElement ( 'search' ) ; } else { $ element = new DefaultSearchElementInformation ( ) ; } if ( ! $ element instanceof SearchElementInformationInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'search' ] ) ) { $ element -> addProperty ( $ value [ 'col_name' ] ) ; } } if ( $ element -> getPropertyNames ( ) && ! $ row -> hasElement ( 'search' ) ) { $ row -> addElement ( $ element ) ; } } 
protected static function upgradeJumpTo ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_content' , null , true ) && ! $ objDB -> fieldExists ( 'metamodel_jumpTo' , 'tl_content' , true ) ) { 
protected static function upgradeDcaSettingsPublished ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_metamodel_dcasetting' , null , true ) && ! $ objDB -> fieldExists ( 'published' , 'tl_metamodel_dcasetting' , true ) ) { 
protected static function changeSubPalettesToConditions ( ) { $ objDB = self :: DB ( ) ; `id` int(10) unsigned NOT NULL auto_increment, `pid` int(10) unsigned NOT NULL default \'0\', `settingId` int(10) unsigned NOT NULL default \'0\', `sorting` int(10) unsigned NOT NULL default \'0\', `tstamp` int(10) unsigned NOT NULL default \'0\', `enabled` char(1) NOT NULL default \'\', `type` varchar(255) NOT NULL default \'\', `attr_id` int(10) unsigned NOT NULL default \'0\', `comment` varchar(255) NOT NULL default \'\', `value` blob NULL, PRIMARY KEY (`id`) )ENGINE=MyISAM DEFAULT CHARSET=utf8;' ) ; } if ( $ objDB -> tableExists ( 'tl_metamodel_dcasetting' , null , true ) && $ objDB -> fieldExists ( 'subpalette' , 'tl_metamodel_dcasetting' , true ) ) { $ subpalettes = $ objDB -> execute ( 'SELECT * FROM tl_metamodel_dcasetting WHERE subpalette!=0' ) ; if ( $ subpalettes -> numRows ) { // Get all attribute names and setting ids. $ attributes = $ objDB -> execute ( ' SELECT attr_id, colName FROM tl_metamodel_dcasetting AS setting LEFT JOIN tl_metamodel_attribute AS attribute ON (setting.attr_id=attribute.id) WHERE dcatype=\'attribute\' ' ) ; $ attr = array ( ) ; while ( $ attributes -> next ( ) ) { $ attr [ $ attributes -> attr_id ] = $ attributes -> colName ; } $ checkboxes = $ objDB -> execute ( ' SELECT * FROM tl_metamodel_dcasetting WHERE subpalette=0 AND dcatype=\'attribute\' ' ) ; $ check = array ( ) ; while ( $ checkboxes -> next ( ) ) { $ check [ $ checkboxes -> id ] = $ checkboxes -> attr_id ; } while ( $ subpalettes -> next ( ) ) { // Add property value condition for parent property dependency. $ data = array ( 'pid' => 0 , 'settingId' => $ subpalettes -> id , 'sorting' => '128' , 'tstamp' => time ( ) , 'enabled' => '1' , 'type' => 'conditionpropertyvalueis' , 'attr_id' => $ check [ $ subpalettes -> subpalette ] , 'comment' => sprintf ( 'Only show when checkbox "%s" is checked' , $ attr [ $ check [ $ subpalettes -> subpalette ] ] ) , 'value' => '1' , ) ; $ objDB -> prepare ( 'INSERT INTO tl_metamodel_dcasetting_condition %s' ) -> set ( $ data ) -> execute ( ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET subpalette=0 WHERE id=?' ) -> execute ( $ subpalettes -> id ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET submitOnChange=1 WHERE id=?' ) -> execute ( $ subpalettes -> subpalette ) ; } } TableManipulation :: dropColumn ( 'tl_metamodel_dcasetting' , 'subpalette' , true ) ; } } 
protected static function upgradeClosed ( ) { $ objDB = self :: DB ( ) ; UPDATE tl_metamodel_dca SET iseditable=isclosed^1, iscreatable=isclosed^1, isdeleteable=isclosed^1 ' ) ; TableManipulation :: dropColumn ( 'tl_metamodel_dca' , 'isclosed' , true ) ; } } 
protected static function upgradeInputScreenMode ( ) { $ objDB = self :: DB ( ) ; if ( ! $ objDB -> tableExists ( 'tl_metamodel_dca' , null , true ) ) { return ; } if ( ! $ objDB -> fieldExists ( 'mode' , 'tl_metamodel_dca' ) ) { return ; } 
protected static function upgradeInputScreenFlag ( ) { $ objDB = self :: DB ( ) ; if ( ! $ objDB -> tableExists ( 'tl_metamodel_dca' , null , true ) ) { return ; } if ( ! $ objDB -> fieldExists ( 'flag' , 'tl_metamodel_dca' ) ) { return ; } if ( ! $ objDB -> tableExists ( 'tl_metamodel_dca_sortgroup' , null , true ) ) { $ objDB -> execute ( ' CREATE TABLE `tl_metamodel_dca_sortgroup` ( `id` int(10) unsigned NOT NULL auto_increment, `pid` int(10) unsigned NOT NULL default \'0\', `sorting` int(10) unsigned NOT NULL default \'0\', `tstamp` int(10) unsigned NOT NULL default \'0\', `name` text NULL, `isdefault` char(1) NOT NULL default \'\', `ismanualsort` char(1) NOT NULL default \'\', `rendergrouptype` varchar(10) NOT NULL default \'none\', `rendergrouplen` int(10) unsigned NOT NULL default \'1\', `rendergroupattr` int(10) unsigned NOT NULL default \'0\', `rendersort` varchar(10) NOT NULL default \'asc\', `rendersortattr` int(10) unsigned NOT NULL default \'0\', PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; ' ) ; } $ dca = $ objDB -> execute ( 'SELECT * FROM tl_metamodel_dca' ) ; while ( $ dca -> next ( ) ) { $ renderGroupLen = 0 ; if ( in_array ( $ dca -> flag , array ( 1 , 2 , 3 , 4 ) ) ) { $ renderGroupType = 'char' ; if ( in_array ( $ dca -> flag , array ( 1 , 2 ) ) ) { $ renderGroupLen = 1 ; } else { $ renderGroupLen = 2 ; } } elseif ( in_array ( $ dca -> flag , array ( 5 , 6 ) ) ) { $ renderGroupType = 'day' ; } elseif ( in_array ( $ dca -> flag , array ( 7 , 8 ) ) ) { $ renderGroupType = 'month' ; } elseif ( in_array ( $ dca -> flag , array ( 9 , 10 ) ) ) { $ renderGroupType = 'year' ; } elseif ( in_array ( $ dca -> flag , array ( 11 , 12 ) ) ) { $ renderGroupType = 'digit' ; } else { $ renderGroupType = 'none' ; } $ data = array ( 'pid' => $ dca -> id , 'sorting' => 128 , 'tstamp' => time ( ) , 'name' => null , 'isdefault' => '1' , 'ismanualsort' => '1' , 'rendergrouptype' => $ renderGroupType , 'rendergrouplen' => $ renderGroupLen , 'rendergroupattr' => 0 , 'rendersort' => in_array ( $ dca -> flag , array ( 2 , 4 , 6 , 8 , 10 , 12 ) ) ? 'desc' : 'asc' , 'rendersortattr' => 0 , ) ; $ objDB -> prepare ( 'INSERT INTO tl_metamodel_dca_sortgroup %s' ) -> set ( $ data ) -> execute ( ) ; } TableManipulation :: dropColumn ( 'tl_metamodel_dca' , 'flag' , true ) ; } 
public static function perform ( ) { self :: upgradeJumpTo ( ) ; self :: upgradeDcaSettingsPublished ( ) ; self :: changeSubPalettesToConditions ( ) ; self :: upgradeClosed ( ) ; self :: upgradeInputScreenMode ( ) ; self :: upgradeInputScreenFlag ( ) ; } 
public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'tableName' ) ) { return ; } 
public function handle ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ result = [ ] ; $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( $ attribute instanceof IInternal ) { continue ; } $ typeName = $ attribute -> get ( 'type' ) ; $ result [ $ attribute -> get ( 'id' ) ] = $ attribute -> getName ( ) . ' [' . $ typeName . ']' ; } $ event -> setOptions ( $ result ) ; } 
public function getServiceContainer ( ) { if ( ! $ this -> serviceContainer ) { $ this -> useDefaultServiceContainer ( ) ; } if ( is_callable ( $ this -> serviceContainer ) ) { return $ this -> serviceContainer = $ this -> serviceContainer -> __invoke ( ) ; } return $ this -> serviceContainer ; } 
public function setLimit ( $ blnUse , $ intOffset , $ intLimit ) { $ this -> paginationLimitCalculator -> setApplyLimitAndOffset ( $ blnUse ) -> setOffset ( $ intOffset ) -> setLimit ( $ intLimit ) ; return $ this ; } 
public function setSorting ( $ strSortBy , $ strDirection = 'ASC' ) { $ this -> strSortBy = $ strSortBy ; $ this -> strSortDirection = ( $ strDirection == 'DESC' ) ? 'DESC' : 'ASC' ; return $ this ; } 
public function overrideOutputFormat ( $ strOutputFormat = null ) { $ strOutputFormat = strval ( $ strOutputFormat ) ; if ( strlen ( $ strOutputFormat ) ) { $ this -> strOutputFormat = $ strOutputFormat ; } else { unset ( $ this -> strOutputFormat ) ; } return $ this ; } 
public function setMetaModel ( $ intMetaModel , $ intView ) { $ this -> intMetaModel = $ intMetaModel ; $ this -> intView = $ intView ; $ this -> prepareMetaModel ( ) ; $ this -> prepareView ( ) ; return $ this ; } 
public function setMetaTags ( $ strTitleAttribute , $ strDescriptionAttribute ) { $ this -> strDescriptionAttribute = $ strDescriptionAttribute ; $ this -> strTitleAttribute = $ strTitleAttribute ; return $ this ; } 
protected function prepareMetaModel ( ) { $ factory = $ this -> getFactory ( ) ; $ this -> objMetaModel = $ factory -> getMetaModel ( $ factory -> translateIdToMetaModelName ( $ this -> intMetaModel ) ) ; if ( ! $ this -> objMetaModel ) { throw new \ RuntimeException ( 'Could get metamodel id: ' . $ this -> intMetaModel ) ; } } 
protected function prepareView ( ) { if ( $ this -> renderSettingFactory ) { $ this -> objView = $ this -> renderSettingFactory -> createCollection ( $ this -> objMetaModel , $ this -> intView ) ; } else { $ this -> objView = $ this -> objMetaModel -> getView ( $ this -> intView ) ; } if ( $ this -> objView ) { $ this -> objTemplate = new Template ( $ this -> objView -> get ( 'template' ) ) ; $ this -> objTemplate -> view = $ this -> objView ; } else { 
public function setFilterSettings ( $ intFilter ) { $ this -> intFilter = $ intFilter ; $ this -> objFilterSettings = $ this -> getFilterFactory ( ) -> createCollection ( $ this -> intFilter ) ; if ( ! $ this -> objFilterSettings ) { throw new \ RuntimeException ( 'Error: no filter object defined.' ) ; } return $ this ; } 
public function setFilterParameters ( $ arrPresets , $ arrValues ) { if ( ! $ this -> objFilterSettings ) { throw new \ RuntimeException ( 'Error: no filter object defined, call setFilterSettings() before setFilterParameters().' ) ; } $ arrPresetNames = $ this -> objFilterSettings -> getParameters ( ) ; $ arrFEFilterParams = array_keys ( $ this -> objFilterSettings -> getParameterFilterNames ( ) ) ; $ arrProcessed = array ( ) ; 
public function addFilterRule ( $ objFilterRule ) { if ( ! $ this -> objFilter ) { $ this -> objFilter = $ this -> objMetaModel -> getEmptyFilter ( ) ; } $ this -> objFilter -> addFilterRule ( $ objFilterRule ) ; return $ this ; } 
protected function getAttributeNames ( ) { $ arrAttributes = $ this -> objView -> getSettingNames ( ) ; 
public function prepare ( ) { if ( $ this -> objItems ) { return $ this ; } 
public function getOutputFormat ( ) { if ( isset ( $ this -> strOutputFormat ) ) { return $ this -> strOutputFormat ; } if ( isset ( $ this -> objView ) && $ this -> objView -> get ( 'format' ) ) { return $ this -> objView -> get ( 'format' ) ; } $ page = $ this -> getPage ( ) ; if ( $ page && $ page -> outputFormat ) { return $ page -> outputFormat ; } return 'text' ; } 
private function getCaptionText ( $ langKey ) { $ tableName = $ this -> getMetaModel ( ) -> getTableName ( ) ; if ( isset ( $ this -> objView ) && isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ; } elseif ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ; } return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ langKey ] ; } 
private function setTitleAndDescription ( ) { $ page = $ this -> getPage ( ) ; if ( $ page && $ this -> objItems -> getCount ( ) ) { 
public function render ( $ blnNoNativeParsing , $ objCaller ) { $ event = new RenderItemListEvent ( $ this , $ this -> objTemplate , $ objCaller ) ; $ this -> getEventDispatcher ( ) -> dispatch ( MetaModelsEvents :: RENDER_ITEM_LIST , $ event ) ; $ this -> objTemplate -> noItemsMsg = $ this -> getNoItemsCaption ( ) ; $ this -> objTemplate -> details = $ this -> getCaptionText ( 'details' ) ; $ this -> prepare ( ) ; $ strOutputFormat = $ this -> getOutputFormat ( ) ; if ( $ this -> objItems -> getCount ( ) && ! $ blnNoNativeParsing ) { $ this -> objTemplate -> data = $ this -> objItems -> parseAll ( $ strOutputFormat , $ this -> objView ) ; } else { $ this -> objTemplate -> data = array ( ) ; } $ this -> setTitleAndDescription ( ) ; $ this -> objTemplate -> caller = $ objCaller ; $ this -> objTemplate -> items = $ this -> objItems ; $ this -> objTemplate -> filterParams = $ this -> arrParam ; return $ this -> objTemplate -> parse ( $ strOutputFormat ) ; } 
protected function build ( IMetaModelDataDefinition $ container ) { $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( ! $ inputScreen ) { return ; } $ meta = $ inputScreen [ 'meta' ] ; $ config = $ this -> getOrCreateBasicDefinition ( $ container ) ; $ config -> setDataProvider ( $ container -> getName ( ) ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ container -> getName ( ) ) ; 
private function getOrCreateBasicDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasBasicDefinition ( ) ) { return $ container -> getBasicDefinition ( ) ; } $ config = new DefaultBasicDefinition ( ) ; $ container -> setBasicDefinition ( $ config ) ; return $ config ; } 
public function handle ( ManipulateWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && ( 'tl_class' === $ event -> getProperty ( ) -> getName ( ) ) ) ) { return ; } $ link = ' <a href="%1$s" onclick="Backend.getScrollOffset();Backend.openModalIframe({' . '\'width\':765,' . '\'title\':\'%2$s\',' . '\'url\':this.href,' . '\'id\':\'%3$s\'' . '});return false">%4$s</a>' ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/dca_wizard.png' , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'stylepicker' , 'tl_metamodel_dca' ) , 'style="vertical-align:top;"' ) ; $ event -> getWidget ( ) -> wizard = sprintf ( $ link , $ this -> urlGenerator -> generate ( 'metamodels.picker' , [ 'tbl' => $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) , 'fld' => $ event -> getProperty ( ) -> getName ( ) , 'inputName' => 'ctrl_' . $ event -> getProperty ( ) -> getName ( ) , 'id' => $ event -> getModel ( ) -> getId ( ) , 'item' => 'PALETTE_STYLE_PICKER' , ] ) , addslashes ( $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'stylepicker' , 'tl_metamodel_dca' ) ) , $ event -> getModel ( ) -> getId ( ) , $ image ) ; } 
protected function getConfigs ( ) { if ( ! count ( $ this -> configs ) ) { 
protected function getMetaModel ( $ identifier , $ ignoreError ) { 
protected function getView ( $ identifier , $ view ) { $ metaModels = $ this -> getMetaModel ( $ identifier , false ) ; return $ metaModels -> getView ( $ view ) ; } 
protected function getLanguage ( $ singleLanguage , $ metaModels ) { if ( ! empty ( $ singleLanguage ) ) { return array ( $ singleLanguage ) ; } elseif ( $ metaModels -> isTranslated ( ) && $ metaModels -> getAvailableLanguages ( ) ) { return $ metaModels -> getAvailableLanguages ( ) ; } return array ( $ GLOBALS [ 'TL_LANGUAGE' ] ) ; } 
protected function getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage = null ) { $ entries = array ( ) ; 
private function getBaseUrl ( $ pageDetails , $ path = null , $ ignoreSSL = false ) { $ url = new UrlBuilder ( ) ; 
protected function removeEmptyDetailPages ( $ jumpTos ) { 
public function setFilterParameters ( $ filterId , $ presets , $ values ) { $ filterSettings = $ this -> getFilterSettings ( $ filterId ) ; $ presetNames = $ filterSettings -> getParameters ( ) ; $ feFilterParams = array_keys ( $ filterSettings -> getParameterFilterNames ( ) ) ; $ processed = array ( ) ; 
public function addPages ( $ pages , $ rootPage = null , $ fromSiteMap = false , $ language = null ) { 
private function getMetaModelsPages ( $ config , $ rootPage = null , $ language = null ) { $ metaModelsIdentifier = $ config [ 'pid' ] ; $ filterIdentifier = $ config [ 'filter' ] ; $ presetParams = StringUtil :: deserialize ( $ config [ 'filterparams' ] , true ) ; $ renderSettingId = $ config [ 'rendersetting' ] ; 
public function build ( ) { if ( ! $ this -> isEmpty ( ) ) { return new SimpleQuery ( sprintf ( 'SELECT id FROM %s WHERE %s' , $ this -> tableName , $ this -> getProcedure ( ) ) , $ this -> getParameters ( ) , 'id' , $ this -> connection ) ; } return null ; } 
protected function getFilterForComparingOperator ( $ operation ) { $ this -> parameter [ ] = $ operation [ 'value' ] ; $ this -> procedures [ ] = sprintf ( '(%s %s ?)' , $ operation [ 'property' ] , $ operation [ 'operation' ] ) ; return $ this ; } 
protected function getFilterForInList ( $ operation ) { $ this -> parameter = array_merge ( $ this -> parameter , array_values ( $ operation [ 'values' ] ) ) ; $ this -> procedures [ ] = sprintf ( '(%s IN (%s))' , $ operation [ 'property' ] , rtrim ( str_repeat ( '?,' , \ count ( $ operation [ 'values' ] ) ) , ',' ) ) ; return $ this ; } 
protected function getFilterForLike ( $ operation ) { $ this -> parameter [ ] = str_replace ( array ( '*' , '?' ) , array ( '%' , '_' ) , $ operation [ 'value' ] ) ; $ this -> procedures [ ] = sprintf ( '(%s LIKE ?)' , $ operation [ 'property' ] ) ; return $ this ; } 
public function addChild ( $ child ) { if ( ! \ is_array ( $ child ) ) { throw new \ RuntimeException ( 'Error Processing sub filter: ' . var_export ( $ child , true ) , 1 ) ; } switch ( strtoupper ( $ child [ 'operation' ] ) ) { case '=' : case '>' : case '<' : return $ this -> getFilterForComparingOperator ( $ child ) ; case 'IN' : return $ this -> getFilterForInList ( $ child ) ; case 'LIKE' : return $ this -> getFilterForLike ( $ child ) ; default : } throw new \ RuntimeException ( 'Error processing filter array ' . var_export ( $ child , true ) , 1 ) ; } 
public function addSubProcedure ( FilterBuilderSql $ subProcedure ) { $ this -> procedures [ ] = $ subProcedure -> getProcedure ( ) ; $ this -> parameter = array_merge ( $ this -> parameter , $ subProcedure -> getParameters ( ) ) ; return $ this ; } 
public function handle ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getPropertyName ( ) !== 'template' ) ) { return ; } $ event -> setOptions ( $ this -> templateList -> getTemplatesForBase ( 'metamodel_' ) ) ; } 
public function getSetting ( $ strAttributeName ) { return isset ( $ this -> arrSettings [ $ strAttributeName ] ) ? $ this -> arrSettings [ $ strAttributeName ] : null ; } 
public function setSetting ( $ strAttributeName , $ objSetting ) { if ( $ objSetting ) { $ this -> arrSettings [ $ strAttributeName ] = $ objSetting -> setParent ( $ this ) ; } else { unset ( $ this -> arrSettings [ $ strAttributeName ] ) ; } return $ this ; } 
private function getJumpToLabel ( ) { $ tableName = $ this -> metaModel -> getTableName ( ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> get ( 'id' ) ] [ 'details' ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> get ( 'id' ) ] [ 'details' ] ; } elseif ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ 'details' ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ 'details' ] ; } return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'details' ] ; } 
private function getPageDetails ( $ pageId ) { if ( empty ( $ pageId ) ) { return array ( ) ; } $ event = new GetPageDetailsEvent ( $ pageId ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; return $ event -> getPageDetails ( ) ; } 
private function determineJumpToInformation ( ) { 
public function buildJumpToUrlFor ( IItem $ item ) { $ information = $ this -> determineJumpToInformation ( ) ; if ( empty ( $ information [ 'pageDetails' ] ) ) { return array ( ) ; } $ result = $ information ; $ parameterList = [ ] ; $ filterUrl = new FilterUrl ( $ information [ 'pageDetails' ] ) ; if ( ! empty ( $ information [ 'language' ] ) ) { $ filterUrl -> setPageValue ( 'language' , $ information [ 'language' ] ) ; } if ( ! empty ( $ information [ 'filterSetting' ] ) ) { $ filterSetting = $ information [ 'filterSetting' ] ; $ parameterList = $ filterSetting -> generateFilterUrlFrom ( $ item , $ this ) ; foreach ( $ parameterList as $ strKey => $ strValue ) { 
public function handle ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getPropertyName ( ) !== 'filter' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ pid = $ model -> getProperty ( 'pid' ) ; if ( empty ( $ pid ) ) { return ; } $ filters = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' , 'name' ) -> from ( 'tl_metamodel_filter' ) -> where ( 'pid=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ options = [ ] ; foreach ( $ filters as $ filter ) { $ options [ $ filter [ 'id' ] ] = $ filter [ 'name' ] ; } $ event -> setOptions ( $ options ) ; } 
public function getBackendIcon ( $ icon , $ defaultIcon = 'bundles/metamodelscore/images/icons/metamodels.png' ) { $ realIcon = $ this -> convertValueToPath ( $ icon , $ defaultIcon ) ; $ targetPath = $ this -> outputPath . '/' . basename ( $ realIcon ) ; if ( \ file_exists ( $ targetPath ) ) { return $ this -> webPath . '/' . basename ( $ realIcon ) ; } $ this -> imageFactory -> create ( $ realIcon , [ 16 , 16 , 'center_center' ] , $ targetPath ) ; return $ this -> webPath . '/' . basename ( $ realIcon ) ; } 
public function getBackendIconImageTag ( $ icon , $ alt = '' , $ attributes = '' , $ defaultIcon = 'bundles/metamodelscore/images/icons/metamodels.png' ) { return $ this -> image -> getHtml ( $ this -> getBackendIcon ( $ icon , $ defaultIcon ) , $ alt , $ attributes ) ; } 
public function convertValueToPath ( $ varValue , $ fallback ) { if ( Validator :: isUuid ( $ varValue ) ) { $ model = $ this -> filesAdapter -> findByPk ( $ varValue ) ; if ( $ model !== null && file_exists ( $ this -> rootPath . '/' . $ model -> path ) ) { return $ model -> path ; } return $ fallback ; } if ( file_exists ( $ varValue ) ) { return $ varValue ; } return $ fallback ; } 
public function setServiceContainer ( IMetaModelsServiceContainer $ serviceContainer , $ deprecationNotice = true ) { if ( $ deprecationNotice ) { 
public function addTypeFactory ( $ factory ) { $ typeName = $ factory -> getTypeName ( ) ; if ( isset ( $ this -> typeFactories [ $ typeName ] ) ) { throw new \ RuntimeException ( 'Filter type ' . $ typeName . ' is already registered.' ) ; } $ this -> typeFactories [ $ typeName ] = $ factory ; return $ this ; } 
public function getTypeFactory ( $ type ) { return isset ( $ this -> typeFactories [ $ type ] ) ? $ this -> typeFactories [ $ type ] : null ; } 
private function createSetting ( $ dbResult , $ filterSettings ) { $ factory = $ this -> getTypeFactory ( $ dbResult [ 'type' ] ) ; if ( $ factory ) { $ setting = $ factory -> createInstance ( $ dbResult , $ filterSettings ) ; if ( ! $ setting ) { return null ; } 
private function collectRulesFor ( $ parentSetting , $ filterSettings ) { $ childInformation = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'pid' , $ parentSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ childInformation -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ childSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ childSetting ) { $ parentSetting -> addChild ( $ childSetting ) ; } } } 
public function collectRules ( $ filterSettings ) { $ information = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'fid=:fid' ) -> andWhere ( 'pid=0' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'fid' , $ filterSettings -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ information -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ newSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ newSetting ) { $ filterSettings -> addSetting ( $ newSetting ) ; } } } 
public function createCollection ( $ settingId ) { $ query = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filter' ) -> where ( 'id=:id' ) -> setMaxResults ( 1 ) -> setParameter ( 'id' , $ settingId ) -> execute ( ) ; if ( ! $ query ) { throw new \ RuntimeException ( 'Could not retrieve filter setting' ) ; } if ( ! empty ( $ information = $ query -> fetch ( \ PDO :: FETCH_ASSOC ) ) ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ information [ 'pid' ] ) ) ; if ( $ metaModel === null ) { throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ information [ 'pid' ] ) ; } $ collection = new Collection ( $ information ) ; $ collection -> setMetaModel ( $ metaModel ) ; $ this -> collectRules ( $ collection ) ; return $ collection ; } return new Collection ( array ( ) ) ; } 
public function editRenderSettingButton ( \ DC_Table $ dataContainer ) { if ( $ dataContainer -> value < 1 ) { return '' ; } $ url = $ this -> urlBuilderFactory -> create ( 'contao/main.php?do=metamodels&table=tl_metamodel_rendersetting' ) -> setQueryParameter ( 'pid' , ModelId :: fromValues ( 'tl_metamodel_rendersettings' , $ dataContainer -> value ) -> getSerialized ( ) ) ; return $ this -> renderEditButton ( $ GLOBALS [ 'TL_LANG' ] [ static :: $ tableName ] [ 'editrendersetting' ] [ 0 ] , sprintf ( StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ static :: $ tableName ] [ 'editrendersetting' ] [ 1 ] ) , $ dataContainer -> value ) , $ url ) ; } 
public function getAttributeNames ( \ DC_Table $ objDc ) { $ attributeNames = [ 'sorting' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodels_sorting' ] , 'random' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'random' ] , 'id' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'id' ] [ 0 ] ] ; $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ objDc -> activeRecord -> metamodel ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( $ metaModel ) { foreach ( $ metaModel -> getAttributes ( ) as $ objAttribute ) { $ attributeNames [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; } } return $ attributeNames ; } 
public function getFilterSettings ( \ DC_Table $ objDC ) { $ filterSettings = $ this -> connection -> createQueryBuilder ( ) -> select ( 'f.id' , 'f.name' ) -> from ( 'tl_metamodel_filter' , 'f' ) -> where ( 'f.pid=:id' ) -> setParameter ( 'id' , $ objDC -> activeRecord -> metamodel ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ filterSettings as $ filterSetting ) { $ result [ $ filterSetting [ 'id' ] ] = $ filterSetting [ 'name' ] ; } 
protected function buildFilterParamsFor ( \ DC_Table $ dataContainer , $ elementName ) { if ( ! $ this -> requestStack -> getCurrentRequest ( ) -> query -> get ( 'act' ) ) { return ; } $ filterId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'c.metamodel_filtering' ) -> from ( static :: $ tableName , 'c' ) -> join ( 'c' , 'tl_metamodel' , 'mm' , 'mm.id=c.metamodel' ) -> where ( 'c.id=:id' ) -> setParameter ( 'id' , $ dataContainer -> id ) -> andWhere ( 'c.type=:type' ) -> setParameter ( 'type' , $ elementName ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_COLUMN ) ; if ( ! $ filterId ) { unset ( $ GLOBALS [ 'TL_DCA' ] [ static :: $ tableName ] [ 'fields' ] [ 'metamodel_filterparams' ] ) ; return ; } $ collection = $ this -> filterFactory -> createCollection ( $ filterId ) ; $ dca = $ collection -> getParameterDCA ( ) ; foreach ( $ dca as $ fieldName => $ subField ) { $ options = [ ] ; foreach ( $ subField [ 'options' ] as $ key => $ value ) { $ options [ $ this -> loadCallback ( $ key ) ] = $ value ; } $ dca [ $ fieldName ] [ 'options' ] = $ options ; $ dca [ $ fieldName ] [ 'save_callback' ] [ ] = [ static :: class , 'saveCallback' ] ; $ dca [ $ fieldName ] [ 'load_callback' ] [ ] = [ static :: class , 'loadCallback' ] ; } $ GLOBALS [ 'TL_DCA' ] [ static :: $ tableName ] [ 'fields' ] [ 'metamodel_filterparams' ] [ 'eval' ] [ 'subfields' ] = $ dca ; } 
public function loadCallback ( string $ value = null ) { return null === $ value ? null : trim ( \ base64_encode ( $ value ) , '=' ) ; } 
public function getFilterParameterNames ( \ DC_Table $ objDc ) { $ return = array ( ) ; $ filter = $ objDc -> activeRecord -> metamodel_filtering ; if ( ! $ filter ) { return $ return ; } $ collection = $ this -> filterFactory -> createCollection ( $ filter ) ; return $ collection -> getParameterFilterNames ( ) ; } 
private function renderEditButton ( $ caption , $ title , UrlBuilder $ url ) { $ icon = $ this -> iconBuilder -> getBackendIconImageTag ( 'system/themes/flexible/icons/alias.svg' , $ caption , 'style="vertical-align:top"' ) ; return sprintf ( '<a href="%s" title="%s" style="padding-left:3px">%s</a>' , $ url -> getUrl ( ) , $ title , $ icon ) ; } 
private function getFilteredAttributeNames ( $ metaModelId , $ allowedTypes = array ( ) ) { $ attributeNames = array ( ) ; if ( $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ) ) { foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( empty ( $ allowedTypes ) || in_array ( $ attribute -> get ( 'type' ) , $ allowedTypes ) ) { $ attributeNames [ $ attribute -> getColName ( ) ] = sprintf ( '%s [%s]' , $ attribute -> getName ( ) , $ attribute -> getColName ( ) ) ; } } } return $ attributeNames ; } 
protected function getMetaModel ( $ metaModelId ) { if ( null === $ this -> factory ) { throw new \ RuntimeException ( 'No factory set.' ) ; } $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; return $ metaModel ; } 
public function getTemplates ( \ DC_Table $ objDC ) { $ type = $ objDC -> activeRecord -> type ; return $ this -> getTemplateList ( 'mod_' . $ type ) ; } 
public function prepareRules ( IFilter $ objFilter , $ arrFilterUrl ) { $ objSubFilter = new Filter ( $ this -> getMetaModel ( ) ) ; foreach ( $ this -> arrChildren as $ objChildSetting ) { $ objChildSetting -> prepareRules ( $ objSubFilter , $ arrFilterUrl ) ; } $ objFilterRule = new FilterRuleAnd ( ) ; $ objFilterRule -> addChild ( $ objSubFilter ) ; $ objFilter -> addFilterRule ( $ objFilterRule ) ; } 
public function pagePicker ( ManipulateWidgetEvent $ event ) { if ( ! $ this -> scopeDeterminator -> currentScopeIsBackend ( ) || ! ( 'tl_metamodel_rendersettings' === $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ! ( ( 0 === strpos ( $ event -> getProperty ( ) -> getName ( ) , 'jumpTo' ) ) && ( '[value]' === substr ( $ event -> getProperty ( ) -> getName ( ) , - \ strlen ( '[value]' ) ) ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ pickerUrl = $ this -> pickerBuilder -> getUrl ( 'cca_link' ) ; $ urlEvent = new GenerateHtmlEvent ( 'pickpage.svg' , $ environment -> getTranslator ( ) -> translate ( 'MSC.pagepicker' ) , 'style="vertical-middle:top;cursor:pointer"' ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: IMAGE_GET_HTML , $ urlEvent ) ; $ template = new ContaoBackendViewTemplate ( 'dc_general_wizard_link_url_picker' ) ; $ template -> set ( 'name' , $ event -> getWidget ( ) -> name ) -> set ( 'popupUrl' , $ pickerUrl ) -> set ( 'html' , ' ' . $ urlEvent -> getHtml ( ) ) -> set ( 'label' , $ event -> getProperty ( ) -> getLabel ( ) [ 1 ] ) -> set ( 'id' , $ event -> getWidget ( ) -> id ) ; $ event -> getWidget ( ) -> wizard = $ template -> parse ( ) ; } 
public function handleMetaChange ( $ strMetaName , $ varNewValue ) { 
public function setDataFor ( $ arrValues ) { $ strTable = $ this -> getMetaModel ( ) -> getTableName ( ) ; $ strColName = $ this -> getColName ( ) ; foreach ( $ arrValues as $ intId => $ varData ) { if ( is_array ( $ varData ) ) { $ varData = serialize ( $ varData ) ; } $ this -> connection -> update ( $ strTable , [ $ strColName => $ varData ] , [ 'id' => $ intId ] ) ; } } 
public function sortIds ( $ idList , $ strDirection ) { 
public function searchFor ( $ strPattern ) { 
public function createColumn ( ) { if ( $ this -> getColName ( ) ) { $ this -> tableManipulator -> createColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) , $ this -> getSQLDataType ( ) ) ; } } 
public function deleteColumn ( ) { $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; $ columns = $ schemaManager -> listTableColumns ( $ this -> getMetaModel ( ) -> getTableName ( ) ) ; 
public function renameColumn ( $ strNewColumnName ) { $ this -> tableManipulator -> checkColumnName ( $ strNewColumnName ) ; $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; $ columns = $ schemaManager -> listTableIndexes ( $ this -> getMetaModel ( ) -> getTableName ( ) ) ; if ( $ this -> getColName ( ) && isset ( $ columns [ $ this -> getColName ( ) ] ) ) { $ this -> tableManipulator -> renameColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) , $ strNewColumnName , $ this -> getSQLDataType ( ) ) ; } else { $ strBackupColName = $ this -> getColName ( ) ; $ this -> set ( 'colname' , $ strNewColumnName ) ; $ this -> createColumn ( ) ; $ this -> set ( 'colname' , $ strBackupColName ) ; } } 
public function handle ( GetOptionsEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getPropertyName ( ) ) || ( 'dca_id' !== $ event -> getSubPropertyName ( ) ) ) { return ; } $ screens = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' ) -> addSelect ( 'name' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ event -> getModel ( ) -> getProperty ( 'id' ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ screens as $ screen ) { $ result [ $ screen [ 'id' ] ] = $ screen [ 'name' ] ; } $ event -> setOptions ( $ result ) ; } 
public function handle ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( $ event -> getModel ( ) -> getProperty ( 'isdefault' ) ) { $ event -> setLabel ( sprintf ( '%s <span style="color:#b3b3b3; padding-left:3px">[%s]</span>' , $ event -> getLabel ( ) , $ this -> translator -> trans ( 'MSC.fallback' , [ ] , 'contao_default' ) ) ) ; } } 
public function addFilterRule ( IFilterRule $ objFilterRule ) { 
public function getMatchingIds ( ) { if ( $ this -> arrMatches !== null ) { return $ this -> arrMatches ; } $ arrIds = null ; foreach ( $ this -> arrFilterRules as $ objFilterRule ) { $ arrRuleIds = $ objFilterRule -> getMatchingIds ( ) ; if ( $ arrRuleIds === null ) { continue ; } 
protected function getPropertyNames ( ) { $ propertyNames = array ( 'id' , 'pid' , 'tstamp' , 'sorting' ) ; if ( $ this -> getItem ( ) -> getMetaModel ( ) -> hasVariants ( ) ) { $ propertyNames [ ] = 'varbase' ; $ propertyNames [ ] = 'vargroup' ; } return array_merge ( $ propertyNames , array_keys ( $ this -> getItem ( ) -> getMetaModel ( ) -> getAttributes ( ) ) ) ; } 
public function getProperty ( $ strPropertyName ) { if ( $ this -> getItem ( ) ) { $ varValue = $ this -> getItem ( ) -> get ( $ strPropertyName ) ; 
public function getPropertiesAsArray ( ) { $ arrResult = array ( ) ; foreach ( $ this -> getPropertyNames ( ) as $ strKey ) { $ arrResult [ $ strKey ] = $ this -> getProperty ( $ strKey ) ; } return $ arrResult ; } 
public function getMeta ( $ strMetaName ) { if ( array_key_exists ( $ strMetaName , $ this -> arrMetaInformation ) ) { return $ this -> arrMetaInformation [ $ strMetaName ] ; } return null ; } 
public function setId ( $ mixID ) { if ( $ this -> getId ( ) == null ) { $ this -> getItem ( ) -> set ( 'id' , $ mixID ) ; $ this -> setMeta ( static :: IS_CHANGED , true ) ; } } 
public function setProperty ( $ strPropertyName , $ varValue ) { if ( $ this -> getItem ( ) ) { $ varInternalValue = $ varValue ; 
public function setPropertiesAsArray ( $ arrProperties ) { foreach ( $ arrProperties as $ strKey => $ varValue ) { $ this -> setProperty ( $ strKey , $ varValue ) ; } } 
public function readFromPropertyValueBag ( PropertyValueBagInterface $ valueBag ) { foreach ( $ this -> getPropertyNames ( ) as $ property ) { if ( ! $ valueBag -> hasPropertyValue ( $ property ) ) { continue ; } if ( $ valueBag -> isPropertyValueInvalid ( $ property ) ) { throw new DcGeneralInvalidArgumentException ( 'The value for property ' . $ property . ' is invalid.' ) ; } $ this -> setProperty ( $ property , $ valueBag -> getPropertyValue ( $ property ) ) ; } } 
public function writeToPropertyValueBag ( PropertyValueBagInterface $ valueBag ) { foreach ( $ this -> getPropertyNames ( ) as $ property ) { if ( ! $ valueBag -> hasPropertyValue ( $ property ) ) { continue ; } $ valueBag -> setPropertyValue ( $ property , $ this -> getProperty ( $ property ) ) ; } } 
public function createInstance ( $ information , $ filterSettings ) { return new SimpleLookup ( $ filterSettings , $ information , $ this -> dispatcher , $ this -> filterUrlBuilder ) ; } 
public function handle ( GetOptionsEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getPropertyName ( ) ) || ! in_array ( $ event -> getSubPropertyName ( ) , [ 'be_group' , 'fe_group' ] ) ) { return ; } $ isBackend = 'be_group' === $ event -> getSubPropertyName ( ) ; $ groups = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' ) -> addSelect ( 'name' ) -> from ( $ isBackend ? 'tl_user_group' : 'tl_member_group' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; $ result [ - 1 ] = $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( $ isBackend ? 'sysadmin' : 'anonymous' , 'tl_metamodel_dca_combine' ) ; foreach ( $ groups as $ group ) { $ result [ $ group [ 'id' ] ] = $ group [ 'name' ] ; } $ event -> setOptions ( $ result ) ; } 
public function handle ( GetOperationButtonEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ command = $ event -> getCommand ( ) ; if ( $ command -> getName ( ) == 'dca_combine' ) { $ event -> setHref ( UrlBuilder :: fromUrl ( $ event -> getHref ( ) ) -> setQueryParameter ( 'id' , ModelId :: fromValues ( 'tl_metamodel_dca_combine' , $ event -> getModel ( ) -> getId ( ) ) -> getSerialized ( ) ) -> getUrl ( ) ) ; } } 
public function handle ( BuildDataDefinitionEvent $ event ) { $ container = $ event -> getContainer ( ) ; if ( $ container instanceof IMetaModelDataDefinition ) { $ this -> build ( $ container ) ; } } 
public function getTypeOfAttribute ( $ value ) { if ( ! isset ( self :: $ attributeTypes [ $ value ] ) ) { $ statement = $ this -> connection -> createQueryBuilder ( ) -> select ( 'type' ) -> from ( 'tl_metamodel_attribute' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ value ) -> setMaxResults ( 1 ) -> execute ( ) ; self :: $ attributeTypes [ $ value ] = $ statement -> fetch ( \ PDO :: FETCH_COLUMN ) ; } return self :: $ attributeTypes [ $ value ] ; } 
public function match ( ModelInterface $ model = null , PropertyValueBag $ input = null , PropertyInterface $ property = null , LegendInterface $ legend = null ) { if ( $ input && $ input -> hasPropertyValue ( $ this -> idProperty ) ) { $ value = $ input -> getPropertyValue ( $ this -> idProperty ) ; } elseif ( $ model ) { $ value = $ model -> getProperty ( $ this -> idProperty ) ; } else { return false ; } return $ this -> getTypeOfAttribute ( $ value ) === $ this -> getAttributeType ( ) ; } 
public function setAcceptedExtensions ( $ acceptedExtensions ) { 
public function addPathById ( $ strId ) { 
protected function collectFiles ( ) { $ table = FilesModel :: getTable ( ) ; $ conditions = array ( ) ; $ parameters = array ( ) ; if ( count ( $ this -> pendingIds ) ) { $ conditions [ ] = $ table . '.uuid IN(' . implode ( ',' , array_fill ( 0 , count ( $ this -> pendingIds ) , 'UNHEX(?)' ) ) . ')' ; $ parameters = array_map ( 'bin2hex' , $ this -> pendingIds ) ; $ this -> pendingIds = array ( ) ; } if ( count ( $ this -> pendingPaths ) ) { $ slug = $ table . '.path LIKE ?' ; foreach ( $ this -> pendingPaths as $ pendingPath ) { $ conditions [ ] = $ slug ; $ parameters [ ] = $ pendingPath . '%' ; } $ this -> pendingPaths = array ( ) ; } if ( ! count ( $ conditions ) ) { return ; } if ( $ files = FilesModel :: findBy ( array ( implode ( ' OR ' , $ conditions ) ) , $ parameters ) ) { $ this -> addFileModels ( $ files ) ; } if ( count ( $ this -> pendingPaths ) ) { 
protected function getDownloadLink ( $ strFile ) { if ( ! isset ( $ _SESSION [ 'metaModels_downloads' ] [ $ strFile ] ) ) { $ _SESSION [ 'metaModels_downloads' ] [ $ strFile ] = md5 ( uniqid ( ) ) ; } return UrlBuilder :: fromUrl ( Environment :: get ( 'request' ) ) -> setQueryParameter ( 'file' , urlencode ( $ strFile ) ) -> setQueryParameter ( 'fileKey' , $ _SESSION [ 'metaModels_downloads' ] [ $ strFile ] ) -> getUrl ( ) ; } 
protected function fetchAdditionalData ( ) { $ this -> modifiedTime = array ( ) ; $ this -> outputBuffer = array ( ) ; if ( ! $ this -> foundFiles ) { return ; } foreach ( $ this -> foundFiles as $ strFile ) { $ this -> processFile ( $ strFile ) ; } } 
protected function remapSorting ( $ arrFiles , $ arrSource ) { $ files = array ( ) ; $ source = array ( ) ; foreach ( array_keys ( $ arrFiles ) as $ k ) { $ files [ ] = $ arrFiles [ $ k ] ; $ source [ ] = $ arrSource [ $ k ] ; } $ this -> addClasses ( $ source ) ; return array ( 'files' => $ files , 'source' => $ source ) ; } 
public function sortFiles ( $ sortType , $ sortIds = array ( ) ) { switch ( $ sortType ) { case 'name_desc' : return $ this -> sortByName ( false ) ; case 'date_asc' : return $ this -> sortByDate ( true ) ; case 'date_desc' : return $ this -> sortByDate ( false ) ; case 'manual' : return $ this -> sortByIdList ( $ sortIds ) ; case 'random' : return $ this -> sortByRandom ( ) ; default : case 'name_asc' : } return $ this -> sortByName ( true ) ; } 
protected function addClasses ( & $ arrSource ) { $ countFiles = count ( $ arrSource ) ; foreach ( array_keys ( $ arrSource ) as $ k ) { $ arrSource [ $ k ] [ 'class' ] = ( ( $ k == 0 ) ? ' first' : '' ) . ( ( $ k == ( $ countFiles - 1 ) ) ? ' last' : '' ) . ( ( ( $ k % 2 ) == 0 ) ? ' even' : ' odd' ) ; } } 
protected function sortByName ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } \ uasort ( $ arrFiles , ( $ blnAscending ) ? '\basename_natcasecmp' : '\basename_natcasercmp' ) ; return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; } 
protected function sortByDate ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; $ arrDates = $ this -> modifiedTime ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } if ( $ blnAscending ) { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_ASC ) ; } else { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_DESC ) ; } return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; } 
protected function sortByIdList ( $ sortIds ) { $ fileMap = $ this -> foundFiles ; if ( ! $ fileMap ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } $ fileKeys = array_flip ( array_keys ( $ this -> uuidMap ) ) ; $ sorted = array ( ) ; foreach ( $ sortIds as $ sortStringId ) { $ key = $ fileKeys [ $ sortStringId ] ; $ sorted [ $ key ] = $ fileMap [ $ key ] ; unset ( $ fileMap [ $ key ] ) ; } 
protected function sortByRandom ( ) { $ arrFiles = $ this -> foundFiles ; $ arrSource = $ this -> outputBuffer ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } $ keys = array_keys ( $ arrFiles ) ; $ files = array ( ) ; shuffle ( $ keys ) ; foreach ( $ keys as $ key ) { $ files [ $ key ] = $ arrFiles [ $ key ] ; } return $ this -> remapSorting ( $ files , $ arrSource ) ; } 
private function checkDownloads ( ) { 
public static function convertValueToPath ( $ varValue ) { if ( empty ( $ varValue ) ) { return '' ; } $ objFiles = FilesModel :: findByPk ( $ varValue ) ; if ( $ objFiles !== null ) { return $ objFiles -> path ; } return '' ; } 
public static function convertValuesToDatabase ( $ values ) { if ( ! ( isset ( $ values [ 'bin' ] ) && isset ( $ values [ 'value' ] ) && isset ( $ values [ 'path' ] ) ) ) { throw new InvalidArgumentException ( 'Invalid file array' ) ; } $ bin = array ( ) ; foreach ( $ values [ 'bin' ] as $ value ) { $ bin [ ] = $ value ; } return $ bin ; } 
public static function convertValuesToMetaModels ( $ values ) { if ( ! is_array ( $ values ) ) { throw new InvalidArgumentException ( 'Invalid uuid list.' ) ; } 
public static function convertUuidsOrPathsToMetaModels ( $ values ) { $ values = array_filter ( ( array ) $ values ) ; if ( empty ( $ values ) ) { return array ( 'bin' => array ( ) , 'value' => array ( ) , 'path' => array ( ) , 'meta' => array ( ) ) ; } foreach ( $ values as $ key => $ value ) { if ( ! ( Validator :: isUuid ( $ value ) ) ) { $ file = FilesModel :: findByPath ( $ value ) ? : Dbafs :: addResource ( $ value ) ; if ( ! $ file ) { throw new InvalidArgumentException ( 'Invalid value.' ) ; } $ values [ $ key ] = $ file -> uuid ; } } return self :: convertValuesToMetaModels ( $ values ) ; } 
private function addFileModels ( $ files , $ skipPaths = array ( ) ) { $ baseLanguage = $ this -> getBaseLanguage ( ) ; $ fallbackLanguage = $ this -> getFallbackLanguage ( ) ; foreach ( $ files as $ file ) { if ( 'folder' === $ file -> type && ! in_array ( $ file -> path , $ skipPaths ) ) { $ this -> pendingPaths [ ] = $ file -> path . '/' ; continue ; } if ( is_file ( TL_ROOT . DIRECTORY_SEPARATOR . $ file -> path ) && in_array ( strtolower ( pathinfo ( $ file -> path , PATHINFO_EXTENSION ) ) , $ this -> acceptedExtensions ) ) { $ path = $ file -> path ; $ this -> foundFiles [ ] = $ path ; $ this -> uuidMap [ $ file -> uuid ] = $ path ; $ meta = StringUtil :: deserialize ( $ file -> meta , true ) ; if ( isset ( $ meta [ $ baseLanguage ] ) ) { $ this -> metaInformation [ dirname ( $ path ) ] [ basename ( $ path ) ] = $ meta [ $ baseLanguage ] ; } elseif ( isset ( $ meta [ $ fallbackLanguage ] ) ) { $ this -> metaInformation [ dirname ( $ path ) ] [ basename ( $ path ) ] = $ meta [ $ fallbackLanguage ] ; } } } } 
private function processFile ( $ fileName ) { $ file = new File ( $ fileName ) ; $ meta = $ this -> metaInformation [ dirname ( $ fileName ) ] [ $ file -> basename ] ; $ title = strlen ( $ meta [ 'title' ] ) ? $ meta [ 'title' ] : StringUtil :: specialchars ( $ file -> basename ) ; if ( strlen ( $ meta [ 'caption' ] ) ) { $ altText = $ meta [ 'caption' ] ; } else { $ altText = ucfirst ( str_replace ( '_' , ' ' , preg_replace ( '/^[0-9]+_/' , '' , $ file -> filename ) ) ) ; } $ information = [ 'file' => $ fileName , 'mtime' => $ file -> mtime , 'alt' => $ altText , 'caption' => ( ! empty ( $ meta [ 'caption' ] ) ? $ meta [ 'caption' ] : '' ) , 'title' => $ title , 'metafile' => $ meta , 'icon' => 'assets/contao/images/' . $ file -> icon , 'extension' => $ file -> extension , 'size' => $ file -> filesize , 'sizetext' => sprintf ( '(%s)' , Controller :: getReadableSize ( $ file -> filesize , 2 ) ) , 'url' => StringUtil :: specialchars ( $ this -> getDownloadLink ( $ fileName ) ) ] ; 
private function resizeImage ( $ fileName ) { list ( $ width , $ height , $ mode ) = $ this -> getResizeImages ( ) ; if ( $ this -> getShowImages ( ) && ( $ width || $ height || $ mode ) ) { if ( $ this -> imageFactory ) { $ image = $ this -> imageFactory -> create ( $ this -> rootDir . '/' . $ fileName , [ $ width , $ height , $ mode ] ) ; return $ image -> getUrl ( $ this -> rootDir ) ; } $ event = new ResizeImageEvent ( $ fileName , $ width , $ height , $ mode ) ; $ this -> dispatcher -> dispatch ( ContaoEvents :: IMAGE_RESIZE , $ event ) ; return $ event -> getResultImage ( ) ; } return $ fileName ; } 
protected function createEmptyDataFor ( IAttribute $ attribute , $ parentId , $ activate , $ sort ) { $ result = [ 'attr_id' => $ attribute -> get ( 'id' ) , 'pid' => $ parentId , 'sorting' => $ sort , 'tstamp' => time ( ) , 'enabled' => $ activate ? '1' : '' ] ; $ defaults = $ attribute -> getDefaultRenderSettings ( ) ; foreach ( $ defaults -> getKeys ( ) as $ key ) { $ result [ $ key ] = $ defaults -> get ( $ key ) ; } return $ result ; } 
protected function getConnection ( ) { if ( null === $ this -> connection ) { 
public function generate ( ) { if ( TL_MODE == 'BE' ) { $ strInfo = '' ; if ( $ this -> metamodel ) { 
public function getValueOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ options = $ this -> getOptionsViaDcGeneral ( $ metaModel , $ event -> getEnvironment ( ) , $ attribute ) ; $ mangled = [ ] ; foreach ( ( array ) $ options as $ key => $ option ) { $ mangled [ 'value_' . $ key ] = $ option ; } $ event -> setOptions ( $ mangled ) ; } } 
public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = 'value_' . $ value ; } 
public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = substr ( $ value , 6 ) ; } 
public function setValueOptionsMultiple ( ManipulateWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( $ event -> getModel ( ) -> getProperty ( 'type' ) !== 'conditionpropertycontainanyof' ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ attribute = $ metaModel -> getAttributeById ( $ event -> getModel ( ) -> getProperty ( 'attr_id' ) ) ; if ( ! ( $ attribute && ( $ attribute -> get ( 'type' ) == 'tags' ) ) ) { return ; } $ event -> getWidget ( ) -> multiple = true ; } 
protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) ) { return false ; } if ( method_exists ( $ event , 'getPropertyName' ) && ( 'value' !== $ event -> getPropertyName ( ) ) ) { return false ; } if ( method_exists ( $ event , 'getProperty' ) ) { $ property = $ event -> getProperty ( ) ; if ( $ property instanceof PropertyInterface ) { $ property = $ property -> getName ( ) ; } if ( 'value' !== $ property ) { return false ; } } return true ; } 
private function getOptionsViaDcGeneral ( $ metaModel , $ environment , $ attribute ) { $ factory = DcGeneralFactory :: deriveEmptyFromEnvironment ( $ environment ) -> setContainerName ( $ metaModel -> getTableName ( ) ) ; $ dcGeneral = $ factory -> createDcGeneral ( ) ; $ subEnv = $ dcGeneral -> getEnvironment ( ) ; $ optEv = new GetPropertyOptionsEvent ( $ subEnv , $ subEnv -> getDataProvider ( ) -> getEmptyModel ( ) ) ; $ optEv -> setPropertyName ( $ attribute -> getColName ( ) ) ; $ subEnv -> getEventDispatcher ( ) -> dispatch ( GetPropertyOptionsEvent :: NAME , $ optEv ) ; $ options = $ optEv -> getOptions ( ) ; return $ options ; } 
protected function build ( IMetaModelDataDefinition $ container ) { $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( ! $ inputScreen ) { return ; } if ( $ container -> hasPropertiesDefinition ( ) ) { $ definition = $ container -> getPropertiesDefinition ( ) ; } else { $ definition = new DefaultPropertiesDefinition ( ) ; $ container -> setPropertiesDefinition ( $ definition ) ; } $ metaModel = $ this -> factory -> getMetaModel ( $ container -> getName ( ) ) ; 
private function buildProperty ( PropertiesDefinitionInterface $ definition , IAttribute $ attribute , array $ propInfo ) { if ( ! $ attribute ) { return ; } $ property = $ this -> getOrCreateProperty ( $ definition , $ attribute -> getColName ( ) ) ; $ this -> setLabel ( $ property , $ propInfo , $ attribute ) ; $ this -> setDescription ( $ property , $ propInfo ) ; $ this -> setDefaultValue ( $ property , $ propInfo ) ; $ this -> setExcluded ( $ property , $ propInfo ) ; $ this -> setSearchable ( $ property , $ propInfo ) ; $ this -> setFilterable ( $ property , $ propInfo ) ; $ this -> setWidgetType ( $ property , $ propInfo ) ; $ this -> setOptions ( $ property , $ propInfo ) ; $ this -> setExplanation ( $ property , $ propInfo ) ; $ this -> setEval ( $ property , $ propInfo , ( $ attribute instanceof ITranslated ) ) ; $ this -> setEmptyValue ( $ property , $ propInfo ) ; } 
private function getOrCreateProperty ( PropertiesDefinitionInterface $ definition , $ propName ) { if ( $ definition -> hasProperty ( $ propName ) ) { return $ definition -> getProperty ( $ propName ) ; } $ property = new DefaultProperty ( $ propName ) ; $ definition -> addProperty ( $ property ) ; return $ property ; } 
private function setLabel ( PropertyInterface $ property , $ propInfo , IAttribute $ attribute ) { if ( $ property -> getLabel ( ) ) { return ; } if ( ! isset ( $ propInfo [ 'label' ] ) ) { $ property -> setLabel ( $ attribute -> getName ( ) ) ; return ; } $ lang = $ propInfo [ 'label' ] ; if ( is_array ( $ lang ) ) { $ property -> setLabel ( reset ( $ lang ) ) ; $ property -> setDescription ( next ( $ lang ) ) ; return ; } $ property -> setLabel ( $ lang ) ; } 
private function setDescription ( PropertyInterface $ property , $ propInfo ) { if ( $ property -> getDescription ( ) || ! isset ( $ propInfo [ 'description' ] ) ) { return ; } $ property -> setDescription ( $ propInfo [ 'description' ] ) ; } 
private function setExcluded ( PropertyInterface $ property , $ propInfo ) { if ( ! isset ( $ propInfo [ 'exclude' ] ) ) { return ; } $ property -> setExcluded ( ( bool ) $ propInfo [ 'exclude' ] ) ; } 
private function setSearchable ( PropertyInterface $ property , $ propInfo ) { if ( ! isset ( $ propInfo [ 'search' ] ) ) { return ; } $ property -> setSearchable ( ( bool ) $ propInfo [ 'search' ] ) ; } 
private function setWidgetType ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getWidgetType ( ) || ! isset ( $ propInfo [ 'inputType' ] ) ) { return ; } $ property -> setWidgetType ( $ propInfo [ 'inputType' ] ) ; } 
private function setOptions ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getOptions ( ) || ! isset ( $ propInfo [ 'options' ] ) ) { return ; } $ property -> setOptions ( $ propInfo [ 'options' ] ) ; } 
private function setExplanation ( PropertyInterface $ property , $ propInfo ) { if ( $ property -> getExplanation ( ) || ! isset ( $ propInfo [ 'explanation' ] ) ) { return ; } $ property -> setExplanation ( $ propInfo [ 'explanation' ] ) ; } 
private function setEval ( $ property , $ propInfo , $ isTranslated ) { $ extra = isset ( $ propInfo [ 'eval' ] ) ? $ propInfo [ 'eval' ] : [ ] ; if ( $ isTranslated ) { $ extra [ 'tl_class' ] = 'translat-attr' . ( ! empty ( $ extra [ 'tl_class' ] ) ? ' ' . $ extra [ 'tl_class' ] : '' ) ; } $ property -> setExtra ( array_merge ( ( array ) $ property -> getExtra ( ) , $ extra ) ) ; } 
private function setEmptyValue ( PropertyInterface $ property , array $ propInfo ) { if ( ! array_key_exists ( 'empty_value' , $ propInfo ) || ! ( $ property instanceof EmptyValueAwarePropertyInterface ) ) { return ; } $ property -> setEmptyValue ( $ propInfo [ 'empty_value' ] ) ; } 
public function translateIdToMetaModelName ( $ metaModelId ) { if ( ! isset ( $ this -> lookupMap [ $ metaModelId ] ) ) { $ event = new GetMetaModelNameFromIdEvent ( $ metaModelId ) ; $ this -> dispatcher -> dispatch ( $ event :: NAME , $ event ) ; $ this -> lookupMap [ $ metaModelId ] = $ event -> getMetaModelName ( ) ; } return $ this -> lookupMap [ $ metaModelId ] ; } 
public function getMetaModel ( $ metaModelName ) { $ event = new CreateMetaModelEvent ( $ this , $ metaModelName ) ; $ this -> dispatcher -> dispatch ( $ event :: NAME , $ event ) ; $ metaModel = $ event -> getMetaModel ( ) ; return $ metaModel ; } 
public function collectNames ( ) { $ event = new CollectMetaModelTableNamesEvent ( $ this ) ; $ this -> dispatcher -> dispatch ( $ event :: NAME , $ event ) ; return $ event -> getMetaModelNames ( ) ; } 
public function supportsNesting ( $ conditionType ) { if ( ! isset ( $ GLOBALS [ 'METAMODELS' ] [ 'inputscreen_conditions' ] [ $ conditionType ] [ 'nestingAllowed' ] ) ) { return null ; } 
public function maxChildren ( $ conditionType ) { if ( ! isset ( $ GLOBALS [ 'METAMODELS' ] [ 'inputscreen_conditions' ] [ $ conditionType ] [ 'maxChildren' ] ) ) { return null ; } 
public function supportsAttribute ( $ conditionType , $ attribute ) { if ( ! isset ( $ GLOBALS [ 'METAMODELS' ] [ 'inputscreen_conditions' ] [ $ conditionType ] [ 'attributes' ] ) ) { return null ; } 
public function createCondition ( array $ configuration , IMetaModel $ metaModel ) { $ event = new CreatePropertyConditionEvent ( $ configuration , $ metaModel ) ; $ this -> dispatcher -> dispatch ( CreatePropertyConditionEvent :: NAME , $ event ) ; if ( null === $ instance = $ event -> getInstance ( ) ) { throw new \ RuntimeException ( sprintf ( 'Condition of type %s could not be transformed to an instance.' , $ configuration [ 'type' ] ) ) ; } 
public function handle ( GetPropertyOptionsEvent $ event ) { if ( ( 'tl_metamodel_dca' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'ptable' !== $ event -> getPropertyName ( ) ) ) { return ; } $ tables = [ ] ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableNames ( ) as $ table ) { $ tables [ $ table ] = $ table ; } if ( 'ctable' === $ event -> getModel ( ) -> getProperty ( 'rendertype' ) ) { $ currentTable = $ this -> factory -> translateIdToMetaModelName ( $ event -> getModel ( ) -> getProperty ( 'pid' ) ) ; $ tables = array_filter ( $ tables , function ( $ table ) use ( $ currentTable ) { return ( $ currentTable !== $ table ) ; } ) ; } $ event -> setOptions ( $ tables ) ; } 
public static function decodeLangArray ( $ varValue , IMetaModel $ objMetaModel ) { $ arrLangValues = StringUtil :: deserialize ( $ varValue ) ; if ( ! $ objMetaModel -> isTranslated ( ) ) { 
public static function encodeLangArray ( $ varValue , IMetaModel $ objMetaModel ) { 
private static function buildLanguageArray ( IMetaModel $ metaModel , TranslatorInterface $ translator ) { $ languages = array ( ) ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ langCode ) { $ languages [ $ langCode ] = $ translator -> translate ( 'LNG.' . $ langCode , 'languages' ) ; } asort ( $ languages ) ; return $ languages ; } 
public static function prepareLanguageAwareWidget ( EnvironmentInterface $ environment , PropertyInterface $ property , IMetaModel $ metaModel , $ languageLabel , $ valueLabel , $ isTextArea , $ arrValues ) { if ( ! $ metaModel -> isTranslated ( ) ) { $ extra = $ property -> getExtra ( ) ; $ extra [ 'tl_class' ] .= empty ( $ extra [ 'tl_class' ] ) ? 'w50' : ' w50' ; $ property -> setWidgetType ( 'text' ) -> setExtra ( $ extra ) ; return ; } $ fallback = $ metaModel -> getFallbackLanguage ( ) ; $ languages = self :: buildLanguageArray ( $ metaModel , $ environment -> getTranslator ( ) ) ; $ neededKeys = array_keys ( $ languages ) ; 
public static function searchFiles ( $ folder , $ extension ) { $ scanResult = array ( ) ; $ result = array ( ) ; 
protected function calculate ( ) { 
public function onLoadDataContainer ( $ tableName ) { static $ tableExists ; 
private function handleMetaModelTable ( $ tableName ) { static $ tableNames ; if ( ! $ tableNames ) { $ tableNames = $ this -> factory -> collectNames ( ) ; } 
private function handleNonMetaModelTable ( $ tableName ) { 
private function buildMap ( ) { $ map = [ ] ; foreach ( $ this -> combination -> getParented ( ) as $ childName => $ child ) { $ map [ $ child [ 'meta' ] [ 'ptable' ] ] [ $ childName ] = $ child ; } return $ map ; } 
private function buildCaption ( $ metaModel , $ inputScreen ) : array { $ caption = [ sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) , '' ] ; foreach ( $ inputScreen [ 'label' ] as $ langCode => $ label ) { if ( $ label !== '' && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ label , $ inputScreen [ 'description' ] [ $ langCode ] ] ; } } return $ caption ; } 
private function buildChildOperationButton ( $ idParameter , $ itemId , $ href , $ label , $ name , $ icon , $ attributes , $ table ) { $ modelId = ModelId :: fromValues ( $ table , $ itemId ) ; $ url = $ href . '&amp;' . $ idParameter . '=' . $ modelId -> getSerialized ( ) ; 
public function internalParseAttribute ( $ objAttribute , $ strOutputFormat , $ objSettings ) { if ( $ objAttribute instanceof IInternal ) { return array ( ) ; } $ arrResult = array ( ) ; if ( $ objAttribute ) { 
protected function isEmptyValue ( $ mixValue ) { if ( is_array ( $ mixValue ) ) { return $ this -> isArrayEmpty ( $ mixValue ) ; } elseif ( $ mixValue === '' ) { return true ; } elseif ( $ mixValue === null ) { return true ; } return false ; } 
protected function isArrayEmpty ( $ arrArray ) { 
public function get ( $ strAttributeName ) { return array_key_exists ( $ strAttributeName , $ this -> arrData ) ? $ this -> arrData [ $ strAttributeName ] : null ; } 
public function getVariants ( $ objFilter ) { if ( $ this -> isVariantBase ( ) ) { return $ this -> getMetaModel ( ) -> findVariants ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; } return null ; } 
public function getVariantBase ( ) { if ( $ this -> getMetaModel ( ) -> hasVariants ( ) && ! $ this -> isVariantBase ( ) ) { return $ this -> getMetaModel ( ) -> findById ( $ this -> get ( 'vargroup' ) ) ; } return $ this ; } 
public function getSiblings ( $ objFilter ) { if ( ! $ this -> getMetaModel ( ) -> hasVariants ( ) ) { return null ; } return $ this -> getMetaModel ( ) -> findVariantsWithBase ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; } 
public function save ( $ timestamp = null ) { if ( null === $ timestamp ) { 
protected function registerAssets ( $ objSettings ) { if ( ! $ objSettings ) { return ; } 
public function parseValue ( $ strOutputFormat = 'text' , $ objSettings = null ) { $ this -> registerAssets ( $ objSettings ) ; $ arrResult = [ 'raw' => $ this -> arrData , 'text' => [ ] , 'attributes' => [ ] , $ strOutputFormat => [ ] , 'class' => '' , 'actions' => [ ] ] ; 
public function parseAttribute ( $ strAttributeName , $ strOutputFormat = 'text' , $ objSettings = null ) { return $ this -> internalParseAttribute ( $ this -> getAttribute ( $ strAttributeName ) , $ strOutputFormat , $ objSettings ) ; } 
public function copy ( ) { 
public function varCopy ( ) { $ objNewItem = $ this -> copy ( ) ; 
private function variantCssClass ( ) { if ( $ this -> isVariant ( ) ) { return 'variant' ; } if ( $ this -> isVariantBase ( ) ) { $ result = 'varbase' ; if ( 0 !== $ this -> getVariants ( null ) -> getCount ( ) ) { $ result .= ' varbase-with-variants' ; } return $ result ; } return '' ; } 
public function buildCondition ( array $ configuration , IMetaModel $ metaModel ) { return new PropertyContainAnyOfCondition ( $ this -> attributeIdToName ( $ metaModel , $ configuration [ 'attr_id' ] ) , StringUtil :: deserialize ( $ configuration [ 'value' ] ) ) ; } 
protected function build ( IMetaModelDataDefinition $ container ) { $ definition = $ this -> createOrGetDefinition ( $ container ) ; if ( empty ( $ combination = $ this -> viewCombination -> getCombination ( $ container -> getName ( ) ) ) ) { return ; } if ( ! $ definition -> hasActiveRenderSetting ( ) ) { $ definition -> setActiveRenderSetting ( $ combination [ 'view_id' ] ) ; } if ( ! $ definition -> hasActiveInputScreen ( ) ) { $ definition -> setActiveInputScreen ( $ combination [ 'dca_id' ] ) ; } } 
private function createOrGetDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasMetaModelDefinition ( ) ) { return $ container -> getMetaModelDefinition ( ) ; } $ container -> setMetaModelDefinition ( $ definition = new MetaModelDefinition ( ) ) ; return $ definition ; } 
public static function isReserveColumnPostFix ( $ strColName ) { $ inputProvider = new InputProvider ( ) ; if ( ! $ inputProvider -> hasValue ( 'colname' ) || strtolower ( $ strColName ) !== strtolower ( $ inputProvider -> getValue ( 'colname' ) ) ) { return false ; } foreach ( self :: $ reservedColumnPostFix as $ postFix ) { if ( $ postFix !== strtolower ( substr ( $ strColName , - strlen ( $ postFix ) ) ) ) { continue ; } return true ; } return false ; } 
public static function isValidColumnName ( $ strColName ) { return self :: isValidMySQLIdentifier ( $ strColName ) && ! self :: isReservedWord ( $ strColName ) && ! self :: isReserveColumnPostFix ( $ strColName ) ; } 
public static function checkColumnName ( $ strColName , $ blnAllowSystemCol = false ) { if ( ! self :: isValidColumnName ( $ strColName ) ) { throw new \ Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidColumnName' ] , $ strColName ) ) ; } if ( ( ! $ blnAllowSystemCol ) && self :: isSystemColumn ( $ strColName ) ) { throw new \ Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'systemColumn' ] , $ strColName ) ) ; } } 
public static function checkTableDoesNotExist ( $ strTableName ) { self :: checkTablename ( $ strTableName ) ; if ( self :: getDB ( ) -> tableExists ( $ strTableName , null , true ) ) { throw new \ Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'tableExists' ] , $ strTableName ) ) ; } } 
public static function createTable ( $ strTableName ) { self :: checkTableDoesNotExist ( $ strTableName ) ; self :: getDB ( ) -> execute ( sprintf ( self :: STATEMENT_CREATE_TABLE , $ strTableName ) ) ; } 
public static function renameTable ( $ strTableName , $ strNewTableName ) { self :: checkTableExists ( $ strTableName ) ; self :: checkTableDoesNotExist ( $ strNewTableName ) ; self :: getDB ( ) -> execute ( sprintf ( self :: STATEMENT_RENAME_TABLE , $ strTableName , $ strNewTableName ) ) ; } 
public static function deleteTable ( $ strTableName ) { self :: checkTableExists ( $ strTableName ) ; self :: getDB ( ) -> execute ( sprintf ( self :: STATEMENT_DROP_TABLE , $ strTableName ) ) ; } 
public static function addIndex ( $ strTableName , $ strIndexType , $ strColName ) { self :: checkColumnExists ( $ strTableName , $ strColName ) ; self :: getDB ( ) -> execute ( sprintf ( self :: STATEMENT_ADD_INDEX_COLUMN , $ strTableName , $ strIndexType , $ strColName ) ) ; } 
public static function checkColumnExists ( $ strTableName , $ strColName , $ blnAllowSystemCol = false ) { self :: checkTableExists ( $ strTableName ) ; self :: checkColumnName ( $ strColName , $ blnAllowSystemCol ) ; if ( ! self :: getDB ( ) -> fieldExists ( $ strColName , $ strTableName , true ) ) { throw new \ Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'columnDoesNotExist' ] , $ strColName , $ strTableName ) ) ; } } 
public static function createColumn ( $ strTableName , $ strColumnName , $ strType , $ blnAllowSystemCol = false ) { self :: checkColumnDoesNotExist ( $ strTableName , $ strColumnName , $ blnAllowSystemCol ) ; self :: getDB ( ) -> execute ( sprintf ( self :: STATEMENT_CREATE_COLUMN , $ strTableName , $ strColumnName , $ strType ) ) ; } 
public static function renameColumn ( $ strTableName , $ strColumnName , $ strNewColumnName , $ strNewType , $ blnAllowSystemCol = false ) { if ( $ strColumnName != $ strNewColumnName ) { self :: checkColumnExists ( $ strTableName , $ strColumnName , $ blnAllowSystemCol ) ; self :: checkColumnDoesNotExist ( $ strTableName , $ strNewColumnName , $ blnAllowSystemCol ) ; } self :: getDB ( ) -> execute ( sprintf ( self :: STATEMENT_RENAME_COLUMN , $ strTableName , $ strColumnName , $ strNewColumnName , $ strNewType ) ) ; } 
public static function dropColumn ( $ strTableName , $ strColumnName , $ blnAllowSystemCol = false ) { self :: checkColumnExists ( $ strTableName , $ strColumnName , $ blnAllowSystemCol ) ; self :: getDB ( ) -> execute ( sprintf ( self :: STATEMENT_DROP_COLUMN , $ strTableName , $ strColumnName ) ) ; } 
public static function setVariantSupport ( $ strTableName , $ blnVariantSupport ) { if ( $ blnVariantSupport ) { if ( self :: getDB ( ) -> tableExists ( $ strTableName , null , true ) && ( ! self :: getDB ( ) -> fieldExists ( 'varbase' , $ strTableName , true ) ) ) { self :: createColumn ( $ strTableName , 'varbase' , 'char(1) NOT NULL default \'\'' , true ) ; self :: createColumn ( $ strTableName , 'vargroup' , 'int(11) NOT NULL default 0' , true ) ; 
private function getJsonFile ( $ filename ) { if ( ! is_readable ( $ filename ) ) { return [ ] ; } $ contents = json_decode ( file_get_contents ( $ filename ) , true ) ; return $ contents ? : [ ] ; } 
protected function authenticateUser ( ) { if ( \ System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) -> currentScopeIsUnknown ( ) ) { return false ; } 
public function match ( ModelInterface $ model = null , PropertyValueBag $ input = null , PropertyInterface $ property = null , LegendInterface $ legend = null ) { if ( $ input && $ input -> hasPropertyValue ( $ this -> propertyName ) ) { $ values = $ input -> getPropertyValue ( $ this -> propertyName ) ; } elseif ( $ model ) { $ values = $ model -> getProperty ( $ this -> propertyName ) ; } else { return false ; } if ( ! $ values || ! is_array ( $ values ) ) { return false ; } foreach ( $ values as $ value ) { if ( in_array ( $ value , $ this -> propertyValue , $ this -> strict ) ) { return true ; } } return false ; } 
public function getInputScreen ( ) { return new InputScreen ( \ System :: getContainer ( ) -> get ( 'cca.legacy_dic' ) -> getService ( 'metamodels-service-container' ) , $ this -> inputScreen [ 'meta' ] , $ this -> inputScreen [ 'properties' ] , $ this -> inputScreen [ 'conditions' ] , $ this -> inputScreen [ 'groupSort' ] ) ; } 
protected function getMetaModelByModelPid ( ModelInterface $ model ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; if ( $ metaModel === null ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ model -> getProperty ( 'pid' ) ) ; } return $ metaModel ; } 
protected function createAttributeInstance ( ModelInterface $ model = null ) { if ( null === $ model ) { return null ; } return $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ this -> getMetaModelByModelPid ( $ model ) ) ; } 
public function getRenderGroupAttribute ( ) { if ( ! empty ( $ this -> data [ 'rendergroupattr' ] ) ) { $ metaModel = $ this -> getMetaModel ( ) ; if ( $ metaModel ) { $ attribute = $ metaModel -> getAttributeById ( $ this -> data [ 'rendergroupattr' ] ) ; if ( $ attribute ) { return $ attribute -> getColName ( ) ; } } } return '' ; } 
public function handle ( PreDeleteModelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( $ attribute = $ this -> createAttributeInstance ( $ event -> getModel ( ) ) ) { $ this -> deleteConditionSettings ( $ event ) ; $ attribute -> destroyAUX ( ) ; } } 
protected function deleteConditionSettings ( PreDeleteModelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ model = $ event -> getModel ( ) ; $ dataProvider = $ environment -> getDataProvider ( 'tl_metamodel_dcasetting_condition' ) ; $ conditions = $ dataProvider -> fetchAll ( $ dataProvider -> getEmptyConfig ( ) -> setFilter ( [ [ 'operation' => '=' , 'property' => 'attr_id' , 'value' => $ model -> getId ( ) ] ] ) ) ; if ( $ conditions -> count ( ) < 1 ) { return ; } $ conditionsGeneral = new \ DC_General ( $ dataProvider -> getEmptyModel ( ) -> getProviderName ( ) ) ; $ conditionsEnvironment = $ conditionsGeneral -> getEnvironment ( ) ; $ conditionsDataDefinition = $ conditionsEnvironment -> getDataDefinition ( ) ; $ conditionsPalettesDefinition = $ conditionsDataDefinition -> getPalettesDefinition ( ) ; $ conditionsIterator = $ conditions -> getIterator ( ) ; while ( $ currentCondition = $ conditionsIterator -> current ( ) ) { $ conditionPalette = $ conditionsPalettesDefinition -> getPaletteByName ( $ currentCondition -> getProperty ( 'type' ) ) ; $ conditionProperties = $ conditionPalette -> getVisibleProperties ( $ currentCondition ) ; foreach ( $ conditionProperties as $ conditionProperty ) { if ( $ conditionProperty -> getName ( ) !== 'attr_id' ) { continue ; } $ dataProvider -> delete ( $ currentCondition ) ; } $ conditionsIterator -> next ( ) ; } } 
protected function attributeIdToName ( IMetaModel $ metaModel , $ attributeId ) { if ( null === $ attribute = $ metaModel -> getAttributeById ( $ attributeId ) ) { throw new \ RuntimeException ( sprintf ( 'Could not retrieve attribute %s from MetaModel %s.' , $ attributeId , $ metaModel -> getTableName ( ) ) ) ; } return $ attribute -> getColName ( ) ; } 
public function getAttributeOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ result = [ ] ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ conditionType = $ event -> getModel ( ) -> getProperty ( 'type' ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( ! $ this -> conditionFactory -> supportsAttribute ( $ conditionType , $ attribute -> get ( 'type' ) ) ) { continue ; } $ typeName = $ attribute -> get ( 'type' ) ; $ strSelectVal = $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ; $ result [ $ strSelectVal ] = $ attribute -> getName ( ) . ' [' . $ typeName . ']' ; } $ event -> setOptions ( $ result ) ; } 
public function decodeAttributeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ attribute = $ metaModel -> getAttributeById ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ) ; } } 
public function encodeAttributeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } 
protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) ) { return false ; } if ( method_exists ( $ event , 'getPropertyName' ) && ( 'attr_id' !== $ event -> getPropertyName ( ) ) ) { return false ; } if ( method_exists ( $ event , 'getProperty' ) && ( 'attr_id' !== $ event -> getProperty ( ) ) ) { return false ; } return true ; } 
protected function build ( IMetaModelDataDefinition $ container ) { $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( ! $ inputScreen ) { return ; } $ meta = $ inputScreen [ 'meta' ] ; $ config = $ this -> getDataProviderDefinition ( $ container ) ; 
private function getDataProviderDefinition ( IMetaModelDataDefinition $ container ) { 
public function getGlobalButton ( GetGlobalButtonEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( 'addall' !== $ event -> getKey ( ) || 'tl_metamodel_rendersetting' !== $ environment -> getDataDefinition ( ) -> getName ( ) ) { return ; } $ renderSetting = ModelId :: fromSerialized ( $ environment -> getInputProvider ( ) -> getParameter ( 'pid' ) ) -> getId ( ) ; $ modelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'r.pid' ) -> from ( 'tl_metamodel_rendersettings' , 'r' ) -> where ( 'r.id=:pid' ) -> setParameter ( 'pid' , $ renderSetting ) -> execute ( ) -> fetchColumn ( ) ; $ name = $ this -> factory -> translateIdToMetaModelName ( $ modelId ) ; $ event -> setHref ( $ this -> urlGenerator -> generate ( 'metamodels.rendersetting.add_all' , [ 'metaModel' => $ name , 'renderSetting' => $ renderSetting ] ) ) ; } 
public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'colname' ) ) { return ; } $ oldColumnName = $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) ) ; $ columnName = $ event -> getValue ( ) ; $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; if ( ( ! $ columnName ) || $ oldColumnName !== $ columnName ) { $ this -> tableManipulator -> checkColumnDoesNotExist ( $ metaModel -> getTableName ( ) , $ columnName ) ; $ colNames = array_keys ( $ metaModel -> getAttributes ( ) ) ; if ( in_array ( $ columnName , $ colNames ) ) { throw new \ RuntimeException ( sprintf ( $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'columnExists' , 'ERR' ) , $ columnName , $ metaModel -> getTableName ( ) ) ) ; } } } 
protected function build ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; } else { $ view = new Contao2BackendViewDefinition ( ) ; $ container -> setDefinition ( Contao2BackendViewDefinitionInterface :: NAME , $ view ) ; } if ( ! $ view instanceof Contao2BackendViewDefinitionInterface ) { throw new DcGeneralInvalidArgumentException ( 'Configured BackendViewDefinition does not implement Contao2BackendViewDefinitionInterface.' ) ; } $ this -> container = $ container ; $ this -> inputScreen = $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( null === $ inputScreen ) { return ; } $ this -> addEditMultipleCommand ( $ view ) ; $ this -> parseModelOperations ( $ view ) ; $ this -> container = null ; $ this -> inputScreen = null ; if ( $ this -> dispatcher -> hasListeners ( BuildMetaModelOperationsEvent :: NAME ) ) { 
private function addEditMultipleCommand ( Contao2BackendViewDefinitionInterface $ view ) { $ definition = $ this -> container -> getBasicDefinition ( ) ; 
private function parseModelOperations ( Contao2BackendViewDefinitionInterface $ view ) { $ collection = $ view -> getModelCommands ( ) ; $ scrOffsetAttributes = [ 'attributes' => 'onclick="Backend.getScrollOffset();"' ] ; $ this -> createCommand ( $ collection , 'edit' , [ 'act' => 'edit' ] , 'edit.svg' ) ; $ this -> createCommand ( $ collection , 'copy' , [ 'act' => '' ] , 'copy.svg' , $ scrOffsetAttributes ) ; $ this -> createCommand ( $ collection , 'cut' , [ 'act' => 'paste' , 'mode' => 'cut' ] , 'cut.svg' , $ scrOffsetAttributes ) ; $ this -> createCommand ( $ collection , 'delete' , [ 'act' => 'delete' ] , 'delete.svg' , [ 'attributes' => sprintf ( 'onclick="if (!confirm(\'%s\')) return false; Backend.getScrollOffset();"' , $ this -> translator -> trans ( 'MSC.deleteConfirm' , [ ] , 'contao_default' ) ) ] ) ; $ this -> createCommand ( $ collection , 'show' , [ 'act' => 'show' ] , 'show.svg' ) ; if ( $ this -> factory -> getMetaModel ( $ this -> container -> getName ( ) ) -> hasVariants ( ) ) { $ this -> createCommand ( $ collection , 'createvariant' , [ 'act' => 'createvariant' ] , 'bundles/metamodelscore/images/icons/variants.png' ) ; } 
private function createCommand ( CommandCollectionInterface $ collection , $ operationName , $ queryParameters , $ icon , $ extraValues = [ ] ) { $ command = $ this -> getCommandInstance ( $ collection , $ operationName ) ; $ parameters = $ command -> getParameters ( ) ; foreach ( $ queryParameters as $ name => $ value ) { if ( ! isset ( $ parameters [ $ name ] ) ) { $ parameters [ $ name ] = $ value ; } } if ( ! $ command -> getLabel ( ) ) { $ command -> setLabel ( $ operationName . '.0' ) ; if ( isset ( $ extraValues [ 'label' ] ) ) { $ command -> setLabel ( $ extraValues [ 'label' ] ) ; } } if ( ! $ command -> getDescription ( ) ) { $ command -> setDescription ( $ operationName . '.1' ) ; if ( isset ( $ extraValues [ 'description' ] ) ) { $ command -> setDescription ( $ extraValues [ 'description' ] ) ; } } $ extra = $ command -> getExtra ( ) ; $ extra [ 'icon' ] = $ icon ; foreach ( $ extraValues as $ name => $ value ) { if ( ! isset ( $ extra [ $ name ] ) ) { $ extra [ $ name ] = $ value ; } } } 
private function getCommandInstance ( CommandCollectionInterface $ collection , $ operationName ) { if ( $ collection -> hasCommandNamed ( $ operationName ) ) { $ command = $ collection -> getCommandNamed ( $ operationName ) ; } else { switch ( $ operationName ) { case 'cut' : $ command = new CutCommand ( ) ; break ; case 'copy' : $ command = new CopyCommand ( ) ; break ; default : $ command = new Command ( ) ; } $ command -> setName ( $ operationName ) ; $ collection -> addCommand ( $ command ) ; } return $ command ; } 
private function getChildModelCaption ( $ metaModel , $ screen ) { $ caption = [ '' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) ] ; foreach ( $ screen [ 'label' ] as $ langCode => $ label ) { if ( ! empty ( $ label ) && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ screen [ 'description' ] [ $ langCode ] , $ label ] ; } } return $ caption ; } 
public function onGetUserNavigation ( $ modules ) { if ( null === $ request = $ this -> requestStack -> getCurrentRequest ( ) ) { return $ modules ; } $ this -> addBackendCss ( ) ; if ( null !== ( $ user = $ this -> tokenStorage -> getToken ( ) ) ) { $ userRights = $ this -> extractUserRights ( $ user ) ; } $ isAdmin = \ in_array ( 'ROLE_ADMIN' , array_map ( function ( Role $ role ) { return $ role -> getRole ( ) ; } , $ user -> getRoles ( ) ) , true ) ; if ( $ isAdmin || isset ( $ userRights [ 'support_metamodels' ] ) ) { $ this -> addMenu ( $ modules , 'metamodels' , 'support_screen' , [ 'label' => $ this -> translator -> trans ( 'MOD.support_metamodels.0' , [ ] , 'contao_modules' ) , 'title' => $ this -> translator -> trans ( 'MOD.support_metamodels.1' , [ ] , 'contao_modules' ) , 'route' => 'metamodels.support_screen' , 'param' => [ ] , ] , $ request ) ; } $ locale = $ request -> getLocale ( ) ; foreach ( $ this -> viewCombination -> getStandalone ( ) as $ metaModelName => $ screen ) { $ moduleName = 'metamodel_' . $ metaModelName ; if ( ! $ isAdmin && ! isset ( $ userRights [ $ moduleName ] ) ) { continue ; } $ this -> addMenu ( $ modules , $ screen [ 'meta' ] [ 'backendsection' ] , $ moduleName , [ 'label' => $ this -> extractLanguageValue ( $ screen [ 'label' ] , $ locale ) , 'title' => $ this -> extractLanguageValue ( $ screen [ 'description' ] , $ locale ) , 'route' => 'contao_backend' , 'param' => [ 'do' => 'metamodel_' . $ metaModelName ] , ] , $ request ) ; } return $ modules ; } 
private function extractUserRights ( TokenInterface $ token ) { $ beUser = $ token -> getUser ( ) ; if ( ! ( $ beUser instanceof BackendUser ) ) { return [ ] ; } $ allowedModules = $ beUser -> modules ; switch ( true ) { case \ is_string ( $ allowedModules ) : $ allowedModules = unserialize ( $ allowedModules , [ 'allowed_classes' => false ] ) ; break ; case null === $ allowedModules : $ allowedModules = [ ] ; break ; default : } return array_flip ( $ allowedModules ) ; } 
private function buildBackendMenuSection ( $ groupName , Request $ request ) { $ strRefererId = $ request -> attributes -> get ( '_contao_referer_id' ) ; $ label = $ this -> translator -> trans ( 'MOD.' . $ groupName , [ ] , 'contao_modules' ) ; if ( \ is_array ( $ label ) ) { $ label = $ label [ 0 ] ; } return [ 'class' => ' node-expanded' , 'title' => StringUtil :: specialchars ( $ this -> translator -> trans ( 'MSC.collapseNode' , [ ] , 'contao_modules' ) ) , 'label' => $ label , 'href' => $ this -> urlGenerator -> generate ( 'contao_backend' , [ 'do' => $ request -> get ( 'do' ) , 'mtg' => $ groupName , 'ref' => $ strRefererId ] ) , 'ajaxUrl' => $ this -> urlGenerator -> generate ( 'contao_backend' ) , 
private function addMenu ( & $ modules , $ section , $ name , $ module , Request $ request ) { if ( ! isset ( $ modules [ $ section ] ) ) { $ modules [ $ section ] = $ this -> buildBackendMenuSection ( $ section , $ request ) ; } $ active = $ this -> isActive ( $ module [ 'route' ] , $ module [ 'param' ] , $ request ) ; $ class = 'navigation ' . $ name ; if ( isset ( $ module [ 'class' ] ) ) { $ class .= ' ' . $ module [ 'class' ] ; } if ( $ active ) { $ class .= ' active' ; } if ( $ request -> query -> has ( 'ref' ) ) { $ module [ 'param' ] [ 'ref' ] = $ request -> query -> get ( 'ref' ) ; } $ modules [ $ section ] [ 'modules' ] [ $ name ] = [ 'label' => $ module [ 'label' ] , 'title' => $ module [ 'title' ] , 'class' => $ class , 'isActive' => $ active , 'href' => $ this -> urlGenerator -> generate ( $ module [ 'route' ] , $ module [ 'param' ] ) , ] ; } 
private function isActive ( $ route , $ params , Request $ request ) { if ( '/contao' === $ request -> getPathInfo ( ) || ! ( $ request -> attributes -> get ( '_route' ) === $ route ) ) { return false ; } $ attributes = $ request -> attributes -> get ( '_route_params' ) ; $ query = $ request -> query ; foreach ( $ params as $ param => $ value ) { if ( isset ( $ attributes [ $ param ] ) && ( $ value !== $ request -> attributes [ '_route_params' ] [ $ param ] ) ) { return false ; } if ( $ query -> has ( $ param ) && ( $ value !== $ query -> get ( $ param ) ) ) { return false ; } } return true ; } 
public function getCombinations ( ) { $ user = $ this -> getUser ( ) ; switch ( true ) { case ( $ user instanceof BackendUser ) : $ mode = 'be' ; 
public function getCombination ( $ tableName ) { $ combinations = $ this -> getCombinations ( ) ; if ( isset ( $ combinations [ 'byName' ] [ $ tableName ] ) ) { return $ combinations [ 'byName' ] [ $ tableName ] ; } return null ; } 
public function getChildrenOf ( $ parentTable ) { $ inputScreens = array_filter ( $ this -> getInputScreens ( ) , function ( $ inputScreen ) use ( $ parentTable ) { return ( $ inputScreen [ 'meta' ] [ 'rendertype' ] === 'ctable' ) && ( $ inputScreen [ 'meta' ] [ 'ptable' ] === $ parentTable ) ; } ) ; return $ inputScreens ; } 
public function getScreen ( $ tableName ) { $ inputScreens = $ this -> getInputScreens ( ) ; if ( isset ( $ inputScreens [ $ tableName ] ) ) { return $ inputScreens [ $ tableName ] ; } return null ; } 
private function getInputScreens ( ) { $ combinations = $ this -> getCombinations ( ) ; if ( null === $ combinations ) { return [ ] ; } $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; if ( $ this -> cache -> contains ( $ cacheKey = 'screens_' . implode ( ',' , $ screenIds ) ) ) { return $ this -> cache -> fetch ( $ cacheKey ) ; } $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ this -> cache -> save ( $ cacheKey , $ screens ) ; return $ screens ; } 
public function get ( $ key ) { return isset ( $ this -> arrData [ $ key ] ) ? $ this -> arrData [ $ key ] : null ; } 
public function addRules ( IFilter $ objFilter , $ arrFilterUrl , $ arrIgnoredFilter = array ( ) ) { foreach ( $ this -> arrSettings as $ objSetting ) { 
public function generateFilterUrlFrom ( IItem $ objItem , IRenderSettings $ objRenderSetting ) { $ arrFilterUrl = array ( ) ; foreach ( $ this -> arrSettings as $ objSetting ) { $ arrFilterUrl = array_merge ( $ arrFilterUrl , $ objSetting -> generateFilterUrlFrom ( $ objItem , $ objRenderSetting ) ) ; } return $ arrFilterUrl ; } 
public function getParameters ( ) { $ arrParams = array ( ) ; foreach ( $ this -> arrSettings as $ objSetting ) { $ arrParams = array_merge ( $ arrParams , $ objSetting -> getParameters ( ) ) ; } return $ arrParams ; } 
public function getParameterDCA ( ) { $ arrParams = array ( ) ; foreach ( $ this -> arrSettings as $ objSetting ) { $ arrParams = array_merge ( $ arrParams , $ objSetting -> getParameterDCA ( ) ) ; } return $ arrParams ; } 
public function getParameterFilterNames ( ) { $ arrParams = array ( ) ; foreach ( $ this -> arrSettings as $ objSetting ) { $ arrParams = array_merge ( $ arrParams , $ objSetting -> getParameterFilterNames ( ) ) ; } return $ arrParams ; } 
public function getParameterFilterWidgets ( $ arrFilterUrl , $ arrJumpTo , FrontendFilterOptions $ objFrontendFilterOptions ) { $ arrParams = array ( ) ; 
public function getReferencedAttributes ( ) { $ arrAttributes = array ( ) ; foreach ( $ this -> arrSettings as $ objSetting ) { $ arrAttributes = array_merge ( $ arrAttributes , $ objSetting -> getReferencedAttributes ( ) ) ; } return $ arrAttributes ; } 
public function handle ( GetPasteButtonEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ model = $ event -> getModel ( ) ; $ clipboard = $ environment -> getClipboard ( ) ; 
public function acceptsAnotherChild ( ModelInterface $ model , ModelCollector $ collector ) { $ conditionType = $ model -> getProperty ( 'type' ) ; if ( ! $ this -> conditionFactory -> supportsNesting ( $ conditionType ) ) { return false ; } if ( - 1 === ( $ max = $ this -> conditionFactory -> maxChildren ( $ conditionType ) ) ) { return true ; } return \ count ( $ collector -> collectDirectChildrenOf ( $ model ) ) < $ max ; } 
public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values ) ) ; } 
public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: encodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( $ values ) ; } 
public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_langcode' , 'tl_metamodel_dcasetting' ) , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_value' , 'tl_metamodel_dcasetting' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( 'legendtitle' ) , true ) ) ; } 
public function replaceTags ( $ strTag ) { $ arrElements = explode ( '::' , $ strTag ) ; 
protected function jumpTo ( $ mixMetaModel , $ mixDataId , $ intIdRenderSetting , $ strParam = 'url' ) { 
protected function getItem ( $ metaModelIdOrName , $ mixDataId , $ intIdRenderSetting , $ strOutput = null ) { 
protected function getAttribute ( $ metaModelIdOrName , $ intDataId , $ strAttributeName , $ strOutput = 'raw' ) { 
protected function getCount ( $ strType , $ intID ) { switch ( $ strType ) { 
protected function loadMetaModel ( $ nameOrId ) { if ( is_numeric ( $ nameOrId ) ) { 
protected function getMetaModelDataFrom ( $ strTable , $ intID ) { 
protected function getCountFor ( $ intMetaModelId , $ intFilterId ) { $ metaModel = $ this -> loadMetaModel ( $ intMetaModelId ) ; if ( $ metaModel == null ) { return false ; } $ objFilter = $ metaModel -> getEmptyFilter ( ) ; if ( $ intFilterId ) { $ collection = $ this -> getServiceContainer ( ) -> getFilterFactory ( ) -> createCollection ( $ intFilterId ) ; $ values = [ ] ; foreach ( $ collection -> getParameters ( ) as $ key ) { $ values [ $ key ] = Input :: get ( $ key ) ; } $ collection -> addRules ( $ objFilter , $ values ) ; } return $ metaModel -> getCount ( $ objFilter ) ; } 
protected function isPublishedItem ( $ objMetaModel , $ intItemId ) { 
public function getMetaModelNameFromId ( GetMetaModelNameFromIdEvent $ event ) { $ metaModelId = $ event -> getMetaModelId ( ) ; if ( array_key_exists ( $ metaModelId , $ this -> instancesById ) ) { $ event -> setMetaModelName ( $ this -> instancesById [ $ metaModelId ] -> getTableName ( ) ) ; return ; } if ( isset ( $ this -> tableNames [ $ metaModelId ] ) ) { $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; return ; } if ( ! $ this -> tableNamesCollected ) { $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ metaModelId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ this -> tableNames [ $ metaModelId ] = $ table [ 'tableName' ] ; $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; } } } 
protected function createInstanceViaLegacyFactory ( CreateMetaModelEvent $ event , $ arrData ) { $ name = $ arrData [ 'tableName' ] ; if ( ! isset ( $ GLOBALS [ 'METAMODELS' ] [ 'factories' ] [ $ name ] ) ) { return false ; } 
protected function createInstance ( CreateMetaModelEvent $ event , $ arrData ) { if ( ! $ this -> createInstanceViaLegacyFactory ( $ event , $ arrData ) ) { $ metaModel = new MetaModel ( $ arrData , $ this -> dispatcher , $ this -> database ) ; $ metaModel -> setServiceContainer ( function ( ) { return $ this -> getServiceContainer ( ) ; } , false ) ; $ event -> setMetaModel ( $ metaModel ) ; } if ( $ event -> getMetaModel ( ) ) { $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] = $ event -> getMetaModel ( ) ; $ this -> instancesById [ $ event -> getMetaModel ( ) -> get ( 'id' ) ] = $ event -> getMetaModel ( ) ; } } 
public function createMetaModel ( CreateMetaModelEvent $ event ) { if ( $ event -> getMetaModel ( ) !== null ) { return ; } if ( isset ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ) { $ event -> setMetaModel ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ; return ; } $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'tableName=:tableName' ) -> setParameter ( 'tableName' , $ event -> getMetaModelName ( ) ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ table [ 'system_columns' ] = $ this -> systemColumns ; $ this -> createInstance ( $ event , $ table ) ; } } 
public function collectMetaModelTableNames ( CollectMetaModelTableNamesEvent $ event ) { if ( $ this -> tableNamesCollected ) { $ event -> addMetaModelNames ( $ this -> tableNames ) ; return ; } $ tables = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; foreach ( $ tables as $ table ) { $ this -> tableNames [ $ table [ 'id' ] ] = $ table [ 'tableName' ] ; } $ event -> addMetaModelNames ( $ this -> tableNames ) ; $ this -> tableNamesCollected = true ; } 
public function collectMetaModelAttributeInformation ( CollectMetaModelAttributeInformationEvent $ event ) { $ metaModelName = $ event -> getMetaModel ( ) -> getTableName ( ) ; if ( ! array_key_exists ( $ metaModelName , $ this -> attributeInformation ) ) { $ attributes = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_attribute' ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ event -> getMetaModel ( ) -> get ( 'id' ) ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ this -> attributeInformation [ $ metaModelName ] = [ ] ; foreach ( $ attributes as $ attribute ) { $ colName = $ attribute [ 'colname' ] ; $ this -> attributeInformation [ $ metaModelName ] [ $ colName ] = $ attribute ; } } foreach ( $ this -> attributeInformation [ $ metaModelName ] as $ name => $ information ) { $ event -> addAttributeInformation ( $ name , $ information ) ; } } 
public function getAttributeOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getPropertyName ( ) !== 'attr_id' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; if ( ! $ metaModel ) { return ; } $ options = [ ] ; 
public function getMatchingIds ( ) { if ( $ this -> objAttribute instanceof ITranslated ) { return $ this -> objAttribute -> searchForInLanguages ( $ this -> strValue , $ this -> arrValidLanguages ) ; } return $ this -> objAttribute -> searchFor ( $ this -> strValue ) ; } 
public function getMaxPaginationLinks ( ) { if ( null === $ this -> maxPaginationLinks ) { $ this -> setMaxPaginationLinks ( \ Config :: get ( 'maxPaginationLinks' ) ) ; } return $ this -> maxPaginationLinks ; } 
public function getPaginationString ( ) { $ this -> calculate ( ) ; if ( $ this -> getPerPage ( ) == 0 ) { return '' ; } 
private function calculatePaginated ( ) { $ this -> calculatedTotal = $ this -> getTotalAmount ( ) ; 
protected function calculate ( ) { if ( ! $ this -> isDirty ( ) ) { return ; } $ this -> isDirty = false ; $ this -> calculatedOffset = null ; $ this -> calculatedLimit = null ; 
protected function getHelpWizard ( $ key , $ field ) { 
protected function makeMandatory ( $ field , $ row , $ key ) { $ field [ 'eval' ] [ 'required' ] = false ; 
protected function getWidgetClass ( $ field ) { $ className = $ GLOBALS [ ( TL_MODE == 'BE' ? 'BE_FFL' : 'TL_FFL' ) ] [ $ field [ 'inputType' ] ] ; if ( ( $ className !== '' ) && class_exists ( $ className ) ) { return $ className ; } return null ; } 
protected function handleLoadCallback ( $ field , $ value ) { 
protected function initializeWidget ( & $ arrField , $ strRow , $ strKey , $ varValue ) { $ xlabel = $ this -> getHelpWizard ( $ strKey , $ arrField ) ; 
protected function prepareWidgets ( ) { if ( $ this -> arrWidgets ) { return ; } $ arrWidgets = array ( ) ; foreach ( $ this -> arrSubFields as $ strFieldName => & $ arrSubField ) { $ varValue = $ this -> value [ $ strFieldName ] ; $ arrRow = array ( ) ; $ objWidget = $ this -> initializeWidget ( $ arrSubField , $ strFieldName , 'value' , $ varValue [ 'value' ] ) ; if ( ! $ objWidget ) { continue ; } $ arrRow [ ] = $ objWidget ; foreach ( $ this -> arrFlagFields as $ strFlag => $ arrFlagField ) { $ objWidget = $ this -> initializeWidget ( $ arrFlagField , $ strFieldName , $ strFlag , $ varValue [ $ strFlag ] ) ; if ( $ objWidget ) { $ arrRow [ ] = $ objWidget ; } } $ arrWidgets [ ] = $ arrRow ; } $ this -> arrWidgets = $ arrWidgets ; } 
protected function handleSaveCallback ( $ field , $ widget , $ value ) { $ newValue = $ value ; if ( isset ( $ field [ 'save_callback' ] ) && is_array ( $ field [ 'save_callback' ] ) ) { foreach ( $ field [ 'save_callback' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; try { $ newValue = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ newValue , $ this ) ; } catch ( Exception $ e ) { $ widget -> addError ( $ e -> getMessage ( ) ) ; $ this -> blnSubmitInput = false ; return $ value ; } } } return $ newValue ; } 
protected function validateWidget ( & $ arrField , $ strRow , $ strKey , & $ varInput ) { $ varValue = $ varInput [ $ strRow ] [ $ strKey ] ; $ objWidget = $ this -> initializeWidget ( $ arrField , $ strRow , $ strKey , $ varValue ) ; if ( ! is_object ( $ objWidget ) ) { return false ; } 
protected function validator ( $ varInput ) { $ blnHasError = false ; foreach ( $ this -> arrSubFields as $ strFieldName => & $ arrSubField ) { if ( ! $ this -> validateWidget ( $ arrSubField , $ strFieldName , 'value' , $ varInput ) ) { $ blnHasError = true ; } foreach ( $ this -> arrFlagFields as $ strFlag => $ arrFlagField ) { if ( ! $ this -> validateWidget ( $ arrFlagField , $ strFieldName , $ strFlag , $ varInput ) ) { $ blnHasError = true ; } } } unset ( $ arrSubField ) ; if ( $ blnHasError ) { $ this -> blnSubmitInput = false ; $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] ) ; } return $ varInput ; } 
protected function getHelpForWidget ( $ widget ) { if ( $ GLOBALS [ 'TL_CONFIG' ] [ 'showHelp' ] && $ widget -> description ) { return sprintf ( '<p class="tl_help tl_tip%s">%s</p>' , $ widget -> tl_class , $ widget -> description ) ; } return '' ; } 
protected function buildOptions ( ) { $ options = array ( ) ; foreach ( $ this -> arrWidgets as $ widgetRow ) { $ columns = array ( ) ; foreach ( $ widgetRow as $ widget ) { $ valign = ( $ widget -> valign != '' ? ' valign="' . $ widget -> valign . '"' : '' ) ; $ class = ( $ widget -> tl_class != '' ? ' class="' . $ widget -> tl_class . '"' : '' ) ; $ style = ( $ widget -> style != '' ? ' style="' . $ widget -> style . '"' : '' ) ; $ help = $ this -> getHelpForWidget ( $ widget ) ; $ columns [ ] = sprintf ( '<td %1$s%2$s%3$s>%4$s%5$s</td>' , $ valign , $ class , $ style , $ widget -> parse ( ) , $ help ) ; } $ options [ ] = implode ( '' , $ columns ) ; } return $ options ; } 
public function generate ( ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/metamodelscore/css/style.css' ; $ this -> prepareWidgets ( ) ; $ arrOptions = $ this -> buildOptions ( ) ; 
public function handle ( PreCreateDcGeneralEvent $ event ) { $ factory = $ event -> getFactory ( ) ; if ( ! in_array ( $ factory -> getContainerName ( ) , $ this -> factory -> collectNames ( ) ) ) { return ; } $ factory -> setContainerClassName ( MetaModelDataDefinition :: class ) ; } 
public function handle ( BuildDataDefinitionEvent $ event ) { if ( 'tl_metamodel_dca_sortgroup' !== $ event -> getContainer ( ) -> getName ( ) ) { return ; } foreach ( $ event -> getContainer ( ) -> getPalettesDefinition ( ) -> getPalettes ( ) as $ palette ) { foreach ( $ palette -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) != 'rendergrouptype' ) { continue ; } $ this -> addCondition ( $ property , new PropertyConditionChain ( array ( new InputScreenRenderModeIs ( 'flat' , $ this -> connection ) , new InputScreenRenderModeIs ( 'parented' , $ this -> connection ) , ) , PropertyConditionChain :: OR_CONJUNCTION ) ) ; } } } 
private function addCondition ( PropertyInterface $ property , ConditionInterface $ condition ) { $ chain = $ property -> getVisibleCondition ( ) ; if ( ! ( $ chain && ( $ chain instanceof PropertyConditionChain ) && $ chain -> getConjunction ( ) == PropertyConditionChain :: AND_CONJUNCTION ) ) { if ( $ property -> getVisibleCondition ( ) ) { $ previous = array ( $ property -> getVisibleCondition ( ) ) ; } else { $ previous = array ( ) ; } $ chain = new PropertyConditionChain ( $ previous , PropertyConditionChain :: AND_CONJUNCTION ) ; $ property -> setVisibleCondition ( $ chain ) ; } $ chain -> addCondition ( $ condition ) ; } 
public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> scopeMatcher -> currentScopeIsBackend ( ) ) { return ; } $ model = $ event -> getModel ( ) ; if ( ( $ model -> getProviderName ( ) !== 'tl_metamodel_filtersetting' ) || ! in_array ( $ event -> getModel ( ) -> getProperty ( 'type' ) , $ this -> getTypes ( ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ event -> setLabel ( $ this -> getLabelPattern ( $ environment , $ model ) ) -> setArgs ( $ this -> getLabelParameters ( $ environment , $ model ) ) ; } 
protected function getMetaModel ( ModelInterface $ model ) { 
protected function getLabelComment ( ModelInterface $ model , TranslatorInterface $ translator ) { if ( $ model -> getProperty ( 'comment' ) ) { return sprintf ( $ translator -> translate ( 'typedesc._comment_' , 'tl_metamodel_filtersetting' ) , StringUtil :: specialchars ( $ model -> getProperty ( 'comment' ) ) ) ; } return '' ; } 
protected function getLabelImage ( ModelInterface $ model ) { $ typeFactory = $ this -> factory -> getTypeFactory ( $ model -> getProperty ( 'type' ) ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> updateImageWithDisabled ( $ model , $ typeFactory -> getTypeIcon ( ) ) , '' , '' , $ this -> updateImageWithDisabled ( $ model , 'bundles/metamodelscore/images/icons/filter_default.png' ) ) ; $ urlEvent = $ this -> dispatcher -> dispatch ( ContaoEvents :: BACKEND_ADD_TO_URL , new AddToUrlEvent ( 'act=edit&amp;id=' . $ model -> getId ( ) ) ) ; return sprintf ( '<a href="%s">%s</a>' , $ urlEvent -> getUrl ( ) , $ image ) ; } 
protected function getLabelText ( TranslatorInterface $ translator , ModelInterface $ model ) { $ type = $ model -> getProperty ( 'type' ) ; $ label = $ translator -> translate ( 'typenames.' . $ type , 'tl_metamodel_filtersetting' ) ; if ( $ label == 'typenames.' . $ type ) { return $ type ; } return $ label ; } 
protected function getLabelPattern ( EnvironmentInterface $ environment , ModelInterface $ model ) { $ translator = $ environment -> getTranslator ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ combined = 'typedesc.' . $ type ; if ( ( $ resultPattern = $ translator -> translate ( $ combined , 'tl_metamodel_filtersetting' ) ) == $ combined ) { $ resultPattern = $ translator -> translate ( 'typedesc._default_' , 'tl_metamodel_filtersetting' ) ; } return $ resultPattern ; } 
protected function getLabelParametersWithAttributeAndUrlParam ( EnvironmentInterface $ environment , ModelInterface $ model ) { $ translator = $ environment -> getTranslator ( ) ; $ metamodel = $ this -> getMetaModel ( $ model ) ; $ attribute = $ metamodel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ attributeName = $ attribute -> getColName ( ) ; } else { $ attributeName = $ model -> getProperty ( 'attr_id' ) ; } return array ( $ this -> getLabelImage ( $ model ) , $ this -> getLabelText ( $ translator , $ model ) , $ this -> getLabelComment ( $ model , $ translator ) , $ attributeName , ( $ model -> getProperty ( 'urlparam' ) ? $ model -> getProperty ( 'urlparam' ) : $ attributeName ) ) ; } 
protected function getLabelParametersNormal ( EnvironmentInterface $ environment , ModelInterface $ model ) { $ translator = $ environment -> getTranslator ( ) ; return array ( $ this -> getLabelImage ( $ model ) , $ this -> getLabelText ( $ translator , $ model ) , $ this -> getLabelComment ( $ model , $ translator ) , $ model -> getProperty ( 'type' ) ) ; } 
private function updateImageWithDisabled ( ModelInterface $ model , $ image ) { $ this -> preCreateInverseImage ( $ model , $ image ) ; if ( $ model -> getProperty ( 'enabled' ) ) { return $ image ; } if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return $ image ; } return substr_replace ( $ image , '_1' , $ intPos , 0 ) ; } 
private function preCreateInverseImage ( ModelInterface $ model , string $ image ) : void { if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return ; } if ( $ model -> getProperty ( 'enabled' ) ) { $ this -> iconBuilder -> getBackendIcon ( substr_replace ( $ image , '_1' , $ intPos , 0 ) ) ; return ; } $ this -> iconBuilder -> getBackendIcon ( $ image ) ; } 
public function push ( $ url , $ table , $ icon ) { $ this -> elements [ ] = [ 'url' => $ url , 'text' => $ this -> getLabel ( $ table ) , 'icon' => $ this -> iconBuilder -> getBackendIcon ( $ icon ) ] ; } 
public function getLabel ( $ table ) : string { if ( strpos ( $ table , 'tl_' ) !== 0 ) { return $ table ; } $ shortTable = str_replace ( 'tl_' , '' , $ table ) ; $ label = $ this -> translator -> trans ( 'BRD.' . $ shortTable , [ ] , 'contao_default' ) ; if ( $ label === $ shortTable ) { $ shortTable = str_replace ( 'tl_metamodel_' , '' , $ table ) ; return ucfirst ( $ shortTable ) . ' %s' ; } return StringUtil :: specialchars ( $ label ) ; } 
public function getTemplatesForBase ( $ templateBaseName ) { $ allTemplates = array_replace_recursive ( $ this -> fetchTemplatesFromThemes ( $ templateBaseName ) , $ this -> fetchRootTemplates ( $ templateBaseName ) , $ this -> fetchTemplatesFromResourceDirectories ( $ templateBaseName ) ) ; $ templateList = array ( ) ; foreach ( $ allTemplates as $ template => $ themeList ) { $ templateList [ $ template ] = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'template_in_theme' ] , $ template , implode ( ', ' , $ themeList ) ) ; } ksort ( $ templateList ) ; return array_unique ( $ templateList ) ; } 
private function fetchTemplatesFromThemes ( $ templateBaseName ) { $ allTemplates = [ ] ; $ themes = $ this -> database -> createQueryBuilder ( ) -> select ( 'id,name,templates' ) -> from ( 'tl_theme' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; 
private function fetchTemplatesFromResourceDirectories ( $ templateBaseName ) { $ allTemplates = [ ] ; $ themeName = $ this -> getNoThemeMessage ( ) ; 
private function getTemplatesForBaseFrom ( $ base , $ folder , $ themeName ) { if ( ! is_dir ( $ folder ) ) { return [ ] ; } $ themeName = trim ( $ themeName ) ; $ foundTemplates = Finder :: create ( ) -> in ( $ folder ) -> name ( $ base . '*' ) ; $ templates = [ ] ; foreach ( $ foundTemplates as $ template ) { $ templates [ $ template -> getBasename ( '.' . $ template -> getExtension ( ) ) ] = [ $ themeName => $ themeName ] ; } return $ templates ; } 
public function getMatchingIds ( ) { $ arrIds = array ( ) ; foreach ( $ this -> arrChildFilters as $ objChildFilter ) { $ arrChildMatches = $ objChildFilter -> getMatchingIds ( ) ; 
protected function calculate ( ) { if ( $ this -> inputScreen [ 'meta' ] [ 'rendertype' ] !== 'standalone' ) { if ( $ this -> container -> getBasicDefinition ( ) -> getMode ( ) == BasicDefinitionInterface :: MODE_HIERARCHICAL ) { throw new \ RuntimeException ( 'Hierarchical mode with parent table is not supported yet.' ) ; } } $ this -> addHierarchicalConditions ( ) ; $ this -> addParentCondition ( ) ; } 
protected function validator ( $ varInput ) { if ( is_array ( $ varInput ) ) { return parent :: validator ( $ varInput ) ; } return parent :: validator ( trim ( $ varInput ) ) ; } 
protected function getClassForOption ( $ index ) { 
protected function generateOption ( $ val , $ index ) { $ checked = '' ; if ( is_array ( $ this -> varValue ) && in_array ( $ val [ 'value' ] , $ this -> varValue ) ) { $ checked = ' checked="checked"' ; } return sprintf ( '<span class="%1$s opt_%2$s">' . '<input type="checkbox" name="%8$s[]" id="opt_%3$s" class="checkbox" value="%4$s"%5$s%6$s ' . '<label id="lbl_%3$s" for="opt_%3$s">%7$s</label></span>' , 
public function generate ( ) { $ return = sprintf ( '<fieldset id="ctrl_%s" class="checkbox_container"> ' , $ this -> strName ) ; $ count = 0 ; if ( $ this -> options && is_array ( $ this -> options ) ) { if ( $ this -> arrConfiguration [ 'includeBlankOption' ] ) { $ return .= $ this -> generateOption ( array ( 'value' => '--none--' , 'label' => $ this -> arrConfiguration [ 'blankOptionLabel' ] ) , $ count ++ ) ; } 
public function getItem ( ) { 
public function next ( ) { if ( $ this -> getCount ( ) == $ this -> intCursor ) { return false ; } 
public function getClass ( ) { $ arrClass = array ( ) ; if ( $ this -> intCursor == 0 ) { $ arrClass [ ] = 'first' ; } if ( $ this -> intCursor == ( $ this -> getCount ( ) - 1 ) ) { $ arrClass [ ] = 'last' ; } if ( ( $ this -> intCursor % 2 ) == 0 ) { $ arrClass [ ] = 'even' ; } else { $ arrClass [ ] = 'odd' ; } return implode ( ' ' , $ arrClass ) ; } 
public function parseAll ( $ strOutputFormat = 'text' , $ objSettings = null ) { $ arrResult = array ( ) ; 
public function render ( ModelToLabelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ viewSection = $ definition -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; $ listing = $ viewSection -> getListingConfig ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ data = array ( $ nativeItem -> parseValue ( 'html5' , $ renderSetting ) ) ; if ( $ listing -> getShowColumns ( ) ) { $ event -> setArgs ( $ data [ 0 ] [ 'html5' ] ) ; return ; } $ template = new Template ( $ renderSetting -> get ( 'template' ) ) ; $ renderSetting = self :: removeInvariantAttributes ( $ nativeItem , $ renderSetting ) ; $ template -> setData ( array ( 'settings' => $ renderSetting , 'items' => new Items ( array ( $ nativeItem ) ) , 'view' => $ renderSetting , 'data' => $ data ) ) ; $ event -> setLabel ( '%s' ) -> setArgs ( array ( $ template -> parse ( 'html5' ) ) ) ; } 
public function getReadableValue ( RenderReadablePropertyValueEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ result = $ nativeItem -> parseAttribute ( $ event -> getProperty ( ) -> getName ( ) , 'text' , $ renderSetting ) ; if ( ! isset ( $ result [ 'text' ] ) ) { $ event -> setRendered ( sprintf ( 'Unexpected behaviour, attribute %s text representation was not rendered.' , $ event -> getProperty ( ) -> getName ( ) ) ) ; return ; } $ event -> setRendered ( $ result [ 'text' ] ) ; } 
public function addAdditionalParentHeaderFields ( GetParentHeaderEvent $ event ) { $ parentModel = $ event -> getModel ( ) ; if ( ! $ parentModel instanceof Model ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ item = $ parentModel -> getItem ( ) ; $ metaModel = $ item -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; $ additional = array ( ) ; foreach ( $ renderSetting -> getSettingNames ( ) as $ name ) { $ parsed = $ item -> parseAttribute ( $ name , 'text' , $ renderSetting ) ; $ name = $ item -> getAttribute ( $ name ) -> getName ( ) ; $ additional [ $ name ] = $ parsed [ 'text' ] ; } $ additional = array_merge ( $ additional , $ event -> getAdditional ( ) ) ; $ event -> setAdditional ( $ additional ) ; } 
private function removeInvariantAttributes ( IItem $ nativeItem , ICollection $ renderSetting ) { $ model = $ nativeItem -> getMetaModel ( ) ; if ( $ model -> hasVariants ( ) && ! $ nativeItem -> isVariantBase ( ) ) { 
public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'jumpTo' ) ) { return ; } $ propInfo = $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getPropertiesDefinition ( ) -> getProperty ( 'jumpTo' ) ; $ value = StringUtil :: deserialize ( $ event -> getValue ( ) , true ) ; $ extra = $ propInfo -> getExtra ( ) ; $ newValues = [ ] ; $ languages = $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] ; foreach ( array_keys ( $ languages ) as $ key ) { $ newValue = '' ; $ filter = 0 ; if ( $ value ) { foreach ( $ value as $ arr ) { if ( ! is_array ( $ arr ) ) { break ; } 
public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'jumpTo' ) ) { return ; } $ value = StringUtil :: deserialize ( $ event -> getValue ( ) , true ) ; foreach ( $ value as $ k => $ v ) { $ value [ $ k ] [ 'value' ] = str_replace ( [ '{{link_url::' , '}}' ] , [ '' , '' ] , $ v [ 'value' ] ) ; } $ event -> setValue ( serialize ( $ value ) ) ; } 
public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'jumpTo' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; if ( $ metaModel -> isTranslated ( ) ) { $ arrLanguages = [ ] ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ strLangCode ) { $ arrLanguages [ $ strLangCode ] = $ this -> translator -> trans ( 'LNG.' . $ strLangCode , [ ] , 'contao_languages' ) ; } asort ( $ arrLanguages ) ; $ extra [ 'minCount' ] = count ( $ arrLanguages ) ; $ extra [ 'maxCount' ] = count ( $ arrLanguages ) ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = $ arrLanguages ; } else { $ extra [ 'minCount' ] = 1 ; $ extra [ 'maxCount' ] = 1 ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = [ 'xx' => $ this -> translator -> trans ( 'tl_metamodel_rendersettings.jumpTo_allLanguages' , [ ] , 'contao_tl_metamodel_rendersettings' ) ] ; } $ extra [ 'columnFields' ] [ 'filter' ] [ 'options' ] = $ this -> getFilterSettings ( $ model ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; } 
private function getFilterSettings ( ModelInterface $ model ) { $ filters = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' , 'name' ) -> from ( 'tl_metamodel_filter' ) -> where ( 'pid=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ filters as $ filter ) { $ result [ $ filter [ 'id' ] ] = $ filter [ 'name' ] ; } return $ result ; } 
public function fetchInputScreens ( $ idList ) : array { $ idList = array_filter ( $ idList ) ; $ builder = $ this -> connection -> createQueryBuilder ( ) ; $ screens = $ builder -> select ( 'd.*' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel' , 'm' , 'm.id=d.pid' ) -> where ( $ builder -> expr ( ) -> in ( 'd.id' , ':idList' ) ) -> setParameter ( 'idList' , $ idList , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'm.sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; $ keys = array_flip ( $ idList ) ; foreach ( $ screens as $ screen ) { $ metaModelName = $ keys [ $ screen [ 'id' ] ] ; $ result [ $ metaModelName ] = $ this -> prepareInputScreen ( $ metaModelName , $ screen ) ; } return $ result ; } 
private function prepareInputScreen ( $ modelName , $ screen ) : array { if ( null === $ metaModel = $ this -> factory -> getMetaModel ( $ modelName ) ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ modelName ) ; } $ caption = [ '' => $ metaModel -> getName ( ) ] ; $ description = [ '' => $ metaModel -> getName ( ) ] ; foreach ( StringUtil :: deserialize ( $ screen [ 'backendcaption' ] , true ) as $ languageEntry ) { $ langCode = $ languageEntry [ 'langcode' ] ; $ caption [ $ langCode ] = ! empty ( $ label = $ languageEntry [ 'label' ] ) ? $ label : $ caption [ '' ] ; $ description [ $ langCode ] = ! empty ( $ title = $ languageEntry [ 'description' ] ) ? $ title : $ description [ '' ] ; if ( $ metaModel -> getFallbackLanguage ( ) === $ langCode ) { $ caption [ '' ] = $ label ; $ description [ '' ] = $ title ; } } $ result = [ 'meta' => $ screen , 'properties' => $ this -> fetchPropertiesFor ( $ screen [ 'id' ] , $ metaModel ) , 'conditions' => $ this -> fetchConditions ( $ screen [ 'id' ] ) , 'groupSort' => $ this -> fetchGroupSort ( $ screen [ 'id' ] , $ metaModel ) , 'label' => $ caption , 'description' => $ description ] ; $ bySetting = $ this -> buildConditionTree ( $ result [ 'conditions' ] ) ; $ result [ 'legends' ] = $ this -> convertLegends ( $ result [ 'properties' ] , $ metaModel , $ bySetting ) ; return $ result ; } 
private function buildConditionTree ( array $ conditions ) : array { 
private function fetchPropertiesFor ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ column ) use ( $ inputScreenId , $ metaModel ) { if ( 'attribute' !== $ column [ 'dcatype' ] ) { return $ column ; } if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ column [ 'attr_id' ] ) ) ) { 
private function fetchConditions ( $ inputScreenId ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return $ builder -> select ( 'cond.*' , 'setting.attr_id AS setting_attr_id' ) -> from ( 'tl_metamodel_dcasetting_condition' , 'cond' ) -> leftJoin ( 'cond' , 'tl_metamodel_dcasetting' , 'setting' , 'cond.settingId=setting.id' ) -> leftJoin ( 'setting' , 'tl_metamodel_dca' , 'dca' , 'setting.pid=dca.id' ) -> where ( 'cond.enabled=1' ) -> andWhere ( 'setting.published=1' ) -> andWhere ( 'dca.id=:screenId' ) -> setParameter ( 'screenId' , $ inputScreenId ) -> orderBy ( 'pid' ) -> addOrderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; } 
private function fetchGroupSort ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ information ) use ( $ inputScreenId , $ metaModel ) { $ information [ 'isdefault' ] = ( bool ) $ information [ 'isdefault' ] ; $ information [ 'ismanualsort' ] = ( bool ) $ information [ 'ismanualsort' ] ; $ information [ 'rendergrouplen' ] = ( int ) $ information [ 'rendergrouplen' ] ; if ( $ information [ 'ismanualsort' ] ) { $ information [ 'rendergrouptype' ] = 'none' ; } if ( ! empty ( $ information [ 'rendersortattr' ] ) ) { if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ information [ 'rendersortattr' ] ) ) ) { 
private function convertLegends ( array $ properties , IMetaModel $ metaModel , array $ conditions ) : array { $ result = [ ] ; $ label = [ ] ; if ( $ trans = $ metaModel -> isTranslated ( ) ) { foreach ( $ metaModel -> getAvailableLanguages ( ) as $ availableLanguage ) { $ label [ $ availableLanguage ] = $ metaModel -> getName ( ) ; } } else { $ label [ $ metaModel -> getActiveLanguage ( ) ] = $ metaModel -> getName ( ) ; } $ legend = [ 'label' => $ label , 'hide' => false , 'properties' => [ ] ] ; $ condition = function ( $ property ) use ( $ conditions ) { if ( ! isset ( $ conditions [ $ property [ 'id' ] ] ) ) { return null ; } return [ 'type' => 'conditionand' , 'children' => $ conditions [ $ property [ 'id' ] ] ] ; } ; foreach ( $ properties as $ property ) { switch ( $ property [ 'dcatype' ] ) { case 'legend' : $ this -> convertLegend ( $ property , $ trans , $ condition , $ legend , $ result ) ; break ; case 'attribute' : $ this -> convertAttribute ( $ property , $ condition , $ legend ) ; break ; default : break ; } } if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } return $ result ; } 
private function convertLegend ( array $ property , bool $ trans , $ condition , array & $ legend , array & $ result ) { if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } $ legend = [ 'label' => $ trans ? unserialize ( $ property [ 'legendtitle' ] , [ 'allowed_classes' => false ] ) : [ '' => $ property [ 'legendtitle' ] ] , 'hide' => ( bool ) $ property [ 'legendhide' ] , 'properties' => [ ] , 'condition' => $ condition ( $ property ) ] ; } 
private function convertAttribute ( array $ property , $ condition , array & $ legend ) { if ( ! isset ( $ property [ 'col_name' ] ) ) { return ; } $ legend [ 'properties' ] [ ] = [ 'name' => $ property [ 'col_name' ] , 'condition' => $ condition ( $ property ) ] ; } 
public function handle ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; switch ( $ model -> getProperty ( 'dcatype' ) ) { case 'attribute' : $ this -> drawAttribute ( $ event ) ; break ; case 'legend' : $ this -> drawLegend ( $ event ) ; break ; default : break ; } } 
private function drawAttribute ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ type = $ attribute -> get ( 'type' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> attributeFactory -> getIconForType ( $ type ) , $ type , '' , 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = $ attribute -> getName ( ) ; $ colName = $ attribute -> getColName ( ) ; $ isUnique = $ attribute -> get ( 'isunique' ) ; } else { $ type = 'unknown ID: ' . $ model -> getProperty ( 'attr_id' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = 'unknown attribute' ; $ colName = 'unknown column' ; $ isUnique = false ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong><span class="mandatory">%s</span> <span class="tl_class">%s</span> </div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ colName , $ type , $ image , $ name , 
private function drawLegend ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; if ( is_array ( $ legend = StringUtil :: deserialize ( $ model -> getProperty ( 'legendtitle' ) ) ) ) { foreach ( [ $ metaModel -> getActiveLanguage ( ) , $ metaModel -> getFallbackLanguage ( ) ] as $ language ) { if ( array_key_exists ( $ language , $ legend ) && ! empty ( $ legend [ $ language ] ) ) { $ legend = $ legend [ $ language ] ; break ; } } } if ( empty ( $ legend ) ) { $ legend = 'legend' ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong></div> <div class="dca_palette">%s%s</div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ this -> trans ( 'dcatypes.legend' ) , $ legend , $ model -> getProperty ( 'legendhide' ) ? ':hide' : '' ] ) ; } 
public function handle ( PopulateEnvironmentEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( $ environment -> getDataDefinition ( ) instanceof IMetaModelDataDefinition ) { $ this -> populate ( $ environment ) ; } } 
public static function compare ( $ expected , $ actual , $ strict = true ) { try { self :: calculateDiff ( $ expected , $ actual , $ strict ) ; } catch ( \ Exception $ exception ) { $ instance = new DifferentValuesException ( $ expected , $ actual , $ strict , 'The values differ.' , 0 , $ exception ) ; throw $ instance ; } } 
public function getLongMessage ( $ glue = ' ' ) { $ messages = array ( ) ; $ exception = $ this ; do { $ messages [ ] = $ exception -> getMessage ( ) ; } while ( null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; return implode ( $ glue , $ messages ) ; } 
private static function isEmptyArrayEquivalent ( $ expected , $ actual ) { return ( gettype ( $ expected ) == 'string' ) && ( ( gettype ( $ actual ) == 'array' ) || ( gettype ( $ actual ) == 'NULL' ) ) && empty ( $ actual ) && empty ( $ expected ) ; } 
private static function calculateArrayDiff ( $ expected , $ actual , $ strict ) { if ( count ( $ expected ) !== count ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array element count mismatch. Found %s, expected %s.' , count ( $ actual ) , count ( $ expected ) ) , self :: ARRAY_COUNT_MISMATCH ) ; } reset ( $ actual ) ; foreach ( $ expected as $ key => $ value ) { if ( $ key !== key ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array key mismatch. Found %s, expected %s.' , key ( $ actual ) , $ key ) , self :: ARRAY_KEY_MISMATCH ) ; } try { self :: calculateDiff ( $ value , current ( $ actual ) , $ strict ) ; } catch ( \ Exception $ exception ) { throw new \ LogicException ( sprintf ( 'Array value mismatch for key %s.' , key ( $ actual ) ) , self :: ARRAY_VALUE_MISMATCH , $ exception ) ; } next ( $ actual ) ; } } 
private static function calculateDiff ( $ expected , $ actual , $ strict ) { if ( $ expected === $ actual ) { return ; } if ( gettype ( $ expected ) !== gettype ( $ actual ) ) { 
public function getParameters ( ) { $ arrParams = array ( ) ; foreach ( $ this -> arrChildren as $ objSetting ) { $ arrParams = array_merge ( $ arrParams , $ objSetting -> getParameters ( ) ) ; } return $ arrParams ; } 
public function getParameterDCA ( ) { $ arrParams = array ( ) ; foreach ( $ this -> arrChildren as $ objSetting ) { $ arrParams = array_merge ( $ arrParams , $ objSetting -> getParameterDCA ( ) ) ; } return $ arrParams ; } 
public function getParameterFilterWidgets ( $ arrIds , $ arrFilterUrl , $ arrJumpTo , FrontendFilterOptions $ objFrontendFilterOptions ) { $ arrParams = array ( ) ; foreach ( $ this -> arrChildren as $ objSetting ) { $ arrParams = array_merge ( $ arrParams , $ objSetting -> getParameterFilterWidgets ( $ arrIds , $ arrFilterUrl , $ arrJumpTo , $ objFrontendFilterOptions ) ) ; } return $ arrParams ; } 
public function getParameterFilterNames ( ) { $ arrParams = array ( ) ; foreach ( $ this -> arrChildren as $ objSetting ) { $ arrParams = array_merge ( $ arrParams , $ objSetting -> getParameterFilterNames ( ) ) ; } return $ arrParams ; } 
public function getReferencedAttributes ( ) { $ arrAttributes = array ( ) ; foreach ( $ this -> arrChildren as $ objSetting ) { $ arrAttributes = array_merge ( $ arrAttributes , $ objSetting -> getReferencedAttributes ( ) ) ; } return $ arrAttributes ; } 
public function handle ( BuildWidgetEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ( $ environment -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_dcasetting' ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'mandatory' ) || ( null === $ event -> getModel ( ) -> getId ( ) ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( null === $ attribute ) { return ; } if ( $ attribute -> get ( 'isunique' ) ) { Message :: addInfo ( $ this -> translator -> trans ( 'tl_metamodel_dcasetting.mandatory_for_unique_attr' , [ ] , 'contao_tl_metamodel_dcasetting' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'disabled' ] = true ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; $ model -> setProperty ( 'mandatory' , true ) ; } } 
public function get ( $ strName ) { return isset ( $ this -> arrBase [ $ strName ] ) ? $ this -> arrBase [ $ strName ] : null ; } 
public function configure ( MetaModelsServiceContainer $ serviceContainer ) { $ serviceContainer -> setEventDispatcher ( function ( ) { return $ this -> container -> get ( 'event_dispatcher' ) ; } ) -> setDatabase ( function ( ) { return $ this -> container -> get ( 'cca.legacy_dic.contao_database_connection' ) ; } ) -> setAttributeFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.attribute_factory' ) ; } ) -> setFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.factory' ) ; } ) -> setFilterFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.filter_setting_factory' ) ; } ) -> setRenderSettingFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.render_setting_factory' ) ; } ) -> setCache ( function ( ) { return $ this -> container -> get ( 'metamodels.cache' ) ; } ) ; return $ serviceContainer ; } 
public function handle ( GetOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ event -> setOptions ( array_flip ( array_filter ( array_flip ( System :: getLanguages ( ) ) , function ( $ langCode ) { 
protected function wantToHandle ( GetOptionsEvent $ event ) { if ( $ event -> getOptions ( ) !== null ) { return false ; } if ( ! $ this -> scopeDeterminator -> currentScopeIsBackend ( ) ) { return false ; } $ environment = $ event -> getEnvironment ( ) ; if ( 'tl_metamodel' !== $ environment -> getDataDefinition ( ) -> getName ( ) ) { return false ; } if ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== $ event -> getModel ( ) -> getProviderName ( ) ) { return false ; } return ( 'languages' === $ event -> getPropertyName ( ) ) && ( 'langcode' === $ event -> getSubPropertyName ( ) ) ; } 
public function getStylesheets ( GetOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getPropertyName ( ) !== 'additionalCss' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'css' ) ) ; } 
public function getJavascripts ( GetOptionsEvent $ event ) { if ( ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_rendersettings' ) || ( $ event -> getPropertyName ( ) !== 'additionalJs' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'js' ) ) ; } 
private function scanFiles ( $ extension ) { $ files = [ ] ; foreach ( Finder :: create ( ) -> in ( $ this -> uploadPath ) -> name ( '*.' . $ extension ) -> getIterator ( ) as $ item ) { $ files [ ] = 'files/' . Path :: normalize ( $ item -> getRelativePathname ( ) ) ; } return $ files ; } 
protected function calculateCacheKey ( ) { $ key = 'view_combination_' . strtolower ( TL_MODE ) ; 
public function getUser ( ) { static $ authenticated ; if ( ! isset ( $ authenticated ) ) { $ authenticated = true ; $ this -> authenticateUser ( ) ; } return $ this -> user ; } 
protected function loadFromCache ( ) { $ key = $ this -> calculateCacheKey ( ) ; if ( ! $ this -> container -> getCache ( ) -> contains ( $ key ) ) { return false ; } 
protected function saveToCache ( ) { 
protected function resolve ( ) { $ factory = $ this -> container -> getFactory ( ) ; $ names = $ factory -> collectNames ( ) ; foreach ( $ names as $ name ) { $ this -> information [ $ name ] = array ( self :: COMBINATION => null , self :: INPUTSCREEN => null , self :: RENDERSETTING => null , self :: MODELID => null , ) ; } $ found = $ this -> getPaletteCombinationRows ( ) ; if ( ! $ found ) { $ found = array ( ) ; } 
protected function setTableMapping ( $ modelId , $ tableName ) { $ this -> information [ $ tableName ] [ self :: MODELID ] = $ modelId ; $ this -> tableMap [ $ modelId ] = $ tableName ; } 
protected function getMetaModelName ( $ nameOrId ) { return isset ( $ this -> tableMap [ $ nameOrId ] ) ? $ this -> tableMap [ $ nameOrId ] : $ nameOrId ; } 
protected function getCombinationsFromDatabase ( ) { $ groups = $ this -> getUserGroups ( ) ; if ( ! $ groups ) { return null ; } $ statement = $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_dca_combine' ) -> where ( strtolower ( TL_MODE ) . '_group IN (:groups)' ) -> orderBy ( 'pid' ) -> addOrderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'groups' , $ groups ) -> execute ( ) ; return $ statement -> fetchAll ( \ PDO :: FETCH_OBJ ) ; } 
protected function getPaletteCombinationRows ( ) { $ combinations = $ this -> getCombinationsFromDatabase ( ) ; $ success = array ( ) ; 
protected function fetchInputScreenDetails ( ) { $ inputScreenIds = array ( ) ; foreach ( $ this -> information as $ info ) { $ inputScreenIds [ ] = $ info [ self :: COMBINATION ] [ 'dca_id' ] ; } if ( ! $ inputScreenIds ) { return ; } $ statement = $ this -> connection -> query ( sprintf ( 'SELECT * FROM tl_metamodel_dca WHERE id IN (%s)' , implode ( ',' , $ inputScreenIds ) ) ) ; while ( $ inputScreens = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ screenId = $ inputScreens -> id ; $ metaModelId = $ inputScreens -> pid ; $ metaModelName = $ this -> tableNameFromId ( $ metaModelId ) ; $ propertyRows = $ this -> connection -> prepare ( 'SELECT * FROM tl_metamodel_dcasetting WHERE pid=? AND published=1 ORDER BY sorting ASC' ) ; $ propertyRows -> bindValue ( 1 , $ screenId ) ; $ propertyRows -> execute ( ) ; $ conditions = $ this -> connection -> prepare ( ' SELECT cond.*, setting.attr_id AS setting_attr_id FROM tl_metamodel_dcasetting_condition AS cond LEFT JOIN tl_metamodel_dcasetting AS setting ON (cond.settingId=setting.id) LEFT JOIN tl_metamodel_dca AS dca ON (setting.pid=dca.id) WHERE dca.id=? AND setting.published=1 AND cond.enabled=1 ORDER BY sorting ASC ' ) ; $ conditions -> bindValue ( 1 , $ screenId ) ; $ conditions -> execute ( ) ; $ groupSort = $ this -> connection -> prepare ( ' SELECT * FROM tl_metamodel_dca_sortgroup WHERE pid=? ORDER BY sorting ASC ' ) ; $ groupSort -> bindValue ( 1 , $ screenId ) ; $ groupSort -> execute ( ) ; $ inputScreen = array ( 'row' => $ inputScreens -> row ( ) , 'properties' => $ propertyRows -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'conditions' => $ conditions -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'groupSort' => $ groupSort -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = $ inputScreen ; $ this -> information [ $ metaModelName ] [ self :: MODELID ] = $ metaModelId ; $ parentTable = $ inputScreen [ 'row' ] [ 'ptable' ] ; if ( $ parentTable && ! $ this -> isInputScreenStandalone ( $ metaModelName ) ) { $ this -> parentMap [ $ parentTable ] [ ] = $ this -> information [ $ metaModelName ] [ self :: MODELID ] ; $ this -> childMap [ $ metaModelName ] = $ parentTable ; } } } 
protected function buildInputScreen ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] ; if ( ! is_object ( $ inputScreen ) ) { $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = new InputScreen ( $ this -> container , $ inputScreen [ 'row' ] , $ inputScreen [ 'properties' ] , $ inputScreen [ 'conditions' ] , $ inputScreen [ 'groupSort' ] ) ; } return $ inputScreen ; } 
protected function isInputScreenStandalone ( $ metaModel ) { $ information = $ this -> information [ $ metaModel ] ; $ inputScreen = isset ( $ information [ self :: INPUTSCREEN ] ) ? $ information [ self :: INPUTSCREEN ] : null ; if ( ! is_object ( $ inputScreen ) ) { return ( $ inputScreen [ 'row' ] [ 'rendertype' ] == 'standalone' ) ; } return $ inputScreen -> isStandalone ( ) ; } 
public function getRenderSetting ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] ) ? $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] : null ; } 
public function getInputScreen ( $ metaModel ) { $ inputScreen = $ this -> getInputScreenDetails ( $ metaModel ) ; return $ inputScreen ? $ inputScreen -> getId ( ) : null ; } 
public function getStandaloneInputScreens ( ) { $ result = array ( ) ; foreach ( array_keys ( $ this -> information ) as $ modelName ) { if ( $ this -> isInputScreenStandalone ( $ modelName ) ) { $ result [ ] = $ this -> getInputScreenDetails ( $ modelName ) ; } } return $ result ; } 
public function getParentOf ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> childMap [ $ metaModelName ] ) ? $ this -> childMap [ $ metaModelName ] : null ; } 
public function getParentedInputScreenNames ( $ parent = null ) { $ result = array ( ) ; if ( $ parent ) { if ( ! isset ( $ this -> parentMap [ $ parent ] ) ) { return array ( ) ; } foreach ( $ this -> parentMap [ $ parent ] as $ child ) { $ result [ ] = ( isset ( $ this -> tableMap [ $ child ] ) ) ? $ this -> tableMap [ $ child ] : $ child ; } return $ result ; } foreach ( array_keys ( $ this -> information ) as $ modelName ) { if ( ! $ this -> isInputScreenStandalone ( $ modelName ) ) { $ result [ ] = ( isset ( $ this -> tableMap [ $ modelName ] ) ) ? $ this -> tableMap [ $ modelName ] : $ modelName ; } } return $ result ; } 
public function getParentedInputScreens ( $ parent = null ) { $ result = array ( ) ; foreach ( $ this -> getParentedInputScreenNames ( $ parent ) as $ modelName ) { $ result [ ] = $ this -> getInputScreenDetails ( $ modelName ) ; } return $ result ; } 
public function getMatchingIds ( ) { if ( 0 === count ( $ this -> arrChildFilters ) ) { return array ( ) ; } $ ids = null ; foreach ( $ this -> arrChildFilters as $ objChildFilter ) { $ matchingIds = $ objChildFilter -> getMatchingIds ( ) ; if ( array ( ) === $ matchingIds ) { 
public function createInstance ( $ information , $ metaModel ) { return new $ this -> typeClass ( $ metaModel , $ information , $ this -> connection , $ this -> tableManipulator ) ; } 
public function createStore ( ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; return new BreadcrumbStore ( $ this -> iconBuilder , $ this -> translator , $ request ? $ request -> getUri ( ) : '' ) ; } 
public function handle ( BuildDataDefinitionEvent $ event ) { if ( ( $ event -> getContainer ( ) -> getName ( ) !== 'tl_metamodel_searchable_pages' ) ) { return ; } foreach ( $ event -> getContainer ( ) -> getPalettesDefinition ( ) -> getPalettes ( ) as $ palette ) { foreach ( $ palette -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) != 'filterparams' ) { continue ; } $ chain = $ property -> getVisibleCondition ( ) ; if ( ! ( $ chain && ( $ chain instanceof PropertyConditionChain ) && $ chain -> getConjunction ( ) == PropertyConditionChain :: AND_CONJUNCTION ) ) { $ chain = new PropertyConditionChain ( $ chain ? : array ( ) , PropertyConditionChain :: AND_CONJUNCTION ) ; $ property -> setVisibleCondition ( $ chain ) ; } $ chain -> addCondition ( new NotCondition ( new PropertyValueCondition ( 'filter' , 0 ) ) ) ; break ; } } } 
public function handle ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'filterparams' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ objFilterSettings = $ this -> settingFactory -> createCollection ( $ model -> getProperty ( 'filter' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'subfields' ] = $ objFilterSettings -> getParameterDCA ( ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; } 
protected function transformDSLTermToString ( $ dslTerm ) { $ string = "" ; if ( is_array ( $ dslTerm ) ) { $ key = key ( $ dslTerm ) ; $ value = $ dslTerm [ $ key ] ; if ( is_string ( $ key ) ) $ string .= "$key:" ; } else $ value = $ dslTerm ; if ( strpos ( $ value , " " ) !== false ) $ string .= '"' . $ value . '"' ; else $ string .= $ value ; return $ string ; } 
protected function transformDSLSortToString ( $ dslSort ) { $ string = "" ; if ( is_array ( $ dslSort ) ) { foreach ( $ dslSort as $ sort ) { if ( is_array ( $ sort ) ) { $ field = key ( $ sort ) ; $ info = current ( $ sort ) ; } else $ field = $ sort ; $ string .= "&sort=" . $ field ; if ( isset ( $ info ) ) { if ( is_string ( $ info ) && $ info == "desc" ) $ string .= ":reverse" ; elseif ( is_array ( $ info ) && array_key_exists ( "reverse" , $ info ) && $ info [ 'reverse' ] ) $ string .= ":reverse" ; } } } return $ string ; } 
protected function buildUrl ( $ path = false , array $ options = array ( ) ) { $ isAbsolute = ( is_array ( $ path ) ? $ path [ 0 ] [ 0 ] : $ path [ 0 ] ) === '/' ; $ url = $ isAbsolute || null === $ this -> index ? '' : "/" . $ this -> index ; if ( $ path && is_array ( $ path ) && count ( $ path ) > 0 ) $ url .= "/" . implode ( "/" , array_filter ( $ path ) ) ; if ( substr ( $ url , - 1 ) == "/" ) $ url = substr ( $ url , 0 , - 1 ) ; if ( count ( $ options ) > 0 ) $ url .= "?" . http_build_query ( $ options , '' , '&' ) ; return $ url ; } 
public function index ( $ document , $ id = false , array $ options = array ( ) ) { if ( $ id === false ) throw new \ ElasticSearch \ Exception ( "Memcached transport requires id when indexing" ) ; $ document = json_encode ( $ document ) ; $ url = $ this -> buildUrl ( array ( $ this -> type , $ id ) ) ; $ response = $ this -> conn -> set ( $ url , $ document ) ; return array ( 'ok' => $ response ) ; } 
public function update ( $ partialDocument , $ id , array $ options = array ( ) ) { $ document = json_encode ( array ( 'doc' => $ partialDocument ) ) ; $ url = $ this -> buildUrl ( array ( $ this -> type , $ id ) ) ; $ response = $ this -> conn -> set ( $ url , $ document ) ; return array ( 'ok' => $ response , ) ; } 
public function search ( $ query ) { if ( is_array ( $ query ) ) { if ( array_key_exists ( "query" , $ query ) ) { $ dsl = new Stringify ( $ query ) ; $ q = ( string ) $ dsl ; $ url = $ this -> buildUrl ( array ( $ this -> type , "_search?q=" . $ q ) ) ; $ result = json_decode ( $ this -> conn -> get ( $ url ) , true ) ; return $ result ; } throw new \ ElasticSearch \ Exception ( "Memcached protocol doesnt support the full DSL, only query" ) ; } elseif ( is_string ( $ query ) ) { $ url = $ this -> buildUrl ( array ( $ this -> type , "_search?q=" . $ query ) ) ; $ result = json_decode ( $ this -> conn -> get ( $ url ) , true ) ; return $ result ; } } 
public function request ( $ path , $ method = "GET" , $ payload = false ) { $ url = $ this -> buildUrl ( $ path ) ; switch ( $ method ) { case 'GET' : $ result = $ this -> conn -> get ( $ url ) ; break ; case 'DELETE' : $ result = $ this -> conn -> delete ( $ url ) ; break ; } return json_decode ( $ result ) ; } 
public function delete ( $ id = false , array $ options = array ( ) ) { if ( $ id ) return $ this -> request ( array ( $ this -> type , $ id ) , "DELETE" ) ; else return $ this -> request ( false , "DELETE" ) ; } 
public function index ( $ document , $ id = null , $ index , $ type , array $ options = array ( ) ) { $ params = array ( '_id' => $ id , '_index' => $ index , '_type' => $ type ) ; foreach ( $ options as $ key => $ value ) { $ params [ '_' . $ key ] = $ value ; } $ operation = array ( array ( 'index' => $ params ) , $ document ) ; $ this -> operations [ ] = $ operation ; return $ this ; } 
public function update ( $ partialDocument , $ id , $ index , $ type , array $ options = array ( ) ) { $ params = array ( '_id' => $ id , '_index' => $ index , '_type' => $ type , ) ; foreach ( $ options as $ key => $ value ) { $ params [ '_' . $ key ] = $ value ; } $ operation = array ( array ( 'update' => $ params ) , array ( 'doc' => $ partialDocument ) , ) ; $ this -> operations [ ] = $ operation ; return $ this ; } 
public function delete ( $ id = false , $ index , $ type , array $ options = array ( ) ) { $ params = array ( '_id' => $ id , '_index' => $ index , '_type' => $ type ) ; foreach ( $ options as $ key => $ value ) { $ params [ '_' . $ key ] = $ value ; } $ operation = array ( array ( 'delete' => $ params ) ) ; $ this -> operations [ ] = $ operation ; return $ this ; } 
public function createPayload ( ) { $ payloads = array ( ) ; foreach ( $ this -> operations as $ operation ) { foreach ( $ operation as $ partial ) { $ payloads [ ] = json_encode ( $ partial ) ; } } return join ( "\n" , $ payloads ) . "\n" ; } 
public function term ( $ term , $ field = false ) { $ this -> term = ( $ field ) ? array ( $ field => $ term ) : $ term ; return $ this ; } 
public function wildcard ( $ val , $ field = false ) { $ this -> wildcard = ( $ field ) ? array ( $ field => $ val ) : $ val ; return $ this ; } 
public function build ( ) { $ built = array ( ) ; if ( $ this -> term ) $ built [ 'term' ] = $ this -> term ; elseif ( $ this -> range ) $ built [ 'range' ] = $ this -> range -> build ( ) ; elseif ( $ this -> wildcard ) $ built [ 'wildcard' ] = $ this -> wildcard ; return $ built ; } 
public function query ( array $ options = array ( ) ) { if ( ! ( $ this -> query instanceof Query ) ) $ this -> query = new Query ( $ options ) ; return $ this -> query ; } 
public function build ( ) { $ built = array ( ) ; if ( $ this -> from != null ) $ built [ 'from' ] = $ this -> from ; if ( $ this -> size != null ) $ built [ 'size' ] = $ this -> size ; if ( $ this -> sort && is_array ( $ this -> sort ) ) $ built [ 'sort' ] = $ this -> sort ; if ( ! $ this -> query ) throw new \ ElasticSearch \ Exception ( "Query must be specified" ) ; else $ built [ 'query' ] = $ this -> query -> build ( ) ; return $ built ; } 
public function index ( $ document , $ id = false , array $ options = array ( ) ) { $ url = $ this -> buildUrl ( array ( $ this -> type , $ id ) , $ options ) ; $ method = ( $ id == false ) ? "POST" : "PUT" ; return $ this -> call ( $ url , $ method , $ document ) ; } 
public function update ( $ partialDocument , $ id , array $ options = array ( ) ) { $ url = $ this -> buildUrl ( array ( $ this -> type , $ id ) , $ options ) ; return $ this -> call ( $ url , "POST" , array ( 'doc' => $ partialDocument ) ) ; } 
public function search ( $ query , array $ options = array ( ) ) { $ result = false ; if ( is_array ( $ query ) ) { $ arg = "_search" ; $ url = $ this -> buildUrl ( array ( $ this -> type , $ arg ) , $ options ) ; $ result = $ this -> call ( $ url , "GET" , $ query ) ; } elseif ( is_string ( $ query ) ) { $ url = $ this -> buildUrl ( array ( $ this -> type , "_search?q=" . $ query ) ) ; $ result = $ this -> call ( $ url , "POST" , $ options ) ; } else { $ url = $ this -> buildUrl ( array ( $ this -> type , "_search?" ) ) ; $ result = $ this -> call ( $ url , "POST" , $ options ) ; } return $ result ; } 
public function deleteByQuery ( $ query , array $ options = array ( ) ) { $ options += array ( 'refresh' => true ) ; if ( is_array ( $ query ) ) { $ url = $ this -> buildUrl ( array ( $ this -> type , "_query" ) ) ; $ result = $ this -> call ( $ url , "DELETE" , $ query ) ; } elseif ( is_string ( $ query ) ) { $ url = $ this -> buildUrl ( array ( $ this -> type , "_query" ) , array ( 'q' => $ query ) ) ; $ result = $ this -> call ( $ url , "DELETE" ) ; } if ( $ options [ 'refresh' ] ) { $ this -> request ( '_refresh' , "POST" ) ; } return ! isset ( $ result [ 'error' ] ) ; } 
public function request ( $ path , $ method = "GET" , $ payload = false ) { return $ this -> call ( $ this -> buildUrl ( $ path ) , $ method , $ payload ) ; } 
public function delete ( $ id = false , array $ options = array ( ) ) { if ( $ id ) return $ this -> call ( $ this -> buildUrl ( array ( $ this -> type , $ id ) , $ options ) , "DELETE" ) ; else return $ this -> request ( false , "DELETE" ) ; } 
protected function call ( $ url , $ method = "GET" , $ payload = null ) { $ conn = $ this -> ch ; $ protocol = "http" ; $ requestURL = $ protocol . "://" . $ this -> host . $ url ; curl_setopt ( $ conn , CURLOPT_URL , $ requestURL ) ; curl_setopt ( $ conn , CURLOPT_TIMEOUT , $ this -> timeout ) ; curl_setopt ( $ conn , CURLOPT_PORT , $ this -> port ) ; curl_setopt ( $ conn , CURLOPT_CUSTOMREQUEST , strtoupper ( $ method ) ) ; curl_setopt ( $ conn , CURLOPT_FORBID_REUSE , 0 ) ; $ headers = array ( ) ; $ headers [ ] = 'Accept: application/json' ; $ headers [ ] = 'Content-Type: application/json' ; curl_setopt ( $ conn , CURLOPT_HTTPHEADER , $ headers ) ; if ( is_array ( $ payload ) && count ( $ payload ) > 0 ) curl_setopt ( $ conn , CURLOPT_POSTFIELDS , json_encode ( $ payload ) ) ; else curl_setopt ( $ conn , CURLOPT_POSTFIELDS , $ payload ) ; * cUrl error code reference can be found here: * http: */ $ errno = curl_errno ( $ conn ) ; switch ( $ errno ) { case CURLE_UNSUPPORTED_PROTOCOL : $ error = "Unsupported protocol [$protocol]" ; break ; case CURLE_FAILED_INIT : $ error = "Internal cUrl error?" ; break ; case CURLE_URL_MALFORMAT : $ error = "Malformed URL [$requestURL] -d " . json_encode ( $ payload ) ; break ; case CURLE_COULDNT_RESOLVE_PROXY : $ error = "Couldnt resolve proxy" ; break ; case CURLE_COULDNT_RESOLVE_HOST : $ error = "Couldnt resolve host" ; break ; case CURLE_COULDNT_CONNECT : $ error = "Couldnt connect to host [{$this->host}], ElasticSearch down?" ; break ; case CURLE_OPERATION_TIMEDOUT : $ error = "Operation timed out on [$requestURL]" ; break ; default : $ error = "Unknown error" ; if ( $ errno == 0 ) { $ error .= ". Non-cUrl error" ; } else { $ errstr = curl_error ( $ conn ) ; $ error .= " ($errstr)" ; } break ; } $ exception = new HTTPException ( $ error ) ; $ exception -> payload = $ payload ; $ exception -> port = $ this -> port ; $ exception -> protocol = $ protocol ; $ exception -> host = $ this -> host ; $ exception -> method = $ method ; throw $ exception ; } return $ data ; } 
public function build ( ) { $ built = array ( ) ; if ( $ this -> fieldname ) { $ built [ $ this -> fieldname ] = array ( ) ; foreach ( array ( "from" , "to" , "includeLower" , "includeUpper" , "boost" ) as $ opt ) { if ( $ this -> $ opt !== null ) $ built [ $ this -> fieldname ] [ $ opt ] = $ this -> $ opt ; } if ( count ( $ built [ $ this -> fieldname ] ) == 0 ) throw new \ ElasticSearch \ Exception ( "Empty RangeQuery cant be created" ) ; } return $ built ; } 
public function field ( $ field , $ config = array ( ) ) { if ( is_string ( $ config ) ) $ config = array ( 'type' => $ config ) ; $ this -> properties [ $ field ] = $ config ; return $ this ; } 
public function config ( $ key , $ value = null ) { if ( is_array ( $ key ) ) $ this -> config = $ key + $ this -> config ; else { if ( $ value !== null ) $ this -> config [ $ key ] = $ value ; if ( ! isset ( $ this -> config [ $ key ] ) ) throw new \ Exception ( "Configuration key `type` is not set" ) ; return $ this -> config [ $ key ] ; } } 
public static function connection ( $ config = array ( ) ) { if ( ! $ config && ( $ url = getenv ( 'ELASTICSEARCH_URL' ) ) ) { $ config = $ url ; } if ( is_string ( $ config ) ) { $ config = self :: parseDsn ( $ config ) ; } $ config += self :: $ _defaults ; $ protocol = $ config [ 'protocol' ] ; if ( ! isset ( self :: $ _protocols [ $ protocol ] ) ) { throw new \ Exception ( "Tried to use unknown protocol: $protocol" ) ; } $ class = self :: $ _protocols [ $ protocol ] ; if ( null !== $ config [ 'timeout' ] && ! is_numeric ( $ config [ 'timeout' ] ) ) { throw new \ Exception ( "HTTP timeout should have a numeric value when specified." ) ; } $ server = is_array ( $ config [ 'servers' ] ) ? $ config [ 'servers' ] [ 0 ] : $ config [ 'servers' ] ; list ( $ host , $ port ) = explode ( ':' , $ server ) ; $ transport = new $ class ( $ host , $ port , $ config [ 'timeout' ] ) ; $ client = new self ( $ transport , $ config [ 'index' ] , $ config [ 'type' ] ) ; $ client -> config ( $ config ) ; return $ client ; } 
public function setIndex ( $ index ) { if ( is_array ( $ index ) ) $ index = implode ( "," , array_filter ( $ index ) ) ; $ this -> index = $ index ; $ this -> transport -> setIndex ( $ index ) ; return $ this ; } 
public function setType ( $ type ) { if ( is_array ( $ type ) ) $ type = implode ( "," , array_filter ( $ type ) ) ; $ this -> type = $ type ; $ this -> transport -> setType ( $ type ) ; return $ this ; } 
public function map ( $ mapping , array $ config = array ( ) ) { if ( is_array ( $ mapping ) ) $ mapping = new Mapping ( $ mapping ) ; $ mapping -> config ( $ config ) ; try { $ type = $ mapping -> config ( 'type' ) ; } catch ( \ Exception $ e ) { } 
public function request ( $ path , $ method = 'GET' , $ payload = false , $ verbose = false ) { $ response = $ this -> transport -> request ( $ this -> expandPath ( $ path ) , $ method , $ payload ) ; return ( $ verbose || ! isset ( $ response [ '_source' ] ) ) ? $ response : $ response [ '_source' ] ; } 
public function index ( $ document , $ id = false , array $ options = array ( ) ) { if ( $ this -> bulk ) { return $ this -> bulk -> index ( $ document , $ id , $ this -> index , $ this -> type , $ options ) ; } return $ this -> transport -> index ( $ document , $ id , $ options ) ; } 
public function update ( $ partialDocument , $ id , array $ options = array ( ) ) { if ( $ this -> bulk ) { return $ this -> bulk -> update ( $ partialDocument , $ id , $ this -> index , $ this -> type , $ options ) ; } return $ this -> transport -> update ( $ partialDocument , $ id , $ options ) ; } 
public function search ( $ query , array $ options = array ( ) ) { $ start = microtime ( true ) ; $ result = $ this -> transport -> search ( $ query , $ options ) ; $ result [ 'time' ] = microtime ( true ) - $ start ; return $ result ; } 
public function delete ( $ id = false , array $ options = array ( ) ) { if ( $ this -> bulk ) { return $ this -> bulk -> delete ( $ id , $ this -> index , $ this -> type , $ options ) ; } return $ this -> transport -> delete ( $ id , $ options ) ; } 
protected function expandPath ( $ path ) { $ path = ( array ) $ path ; $ isAbsolute = $ path [ 0 ] [ 0 ] === '/' ; return $ isAbsolute ? $ path : array_merge ( ( array ) $ this -> type , $ path ) ; } 
protected static function parseDsn ( $ dsn ) { $ parts = parse_url ( $ dsn ) ; $ protocol = $ parts [ 'scheme' ] ; $ servers = $ parts [ 'host' ] . ':' . $ parts [ 'port' ] ; if ( isset ( $ parts [ 'path' ] ) ) { $ path = explode ( '/' , $ parts [ 'path' ] ) ; list ( $ index , $ type ) = array_values ( array_filter ( $ path ) ) ; } return compact ( 'protocol' , 'servers' , 'index' , 'type' ) ; } 
public function beginBulk ( ) { if ( ! $ this -> bulk ) { $ this -> bulk = $ this -> createBulk ( $ this ) ; } return $ this -> bulk ; } 
public function commitBulk ( ) { if ( $ this -> bulk && $ this -> bulk -> count ( ) ) { $ result = $ this -> bulk -> commit ( ) ; $ this -> bulk = null ; return $ result ; } } 
public function init ( $ wrappedHtml ) { $ helper = Mage :: helper ( 'aoe_templatehints' ) ; $ wrappedHtml .= '<script type="text/javascript">' . $ helper -> getSkinFileContent ( 'aoe_templatehints/js/opentip.min.js' ) . '</script>' ; $ wrappedHtml .= '<script type="text/javascript">' . $ helper -> getSkinFileContent ( 'aoe_templatehints/js/excanvas.js' ) . '</script>' ; $ wrappedHtml .= '<script type="text/javascript">' . $ helper -> getSkinFileContent ( 'aoe_templatehints/js/aoe_templatehints.js' ) . '</script>' ; $ wrappedHtml .= '<style type="text/css">' . $ helper -> getSkinFileContent ( 'aoe_templatehints/css/aoe_templatehints.css' ) . '</style>' ; $ wrappedHtml .= '<style type="text/css">' . $ helper -> getSkinFileContent ( 'aoe_templatehints/css/opentip.css' ) . '</style>' ; return $ wrappedHtml ; } 
public function render ( Mage_Core_Block_Abstract $ block , $ blockContent , $ id ) { $ helper = Mage :: helper ( 'aoe_templatehints/blockInfo' ) ; $ path = $ helper -> getBlockPath ( $ block ) ; $ blockInfo = $ helper -> getBlockInfo ( $ block ) ; $ this -> aStatistics [ $ blockInfo [ 'cache-status' ] ] ++ ; $ wrappedHtml = sprintf ( '<div id="tpl-hint-%1$s" class="%2$s"> %3$s <div id="tpl-hint-%1$s-title" style="display: none;">%4$s</div> <div id="tpl-hint-%1$s-infobox" style="display: none;">%5$s</div> </div>' , $ id , $ this -> getHintClass ( ) . ' ' . $ blockInfo [ 'cache-status' ] , $ blockContent , $ helper -> renderTitle ( $ blockInfo ) , $ this -> renderBox ( $ blockInfo , $ path ) ) ; $ showStatistics = false ; 
protected function arrayToDtDd ( array $ array , array $ skipKeys = array ( ) ) { $ output = '<dl>' ; foreach ( $ array as $ key => $ value ) { if ( in_array ( $ key , $ skipKeys ) ) { continue ; } if ( is_array ( $ value ) ) { $ value = $ this -> arrayToDtDd ( $ value ) ; } if ( is_int ( $ key ) ) { $ output .= $ value . '<br />' ; } else { $ output .= '<dt>' . ucfirst ( $ key ) . ':</dt><dd>' ; $ output .= $ value ; $ output .= '</dd>' ; } } $ output .= '</dl>' ; return $ output ; } 
public function showHints ( ) { if ( is_null ( $ this -> showHints ) ) { $ this -> showHints = false ; if ( Mage :: helper ( 'core' ) -> isDevAllowed ( ) ) { if ( Mage :: getSingleton ( 'core/cookie' ) -> get ( 'ath' ) || Mage :: app ( ) -> getRequest ( ) -> get ( 'ath' ) ) { $ this -> showHints = true ; } } } return $ this -> showHints ; } 
public function getRenderer ( ) { if ( is_null ( $ this -> renderer ) ) { $ rendererClass = Mage :: getStoreConfig ( 'dev/aoe_templatehints/templateHintRenderer' ) ; if ( empty ( $ rendererClass ) ) { Mage :: throwException ( 'No renderer configured' ) ; } $ this -> renderer = Mage :: getSingleton ( $ rendererClass ) ; if ( ! is_object ( $ this -> renderer ) || ! $ this -> renderer instanceof Aoe_TemplateHints_Model_Renderer_Abstract ) { Mage :: throwException ( 'Render must be an instanceof Aoe_TemplateHints_Model_Renderer_Abstract' ) ; } } return $ this -> renderer ; } 
public function core_block_abstract_to_html_after ( Varien_Event_Observer $ params ) { if ( ! $ this -> showHints ( ) ) { return ; } if ( substr ( trim ( $ params -> getTransport ( ) -> getHtml ( ) ) , 0 , 4 ) == 'http' ) { return ; } $ wrappedHtml = '' ; $ block = $ params -> getBlock ( ) ; 
public function getSkinFileContent ( $ file ) { $ package = Mage :: getSingleton ( 'core/design_package' ) ; $ areaBackup = $ package -> getArea ( ) ; $ path = $ package -> setArea ( 'frontend' ) -> getFilename ( $ file , array ( '_type' => 'skin' ) ) ; $ content = file_get_contents ( $ path ) ; $ package -> setArea ( $ areaBackup ) ; return $ content ; } 
public function toOptionArray ( ) { $ options = array ( ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_comment' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Comments' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_opentip' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_tipOnly' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups (border initially invisible)' ) ) ; Mage :: dispatchEvent ( 'aoetemplatehints_hintrenderer_options' , array ( 'options' => & $ options ) ) ; return $ options ; } 
public function render ( Mage_Core_Block_Abstract $ block , $ blockContent , $ id ) { $ helper = Mage :: helper ( 'aoe_templatehints/blockInfo' ) ; $ path = $ helper -> getBlockPath ( $ block ) ; $ blockInfo = $ helper -> getBlockInfo ( $ block ) ; $ wrappedHtml = sprintf ( "\n" . '<!-- [START: %1$s] %4$s' . "\n" . '%5$s -->' . "\n" . '%3$s' . "\n" . '<!-- [END: %1$s] %4$s -->' . "\n" , $ id , $ blockInfo [ 'cache-status' ] , $ blockContent , $ helper -> renderTitle ( $ blockInfo ) , $ this -> renderBox ( $ blockInfo , $ path ) ) ; return $ wrappedHtml ; } 
protected function renderBox ( array $ info , array $ path ) { $ helper = Mage :: helper ( 'aoe_templatehints/blockInfo' ) ; $ output = '' ; $ output .= $ this -> arrayToTabList ( $ info , array ( 'name' , 'alias' ) ) ; if ( count ( $ path ) > 0 ) { $ output .= "\t" . $ helper -> __ ( 'Block nesting' ) . ":\n" ; foreach ( $ path as $ step ) { $ output .= "\t\t" . $ helper -> renderTitle ( $ step ) . "\n" ; } } return $ output ; } 
protected function arrayToTabList ( array $ array , array $ skipKeys = array ( ) , $ indentationLevel = 1 ) { $ output = '' ; foreach ( $ array as $ key => $ value ) { if ( in_array ( $ key , $ skipKeys , true ) ) { continue ; } $ output .= $ this -> tabsForIndentation ( $ indentationLevel ) ; if ( ! is_array ( $ value ) ) { if ( ! is_int ( $ key ) ) { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> tabsForIndentation ( $ indentationLevel + 1 ) ; } $ output .= $ value . "\n" ; } else { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> arrayToTabList ( $ value , $ skipKeys , $ indentationLevel + 1 ) ; } } return $ output ; } 
public function findFileAndLine ( $ className ) { $ result = false ; $ fullPath = $ this -> searchFullPath ( $ this -> getFileFromClassName ( $ className ) ) ; if ( $ fullPath ) { $ result = array ( 'file' => $ fullPath , 'line' => 0 ) ; $ lineNumber = $ this -> getLineNumber ( $ fullPath , '/class\s+' . $ className . '/' ) ; if ( $ lineNumber ) { $ result [ 'line' ] = $ lineNumber ; } } return $ result ; } 
public function searchFullPath ( $ filename ) { $ paths = explode ( PATH_SEPARATOR , get_include_path ( ) ) ; foreach ( $ paths as $ path ) { $ fullPath = $ path . DIRECTORY_SEPARATOR . $ filename ; if ( file_exists ( $ fullPath ) ) { return $ fullPath ; } } return false ; } 
public function getBlockInfo ( Mage_Core_Block_Abstract $ block , $ fullInfo = true ) { $ info = array ( 'name' => $ block -> getNameInLayout ( ) , 'alias' => $ block -> getBlockAlias ( ) , ) ; if ( ! $ fullInfo ) { return $ info ; } $ info [ 'class' ] = get_class ( $ block ) ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ fileAndLine = Mage :: helper ( 'aoe_templatehints/classInfo' ) -> findFileAndLine ( $ info [ 'class' ] ) ; if ( $ fileAndLine ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , $ fileAndLine [ 'file' ] , $ fileAndLine [ 'line' ] ) ; $ info [ 'class' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ info [ 'class' ] ) ; } } $ info [ 'module' ] = $ block -> getModuleName ( ) ; if ( $ block instanceof Mage_Cms_Block_Block ) { $ info [ 'cms-blockId' ] = $ block -> getBlockId ( ) ; } if ( $ block instanceof Mage_Cms_Block_Page ) { $ info [ 'cms-pageId' ] = $ block -> getPage ( ) -> getIdentifier ( ) ; } $ templateFile = $ block -> getTemplateFile ( ) ; if ( $ templateFile ) { $ info [ 'template' ] = $ templateFile ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , Mage :: getBaseDir ( 'design' ) . DS . $ templateFile , 0 ) ; $ info [ 'template' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ templateFile ) ; } } 
public function getRemoteCallEnabled ( ) { if ( is_null ( $ this -> remoteCallEnabled ) ) { $ this -> remoteCallEnabled = Mage :: getStoreConfigFlag ( 'dev/aoe_templatehints/enablePhpstormRemoteCall' ) ; } return $ this -> remoteCallEnabled ; } 
public function getRemoteCallUrlTemplate ( ) { if ( is_null ( $ this -> remoteCallUrlTemplate ) ) { $ this -> remoteCallUrlTemplate = Mage :: getStoreConfig ( 'dev/aoe_templatehints/remoteCallUrlTemplate' ) ; } return $ this -> remoteCallUrlTemplate ; } 
public function getClassMethods ( $ className ) { if ( ! isset ( $ this -> classMethodCache [ $ className ] ) ) { $ info = array ( ) ; $ rClass = new ReflectionClass ( $ className ) ; $ currentClass = $ rClass ; $ currentClassName = $ currentClass -> getName ( ) ; $ currentMethods = get_class_methods ( $ currentClass -> getName ( ) ) ; $ parentClass = $ currentClass -> getParentClass ( ) ; $ level = 1 ; while ( $ parentClass && $ level < 6 ) { $ parentClassName = $ parentClass -> getName ( ) ; if ( ! in_array ( $ currentClassName , array ( 'Mage_Core_Block_Abstract' , 'Mage_Core_Block_Template' ) ) ) { $ parentMethods = get_class_methods ( $ parentClassName ) ; $ tmp = array_diff ( $ currentMethods , $ parentMethods ) ; $ info [ $ currentClassName ] = array ( ) ; 
public function getBlockPath ( Mage_Core_Block_Abstract $ block ) { $ blockPath = array ( ) ; $ step = $ block -> getParentBlock ( ) ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { $ blockPath [ ] = $ this -> getBlockInfo ( $ step , false ) ; $ step = $ step -> getParentBlock ( ) ; } return $ blockPath ; } 
public function isWithinCachedBlock ( Mage_Core_Block_Abstract $ block ) { $ step = $ block ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { if ( ! is_null ( $ step -> getCacheLifetime ( ) ) ) { return true ; } $ step = $ step -> getParentBlock ( ) ; } return false ; } 
public function renderTitle ( array $ info ) { $ title = $ info [ 'name' ] ; if ( $ info [ 'name' ] != $ info [ 'alias' ] && $ info [ 'alias' ] ) { $ title .= ' (alias: ' . $ info [ 'alias' ] . ')' ; } return $ title ; } 
public static function getType ( $ name ) { if ( ! isset ( self :: $ _typeObjects [ $ name ] ) ) { if ( ! isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: unknownType ( $ name ) ; } self :: $ _typeObjects [ $ name ] = new self :: $ _typesMap [ $ name ] ( ) ; } return self :: $ _typeObjects [ $ name ] ; } 
public static function addType ( $ name , $ className ) { if ( isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeExists ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; } 
public static function overrideType ( $ name , $ className ) { if ( ! isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeNotFound ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; } 
public function getProxy ( $ className , $ identifier ) { $ fqn = ClassUtils :: generateProxyClassName ( $ className , $ this -> proxyNamespace ) ; if ( ! class_exists ( $ fqn , false ) ) { $ fileName = $ this -> getProxyFileName ( $ className ) ; if ( $ this -> autoGenerate ) { $ this -> generateProxyClass ( $ this -> dm -> getClassMetadata ( $ className ) , $ fileName , self :: $ proxyClassTemplate ) ; } require $ fileName ; } if ( ! $ this -> dm -> getMetadataFactory ( ) -> hasMetadataFor ( $ fqn ) ) { $ this -> dm -> getMetadataFactory ( ) -> setMetadataFor ( $ fqn , $ this -> dm -> getClassMetadata ( $ className ) ) ; } return new $ fqn ( $ this -> dm , $ identifier ) ; } 
private function getProxyFileName ( $ className , $ baseDir = null ) { $ proxyDir = $ baseDir ? : $ this -> proxyDir ; return $ proxyDir . DIRECTORY_SEPARATOR . '__CG__' . str_replace ( '\\' , '' , $ className ) . '.php' ; } 
public function generateProxyClasses ( array $ classes , $ toDir = null ) { $ proxyDir = $ toDir ? : $ this -> proxyDir ; $ proxyDir = rtrim ( $ proxyDir , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; foreach ( $ classes as $ class ) { if ( $ class -> isMappedSuperclass ) { continue ; } $ proxyFileName = $ this -> getProxyFileName ( $ class -> name , $ toDir ) ; $ this -> generateProxyClass ( $ class , $ proxyFileName , self :: $ proxyClassTemplate ) ; } } 
private function generateProxyClass ( $ class , $ fileName , $ template ) { $ methods = $ this -> generateMethods ( $ class ) ; $ sleepImpl = $ this -> generateSleep ( $ class ) ; $ placeholders = array ( '<namespace>' , '<proxyClassName>' , '<className>' , '<methods>' , '<sleepImpl>' ) ; $ className = ltrim ( $ class -> name , '\\' ) ; $ proxyClassName = ClassUtils :: generateProxyClassName ( $ class -> name , $ this -> proxyNamespace ) ; $ parts = explode ( '\\' , strrev ( $ proxyClassName ) , 2 ) ; $ proxyClassNamespace = strrev ( $ parts [ 1 ] ) ; $ proxyClassName = strrev ( $ parts [ 0 ] ) ; $ replacements = array ( $ proxyClassNamespace , $ proxyClassName , $ className , $ methods , $ sleepImpl ) ; $ template = str_replace ( $ placeholders , $ replacements , $ template ) ; file_put_contents ( $ fileName , $ template , LOCK_EX ) ; } 
private function generateMethods ( ClassMetadata $ class ) { $ methods = '' ; foreach ( $ class -> reflClass -> getMethods ( ) as $ method ) { if ( $ method -> isConstructor ( ) || strtolower ( $ method -> getName ( ) ) == "__sleep" ) { continue ; } if ( $ method -> isPublic ( ) && ! $ method -> isFinal ( ) && ! $ method -> isStatic ( ) ) { $ methods .= PHP_EOL . ' public function ' ; if ( $ method -> returnsReference ( ) ) { $ methods .= '&' ; } $ methods .= $ method -> getName ( ) . '(' ; $ firstParam = true ; $ parameterString = $ argumentString = '' ; foreach ( $ method -> getParameters ( ) as $ param ) { if ( $ firstParam ) { $ firstParam = false ; } else { $ parameterString .= ', ' ; $ argumentString .= ', ' ; } 
private function generateSleep ( ClassMetadata $ class ) { $ sleepImpl = '' ; if ( $ class -> reflClass -> hasMethod ( '__sleep' ) ) { $ sleepImpl .= "return array_merge(array('__isInitialized__'), parent::__sleep());" ; } else { $ sleepImpl .= "return array('__isInitialized__', " ; $ properties = array ( ) ; foreach ( $ class -> fieldMappings as $ name => $ prop ) { $ properties [ ] = "'$name'" ; } $ sleepImpl .= implode ( ',' , $ properties ) . ');' ; } return $ sleepImpl ; } 
public function getDocumentNamespace ( $ documentNamespaceAlias ) { if ( ! isset ( $ this -> attributes [ 'documentNamespaces' ] [ $ documentNamespaceAlias ] ) ) { throw CouchDBException :: unknownDocumentNamespace ( $ documentNamespaceAlias ) ; } return trim ( $ this -> attributes [ 'documentNamespaces' ] [ $ documentNamespaceAlias ] , '\\' ) ; } 
public function newDefaultAnnotationDriver ( $ paths = array ( ) ) { $ reader = new \ Doctrine \ Common \ Annotations \ SimpleAnnotationReader ( ) ; $ reader -> addNamespace ( 'Doctrine\ODM\CouchDB\Mapping\Annotations' ) ; return new \ Doctrine \ ODM \ CouchDB \ Mapping \ Driver \ AnnotationDriver ( $ reader , ( array ) $ paths ) ; } 
protected function doLoadMetadata ( $ class , $ parent , $ rootEntityFound , array $ nonSuperclassParents ) { if ( $ parent ) { $ this -> addAssociationsMapping ( $ class , $ parent ) ; $ this -> addFieldMapping ( $ class , $ parent ) ; $ this -> addIndexes ( $ class , $ parent ) ; $ parent -> deriveChildMetadata ( $ class ) ; $ class -> setParentClasses ( $ nonSuperclassParents ) ; } if ( $ this -> getDriver ( ) ) { $ this -> getDriver ( ) -> loadMetadataForClass ( $ class -> getName ( ) , $ class ) ; } $ this -> validateMapping ( $ class ) ; } 
protected function loadMetadata ( $ className ) { if ( class_exists ( $ className ) ) { return parent :: loadMetadata ( $ className ) ; } throw MappingException :: classNotFound ( $ className ) ; } 
static public function create ( $ generatorType ) { switch ( $ generatorType ) { case ClassMetadata :: IDGENERATOR_ASSIGNED : $ instance = new AssignedIdGenerator ( ) ; break ; case ClassMetadata :: IDGENERATOR_UUID : $ instance = new CouchUUIDGenerator ( ) ; break ; default : throw new \ Exception ( "ID Generator does not exist!" ) ; } return $ instance ; } 
public function createQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new ODMQuery ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; $ query -> setDocumentManager ( $ this ) ; return $ query ; } 
public function createNativeQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new Query ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; return $ query ; } 
public function createLuceneQuery ( $ designDocName , $ viewName ) { $ luceneHandlerName = $ this -> config -> getLuceneHandlerName ( ) ; $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new ODMLuceneQuery ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ luceneHandlerName , $ designDocName , $ viewName , $ designDoc ) ; $ query -> setDocumentManager ( $ this ) ; return $ query ; } 
public function clear ( $ objectName = null ) { if ( $ objectName === null ) { 
public function initializeObject ( $ obj ) { if ( $ obj instanceof PersistentCollection ) { $ obj -> initialize ( ) ; } else if ( $ obj instanceof Proxy \ Proxy ) { $ obj -> __doctrineLoad__ ( ) ; } } 
public static function encrypt ( $ K , $ IV , $ P = null , $ A = null , $ tag_length = 128 ) { Assertion :: string ( $ K , 'The key encryption key must be a binary string.' ) ; $ key_length = mb_strlen ( $ K , '8bit' ) * 8 ; Assertion :: inArray ( $ key_length , [ 128 , 192 , 256 ] , 'Bad key encryption key length.' ) ; Assertion :: string ( $ IV , 'The Initialization Vector must be a binary string.' ) ; Assertion :: nullOrString ( $ P , 'The data to encrypt must be null or a binary string.' ) ; Assertion :: nullOrString ( $ A , 'The Additional Authentication Data must be null or a binary string.' ) ; Assertion :: integer ( $ tag_length , 'Invalid tag length. Supported values are: 128, 120, 112, 104 and 96.' ) ; Assertion :: inArray ( $ tag_length , [ 128 , 120 , 112 , 104 , 96 ] , 'Invalid tag length. Supported values are: 128, 120, 112, 104 and 96.' ) ; if ( version_compare ( PHP_VERSION , '7.1.0RC5' ) >= 0 && null !== $ P ) { return self :: encryptWithPHP71 ( $ K , $ key_length , $ IV , $ P , $ A , $ tag_length ) ; } elseif ( class_exists ( '\Crypto\Cipher' ) ) { return self :: encryptWithCryptoExtension ( $ K , $ key_length , $ IV , $ P , $ A , $ tag_length ) ; } return self :: encryptWithPHP ( $ K , $ key_length , $ IV , $ P , $ A , $ tag_length ) ; } 
public static function encryptAndAppendTag ( $ K , $ IV , $ P = null , $ A = null , $ tag_length = 128 ) { return implode ( self :: encrypt ( $ K , $ IV , $ P , $ A , $ tag_length ) ) ; } 
private static function encryptWithPHP71 ( $ K , $ key_length , $ IV , $ P = null , $ A = null , $ tag_length = 128 ) { $ mode = 'aes-' . ( $ key_length ) . '-gcm' ; $ T = null ; $ C = openssl_encrypt ( $ P , $ mode , $ K , OPENSSL_RAW_DATA , $ IV , $ T , $ A , $ tag_length / 8 ) ; Assertion :: true ( false !== $ C , 'Unable to encrypt the data.' ) ; return [ $ C , $ T ] ; } 
private static function encryptWithPHP ( $ K , $ key_length , $ IV , $ P = null , $ A = null , $ tag_length = 128 ) { list ( $ J0 , $ v , $ a_len_padding , $ H ) = self :: common ( $ K , $ key_length , $ IV , $ A ) ; $ C = self :: getGCTR ( $ K , $ key_length , self :: getInc ( 32 , $ J0 ) , $ P ) ; $ u = self :: calcVector ( $ C ) ; $ c_len_padding = self :: addPadding ( $ C ) ; $ S = self :: getHash ( $ H , $ A . str_pad ( '' , $ v / 8 , "\0" ) . $ C . str_pad ( '' , $ u / 8 , "\0" ) . $ a_len_padding . $ c_len_padding ) ; $ T = self :: getMSB ( $ tag_length , self :: getGCTR ( $ K , $ key_length , $ J0 , $ S ) ) ; return [ $ C , $ T ] ; } 
private static function encryptWithCryptoExtension ( $ K , $ key_length , $ IV , $ P = null , $ A = null , $ tag_length = 128 ) { $ cipher = \ Crypto \ Cipher :: aes ( \ Crypto \ Cipher :: MODE_GCM , $ key_length ) ; $ cipher -> setAAD ( $ A ) ; $ cipher -> setTagLength ( $ tag_length / 8 ) ; $ C = $ cipher -> encrypt ( $ P , $ K , $ IV ) ; $ T = $ cipher -> getTag ( ) ; return [ $ C , $ T ] ; } 
public static function decrypt ( $ K , $ IV , $ C , $ A , $ T ) { Assertion :: string ( $ K , 'The key encryption key must be a binary string.' ) ; $ key_length = mb_strlen ( $ K , '8bit' ) * 8 ; Assertion :: inArray ( $ key_length , [ 128 , 192 , 256 ] , 'Bad key encryption key length.' ) ; Assertion :: string ( $ IV , 'The Initialization Vector must be a binary string.' ) ; Assertion :: nullOrString ( $ C , 'The data to encrypt must be null or a binary string.' ) ; Assertion :: nullOrString ( $ A , 'The Additional Authentication Data must be null or a binary string.' ) ; $ tag_length = self :: getLength ( $ T ) ; Assertion :: integer ( $ tag_length , 'Invalid tag length. Supported values are: 128, 120, 112, 104 and 96.' ) ; Assertion :: inArray ( $ tag_length , [ 128 , 120 , 112 , 104 , 96 ] , 'Invalid tag length. Supported values are: 128, 120, 112, 104 and 96.' ) ; if ( version_compare ( PHP_VERSION , '7.1.0RC5' ) >= 0 && null !== $ C ) { return self :: decryptWithPHP71 ( $ K , $ key_length , $ IV , $ C , $ A , $ T ) ; } elseif ( class_exists ( '\Crypto\Cipher' ) ) { return self :: decryptWithCryptoExtension ( $ K , $ key_length , $ IV , $ C , $ A , $ T , $ tag_length ) ; } return self :: decryptWithPHP ( $ K , $ key_length , $ IV , $ C , $ A , $ T , $ tag_length ) ; } 
public static function decryptWithAppendedTag ( $ K , $ IV , $ Ciphertext = null , $ A = null , $ tag_length = 128 ) { $ tag_length_in_bits = $ tag_length / 8 ; $ C = mb_substr ( $ Ciphertext , 0 , - $ tag_length_in_bits , '8bit' ) ; $ T = mb_substr ( $ Ciphertext , - $ tag_length_in_bits , null , '8bit' ) ; return self :: decrypt ( $ K , $ IV , $ C , $ A , $ T ) ; } 
private static function decryptWithPHP71 ( $ K , $ key_length , $ IV , $ C , $ A , $ T ) { $ mode = 'aes-' . ( $ key_length ) . '-gcm' ; $ P = openssl_decrypt ( null === $ C ? '' : $ C , $ mode , $ K , OPENSSL_RAW_DATA , $ IV , $ T , null === $ A ? '' : $ A ) ; Assertion :: true ( false !== $ P , 'Unable to decrypt or to verify the tag.' ) ; return $ P ; } 
private static function decryptWithCryptoExtension ( $ K , $ key_length , $ IV , $ C , $ A , $ T , $ tag_length = 128 ) { $ cipher = \ Crypto \ Cipher :: aes ( \ Crypto \ Cipher :: MODE_GCM , $ key_length ) ; $ cipher -> setTag ( $ T ) ; $ cipher -> setAAD ( $ A ) ; $ cipher -> setTagLength ( $ tag_length / 8 ) ; return $ cipher -> decrypt ( $ C , $ K , $ IV ) ; } 
private static function common ( $ K , $ key_length , $ IV , $ A ) { $ H = openssl_encrypt ( str_repeat ( "\0" , 16 ) , 'aes-' . ( $ key_length ) . '-ecb' , $ K , OPENSSL_NO_PADDING | OPENSSL_RAW_DATA ) ; 
private static function getInc ( $ s_bits , $ x ) { $ lsb = self :: getLSB ( $ s_bits , $ x ) ; $ X = self :: toUInt32Bits ( $ lsb ) + 1 ; $ res = self :: getMSB ( self :: getLength ( $ x ) - $ s_bits , $ x ) . pack ( 'N' , $ X ) ; return $ res ; } 
private static function getProduct ( $ X , $ Y ) { $ R = pack ( 'H*' , 'E1' ) . str_pad ( '' , 15 , "\0" ) ; $ Z = str_pad ( '' , 16 , "\0" ) ; $ V = $ Y ; $ parts = str_split ( $ X , 4 ) ; $ x = sprintf ( '%032b%032b%032b%032b' , self :: toUInt32Bits ( $ parts [ 0 ] ) , self :: toUInt32Bits ( $ parts [ 1 ] ) , self :: toUInt32Bits ( $ parts [ 2 ] ) , self :: toUInt32Bits ( $ parts [ 3 ] ) ) ; $ lsb_mask = "\1" ; for ( $ i = 0 ; $ i < 128 ; $ i ++ ) { if ( $ x [ $ i ] ) { $ Z = self :: getBitXor ( $ Z , $ V ) ; } $ lsb_8 = mb_substr ( $ V , - 1 , null , '8bit' ) ; if ( ord ( $ lsb_8 & $ lsb_mask ) ) { $ V = self :: getBitXor ( self :: shiftStringToRight ( $ V ) , $ R ) ; } else { $ V = self :: shiftStringToRight ( $ V ) ; } } return $ Z ; } 
private static function shiftStringToRight ( $ input ) { $ width = 4 ; $ parts = array_map ( 'self::toUInt32Bits' , str_split ( $ input , $ width ) ) ; $ runs = count ( $ parts ) ; for ( $ i = $ runs - 1 ; $ i >= 0 ; $ i -- ) { if ( $ i ) { $ lsb1 = $ parts [ $ i - 1 ] & 0x00000001 ; if ( $ lsb1 ) { $ parts [ $ i ] = ( $ parts [ $ i ] >> 1 ) | 0x80000000 ; $ parts [ $ i ] = pack ( 'N' , $ parts [ $ i ] ) ; continue ; } } $ parts [ $ i ] = ( $ parts [ $ i ] >> 1 ) & 0x7FFFFFFF ; $ parts [ $ i ] = pack ( 'N' , $ parts [ $ i ] ) ; } $ res = implode ( '' , $ parts ) ; return $ res ; } 
private static function getHash ( $ H , $ X ) { $ Y = [ ] ; $ Y [ 0 ] = str_pad ( '' , 16 , "\0" ) ; $ num_blocks = ( int ) ( mb_strlen ( $ X , '8bit' ) / 16 ) ; for ( $ i = 1 ; $ i <= $ num_blocks ; $ i ++ ) { $ Y [ $ i ] = self :: getProduct ( self :: getBitXor ( $ Y [ $ i - 1 ] , mb_substr ( $ X , ( $ i - 1 ) * 16 , 16 , '8bit' ) ) , $ H ) ; } return $ Y [ $ num_blocks ] ; } 
private static function getGCTR ( $ K , $ key_length , $ ICB , $ X ) { if ( empty ( $ X ) ) { return '' ; } $ n = ( int ) ceil ( self :: getLength ( $ X ) / 128 ) ; $ CB = [ ] ; $ Y = [ ] ; $ CB [ 1 ] = $ ICB ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ CB [ $ i ] = self :: getInc ( 32 , $ CB [ $ i - 1 ] ) ; } $ mode = 'aes-' . ( $ key_length ) . '-ecb' ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ C = openssl_encrypt ( $ CB [ $ i ] , $ mode , $ K , OPENSSL_NO_PADDING | OPENSSL_RAW_DATA ) ; $ Y [ $ i ] = self :: getBitXor ( mb_substr ( $ X , ( $ i - 1 ) * 16 , 16 , '8bit' ) , $ C ) ; } $ Xn = mb_substr ( $ X , ( $ n - 1 ) * 16 , null , '8bit' ) ; $ C = openssl_encrypt ( $ CB [ $ n ] , $ mode , $ K , OPENSSL_NO_PADDING | OPENSSL_RAW_DATA ) ; $ Y [ $ n ] = self :: getBitXor ( $ Xn , self :: getMSB ( self :: getLength ( $ Xn ) , $ C ) ) ; return implode ( '' , $ Y ) ; } 
private static function getBitXor ( $ o1 , $ o2 ) { $ xorWidth = PHP_INT_SIZE ; $ o1 = str_split ( $ o1 , $ xorWidth ) ; $ o2 = str_split ( $ o2 , $ xorWidth ) ; $ res = '' ; $ runs = count ( $ o1 ) ; for ( $ i = 0 ; $ i < $ runs ; $ i ++ ) { $ res .= $ o1 [ $ i ] ^ $ o2 [ $ i ] ; } return $ res ; } 
public function send ( $ url , array $ params = array ( ) ) { $ out = array ( ) ; $ default = array ( 'get' => array ( ) , 'post' => array ( ) , 'headers' => array ( ) , 'cookies' => false , 'gzip' => true , ) ; $ params = array_merge ( $ default , $ params ) ; 
public function getParams ( array $ params ) { $ r = '' ; ksort ( $ params ) ; foreach ( $ params as $ key => $ value ) { $ r .= '&' . $ key . '=' . rawurlencode ( $ value ) ; } unset ( $ params , $ key , $ value ) ; return trim ( $ r , '&' ) ; } 
protected function processHeaders ( $ headers ) { $ out = array ( ) ; $ headers = explode ( "\r\n" , trim ( $ headers ) ) ; foreach ( $ headers as $ header ) { if ( strpos ( $ header , ':' ) !== false ) { $ tmp = explode ( ':' , $ header ) ; $ out [ reset ( $ tmp ) ] = end ( $ tmp ) ; } else { if ( ! isset ( $ out [ 'http-code' ] ) ) { $ out [ 'http-code' ] = $ header ; } } } unset ( $ headers , $ header , $ tmp ) ; return $ out ; } 
public function postMedia ( $ call , $ filename ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'POST' ; $ this -> withMedia = true ; $ mimeBoundary = sha1 ( $ call . microtime ( ) ) ; $ params = array ( 'post' => $ this -> buildMultipart ( $ mimeBoundary , $ filename ) , 'headers' => $ this -> buildUploadMediaHeader ( $ mimeBoundary ) , ) ; $ response = $ this -> curl -> send ( $ this -> getUrl ( ) , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> token_type ) || $ obj -> token_type != 'bearer' ) { $ this -> findExceptions ( $ response ) ; } $ this -> headers = $ response [ 'headers' ] ; $ this -> withMedia = null ; unset ( $ call , $ filename , $ mimeBoundary , $ params , $ obj ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; } 
protected function getOauthParameters ( ) { $ time = time ( ) ; return array ( 'oauth_consumer_key' => $ this -> getConsumerKey ( ) , 'oauth_nonce' => trim ( base64_encode ( $ time ) , '=' ) , 'oauth_signature_method' => 'HMAC-SHA1' , 'oauth_timestamp' => $ time , 'oauth_token' => $ this -> getAccessToken ( ) , 'oauth_version' => '1.0' ) ; } 
protected function getRequestString ( ) { $ params = array_merge ( $ this -> getParams , $ this -> postParams , $ this -> getOauthParameters ( ) ) ; $ params = $ this -> curl -> getParams ( $ params ) ; return rawurlencode ( $ params ) ; } 
protected function getSignatureBaseString ( ) { $ method = strtoupper ( $ this -> method ) ; $ url = rawurlencode ( $ this -> getUrl ( ) ) ; return $ method . '&' . $ url . '&' . $ this -> getRequestString ( ) ; } 
protected function getOauthString ( ) { $ oauth = array_merge ( $ this -> getOauthParameters ( ) , array ( 'oauth_signature' => $ this -> calculateSignature ( ) ) ) ; ksort ( $ oauth ) ; $ values = array ( ) ; foreach ( $ oauth as $ key => $ value ) { $ values [ ] = $ key . '="' . rawurlencode ( $ value ) . '"' ; } $ oauth = implode ( ', ' , $ values ) ; unset ( $ values , $ key , $ value ) ; return $ oauth ; } 
public function getHeaders ( $ key = null ) { if ( $ key === null ) { return $ this -> headers ; } if ( isset ( $ this -> headers [ $ key ] ) ) { return $ this -> headers [ $ key ] ; } return false ; } 
public function get ( $ call , array $ getParams = null ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'GET' ; if ( $ getParams !== null && is_array ( $ getParams ) ) { $ this -> getParams = $ getParams ; } $ response = $ this -> getResponse ( ) ; $ response [ 'body' ] = $ this -> findExceptions ( $ response ) ; $ this -> headers = $ response [ 'headers' ] ; unset ( $ call , $ getParams ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; } 
protected function validateCredentials ( $ credentials ) { $ credentials = array_filter ( $ credentials ) ; $ keys = array_keys ( $ credentials ) ; $ diff = array_diff ( $ this -> requiredCredentials , $ keys ) ; if ( ! empty ( $ diff ) ) { throw new MissingCredentialsException ( 'Missing Credentials: ' . implode ( $ diff , ', ' ) ) ; } unset ( $ credentials , $ keys , $ diff ) ; } 
protected function getUrl ( ) { $ domain = $ this -> urls [ 'domain' ] ; $ apiVersion = $ this -> urls [ 'api' ] ; $ jsonExt = '.json' ; if ( isset ( $ this -> withMedia ) && $ this -> withMedia === true ) { $ domain = $ this -> urls [ 'upload' ] ; } if ( $ this -> call === 'oauth/request_token' || $ this -> call === 'oauth/access_token' ) { $ apiVersion = '' ; $ jsonExt = '' ; } return $ domain . $ apiVersion . $ this -> call . $ jsonExt ; } 
protected function getResponse ( ) { $ url = $ this -> getUrl ( ) ; $ params = array ( 'get' => $ this -> getParams , 'post' => $ this -> postParams , 'headers' => $ this -> buildRequestHeader ( ) , ) ; return $ this -> curl -> send ( $ url , $ params ) ; } 
protected function findExceptions ( $ response ) { $ response = $ response [ 'body' ] ; $ data = json_decode ( $ response , true ) ; if ( isset ( $ response [ 0 ] ) && $ response [ 0 ] !== '{' && $ response [ 0 ] !== '[' && ! $ data ) { if ( strpos ( $ response , 'oauth_token=' ) !== false ) { parse_str ( $ response , $ data ) ; } if ( empty ( $ data ) || ! is_array ( $ data ) ) { throw new TwitterException ( $ response , 0 ) ; } return json_encode ( $ data ) ; } if ( ! empty ( $ data [ 'errors' ] ) || ! empty ( $ data [ 'error' ] ) ) { if ( ! empty ( $ data [ 'errors' ] ) ) { $ data = current ( $ data [ 'errors' ] ) ; } if ( empty ( $ data [ 'message' ] ) && ! empty ( $ data [ 'error' ] ) ) { $ data [ 'message' ] = $ data [ 'error' ] ; } if ( ! isset ( $ data [ 'code' ] ) || empty ( $ data [ 'code' ] ) ) { $ data [ 'code' ] = 0 ; } throw new TwitterException ( $ data [ 'message' ] , $ data [ 'code' ] ) ; } unset ( $ data ) ; return $ response ; } 
protected function buildMultipart ( $ mimeBoundary , $ filename ) { $ binary = $ this -> getBinaryFile ( $ filename ) ; $ details = pathinfo ( $ filename ) ; $ type = $ this -> supportedMimes ( $ details [ 'extension' ] ) ; $ data = '--' . $ mimeBoundary . static :: EOL ; $ data .= 'Content-Disposition: form-data; name="media"; filename="' . $ details [ 'basename' ] . '"' . static :: EOL ; $ data .= 'Content-Type: application/octet-stream' . static :: EOL . static :: EOL ; $ data .= $ binary . static :: EOL ; $ data .= '--' . $ mimeBoundary . '--' . static :: EOL . static :: EOL ; unset ( $ mimeBoundary , $ filename , $ binary , $ details , $ type ) ; return $ data ; } 
protected function getBinaryFile ( $ filename ) { if ( ! file_exists ( $ filename ) ) { throw new FileNotFoundException ; } if ( ! is_readable ( $ filename ) ) { throw new FileNotReadableException ; } ob_start ( ) ; readfile ( $ filename ) ; $ binary = ob_get_contents ( ) ; ob_end_clean ( ) ; unset ( $ filename ) ; return $ binary ; } 
protected function resetCallState ( ) { $ this -> call = null ; $ this -> method = null ; $ this -> withMedia = null ; $ this -> getParams = array ( ) ; $ this -> postParams = array ( ) ; $ this -> headers = null ; } 
public function getBearerToken ( ) { $ url = $ this -> getBearerTokenUrl ( ) ; $ params = array ( 'post' => array ( 'grant_type' => 'client_credentials' ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> token_type ) || $ obj -> token_type != 'bearer' ) { $ this -> findExceptions ( $ response ) ; } $ this -> bearerToken = rawurldecode ( $ obj -> access_token ) ; unset ( $ url , $ params , $ response , $ obj ) ; return $ this -> bearerToken ; } 
public function invalidateBearerToken ( ) { $ url = $ this -> getInvalidateBearerTokenUrl ( ) ; $ bearerToken = $ this -> bearerToken ; if ( $ bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } $ params = array ( 'post' => array ( 'access_token' => $ bearerToken ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> access_token ) || $ obj -> access_token != $ bearerToken ) { $ this -> findExceptions ( $ response ) ; } unset ( $ url , $ bearerToken , $ params , $ response , $ obj ) ; return true ; } 
protected function getBearerTokenCredentials ( ) { $ signingKey = rawurlencode ( $ this -> getConsumerKey ( ) ) . ':' . rawurlencode ( $ this -> getConsumerSecret ( ) ) ; return base64_encode ( $ signingKey ) ; } 
protected function buildRequestHeader ( ) { $ bearerToken = $ this -> bearerToken ; if ( $ this -> bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } return array ( 'Authorization: Bearer ' . rawurlencode ( $ bearerToken ) , 'Expect:' ) ; } 
function every ( $ interval , Job $ job ) { $ expression = new SimpleExpression ( $ interval ) ; $ this -> add ( $ expression , $ job ) ; return $ this ; } 
function cron ( $ expression , Job $ job ) { $ expression = new CronExpression ( $ expression ) ; $ this -> add ( $ expression , $ job ) ; return $ this ; } 
function run ( ) { $ now = new DateTime ( 'now' ) ; $ sleep = min ( array_map ( function ( $ entry ) use ( $ now ) { list ( $ expression , $ job ) = $ entry ; return $ expression -> getNextRunDate ( $ now ) -> getTimestamp ( ) ; } , $ this -> entries ) ) ; time_sleep_until ( $ sleep ) ; $ scheduled = 0 ; foreach ( $ this -> entries as $ entry ) { list ( $ expression , $ job ) = $ entry ; if ( $ expression -> isDue ( $ now ) ) { $ this -> queue -> push ( $ job ) ; $ scheduled += 1 ; } } $ this -> queue -> flush ( ) ; return $ scheduled ; } 
function pop ( ) { $ response = $ this -> redis -> blPop ( $ this -> key , 10 ) ; if ( $ response ) { list ( $ list , $ serializedJob ) = $ response ; $ job = unserialize ( $ serializedJob ) ; return $ job ; } } 
public function getLoginUrl ( $ scope = array ( ) , $ state = null ) { $ scope = $ this -> mergeScope ( $ scope ) ; $ state = is_string ( $ state ) ? "&state={$state}" : '' ; return self :: API_OAUTH_URL . '?client_id=' . $ this -> getApiKey ( ) . '&redirect_uri=' . urlencode ( $ this -> getApiCallback ( ) ) . '&scope=' . implode ( '+' , $ scope ) . '&response_type=code' . $ state ; } 
public function modifyRelationship ( $ action , $ user ) { if ( true === in_array ( $ action , $ this -> _actions ) && isset ( $ user ) ) { return $ this -> _makeCall ( 'users/' . $ user . '/relationship' , array ( 'action' => $ action ) , 'POST' ) ; } throw new InvalidParameterException ( 'Error: modifyRelationship() - This method requires an action command and the target user id.' ) ; } 
public function searchMedia ( $ lat , $ lng , $ distance = 1000 , $ minTimestamp = NULL , $ maxTimestamp = NULL ) { return $ this -> _makeCall ( 'media/search' , array ( 'lat' => $ lat , 'lng' => $ lng , 'distance' => $ distance , 'min_timestamp' => $ minTimestamp , 'max_timestamp' => $ maxTimestamp ) ) ; } 
public function pagination ( $ obj , $ limit = 20 ) { if ( true === is_object ( $ obj ) && ! is_null ( $ obj -> pagination ) ) { if ( ! isset ( $ obj -> pagination -> next_url ) ) { return ; } $ apiCall = explode ( '?' , $ obj -> pagination -> next_url ) ; if ( count ( $ apiCall ) < 2 ) { return ; } $ function = str_replace ( self :: API_URL , '' , $ apiCall [ 0 ] ) ; if ( isset ( $ obj -> pagination -> next_max_id ) ) { return $ this -> _makeCall ( $ function , array ( 'max_id' => $ obj -> pagination -> next_max_id , 'count' => $ limit ) ) ; } else { return $ this -> _makeCall ( $ function , array ( 'cursor' => $ obj -> pagination -> next_cursor , 'count' => $ limit ) ) ; } } else { throw new PaginationException ( "Error: pagination() | This method doesn't support pagination." ) ; } } 
protected function _makeCall ( $ function , $ params = null , $ method = 'GET' ) { if ( isset ( $ params [ 'count' ] ) && $ params [ 'count' ] < 1 ) { throw new InvalidParameterException ( 'InstagramClient: you are trying to query 0 records!' ) ; } 
public function setAccessToken ( $ data ) { ( true === is_object ( $ data ) ) ? $ token = $ data -> access_token : $ token = $ data ; $ this -> _accesstoken = $ token ; } 
private function mergeScope ( array $ scope ) { if ( empty ( $ scope ) ) return $ this -> _scope ; $ scope = array_merge ( $ scope , $ this -> _defaulScope ) ; $ scope = array_unique ( $ scope ) ; $ intersectingScope = array_intersect ( $ scope , $ this -> _availableScope ) ; if ( count ( $ intersectingScope ) !== count ( $ scope ) ) { throw new InvalidParameterException ( 'Error: mergeScope() - Invalid permission scope parameter used.' ) ; } return $ intersectingScope ; } 
public function register ( ) { $ this -> app -> bind ( 'andreyco.instagram' , function ( $ app ) { $ client = new \ Andreyco \ Instagram \ Client ( [ 'apiKey' => $ app [ 'config' ] -> get ( 'instagram.clientId' ) , 'apiSecret' => $ app [ 'config' ] -> get ( 'instagram.clientSecret' ) , 'apiCallback' => $ app [ 'config' ] -> get ( 'instagram.redirectUri' ) , 'scope' => $ app [ 'config' ] -> get ( 'instagram.scope' ) , ] ) ; if ( $ app [ 'config' ] -> get ( 'instagram.enforceSignedRequests' ) === true ) { $ client -> setEnforceSignedRequests ( true ) ; } return $ client ; } ) ; } 
public function run ( $ command ) { $ process = new Process ( $ command , null , null , null , ini_get ( 'max_execution_time' ) ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> console -> warn ( trim ( $ buffer ) ) ; } else { $ this -> console -> info ( trim ( $ buffer ) ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } return true ; } 
public function search ( ) { $ this -> console -> info ( 'Searching directory for facades(aliases).' ) ; $ facades = $ this -> getFacades ( ) ; if ( ! $ facades -> count ( ) ) { $ this -> console -> warn ( 'No facades file found. Nothing to install.' ) ; return [ ] ; } $ this -> console -> line ( " Found {$facades->count()} facade" . ( $ facades -> count ( ) > 1 ? 's' : '' ) . '.' ) ; $ facades -> each ( function ( $ facade , $ index ) { $ currentCount = $ index + 1 ; $ this -> console -> line ( " $currentCount. $facade" ) ; } ) ; if ( ! $ this -> console -> confirm ( 'Register facades?' , true ) ) { return [ ] ; } $ this -> registered = true ; return $ this -> getFacades ( ) -> toArray ( ) ; } 
public function make ( ) { $ content = $ this -> getManagerStubContent ( ) ; $ content = str_replace ( '@providers' , $ this -> stringify ( 'providers' ) , $ content ) ; $ content = str_replace ( '@aliases' , $ this -> stringify ( 'aliases' ) , $ content ) ; $ this -> filesystem -> put ( $ this -> getManagerFilePath ( ) , $ content ) ; return true ; } 
protected function stringify ( $ name ) { $ classes = array_unique ( array_merge ( $ this -> suffixClass ( $ this -> getFromConfig ( $ name ) ) , $ this -> suffixClass ( $ this -> $ name ) ) ) ; $ newLine2Tabs = PHP_EOL . ' ' ; if ( $ name == 'providers' ) { return "'$name' => [$newLine2Tabs" . implode ( ',' . $ newLine2Tabs , $ classes ) . PHP_EOL . ' ],' . PHP_EOL ; } $ template = "'$name' => [$newLine2Tabs" ; foreach ( $ classes as $ fullClassName ) { $ template .= "'{$this->getClassName($fullClassName)}' => $fullClassName,$newLine2Tabs" ; } $ template .= PHP_EOL . ' ],' . PHP_EOL ; return $ template ; } 
public function handle ( ) { $ packageInfo = $ this -> tokenizePackageInfo ( ) ; $ packages = $ this -> getPackages ( ) ; $ total = $ packages -> count ( ) ; if ( ! $ total ) { $ this -> warn ( ' No package found. Make sure you spell it correct as specified on github or packagist.' ) ; } if ( $ packages -> first ( ) [ 'name' ] !== $ packageInfo [ 'name' ] ) { $ this -> warn ( $ total . ' package' . ( $ total > 1 ? 's' : '' ) . ' found by given name.' ) ; return $ this -> call ( 'add' , [ 'package' => $ this -> prettify ( $ packages ) ] ) ; } $ this -> downloadPackage ( ) -> runConfiguration ( ) ; } 
public function tokenizePackageInfo ( ) { $ info = explode ( ':' , $ this -> argument ( 'package' ) ) ; return [ 'name' => $ info [ 0 ] , 'version' => ( count ( $ info ) > 1 ) ? last ( $ info ) : null , ] ; } 
public function prettify ( Collection $ packages ) { $ summary = [ ] ; foreach ( $ packages as $ key => $ package ) { $ summary [ ] = [ 'id' => $ key + 1 , 'name' => $ this -> prettifyPackageInfo ( $ package ) , ] ; } return $ packages [ $ this -> askPackageKey ( $ summary ) ] [ 'name' ] ; } 
public function askPackageKey ( $ summary , $ message = 'Please provide an id' ) { $ this -> table ( [ 'id' , 'name' ] , $ summary ) ; $ selected = $ this -> ask ( $ message ) ; $ key = collect ( $ summary ) -> pluck ( 'id' ) -> search ( $ selected ) ; if ( $ key === false ) { $ this -> warn ( 'Invalid package name or id given.' ) ; return $ this -> askPackageKey ( $ summary , 'Please provide a valid id' ) ; } return $ key ; } 
private function prettifyPackageInfo ( $ package ) { $ newLine2Tab = PHP_EOL . ' ' ; $ downloads = number_format ( $ package [ 'downloads' ] ) ; $ stars = number_format ( $ package [ 'favers' ] ) ; $ reputation = " [<fg=green;options=bold>⇩ $downloads</>". " <fg=magenta;options=bold>★ $stars</>]"; $ holdSpace = strlen ( $ package [ 'name' ] . $ downloads . $ stars ) ; $ insertSpace = str_repeat ( ' ' , 65 - $ holdSpace ) ; return "<fg=yellow>{$package['name']}</>" . $ insertSpace . $ reputation . PHP_EOL . wordwrap ( $ package [ 'description' ] ) . PHP_EOL . $ package [ 'repository' ] . $ newLine2Tab ; } 
public function run ( ) { if ( $ this -> search ( ) ) { $ this -> registered = true ; return $ this -> console -> call ( 'migrate' ) ; } return false ; } 
public function search ( ) { $ this -> console -> info ( 'Searching directory for Migrations.' ) ; return $ this -> hasMigrationFile ( ) ? $ this -> console -> confirm ( 'Run migrations?' , true ) : false ; } 
public function hasMigrationFile ( ) { $ this -> count = $ this -> fileHas ( '/class [A-Z]\w+ extends Migration/i' ) -> getClasses ( ) -> count ( ) ; return $ this -> hasMigrationFile = $ this -> count > 0 ; } 
public function build ( ) { $ providers = $ this -> getProviders ( ) -> search ( ) ; $ facades = $ this -> getFacades ( ) -> search ( ) ; if ( ! ConfigFile :: instance ( $ providers , $ facades ) -> make ( ) ) { throw new ErrorException ( 'Unable to register providers and facades. Please report this incident at Qafeen/Manager' ) ; } $ this -> getResources ( ) -> publish ( $ providers [ 0 ] ) ; return $ this ; } 
public function getProviders ( ) { return $ this -> providers ? : $ this -> providers = new ServiceProvider ( clone $ this -> getFiles ( ) , $ this -> console ) ; } 
public function getFacades ( ) { return $ this -> facades ? : $ this -> facades = new Facade ( clone $ this -> getFiles ( ) , $ this -> console ) ; } 
public function getMigration ( ) { return $ this -> migration ? : $ this -> migration = new Migration ( clone $ this -> getFiles ( ) , $ this -> console ) ; } 
public function getFiles ( ) { return $ this -> files ? : $ this -> files = Finder :: create ( ) -> in ( realpath ( $ this -> directory ) ) ; } 
public function hasManagerFile ( ) { if ( app ( 'filesystem' ) -> exists ( $ this -> directory . 'manager.yml' ) ) { return true ; } $ this -> console -> warn ( "No manager.yml file found in {$this->name} package." ) ; return false ; } 
protected function notifyUser ( ) { $ this -> console -> line ( '' ) ; $ this -> console -> line ( "{$this->isDone($this->getProviders()->isRegistered())} " . "{$this->getProviders()->count()} service provider registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getFacades()->isRegistered())} " . "{$this->getFacades()->count()} facade registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getMigration()->isRegistered())} " . "{$this->getMigration()->count()} migration file ran." ) ; $ this -> console -> line ( "{$this->isDone($this->getResources()->isRegistered())} " . '- ' . $ this -> console -> tokenizePackageInfo ( ) [ 'name' ] . ' file publish.' ) ; return true ; } 
public function getResources ( ) { return $ this -> resources ? : $ this -> resources = Resource :: instance ( clone $ this -> getFiles ( ) , $ this -> console ) ; } 
public static function instance ( ) { switch ( func_num_args ( ) ) { case func_num_args ( ) == 0 : return new static ( ) ; case func_num_args ( ) == 1 : return new static ( func_get_arg ( 0 ) ) ; case func_num_args ( ) == 2 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) ) ; case func_num_args ( ) == 3 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) ) ; case func_num_args ( ) == 4 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) ) ; case func_num_args ( ) == 5 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) , func_get_arg ( 4 ) ) ; default : throw new Exception ( 'Unable to instantiate class with given arguments' ) ; } } 
public function fileHas ( $ contains ) { $ this -> files = ( new ClassIterator ( $ this -> finder -> contains ( $ contains ) ) ) -> getClassMap ( ) ; $ this -> count = count ( $ this -> files ) ; return $ this ; } 
public function getFile ( $ class ) { if ( is_null ( $ this -> count ) ) { return $ this -> fileHas ( $ class ) -> getFile ( $ class ) ; } if ( isset ( $ this -> files [ $ class ] ) ) { return $ this -> files [ $ class ] ; } throw new FileException ( "File does not exists with given `{$class}` class." ) ; } 
public function search ( ) { $ this -> console -> info ( 'Searching directory for service providers.' ) ; $ sps = $ this -> getProviders ( ) ; if ( ! $ sps -> count ( ) ) { $ this -> console -> warn ( 'No service provider file found. Nothing to install.' ) ; return [ ] ; } $ this -> console -> line ( " Found {$sps->count()} Service provider" . ( $ sps -> count ( ) > 1 ? 's' : '' ) . '.' ) ; $ sps -> each ( function ( $ sp , $ index ) { $ currentCount = $ index + 1 ; $ this -> console -> line ( " $currentCount. $sp" ) ; } ) ; if ( ! $ this -> console -> confirm ( 'Register service providers?' , true ) ) { return [ ] ; } $ this -> registered = true ; return $ this -> getProviders ( ) -> toArray ( ) ; } 
public function search ( ) { $ url = self :: PACKAGIST_URL . 'search.json?q=' . $ this -> getPackageName ( ) ; $ response = $ this -> client -> get ( $ url ) -> getBody ( ) -> getContents ( ) ; $ this -> rawPackages = collect ( json_decode ( $ response , true ) ) ; return collect ( $ this -> rawPackages -> get ( 'results' ) ) ; } 
public function publish ( $ provider ) { $ class = last ( explode ( '\\' , $ provider ) ) ; $ this -> console -> info ( "Searching {$provider} to publish vendor file." ) ; if ( ! $ this -> finder -> contains ( $ class ) -> contains ( '/\$this->publishes/i' ) -> count ( ) ) { $ this -> console -> warn ( 'Nothing to publish.' ) ; return true ; } $ tag = $ this -> console -> ask ( "If the \"{$this->console->tokenizePackageInfo()['name']}\" has specify vendor publish tag in installation guide then please add it here or press enter to skip adding tag." , false ) ; $ this -> console -> call ( 'vendor:publish' , [ '--provider' => $ provider , '--tag' => $ tag , ] ) ; return $ this -> registered = true ; } 
public function boot ( Factory $ validator ) { $ passwordStrength = app ( 'passwordStrength' ) ; $ translator = app ( 'passwordStrength.translationProvider' ) -> get ( $ validator ) ; foreach ( [ 'letters' , 'numbers' , 'caseDiff' , 'symbols' ] as $ rule ) { $ snakeCasedRule = snake_case ( $ rule ) ; $ validator -> extend ( $ rule , function ( $ _ , $ value , $ __ ) use ( $ passwordStrength , $ rule ) { $ capitalizedRule = ucfirst ( $ rule ) ; return call_user_func ( [ $ passwordStrength , "validate{$capitalizedRule}" ] , $ value ) ; } , $ translator -> get ( "password-strength::validation.{$snakeCasedRule}" ) ) ; } } 
public function onPreSerialize ( PreSerializeEvent $ event ) : void { $ object = $ event -> getObject ( ) ; if ( $ object instanceof Proxy && ! $ object -> __isInitialized ( ) ) { $ object -> __load ( ) ; } $ objectUid = \ spl_object_hash ( $ object ) ; if ( \ array_key_exists ( $ objectUid , $ this -> serializedObjects ) ) { return ; } $ classAnnotation = $ this -> annotationReader -> getClassAnnotation ( new \ ReflectionClass ( ClassUtils :: getClass ( $ object ) ) , VichSerializableClass :: class ) ; if ( $ classAnnotation instanceof VichSerializableClass ) { $ reflectionClass = ClassUtils :: newReflectionClass ( \ get_class ( $ object ) ) ; $ this -> logger -> debug ( \ sprintf ( 'Found @VichSerializableClass annotation for the class "%s"' , $ reflectionClass -> getName ( ) ) ) ; foreach ( $ reflectionClass -> getProperties ( ) as $ property ) { $ vichSerializableAnnotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , VichSerializableField :: class ) ; if ( $ vichSerializableAnnotation instanceof VichSerializableField ) { $ vichUploadableFileAnnotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , UploadableField :: class ) ; if ( $ vichUploadableFileAnnotation instanceof UploadableField ) { throw new IncompatibleUploadableAndSerializableFieldAnnotationException ( \ sprintf ( 'The field "%s" in the class "%s" cannot have @UploadableField and @VichSerializableField annotations at the same moment.' , $ property -> getName ( ) , $ reflectionClass -> getName ( ) ) ) ; } $ this -> logger -> debug ( \ sprintf ( 'Found @VichSerializableField annotation for the field "%s" in the class "%s"' , $ property -> getName ( ) , $ reflectionClass -> getName ( ) ) ) ; $ uri = null ; $ property -> setAccessible ( true ) ; if ( $ property -> getValue ( $ event -> getObject ( ) ) ) { $ uri = $ this -> storage -> resolveUri ( $ object , $ vichSerializableAnnotation -> getField ( ) ) ; if ( $ vichSerializableAnnotation -> isIncludeHost ( ) && false === \ filter_var ( $ uri , FILTER_VALIDATE_URL ) ) { $ uri = $ this -> getHostUrl ( ) . $ uri ; } } $ this -> serializedObjects [ $ objectUid ] [ $ property -> getName ( ) ] = $ property -> getValue ( $ event -> getObject ( ) ) ; $ property -> setValue ( $ object , $ uri ) ; } } } } 
private function getHostUrl ( ) : string { $ scheme = $ this -> requestContext -> getScheme ( ) ; $ url = $ scheme . '://' . $ this -> requestContext -> getHost ( ) ; $ httpPort = $ this -> requestContext -> getHttpPort ( ) ; if ( 'http' === $ scheme && $ httpPort && 80 !== $ httpPort ) { return $ url . ':' . $ httpPort ; } $ httpsPort = $ this -> requestContext -> getHttpsPort ( ) ; if ( 'https' === $ scheme && $ httpsPort && 443 !== $ httpsPort ) { return $ url . ':' . $ httpsPort ; } return $ url ; } 
public function dump ( $ abs ) { $ title = \ trim ( $ abs [ 'phpDoc' ] [ 'summary' ] . "\n\n" . $ abs [ 'phpDoc' ] [ 'description' ] ) ; $ strClassName = $ this -> debug -> output -> html -> markupClassname ( $ abs [ 'className' ] , 'span' , array ( 'title' => $ title ? : null , ) ) ; if ( $ abs [ 'isRecursion' ] ) { return $ strClassName . ' <span class="t_recursion">*RECURSION*</span>' ; } if ( $ abs [ 'isExcluded' ] ) { return $ this -> dumpToString ( $ abs ) . $ strClassName . "\n" . '<span class="excluded">(not inspected)</span>' ; } $ html = $ this -> dumpToString ( $ abs ) . $ strClassName . "\n" . '<dl class="object-inner">' . "\n" . '<dt>extends</dt>' . "\n" . '<dd class="extends">' . \ implode ( '</dd>' . "\n" . '<dd class="extends">' , $ abs [ 'extends' ] ) . '</dd>' . "\n" . '<dt>implements</dt>' . "\n" . '<dd class="interface">' . \ implode ( '</dd>' . "\n" . '<dd class="interface">' , $ abs [ 'implements' ] ) . '</dd>' . "\n" . $ this -> dumpConstants ( $ abs [ 'constants' ] ) . $ this -> dumpProperties ( $ abs ) . ( $ abs [ 'collectMethods' ] && $ this -> debug -> output -> getCfg ( 'outputMethods' ) ? $ this -> dumpMethods ( $ abs [ 'methods' ] ) : '' ) . $ this -> dumpPhpDoc ( $ abs [ 'phpDoc' ] ) . '</dl>' . "\n" ; 
protected function dumpToString ( $ abs ) { $ val = '' ; if ( $ abs [ 'stringified' ] ) { $ val = $ abs [ 'stringified' ] ; } elseif ( isset ( $ abs [ 'methods' ] [ '__toString' ] [ 'returnValue' ] ) ) { $ val = $ abs [ 'methods' ] [ '__toString' ] [ 'returnValue' ] ; } if ( ! $ val ) { return '' ; } $ valAppend = '' ; $ len = \ strlen ( $ val ) ; if ( $ len > 100 ) { $ val = \ substr ( $ val , 0 , 100 ) ; $ valAppend = '&hellip; <i>(' . ( $ len - 100 ) . ' more chars)</i>' ; } $ toStringDump = $ this -> debug -> output -> html -> dump ( $ val ) ; $ parsed = $ this -> debug -> utilities -> parseTag ( $ toStringDump ) ; $ classArray = \ explode ( ' ' , $ parsed [ 'attribs' ] [ 'class' ] ) ; $ classArray [ ] = 't_stringified' ; if ( $ len > 100 ) { $ classArray [ ] = 't_string_trunc' ; 
protected function dumpConstants ( $ constants ) { $ str = '' ; if ( $ constants && $ this -> debug -> output -> getCfg ( 'outputConstants' ) ) { $ str = '<dt class="constants">constants</dt>' . "\n" ; foreach ( $ constants as $ k => $ value ) { $ str .= '<dd class="constant">' . '<span class="constant-name">' . $ k . '</span>' . ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ value ) . '</dd>' . "\n" ; } } return $ str ; } 
protected function dumpMethods ( $ methods ) { $ label = \ count ( $ methods ) ? 'methods' : 'no methods' ; $ str = '<dt class="methods">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__call' , '__callStatic' ) , \ array_keys ( $ methods ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ methods as $ methodName => $ info ) { if ( ! isset ( $ info [ 'phpDoc' ] [ 'return' ] ) ) { $ info [ 'phpDoc' ] [ 'return' ] = array ( 'desc' => null , 'type' => null , ) ; } $ classes = \ array_keys ( \ array_filter ( array ( 'method' => true , 'deprecated' => $ info [ 'isDeprecated' ] , ) ) ) ; $ modifiers = \ array_keys ( \ array_filter ( array ( 'final' => $ info [ 'isFinal' ] , $ info [ 'visibility' ] => true , 'static' => $ info [ 'isStatic' ] , ) ) ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'dd' , array ( 'class' => \ array_merge ( $ classes , $ modifiers ) , 'data-implements' => $ info [ 'implements' ] , ) , \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 't_type' , 'title' => $ info [ 'phpDoc' ] [ 'return' ] [ 'desc' ] , ) , $ info [ 'phpDoc' ] [ 'return' ] [ 'type' ] ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 'method-name' , 'title' => \ trim ( $ info [ 'phpDoc' ] [ 'summary' ] . ( $ this -> debug -> output -> getCfg ( 'outputMethodDescription' ) ? "\n\n" . $ info [ 'phpDoc' ] [ 'description' ] : '' ) ) , ) , $ methodName ) . '<span class="t_punct">(</span>' . $ this -> dumpMethodParams ( $ info [ 'params' ] ) . '<span class="t_punct">)</span>' . ( $ methodName == '__toString' ? '<br />' . $ this -> debug -> output -> html -> dump ( $ info [ 'returnValue' ] ) : '' ) ) . "\n" ; } $ str = \ str_replace ( ' data-implements="null"' , '' , $ str ) ; $ str = \ str_replace ( ' <span class="t_type"></span>' , '' , $ str ) ; return $ str ; } 
protected function dumpMethodParams ( $ params ) { $ paramStr = '' ; foreach ( $ params as $ info ) { $ paramStr .= '<span class="parameter">' ; if ( ! empty ( $ info [ 'type' ] ) ) { $ paramStr .= '<span class="t_type">' . $ info [ 'type' ] . '</span> ' ; } $ paramStr .= '<span class="t_parameter-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . \ htmlspecialchars ( $ info [ 'name' ] ) . '</span>' ; if ( $ info [ 'defaultValue' ] !== $ this -> debug -> abstracter -> UNDEFINED ) { $ defaultValue = $ info [ 'defaultValue' ] ; $ paramStr .= ' <span class="t_operator">=</span> ' ; if ( $ info [ 'constantName' ] ) { $ title = '' ; $ type = $ this -> debug -> abstracter -> getType ( $ defaultValue ) ; if ( ! \ in_array ( $ type , array ( 'array' , 'resource' ) ) ) { $ title = $ this -> debug -> output -> text -> dump ( $ defaultValue ) ; $ title = \ htmlspecialchars ( 'value: ' . $ title ) ; } $ paramStr .= '<span class="t_parameter-default t_const"' . ' title="' . $ title . '"' . '>' . $ info [ 'constantName' ] . '</span>' ; } else { if ( \ is_string ( $ defaultValue ) ) { $ defaultValue = \ str_replace ( "\n" , ' ' , $ defaultValue ) ; } $ parsed = $ this -> debug -> utilities -> parseTag ( $ this -> debug -> output -> html -> dump ( $ defaultValue ) ) ; $ class = \ trim ( 't_parameter-default ' . $ parsed [ 'attribs' ] [ 'class' ] ) ; $ paramStr .= '<span class="' . $ class . '">' . $ parsed [ 'innerhtml' ] . '</span>' ; } } $ paramStr .= '</span>, ' ; 
protected function dumpPhpDoc ( $ phpDoc ) { $ str = '' ; foreach ( $ phpDoc as $ k => $ values ) { if ( ! \ is_array ( $ values ) ) { continue ; } foreach ( $ values as $ value ) { if ( $ k == 'link' ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } elseif ( $ k == 'see' && $ value [ 'uri' ] ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } else { $ value = \ htmlspecialchars ( \ implode ( ' ' , $ value ) ) ; } $ str .= '<dd class="phpdoc phpdoc-' . $ k . '">' . '<span class="phpdoc-tag">' . $ k . '</span>' . '<span class="t_operator">:</span> ' . $ value . '</dd>' . "\n" ; } } if ( $ str ) { $ str = '<dt class="phpDoc">phpDoc</dt>' . "\n" . $ str ; } return $ str ; } 
protected function dumpProperties ( $ abs ) { $ label = \ count ( $ abs [ 'properties' ] ) ? 'properties' : 'no properties' ; if ( $ abs [ 'viaDebugInfo' ] ) { $ label .= ' <span class="text-muted">(via __debugInfo)</span>' ; } $ str = '<dt class="properties">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__get' , '__set' ) , \ array_keys ( $ abs [ 'methods' ] ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ abs [ 'properties' ] as $ k => $ info ) { $ vis = ( array ) $ info [ 'visibility' ] ; $ isPrivateAncestor = \ in_array ( 'private' , $ vis ) && $ info [ 'inheritedFrom' ] ; $ classes = \ array_keys ( \ array_filter ( array ( 'debuginfo-value' => $ info [ 'valueFrom' ] == 'debugInfo' , 'excluded' => $ info [ 'isExcluded' ] , 'forceShow' => $ info [ 'forceShow' ] , 'debug-value' => $ info [ 'valueFrom' ] == 'debug' , 'private-ancestor' => $ isPrivateAncestor , 'property' => true , \ implode ( ' ' , $ vis ) => $ info [ 'visibility' ] !== 'debug' , ) ) ) ; $ modifiers = $ vis ; if ( $ info [ 'isStatic' ] ) { $ modifiers [ ] = 'static' ; } $ str .= '<dd class="' . \ implode ( ' ' , $ classes ) . '">' . \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ( $ isPrivateAncestor ? ' (<i>' . $ info [ 'inheritedFrom' ] . '</i>)' : '' ) . ( $ info [ 'type' ] ? ' <span class="t_type">' . $ info [ 'type' ] . '</span>' : '' ) . ' <span class="property-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . $ k . '</span>' . ( $ info [ 'value' ] !== $ this -> debug -> abstracter -> UNDEFINED ? ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ info [ 'value' ] ) : '' ) . '</dd>' . "\n" ; } return $ str ; } 
private function magicMethodInfo ( $ methods ) { if ( ! $ methods ) { return '' ; } foreach ( $ methods as $ i => $ method ) { $ methods [ $ i ] = '<code>' . $ method . '</code>' ; } $ methods = $ i == 0 ? 'a ' . $ methods [ 0 ] . ' method' : \ implode ( ' and ' , $ methods ) . ' methods' ; return '<dd class="magic info">This object has ' . $ methods . '</dd>' . "\n" ; } 
public function getAbstraction ( $ obj , $ method = null , & $ hist = array ( ) ) { if ( ! \ is_object ( $ obj ) ) { return $ obj ; } $ reflector = new \ ReflectionObject ( $ obj ) ; $ className = $ reflector -> getName ( ) ; $ isTableTop = $ method === 'table' && \ count ( $ hist ) < 2 ; debug.objAbstractStart subscriber may set isExcluded set collectPropertyValues (boolean) set collectMethods (boolean) set propertyOverrideValues set stringified set traverseValues */ $ abs = $ this -> abstracter -> debug -> internal -> publishBubbleEvent ( 'debug.objAbstractStart' , $ abs ) ; if ( \ array_filter ( array ( $ abs [ 'isExcluded' ] , $ abs -> isPropagationStopped ( ) ) ) ) { return \ array_diff_key ( $ abs -> getValues ( ) , $ keysTemp ) ; } $ this -> getAbstractionDetails ( $ abs ) ; $ return = $ this -> abstracter -> debug -> internal -> publishBubbleEvent ( 'debug.objAbstractEnd' , $ abs ) -> getValues ( ) ; $ this -> sort ( $ return [ 'properties' ] ) ; $ this -> sort ( $ return [ 'methods' ] ) ; return \ array_diff_key ( $ return , $ keysTemp ) ; } 
private function getAbstractionDetails ( Event $ abs ) { $ reflector = $ abs [ 'reflector' ] ; $ abs [ 'phpDoc' ] = $ this -> phpDoc -> getParsed ( $ reflector ) ; $ traversed = false ; if ( $ abs [ 'debugMethod' ] === 'table' && \ count ( $ abs [ 'hist' ] ) < 2 ) { 
public function onStart ( Event $ event ) { $ obj = $ event -> getSubject ( ) ; if ( $ obj instanceof \ DateTime || $ obj instanceof \ DateTimeImmutable ) { $ event [ 'stringified' ] = $ obj -> format ( \ DateTime :: ISO8601 ) ; } elseif ( $ obj instanceof \ mysqli && ( $ obj -> connect_errno || ! $ obj -> stat ) ) { 
public function onEnd ( Event $ event ) { $ obj = $ event -> getSubject ( ) ; if ( $ obj instanceof \ DOMNodeList ) { 
public function addConstants ( Event $ abs ) { if ( ! $ this -> abstracter -> getCfg ( 'collectConstants' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; $ constants = $ reflector -> getConstants ( ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ constants = \ array_merge ( $ reflector -> getConstants ( ) , $ constants ) ; } if ( $ this -> abstracter -> getCfg ( 'objectSort' ) == 'name' ) { \ ksort ( $ constants ) ; } $ abs [ 'constants' ] = $ constants ; } 
private function addMethods ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( ! $ abs [ 'collectMethods' ] ) { $ this -> addMethodsMin ( $ abs ) ; return ; } if ( $ this -> abstracter -> getCfg ( 'cacheMethods' ) && isset ( static :: $ methodCache [ $ abs [ 'className' ] ] ) ) { $ abs [ 'methods' ] = static :: $ methodCache [ $ abs [ 'className' ] ] ; } else { $ methodArray = array ( ) ; $ methods = $ abs [ 'reflector' ] -> getMethods ( ) ; $ interfaceMethods = array ( 'ArrayAccess' => array ( 'offsetExists' , 'offsetGet' , 'offsetSet' , 'offsetUnset' ) , 'Countable' => array ( 'count' ) , 'Iterator' => array ( 'current' , 'key' , 'next' , 'rewind' , 'void' ) , 'IteratorAggregate' => array ( 'getIterator' ) , getMethods() returns parent's private methods (must be a reason... but we'll skip it) */ continue ; } foreach ( $ interfacesHide as $ interface ) { if ( \ in_array ( $ methodName , $ interfaceMethods [ $ interface ] ) ) { 
private function addMethodsMin ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( \ method_exists ( $ obj , '__toString' ) ) { $ abs [ 'methods' ] [ '__toString' ] = array ( 'returnValue' => \ call_user_func ( array ( $ obj , '__toString' ) ) , 'visibility' => 'public' , ) ; } if ( \ method_exists ( $ obj , '__get' ) ) { $ abs [ 'methods' ] [ '__get' ] = array ( 'visibility' => 'public' ) ; } if ( \ method_exists ( $ obj , '__set' ) ) { $ abs [ 'methods' ] [ '__set' ] = array ( 'visibility' => 'public' ) ; } return ; } 
private function addMethodsPhpDoc ( Event $ abs ) { $ inheritedFrom = null ; if ( empty ( $ abs [ 'phpDoc' ] [ 'method' ] ) ) { 
private function addProperties ( Event $ abs ) { if ( $ abs [ 'debugMethod' ] === 'table' && $ abs [ 'traverseValues' ] ) { return ; } $ obj = $ abs -> getSubject ( ) ; $ reflectionObject = $ abs [ 'reflector' ] ; while ( $ reflectionObject ) { $ className = $ reflectionObject -> getName ( ) ; $ properties = $ reflectionObject -> getProperties ( ) ; $ isDebugObj = $ className == __NAMESPACE__ ; while ( $ properties ) { $ reflectionProperty = \ array_shift ( $ properties ) ; $ name = $ reflectionProperty -> getName ( ) ; if ( isset ( $ abs [ 'properties' ] [ $ name ] ) ) { 
private function addPropertiesDebug ( Event $ abs ) { if ( ! $ abs [ 'collectPropertyValues' ] ) { return ; } if ( ! $ abs [ 'viaDebugInfo' ] ) { 
private function addPropertiesPhpDoc ( Event $ abs ) { 
private function getParams ( \ ReflectionMethod $ reflectionMethod , $ phpDoc = array ( ) ) { $ paramArray = array ( ) ; $ params = $ reflectionMethod -> getParameters ( ) ; if ( empty ( $ phpDoc ) ) { $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; } foreach ( $ params as $ i => $ reflectionParameter ) { $ nameNoPrefix = $ reflectionParameter -> getName ( ) ; $ name = '$' . $ nameNoPrefix ; if ( \ method_exists ( $ reflectionParameter , 'isVariadic' ) && $ reflectionParameter -> isVariadic ( ) ) { $ name = '...' . $ name ; } if ( $ reflectionParameter -> isPassedByReference ( ) ) { $ name = '&' . $ name ; } $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( $ reflectionParameter -> isDefaultValueAvailable ( ) ) { $ defaultValue = $ reflectionParameter -> getDefaultValue ( ) ; if ( \ version_compare ( PHP_VERSION , '5.4.6' , '>=' ) && $ reflectionParameter -> isDefaultValueConstant ( ) ) { $ constantName = $ reflectionParameter -> getDefaultValueConstantName ( ) ; } } $ paramInfo = array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , 'desc' => null , 'isOptional' => $ reflectionParameter -> isOptional ( ) , 'name' => $ name , 'type' => $ this -> getParamTypeHint ( $ reflectionParameter ) , ) ; if ( isset ( $ phpDoc [ 'param' ] [ $ i ] ) ) { $ paramInfo [ 'desc' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'desc' ] ; if ( ! isset ( $ paramInfo [ 'type' ] ) ) { $ paramInfo [ 'type' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'type' ] ; } } $ paramArray [ $ nameNoPrefix ] = $ paramInfo ; } return $ paramArray ; } 
private function getParamTypeHint ( \ ReflectionParameter $ reflectionParameter ) { $ return = null ; if ( $ reflectionParameter -> isArray ( ) ) { $ return = 'array' ; } elseif ( \ preg_match ( '/\[\s\<\w+?>\s([\w\\\\]+)/s' , $ reflectionParameter -> __toString ( ) , $ matches ) ) { $ return = $ matches [ 1 ] ; } return $ return ; } 
private function getPropInfo ( Event $ abs , \ ReflectionProperty $ reflectionProperty ) { $ obj = $ abs -> getSubject ( ) ; $ reflectionProperty -> setAccessible ( true ) ; getDeclaringClass returns "LAST-declared/overriden" */ $ declaringClassName = $ reflectionProperty -> getDeclaringClass ( ) -> getName ( ) ; $ propInfo = \ array_merge ( static :: $ basePropInfo , array ( 'desc' => $ commentInfo [ 'desc' ] , 'inheritedFrom' => $ declaringClassName !== $ className ? $ declaringClassName : null , 'isStatic' => $ reflectionProperty -> isStatic ( ) , 'type' => $ commentInfo [ 'type' ] , ) ) ; if ( $ reflectionProperty -> isPrivate ( ) ) { $ propInfo [ 'visibility' ] = 'private' ; } elseif ( $ reflectionProperty -> isProtected ( ) ) { $ propInfo [ 'visibility' ] = 'protected' ; } if ( $ abs [ 'collectPropertyValues' ] ) { $ propName = $ reflectionProperty -> getName ( ) ; if ( \ array_key_exists ( $ propName , $ abs [ 'propertyOverrideValues' ] ) ) { $ propInfo [ 'value' ] = $ abs [ 'propertyOverrideValues' ] [ $ propName ] ; $ propInfo [ 'valueFrom' ] = 'debug' ; } else { $ propInfo [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } return $ propInfo ; } 
private function getPropCommentInfo ( \ ReflectionProperty $ reflectionProperty ) { $ name = $ reflectionProperty -> name ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionProperty ) ; $ info = array ( 'type' => null , 'desc' => $ phpDoc [ 'summary' ] ? $ phpDoc [ 'summary' ] : null , ) ; if ( isset ( $ phpDoc [ 'var' ] ) ) { if ( \ count ( $ phpDoc [ 'var' ] ) == 1 ) { $ var = $ phpDoc [ 'var' ] [ 0 ] ; } else { foreach ( $ phpDoc [ 'var' ] as $ var ) { if ( $ var [ 'name' ] == $ name ) { break ; } } } $ info [ 'type' ] = $ var [ 'type' ] ; if ( ! $ info [ 'desc' ] ) { $ info [ 'desc' ] = $ var [ 'desc' ] ; } elseif ( $ var [ 'desc' ] ) { $ info [ 'desc' ] = $ info [ 'desc' ] . ': ' . $ var [ 'desc' ] ; } } return $ info ; } 
private function getScopeClass ( & $ hist ) { $ className = null ; for ( $ i = \ count ( $ hist ) - 1 ; $ i >= 0 ; $ i -- ) { if ( \ is_object ( $ hist [ $ i ] ) ) { $ className = \ get_class ( $ hist [ $ i ] ) ; break ; } } if ( $ i < 0 ) { $ backtrace = \ version_compare ( PHP_VERSION , '5.4.0' , '>=' ) ? \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS ) : \ debug_backtrace ( false ) ; 
private function isObjExcluded ( $ obj ) { if ( \ in_array ( \ get_class ( $ obj ) , $ this -> abstracter -> getCfg ( 'objectsExclude' ) ) ) { return true ; } foreach ( $ this -> abstracter -> getCfg ( 'objectsExclude' ) as $ exclude ) { if ( \ is_subclass_of ( $ obj , $ exclude ) ) { return true ; } } return false ; } 
private function methodInfo ( $ obj , \ ReflectionMethod $ reflectionMethod ) { 
private function phpDocParam ( $ param , $ className ) { $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( \ array_key_exists ( 'defaultValue' , $ param ) ) { $ defaultValue = $ param [ 'defaultValue' ] ; if ( \ in_array ( $ defaultValue , array ( 'true' , 'false' , 'null' ) ) ) { $ defaultValue = \ json_decode ( $ defaultValue ) ; } elseif ( \ is_numeric ( $ defaultValue ) ) { 
private function propOverrides ( \ ReflectionProperty $ reflectionProperty , $ propInfo , $ className ) { if ( empty ( $ propInfo [ 'overrides' ] ) && empty ( $ propInfo [ 'inheritedFrom' ] ) && $ reflectionProperty -> getDeclaringClass ( ) -> getName ( ) == $ className ) { return $ className ; } return null ; } 
protected function sort ( & $ array ) { if ( ! $ array ) { return ; } $ sort = $ this -> abstracter -> getCfg ( 'objectSort' ) ; if ( $ sort == 'name' ) { 
public static function getConstants ( $ phpVer = null ) { $ phpVer = $ phpVer ? : PHP_VERSION ; $ phpVer = \ preg_match ( '/^\d+\.\d+$/' , $ phpVer ) ? $ phpVer . '.0' : $ phpVer ; $ constants = array ( 'E_ERROR' => 1 , 'E_WARNING' => 2 , 'E_PARSE' => 4 , 'E_NOTICE' => 8 , 'E_CORE_ERROR' => 16 , 'E_CORE_WARNING' => 32 , 'E_COMPILE_ERROR' => 64 , 'E_COMPILE_WARNING' => 128 , 'E_USER_ERROR' => 256 , 'E_USER_WARNING' => 512 , 'E_USER_NOTICE' => 1024 , 'E_STRICT' => \ version_compare ( $ phpVer , '5.0.0' , '>=' ) ? 2048 : null , 'E_RECOVERABLE_ERROR' => \ version_compare ( $ phpVer , '5.2.0' , '>=' ) ? 4096 : null , 'E_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 8192 : null , 'E_USER_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 16384 : null , 'E_ALL' => null , E_ALL value: >= 5.4: 32767 5.3: 30719 (doesn't include E_STRICT) 5.2: 6143 (doesn't include E_STRICT) < 5.2: 2047 (doesn't include E_STRICT) */ $ constants [ 'E_ALL' ] = \ array_sum ( $ constants ) ; if ( isset ( $ constants [ 'E_STRICT' ] ) && \ version_compare ( $ phpVer , '5.4.0' , '<' ) ) { // E_STRICT not included in E_ALL until 5.4 $ constants [ 'E_ALL' ] -= $ constants [ 'E_STRICT' ] ; } return $ constants ; } 
public static function toConstantString ( $ level = null , $ phpVer = null , $ explicitStrict = true ) { $ string = '' ; $ level = $ level === null ? \ error_reporting ( ) : $ level ; $ allConstants = self :: getConstants ( $ phpVer ) ; 
private static function filterConstantsByLevel ( $ constants , $ level ) { foreach ( $ constants as $ constantName => $ value ) { if ( ! self :: inBitmask ( $ value , $ level ) ) { unset ( $ constants [ $ constantName ] ) ; } } unset ( $ constants [ 'E_ALL' ] ) ; return $ constants ; } 
public static function colKeys ( $ rows ) { if ( ! \ is_array ( $ rows ) ) { return array ( ) ; } if ( Abstracter :: isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ rows = $ rows [ 'traverseValues' ] ; } $ lastKeys = array ( ) ; $ newKeys = array ( ) ; $ curKeys = array ( ) ; foreach ( $ rows as $ row ) { $ curKeys = self :: keys ( $ row ) ; if ( empty ( $ lastKeys ) ) { $ lastKeys = $ curKeys ; } elseif ( $ curKeys != $ lastKeys ) { $ newKeys = array ( ) ; $ count = \ count ( $ curKeys ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ curKey = $ curKeys [ $ i ] ; if ( $ lastKeys && $ curKey === $ lastKeys [ 0 ] ) { \ array_push ( $ newKeys , $ curKey ) ; \ array_shift ( $ lastKeys ) ; } elseif ( false !== $ position = \ array_search ( $ curKey , $ lastKeys , true ) ) { $ segment = \ array_splice ( $ lastKeys , 0 , $ position + 1 ) ; \ array_splice ( $ newKeys , \ count ( $ newKeys ) , 0 , $ segment ) ; } elseif ( ! \ in_array ( $ curKey , $ newKeys , true ) ) { \ array_push ( $ newKeys , $ curKey ) ; } } 
public static function keyValues ( $ row , $ keys , & $ objInfo ) { $ objInfo = array ( 'row' => false , 'cols' => array ( ) , ) ; $ rowIsAbstraction = Abstracter :: isAbstraction ( $ row ) ; if ( $ rowIsAbstraction ) { if ( $ row [ 'type' ] == 'object' ) { $ objInfo [ 'row' ] = array ( 'className' => $ row [ 'className' ] , 'phpDoc' => $ row [ 'phpDoc' ] , ) ; $ row = self :: objectValues ( $ row ) ; if ( ! \ is_array ( $ row ) ) { 
public function onLog ( Event $ event ) { $ args = $ event [ 'args' ] ; $ meta = \ array_merge ( array ( 'caption' => null , 'columns' => array ( ) , 'sortable' => true , 'totalCols' => array ( ) , ) , $ event [ 'meta' ] ) ; $ argCount = \ count ( $ args ) ; $ data = null ; for ( $ i = 0 ; $ i < $ argCount ; $ i ++ ) { if ( \ is_array ( $ args [ $ i ] ) ) { if ( $ data === null ) { $ data = $ args [ $ i ] ; } elseif ( ! $ meta [ 'columns' ] ) { $ meta [ 'columns' ] = $ args [ $ i ] ; } } elseif ( $ args [ $ i ] instanceof \ Traversable ) { if ( $ data === null ) { $ data = $ args [ $ i ] ; } } elseif ( \ is_string ( $ args [ $ i ] ) && ! $ meta [ 'caption' ] ) { $ meta [ 'caption' ] = $ args [ $ i ] ; } unset ( $ args [ $ i ] ) ; } $ event -> setValues ( array ( 'method' => $ event [ 'method' ] , 'args' => array ( $ data ) , 'meta' => $ meta , ) ) ; return $ event ; } 
private static function keys ( $ val ) { if ( Abstracter :: isAbstraction ( $ val ) ) { Reflection doesn't return properties in any given order so, we'll sort for consistency */ \ ksort ( $ val , SORT_NATURAL | SORT_FLAG_CASE ) ; } } else { 
private static function objectValues ( $ abs ) { if ( $ abs [ 'traverseValues' ] ) { 
public function onLog ( Event $ event ) { $ this -> channelName = $ this -> debug -> parentInstance ? $ event [ 'meta' ] [ 'channel' ] 
private function clearAlerts ( $ flags ) { $ clearAlerts = $ flags & Debug :: CLEAR_ALERTS ; if ( ! $ clearAlerts ) { return null ; } if ( $ this -> channelName ) { foreach ( $ this -> data [ 'alerts' ] as $ i => $ entry ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; if ( $ this -> channelTest ( $ channel ) ) { unset ( $ this -> data [ 'alerts' ] [ $ i ] ) ; } } $ this -> data [ 'alerts' ] = \ array_values ( $ this -> data [ 'alerts' ] ) ; } else { $ this -> data [ 'alerts' ] = array ( ) ; } return 'alerts' ; } 
private function clearErrors ( $ flags ) { $ clearErrors = $ flags & Debug :: CLEAR_LOG_ERRORS || $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( ! $ clearErrors ) { return ; } $ errorsNotCleared = array ( ) ; $ errorsNotCleared = $ this -> clearErrorsHelper ( $ this -> data [ 'log' ] , $ flags & Debug :: CLEAR_LOG_ERRORS ) ; foreach ( \ array_keys ( $ this -> data [ 'logSummary' ] ) as $ priority ) { $ errorsNotCleared = \ array_merge ( $ this -> clearErrorsHelper ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ flags & Debug :: CLEAR_SUMMARY_ERRORS ) ) ; } $ errorsNotCleared = \ array_unique ( $ errorsNotCleared ) ; $ errors = $ this -> debug -> errorHandler -> get ( 'errors' ) ; foreach ( $ errors as $ error ) { if ( ! \ in_array ( $ error [ 'hash' ] , $ errorsNotCleared ) ) { $ error [ 'inConsole' ] = false ; } } } 
private function clearErrorsHelper ( & $ log , $ clear = true ) { $ errorsNotCleared = array ( ) ; foreach ( $ log as $ k => $ entry ) { if ( ! \ in_array ( $ entry [ 0 ] , array ( 'error' , 'warn' ) ) ) { continue ; } $ clear2 = $ clear ; if ( $ this -> channelName ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; $ clear2 = $ clear && $ channel === $ this -> channelName ; } if ( $ clear2 ) { unset ( $ log [ $ k ] ) ; } elseif ( isset ( $ entry [ 2 ] [ 'errorHash' ] ) ) { $ errorsNotCleared [ ] = $ entry [ 2 ] [ 'errorHash' ] ; } } $ log = \ array_values ( $ log ) ; return $ errorsNotCleared ; } 
private function clearLog ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_LOG_ERRORS ; if ( $ flags & Debug :: CLEAR_LOG ) { $ return = 'log (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curDepth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] [ 'main' ] as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entriesKeep = $ this -> debug -> internal -> getCurrentGroups ( $ this -> data [ 'log' ] , $ curDepth ) ; $ this -> clearLogHelper ( $ this -> data [ 'log' ] , $ clearErrors , $ entriesKeep ) ; } elseif ( $ clearErrors ) { $ return = 'errors' ; } return $ return ; } 
private function clearLogHelper ( & $ log , $ clearErrors = false , $ entriesKeep = array ( ) ) { $ keep = $ clearErrors ? array ( ) : array ( 'error' , 'warn' ) ; if ( $ keep || $ this -> channelName ) { 
private function clearSummary ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( $ flags & Debug :: CLEAR_SUMMARY ) { $ return = 'summary (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curPriority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; 
private function getLogArgs ( $ cleared ) { $ cleared = \ array_filter ( $ cleared ) ; if ( ! $ cleared ) { return array ( ) ; } $ count = \ count ( $ cleared ) ; $ glue = $ count == 2 ? ' and ' : ', ' ; if ( $ count > 2 ) { $ cleared [ $ count - 1 ] = 'and ' . $ cleared [ $ count - 1 ] ; } $ msg = 'Cleared ' . \ implode ( $ glue , $ cleared ) ; if ( $ this -> channelName ) { return array ( $ msg . ' %c(%s)' , 'background-color:#c0c0c0; padding:0 .33em;' , $ this -> channelName , ) ; } return array ( $ msg ) ; } 
public function getAbstraction ( & $ array , $ method = null , & $ hist = array ( ) ) { if ( \ in_array ( $ array , $ hist , true ) ) { return $ this -> abstracter -> RECURSION ; } if ( self :: isCallable ( $ array ) ) { 
public function backtrace ( $ error = null ) { $ exception = null ; $ isFatalError = false ; if ( $ error instanceof \ Exception ) { $ exception = $ error ; } elseif ( $ error ) { 
public function get ( $ key = null ) { if ( $ key == 'lastError' ) { return isset ( $ this -> data [ 'lastError' ] ) ? $ this -> data [ 'lastError' ] -> getValues ( ) : null ; } if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } if ( isset ( $ this -> { $ key } ) ) { return $ this -> { $ key } ; } return null ; } 
public function getCfg ( $ key = null ) { if ( ! \ strlen ( $ key ) ) { return $ this -> cfg ; } if ( isset ( $ this -> cfg [ $ key ] ) ) { return $ this -> cfg [ $ key ] ; } return null ; } 
public static function getInstance ( $ cfg = array ( ) ) { if ( ! isset ( self :: $ instance ) ) { return false ; } elseif ( $ cfg ) { self :: $ instance -> setCfg ( $ cfg ) ; } return self :: $ instance ; } 
public function handleError ( $ errType , $ errMsg , $ file , $ line , $ vars = array ( ) ) { $ error = $ this -> buildError ( $ errType , $ errMsg , $ file , $ line , $ vars ) ; $ errorReporting = $ this -> cfg [ 'errorReporting' ] === 'system' ? \ error_reporting ( ) 
public function handleException ( $ exception ) { 
public function onShutdown ( Event $ event ) { if ( ! $ this -> registered ) { return ; } $ error = $ event [ 'error' ] ? : \ error_get_last ( ) ; if ( ! $ error ) { return ; } if ( \ in_array ( $ error [ 'type' ] , $ this -> errCategories [ 'fatal' ] ) ) { \ error_reporting ( E_ALL | E_STRICT ) ; $ this -> handleError ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } foreach ( $ this -> data [ 'errors' ] as $ error ) { if ( $ error [ 'category' ] === 'fatal' ) { $ event [ 'error' ] = $ error ; break ; } } return ; } 
public function register ( ) { if ( $ this -> registered ) { return ; } $ this -> prevDisplayErrors = \ ini_set ( 'display_errors' , 0 ) ; $ this -> prevErrorHandler = \ set_error_handler ( array ( $ this , 'handleError' ) ) ; $ this -> prevExceptionHandler = \ set_exception_handler ( array ( $ this , 'handleException' ) ) ; $ this -> registered = true ; 
public function setCfg ( $ mixed , $ newVal = null ) { $ ret = null ; $ values = array ( ) ; if ( \ is_string ( $ mixed ) ) { $ key = $ mixed ; $ ret = isset ( $ this -> cfg [ $ key ] ) ? $ this -> cfg [ $ key ] : null ; $ values = array ( $ key => $ newVal , ) ; } elseif ( \ is_array ( $ mixed ) ) { $ values = $ mixed ; } if ( isset ( $ values [ 'onError' ] ) ) { if ( isset ( $ this -> cfg [ 'onError' ] ) ) { $ this -> eventManager -> unsubscribe ( 'errorHandler.error' , $ this -> cfg [ 'onError' ] ) ; } $ this -> eventManager -> subscribe ( 'errorHandler.error' , $ values [ 'onError' ] ) ; } $ this -> cfg = \ array_merge ( $ this -> cfg , $ values ) ; return $ ret ; } 
public function setErrorCaller ( $ caller = null , $ offset = 0 ) { if ( $ caller === null ) { $ backtrace = \ version_compare ( PHP_VERSION , '5.4.0' , '>=' ) ? \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS , $ offset + 3 ) : \ debug_backtrace ( false ) ; 
public function unregister ( ) { if ( ! $ this -> registered ) { return ; } $ errHandlerCur = \ set_error_handler ( array ( $ this , 'handleError' ) ) ; \ restore_error_handler ( ) ; if ( $ errHandlerCur == array ( $ this , 'handleError' ) ) { set and restore exception handler to determine the current error handler */ $ exHandlerCur = \ set_exception_handler ( array ( $ this , 'handleException' ) ) ; \ restore_exception_handler ( ) ; if ( $ exHandlerCur == array ( $ this , 'handleException' ) ) { 
protected function backtraceRemoveInternal ( $ backtrace ) { for ( $ i = \ count ( $ backtrace ) - 1 ; $ i > 0 ; $ i -- ) { $ frame = $ backtrace [ $ i ] ; if ( isset ( $ frame [ 'class' ] ) && $ frame [ 'class' ] === __CLASS__ ) { break ; } } if ( $ backtrace [ $ i ] [ 'function' ] == 'onShutdown' ) { $ refObj = new ReflectionObject ( $ this -> eventManager ) ; $ filepath = $ refObj -> getFilename ( ) ; while ( isset ( $ backtrace [ $ i + 1 ] [ 'file' ] ) && $ backtrace [ $ i + 1 ] [ 'file' ] == $ filepath ) { $ i ++ ; } } $ i ++ ; return \ array_slice ( $ backtrace , $ i ) ; } 
protected function normalizeTrace ( $ backtrace ) { $ backtraceNew = array ( ) ; $ frameDefault = array ( 'file' => null , 'line' => null , 'function' => null , 'class' => null , 'type' => null , ) ; $ funcsSkip = array ( 'call_user_func' , 'call_user_func_array' ) ; $ funcsSkipRegex = '/^(' . \ implode ( '|' , $ funcsSkip ) . ')[:\(\{]/' ; for ( $ i = 0 , $ count = \ count ( $ backtrace ) ; $ i < $ count ; $ i ++ ) { $ frame = \ array_merge ( $ frameDefault , $ backtrace [ $ i ] ) ; $ frame = \ array_intersect_key ( $ frame , $ frameDefault ) ; if ( \ in_array ( $ frame [ 'function' ] , $ funcsSkip ) || \ preg_match ( $ funcsSkipRegex , $ frame [ 'function' ] ) ) { $ backtraceNew [ count ( $ backtraceNew ) - 1 ] [ 'file' ] = $ frame [ 'file' ] ; $ backtraceNew [ count ( $ backtraceNew ) - 1 ] [ 'line' ] = $ frame [ 'line' ] ; continue ; } if ( \ in_array ( $ frame [ 'type' ] , array ( 'dynamic' , 'static' ) ) ) { 
protected function buildError ( $ errType , $ errMsg , $ file , $ line , $ vars ) { 
protected function errorHash ( $ errorValues ) { $ errMsg = $ errorValues [ 'message' ] ; 
protected function onUserError ( Event $ error ) { switch ( $ this -> cfg [ 'onEUserError' ] ) { case 'continue' : $ error [ 'continueToNormal' ] = false ; break ; case 'log' : no special consideration unless errorHandler.error subscriber changes `continueToNormal` value, script will be halted */ } } 
public static function getParsed ( $ what ) { $ hash = null ; if ( \ is_object ( $ what ) ) { $ hash = self :: getHash ( $ what ) ; if ( isset ( self :: $ cache [ $ hash ] ) ) { return self :: $ cache [ $ hash ] ; } } $ comment = self :: getCommentContent ( $ what ) ; if ( \ is_array ( $ comment ) ) { return $ comment ; } $ return = array ( 'summary' => null , 'description' => null , ) ; if ( \ preg_match ( '/^@/m' , $ comment , $ matches , PREG_OFFSET_CAPTURE ) ) { Do some string replacement */ $ comment = \ preg_replace ( '/^\\\@/m' , '@' , $ comment ) ; $ comment = \ str_replace ( '{@*}' , '*/' , $ comment ) ; $ split = \ preg_split ( '/(\.[\r\n]+|[\r\n]{2})/' , $ comment , 2 , PREG_SPLIT_DELIM_CAPTURE ) ; $ split = \ array_replace ( array ( '' , '' , '' ) , $ split ) ; 
public static function parseTag ( $ tag , $ tagStr = '' ) { $ parsed = array ( ) ; $ tagParsers = array ( array ( 'tags' => array ( 'param' , 'property' , 'property-read' , 'property-write' , 'var' ) , 'parts' => array ( 'type' , 'name' , 'desc' ) , 'regex' => '/^' . '(?:(?P<type>[^\$].*?)\s+)?' . '(?:&?\$?(?P<name>\S+)\s+)?' . '(?P<desc>.*)?' . '$/s' , 'callable' => function ( $ tag , $ parsed ) { if ( \ strpos ( $ parsed [ 'desc' ] , ' ' ) === false ) { if ( ! $ parsed [ 'type' ] ) { $ parsed [ 'type' ] = $ parsed [ 'desc' ] ; $ parsed [ 'desc' ] = null ; } elseif ( ! $ parsed [ 'name' ] ) { $ parsed [ 'name' ] = \ ltrim ( $ parsed [ 'desc' ] , '&$' ) ; $ parsed [ 'desc' ] = null ; } } return $ parsed ; } , ) , array ( 'tags' => array ( 'method' ) , 'parts' => array ( 'static' , 'type' , 'name' , 'param' , 'desc' ) , 'regex' => '/' . '(?:(?P<static>static)\s+)?' . '(?:(?P<type>.*?)\s+)?' . '(?P<name>\S+)' . '\((?P<param>((?>[^()]+)|(?R))*)\)' 
public static function findInheritedDoc ( \ Reflector $ reflector ) { $ name = $ reflector -> getName ( ) ; $ reflectionClass = $ reflector -> getDeclaringClass ( ) ; $ interfaces = $ reflectionClass -> getInterfaceNames ( ) ; foreach ( $ interfaces as $ className ) { $ reflectionClass2 = new \ ReflectionClass ( $ className ) ; if ( $ reflectionClass2 -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass2 -> getMethod ( $ name ) ) ; } } $ reflectionClass = $ reflectionClass -> getParentClass ( ) ; if ( $ reflectionClass && $ reflectionClass -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass -> getMethod ( $ name ) ) ; } } 
private static function getCommentContent ( $ what ) { $ reflector = null ; if ( \ is_object ( $ what ) ) { $ reflector = $ what instanceof \ Reflector ? $ what : new \ ReflectionObject ( $ what ) ; $ docComment = $ reflector -> getDocComment ( ) ; } else { 
private static function getHash ( $ what ) { $ str = null ; if ( ! ( $ what instanceof \ Reflector ) ) { $ str = \ get_class ( $ what ) ; } elseif ( $ what instanceof \ ReflectionClass ) { $ str = $ what -> getName ( ) ; } elseif ( $ what instanceof \ ReflectionMethod ) { $ str = $ what -> getDeclaringClass ( ) -> getName ( ) . '::' . $ what -> getName ( ) . '()' ; } elseif ( $ what instanceof \ ReflectionFunction ) { $ str = $ what -> getName ( ) . '()' ; } elseif ( $ what instanceof \ ReflectionProperty ) { $ str = $ what -> getDeclaringClass ( ) -> getName ( ) . '::' . $ what -> getName ( ) ; } return $ str ? \ md5 ( $ str ) : null ; } 
private static function parseParams ( $ paramStr ) { $ params = self :: splitParams ( $ paramStr ) ; foreach ( $ params as $ i => $ str ) { \ preg_match ( '/^(?:([^=]*?)\s)?([^\s=]+)(?:\s*=\s*(\S+))?$/' , $ str , $ matches ) ; $ info = array ( 'type' => $ matches [ 1 ] ? : null , 'name' => $ matches [ 2 ] , ) ; if ( ! empty ( $ matches [ 3 ] ) ) { $ info [ 'defaultValue' ] = $ matches [ 3 ] ; } $ params [ $ i ] = $ info ; } return $ params ; } 
private static function parseTags ( $ str ) { $ regexNotTag = '(?P<value>(?:(?!^@).)*)' ; $ regexTags = '#^@(?P<tag>[\w-]+)[ \t]*' . $ regexNotTag . '#sim' ; \ preg_match_all ( $ regexTags , $ str , $ matches , PREG_SET_ORDER ) ; $ singleTags = array ( 'return' ) ; foreach ( $ matches as $ match ) { $ value = $ match [ 'value' ] ; $ value = \ preg_replace ( '/\n\s*\*\s*/' , "\n" , $ value ) ; $ value = \ trim ( $ value ) ; $ value = self :: parseTag ( $ match [ 'tag' ] , $ value ) ; if ( \ in_array ( $ match [ 'tag' ] , $ singleTags ) ) { $ return [ $ match [ 'tag' ] ] = $ value ; } else { $ return [ $ match [ 'tag' ] ] [ ] = $ value ; } } return $ return ; } 
private static function splitParams ( $ paramStr ) { $ depth = 0 ; $ startPos = 0 ; $ chars = \ str_split ( $ paramStr ) ; $ params = array ( ) ; foreach ( $ chars as $ pos => $ char ) { switch ( $ char ) { case ',' : if ( $ depth === 0 ) { $ params [ ] = \ trim ( \ substr ( $ paramStr , $ startPos , $ pos - $ startPos ) ) ; $ startPos = $ pos + 1 ; } break ; case '[' : case '(' : $ depth ++ ; break ; case ']' : case ')' : $ depth -- ; break ; } } $ params [ ] = \ trim ( \ substr ( $ paramStr , $ startPos , $ pos + 1 - $ startPos ) ) ; return $ params ; } 
private static function trimDesc ( $ desc ) { $ lines = \ explode ( "\n" , $ desc ) ; $ leadingSpaces = array ( ) ; foreach ( $ lines as $ line ) { if ( \ strlen ( $ line ) ) { $ leadingSpaces [ ] = \ strspn ( $ line , ' ' ) ; } } \ array_shift ( $ leadingSpaces ) ; 
public function email ( $ toAddr , $ subject , $ body ) { $ addHeadersStr = '' ; $ fromAddr = $ this -> debug -> getCfg ( 'emailFrom' ) ; if ( $ fromAddr ) { $ addHeadersStr .= 'From: ' . $ fromAddr ; } \ call_user_func ( $ this -> debug -> getCfg ( 'emailFunc' ) , $ toAddr , $ subject , $ body , $ addHeadersStr ) ; } 
public function emailLog ( ) { $ errorStr = $ this -> buildErrorList ( ) ; $ subject = 'Debug Log' ; $ subjectMore = '' ; if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ subjectMore .= ' ' . $ _SERVER [ 'HTTP_HOST' ] ; } if ( $ errorStr ) { $ subjectMore .= ' ' . ( $ subjectMore ? '(Error)' : 'Error' ) ; } $ subject = \ rtrim ( $ subject . ':' . $ subjectMore , ':' ) ; $ body = ( ! isset ( $ _SERVER [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ? 'Command: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) : 'Request: ' . $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] ) . "\n\n" ; if ( $ errorStr ) { $ body .= 'Error(s):' . "\n" . $ errorStr . "\n" ; } $ data = \ array_intersect_key ( $ this -> debug -> getData ( ) , \ array_flip ( array ( 'alerts' , 'log' , 'logSummary' , 'requestId' , 'runtime' , ) ) ) ; $ data [ 'rootChannel' ] = $ this -> debug -> getCfg ( 'channel' ) ; $ body .= $ this -> debug -> utilities -> serializeLog ( $ data ) ; $ this -> email ( $ this -> debug -> getCfg ( 'emailTo' ) , $ subject , $ body ) ; return ; } 
public function errorStats ( ) { $ errors = $ this -> debug -> errorHandler -> get ( 'errors' ) ; $ stats = array ( 'inConsole' => 0 , 'inConsoleCategories' => 0 , 'notInConsole' => 0 , 'counts' => array ( ) , ) ; foreach ( $ errors as $ error ) { if ( $ error [ 'isSuppressed' ] ) { continue ; } $ category = $ error [ 'category' ] ; if ( ! isset ( $ stats [ 'counts' ] [ $ category ] ) ) { $ stats [ 'counts' ] [ $ category ] = array ( 'inConsole' => 0 , 'notInConsole' => 0 , ) ; } $ k = $ error [ 'inConsole' ] ? 'inConsole' : 'notInConsole' ; $ stats [ 'counts' ] [ $ category ] [ $ k ] ++ ; } foreach ( $ stats [ 'counts' ] as $ a ) { $ stats [ 'inConsole' ] += $ a [ 'inConsole' ] ; $ stats [ 'notInConsole' ] += $ a [ 'notInConsole' ] ; if ( $ a [ 'inConsole' ] ) { $ stats [ 'inConsoleCategories' ] ++ ; } } $ order = array ( 'fatal' , 'error' , 'warning' , 'deprecated' , 'notice' , 'strict' , ) ; $ stats [ 'counts' ] = \ array_intersect_key ( \ array_merge ( \ array_flip ( $ order ) , $ stats [ 'counts' ] ) , $ stats [ 'counts' ] ) ; return $ stats ; } 
public function getErrorCaller ( ) { $ meta = array ( ) ; if ( $ this -> error ) { 
public static function getCurrentGroups ( & $ logEntries , $ curDepth ) { $ minDepth = $ curDepth ; $ entries = array ( ) ; for ( $ i = \ count ( $ logEntries ) - 1 ; $ i >= 0 ; $ i -- ) { if ( $ curDepth < 1 ) { break ; } $ method = $ logEntries [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ curDepth -- ; if ( $ curDepth < $ minDepth ) { $ minDepth -- ; $ entries [ $ i ] = $ logEntries [ $ i ] ; } } elseif ( $ method == 'groupEnd' ) { $ curDepth ++ ; } } return $ entries ; } 
public static function getMetaVals ( & $ args , $ defaultMeta = array ( ) , $ defaultArgs = array ( ) , $ argsToMeta = array ( ) ) { $ meta = array ( ) ; foreach ( $ args as $ i => $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'debug' ] ) && $ v [ 'debug' ] === Debug :: META ) { unset ( $ v [ 'debug' ] ) ; $ meta = \ array_merge ( $ meta , $ v ) ; unset ( $ args [ $ i ] ) ; } } $ args = \ array_values ( $ args ) ; if ( $ defaultArgs ) { $ args = \ array_slice ( $ args , 0 , \ count ( $ defaultArgs ) ) ; $ args = \ array_combine ( \ array_keys ( $ defaultArgs ) , \ array_replace ( \ array_values ( $ defaultArgs ) , $ args ) ) ; } foreach ( $ argsToMeta as $ argk => $ metak ) { if ( \ is_int ( $ argk ) ) { $ argk = $ metak ; } $ defaultMeta [ $ metak ] = $ args [ $ argk ] ; unset ( $ args [ $ argk ] ) ; } $ meta = \ array_merge ( $ defaultMeta , $ meta ) ; return $ meta ; } 
public function hasLog ( ) { $ entryCountInitial = $ this -> debug -> getData ( 'entryCountInitial' ) ; $ entryCountCurrent = $ this -> debug -> getData ( 'log/__count__' ) ; $ haveLog = $ entryCountCurrent > $ entryCountInitial ; $ lastEntryMethod = $ this -> debug -> getData ( 'log/__end__/0' ) ; return $ haveLog && $ lastEntryMethod !== 'clear' ; } 
public function onBootstrap ( ) { if ( $ this -> debug -> parentInstance ) { 
public function onConfig ( Event $ event ) { $ cfg = $ event [ 'config' ] ; if ( ! isset ( $ cfg [ 'debug' ] ) ) { Replace - not append - subscriber set via setCfg */ if ( isset ( $ this -> cfg [ 'onLog' ] ) ) { $ this -> debug -> eventManager -> unsubscribe ( 'debug.log' , $ this -> cfg [ 'onLog' ] ) ; } $ this -> debug -> eventManager -> subscribe ( 'debug.log' , $ cfg [ 'onLog' ] ) ; } if ( ! static :: $ profilingEnabled ) { $ cfg = $ this -> debug -> getCfg ( 'debug/*' ) ; if ( $ cfg [ 'enableProfiling' ] && $ cfg [ 'collect' ] ) { static :: $ profilingEnabled = true ; $ pathsExclude = array ( __DIR__ , ) ; FileStreamWrapper :: register ( $ pathsExclude ) ; } } } 
public function onError ( Event $ error ) { if ( $ this -> debug -> getCfg ( 'collect' ) ) { $ this -> error = $ error ; $ errInfo = $ error [ 'typeStr' ] . ': ' . $ error [ 'file' ] . ' (line ' . $ error [ 'line' ] . ')' ; $ errMsg = $ error [ 'message' ] ; if ( $ error [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ) { $ this -> debug -> error ( $ errInfo . ': ' , $ errMsg ) ; } else { $ this -> debug -> warn ( $ errInfo . ': ' , $ errMsg ) ; } $ error [ 'continueToNormal' ] = false ; 
public function onOutput ( ) { if ( $ this -> debug -> parentInstance ) { 
public function onShutdown ( ) { $ this -> runtimeVals ( ) ; if ( $ this -> testEmailLog ( ) ) { $ this -> emailLog ( ) ; } if ( ! $ this -> debug -> getData ( 'outputSent' ) ) { echo $ this -> debug -> output ( ) ; } return ; } 
public function publishBubbleEvent ( $ eventName , $ eventOrSubject , array $ values = array ( ) ) { if ( $ eventOrSubject instanceof Event ) { $ event = $ eventOrSubject ; } else { $ event = new Event ( $ eventOrSubject , $ values ) ; } $ debug = $ this -> debug ; while ( ! $ event -> isPropagationStopped ( ) ) { $ debug -> eventManager -> publish ( $ eventName , $ event ) ; if ( ! $ debug -> parentInstance ) { break ; } $ debug = $ debug -> parentInstance ; } return $ event ; } 
private function buildErrorList ( ) { $ errorStr = '' ; $ errors = $ this -> debug -> errorHandler -> get ( 'errors' ) ; \ uasort ( $ errors , function ( $ a1 , $ a2 ) { return \ strcmp ( $ a1 [ 'file' ] . $ a1 [ 'line' ] , $ a2 [ 'file' ] . $ a2 [ 'line' ] ) ; } ) ; $ lastFile = '' ; foreach ( $ errors as $ error ) { if ( $ error [ 'isSuppressed' ] ) { continue ; } if ( $ error [ 'file' ] !== $ lastFile ) { $ errorStr .= $ error [ 'file' ] . ':' . "\n" ; $ lastFile = $ error [ 'file' ] ; } $ typeStr = $ error [ 'type' ] === E_STRICT ? 'Strict' : $ error [ 'typeStr' ] ; $ errorStr .= ' Line ' . $ error [ 'line' ] . ': (' . $ typeStr . ') ' . $ error [ 'message' ] . "\n" ; } return $ errorStr ; } 
private function logPhpInfo ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.phpInfo' ) ) { return ; } $ this -> debug -> log ( 'PHP Version' , PHP_VERSION ) ; $ this -> debug -> log ( 'ini location' , \ php_ini_loaded_file ( ) ) ; $ this -> debug -> log ( 'memory_limit' , $ this -> debug -> utilities -> getBytes ( $ this -> debug -> utilities -> memoryLimit ( ) ) ) ; $ this -> debug -> log ( 'session.cache_limiter' , \ ini_get ( 'session.cache_limiter' ) ) ; if ( \ session_module_name ( ) === 'files' ) { $ this -> debug -> log ( 'session_save_path' , \ session_save_path ( ) ? : \ sys_get_temp_dir ( ) ) ; } $ extensionsCheck = array ( 'curl' , 'mbstring' ) ; $ extensionsCheck = \ array_filter ( $ extensionsCheck , function ( $ extension ) { return ! \ extension_loaded ( $ extension ) ; } ) ; if ( $ extensionsCheck ) { $ this -> debug -> warn ( 'These common extensions are not loaded:' , $ extensionsCheck ) ; } $ this -> logPhpInfoEr ( ) ; } 
private function logPhpInfoEr ( ) { $ errorReportingRaw = $ this -> debug -> getCfg ( 'errorReporting' ) ; $ errorReporting = $ errorReportingRaw === 'system' ? \ error_reporting ( ) : $ errorReportingRaw ; $ msgLines = array ( ) ; $ styles = array ( ) ; $ styleMono = 'font-family:monospace; opacity:0.8;' ; $ styleReset = 'font-family:inherit; white-space:pre-wrap;' ; if ( \ error_reporting ( ) !== ( E_ALL | E_STRICT ) ) { $ msgLines [ ] = 'PHP\'s %cerror_reporting%c is set to `%c' . ErrorLevel :: toConstantString ( ) . '%c` rather than `%cE_ALL | E_STRICT%c`' ; $ styles = array ( $ styleMono , $ styleReset , // wraps "error_reporting" $ styleMono , $ styleReset , // wraps actual $ styleMono , $ styleReset , // wraps E_ALL | E_STRICT ) ; if ( $ errorReporting === ( E_ALL | E_STRICT ) ) { $ msgLines [ ] = 'PHPDebugConsole is disregarding %cerror_reporting%c value (this is configurable)' ; $ styles [ ] = $ styleMono ; $ styles [ ] = $ styleReset ; } } if ( $ errorReporting !== ( E_ALL | E_STRICT ) ) { if ( $ errorReportingRaw === 'system' ) { $ msgLines [ ] = 'PHPDebugConsole\'s errorHandler is set to "system" (not all errors will be shown)' ; } elseif ( $ errorReporting === \ error_reporting ( ) ) { $ msgLines [ ] = 'PHPDebugConsole\'s errorHandler is also using a errorReporting value of ' . '`%c' . ErrorLevel :: toConstantString ( $ errorReporting ) . '%c`' ; $ styles [ ] = $ styleMono ; $ styles [ ] = $ styleReset ; } else { $ msgLines [ ] = 'PHPDebugConsole\'s errorHandler is using a errorReporting value of ' . '`%c' . ErrorLevel :: toConstantString ( $ errorReporting ) . '%c`' ; $ styles [ ] = $ styleMono ; $ styles [ ] = $ styleReset ; } } if ( $ msgLines ) { $ args = array ( \ implode ( "\n" , $ msgLines ) ) ; $ args = \ array_merge ( $ args , $ styles ) ; $ args [ ] = $ this -> debug -> meta ( array ( 'file' => null , 'line' => null , ) ) ; \ call_user_func_array ( array ( $ this -> debug , 'warn' ) , $ args ) ; } } 
private function logRequest ( ) { $ this -> logRequestHeaders ( ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.cookies' ) ) { $ cookieVals = $ _COOKIE ; \ ksort ( $ cookieVals , SORT_NATURAL ) ; $ this -> debug -> log ( '$_COOKIE' , $ cookieVals ) ; } 
private function logRequestHeaders ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.headers' ) ) { return ; } if ( ! empty ( $ _SERVER [ 'argv' ] ) ) { return ; } $ headers = $ this -> debug -> utilities -> getAllHeaders ( ) ; \ ksort ( $ headers , SORT_NATURAL ) ; $ this -> debug -> log ( 'request headers' , $ headers ) ; } 
private function logServerVals ( ) { $ logEnvInfo = $ this -> debug -> getCfg ( 'logEnvInfo' ) ; if ( ! $ logEnvInfo [ 'serverVals' ] ) { return ; } $ logServerKeys = $ this -> debug -> getCfg ( 'logServerKeys' ) ; if ( isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) && $ _SERVER [ 'REQUEST_METHOD' ] !== 'GET' ) { $ logServerKeys [ ] = 'REQUEST_METHOD' ; } if ( isset ( $ _SERVER [ 'CONTENT_LENGTH' ] ) ) { $ logServerKeys [ ] = 'CONTENT_LENGTH' ; $ logServerKeys [ ] = 'CONTENT_TYPE' ; } if ( ! $ logEnvInfo [ 'headers' ] ) { $ logServerKeys [ ] = 'HTTP_HOST' ; } $ logServerKeys = \ array_unique ( $ logServerKeys ) ; if ( ! $ logServerKeys ) { return ; } $ vals = array ( ) ; foreach ( $ logServerKeys as $ k ) { if ( ! \ array_key_exists ( $ k , $ _SERVER ) ) { $ vals [ $ k ] = $ this -> debug -> abstracter -> UNDEFINED ; } elseif ( $ k == 'REQUEST_TIME' ) { $ vals [ $ k ] = \ date ( 'Y-m-d H:i:s T' , $ _SERVER [ 'REQUEST_TIME' ] ) ; } else { $ vals [ $ k ] = $ _SERVER [ $ k ] ; } } \ ksort ( $ vals , SORT_NATURAL ) ; $ this -> debug -> log ( '$_SERVER' , $ vals ) ; } 
private function runtimeVals ( ) { $ vals = $ this -> debug -> getData ( 'runtime' ) ; if ( ! $ vals ) { $ vals = array ( 'memoryPeakUsage' => \ memory_get_peak_usage ( true ) , 'memoryLimit' => $ this -> debug -> utilities -> memoryLimit ( ) , 'runtime' => $ this -> debug -> timeEnd ( 'debugInit' , true ) , ) ; $ this -> debug -> setData ( 'runtime' , $ vals ) ; } return $ vals ; } 
public function onOutput ( Event $ event ) { $ this -> outputEvent = $ event ; $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-Protocol-1' , 'http://meta.wildfirehq.org/Protocol/JsonStream/0.2' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Plugin-1' , 'http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/' . self :: FIREPHP_PROTO_VER ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Structure-1' , 'http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1' ) ; $ heading = isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP: ' . $ heading ) ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Index' , $ this -> messageIndex ) ; $ this -> data = array ( ) ; return ; } 
public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ value = null ; $ firePhpMeta = $ this -> getMeta ( $ method , $ meta ) ; if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; $ value = $ args [ 0 ] ; } elseif ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ firePhpMeta [ 'Label' ] = $ args [ 0 ] ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ firePhpMeta [ 'Type' ] = \ is_array ( $ args [ 0 ] ) ? $ this -> firephpMethods [ 'table' ] : $ this -> firephpMethods [ 'log' ] ; $ value = $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ; if ( $ meta [ 'caption' ] ) { $ firePhpMeta [ 'Label' ] = $ meta [ 'caption' ] ; } } elseif ( $ method == 'trace' ) { $ firePhpMeta [ 'Type' ] = $ this -> firephpMethods [ 'table' ] ; $ value = $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ; $ firePhpMeta [ 'Label' ] = 'trace' ; } elseif ( \ count ( $ args ) ) { if ( \ count ( $ args ) == 1 ) { $ value = $ args [ 0 ] ; 
private function getMeta ( $ method , $ meta ) { $ firePhpMeta = array ( 'Type' => isset ( $ this -> firephpMethods [ $ method ] ) ? $ this -> firephpMethods [ $ method ] : $ this -> firephpMethods [ 'log' ] , 
protected function methodTable ( $ array , $ columns = array ( ) ) { if ( ! \ is_array ( $ array ) ) { return $ this -> dump ( $ array ) ; } $ table = array ( ) ; $ keys = $ columns ? : $ this -> debug -> methodTable -> colKeys ( $ array ) ; $ headerVals = $ keys ; foreach ( $ headerVals as $ i => $ val ) { if ( $ val === MethodTable :: SCALAR ) { $ headerVals [ $ i ] = 'value' ; } } \ array_unshift ( $ headerVals , '' ) ; $ table [ ] = $ headerVals ; $ classNames = array ( ) ; if ( $ this -> debug -> abstracter -> isAbstraction ( $ array ) && $ array [ 'traverseValues' ] ) { $ array = $ array [ 'traverseValues' ] ; } foreach ( $ array as $ k => $ row ) { $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; foreach ( $ values as $ k2 => $ val ) { if ( $ val === $ this -> debug -> abstracter -> UNDEFINED ) { $ values [ $ k2 ] = null ; } } $ classNames [ ] = $ objInfo [ 'row' ] ? $ objInfo [ 'row' ] [ 'className' ] : '' ; \ array_unshift ( $ values , $ k ) ; $ table [ ] = \ array_values ( $ values ) ; } if ( \ array_filter ( $ classNames ) ) { \ array_unshift ( $ table [ 0 ] , '' ) ; 
private function setFirephpHeader ( $ meta , $ value = null ) { $ msg = \ json_encode ( array ( $ meta , $ value , ) ) ; $ structureIndex = 1 ; 
public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ errorStats = $ this -> debug -> internal -> errorStats ( ) ; $ errorStr = '' ; if ( $ errorStats [ 'inConsole' ] ) { $ errorStr = 'Errors: ' ; foreach ( $ errorStats [ 'counts' ] as $ category => $ vals ) { $ errorStr .= $ vals [ 'inConsole' ] . ' ' . $ category . ', ' ; } $ errorStr = \ substr ( $ errorStr , 0 , - 2 ) ; } $ str = '' ; $ str .= '<script type="text/javascript">' . "\n" ; $ str .= $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP' , ( isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) && isset ( $ _SERVER [ 'REQUEST_URI' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '' ) , $ errorStr , ) ) ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ str .= $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ str .= '</script>' . "\n" ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; } 
public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method == 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { if ( isset ( $ meta [ 'file' ] ) ) { $ args [ ] = $ meta [ 'file' ] . ': line ' . $ meta [ 'line' ] ; } } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ k => $ arg ) { $ args [ $ k ] = \ json_encode ( $ this -> dump ( $ arg ) ) ; } $ str = 'console.' . $ method . '(' . \ implode ( ',' , $ args ) . ');' . "\n" ; $ str = \ str_replace ( \ json_encode ( $ this -> debug -> abstracter -> UNDEFINED ) , 'undefined' , $ str ) ; return $ str ; } 
protected function methodAlert ( $ args , $ meta ) { $ args = array ( '%c' . $ args [ 0 ] , '' ) ; $ method = $ meta [ 'class' ] ; $ styleCommon = 'padding:5px; line-height:26px; font-size:125%; font-weight:bold;' ; switch ( $ method ) { case 'danger' : 
public function build ( $ stats ) { $ this -> stats = $ stats ; return '' . $ this -> buildFatal ( ) . $ this -> buildInConsole ( ) . $ this -> buildNotInConsole ( ) ; } 
protected function buildFatal ( ) { $ haveFatal = isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ; if ( ! $ haveFatal ) { return '' ; } $ lastError = $ this -> errorHandler -> get ( 'lastError' ) ; $ isHtml = $ lastError [ 'isHtml' ] ; $ backtrace = $ lastError [ 'backtrace' ] ; $ html = '<h3>Fatal Error</h3>' ; $ html .= '<ul class="list-unstyled indent">' ; if ( \ count ( $ backtrace ) > 1 ) { 
protected function buildInConsole ( ) { if ( ! $ this -> stats [ 'inConsole' ] ) { return '' ; } $ haveFatal = isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ; if ( $ haveFatal ) { $ countNonFatal = $ this -> stats [ 'inConsole' ] - $ this -> stats [ 'counts' ] [ 'fatal' ] [ 'inConsole' ] ; $ header = \ sprintf ( 'There %s %d additional %s' , $ countNonFatal === 1 ? 'was' : 'were' , $ countNonFatal , $ countNonFatal === 1 ? 'error' : 'errors' ) ; } elseif ( $ this -> stats [ 'inConsoleCategories' ] === 1 ) { return $ this -> buildInConsoleOneCat ( ) ; } else { $ header = 'There were ' . $ this -> stats [ 'inConsole' ] . ' errors' ; } $ html = '<h3>' . $ header . ':</h3>' . "\n" ; $ html .= '<ul class="list-unstyled indent">' ; foreach ( $ this -> stats [ 'counts' ] as $ category => $ a ) { if ( ! $ a [ 'inConsole' ] || $ category == 'fatal' ) { continue ; } $ html .= '<li class="error-' . $ category . '">' . $ category . ': ' . $ a [ 'inConsole' ] . '</li>' ; } $ html .= '</ul>' ; return $ html ; } 
protected function buildInConsoleOneCat ( ) { 
protected function buildNotInConsole ( ) { if ( ! $ this -> stats [ 'notInConsole' ] ) { return '' ; } $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ lis = array ( ) ; foreach ( $ errors as $ err ) { if ( \ array_intersect_assoc ( array ( 
protected function getErrorsInCategory ( $ category ) { $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ errorsInCat = array ( ) ; foreach ( $ errors as $ err ) { if ( $ err [ 'category' ] == $ category && $ err [ 'inConsole' ] ) { $ errorsInCat [ ] = $ err ; } } return $ errorsInCat ; } 
public function addSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> subscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; } 
public function getSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return array ( ) ; } if ( ! isset ( $ this -> sorted [ $ eventName ] ) ) { $ this -> sortSubscribers ( $ eventName ) ; } return $ this -> sorted [ $ eventName ] ; } 
public function hasSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { return ! empty ( $ this -> subscribers [ $ eventName ] ) ; } foreach ( $ this -> subscribers as $ subscribers ) { if ( $ subscribers ) { return true ; } } return false ; } 
public function publish ( $ eventName , $ eventOrSubject = null , array $ values = array ( ) ) { if ( $ eventOrSubject instanceof Event ) { $ event = $ eventOrSubject ; } else { $ event = new Event ( $ eventOrSubject , $ values ) ; } $ subscribers = $ this -> getSubscribers ( $ eventName ) ; if ( $ subscribers ) { $ this -> doPublish ( $ eventName , $ subscribers , $ event ) ; } return $ event ; } 
public function removeSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> unsubscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; } 
public function subscribe ( $ eventName , $ callable , $ priority = 0 ) { unset ( $ this -> sorted [ $ eventName ] ) ; 
public function unsubscribe ( $ eventName , $ callable ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return ; } if ( $ this -> isClosureFactory ( $ callable ) ) { 
protected function doPublish ( $ eventName , $ subscribers , Event $ event ) { foreach ( $ subscribers as $ callable ) { if ( $ event -> isPropagationStopped ( ) ) { break ; } \ call_user_func ( $ callable , $ event , $ eventName , $ this ) ; } } 
private function getInterfaceSubscribers ( SubscriberInterface $ interface ) { $ subscribers = array ( ) ; foreach ( $ interface -> getSubscriptions ( ) as $ eventName => $ mixed ) { if ( \ is_string ( $ mixed ) ) { 
private function sortSubscribers ( $ eventName ) { \ krsort ( $ this -> subscribers [ $ eventName ] ) ; $ this -> sorted [ $ eventName ] = array ( ) ; foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ subscriber ) { if ( $ this -> isClosureFactory ( $ subscriber ) ) { $ subscriber [ 0 ] = $ subscriber [ 0 ] ( ) ; $ this -> subscribers [ $ eventName ] [ $ priority ] [ $ k ] = $ subscriber ; } $ this -> sorted [ $ eventName ] [ ] = $ subscriber ; } } } 
public static function register ( $ pathsExclude = array ( ) ) { $ result = \ stream_wrapper_unregister ( static :: PROTOCOL ) ; if ( $ result === false ) { throw new \ UnexpectedValueException ( 'Failed to unregister' ) ; } if ( $ pathsExclude ) { self :: $ pathsExclude = $ pathsExclude ; } \ stream_wrapper_register ( static :: PROTOCOL , \ get_called_class ( ) ) ; \ ini_set ( 'opcache.enable' , 0 ) ; } 
public function dir_closedir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; \ closedir ( $ this -> handle ) ; self :: register ( ) ; $ this -> handle = null ; return true ; } 
public function dir_opendir ( $ path , $ options = 0 ) { if ( $ this -> handle ) { return false ; } 
public function dir_readdir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ readdir ( $ this -> handle ) ; self :: register ( ) ; return $ success ; } 
public function dir_rewinddir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; \ rewinddir ( $ this -> handle ) ; self :: register ( ) ; return true ; } 
public function mkdir ( $ path , $ mode , $ options = 0 ) { self :: restorePrev ( ) ; $ success = \ mkdir ( $ path , $ mode , ( bool ) ( $ options & STREAM_MKDIR_RECURSIVE ) ) ; self :: register ( ) ; return $ success ; } 
public function rename ( $ pathFrom , $ pathTo ) { self :: restorePrev ( ) ; $ success = \ rename ( $ pathFrom , $ pathTo ) ; self :: register ( ) ; return $ success ; } 
public function rmdir ( $ path , $ options ) { 
public function stream_close ( ) { if ( ! $ this -> handle ) { return ; } self :: restorePrev ( ) ; \ fclose ( $ this -> handle ) ; $ this -> handle = null ; self :: register ( ) ; } 
public function stream_eof ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ feof ( $ this -> handle ) ; self :: register ( ) ; return $ result ; } 
public function stream_flush ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ fflush ( $ this -> handle ) ; self :: register ( ) ; return $ success ; } 
public function stream_lock ( $ operation ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ flock ( $ this -> handle , $ operation ) ; self :: register ( ) ; return $ success ; } 
public function stream_metadata ( $ path , $ option , $ value ) { self :: restorePrev ( ) ; switch ( $ option ) { case STREAM_META_TOUCH : if ( ! empty ( $ value ) ) { $ success = \ touch ( $ path , $ value [ 0 ] , $ value [ 1 ] ) ; } else { $ success = \ touch ( $ path ) ; } break ; case STREAM_META_OWNER_NAME : 
public function stream_open ( $ path , $ mode , $ options , & $ openedPath ) { if ( $ this -> handle ) { return false ; } $ useIncludePath = ( bool ) $ options & STREAM_USE_PATH ; $ context = $ this -> context ; if ( $ context === null ) { $ context = \ stream_context_get_default ( ) ; } self :: restorePrev ( ) ; if ( \ strpos ( $ mode , 'r' ) !== false && ! \ file_exists ( $ path ) ) { return false ; } elseif ( \ strpos ( $ mode , 'x' ) !== false && \ file_exists ( $ path ) ) { return false ; } $ handle = \ fopen ( $ path , $ mode , $ useIncludePath , $ context ) ; self :: register ( ) ; if ( $ handle === false ) { return false ; } $ meta = \ stream_get_meta_data ( $ handle ) ; if ( ! isset ( $ meta [ 'uri' ] ) ) { throw new \ UnexpectedValueException ( 'Uri not in meta data' ) ; } $ this -> filepath = $ openedPath = $ meta [ 'uri' ] ; $ this -> handle = $ handle ; return true ; } 
public function stream_read ( $ count ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ buffer = \ fread ( $ this -> handle , $ count ) ; $ bufferLen = \ strlen ( $ buffer ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS , 2 ) ; $ isRequire = ! \ in_array ( $ backtrace [ 1 ] [ 'function' ] , array ( 'file_get_contents' ) ) ; if ( ! $ this -> declaredTicks && $ isRequire ) { foreach ( self :: $ pathsExclude as $ excludePath ) { if ( \ strpos ( $ this -> filepath , $ excludePath . DIRECTORY_SEPARATOR ) === 0 ) { $ this -> declaredTicks = true ; } } } if ( ! $ this -> declaredTicks && $ isRequire ) { 
public function stream_seek ( $ offset , $ whence = SEEK_SET ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ fseek ( $ this -> handle , $ offset , $ whence ) ; $ success = $ result !== - 1 ; self :: register ( ) ; return $ success ; } 
public function stream_stat ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ array = \ fstat ( $ this -> handle ) ; self :: register ( ) ; return $ array ; } 
public function stream_tell ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ position = \ ftell ( $ this -> handle ) ; self :: register ( ) ; return $ position ; } 
public function stream_truncate ( $ size ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ ftruncate ( $ this -> handle , $ size ) ; self :: register ( ) ; return $ success ; } 
public function stream_write ( $ data ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ length = \ fwrite ( $ this -> handle , $ data ) ; self :: register ( ) ; return $ length ; } 
public function unlink ( $ path ) { self :: restorePrev ( ) ; $ success = \ unlink ( $ path ) ; self :: register ( ) ; return $ success ; } 
public function url_stat ( $ path , $ flags ) { self :: restorePrev ( ) ; if ( ! \ file_exists ( $ path ) ) { $ info = false ; } elseif ( $ flags & STREAM_URL_STAT_LINK ) { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ lstat ( $ path ) : \ lstat ( $ path ) ; } else { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ stat ( $ path ) : \ stat ( $ path ) ; } self :: register ( ) ; return $ info ; } 
public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; if ( $ this -> json [ 'rows' ] ) { \ array_unshift ( $ this -> json [ 'rows' ] , array ( array ( 'PHP' , isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ) , null , 'groupCollapsed' , ) ) ; \ array_push ( $ this -> json [ 'rows' ] , array ( array ( ) , null , 'groupEnd' , ) ) ; $ encoded = $ this -> encode ( $ this -> json ) ; if ( \ strlen ( $ encoded ) > 250000 ) { $ this -> debug -> warn ( 'chromeLogger: output limit exceeded' ) ; } else { $ event [ 'headers' ] [ ] = array ( self :: HEADER_NAME , $ encoded ) ; } } $ this -> data = array ( ) ; $ this -> json [ 'rows' ] = array ( ) ; } 
public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method === 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method === 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ i => $ arg ) { $ args [ $ i ] = $ this -> dump ( $ arg ) ; } $ this -> json [ 'rows' ] [ ] = array ( $ args , isset ( $ meta [ 'file' ] ) ? $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] : null , $ method === 'log' ? '' : $ method , ) ; } 
public function getSubscriptions ( ) { if ( ! $ this -> isConnected ( ) ) { $ this -> debug -> alert ( 'WAMP publisher not connected to WAMP router' ) ; return array ( ) ; } $ this -> publishMeta ( ) ; $ this -> processExistingData ( ) ; return array ( 'debug.log' => array ( 'onLog' , PHP_INT_MAX * - 1 ) , 'errorHandler.error' => 'onError' , 
public function onError ( Event $ event ) { if ( $ event [ 'inConsole' ] || ! $ event [ 'isFirstOccur' ] ) { return ; } $ this -> processLogEntry ( 'errorNotConsoled' , array ( $ event [ 'typeStr' ] . ': ' . $ event [ 'file' ] . ' (line ' . $ event [ 'line' ] . '): ' . $ event [ 'message' ] ) , array ( 'channel' => 'phpError' , 'class' => $ event [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ? 'danger' : 'warning' , ) ) ; } 
public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ meta = \ array_merge ( array ( 'format' => 'raw' , 'requestId' => $ this -> requestId , ) , $ meta ) ; if ( $ meta [ 'channel' ] == $ this -> debug -> getCfg ( 'channel' ) ) { unset ( $ meta [ 'channel' ] ) ; } if ( $ meta [ 'format' ] == 'raw' ) { $ args = $ this -> crateValues ( $ args ) ; } if ( ! empty ( $ meta [ 'backtrace' ] ) ) { $ meta [ 'backtrace' ] = $ this -> crateValues ( $ meta [ 'backtrace' ] ) ; } $ this -> wamp -> publish ( $ this -> topic , array ( $ method , $ args , $ meta ) ) ; } 
private function crateValues ( $ values ) { $ prevIntK = null ; $ storeKeyOrder = false ; foreach ( $ values as $ k => $ v ) { if ( ! $ storeKeyOrder && \ is_int ( $ k ) ) { if ( $ k < $ prevIntK ) { $ storeKeyOrder = true ; } $ prevIntK = $ k ; } if ( \ is_array ( $ v ) ) { $ values [ $ k ] = self :: crateValues ( $ v ) ; } elseif ( \ is_string ( $ v ) && ! $ this -> debug -> utf8 -> isUtf8 ( $ v ) ) { $ values [ $ k ] = '_b64_:' . \ base64_encode ( $ v ) ; } } if ( $ storeKeyOrder ) { $ values [ '__debug_key_order__' ] = \ array_keys ( $ values ) ; } return $ values ; } 
private function processExistingData ( ) { $ data = $ this -> debug -> getData ( ) ; $ channelName = $ this -> debug -> getCfg ( 'channel' ) ; foreach ( $ data [ 'alerts' ] as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } foreach ( $ data [ 'logSummary' ] as $ priority => $ entries ) { $ this -> processLogEntryWEvent ( 'groupSummary' , array ( ) , array ( 'channel' => $ channelName , 'priority' => $ priority , ) ) ; foreach ( $ entries as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } $ this -> processLogEntryWEvent ( 'groupEnd' , array ( ) , array ( 'channel' => $ channelName , 'closesSummary' => true , ) ) ; } foreach ( $ data [ 'log' ] as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } } 
private function publishMeta ( ) { $ debugClass = \ get_class ( $ this -> debug ) ; $ metaVals = array ( 'debug_version' => $ debugClass :: VERSION , ) ; $ keys = array ( 'HTTP_HOST' , 'HTTPS' , 'REMOTE_ADDR' , 'REQUEST_METHOD' , 'REQUEST_TIME' , 'REQUEST_URI' , 'SERVER_ADDR' , 'SERVER_NAME' , ) ; foreach ( $ keys as $ k ) { $ metaVals [ $ k ] = isset ( $ _SERVER [ $ k ] ) ? $ _SERVER [ $ k ] : null ; } if ( ! isset ( $ metaVals [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ) { $ metaVals [ 'REQUEST_URI' ] = '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; } $ this -> processLogEntry ( 'meta' , array ( $ metaVals , ) , array ( 'channel' => $ this -> debug -> getCfg ( 'channel' ) , ) ) ; } 
public function getCfg ( $ path = null ) { if ( ! \ strlen ( $ path ) ) { return $ this -> cfg ; } if ( isset ( $ this -> cfg [ $ path ] ) ) { return $ this -> cfg [ $ path ] ; } return null ; } 
public function getAbstraction ( & $ mixed , $ method = null , $ hist = array ( ) ) { if ( \ is_array ( $ mixed ) ) { return $ this -> abstractArray -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_object ( $ mixed ) ) { return $ this -> abstractObject -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_resource ( $ mixed ) || \ strpos ( \ print_r ( $ mixed , true ) , 'Resource' ) === 0 ) { return array ( 'debug' => self :: ABSTRACTION , 'type' => 'resource' , 'value' => \ print_r ( $ mixed , true ) . ': ' . \ get_resource_type ( $ mixed ) , ) ; } } 
public static function getType ( $ val , & $ typeMore = null ) { if ( \ is_string ( $ val ) ) { $ type = 'string' ; if ( \ is_numeric ( $ val ) ) { $ typeMore = 'numeric' ; } elseif ( $ val === self :: UNDEFINED ) { $ type = 'undefined' ; 
public function alert ( $ message , $ class = 'danger' , $ dismissible = false ) { 
public function assert ( $ assertion , $ msg = null ) { 
public function clear ( $ flags = self :: CLEAR_LOG ) { Publish the debug.log event (regardless of cfg.collect) don't actually log */ $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ event ) ; } $ this -> cfg [ 'collect' ] = $ collect ; $ this -> setLogDest ( 'auto' ) ; } 
public function count ( $ label = null , $ flags = 0 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; 
public function countReset ( $ label = 'default' , $ flags = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; 
public function groupEnd ( $ value = \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'value' => \ bdk \ Debug \ Abstracter :: UNDEFINED ) ) ; \ extract ( $ args ) ; $ groupStackWas = $ this -> rootInstance -> groupStackRef ; $ appendLog = false ; if ( $ groupStackWas && \ end ( $ groupStackWas ) [ 'collect' ] == $ this -> cfg [ 'collect' ] ) { \ array_pop ( $ this -> rootInstance -> groupStackRef ) ; $ appendLog = $ this -> cfg [ 'collect' ] ; } if ( $ appendLog && $ value !== \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ this -> appendLog ( 'groupEndValue' , array ( 'return' , $ value ) , $ meta ) ; } if ( $ this -> data [ 'groupPriorityStack' ] && ! $ groupStackWas ) { Publish the debug.log event (regardless of cfg.collect) don't actually log */ $ meta [ 'closesSummary' ] = true ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; } elseif ( $ appendLog ) { $ this -> appendLog ( 'groupEnd' , array ( ) , $ meta ) ; } $ errorCaller = $ this -> errorHandler -> get ( 'errorCaller' ) ; if ( $ errorCaller && isset ( $ errorCaller [ 'groupDepth' ] ) && $ this -> getGroupDepth ( ) < $ errorCaller [ 'groupDepth' ] ) { $ this -> errorHandler -> setErrorCaller ( false ) ; } } 
public function groupSummary ( $ priority = 0 ) { Publish the debug.log event (regardless of cfg.collect) don't actually log */ $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; } 
public function groupUncollapse ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ curDepth = 0 ; foreach ( $ this -> rootInstance -> groupStackRef as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entryKeys = \ array_keys ( $ this -> internal -> getCurrentGroups ( $ this -> rootInstance -> logRef , $ curDepth ) ) ; foreach ( $ entryKeys as $ key ) { $ this -> rootInstance -> logRef [ $ key ] [ 0 ] = 'group' ; } $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; } 
public function profile ( $ name = null ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( ! $ this -> cfg [ 'enableProfiling' ] ) { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ this -> appendLog ( __FUNCTION__ , array ( 'Profile: Unable to start - enableProfiling opt not set. ' . $ callerInfo [ 'file' ] . ' on line ' . $ callerInfo [ 'line' ] . '.' ) ) ; return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) 
public function profileEnd ( $ name = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { \ end ( $ this -> data [ 'profileInstances' ] ) ; $ meta [ 'name' ] = \ key ( $ this -> data [ 'profileInstances' ] ) ; } $ name = $ meta [ 'name' ] ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ data = $ instance -> end ( ) ; $ caption = 'Profile \'' . $ name . '\' Results' ; if ( $ data ) { $ args = array ( $ data ) ; $ meta [ 'sortable' ] = true ; $ meta [ 'caption' ] = $ caption ; $ meta [ 'totalCols' ] = array ( 'ownTime' ) ; $ meta [ 'columns' ] = array ( ) ; } else { $ args = array ( $ caption , 'no data' ) ; } unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; } else { $ args = array ( $ name !== null ? 'profileEnd: No such Profile: ' . $ name : 'profileEnd: Not currently profiling' ) ; } $ this -> appendLog ( __FUNCTION__ , $ args , $ meta ) ; } 
public function table ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ event = $ this -> methodTable -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => $ args , 'meta' => $ meta , ) ) ) ; $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; } 
public function time ( $ label = null ) { $ args = \ func_get_args ( ) ; $ this -> internal -> getMetaVals ( $ args , array ( ) , array ( 'label' => null ) ) ; \ extract ( $ args ) ; if ( isset ( $ label ) ) { $ timers = & $ this -> data [ 'timers' ] [ 'labels' ] ; if ( ! isset ( $ timers [ $ label ] ) ) { 
public function timeEnd ( $ label = null , $ returnOrTemplate = false , $ precision = 4 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'label' => null , 'returnOrTemplate' => false , 'precision' => 4 , ) ) ; \ extract ( $ args ) ; if ( \ is_bool ( $ label ) || \ strpos ( $ label , '%time' ) !== false ) { if ( \ is_numeric ( $ returnOrTemplate ) ) { $ precision = $ returnOrTemplate ; } $ returnOrTemplate = $ label ; $ label = null ; } $ ret = $ this -> timeGet ( $ label , true , null ) ; 
public function timeGet ( $ label = null , $ returnOrTemplate = false , $ precision = 4 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'label' => null , 'returnOrTemplate' => false , 'precision' => 4 , ) ) ; \ extract ( $ args ) ; if ( \ is_bool ( $ label ) || \ strpos ( $ label , '%time' ) !== false ) { if ( \ is_numeric ( $ returnOrTemplate ) ) { $ precision = $ returnOrTemplate ; } $ returnOrTemplate = $ label ; $ label = null ; } $ microT = 0 ; $ ellapsed = 0 ; if ( ! isset ( $ label ) ) { $ label = 'time' ; if ( ! $ this -> data [ 'timers' ] [ 'stack' ] ) { list ( $ ellapsed , $ microT ) = $ this -> data [ 'timers' ] [ 'labels' ] [ 'debugInit' ] ; } else { $ microT = \ end ( $ this -> data [ 'timers' ] [ 'stack' ] ) ; } } elseif ( isset ( $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ) ) { list ( $ ellapsed , $ microT ) = $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ; } else { if ( $ returnOrTemplate !== true ) { $ this -> appendLog ( 'time' , array ( 'Timer \'' . $ label . '\' does not exist' ) , $ meta ) ; } return false ; } if ( $ microT ) { $ ellapsed += \ microtime ( true ) - $ microT ; } if ( \ is_int ( $ precision ) ) { 
public function timeLog ( $ label = null , $ args = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ microT = 0 ; $ ellapsed = 0 ; if ( \ count ( $ args ) === 0 ) { $ args [ 0 ] = 'time' ; if ( ! $ this -> data [ 'timers' ] [ 'stack' ] ) { list ( $ ellapsed , $ microT ) = $ this -> data [ 'timers' ] [ 'labels' ] [ 'debugInit' ] ; } else { $ microT = \ end ( $ this -> data [ 'timers' ] [ 'stack' ] ) ; } } elseif ( isset ( $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ) ) { list ( $ ellapsed , $ microT ) = $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ; } else { $ args = array ( 'Timer \'' . $ label . '\' does not exist' ) ; } if ( $ microT ) { $ args [ 0 ] .= ': ' ; $ ellapsed += \ microtime ( true ) - $ microT ; $ ellapsed = \ number_format ( $ ellapsed , 4 , '.' , '' ) ; \ array_splice ( $ args , 1 , 0 , $ ellapsed . ' sec' ) ; } $ this -> appendLog ( 'timeLog' , $ args , $ meta ) ; } 
public function trace ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'caption' => 'trace' , 'channel' => $ this -> cfg [ 'channel' ] , 'columns' => array ( 'file' , 'line' , 'function' ) , ) ) ; $ backtrace = $ this -> errorHandler -> backtrace ( ) ; 
public function getChannel ( $ channelName , $ config = array ( ) ) { if ( \ strpos ( $ channelName , '.' ) !== false ) { $ this -> error ( 'getChannel(): channelName should not contain period (.)' ) ; return $ this ; } if ( ! isset ( $ this -> channels [ $ channelName ] ) ) { 
public function getChannels ( $ allDescendants = false ) { if ( $ allDescendants ) { $ channels = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ channels = \ array_merge ( $ channels , array ( $ channel -> getCfg ( 'channel' ) => $ channel ) , $ channel -> getChannels ( true ) ) ; } return $ channels ; } return $ this -> channels ; } 
public function getData ( $ path = null ) { $ data = $ this -> utilities -> arrayPathGet ( $ this -> data , $ path ) ; return \ in_array ( $ path , array ( 'logSummary' , 'groupStacks' ) ) ? \ unserialize ( \ serialize ( $ data ) ) : $ data ; } 
public static function meta ( ) { $ args = \ func_get_args ( ) ; $ count = \ count ( $ args ) ; $ args = \ array_replace ( array ( null , null , null ) , $ args ) ; if ( \ is_array ( $ args [ 0 ] ) ) { $ args [ 0 ] [ 'debug' ] = self :: META ; return $ args [ 0 ] ; } if ( ! \ is_string ( $ args [ 0 ] ) ) { return array ( 'debug' => self :: META ) ; } if ( $ args [ 0 ] === 'cfg' ) { if ( \ is_array ( $ args [ 1 ] ) ) { return array ( 'cfg' => $ args [ 1 ] , 'debug' => self :: META , ) ; } if ( ! \ is_string ( $ args [ 1 ] ) ) { 
public function output ( $ options = array ( ) ) { $ cfgRestore = $ this -> config -> setCfg ( $ options ) ; if ( ! $ this -> cfg [ 'output' ] ) { $ this -> config -> setCfg ( $ cfgRestore ) ; return null ; } $ outputAs = $ this -> output -> getCfg ( 'outputAs' ) ; if ( \ is_string ( $ outputAs ) ) { $ this -> output -> setCfg ( 'outputAs' , $ outputAs ) ; } $ channels = $ this -> getChannels ( true ) ; $ channels [ ] = $ this ; $ headers = array ( ) ; foreach ( $ channels as $ channel ) { $ event = $ channel -> eventManager -> publish ( 'debug.output' , $ channel , array ( 'headers' => array ( ) , 'return' => '' , 'isTarget' => $ channel === $ this , ) ) ; $ headers = \ array_merge ( $ headers , $ event [ 'headers' ] ) ; } if ( ! $ this -> getCfg ( 'outputHeaders' ) || ! $ headers ) { $ this -> data [ 'headers' ] = \ array_merge ( $ this -> data [ 'headers' ] , $ event [ 'headers' ] ) ; } elseif ( \ headers_sent ( $ file , $ line ) ) { \ trigger_error ( 'PHPDebugConsole: headers already sent: ' . $ file . ', line ' . $ line , E_USER_NOTICE ) ; } else { foreach ( $ headers as $ nameVal ) { \ header ( $ nameVal [ 0 ] . ': ' . $ nameVal [ 1 ] ) ; } } if ( ! $ this -> parentInstance ) { $ this -> data [ 'outputSent' ] = true ; } $ this -> config -> setCfg ( $ cfgRestore ) ; return $ event [ 'return' ] ; } 
public function setData ( $ path , $ value = null ) { if ( \ is_string ( $ path ) ) { $ path = \ preg_split ( '#[\./]#' , $ path ) ; $ ref = & $ this -> data ; foreach ( $ path as $ k ) { $ ref = & $ ref [ $ k ] ; } $ ref = $ value ; } else { $ this -> data = \ array_merge ( $ this -> data , $ path ) ; } if ( ! $ this -> data [ 'log' ] ) { $ this -> data [ 'groupStacks' ] [ 'main' ] = array ( ) ; } if ( ! $ this -> data [ 'logSummary' ] ) { $ this -> data [ 'groupStacks' ] = \ array_intersect_key ( $ this -> data [ 'groupStacks' ] , array ( 'main' => true ) ) ; $ this -> data [ 'groupPriorityStack' ] = array ( ) ; } $ this -> setLogDest ( ) ; } 
public function setErrorCaller ( $ caller = null ) { if ( $ caller === null ) { $ caller = $ this -> utilities -> getCallerInfo ( 1 ) ; $ caller = array ( 'file' => $ caller [ 'file' ] , 'line' => $ caller [ 'line' ] , ) ; } if ( $ caller ) { 
protected function autoloader ( $ className ) { $ className = \ ltrim ( $ className , '\\' ) ; 
protected function appendLog ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ cfgRestore = array ( ) ; $ meta = \ array_merge ( array ( 'channel' => $ this -> cfg [ 'channel' ] ) , $ meta , $ this -> internal -> getMetaVals ( $ args ) ) ; if ( isset ( $ meta [ 'cfg' ] ) ) { $ cfgRestore = $ this -> config -> setCfg ( $ meta [ 'cfg' ] ) ; unset ( $ meta [ 'cfg' ] ) ; } foreach ( $ args as $ i => $ v ) { if ( $ this -> abstracter -> needsAbstraction ( $ v ) ) { $ args [ $ i ] = $ this -> abstracter -> getAbstraction ( $ v , $ method ) ; } } $ event = $ this -> eventManager -> publish ( 'debug.log' , $ this , array ( 'method' => $ method , 'args' => $ args , 'meta' => $ meta , 'appendLog' => true , 'return' => null , ) ) ; if ( $ cfgRestore ) { $ this -> config -> setCfg ( $ cfgRestore ) ; } if ( ! $ event -> getValue ( 'appendLog' ) ) { return $ event -> getValue ( 'return' ) ; } if ( $ this -> parentInstance ) { return $ this -> parentInstance -> appendLog ( $ event -> getValue ( 'method' ) , $ event -> getValue ( 'args' ) , $ event -> getValue ( 'meta' ) ) ; } $ this -> rootInstance -> logRef [ ] = array ( $ event -> getValue ( 'method' ) , $ event -> getValue ( 'args' ) , \ array_diff_assoc ( $ event -> getValue ( 'meta' ) , array ( 'channel' => $ this -> cfg [ 'channel' ] , ) ) , ) ; return $ event -> getValue ( 'return' ) ; } 
private function doGroup ( $ method , $ args ) { $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ this -> rootInstance -> groupStackRef [ ] = array ( 'channel' => $ meta [ 'channel' ] , 'collect' => $ this -> cfg [ 'collect' ] , ) ; if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( empty ( $ args ) ) { 
protected function doTime ( $ seconds , $ returnOrTemplate = false , $ label = 'time' , $ meta = array ( ) ) { if ( \ is_string ( $ returnOrTemplate ) ) { $ str = $ returnOrTemplate ; $ str = \ str_replace ( '%label' , $ label , $ str ) ; $ str = \ str_replace ( '%time' , $ seconds , $ str ) ; } elseif ( $ returnOrTemplate === true ) { return ; } else { $ str = $ label . ': ' . $ seconds . ' sec' ; } $ this -> appendLog ( 'time' , array ( $ str ) , $ meta ) ; } 
protected function getGroupDepth ( ) { $ depth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] as $ stack ) { $ depth += \ count ( $ stack ) ; } $ depth += \ count ( $ this -> data [ 'groupPriorityStack' ] ) ; return $ depth ; } 
private function getDefaultServices ( ) { return array ( 'abstracter' => function ( Debug $ debug ) { return new Debug \ Abstracter ( $ debug , $ debug -> config -> getCfgLazy ( 'abstracter' ) ) ; } , 'config' => function ( Debug $ debug ) { return new Debug \ Config ( $ debug , $ debug -> cfg ) ; log E_USER_ERROR to system_log without halting script */ $ errorHandler -> setCfg ( 'onEUserError' , 'log' ) ; return $ errorHandler ; } } , 'eventManager' => function ( ) { return new EventManager ( ) ; } , 'internal' => function ( Debug $ debug ) { return new Debug \ Internal ( $ debug ) ; } , 'logger' => function ( Debug $ debug ) { return new Debug \ Logger ( $ debug ) ; } , 'methodClear' => function ( Debug $ debug ) { return new Debug \ MethodClear ( $ debug , $ debug -> data ) ; } , 'methodTable' => function ( ) { return new Debug \ MethodTable ( ) ; } , 'output' => function ( Debug $ debug ) { $ output = new Debug \ Output ( $ debug , $ debug -> config -> getCfgLazy ( 'output' ) ) ; $ debug -> eventManager -> addSubscriberInterface ( $ output ) ; return $ output ; } , 'utf8' => function ( ) { return new Debug \ Utf8 ( ) ; } , 'utilities' => function ( ) { return new Debug \ Utilities ( ) ; } , ) ; } 
private static function getMethodDefaultArgs ( $ methodName ) { $ defaultArgs = array ( ) ; if ( isset ( self :: $ methodDefaultArgs [ $ methodName ] ) ) { $ defaultArgs = self :: $ methodDefaultArgs [ $ methodName ] ; } elseif ( \ method_exists ( self :: $ instance , $ methodName ) ) { $ reflectionMethod = new ReflectionMethod ( self :: $ instance , $ methodName ) ; $ params = $ reflectionMethod -> getParameters ( ) ; foreach ( $ params as $ reflectionParameter ) { $ defaultArgs [ ] = $ reflectionParameter -> isOptional ( ) ? $ reflectionParameter -> getDefaultValue ( ) : null ; } self :: $ methodDefaultArgs [ $ methodName ] = $ defaultArgs ; } return $ defaultArgs ; } 
private function setLogDest ( $ where = 'auto' ) { if ( $ where == 'auto' ) { $ where = $ this -> data [ 'groupPriorityStack' ] ? 'summary' : 'log' ; } if ( $ where == 'log' ) { $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'log' ] ; $ this -> rootInstance -> groupStackRef = & $ this -> rootInstance -> data [ 'groupStacks' ] [ 'main' ] ; } elseif ( $ where == 'alerts' ) { $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'alerts' ] ; } else { $ priority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; if ( ! isset ( $ this -> data [ 'logSummary' ] [ $ priority ] ) ) { $ this -> data [ 'logSummary' ] [ $ priority ] = array ( ) ; $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'logSummary' ] [ $ priority ] ; $ this -> rootInstance -> groupStackRef = & $ this -> rootInstance -> data [ 'groupStacks' ] [ $ priority ] ; } } 
public function log ( $ level , $ message , array $ context = array ( ) ) { if ( ! $ this -> isValidLevel ( $ level ) ) { throw new InvalidArgumentException ( ) ; } $ str = $ this -> interpolate ( $ message , $ context ) ; $ meta = $ this -> getMeta ( $ level , $ context ) ; if ( \ in_array ( $ level , array ( 'emergency' , 'critical' , 'error' ) ) ) { $ this -> debug -> error ( $ str , $ context , $ meta ) ; } elseif ( \ in_array ( $ level , array ( 'warning' , 'notice' ) ) ) { $ this -> debug -> warn ( $ str , $ context , $ meta ) ; } elseif ( $ level == 'alert' ) { $ this -> debug -> alert ( $ str ) ; } elseif ( $ level == 'info' ) { $ this -> debug -> info ( $ str , $ context ) ; } else { $ this -> debug -> log ( $ str , $ context ) ; } } 
protected function getMeta ( $ level , & $ context ) { $ haveException = isset ( $ context [ 'exception' ] ) && ( $ context [ 'exception' ] instanceof \ Exception || PHP_VERSION_ID >= 70000 && $ context [ 'exception' ] instanceof \ Throwable ) ; $ isError = \ in_array ( $ level , array ( 'emergency' , 'critical' , 'error' , 'warning' , 'notice' ) ) ; $ metaVals = \ array_intersect_key ( $ context , \ array_flip ( array ( 'file' , 'line' ) ) ) ; $ metaVals [ 'psr3level' ] = $ level ; $ context = \ array_diff_key ( $ context , $ metaVals ) ; if ( $ haveException ) { $ exception = $ context [ 'exception' ] ; $ metaVals = \ array_merge ( array ( 'backtrace' => $ this -> debug -> errorHandler -> backtrace ( $ exception ) , 'file' => $ exception -> getFile ( ) , 'line' => $ exception -> getLine ( ) , ) , $ metaVals ) ; } elseif ( $ isError && \ count ( $ metaVals ) < 2 ) { $ callerInfo = $ this -> debug -> utilities -> getCallerInfo ( 1 ) ; $ metaVals = \ array_merge ( array ( 'file' => $ callerInfo [ 'file' ] , 'line' => $ callerInfo [ 'line' ] , ) , $ metaVals ) ; } if ( ! $ context ) { $ context = $ this -> debug -> meta ( ) ; } return $ this -> debug -> meta ( $ metaVals ) ; } 
protected function interpolate ( $ message , array & $ context = array ( ) ) { 
public static function arrayMergeDeep ( $ arrayDef , $ array2 ) { if ( ! \ is_array ( $ arrayDef ) || self :: isCallable ( $ arrayDef ) ) { 
public static function arrayPathGet ( $ array , $ path ) { if ( ! \ is_array ( $ path ) ) { $ path = \ array_filter ( \ preg_split ( '#[\./]#' , $ path ) , 'strlen' ) ; } $ path = \ array_reverse ( $ path ) ; while ( $ path ) { $ key = \ array_pop ( $ path ) ; $ arrayAccess = \ is_array ( $ array ) || $ array instanceof \ ArrayAccess ; if ( ! $ arrayAccess ) { return null ; } elseif ( isset ( $ array [ $ key ] ) ) { $ array = $ array [ $ key ] ; } elseif ( $ key == '__count__' ) { return \ count ( $ array ) ; } elseif ( $ key == '__end__' ) { \ end ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } elseif ( $ key == '__reset__' ) { \ reset ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } else { return null ; } } return $ array ; } 
public static function buildAttribString ( $ attribs ) { if ( \ is_string ( $ attribs ) ) { return \ rtrim ( ' ' . \ trim ( $ attribs ) ) ; } $ attribPairs = array ( ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_int ( $ k ) ) { $ k = $ v ; $ v = true ; } $ k = \ strtolower ( $ k ) ; if ( \ strpos ( $ k , 'data-' ) === 0 ) { $ v = \ json_encode ( $ v ) ; $ v = \ trim ( $ v , '"' ) ; } elseif ( \ is_bool ( $ v ) ) { $ v = self :: buildAttribBoolVal ( $ k , $ v ) ; } elseif ( \ is_array ( $ v ) || $ k === 'class' ) { $ v = self :: buildAttribArrayVal ( $ k , $ v ) ; } if ( \ array_filter ( array ( $ v === null , $ v === '' && \ in_array ( $ k , array ( 'class' , 'style' ) ) ) ) ) { 
public static function buildTag ( $ tagName , $ attribs = array ( ) , $ innerhtml = '' ) { $ tagName = \ strtolower ( $ tagName ) ; $ attribStr = self :: buildAttribString ( $ attribs ) ; return \ in_array ( $ tagName , self :: $ htmlEmptyTags ) ? '<' . $ tagName . $ attribStr . ' />' : '<' . $ tagName . $ attribStr . '>' . $ innerhtml . '</' . $ tagName . '>' ; } 
public static function getAllHeaders ( ) { if ( \ function_exists ( 'getallheaders' ) ) { return \ getallheaders ( ) ; } $ headers = array ( ) ; $ copyServer = array ( 'CONTENT_TYPE' => 'Content-Type' , 'CONTENT_LENGTH' => 'Content-Length' , 'CONTENT_MD5' => 'Content-Md5' , ) ; foreach ( $ _SERVER as $ key => $ value ) { if ( \ substr ( $ key , 0 , 5 ) === 'HTTP_' ) { $ key = \ substr ( $ key , 5 ) ; if ( ! isset ( $ copyServer [ $ key ] ) || ! isset ( $ _SERVER [ $ key ] ) ) { $ key = \ str_replace ( ' ' , '-' , \ ucwords ( \ strtolower ( \ str_replace ( '_' , ' ' , $ key ) ) ) ) ; $ headers [ $ key ] = $ value ; } } elseif ( isset ( $ copyServer [ $ key ] ) ) { $ headers [ $ copyServer [ $ key ] ] = $ value ; } } if ( ! isset ( $ headers [ 'Authorization' ] ) ) { if ( isset ( $ _SERVER [ 'REDIRECT_HTTP_AUTHORIZATION' ] ) ) { $ headers [ 'Authorization' ] = $ _SERVER [ 'REDIRECT_HTTP_AUTHORIZATION' ] ; } elseif ( isset ( $ _SERVER [ 'PHP_AUTH_USER' ] ) ) { $ basicPass = isset ( $ _SERVER [ 'PHP_AUTH_PW' ] ) ? $ _SERVER [ 'PHP_AUTH_PW' ] : '' ; $ headers [ 'Authorization' ] = 'Basic ' . \ base64_encode ( $ _SERVER [ 'PHP_AUTH_USER' ] . ':' . $ basicPass ) ; } elseif ( isset ( $ _SERVER [ 'PHP_AUTH_DIGEST' ] ) ) { $ headers [ 'Authorization' ] = $ _SERVER [ 'PHP_AUTH_DIGEST' ] ; } } return $ headers ; } 
public static function getBytes ( $ size ) { if ( \ is_string ( $ size ) && \ preg_match ( '/^([\d,.]+)\s?([kmgtp])b?$/i' , $ size , $ matches ) ) { $ size = \ str_replace ( ',' , '' , $ matches [ 1 ] ) ; switch ( \ strtolower ( $ matches [ 2 ] ) ) { case 'p' : $ size *= 1024 ; 
public static function getCallerInfo ( $ offset = 0 ) { $ return = array ( 'file' => null , 'line' => null , 'function' => null , 'class' => null , 'type' => null , ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS | DEBUG_BACKTRACE_PROVIDE_OBJECT , 8 ) ; $ numFrames = \ count ( $ backtrace ) ; $ regexInternal = '/^' . \ preg_quote ( __NAMESPACE__ ) . '\b/' ; if ( isset ( $ backtrace [ 1 ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ 1 ] [ 'class' ] ) ) { 
public static function getIncludedFiles ( ) { $ includedFiles = \ get_included_files ( ) ; \ usort ( $ includedFiles , function ( $ valA , $ valB ) { $ dirA = \ dirname ( $ valA ) ; $ dirB = \ dirname ( $ valB ) ; return $ dirA == $ dirB ? \ strnatcasecmp ( $ valA , $ valB ) : \ strnatcasecmp ( $ dirA , $ dirB ) ; } ) ; return $ includedFiles ; } 
public static function getInterface ( ) { $ return = 'http' ; $ isCliOrCron = \ count ( \ array_filter ( array ( \ defined ( 'STDIN' ) , isset ( $ _SERVER [ 'argv' ] ) , ! \ array_key_exists ( 'REQUEST_METHOD' , $ _SERVER ) , ) ) ) > 0 ; if ( $ isCliOrCron ) { 
public static function getResponseHeader ( $ key = 'Content-Type' ) { $ value = null ; $ headers = \ headers_list ( ) ; foreach ( $ headers as $ header ) { if ( \ preg_match ( '/^' . $ key . ':\s*([^;]*)/i' , $ header , $ matches ) ) { $ value = $ matches [ 1 ] ; break ; } } return $ value ; } 
public static function isList ( $ val ) { if ( ! \ is_array ( $ val ) ) { return false ; } $ keys = \ array_keys ( $ val ) ; foreach ( $ keys as $ i => $ key ) { if ( $ i != $ key ) { return false ; } } return true ; } 
public static function parseAttribString ( $ str , $ dataDecode = true ) { $ attribs = array ( ) ; $ regexAttribs = '/\b([\w\-]+)\b(?: \s*=\s*(["\'])(.*?)\\2 | \s*=\s*(\S+) )?/xs' ; \ preg_match_all ( $ regexAttribs , $ str , $ matches ) ; $ keys = \ array_map ( 'strtolower' , $ matches [ 1 ] ) ; $ values = \ array_replace ( $ matches [ 3 ] , \ array_filter ( $ matches [ 4 ] , 'strlen' ) ) ; foreach ( $ keys as $ i => $ k ) { $ attribs [ $ k ] = $ values [ $ i ] ; if ( \ in_array ( $ k , self :: $ htmlBoolAttr ) ) { $ attribs [ $ k ] = true ; } } \ ksort ( $ attribs ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_string ( $ v ) ) { $ attribs [ $ k ] = \ htmlspecialchars_decode ( $ v ) ; } $ isDataAttrib = \ strpos ( $ k , 'data-' ) === 0 ; if ( $ isDataAttrib && $ dataDecode ) { $ val = $ attribs [ $ k ] ; $ attribs [ $ k ] = \ json_decode ( $ attribs [ $ k ] , true ) ; if ( $ attribs [ $ k ] === null && $ val !== 'null' ) { $ attribs [ $ k ] = \ json_decode ( '"' . $ val . '"' , true ) ; } } } return $ attribs ; } 
public static function parseTag ( $ tag ) { $ regexTag = '#<([^\s>]+)([^>]*)>(.*)</\\1>#is' ; $ regexTag2 = '#^<(?:\/\s*)?([^\s>]+)(.*?)\/?>$#s' ; $ tag = \ trim ( $ tag ) ; if ( \ preg_match ( $ regexTag , $ tag , $ matches ) ) { $ return = array ( 'tagname' => $ matches [ 1 ] , 'attribs' => self :: parseAttribString ( $ matches [ 2 ] ) , 'innerhtml' => $ matches [ 3 ] , ) ; } elseif ( \ preg_match ( $ regexTag2 , $ tag , $ matches ) ) { $ return = array ( 'tagname' => $ matches [ 1 ] , 'attribs' => self :: parseAttribString ( $ matches [ 2 ] ) , 'innerhtml' => null , ) ; } return $ return ; } 
public static function requestId ( ) { return \ hash ( 'crc32b' , ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) ? $ _SERVER [ 'REMOTE_ADDR' ] : 'terminal' ) . ( isset ( $ _SERVER [ 'REQUEST_TIME_FLOAT' ] ) ? $ _SERVER [ 'REQUEST_TIME_FLOAT' ] : $ _SERVER [ 'REQUEST_TIME' ] ) . ( isset ( $ _SERVER [ 'REMOTE_PORT' ] ) ? $ _SERVER [ 'REMOTE_PORT' ] : '' ) ) ; } 
public static function serializeLog ( $ data ) { $ str = \ serialize ( $ data ) ; if ( \ function_exists ( 'gzdeflate' ) ) { $ str = \ gzdeflate ( $ str ) ; } $ str = \ chunk_split ( \ base64_encode ( $ str ) , 124 ) ; return "START DEBUG\n" . $ str 
public static function unserializeLog ( $ str ) { $ strStart = 'START DEBUG' ; $ strEnd = 'END DEBUG' ; if ( \ preg_match ( '/' . $ strStart . '[\r\n]+(.+)[\r\n]+' . $ strEnd . '/s' , $ str , $ matches ) ) { $ str = $ matches [ 1 ] ; } $ str = self :: isBase64Encoded ( $ str ) ? \ base64_decode ( $ str ) : false ; if ( $ str && \ function_exists ( 'gzinflate' ) ) { $ strInflated = \ gzinflate ( $ str ) ; if ( $ strInflated ) { $ str = $ strInflated ; } } $ data = \ unserialize ( $ str ) ; return $ data ; } 
private static function buildAttribArrayVal ( $ key , $ value = array ( ) ) { if ( $ key == 'class' ) { if ( ! \ is_array ( $ value ) ) { $ value = \ explode ( ' ' , $ value ) ; } $ value = \ array_filter ( \ array_unique ( $ value ) ) ; \ sort ( $ value ) ; $ value = \ implode ( ' ' , $ value ) ; } elseif ( $ key == 'style' ) { $ keyValues = array ( ) ; foreach ( $ value as $ k => $ v ) { $ keyValues [ ] = $ k . ':' . $ v . ';' ; } \ sort ( $ keyValues ) ; $ value = \ implode ( '' , $ keyValues ) ; } else { $ value = null ; } return $ value ; } 
private static function buildAttribBoolVal ( $ key , $ value = true ) { if ( $ key == 'autocomplete' ) { $ value = $ value ? 'on' : 'off' ; } elseif ( $ key == 'spellcheck' ) { $ value = $ value ? 'true' : 'false' ; } elseif ( $ key == 'translate' ) { $ value = $ value ? 'yes' : 'no' ; } elseif ( $ value ) { 
public function getCfg ( $ path = null ) { if ( $ path == 'outputAs' ) { $ ret = $ this -> cfg [ 'outputAs' ] ; if ( ! $ ret ) { $ ret = $ this -> getDefaultOutputAs ( ) ; } } elseif ( $ path == 'css' ) { $ ret = $ this -> getCss ( ) ; } else { $ ret = $ this -> debug -> utilities -> arrayPathGet ( $ this -> cfg , $ path ) ; } return $ ret ; } 
public function onOutput ( Event $ event ) { if ( ! $ event [ 'isTarget' ] ) { return ; } $ this -> data = $ this -> debug -> getData ( ) ; $ this -> closeOpenGroups ( ) ; foreach ( $ this -> data [ 'logSummary' ] as & $ log ) { $ this -> removeHideIfEmptyGroups ( $ log ) ; $ this -> uncollapseErrors ( $ log ) ; } $ this -> removeHideIfEmptyGroups ( $ this -> data [ 'log' ] ) ; $ this -> uncollapseErrors ( $ this -> data [ 'log' ] ) ; $ this -> debug -> setData ( $ this -> data ) ; } 
public function setCfg ( $ mixed , $ newVal = null ) { $ ret = null ; $ values = array ( ) ; if ( \ is_string ( $ mixed ) ) { $ key = $ mixed ; $ ret = isset ( $ this -> cfg [ $ key ] ) ? $ this -> cfg [ $ key ] : null ; $ values = array ( $ key => $ newVal , ) ; } elseif ( \ is_array ( $ mixed ) ) { $ values = $ mixed ; } if ( isset ( $ values [ 'outputAs' ] ) ) { $ this -> setOutputAs ( $ values [ 'outputAs' ] ) ; unset ( $ values [ 'outputAs' ] ) ; Replace - not append - subscriber set via setCfg */ if ( isset ( $ this -> cfg [ 'onOutput' ] ) ) { $ this -> debug -> eventManager -> unsubscribe ( 'debug.output' , $ this -> cfg [ 'onOutput' ] ) ; } $ this -> debug -> eventManager -> subscribe ( 'debug.output' , $ values [ 'onOutput' ] ) ; } $ this -> cfg = $ this -> debug -> utilities -> arrayMergeDeep ( $ this -> cfg , $ values ) ; return $ ret ; } 
private function closeOpenGroups ( ) { $ this -> data [ 'groupPriorityStack' ] [ ] = 'main' ; while ( $ this -> data [ 'groupPriorityStack' ] ) { $ priority = \ array_pop ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ i => $ info ) { if ( $ info [ 'collect' ] ) { unset ( $ this -> data [ 'groupStacks' ] [ $ priority ] [ $ i ] ) ; $ meta = array ( 'channel' => $ info [ 'channel' ] , ) ; if ( $ priority === 'main' ) { $ this -> data [ 'log' ] [ ] = array ( 'groupEnd' , array ( ) , $ meta ) ; } else { $ this -> data [ 'logSummary' ] [ $ priority ] [ ] = array ( 'groupEnd' , array ( ) , $ meta ) ; } } } } } 
private function getDefaultOutputAs ( ) { $ ret = 'html' ; $ interface = $ this -> debug -> utilities -> getInterface ( ) ; if ( $ interface == 'ajax' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } elseif ( $ interface == 'http' ) { $ contentType = $ this -> debug -> utilities -> getResponseHeader ( ) ; if ( $ contentType && $ contentType !== 'text/html' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } } else { $ ret = 'text' ; } return $ ret ; } 
private function removeHideIfEmptyGroups ( & $ log ) { $ groupStack = array ( ) ; $ groupStackCount = 0 ; $ removed = false ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ entry = $ log [ $ i ] ; $ groupStack [ ] = array ( 'i' => $ i , 'meta' => ! empty ( $ entry [ 2 ] ) ? $ entry [ 2 ] : array ( ) , 'hasEntries' => false , ) ; $ groupStackCount ++ ; } elseif ( $ method == 'groupEnd' ) { $ group = \ end ( $ groupStack ) ; if ( ! $ group [ 'hasEntries' ] && ! empty ( $ group [ 'meta' ] [ 'hideIfEmpty' ] ) ) { 
private function setOutputAs ( $ outputAs ) { if ( \ is_object ( $ this -> cfg [ 'outputAs' ] ) ) { $ this -> debug -> removePlugin ( $ this -> cfg [ 'outputAs' ] ) ; $ this -> cfg [ 'outputAs' ] = null ; } $ prop = null ; $ obj = null ; if ( \ is_string ( $ outputAs ) ) { $ prop = $ outputAs ; $ classname = __NAMESPACE__ . '\\Output\\' . \ ucfirst ( $ outputAs ) ; if ( \ property_exists ( $ this , $ prop ) ) { $ obj = $ this -> { $ prop } ; } elseif ( \ class_exists ( $ classname ) ) { $ obj = new $ classname ( $ this -> debug ) ; } } elseif ( $ outputAs instanceof OutputInterface ) { $ classname = \ get_class ( $ outputAs ) ; $ prefix = __NAMESPACE__ . '\\Output\\' ; if ( \ strpos ( $ classname , $ prefix ) == 0 ) { $ prop = \ substr ( $ classname , \ strlen ( $ prefix ) ) ; $ prop = \ lcfirst ( $ prop ) ; } $ obj = $ outputAs ; } if ( $ obj ) { $ this -> debug -> addPlugin ( $ obj ) ; $ this -> cfg [ 'outputAs' ] = $ obj ; if ( $ prop ) { $ this -> { $ prop } = $ obj ; } } } 
private function uncollapseErrors ( & $ log ) { $ groupStack = array ( ) ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ groupStack [ ] = $ i ; } elseif ( $ method == 'groupEnd' ) { \ array_pop ( $ groupStack ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { foreach ( $ groupStack as $ i2 ) { $ log [ $ i2 ] [ 0 ] = 'group' ; } } } } 
public function end ( ) { \ unregister_tick_function ( array ( $ this , 'tickFunction' ) ) ; while ( $ this -> funcStack ) { $ this -> popStack ( ) ; } 
public function start ( ) { if ( $ this -> isProfiling ) { return false ; } $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS ) ; $ backtrace = $ this -> backtraceRemoveInternal ( $ backtrace ) ; foreach ( $ backtrace as $ frame ) { $ class = isset ( $ frame [ 'class' ] ) ? $ frame [ 'class' ] . '::' : '' ; $ this -> rootStack [ ] = $ class . $ frame [ 'function' ] ; } \ register_tick_function ( array ( $ this , 'tickFunction' ) ) ; $ this -> isProfiling = true ; $ this -> timeLastTick = \ microtime ( true ) ; return true ; } 
public function tickFunction ( ) { $ trace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS ) ; $ stackCount = \ count ( $ trace ) - \ count ( $ this -> rootStack ) - 1 ; $ stackCountInternal = \ count ( $ this -> funcStack ) ; $ class = isset ( $ trace [ 1 ] [ 'class' ] ) ? $ trace [ 1 ] [ 'class' ] : null ; if ( $ stackCount === 0 && $ this -> data ) { $ function = \ ltrim ( $ class . '::' . $ trace [ 1 ] [ 'function' ] , ':' ) ; if ( $ function !== $ this -> rootStack [ 0 ] ) { 
protected function backtraceRemoveInternal ( $ backtrace ) { $ count = \ count ( $ backtrace ) ; for ( $ i = $ count - 1 ; $ i > 0 ; $ i -- ) { $ frame = $ backtrace [ $ i ] ; if ( isset ( $ frame [ 'class' ] ) && \ strpos ( $ frame [ 'class' ] , __NAMESPACE__ ) === 0 ) { break ; } } $ i ++ ; return \ array_slice ( $ backtrace , $ i ) ; } 
protected function popStack ( ) { $ stackInfo = \ array_pop ( $ this -> funcStack ) ; $ funcPopped = $ stackInfo [ 'function' ] ; $ timeElapsed = \ microtime ( true ) - $ stackInfo [ 'tsStart' ] ; $ this -> data [ $ funcPopped ] [ 'ownTime' ] += $ timeElapsed - $ stackInfo [ 'subTime' ] ; $ this -> data [ $ funcPopped ] [ 'totalTime' ] += $ timeElapsed ; if ( $ this -> data [ $ funcPopped ] [ 'calls' ] === 0 ) { $ this -> data [ $ funcPopped ] [ 'calls' ] ++ ; } if ( $ this -> funcStack ) { $ this -> funcStack [ \ count ( $ this -> funcStack ) - 1 ] [ 'subTime' ] += $ timeElapsed ; } return $ stackInfo [ 'function' ] ; } 
protected function pushStack ( $ funcName ) { $ this -> funcStack [ ] = array ( 'function' => $ funcName , 'tsStart' => $ this -> timeLastTick , 'subTime' => 0 , 
public function getCfg ( $ path = '' ) { $ path = $ this -> normalizePath ( $ path ) ; $ path = \ array_filter ( \ preg_split ( '#[\./]#' , $ path ) , 'strlen' ) ; if ( empty ( $ path ) ) { return $ this -> getCfgAll ( ) ; } $ classname = \ array_shift ( $ path ) ; if ( $ classname == 'debug' ) { return $ this -> debug -> utilities -> arrayPathGet ( $ this -> cfg , $ path ) ; } elseif ( isset ( $ this -> debug -> { $ classname } ) && \ is_object ( $ this -> debug -> { $ classname } ) ) { $ pathRel = \ implode ( '/' , $ path ) ; return $ this -> debug -> { $ classname } -> getCfg ( $ pathRel ) ; } if ( isset ( $ this -> cfgLazy [ $ classname ] ) && $ path ) { 
public function getCfgLazy ( $ name ) { if ( ! isset ( $ this -> cfgLazy [ $ name ] ) ) { return array ( ) ; } $ return = $ this -> cfgLazy [ $ name ] ; unset ( $ this -> cfgLazy [ $ name ] ) ; return $ return ; } 
public function setCfg ( $ pathOrVals , $ val = null ) { if ( \ is_array ( $ pathOrVals ) ) { $ cfg = $ this -> normalizeArray ( $ pathOrVals ) ; } else { $ path = $ this -> normalizePath ( $ pathOrVals ) ; $ cfg = $ this -> keyValToArray ( $ path , $ val ) ; } $ cfg = $ this -> setCopyValues ( $ cfg ) ; $ return = $ this -> doSetCfg ( $ cfg ) ; if ( isset ( $ this -> cfgLazy [ 'output' ] [ 'outputAs' ] ) ) { $ lazyPlugins = array ( 'chromeLogger' , 'firephp' , 'html' , 'script' , 'text' ) ; if ( \ is_object ( $ this -> cfgLazy [ 'output' ] [ 'outputAs' ] ) || ! \ in_array ( $ this -> cfgLazy [ 'output' ] [ 'outputAs' ] , $ lazyPlugins ) ) { 
private function debugKeyValues ( $ key ) { $ values = array ( ) ; 
private function doSetCfg ( $ cfg ) { $ return = array ( ) ; foreach ( $ cfg as $ k => $ v ) { if ( $ k == 'debug' ) { $ return [ $ k ] = \ array_intersect_key ( $ this -> cfg , $ v ) ; $ this -> setDebugCfg ( $ v ) ; } elseif ( isset ( $ this -> debug -> { $ k } ) && \ is_object ( $ this -> debug -> { $ k } ) ) { $ return [ $ k ] = \ array_intersect_key ( $ this -> getCfg ( $ k . '/*' ) , $ v ) ; $ this -> debug -> { $ k } -> setCfg ( $ v ) ; } elseif ( isset ( $ this -> cfgLazy [ $ k ] ) ) { $ return [ $ k ] = \ array_intersect_key ( $ this -> cfgLazy [ $ k ] , $ v ) ; $ this -> cfgLazy [ $ k ] = \ array_merge ( $ this -> cfgLazy [ $ k ] , $ v ) ; } else { $ return [ $ k ] = array ( ) ; $ this -> cfgLazy [ $ k ] = $ v ; } } return $ return ; } 
private function getCfgAll ( ) { $ cfg = array ( ) ; foreach ( \ array_keys ( $ this -> configKeys ) as $ classname ) { if ( $ classname === 'debug' ) { $ cfg [ 'debug' ] = $ this -> cfg ; } elseif ( isset ( $ this -> debug -> { $ classname } ) ) { $ cfg [ $ classname ] = $ this -> debug -> { $ classname } -> getCfg ( ) ; } elseif ( isset ( $ this -> cfgLazy [ $ classname ] ) ) { $ cfg [ $ classname ] = $ this -> cfgLazy [ $ classname ] ; } } return $ cfg ; } 
private function getConfigKeys ( ) { if ( isset ( $ this -> configKeys ) ) { return $ this -> configKeys ; } $ this -> configKeys = array ( 'debug' => array ( 
private function keyValToArray ( $ key , $ val ) { $ new = array ( ) ; $ path = \ preg_split ( '#[\./]#' , $ key ) ; $ ref = & $ new ; foreach ( $ path as $ k ) { $ ref [ $ k ] = array ( ) ; 
private function normalizeArray ( $ cfg ) { $ return = array ( 'debug' => array ( ) , 
private function normalizePath ( $ path ) { $ path = \ array_filter ( \ preg_split ( '#[\./]#' , $ path ) , 'strlen' ) ; if ( \ count ( $ path ) == 0 || $ path [ 0 ] == '*' ) { return '' ; } $ configKeys = $ this -> getConfigKeys ( ) ; $ found = false ; foreach ( $ configKeys as $ objName => $ objKeys ) { if ( \ in_array ( $ path [ 0 ] , $ objKeys ) && $ objName !== 'debug' ) { $ found = true ; \ array_unshift ( $ path , $ objName ) ; break ; } if ( $ path [ 0 ] == $ objName && ! empty ( $ path [ 1 ] ) ) { $ found = true ; break ; } } if ( ! $ found ) { 
private function setCopyValues ( $ values ) { if ( isset ( $ values [ 'debug' ] [ 'emailLog' ] ) && $ values [ 'debug' ] [ 'emailLog' ] === true ) { $ values [ 'debug' ] [ 'emailLog' ] = 'onError' ; } foreach ( array ( 'emailFrom' , 'emailFunc' , 'emailTo' ) as $ key ) { if ( isset ( $ values [ 'debug' ] [ $ key ] ) && ! isset ( $ values [ 'errorEmailer' ] [ $ key ] ) ) { 
private function setDebugCfg ( $ cfg ) { if ( isset ( $ cfg [ 'key' ] ) ) { $ cfg = \ array_merge ( $ cfg , $ this -> debugKeyValues ( $ cfg [ 'key' ] ) ) ; } if ( isset ( $ cfg [ 'logEnvInfo' ] ) && \ is_bool ( $ cfg [ 'logEnvInfo' ] ) ) { $ keys = \ array_keys ( $ this -> cfg [ 'logEnvInfo' ] ) ; $ cfg [ 'logEnvInfo' ] = \ array_fill_keys ( $ keys , $ cfg [ 'logEnvInfo' ] ) ; } if ( isset ( $ cfg [ 'logServerKeys' ] ) ) { 
public function onConfig ( Event $ event ) { $ file = $ this -> debug -> getCfg ( 'file' ) ; $ this -> setFile ( $ file ) ; } 
public function onLog ( Event $ event ) { if ( ! $ this -> fileHandle ) { return ; } $ method = $ event [ 'method' ] ; if ( $ method == 'groupUncollapse' ) { return ; } $ args = $ event [ 'args' ] ; $ meta = $ event [ 'meta' ] ; $ isSummaryBookend = $ method == 'groupSummary' || ! empty ( $ meta [ 'closesSummary' ] ) ; if ( $ isSummaryBookend ) { \ fwrite ( $ this -> fileHandle , "=========\n" ) ; return ; } if ( $ args ) { $ str = $ this -> processLogEntryWEvent ( $ method , $ args , $ meta ) ; \ fwrite ( $ this -> fileHandle , $ str ) ; } elseif ( $ method == 'groupEnd' && $ this -> depth > 0 ) { $ this -> depth -- ; } } 
protected function setFile ( $ file ) { if ( $ file == $ this -> file ) { 
public function dump ( $ val ) { $ typeMore = null ; $ type = $ this -> debug -> abstracter -> getType ( $ val , $ typeMore ) ; if ( $ typeMore == 'raw' ) { $ val = $ this -> debug -> abstracter -> getAbstraction ( $ val ) ; $ typeMore = null ; } elseif ( $ typeMore == 'abstraction' ) { $ typeMore = null ; } $ method = 'dump' . \ ucfirst ( $ type ) ; $ return = $ this -> { $ method } ( $ val ) ; $ this -> dumpType = $ type ; $ this -> dumpTypeMore = $ typeMore ; return $ return ; } 
protected function checkTimestamp ( $ val ) { $ secs = 86400 * 90 ; 
protected function dumpFloat ( $ val ) { $ date = $ this -> checkTimestamp ( $ val ) ; return $ date ? $ val . ' (' . $ date . ')' : $ val ; } 
protected function dumpObject ( $ abs ) { if ( $ abs [ 'isRecursion' ] ) { $ return = '(object) ' . $ abs [ 'className' ] . ' *RECURSION*' ; } elseif ( $ abs [ 'isExcluded' ] ) { $ return = '(object) ' . $ abs [ 'className' ] . ' (not inspected)' ; } else { $ return = array ( '___class_name' => $ abs [ 'className' ] , ) ; foreach ( $ abs [ 'properties' ] as $ name => $ info ) { $ vis = ( array ) $ info [ 'visibility' ] ; foreach ( $ vis as $ i => $ v ) { if ( \ in_array ( $ v , array ( 'magic' , 'magic-read' , 'magic-write' ) ) ) { $ vis [ $ i ] = '✨ '.$ v ; "sparkles": there is no magic-want unicode char } elseif ( $ v == 'private' && $ info [ 'inheritedFrom' ] ) { $ vis [ $ i ] = '🔒 '.$v ; } } if ( $ info [ 'isExcluded' ] ) { $ vis [ ] = 'excluded' ; } $ name = '(' . \ implode ( ' ' , $ vis ) . ') ' . $ name ; $ return [ $ name ] = $ this -> dump ( $ info [ 'value' ] ) ; } } return $ return ; } 
protected function dumpString ( $ val ) { if ( \ is_numeric ( $ val ) ) { $ date = $ this -> checkTimestamp ( $ val ) ; return $ date ? $ val . ' (' . $ date . ')' : $ val ; } else { return $ this -> debug -> utf8 -> dump ( $ val ) ; } } 
protected function methodAlert ( $ args , $ meta ) { $ classToMethod = array ( 'danger' => 'error' , 'info' => 'info' , 'success' => 'info' , 'warning' => 'warn' , ) ; $ msg = \ str_replace ( '<br />' , ", \n" , $ args [ 0 ] ) ; $ method = $ meta [ 'class' ] ; if ( isset ( $ classToMethod [ $ method ] ) ) { $ method = $ classToMethod [ $ method ] ; } return array ( $ method , array ( $ msg ) ) ; } 
protected function methodTable ( $ array , $ columns = array ( ) ) { if ( ! \ is_array ( $ array ) ) { return $ this -> dump ( $ array ) ; } $ keys = $ columns ? : $ this -> debug -> methodTable -> colKeys ( $ array ) ; $ table = array ( ) ; $ classnames = array ( ) ; if ( $ this -> debug -> abstracter -> isAbstraction ( $ array ) && $ array [ 'traverseValues' ] ) { $ array = $ array [ 'traverseValues' ] ; } foreach ( $ array as $ k => $ row ) { $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; $ values = $ this -> methodTableCleanValues ( $ values ) ; $ table [ $ k ] = $ values ; $ classnames [ $ k ] = $ objInfo [ 'row' ] ? $ objInfo [ 'row' ] [ 'className' ] : '' ; } if ( \ array_filter ( $ classnames ) ) { foreach ( $ classnames as $ k => $ classname ) { $ table [ $ k ] = \ array_merge ( array ( '___class_name' => $ classname ) , $ table [ $ k ] ) ; } } return $ table ; } 
private function methodTableCleanValues ( $ values ) { foreach ( $ values as $ k2 => $ val ) { if ( $ val === $ this -> debug -> abstracter -> UNDEFINED ) { unset ( $ values [ $ k2 ] ) ; } elseif ( \ is_array ( $ val ) ) { $ values [ $ k2 ] = $ this -> debug -> output -> text -> dump ( $ val ) ; } } if ( \ count ( $ values ) == 1 && $ k2 == MethodTable :: SCALAR ) { $ values = $ val ; } return $ values ; } 

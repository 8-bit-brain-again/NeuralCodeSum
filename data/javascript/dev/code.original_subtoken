function get Counts ( langs = [ ] ) { return { langs : langs . length , model Langs : langs . filter ( ( { models } ) = > models & & ! ! models . length ) . length , models : langs . map ( ( { models } ) = > ( models ? models . length : 0 ) ) . reduce ( ( a , b ) = > a + b , 0 ) , } } 
function ( type , _ , _ _ ) { var types = [ ' # ( [ \ \s \ \S ] ) + ? ' , 
function ( ) { var real Value = this . value ; real Value = is Na N ( real Value ) ? 0 : real Value ; real Value = real Value < options . min ? options . min : real Value ; real Value = real Value > options . max ? options . max : real Value ; this . value = real Value ; var input Scale = ( real Value - options . min ) / ( options . max - options . min ) * 1 0 0 / step ; change ( input Scale , 0 ) ; } 
function ( e , index , li Elem , options ) { options = options | | { } ; var othis = li Elem | | $ ( this ) , index = index | | othis . parent ( ) . children ( 'li ' ) . index ( othis ) , parents = options . header Elem ? othis . parent ( ) : othis . parents ( ' .layui -tab ' ) . eq ( 0 ) , item = options . body Elem ? $ ( options . body Elem ) : parents . children ( ' .layui -tab -content ' ) . children ( ' .layui -tab -item ' ) , elem A = othis . find ( 'a ' ) , filter = parents . attr ( 'lay -filter ' ) ; if ( ! ( elem A . attr ( 'href ' ) ! = = 'javascript : ; ' & & elem A . attr ( 'target ' ) = = = ' _blank ' ) ) { othis . add Class ( THIS ) . siblings ( ) . remove Class ( THIS ) ; item . eq ( index ) . add Class ( SHOW ) . siblings ( ) . remove Class ( SHOW ) ; } layui . event . call ( this , MOD _NAME , 'tab ( ' + filter + ' ) ' , { elem : parents , index : index } ) ; } 
function ( ver ) { ver = ver = = = 'open ' ; 
function ( req , res , next ) { if ( req . url . index Of ( ' /api /mock ' ) = = = - 1 ) { return next ( ) ; } var data = url . parse ( req . url , true ) . query ; set Timeout ( function ( ) { res . status Code = data . status Code | | 2 0 0 ; res . set Header ( 'content -type ' , data . content Type | | 'json ' ) ; res . end ( data . response | | ' { } ' ) ; } , data . timeout | | 0 ) ; } 
function ( node , name ) { var style = node . current Style ? node . current Style : window . get Computed Style ( node , null ) ; return style [ style . get Property Value ? 'get Property Value ' : 'get Attribute ' ] ( name ) ; } 
function ( callback ) { var cssname = 'layer ' , ver = ' ' , path = ( is Layui ? 'modules /layer / ' : 'theme / ' ) + 'default /layer .css ?v = ' + layer . v + ver ; is Layui ? layui . addcss ( path , callback , cssname ) : ready . link ( path , callback , cssname ) ; return this ; } 
function ( content , options , yes ) { var type = typeof options = = = 'function ' ; if ( type ) yes = options ; return layer . open ( $ . extend ( { content : content , yes : yes } , type ? { } : options ) ) ; } 
function cancel ( ) { var close = config . cancel & & config . cancel ( that . index , layero ) ; close = = = false | | layer . close ( that . index ) ; } 
function ( ) { data = [ ] ; parent . find ( options . img ) . each ( function ( index ) { var othis = $ ( this ) ; othis . attr ( 'layer -index ' , index ) ; data . push ( { alt : othis . attr ( 'alt ' ) , pid : othis . attr ( 'layer -pid ' ) , src : othis . attr ( 'layer -src ' ) | | othis . attr ( 'src ' ) , thumb : othis . attr ( 'src ' ) } ) ; } ) } 
function load Image ( url , callback , error ) { var img = new Image ( ) ; img . src = url ; if ( img . complete ) { return callback ( img ) ; } img . onload = function ( ) { img . onload = null ; callback ( img ) ; } ; img . onerror = function ( e ) { img . onerror = null ; error ( e ) ; } ; } 
function ( sets ) { var othis = $ ( this ) , index = othis . parents ( 'tr ' ) . eq ( 0 ) . data ( 'index ' ) , tr = that . lay Body . find ( 'tr [data -index = " ' + index + ' " ] ' ) , data = table . cache [ that . key ] [ index ] ; return $ . extend ( { tr : tr 
function ( event Type ) { var othis = $ ( this ) ; layui . event . call ( this , MOD _NAME , event Type + ' ( ' + filter + ' ) ' , common Member . call ( othis . children ( 'td ' ) [ 0 ] ) ) ; } 
function ( hide ) { var othis = $ ( this ) , elem Cell = othis . children ( ELEM _CELL ) ; if ( hide ) { othis . find ( ' .layui -table -grid -down ' ) . remove ( ) ; } else if ( elem Cell . prop ( 'scroll Width ' ) > elem Cell . outer Width ( ) ) { if ( elem Cell . find ( ' . ' + ELEM _GRID _DOWN ) [ 0 ] ) return ; othis . append ( ' <div class = " ' + ELEM _GRID _DOWN + ' " > <i class = "layui -icon layui -icon -down " > < /i > < /div > ' ) ; } } 
function ( obj ) { layui . each ( obj | | arrs , function ( i , item ) { if ( item . CHILD _COLS ) return each Arrs ( item . CHILD _COLS ) ; typeof callback = = = 'function ' & & callback ( i , item ) ; } ) ; } 
function ( ) { var TIPS = ' 请 选 择 ' , CLAS S = 'la u -form -select ' , TITL E = 'la u -select -title ' , NONE = 'layui -select -none ' , init Value = ' ' , that Input , selects = elem Form . find ( 'select ' ) 
function ( ) { var top = re Elem . offset ( ) . top + re Elem . outer Height ( ) + 5 - $win . scroll Top ( ) , dl Height = dl . outer Height ( ) ; index = select [ 0 ] . selected Index ; 
function ( choose ) { re Elem . remove Class ( CLASS + 'ed ' + CLASS + 'up ' ) ; input . blur ( ) ; near Elem = null ; if ( choose ) return ; not Option ( input . val ( ) , function ( none ) { var selected Index = select [ 0 ] . selected Index ; 
function ( ) { var this Dd = dl . children ( 'dd . ' + THIS ) ; if ( ! this Dd [ 0 ] ) return ; var pos Top = this Dd . position ( ) . top , dl Height = dl . height ( ) , dd Height = this Dd . height ( ) ; 
function ( value , callback , origin ) { var num = 0 ; layui . each ( dds , function ( ) { var othis = $ ( this ) , text = othis . text ( ) , not = text . index Of ( value ) = = = - 1 ; if ( value = = = ' ' | | ( origin = = = 'blur ' ) ? value ! = = text : not ) num + + ; origin = = = 'keyup ' & & othis [ not ? 'add Class ' : 'remove Class ' ] ( HIDE ) ; } ) ; var none = num = = = dds . length ; return callback ( none ) , none ; } 
function ( e ) { var value = this . value , key Code = e . key Code ; if ( key Code = = = 9 | | key Code = = = 1 3 | | key Code = = = 3 7 | | key Code = = = 3 8 | | key Code = = = 3 9 | | key Code = = = 4 0 ) { return false ; } not Option ( value , function ( none ) { if ( none ) { dl . find ( ' . ' + NONE ) [ 0 ] | | dl . append ( ' <p class = " ' + NONE + ' " > 无 匹 配 项 < /p > ' ) ; } else { dl . find ( ' . ' + NONE ) . remove ( ) ; } } , 'keyup ' ) ; if ( value = = = ' ' ) { dl . find ( ' . ' + NONE ) . remove ( ) ; } follow Scroll ( ) ; 
function ( ) { var button = $ ( this ) , verify = form . config . verify , stop = null , DANGER = 'layui -form -danger ' , field = { } , elem = button . parents ( ELEM ) , verify Elem = elem . find ( ' * [lay -verify ] ' ) 
function ( ) { lay ( ul ) . find ( 'ol ' ) . each ( function ( i , ol ) { lay ( ol ) . find ( 'li ' ) . each ( function ( ii , li ) { that . limit ( lay ( li ) , [ { hours : ii } , { hours : that [ start End ] . hours , minutes : ii } , { hours : that [ start End ] . hours , minutes : that [ start End ] . minutes , seconds : ii } ] [ i ] , index , [ [ 'hours ' ] , [ 'hours ' , 'minutes ' ] , [ 'hours ' , 'minutes ' , 'seconds ' ] ] [ i ] ) ; } ) ; } ) ; if ( ! options . range ) that . limit ( lay ( that . footer ) . find ( ELEM _CONFIRM ) , that [ start End ] , 0 , [ 'hours ' , 'minutes ' , 'seconds ' ] ) ; } 
function ( ) { if ( lay ( btn ) . has Class ( DISABLED ) ) return ; that . list ( 'time ' , 0 ) ; options . range & & that . list ( 'time ' , 1 ) ; lay ( btn ) . attr ( 'lay -type ' , 'date ' ) . html ( that . lang ( ) . date Tips ) ; } 
function ( html , over ) { html = $ ( html ) ; more . before ( html ) ; over = over = = 0 ? true : null ; over ? more . html ( end ) : more . find ( 'a ' ) . html ( ELEM _TEXT ) ; is Over = over ; lock = null ; lazyimg & & lazyimg ( ) ; } 
function ( ) { lock = true ; more . find ( 'a ' ) . html ( ELEM _LOAD ) ; typeof options . done = = = 'function ' & & options . done ( + + page , next ) ; } 
function ( item , height ) { var start = scroll Elem . scroll Top ( ) , end = start + height ; var elem Top = not Docment ? function ( ) { return item . offset ( ) . top - scroll Elem . offset ( ) . top + start ; } ( ) : item . offset ( ) . top ; if ( elem Top > = start & & elem Top < = end ) { if ( ! item . attr ( 'src ' ) ) { var src = item . attr ( 'lay -src ' ) ; layui . img ( src , function ( ) { var next = that . lazyimg . elem . eq ( index ) ; item . attr ( 'src ' , src ) . remove Attr ( 'lay -src ' ) ; next [ 0 ] & & render ( next ) ; index + + ; } ) ; } } } 
function ( othis , scroll ) { 
function ( othis ) { elem Color Box Span [ 0 ] . style . background = ' ' ; that . elem Color Box . find ( ' . ' + PICKER _TRIG _I ) . remove Class ( ICON _PICKER _DOWN ) . add Class ( ICON _PICKER _CLOSE ) ; that . color = ' ' ; options . done & & options . done ( ' ' ) ; that . remove Picker ( ) ; } 
function class Name ( node , value ) { var klass = node . class Name | | ' ' , svg = klass & & klass . base Val ! = = undefined if ( value = = = undefined ) return svg ? klass . base Val : klass svg ? ( klass . base Val = value ) : ( node . class Name = value ) } 
function deserialize Value ( value ) { try { return value ? value = = "true " | | ( value = = "false " ? false : value = = "null " ? null : + value + " " = = value ? + value : / ^ [ \ [ \ { ] / . test ( value ) ? $ . parse JSON ( value ) : value ) : value } catch ( e ) { return value } } 
function ajax Complete ( status , xhr , settings ) { var context = settings . context settings . complete . call ( context , xhr , status ) trigger Global ( settings , context , 'ajax Complete ' , [ xhr , settings ] ) ajax Stop ( settings ) } 
function parse Arguments ( url , data , success , data Type ) { if ( $ . is Function ( data ) ) data Type = success , success = data , data = undefined if ( ! $ . is Function ( success ) ) data Type = success , success = undefined return { url : url , data : data , success : success , data Type : data Type } } 
function ( editor , text Area , set ) { var that = this , iframe = editor . find ( 'iframe ' ) ; iframe . css ( { height : set . height } ) . on ( 'load ' , function ( ) { var conts = iframe . contents ( ) , iframe Win = iframe . prop ( 'content Window ' ) , head = conts . find ( 'head ' ) , style = $ ( [ ' <style > ' , ' * {margin : 0 ; padding : 0 ; } ' , 'body {padding : 1 0px ; line -height : 2 0px ; overflow -x : hidden ; word -wrap : break -word ; font : 1 4px Helvetica Neue ,Helvetica ,Ping Fang SC ,Microsoft Ya Hei ,Tahoma ,Arial ,sans -serif ; -webkit -box -sizing : border -box !important ; -moz -box -sizing : border -box !important ; box -sizing : border -box !important ; } ' , 'a {color : # 0 1AAED ; text -decoration :none ; }a :hover {color : #c 0 0 } ' , 'p {margin -bottom : 1 0px ; } ' , 'img {display : inline -block ; border : none ; vertical -align : middle ; } ' , 'pre {margin : 1 0px 0 ; padding : 1 0px ; line -height : 2 0px ; border : 1px solid #ddd ; border -left -width : 6px ; background -color : #F 2F 2F 2 ; color : # 3 3 3 ; font -family : Courier New ; font -size : 1 2px ; } ' , ' < /style > ' ] . join ( ' ' ) ) , body = conts . find ( 'body ' ) ; head . append ( style ) ; body . attr ( 'contenteditable ' , 'true ' ) . css ( { 'min -height ' : set . height } ) . html ( text Area . value | | ' ' ) ; hotkey . apply ( that , [ iframe Win , iframe , text Area , set ] ) ; 
function ( html ) { if ( device . ie = = 8 ) { html = html . replace ( / < . + > / g , function ( str ) { return str . to Lower Case ( ) ; } ) ; } return html ; } 
function ( iframe Win , iframe , text Area , set ) { var iframe DOM = iframe Win . document , body = $ ( iframe DOM . body ) ; body . on ( 'keydown ' , function ( e ) { var keycode = e . key Code ; 
function ( body ) { var iframe Win = this , iframe DOM = iframe Win . document ; 
function ( tag Name , attr , range ) { var iframe DOM = this . document , elem = document . create Element ( tag Name ) for ( var key in attr ) { elem . set Attribute ( key , attr [ key ] ) ; } elem . remove Attribute ( 'text ' ) ; if ( iframe DOM . selection ) { 
function ( tools , othis ) { var iframe DOM = this . document , CHECK = 'layedit -tool -active ' , container = get Container ( Range ( iframe DOM ) ) , item = function ( type ) { return tools . find ( ' .layedit -tool - ' + type ) } if ( othis ) { othis [ othis . has Class ( CHECK ) ? 'remove Class ' : 'add Class ' ] ( CHECK ) ; } tools . find ( ' >i ' ) . remove Class ( CHECK ) ; item ( 'unlink ' ) . add Class ( ABLED ) ; $ ( container ) . parents ( ) . each ( function ( ) { var tag Name = this . tag Name . to Lower Case ( ) , text Align = this . style . text Align ; 
function ( iframe Win , editor , set ) { var iframe DOM = iframe Win . document , body = $ ( iframe DOM . body ) , tool Event = { 
function ( range ) { var container = get Container ( range ) , parent Node = $ ( container ) . parent ( ) ; link . call ( body , { href : parent Node . attr ( 'href ' ) , target : parent Node . attr ( 'target ' ) } , function ( field ) { var parent = parent Node [ 0 ] ; if ( parent . tag Name = = = 'A ' ) { parent . href = field . url ; } else { insert Inline . call ( iframe Win , 'a ' , { target : field . target , href : field . url , text : field . url } , range ) ; } } ) ; } 
function ( callback ) { 
function ( callback ) { var body = this , index = layer . open ( { type : 1 , id : 'LAY _layedit _code ' , area : ' 5 5 0px ' , shade : 0 . 0 5 , shade Close : true , move Type : 1 , title : ' 插 入 代 码 ' , skin : 'layui -layer -msg ' , content : [ ' <ul class = "layui -form layui -form -pane " style = "margin : 1 5px ; " > ' , ' <li class = "layui -form -item " > ' , ' <label class = "layui -form -label " > 请 选 择 语 言 < /label > ' , ' <div class = "layui -input -block " > ' , ' <select name = "lang " > ' , ' <option value = "Java Script " >Java Script < /option > ' , ' <option value = "HTML " >HTML < /option > ' , ' <option value = "CSS " >CSS < /option > ' , ' <option value = "Java " >Java < /option > ' , ' <option value = "PHP " >PHP < /option > ' , ' <option value = "C # " >C # < /option > ' , ' <option value = "Python " >Python < /option > ' , ' <option value = "Ruby " >Ruby < /option > ' , ' <option value = "Go " >Go < /option > ' , ' < /select > ' , ' < /div > ' , ' < /li > ' , ' <li class = "layui -form -item layui -form -text " > ' , ' <label class = "layui -form -label " > 代 码 < /label > ' , ' <div class = "layui -input -block " > ' , ' <textarea name = "code " lay -verify = "required " autofocus = "true " class = "layui -textarea " style = "height : 2 0 0px ; " > < /textarea > ' , ' < /div > ' , ' < /li > ' , ' <li class = "layui -form -item " style = "text -align : center ; " > ' , ' <button type = "button " lay -submit lay -filter = "layedit -code -yes " class = "layui -btn " > 确 定 < /button > ' , ' <button style = "margin -left : 2 0px ; " type = "button " class = "layui -btn layui -btn -primary " > 取 消 < /button > ' , ' < /li > ' , ' < /ul > ' ] . join ( ' ' ) , success : function ( layero , index ) { var event Filter = 'submit (layedit -code -yes ) ' ; form . render ( 'select ' ) ; layero . find ( ' .layui -btn -primary ' ) . on ( 'click ' , function ( ) { layer . close ( index ) ; body . focus ( ) ; } ) ; form . on ( event Filter , function ( data ) { layer . close ( code . index ) ; callback & & callback ( data . field ) ; } ) ; } } ) ; code . index = index ; } 
function ( options ) { var ELEM = 'layui -fixbar ' , TOP _BAR = 'layui -fixbar -top ' , dom = $ ( document ) , body = $ ( 'body ' ) , is , timer ; options = $ . extend ( { show Height : 2 0 0 
function on Script Load ( e , url ) { var ready Reg Exp = navigator . platform = = = 'PLay STATION 3 ' ? / ^complete $ / : / ^ (complete |loaded ) $ / if ( e . type = = = 'load ' | | ( ready Reg Exp . test ( ( e . current Target | | e . src Element ) . ready State ) ) ) { config . modules [ item ] = url ; head . remove Child ( node ) ; ( function poll ( ) { if ( + + timeout > config . timeout * 1 0 0 0 / 4 ) { return error ( item + ' is not a valid module ' ) ; } ; config . status [ item ] ? on Callback ( ) : set Timeout ( poll , 4 ) ; } ( ) ) ; } } 
function on Callback ( ) { exports . push ( layui [ item ] ) ; apps . length > 1 ? that . use ( apps . slice ( 1 ) , callback , exports ) : ( typeof callback = = = 'function ' & & callback . apply ( layui , exports ) ) ; } 
function ( ) { if ( elem . data ( 'spread ' ) ) { elem . data ( 'spread ' , null ) ul . remove Class ( 'layui -show ' ) ; arrow . html ( icon . arrow [ 0 ] ) ; a . find ( ' .layui -icon ' ) . html ( icon . branch [ 0 ] ) ; } else { elem . data ( 'spread ' , true ) ; ul . add Class ( 'layui -show ' ) ; arrow . html ( icon . arrow [ 1 ] ) ; a . find ( ' .layui -icon ' ) . html ( icon . branch [ 1 ] ) ; } } 
function once ( fn ) { let called = false return function ( . . . args ) { if ( called ) return called = true return fn . apply ( this , args ) } } 
function guard Route ( to , from , next ) { if ( window . confirm ( ` $ { to . path } ` ) ) { next ( ) } else if ( window . confirm ( ` ` ) ) { next ( ' /baz ' ) } else { next ( false ) } } 
function jsfiddle Tag ( args , content ) { const id = args [ 0 ] ; const tabs = args [ 1 ] & & args [ 1 ] ! = = 'default ' ? args [ 1 ] : 'js ,resources ,html ,css ,result ' ; const skin = args [ 2 ] & & args [ 2 ] ! = = 'default ' ? args [ 2 ] : 'light ' ; const width = args [ 3 ] & & args [ 3 ] ! = = 'default ' ? args [ 3 ] : ' 1 0 0 % ' ; const height = args [ 4 ] & & args [ 4 ] ! = = 'default ' ? args [ 4 ] : ' 3 0 0 ' ; return ` $ { width } $ { height } $ { id } $ { tabs } $ { skin } ` ; } 
function link Tag ( args , content ) { let url = ' ' ; const text = [ ] ; let external = false ; let title = ' ' ; let i = 0 ; const len = args . length ; 
function get Highlight Options ( config , arg ) { let lang = ' ' ; if ( r Lang . test ( arg ) ) { arg = arg . replace ( r Lang , ( match , _lang ) = > { lang = _lang ; return ' ' ; } ) ; } let line _number = config . line _number ; if ( r Line Number . test ( arg ) ) { arg = arg . replace ( r Line Number , ( match , _line _number ) = > { line _number = _line _number = = = 'true ' ; return ' ' ; } ) ; } let first _line = 1 ; if ( r First Line . test ( arg ) ) { arg = arg . replace ( r First Line , ( match , _first _line ) = > { first _line = _first _line ; return ' ' ; } ) ; } let mark = [ ] ; if ( r Mark . test ( arg ) ) { arg = arg . replace ( r Mark , ( match , _mark ) = > { mark = _mark . split ( ' , ' ) . reduce ( function get Marked Lines ( prev , cur ) { if ( / - / . test ( cur ) ) { let a = Number ( cur . substr ( 0 , cur . index Of ( ' - ' ) ) ) ; let b = Number ( cur . substr ( cur . index Of ( ' - ' ) + 1 ) ) ; if ( b < a ) { 
function pipe Stream ( . . . args ) { const src = args . shift ( ) ; return new Promise ( ( resolve , reject ) = > { let stream = src . on ( 'error ' , reject ) ; let target ; while ( ( target = args . shift ( ) ) ! = null ) { stream = stream . pipe ( target ) . on ( 'error ' , reject ) ; } stream . on ( 'finish ' , resolve ) ; stream . on ( 'end ' , resolve ) ; stream . on ( 'close ' , resolve ) ; } ) ; } 
function gist Tag ( args , content ) { const id = args . shift ( ) ; const file = args . length ? ` $ { args [ 0 ] } ` : ' ' ; return ` $ { id } $ { file } ` ; } 
function iframe Tag ( args , content ) { const url = args [ 0 ] ; const width = args [ 1 ] & & args [ 1 ] ! = = 'default ' ? args [ 1 ] : ' 1 0 0 % ' ; const height = args [ 2 ] & & args [ 2 ] ! = = 'default ' ? args [ 2 ] : ' 3 0 0 ' ; return ` $ { url } $ { width } $ { height } ` ; } 
function format Nunjucks Error ( err , input ) { const match = err . message . match ( / Line ( \d + ) , Column \d + / ) ; if ( ! match ) return err ; const err Line = parse Int ( match [ 1 ] , 1 0 ) ; if ( is Na N ( err Line ) ) return err ; 
function ( event , context , response Status , physical Resource Id , response Data , reason ) { return new Promise ( ( resolve , reject ) = > { const https = require ( 'https ' ) ; const { URL } = require ( 'url ' ) ; var response Body = JSON . stringify ( { Status : response Status , Reason : reason , Physical Resource Id : physical Resource Id | | context . log Stream Name , Stack Id : event . Stack Id , Request Id : event . Request Id , Logical Resource Id : event . Logical Resource Id , Data : response Data } ) ; const parsed Url = new URL ( event . Response URL | | default Response URL ) ; const options = { hostname : parsed Url . hostname , port : 4 4 3 , path : parsed Url . pathname + parsed Url . search , method : 'PUT ' , headers : { 'Content -Type ' : ' ' , 'Content -Length ' : response Body . length } } ; https . request ( options ) . on ( 'error ' , reject ) . on ( 'response ' , res = > { res . resume ( ) ; if ( res . status Code > = 4 0 0 ) { reject ( new Error ( ` $ { res . status Code } $ { res . status Message } ` ) ) ; } else { resolve ( ) ; } } ) . end ( response Body , 'utf 8 ' ) ; } ) ; } 
async function ( request Id , domain Name , subject Alternative Names , hosted Zone Id ) { const crypto = require ( 'crypto ' ) ; const acm = new aws . ACM ( ) ; const route 5 3 = new aws . Route 5 3 ( ) ; if ( waiter ) { 
async function ( arn ) { const acm = new aws . ACM ( ) ; console . log ( ` $ { arn } ` ) ; try { await acm . delete Certificate ( { Certificate Arn : arn } ) . promise ( ) ; } catch ( err ) { if ( err . name ! = = 'Resource Not Found Exception ' ) { throw err ; } } } 
async function get Adopter ( name ) { try { const policy Response = await ecr . get Repository Policy ( { repository Name : name } ) . promise ( ) ; const policy = JSON . parse ( policy Response . policy Text ) ; 
function calculate Line Height ( model , column Widths ) { var padding = this . internal . _ _cell _ _ . padding ; var font Size = this . internal . _ _cell _ _ . table _font _size ; var scale Factor = this . internal . scale Factor ; return Object . keys ( model ) . map ( function ( value ) { return typeof value = = = 'object ' ? value . text : value } ) . map ( function ( value ) { return this . split Text To Size ( value , column Widths [ value ] - padding - padding ) } , this ) . map ( function ( value ) { return this . get Line Height Factor ( ) * value . length * font Size / scale Factor + padding + padding } , this ) . reduce ( function ( pv , cv ) { return Math . max ( pv , cv ) } , 0 ) ; } 
function make Worker ( script ) { var URL = window . URL | | window . webkit URL ; var Blob = window . Blob ; var Worker = window . Worker ; if ( ! URL | | ! Blob | | ! Worker | | ! script ) { return null ; } var blob = new Blob ( [ script ] ) ; var worker = new Worker ( URL . create Object URL ( blob ) ) ; return worker ; } 
function setup Clipboard ( element , opts ) { if ( ! File Reader JS . enabled ) { return ; } var instance Options = extend ( extend ( { } , File Reader JS . opts ) , opts ) ; element . add Event Listener ( "paste " , onpaste , false ) ; function onpaste ( e ) { var files = [ ] ; var clipboard Data = e . clipboard Data | | { } ; var items = clipboard Data . items | | [ ] ; for ( var i = 0 ; i < items . length ; i + + ) { var file = items [ i ] . get As File ( ) ; if ( file ) { 
function setup Input ( input , opts ) { if ( ! File Reader JS . enabled ) { return ; } var instance Options = extend ( extend ( { } , File Reader JS . opts ) , opts ) ; input . add Event Listener ( "change " , input Change , false ) ; input . add Event Listener ( "drop " , input Drop , false ) ; function input Change ( e ) { process File List ( e , input . files , instance Options ) ; } function input Drop ( e ) { e . stop Propagation ( ) ; e . prevent Default ( ) ; process File List ( e , e . data Transfer . files , instance Options ) ; } } 
function setup Drop ( dropbox , opts ) { if ( ! File Reader JS . enabled ) { return ; } var instance Options = extend ( extend ( { } , File Reader JS . opts ) , opts ) ; var drag Class = instance Options . drag Class ; var initialized On Body = false ; 
function setup Custom File Properties ( files , group ID ) { for ( var i = 0 ; i < files . length ; i + + ) { var file = files [ i ] ; file . extra = { name No Extension : file . name . substring ( 0 , file . name . last Index Of ( ' . ' ) ) , extension : file . name . substring ( file . name . last Index Of ( ' . ' ) + 1 ) , file ID : i , unique ID : get Unique ID ( ) , group ID : group ID , pretty Size : pretty Size ( file . size ) } ; } } 
function get Read As Method ( type , read As Map , read As Default ) { for ( var r in read As Map ) { if ( type . match ( new Reg Exp ( r ) ) ) { return 'read As ' + read As Map [ r ] ; } } return 'read As ' + read As Default ; } 
function process File List ( e , files , opts ) { var files Left = files . length ; var group = { group ID : get Group ID ( ) , files : files , started : new Date ( ) } ; function group End ( ) { group . ended = new Date ( ) ; opts . on . groupend ( group ) ; } function group File Done ( ) { if ( - - files Left = = = 0 ) { group End ( ) ; } } File Reader JS . output . push ( group ) ; setup Custom File Properties ( files , group . group ID ) ; opts . on . groupstart ( group ) ; 
function check File Reader Sync Support ( ) { var worker = make Worker ( sync Detection Script ) ; if ( worker ) { worker . onmessage = function ( e ) { File Reader Sync Support = e . data ; } ; worker . post Message ( { } ) ; } } 
function add Class ( el , name ) { if ( ! has Class ( el , name ) ) { el . class Name = el . class Name ? [ el . class Name , name ] . join ( ' ' ) : name ; } } 
function remove Class ( el , name ) { if ( has Class ( el , name ) ) { var c = el . class Name ; el . class Name = c . replace ( new Reg Exp ( " ( ? : ^ | \ \s + ) " + name + " ( ? : \ \s + | $ ) " , "g " ) , " " ) . replace ( / ^ \s \s * / , ' ' ) . replace ( / \s \s * $ / , ' ' ) ; } } 
function pretty Size ( bytes ) { var s = [ 'bytes ' , 'kb ' , 'MB ' , 'GB ' , 'TB ' , 'PB ' ] ; var e = Math . floor ( Math . log ( bytes ) / Math . log ( 1 0 2 4 ) ) ; return ( bytes / Math . pow ( 1 0 2 4 , Math . floor ( e ) ) ) . to Fixed ( 2 ) + " " + s [ e ] ; } 
function monkey Patch ( ) { return { transform : ( code , id ) = > { var file = id . split ( ' / ' ) . pop ( ) / / Only one define call per module is allowed by requirejs so / / we have to remove calls that other libraries make if ( file = = = 'File Saver .js ' ) { code = code . replace ( / define ! = = null \ ) & & \ (define .amd ! = null / g , ' 0 ' ) } else if ( file = = = 'html 2canvas .js ' ) { code = code . replace ( / & & \s +define .amd / g , ' & & define .amd & & false ' ) } return code } } } 
function rawjs ( opts ) { opts = opts | | { } return { transform : ( code , id ) = > { var variable = opts [ id . split ( ' / ' ) . pop ( ) ] if ( ! variable ) return code var keep Str = ' / *rollup -keeper -start * /window .tmp = ' + variable + ' ; / *rollup -keeper -end * / ' return code + keep Str } , transform Bundle : ( code ) = > { for ( var file in opts ) { var r = new Reg Exp ( opts [ file ] + ' \ \ $ \ \d + ' , 'g ' ) code = code . replace ( r , opts [ file ] ) } var re = / \ / \ *rollup -keeper -start \ * \ / . * \ / \ *rollup -keeper -end \ * \ / / g return code . replace ( re , ' ' ) } } } 
function ( img Data ) { var width , height , numcomponents ; var block Length = img Data . char Code At ( 4 ) * 2 5 6 + img Data . char Code At ( 5 ) ; var len = img Data . length ; var result = { width : 0 , height : 0 , numcomponents : 1 } ; for ( var i = 4 ; i < len ; i + = 2 ) { i + = block Length ; if ( markers . index Of ( img Data . char Code At ( i + 1 ) ) ! = = - 1 ) { height = img Data . char Code At ( i + 5 ) * 2 5 6 + img Data . char Code At ( i + 6 ) ; width = img Data . char Code At ( i + 7 ) * 2 5 6 + img Data . char Code At ( i + 8 ) ; numcomponents = img Data . char Code At ( i + 9 ) ; result = { width : width , height : height , numcomponents : numcomponents } ; break ; } else { block Length = img Data . char Code At ( i + 2 ) * 2 5 6 + img Data . char Code At ( i + 3 ) ; } } return result ; } 
function Bmp Decoder ( buffer , is _with _alpha ) { this . pos = 0 ; this . buffer = buffer ; this . datav = new Data View ( buffer . buffer ) ; this . is _with _alpha = ! ! is _with _alpha ; this . bottom _up = true ; this . flag = String . from Char Code ( this . buffer [ 0 ] ) + String . from Char Code ( this . buffer [ 1 ] ) ; this . pos + = 2 ; if ( [ "BM " , "BA " , "CI " , "CP " , "IC " , "PT " ] . index Of ( this . flag ) = = = - 1 ) throw new Error ( "Invalid BMP File " ) ; this . parse Header ( ) ; this . parse BGR ( ) ; } 
function ( tag Name , opt ) { var el = document . create Element ( tag Name ) ; if ( opt . class Name ) el . class Name = opt . class Name ; if ( opt . inner HTML ) { el . inner HTML = opt . inner HTML ; var scripts = el . get Elements By Tag Name ( 'script ' ) ; for ( var i = scripts . length ; i - - > 0 ; ) { scripts [ i ] . parent Node . remove Child ( scripts [ i ] ) ; } } for ( var key in opt . style ) { el . style [ key ] = opt . style [ key ] ; } return el ; } 
function ( node , javascript Enabled ) { 
function Worker ( opt ) { 
function Static Tree ( static _tree , extra _bits , extra _base , elems , max _length ) { var that = this ; that . static _tree = static _tree ; that . extra _bits = extra _bits ; that . extra _base = extra _base ; that . elems = elems ; that . max _length = max _length ; } 
function tr _init ( ) { l _desc . dyn _tree = dyn _ltree ; l _desc . stat _desc = Static Tree . static _l _desc ; d _desc . dyn _tree = dyn _dtree ; d _desc . stat _desc = Static Tree . static _d _desc ; bl _desc . dyn _tree = bl _tree ; bl _desc . stat _desc = Static Tree . static _bl _desc ; bi _buf = 0 ; bi _valid = 0 ; last _eob _len = 8 ; 
function _tr _align ( ) { send _bits ( STATIC _TREES < < 1 , 3 ) ; send _code ( END _BLOCK , Static Tree . static _ltree ) ; bi _flush ( ) ; 
function _tr _tally ( dist , 
function compress _block ( ltree , dtree ) { var dist ; 
function copy _block ( buf , 
function _tr _stored _block ( buf , 
function deflate _stored ( flush ) { 
function ZStream ( ) { var that = this ; that . next _in _index = 0 ; that . next _out _index = 0 ; 
function ( buf , start , size ) { var that = this ; var len = that . avail _in ; if ( len > size ) len = size ; if ( len = = = 0 ) return 0 ; that . avail _in - = len ; buf . set ( that . next _in . subarray ( that . next _in _index , that . next _in _index + len ) , start ) ; that . next _in _index + = len ; that . total _in + = len ; return len ; } 
function ( ) { var that = this ; var len = that . dstate . pending ; if ( len > that . avail _out ) len = that . avail _out ; if ( len = = = 0 ) return ; 
function Deflater ( options ) { var that = this ; var z = new ZStream ( ) ; var bufsize = 5 1 2 ; var flush = Z _NO _FLUSH ; var buf = new Uint 8Array ( bufsize ) ; var level = options ? options . level : Z _DEFAULT _COMPRESSION ; if ( typeof level = = = "undefined " ) level = Z _DEFAULT _COMPRESSION ; z . deflate Init ( level ) ; z . next _out = buf ; that . append = function ( data , onprogress ) { var err , buffers = [ ] , last Index = 0 , buffer Index = 0 , buffer Size = 0 , array ; if ( ! data . length ) return ; z . next _in _index = 0 ; z . next _in = data ; z . avail _in = data . length ; do { z . next _out _index = 0 ; z . avail _out = bufsize ; err = z . deflate ( flush ) ; if ( err ! = = Z _OK ) throw new Error ( "deflating : " + z . msg ) ; if ( z . next _out _index ) if ( z . next _out _index = = = bufsize ) buffers . push ( new Uint 8Array ( buf ) ) ; else buffers . push ( new Uint 8Array ( buf . subarray ( 0 , z . next _out _index ) ) ) ; buffer Size + = z . next _out _index ; if ( onprogress & & z . next _in _index > 0 & & z . next _in _index ! = = last Index ) { onprogress ( z . next _in _index ) ; last Index = z . next _in _index ; } } while ( z . avail _in > 0 | | z . avail _out = = = 0 ) ; array = new Uint 8Array ( buffer Size ) ; buffers . for Each ( function ( chunk ) { array . set ( chunk , buffer Index ) ; buffer Index + = chunk . length ; } ) ; return array ; } ; that . flush = function ( ) { var err , buffers = [ ] , buffer Index = 0 , buffer Size = 0 , array ; do { z . next _out _index = 0 ; z . avail _out = bufsize ; err = z . deflate ( Z _FINISH ) ; if ( err ! = = Z _STREAM _END & & err ! = = Z _OK ) throw new Error ( "deflating : " + z . msg ) ; if ( bufsize - z . avail _out > 0 ) buffers . push ( new Uint 8Array ( buf . subarray ( 0 , z . next _out _index ) ) ) ; buffer Size + = z . next _out _index ; } while ( z . avail _in > 0 | | z . avail _out = = = 0 ) ; z . deflate End ( ) ; array = new Uint 8Array ( buffer Size ) ; buffers . for Each ( function ( chunk ) { array . set ( chunk , buffer Index ) ; buffer Index + = chunk . length ; } ) ; return array ; } ; } 
function ( style ) { var rx Rgb = / rgb \s * \ ( \s * ( \d + ) \s * , \s * ( \d + ) \s * , \s * ( \d + ) \s * \ ) / ; var rx Rgba = / rgba \s * \ ( \s * ( \d + ) \s * , \s * ( \d + ) \s * , \s * ( \d + ) \s * , \s * ( [ \d . ] + ) \s * \ ) / ; var rx Transparent = / transparent |rgba \s * \ ( \s * ( \d + ) \s * , \s * ( \d + ) \s * , \s * ( \d + ) \s * , \s * 0 + \s * \ ) / ; var r , g , b , a ; if ( style . is Canvas Gradient = = = true ) { style = style . get Color ( ) ; } if ( ! style ) { return { r : 0 , g : 0 , b : 0 , a : 0 , style : style } ; } if ( rx Transparent . test ( style ) ) { r = 0 ; g = 0 ; b = 0 ; a = 0 ; } else { var matches = rx Rgb . exec ( style ) ; if ( matches ! = = null ) { r = parse Int ( matches [ 1 ] ) ; g = parse Int ( matches [ 2 ] ) ; b = parse Int ( matches [ 3 ] ) ; a = 1 ; } else { matches = rx Rgba . exec ( style ) ; if ( matches ! = = null ) { r = parse Int ( matches [ 1 ] ) ; g = parse Int ( matches [ 2 ] ) ; b = parse Int ( matches [ 3 ] ) ; a = parse Float ( matches [ 4 ] ) ; } else { a = 1 ; if ( typeof style = = = "string " & & style . char At ( 0 ) ! = = ' # ' ) { var rgb Color = new RGBColor ( style ) ; if ( rgb Color . ok ) { style = rgb Color . to Hex ( ) ; } else { style = ' # 0 0 0 0 0 0 ' ; } } if ( style . length = = = 4 ) { r = style . substring ( 1 , 2 ) ; r + = r ; g = style . substring ( 2 , 3 ) ; g + = g ; b = style . substring ( 3 , 4 ) ; b + = b ; } else { r = style . substring ( 1 , 3 ) ; g = style . substring ( 3 , 5 ) ; b = style . substring ( 5 , 7 ) ; } r = parse Int ( r , 1 6 ) ; g = parse Int ( g , 1 6 ) ; b = parse Int ( b , 1 6 ) ; } } } return { r : r , g : g , b : b , a : a , style : style } ; } 
function ( y ) { if ( this . page Wrap YEnabled ) { this . last Break = 0 ; var manual Breaks = 0 ; var auto Breaks = 0 ; for ( var i = 0 ; i < this . page Breaks . length ; i + + ) { if ( y > = this . page Breaks [ i ] ) { manual Breaks + + ; if ( this . last Break = = = 0 ) { auto Breaks + + ; } var space Between Last Break = this . page Breaks [ i ] - this . last Break ; this . last Break = this . page Breaks [ i ] ; var pages Since Last Break = Math . floor ( space Between Last Break / this . page Wrap Y ) ; auto Breaks + = pages Since Last Break ; } } if ( this . last Break = = = 0 ) { var pages Since Last Break = Math . floor ( y / this . page Wrap Y ) + 1 ; auto Breaks + = pages Since Last Break ; } return auto Breaks + manual Breaks ; } else { return this . pdf . internal . get Current Page Info ( ) . page Number ; } } 
function ( rule , is Clip ) { if ( ( rule = = = 'stroke ' ) & & ! is Clip & & is Stroke Transparent . call ( this ) ) { return ; } if ( ( rule ! = = 'stroke ' ) & & ! is Clip & & is Fill Transparent . call ( this ) ) { return ; } var moves = [ ] ; 
function ( radius , start Angle , end Angle , anticlockwise ) { var EPSILON = 0 . 0 0 0 0 1 ; 
function ( ax , ay , bx , by , cx , cy , dx , dy ) { var tobx = bx - ax ; var toby = by - ay ; var tocx = cx - bx ; var tocy = cy - by ; var todx = dx - cx ; var tody = dy - cy ; var precision = 4 0 ; var d , i , px , py , qx , qy , rx , ry , tx , ty , sx , sy , x , y , minx , miny , maxx , maxy , toqx , toqy , torx , tory , totx , toty ; for ( i = 0 ; i < ( precision + 1 ) ; i + + ) { d = i / precision ; px = ax + d * tobx ; py = ay + d * toby ; qx = bx + d * tocx ; qy = by + d * tocy ; rx = cx + d * todx ; ry = cy + d * tody ; toqx = qx - px ; toqy = qy - py ; torx = rx - qx ; tory = ry - qy ; sx = px + d * toqx ; sy = py + d * toqy ; tx = qx + d * torx ; ty = qy + d * tory ; totx = tx - sx ; toty = ty - sy ; x = sx + d * totx ; y = sy + d * toty ; if ( i = = 0 ) { minx = x ; miny = y ; maxx = x ; maxy = y ; } else { minx = Math . min ( minx , x ) ; miny = Math . min ( miny , y ) ; maxx = Math . max ( maxx , x ) ; maxy = Math . max ( maxy , y ) ; } } return new Rectangle ( Math . round ( minx ) , Math . round ( miny ) , Math . round ( maxx - minx ) , Math . round ( maxy - miny ) ) ; } 
function click ( node ) { try { node . dispatch Event ( new Mouse Event ( 'click ' ) ) ; } catch ( e ) { var evt = document . create Event ( 'Mouse Events ' ) ; evt . init Mouse Event ( 'click ' , true , true , window , 0 , 0 , 0 , 8 0 , 2 0 , false , false , false , false , 0 , null ) ; node . dispatch Event ( evt ) ; } } 
function ( buffer 1 , buffer 2 ) { var combined Buffer = new Uint 8Array ( buffer 1 . byte Length + buffer 2 . byte Length ) ; combined Buffer . set ( new Uint 8Array ( buffer 1 ) , 0 ) ; combined Buffer . set ( new Uint 8Array ( buffer 2 ) , buffer 1 . byte Length ) ; return combined Buffer ; } 
function ( page Info ) { var page Number = page Info ! = = undefined ? page Info . page Number : 1 ; 
function Pub Sub ( context ) { if ( _typeof ( context ) ! = = 'object ' ) { throw new Error ( 'Invalid Context passed to initialize Pub Sub (js PDF -module ) ' ) ; } var topics = { } ; this . subscribe = function ( topic , callback , once ) { once = once | | false ; if ( typeof topic ! = = 'string ' | | typeof callback ! = = 'function ' | | typeof once ! = = 'boolean ' ) { throw new Error ( 'Invalid arguments passed to Pub Sub .subscribe (js PDF -module ) ' ) ; } if ( ! topics . has Own Property ( topic ) ) { topics [ topic ] = { } ; } var token = Math . random ( ) . to String ( 3 5 ) ; topics [ topic ] [ token ] = [ callback , ! ! once ] ; return token ; } ; this . unsubscribe = function ( token ) { for ( var topic in topics ) { if ( topics [ topic ] [ token ] ) { delete topics [ topic ] [ token ] ; if ( Object . keys ( topics [ topic ] ) . length = = = 0 ) { delete topics [ topic ] ; } return true ; } } return false ; } ; this . publish = function ( topic ) { if ( topics . has Own Property ( topic ) ) { var args = Array . prototype . slice . call ( arguments , 1 ) , tokens = [ ] ; for ( var token in topics [ topic ] ) { var sub = topics [ topic ] [ token ] ; try { sub [ 0 ] . apply ( context , args ) ; } catch ( ex ) { if ( global . console ) { console . error ( 'js PDF Pub Sub Error ' , ex . message , ex ) ; } } if ( sub [ 1 ] ) tokens . push ( token ) ; } if ( tokens . length ) tokens . for Each ( this . unsubscribe ) ; } } ; this . get Topics = function ( ) { return topics ; } ; } 
function get Font ( font Name , font Style , options ) { var key = undefined , font Name Lower Case ; options = options | | { } ; font Name = font Name ! = = undefined ? font Name : fonts [ active Font Key ] . font Name ; font Style = font Style ! = = undefined ? font Style : fonts [ active Font Key ] . font Style ; font Name Lower Case = font Name . to Lower Case ( ) ; if ( fontmap [ font Name Lower Case ] ! = = undefined & & fontmap [ font Name Lower Case ] [ font Style ] ! = = undefined ) { key = fontmap [ font Name Lower Case ] [ font Style ] ; } else if ( fontmap [ font Name ] ! = = undefined & & fontmap [ font Name ] [ font Style ] ! = = undefined ) { key = fontmap [ font Name ] [ font Style ] ; } else { if ( options . disable Warning = = = false ) { console . warn ( "Unable to look up font label for font ' " + font Name + " ' , ' " + font Style + " ' . Refer to get Font List ( ) for available fonts . " ) ; } } if ( ! key & & ! options . no Fallback ) { key = fontmap [ 'times ' ] [ font Style ] ; if ( key = = null ) { key = fontmap [ 'times ' ] [ 'normal ' ] ; } } return key ; } 
function calculate Font Space ( text , form Object , font Size ) { var font = scope . internal . get Font ( form Object . font Name , form Object . font Style ) ; var width = scope . get String Unit Width ( text , { font : font , font Size : parse Float ( font Size ) , char Space : 0 } ) * parse Float ( font Size ) ; var height = scope . get String Unit Width ( " 3 " , { font : font , font Size : parse Float ( font Size ) , char Space : 0 } ) * parse Float ( font Size ) * 1 . 5 ; return { height : height , width : width } ; } 
function create Annotation Reference ( object ) { var options = { type : 'reference ' , object : object } ; var find Entry = function find Entry ( entry ) { return entry . type = = = options . type & & entry . object = = = options . object ; } ; if ( scope . internal . get Page Info ( object . page ) . page Context . annotations . find ( find Entry ) = = = undefined ) { scope . internal . get Page Info ( object . page ) . page Context . annotations . push ( options ) ; } } 
function put Catalog Callback ( ) { 
function Acro Form Dictionary Callback ( ) { 
function create Field Callback ( field Array ) { var standard Fields = ! field Array ; if ( ! field Array ) { 
function Acro Form PDFObject ( ) { var _obj Id ; Object . define Property ( this , 'obj Id ' , { configurable : true , get : function get ( ) { if ( ! _obj Id ) { _obj Id = scope . internal . new Object Deferred ( ) ; } if ( ! _obj Id ) { throw new Error ( "Acro Form PDFObject : Couldn 't create Object ID " ) ; } return _obj Id ; } , set : function set ( value ) { _obj Id = value ; } } ) ; } 
function Acro Form Field ( ) { Acro Form PDFObject . call ( this ) ; * (PDF 1 . 2 ) If set , print the annotation when the page is printed . If clear , never print the annotation , regardless of wether is is displayed on the screen . * NOTE 2 This can be useful for annotations representing interactive pushbuttons , which would serve no meaningful purpose on the printed page . * * @name Acro Form Field #show When Printed * @default true * @type {boolean } * / Object . define Property ( this , 'show When Printed ' , { enumerable : true , configurable : true , get : function get ( ) { return Boolean ( get Bit For Pdf ( _F , 3 ) ) ; } , set : function set ( value ) { if ( Boolean ( value ) = = = true ) { this . F = set Bit For Pdf ( _F , 3 ) ; } else { this . F = clear Bit For Pdf ( _F , 3 ) ; } } } ) ; var _Ff = 0 ; Object . define Property ( this , 'Ff ' , { enumerable : false , configurable : false , get : function get ( ) { return _Ff ; } , set : function set ( value ) { if ( ! is Na N ( value ) ) { _Ff = value ; } else { throw new Error ( 'Invalid value " ' + value + ' " for attribute Ff supplied . ' ) ; } } } ) ; var _Rect = [ ] ; Object . define Property ( this , 'Rect ' , { enumerable : false , configurable : false , get : function get ( ) { if ( _Rect . length = = = 0 ) { return ; } return _Rect ; } , set : function set ( value ) { if ( typeof value ! = = "undefined " ) { _Rect = value ; } else { _Rect = [ ] ; } } } ) ; Object . define Property ( this , 'x ' , { enumerable : true , configurable : true , get : function get ( ) { if ( ! _Rect | | is Na N ( _Rect [ 0 ] ) ) { return 0 ; } return anti Scale ( _Rect [ 0 ] ) ; } , set : function set ( value ) { _Rect [ 0 ] = scale ( value ) ; } } ) ; Object . define Property ( this , 'y ' , { enumerable : true , configurable : true , get : function get ( ) { if ( ! _Rect | | is Na N ( _Rect [ 1 ] ) ) { return 0 ; } return anti Scale ( _Rect [ 1 ] ) ; } , set : function set ( value ) { _Rect [ 1 ] = scale ( value ) ; } } ) ; Object . define Property ( this , 'width ' , { enumerable : true , configurable : true , get : function get ( ) { if ( ! _Rect | | is Na N ( _Rect [ 2 ] ) ) { return 0 ; } return anti Scale ( _Rect [ 2 ] ) ; } , set : function set ( value ) { _Rect [ 2 ] = scale ( value ) ; } } ) ; Object . define Property ( this , 'height ' , { enumerable : true , configurable : true , get : function get ( ) { if ( ! _Rect | | is Na N ( _Rect [ 3 ] ) ) { return 0 ; } return anti Scale ( _Rect [ 3 ] ) ; } , set : function set ( value ) { _Rect [ 3 ] = scale ( value ) ; } } ) ; var _FT = " " ; Object . define Property ( this , 'FT ' , { enumerable : true , configurable : false , get : function get ( ) { return _FT ; } , set : function set ( value ) { switch ( value ) { case ' /Btn ' : case ' /Tx ' : case ' /Ch ' : case ' /Sig ' : _FT = value ; break ; default : throw new Error ( 'Invalid value " ' + value + ' " for attribute FT supplied . ' ) ; } } } ) ; var _T = null ; Object . define Property ( this , 'T ' , { enumerable : true , configurable : false , get : function get ( ) { if ( ! _T | | _T . length < 1 ) { * (Optional ) The partial field name (see 1 2 . 7 . 3 . 2 , “Field Names ” ) . * * @name Acro Form Field #field Name * @default null * @type {string } * / Object . define Property ( this , 'field Name ' , { configurable : true , enumerable : true , get : function get ( ) { return _T ; } , set : function set ( value ) { _T = value ; } } ) ; var _font Name = 'helvetica ' ; Object . define Property ( this , 'font Name ' , { enumerable : true , configurable : true , get : function get ( ) { return _font Name ; } , set : function set ( value ) { _font Name = value ; } } ) ; var _font Style = 'normal ' ; Object . define Property ( this , 'font Style ' , { enumerable : true , configurable : true , get : function get ( ) { return _font Style ; } , set : function set ( value ) { _font Style = value ; } } ) ; var _font Size = 0 ; Object . define Property ( this , 'font Size ' , { enumerable : true , configurable : true , get : function get ( ) { return anti Scale ( _font Size ) ; } , set : function set ( value ) { _font Size = scale ( value ) ; } } ) ; var _max Font Size = 5 0 ; Object . define Property ( this , 'max Font Size ' , { enumerable : true , configurable : true , get : function get ( ) { return anti Scale ( _max Font Size ) ; } , set : function set ( value ) { _max Font Size = scale ( value ) ; } } ) ; var _color = 'black ' ; Object . define Property ( this , 'color ' , { enumerable : true , configurable : true , get : function get ( ) { return _color ; } , set : function set ( value ) { _color = value ; } } ) ; var _DA = ' /F 1 0 Tf 0 g ' ; * (Optional ; inheritable ) The default value to which the field reverts when a reset -form action is executed (see 1 2 . 7 . 5 . 3 , “Reset -Form Action ” ) . The format of this value is the same as that of value . * * @name Acro Form Field #default Value * @default null * @type {any } * / Object . define Property ( this , 'default Value ' , { enumerable : true , configurable : true , get : function get ( ) { if ( this instanceof Acro Form Button = = = true ) { return pdf Unescape ( _DV . substr ( 1 , _DV . length - 1 ) ) ; } else { return _DV ; } } , set : function set ( value ) { value = value . to String ( ) ; if ( this instanceof Acro Form Button = = = true ) { _DV = ' / ' + value ; } else { _DV = value ; } } } ) ; var _V = null ; Object . define Property ( this , 'V ' , { enumerable : false , configurable : false , get : function get ( ) { if ( ! _V ) { return ; } if ( this instanceof Acro Form Button = = = false ) { return to Pdf String ( _V ) ; } return _V ; } , set : function set ( value ) { value = value . to String ( ) ; if ( this instanceof Acro Form Button = = = false ) { if ( value . substr ( 0 , 1 ) = = = ' ( ' ) { _V = pdf Unescape ( value . substr ( 1 , value . length - 2 ) ) ; } else { _V = pdf Unescape ( value ) ; } } else { _V = value ; } } } ) ; Object . define Property ( this , 'value ' , { enumerable : true , configurable : true , get : function get ( ) { if ( this instanceof Acro Form Button = = = true ) { return pdf Unescape ( _V . substr ( 1 , _V . length - 1 ) ) ; } else { return _V ; } } , set : function set ( value ) { value = value . to String ( ) ; if ( this instanceof Acro Form Button = = = true ) { _V = ' / ' + value ; } else { _V = value ; } } } ) ; Object . define Property ( this , 'has Annotation ' , { enumerable : true , configurable : true , get : function get ( ) { return this . Rect ; } } ) ; Object . define Property ( this , 'Type ' , { enumerable : true , configurable : false , get : function get ( ) { return this . has Annotation ? " /Annot " : null ; } } ) ; Object . define Property ( this , 'Subtype ' , { enumerable : true , configurable : false , get : function get ( ) { return this . has Annotation ? " /Widget " : null ; } } ) ; var _has Appearance Stream = false ; Object . define Property ( this , 'has Appearance Stream ' , { enumerable : true , configurable : true , writeable : true , get : function get ( ) { return _has Appearance Stream ; } , set : function set ( value ) { value = Boolean ( value ) ; _has Appearance Stream = value ; } } ) ; var _page ; Object . define Property ( this , 'page ' , { enumerable : true , configurable : true , writeable : true , get : function get ( ) { if ( ! _page ) { return ; } return _page ; } , set : function set ( value ) { _page = value ; } } ) ; Object . define Property ( this , 'read Only ' , { enumerable : true , configurable : true , get : function get ( ) { return Boolean ( get Bit For Pdf ( this . Ff , 1 ) ) ; } , set : function set ( value ) { if ( Boolean ( value ) = = = true ) { this . Ff = set Bit For Pdf ( this . Ff , 1 ) ; } else { this . Ff = clear Bit For Pdf ( this . Ff , 1 ) ; } } } ) ; Object . define Property ( this , 'required ' , { enumerable : true , configurable : true , get : function get ( ) { return Boolean ( get Bit For Pdf ( this . Ff , 2 ) ) ; } , set : function set ( value ) { if ( Boolean ( value ) = = = true ) { this . Ff = set Bit For Pdf ( this . Ff , 2 ) ; } else { this . Ff = clear Bit For Pdf ( this . Ff , 2 ) ; } } } ) ; Object . define Property ( this , 'no Export ' , { enumerable : true , configurable : true , get : function get ( ) { return Boolean ( get Bit For Pdf ( this . Ff , 3 ) ) ; } , set : function set ( value ) { if ( Boolean ( value ) = = = true ) { this . Ff = set Bit For Pdf ( this . Ff , 3 ) ; } else { this . Ff = clear Bit For Pdf ( this . Ff , 3 ) ; } } } ) ; var _Q = null ; Object . define Property ( this , 'Q ' , { enumerable : true , configurable : false , get : function get ( ) { if ( _Q = = = null ) { return ; } return _Q ; } , set : function set ( value ) { if ( [ 0 , 1 , 2 ] . index Of ( value ) ! = = - 1 ) { _Q = value ; } else { throw new Error ( 'Invalid value " ' + value + ' " for attribute Q supplied . ' ) ; } } } ) ; Object . define Property ( this , 'text Align ' , { get : function get ( ) { var result = 'left ' ; switch ( _Q ) { case 0 : default : result = 'left ' ; break ; case 1 : result = 'center ' ; break ; case 2 : result = 'right ' ; break ; } return result ; } , configurable : true , enumerable : true , set : function set ( value ) { switch ( value ) { case 'right ' : case 2 : _Q = 2 ; break ; case 'center ' : case 1 : _Q = 1 ; break ; case 'left ' : case 0 : default : _Q = 0 ; } } } ) ; } 
function Acro Form Child Class ( ) { Acro Form Field . call ( this ) ; var _parent ; Object . define Property ( this , 'Parent ' , { enumerable : false , configurable : false , get : function get ( ) { return _parent ; } , set : function set ( value ) { _parent = value ; } } ) ; var _option Name ; Object . define Property ( this , 'option Name ' , { enumerable : false , configurable : true , get : function get ( ) { return _option Name ; } , set : function set ( value ) { _option Name = value ; } } ) ; var _MK = { } ; Object . define Property ( this , 'MK ' , { enumerable : false , configurable : false , get : function get ( ) { var result = [ ] ; result . push ( ' < < ' ) ; var key ; for ( key in _MK ) { result . push ( ' / ' + key + ' ( ' + _MK [ key ] + ' ) ' ) ; } result . push ( ' > > ' ) ; return result . join ( ' \n ' ) ; } , set : function set ( value ) { if ( _typeof ( value ) = = = "object " ) { _MK = value ; } } } ) ; Object . define Property ( this , 'caption ' , { enumerable : true , configurable : true , get : function get ( ) { return _MK . CA | | ' ' ; } , set : function set ( value ) { if ( typeof value = = = "string " ) { _MK . CA = value ; } } } ) ; var _AS ; Object . define Property ( this , 'AS ' , { enumerable : false , configurable : false , get : function get ( ) { return _AS ; } , set : function set ( value ) { _AS = value ; } } ) ; Object . define Property ( this , 'appearance State ' , { enumerable : true , configurable : true , get : function get ( ) { return _AS . substr ( 1 , _AS . length - 1 ) ; } , set : function set ( value ) { _AS = ' / ' + value ; } } ) ; this . option Name = name ; this . caption = 'l ' ; this . appearance State = 'Off ' ; 
function Yes Push Down ( form Object ) { var xobj = create Form XObject ( form Object ) ; var stream = [ ] ; var font Key = scope . internal . get Font ( form Object . font Name , form Object . font Style ) . id ; var encoded Color = scope . _ _private _ _ . encode Color String ( form Object . color ) ; var calc Res = calculate X ( form Object , form Object . caption ) ; stream . push ( " 0 . 7 4 9 0 2 3 g " ) ; stream . push ( " 0 0 " + f 2 ( Acro Form Appearance . internal . get Width ( form Object ) ) + " " + f 2 ( Acro Form Appearance . internal . get Height ( form Object ) ) + " re " ) ; stream . push ( "f " ) ; stream . push ( "BMC " ) ; stream . push ( "q " ) ; stream . push ( " 0 0 1 rg " ) ; stream . push ( " / " + font Key + " " + f 2 ( calc Res . font Size ) + " Tf " + encoded Color ) ; stream . push ( "BT " ) ; stream . push ( calc Res . text ) ; stream . push ( "ET " ) ; stream . push ( "Q " ) ; stream . push ( "EMC " ) ; xobj . stream = stream . join ( " \n " ) ; return xobj ; } 
function Off Push Down ( form Object ) { var xobj = create Form XObject ( form Object ) ; var stream = [ ] ; stream . push ( " 0 . 7 4 9 0 2 3 g " ) ; stream . push ( " 0 0 " + f 2 ( Acro Form Appearance . internal . get Width ( form Object ) ) + " " + f 2 ( Acro Form Appearance . internal . get Height ( form Object ) ) + " re " ) ; stream . push ( "f " ) ; xobj . stream = stream . join ( " \n " ) ; return xobj ; } 
function create Default Appearance Stream ( form Object ) { 
function put Image ( img ) { var object Number = this . internal . new Object ( ) , out = this . internal . write , put Stream = this . internal . put Stream , get Filters = this . internal . get Filters ; var filters = get Filters ( ) ; while ( filters . index Of ( 'Flate Encode ' ) ! = = - 1 ) { filters . splice ( filters . index Of ( 'Flate Encode ' ) , 1 ) ; } img [ 'n ' ] = object Number ; var additional Key Values = [ ] ; additional Key Values . push ( { key : 'Type ' , value : ' /XObject ' } ) ; additional Key Values . push ( { key : 'Subtype ' , value : ' /Image ' } ) ; additional Key Values . push ( { key : 'Width ' , value : img [ 'w ' ] } ) ; additional Key Values . push ( { key : 'Height ' , value : img [ 'h ' ] } ) ; if ( img [ 'cs ' ] = = = this . color _spaces . INDEXED ) { additional Key Values . push ( { key : 'Color Space ' , value : ' [ /Indexed /Device RGB ' 
function put XObjects Dict Callback ( ) { var images = this . internal . collections [ namespace + 'images ' ] , out = this . internal . write , image ; for ( var i in images ) { image = images [ i ] ; out ( ' /I ' + image [ 'i ' ] , image [ 'n ' ] , ' 0 ' , 'R ' ) ; } } 
function get Images ( ) { var images = this . internal . collections [ namespace + 'images ' ] ; 
function get Image Index ( images ) { var image Index = 0 ; if ( images ) { 
function generate Alias From Image Data ( image Data ) { if ( typeof image Data = = = 'string ' ) { return js PDFAPI . s Hash Code ( image Data ) ; } if ( js PDFAPI . is Array Buffer View ( image Data ) ) { return js PDFAPI . s Hash Code ( js PDFAPI . array Buffer To Binary String ( image Data ) ) ; } return null ; } 
function create Data URIFrom Element ( element , format ) { 
function check Images For Alias ( alias , images ) { var cached _info ; if ( images ) { for ( var e in images ) { if ( alias = = = images [ e ] . alias ) { cached _info = images [ e ] ; break ; } } } return cached _info ; } 
function determine Width And Height ( w , h , info ) { if ( ! w & & ! h ) { w = - 9 6 ; h = - 9 6 ; } if ( w < 0 ) { w = - 1 * info [ 'w ' ] * 7 2 / w / this . internal . scale Factor ; } if ( h < 0 ) { h = - 1 * info [ 'h ' ] * 7 2 / h / this . internal . scale Factor ; } if ( w = = = 0 ) { w = h * info [ 'w ' ] / info [ 'h ' ] ; } if ( h = = = 0 ) { h = w * info [ 'h ' ] / info [ 'w ' ] ; } return [ w , h ] ; } 
function write Image To PDF ( x , y , w , h , info , index , images , rotation ) { var dims = determine Width And Height . call ( this , w , h , info ) , coord = this . internal . get Coordinate String , vcoord = this . internal . get Vertical Coordinate String ; w = dims [ 0 ] ; h = dims [ 1 ] ; images [ index ] = info ; if ( rotation ) { rotation * = Math . PI / 1 8 0 ; var c = Math . cos ( rotation ) ; var s = Math . sin ( rotation ) ; 
function get Jpeg Size ( img Data ) { var width , height , numcomponents ; 
function get Jpeg Size From Bytes ( data ) { var hdr = data [ 0 ] < < 8 | data [ 1 ] ; if ( hdr ! = = 0x FFD 8 ) throw new Error ( 'Supplied data is not a JPEG ' ) ; var len = data . length , block = ( data [ 4 ] < < 8 ) + data [ 5 ] , pos = 4 , bytes , width , height , numcomponents ; while ( pos < len ) { pos + = block ; bytes = read Bytes ( data , pos ) ; block = ( bytes [ 2 ] < < 8 ) + bytes [ 3 ] ; if ( ( bytes [ 1 ] = = = 0x C 0 | | bytes [ 1 ] = = = 0x C 2 ) & & bytes [ 0 ] = = = 0x FF & & block > 7 ) { bytes = read Bytes ( data , pos + 5 ) ; width = ( bytes [ 2 ] < < 8 ) + bytes [ 3 ] ; height = ( bytes [ 0 ] < < 8 ) + bytes [ 1 ] ; numcomponents = bytes [ 4 ] ; return { width : width , height : height , numcomponents : numcomponents } ; } pos + = 2 ; } throw new Error ( 'get Jpeg Size From Bytes could not find the size of the image ' ) ; } 
function set Last Cell Position ( x , y , w , h , ln ) { last Cell Pos = { 'x ' : x , 'y ' : y , 'w ' : w , 'h ' : h , 'ln ' : ln } ; } 
function draw Paths ( rule , is Clip ) { if ( rule = = = 'stroke ' & & ! is Clip & & is Stroke Transparent . call ( this ) ) { return ; } if ( rule ! = = 'stroke ' & & ! is Clip & & is Fill Transparent . call ( this ) ) { return ; } var moves = [ ] ; var alpha = this . ctx . global Alpha ; if ( this . ctx . fill Opacity < 1 ) { alpha = this . ctx . fill Opacity ; } var x Path = this . path ; for ( var i = 0 ; i < x Path . length ; i + + ) { var pt = x Path [ i ] ; switch ( pt . type ) { case 'begin ' : moves . push ( { begin : true } ) ; break ; case 'close ' : moves . push ( { close : true } ) ; break ; case 'mt ' : moves . push ( { start : pt , deltas : [ ] , abs : [ ] } ) ; break ; case 'lt ' : var iii = moves . length ; if ( ! is Na N ( x Path [ i - 1 ] . x ) ) { var delta = [ pt . x - x Path [ i - 1 ] . x , pt . y - x Path [ i - 1 ] . y ] ; if ( iii > 0 ) { for ( iii ; iii > = 0 ; iii - - ) { if ( moves [ iii - 1 ] . close ! = = true & & moves [ iii - 1 ] . begin ! = = true ) { moves [ iii - 1 ] . deltas . push ( delta ) ; moves [ iii - 1 ] . abs . push ( pt ) ; break ; } } } } break ; case 'bct ' : var delta = [ pt . x 1 - x Path [ i - 1 ] . x , pt . y 1 - x Path [ i - 1 ] . y , pt . x 2 - x Path [ i - 1 ] . x , pt . y 2 - x Path [ i - 1 ] . y , pt . x - x Path [ i - 1 ] . x , pt . y - x Path [ i - 1 ] . y ] ; moves [ moves . length - 1 ] . deltas . push ( delta ) ; break ; case 'qct ' : var x 1 = x Path [ i - 1 ] . x + 2 . 0 / 3 . 0 * ( pt . x 1 - x Path [ i - 1 ] . x ) ; var y 1 = x Path [ i - 1 ] . y + 2 . 0 / 3 . 0 * ( pt . y 1 - x Path [ i - 1 ] . y ) ; var x 2 = pt . x + 2 . 0 / 3 . 0 * ( pt . x 1 - pt . x ) ; var y 2 = pt . y + 2 . 0 / 3 . 0 * ( pt . y 1 - pt . y ) ; var x 3 = pt . x ; var y 3 = pt . y ; var delta = [ x 1 - x Path [ i - 1 ] . x , y 1 - x Path [ i - 1 ] . y , x 2 - x Path [ i - 1 ] . x , y 2 - x Path [ i - 1 ] . y , x 3 - x Path [ i - 1 ] . x , y 3 - x Path [ i - 1 ] . y ] ; moves [ moves . length - 1 ] . deltas . push ( delta ) ; break ; case 'arc ' : moves . push ( { deltas : [ ] , abs : [ ] , arc : true } ) ; if ( Array . is Array ( moves [ moves . length - 1 ] . abs ) ) { moves [ moves . length - 1 ] . abs . push ( pt ) ; } break ; } } var style ; if ( ! is Clip ) { if ( rule = = = 'stroke ' ) { style = 'stroke ' ; } else { style = 'fill ' ; } } else { style = null ; } for ( var i = 0 ; i < moves . length ; i + + ) { if ( moves [ i ] . arc ) { var arcs = moves [ i ] . abs ; for ( var ii = 0 ; ii < arcs . length ; ii + + ) { var arc = arcs [ ii ] ; if ( typeof arc . start Angle ! = = 'undefined ' ) { var start = rad 2deg ( arc . start Angle ) ; var end = rad 2deg ( arc . end Angle ) ; var x = arc . x ; var y = arc . y ; draw Arc . call ( this , x , y , arc . radius , start , end , arc . counterclockwise , style , is Clip ) ; } else { draw Line . call ( this , arc . x , arc . y ) ; } } } if ( ! moves [ i ] . arc ) { if ( moves [ i ] . close ! = = true & & moves [ i ] . begin ! = = true ) { var x = moves [ i ] . start . x ; var y = moves [ i ] . start . y ; draw Lines . call ( this , moves [ i ] . deltas , x , y , null , null ) ; } } } if ( style ) { put Style . call ( this , style ) ; } if ( is Clip ) { do Clip . call ( this ) ; } } 
function create Arc ( radius , start Angle , end Angle , anticlockwise ) { var EPSILON = 0 . 0 0 0 0 1 ; 
function create Small Arc ( r , a 1 , a 2 ) { var a = ( a 2 - a 1 ) / 2 . 0 ; var x 4 = r * Math . cos ( a ) ; var y 4 = r * Math . sin ( a ) ; var x 1 = x 4 ; var y 1 = - y 4 ; var q 1 = x 1 * x 1 + y 1 * y 1 ; var q 2 = q 1 + x 1 * x 4 + y 1 * y 4 ; var k 2 = 4 / 3 * ( Math . sqrt ( 2 * q 1 * q 2 ) - q 2 ) / ( x 1 * y 4 - y 1 * x 4 ) ; var x 2 = x 1 - k 2 * y 1 ; var y 2 = y 1 + k 2 * x 1 ; var x 3 = x 2 ; var y 3 = - y 2 ; var ar = a + a 1 ; var cos _ar = Math . cos ( ar ) ; var sin _ar = Math . sin ( ar ) ; return { x 1 : r * Math . cos ( a 1 ) , y 1 : r * Math . sin ( a 1 ) , x 2 : x 2 * cos _ar - y 2 * sin _ar , y 2 : x 2 * sin _ar + y 2 * cos _ar , x 3 : x 3 * cos _ar - y 3 * sin _ar , y 3 : x 3 * sin _ar + y 3 * cos _ar , x 4 : r * Math . cos ( a 2 ) , y 4 : r * Math . sin ( a 2 ) } ; } 
function ASCIIHex Encode ( value ) { var result = ' ' ; var i ; for ( var i = 0 ; i < value . length ; i + = 1 ) { result + = ( " 0 " + value . char Code At ( i ) . to String ( 1 6 ) ) . slice ( - 2 ) ; } result + = ' > ' ; return result ; } 
function compress Bytes ( bytes , line Length , colors Per Pixel , compression ) { var level = 5 , filter _method = filter Up ; switch ( compression ) { case js PDFAPI . image _compression . FAST : level = 3 ; filter _method = filter Sub ; break ; case js PDFAPI . image _compression . MEDIUM : level = 6 ; filter _method = filter Average ; break ; case js PDFAPI . image _compression . SLOW : level = 9 ; filter _method = filter Paeth ; 
function create Zlib Header ( bytes , level ) { var cm = 8 ; var cinfo = Math . LOG 2E * Math . log ( 0x 8 0 0 0 ) - 8 ; var cmf = cinfo < < 4 | cm ; var hdr = cmf < < 8 ; var flevel = Math . min ( 3 , ( level - 1 & 0xff ) > > 1 ) ; hdr | = flevel < < 6 ; hdr | = 0 ; 
function adler 3 2 ( array , param ) { var adler = 1 ; var s 1 = adler & 0xffff , s 2 = adler > > > 1 6 & 0xffff ; var len = array . length ; var tlen ; var i = 0 ; while ( len > 0 ) { tlen = len > param ? param : len ; len - = tlen ; do { s 1 + = array [ i + + ] ; s 2 + = s 1 ; } while ( - - tlen ) ; s 1 % = 6 5 5 2 1 ; s 2 % = 6 5 5 2 1 ; } return ( s 2 < < 1 6 | s 1 ) > > > 0 ; } 
function apply Png Filter Method ( bytes , line Length , colors Per Pixel , filter _method ) { var lines = bytes . length / line Length , result = new Uint 8Array ( bytes . length + lines ) , filter _methods = get Filter Methods ( ) , i = 0 , line , prev Line , offset ; for ( ; i < lines ; i + + ) { offset = i * line Length ; line = bytes . subarray ( offset , offset + line Length ) ; if ( filter _method ) { result . set ( filter _method ( line , colors Per Pixel , prev Line ) , offset + i ) ; } else { var j = 0 , len = filter _methods . length , results = [ ] ; for ( ; j < len ; j + + ) { results [ j ] = filter _methods [ j ] ( line , colors Per Pixel , prev Line ) ; } var ind = get Index Of Smallest Sum ( results . concat ( ) ) ; result . set ( results [ ind ] , offset + i ) ; } prev Line = line ; } return result ; } 
function filter None ( line , colors Per Pixel , prev Line ) { var result = Array . apply ( [ ] , line ) ; result . unshift ( 0 ) ; return result ; } 
function paeth Predictor ( left , up , up Left ) { var p = left + up - up Left , p Left = Math . abs ( p - left ) , p Up = Math . abs ( p - up ) , p Up Left = Math . abs ( p - up Left ) ; return p Left < = p Up & & p Left < = p Up Left ? left : p Up < = p Up Left ? up : up Left ; } 
function get Index Of Smallest Sum ( arrays ) { var i = 0 , len = arrays . length , sum , min , ind ; while ( i < len ) { sum = abs Sum ( arrays [ i ] . slice ( 1 ) ) ; if ( sum < min | | ! min ) { min = sum ; ind = i ; } i + + ; } return ind ; } 
function abs Sum ( array ) { var i = 0 , len = array . length , sum = 0 ; while ( i < len ) { sum + = Math . abs ( array [ i + + ] ) ; } return sum ; } 
function get Predictor From Compression ( compression ) { var predictor ; switch ( compression ) { case js PDFAPI . image _compression . FAST : predictor = 1 1 ; break ; case js PDFAPI . image _compression . MEDIUM : predictor = 1 3 ; break ; case js PDFAPI . image _compression . SLOW : predictor = 1 4 ; break ; default : predictor = 1 2 ; break ; } return predictor ; } 
function split Long Word ( word , widths _array , first Line Max Len , max Len ) { var answer = [ ] ; 
function split Paragraph Into Lines ( text , maxlen , options ) { 
function uncompress ( data ) { var decoded = ' 0 1 2 3 4 5 6 7 8 9abcdef ' , encoded = 'klmnopqrstuvwxyz ' , mapping = { } ; for ( var i = 0 ; i < encoded . length ; i + + ) { mapping [ encoded [ i ] ] = decoded [ i ] ; } var undef , output = { } , sign = 1 , stringparts 
function _get Char Type ( ch ) { var char Code = ch . char Code At ( ) , range = char Code > > 8 , range Idx = _UNICODE _RANGES _MAP [ range ] ; if ( range Idx ! = = undefined ) { return _UNICODE _TYPES [ range Idx * 2 5 6 + ( char Code & 0x FF ) ] ; } else if ( range = = = 0x FC | | range = = = 0x FD ) { return "AL " ; } else if ( _LTR _RANGES _REG _EXPR . test ( range ) ) { 
function _resolve Char Type ( chars , types , resolved Types , index ) { var c Type = types [ index ] , w Type , n Type , i , len ; switch ( c Type ) { case "L " : case "R " : _last Arabic = false ; break ; case "N " : case "AN " : break ; case "EN " : if ( _last Arabic ) { c Type = "AN " ; } break ; case "AL " : _last Arabic = true ; c Type = "R " ; break ; case "WS " : c Type = "N " ; break ; case "CS " : if ( index < 1 | | index + 1 > = types . length | | ( w Type = resolved Types [ index - 1 ] ) ! = = "EN " & & w Type ! = = "AN " | | ( n Type = types [ index + 1 ] ) ! = = "EN " & & n Type ! = = "AN " ) { c Type = "N " ; } else if ( _last Arabic ) { n Type = "AN " ; } c Type = n Type = = = w Type ? n Type : "N " ; break ; case "ES " : w Type = index > 0 ? resolved Types [ index - 1 ] : "B " ; c Type = w Type = = = "EN " & & index + 1 < types . length & & types [ index + 1 ] = = = "EN " ? "EN " : "N " ; break ; case "ET " : if ( index > 0 & & resolved Types [ index - 1 ] = = = "EN " ) { c Type = "EN " ; break ; } else if ( _last Arabic ) { c Type = "N " ; break ; } i = index + 1 ; len = types . length ; while ( i < len & & types [ i ] = = = "ET " ) { i + + ; } if ( i < len & & types [ i ] = = = "EN " ) { c Type = "EN " ; } else { c Type = "N " ; } break ; case "NSM " : if ( _is In Visual & & ! _is In Rtl ) { 
function _compute Levels ( chars , levels , params ) { var action , condition , i , index , new Level , prev State , cond Pos = - 1 , len = chars . length , new State = 0 , resolved Types = [ ] , state Table = _dir ? _STATE _TABLE _RTL : _STATE _TABLE _LTR , types = [ ] ; _last Arabic = false ; _has Ubat B = false ; _has Ubat S = false ; for ( i = 0 ; i < len ; i + + ) { types [ i ] = _get Char Type ( chars [ i ] ) ; } for ( index = 0 ; index < len ; index + + ) { prev State = new State ; resolved Types [ index ] = _resolve Char Type ( chars , types , resolved Types , index ) ; new State = state Table [ prev State ] [ _TYPE _NAMES _MAP [ resolved Types [ index ] ] ] ; action = new State & 0x F 0 ; new State & = 0x 0F ; levels [ index ] = new Level = state Table [ new State ] [ 5 ] ; if ( action > 0 ) { if ( action = = = 0x 1 0 ) { for ( i = cond Pos ; i < index ; i + + ) { levels [ i ] = 1 ; } cond Pos = - 1 ; } else { cond Pos = - 1 ; } } condition = state Table [ new State ] [ 6 ] ; if ( condition ) { if ( cond Pos = = = - 1 ) { cond Pos = index ; } } else { if ( cond Pos > - 1 ) { for ( i = cond Pos ; i < index ; i + + ) { levels [ i ] = new Level ; } cond Pos = - 1 ; } } if ( types [ index ] = = = "B " ) { levels [ index ] = 0 ; } params . hi Level | = new Level ; } if ( _has Ubat S ) { _handle Ubat S ( types , levels , len ) ; } } 
function _invert By Level ( level , char Array , source To Target Map , levels , params ) { if ( params . hi Level < level ) { return ; } if ( level = = = 1 & & _dir = = = DIR _RTL & & ! _has Ubat B ) { char Array . reverse ( ) ; source To Target Map & & source To Target Map . reverse ( ) ; return ; } var ch , high , end , low , len = char Array . length , start = 0 ; while ( start < len ) { if ( levels [ start ] > = level ) { end = start + 1 ; while ( end < len & & levels [ end ] > = level ) { end + + ; } for ( low = start , high = end - 1 ; low < high ; low + + , high - - ) { ch = char Array [ low ] ; char Array [ low ] = char Array [ high ] ; char Array [ high ] = ch ; if ( source To Target Map ) { ch = source To Target Map [ low ] ; source To Target Map [ low ] = source To Target Map [ high ] ; source To Target Map [ high ] = ch ; } } start = end ; } start + + ; } } 
function _symmetric Swap ( char Array , levels , params ) { if ( params . hi Level ! = = 0 & & _is Symmetric Swapping ) { for ( var i = 0 , index ; i < char Array . length ; i + + ) { if ( levels [ i ] = = = 1 ) { index = _SWAP _TABLE . index Of ( char Array [ i ] ) ; if ( index > = 0 ) { char Array [ i ] = _SWAP _TABLE [ index + 1 ] ; } } } } } 
function JPEGEncoder ( quality ) { var ffloor = Math . floor ; var YTable = new Array ( 6 4 ) ; var UVTable = new Array ( 6 4 ) ; var fdtbl _Y = new Array ( 6 4 ) ; var fdtbl _UV = new Array ( 6 4 ) ; var YDC _HT ; var UVDC _HT ; var YAC _HT ; var UVAC _HT ; var bitcode = new Array ( 6 5 5 3 5 ) ; var category = new Array ( 6 5 5 3 5 ) ; var outputf DCTQuant = new Array ( 6 4 ) ; var DU = new Array ( 6 4 ) ; var byteout = [ ] ; var bytenew = 0 ; var bytepos = 7 ; var YDU = new Array ( 6 4 ) ; var UDU = new Array ( 6 4 ) ; var VDU = new Array ( 6 4 ) ; var clt = new Array ( 2 5 6 ) ; var RGB _YUV _TABLE = new Array ( 2 0 4 8 ) ; var current Quality ; var Zig Zag = [ 0 , 1 , 5 , 6 , 1 4 , 1 5 , 2 7 , 2 8 , 2 , 4 , 7 , 1 3 , 1 6 , 2 6 , 2 9 , 4 2 , 3 , 8 , 1 2 , 1 7 , 2 5 , 3 0 , 4 1 , 4 3 , 9 , 1 1 , 1 8 , 2 4 , 3 1 , 4 0 , 4 4 , 5 3 , 1 0 , 1 9 , 2 3 , 3 2 , 3 9 , 4 5 , 5 2 , 5 4 , 2 0 , 2 2 , 3 3 , 3 8 , 4 6 , 5 1 , 5 5 , 6 0 , 2 1 , 3 4 , 3 7 , 4 7 , 5 0 , 5 6 , 5 9 , 6 1 , 3 5 , 3 6 , 4 8 , 4 9 , 5 7 , 5 8 , 6 2 , 6 3 ] ; var std _dc _luminance _nrcodes = [ 0 , 0 , 1 , 5 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var std _dc _luminance _values = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 0 , 1 1 ] ; var std _ac _luminance _nrcodes = [ 0 , 0 , 2 , 1 , 3 , 3 , 2 , 4 , 3 , 5 , 5 , 4 , 4 , 0 , 0 , 1 , 0x 7d ] ; var std _ac _luminance _values = [ 0x 0 1 , 0x 0 2 , 0x 0 3 , 0x 0 0 , 0x 0 4 , 0x 1 1 , 0x 0 5 , 0x 1 2 , 0x 2 1 , 0x 3 1 , 0x 4 1 , 0x 0 6 , 0x 1 3 , 0x 5 1 , 0x 6 1 , 0x 0 7 , 0x 2 2 , 0x 7 1 , 0x 1 4 , 0x 3 2 , 0x 8 1 , 0x 9 1 , 0xa 1 , 0x 0 8 , 0x 2 3 , 0x 4 2 , 0xb 1 , 0xc 1 , 0x 1 5 , 0x 5 2 , 0xd 1 , 0xf 0 , 0x 2 4 , 0x 3 3 , 0x 6 2 , 0x 7 2 , 0x 8 2 , 0x 0 9 , 0x 0a , 0x 1 6 , 0x 1 7 , 0x 1 8 , 0x 1 9 , 0x 1a , 0x 2 5 , 0x 2 6 , 0x 2 7 , 0x 2 8 , 0x 2 9 , 0x 2a , 0x 3 4 , 0x 3 5 , 0x 3 6 , 0x 3 7 , 0x 3 8 , 0x 3 9 , 0x 3a , 0x 4 3 , 0x 4 4 , 0x 4 5 , 0x 4 6 , 0x 4 7 , 0x 4 8 , 0x 4 9 , 0x 4a , 0x 5 3 , 0x 5 4 , 0x 5 5 , 0x 5 6 , 0x 5 7 , 0x 5 8 , 0x 5 9 , 0x 5a , 0x 6 3 , 0x 6 4 , 0x 6 5 , 0x 6 6 , 0x 6 7 , 0x 6 8 , 0x 6 9 , 0x 6a , 0x 7 3 , 0x 7 4 , 0x 7 5 , 0x 7 6 , 0x 7 7 , 0x 7 8 , 0x 7 9 , 0x 7a , 0x 8 3 , 0x 8 4 , 0x 8 5 , 0x 8 6 , 0x 8 7 , 0x 8 8 , 0x 8 9 , 0x 8a , 0x 9 2 , 0x 9 3 , 0x 9 4 , 0x 9 5 , 0x 9 6 , 0x 9 7 , 0x 9 8 , 0x 9 9 , 0x 9a , 0xa 2 , 0xa 3 , 0xa 4 , 0xa 5 , 0xa 6 , 0xa 7 , 0xa 8 , 0xa 9 , 0xaa , 0xb 2 , 0xb 3 , 0xb 4 , 0xb 5 , 0xb 6 , 0xb 7 , 0xb 8 , 0xb 9 , 0xba , 0xc 2 , 0xc 3 , 0xc 4 , 0xc 5 , 0xc 6 , 0xc 7 , 0xc 8 , 0xc 9 , 0xca , 0xd 2 , 0xd 3 , 0xd 4 , 0xd 5 , 0xd 6 , 0xd 7 , 0xd 8 , 0xd 9 , 0xda , 0xe 1 , 0xe 2 , 0xe 3 , 0xe 4 , 0xe 5 , 0xe 6 , 0xe 7 , 0xe 8 , 0xe 9 , 0xea , 0xf 1 , 0xf 2 , 0xf 3 , 0xf 4 , 0xf 5 , 0xf 6 , 0xf 7 , 0xf 8 , 0xf 9 , 0xfa ] ; var std _dc _chrominance _nrcodes = [ 0 , 0 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] ; var std _dc _chrominance _values = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 0 , 1 1 ] ; var std _ac _chrominance _nrcodes = [ 0 , 0 , 2 , 1 , 2 , 4 , 4 , 3 , 4 , 7 , 5 , 4 , 4 , 0 , 1 , 2 , 0x 7 7 ] ; var std _ac _chrominance _values = [ 0x 0 0 , 0x 0 1 , 0x 0 2 , 0x 0 3 , 0x 1 1 , 0x 0 4 , 0x 0 5 , 0x 2 1 , 0x 3 1 , 0x 0 6 , 0x 1 2 , 0x 4 1 , 0x 5 1 , 0x 0 7 , 0x 6 1 , 0x 7 1 , 0x 1 3 , 0x 2 2 , 0x 3 2 , 0x 8 1 , 0x 0 8 , 0x 1 4 , 0x 4 2 , 0x 9 1 , 0xa 1 , 0xb 1 , 0xc 1 , 0x 0 9 , 0x 2 3 , 0x 3 3 , 0x 5 2 , 0xf 0 , 0x 1 5 , 0x 6 2 , 0x 7 2 , 0xd 1 , 0x 0a , 0x 1 6 , 0x 2 4 , 0x 3 4 , 0xe 1 , 0x 2 5 , 0xf 1 , 0x 1 7 , 0x 1 8 , 0x 1 9 , 0x 1a , 0x 2 6 , 0x 2 7 , 0x 2 8 , 0x 2 9 , 0x 2a , 0x 3 5 , 0x 3 6 , 0x 3 7 , 0x 3 8 , 0x 3 9 , 0x 3a , 0x 4 3 , 0x 4 4 , 0x 4 5 , 0x 4 6 , 0x 4 7 , 0x 4 8 , 0x 4 9 , 0x 4a , 0x 5 3 , 0x 5 4 , 0x 5 5 , 0x 5 6 , 0x 5 7 , 0x 5 8 , 0x 5 9 , 0x 5a , 0x 6 3 , 0x 6 4 , 0x 6 5 , 0x 6 6 , 0x 6 7 , 0x 6 8 , 0x 6 9 , 0x 6a , 0x 7 3 , 0x 7 4 , 0x 7 5 , 0x 7 6 , 0x 7 7 , 0x 7 8 , 0x 7 9 , 0x 7a , 0x 8 2 , 0x 8 3 , 0x 8 4 , 0x 8 5 , 0x 8 6 , 0x 8 7 , 0x 8 8 , 0x 8 9 , 0x 8a , 0x 9 2 , 0x 9 3 , 0x 9 4 , 0x 9 5 , 0x 9 6 , 0x 9 7 , 0x 9 8 , 0x 9 9 , 0x 9a , 0xa 2 , 0xa 3 , 0xa 4 , 0xa 5 , 0xa 6 , 0xa 7 , 0xa 8 , 0xa 9 , 0xaa , 0xb 2 , 0xb 3 , 0xb 4 , 0xb 5 , 0xb 6 , 0xb 7 , 0xb 8 , 0xb 9 , 0xba , 0xc 2 , 0xc 3 , 0xc 4 , 0xc 5 , 0xc 6 , 0xc 7 , 0xc 8 , 0xc 9 , 0xca , 0xd 2 , 0xd 3 , 0xd 4 , 0xd 5 , 0xd 6 , 0xd 7 , 0xd 8 , 0xd 9 , 0xda , 0xe 2 , 0xe 3 , 0xe 4 , 0xe 5 , 0xe 6 , 0xe 7 , 0xe 8 , 0xe 9 , 0xea , 0xf 2 , 0xf 3 , 0xf 4 , 0xf 5 , 0xf 6 , 0xf 7 , 0xf 8 , 0xf 9 , 0xfa ] ; function init Quant Tables ( sf ) { var YQT = [ 1 6 , 1 1 , 1 0 , 1 6 , 2 4 , 4 0 , 5 1 , 6 1 , 1 2 , 1 2 , 1 4 , 1 9 , 2 6 , 5 8 , 6 0 , 5 5 , 1 4 , 1 3 , 1 6 , 2 4 , 4 0 , 5 7 , 6 9 , 5 6 , 1 4 , 1 7 , 2 2 , 2 9 , 5 1 , 8 7 , 8 0 , 6 2 , 1 8 , 2 2 , 3 7 , 5 6 , 6 8 , 1 0 9 , 1 0 3 , 7 7 , 2 4 , 3 5 , 5 5 , 6 4 , 8 1 , 1 0 4 , 1 1 3 , 9 2 , 4 9 , 6 4 , 7 8 , 8 7 , 1 0 3 , 1 2 1 , 1 2 0 , 1 0 1 , 7 2 , 9 2 , 9 5 , 9 8 , 1 1 2 , 1 0 0 , 1 0 3 , 9 9 ] ; for ( var i = 0 ; i < 6 4 ; i + + ) { var t = ffloor ( ( YQT [ i ] * sf + 5 0 ) / 1 0 0 ) ; if ( t < 1 ) { t = 1 ; } else if ( t > 2 5 5 ) { t = 2 5 5 ; } YTable [ Zig Zag [ i ] ] = t ; } var UVQT = [ 1 7 , 1 8 , 2 4 , 4 7 , 9 9 , 9 9 , 9 9 , 9 9 , 1 8 , 2 1 , 2 6 , 6 6 , 9 9 , 9 9 , 9 9 , 9 9 , 2 4 , 2 6 , 5 6 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 4 7 , 6 6 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 , 9 9 ] ; for ( var j = 0 ; j < 6 4 ; j + + ) { var u = ffloor ( ( UVQT [ j ] * sf + 5 0 ) / 1 0 0 ) ; if ( u < 1 ) { u = 1 ; } else if ( u > 2 5 5 ) { u = 2 5 5 ; } UVTable [ Zig Zag [ j ] ] = u ; } var aasf = [ 1 . 0 , 1 . 3 8 7 0 3 9 8 4 5 , 1 . 3 0 6 5 6 2 9 6 5 , 1 . 1 7 5 8 7 5 6 0 2 , 1 . 0 , 0 . 7 8 5 6 9 4 9 5 8 , 0 . 5 4 1 1 9 6 1 0 0 , 0 . 2 7 5 8 9 9 3 7 9 ] ; var k = 0 ; for ( var row = 0 ; row < 8 ; row + + ) { for ( var col = 0 ; col < 8 ; col + + ) { fdtbl _Y [ k ] = 1 . 0 / ( YTable [ Zig Zag [ k ] ] * aasf [ row ] * aasf [ col ] * 8 . 0 ) ; fdtbl _UV [ k ] = 1 . 0 / ( UVTable [ Zig Zag [ k ] ] * aasf [ row ] * aasf [ col ] * 8 . 0 ) ; k + + ; } } } function compute Huffman Tbl ( nrcodes , std _table ) { var codevalue = 0 ; var pos _in _table = 0 ; var HT = new Array ( ) ; for ( var k = 1 ; k < = 1 6 ; k + + ) { for ( var j = 1 ; j < = nrcodes [ k ] ; j + + ) { HT [ std _table [ pos _in _table ] ] = [ ] ; HT [ std _table [ pos _in _table ] ] [ 0 ] = codevalue ; HT [ std _table [ pos _in _table ] ] [ 1 ] = k ; pos _in _table + + ; codevalue + + ; } codevalue * = 2 ; } return HT ; } function init Huffman Tbl ( ) { YDC _HT = compute Huffman Tbl ( std _dc _luminance _nrcodes , std _dc _luminance _values ) ; UVDC _HT = compute Huffman Tbl ( std _dc _chrominance _nrcodes , std _dc _chrominance _values ) ; YAC _HT = compute Huffman Tbl ( std _ac _luminance _nrcodes , std _ac _luminance _values ) ; UVAC _HT = compute Huffman Tbl ( std _ac _chrominance _nrcodes , std _ac _chrominance _values ) ; } function init Category Number ( ) { var nrlower = 1 ; var nrupper = 2 ; for ( var cat = 1 ; cat < = 1 5 ; cat + + ) { YDU [pos ] = ( ( ( 0 . 2 9 9 0 0 ) *r + ( 0 . 5 8 7 0 0 ) *g + ( 0 . 1 1 4 0 0 ) *b ) ) - 1 2 8 ; UDU [pos ] = ( ( ( - 0 . 1 6 8 7 4 ) *r + ( - 0 . 3 3 1 2 6 ) *g + ( 0 . 5 0 0 0 0 ) *b ) ) ; VDU [pos ] = ( ( ( 0 . 5 0 0 0 0 ) *r + ( - 0 . 4 1 8 6 9 ) *g + ( - 0 . 0 8 1 3 1 ) *b ) ) ; * / 
function f DCTQuant ( data , fdtbl ) { var d 0 , d 1 , d 2 , d 3 , d 4 , d 5 , d 6 , d 7 ; var data Off = 0 ; var i ; var I 8 = 8 ; var I 6 4 = 6 4 ; for ( i = 0 ; i < I 8 ; + + i ) { d 0 = data [ data Off ] ; d 1 = data [ data Off + 1 ] ; d 2 = data [ data Off + 2 ] ; d 3 = data [ data Off + 3 ] ; d 4 = data [ data Off + 4 ] ; d 5 = data [ data Off + 5 ] ; d 6 = data [ data Off + 6 ] ; d 7 = data [ data Off + 7 ] ; var tmp 0 = d 0 + d 7 ; var tmp 7 = d 0 - d 7 ; var tmp 1 = d 1 + d 6 ; var tmp 6 = d 1 - d 6 ; var tmp 2 = d 2 + d 5 ; var tmp 5 = d 2 - d 5 ; var tmp 3 = d 3 + d 4 ; var tmp 4 = d 3 - d 4 ; var tmp 1 0 = tmp 0 + tmp 3 ; var tmp 1 3 = tmp 0 - tmp 3 ; var tmp 1 1 = tmp 1 + tmp 2 ; var tmp 1 2 = tmp 1 - tmp 2 ; data [ data Off ] = tmp 1 0 + tmp 1 1 ; data [ data Off + 4 ] = tmp 1 0 - tmp 1 1 ; var z 1 = ( tmp 1 2 + tmp 1 3 ) * 0 . 7 0 7 1 0 6 7 8 1 ; data [ data Off + 2 ] = tmp 1 3 + z 1 ; data [ data Off + 6 ] = tmp 1 3 - z 1 ; tmp 1 0 = tmp 4 + tmp 5 ; tmp 1 1 = tmp 5 + tmp 6 ; tmp 1 2 = tmp 6 + tmp 7 ; var z 5 = ( tmp 1 0 - tmp 1 2 ) * 0 . 3 8 2 6 8 3 4 3 3 ; var z 2 = 0 . 5 4 1 1 9 6 1 0 0 * tmp 1 0 + z 5 ; var z 4 = 1 . 3 0 6 5 6 2 9 6 5 * tmp 1 2 + z 5 ; var z 3 = tmp 1 1 * 0 . 7 0 7 1 0 6 7 8 1 ; var z 1 1 = tmp 7 + z 3 ; var z 1 3 = tmp 7 - z 3 ; data [ data Off + 5 ] = z 1 3 + z 2 ; data [ data Off + 3 ] = z 1 3 - z 2 ; data [ data Off + 1 ] = z 1 1 + z 4 ; data [ data Off + 7 ] = z 1 1 - z 4 ; data Off + = 8 ; } data Off = 0 ; for ( i = 0 ; i < I 8 ; + + i ) { d 0 = data [ data Off ] ; d 1 = data [ data Off + 8 ] ; d 2 = data [ data Off + 1 6 ] ; d 3 = data [ data Off + 2 4 ] ; d 4 = data [ data Off + 3 2 ] ; d 5 = data [ data Off + 4 0 ] ; d 6 = data [ data Off + 4 8 ] ; d 7 = data [ data Off + 5 6 ] ; var tmp 0p 2 = d 0 + d 7 ; var tmp 7p 2 = d 0 - d 7 ; var tmp 1p 2 = d 1 + d 6 ; var tmp 6p 2 = d 1 - d 6 ; var tmp 2p 2 = d 2 + d 5 ; var tmp 5p 2 = d 2 - d 5 ; var tmp 3p 2 = d 3 + d 4 ; var tmp 4p 2 = d 3 - d 4 ; var tmp 1 0p 2 = tmp 0p 2 + tmp 3p 2 ; var tmp 1 3p 2 = tmp 0p 2 - tmp 3p 2 ; var tmp 1 1p 2 = tmp 1p 2 + tmp 2p 2 ; var tmp 1 2p 2 = tmp 1p 2 - tmp 2p 2 ; data [ data Off ] = tmp 1 0p 2 + tmp 1 1p 2 ; data [ data Off + 3 2 ] = tmp 1 0p 2 - tmp 1 1p 2 ; var z 1p 2 = ( tmp 1 2p 2 + tmp 1 3p 2 ) * 0 . 7 0 7 1 0 6 7 8 1 ; data [ data Off + 1 6 ] = tmp 1 3p 2 + z 1p 2 ; data [ data Off + 4 8 ] = tmp 1 3p 2 - z 1p 2 ; tmp 1 0p 2 = tmp 4p 2 + tmp 5p 2 ; tmp 1 1p 2 = tmp 5p 2 + tmp 6p 2 ; tmp 1 2p 2 = tmp 6p 2 + tmp 7p 2 ; var z 5p 2 = ( tmp 1 0p 2 - tmp 1 2p 2 ) * 0 . 3 8 2 6 8 3 4 3 3 ; var z 2p 2 = 0 . 5 4 1 1 9 6 1 0 0 * tmp 1 0p 2 + z 5p 2 ; var z 4p 2 = 1 . 3 0 6 5 6 2 9 6 5 * tmp 1 2p 2 + z 5p 2 ; var z 3p 2 = tmp 1 1p 2 * 0 . 7 0 7 1 0 6 7 8 1 ; var z 1 1p 2 = tmp 7p 2 + z 3p 2 ; var z 1 3p 2 = tmp 7p 2 - z 3p 2 ; data [ data Off + 4 0 ] = z 1 3p 2 + z 2p 2 ; data [ data Off + 2 4 ] = z 1 3p 2 - z 2p 2 ; data [ data Off + 8 ] = z 1 1p 2 + z 4p 2 ; data [ data Off + 5 6 ] = z 1 1p 2 - z 4p 2 ; data Off + + ; } 
function bi _flush ( ) { if ( bi _valid = = 1 6 ) { put _short ( bi _buf ) ; bi _buf = 0 ; bi _valid = 0 ; } else if ( bi _valid > = 8 ) { put _byte ( bi _buf & 0xff ) ; bi _buf > > > = 8 ; bi _valid - = 8 ; } } 
function _tr _flush _block ( buf , 
function fill _window ( ) { var n , m ; var p ; var more ; 
function deflate _slow ( flush ) { 
function TTFFont ( raw Data , name , encoding ) { var data ; this . raw Data = raw Data ; data = this . contents = new Data ( raw Data ) ; this . contents . pos = 4 ; if ( data . read String ( 4 ) = = = 'ttcf ' ) { if ( ! name ) { throw new Error ( "Must specify a font name for TTC files . " ) ; } throw new Error ( "Font " + name + " not found in TTC file . " ) ; } else { data . pos = 0 ; this . parse ( ) ; this . subset = new Subset ( this ) ; this . register TTF ( ) ; } } 
function Directory ( data ) { var entry , i , _i , _ref ; this . scalar Type = data . read Int ( ) ; this . table Count = data . read Short ( ) ; this . search Range = data . read Short ( ) ; this . entry Selector = data . read Short ( ) ; this . range Shift = data . read Short ( ) ; this . tables = { } ; for ( i = _i = 0 , _ref = this . table Count ; 0 < = _ref ? _i < _ref : _i > _ref ; i = 0 < = _ref ? + + _i : - - _i ) { entry = { tag : data . read String ( 4 ) , checksum : data . read Int ( ) , offset : data . read Int ( ) , length : data . read Int ( ) } ; this . tables [ entry . tag ] = entry ; } } 
function Simple Glyph ( raw , number Of Contours , x Min , y Min , x Max , y Max ) { this . raw = raw ; this . number Of Contours = number Of Contours ; this . x Min = x Min ; this . y Min = y Min ; this . x Max = x Max ; this . y Max = y Max ; this . compound = false ; } 
function Compound Glyph ( raw , x Min , y Min , x Max , y Max ) { var data , flags ; this . raw = raw ; this . x Min = x Min ; this . y Min = y Min ; this . x Max = x Max ; this . y Max = y Max ; this . compound = true ; this . glyph IDs = [ ] ; this . glyph Offsets = [ ] ; data = this . raw ; while ( true ) { flags = data . read Short ( ) ; this . glyph Offsets . push ( data . pos ) ; this . glyph IDs . push ( data . read Short ( ) ) ; if ( ! ( flags & MORE _COMPONENTS ) ) { break ; } if ( flags & ARG _ 1 _AND _ 2 _ARE _WORDS ) { data . pos + = 4 ; } else { data . pos + = 2 ; } if ( flags & WE _HAVE _A _TWO _BY _TWO ) { data . pos + = 8 ; } else if ( flags & WE _HAVE _AN _X _AND _Y _SCALE ) { data . pos + = 4 ; } else if ( flags & WE _HAVE _A _SCALE ) { data . pos + = 2 ; } } } 
function invert ( object ) { var key , ret , val ; ret = { } ; for ( key in object ) { val = object [ key ] ; ret [ val ] = key ; } return ret ; } 
function ( image ) { var out = this . internal . write ; var put Stream = this . internal . put Stream ; var get Filters = this . internal . get Filters ; var filter = get Filters ( ) ; while ( filter . index Of ( 'Flate Encode ' ) ! = = - 1 ) { filter . splice ( filter . index Of ( 'Flate Encode ' ) , 1 ) ; } image . object Id = this . internal . new Object ( ) ; var additional Key Values = [ ] ; additional Key Values . push ( { key : 'Type ' , value : ' /XObject ' } ) ; additional Key Values . push ( { key : 'Subtype ' , value : ' /Image ' } ) ; additional Key Values . push ( { key : 'Width ' , value : image . width } ) ; additional Key Values . push ( { key : 'Height ' , value : image . height } ) ; if ( image . color Space = = = color _spaces . INDEXED ) { additional Key Values . push ( { key : 'Color Space ' , value : ' [ /Indexed /Device RGB ' 
function Gif Writer Output LZWCode Stream ( buf , p , min _code _size , index _stream ) { buf [ p + + ] = min _code _size ; var cur _subblock = p + + ; 
function map Array Buffer Views ( ary ) { return ary . map ( function ( chunk ) { if ( chunk . buffer instanceof Array Buffer ) { var buf = chunk . buffer ; 
function Blob ( chunks , opts ) { chunks = chunks | | [ ] for ( var i = 0 , len = chunks . length ; i < len ; i + + ) { var chunk = chunks [ i ] if ( chunk instanceof Blob ) { chunks [ i ] = chunk . _buffer } else if ( typeof chunk = = = 'string ' ) { chunks [ i ] = to UTF 8Array ( chunk ) } else if ( array Buffer Supported & & ( Array Buffer . prototype . is Prototype Of ( chunk ) | | is Array Buffer View ( chunk ) ) ) { chunks [ i ] = buffer Clone ( chunk ) } else if ( array Buffer Supported & & is Data View ( chunk ) ) { chunks [ i ] = buffer Clone ( chunk . buffer ) } else { chunks [ i ] = to UTF 8Array ( String ( chunk ) ) } } this . _buffer = [ ] . concat . apply ( [ ] , chunks ) this . size = this . _buffer . length this . type = opts ? opts . type | | ' ' : ' ' } 
function File ( chunks , name , opts ) { opts = opts | | { } var a = Blob . call ( this , chunks , opts ) | | this a . name = name a . last Modified Date = opts . last Modified ? new Date ( opts . last Modified ) : new Date a . last Modified = + a . last Modified Date return a } 
function File Reader ( ) { if ( ! ( this instanceof File Reader ) ) throw new Type Error ( "Failed to construct 'File Reader ' : Please use the 'new ' operator , this DOM object constructor cannot be called as a function . " ) var delegate = document . create Document Fragment ( ) this . add Event Listener = delegate . add Event Listener this . dispatch Event = function ( evt ) { var local = this [ 'on ' + evt . type ] if ( typeof local = = = 'function ' ) local ( evt ) delegate . dispatch Event ( evt ) } this . remove Event Listener = delegate . remove Event Listener } 
function prompt User ( ) { return inquirer . prompt ( [ { type : "list " , name : "env " , message : "Where does your code run ? " , default : [ "browser " ] , choices : [ { name : "Browser " , value : "browser " } , { name : "Node " , value : "node " } ] } , { type : "checkbox " , name : "images " , message : "Which Image Types should be supported ? " , default : [ "jpeg _support " , 'bmp _support ' , 'gif _support ' , 'webp _support ' ] , choices : [ { name : "Jpeg " , value : "jpeg _support " } , { name : "Bmp " , value : "bmp _support " } , { name : "Gif " , value : "gif _support " } , { name : "Web P " , value : "webp _support " } ] } , { type : "checkbox " , name : "modules " , message : "Additional Modules " , default : [ 'acroform ' , 'annotations ' , 'arabic ' , 'autoprint ' , 'context 2d ' , 'fileloading ' , 'filters ' , 'html ' , 'javascript ' , 'outline ' , 'setlanguage ' , 'svg ' , 'total _pages ' , 'utf 8 ' , 'viewerpreferences ' , 'xmp _metadata ' ] , choices : [ { name : "Acroform " , value : "acroform " } , { name : "Annotations " , value : "annotations " } , { name : "Arabic Parser " , value : "arabic " } , { name : "Autoprint " , value : "autoprint " } , { name : "Context 2d " , value : "context 2d " } , { name : "File Loading " , value : "fileloading " } , { name : "Filters " , value : "filters " } , { name : "HTML " , value : "html " } , { name : "Javascript " , value : "javascript " } , { name : "Outline " , value : "outline " } , { name : "Language -Tagging " , value : "setlanguage " } , { name : "SVG " , value : "svg " } , { name : "Total Pages " , value : "total _pages " } , { name : "Unicode " , value : "utf 8 " } , { name : "Viewer Preferences " , value : "viewerpreferences " } , { name : "XMP Metadata " , value : "xmp _metadata " } ] } ] ) . then ( result = > { console . log ( generate File List ( [ . . . result . images , . . . result . modules ] ) ) ; } ) ; } 
function memcmp ( data , data _off , str , size ) { for ( var i = 0 ; i < size ; i + + ) if ( data [ data _off + i ] ! = str . char Code At ( i ) ) return true ; return false ; } 
function demo Two Page Document ( ) { var doc = new js PDF ( ) ; doc . text ( 2 0 , 2 0 , 'Hello world ! ' ) ; doc . text ( 2 0 , 3 0 , 'This is client -side Javascript , pumping out a PDF . ' ) ; doc . add Page ( ) ; doc . text ( 2 0 , 2 0 , 'Do you like that ? ' ) ; 
function ( url , callback ) { var img = new Image ( ) , data , ret = { data : null , pending : true } ; img . on Error = function ( ) { throw new Error ( 'Cannot load image : " ' + url + ' " ' ) ; } ; img . onload = function ( ) { var canvas = document . create Element ( 'canvas ' ) ; document . body . append Child ( canvas ) ; canvas . width = img . width ; canvas . height = img . height ; var ctx = canvas . get Context ( ' 2d ' ) ; ctx . draw Image ( img , 0 , 0 ) ; 
function ( img Data ) { var doc = new js PDF ( ) ; doc . add Image ( img Data , 'JPEG ' , 1 0 , 1 0 , 5 0 , 5 0 ) ; doc . add Image ( img Data , 'JPEG ' , 7 0 , 1 0 , 1 0 0 , 1 2 0 ) ; doc . save ( 'output .pdf ' ) ; } 
function parse Id ( url ) { if ( is . empty ( url ) ) { return null ; } const regex = / ^ . * (youtu .be \ / |v \ / |u \ / \w \ / |embed \ / |watch \ ?v = | &v = ) ( [ ^ # & ? ] * ) . * / ; return url . match ( regex ) ? Reg Exp . $ 2 : url ; } 
function assure Playback State ( play ) { if ( play & & ! this . embed . has Played ) { this . embed . has Played = true ; } if ( this . media . paused = = = play ) { this . media . paused = ! play ; trigger Event . call ( this , this . media , play ? 'play ' : 'pause ' ) ; } } 
function stringify Error ( value ) { var err = { 
function is Error ( value ) { switch ( Object . prototype . to String . call ( value ) ) { case ' [object Error ] ' : return true ; case ' [object Exception ] ' : return true ; case ' [object DOMException ] ' : return true ; default : return value instanceof Error ; } } 
function parse Url ( url ) { if ( typeof url ! = = 'string ' ) return { } ; var match = url . match ( / ^ ( ( [ ^ : \ / ? # ] + ) : ) ? ( \ / \ / ( [ ^ \ / ? # ] * ) ) ? ( [ ^ ? # ] * ) ( \ ? ( [ ^ # ] * ) ) ? ( # ( . * ) ) ? $ / ) ; 
function is Same Exception ( ex 1 , ex 2 ) { if ( is Only One Truthy ( ex 1 , ex 2 ) ) return false ; ex 1 = ex 1 . values [ 0 ] ; ex 2 = ex 2 . values [ 0 ] ; if ( ex 1 . type ! = = ex 2 . type | | ex 1 . value ! = = ex 2 . value ) return false ; 
function is Same Stacktrace ( stack 1 , stack 2 ) { if ( is Only One Truthy ( stack 1 , stack 2 ) ) return false ; var frames 1 = stack 1 . frames ; var frames 2 = stack 2 . frames ; 
function fill ( obj , name , replacement , track ) { if ( obj = = null ) return ; var orig = obj [ name ] ; obj [ name ] = replacement ( orig ) ; obj [ name ] . _ _raven _ _ = true ; obj [ name ] . _ _orig _ _ = orig ; if ( track ) { track . push ( [ obj , name , orig ] ) ; } } 
function safe Join ( input , delimiter ) { if ( ! is Array ( input ) ) return ' ' ; var output = [ ] ; for ( var i = 0 ; i < input . length ; i + + ) { try { output . push ( String ( input [ i ] ) ) ; } catch ( e ) { output . push ( ' [value cannot be serialized ] ' ) ; } } return output . join ( delimiter ) ; } 
function notify Handlers ( stack , is Window Error ) { var exception = null ; if ( is Window Error & & ! Trace Kit . collect Window Errors ) { return ; } for ( var i in handlers ) { if ( handlers . has Own Property ( i ) ) { try { handlers [ i ] . apply ( null , [ stack ] . concat ( _slice . call ( arguments , 2 ) ) ) ; } catch ( inner ) { exception = inner ; } } } if ( exception ) { throw exception ; } } 
function trace Kit Window On Error ( msg , url , line No , col No , ex ) { var stack = null ; 
function report ( ex , rethrow ) { var args = _slice . call ( arguments , 1 ) ; if ( last Exception Stack ) { if ( last Exception = = = ex ) { return ; 
function compute Stack Trace From Stack Prop ( ex ) { if ( typeof ex . stack = = = 'undefined ' | | ! ex . stack ) return ; var chrome = / ^ \s *at ( ? : ( . * ? ) ? \ ( ) ? ( ( ? :file |https ? |blob |chrome -extension |native |eval |webpack | <anonymous > | [a -z ] : | \ / ) . * ? ) ( ? : : ( \d + ) ) ? ( ? : : ( \d + ) ) ? \ ) ? \s * $ / i ; var winjs = / ^ \s *at ( ? : ( ( ? : \ [object object \ ] ) ? . + ) ) ? \ ( ? ( ( ? :file |ms -appx ( ? : -web ) |https ? |webpack |blob ) : . * ? ) : ( \d + ) ( ? : : ( \d + ) ) ? \ ) ? \s * $ / i ; 
function augment Stack Trace With Initial Element ( stack Info , url , line No , message ) { var initial = { url : url , line : line No } ; if ( initial . url & & initial . line ) { stack Info . incomplete = false ; if ( ! initial . func ) { initial . func = UNKNOWN _FUNCTION ; } if ( stack Info . stack . length > 0 ) { if ( stack Info . stack [ 0 ] . url = = = initial . url ) { if ( stack Info . stack [ 0 ] . line = = = initial . line ) { return false ; 
function compute Stack Trace ( ex , depth ) { var stack = null ; depth = depth = = null ? 0 : + depth ; try { stack = compute Stack Trace From Stack Prop ( ex ) ; if ( stack ) { return stack ; } } catch ( e ) { if ( Trace Kit . debug ) { throw e ; } } try { stack = compute Stack Trace By Walking Caller Chain ( ex , depth + 1 ) ; if ( stack ) { return stack ; } } catch ( e ) { if ( Trace Kit . debug ) { throw e ; } } return { name : ex . name , message : ex . message , url : get Location Href ( ) } ; } 
function rstr HMACMD 5 ( key , data ) { var i ; var bkey = rstr 2binl ( key ) ; var ipad = [ ] ; var opad = [ ] ; var hash ; ipad [ 1 5 ] = opad [ 1 5 ] = undefined ; if ( bkey . length > 1 6 ) { bkey = binl MD 5 ( bkey , key . length * 8 ) ; } for ( i = 0 ; i < 1 6 ; i + = 1 ) { ipad [ i ] = bkey [ i ] ^ 0x 3 6 3 6 3 6 3 6 ; opad [ i ] = bkey [ i ] ^ 0x 5c 5c 5c 5c ; } hash = binl MD 5 ( ipad . concat ( rstr 2binl ( data ) ) , 5 1 2 + data . length * 8 ) ; return binl 2rstr ( binl MD 5 ( opad . concat ( hash ) , 5 1 2 + 1 2 8 ) ) ; } 
function rstr 2hex ( input ) { var hex Tab = ' 0 1 2 3 4 5 6 7 8 9abcdef ' ; var output = ' ' ; var x ; var i ; for ( i = 0 ; i < input . length ; i + = 1 ) { x = input . char Code At ( i ) ; output + = hex Tab . char At ( x > > > 4 & 0x 0f ) + hex Tab . char At ( x & 0x 0f ) ; } return output ; } 
function install ( ) { var self = this ; if ( self . is Setup ( ) & & ! self . _is Raven Installed ) { tracekit . report . subscribe ( function ( ) { self . _handle On Error Stack Info . apply ( self , arguments ) ; } ) ; if ( self . _global Options . capture Unhandled Rejections ) { self . _attach Promise Rejection Handler ( ) ; } self . _patch Function To String ( ) ; if ( self . _global Options . instrument & & self . _global Options . instrument . try Catch ) { self . _instrument Try Catch ( ) ; } if ( self . _global Options . auto Breadcrumbs ) self . _instrument Breadcrumbs ( ) ; 
function set DSN ( dsn ) { var self = this , uri = self . _parse DSN ( dsn ) , last Slash = uri . path . last Index Of ( ' / ' ) , path = uri . path . substr ( 1 , last Slash ) ; self . _dsn = dsn ; self . _global Key = uri . user ; self . _global Secret = uri . pass & & uri . pass . substr ( 1 ) ; self . _global Project = uri . path . substr ( last Slash + 1 ) ; self . _global Server = self . _get Global Server ( uri ) ; self . _global Endpoint = self . _global Server + ' / ' + path + 'api / ' + self . _global Project + ' /store / ' ; 
function context ( options , func , args ) { if ( is Function $ 1 ( options ) ) { args = func | | [ ] ; func = options ; options = { } ; } return this . wrap ( options , func ) . apply ( this , args ) ; } 
function wrap ( options , func , _before ) { var self = this ; 
function _promise Rejection Handler ( event ) { this . _log Debug ( 'debug ' , 'Raven caught unhandled promise rejection : ' , event ) ; this . capture Exception ( event . reason , { mechanism : { type : 'onunhandledrejection ' , handled : false } } ) ; } 
function capture Exception ( ex , options ) { options = object Merge $ 1 ( { trim Head Frames : 0 } , options ? options : { } ) ; if ( is Error Event $ 1 ( ex ) & & ex . error ) { 
function capture Message ( msg , options ) { 
function set Data Callback ( callback ) { var original = this . _global Options . data Callback ; this . _global Options . data Callback = keep Original Callback ( original , callback ) ; return this ; } 
function set Breadcrumb Callback ( callback ) { var original = this . _global Options . breadcrumb Callback ; this . _global Options . breadcrumb Callback = keep Original Callback ( original , callback ) ; return this ; } 
function set Should Send Callback ( callback ) { var original = this . _global Options . should Send Callback ; this . _global Options . should Send Callback = keep Original Callback ( original , callback ) ; return this ; } 
function is Setup ( ) { if ( ! this . _has JSON ) return false ; 
function _breadcrumb Event Handler ( evt Name ) { var self = this ; return function ( evt ) { 
function _capture Url Change ( from , to ) { var parsed Loc = parse Url $ 1 ( this . _location . href ) ; var parsed To = parse Url $ 1 ( to ) ; var parsed From = parse Url $ 1 ( from ) ; 
function _trim Breadcrumbs ( breadcrumbs ) { 
function _is Repeat Data ( current ) { var last = this . _last Data ; if ( ! last | | current . message ! = = last . message | | 
function trigger ( element , type ) { if ( ! element | | ! type ) { return ; } 
function get Decimal Places ( value ) { var match = " " . concat ( value ) . match ( / ( ? : \ . ( \d + ) ) ? ( ? : [e E ] ( [ + - ] ? \d + ) ) ? $ / ) ; if ( ! match ) { return 0 ; } return Math . max ( 0 , 
function round ( number , step ) { if ( step < 1 ) { var places = get Decimal Places ( step ) ; return parse Float ( number . to Fixed ( places ) ) ; } return Math . round ( number / step ) * step ; } 
function Range Touch ( target , options ) { _class Call Check ( this , Range Touch ) ; if ( is . element ( target ) ) { 
function setup ( target ) { var options = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : { } ; var targets = null ; if ( is . empty ( target ) | | is . string ( target ) ) { targets = Array . from ( document . query Selector All ( is . string ( target ) ? target : 'input [type = "range " ] ' ) ) ; } else if ( is . element ( target ) ) { targets = [ target ] ; } else if ( is . node List ( target ) ) { targets = Array . from ( target ) ; } else if ( is . array ( target ) ) { targets = target . filter ( is . element ) ; } if ( is . empty ( targets ) ) { return null ; } var config = Object . assign ( { } , defaults , options ) ; if ( is . string ( target ) & & config . watch ) { 
function toggle Listener ( element , event , callback ) { var _this = this ; var toggle = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : false ; var passive = arguments . length > 4 & & arguments [ 4 ] ! = = undefined ? arguments [ 4 ] : true ; var capture = arguments . length > 5 & & arguments [ 5 ] ! = = undefined ? arguments [ 5 ] : false ; 
function on ( element ) { var events = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : ' ' ; var callback = arguments . length > 2 ? arguments [ 2 ] : undefined ; var passive = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : true ; var capture = arguments . length > 4 & & arguments [ 4 ] ! = = undefined ? arguments [ 4 ] : false ; toggle Listener . call ( this , element , events , callback , true , passive , capture ) ; } 
function once ( element ) { var _this 2 = this ; var events = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : ' ' ; var callback = arguments . length > 2 ? arguments [ 2 ] : undefined ; var passive = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : true ; var capture = arguments . length > 4 & & arguments [ 4 ] ! = = undefined ? arguments [ 4 ] : false ; var once Callback = function once Callback ( ) { off ( element , events , once Callback , passive , capture ) ; for ( var _len = arguments . length , args = new Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } callback . apply ( _this 2 , args ) ; } ; toggle Listener . call ( this , element , events , once Callback , true , passive , capture ) ; } 
function trigger Event ( element ) { var type = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : ' ' ; var bubbles = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : false ; var detail = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : { } ; 
function unbind Listeners ( ) { if ( this & & this . event Listeners ) { this . event Listeners . for Each ( function ( item ) { var element = item . element , type = item . type , callback = item . callback , options = item . options ; element . remove Event Listener ( type , callback , options ) ; } ) ; this . event Listeners = [ ] ; } } 
function ready ( ) { var _this 3 = this ; return new Promise ( function ( resolve ) { return _this 3 . ready ? set Timeout ( resolve , 0 ) : on . call ( _this 3 , _this 3 . elements . container , 'ready ' , resolve ) ; } ) . then ( function ( ) { } ) ; } 
function get Deep ( object , path ) { return path . split ( ' . ' ) . reduce ( function ( obj , key ) { return obj & & obj [ key ] ; } , object ) ; } 
function extend ( ) { var target = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : { } ; for ( var _len = arguments . length , sources = new Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key + + ) { sources [ _key - 1 ] = arguments [ _key ] ; } if ( ! sources . length ) { return target ; } var source = sources . shift ( ) ; if ( ! is $ 1 . object ( source ) ) { return target ; } Object . keys ( source ) . for Each ( function ( key ) { if ( is $ 1 . object ( source [ key ] ) ) { if ( ! Object . keys ( target ) . includes ( key ) ) { Object . assign ( target , _define Property ( { } , key , { } ) ) ; } extend ( target [ key ] , source [ key ] ) ; } else { Object . assign ( target , _define Property ( { } , key , source [ key ] ) ) ; } } ) ; return extend . apply ( void 0 , [ target ] . concat ( sources ) ) ; } 
function set Attributes ( element , attributes ) { if ( ! is $ 1 . element ( element ) | | is $ 1 . empty ( attributes ) ) { return ; } 
function create Element ( type , attributes , text ) { 
function insert After ( element , target ) { if ( ! is $ 1 . element ( element ) | | ! is $ 1 . element ( target ) ) { return ; } target . parent Node . insert Before ( element , target . next Sibling ) ; } 
function insert Element ( type , parent , attributes , text ) { if ( ! is $ 1 . element ( parent ) ) { return ; } parent . append Child ( create Element ( type , attributes , text ) ) ; } 
function remove Element ( element ) { if ( is $ 1 . node List ( element ) | | is $ 1 . array ( element ) ) { Array . from ( element ) . for Each ( remove Element ) ; return ; } if ( ! is $ 1 . element ( element ) | | ! is $ 1 . element ( element . parent Node ) ) { return ; } element . parent Node . remove Child ( element ) ; } 
function empty Element ( element ) { if ( ! is $ 1 . element ( element ) ) { return ; } var length = element . child Nodes . length ; while ( length > 0 ) { element . remove Child ( element . last Child ) ; length - = 1 ; } } 
function replace Element ( new Child , old Child ) { if ( ! is $ 1 . element ( old Child ) | | ! is $ 1 . element ( old Child . parent Node ) | | ! is $ 1 . element ( new Child ) ) { return null ; } old Child . parent Node . replace Child ( new Child , old Child ) ; return new Child ; } 
function get Attributes From Selector ( sel , existing Attributes ) { 
function toggle Hidden ( element , hidden ) { if ( ! is $ 1 . element ( element ) ) { return ; } var hide = hidden ; if ( ! is $ 1 . boolean ( hide ) ) { hide = ! element . hidden ; } if ( hide ) { element . set Attribute ( 'hidden ' , ' ' ) ; } else { element . remove Attribute ( 'hidden ' ) ; } } 
function toggle Class ( element , class Name , force ) { if ( is $ 1 . node List ( element ) ) { return Array . from ( element ) . map ( function ( e ) { return toggle Class ( e , class Name , force ) ; } ) ; } if ( is $ 1 . element ( element ) ) { var method = 'toggle ' ; if ( typeof force ! = = 'undefined ' ) { method = force ? 'add ' : 'remove ' ; } element . class List [ method ] ( class Name ) ; return element . class List . contains ( class Name ) ; } return false ; } 
function has Class ( element , class Name ) { return is $ 1 . element ( element ) & & element . class List . contains ( class Name ) ; } 
function matches $ 1 ( element , selector ) { function match ( ) { return Array . from ( document . query Selector All ( selector ) ) . includes ( this ) ; } var matches = match ; return matches . call ( element , selector ) ; } 
function trap Focus ( ) { var element = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : null ; var toggle = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : false ; if ( ! is $ 1 . element ( element ) ) { return ; } var focusable = get Elements . call ( this , 'button :not ( :disabled ) , input :not ( :disabled ) , [tabindex ] ' ) ; var first = focusable [ 0 ] ; var last = focusable [ focusable . length - 1 ] ; var trap = function trap ( event ) { 
function set Focus ( ) { var element = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : null ; var tab Focus = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : false ; if ( ! is $ 1 . element ( element ) ) { return ; } 
function repaint ( element ) { set Timeout ( function ( ) { try { toggle Hidden ( element , true ) ; element . offset Height ; 
function check ( type , provider , playsinline ) { var can Play Inline = browser . is IPhone & & playsinline & & support . playsinline ; var api = support [ type ] | | provider ! = = 'html 5 ' ; var ui = api & & support . range Input & & ( type ! = = 'video ' | | ! browser . is IPhone | | can Play Inline ) ; return { api : api , ui : ui } ; } 
function mime ( input ) { if ( is $ 1 . empty ( input ) ) { return false ; } var _input $split = input . split ( ' / ' ) , _input $split 2 = _sliced To Array ( _input $split , 1 ) , media Type = _input $split 2 [ 0 ] ; var type = input ; 
function set Aspect Ratio ( input ) { if ( ! this . is Video ) { return { } ; } var ratio = get Aspect Ratio . call ( this , input ) ; var _ref = is $ 1 . array ( ratio ) ? ratio : [ 0 , 0 ] , _ref 2 = _sliced To Array ( _ref , 2 ) , w = _ref 2 [ 0 ] , h = _ref 2 [ 1 ] ; var padding = 1 0 0 / w * h ; this . elements . wrapper . style . padding Bottom = " " . concat ( padding , " % " ) ; 
function get Quality Options ( ) { 
function cancel Requests ( ) { if ( ! this . is HTML 5 ) { return ; } 
function dedupe ( array ) { if ( ! is $ 1 . array ( array ) ) { return array ; } return array . filter ( function ( item , index ) { return array . index Of ( item ) = = = index ; } ) ; } 
function closest ( array , value ) { if ( ! is $ 1 . array ( array ) | | ! array . length ) { return null ; } return array . reduce ( function ( prev , curr ) { return Math . abs ( curr - value ) < Math . abs ( prev - value ) ? curr : prev ; } ) ; } 
function format ( input ) { for ( var _len = arguments . length , args = new Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key + + ) { args [ _key - 1 ] = arguments [ _key ] ; } if ( is $ 1 . empty ( input ) ) { return input ; } return input . to String ( ) . replace ( / { ( \d + ) } / g , function ( match , i ) { return args [ i ] . to String ( ) ; } ) ; } 
function get Percentage ( current , max ) { if ( current = = = 0 | | max = = = 0 | | Number . is Na N ( current ) | | Number . is Na N ( max ) ) { return 0 ; } return ( current / max * 1 0 0 ) . to Fixed ( 2 ) ; } 
function replace All ( ) { var input = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : ' ' ; var find = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : ' ' ; var replace = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : ' ' ; return input . replace ( new Reg Exp ( find . to String ( ) . replace ( / ( [ . * + ? ^ = ! : $ { } ( ) | [ \ ] / \ \ ] ) / g , ' \ \ $ 1 ' ) , 'g ' ) , replace . to String ( ) ) ; } 
function to Title Case ( ) { var input = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : ' ' ; return input . to String ( ) . replace ( / \w \S * / g , function ( text ) { return text . char At ( 0 ) . to Upper Case ( ) + text . substr ( 1 ) . to Lower Case ( ) ; } ) ; } 
function to Pascal Case ( ) { var input = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : ' ' ; var string = input . to String ( ) ; 
function to Camel Case ( ) { var input = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : ' ' ; var string = input . to String ( ) ; 
function strip HTML ( source ) { var fragment = document . create Document Fragment ( ) ; var element = document . create Element ( 'div ' ) ; fragment . append Child ( element ) ; element . inner HTML = source ; return fragment . first Child . inner Text ; } 
function get HTML ( element ) { var wrapper = document . create Element ( 'div ' ) ; wrapper . append Child ( element ) ; return wrapper . inner HTML ; } 
function fetch ( url ) { var response Type = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 'text ' ; return new Promise ( function ( resolve , reject ) { try { var request = new XMLHttp Request ( ) ; 
function load Sprite ( url , id ) { if ( ! is $ 1 . string ( url ) ) { return ; } var prefix = 'cache ' ; var has Id = is $ 1 . string ( id ) ; var is Cached = false ; var exists = function exists ( ) { return document . get Element By Id ( id ) ! = = null ; } ; var update = function update ( container , data ) { container . inner HTML = data ; 
function format Time ( ) { var time = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : 0 ; var display Hours = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : false ; var inverted = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : false ; 
function get Icon Url ( ) { var url = new URL ( this . config . icon Url , window . location ) ; var cors = url . host ! = = window . location . host | | browser . is IE & & ! window . svg 4everybody ; return { url : this . config . icon Url , cors : cors } ; } 
function find Elements ( ) { try { this . elements . controls = get Element . call ( this , this . config . selectors . controls . wrapper ) ; 
function create Icon ( type , attributes ) { var namespace = 'http : / /www .w 3 .org / 2 0 0 0 /svg ' ; var icon Url = controls . get Icon Url . call ( this ) ; var icon Path = " " . concat ( ! icon Url . cors ? icon Url . url : ' ' , " # " ) . concat ( this . config . icon Prefix ) ; 
function create Label ( key ) { var attr = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : { } ; var text = i 1 8n . get ( key , this . config ) ; var attributes = Object . assign ( { } , attr , { class : [ attr . class , this . config . class Names . hidden ] . filter ( Boolean ) . join ( ' ' ) } ) ; return create Element ( 'span ' , attributes , text ) ; } 
function create Badge ( text ) { if ( is $ 1 . empty ( text ) ) { return null ; } var badge = create Element ( 'span ' , { class : this . config . class Names . menu . value } ) ; badge . append Child ( create Element ( 'span ' , { class : this . config . class Names . menu . badge } , text ) ) ; return badge ; } 
function create Button ( button Type , attr ) { var _this = this ; var attributes = extend ( { } , attr ) ; var type = to Camel Case ( button Type ) ; var props = { element : 'button ' , toggle : false , label : null , icon : null , label Pressed : null , icon Pressed : null } ; [ 'element ' , 'icon ' , 'label ' ] . for Each ( function ( key ) { if ( Object . keys ( attributes ) . includes ( key ) ) { props [ key ] = attributes [ key ] ; delete attributes [ key ] ; } } ) ; 
function create Range ( type , attributes ) { 
function create Progress ( type , attributes ) { var progress = create Element ( 'progress ' , extend ( get Attributes From Selector ( this . config . selectors . display [ type ] ) , { min : 0 , max : 1 0 0 , value : 0 , role : 'progressbar ' , 'aria -hidden ' : true } , attributes ) ) ; 
function create Time ( type , attrs ) { var attributes = get Attributes From Selector ( this . config . selectors . display [ type ] , attrs ) ; var container = create Element ( 'div ' , extend ( attributes , { class : " " . concat ( attributes . class ? attributes . class : ' ' , " " ) . concat ( this . config . class Names . display . time , " " ) . trim ( ) , 'aria -label ' : i 1 8n . get ( type , this . config ) } ) , ' 0 0 : 0 0 ' ) ; 
function bind Menu Item Shortcuts ( menu Item , type ) { var _this 2 = this ; 
function create Menu Item ( _ref ) { var _this 3 = this ; var value = _ref . value , list = _ref . list , type = _ref . type , title = _ref . title , _ref $badge = _ref . badge , badge = _ref $badge = = = void 0 ? null : _ref $badge , _ref $checked = _ref . checked , checked = _ref $checked = = = void 0 ? false : _ref $checked ; var attributes = get Attributes From Selector ( this . config . selectors . inputs [ type ] ) ; var menu Item = create Element ( 'button ' , extend ( attributes , { type : 'button ' , role : 'menuitemradio ' , class : " " . concat ( this . config . class Names . control , " " ) . concat ( attributes . class ? attributes . class : ' ' ) . trim ( ) , 'aria -checked ' : checked , value : value } ) ) ; var flex = create Element ( 'span ' ) ; 
function format Time $ 1 ( ) { var time = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : 0 ; var inverted = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : false ; 
function update Time Display ( ) { var target = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : null ; var time = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 0 ; var inverted = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : false ; 
function update Volume ( ) { if ( ! this . supported . ui ) { return ; } 
function set Range ( target ) { var value = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 0 ; if ( ! is $ 1 . element ( target ) ) { return ; } 
function update Progress ( event ) { var _this 4 = this ; if ( ! this . supported . ui | | ! is $ 1 . event ( event ) ) { return ; } var value = 0 ; var set Progress = function set Progress ( target , input ) { var value = is $ 1 . number ( input ) ? input : 0 ; var progress = is $ 1 . element ( target ) ? target : _this 4 . elements . display . buffer ; 
function update Range Fill ( target ) { 
function update Seek Tooltip ( event ) { var _this 5 = this ; 
function time Update ( event ) { 
function duration Update ( ) { 
function update Setting ( setting , container , input ) { var pane = this . elements . settings . panels [ setting ] ; var value = null ; var list = container ; if ( setting = = = 'captions ' ) { value = this . current Track ; } else { value = ! is $ 1 . empty ( input ) ? input : this [ setting ] ; 
function get Label ( setting , value ) { switch ( setting ) { case 'speed ' : return value = = = 1 ? i 1 8n . get ( 'normal ' , this . config ) : " " . concat ( value , " &times ; " ) ; case 'quality ' : if ( is $ 1 . number ( value ) ) { var label = i 1 8n . get ( "quality Label . " . concat ( value ) , this . config ) ; if ( ! label . length ) { return " " . concat ( value , "p " ) ; } return label ; } return to Title Case ( value ) ; case 'captions ' : return captions . get Label . call ( this ) ; default : return null ; } } 
function set Quality Menu ( options ) { var _this 6 = this ; 
function get Badge ( quality ) { var label = i 1 8n . get ( "quality Badge . " . concat ( quality ) , _this 6 . config ) ; if ( ! label . length ) { return null ; } return controls . create Badge . call ( _this 6 , label ) ; } 
function set Captions Menu ( ) { var _this 7 = this ; 
function set Speed Menu ( options ) { var _this 8 = this ; 
function check Menu ( ) { var buttons = this . elements . settings . buttons ; var visible = ! is $ 1 . empty ( buttons ) & & Object . values ( buttons ) . some ( function ( button ) { return ! button . hidden ; } ) ; toggle Hidden ( this . elements . settings . menu , ! visible ) ; } 
function focus First Menu Item ( pane ) { var tab Focus = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : false ; if ( this . elements . settings . popup . hidden ) { return ; } var target = pane ; if ( ! is $ 1 . element ( target ) ) { target = Object . values ( this . elements . settings . panels ) . find ( function ( pane ) { return ! pane . hidden ; } ) ; } var first Item = target . query Selector ( ' [role ^ = "menuitem " ] ' ) ; set Focus . call ( this , first Item , tab Focus ) ; } 
function toggle Menu ( input ) { var popup = this . elements . settings . popup ; var button = this . elements . buttons . settings ; 
function get Menu Size ( tab ) { var clone = tab . clone Node ( true ) ; clone . style . position = 'absolute ' ; clone . style . opacity = 0 ; clone . remove Attribute ( 'hidden ' ) ; 
function show Menu Panel ( ) { var _this 9 = this ; var type = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : ' ' ; var tab Focus = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : false ; var target = this . elements . container . query Selector ( " #plyr -settings - " . concat ( this . id , " - " ) . concat ( type ) ) ; 
function restore ( event ) { 
function set Download Url ( ) { var button = this . elements . buttons . download ; 
function create ( data ) { var _this 1 0 = this ; var bind Menu Item Shortcuts = controls . bind Menu Item Shortcuts , create Button = controls . create Button , create Progress = controls . create Progress , create Range = controls . create Range , create Time = controls . create Time , set Quality Menu = controls . set Quality Menu , set Speed Menu = controls . set Speed Menu , show Menu Panel = controls . show Menu Panel ; this . elements . controls = null ; 
function inject ( ) { var _this 1 1 = this ; 
function replace ( input ) { var result = input ; Object . entries ( props ) . for Each ( function ( _ref 2 ) { var _ref 3 = _sliced To Array ( _ref 2 , 2 ) , key = _ref 3 [ 0 ] , value = _ref 3 [ 1 ] ; result = replace All ( result , " { " . concat ( key , " } " ) , value ) ; } ) ; return result ; } 
function parse Url $ 2 ( input ) { var safe = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : true ; var url = input ; if ( safe ) { var parser = document . create Element ( 'a ' ) ; parser . href = url ; url = parser . href ; } try { return new URL ( url ) ; } catch ( e ) { return null ; } } 
function build Url Params ( input ) { var params = new URLSearch Params ( ) ; if ( is $ 1 . object ( input ) ) { Object . entries ( input ) . for Each ( function ( _ref ) { var _ref 2 = _sliced To Array ( _ref , 2 ) , key = _ref 2 [ 0 ] , value = _ref 2 [ 1 ] ; params . set ( key , value ) ; } ) ; } return params ; } 
function setup ( ) { 
function update ( ) { var _this = this ; var tracks = captions . get Tracks . call ( this , true ) ; 
function toggle ( input ) { var passive = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : true ; 
function set ( index ) { var passive = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : true ; var tracks = captions . get Tracks . call ( this ) ; 
function set Language ( input ) { var passive = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : true ; if ( ! is $ 1 . string ( input ) ) { this . debug . warn ( 'Invalid language argument ' , input ) ; return ; } 
function get Tracks ( ) { var _this 2 = this ; var update = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : false ; 
function find Track ( languages ) { var _this 3 = this ; var force = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : false ; var tracks = captions . get Tracks . call ( this ) ; var sort Is Default = function sort Is Default ( track ) { return Number ( ( _this 3 . captions . meta . get ( track ) | | { } ) . default ) ; } ; var sorted = Array . from ( tracks ) . sort ( function ( a , b ) { return sort Is Default ( b ) - sort Is Default ( a ) ; } ) ; var track ; languages . every ( function ( language ) { track = sorted . find ( function ( track ) { return track . language = = = language ; } ) ; return ! track ; 
function get Label ( track ) { var current Track = track ; if ( ! is $ 1 . track ( current Track ) & & support . text Tracks & & this . captions . toggled ) { current Track = captions . get Current Track . call ( this ) ; } if ( is $ 1 . track ( current Track ) ) { if ( ! is $ 1 . empty ( current Track . label ) ) { return current Track . label ; } if ( ! is $ 1 . empty ( current Track . language ) ) { return track . language . to Upper Case ( ) ; } return i 1 8n . get ( 'enabled ' , this . config ) ; } return i 1 8n . get ( 'disabled ' , this . config ) ; } 
function update Cues ( input ) { 
function get Provider By Url ( url ) { 
function update ( ) { if ( this . enabled ) { var mode ; if ( this . force Fallback ) { mode = 'Fallback (forced ) ' ; } else if ( Fullscreen . native ) { mode = 'Native ' ; } else { mode = 'Fallback ' ; } this . player . debug . log ( " " . concat ( mode , " fullscreen enabled " ) ) ; } else { this . player . debug . log ( 'Fullscreen not supported and fallback disabled ' ) ; } 
function get ( ) { return ( Fullscreen . native | | this . player . config . fullscreen . fallback ) & & this . player . config . fullscreen . enabled & & this . player . supported . ui & & this . player . is Video ; } 
function load Image ( src ) { var min Width = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 1 ; return new Promise ( function ( resolve , reject ) { var image = new Image ( ) ; var handler = function handler ( ) { delete image . onload ; delete image . onerror ; ( image . natural Width > = min Width ? resolve : reject ) ( image ) ; } ; Object . assign ( image , { onload : handler , onerror : handler , src : src } ) ; } ) ; } 
function toggle Native Controls ( ) { var toggle = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : false ; if ( toggle & & this . is HTML 5 ) { this . media . set Attribute ( 'controls ' , ' ' ) ; } else { this . media . remove Attribute ( 'controls ' ) ; } } 
function build ( ) { var _this = this ; 
function set Title ( ) { 
function set Poster ( poster ) { var _this 2 = this ; var passive = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : true ; 
function check Playing ( event ) { var _this 3 = this ; 
function check Loading ( event ) { var _this 4 = this ; this . loading = [ 'stalled ' , 'waiting ' ] . includes ( event . type ) ; 
function toggle Controls ( force ) { var controls = this . elements . controls ; if ( controls & & this . config . hide Controls ) { 
function remove Current ( ) { var class Name = player . config . class Names . tab Focus ; var current = get Elements . call ( player , " . " . concat ( class Name ) ) ; toggle Class ( current , class Name , false ) ; } 
function set Gutter ( ratio , padding , toggle ) { if ( ! player . is Vimeo ) { return ; } var target = player . elements . wrapper . first Child ; var _ratio = _sliced To Array ( ratio , 2 ) , y = _ratio [ 1 ] ; var _get Aspect Ratio $call = get Aspect Ratio . call ( player ) , _get Aspect Ratio $call 2 = _sliced To Array ( _get Aspect Ratio $call , 2 ) , video X = _get Aspect Ratio $call 2 [ 0 ] , video Y = _get Aspect Ratio $call 2 [ 1 ] ; target . style . max Width = toggle ? " " . concat ( y / video Y * video X , "px " ) : null ; target . style . margin = toggle ? ' 0 auto ' : null ; } 
function set Player Size ( measure ) { 
function subscribe ( bundle Ids , callback Fn ) { 
function publish ( bundle Id , paths Not Found ) { 
function execute Callbacks ( args , deps Not Found ) { 
function load File ( path , callback Fn , args , num Tries ) { var doc = document , async = args . async , max Tries = ( args . num Retries | | 0 ) + 1 , before Callback Fn = args . before | | devnull , path Stripped = path . replace ( / ^ (css |img ) ! / , ' ' ) , is Legacy IECss , e ; num Tries = num Tries | | 0 ; if ( / ( ^css ! | \ .css $ ) / . test ( path ) ) { 
function loadjs ( paths , arg 1 , arg 2 ) { var bundle Id , args ; 
function load Script ( url ) { return new Promise ( function ( resolve , reject ) { loadjs _umd ( url , { success : resolve , error : reject } ) ; } ) ; } 
function ready ( ) { var _this 2 = this ; var player = this ; var config = player . config . vimeo ; 
function parse Id $ 1 ( url ) { if ( is $ 1 . empty ( url ) ) { return null ; } var regex = / ^ . * (youtu .be \ / |v \ / |u \ / \w \ / |embed \ / |watch \ ?v = | &v = ) ( [ ^ # & ? ] * ) . * / ; return url . match ( regex ) ? Reg Exp . $ 2 : url ; } 
function get Title ( video Id ) { var _this 2 = this ; var url = format ( this . config . urls . youtube . api , video Id ) ; fetch ( url ) . then ( function ( data ) { if ( is $ 1 . object ( data ) ) { var title = data . title , height = data . height , width = data . width ; 
function ready ( ) { var player = this ; 
function setup ( ) { 
function Ads ( player ) { var _this = this ; _class Call Check ( this , Ads ) ; this . player = player ; this . config = player . config . ads ; this . playing = false ; this . initialized = false ; this . elements = { container : null , display Container : null } ; this . manager = null ; this . loader = null ; this . cue Points = null ; this . events = { } ; this . safety Timer = null ; this . countdown Timer = null ; 
function load ( ) { var _this 2 = this ; if ( ! this . enabled ) { return ; } 
function setup IMA ( ) { 
function dispatch Event ( type ) { var event = "ads " . concat ( type . replace ( / _ / g , ' ' ) . to Lower Case ( ) ) ; trigger Event . call ( _this 8 . player , _this 8 . player . media , event ) ; } 
function Preview Thumbnails ( player ) { _class Call Check ( this , Preview Thumbnails ) ; this . player = player ; this . thumbnails = [ ] ; this . loaded = false ; this . last Mouse Move Time = Date . now ( ) ; this . mouse Down = false ; this . loaded Images = [ ] ; this . elements = { thumb : { } , scrubbing : { } } ; this . load ( ) ; } 
function insert Elements ( type , attributes ) { var _this = this ; if ( is $ 1 . string ( attributes ) ) { insert Element ( type , this . media , { src : attributes } ) ; } else if ( is $ 1 . array ( attributes ) ) { attributes . for Each ( function ( attribute ) { insert Element ( type , _this . media , attribute ) ; } ) ; } } 
function change ( input ) { var _this 2 = this ; if ( ! get Deep ( input , 'sources .length ' ) ) { this . debug . warn ( 'Invalid source format ' ) ; return ; } 
function clamp ( ) { var input = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : 0 ; var min = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 0 ; var max = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : 2 5 5 ; return Math . min ( Math . max ( input , min ) , max ) ; } 
function play ( ) { var _this 2 = this ; if ( ! is $ 1 . function ( this . media . play ) ) { return null ; } 
function toggle Play ( input ) { 
function increase Volume ( step ) { var volume = this . media . muted ? 0 : this . volume ; this . volume = volume + ( is $ 1 . number ( step ) ? step : 0 ) ; } 
function new Source ( type , init ) { 
function ( str ) { const args = arguments let flag = true let i = 1 str = str . replace ( / %s / g , ( ) = > { const arg = args [ i + + ] if ( typeof arg = = = 'undefined ' ) { flag = false return ' ' } return arg } ) return flag ? str : ' ' } 
function filter Fn ( ) { if ( ! Array . prototype . filter ) { Array . prototype . filter = function ( fun ) { 'use strict ' ; if ( this = = = void 0 | | this = = = null ) { throw new Type Error ( ) ; } var t = Object ( this ) ; var len = t . length > > > 0 ; if ( typeof fun ! = = 'function ' ) { throw new Type Error ( ) ; } var res = [ ] ; var this Arg = arguments . length > = 2 ? arguments [ 1 ] : void 0 ; for ( var i = 0 ; i < len ; i + + ) { if ( i in t ) { var val = t [ i ] ; 
function _GET ( key ) { var url = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : window . location . search ; var reg = new Reg Exp ( ' ( ^ | & ) ' + key + ' = ( [ ^ & ] * ) ( & | $ ) ' ) ; var result = url . substr ( 1 ) . match ( reg ) ; if ( result ) { return decode URIComponent ( result [ 2 ] ) ; } return null ; } 
function _build Url ( dict ) { var url = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : window . location . search ; for ( var _iterator = function ( target ) { return Object . keys ( target ) . map ( function ( key ) { return [ key , target [ key ] ] ; } ) ; } ( dict ) , _is Array = Array . is Array ( _iterator ) , _i = 0 , _iterator = _is Array ? _iterator : _iterator [ Symbol . iterator ] ( ) ; ; ) { var _ref ; if ( _is Array ) { if ( _i > = _iterator . length ) break ; _ref = _iterator [ _i + + ] ; } else { _i = _iterator . next ( ) ; if ( _i . done ) break ; _ref = _i . value ; } var _ref 2 = _ref , _ref 3 = _sliced To Array ( _ref 2 , 2 ) , key = _ref 3 [ 0 ] , val = _ref 3 [ 1 ] ; * 如 果 目 标url 中 包 含 了key 键 , 我 们 需 要 将 它 替 换 成 我 们 自 己 的val * 不 然 就 直 接 添 加 好 了 . * / if ( url . match ( pattern ) ) { var tmp = new Reg Exp ( ' ( ' + key + ' = ) ( [ ^ & ] * ) ' , 'gi ' ) ; url = url . replace ( tmp , target Str ) ; } else { var seperator = url . match ( ' [ ? ] ' ) ? ' & ' : ' ? ' ; url = url + seperator + target Str ; } } if ( location . hash ) { url + = location . hash ; } return url ; } 
function alphanum ( a , b ) { function chunkify ( t ) { const tz = [ ] let y = - 1 let n = 0 for ( let i = 0 ; i < = t . length ; i + + ) { const char = t . char At ( i ) const char Code = char . char Code At ( 0 ) const m = ( char Code = = = 4 6 | | ( char Code > = 4 8 & & char Code < = 5 7 ) ) if ( m ! = = n ) { tz [ + + y ] = ' ' n = m } tz [ y ] + = char } return tz } function stringfy ( v ) { if ( typeof ( v ) = = = 'number ' ) { v = ` $ { v } ` } if ( ! v ) { v = ' ' } return v } const aa = chunkify ( stringfy ( a ) ) const bb = chunkify ( stringfy ( b ) ) for ( let x = 0 ; aa [ x ] & & bb [ x ] ; x + + ) { if ( aa [ x ] ! = = bb [ x ] ) { const c = Number ( aa [ x ] ) const d = Number ( bb [ x ] ) if ( c = = = aa [ x ] & & d = = = bb [ x ] ) { return c - d } return ( aa [ x ] > bb [ x ] ) ? 1 : - 1 } } return aa . length - bb . length } 
function list Packages ( ) { return get Packages ( ) . filter ( path = > ! blacklist . includes ( basename ( path ) ) ) . map ( dir = > dir . replace ( process . cwd ( ) + " / " , " " ) ) ; } 
function jump To Past ( history , index ) { if ( index < 0 | | index > = history . past . length ) return history ; const { past , future , _latest Unfiltered } = history ; const new Past = past . slice ( 0 , index ) ; const new Future = [ . . . past . slice ( index + 1 ) , _latest Unfiltered , . . . future ] ; const new Present = past [ index ] ; return new History ( new Past , new Present , new Future ) ; } 
function jump ( history , n ) { if ( n > 0 ) return jump To Future ( history , n - 1 ) ; if ( n < 0 ) return jump To Past ( history , history . past . length + n ) ; return history ; } 
function update Deps ( deps , packages , version ) { const lib = { } ; _ . each ( packages , pkg = > { lib [ pkg . name ] = version ; } ) ; _ . each ( deps , ( v , dep ) = > { if ( dep in lib ) { deps [ dep ] = " ^ " + version ; } } ) ; } 
function update Deps ( deps , packages ) { const lib = { } ; _ . each ( packages , pkg = > { lib [ pkg . name ] = _ . get ( pkg , "next Release .version " , _ . get ( pkg , "last Release .version " ) ) ; } ) ; _ . each ( deps , ( version , dep ) = > { if ( dep in lib ) { deps [ dep ] = " ^ " + lib [ dep ] ; } } ) ; } 
function update Files ( current Version , next Version ) { process . stdout . write ( ` $ { current Version } ne xt Version } : \ ` ) ; return Promise . all ( files To Update . map ( relative Path = > update Version In File ( current Version , next Version , relative Path ) ) ) ; } 
function preprocess Cart For Server ( { coupon , is _coupon _applied , is _coupon _removed , currency , temporary , extra , products , tax , } ) { const needs Url Coupon = ! ( coupon | | is _coupon _applied | | is _coupon _removed | | typeof document = = = 'undefined ' ) ; const url Coupon = needs Url Coupon ? url . parse ( document . URL , true ) . query . coupon : ' ' ; return Object . assign ( { coupon , is _coupon _applied , is _coupon _removed , currency , tax , temporary , extra , products : products . map ( ( { product _id , meta , free _trial , volume , extra : product Extra } ) = > ( { product _id , meta , free _trial , volume , extra : product Extra , } ) ) , } , needs Url Coupon & & url Coupon & & { coupon : url Coupon , is _coupon _applied : false , } ) ; } 
function get New Messages ( previous Cart Value , next Cart Value ) { previous Cart Value = previous Cart Value | | { } ; next Cart Value = next Cart Value | | { } ; const next Cart Messages = next Cart Value . messages | | [ ] ; 
function get Refund Policy ( cart ) { if ( cart Items . has Domain Registration ( cart ) & & cart Items . has Plan ( cart ) ) { return 'plan With Domain Refund ' ; } if ( cart Items . has Domain Registration ( cart ) ) { return 'domain Refund ' ; } return 'generic Refund ' ; } 
function payment Method Name ( method ) { const payment Methods Names = { alipay : 'Alipay ' , bancontact : 'Bancontact ' , 'credit -card ' : i 1 8n . translate ( 'Credit or debit card ' ) , eps : 'EPS ' , giropay : 'Giropay ' , ideal : 'i DEAL ' , netbanking : 'Net Banking ' , paypal : 'Pay Pal ' , p 2 4 : 'Przelewy 2 4 ' , 'brazil -tef ' : 'Transfer ência banc ária ' , wechat : i 1 8n . translate ( 'We Chat Pay ' , { comment : 'Name for We Chat Pay - https : / /pay .weixin .qq .com / ' , } ) , 'web -payment ' : i 1 8n . translate ( 'Wallet ' ) , sofort : 'Sofort ' , } ; return payment Methods Names [ method ] | | method ; } 
function is Redirect To Valid For Ssr ( redirect To Query Value ) { if ( 'undefined ' = = = typeof redirect To Query Value ) { return true ; } const redirect To Decoded = decode URIComponent ( redirect To Query Value ) ; return ( redirect To Decoded . starts With ( 'https : / /wordpress .com /theme ' ) | | redirect To Decoded . starts With ( 'https : / /wordpress .com /go ' ) ) ; } 
function highlight ( term , html , wrapper Node ) { debug ( 'Starting highlight ' ) ; if ( ! wrapper Node ) { wrapper Node = document . create Element ( 'mark ' ) ; } if ( ! term | | ! html ) { return html ; } const root = document . create Element ( 'div ' ) ; root . inner HTML = html ; walk ( root , term , wrapper Node ) ; return root . inner HTML ; } 
function Mailing List ( category , wpcom ) { if ( ! ( this instanceof Mailing List ) ) { return new Mailing List ( category , wpcom ) ; } this . _category = category ; this . wpcom = wpcom ; } 
function embed ( editor ) { let embed Dialog Container ; const render = ( visible = true ) = > { const selected Embed Node = editor . selection . get Node ( ) ; const store = editor . get Param ( 'redux _store ' ) ; const embed Dialog Props = { embed Url : selected Embed Node . inner Text | | selected Embed Node . text Content , is Visible : visible , on Cancel : ( ) = > render ( false ) , on Update : new Url = > { editor . exec Command ( 'mce Insert Content ' , false , new Url ) ; render ( false ) ; } , } ; render With Redux Store ( React . create Element ( Embed Dialog , embed Dialog Props ) , embed Dialog Container , store ) ; 
function get Webpack Config ( env = { } , argv = { } ) { env . WP = true ; if ( 'theme ' = = = argv . source ) { argv . entry = path . join ( _ _dirname , 'blank -theme ' ) ; argv [ 'output -path ' ] = path . join ( _ _dirname , 'blank -theme ' , 'dist ' ) ; argv [ 'output -filename ' ] = 'blank -theme .js ' ; } else { argv . entry = path . join ( _ _dirname , 'full -site -editing -plugin ' ) ; argv [ 'output -path ' ] = path . join ( _ _dirname , 'full -site -editing -plugin ' , 'dist ' ) ; argv [ 'output -filename ' ] = 'full -site -editing -plugin .js ' ; } const webpack Config = get Base Webpack Config ( env , argv ) ; return { . . . webpack Config , watch : is Development , devtool : is Development ? 'inline -cheap -source -map ' : false , } ; } 
function add Module Import To Sections ( { sections , should Split , only Isomorphic } ) { sections . for Each ( section = > { if ( only Isomorphic & & ! section . isomorphic ) { return ; } const loader Function = ` $ { section . name } $ { section . module } ` ; section . load = should Split ? loader Function . replace ( 'require ' , 'import ' ) : loader Function ; } ) ; 
function setup ( io ) { const SCSS _PATHS = [ path . join ( ' . ' , 'assets ' , 'stylesheets ' ) , path . join ( ' . ' , 'client ' ) ] ; const ROOT _DIR = path . resolve ( _ _dirname , ' . . ' , ' . . ' ) ; const PUBLIC _DIR = path . join ( ROOT _DIR , 'public ' ) ; let css Make = null , errors = ' ' , schedule Build = false ; const public Css Files = { } ; * Handle 'make build -css ' success or failure * @param {Number } code The exit code * / function onexit ( code ) { let changed Files ; css Make . stderr . remove Listener ( 'data ' , onstderr ) ; css Make . stdout . remove Listener ( 'data ' , onstdout ) ; css Make = null ; if ( schedule Build ) { * Updates the MD 5 hash of the public CSS files and returns the changed ones * in a list . * @returns {Array } an array of changed files (string ) * / function update Changed Css Files ( ) { let hash , file Path ; const changed Files = [ ] ; for ( file Path in public Css Files ) { hash = md 5File . sync ( file Path ) ; if ( hash ! = = public Css Files [ file Path ] ) { public Css Files [ file Path ] = hash ; changed Files . push ( path . basename ( file Path ) ) ; } } return changed Files ; } 
function spawn Make ( ) { 
function onexit ( code ) { let changed Files ; css Make . stderr . remove Listener ( 'data ' , onstderr ) ; css Make . stdout . remove Listener ( 'data ' , onstdout ) ; css Make = null ; if ( schedule Build ) { 
function update Changed Css Files ( ) { let hash , file Path ; const changed Files = [ ] ; for ( file Path in public Css Files ) { hash = md 5File . sync ( file Path ) ; if ( hash ! = = public Css Files [ file Path ] ) { public Css Files [ file Path ] = hash ; changed Files . push ( path . basename ( file Path ) ) ; } } return changed Files ; } 
function add Seen Guided Tour ( get State , tour Name , finished = false ) { return save Preference ( 'guided -tours -history ' , [ . . . get Preference ( get State ( ) , 'guided -tours -history ' ) , { timestamp : Date . now ( ) , tour Name , finished , } , ] ) ; } 
function update Site State ( state , site Id , attributes ) { return Object . assign ( { } , state , { [ site Id ] : Object . assign ( { } , initial Site State , state [ site Id ] , attributes ) , } ) ; } 
function path Starts With ( full Path , path Prefix ) { return ( full Path = = = path Prefix | | ( full Path . slice ( 0 , path Prefix . length ) = = = path Prefix & & includes ( ' / ? ' , full Path [ path Prefix . length ] ) ) ) ; } 
function is Valid Categories Array ( categories ) { for ( let i = 0 ; i < categories . length ; i + + ) { if ( ! is Valid Product Category ( categories [ i ] ) ) { 
function is Valid Product Category ( category ) { return ( category & & category . id & & 'number ' = = = typeof category . id & & category . name & & 'string ' = = = typeof category . name & & category . slug & & 'string ' = = = typeof category . slug ) ; } 
function decode User Settings Entities ( data ) { const decoded Values = { display _name : data . display _name & & decode Entities ( data . display _name ) , description : data . description & & decode Entities ( data . description ) , user _URL : data . user _URL & & decode Entities ( data . user _URL ) , } ; return assign ( { } , data , decoded Values ) ; } 
function delete Unsaved Setting ( settings , setting Name ) { unset ( settings , setting Name ) ; const setting Keys = setting Name . split ( ' . ' ) ; if ( setting Keys . length > 1 ) { setting Keys . pop ( ) ; const parent Key = setting Keys . join ( ' . ' ) ; 
function has Language Changed ( language Setting Value , settings = { } ) { if ( ! language Setting Value ) { return false ; } 
function User Settings ( ) { if ( ! ( this instanceof User Settings ) ) { return new User Settings ( ) ; } this . settings = false ; this . initialized = false ; this . re Auth Required = false ; this . fetching Settings = false ; this . unsaved Settings = { } ; } 
function get Domain Name From Receipt Or Cart ( receipt , cart ) { let domain Registration ; if ( receipt & & ! is Empty ( receipt . purchases ) ) { domain Registration = find ( values ( receipt . purchases ) , is Domain Registration ) ; } if ( cart Items . has Domain Registration ( cart ) ) { domain Registration = cart Items . get Domain Registrations ( cart ) [ 0 ] ; } if ( domain Registration ) { return domain Registration . meta ; } return null ; } 
function bust Hash For Hrefs ( { name , old Value } ) { 
function get Modules With Dependencies ( root , file List ) { const file Promises = file List . map ( async file With Path = > { const file Source = await read File Async ( fspath . join ( root , file With Path ) , 'utf 8 ' ) ; const deps = get Dependencies ( file Source ) ; return [ file With Path , deps ] ; } ) ; return Promise . all ( file Promises ) . then ( _ . from Pairs ) ; } 
function get Dependencies ( code ) { var cache = Object . create ( null ) ; var deps = [ ] ; function add Dependency ( dep ) { if ( ! cache [ dep ] ) { cache [ dep ] = true ; deps . push ( dep ) ; } } code . replace ( replace Patterns . BLOCK _COMMENT _RE , ' ' ) . replace ( replace Patterns . LINE _COMMENT _RE , ' ' ) . replace ( replace Patterns . IMPORT _RE , function ( match , pre , quot , dep ) { add Dependency ( dep ) ; return match ; } ) . replace ( replace Patterns . EXPORT _RE , function ( match , pre , quot , dep ) { add Dependency ( dep ) ; return match ; } ) . replace ( replace Patterns . REQUIRE _RE , function ( match , pre , quot , dep ) { add Dependency ( dep ) ; } ) ; return deps ; } 
function generate Usage Stats ( modules ) { function get Camel Cased Dep Name ( dep ) { return dep . split ( ' / ' ) . map ( function ( part ) { return _ . camel Case ( part ) ; } ) . join ( ' / ' ) ; } return Object . keys ( modules ) . reduce ( function ( target , module Name ) { var deps = modules [ module Name ] ; deps . for Each ( function ( dependency ) { const camel Cased Dep Name = get Camel Cased Dep Name ( dependency ) ; if ( ! target [ camel Cased Dep Name ] ) { target [ camel Cased Dep Name ] = { count : 0 } ; } target [ camel Cased Dep Name ] . count + = 1 ; } ) ; return target ; } , { } ) ; } 
function update Cached Product ( products , product ) { let found = false ; const updated Product = { . . . product , name : decode Entities ( product . name ) } ; const new Products = products . map ( p = > { if ( p . id = = = product . id ) { found = true ; return updated Product ; } return p ; } ) ; if ( ! found ) { new Products . push ( updated Product ) ; } return new Products ; } 
function set Loading ( state , params , new Status ) { const queries = ( state . queries & & { . . . state . queries } ) | | { } ; const key = get Serialized Products Query ( params ) ; queries [ key ] = { . . . ( queries [ key ] | | { } ) , is Loading : new Status } ; return queries ; } 
function get Initial Server State ( serialized Server State ) { 
function is UAIn Browserslist ( user Agent String , environment = 'defaults ' ) { return matches UA ( user Agent String , { env : environment , ignore Patch : true , ignore Minor : true , allow Higher Versions : true , } ) ; } 
function generate Static Urls ( target ) { const urls = { . . . static Files Urls } ; const assets = get Assets ( target ) . assets By Chunk Name ; for Each ( assets , ( asset , name ) = > { urls [ name ] = asset ; } ) ; return urls ; } 
function get Accepted Languages From Header ( header ) { if ( ! header ) { return [ ] ; } return header . split ( ' , ' ) . map ( lang = > { const match = lang . match ( / ^ [A -Z ] { 2 , 3 } ( - [A -Z ] { 2 , 3 } ) ? / i ) ; if ( ! match ) { return false ; } return match [ 0 ] . to Lower Case ( ) ; } ) . filter ( lang = > lang ) ; } 
function setup Logged In Context ( req , res , next ) { const is Support Session = ! ! req . get ( 'x -support -session ' ) ; const is Logged In = ! ! req . cookies . wordpress _logged _in ; req . context = { . . . req . context , is Support Session , is Logged In , } ; next ( ) ; } 
function set Up CSP ( req , res , next ) { const original Url Pathname = req . original Url . split ( ' ? ' ) [ 0 ] ; 
function render Server Error ( err , req , res , next ) { if ( process . env . NODE _ENV ! = = 'production ' ) { console . error ( err ) ; } const target = get Build Target From Request ( req ) ; res . status ( err . status | | 5 0 0 ) ; const ctx = { urls : generate Static Urls ( target ) , favicon URL : config ( 'favicon _url ' ) , } ; res . send ( render Jsx ( ' 5 0 0 ' , ctx ) ) ; } 
function handle Locale Subdomains ( req , res , next ) { const lang Slug = ends With ( req . hostname , config ( 'hostname ' ) ) ? split ( req . hostname , ' . ' ) [ 0 ] : null ; if ( lang Slug & & includes ( config ( 'magnificent _non _en _locales ' ) , lang Slug ) ) { 
function get Offset Item ( state , current Item , offset ) { const stream Key = get Current Stream ( state ) ; if ( ! stream Key | | ! state . reader . streams [ stream Key ] ) { return null ; } const stream = state . reader . streams [ stream Key ] ; let index = find Index ( stream . items , item = > keys Are Equal ( item , current Item ) ) ; 
function ( post ) { let latitude , longitude ; if ( ! post ) { return ; } latitude = parse Float ( get Value By Key ( post . metadata , 'geo _latitude ' ) ) ; longitude = parse Float ( get Value By Key ( post . metadata , 'geo _longitude ' ) ) ; if ( latitude & & longitude ) { return [ latitude , longitude ] ; } } 
function ( post ) { if ( ! post ) { return null ; } const is Shared Publicly = get Value By Key ( post . metadata , 'geo _public ' ) ; if ( parse Int ( is Shared Publicly , 1 0 ) ) { return true ; } if ( undefined = = = is Shared Publicly ) { 
function sanitize Extra ( data ) { const path = data . _contact Details Cache ? [ ' _contact Details Cache ' , 'extra ' ] : 'extra ' ; return data & & is Array ( get ( data , path ) ) ? omit ( data , path ) : data ; } 
function transmit Draft Id ( calypso Port ) { 
function handle Press This ( calypso Port ) { calypso Port . add Event Listener ( 'message ' , on Press This , false ) ; calypso Port . start ( ) ; function on Press This ( message ) { const action = get ( message , 'data .action ' ) ; const payload = get ( message , 'data .payload ' ) ; if ( action ! = = 'press This ' | | ! payload ) { return ; } calypso Port . remove Event Listener ( 'message ' , on Press This , false ) ; const unsubscribe = subscribe ( ( ) = > { 
function handle Post Locked ( calypso Port ) { const unsubscribe = subscribe ( ( ) = > { const is Locked = select ( 'core /editor ' ) . is Post Locked ( ) ; const is Lock Takeover = select ( 'core /editor ' ) . is Post Lock Takeover ( ) ; const locked Dialog Buttons = document . query Selector All ( 'div .editor -post -locked -modal _ _buttons > a ' ) ; const is Post Takeover Dialog = is Locked & & ! is Lock Takeover & & locked Dialog Buttons . length = = = 3 ; if ( is Post Takeover Dialog ) { 
function handle Post Lock Takeover ( calypso Port ) { const unsubscribe = subscribe ( ( ) = > { const is Locked = select ( 'core /editor ' ) . is Post Locked ( ) ; const is Lock Takeover = select ( 'core /editor ' ) . is Post Lock Takeover ( ) ; const all Posts Button = document . query Selector ( 'div .editor -post -locked -modal _ _buttons > a ' ) ; const is Post Takeover Dialog = is Locked & & is Lock Takeover & & all Posts Button ; if ( is Post Takeover Dialog ) { 
function handle Update Image Blocks ( calypso Port ) { calypso Port . add Event Listener ( 'message ' , on Update Image Blocks , false ) ; calypso Port . start ( ) ; const image Blocks = { 'core /cover ' : update Singe Image Block , 'core /image ' : update Singe Image Block , 'core /file ' : partial Right ( update Singe Image Block , { url : 'href ' } ) , 'core /gallery ' : update Multiple Images Block , 'core /media -text ' : partial Right ( update Singe Image Block , { id : 'media Id ' , url : 'media Url ' , } ) , 'jetpack /tiled -gallery ' : update Multiple Images Block , } ; function update Image Blocks ( blocks , image ) { for Each ( blocks , block = > { if ( image Blocks [ block . name ] ) { image Blocks [ block . name ] ( block , image ) ; } if ( block . inner Blocks . length ) { update Image Blocks ( block . inner Blocks , image ) ; } } ) ; } function preload Image ( image Url ) { return new Promise ( ( resolve , reject ) = > { const preloaded Image = new Image ( ) ; preloaded Image . src = image Url ; preloaded Image . onload = resolve ; preloaded Image . onerror = reject ; } ) ; } function update Singe Image Block ( block , image , attr Names ) { const block Image Id = get ( block , 'attributes .id ' ) ; if ( block Image Id ! = = image . id & & block Image Id ! = = image . transient Id ) { return ; } attr Names = { . . . attr Names , id : 'id ' , url : 'url ' } ; if ( 'deleted ' = = = image . status ) { dispatch ( 'core /editor ' ) . update Block Attributes ( block . client Id , { [ attr Names . id ] : undefined , [ attr Names . url ] : undefined , } ) ; return ; } preload Image ( image . url ) . then ( ( ) = > { dispatch ( 'core /editor ' ) . update Block Attributes ( block . client Id , { [ attr Names . id ] : image . id , [ attr Names . url ] : image . url , } ) ; } ) ; } function update Multiple Images Block ( block , image , attr Names ) { attr Names = { . . . attr Names , id : 'id ' , url : 'url ' , images : 'images ' } ; const current Images = get ( block , [ 'attributes ' , attr Names . images ] ) ; let updated Images = [ ] ; if ( 'deleted ' = = = image . status ) { updated Images = filter ( current Images , current Image = > { return current Image . id ! = = image . id & & current Image . id ! = = image . transient Id ; } ) ; dispatch ( 'core /editor ' ) . update Block Attributes ( block . client Id , { [ attr Names . images ] : updated Images , } ) ; return ; } preload Image ( image . url ) . then ( ( ) = > { updated Images = map ( current Images , current Image = > { const current Image Id = parse Int ( current Image . id , 1 0 ) ; if ( current Image Id ! = = image . id & & current Image Id ! = = image . transient Id ) { return current Image ; } return { [ attr Names . id ] : image . id , [ attr Names . url ] : image . url , } ; } ) ; dispatch ( 'core /editor ' ) . update Block Attributes ( block . client Id , { [ attr Names . images ] : updated Images , } ) ; } ) ; } 
function update Image Blocks ( blocks , image ) { for Each ( blocks , block = > { if ( image Blocks [ block . name ] ) { image Blocks [ block . name ] ( block , image ) ; } if ( block . inner Blocks . length ) { update Image Blocks ( block . inner Blocks , image ) ; } } ) ; } 
function update Featured Image Preview ( image ) { const current Image Id = select ( 'core /editor ' ) . get Edited Post Attribute ( 'featured _media ' ) ; if ( current Image Id ! = = image . id ) { return ; } preload Image ( image . url ) . then ( ( ) = > { const current Image = select ( 'core ' ) . get Media ( current Image Id ) ; const updated Image = { . . . current Image , media _details : { height : image . height , width : image . width , } , source _url : image . url , } ; dispatch ( 'core ' ) . receive Entity Records ( 'root ' , 'media ' , [ updated Image ] , null , true ) ; } ) ; } 
function handle Preview ( calypso Port ) { $ ( ' #editor ' ) . on ( 'click ' , ' .editor -post -preview ' , e = > { e . prevent Default ( ) ; e . stop Propagation ( ) ; const post Url = select ( 'core /editor ' ) . get Current Post Attribute ( 'link ' ) ; const preview Channel = new Message Channel ( ) ; calypso Port . post Message ( { action : 'preview Post ' , payload : { post Url : post Url , } , } , [ preview Channel . port 2 ] ) ; const is Autosaveable = select ( 'core /editor ' ) . is Edited Post Autosaveable ( ) ; 
function handle Insert Classic Block Media ( calypso Port ) { calypso Port . add Event Listener ( 'message ' , on Insert Classic Block Media , false ) ; calypso Port . start ( ) ; function on Insert Classic Block Media ( message ) { const action = get ( message , 'data .action ' ) ; if ( action ! = = 'insert Classic Block Media ' ) { return ; } const editor Id = get ( message , 'data .payload .editor Id ' ) ; const media = get ( message , 'data .payload .media ' ) ; tinymce . editors [ editor Id ] . exec Command ( 'mce Insert Content ' , false , media ) ; } } 
function handle Go To All Posts ( calypso Port ) { $ ( ' #editor ' ) . on ( 'click ' , ' .edit -post -fullscreen -mode -close _ _toolbar a ' , e = > { e . prevent Default ( ) ; calypso Port . post Message ( { action : 'go To All Posts ' , payload : { unsaved Changes : select ( 'core /editor ' ) . is Edited Post Dirty ( ) , } , } ) ; } ) ; } 
function open Links In Parent Frame ( ) { const view Post Link Selectors = [ ' .components -notice -list .is -success .components -notice _ _action .is -link ' , 
function toolbar Pin ( editor ) { let is Monitoring Scroll = false , is Pinned = false , container ; function set Container ( ) { container = editor . get Container ( ) ; } function toggle Pinned ( to Be Pinned ) { is Pinned = to Be Pinned ; editor . dom . toggle Class ( container , 'is -pinned ' , is Pinned ) ; } const pin Toolbar On Scroll = throttle ( ( ) = > { if ( ! container ) { return ; } if ( is Pinned & & window . page YOffset < container . offset Top ) { * Binds or unbinds the scroll event from the global window object , since * pinning behavior is restricted to larger viewports whilst the visual * editing mode is active . * / const maybe Bind Scroll = throttle ( event = > { const is Visual = ! editor . is Hidden ( ) ; const should Bind = 'remove ' ! = = event . type & & is Visual & & is Within Breakpoint ( ' > 6 6 0px ' ) ; if ( should Bind = = = is Monitoring Scroll ) { 
function Two Step Authorization ( ) { if ( ! ( this instanceof Two Step Authorization ) ) { return new Two Step Authorization ( ) ; } this . data = null ; this . initialized = false ; this . sms Resend Throttled = false ; this . bump MCStat = function ( event Action ) { analytics . mc . bump Stat ( ' 2fa ' , event Action ) ; analytics . tracks . record Event ( 'calypso _login _twostep _authorize ' , { event _action : event Action , } ) ; } ; this . fetch ( ) ; } 
function _init Storage ( options ) { const db Info = { } ; if ( options ) { for ( const i in options ) { db Info [ i ] = options [ i ] ; } } db Info . db = { } ; dummy Storage [ db Info . name ] = db Info . db ; this . _db Info = db Info ; return Promise . resolve ( ) ; } 
function track Body Click ( event ) { if ( editor Event Ancestor ( event , ' .mce -colorbutton ' ) & & ! editor Event Ancestor ( event , ' .mce -open ' ) ) { 
function get Query Manager ( state , site Id ) { if ( ! site Id ) { return state . posts . all Sites Queries ; } return state . posts . queries [ site Id ] | | null ; } 
function ( state , action ) { if ( typeof state [ action . site Id ] ! = = 'undefined ' ) { return Object . assign ( { } , state , { [ action . site Id ] : plugins For Site ( state [ action . site Id ] , action ) , } ) ; } return state ; } 
function plugins For Site ( state = [ ] , action ) { switch ( action . type ) { case PLUGIN _ACTIVATE _REQUEST _SUCCESS : case PLUGIN _DEACTIVATE _REQUEST _SUCCESS : case PLUGIN _UPDATE _REQUEST _SUCCESS : case PLUGIN _AUTOUPDATE _ENABLE _REQUEST _SUCCESS : case PLUGIN _AUTOUPDATE _DISABLE _REQUEST _SUCCESS : return state . map ( p = > plugin ( p , action ) ) ; case PLUGIN _INSTALL _REQUEST _SUCCESS : return [ . . . state , action . data ] ; case PLUGIN _REMOVE _REQUEST _SUCCESS : const index = find Index ( state , { id : action . plugin Id } ) ; return [ . . . state . slice ( 0 , index ) , . . . state . slice ( index + 1 ) ] ; default : return state ; } } 
function plugin ( state , action ) { switch ( action . type ) { case PLUGIN _ACTIVATE _REQUEST _SUCCESS : case PLUGIN _DEACTIVATE _REQUEST _SUCCESS : case PLUGIN _AUTOUPDATE _ENABLE _REQUEST _SUCCESS : case PLUGIN _AUTOUPDATE _DISABLE _REQUEST _SUCCESS : if ( state . id ! = = action . data . id ) { return state ; } return Object . assign ( { } , state , action . data ) ; case PLUGIN _UPDATE _REQUEST _SUCCESS : if ( state . id ! = = action . data . id ) { return state ; } return Object . assign ( { } , omit ( state , 'update ' ) , action . data ) ; default : return state ; } } 
function init At DCore ( ) { atd Core = new At DCore ( ) ; atd Core . map = each ; atd Core . _is Tiny MCE = true ; atd Core . get Attrib = function ( node , key ) { return dom . get Attrib ( node , key ) ; } ; atd Core . find Spans = function ( parent ) { if ( parent = = = undefined ) { return dom . select ( 'span ' ) ; } return dom . select ( 'span ' , parent ) ; } ; atd Core . has Class = function ( node , class Name ) { return dom . has Class ( node , class Name ) ; } ; atd Core . contents = function ( node ) { return node . child Nodes ; } ; atd Core . replace With = function ( old _node , new _node ) { return dom . replace ( new _node , old _node ) ; } ; atd Core . create = function ( node _html ) { return dom . create ( 'span ' , { class : 'mce Item Hidden ' , 'data -mce -bogus ' : 1 } , node _html ) ; } ; atd Core . remove Parent = function ( node ) { dom . remove ( node , true ) ; return node ; } ; atd Core . remove = function ( node ) { dom . remove ( node ) ; } ; atd Core . set Ignore Strings ( editor . get Param ( 'atd _ignore _strings ' , [ ] ) . join ( ' , ' ) ) ; atd Core . show Types ( editor . get Param ( 'atd _show _types ' , ' ' ) ) ; } 
function finish ( ) { let node , regex = new Reg Exp ( 'mce Item Hidden |hidden ( ( (Grammar |Spell )Error ) |Suggestion ) ' ) , nodes = editor . dom . select ( 'span ' ) , i = nodes . length ; while ( i - - ) { 
function show Suggestions ( target ) { let items = [ ] , text = target . inner Text | | target . text Content , error Description = atd Core . find Suggestion ( target ) ; if ( ! error Description ) { items . push ( { text : translate ( 'No suggestions ' , { comment : 'Editor proofreading no suggestions ' } ) , classes : 'atd -menu -title ' , disabled : true , } ) ; } else { items . push ( { text : error Description . description , classes : 'atd -menu -title ' , disabled : true , } ) ; if ( error Description . suggestions . length ) { items . push ( { text : ' - ' } ) ; 
function render _range ( new _sub _text , new _sub _range , range _info , range _data , options ) { 
function build _chunks ( sub _text , sub _ranges , range _data , container , options ) { let text _start = null , text _stop = null , i , remove _r _id , r _id , sr _id , range _id , range _info , new _i , new _sub _text , new _sub _range ; 
function find _largest _range ( rs ) { let r _id = - 1 , r _size = 0 , i ; if ( rs . length < 1 ) { return null ; } for ( i = 0 ; i < rs . length ; i + + ) { if ( null = = = rs [ i ] ) { continue ; } 
function parse Image ( node , _parsed ) { _parsed . type = Media Types . IMAGE ; _parsed . media . URL = node . get Attribute ( 'src ' ) ; _parsed . media . alt = node . get Attribute ( 'alt ' ) ; 
function create Progress Handler ( ) { const start Time = Date . now ( ) ; let last Shown Building Message Time = null ; let last Unshown Building Message = null ; return ( percentage , msg , . . . details ) = > { const now Time = Date . now ( ) ; const time String = ( ( now Time - start Time ) / 1 0 0 0 ) . to Fixed ( 1 ) + 's ' ; const percentage String = ` $ { Math . floor ( percentage * 1 0 0 ) } ` ; const details String = details . map ( detail = > { if ( ! detail ) { return ' ' ; } if ( detail . length > 4 0 ) { return ` d tail .s u bstr ( d tail .l e ngth - 3 ) } ; } return detail ; } ) . join ( ' ' ) ; const message = ` $ { time String } $ { percentage String } $ { msg } $ { details String } ` ; 
function should Transpile Dependency ( filepath ) { 
function get Node As String ( node ) { if ( undefined = = = node ) { return ' ' ; } switch ( node . type ) { case 'Binary Expression ' : return get Node As String ( node . left ) + get Node As String ( node . right ) ; case 'String Literal ' : return node . value ; default : return ' ' ; } } 
function set Up Locale ( context , next ) { const language = get Language ( context . params . lang ) ; if ( language ) { context . lang = context . params . lang ; if ( language . rtl ) { context . is RTL = true ; } } next ( ) ; } 
function custom Post Metadata To Product Attributes ( metadata ) { const product Attributes = { } ; metadata . for Each ( ( { key , value } ) = > { const schema Key = meta Key To Schema Key Map [ key ] ; if ( ! schema Key ) { return ; } 
function split Text Node ( textnode , regexp , replacement ) { let text = textnode . node Value , index = text . search ( regexp ) , match = text . match ( regexp ) , captured = [ ] , cursor ; if ( index < 0 | | ! match . length ) { return [ textnode ] ; } if ( index > 0 ) { 
function bring The Hurt ( node ) { let span , split Nodes ; if ( node . node Type = = = 3 ) { ecount + + ; if ( parent . is IE ( ) & & node . node Value . length > 0 & & node . node Value . substr ( 0 , 1 ) = = = ' ' ) { return parent . create ( empty Span + node . node Value . substr ( 1 , node . node Value . length - 1 ) . replace ( regexp , result ) , false ) ; } if ( text Only Mode ) { return parent . create ( node . node Value . replace ( regexp , result ) , false ) ; } span = parent . create ( ' <span / > ' ) ; if ( typeof text Only Mode = = = 'undefined ' ) { 
function first Element Is Breakline ( dom ) { if ( dom . child Nodes . length = = = 0 ) { return dom . node Name = = = 'BR ' & & dom ; } return first Element Is Breakline ( dom . first Child ) ; } 
function parse As Shortcode ( node , _parsed ) { 
function parse As Element ( node , _parsed ) { 
function is Default Or Null Query Value ( value , key ) { return value = = = undefined | | value = = = null | | DEFAULT _THEME _QUERY [ key ] = = = value ; } 
function get Webpack Config ( env = { } , { entry = path . join ( _ _dirname , 'src ' , 'standalone ' ) , 'output -path ' : output Path = path . join ( _ _dirname , 'dist ' ) , 'output -filename ' : output Filename = 'build .min .js ' , } ) { const webpack Config = get Base Webpack Config ( env , { entry , 'output -filename ' : output Filename , 'output -path ' : output Path , } ) ; const page Meta = { node Platform : process . platform , node Version : process . version , git Describe : spawn Sync ( 'git ' , [ 'describe ' , ' - -always ' , ' - -dirty ' , ' - -long ' ] , { encoding : 'utf 8 ' , } ) . stdout . replace ( ' \n ' , ' ' ) , } ; return { . . . webpack Config , plugins : [ . . . webpack Config . plugins , new Html Webpack Plugin ( { filename : path . join ( output Path , 'index .html ' ) , template : path . join ( _ _dirname , 'src ' , 'index .ejs ' ) , title : 'Notifications ' , hash : true , inject : false , is RTL : false , . . . page Meta , } ) , new Html Webpack Plugin ( { filename : path . join ( output Path , 'rtl .html ' ) , template : path . join ( _ _dirname , 'src ' , 'index .ejs ' ) , title : 'Notifications ' , hash : true , inject : false , is RTL : true , . . . page Meta , } ) , new Html Webpack Plugin ( { filename : path . join ( output Path , 'cache -buster .txt ' ) , template Content : ( ) = > page Meta . git Describe , inject : false , } ) , ] , } ; } 
function settings ( state = { } , action ) { switch ( action . type ) { case WOOCOMMERCE _MAILCHIMP _SETTINGS _REQUEST _SUCCESS : case WOOCOMMERCE _MAILCHIMP _SETTINGS _REQUEST _FAILURE : case WOOCOMMERCE _MAILCHIMP _API _KEY _SUBMIT _SUCCESS : case WOOCOMMERCE _MAILCHIMP _STORE _INFO _SUBMIT _SUCCESS : case WOOCOMMERCE _MAILCHIMP _CAMPAIGN _DEFAULTS _SUBMIT _SUCCESS : case WOOCOMMERCE _MAILCHIMP _NEWSLETTER _SETTINGS _SUBMIT _SUCCESS : return Object . assign ( { } , state , action . settings ) ; case WOOCOMMERCE _MAILCHIMP _LISTS _REQUEST _SUCCESS : const data = { mailchimp _lists : action . lists } ; const list Keys = keys ( action . lists ) ; if ( ! state . mailchimp _list & & list Keys . length > 0 ) { 
function settings Request ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE _MAILCHIMP _SETTINGS _REQUEST : case WOOCOMMERCE _MAILCHIMP _SETTINGS _REQUEST _SUCCESS : case WOOCOMMERCE _MAILCHIMP _SETTINGS _REQUEST _FAILURE : return WOOCOMMERCE _MAILCHIMP _SETTINGS _REQUEST = = = type ; } return state ; } 
function settings Request Error ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE _MAILCHIMP _SETTINGS _REQUEST _SUCCESS : case WOOCOMMERCE _MAILCHIMP _SETTINGS _REQUEST _FAILURE : const error = WOOCOMMERCE _MAILCHIMP _SETTINGS _REQUEST _FAILURE = = = action . type ? action . error : false ; return error ; } return state ; } 
function sync Status ( state = { } , action ) { switch ( action . type ) { case WOOCOMMERCE _MAILCHIMP _SYNC _STATUS _REQUEST _SUCCESS : case WOOCOMMERCE _MAILCHIMP _RESYNC _REQUEST _SUCCESS : return Object . assign ( { } , action . sync Status ) ; } return state ; } 
function sync Status Request ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE _MAILCHIMP _SYNC _STATUS _REQUEST : case WOOCOMMERCE _MAILCHIMP _SYNC _STATUS _REQUEST _SUCCESS : case WOOCOMMERCE _MAILCHIMP _SYNC _STATUS _REQUEST _FAILURE : return WOOCOMMERCE _MAILCHIMP _SYNC _STATUS _REQUEST = = = type ; } return state ; } 
function sync Status Request Error ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE _MAILCHIMP _SYNC _STATUS _REQUEST _SUCCESS : case WOOCOMMERCE _MAILCHIMP _SYNC _STATUS _REQUEST _FAILURE : const error = WOOCOMMERCE _MAILCHIMP _SYNC _STATUS _REQUEST _FAILURE = = = action . type ? action . error : false ; return error ; } return state ; } 
function resync Request ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE _MAILCHIMP _RESYNC _REQUEST : case WOOCOMMERCE _MAILCHIMP _RESYNC _REQUEST _SUCCESS : case WOOCOMMERCE _MAILCHIMP _RESYNC _REQUEST _FAILURE : return WOOCOMMERCE _MAILCHIMP _RESYNC _REQUEST = = = type ; } return state ; } 
function resync Request Error ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE _MAILCHIMP _RESYNC _REQUEST _SUCCESS : case WOOCOMMERCE _MAILCHIMP _RESYNC _REQUEST _FAILURE : const error = WOOCOMMERCE _MAILCHIMP _RESYNC _REQUEST _FAILURE = = = action . type ? action . error : false ; return error ; } return state ; } 
function api Key Submit ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE _MAILCHIMP _API _KEY _SUBMIT : case WOOCOMMERCE _MAILCHIMP _API _KEY _SUBMIT _SUCCESS : case WOOCOMMERCE _MAILCHIMP _API _KEY _SUBMIT _FAILURE : return WOOCOMMERCE _MAILCHIMP _API _KEY _SUBMIT = = = type ; } return state ; } 
function api Key Submit Error ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE _MAILCHIMP _API _KEY _SUBMIT _SUCCESS : case WOOCOMMERCE _MAILCHIMP _API _KEY _SUBMIT _FAILURE : const error = WOOCOMMERCE _MAILCHIMP _API _KEY _SUBMIT _FAILURE = = = action . type ? action . error : false ; return error ; } return state ; } 
function store Info Submit ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE _MAILCHIMP _STORE _INFO _SUBMIT : case WOOCOMMERCE _MAILCHIMP _STORE _INFO _SUBMIT _SUCCESS : case WOOCOMMERCE _MAILCHIMP _STORE _INFO _SUBMIT _FAILURE : return WOOCOMMERCE _MAILCHIMP _STORE _INFO _SUBMIT = = = type ; } return state ; } 
function store Info Submit Error ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE _MAILCHIMP _STORE _INFO _SUBMIT _SUCCESS : case WOOCOMMERCE _MAILCHIMP _STORE _INFO _SUBMIT _FAILURE : const error = WOOCOMMERCE _MAILCHIMP _STORE _INFO _SUBMIT _FAILURE = = = action . type ? action . error : false ; return error ; } return state ; } 
function lists Request ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE _MAILCHIMP _LISTS _REQUEST : case WOOCOMMERCE _MAILCHIMP _LISTS _REQUEST _SUCCESS : case WOOCOMMERCE _MAILCHIMP _LISTS _REQUEST _FAILURE : return WOOCOMMERCE _MAILCHIMP _LISTS _REQUEST = = = type ; } return state ; } 
function lists Request Error ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE _MAILCHIMP _LISTS _REQUEST _SUCCESS : case WOOCOMMERCE _MAILCHIMP _LISTS _REQUEST _FAILURE : const error = WOOCOMMERCE _MAILCHIMP _LISTS _REQUEST _FAILURE = = = action . type ? action . error : false ; return error ; } return state ; } 
function newsletter Settings Submit ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE _MAILCHIMP _NEWSLETTER _SETTINGS _SUBMIT : case WOOCOMMERCE _MAILCHIMP _NEWSLETTER _SETTINGS _SUBMIT _SUCCESS : case WOOCOMMERCE _MAILCHIMP _NEWSLETTER _SETTINGS _SUBMIT _FAILURE : return WOOCOMMERCE _MAILCHIMP _NEWSLETTER _SETTINGS _SUBMIT = = = type ; } return state ; } 
function newsletter Settings Submit Error ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE _MAILCHIMP _NEWSLETTER _SETTINGS _SUBMIT _SUCCESS : case WOOCOMMERCE _MAILCHIMP _NEWSLETTER _SETTINGS _SUBMIT _FAILURE : const error = WOOCOMMERCE _MAILCHIMP _NEWSLETTER _SETTINGS _SUBMIT _FAILURE = = = action . type ? action . error : false ; return error ; } return state ; } 
function save Settings ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE _MAILCHIMP _SAVE _SETTINGS : return true ; case WOOCOMMERCE _MAILCHIMP _NEWSLETTER _SETTINGS _SUBMIT _SUCCESS : case WOOCOMMERCE _MAILCHIMP _NEWSLETTER _SETTINGS _SUBMIT _FAILURE : return false ; } return state ; } 
function delete Invites ( site Invites , invites To Delete ) { return site Invites . filter ( site Invite = > ! includes ( invites To Delete , site Invite . key ) ) ; } 
function Stats Data Local List ( options ) { if ( ! ( this instanceof Stats Data Local List ) ) { return new Stats Data Local List ( options ) ; } if ( 'string ' ! = = typeof options . local Store Key ) { throw new Type Error ( 'a options .local Store Key must be passed in ' ) ; } debug ( 'creating new local list ' ) ; this . local Store Key = options . local Store Key ; this . limit = options . limit | | 1 0 ; return this ; } 
function get Aliases For Extensions ( { extensions Directory } ) { const extensions Names = fs . readdir Sync ( extensions Directory ) . filter ( filename = > filename . index Of ( ' . ' ) = = = - 1 ) ; 
function updated Action ( site Id , originating Action , success Action , sent Data ) { return ( dispatch , get State , { data : received Data } ) = > { dispatch ( product Updated ( site Id , received Data , originating Action ) ) ; const props = { sent Data , received Data } ; dispatch With Props ( dispatch , get State , success Action , props ) ; } ; } 
function markdown ( editor ) { function allow Markdown Attribute ( event ) { const ed = event . target ; Object . keys ( ed . schema . elements ) . for Each ( function ( key ) { ed . schema . elements [ key ] . attributes . markdown = { } ; ed . schema . elements [ key ] . attributes Order . push ( 'markdown ' ) ; } ) ; } editor . on ( 'preinit ' , allow Markdown Attribute ) ; } 
function get Purchases By Site ( purchases , sites ) { return purchases . reduce ( ( result , current Value ) = > { const site = find ( result , { id : current Value . site Id } ) ; if ( site ) { site . purchases = site . purchases . concat ( current Value ) ; } else { const site Object = find ( sites , { ID : current Value . site Id } ) ; result = result . concat ( { id : current Value . site Id , name : current Value . site Name , slug : site Object ? site Object . slug : current Value . domain , is Domain Only : site Object ? site Object . options . is _domain _only : false , title : current Value . site Name | | current Value . domain | | ' ' , purchases : [ current Value ] , domain : site Object ? site Object . domain : current Value . domain , } ) ; } return result ; } , [ ] ) . sort ( ( a , b ) = > ( a . title . to Lower Case ( ) > b . title . to Lower Case ( ) ? 1 : - 1 ) ) ; } 
function handle Renew Now Click ( purchase , site Slug ) { const renew Item = cart Items . get Renewal Item From Product ( purchase , { domain : purchase . meta , } ) ; const renew Items = [ renew Item ] ; 
function is Cancelable ( purchase ) { if ( is Included With Plan ( purchase ) ) { return false ; } if ( is Pending Transfer ( purchase ) ) { return false ; } if ( is Expired ( purchase ) ) { return false ; } if ( is Refundable ( purchase ) ) { return true ; } return purchase . can Disable Auto Renew ; } 
function maybe Within Refund Period ( purchase ) { if ( is Refundable ( purchase ) ) { return true ; } 
function is Removable ( purchase ) { if ( is Included With Plan ( purchase ) ) { return false ; } if ( is Concierge Session ( purchase ) ) { return false ; } return ( is Jetpack Plan ( purchase ) | | is Expiring ( purchase ) | | is Expired ( purchase ) | | ( is Domain Transfer ( purchase ) & & ! is Refundable ( purchase ) & & is Purchase Cancelable ( purchase ) ) ) ; } 
function payment Logo Type ( purchase ) { if ( is Paid With Credit Card ( purchase ) ) { return purchase . payment . credit Card . type ; } if ( is Paid With Pay Pal Direct ( purchase ) ) { return 'placeholder ' ; } return purchase . payment . type | | null ; } 
function image Has Min Width And Height ( width , height ) { return function ( image ) { return image . width > = width & & image . height > = height ; } ; } 
function css Name From Filename ( name ) { if ( name ) { const [ css Chunk Filename , chunk Query String ] = name . split ( ' ? ' , 2 ) ; return css Chunk Filename . replace ( / \ .js $ / i , ' .css ' + ( chunk Query String ? ` $ { chunk Query String } ` : ' ' ) ) ; } } 
function verify HTML ( caption ) { if ( ! caption | | ( caption . index Of ( ' < ' ) = = = - 1 & & caption . index Of ( ' > ' ) = = = - 1 ) ) { return caption ; } if ( ! serializer ) { serializer = new tinymce . html . Serializer ( { } , editor . schema ) ; } return serializer . serialize ( editor . parser . parse ( caption , { forced _root _block : false } ) ) ; } 
function init ( { custom Enhancer , custom Middleware = { } } = { } ) { const middle = with Middleware ( custom Middleware ) ; const create = custom Enhancer ? custom Enhancer ( middle ) : middle ; store = create ( reducer , reducer ( undefined , { type : ' @ @INIT ' } ) ) ; return store ; } 
function Popup Monitor ( ) { this . intervals = { } ; this . monitor Interval = null ; this . window Instance = null ; this . on Message = message Event = > { if ( message Event . source = = = this . window Instance ) { this . emit ( 'message ' , message Event . data ) ; } } ; } 
function plugins For Site ( state = [ ] , action ) { switch ( action . type ) { case PLUGIN _SETUP _INSTRUCTIONS _RECEIVE : return action . data ; case PLUGIN _SETUP _INSTALL : case PLUGIN _SETUP _ACTIVATE : case PLUGIN _SETUP _CONFIGURE : case PLUGIN _SETUP _FINISH : case PLUGIN _SETUP _ERROR : return state . map ( p = > plugin ( p , action ) ) ; default : return state ; } } 
function plugin ( state , action ) { switch ( action . type ) { case PLUGIN _SETUP _INSTALL : case PLUGIN _SETUP _ACTIVATE : case PLUGIN _SETUP _CONFIGURE : case PLUGIN _SETUP _FINISH : if ( state . slug ! = = action . slug ) { return state ; } return Object . assign ( { } , state , { status : plugin Status ( state . status , action ) , } ) ; case PLUGIN _SETUP _ERROR : if ( state . slug ! = = action . slug ) { return state ; } return Object . assign ( { } , state , { status : plugin Status ( state . status , action ) , error : action . error , } ) ; default : return state ; } } 
function plugin Status ( state , action ) { switch ( action . type ) { case PLUGIN _SETUP _INSTALL : return 'install ' ; case PLUGIN _SETUP _ACTIVATE : return 'activate ' ; case PLUGIN _SETUP _CONFIGURE : return 'configure ' ; case PLUGIN _SETUP _FINISH : return 'done ' ; default : return state | | 'wait ' ; } } 
function wpcom Plugin ( editor ) { var DOM = tinymce . DOM , each = tinymce . each , style ; editor . on ( 'focus ' , function ( ) { window . wp Active Editor = editor . id ; } ) ; * Experimental : create a floating toolbar . * This functionality will change in the next releases . Not recommended for use by plugins . * / editor . on ( 'preinit ' , function ( ) { var Factory = tinymce . ui . Factory , settings = editor . settings , active Toolbar , current Selection , timeout , container = editor . get Container ( ) , wp Adminbar = document . get Element By Id ( 'wpadminbar ' ) , mce Iframe = document . get Element By Id ( editor . id + ' _ifr ' ) , mce Toolbar , mce Statusbar , wp Statusbar , is Chrome Rtl = editor . get Param ( 'directionality ' ) = = = 'rtl ' & & / Chrome / . test ( navigator . user Agent ) ; if ( container ) { mce Toolbar = tinymce . $ ( ' .mce -toolbar -grp ' , container ) [ 0 ] ; mce Statusbar = tinymce . $ ( ' .mce -statusbar ' , container ) [ 0 ] ; } if ( editor . id = = = 'content ' ) { wp Statusbar = document . get Element By Id ( 'post -status -info ' ) ; } function create ( buttons , bottom ) { var toolbar , toolbar Items = [ ] , button Group ; each ( buttons , function ( item ) { var item Name ; function bind Selector Changed ( ) { var selection = editor . selection ; if ( item Name = = = 'bullist ' ) { selection . selector Changed ( 'ul > li ' , function ( state , args ) { var i = args . parents . length , node Name ; while ( i - - ) { node Name = args . parents [ i ] . node Name ; if ( node Name = = = 'OL ' | | node Name = = = 'UL ' ) { break ; } } item . active ( state & & node Name = = = 'UL ' ) ; } ) ; } if ( item Name = = = 'numlist ' ) { selection . selector Changed ( 'ol > li ' , function ( state , args ) { var i = args . parents . length , node Name ; while ( i - - ) { node Name = args . parents [ i ] . node Name ; if ( node Name = = = 'OL ' | | node Name = = = 'UL ' ) { break ; } } item . active ( state & & node Name = = = 'OL ' ) ; } ) ; } if ( item . settings . state Selector ) { selection . selector Changed ( item . settings . state Selector , function ( state ) { item . active ( state ) ; } , true ) ; } if ( item . settings . disabled State Selector ) { selection . selector Changed ( item . settings . disabled State Selector , function ( state ) { item . disabled ( state ) ; } ) ; } } if ( item = = = ' | ' ) { button Group = null ; } else { if ( Factory . has ( item ) ) { item = { type : item , } ; if ( settings . toolbar _items _size ) { item . size = settings . toolbar _items _size ; } toolbar Items . push ( item ) ; button Group = null ; } else { if ( ! button Group ) { button Group = { type : 'buttongroup ' , items : [ ] , } ; toolbar Items . push ( button Group ) ; } if ( editor . buttons [ item ] ) { item Name = item ; item = editor . buttons [ item Name ] ; if ( typeof item = = = 'function ' ) { item = item ( ) ; } item . type = item . type | | 'button ' ; if ( settings . toolbar _items _size ) { item . size = settings . toolbar _items _size ; } item = Factory . create ( item ) ; button Group . items . push ( item ) ; if ( editor . initialized ) { bind Selector Changed ( ) ; } else { editor . on ( 'init ' , bind Selector Changed ) ; } } } } } ) ; toolbar = Factory . create ( { type : 'panel ' , layout : 'stack ' , classes : 'toolbar -grp inline -toolbar -grp ' , aria Root : true , aria Remember : true , items : [ { type : 'toolbar ' , layout : 'flow ' , items : toolbar Items , } , ] , } ) ; toolbar . bottom = bottom ; function reposition ( ) { if ( ! current Selection ) { return this ; } var scroll X = window . page XOffset | | document . document Element . scroll Left , scroll Y = window . page YOffset | | document . document Element . scroll Top , window Width = window . inner Width , window Height = window . inner Height , iframe Rect = mce Iframe ? mce Iframe . get Bounding Client Rect ( ) : { top : 0 , right : window Width , bottom : window Height , left : 0 , width : window Width , height : window Height , } , toolbar = this . get El ( ) , toolbar Width = toolbar . offset Width , toolbar Height = toolbar . offset Height , selection = current Selection . get Bounding Client Rect ( ) , selection Middle = ( selection . left + selection . right ) / 2 , buffer = 5 , margin = 8 , space Needed = toolbar Height + margin + buffer , wp Adminbar Bottom = wp Adminbar ? wp Adminbar . get Bounding Client Rect ( ) . bottom : 0 , mce Toolbar Bottom = mce Toolbar ? mce Toolbar . get Bounding Client Rect ( ) . bottom : 0 , mce Statusbar Top = mce Statusbar ? window Height - mce Statusbar . get Bounding Client Rect ( ) . top : 0 , wp Statusbar Top = wp Statusbar ? window Height - wp Statusbar . get Bounding Client Rect ( ) . top : 0 , blocked Top = Math . max ( 0 , wp Adminbar Bottom , mce Toolbar Bottom , iframe Rect . top ) , blocked Bottom = Math . max ( 0 , mce Statusbar Top , wp Statusbar Top , window Height - iframe Rect . bottom ) , space Top = selection . top + iframe Rect . top - blocked Top , space Bottom = window Height - iframe Rect . top - selection . bottom - blocked Bottom , editor Height = window Height - blocked Top - blocked Bottom , class Name = ' ' , top , left ; if ( space Top > = editor Height | | space Bottom > = editor Height ) { return this . hide ( ) ; } if ( this . bottom ) { if ( space Bottom > = space Needed ) { class Name = ' mce -arrow -up ' ; top = selection . bottom + iframe Rect . top + scroll Y ; } else if ( space Top > = space Needed ) { class Name = ' mce -arrow -down ' ; top = selection . top + iframe Rect . top + scroll Y - toolbar Height - margin ; } } else { if ( space Top > = space Needed ) { class Name = ' mce -arrow -down ' ; top = selection . top + iframe Rect . top + scroll Y - toolbar Height - margin ; } else if ( space Bottom > = space Needed & & editor Height / 2 > selection . bottom + iframe Rect . top - blocked Top ) { class Name = ' mce -arrow -up ' ; top = selection . bottom + iframe Rect . top + scroll Y ; } } if ( typeof top = = = 'undefined ' ) { top = scroll Y + blocked Top + buffer ; } left = selection Middle - toolbar Width / 2 + iframe Rect . left + scroll X ; if ( selection . left < 0 | | selection . right > iframe Rect . width ) { left = iframe Rect . left + scroll X + ( iframe Rect . width - toolbar Width ) / 2 ; } else if ( toolbar Width > = window Width ) { class Name + = ' mce -arrow -full ' ; left = 0 ; } else if ( ( left < 0 & & selection . left + toolbar Width > window Width ) | | ( left + toolbar Width > window Width & & selection . right - toolbar Width < 0 ) ) { left = ( window Width - toolbar Width ) / 2 ; } else if ( left < iframe Rect . left + scroll X ) { class Name + = ' mce -arrow -left ' ; left = selection . left + iframe Rect . left + scroll X ; } else if ( left + toolbar Width > iframe Rect . width + iframe Rect . left + scroll X ) { class Name + = ' mce -arrow -right ' ; left = selection . right - toolbar Width + iframe Rect . left + scroll X ; } toolbar . class Name = toolbar . class Name . replace ( / ?mce -arrow - [ \w ] + / g , ' ' ) + class Name ; DOM . set Styles ( toolbar , { left : left , top : top , } ) ; return this ; } toolbar . on ( 'show ' , function ( ) { this . reposition ( ) ; if ( is Chrome Rtl ) { editor . $ ( ' .mce -widget .mce -tooltip ' , document . body ) . add Class ( 'wp -hide -mce -tooltip ' ) ; } } ) ; toolbar . on ( 'keydown ' , function ( event ) { if ( event . key Code = = = 2 7 ) { this . hide ( ) ; editor . focus ( ) ; } } ) ; editor . on ( 'remove ' , function ( ) { toolbar . remove ( ) ; } ) ; toolbar . reposition = reposition ; toolbar . hide ( ) . render To ( document . body ) ; return toolbar ; } editor . shortcuts . add ( 'alt + 1 1 9 ' , ' ' , function ( ) { var node ; if ( active Toolbar ) { node = active Toolbar . find ( 'toolbar ' ) [ 0 ] ; node & & node . focus ( true ) ; } } ) ; editor . on ( 'nodechange ' , function ( event ) { var collapsed = editor . selection . is Collapsed ( ) ; var args = { element : event . element , parents : event . parents , collapsed : collapsed , } ; editor . fire ( 'wptoolbar ' , args ) ; current Selection = args . selection | | args . element ; if ( active Toolbar ) { active Toolbar . hide ( ) ; } if ( args . toolbar ) { active Toolbar = args . toolbar ; active Toolbar . show ( ) ; } else { active Toolbar = false ; } } ) ; editor . on ( 'focus ' , function ( ) { if ( active Toolbar ) { active Toolbar . show ( ) ; } } ) ; function hide ( event ) { if ( active Toolbar ) { active Toolbar . hide ( ) ; if ( event . type = = = 'hide ' | | event . type = = = 'blur ' ) { active Toolbar = false ; } else if ( event . type = = = 'resizewindow ' | | event . type = = = 'scrollwindow ' ) { clear Timeout ( timeout ) ; timeout = set Timeout ( function ( ) { if ( active Toolbar & & typeof active Toolbar . show = = = 'function ' ) { active Toolbar . show ( ) ; } } , 2 5 0 ) ; } } } DOM . bind ( window , 'resize scroll ' , hide ) ; editor . on ( 'remove ' , function ( ) { DOM . unbind ( window , 'resize scroll ' , hide ) ; } ) ; editor . on ( 'blur hide ' , hide ) ; editor . wp = editor . wp | | { } ; editor . wp . _create Toolbar = create ; } , true ) ; } 
function Follow List Site ( args ) { if ( ! ( this instanceof Follow List Site ) ) { return new Follow List Site ( args ) ; } this . site _id = args . site _id ; this . is _following = args . is _following ; this . blog _domain = args . blog _domain ; } 
function set RTLFlag On CSSLink ( url , is RTL ) { if ( is RTL ) { return url . ends With ( ' .rtl .css ' ) ? url : url . replace ( / \ .css $ / , ' .rtl .css ' ) ; } return ! url . ends With ( ' .rtl .css ' ) ? url : url . replace ( / \ .rtl .css $ / , ' .css ' ) ; } 
function load CSS ( css Url , current Link ) { return new Promise ( resolve = > { const link = document . create Element ( 'link ' ) ; link . rel = 'stylesheet ' ; link . type = 'text /css ' ; link . href = css Url ; if ( 'onload ' in link ) { link . onload = ( ) = > { link . onload = null ; resolve ( link ) ; } ; } else { 
function overwrite Existing Purchases ( existing Purchases , new Purchases ) { let purchases = new Purchases ; existing Purchases . for Each ( purchase = > { if ( ! find ( purchases , { ID : purchase . ID } ) ) { purchases = purchases . concat ( purchase ) ; } } ) ; return purchases ; } 
function remove Missing Purchases By Predicate ( existing Purchases , new Purchases , predicate ) { return existing Purchases . filter ( purchase = > { if ( matches ( predicate ) ( purchase ) & & find ( new Purchases , { ID : purchase . ID } ) ) { 
function insert Dependent Key ( map , key , current Index , arr ) { const weak Map Key = key | | STATIC _FALSY _KEY ; const existing Map = map . get ( weak Map Key ) ; if ( existing Map ) { return existing Map ; } const new Map = current Index = = = arr . length - 1 ? new Map ( ) : new Weak Map ( ) ; map . set ( weak Map Key , new Map ) ; return new Map ; } 
function ( fetch Options ) { const namespace = get Namespace ( fetch Options ) ; debug ( 'get Pagination Data : ' , namespace ) ; return { fetch Initialized : _followers Fetched By Namespace . has Own Property ( namespace ) , total Followers : _total Followers By Namespace [ namespace ] | | 0 , fetching Followers : _fetching Followers By Namespace [ namespace ] | | false , followers Current Page : _page By Namespace [ namespace ] , num Followers Fetched : _followers Fetched By Namespace [ namespace ] , fetch Name Space : namespace , } ; } 
function sort Products ( products ) { let plan Items , included Items , domain Items , credit Items , other Items ; plan Items = products . filter ( is Plan ) ; included Items = products . filter ( is Included With Plan ) ; domain Items = difference ( products , included Items ) ; domain Items = domain Items . filter ( is Domain Product ) ; domain Items = to Pairs ( group By ( domain Items , 'meta ' ) ) ; domain Items = sort By ( domain Items , function ( pair ) { if ( pair [ 1 ] [ 0 ] & & pair [ 1 ] [ 0 ] . cost = = = 0 ) { return - 1 ; } return pair [ 0 ] ; } ) ; domain Items = domain Items . map ( function ( pair ) { return sort By ( pair [ 1 ] , get Domain Product Ranking ) ; } ) ; domain Items = flatten ( domain Items ) ; credit Items = products . filter ( is Credits ) ; other Items = difference ( products , plan Items , domain Items , included Items , credit Items ) ; return plan Items . concat ( included Items ) . concat ( domain Items ) . concat ( other Items ) . concat ( credit Items ) ; } 
function proxy OAuth ( request , response ) { 
function Undocumented Site ( id , wpcom ) { debug ( 'Undocumented Site ' , id ) ; if ( ! ( this instanceof Undocumented Site ) ) { return new Undocumented Site ( id , wpcom ) ; } this . wpcom = wpcom ; this . _id = id ; } 
function add Or Edit Product ( list = [ ] , new Product ) { let found = 0 ; const products = list . map ( product = > { if ( product . ID = = = new Product . ID ) { found = 1 ; return new Product ; } return product ; } ) ; if ( ! found ) { return [ new Product , . . . products ] ; } return products ; } 
function create Navigation ( context ) { const site Fragment = get Site Fragment ( context . pathname ) ; let base Path = context . pathname ; if ( site Fragment ) { base Path = sectionify ( context . pathname ) ; } return ( < Navigation Component path = { context . path } all Sites Path = { base Path } site Base Path = { base Path } / > ) ; } 
function create Sites Component ( context ) { const context Path = sectionify ( context . path ) ; 
function update State ( state , domain Name , data ) { const command = { [ domain Name ] : { $set : Object . assign ( { } , state [ domain Name ] | | initial Domain State , data ) , } , } ; return update ( state , command ) ; } 
function ( site Id ) { return { total Viewers : _total Viewers [ site Id ] | | 0 , fetching Viewers : _fetching Viewers [ site Id ] , current Viewers Page : _viewers Current Page [ site Id ] , num Viewers Fetched : _num Viewers Fetched [ site Id ] , } ; } 
function update Receipt State ( state , receipt Id , attributes ) { return Object . assign ( { } , state , { [ receipt Id ] : Object . assign ( { } , initial Receipt State , state [ receipt Id ] , attributes ) , } ) ; } 
function is Tracking Pixel ( image ) { if ( ! image | | ! image . src ) { return false ; } const edge Length = image . height + image . width ; return edge Length = = = 1 | | edge Length = = = 2 ; } 
function is Candidate For Content Image ( image ) { if ( ! image | | ! image . get Attribute ( 'src ' ) ) { return false ; } const ineligible Candidate Url Parts = [ 'gravatar .com ' , ' /wpcom -smileys / ' ] ; const image Url = image . get Attribute ( 'src ' ) ; const image Should Be Excluded From Candidacy = some ( ineligible Candidate Url Parts , url Part = > includes ( image Url . to Lower Case ( ) , url Part ) ) ; return ! ( is Tracking Pixel ( image ) | | image Should Be Excluded From Candidacy ) ; } 
function get Product Category Label ( state , category Id , site Id = get Selected Site Id ( state ) ) { const category State = get Raw Category State ( state , site Id ) ; const categories = category State . items | | { } ; const category = categories [ category Id ] ; if ( ! category ) { return ' ' ; } if ( ! Number ( category . parent ) ) { return category . name ; } return get Product Category Label ( state , category . parent , site Id ) + ` $ { category . name } ` ; } 
function get Enhanced Context ( req , res ) { return Object . assign ( { } , req . context , { is Server Side : true , original Url : req . original Url , path : req . url , pathname : req . path , params : req . params , query : req . query , redirect : res . redirect . bind ( res ) , res , } ) ; } 
function ready ( ) { const notes = get All Notes ( store . get State ( ) ) ; const timestamps = notes . map ( property ( 'timestamp ' ) ) . map ( timestamp = > Date . parse ( timestamp ) / 1 0 0 0 ) ; let new Note Count = timestamps . filter ( time = > time > this . last Seen Time ) . length ; if ( ! this . first Render & & this . last Seen Time = = = 0 ) { new Note Count = 0 ; } const latest Type = get ( notes . slice ( - 1 ) [ 0 ] , 'type ' , null ) ; store . dispatch ( { type : 'APP _RENDER _NOTES ' , new Note Count , latest Type } ) ; this . has New Note Data = false ; this . first Render = false ; } 
function update Last Seen Time ( proposed Time , from Storage ) { let from Note = false ; let most Recent Note Time = 0 ; 
function cast Product IDs To Numbers ( cart Items ) { return cart Items . map ( function ( item ) { return assign ( { } , item , { product _id : parse Int ( item . product _id , 1 0 ) } ) ; } ) ; } 
function update Viewport ( ) { const viewport = { } ; viewport . top = window . scroll Y ; viewport . left = window . scroll X ; viewport . width = window . inner Width ; viewport . height = window . inner Height ; viewport . right = viewport . left + viewport . width ; viewport . bottom = viewport . top + viewport . height ; debug ( 'viewport : %o ' , viewport ) ; return viewport ; } 
function _offset ( box , doc ) { const body = doc . body | | doc . get Elements By Tag Name ( 'body ' ) [ 0 ] ; const doc El = doc . document Element | | body . parent Node ; const client Top = doc El . client Top | | body . client Top | | 0 ; const client Left = doc El . client Left | | body . client Left | | 0 ; const scroll Top = window . page YOffset | | doc El . scroll Top ; const scroll Left = window . page XOffset | | doc El . scroll Left ; return { top : box . top + scroll Top - client Top , left : box . left + scroll Left - client Left , } ; } 
function ( off , el ) { const ew = get Bounding Client Rect ( el ) . width ; off . left = Math . max ( 0 , Math . min ( off . left , viewport . width - ew ) ) ; return off ; } 
function accessible Focus ( ) { document . add Event Listener ( 'keydown ' , function ( event ) { if ( keyboard Navigation ) { return ; } if ( keyboard Navigation Keycodes . index Of ( event . key Code ) ! = = - 1 ) { keyboard Navigation = true ; document . document Element . class List . add ( 'accessible -focus ' ) ; } } ) ; document . add Event Listener ( 'mouseup ' , function ( ) { if ( ! keyboard Navigation ) { return ; } keyboard Navigation = false ; document . document Element . class List . remove ( 'accessible -focus ' ) ; } ) ; } 
function filter Notices By ( site , plugin Slug , log ) { if ( ! site & & ! plugin Slug ) { return true ; } if ( is Same Site Notice ( site , log ) & & is Same Plugin Notice ( plugin Slug , log ) ) { return true ; } else if ( ! plugin Slug & & is Same Site Notice ( site , log ) ) { return true ; } else if ( ! site & & is Same Plugin Notice ( plugin Slug , log ) ) { return true ; } return false ; } 
function is In Viewport Range ( element Start , element End ) { let viewport Start = window . scroll Y , viewport End = document . document Element . client Height + window . scroll Y ; return element Start > viewport Start & & element End < viewport End ; } 
function scroll Into Viewport ( element ) { const element Start Y = recursively Walk And Sum ( element , 'offset Top ' , 'offset Parent ' ) , element End Y = element Start Y + element . offset Height ; if ( is In Viewport Range ( element Start Y , element End Y ) ) { return ; } try { window . scroll ( { top : element Start Y , left : 0 , behavior : 'smooth ' , } ) ; } catch ( e ) { window . scroll To ( 0 , element Start Y ) ; } } 
function setup ( ) { var build = null , errors = ' ' , rootdir = path . resolve ( _ _dirname , ' . . ' , ' . . ' ) ; function spawn Make ( ) { debug ( 'spawning %o ' , 'npm run build -css ' ) ; build = spawn ( 'npm ' , [ 'run ' , 'build -css ' ] , { shell : true , cwd : rootdir , stdio : [ 'ignore ' , 'pipe ' , 'pipe ' ] , } ) ; errors = ' ' ; build . once ( 'exit ' , onexit ) ; build . stdout . set Encoding ( 'utf 8 ' ) ; build . stdout . on ( 'data ' , onstdout ) ; build . stderr . on ( 'data ' , onstderr ) ; } function onstdout ( d ) { debug ( 'stdout %o ' , d . trim ( ) ) ; } function onexit ( ) { build . stderr . remove Listener ( 'data ' , onstderr ) ; build . stdout . remove Listener ( 'data ' , onstdout ) ; build = null ; } function onstderr ( stderr ) { process . stderr . write ( stderr . to String ( 'utf 8 ' ) ) ; errors + = stderr . to String ( 'utf 8 ' ) ; } return function ( req , res , next ) { if ( ! build ) { spawn Make ( ) ; } build . once ( 'exit ' , function ( code ) { if ( 0 = = = code ) { 
function parse Caption ( node , _parsed ) { 
function apply Metadata Edit ( metadata , edit ) { switch ( edit . operation ) { case 'update ' : { 
function Keyboard Shortcuts ( key Bindings ) { if ( ! ( this instanceof Keyboard Shortcuts ) ) { return new Keyboard Shortcuts ( key Bindings ) ; } 
function ( ) { return flatten ( compact ( map ( this . _flow . steps , function ( step ) { return steps [ step ] . provides Dependencies ; } ) ) ) . concat ( this . _flow . provides Dependencies In Query ) ; } 
function is Pending Sync Start ( state , site Id ) { const sync Status = get Sync Status ( state , site Id ) ; const full Sync Request = get Full Sync Request ( state , site Id ) ; 
function is Full Syncing ( state , site Id ) { const sync Status = get Sync Status ( state , site Id ) ; if ( ! sync Status ) { return false ; } const is Started = get ( sync Status , 'started ' ) ; const is Finished = get ( sync Status , 'finished ' ) ; return is Started & & ! is Finished ; } 
function get Sync Progress Percentage ( state , site Id ) { const sync Status = get Sync Status ( state , site Id ) , queued = get ( sync Status , 'queue ' ) , sent = get ( sync Status , 'sent ' ) , total = get ( sync Status , 'total ' ) , queued Multiplier = 0 . 1 , sent Multiplier = 0 . 9 ; if ( is Pending Sync Start ( state , site Id ) | | ! queued | | ! sent | | ! total ) { return 0 ; } const count Queued = reduce ( queued , ( sum , value ) = > { return ( sum + = value ) ; } , 0 ) ; const count Sent = reduce ( sent , ( sum , value ) = > { return ( sum + = value ) ; } , 0 ) ; const count Total = reduce ( total , ( sum , value ) = > { return ( sum + = value ) ; } , 0 ) ; const percent Queued = ( count Queued / count Total ) * queued Multiplier * 1 0 0 ; const percent Sent = ( count Sent / count Total ) * sent Multiplier * 1 0 0 ; return Math . ceil ( percent Queued + percent Sent ) ; } 
function ( page Url , event Type , duration ) { 
function merge Domain Registrant Contact Details ( domain State , registrant Contact Details ) { return is Array ( domain State . data ) ? domain State . data . map ( item = > { if ( item . type = = = whois Type . REGISTRANT ) { return { . . . item , . . . registrant Contact Details , } ; } return item ; } ) : [ { . . . registrant Contact Details , type : whois Type . REGISTRANT , } , ] ; } 
function maybe Refresh Country Code Cookie Gdpr ( callback ) { const cookie Max Age Seconds = 6 * 6 0 * 6 0 ; const cookies = cookie . parse ( document . cookie ) ; if ( ! cookies . country _code ) { 
function setup Quora Global ( ) { if ( window . qp ) { return ; } const quora Pixel = ( window . qp = function ( ) { quora Pixel . qp ? quora Pixel . qp . apply ( quora Pixel , arguments ) : quora Pixel . queue . push ( arguments ) ; } ) ; quora Pixel . queue = [ ] ; } 
function setup Facebook Global ( ) { if ( window . fbq ) { return ; } const facebook Events = ( window . fbq = function ( ) { if ( facebook Events . call Method ) { facebook Events . call Method . apply ( facebook Events , arguments ) ; } else { facebook Events . queue . push ( arguments ) ; } } ) ; if ( ! window . _fbq ) { window . _fbq = facebook Events ; } window . _fbq . disable Push State = true ; facebook Events . push = facebook Events ; facebook Events . loaded = true ; facebook Events . version = ' 2 . 0 ' ; facebook Events . queue = [ ] ; } 
function setup Twitter Global ( ) { if ( window . twq ) { return ; } const twq = ( window . twq = function ( ) { twq . exe ? twq . exe . apply ( twq , arguments ) : twq . queue . push ( arguments ) ; } ) ; twq . version = ' 1 . 1 ' ; twq . queue = [ ] ; } 
function setup Nanigans Global ( ) { const normalized Hashed Email = get Normalized Hashed User Email ( user ) ; window . Na N _api = [ [ TRACKING _IDS . nanigans App Id , normalized Hashed Email ? normalized Hashed Email : ' ' ] , ] ; is Nanigans Configured = true ; debug ( 'Nanigans setup : ' , window . Na N _api ) ; } 
function record Product ( product , order Id ) { if ( ! is Ad Tracking Allowed ( ) ) { debug ( 'record Product : [Skipping ] ad tracking is not allowed ' ) ; return ; } if ( TRACKING _STATE _VALUES . LOADED ! = = tracking State ) { load Tracking Scripts ( record Product . bind ( null , product , order Id ) ) ; return ; } const is Jetpack Plan = products Values . is Jetpack Plan ( product ) ; if ( is Jetpack Plan ) { debug ( 'Recording Jetpack purchase ' , product ) ; } else { debug ( 'Recording purchase ' , product ) ; } const current User = user . get ( ) ; const user Id = current User ? hash Pii ( current User . ID ) : 0 ; try { 
function record Order In Quantcast ( cart , order Id , wpcom Jetpack Cart Info ) { if ( ! is Ad Tracking Allowed ( ) | | ! is Quantcast Enabled ) { return ; } if ( wpcom Jetpack Cart Info . contains Wpcom Products ) { if ( null ! = = wpcom Jetpack Cart Info . wpcom Cost USD ) { 
function record Order In Floodlight ( cart , order Id , wpcom Jetpack Cart Info ) { if ( ! is Ad Tracking Allowed ( ) | | ! is Floodlight Enabled ) { return ; } debug ( 'record Order In Floodlight : record purchase ' ) ; debug ( 'record Order In Floodlight : ' ) ; record Params In Floodlight Gtag ( { value : cart . total _cost , transaction _id : order Id , u 1 : cart . total _cost , u 2 : cart . products . map ( product = > product . product _name ) . join ( ' , ' ) , u 3 : cart . currency , send _to : 'DC - 6 3 5 5 5 5 6 /wpsal 0 /wpsale +transactions ' , } ) ; 
function record Order In Nanigans ( cart , order Id ) { if ( ! is Ad Tracking Allowed ( ) | | ! is Nanigans Enabled ) { return ; } const paid Products = cart . products . filter ( product = > product . cost > = 0 . 0 1 ) ; if ( paid Products . length = = = 0 ) { debug ( 'record Order In Nanigans : Skip cart because it has ONLY < 0 . 0 1 products ' ) ; return ; } debug ( 'record Order In Nanigans : Record purchase ' ) ; const product Prices = paid Products . map ( product = > product . cost * 1 0 0 ) ; 
function record Order In Facebook ( cart , order Id , wpcom Jetpack Cart Info ) { if ( ! is Ad Tracking Allowed ( ) | | ! is Facebook Enabled ) { return ; } if ( cart . total _cost < 0 . 0 1 ) { debug ( 'record Order In Facebook : skipping due to a 0 -value cart . ' ) ; return ; } const current User = user . get ( ) ; const user Id = current User ? hash Pii ( current User . ID ) : 0 ; 
function record Order In Bing ( cart , order Id , wpcom Jetpack Cart Info ) { 
function floodlight Session Id ( ) { const cookies = cookie . parse ( document . cookie ) ; const existing Session Id = cookies [ DCM _FLOODLIGHT _SESSION _COOKIE _NAME ] ; if ( existing Session Id ) { debug ( 'Floodlight : Existing session : ' + existing Session Id ) ; return existing Session Id ; } 
function floodlight User Params ( ) { const params = { } ; const current User = user . get ( ) ; if ( current User ) { params . u 4 = hash Pii ( current User . ID ) ; } const anonymous User Id = tracks Anonymous User Id ( ) ; if ( anonymous User Id ) { params . u 5 = anonymous User Id ; } return params ; } 
function record Params In Floodlight Gtag ( params ) { if ( ! is Ad Tracking Allowed ( ) | | ! is Floodlight Enabled ) { return ; } 
function record Order In Criteo ( cart , order Id ) { if ( ! is Ad Tracking Allowed ( ) | | ! is Criteo Enabled ) { return ; } const params = [ 'track Transaction ' , { id : order Id , currency : cart . currency , item : cart To Criteo Items ( cart ) , } , ] ; debug ( 'record Order In Criteo : ' , params ) ; record In Criteo ( . . . params ) ; } 
function record View Checkout In Criteo ( cart ) { if ( ! is Ad Tracking Allowed ( ) | | ! is Criteo Enabled ) { return ; } if ( cart . is _signup ) { return ; } 
function cart To Criteo Items ( cart ) { return cart . products . map ( product = > { return { id : product . product _id , price : product . cost , quantity : product . volume , } ; } ) ; } 
function record In Criteo ( event Name , event Props ) { if ( ! is Ad Tracking Allowed ( ) | | ! is Criteo Enabled ) { debug ( 'record In Criteo : [Skipping ] ad tracking is not allowed ' ) ; return ; } if ( TRACKING _STATE _VALUES . LOADED ! = = tracking State ) { load Tracking Scripts ( record In Criteo . bind ( null , event Name , event Props ) ) ; return ; } const events = [ ] ; events . push ( { event : 'set Account ' , account : TRACKING _IDS . criteo } ) ; events . push ( { event : 'set Site Type ' , type : criteo Site Type ( ) } ) ; const normalized Hashed Email = get Normalized Hashed User Email ( user ) ; if ( normalized Hashed Email ) { events . push ( { event : 'set Email ' , email : [ normalized Hashed Email ] } ) ; } const conversion Event = clone ( event Props ) ; conversion Event . event = event Name ; events . push ( conversion Event ) ; 
function record Order In Google Analytics ( cart , order Id ) { if ( ! is Ad Tracking Allowed ( ) ) { debug ( 'record Order In Google Analytics : skipping as ad tracking is disallowed ' ) ; return ; } const transaction = { id : order Id , affiliation : 'Word Press .com ' , revenue : cart . total _cost , currency : cart . currency , } ; debug ( 'record Order In Google Analytics : ga ecommerce add transaction ' , transaction ) ; window . ga ( 'ecommerce :add Transaction ' , transaction ) ; } 
function record Order In Google Ads ( cart , order Id , wpcom Jetpack Cart Info ) { if ( ! is Ad Tracking Allowed ( ) ) { debug ( 'record Order In Google Ads : skipping as ad tracking is disallowed ' ) ; return ; } if ( is Jetpack Google Ads Gtag Enabled ) { if ( wpcom Jetpack Cart Info . contains Jetpack Products ) { const params = [ 'event ' , 'conversion ' , { send _to : TRACKING _IDS . jetpack Google Ads Gtag Purchase , value : wpcom Jetpack Cart Info . jetpack Cost , currency : cart . currency , transaction _id : order Id , } , ] ; debug ( 'record Order In Google Ads : Record Jetpack Purchase ' , params ) ; window . gtag ( . . . params ) ; } } if ( is Wpcom Google Ads Gtag Enabled ) { if ( wpcom Jetpack Cart Info . contains Wpcom Products ) { const params = [ 'event ' , 'conversion ' , { send _to : TRACKING _IDS . wpcom Google Ads Gtag Purchase , value : wpcom Jetpack Cart Info . wpcom Cost , currency : cart . currency , transaction _id : order Id , } , ] ; debug ( 'record Order In Google Ads : Record WPCom Purchase ' , params ) ; window . gtag ( . . . params ) ; } } } 
function init Facebook ( ) { if ( user . get ( ) ) { init Facebook Advanced Matching ( ) ; } else { window . fbq ( 'init ' , TRACKING _IDS . facebook Init ) ; window . fbq ( 'set ' , 'auto Config ' , false , TRACKING _IDS . facebook Jetpack Init ) ; window . fbq ( 'init ' , TRACKING _IDS . facebook Jetpack Init ) ; } } 
function init Facebook Advanced Matching ( ) { const normalized Hashed Email = get Normalized Hashed User Email ( user ) ; const advanced Matching = normalized Hashed Email ? { em : normalized Hashed Email } : { } ; debug ( 'init Facebook Advanced Matching : ' , advanced Matching ) ; window . fbq ( 'init ' , TRACKING _IDS . facebook Init , advanced Matching ) ; window . fbq ( 'set ' , 'auto Config ' , false , TRACKING _IDS . facebook Jetpack Init ) ; window . fbq ( 'init ' , TRACKING _IDS . facebook Jetpack Init , advanced Matching ) ; } 
function is Server Side Render Compatible ( context ) { return Boolean ( is Section Isomorphic ( context . store . get State ( ) ) & & ! context . user & & 
function set Tab Index On Editor Iframe ( tabindex ) { return function ( ) { 
function jsonp ( url , query , fn ) { let prefix = ' _ _jp ' , timeout = 6 0 0 0 0 , enc = encode URIComponent , target = document . get Elements By Tag Name ( 'script ' ) [ 0 ] | | document . head , script , timer , id ; 
function cleanup Replies Cache ( ) { const keys To Remove = [ ] ; try { for ( let i = 0 ; i < local Storage . length ; i + + ) { const stored Reply Key = local Storage . key ( i ) ; 
function parse Git Diff To Path Array ( command ) { return exec Sync ( command , { encoding : 'utf 8 ' } ) . split ( ' \n ' ) . map ( name = > name . trim ( ) ) . filter ( name = > / ( ? : \ .json | \ . [jt ]sx ? | \ .scss ) $ / . test ( name ) ) ; } 
function get Category For Plugins Browser ( context ) { if ( context . params . plugin & & includes ( allowed Category Names , context . params . plugin ) ) { return context . params . plugin ; } return context . params . category ; } 
function create Success ( site Id , { email } , { account _id } ) { return { type : WOOCOMMERCE _SETTINGS _STRIPE _CONNECT _ACCOUNT _CREATE _COMPLETE , connected User ID : account _id , email , site Id , } ; } 
function fetch Success ( site Id , fetch Action , data ) { const { account _id , display _name , email , business _logo , legal _entity , payouts _enabled } = data ; return { type : WOOCOMMERCE _SETTINGS _STRIPE _CONNECT _ACCOUNT _DETAILS _UPDATE , connected User ID : account _id , display Name : display _name , email , first Name : legal _entity . first _name , is Activated : payouts _enabled , logo : business _logo , last Name : legal _entity . last _name , site Id , } ; } 
function oauth Connect Failure ( site Id , action , { error , message } ) { return { type : WOOCOMMERCE _SETTINGS _STRIPE _CONNECT _ACCOUNT _OAUTH _CONNECT _COMPLETE , error : message | | error , site Id , } ; } 
function request Posts ( site Id , query = { } ) { return dispatch = > { dispatch ( { type : POSTS _REQUEST , site Id , query , } ) ; const source = site Id ? wpcom . site ( site Id ) : wpcom . me ( ) ; return source . posts List ( { . . . query } ) . then ( ( { found , posts } ) = > { dispatch ( receive Posts ( posts ) ) ; dispatch ( { type : POSTS _REQUEST _SUCCESS , site Id , query , found , posts , } ) ; } ) . catch ( error = > { dispatch ( { type : POSTS _REQUEST _FAILURE , site Id , query , error , } ) ; } ) ; } ; } 
function normalize Api Attributes ( attributes ) { attributes = clone ( attributes ) ; attributes = normalize Terms For Api ( attributes ) ; if ( attributes . author ) { attributes . author = attributes . author . ID ; } return attributes ; } 
function is Image Large Enough For Feature ( image ) { if ( ! image ) { return false ; } const image Is Tall Enough = 1 0 0 < = image . width ; const image Is Wide Enough = 7 5 < = image . height ; return image Is Tall Enough & & image Is Wide Enough ; } 
function wpview ( editor ) { let $ = editor . $ , selected , Env = tinymce . Env , VK = tinymce . util . VK , Tree Walker = tinymce . dom . Tree Walker , to Remove = false , first Focus = true , isios = / i Pad |i Pod |i Phone / . test ( navigator . user Agent ) , cursor Interval , last Key Down Node , set View Cursor Tries , focus , exec Command View , exec Command Before , toolbar ; function replace Markers ( ) { const markers = $ ( ' .wpview -marker ' ) ; if ( ! markers . length ) { return false ; } markers . each ( function ( index , node ) { let text = editor . dom . get Attrib ( node , 'data -wpview -text ' ) , type = editor . dom . get Attrib ( node , 'data -wpview -type ' ) ; editor . dom . replace ( editor . dom . create Fragment ( ' <div class = "wpview -wrap " data -wpview -text = " ' + text + ' " data -wpview -type = " ' + type + ' " > ' + ' <p class = "wpview -selection -before " > \u 0 0a 0 < /p > ' + ' <div class = "wpview -body " contenteditable = "false " > < /div > ' + ' <p class = "wpview -selection -after " > \u 0 0a 0 < /p > ' + ' < /div > ' ) , node ) ; } ) ; return true ; } function trigger Node Changed ( ) { editor . node Changed ( ) ; } function render Views ( ) { if ( ! replace Markers ( ) ) { return ; } const store = editor . get Param ( 'redux _store ' ) ; const site Id = get Selected Site Id ( store . get State ( ) ) ; $ ( ' .wpview -wrap ' ) . each ( function ( index , view ) { const $view = $ ( view ) ; if ( undefined ! = = $view . attr ( 'data -wpview -rendered ' ) ) { return ; } const type = $view . attr ( 'data -wpview -type ' ) ; render With Redux Store ( React . create Element ( views . components [ type ] , { content : get Text ( view ) , site Id , on Resize : debounce ( trigger Node Changed , 5 0 0 ) , } ) , $view . find ( ' .wpview -body ' ) [ 0 ] , store ) ; $view . attr ( 'data -wpview -rendered ' , ' ' ) ; } ) ; } function get Text ( node ) { return decode URIComponent ( $ ( node ) . attr ( 'data -wpview -text ' ) | | ' ' ) ; } function get View ( node ) { return get Parent ( node , 'wpview -wrap ' ) ; } function get Parent ( node , class Name ) { while ( node & & node . parent Node ) { if ( node . class Name & & ( ' ' + node . class Name + ' ' ) . index Of ( ' ' + class Name + ' ' ) ! = = - 1 ) { return node ; } node = node . parent Node ; } return false ; } function _stop ( event ) { event . stop Propagation ( ) ; } function set View Cursor ( before , view ) { let location = before ? 'before ' : 'after ' , offset = before ? 0 : 1 ; deselect ( ) ; editor . selection . set Cursor Location ( editor . dom . select ( ' .wpview -selection - ' + location , view ) [ 0 ] , offset ) ; editor . node Changed ( ) ; } function handle Enter ( view , before , key ) { let dom = editor . dom , pad Node = dom . create ( 'p ' ) ; if ( ! ( Env . ie & & Env . ie < 1 1 ) ) { pad Node . inner HTML = ' <br data -mce -bogus = " 1 " > ' ; } if ( before ) { view . parent Node . insert Before ( pad Node , view ) ; } else { dom . insert After ( pad Node , view ) ; } deselect ( ) ; if ( before & & key = = = VK . ENTER ) { set View Cursor ( before , view ) ; } else { editor . selection . set Cursor Location ( pad Node , 0 ) ; } editor . node Changed ( ) ; } function remove View ( view ) { editor . undo Manager . transact ( function ( ) { handle Enter ( view ) ; React Dom . unmount Component At Node ( $ ( view ) . find ( ' .wpview -body ' ) [ 0 ] ) ; editor . dom . remove ( view ) ; editor . focus ( ) ; } ) ; } function select ( view Node ) { let clipboard , dom = editor . dom ; if ( ! view Node ) { return ; } if ( view Node ! = = selected ) { * Deselect a selected view and remove clipboard * / function deselect ( ) { let clipboard , dom = editor . dom ; if ( selected ) { clipboard = editor . dom . select ( ' .wpview -clipboard ' , selected ) [ 0 ] ; dom . unbind ( clipboard ) ; dom . remove ( clipboard ) ; dom . unbind ( selected , 'beforedeactivate focusin focusout click mouseup ' , _stop ) ; dom . set Attrib ( selected , 'data -mce -selected ' , null ) ; } selected = null ; } function reset Views Callback ( match , view Text ) { return ' <p > ' + window . decode URIComponent ( view Text ) + ' < /p > ' ; } 
function replace Markers ( ) { const markers = $ ( ' .wpview -marker ' ) ; if ( ! markers . length ) { return false ; } markers . each ( function ( index , node ) { let text = editor . dom . get Attrib ( node , 'data -wpview -text ' ) , type = editor . dom . get Attrib ( node , 'data -wpview -type ' ) ; editor . dom . replace ( editor . dom . create Fragment ( ' <div class = "wpview -wrap " data -wpview -text = " ' + text + ' " data -wpview -type = " ' + type + ' " > ' + ' <p class = "wpview -selection -before " > \u 0 0a 0 < /p > ' + ' <div class = "wpview -body " contenteditable = "false " > < /div > ' + ' <p class = "wpview -selection -after " > \u 0 0a 0 < /p > ' + ' < /div > ' ) , node ) ; } ) ; return true ; } 
function get Parent ( node , class Name ) { while ( node & & node . parent Node ) { if ( node . class Name & & ( ' ' + node . class Name + ' ' ) . index Of ( ' ' + class Name + ' ' ) ! = = - 1 ) { return node ; } node = node . parent Node ; } return false ; } 
function deselect ( ) { let clipboard , dom = editor . dom ; if ( selected ) { clipboard = editor . dom . select ( ' .wpview -clipboard ' , selected ) [ 0 ] ; dom . unbind ( clipboard ) ; dom . remove ( clipboard ) ; dom . unbind ( selected , 'beforedeactivate focusin focusout click mouseup ' , _stop ) ; dom . set Attrib ( selected , 'data -mce -selected ' , null ) ; } selected = null ; } 
function is Special Key ( key ) { return ( ( key < = 4 7 & & key ! = = VK . SPACEBAR & & key ! = = VK . ENTER & & key ! = = VK . DELETE & & key ! = = VK . BACKSPACE & & ( key < 3 7 | | key > 4 0 ) ) | | key > = 2 2 4 | | 
function deep Remove Undefined Keys From Object ( obj ) { for ( let key in obj ) { if ( obj . has Own Property ( key ) ) { if ( _ . is Undefined ( obj [ key ] ) ) { delete obj [ key ] ; } else if ( _ . is Object ( obj [ key ] ) ) { deep Remove Undefined Keys From Object ( obj [ key ] ) ; } } } return obj ; } 
function process Lib Phone Number Metadata ( lib Phone Number Data ) { const data = { } ; for ( let country Code in lib Phone Number Data ) { if ( lib Phone Number Data . has Own Property ( country Code ) ) { const country Code Upper = country Code . to Upper Case ( ) ; const country = lib Phone Number Data [ country Code ] ; data [ country Code Upper ] = { iso Code : country Code Upper , dial Code : String ( country [ lib Phone Number Indexes . COUNTRY _DIAL _CODE ] + ( country [ lib Phone Number Indexes . REGION _AREA _CODE ] | | ' ' ) ) , country Dial Code : String ( country [ lib Phone Number Indexes . COUNTRY _DIAL _CODE ] ) , region Code : country [ lib Phone Number Indexes . REGION _AREA _CODE ] | | ' ' , area Codes : area Codes [ country Code ] , national Prefix : country [ lib Phone Number Indexes . NATIONAL _PREFIX ] , patterns : ( country [ lib Phone Number Indexes . NUMBER _FORMAT ] | | [ ] ) . map ( process Number Format ) , international Patterns : ( country [ lib Phone Number Indexes . INTERNATIONAL _NUMBER _FORMAT ] | | [ ] ) . map ( process Number Format ) , priority : priority Data [ country Code Upper ] , } ; } } const no Pattern = _ . filter ( data , _ . conforms ( { patterns : patterns = > patterns . length = = = 0 } ) ) ; _ . for In ( no Pattern , function ( country ) { country . pattern Region = ( _ . max By ( _ . values ( _ . filter ( data , { dial Code : country . dial Code } ) ) , 'priority ' ) | | { } ) . iso Code ; console . log ( 'Info : ' + country . iso Code + " didn 't have a pattern " + ( country . pattern Region ? ' so we use ' + country . pattern Region : ' . ' ) ) ; } ) ; return data ; } 
function inject Hard Coded Values ( lib Phone Number Data ) { return Object . assign ( { } , { KV : { iso Code : 'KV ' , dial Code : ' 3 8 3 ' , national Prefix : ' 0 ' , priority : priority Data . KV , } , UM : { iso Code : 'UM ' , dial Code : ' 1 ' , national Prefix : ' ' , pattern Region : 'US ' , priority : priority Data . UM , } , BV : { iso Code : 'BV ' , dial Code : ' 4 7 ' , national Prefix : ' ' , priority : priority Data . BV , } , TF : { iso Code : 'TF ' , dial Code : ' 2 6 2 ' , national Prefix : ' 0 ' , priority : priority Data . TF , } , HM : { iso Code : 'HM ' , dial Code : ' 6 1 ' , national Prefix : ' 0 ' , priority : priority Data . HM , } , PN : { iso Code : 'PN ' , dial Code : ' 6 4 ' , national Prefix : ' 0 ' , priority : priority Data . PN , } , GS : { iso Code : 'GS ' , national Prefix : ' ' , dial Code : ' 5 0 0 ' , priority : priority Data . GS , } , } , lib Phone Number Data ) ; } 
function insert Country Aliases ( data ) { Object . keys ( aliases ) . for Each ( source = > { data [ source ] = data [ aliases [ source ] ] ; } ) ; return data ; } 
function save To File ( data ) { const script Str = ' / * * @format * / \n ' + ' / / Generated by build -metadata .js \n ' + ' / * eslint -disable * / \n ' + Object . keys ( data ) . map ( key = > ` $ { key } $ { JSON . stringify ( data [ key ] , null , ' \t ' ) } \n ` ) . join ( ' \n ' ) + ' / * eslint -enable * / \n ' ; const file Path = path . resolve ( _ _dirname , ' . . ' , 'client ' , 'components ' , 'phone -input ' , 'data .js ' ) ; fs . write File Sync ( file Path , script Str ) ; } 
function get Webpack Config ( env = { } , 
function WPCOMUndocumented ( token , req Handler ) { if ( ! ( this instanceof WPCOMUndocumented ) ) { return new WPCOMUndocumented ( token , req Handler ) ; } if ( 'function ' = = = typeof token ) { req Handler = token ; token = null ; } else if ( token ) { this . load Token ( token ) ; } wpcom Factory . call ( this , token , function ( params , fn ) { if ( this . is Token Loaded ( ) ) { 
function download And Print ( order Id , site Id , dispatch , get State , labels ) { 
function Account Password Data ( ) { this . validated Password = null ; this . charsets = { lower Chars : 'abcdefghjkmnpqrstuvwxyz ' . split ( ' ' ) , upper Chars : 'ABCDEFGHJKMNPQRSTUVWXYZ ' . split ( ' ' ) , digit Chars : ' 2 3 4 5 6 7 8 9 ' . split ( ' ' ) , special Chars : ' ! @ # $ % ^ & * ' . split ( ' ' ) , } ; this . letter Charsets = pick ( this . charsets , [ 'lower Chars ' , 'upper Chars ' ] ) ; } 
function transfer Status ( site Id , transfer Id , status , message , theme Id ) { return { type : THEME _TRANSFER _STATUS _RECEIVE , site Id , transfer Id , status , message , theme Id , } ; } 
function transfer Initiate Failure ( site Id , error , plugin ) { const context = ! ! plugin ? 'plugin ' : 'theme ' ; return dispatch = > { const theme Initiate Failure Action = { type : THEME _TRANSFER _INITIATE _FAILURE , site Id , error , } ; dispatch ( with Analytics ( record Tracks Event ( 'calypso _automated _transfer _initiate _failure ' , { plugin , context } ) , theme Initiate Failure Action ) ) ; } ; } 
function suffix Theme Id For Install ( state , site Id , theme Id ) { 
function query Docs ( query ) { return docs Index . search ( query ) . map ( result = > { const doc = documents [ result . ref ] , snippet = make Snippet ( doc , query ) ; return { path : doc . path , title : doc . title , snippet : snippet , } ; } ) ; } 
function list Docs ( file Paths ) { return file Paths . map ( path = > { const doc = find ( documents , entry = > entry . path = = = path ) ; if ( doc ) { return { path : path , title : doc . title , snippet : default Snippet ( doc ) , } ; } return { path : path , title : 'Not found : ' + path , snippet : ' ' , } ; } ) ; } 
function make Snippet ( doc , query ) { 
function escape Regex String ( token ) { 
function reduce Components Usage Stats ( modules With Dependences ) { return Object . keys ( modules With Dependences ) . filter ( module Name = > module Name . index Of ( 'components / ' ) = = = 0 & & module Name . index Of ( ' /docs ' ) = = = - 1 ) . reduce ( ( target , module Name ) = > { const name = module Name . replace ( 'components / ' , ' ' ) ; target [ name ] = modules With Dependences [ module Name ] ; return target ; } , { } ) ; } 
function ( fetch Options ) { const namespace = get Namespace ( fetch Options ) ; debug ( 'get Pagination Data : ' , namespace ) ; return { fetch Initialized : _users Fetched By Namespace . has Own Property ( namespace ) , total Users : _total Users By Namespace [ namespace ] | | 0 , fetching Users : _fetching Users By Namespace [ namespace ] | | false , users Current Offset : _offset By Namespace [ namespace ] , num Users Fetched : _users Fetched By Namespace [ namespace ] , fetch Name Space : namespace , } ; } 
function ( fetch Options ) { let namespace = get Namespace ( fetch Options ) , site Id = fetch Options . site Id , users = [ ] ; debug ( 'get Users : ' , namespace ) ; if ( ! _users By Site [ site Id ] ) { _users By Site [ site Id ] = { } ; } if ( ! _user IDs By Namespace [ namespace ] ) { return users ; } _user IDs By Namespace [ namespace ] . for Each ( user Id = > { if ( _users By Site [ site Id ] [ user Id ] ) { users . push ( _users By Site [ site Id ] [ user Id ] ) ; } } ) ; return users ; } 
function get Tld ( domain Name ) { const last Index Of Dot = domain Name . last Index Of ( ' . ' ) ; if ( last Index Of Dot = = = - 1 ) { return ' ' ; } let tld = parse Domain Against Tld List ( domain Name , wpcom Multi Level Tlds ) ; if ( ! tld ) { tld = domain Name . substring ( last Index Of Dot + 1 ) ; } return tld ; } 
function get Domain Suggestion Search ( search , min Length = 2 ) { const cleaned Search = get Fixed Domain Search ( search ) ; 
function ( site ) { if ( ! site ) { return [ ] ; } if ( ! _plugins By Site [ site . ID ] & & ! _fetching [ site . ID ] ) { Plugins Actions . fetch Site Plugins ( site ) ; _fetching [ site . ID ] = true ; } if ( ! _plugins By Site [ site . ID ] ) { return _plugins By Site [ site . ID ] ; } return values ( _plugins By Site [ site . ID ] ) ; } 
function ( sites , plugin Slug ) { let plugin , plugins = this . get Plugins ( sites ) , plugin Sites ; if ( ! plugins ) { return ; } plugin = find ( plugins , _filters . is Equal . bind ( this , plugin Slug ) ) ; if ( ! plugin ) { return null ; } plugin Sites = plugin . sites . filter ( site = > site . visible ) . map ( site = > { 
function ( sites , plugin Slug ) { const installed On Sites = this . get Sites ( sites , plugin Slug ) | | [ ] ; return sites . filter ( function ( site ) { if ( ! site . visible ) { return false ; } if ( site . jetpack & & site . is Secondary Network Site ) { return false ; } return installed On Sites . every ( function ( installed On Site ) { return installed On Site . slug ! = = site . slug ; } ) ; } ) ; } 
function product Variation Updated ( state , action ) { const { data : product Variation , product Id } = action ; const product Variations = state . product Variations | | [ ] ; const index = find Index ( product Variations , { id : product Variation . id } ) ; const new Product Variation = { . . . product Variation , product Id } ; const new Product Variations = [ . . . product Variations ] ; if ( - 1 < index ) { new Product Variations [ index ] = new Product Variation ; } else { new Product Variations . push ( new Product Variation ) ; } const promotions = calculate Promotions ( state . coupons , state . products , new Product Variations ) ; return { . . . state , product Variations : new Product Variations , promotions } ; } 
function url Safe Base 6 4Decode String ( str ) { const decode Map = { ' - ' : ' + ' , _ : ' / ' , ' . ' : ' = ' , } ; return atob ( str . replace ( / [ - _ . ] / g , ch = > decode Map [ ch ] ) ) ; } 
function parse Amp Encoded Params ( value ) { value = value . split ( ' * ' ) . filter ( val = > val . length ) . slice ( 2 ) ; 
function cartesian ( . . . arrays ) { let i , j , l , m ; const o = [ ] ; if ( ! arrays | | arrays . length = = = 0 ) { return arrays ; } const array 1 = arrays . splice ( 0 , 1 ) [ 0 ] ; arrays = cartesian ( . . . arrays ) ; for ( i = 0 , l = array 1 . length ; i < l ; i + + ) { if ( arrays & & arrays . length ) { for ( j = 0 , m = arrays . length ; j < m ; j + + ) { o . push ( [ array 1 [ i ] ] . concat ( arrays [ j ] ) ) ; } } else { o . push ( [ array 1 [ i ] ] ) ; } } return o ; } 
function disable Toolbar Touch Events ( ) { editor . $ ( ' .mce -toolbar :not ( .mce -menubar ) ' , document . body ) . each ( ( i , toolbar ) = > { toolbar . add Event Listener ( 'touchstart ' , event = > { event . stop Immediate Propagation ( ) ; } ) ; } ) ; } 
function hide Toolbar Fade On Full Scroll ( ) { editor . $ ( [ editor . $ ( ' .mce -inline -toolbar -grp .mce -container -body ' , document . body ) , editor . $ ( ' .mce -toolbar -grp ' , editor . theme . panel . get El ( ) ) , ] ) . each ( ( i , toolbar ) = > { toolbar . on ( 'scroll ' , throttle ( ( { target } ) = > { let action ; if ( target . scroll Left = = = target . scroll Width - target . client Width ) { action = 'add ' ; } else if ( tinymce . DOM . has Class ( target , 'is -scrolled -full ' ) ) { action = 'remove ' ; } if ( action ) { const elements = editor . $ ( target ) ; if ( ! elements . has Class ( 'mce -container -body ' ) ) { elements . add ( tinymce . DOM . get Parent ( target , ' .mce -container -body ' ) ) ; } elements [ action + 'Class ' ] ( 'is -scrolled -full ' ) ; } } , 2 0 0 ) ) ; } ) ; } 
function toggle Toolbars Scrollable On Resize ( ) { function toggle Toolbars Scrollable Class ( ) { editor . $ ( ' .mce -toolbar -grp ' , editor . theme . panel . get El ( ) ) . each ( ( i , toolbar ) = > { const is Scrollable = toolbar . scroll Width > toolbar . client Width ; editor . $ ( toolbar ) . toggle Class ( 'is -scrollable ' , is Scrollable ) ; } ) ; } window . add Event Listener ( 'resize ' , throttle ( toggle Toolbars Scrollable Class , 2 0 0 ) ) ; toggle Toolbars Scrollable Class ( ) ; 
function warn ( ) { if ( ! I 1 8N . throw Errors ) { return ; } if ( 'undefined ' ! = = typeof window & & window . console & & window . console . warn ) { window . console . warn . apply ( window . console , arguments ) ; } } 
function get Jed Args ( jed Method , props ) { switch ( jed Method ) { case 'gettext ' : return [ props . original ] ; case 'ngettext ' : return [ props . original , props . plural , props . count ] ; case 'npgettext ' : return [ props . context , props . original , props . plural , props . count ] ; case 'pgettext ' : return [ props . context , props . original ] ; } return [ ] ; } 
function get Translation From Jed ( jed , options ) { let jed Method = 'gettext ' ; if ( options . context ) { jed Method = 'p ' + jed Method ; } if ( typeof options . original = = = 'string ' & & typeof options . plural = = = 'string ' ) { jed Method = 'n ' + jed Method ; } const jed Args = get Jed Args ( jed Method , options ) ; return jed [ jed Method ] . apply ( jed , jed Args ) ; } 
function connect Account Create ( state = { } ) { return Object . assign ( { } , state , { error : ' ' , is Creating : true , notify Completed : false , } ) ; } 
function connect Account Create Complete ( state = { } , action ) { return Object . assign ( { } , state , { connected User ID : action . connected User ID | | ' ' , display Name : ' ' , email : action . email | | ' ' , error : action . error | | ' ' , first Name : ' ' , is Activated : false , is Creating : false , is Requesting : false , last Name : ' ' , logo : ' ' , notify Completed : true , } ) ; } 
function connect Account Fetch ( state = { } ) { return Object . assign ( { } , state , { connected User ID : ' ' , display Name : ' ' , email : ' ' , error : ' ' , first Name : ' ' , is Activated : false , is Deauthorizing : false , is Requesting : true , last Name : ' ' , logo : ' ' , } ) ; } 
function connect Account Fetch Complete ( state = { } , action ) { return Object . assign ( { } , state , { connected User ID : action . connected User ID | | ' ' , display Name : action . display Name | | ' ' , email : action . email | | ' ' , error : action . error | | ' ' , first Name : action . first Name | | ' ' , is Activated : action . is Activated | | false , is Deauthorizing : false , is Requesting : false , last Name : action . last Name | | ' ' , logo : action . logo | | ' ' , } ) ; } 
function connect Account Deauthorize Complete ( state = { } , action ) { return Object . assign ( { } , state , { connected User ID : ' ' , display Name : ' ' , email : ' ' , error : action . error | | ' ' , first Name : ' ' , is Activated : false , is Deauthorizing : false , is Requesting : false , last Name : ' ' , logo : ' ' , } ) ; } 
function connect Account OAuth Init Complete ( state = { } , action ) { return Object . assign ( { } , state , { is OAuth Initializing : false , error : action . error | | ' ' , oauth Url : action . oauth Url | | ' ' , } ) ; } 
function connect Account OAuth Connect ( state = { } ) { return Object . assign ( { } , state , { error : ' ' , is OAuth Connecting : true , notify Completed : false , } ) ; } 
function apply Precision ( cost , precision ) { const exponent = Math . pow ( 1 0 , precision ) ; return Math . ceil ( cost * exponent ) / exponent ; } 
function can Domain Add GSuite ( domain Name ) { const GOOGLE _APPS _INVALID _SUFFIXES = [ ' .in ' , ' .wpcomstaging .com ' ] ; const GOOGLE _APPS _BANNED _PHRASES = [ 'google ' ] ; const includes Banned Phrase = some ( GOOGLE _APPS _BANNED _PHRASES , banned Phrase = > includes ( domain Name , banned Phrase ) ) ; const has Invalid Suffix = some ( GOOGLE _APPS _INVALID _SUFFIXES , invalid Suffix = > ends With ( domain Name , invalid Suffix ) ) ; return ! ( has Invalid Suffix | | includes Banned Phrase | | is GSuite Restricted ( ) ) ; } 
function format Price ( cost , currency Code , options = { } ) { if ( undefined ! = = options . precision ) { cost = apply Precision ( cost , options . precision ) ; } return format Currency ( cost , currency Code , cost % 1 > 0 ? { } : { precision : 0 } ) ; } 
function get Eligible GSuite Domain ( selected Domain Name , domains ) { if ( selected Domain Name & & can Domain Add GSuite ( selected Domain Name ) ) { return selected Domain Name ; } const [ eligible Domain ] = get GSuite Supported Domains ( domains ) ; return ( eligible Domain & & eligible Domain . name ) | | ' ' ; } 
function get GSuite Supported Domains ( domains ) { return domains . filter ( function ( domain ) { const wpcom Hosted = includes ( [ domain Types . REGISTERED ] , domain . type ) & & ( domain . has Wpcom Nameservers | | has GSuite ( domain ) ) ; const mapped = includes ( [ domain Types . MAPPED ] , domain . type ) ; const not Other Providor = domain . google Apps Subscription & & domain . google Apps Subscription . status ! = = 'other _provider ' ; return ( wpcom Hosted | | mapped ) & & can Domain Add GSuite ( domain . name ) & & not Other Providor ; } ) ; } 
function setup Reducer Persistence ( reducer ) { if ( reducer . has Custom Persistence ) { return reducer ; } if ( reducer . schema ) { return with Schema Validation ( reducer . schema , reducer ) ; } return without Persistence ( reducer ) ; } 
function serialize State ( reducers , state , action ) { if ( state = = = undefined ) { return undefined ; } return reduce ( reducers , ( result , reducer , reducer Key ) = > { const serialized = reducer ( state [ reducer Key ] , action ) ; if ( serialized ! = = undefined ) { if ( ! result ) { 
function stop Mutation Observer ( ) { if ( mutation Observer & & mutation Observer Active ) { active Placeholders = [ ] ; active Placeholder Ever Detected = false ; mutation Observer . disconnect ( ) ; mutation Observer Active = false ; } } 
function check Active Placeholders ( ) { const placeholders Count = active Placeholders . length ; debug ( ` $ { placeholders Count } ` ) ; if ( placeholders Count > 0 ) { active Placeholder Ever Detected = true ; } 
function should Request Recs ( state , stream Key , recs Stream Key ) { if ( ! recs Stream Key ) { return false ; } const total Subs = get Reader Follows ( state ) . length ; const items = get Reader Stream ( state , stream Key ) . items ; const recs Stream = get Reader Stream ( state , recs Stream Key ) ; const recs = recs Stream . items ; if ( recs Stream . last Page | | recs Stream . is Requesting ) { return false ; } if ( recs . length = = = 0 ) { return true ; } return recs . length < items . length * ( RECS _PER _BLOCK / get Distance Between Recs ( total Subs ) ) ; } 
function get Default Options ( ) { const ids = config ( 'directly _rtm _widget _ids ' ) ; const env = config ( 'directly _rtm _widget _environment ' ) ; return { id : ids [ env ] , display Ask Question : false , } ; } 
function configure Globals ( ) { 
function insert DOM ( ) { if ( null ! = = document . get Element By Id ( 'directly RTMScript ' ) ) { return ; } const d = document . create Element ( 'div ' ) ; d . id = 'directly RTMScript ' ; d . src = DIRECTLY _ASSETS _BASE _URL ; document . body . append Child ( d ) ; } 
function load Directly Script ( ) { return new Promise ( ( resolve , reject ) = > { load Script ( DIRECTLY _RTM _SCRIPT _URL , function ( error ) { if ( error ) { return reject ( new Error ( ` $ { error . src } ` ) ) ; } resolve ( ) ; } ) ; } ) ; } 
function wpemoji ( editor ) { let typing = false ; const env = tinymce . Env , ua = window . navigator . user Agent , is Win = ua . index Of ( 'Windows ' ) > - 1 , is Win 8 = ( function ( ) { const match = ua . match ( / Windows NT 6 \ . ( \d ) / ) ; if ( match & & match [ 1 ] > 1 ) { return true ; } return false ; } ) ( ) ; function set Img Attr ( image ) { image . class Name = 'emoji ' ; image . set Attribute ( 'data -mce -resize ' , 'false ' ) ; image . set Attribute ( 'data -mce -placeholder ' , ' 1 ' ) ; image . set Attribute ( 'data -wp -emoji ' , ' 1 ' ) ; } function replace Emoji ( node ) { twemoji . parse ( node , { base : config ( 'twemoji _cdn _url ' ) , size : ' 7 2x 7 2 ' , attributes : ( ) = > { return { 'data -mce -resize ' : 'false ' , 'data -mce -placeholder ' : ' 1 ' , 'data -wp -emoji ' : ' 1 ' , } ; } , callback : ( icon , options ) = > { const ignored = [ 'a 9 ' , 'ae ' , ' 2 1 2 2 ' , ' 2 1 9 4 ' , ' 2 6 6 0 ' , ' 2 6 6 3 ' , ' 2 6 6 5 ' , ' 2 6 6 6 ' ] ; if ( - 1 ! = = ignored . index Of ( icon ) ) { return false ; } return ' ' . concat ( options . base , options . size , ' / ' , icon , options . ext ) ; } , } ) ; } 
function parse Node ( node ) { let selection , bookmark ; if ( node & & twemoji . test ( node . text Content | | node . inner Text ) ) { if ( env . webkit ) { selection = editor . selection ; bookmark = selection . get Bookmark ( ) ; } replace Emoji ( node ) ; if ( env . webkit ) { selection . move To Bookmark ( bookmark ) ; } } } 
function get Initial Server State ( initial Reducer ) { if ( typeof window ! = = 'object ' | | ! window . initial Redux State | | is Support Session ( ) ) { return null ; } const server State = deserialize ( window . initial Redux State , initial Reducer ) ; return pick ( server State , Object . keys ( window . initial Redux State ) ) ; } 
function should Add Sympathy ( ) { 
function verify Stored Root State ( state ) { const current User Id = get ( user . get ( ) , 'ID ' , null ) ; const stored User Id = get ( state , [ 'current User ' , 'id ' ] , null ) ; if ( current User Id ! = = stored User Id ) { debug ( ` $ { current User Id } $ { stored User Id } ` ) ; return false ; } return true ; } 
function to Fixed Fix ( n , prec ) { const k = Math . pow ( 1 0 , prec ) ; return ' ' + ( Math . round ( n * k ) / k ) . to Fixed ( prec ) ; } 
function get Webpack Config ( env = { } , { entry = { common : path . join ( _ _dirname , 'src ' , 'common ' ) , 'calypso -iframe -bridge -server ' : path . join ( _ _dirname , 'src ' , 'calypso ' , 'iframe -bridge -server .js ' ) , 'calypso -tinymce ' : path . join ( _ _dirname , 'src ' , 'calypso ' , 'tinymce .js ' ) , } , 'output -path ' : output Path = path . join ( _ _dirname , 'dist ' ) , 'output -filename ' : output Filename = is Development ? ' [name ] .js ' : ' [name ] .min .js ' , } ) { const webpack Config = get Base Webpack Config ( env , { entry , 'output -filename ' : output Filename , 'output -path ' : output Path , } ) ; return { . . . webpack Config , devtool : is Development ? 'inline -cheap -source -map ' : false , } ; } 
function create Request Action ( options , action ) { const { fetch = noop , on Success = noop , on Error = noop , on Progress = noop , from Api = identity , } = options ; const error = get Error ( action ) ; if ( error ) { return on Error ( action , error ) ; } const data = get Data ( action ) ; if ( data ) { try { return on Success ( action , from Api ( data ) ) ; } catch ( err ) { return on Error ( action , err ) ; } } const progress = get Progress ( action ) ; if ( progress ) { return on Progress ( action , progress ) ; } return fetch ( action ) ; } 
function update Product Edits ( edits , product Id , do Update ) { const prev Edits = edits | | [ ] ; let found = false ; const new Edits = prev Edits . map ( product Edits = > { if ( is Equal ( product Id , product Edits . product Id ) ) { found = true ; return do Update ( product Edits ) ; } return product Edits ; } ) ; if ( ! found ) { new Edits . push ( do Update ( undefined ) ) ; } return new Edits ; } 
function does Not Need Sandbox ( iframe ) { const trusted Hosts = [ 'spotify .com ' , 'kickstarter .com ' , 'soundcloud .com ' , 'embed .ted .com ' , 'player .twitch .tv ' , ] ; const host Name = iframe . src & & url . parse ( iframe . src ) . hostname ; const iframe Host = host Name & & host Name . to Lower Case ( ) ; return some ( trusted Hosts , trusted Host = > ends With ( ' . ' + iframe Host , ' . ' + trusted Host ) ) ; } 
function get Eligible Email Forwarding Domain ( selected Domain Name , domains = [ ] ) { const eligible Domains = get Email Forwarding Supported Domains ( domains ) ; let selected Domain ; if ( selected Domain Name ) { selected Domain = eligible Domains . reduce ( function ( selected , domain ) { return domain . name = = = selected Domain Name ? domain . name : selected ; } , ' ' ) ; } return selected Domain | | ( eligible Domains . length & & eligible Domains [ 0 ] . name ) | | ' ' ; } 
function get Email Forwarding Supported Domains ( domains ) { return domains . filter ( function ( domain ) { const domain Has GSuite = has GSuite ( domain ) ; const wpcom Hosted = includes ( [ domain Types . REGISTERED ] , domain . type ) & & domain . has Wpcom Nameservers ; const mapped = includes ( [ domain Types . MAPPED ] , domain . type ) ; return ( wpcom Hosted | | mapped ) & & ! domain Has GSuite ; } ) ; } 
function setup ( ) { const app = express ( ) ; 
function get Externals ( ) { const externals = { } ; 
function submit Free Transaction ( partial Cart , on Complete ) { const cart = fill In All Cart Item Attributes ( partial Cart , products List . get ( ) ) , transaction = { payment : full Credits Payment , } ; submit Transaction ( { cart , transaction } , on Complete ) ; } 
function replace Search Url ( new Value , sort ) { let search Url = ' /read /search ' ; if ( new Value ) { search Url + = ' ? ' + stringify ( { q : new Value , sort } ) ; } page . replace ( search Url ) ; } 
function ( plugin Slug ) { const query = { fields : 'icons ,banners ,compatibility ,ratings , -contributors ' , locale : get Wporg Locale Code ( ) , } ; plugin Slug = plugin Slug . replace ( new Reg Exp ( ' .php $ ' ) , ' ' ) ; const base Url = 'https : / /api .wordpress .org /plugins /info / 1 . 0 / ' + plugin Slug + ' .jsonp ' ; return new Promise ( ( resolve , reject ) = > { jsonp ( base Url , query , function ( error , data ) { if ( error ) { debug ( 'error downloading plugin details from .org : %s ' , error ) ; reject ( error ) ; return ; } if ( ! data | | ! data . slug ) { debug ( 'unrecognized format fetching plugin details from .org : %s ' , data ) ; reject ( new Error ( 'Unrecognized response format ' ) ) ; return ; } resolve ( data ) ; } ) ; } ) ; } 
function ( theme Id ) { const query = { action : 'theme _information ' , 
function ( options = { } ) { const { search , page , number } = options ; const query = { action : 'query _themes ' , 
function is Plain Object ( value ) { if ( ! is Object ( value ) ) { return false ; } try { var _constructor = value . constructor ; var prototype = _constructor . prototype ; return _constructor & & prototype & & has Own Property . call ( prototype , 'is Prototype Of ' ) ; } catch ( error ) { return false ; } } 
function to Array ( value ) { return Array . from ? Array . from ( value ) : slice . call ( value ) ; } 
function for Each ( data , callback ) { if ( data & & is Function ( callback ) ) { if ( Array . is Array ( data ) | | is Number ( data . length ) ) { to Array ( data ) . for Each ( function ( value , key ) { callback . call ( data , value , key , data ) ; } ) ; } else if ( is Object ( data ) ) { Object . keys ( data ) . for Each ( function ( key ) { callback . call ( data , data [ key ] , key , data ) ; } ) ; } } return data ; } 
function normalize Decimal Number ( value ) { var times = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 1 0 0 0 0 0 0 0 0 0 0 0 ; return REGEXP _DECIMALS . test ( value ) ? Math . round ( value * times ) / times : value ; } 
function has Class ( element , value ) { return element . class List ? element . class List . contains ( value ) : element . class Name . index Of ( value ) > - 1 ; } 
function add Class ( element , value ) { if ( ! value ) { return ; } if ( is Number ( element . length ) ) { for Each ( element , function ( elem ) { add Class ( elem , value ) ; } ) ; return ; } if ( element . class List ) { element . class List . add ( value ) ; return ; } var class Name = element . class Name . trim ( ) ; if ( ! class Name ) { element . class Name = value ; } else if ( class Name . index Of ( value ) < 0 ) { element . class Name = " " . concat ( class Name , " " ) . concat ( value ) ; } } 
function remove Class ( element , value ) { if ( ! value ) { return ; } if ( is Number ( element . length ) ) { for Each ( element , function ( elem ) { remove Class ( elem , value ) ; } ) ; return ; } if ( element . class List ) { element . class List . remove ( value ) ; return ; } if ( element . class Name . index Of ( value ) > = 0 ) { element . class Name = element . class Name . replace ( value , ' ' ) ; } } 
function toggle Class ( element , value , added ) { if ( ! value ) { return ; } if ( is Number ( element . length ) ) { for Each ( element , function ( elem ) { toggle Class ( elem , value , added ) ; } ) ; return ; } 
function get Data ( element , name ) { if ( is Object ( element [ name ] ) ) { return element [ name ] ; } if ( element . dataset ) { return element . dataset [ name ] ; } return element . get Attribute ( "data - " . concat ( to Param Case ( name ) ) ) ; } 
function set Data ( element , name , data ) { if ( is Object ( data ) ) { element [ name ] = data ; } else if ( element . dataset ) { element . dataset [ name ] = data ; } else { element . set Attribute ( "data - " . concat ( to Param Case ( name ) ) , data ) ; } } 
function remove Data ( element , name ) { if ( is Object ( element [ name ] ) ) { try { delete element [ name ] ; } catch ( error ) { element [ name ] = undefined ; } } else if ( element . dataset ) { 
function remove Listener ( element , type , listener ) { var options = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : { } ; var handler = listener ; type . trim ( ) . split ( REGEXP _SPACES ) . for Each ( function ( event ) { if ( ! once Supported ) { var listeners = element . listeners ; if ( listeners & & listeners [ event ] & & listeners [ event ] [ listener ] ) { handler = listeners [ event ] [ listener ] ; delete listeners [ event ] [ listener ] ; if ( Object . keys ( listeners [ event ] ) . length = = = 0 ) { delete listeners [ event ] ; } if ( Object . keys ( listeners ) . length = = = 0 ) { delete element . listeners ; } } } element . remove Event Listener ( event , handler , options ) ; } ) ; } 
function add Listener ( element , type , listener ) { var options = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : { } ; var _handler = listener ; type . trim ( ) . split ( REGEXP _SPACES ) . for Each ( function ( event ) { if ( options . once & & ! once Supported ) { var _element $listeners = element . listeners , listeners = _element $listeners = = = void 0 ? { } : _element $listeners ; _handler = function handler ( ) { delete listeners [ event ] [ listener ] ; element . remove Event Listener ( event , _handler , options ) ; for ( var _len 2 = arguments . length , args = new Array ( _len 2 ) , _key 2 = 0 ; _key 2 < _len 2 ; _key 2 + + ) { args [ _key 2 ] = arguments [ _key 2 ] ; } listener . apply ( element , args ) ; } ; if ( ! listeners [ event ] ) { listeners [ event ] = { } ; } if ( listeners [ event ] [ listener ] ) { element . remove Event Listener ( event , listeners [ event ] [ listener ] , options ) ; } listeners [ event ] [ listener ] = _handler ; element . listeners = listeners ; } element . add Event Listener ( event , _handler , options ) ; } ) ; } 
function dispatch Event ( element , type , data ) { var event ; 
function get Offset ( element ) { var box = element . get Bounding Client Rect ( ) ; return { left : box . left + ( window . page XOffset - document . document Element . client Left ) , top : box . top + ( window . page YOffset - document . document Element . client Top ) } ; } 
function add Timestamp ( url ) { var timestamp = "timestamp = " . concat ( new Date ( ) . get Time ( ) ) ; return url + ( url . index Of ( ' ? ' ) = = = - 1 ? ' ? ' : ' & ' ) + timestamp ; } 
function get Transforms ( _ref ) { var rotate = _ref . rotate , scale X = _ref . scale X , scale Y = _ref . scale Y , translate X = _ref . translate X , translate Y = _ref . translate Y ; var values = [ ] ; if ( is Number ( translate X ) & & translate X ! = = 0 ) { values . push ( "translate X ( " . concat ( translate X , "px ) " ) ) ; } if ( is Number ( translate Y ) & & translate Y ! = = 0 ) { values . push ( "translate Y ( " . concat ( translate Y , "px ) " ) ) ; } 
function get Max Zoom Ratio ( pointers ) { var pointers 2 = assign ( { } , pointers ) ; var ratios = [ ] ; for Each ( pointers , function ( pointer , pointer Id ) { delete pointers 2 [ pointer Id ] ; for Each ( pointers 2 , function ( pointer 2 ) { var x 1 = Math . abs ( pointer . start X - pointer 2 . start X ) ; var y 1 = Math . abs ( pointer . start Y - pointer 2 . start Y ) ; var x 2 = Math . abs ( pointer . end X - pointer 2 . end X ) ; var y 2 = Math . abs ( pointer . end Y - pointer 2 . end Y ) ; var z 1 = Math . sqrt ( x 1 * x 1 + y 1 * y 1 ) ; var z 2 = Math . sqrt ( x 2 * x 2 + y 2 * y 2 ) ; var ratio = ( z 2 - z 1 ) / z 1 ; ratios . push ( ratio ) ; } ) ; } ) ; ratios . sort ( function ( a , b ) { return Math . abs ( a ) < Math . abs ( b ) ; } ) ; return ratios [ 0 ] ; } 
function get Pointer ( _ref 2 , end Only ) { var page X = _ref 2 . page X , page Y = _ref 2 . page Y ; var end = { end X : page X , end Y : page Y } ; return end Only ? end : assign ( { start X : page X , start Y : page Y } , end ) ; } 
function get Pointers Center ( pointers ) { var page X = 0 ; var page Y = 0 ; var count = 0 ; for Each ( pointers , function ( _ref 3 ) { var start X = _ref 3 . start X , start Y = _ref 3 . start Y ; page X + = start X ; page Y + = start Y ; count + = 1 ; } ) ; page X / = count ; page Y / = count ; return { page X : page X , page Y : page Y } ; } 
function get Adjusted Sizes ( _ref 4 ) 
function get Rotated Sizes ( _ref 5 ) { var width = _ref 5 . width , height = _ref 5 . height , degree = _ref 5 . degree ; degree = Math . abs ( degree ) % 1 8 0 ; if ( degree = = = 9 0 ) { return { width : height , height : width } ; } var arc = degree % 9 0 * Math . PI / 1 8 0 ; var sin Arc = Math . sin ( arc ) ; var cos Arc = Math . cos ( arc ) ; var new Width = width * cos Arc + height * sin Arc ; var new Height = width * sin Arc + height * cos Arc ; return degree > 9 0 ? { width : new Height , height : new Width } : { width : new Width , height : new Height } ; } 
function get Source Canvas ( image , _ref 6 , _ref 7 , _ref 8 ) { var image Aspect Ratio = _ref 6 . aspect Ratio , image Natural Width = _ref 6 . natural Width , image Natural Height = _ref 6 . natural Height , _ref 6 $rotate = _ref 6 . rotate , rotate = _ref 6 $rotate = = = void 0 ? 0 : _ref 6 $rotate , _ref 6 $scale X = _ref 6 . scale X , scale X = _ref 6 $scale X = = = void 0 ? 1 : _ref 6 $scale X , _ref 6 $scale Y = _ref 6 . scale Y , scale Y = _ref 6 $scale Y = = = void 0 ? 1 : _ref 6 $scale Y ; var aspect Ratio = _ref 7 . aspect Ratio , natural Width = _ref 7 . natural Width , natural Height = _ref 7 . natural Height ; var _ref 8 $fill Color = _ref 8 . fill Color , fill Color = _ref 8 $fill Color = = = void 0 ? 'transparent ' : _ref 8 $fill Color , _ref 8 $image Smoothing E = _ref 8 . image Smoothing Enabled , image Smoothing Enabled = _ref 8 $image Smoothing E = = = void 0 ? true : _ref 8 $image Smoothing E , _ref 8 $image Smoothing Q = _ref 8 . image Smoothing Quality , image Smoothing Quality = _ref 8 $image Smoothing Q = = = void 0 ? 'low ' : _ref 8 $image Smoothing Q , _ref 8 $max Width = _ref 8 . max Width , max Width = _ref 8 $max Width = = = void 0 ? Infinity : _ref 8 $max Width , _ref 8 $max Height = _ref 8 . max Height , max Height = _ref 8 $max Height = = = void 0 ? Infinity : _ref 8 $max Height , _ref 8 $min Width = _ref 8 . min Width , min Width = _ref 8 $min Width = = = void 0 ? 0 : _ref 8 $min Width , _ref 8 $min Height = _ref 8 . min Height , min Height = _ref 8 $min Height = = = void 0 ? 0 : _ref 8 $min Height ; var canvas = document . create Element ( 'canvas ' ) ; var context = canvas . get Context ( ' 2d ' ) ; var max Sizes = get Adjusted Sizes ( { aspect Ratio : aspect Ratio , width : max Width , height : max Height } ) ; var min Sizes = get Adjusted Sizes ( { aspect Ratio : aspect Ratio , width : min Width , height : min Height } , 'cover ' ) ; var width = Math . min ( max Sizes . width , Math . max ( min Sizes . width , natural Width ) ) ; var height = Math . min ( max Sizes . height , Math . max ( min Sizes . height , natural Height ) ) ; 
function data URLTo Array Buffer ( data URL ) { var base 6 4 = data URL . replace ( REGEXP _DATA _URL _HEAD , ' ' ) ; var binary = atob ( base 6 4 ) ; var array Buffer = new Array Buffer ( binary . length ) ; var uint 8 = new Uint 8Array ( array Buffer ) ; for Each ( uint 8 , function ( value , i ) { uint 8 [ i ] = binary . char Code At ( i ) ; } ) ; return array Buffer ; } 
function array Buffer To Data URL ( array Buffer , mime Type ) { var chunks = [ ] ; 
function parse Orientation ( orientation ) { var rotate = 0 ; var scale X = 1 ; var scale Y = 1 ; switch ( orientation ) { 
function init Canvas ( ) { var container Data = this . container Data , image Data = this . image Data ; var view Mode = this . options . view Mode ; var rotated = Math . abs ( image Data . rotate ) % 1 8 0 = = = 9 0 ; var natural Width = rotated ? image Data . natural Height : image Data . natural Width ; var natural Height = rotated ? image Data . natural Width : image Data . natural Height ; var aspect Ratio = natural Width / natural Height ; var canvas Width = container Data . width ; var canvas Height = container Data . height ; if ( container Data . height * aspect Ratio > container Data . width ) { if ( view Mode = = = 3 ) { canvas Width = container Data . height * aspect Ratio ; } else { canvas Height = container Data . width / aspect Ratio ; } } else if ( view Mode = = = 3 ) { canvas Height = container Data . width / aspect Ratio ; } else { canvas Width = container Data . height * aspect Ratio ; } var canvas Data = { aspect Ratio : aspect Ratio , natural Width : natural Width , natural Height : natural Height , width : canvas Width , height : canvas Height } ; canvas Data . left = ( container Data . width - canvas Width ) / 2 ; canvas Data . top = ( container Data . height - canvas Height ) / 2 ; canvas Data . old Left = canvas Data . left ; canvas Data . old Top = canvas Data . top ; this . canvas Data = canvas Data ; this . limited = view Mode = = = 1 | | view Mode = = = 2 ; this . limit Canvas ( true , true ) ; this . initial Image Data = assign ( { } , image Data ) ; this . initial Canvas Data = assign ( { } , canvas Data ) ; } 
function crop ( ) { if ( this . ready & & ! this . cropped & & ! this . disabled ) { this . cropped = true ; this . limit Crop Box ( true , true ) ; if ( this . options . modal ) { add Class ( this . drag Box , CLASS _MODAL ) ; } remove Class ( this . crop Box , CLASS _HIDDEN ) ; this . set Crop Box Data ( this . initial Crop Box Data ) ; } return this ; } 
function reset ( ) { if ( this . ready & & ! this . disabled ) { this . image Data = assign ( { } , this . initial Image Data ) ; this . canvas Data = assign ( { } , this . initial Canvas Data ) ; this . crop Box Data = assign ( { } , this . initial Crop Box Data ) ; this . render Canvas ( ) ; if ( this . cropped ) { this . render Crop Box ( ) ; } } return this ; } 
function clear ( ) { if ( this . cropped & & ! this . disabled ) { assign ( this . crop Box Data , { left : 0 , top : 0 , width : 0 , height : 0 } ) ; this . cropped = false ; this . render Crop Box ( ) ; this . limit Canvas ( true , true ) ; 
function replace ( url ) { var has Same Size = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : false ; if ( ! this . disabled & & url ) { if ( this . is Img ) { this . element . src = url ; } if ( has Same Size ) { this . url = url ; this . image . src = url ; if ( this . ready ) { this . view Box Image . src = url ; for Each ( this . previews , function ( element ) { element . get Elements By Tag Name ( 'img ' ) [ 0 ] . src = url ; } ) ; } } else { if ( this . is Img ) { this . replaced = true ; } this . options . data = null ; this . uncreate ( ) ; this . load ( url ) ; } } return this ; } 
function destroy ( ) { var element = this . element ; if ( ! element [ NAMESPACE ] ) { return this ; } element [ NAMESPACE ] = undefined ; if ( this . is Img & & this . replaced ) { element . src = this . original Url ; } this . uncreate ( ) ; return this ; } 
function move ( offset X ) { var offset Y = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : offset X ; var _this $canvas Data = this . canvas Data , left = _this $canvas Data . left , top = _this $canvas Data . top ; return this . move To ( is Undefined ( offset X ) ? offset X : left + Number ( offset X ) , is Undefined ( offset Y ) ? offset Y : top + Number ( offset Y ) ) ; } 
function move To ( x ) { var y = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : x ; var canvas Data = this . canvas Data ; var changed = false ; x = Number ( x ) ; y = Number ( y ) ; if ( this . ready & & ! this . disabled & & this . options . movable ) { if ( is Number ( x ) ) { canvas Data . left = x ; changed = true ; } if ( is Number ( y ) ) { canvas Data . top = y ; changed = true ; } if ( changed ) { this . render Canvas ( true ) ; } } return this ; } 
function zoom ( ratio , _original Event ) { var canvas Data = this . canvas Data ; ratio = Number ( ratio ) ; if ( ratio < 0 ) { ratio = 1 / ( 1 - ratio ) ; } else { ratio = 1 + ratio ; } return this . zoom To ( canvas Data . width * ratio / canvas Data . natural Width , null , _original Event ) ; } 
function rotate To ( degree ) { degree = Number ( degree ) ; if ( is Number ( degree ) & & this . ready & & ! this . disabled & & this . options . rotatable ) { this . image Data . rotate = degree % 3 6 0 ; this . render Canvas ( true , true ) ; } return this ; } 
function scale X ( _scale X ) { var scale Y = this . image Data . scale Y ; return this . scale ( _scale X , is Number ( scale Y ) ? scale Y : 1 ) ; } 
function scale Y ( _scale Y ) { var scale X = this . image Data . scale X ; return this . scale ( is Number ( scale X ) ? scale X : 1 , _scale Y ) ; } 
function scale ( scale X ) { var scale Y = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : scale X ; var image Data = this . image Data ; var transformed = false ; scale X = Number ( scale X ) ; scale Y = Number ( scale Y ) ; if ( this . ready & & ! this . disabled & & this . options . scalable ) { if ( is Number ( scale X ) ) { image Data . scale X = scale X ; transformed = true ; } if ( is Number ( scale Y ) ) { image Data . scale Y = scale Y ; transformed = true ; } if ( transformed ) { this . render Canvas ( true , true ) ; } } return this ; } 
function get Data ( ) { var rounded = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : false ; var options = this . options , image Data = this . image Data , canvas Data = this . canvas Data , crop Box Data = this . crop Box Data ; var data ; if ( this . ready & & this . cropped ) { data = { x : crop Box Data . left - canvas Data . left , y : crop Box Data . top - canvas Data . top , width : crop Box Data . width , height : crop Box Data . height } ; var ratio = image Data . width / image Data . natural Width ; for Each ( data , function ( n , i ) { data [ i ] = n / ratio ; } ) ; if ( rounded ) { 
function get Canvas Data ( ) { var canvas Data = this . canvas Data ; var data = { } ; if ( this . ready ) { for Each ( [ 'left ' , 'top ' , 'width ' , 'height ' , 'natural Width ' , 'natural Height ' ] , function ( n ) { data [ n ] = canvas Data [ n ] ; } ) ; } return data ; } 
function set Canvas Data ( data ) { var canvas Data = this . canvas Data ; var aspect Ratio = canvas Data . aspect Ratio ; if ( this . ready & & ! this . disabled & & is Plain Object ( data ) ) { if ( is Number ( data . left ) ) { canvas Data . left = data . left ; } if ( is Number ( data . top ) ) { canvas Data . top = data . top ; } if ( is Number ( data . width ) ) { canvas Data . width = data . width ; canvas Data . height = data . width / aspect Ratio ; } else if ( is Number ( data . height ) ) { canvas Data . height = data . height ; canvas Data . width = data . height * aspect Ratio ; } this . render Canvas ( true ) ; } return this ; } 
function set Aspect Ratio ( aspect Ratio ) { var options = this . options ; if ( ! this . disabled & & ! is Undefined ( aspect Ratio ) ) { 
function set Drag Mode ( mode ) { var options = this . options , drag Box = this . drag Box , face = this . face ; if ( this . ready & & ! this . disabled ) { var croppable = mode = = = DRAG _MODE _CROP ; var movable = options . movable & & mode = = = DRAG _MODE _MOVE ; mode = croppable | | movable ? mode : DRAG _MODE _NONE ; options . drag Mode = mode ; set Data ( drag Box , DATA _ACTION , mode ) ; toggle Class ( drag Box , CLASS _CROP , croppable ) ; toggle Class ( drag Box , CLASS _MOVE , movable ) ; if ( ! options . crop Box Movable ) { 
function append Node Factory ( Node ) { function Append Node ( editor ) { this . editor = editor ; this . dom = { } ; } Append Node . prototype = new Node ( ) ; Append Node . prototype . get Dom = function ( ) { * Append node doesn 't have a path * @returns {null } * / Append Node . prototype . get Path = function ( ) { return null ; } ; / * * * Append node doesn 't have an index * @returns {null } * / Append Node . prototype . get Index = function ( ) { return null ; } ; Append Node . prototype . update Dom = function ( options ) { var dom = this . dom ; var td Append = dom . td ; if ( td Append ) { td Append . style . padding Left = ( this . get Level ( ) * 2 4 + 2 6 ) + 'px ' ; * Check whether the Append Node is currently visible . * the Append Node is visible when its parent has no childs (i .e . is empty ) . * @return {boolean } is Visible * / Append Node . prototype . is Visible = function ( ) { return ( this . parent . childs . length = = 0 ) ; } ; Append Node . prototype . show Context Menu = function ( anchor , on Close ) { var node = this ; var titles = Node . TYPE _TITLES ; var append Submenu = [ { text : translate ( 'auto ' ) , class Name : 'jsoneditor -type -auto ' , title : titles . auto , click : function ( ) { node . _on Append ( ' ' , ' ' , 'auto ' ) ; } } , { text : translate ( 'array ' ) , class Name : 'jsoneditor -type -array ' , title : titles . array , click : function ( ) { node . _on Append ( ' ' , [ ] ) ; } } , { text : translate ( 'object ' ) , class Name : 'jsoneditor -type -object ' , title : titles . object , click : function ( ) { node . _on Append ( ' ' , { } ) ; } } , { text : translate ( 'string ' ) , class Name : 'jsoneditor -type -string ' , title : titles . string , click : function ( ) { node . _on Append ( ' ' , ' ' , 'string ' ) ; } } ] ; node . add Templates ( append Submenu , true ) ; var items = [ * Handle an event . The event is caught centrally by the editor * @param {Event } event * / Append Node . prototype . on Event = function ( event ) { var type = event . type ; var target = event . target | | event . src Element ; var dom = this . dom ; 
function ( event , func ) { this . _events = this . _events | | { } ; this . _events [ event ] = this . _events [ event ] | | [ ] ; this . _events [ event ] . push ( func ) ; } 
function ( event , func ) { this . _events = this . _events | | { } ; if ( event in this . _events = = = false ) return ; this . _events [ event ] . splice ( this . _events [ event ] . index Of ( func ) , 1 ) ; } 
function append Item ( item , parent , custom ) { if ( item . parent Node ) { if ( ! item . parent Node . parent Node ) { parent . append Child ( item . parent Node ) ; } } else { parent . append Child ( item ) ; } util . remove Class ( item , "excluded " ) ; if ( ! custom ) { item . inner HTML = item . text Content ; } } 
function ( ) { if ( this . items . length ) { var f = document . create Document Fragment ( ) ; if ( this . config . pagination ) { var pages = this . pages . slice ( 0 , this . page Index ) ; util . each ( pages , function ( i , items ) { util . each ( items , function ( j , item ) { append Item ( item , f , this . custom Option ) ; } , this ) ; } , this ) ; } else { util . each ( this . items , function ( i , item ) { append Item ( item , f , this . custom Option ) ; } , this ) ; } if ( f . child Element Count ) { util . remove Class ( this . items [ this . nav Index ] , "active " ) ; this . nav Index = f . query Selector ( " .selectr -option " ) . idx ; util . add Class ( this . items [ this . nav Index ] , "active " ) ; } this . tree . append Child ( f ) ; } } 
function ( e ) { var target = e . target ; if ( ! this . container . contains ( target ) & & ( this . opened | | util . has Class ( this . container , "notice " ) ) ) { this . close ( ) ; } } 
function ( option , data ) { data = data | | option ; var content = this . custom Option ? this . config . render Option ( data ) : option . text Content ; var opt = util . create Element ( "li " , { class : "selectr -option " , html : content , role : "treeitem " , "aria -selected " : false } ) ; opt . idx = option . idx ; this . items . push ( opt ) ; if ( option . default Selected ) { this . default Selected . push ( option . idx ) ; } if ( option . disabled ) { opt . disabled = true ; util . add Class ( opt , "disabled " ) ; } return opt ; } 
function ( ) { this . requires Pagination = this . config . pagination & & this . config . pagination > 0 ; 
function ( e ) { e = e | | window . event ; 
function ( item ) { var that = this , r ; var doc Frag = document . create Document Fragment ( ) ; var option = this . options [ item . idx ] ; var data = this . data ? this . data [ item . idx ] : option ; var content = this . custom Selected ? this . config . render Selection ( data ) : option . text Content ; var tag = util . create Element ( "li " , { class : "selectr -tag " , html : content } ) ; var btn = util . create Element ( "button " , { class : "selectr -tag -remove " , type : "button " } ) ; tag . append Child ( btn ) ; 
function ( item ) { var tag = false ; util . each ( this . tags , function ( i , t ) { if ( t . idx = = = item . idx ) { tag = t ; } } , this ) ; if ( tag ) { this . label . remove Child ( tag ) ; this . tags . splice ( this . tags . index Of ( tag ) , 1 ) ; } } 
function ( ) { var tree = this . tree ; var scroll Top = tree . scroll Top ; var scroll Height = tree . scroll Height ; var offset Height = tree . offset Height ; var at Bottom = scroll Top > = ( scroll Height - offset Height ) ; if ( ( at Bottom & & this . page Index < this . pages . length ) ) { var f = document . create Document Fragment ( ) ; util . each ( this . pages [ this . page Index ] , function ( i , item ) { append Item ( item , f , this . custom Option ) ; } , this ) ; tree . append Child ( f ) ; this . page Index + + ; this . emit ( "selectr .paginate " , { items : this . items . length , total : this . data . length , page : this . page Index , pages : this . pages . length } ) ; } } 
function ( ) { if ( this . config . searchable | | this . config . taggable ) { this . input . value = null ; this . searching = false ; if ( this . config . searchable ) { util . remove Class ( this . input Container , "active " ) ; } if ( util . has Class ( this . container , "notice " ) ) { util . remove Class ( this . container , "notice " ) ; util . add Class ( this . container , "open " ) ; this . input . focus ( ) ; } util . each ( this . items , function ( i , item ) { 
function ( query , option ) { var result = new Reg Exp ( query , "i " ) . exec ( option . text Content ) ; if ( result ) { return option . text Content . replace ( result [ 0 ] , " <span class = 'selectr -match ' > " + result [ 0 ] + " < /span > " ) ; } return false ; } 
function ( el , config ) { config = config | | { } ; if ( ! el ) { throw new Error ( "You must supply either a HTMLSelect Element or a CSS 3 selector string . " ) ; } this . el = el ; 
function show Transform Modal ( node , container ) { var value = node . get Value ( ) ; var content = ' <label class = "pico -modal -contents " > ' + ' <div class = "pico -modal -header " > ' + translate ( 'transform ' ) + ' < /div > ' + ' <p > ' + 'Enter a <a href = "http : / /jmespath .org " target = " _blank " >JMESPath < /a > query to filter , sort , or transform the JSON data . <br / > ' + 'To learn JMESPath , go to <a href = "http : / /jmespath .org /tutorial .html " target = " _blank " >the interactive tutorial < /a > . ' + ' < /p > ' + ' <div class = "jsoneditor -jmespath -label " > ' + translate ( 'transform Wizard Label ' ) + ' < /div > ' + ' <div id = "wizard " class = "jsoneditor -jmespath -block jsoneditor -jmespath -wizard " > ' + ' <table class = "jsoneditor -jmespath -wizard -table " > ' + ' <tbody > ' + ' <tr > ' + ' <th > ' + translate ( 'transform Wizard Filter ' ) + ' < /th > ' + ' <td class = "jsoneditor -jmespath -filter " > ' + ' <div class = "jsoneditor -inline jsoneditor -jmespath -filter -field " > ' + ' <select id = "filter Field " > ' + ' < /select > ' + ' < /div > ' + ' <div class = "jsoneditor -inline jsoneditor -jmespath -filter -relation " > ' + ' <select id = "filter Relation " > ' + ' <option value = " = = " > = = < /option > ' + ' <option value = " ! = " > ! = < /option > ' + ' <option value = " < " > &lt ; < /option > ' + ' <option value = " < = " > &lt ; = < /option > ' + ' <option value = " > " > &gt ; < /option > ' + ' <option value = " > = " > &gt ; = < /option > ' + ' < /select > ' + ' < /div > ' + ' <div class = "jsoneditor -inline jsoneditor -jmespath -filter -value " > ' + ' <input placeholder = "value . . . " id = "filter Value " / > ' + ' < /div > ' + ' < /td > ' + ' < /tr > ' + ' <tr > ' + ' <th > ' + translate ( 'transform Wizard Sort By ' ) + ' < /th > ' + ' <td class = "jsoneditor -jmespath -filter " > ' + ' <div class = "jsoneditor -inline jsoneditor -jmespath -sort -field " > ' + ' <select id = "sort Field " > ' + ' < /select > ' + ' < /div > ' + ' <div class = "jsoneditor -inline jsoneditor -jmespath -sort -order " > ' + ' <select id = "sort Order " > ' + ' <option value = "asc " >Ascending < /option > ' + ' <option value = "desc " >Descending < /option > ' + ' < /select > ' + ' < /div > ' + ' < /td > ' + ' < /tr > ' + ' <tr id = "select Fields Part " > ' + ' <th > ' + translate ( 'transform Wizard Select Fields ' ) + ' < /th > ' + ' <td class = "jsoneditor -jmespath -filter " > ' + ' <select class = "jsoneditor -jmespath -select -fields " id = "select Fields " multiple > < /select > ' + ' < /td > ' + ' < /tr > ' + ' < /tbody > ' + ' < /table > ' + ' < /div > ' + ' <div class = "jsoneditor -jmespath -label " > ' + translate ( 'transform Query Label ' ) + ' < /div > ' + ' <div class = "jsoneditor -jmespath -block " > ' + ' <textarea id = "query " ' + ' rows = " 4 " ' + ' autocomplete = "off " ' + ' autocorrect = "off " ' + ' autocapitalize = "off " ' + ' spellcheck = "false " ' + ' title = " ' + translate ( 'transform Query Title ' ) + ' " > [ * ] < /textarea > ' + ' < /div > ' + ' <div class = "jsoneditor -jmespath -label " > ' + translate ( 'transform Preview Label ' ) + ' < /div > ' + ' <div class = "jsoneditor -jmespath -block " > ' + ' <textarea id = "preview " ' + ' class = "jsoneditor -transform -preview " ' + ' readonly > < /textarea > ' + ' < /div > ' + ' <div class = "jsoneditor -jmespath -block jsoneditor -modal -actions " > ' + ' <input type = "submit " id = "ok " value = " ' + translate ( 'ok ' ) + ' " autofocus / > ' + ' < /div > ' + ' < /div > ' ; pico Modal ( { parent : container , content : content , overlay Class : 'jsoneditor -modal -overlay ' , modal Class : 'jsoneditor -modal jsoneditor -modal -transform ' , focus : false } ) . after Create ( function ( modal ) { var elem = modal . modal Elem ( ) ; var wizard = elem . query Selector ( ' #wizard ' ) ; var ok = elem . query Selector ( ' #ok ' ) ; var filter Field = elem . query Selector ( ' #filter Field ' ) ; var filter Relation = elem . query Selector ( ' #filter Relation ' ) ; var filter Value = elem . query Selector ( ' #filter Value ' ) ; var sort Field = elem . query Selector ( ' #sort Field ' ) ; var sort Order = elem . query Selector ( ' #sort Order ' ) ; var select Fields = elem . query Selector ( ' #select Fields ' ) ; var query = elem . query Selector ( ' #query ' ) ; var preview = elem . query Selector ( ' #preview ' ) ; if ( ! Array . is Array ( value ) ) { wizard . style . font Style = 'italic ' ; wizard . inner HTML = ' (wizard not available for objects , only for arrays ) ' } var paths = node . get Child Paths ( ) ; paths . for Each ( function ( path ) { var formatted Path = preprocess Path ( path ) ; var filter Option = document . create Element ( 'option ' ) ; filter Option . text = formatted Path ; filter Option . value = formatted Path ; filter Field . append Child ( filter Option ) ; var sort Option = document . create Element ( 'option ' ) ; sort Option . text = formatted Path ; sort Option . value = formatted Path ; sort Field . append Child ( sort Option ) ; } ) ; var all Paths = node . get Child Paths ( true ) . filter ( function ( path ) { return path ! = = ' . ' ; } ) ; if ( all Paths . length > 0 ) { all Paths . for Each ( function ( path ) { var formatted Path = preprocess Path ( path ) ; var option = document . create Element ( 'option ' ) ; option . text = formatted Path ; option . value = formatted Path ; select Fields . append Child ( option ) ; } ) ; } else { var select Fields Part = elem . query Selector ( ' #select Fields Part ' ) ; if ( select Fields Part ) { select Fields Part . style . display = 'none ' ; } } var selectr Filter Field = new Selectr ( filter Field , { default Selected : false , clearable : true , allow Deselect : true , placeholder : 'field . . . ' } ) ; var selectr Filter Relation = new Selectr ( filter Relation , { default Selected : false , clearable : true , allow Deselect : true , placeholder : 'compare . . . ' } ) ; var selectr Sort Field = new Selectr ( sort Field , { default Selected : false , clearable : true , allow Deselect : true , placeholder : 'field . . . ' } ) ; var selectr Sort Order = new Selectr ( sort Order , { default Selected : false , clearable : true , allow Deselect : true , placeholder : 'order . . . ' } ) ; var selectr Select Fields = new Selectr ( select Fields , { multiple : true , clearable : true , default Selected : false , placeholder : 'select fields . . . ' } ) ; selectr Filter Field . on ( 'selectr .change ' , generate Query From Wizard ) ; selectr Filter Relation . on ( 'selectr .change ' , generate Query From Wizard ) ; filter Value . oninput = generate Query From Wizard ; selectr Sort Field . on ( 'selectr .change ' , generate Query From Wizard ) ; selectr Sort Order . on ( 'selectr .change ' , generate Query From Wizard ) ; selectr Select Fields . on ( 'selectr .change ' , generate Query From Wizard ) ; elem . query Selector ( ' .pico -modal -contents ' ) . onclick = function ( event ) { 
function show More Node Factory ( Node ) { function Show More Node ( editor , parent ) { this . editor = editor ; this . parent = parent ; this . dom = { } ; } Show More Node . prototype = new Node ( ) ; Show More Node . prototype . get Dom = function ( ) { if ( this . dom . tr ) { return this . dom . tr ; } this . _update Editability ( ) ; * Update the HTML dom of the Node * / Show More Node . prototype . update Dom = function ( options ) { if ( this . is Visible ( ) ) { * Check whether the Show More Node is currently visible . * the Show More Node is visible when it 's parent has more childs than * the current visible Childs * @return {boolean } is Visible * / Show More Node . prototype . is Visible = function ( ) { return this . parent . expanded & & this . parent . childs . length > this . parent . visible Childs ; } ; / * * * Handle an event . The event is caught centrally by the editor * @param {Event } event * / Show More Node . prototype . on Event = function ( event ) { var type = event . type ; if ( type = = = 'keydown ' ) { this . on Key Down ( event ) ; } } ; return Show More Node ; } 
function show Sort Modal ( node , container ) { var content = ' <div class = "pico -modal -contents " > ' + ' <div class = "pico -modal -header " > ' + translate ( 'sort ' ) + ' < /div > ' + ' <form > ' + ' <table > ' + ' <tbody > ' + ' <tr > ' + ' <td > ' + translate ( 'sort Field Label ' ) + ' < /td > ' + ' <td class = "jsoneditor -modal -input " > ' + ' <div class = "jsoneditor -select -wrapper " > ' + ' <select id = "field " title = " ' + translate ( 'sort Field Title ' ) + ' " > ' + ' < /select > ' + ' < /div > ' + ' < /td > ' + ' < /tr > ' + ' <tr > ' + ' <td > ' + translate ( 'sort Direction Label ' ) + ' < /td > ' + ' <td class = "jsoneditor -modal -input " > ' + ' <div id = "direction " class = "jsoneditor -button -group " > ' + ' <input type = "button " ' + 'value = " ' + translate ( 'sort Ascending ' ) + ' " ' + 'title = " ' + translate ( 'sort Ascending Title ' ) + ' " ' + 'data -value = "asc " ' + 'class = "jsoneditor -button -first jsoneditor -button -asc " / > ' + ' <input type = "button " ' + 'value = " ' + translate ( 'sort Descending ' ) + ' " ' + 'title = " ' + translate ( 'sort Descending Title ' ) + ' " ' + 'data -value = "desc " ' + 'class = "jsoneditor -button -last jsoneditor -button -desc " / > ' + ' < /div > ' + ' < /td > ' + ' < /tr > ' + ' <tr > ' + ' <td colspan = " 2 " class = "jsoneditor -modal -input jsoneditor -modal -actions " > ' + ' <input type = "submit " id = "ok " value = " ' + translate ( 'ok ' ) + ' " / > ' + ' < /td > ' + ' < /tr > ' + ' < /tbody > ' + ' < /table > ' + ' < /form > ' + ' < /div > ' ; pico Modal ( { parent : container , content : content , overlay Class : 'jsoneditor -modal -overlay ' , modal Class : 'jsoneditor -modal jsoneditor -modal -sort ' } ) . after Create ( function ( modal ) { var form = modal . modal Elem ( ) . query Selector ( 'form ' ) ; var ok = modal . modal Elem ( ) . query Selector ( ' #ok ' ) ; var field = modal . modal Elem ( ) . query Selector ( ' #field ' ) ; var direction = modal . modal Elem ( ) . query Selector ( ' #direction ' ) ; var paths = node . type = = = 'array ' ? node . get Child Paths ( ) : [ ' . ' ] ; paths . for Each ( function ( path ) { var option = document . create Element ( 'option ' ) ; option . text = path ; option . value = path ; field . append Child ( option ) ; } ) ; function set Direction ( value ) { direction . value = value ; direction . class Name = 'jsoneditor -button -group jsoneditor -button -group -value - ' + direction . value ; } field . value = node . sorted By ? node . sorted By . path : paths [ 0 ] ; set Direction ( node . sorted By ? node . sorted By . direction : 'asc ' ) ; direction . onclick = function ( event ) { set Direction ( event . target . get Attribute ( 'data -value ' ) ) ; } ; ok . onclick = function ( event ) { event . prevent Default ( ) ; event . stop Propagation ( ) ; modal . close ( ) ; var path = field . value ; var path Array = ( path = = = ' . ' ) ? [ ] : path . split ( ' . ' ) . slice ( 1 ) ; node . sorted By = { path : path , direction : direction . value } ; node . sort ( path Array , direction . value ) } ; if ( form ) { 
function Tree Path ( container , root ) { if ( container ) { this . root = root ; this . path = document . create Element ( 'div ' ) ; this . path . class Name = 'jsoneditor -treepath ' ; this . path . set Attribute ( 'tabindex ' , 0 ) ; this . content Menu Clicked ; container . append Child ( this . path ) ; this . reset ( ) ; } } 
function Context Menu ( items , options ) { this . dom = { } ; var me = this ; var dom = this . dom ; this . anchor = undefined ; this . items = items ; this . event Listeners = { } ; this . selection = undefined ; 
function Mode Switcher ( container , modes , current , on Switch ) { 
function last Non Whitespace ( ) { var p = chars . length - 1 ; while ( p > = 0 ) { var pp = chars [ p ] ; if ( ! is White Space ( pp ) ) { return pp ; } p - - ; } return ' ' ; } 
function next Non White Space ( ) { var i Next = i + 1 ; while ( i Next < js String . length & & is White Space ( js String [ i Next ] ) ) { i Next + + ; } return js String [ i Next ] ; } 
function parse String ( end Quote ) { chars . push ( ' " ' ) ; i + + ; var c = curr ( ) ; while ( i < js String . length & & c ! = = end Quote ) { if ( c = = = ' " ' & & prev ( ) ! = = ' \ \ ' ) { 
function parse Key ( ) { var special Values = [ 'null ' , 'true ' , 'false ' ] ; var key = ' ' ; var c = curr ( ) ; var regexp = / [a -z A -Z _ $ \d ] / ; 
function _position For Index ( index ) { var text Till Index = el . value . substring ( 0 , index ) ; var row = ( text Till Index . match ( / \n / g ) | | [ ] ) . length + 1 ; var col = text Till Index . length - text Till Index . last Index Of ( " \n " ) ; return { row : row , column : col } } 
function JSONEditor ( container , options , json ) { if ( ! ( this instanceof JSONEditor ) ) { throw new Error ( 'JSONEditor constructor called without "new " . ' ) ; } 
function ( ) { var scroll Top = content . scroll Top ; var diff = ( final Scroll Top - scroll Top ) ; if ( Math . abs ( diff ) > 3 ) { content . scroll Top + = diff / 3 ; editor . animate Callback = callback ; editor . animate Timeout = set Timeout ( animate , 5 0 ) ; } else { 
function ( event ) { var target = event . target ; if ( ( target ! = = absolute Anchor ) & & ! util . is Child Of ( target , absolute Anchor ) ) { destroy ( ) ; } } 
function ( elem , rs ) { var rows = [ ] ; var ix = 0 ; var old Index = - 1 ; var on Mouse Over = function ( ) { this . style . outline = ' 1px solid #ddd ' ; } var on Mouse Out = function ( ) { this . style . outline = ' 0 ' ; } var on Mouse Down = function ( ) { p . hide ( ) ; p . onmouseselection ( this . _ _hint , p . rs ) ; } var p = { rs : rs , hide : function ( ) { elem . style . visibility = 'hidden ' ; 
function ( element , start Pos , options ) { this . start From = start Pos ; this . wrapper . remove ( ) ; if ( this . element Hint ) { this . element Hint . remove ( ) ; this . element Hint = null ; } if ( font Size = = ' ' ) { font Size = window . get Computed Style ( element ) . get Property Value ( 'font -size ' ) ; } if ( font Family = = ' ' ) { font Family = window . get Computed Style ( element ) . get Property Value ( 'font -family ' ) ; } var w = element . get Bounding Client Rect ( ) . right - element . get Bounding Client Rect ( ) . left ; drop Down . style . margin Left = ' 0 ' ; drop Down . style . margin Top = element . get Bounding Client Rect ( ) . height + 'px ' ; this . options = options ; if ( this . element ! = element ) { this . element = element ; this . element Style = { z Index : this . element . style . z Index , position : this . element . style . position , background Color : this . element . style . background Color , border Color : this . element . style . border Color } } this . element . style . z Index = 3 ; this . element . style . position = 'relative ' ; this . element . style . background Color = 'transparent ' ; this . element . style . border Color = 'transparent ' ; this . element Hint = element . clone Node ( ) ; this . element Hint . class Name = 'autocomplete hint ' ; this . element Hint . style . z Index = 2 ; this . element Hint . style . position = 'absolute ' ; this . element Hint . onfocus = function ( ) { this . element . focus ( ) ; } . bind ( this ) ; if ( this . element . add Event Listener ) { this . element . remove Event Listener ( "keydown " , key Down Handler ) ; this . element . add Event Listener ( "keydown " , key Down Handler , false ) ; this . element . remove Event Listener ( "blur " , on Blur Handler ) ; this . element . add Event Listener ( "blur " , on Blur Handler , false ) ; } wrapper . append Child ( this . element Hint ) ; wrapper . append Child ( drop Down ) ; element . parent Element . append Child ( wrapper ) ; this . repaint ( element ) ; } 
function ( id ) { for ( let parent = module . parent ; parent ; parent = parent . parent ) { try { return parent . require ( id ) ; } catch ( e ) { } } throw new Error ( "Cannot find module ' " + id + " ' from parent " ) ; } 
function render ( element ) { connect Devtools ( Desktop Renderer ) ; ROOT _NODE = create Element ( 'ROOT ' ) ; const container = ROOT _NODE ; 
function create Element ( type , props ) { const COMPONENTS = { ROOT : ( ) = > new Root ( ) , TEXT : ( ) = > new Text ( ROOT _NODE , props ) , APP : ( ) = > new App ( ROOT _NODE , props ) , WINDOW : ( ) = > new Window ( ROOT _NODE , props ) , BUTTON : ( ) = > new Button ( ROOT _NODE , props ) , VERTICALBOX : ( ) = > new Vertical Box ( ROOT _NODE , props ) , HORIZONTALBOX : ( ) = > new Horizontal Box ( ROOT _NODE , props ) , ENTRY : ( ) = > new Entry ( ROOT _NODE , props ) , PASSWORDENTRY : ( ) = > new Password Entry ( ROOT _NODE , props ) , MULTILINEENTRY : ( ) = > new Multiline Entry ( ROOT _NODE , props ) , COLORBUTTON : ( ) = > new Color Button ( ROOT _NODE , props ) , FORM : ( ) = > new Form ( ROOT _NODE , props ) , TAB : ( ) = > new Tab ( ROOT _NODE , props ) , GROUP : ( ) = > new Group ( ROOT _NODE , props ) , GRID : ( ) = > new Grid ( ROOT _NODE , props ) , CHECKBOX : ( ) = > new Checkbox ( ROOT _NODE , props ) , SPINBOX : ( ) = > new Spinbox ( ROOT _NODE , props ) , SLIDER : ( ) = > new Slider ( ROOT _NODE , props ) , COMBOBOX : ( ) = > new Combobox ( ROOT _NODE , props ) , COMBOBOXITEM : ( ) = > new Combobox . Item ( ROOT _NODE , props ) , RADIOBUTTON : ( ) = > new Radio Button ( ROOT _NODE , props ) , RADIOBUTTONITEM : ( ) = > new Radio Button . Item ( ROOT _NODE , props ) , EDITABLECOMBOBOX : ( ) = > new Editable Combobox ( ROOT _NODE , props ) , HORIZONTALSEPARATOR : ( ) = > new Horizontal Separator ( ROOT _NODE , props ) , VERTICALSEPARATOR : ( ) = > new Vertical Separator ( ROOT _NODE , props ) , PROGRESSBAR : ( ) = > new Progress Bar ( ROOT _NODE , props ) , MENUBAR : ( ) = > new Menu Bar ( ROOT _NODE , props ) , MENUBARITEM : ( ) = > new Menu Bar . Item ( ROOT _NODE , props ) , FONTBUTTON : ( ) = > new Font Button ( ROOT _NODE , props ) , AREA : ( ) = > new Area ( ROOT _NODE , props ) , AREARECTANGLE : ( ) = > new Area . Rectangle ( ROOT _NODE , props ) , AREALINE : ( ) = > new Area . Line ( ROOT _NODE , props ) , AREAARC : ( ) = > new Area . Arc ( ROOT _NODE , props ) , AREABEZIER : ( ) = > new Area . Bezier ( ROOT _NODE , props ) , AREAPATH : ( ) = > new Area . Path ( ROOT _NODE , props ) , AREAGROUP : ( ) = > new Area . Group ( ROOT _NODE , props ) , AREACIRCLE : ( ) = > new Area . Circle ( ROOT _NODE , props ) , AREATEXT : ( ) = > new Area . Text ( ROOT _NODE , props ) , default : undefined , } ; return COMPONENTS [ type ] ( ) | | COMPONENTS . default ; } 
function caml _open _sync _raw ( file Name , on Success , on Failure ) { var f = caml _js _from _string ( file Name ) ; var data = new joo _global _object . Uint 8Array ( [ 1 7 , 2 1 1 , 2 ] ) ; var result = null ; function on Success ( ) { var res = new joo _global _object . Uint 8Array ( o Req . response ) ; var ba = caml _ba _create _from ( res , null , 0 , 0 , 0 , [ res . length ] ) on Success ( ba ) ; } ; function on Failure ( ) { on Failure ( caml _js _to _string ( "failed to load file : " + f ) ) ; } ; var o Req = new XMLHttp Request ( ) ; o Req . add Event Listener ( "load " , on Success , on Failure ) ; o Req . response Type = "arraybuffer " o Req . open ( "GET " , file Name , true ) ; o Req . send ( ) ; } 
function whitespace ( rule , value , source , errors , options ) { if ( / ^ \s + $ / . test ( value ) | | value = = = ' ' ) { errors . push ( util . format ( options . messages . whitespace , rule . full Field ) ) ; } } 
function enumerable ( rule , value , source , errors , options ) { rule [ ENUM ] = Array . is Array ( rule [ ENUM ] ) ? rule [ ENUM ] : [ ] ; if ( rule [ ENUM ] . index Of ( value ) = = = - 1 ) { errors . push ( util . format ( options . messages [ ENUM ] , rule . full Field , rule [ ENUM ] . join ( ' , ' ) ) ) ; } } 
function range ( rule , value , source , errors , options ) { const len = typeof rule . len = = = 'number ' ; const min = typeof rule . min = = = 'number ' ; const max = typeof rule . max = = = 'number ' ; 
function required ( rule , value , source , errors , options , type ) { if ( rule . required & & ( ! source . has Own Property ( rule . field ) | | util . is Empty Value ( value , type | | rule . type ) ) ) { errors . push ( util . format ( options . messages . required , rule . full Field ) ) ; } } 
function string ( rule , value , callback , source , options ) { const errors = [ ] ; const validate = rule . required | | ( ! rule . required & & source . has Own Property ( rule . field ) ) ; if ( validate ) { if ( is Empty Value ( value , 'string ' ) & & ! rule . required ) { return callback ( ) ; } rules . required ( rule , value , source , errors , options , 'string ' ) ; if ( ! is Empty Value ( value , 'string ' ) ) { rules . type ( rule , value , source , errors , options ) ; rules . range ( rule , value , source , errors , options ) ; rules . pattern ( rule , value , source , errors , options ) ; if ( rule . whitespace = = = true ) { rules . whitespace ( rule , value , source , errors , options ) ; } } } callback ( errors ) ; } 
function regexp ( rule , value , callback , source , options ) { const errors = [ ] ; const validate = rule . required | | ( ! rule . required & & source . has Own Property ( rule . field ) ) ; if ( validate ) { if ( is Empty Value ( value ) & & ! rule . required ) { return callback ( ) ; } rules . required ( rule , value , source , errors , options ) ; if ( ! is Empty Value ( value ) ) { rules . type ( rule , value , source , errors , options ) ; } } callback ( errors ) ; } 
function pattern ( rule , value , source , errors , options ) { if ( rule . pattern ) { if ( rule . pattern instanceof Reg Exp ) { 
function type ( rule , value , source , errors , options ) { if ( rule . required & & value = = = undefined ) { required ( rule , value , source , errors , options ) ; return ; } const custom = [ 'integer ' , 'float ' , 'array ' , 'regexp ' , 'object ' , 'method ' , 'email ' , 'number ' , 'date ' , 'url ' , 'hex ' ] ; const rule Type = rule . type ; if ( custom . index Of ( rule Type ) > - 1 ) { if ( ! types [ rule Type ] ( value ) ) { errors . push ( util . format ( options . messages . types [ rule Type ] , rule . full Field , rule . type ) ) ; } 
function get Style Computed Property ( element , property ) { if ( element . node Type ! = = 1 ) { return [ ] ; } 
function get Bounding Client Rect ( element ) { var rect = { } ; 
function is Fixed ( element ) { var node Name = element . node Name ; if ( node Name = = = 'BODY ' | | node Name = = = 'HTML ' ) { return false ; } if ( get Style Computed Property ( element , 'position ' ) = = = 'fixed ' ) { return true ; } var parent Node = get Parent Node ( element ) ; if ( ! parent Node ) { return false ; } return is Fixed ( parent Node ) ; } 
function get Boundaries ( popper , reference , padding , boundaries Element ) { var fixed Position = arguments . length > 4 & & arguments [ 4 ] ! = = undefined ? arguments [ 4 ] : false ; 
function is Modifier Enabled ( modifiers , modifier Name ) { return modifiers . some ( function ( _ref ) { var name = _ref . name , enabled = _ref . enabled ; return enabled & & name = = = modifier Name ; } ) ; } 
function Popper ( reference , popper ) { var _this = this ; var options = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : { } ; class Call Check ( this , Popper ) ; this . schedule Update = function ( ) { return request Animation Frame ( _this . update ) ; } ; 
function write Output HTML ( dir , html ) { const output Path = path Join ( dir , 'index .html ' ) ; mkdirp . sync ( path . dirname ( output Path ) ) ; write File Sync ( output Path , serialize ( html ) ) ; } 
function needs Template Polyfill ( ) { 
function create Config ( options , legacy ) { return { entry : Array . is Array ( options . entry ) ? options . entry : [ options . entry ] , output : { filename : ` $ { legacy ? 'legacy / ' : ' ' } ` , chunk Filename : ` $ { legacy ? 'legacy / ' : ' ' } ` , path : path . resolve ( process . cwd ( ) , ` ` ) , } , devtool : development ? 'inline -source -map ' : 'source -map ' , resolve : { main Fields : [ 
function get Output HTML ( dir ) { if ( exists Sync ( ` $ { dir } ` ) ) { return read HTML ( ` $ { dir } ` ) ; } const output HTML = read HTML ( input Index HTMLPath ) ; const scripts = query All ( output HTML , predicates . has Tag Name ( 'script ' ) ) ; const module Scripts = scripts . filter ( script = > get Attribute ( script , 'type ' ) = = = 'module ' ) ; module Scripts . for Each ( module Script = > { remove ( module Script ) ; } ) ; write Output HTML ( dir , output HTML ) ; return output HTML ; } 
function copy Polyfills ( plugin Config , output Config ) { if ( ! plugin Config . polyfill Dynamic Imports & & ! plugin Config . polyfill Webcomponents & & ! plugin Config . polyfill Babel ) { return ; } const polyfills Dir = ` $ { output Config . dir . replace ( ' /legacy ' , ' ' ) } ` ; mkdirp . sync ( polyfills Dir ) ; if ( plugin Config . polyfill Dynamic Imports ) { copy File Sync ( path . resolve ( path Join ( _ _dirname , ' . . / . . /src /dynamic -import -polyfill .js ' ) ) , ` $ { polyfills Dir } ` , ) ; } if ( plugin Config . polyfill Webcomponents ) { copy File Sync ( require . resolve ( ' @webcomponents /webcomponentsjs /webcomponents -bundle .js ' ) , ` $ { polyfills Dir } ` , ) ; } if ( plugin Config . polyfill Babel ) { copy File Sync ( require . resolve ( ' @babel /polyfill /browser .js ' ) , ` $ { polyfills Dir } ` , ) ; } } 
function write Modules ( plugin Config , output Config , entry Modules ) { const index HTML = get Output HTML ( output Config . dir ) ; const head = query ( index HTML , predicates . has Tag Name ( 'head ' ) ) ; const body = query ( index HTML , predicates . has Tag Name ( 'body ' ) ) ; 
function write Legacy Modules ( plugin Config , output Config , entry Modules ) { const legacy Output Dir = output Config . dir ; const output Dir = legacy Output Dir . replace ( ' /legacy ' , ' ' ) ; const index HTML = get Output HTML ( output Dir ) ; const body = query ( index HTML , predicates . has Tag Name ( 'body ' ) ) ; const polyfills Dir = ` $ { output Dir } ` ; mkdirp . sync ( polyfills Dir ) ; if ( plugin Config . polyfill Babel ) { append ( body , create Script ( { src : ` ` , nomodule : ' ' , } ) , ) ; } if ( plugin Config . polyfill Webcomponents ) { append ( body , create Script ( { src : ` ` , nomodule : ' ' , } ) , ) ; } copy File Sync ( require . resolve ( 'systemjs /dist /s .min .js ' ) , ` $ { polyfills Dir } ` ) ; append ( body , create Script ( { src : ` ` , nomodule : ' ' , } ) , ) ; const load Script = create Script ( { nomodule : ' ' } , entry Modules . map ( src = > ` $ { path Join ( 'legacy ' , src ) } ` ) . join ( ' ' ) , ) ; append ( body , load Script ) ; write Output HTML ( output Dir , index HTML ) ; } 
function karma Esm Framework ( karma Config , karma Emitter ) { if ( ! karma Config . files . some ( file = > file . type = = = 'module ' ) ) { throw new Error ( "Did not find any test files with type = 'module ' . " + "Follow this format : { pattern : config .grep ? config .grep : 'test / * * / * .test .js ' , type : 'module ' } " , ) ; } initialize ( karma Config , karma Emitter ) ; } 
function create Compiler ( config , karma Emitter ) { const cache = new Map ( ) ; const watcher = chokidar . watch ( [ ] ) ; watcher . on ( 'change ' , file Path = > { if ( ! file Path . ends With ( ' .test .js ' ) & & ! file Path . ends With ( ' .spec .js ' ) ) { karma Emitter . refresh Files ( ) ; } cache . delete ( file Path ) ; } ) ; function add To Cache ( file Path , code ) { cache . set ( file Path , code ) ; watcher . add ( file Path ) ; } function babel Compile ( file Path , code ) { return babel . transform ( code , { filename : file Path , . . . config . babel Options , } ) . code ; } function compile ( file Path , code ) { 
function karma Esm Preprocessor ( logger ) { const log = logger . create ( 'preprocessor .esm ' ) ; function preprocess ( code , file , done ) { try { let compiled Code = esm . compiler . get Cached ( file . original Path ) ; if ( ! compiled Code ) { compiled Code = esm . compiler . compile ( file . original Path , code ) ; } done ( null , compiled Code ) ; } catch ( e ) { const message = ` \n \n $ { e . message } \n $ { file . original Path } \n \n ` ; log . error ( message ) ; done ( null , code ) ; } } return preprocess ; } 
function to Absolute URL ( url ) { const a = document . create Element ( 'a ' ) ; a . set Attribute ( 'href ' , url ) ; 
function has Matching Tag Name ( regex ) { return function ( node ) { if ( ! node . tag Name ) { return false ; } return regex . test ( node . tag Name . to Lower Case ( ) ) ; } ; } 
function normalize ( node ) { if ( ! ( is Element ( node ) | | is Document ( node ) | | is Document Fragment ( node ) ) ) { return ; } if ( ! node . child Nodes ) { return ; } var text Range Start = - 1 ; for ( var i = node . child Nodes . length - 1 , n = void 0 ; i > = 0 ; i - - ) { n = node . child Nodes [ i ] ; if ( is Text Node ( n ) ) { if ( text Range Start = = = - 1 ) { text Range Start = i ; } if ( i = = = 0 ) { 
function get Text Content ( node ) { if ( is Comment Node ( node ) ) { return node . data | | ' ' ; } if ( is Text Node ( node ) ) { return node . value | | ' ' ; } var subtree = node Walk All ( node , is Text Node ) ; return subtree . map ( get Text Content ) . join ( ' ' ) ; } 
function set Text Content ( node , value ) { if ( is Comment Node ( node ) ) { node . data = value ; } else if ( is Text Node ( node ) ) { node . value = value ; } else { var tn = new Text Node ( value ) ; tn . parent Node = node ; node . child Nodes = [ tn ] ; } } 
function tree Map ( node , mapfn ) { var results = [ ] ; node Walk ( node , function ( node ) { results = results . concat ( mapfn ( node ) ) ; return false ; } ) ; return results ; } 
function node Walk ( node , predicate , get Child Nodes ) { if ( get Child Nodes = = = void 0 ) { get Child Nodes = module . exports . default Child Nodes ; } if ( predicate ( node ) ) { return node ; } var match = null ; var child Nodes = get Child Nodes ( node ) ; if ( child Nodes ) { for ( var i = 0 ; i < child Nodes . length ; i + + ) { match = node Walk ( child Nodes [ i ] , predicate , get Child Nodes ) ; if ( match ) { break ; } } } return match ; } 
function node Walk All ( node , predicate , matches , get Child Nodes ) { if ( get Child Nodes = = = void 0 ) { get Child Nodes = module . exports . default Child Nodes ; } if ( ! matches ) { matches = [ ] ; } if ( predicate ( node ) ) { matches . push ( node ) ; } var child Nodes = get Child Nodes ( node ) ; if ( child Nodes ) { for ( var i = 0 ; i < child Nodes . length ; i + + ) { node Walk All ( child Nodes [ i ] , predicate , matches , get Child Nodes ) ; } } return matches ; } 
function node Walk Prior ( node , predicate ) { 
function node Walk Ancestors ( node , predicate ) { var parent = node . parent Node ; if ( ! parent ) { return undefined ; } if ( predicate ( parent ) ) { return parent ; } return node Walk Ancestors ( parent , predicate ) ; } 
function node Walk All Prior ( node , predicate , matches ) { if ( ! matches ) { matches = [ ] ; } if ( predicate ( node ) ) { matches . push ( node ) ; } 
function query ( node , predicate , get Child Nodes ) { if ( get Child Nodes = = = void 0 ) { get Child Nodes = module . exports . default Child Nodes ; } var element Predicate = AND ( is Element , predicate ) ; return node Walk ( node , element Predicate , get Child Nodes ) ; } 
function query All ( node , predicate , matches , get Child Nodes ) { if ( get Child Nodes = = = void 0 ) { get Child Nodes = module . exports . default Child Nodes ; } var element Predicate = AND ( is Element , predicate ) ; return node Walk All ( node , element Predicate , matches , get Child Nodes ) ; } 
function insert Node ( parent , index , new Node , replace ) { if ( ! parent . child Nodes ) { parent . child Nodes = [ ] ; } var new Nodes = [ ] ; var removed Node = replace ? parent . child Nodes [ index ] : null ; if ( new Node ) { if ( is Document Fragment ( new Node ) ) { if ( new Node . child Nodes ) { new Nodes = Array . from ( new Node . child Nodes ) ; new Node . child Nodes . length = 0 ; } } else { new Nodes = [ new Node ] ; remove ( new Node ) ; } } if ( replace ) { removed Node = parent . child Nodes [ index ] ; } Array . prototype . splice . apply ( parent . child Nodes , [ index , replace ? 1 : 0 ] . concat ( new Nodes ) ) ; new Nodes . for Each ( function ( n ) { n . parent Node = parent ; } ) ; if ( removed Node ) { removed Node . parent Node = undefined ; } } 
function remove Node Save Children ( node ) { 
function remove Fake Root Elements ( ast ) { var injected Nodes = query All ( ast , AND ( function ( node ) { return ! node . _ _location ; } , has Matching Tag Name ( / ^ (html |head |body ) $ / i ) ) , undefined , 
function get Code ( file Path ) { 
function wrap Transitioning Context ( Comp ) { return props = > { return ( < Transitioning Context . Consumer > { context = > < Comp context = { context } { . . . props } / > } < / Transitioning Context . Consumer > ) ; } ; } 
function friction ( value ) { const MAX _FRICTION = 5 ; const MAX _VALUE = 1 0 0 ; return max ( 1 , min ( MAX _FRICTION , add ( 1 , multiply ( value , ( MAX _FRICTION - 1 ) / MAX _VALUE ) ) ) ) ; } 
function find Shallow Intersecting Range ( date 1 , date 2 ) { const this Range = date 1 . to Range ( ) ; const other Range = date 2 . to Range ( ) ; 
function date Shallow Includes Date ( date 1 , date 2 ) { 
function date Shallow Intersects Date ( date 1 , date 2 ) { if ( date 1 . is Date ) return date 2 . is Date ? date 1 . date Time = = = date 2 . date Time : date Shallow Includes Date ( date 2 , date 1 ) ; if ( date 2 . is Date ) return date Shallow Includes Date ( date 1 , date 2 ) ; 
function split _linebreaks ( s ) { 
function process Input Sync ( filepath ) { var data = null , config = this . cfg , outfile = config . outfile , input ; 
function on Output Error ( err ) { if ( err . code = = = 'EACCES ' ) { console . error ( err . path + " is not writable . Skipping ! " ) ; } else { console . error ( err ) ; process . exit ( 0 ) ; } } 
function dasherize Shorthands ( hash ) { 
function _merge Opts ( all Options , child Field Name ) { var final Opts = { } ; all Options = _normalize Opts ( all Options ) ; var name ; for ( name in all Options ) { if ( name ! = = child Field Name ) { final Opts [ name ] = all Options [ name ] ; } } 
function Templatable Pattern ( input _scanner , parent ) { Pattern . call ( this , input _scanner , parent ) ; this . _ _template _pattern = null ; this . _disabled = Object . assign ( { } , template _names ) ; this . _excluded = Object . assign ( { } , template _names ) ; if ( parent ) { this . _ _template _pattern = this . _input . get _regexp ( parent . _ _template _pattern ) ; this . _excluded = Object . assign ( this . _excluded , parent . _excluded ) ; this . _disabled = Object . assign ( this . _disabled , parent . _disabled ) ; } var pattern = new Pattern ( input _scanner ) ; this . _ _patterns = { handlebars _comment : pattern . starting _with ( / { { ! - - / ) . until _after ( / - - } } / ) , handlebars : pattern . starting _with ( / { { / ) . until _after ( / } } / ) , php : pattern . starting _with ( / < \ ? ( ? : [ = ] |php ) / ) . until _after ( / \ ? > / ) , erb : pattern . starting _with ( / < % [ ^ % ] / ) . until _after ( / [ ^ % ] % > / ) , 
function filter Unused Selectors ( selectors , ignore , used Selectors ) { return selectors . filter ( ( selector ) = > { selector = de Pseudify ( selector ) ; if ( selector [ 0 ] = = = ' @ ' ) { return true ; } for ( let i = 0 , len = ignore . length ; i < len ; + + i ) { if ( _ . is Reg Exp ( ignore [ i ] ) & & ignore [ i ] . test ( selector ) ) { return true ; } if ( ignore [ i ] = = = selector ) { return true ; } } return used Selectors . index Of ( selector ) ! = = - 1 ; } ) ; } 
function filter Keyframes ( css , unused Rules ) { const used Animations = [ ] ; css . walk Decls ( ( decl ) = > { if ( _ . ends With ( decl . prop , 'animation -name ' ) ) { used Animations . push ( . . . postcss . list . comma ( decl . value ) ) ; } else if ( _ . ends With ( decl . prop , 'animation ' ) ) { postcss . list . comma ( decl . value ) . for Each ( ( anim ) = > { used Animations . push ( . . . postcss . list . space ( anim ) ) ; } ) ; } } ) ; const used Animations Set = new Set ( used Animations ) ; css . walk At Rules ( / keyframes $ / , ( at Rule ) = > { if ( ! used Animations Set . has ( at Rule . params ) ) { unused Rules . push ( at Rule ) ; at Rule . remove ( ) ; } } ) ; } 
function filter Empty At Rules ( css ) { css . walk At Rules ( ( at Rule ) = > { if ( at Rule . name = = = 'media ' & & at Rule . nodes . length = = = 0 ) { at Rule . remove ( ) ; } } ) ; } 
function get Used Selectors ( page , css ) { let used Selectors = [ ] ; css . walk Rules ( ( rule ) = > { used Selectors = _ . concat ( used Selectors , rule . selectors . map ( de Pseudify ) ) ; } ) ; return jsdom . find All ( page , used Selectors ) ; } 
function get All Selectors ( css ) { let selectors = [ ] ; css . walk Rules ( ( rule ) = > { selectors = _ . concat ( selectors , rule . selector ) ; } ) ; return selectors ; } 
function filter Unused Rules ( pages , css , ignore , used Selectors ) { let ignore Next Rule = false , ignore Next Rules Start = false , unused Rules = [ ] , unused Rule Selectors , used Rule Selectors ; ignore Next Rule = false ; css . walk ( ( rule ) = > { if ( rule . type = = = 'comment ' ) { if ( / ^ ! ? \s ?uncss :ignore start \s ? $ / . test ( rule . text ) ) { 
function parse Uncssrc ( filename ) { let options = JSON . parse ( fs . read File Sync ( filename , 'utf - 8 ' ) ) ; options . ignore = options . ignore ? options . ignore . map ( str To Reg Exp ) : undefined ; options . ignore Sheets = options . ignore Sheets ? options . ignore Sheets . map ( str To Reg Exp ) : undefined ; return options ; } 
function parse Paths ( source , stylesheets , options ) { return stylesheets . map ( ( sheet ) = > { let source Protocol ; const is Local File = sheet . substr ( 0 , 5 ) = = = 'file : ' ; if ( sheet . substr ( 0 , 4 ) = = = 'http ' ) { return sheet ; } if ( is URL ( source ) & & ! is Local File ) { source Protocol = url . parse ( source ) . protocol ; if ( sheet . substr ( 0 , 2 ) = = = ' / / ' ) { return source Protocol ? source Protocol + sheet : 'http : ' + sheet ; } return url . resolve ( source , sheet ) ; } sheet = sheet . split ( ' ? ' ) [ 0 ] . split ( ' # ' ) [ 0 ] ; if ( is Local File ) { sheet = url . parse ( sheet ) . path . replace ( ' % 2 0 ' , ' ' ) ; sheet = is Windows ( ) ? sheet . substring ( 1 ) : sheet ; if ( options . htmlroot ) { return path . join ( options . htmlroot , sheet ) ; } sheet = path . relative ( path . join ( path . dirname ( source ) ) , sheet ) ; } if ( sheet [ 0 ] = = = ' / ' & & options . htmlroot ) { return path . join ( options . htmlroot , sheet ) ; } else if ( is HTML ( source ) ) { return path . join ( options . csspath , sheet ) ; } return path . join ( path . dirname ( source ) , options . csspath , sheet ) ; } ) ; } 
function read Stylesheets ( files , output Banner ) { return Promise . all ( files . map ( ( filename ) = > { if ( is URL ( filename ) ) { return new Promise ( ( resolve , reject ) = > { request ( { url : filename , headers : { 'User -Agent ' : 'Un CSS ' } } , ( err , response , body ) = > { if ( err ) { return reject ( err ) ; } return resolve ( body ) ; } ) ; } ) ; } else if ( fs . exists Sync ( filename ) ) { return new Promise ( ( resolve , reject ) = > { fs . read File ( filename , 'utf - 8 ' , ( err , contents ) = > { if ( err ) { return reject ( err ) ; } return resolve ( contents ) ; } ) ; } ) ; } throw new Error ( ` $ { path . join ( process . cwd ( ) , filename ) } ` ) ; } ) ) . then ( ( res ) = > { 
function get HTML ( files , options ) { if ( _ . is String ( files ) ) { files = [ files ] ; } files = _ . flatten ( files . map ( ( file ) = > { if ( ! is URL ( file ) & & ! is HTML ( file ) ) { return glob . sync ( file ) ; } return file ; } ) ) ; if ( ! files . length ) { return Promise . reject ( new Error ( 'Un CSS : no HTML files found ' ) ) ; } 
function get Stylesheets ( files , options , pages ) { if ( options . stylesheets & & options . stylesheets . length ) { return Promise . resolve ( [ files , options , pages , [ options . stylesheets ] ] ) ; } return Promise . all ( pages . map ( ( page ) = > jsdom . get Stylesheets ( page , options ) ) ) . then ( ( stylesheets ) = > [ files , options , pages , stylesheets ] ) ; } 
function get CSS ( [ files , options , pages , stylesheets ] ) { if ( options . ignore Sheets . length ) { stylesheets = stylesheets . map ( ( arr ) = > { return arr . filter ( ( sheet ) = > { return _ . every ( options . ignore Sheets , ( ignore ) = > { if ( _ . is Reg Exp ( ignore ) ) { return ! ignore . test ( sheet ) ; } return sheet ! = = ignore ; } ) ; } ) ; } ) ; } if ( _ . flatten ( stylesheets ) . length ) { stylesheets = _ . chain ( stylesheets ) . map ( ( sheets , i ) = > utility . parse Paths ( files [ i ] , sheets , options ) ) . flatten ( ) . uniq ( ) . value ( ) ; } else { stylesheets = [ ] ; } return Promise . all ( [ options , pages , utility . read Stylesheets ( stylesheets , options . banner ) ] ) ; } 
function process With Text Api ( [ options , pages , stylesheets ] ) { if ( options . raw ) { if ( _ . is String ( options . raw ) ) { stylesheets . push ( options . raw ) ; } else { throw new Error ( 'Un CSS : options .raw - expected a string ' ) ; } } if ( ! _ . flatten ( stylesheets ) . length ) { throw new Error ( 'Un CSS : no stylesheets found ' ) ; } const css Str = stylesheets . join ( ' \n ' ) ; let pcss , report ; try { pcss = postcss . parse ( css Str ) ; } catch ( err ) { throw utility . parse Error Message ( err , css Str ) ; } return uncss ( pages , pcss , options . ignore ) . then ( ( [ css , rep ] ) = > { let new Css Str = ' ' ; postcss . stringify ( css , ( result ) = > { new Css Str + = result ; } ) ; if ( options . report ) { report = { original : css Str , selectors : rep } ; } return [ new Css Str , report ] ; } ) ; } 
function init ( files , options , callback ) { if ( _ . is Function ( options ) ) { callback = options ; options = { } ; } else if ( ! _ . is Function ( callback ) ) { throw new Type Error ( 'Un CSS : expected a callback ' ) ; } if ( options . uncssrc ) { try { options = _ . merge ( utility . parse Uncssrc ( options . uncssrc ) , options ) ; } catch ( err ) { if ( err instanceof Syntax Error ) { callback ( new Syntax Error ( 'Un CSS : uncssrc file is invalid JSON . ' ) ) ; return ; } callback ( err ) ; return ; } } options = _ . defaults ( options , { csspath : ' ' , ignore : [ ] , media : [ ] , timeout : 0 , report : false , ignore Sheets : [ ] , html : files , banner : true , 
function from Source ( src , options ) { const config = { features : { Fetch External Resources : [ 'script ' ] , Process External Resources : [ 'script ' ] } , virtual Console : jsdom . create Virtual Console ( ) . send To ( console ) , user Agent : options . user Agent } ; 
function get Stylesheets ( window , options ) { if ( Array . is Array ( options . media ) = = = false ) { options . media = [ options . media ] ; } const media = _ . union ( [ ' ' , 'all ' , 'screen ' ] , options . media ) ; const elements = window . document . query Selector All ( 'link [rel = "stylesheet " ] ' ) ; return Array . prototype . map . call ( elements , ( link ) = > ( { href : link . get Attribute ( 'href ' ) , media : link . get Attribute ( 'media ' ) | | ' ' } ) ) . filter ( ( sheet ) = > media . index Of ( sheet . media ) ! = = - 1 ) . map ( ( sheet ) = > sheet . href ) ; } 
function find All ( window , sels ) { const document = window . document ; 
function open DB ( name , version , { blocked , upgrade , blocking } = { } ) { const request = indexed DB . open ( name , version ) ; const open Promise = wrap ( request ) ; if ( upgrade ) { request . add Event Listener ( 'upgradeneeded ' , ( event ) = > { upgrade ( wrap ( request . result ) , event . old Version , event . new Version , wrap ( request . transaction ) ) ; } ) ; } if ( blocked ) request . add Event Listener ( 'blocked ' , ( ) = > blocked ( ) ) ; if ( blocking ) open Promise . then ( db = > db . add Event Listener ( 'versionchange ' , blocking ) ) ; return open Promise ; } 
function delete DB ( name , { blocked } = { } ) { const request = indexed DB . delete Database ( name ) ; if ( blocked ) request . add Event Listener ( 'blocked ' , ( ) = > blocked ( ) ) ; return wrap ( request ) . then ( ( ) = > undefined ) ; } 
function get Cursor Advance Methods ( ) { return cursor Advance Methods | | ( cursor Advance Methods = [ IDBCursor . prototype . advance , IDBCursor . prototype . continue , IDBCursor . prototype . continue Primary Key , ] ) ; } 
function resolve Or Reject ( data ) { if ( data . filename ) { console . warn ( data ) ; } if ( ! options . async ) { head . remove Child ( style ) ; } } 
function ( t ) { return function ( ) { var obj = Object . create ( t . prototype ) ; t . apply ( obj , Array . prototype . slice . call ( arguments , 0 ) ) ; return obj ; } ; } 
function add Replacement Into Path ( beginning Path , add Path , replaced Element , original Selector ) { var new Selector Path , last Selector , new Joined Selector ; 
function add All Replacements Into Path ( beginning Path , add Paths , replaced Element , original Selector , result ) { var j ; for ( j = 0 ; j < beginning Path . length ; j + + ) { var new Selector Path = add Replacement Into Path ( beginning Path [ j ] , add Paths , replaced Element , original Selector ) ; result . push ( new Selector Path ) ; } return result ; } 
function replace Parent Selector ( paths , context , in Selector ) { 
function ( value , unit ) { this . value = parse Float ( value ) ; if ( is Na N ( this . value ) ) { throw new Error ( 'Dimension is not a number . ' ) ; } this . unit = ( unit & & unit instanceof Unit ) ? unit : new Unit ( unit ? [ unit ] : undefined ) ; this . set Parent ( this . unit , this ) ; } 
function Parser ( context , imports , file Info ) { var parsers , parser Input = get Parser Input ( ) ; function error ( msg , type ) { throw new Less Error ( { index : parser Input . i , filename : file Info . filename , type : type | | 'Syntax ' , message : msg } , imports ) ; } function expect ( arg , msg ) { * Used after initial parsing to create nodes on the fly * * @param {String } str - string to parse * @param {Array } parse List - array of parsers to run input through e .g . [ "value " , "important " ] * @param {Number } current Index - start number to begin indexing * @param {Object } file Info - file Info to attach to created nodes * / function parse Node ( str , parse List , current Index , file Info , callback ) { var result , return Nodes = [ ] ; var parser = parser Input ; try { parser . start ( str , false , function fail ( msg , index ) { callback ( { message : msg , index : index + current Index } ) ; } ) ; for ( var x = 0 , p , i ; ( p = parse List [ x ] ) ; x + + ) { i = parser . i ; result = parsers [ p ] ( ) ; if ( result ) { result . _index = i + current Index ; result . _file Info = file Info ; return Nodes . push ( result ) ; } else { return Nodes . push ( null ) ; } } var end Info = parser . end ( ) ; if ( end Info . is Finished ) { callback ( null , return Nodes ) ; } else { callback ( true , null ) ; } } catch ( e ) { throw new Less Error ( { index : e . index + current Index , message : e . message } , imports , file Info . filename ) ; } } but it 's quite tricky since it relies on all these `parsers ` and `expect ` available only here * / return { alpha : f ( parsers . ie Alpha , true ) , boolean : f ( condition ) , 'if ' : f ( condition ) } [ name . to Lower Case ( ) ] ; function f ( parse , stop ) { return { parse : parse , / / parsing function stop : stop / / when true - stop after parse ( ) and return its result , / / otherwise continue for plain args } ; } function condition ( ) { return [ expect ( parsers . condition , 'expected condition ' ) ] ; } } , arguments : function ( prev Args ) { var args Comma = prev Args | | [ ] , args Semi Colon = [ ] , is Semi Colon Separated , value ; parser Input . save ( ) ; while ( true ) { if ( prev Args ) { prev Args = false ; } else { value = parsers . detached Ruleset ( ) | | this . assignment ( ) | | parsers . expression ( ) ; if ( ! value ) { break ; } if ( value . value & & value . value . length = = 1 ) { value = value . value [ 0 ] ; } args Comma . push ( value ) ; } if ( parser Input . $char ( ' , ' ) ) { continue ; } if ( parser Input . $char ( ' ; ' ) | | is Semi Colon Separated ) { is Semi Colon Separated = true ; value = ( args Comma . length < 1 ) ? args Comma [ 0 ] : new tree . Value ( args Comma ) ; args Semi Colon . push ( value ) ; args Comma = [ ] ; } } parser Input . forget ( ) ; return is Semi Colon Separated ? args Semi Colon : args Comma ; } , literal : function ( ) { return this . dimension ( ) | | this . color ( ) | | this . quoted ( ) | | this . unicode Descriptor ( ) ; } , / / Assignments are argument entities for calls . / / They are present in ie filter properties as shown below . / / / / filter : progid :DXImage Transform .Microsoft .Alpha ( *opacity = 5 0 * ) / / assignment : function ( ) { var key , value ; parser Input . save ( ) ; key = parser Input . $re ( / ^ \w + ( ? = \s ? = ) / i ) ; if ( ! key ) { parser Input . restore ( ) ; return ; } if ( ! parser Input . $char ( ' = ' ) ) { parser Input . restore ( ) ; return ; } value = parsers . entity ( ) ; if ( value ) { parser Input . forget ( ) ; return new ( tree . Assignment ) ( key , value ) ; } else { parser Input . restore ( ) ; } } , / / / / Parse url ( ) tokens / / / / We use a specific rule for urls , because they don 't really behave like * Matching elements for mixins * (Start with . or # and can have > ) * / elements : function ( ) { var elements , e , c , elem , elem Index , re = / ^ [ # . ] ( ? : [ \w - ] | \ \ ( ? : [A -Fa -f 0 - 9 ] { 1 , 6 } ? | [ ^A -Fa -f 0 - 9 ] ) ) + / ; while ( true ) { elem Index = parser Input . i ; e = parser Input . $re ( re ) ; if ( ! e ) { break ; } elem = new ( tree . Element ) ( c , e , false , elem Index , file Info ) ; if ( elements ) { elements . push ( elem ) ; } else { elements = [ elem ] ; } c = parser Input . $char ( ' > ' ) ; } return elements ; } , args : function ( is Call ) { var entities = parsers . entities , returner = { args : null , variadic : false } , expressions = [ ] , args Semi Colon = [ ] , args Comma = [ ] , is Semi Colon Separated , expression Contains Named , name , name Loop , value , arg , expand , has Sep = true ; parser Input . save ( ) ; while ( true ) { if ( is Call ) { arg = parsers . detached Ruleset ( ) | | parsers . expression ( ) ; } else { parser Input . comment Store . length = 0 ; if ( parser Input . $str ( ' . . . ' ) ) { returner . variadic = true ; if ( parser Input . $char ( ' ; ' ) & & ! is Semi Colon Separated ) { is Semi Colon Separated = true ; } ( is Semi Colon Separated ? args Semi Colon : args Comma ) . push ( { variadic : true } ) ; break ; } arg = entities . variable ( ) | | entities . property ( ) | | entities . literal ( ) | | entities . keyword ( ) | | this . call ( true ) ; } if ( ! arg | | ! has Sep ) { break ; } name Loop = null ; if ( arg . throw Away Comments ) { arg . throw Away Comments ( ) ; } value = arg ; var val = null ; if ( is Call ) { * DR args currently only implemented for each ( ) function , and not * yet settable as ` @dr : # ( @arg ) { } ` * This should be done when DRs are merged with mixins . * See : https : * / arg Info = this . mixin . args ( false ) ; params = arg Info . args ; variadic = arg Info . variadic ; if ( ! parser Input . $char ( ' ) ' ) ) { parser Input . restore ( ) ; return ; } } var block Ruleset = this . block Ruleset ( ) ; if ( block Ruleset ) { parser Input . forget ( ) ; if ( params ) { return new tree . mixin . Definition ( null , params , block Ruleset , null , variadic ) ; } return new tree . Detached Ruleset ( block Ruleset ) ; } parser Input . restore ( ) ; } , * Used for custom properties , at -rules , and variables (as fallback ) * Parses almost anything inside of { } [ ] ( ) " " blocks * until it reaches outer -most tokens . * * First , it will try to parse comments and entities to reach * the end . This is mostly like the Expression parser except no * math is allowed . * / permissive Value : function ( until Tokens ) { var i , e , done , value , tok = until Tokens | | ' ; ' , index = parser Input . i , result = [ ] ; function test Current Char ( ) { var char = parser Input . current Char ( ) ; if ( typeof tok = = = 'string ' ) { return char = = = tok ; } else { return tok . test ( char ) ; } } if ( test Current Char ( ) ) { return ; } value = [ ] ; do { e = this . comment ( ) ; if ( e ) { value . push ( e ) ; continue ; } e = this . entity ( ) ; if ( e ) { value . push ( e ) ; } } while ( e ) ; done = test Current Char ( ) ; if ( value . length > 0 ) { value = new ( tree . Expression ) ( value ) ; if ( done ) { return value ; } else { result . push ( value ) ; } 
function expect Char ( arg , msg ) { if ( parser Input . $char ( arg ) ) { return arg ; } error ( msg | | 'expected \ ' ' + arg + ' \ ' got \ ' ' + parser Input . current Char ( ) + ' \ ' ' ) ; } 
function parse Node ( str , parse List , current Index , file Info , callback ) { var result , return Nodes = [ ] ; var parser = parser Input ; try { parser . start ( str , false , function fail ( msg , index ) { callback ( { message : msg , index : index + current Index } ) ; } ) ; for ( var x = 0 , p , i ; ( p = parse List [ x ] ) ; x + + ) { i = parser . i ; result = parsers [ p ] ( ) ; if ( result ) { result . _index = i + current Index ; result . _file Info = file Info ; return Nodes . push ( result ) ; } else { return Nodes . push ( null ) ; } } var end Info = parser . end ( ) ; if ( end Info . is Finished ) { callback ( null , return Nodes ) ; } else { callback ( true , null ) ; } } catch ( e ) { throw new Less Error ( { index : e . index + current Index , message : e . message } , imports , file Info . filename ) ; } } 
function ( str , callback , additional Data ) { var root , error = null , global Vars , modify Vars , ignored , pre Text = ' ' ; global Vars = ( additional Data & & additional Data . global Vars ) ? Parser . serialize Vars ( additional Data . global Vars ) + ' \n ' : ' ' ; modify Vars = ( additional Data & & additional Data . modify Vars ) ? ' \n ' + Parser . serialize Vars ( additional Data . modify Vars ) : ' ' ; if ( context . plugin Manager ) { var pre Processors = context . plugin Manager . get Pre Processors ( ) ; for ( var i = 0 ; i < pre Processors . length ; i + + ) { str = pre Processors [ i ] . process ( str , { context : context , imports : imports , file Info : file Info } ) ; } } if ( global Vars | | ( additional Data & & additional Data . banner ) ) { pre Text = ( ( additional Data & & additional Data . banner ) ? additional Data . banner : ' ' ) + global Vars ; ignored = imports . contents Ignored Chars ; ignored [ file Info . filename ] = ignored [ file Info . filename ] | | 0 ; ignored [ file Info . filename ] + = pre Text . length ; } str = str . replace ( / \r \n ? / g , ' \n ' ) ; 
function ( ) { var mixin = this . mixin , root = [ ] , node ; while ( true ) { while ( true ) { node = this . comment ( ) ; if ( ! node ) { break ; } root . push ( node ) ; } 
function ( ) { if ( parser Input . comment Store . length ) { var comment = parser Input . comment Store . shift ( ) ; return new ( tree . Comment ) ( comment . text , comment . is Line Comment , comment . index , file Info ) ; } } 
function ( force Escaped ) { var str , index = parser Input . i , is Escaped = false ; parser Input . save ( ) ; if ( parser Input . $char ( ' ~ ' ) ) { is Escaped = true ; } else if ( force Escaped ) { parser Input . restore ( ) ; return ; } str = parser Input . $quoted ( ) ; if ( ! str ) { parser Input . restore ( ) ; return ; } parser Input . forget ( ) ; return new ( tree . Quoted ) ( str . char At ( 0 ) , str . substr ( 1 , str . length - 2 ) , is Escaped , index , file Info ) ; } 
function ( ) { var k = parser Input . $char ( ' % ' ) | | parser Input . $re ( / ^ \ [ ? ( ? : [ \w - ] | \ \ ( ? : [A -Fa -f 0 - 9 ] { 1 , 6 } ? | [ ^A -Fa -f 0 - 9 ] ) ) + \ ] ? / ) ; if ( k ) { return tree . Color . from Keyword ( k ) | | new ( tree . Keyword ) ( k ) ; } } 
function ( ) { var name , args , func , index = parser Input . i ; 
function ( name ) { return { alpha : f ( parsers . ie Alpha , true ) , boolean : f ( condition ) , 'if ' : f ( condition ) } [ name . to Lower Case ( ) ] ; function f ( parse , stop ) { return { parse : parse , 
function ( ) { var key , value ; parser Input . save ( ) ; key = parser Input . $re ( / ^ \w + ( ? = \s ? = ) / i ) ; if ( ! key ) { parser Input . restore ( ) ; return ; } if ( ! parser Input . $char ( ' = ' ) ) { parser Input . restore ( ) ; return ; } value = parsers . entity ( ) ; if ( value ) { parser Input . forget ( ) ; return new ( tree . Assignment ) ( key , value ) ; } else { parser Input . restore ( ) ; } } 
function ( ) { var value , index = parser Input . i ; parser Input . auto Comment Absorb = false ; if ( ! parser Input . $str ( 'url ( ' ) ) { parser Input . auto Comment Absorb = true ; return ; } value = this . quoted ( ) | | this . variable ( ) | | this . property ( ) | | parser Input . $re ( / ^ ( ? : ( ? : \ \ [ \ ( \ ) ' " ] ) | [ ^ \ ( \ ) ' " ] ) + / ) | | ' ' ; parser Input . auto Comment Absorb = true ; expect Char ( ' ) ' ) ; return new ( tree . URL ) ( ( value . value ! = null | | value instanceof tree . Variable | | value instanceof tree . Property ) ? value : new ( tree . Anonymous ) ( value , index ) , index , file Info ) ; } 
function ( ) { var ch , name , index = parser Input . i ; parser Input . save ( ) ; if ( parser Input . current Char ( ) = = = ' @ ' & & ( name = parser Input . $re ( / ^ @ @ ? [ \w - ] + / ) ) ) { ch = parser Input . current Char ( ) ; if ( ch = = = ' ( ' | | ch = = = ' [ ' & & ! parser Input . prev Char ( ) . match ( / ^ \s / ) ) { 
function ( ) { var curly , index = parser Input . i ; if ( parser Input . current Char ( ) = = = ' @ ' & & ( curly = parser Input . $re ( / ^ @ \ { ( [ \w - ] + ) \ } / ) ) ) { return new ( tree . Variable ) ( ' @ ' + curly [ 1 ] , index , file Info ) ; } } 
function ( ) { var name , index = parser Input . i ; if ( parser Input . current Char ( ) = = = ' $ ' & & ( name = parser Input . $re ( / ^ \ $ [ \w - ] + / ) ) ) { return new ( tree . Property ) ( name , index , file Info ) ; } } 
function ( ) { var curly , index = parser Input . i ; if ( parser Input . current Char ( ) = = = ' $ ' & & ( curly = parser Input . $re ( / ^ \ $ \ { ( [ \w - ] + ) \ } / ) ) ) { return new ( tree . Property ) ( ' $ ' + curly [ 1 ] , index , file Info ) ; } } 
function ( ) { var rgb ; if ( parser Input . current Char ( ) = = = ' # ' & & ( rgb = parser Input . $re ( / ^ # ( [A -Fa -f 0 - 9 ] { 8 } | [A -Fa -f 0 - 9 ] { 6 } | [A -Fa -f 0 - 9 ] { 3 , 4 } ) / ) ) ) { return new ( tree . Color ) ( rgb [ 1 ] , undefined , rgb [ 0 ] ) ; } } 
function ( ) { if ( parser Input . peek Not Numeric ( ) ) { return ; } var value = parser Input . $re ( / ^ ( [ + - ] ? \d * \ . ? \d + ) ( % | [a -z _ ] + ) ? / i ) ; if ( value ) { return new ( tree . Dimension ) ( value [ 1 ] , value [ 2 ] ) ; } } 
function ( ) { var js , index = parser Input . i ; parser Input . save ( ) ; var escape = parser Input . $char ( ' ~ ' ) ; var js Quote = parser Input . $char ( ' ` ' ) ; if ( ! js Quote ) { parser Input . restore ( ) ; return ; } js = parser Input . $re ( / ^ [ ^ ` ] * ` / ) ; if ( js ) { parser Input . forget ( ) ; return new ( tree . Java Script ) ( js . substr ( 0 , js . length - 1 ) , Boolean ( escape ) , index , file Info ) ; } parser Input . restore ( 'invalid javascript definition ' ) ; } 
function ( parsed Name ) { var lookups , important , i = parser Input . i , in Value = ! ! parsed Name , name = parsed Name ; parser Input . save ( ) ; if ( name | | ( parser Input . current Char ( ) = = = ' @ ' & & ( name = parser Input . $re ( / ^ ( @ [ \w - ] + ) ( \ ( \s * \ ) ) ? / ) ) ) ) { lookups = this . mixin . rule Lookups ( ) ; if ( ! lookups & & ( ( in Value & & parser Input . $str ( ' ( ) ' ) ! = = ' ( ) ' ) | | ( name [ 2 ] ! = = ' ( ) ' ) ) ) { parser Input . restore ( 'Missing \ ' [ . . . ] \ ' lookup in variable call ' ) ; return ; } if ( ! in Value ) { name = name [ 1 ] ; } if ( lookups & & parsers . important ( ) ) { important = true ; } var call = new tree . Variable Call ( name , i , file Info ) ; if ( ! in Value & & parsers . end ( ) ) { parser Input . forget ( ) ; return call ; } else { parser Input . forget ( ) ; return new tree . Namespace Value ( call , lookups , important , i , file Info ) ; } } parser Input . restore ( ) ; } 
function ( in Value , get Lookup ) { var s = parser Input . current Char ( ) , important = false , lookups , index = parser Input . i , elements , args , has Parens ; if ( s ! = = ' . ' & & s ! = = ' # ' ) { return ; } parser Input . save ( ) ; 
function ( ) { var elements , e , c , elem , elem Index , re = / ^ [ # . ] ( ? : [ \w - ] | \ \ ( ? : [A -Fa -f 0 - 9 ] { 1 , 6 } ? | [ ^A -Fa -f 0 - 9 ] ) ) + / ; while ( true ) { elem Index = parser Input . i ; e = parser Input . $re ( re ) ; if ( ! e ) { break ; } elem = new ( tree . Element ) ( c , e , false , elem Index , file Info ) ; if ( elements ) { elements . push ( elem ) ; } else { elements = [ elem ] ; } c = parser Input . $char ( ' > ' ) ; } return elements ; } 
function ( ) { var name , params = [ ] , match , ruleset , cond , variadic = false ; if ( ( parser Input . current Char ( ) ! = = ' . ' & & parser Input . current Char ( ) ! = = ' # ' ) | | parser Input . peek ( / ^ [ ^ { ] * \ } / ) ) { return ; } parser Input . save ( ) ; match = parser Input . $re ( / ^ ( [ # . ] ( ? : [ \w - ] | \ \ ( ? : [A -Fa -f 0 - 9 ] { 1 , 6 } ? | [ ^A -Fa -f 0 - 9 ] ) ) + ) \s * \ ( / ) ; if ( match ) { name = match [ 1 ] ; var arg Info = this . args ( false ) ; params = arg Info . args ; variadic = arg Info . variadic ; 
function ( ) { var entities = this . entities ; return this . comment ( ) | | entities . literal ( ) | | entities . variable ( ) | | entities . url ( ) | | entities . property ( ) | | entities . call ( ) | | entities . keyword ( ) | | this . mixin . call ( true ) | | entities . javascript ( ) ; } 
function ( ) { var value ; 
function ( ) { var e , c , v , index = parser Input . i ; c = this . combinator ( ) ; e = parser Input . $re ( / ^ ( ? : \d + \ . \d + | \d + ) % / ) | | parser Input . $re ( / ^ ( ? : [ . # ] ? | : * ) ( ? : [ \w - ] | [ ^ \x 0 0 - \x 9f ] | \ \ ( ? : [A -Fa -f 0 - 9 ] { 1 , 6 } ? | [ ^A -Fa -f 0 - 9 ] ) ) + / ) | | parser Input . $char ( ' * ' ) | | parser Input . $char ( ' & ' ) | | this . attribute ( ) | | parser Input . $re ( / ^ \ ( [ ^ & ( ) @ ] + \ ) / ) | | parser Input . $re ( / ^ [ \ . # : ] ( ? = @ ) / ) | | this . entities . variable Curly ( ) ; if ( ! e ) { parser Input . save ( ) ; if ( parser Input . $char ( ' ( ' ) ) { if ( ( v = this . selector ( false ) ) & & parser Input . $char ( ' ) ' ) ) { e = new ( tree . Paren ) ( v ) ; parser Input . forget ( ) ; } else { parser Input . restore ( 'Missing closing \ ' ) \ ' ' ) ; } } else { parser Input . forget ( ) ; } } if ( e ) { return new ( tree . Element ) ( c , e , e instanceof tree . Variable , index , file Info ) ; } } 
function ( ) { var c = parser Input . current Char ( ) ; if ( c = = = ' / ' ) { parser Input . save ( ) ; var slashed Combinator = parser Input . $re ( / ^ \ / [a -z ] + \ / / i ) ; if ( slashed Combinator ) { parser Input . forget ( ) ; return new ( tree . Combinator ) ( slashed Combinator ) ; } parser Input . restore ( ) ; } if ( c = = = ' > ' | | c = = = ' + ' | | c = = = ' ~ ' | | c = = = ' | ' | | c = = = ' ^ ' ) { parser Input . i + + ; if ( c = = = ' ^ ' & & parser Input . current Char ( ) = = = ' ^ ' ) { c = ' ^ ^ ' ; parser Input . i + + ; } while ( parser Input . is Whitespace ( ) ) { parser Input . i + + ; } return new ( tree . Combinator ) ( c ) ; } else if ( parser Input . is Whitespace ( - 1 ) ) { return new ( tree . Combinator ) ( ' ' ) ; } else { return new ( tree . Combinator ) ( null ) ; } } 
function ( is Less ) { var index = parser Input . i , elements , extend List , c , e , all Extends , when , condition ; is Less = is Less ! = = false ; while ( ( is Less & & ( extend List = this . extend ( ) ) ) | | ( is Less & & ( when = parser Input . $str ( 'when ' ) ) ) | | ( e = this . element ( ) ) ) { if ( when ) { condition = expect ( this . conditions , 'expected condition ' ) ; } else if ( condition ) { error ( 'CSS guard can only be used at the end of selector ' ) ; } else if ( extend List ) { if ( all Extends ) { all Extends = all Extends . concat ( extend List ) ; } else { all Extends = extend List ; } } else { if ( all Extends ) { error ( 'Extend can only be used at the end of selector ' ) ; } c = parser Input . current Char ( ) ; if ( elements ) { elements . push ( e ) ; } else { elements = [ e ] ; } e = null ; } if ( c = = = ' { ' | | c = = = ' } ' | | c = = = ' ; ' | | c = = = ' , ' | | c = = = ' ) ' ) { break ; } } if ( elements ) { return new ( tree . Selector ) ( elements , all Extends , condition , index , file Info ) ; } if ( all Extends ) { error ( 'Extend must be used to extend a selector , it cannot be used on its own ' ) ; } } 
function ( ) { var selectors , rules , debug Info ; parser Input . save ( ) ; if ( context . dump Line Numbers ) { debug Info = get Debug Info ( parser Input . i ) ; } selectors = this . selectors ( ) ; if ( selectors & & ( rules = this . block ( ) ) ) { parser Input . forget ( ) ; var ruleset = new ( tree . Ruleset ) ( selectors , rules , context . strict Imports ) ; if ( context . dump Line Numbers ) { ruleset . debug Info = debug Info ; } return ruleset ; } else { parser Input . restore ( ) ; } } 
function ( until Tokens ) { var i , e , done , value , tok = until Tokens | | ' ; ' , index = parser Input . i , result = [ ] ; function test Current Char ( ) { var char = parser Input . current Char ( ) ; if ( typeof tok = = = 'string ' ) { return char = = = tok ; } else { return tok . test ( char ) ; } } if ( test Current Char ( ) ) { return ; } value = [ ] ; do { e = this . comment ( ) ; if ( e ) { value . push ( e ) ; continue ; } e = this . entity ( ) ; if ( e ) { value . push ( e ) ; } } while ( e ) ; done = test Current Char ( ) ; if ( value . length > 0 ) { value = new ( tree . Expression ) ( value ) ; if ( done ) { return value ; } else { result . push ( value ) ; } 
function ( ) { var path , features , index = parser Input . i ; var dir = parser Input . $re ( / ^ @import ? \s + / ) ; if ( dir ) { var options = ( dir ? this . import Options ( ) : null ) | | { } ; if ( ( path = this . entities . quoted ( ) | | this . entities . url ( ) ) ) { features = this . media Features ( ) ; if ( ! parser Input . $char ( ' ; ' ) ) { parser Input . i = index ; error ( 'missing semi -colon or unrecognised media features on import ' ) ; } features = features & & new ( tree . Value ) ( features ) ; return new ( tree . Import ) ( path , features , options , index , file Info ) ; } else { parser Input . i = index ; error ( 'malformed import statement ' ) ; } } } 
function ( ) { var path , args , options , index = parser Input . i , dir = parser Input . $re ( / ^ @plugin ? \s + / ) ; if ( dir ) { args = this . plugin Args ( ) ; if ( args ) { options = { plugin Args : args , is Plugin : true } ; } else { options = { is Plugin : true } ; } if ( ( path = this . entities . quoted ( ) | | this . entities . url ( ) ) ) { if ( ! parser Input . $char ( ' ; ' ) ) { parser Input . i = index ; error ( 'missing semi -colon on @plugin ' ) ; } return new ( tree . Import ) ( path , null , options , index , file Info ) ; } else { parser Input . i = index ; error ( 'malformed @plugin statement ' ) ; } } } 
function ( ) { var index = parser Input . i , name , value , rules , non Vendor Specific Name , has Identifier , has Expression , has Unknown , has Block = true , is Rooted = true ; if ( parser Input . current Char ( ) ! = = ' @ ' ) { return ; } value = this [ 'import ' ] ( ) | | this . plugin ( ) | | this . media ( ) ; if ( value ) { return value ; } parser Input . save ( ) ; name = parser Input . $re ( / ^ @ [a -z - ] + / ) ; if ( ! name ) { return ; } non Vendor Specific Name = name ; if ( name . char At ( 1 ) = = ' - ' & & name . index Of ( ' - ' , 2 ) > 0 ) { non Vendor Specific Name = ' @ ' + name . slice ( name . index Of ( ' - ' , 2 ) + 1 ) ; } switch ( non Vendor Specific Name ) { case ' @charset ' : has Identifier = true ; has Block = false ; break ; case ' @namespace ' : has Expression = true ; has Block = false ; break ; case ' @keyframes ' : case ' @counter -style ' : has Identifier = true ; break ; case ' @document ' : case ' @supports ' : has Unknown = true ; is Rooted = false ; break ; default : has Unknown = true ; break ; } parser Input . comment Store . length = 0 ; if ( has Identifier ) { value = this . entity ( ) ; if ( ! value ) { error ( 'expected ' + name + ' identifier ' ) ; } } else if ( has Expression ) { value = this . expression ( ) ; if ( ! value ) { error ( 'expected ' + name + ' expression ' ) ; } } else if ( has Unknown ) { value = this . permissive Value ( / ^ [ { ; ] / ) ; has Block = ( parser Input . current Char ( ) = = = ' { ' ) ; if ( ! value ) { if ( ! has Block & & parser Input . current Char ( ) ! = = ' ; ' ) { error ( name + ' rule is missing block or ending semi -colon ' ) ; } } else if ( ! value . value ) { value = null ; } } if ( has Block ) { rules = this . block Ruleset ( ) ; } if ( rules | | ( ! has Block & & value & & parser Input . $char ( ' ; ' ) ) ) { parser Input . forget ( ) ; return new ( tree . At Rule ) ( name , value , rules , index , file Info , context . dump Line Numbers ? get Debug Info ( index ) : null , is Rooted ) ; } parser Input . restore ( 'at -rule options not recognised ' ) ; } 
function ( ) { var e , expressions = [ ] , index = parser Input . i ; do { e = this . expression ( ) ; if ( e ) { expressions . push ( e ) ; if ( ! parser Input . $char ( ' , ' ) ) { break ; } } } while ( e ) ; if ( expressions . length > 0 ) { return new ( tree . Value ) ( expressions , index ) ; } } 
function ( ) { var entities = this . entities , negate ; if ( parser Input . peek ( / ^ - [ @ \ $ \ ( ] / ) ) { negate = parser Input . $char ( ' - ' ) ; } var o = this . sub ( ) | | entities . dimension ( ) | | entities . color ( ) | | entities . variable ( ) | | entities . property ( ) | | entities . call ( ) | | entities . quoted ( true ) | | entities . color Keyword ( ) | | entities . mixin Lookup ( ) ; if ( negate ) { o . parens In Op = true ; o = new ( tree . Negative ) ( o ) ; } return o ; } 
function ( ) { var entities = [ ] , e , delim , index = parser Input . i ; do { e = this . comment ( ) ; if ( e ) { entities . push ( e ) ; continue ; } e = this . addition ( ) | | this . entity ( ) ; if ( e ) { entities . push ( e ) ; 
function ( color 1 , color 2 , weight ) { if ( ! color 1 . to HSL | | ! color 2 . to HSL ) { console . log ( color 2 . type ) ; console . dir ( color 2 ) ; } if ( ! weight ) { weight = new Dimension ( 5 0 ) ; } var p = weight . value / 1 0 0 . 0 ; var w = p * 2 - 1 ; var a = color 1 . to HSL ( ) . a - color 2 . to HSL ( ) . a ; var w 1 = ( ( ( w * a = = - 1 ) ? w : ( w + a ) / ( 1 + w * a ) ) + 1 ) / 2 . 0 ; var w 2 = 1 - w 1 ; var rgb = [ color 1 . rgb [ 0 ] * w 1 + color 2 . rgb [ 0 ] * w 2 , color 1 . rgb [ 1 ] * w 1 + color 2 . rgb [ 1 ] * w 2 , color 1 . rgb [ 2 ] * w 1 + color 2 . rgb [ 2 ] * w 2 ] ; var alpha = color 1 . alpha * p + color 2 . alpha * ( 1 - p ) ; return new Color ( rgb , alpha ) ; } 
function ( name , args , index , current File Info ) { this . name = name ; this . args = args ; this . calc = name = = = 'calc ' ; this . _index = index ; this . _file Info = current File Info ; } 
function ( less ) { this . less = less ; this . require = function ( prefix ) { prefix = path . dirname ( prefix ) ; return function ( id ) { var str = id . substr ( 0 , 2 ) ; if ( str = = = ' . . ' | | str = = = ' . / ' ) { return require ( path . join ( prefix , id ) ) ; } else { return require ( id ) ; } } ; } ; } 
function ( path , features , options , index , current File Info , visibility Info ) { this . options = options ; this . _index = index ; this . _file Info = current File Info ; this . path = path ; this . features = features ; this . allow Root = true ; if ( this . options . less ! = = undefined | | this . options . inline ) { this . css = ! this . options . less | | this . options . inline ; } else { var path Value = this . get Path ( ) ; if ( path Value & & / [ # \ . \ & \ ? ]css ( [ \ ? ; ] . * ) ? $ / . test ( path Value ) ) { this . css = true ; } } this . copy Visibility Info ( visibility Info ) ; this . set Parent ( this . features , this ) ; this . set Parent ( this . path , this ) ; } 
function ( less , context , root File Info ) { this . less = less ; this . root Filename = root File Info . filename ; this . paths = context . paths | | [ ] ; 
function has Fake Ruleset ( at Rule Node ) { var body Rules = at Rule Node . rules ; return body Rules . length = = = 1 & & ( ! body Rules [ 0 ] . paths | | body Rules [ 0 ] . paths . length = = = 0 ) ; } 
function bind ( func , this Arg ) { var curry Args = Array . prototype . slice . call ( arguments , 2 ) ; return function ( ) { var args = curry Args . concat ( Array . prototype . slice . call ( arguments , 0 ) ) ; return func . apply ( this Arg , args ) ; } ; } 
function ( less ) { this . less = less ; this . visitors = [ ] ; this . pre Processors = [ ] ; this . post Processors = [ ] ; this . installed Plugins = [ ] ; this . file Managers = [ ] ; this . iterator = - 1 ; this . plugin Cache = { } ; this . Loader = new less . Plugin Loader ( less ) ; } 
function ( rgb , a , original Form ) { var self = this ; 
function get Node Transitions ( old Data , next Data ) { const old Data Keyed = old Data & & get Keyed Data ( old Data ) ; const next Data Keyed = next Data & & get Keyed Data ( next Data ) ; return { entering : old Data Keyed & & get Keyed Data Difference ( next Data Keyed , old Data Keyed ) , exiting : next Data Keyed & & get Keyed Data Difference ( old Data Keyed , next Data Keyed ) } ; } 
function get Initial Transition State ( old Children , next Children ) { let nodes Will Exit = false ; let nodes Will Enter = false ; const get Transition = ( old Child , new Child ) = > { if ( ! new Child | | old Child . type ! = = new Child . type ) { return { } ; } const { entering , exiting } = get Node Transitions ( get Child Data ( old Child ) , get Child Data ( new Child ) ) | | { } ; nodes Will Exit = nodes Will Exit | | ! ! exiting ; nodes Will Enter = nodes Will Enter | | ! ! entering ; return { entering : entering | | false , exiting : exiting | | false } ; } ; const get Transitions From Children = ( old , next ) = > { return old . map ( ( child , idx ) = > { if ( child & & child . props & & child . props . children & & next [ idx ] ) { return get Transitions From Children ( React . Children . to Array ( old [ idx ] . props . children ) , React . Children . to Array ( next [ idx ] . props . children ) ) ; } 
function get Child Before Load ( animate , child , data , cb ) { animate = assign ( { } , animate , { on End : cb } ) ; if ( animate & & animate . on Load & & ! animate . on Load . duration ) { return { animate , data } ; } const before = animate . on Load & & animate . on Load . before ? animate . on Load . before : identity ; 
function get Child On Load ( animate , data , cb ) { animate = assign ( { } , animate , { on End : cb } ) ; if ( animate & & animate . on Load & & ! animate . on Load . duration ) { return { animate , data } ; } const after = animate . on Load & & animate . on Load . after ? animate . on Load . after : identity ; 
function get Child Props On Exit ( animate , child , data , exiting Nodes , cb ) { 
function get Child Props Before Enter ( animate , child , data , entering Nodes , cb ) { if ( entering Nodes ) { 
function get Child Props On Enter ( animate , data , entering Nodes , cb ) { 
function get Transition Props Factory ( props , state , set State ) { const nodes Will Exit = state & & state . nodes Will Exit ; const nodes Will Enter = state & & state . nodes Will Enter ; const nodes Should Enter = state & & state . nodes Should Enter ; const nodes Should Load = state & & state . nodes Should Load ; const nodes Done Load = state & & state . nodes Done Load ; const children Transitions = ( state & & state . children Transitions ) | | [ ] ; const transition Durations = { enter : props . animate & & props . animate . on Enter & & props . animate . on Enter . duration , exit : props . animate & & props . animate . on Exit & & props . animate . on Exit . duration , load : props . animate & & props . animate . on Load & & props . animate . on Load . duration , move : props . animate & & props . animate . duration } ; const on Load = ( child , data , animate ) = > { if ( nodes Should Load ) { return get Child On Load ( animate , data , ( ) = > { set State ( { nodes Should Load : false , nodes Done Load : true } ) ; } ) ; } return get Child Before Load ( animate , child , data , ( ) = > { set State ( { nodes Done Load : true } ) ; } ) ; } ; 
function get Cartesian Range ( props , axis ) { 
function omit ( original Object , keys = [ ] ) { 
function to New Name ( scale ) { 
function get Calculated Props ( props , child Components ) { const role = "group " ; props = Helpers . modify Props ( props , fallback Props , role ) ; const style = Wrapper . get Style ( props . theme , props . style , role ) ; const { offset , color Scale , color , polar , horizontal } = props ; const categories = Wrapper . get Categories ( props , child Components ) ; const datasets = Wrapper . get Data From Children ( props ) ; const domain = { x : Wrapper . get Domain ( assign ( { } , props , { categories } ) , "x " , child Components ) , y : Wrapper . get Domain ( assign ( { } , props , { categories } ) , "y " , child Components ) } ; const range = { x : Helpers . get Range ( props , "x " ) , y : Helpers . get Range ( props , "y " ) } ; const base Scale = { x : Scale . get Scale From Props ( props , "x " ) | | Wrapper . get Scale ( props , "x " ) , y : Scale . get Scale From Props ( props , "y " ) | | Wrapper . get Scale ( props , "y " ) } ; const scale = { x : base Scale . x . domain ( domain . x ) . range ( props . horizontal ? range . y : range . x ) , y : base Scale . y . domain ( domain . y ) . range ( props . horizontal ? range . x : range . y ) } ; const origin = polar ? props . origin : Helpers . get Polar Origin ( props ) ; const padding = Helpers . get Padding ( props ) ; return { datasets , categories , range , domain , horizontal , scale , style , color Scale , color , offset , origin , padding } ; } 
function clean Domain ( domain , props , axis ) { const scale Type = Scale . get Scale Type ( props , axis ) ; if ( scale Type ! = = "log " ) { return domain ; } const rules = ( dom ) = > { const almost Zero = dom [ 0 ] < 0 | | dom [ 1 ] < 0 ? - 1 / Number . MAX _SAFE _INTEGER : 1 / Number . MAX _SAFE _INTEGER ; const domain One = dom [ 0 ] = = = 0 ? almost Zero : dom [ 0 ] ; const domain Two = dom [ 1 ] = = = 0 ? almost Zero : dom [ 1 ] ; return [ domain One , domain Two ] ; } ; return rules ( domain ) ; } 
function pad Domain ( domain , props , axis ) { if ( ! props . domain Padding ) { return domain ; } const min Domain = get Min From Props ( props , axis ) ; const max Domain = get Max From Props ( props , axis ) ; const padding = get Domain Padding ( props , axis ) ; if ( ! padding . left & & ! padding . right ) { return domain ; } const min = Collection . get Min Value ( domain ) ; const max = Collection . get Max Value ( domain ) ; const current Axis = Helpers . get Current Axis ( axis , props . horizontal ) ; const range = Helpers . get Range ( props , current Axis ) ; const range Extent = Math . abs ( range [ 0 ] - range [ 1 ] ) ; 
function create Domain Function ( get Domain From Data Function , format Domain Function ) { get Domain From Data Function = is Function ( get Domain From Data Function ) ? get Domain From Data Function : get Domain From Data ; format Domain Function = is Function ( format Domain Function ) ? format Domain Function : format Domain ; return ( props , axis ) = > { const props Domain = get Domain From Props ( props , axis ) ; if ( props Domain ) { return format Domain Function ( props Domain , props , axis ) ; } const categories = Data . get Categories ( props , axis ) ; const domain = categories ? get Domain From Categories ( props , axis , categories ) : get Domain From Data Function ( props , axis ) ; return domain ? format Domain Function ( domain , props , axis ) : undefined ; } ; } 
function format Domain ( domain , props , axis ) { return clean Domain ( pad Domain ( domain , props , axis ) , props , axis ) ; } 
function get Domain From Categories ( props , axis , categories ) { categories = categories | | Data . get Categories ( props , axis ) ; const { polar , start Angle = 0 , end Angle = 3 6 0 } = props ; if ( ! categories ) { return undefined ; } const min Domain = get Min From Props ( props , axis ) ; const max Domain = get Max From Props ( props , axis ) ; const string Array = Collection . contains Strings ( categories ) ? Data . get Strings From Categories ( props , axis ) : [ ] ; const string Map = string Array . length = = = 0 ? null : string Array . reduce ( ( memo , string , index ) = > { memo [ string ] = index + 1 ; return memo ; } , { } ) ; const category Values = string Map ? categories . map ( ( value ) = > string Map [ value ] ) : categories ; const min = min Domain ! = = undefined ? min Domain : Collection . get Min Value ( category Values ) ; const max = max Domain ! = = undefined ? max Domain : Collection . get Max Value ( category Values ) ; const category Domain = get Domain From Min Max ( min , max ) ; return polar & & axis = = = "x " & & Math . abs ( start Angle - end Angle ) = = = 3 6 0 ? get Symmetric Domain ( category Domain , category Values ) : category Domain ; } 
function get Domain From Data ( props , axis , dataset ) { dataset = dataset | | Data . get Data ( props ) ; const { polar , start Angle = 0 , end Angle = 3 6 0 } = props ; const min Domain = get Min From Props ( props , axis ) ; const max Domain = get Max From Props ( props , axis ) ; if ( dataset . length < 1 ) { return min Domain ! = = undefined & & max Domain ! = = undefined ? get Domain From Min Max ( min Domain , max Domain ) : undefined ; } const min = min Domain ! = = undefined ? min Domain : get Extreme From Data ( dataset , axis , "min " ) ; const max = max Domain ! = = undefined ? max Domain : get Extreme From Data ( dataset , axis , "max " ) ; const domain = get Domain From Min Max ( min , max ) ; return polar & & axis = = = "x " & & Math . abs ( start Angle - end Angle ) = = = 3 6 0 ? get Symmetric Domain ( domain , get Flat Data ( dataset , axis ) ) : domain ; } 
function get Domain From Min Max ( min , max ) { const get Single Point Domain = ( val ) = > { 
function get Domain From Props ( props , axis ) { const min Domain = get Min From Props ( props , axis ) ; const max Domain = get Max From Props ( props , axis ) ; if ( is Plain Object ( props . domain ) & & props . domain [ axis ] ) { return props . domain [ axis ] ; } else if ( Array . is Array ( props . domain ) ) { return props . domain ; } else if ( min Domain ! = = undefined & & max Domain ! = = undefined ) { return get Domain From Min Max ( min Domain , max Domain ) ; } return undefined ; } 
function get Domain With Zero ( props , axis ) { const props Domain = get Domain From Props ( props , axis ) ; if ( props Domain ) { return props Domain ; } const dataset = Data . get Data ( props ) ; const y 0Min = dataset . reduce ( ( min , datum ) = > ( datum . _y 0 < min ? datum . _y 0 : min ) , Infinity ) ; const ensure Zero = ( domain ) = > { if ( axis = = = "x " ) { return domain ; } const default Min = y 0Min ! = = Infinity ? y 0Min : 0 ; const max Domain Prop = get Max From Props ( props , axis ) ; const min Domain Prop = get Min From Props ( props , axis ) ; const max = max Domain Prop ! = = undefined ? max Domain Prop : Collection . get Max Value ( domain , default Min ) ; const min = min Domain Prop ! = = undefined ? min Domain Prop : Collection . get Min Value ( domain , default Min ) ; return get Domain From Min Max ( min , max ) ; } ; const get Domain Function = ( ) = > { return get Domain From Data ( props , axis , dataset ) ; } ; const format Domain Function = ( domain ) = > { return format Domain ( ensure Zero ( domain ) , props , axis ) ; } ; return create Domain Function ( get Domain Function , format Domain Function ) ( props , axis ) ; } 
function get Max From Props ( props , axis ) { if ( is Plain Object ( props . max Domain ) & & props . max Domain [ axis ] ! = = undefined ) { return props . max Domain [ axis ] ; } return typeof props . max Domain = = = "number " ? props . max Domain : undefined ; } 
function get Min From Props ( props , axis ) { if ( is Plain Object ( props . min Domain ) & & props . min Domain [ axis ] ! = = undefined ) { return props . min Domain [ axis ] ; } return typeof props . min Domain = = = "number " ? props . min Domain : undefined ; } 
function get Symmetric Domain ( domain , values ) { const processed Data = sorted Uniq ( values . sort ( ( a , b ) = > a - b ) ) ; const step = processed Data [ 1 ] - processed Data [ 0 ] ; return [ domain [ 0 ] , domain [ 1 ] + step ] ; } 
function is Domain Component ( component ) { const get Role = ( child ) = > { return child & & child . type ? child . type . role : " " ; } ; let role = get Role ( component ) ; if ( role = = = "portal " ) { const children = React . Children . to Array ( component . props . children ) ; role = children . length ? get Role ( children [ 0 ] ) : " " ; } const whitelist = [ "area " , "axis " , "bar " , "boxplot " , "candlestick " , "errorbar " , "group " , "line " , "pie " , "scatter " , "stack " , "voronoi " ] ; return includes ( whitelist , role ) ; } 
function parse Datum ( datum ) { const immutable Datum Whitelist = { error X : true , error Y : true } ; return Immutable . is Immutable ( datum ) ? Immutable . shallow To JS ( datum , immutable Datum Whitelist ) : datum ; } 
function generate Data Array ( props , axis ) { const props Domain = is Plain Object ( props . domain ) ? props . domain [ axis ] : props . domain ; const domain = props Domain | | Scale . get Base Scale ( props , axis ) . domain ( ) ; const samples = props . samples | | 1 ; const domain Max = Math . max ( . . . domain ) ; const domain Min = Math . min ( . . . domain ) ; const step = ( domain Max - domain Min ) / samples ; const values = range ( domain Min , domain Max , step ) ; return last ( values ) = = = domain Max ? values : values . concat ( domain Max ) ; } 
function sort Data ( dataset , sort Key , sort Order = "ascending " ) { if ( ! sort Key ) { return dataset ; } 
function clean Data ( dataset , props ) { const small Number = 1 / Number . MAX _SAFE _INTEGER ; const scale Type = { x : Scale . get Scale Type ( props , "x " ) , y : Scale . get Scale Type ( props , "y " ) } ; if ( scale Type . x ! = = "log " & & scale Type . y ! = = "log " ) { return dataset ; } const rules = ( datum , axis ) = > { return scale Type [ axis ] = = = "log " ? datum [ ` $ { axis } ` ] ! = = 0 : true ; } ; const sanitize = ( datum ) = > { const _x = rules ( datum , "x " ) ? datum . _x : small Number ; const _y = rules ( datum , "y " ) ? datum . _y : small Number ; const _y 0 = rules ( datum , "y 0 " ) ? datum . _y 0 : small Number ; return assign ( { } , datum , { _x , _y , _y 0 } ) ; } ; return dataset . map ( ( datum ) = > { if ( rules ( datum , "x " ) & & rules ( datum , "y " ) & & rules ( datum , "y 0 " ) ) { return datum ; } return sanitize ( datum ) ; } ) ; } 
function get Event Key ( key ) { 
function add Event Keys ( props , data ) { const has Event Key Accessor = ! ! props . event Key ; const event Key Accessor = get Event Key ( props . event Key ) ; return data . map ( ( datum ) = > { if ( datum . event Key ! = = undefined ) { return datum ; } else if ( has Event Key Accessor ) { const event Key = event Key Accessor ( datum ) ; return event Key ! = = undefined ? assign ( { event Key } , datum ) : datum ; } else { return datum ; } } ) ; } 
function create String Map ( props , axis ) { const strings From Axes = get Strings From Axes ( props , axis ) ; const strings From Categories = get Strings From Categories ( props , axis ) ; const strings From Data = get Strings From Data ( props , axis ) ; const all Strings = uniq ( [ . . . strings From Axes , . . . strings From Categories , . . . strings From Data ] ) ; return all Strings . length = = = 0 ? null : all Strings . reduce ( ( memo , string , index ) = > { memo [ string ] = index + 1 ; return memo ; } , { } ) ; } 
function downsample ( data , max Points , starting Index = 0 ) { 
function format Data ( dataset , props , expected Keys ) { const is Array Or Iterable = Array . is Array ( dataset ) | | Immutable . is Iterable ( dataset ) ; if ( ! is Array Or Iterable | | get Length ( dataset ) < 1 ) { return [ ] ; } const default Keys = [ "x " , "y " , "y 0 " ] ; expected Keys = Array . is Array ( expected Keys ) ? expected Keys : default Keys ; const string Map = { x : expected Keys . index Of ( "x " ) ! = = - 1 ? create String Map ( props , "x " ) : undefined , y : expected Keys . index Of ( "y " ) ! = = - 1 ? create String Map ( props , "y " ) : undefined , y 0 : expected Keys . index Of ( "y 0 " ) ! = = - 1 ? create String Map ( props , "y " ) : undefined } ; const create Accessor = ( name ) = > { return Helpers . create Accessor ( props [ name ] ! = = undefined ? props [ name ] : name ) ; } ; const accessor = expected Keys . reduce ( ( memo , type ) = > { memo [ type ] = create Accessor ( type ) ; return memo ; } , { } ) ; const preformatted Data = is Equal ( expected Keys , default Keys ) & & props . x = = = " _x " & & props . y = = = " _y " & & props . y 0 = = = " _y 0 " ; const data = preformatted Data ? dataset : dataset . reduce ( ( data Arr , datum , index ) = > { 
function generate Data ( props ) { const x Values = generate Data Array ( props , "x " ) ; const y Values = generate Data Array ( props , "y " ) ; const values = x Values . map ( ( x , i ) = > { return { x , y : y Values [ i ] } ; } ) ; return values ; } 
function get Categories ( props , axis ) { return props . categories & & ! Array . is Array ( props . categories ) ? props . categories [ axis ] : props . categories ; } 
function get Data ( props ) { return props . data ? format Data ( props . data , props ) : format Data ( generate Data ( props ) , props ) ; } 
function get Strings From Axes ( props , axis ) { const { tick Values , tick Format } = props ; let tick Value Array ; if ( ! tick Values | | ( ! Array . is Array ( tick Values ) & & ! tick Values [ axis ] ) ) { tick Value Array = tick Format & & Array . is Array ( tick Format ) ? tick Format : [ ] ; } else { tick Value Array = tick Values [ axis ] | | tick Values ; } return tick Value Array . filter ( ( val ) = > typeof val = = = "string " ) ; } 
function get Strings From Categories ( props , axis ) { if ( ! props . categories ) { return [ ] ; } const categories = get Categories ( props , axis ) ; const category Strings = categories & & categories . filter ( ( val ) = > typeof val = = = "string " ) ; return category Strings ? Collection . remove Undefined ( category Strings ) : [ ] ; } 
function get Strings From Data ( props , axis ) { const is Array Or Iterable = Array . is Array ( props . data ) | | Immutable . is Iterable ( props . data ) ; if ( ! is Array Or Iterable ) { return [ ] ; } const key = props [ axis ] = = = undefined ? axis : props [ axis ] ; const accessor = Helpers . create Accessor ( key ) ; 
function get Text ( props , datum , index ) { datum = datum | | { } ; if ( datum . label ! = = undefined ) { return datum . label ; } return Array . is Array ( props . labels ) ? props . labels [ index ] : props . labels ; } 
function find Axis Components ( child Components , predicate ) { predicate = predicate | | identity ; const find Axes = ( children ) = > { return children . reduce ( ( memo , child ) = > { if ( child . type & & child . type . role = = = "axis " & & predicate ( child ) ) { return memo . concat ( child ) ; } else if ( child . props & & child . props . children ) { return memo . concat ( find Axes ( React . Children . to Array ( child . props . children ) ) ) ; } return memo ; } , [ ] ) ; } ; return find Axes ( child Components ) ; } 
function get Axis Component ( child Components , axis ) { const matches Axis = ( component ) = > { const type = component . type . get Axis ( component . props ) ; return type = = = axis ; } ; return find Axis Components ( child Components , matches Axis ) [ 0 ] ; } 
function get Axis Components With Parent ( child Components , type ) { const matches Type = ( child ) = > { return type = = = "dependent " ? child . props . dependent Axis : ! child . props . dependent Axis ; } ; const find Components = ( children ) = > { return children . reduce ( ( memo , child ) = > { if ( child . type & & child . type . role = = = "axis " & & matches Type ( child ) ) { return memo . concat ( child ) ; } else if ( child . props & & child . props . children ) { const child Axis = find Components ( React . Children . to Array ( child . props . children ) ) ; return child Axis . length > 0 ? memo . concat ( child ) : memo ; } return memo ; } , [ ] ) ; } ; return find Components ( child Components ) ; } 
function get Domain From Data ( props , axis ) { const { polar , start Angle = 0 , end Angle = 3 6 0 } = props ; const tick Values = get Tick Array ( props ) ; if ( ! Array . is Array ( tick Values ) ) { return undefined ; } const min Domain = Domain . get Min From Props ( props , axis ) ; const max Domain = Domain . get Max From Props ( props , axis ) ; const tick Strings = string Ticks ( props ) ; const ticks = tick Values . map ( ( value ) = > + value ) ; const default Min = tick Strings ? 1 : Collection . get Min Value ( ticks ) ; const default Max = tick Strings ? tick Values . length : Collection . get Max Value ( ticks ) ; const min = min Domain ! = = undefined ? min Domain : default Min ; const max = max Domain ! = = undefined ? max Domain : default Max ; const initial Domain = Domain . get Domain From Min Max ( min , max ) ; const domain = polar & & axis = = = "x " & & Math . abs ( start Angle - end Angle ) = = = 3 6 0 ? Domain . get Symmetric Domain ( initial Domain , ticks ) : initial Domain ; if ( is Vertical ( props ) & & ! polar ) { domain . reverse ( ) ; } return domain ; } 
function get Domain ( props , axis ) { const inherent Axis = get Axis ( props ) ; if ( axis & & axis ! = = inherent Axis ) { return undefined ; } return Domain . create Domain Function ( get Domain From Data ) ( props , inherent Axis ) ; } 
function transform Target ( target , matrix , dimension ) { const { a , d , e , f } = matrix ; return dimension = = = "y " ? d * target + f : a * target + e ; } 
function get Parent SVG ( evt ) { if ( evt . native Event & & evt . native Event . identifier ! = = undefined ) { return undefined ; } const get Parent = ( target ) = > { if ( target . node Name = = = "svg " ) { return target ; } else { return target . parent Node ? get Parent ( target . parent Node ) : target ; } } ; return get Parent ( evt . target ) ; } 
function get Data Coordinates ( props , scale , x , y ) { const { polar , horizontal } = props ; if ( ! polar ) { return { x : horizontal ? scale . x . invert ( y ) : scale . x . invert ( x ) , y : horizontal ? scale . y . invert ( x ) : scale . y . invert ( y ) } ; } else { const origin = props . origin | | { x : 0 , y : 0 } ; const base X = x - origin . x ; const base Y = y - origin . y ; const radius = Math . abs ( base X * Math . sqrt ( 1 + Math . pow ( - base Y / base X , 2 ) ) ) ; const angle = ( - Math . atan 2 ( base Y , base X ) + Math . PI * 2 ) % ( Math . PI * 2 ) ; return { x : scale . x . invert ( angle ) , y : scale . y . invert ( radius ) } ; } } 
function fill Data ( props , datasets ) { const { fill In Missing Data } = props ; const x Map = datasets . reduce ( ( prev , dataset ) = > { dataset . for Each ( ( datum ) = > { prev [ datum . _x instanceof Date ? datum . _x . get Time ( ) : datum . _x ] = true ; } ) ; return prev ; } , { } ) ; const x Keys = keys ( x Map ) . map ( ( k ) = > + k ) ; const x Arr = order By ( x Keys ) ; return datasets . map ( ( dataset ) = > { let index Offset = 0 ; const is Date = dataset [ 0 ] & & dataset [ 0 ] . _x instanceof Date ; const filled In Data = x Arr . map ( ( x , index ) = > { x = + x ; const datum = dataset [ index - index Offset ] ; if ( datum ) { const x 1 = is Date ? datum . _x . get Time ( ) : datum . _x ; if ( x 1 = = = x ) { return datum ; } else { index Offset + + ; const y = fill In Missing Data ? 0 : null ; x = is Date ? new Date ( x ) : x ; return { x , y , _x : x , _y : y } ; } } else { const y = fill In Missing Data ? 0 : null ; x = is Date ? new Date ( x ) : x ; return { x , y , _x : x , _y : y } ; } } ) ; return filled In Data ; } ) ; } 
function add Layout Data ( props , datasets , index ) { const x Offset = props . x Offset | | 0 ; return datasets [ index ] . map ( ( datum ) = > { const y Offset = get Y 0 ( datum , index , datasets ) | | 0 ; return assign ( { } , datum , { _y 0 : ! ( datum . _y instanceof Date ) ? y Offset : y Offset ? new Date ( y Offset ) : datum . _y , _y 1 : datum . _y = = = null ? null : datum . _y instanceof Date ? new Date ( + datum . _y + + y Offset ) : datum . _y + y Offset , _x 1 : datum . _x = = = null ? null : datum . _x instanceof Date ? new Date ( + datum . _x + + x Offset ) : datum . _x + x Offset } ) ; } ) ; } 
function stack Data ( props , child Components ) { const data From Children = Wrapper . get Data From Children ( props , child Components ) ; const datasets = fill Data ( props , data From Children ) ; return datasets . map ( ( d , i ) = > add Layout Data ( props , datasets , i ) ) ; } 
function update State ( ) { history . replace State ( { left _top : split _left . scroll Top , right _top : split _right . scroll Top } , document . title ) ; } 
function _apply Remaining Default Options ( opts ) { opts . icon = opts . has Own Property ( 'icon ' ) ? opts . icon : ' \ue 9cb ' ; 
function _get Elements ( input ) { var elements ; if ( typeof input = = = 'string ' | | input instanceof String ) { 
function _add Baseline Styles ( ) { 
function get Claim Value ( entity , prop ) { if ( ! entity . claims ) return ; if ( ! entity . claims [ prop ] ) return ; let value , c ; for ( let i = 0 ; i < entity . claims [ prop ] . length ; i + + ) { c = entity . claims [ prop ] [ i ] ; if ( c . rank = = = 'deprecated ' ) continue ; if ( c . mainsnak . snaktype ! = = 'value ' ) continue ; value = c . mainsnak . datavalue . value ; if ( c . rank = = = 'preferred ' ) return value ; 
function check Twitter Rate Limit ( need ) { _twitter APIIndex = ( _twitter APIIndex + 1 ) % twitter APIs . length ; let twitter API = twitter APIs [ _twitter APIIndex ] ; let which = twitter APIs . length > 1 ? ( ' ' + ( _twitter APIIndex + 1 ) ) : ' ' ; return twitter API . get ( 'application /rate _limit _status ' , { resources : 'users ' } ) . then ( result = > { let now = Date . now ( ) / 1 0 0 0 ; let stats = result . resources . users [ ' /users /show / :id ' ] ; let reset Sec = Math . ceil ( stats . reset - now ) + 3 0 ; 
function fetch Twitter User Details ( qid , username ) { let target = _wikidata [ qid ] ; let twitter API = twitter APIs [ _twitter APIIndex ] ; return twitter API . get ( 'users /show ' , { screen _name : username } ) . then ( user = > { target . logos . twitter = user . profile _image _url _https . replace ( ' _normal ' , ' _bigger ' ) ; } ) . catch ( e = > { let msg = ` $ { username } $ { qid } ` + JSON . stringify ( e ) ; _errors . push ( msg ) ; console . error ( colors . red ( msg ) ) ; } ) ; } 
function check Wikipedia ( brands ) { Object . keys ( brands ) . for Each ( k = > { [ 'brand :wikipedia ' , 'operator :wikipedia ' ] . for Each ( t = > { let wp = brands [ k ] . tags [ t ] ; if ( wp & & ! / ^ [a -z _ ] { 2 , } : [ ^ _ ] * $ / . test ( wp ) ) { _wrong Format . push ( [ k , wp , t ] ) ; } } ) ; } ) ; } 
function filter Names ( ) { console . log ( ' \nfiltering names ' ) ; console . time ( colors . green ( 'names filtered ' ) ) ; 
function merge Brands ( ) { build Reverse Index ( brands ) ; check Brands ( ) ; console . log ( ' \nmerging brands ' ) ; console . time ( colors . green ( 'brands merged ' ) ) ; 
function check Ambiguous ( k ) { let i = k . index Of ( ' ~ ' ) ; if ( i ! = = - 1 ) { let stem = k . substring ( 0 , i ) ; ambiguous [ stem ] = true ; return true ; } return false ; } 
function build Reverse Index ( obj ) { let warn Collisions = [ ] ; for ( let k in obj ) { check Ambiguous ( k ) ; if ( obj [ k ] . match ) { for ( let i = obj [ k ] . match . length - 1 ; i > = 0 ; i - - ) { let match = obj [ k ] . match [ i ] ; check Ambiguous ( match ) ; if ( r Index [ match ] ) { warn Collisions . push ( [ r Index [ match ] , match ] ) ; warn Collisions . push ( [ k , match ] ) ; } r Index [ match ] = k ; } } } if ( warn Collisions . length ) { console . warn ( colors . yellow ( ' \n Warning - match name collisions ' ) ) ; console . warn ( 'To resolve these , make sure multiple entries do not contain the same "match " property . ' ) ; warn Collisions . for Each ( w = > console . warn ( colors . yellow ( ' " ' + w [ 0 ] + ' " ' ) + ' - > match ? - > ' + colors . yellow ( ' " ' + w [ 1 ] + ' " ' ) ) ) ; } } 
function check Brands ( ) { let warn Matched = [ ] ; let warn Duplicate = [ ] ; let warn Format Wikidata = [ ] ; let warn Format Wikipedia = [ ] ; let warn Missing Wikidata = [ ] ; let warn Missing Wikipedia = [ ] ; let warn Missing Logos = [ ] ; let warn Missing Tag = [ ] ; let seen = { } ; Object . keys ( brands ) . for Each ( k = > { let obj = brands [ k ] ; let parts = k . split ( ' | ' , 2 ) ; let tag = parts [ 0 ] ; let name = parts [ 1 ] ; 
function ( KEY , exec ) { var fn = ( _core . Object | | { } ) [ KEY ] | | Object [ KEY ] ; var exp = { } ; exp [ KEY ] = exec ( fn ) ; _export ( _export . S + _export . F * _fails ( function ( ) { fn ( 1 ) ; } ) , 'Object ' , exp ) ; } 
function ( TO _STRING ) { return function ( that , pos ) { var s = String ( _defined ( that ) ) ; var i = _to Integer ( pos ) ; var l = s . length ; var a , b ; if ( i < 0 | | i > = l ) return TO _STRING ? ' ' : undefined ; a = s . char Code At ( i ) ; return a < 0xd 8 0 0 | | a > 0xdbff | | i + 1 = = = l | | ( b = s . char Code At ( i + 1 ) ) < 0xdc 0 0 | | b > 0xdfff ? TO _STRING ? s . char At ( i ) : a : TO _STRING ? s . slice ( i , i + 2 ) : ( a - 0xd 8 0 0 < < 1 0 ) + ( b - 0xdc 0 0 ) + 0x 1 0 0 0 0 ; } ; } 
function ( ) { 
function ( it ) { if ( FREEZE & & meta . NEED & & is Extensible ( it ) & & ! _has ( it , META ) ) set Meta ( it ) ; return it ; } 
function ( O , proto ) { _an Object ( O ) ; if ( ! _is Object ( proto ) & & proto ! = = null ) throw Type Error ( proto + " : can 't set as prototype ! " ) ; } 
function Promise Capability ( C ) { var resolve , reject ; this . promise = new C ( function ( $ $resolve , $ $reject ) { if ( resolve ! = = undefined | | reject ! = = undefined ) throw Type Error ( 'Bad Promise constructor ' ) ; resolve = $ $resolve ; reject = $ $reject ; } ) ; this . resolve = _a Function ( resolve ) ; this . reject = _a Function ( reject ) ; } 
function then ( on Fulfilled , on Rejected ) { var reaction = new Promise Capability ( _species Constructor ( this , $Promise ) ) ; reaction . ok = typeof on Fulfilled = = 'function ' ? on Fulfilled : true ; reaction . fail = typeof on Rejected = = 'function ' & & on Rejected ; reaction . domain = is Node $ 1 ? process $ 2 . domain : undefined ; this . _c . push ( reaction ) ; if ( this . _a ) this . _a . push ( reaction ) ; if ( this . _s ) notify ( this , false ) ; return reaction . promise ; } 
function race ( iterable ) { var C = this ; var capability = new Promise Capability ( C ) ; var reject = capability . reject ; var result = _perform ( function ( ) { _for Of ( iterable , false , function ( promise ) { C . resolve ( promise ) . then ( capability . resolve , reject ) ; } ) ; } ) ; if ( result . e ) reject ( result . v ) ; return capability . promise ; } 
function is Object ( obj ) { 
function is Empty ( obj ) { if ( is Array ( obj ) ) { return obj . length = = = 0 ; } else if ( is Object ( obj ) ) { return _Object $keys ( obj ) . length = = = 0 ; } else { return ! obj ; } } 
function is Primitive ( val ) { return is Void ( val ) | | is Boolean ( val ) | | is String ( val ) | | is Number ( val ) ; } 
function is Node $ 2 ( obj ) { return ! ! ( ( typeof Node = = = 'undefined ' ? 'undefined ' : _typeof ( Node ) ) = = = 'object ' ? obj instanceof Node : obj & & ( typeof obj = = = 'undefined ' ? 'undefined ' : _typeof ( obj ) ) = = = 'object ' & & typeof obj . node Type = = = 'number ' & & typeof obj . node Name = = = 'string ' ) ; } 
function is Element ( obj ) { return ! ! ( ( typeof HTMLElement = = = 'undefined ' ? 'undefined ' : _typeof ( HTMLElement ) ) = = = 'object ' ? obj instanceof HTMLElement : obj & & ( typeof obj = = = 'undefined ' ? 'undefined ' : _typeof ( obj ) ) = = = 'object ' & & obj ! = = null & & obj . node Type = = = 1 & & typeof obj . node Name = = = 'string ' ) ; } 
function is Posterity Node ( parent , child ) { if ( ! is Node $ 2 ( parent ) | | ! is Node $ 2 ( child ) ) { return false ; } while ( child . parent Node ) { child = child . parent Node ; if ( child = = = parent ) { return true ; } } return false ; } 
function from ( array Like ) { var O = _to Object ( array Like ) ; var C = typeof this = = 'function ' ? this : Array ; var a Len = arguments . length ; var mapfn = a Len > 1 ? arguments [ 1 ] : undefined ; var mapping = mapfn ! = = undefined ; var index = 0 ; var iter Fn = core _get Iterator Method ( O ) ; var length , result , step , iterator ; if ( mapping ) mapfn = _ctx ( mapfn , a Len > 2 ? arguments [ 2 ] : undefined , 2 ) ; 
function gen Traversal Handler ( fn ) { var setter = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : function ( target , key , value ) { target [ key ] = value ; } ; 
function recursive Fn ( source , target , key ) { if ( is Array ( source ) | | is Object ( source ) ) { target = is Primitive ( target ) ? is Object ( source ) ? { } : [ ] : target ; for ( var _key in source ) { 
function deep Assign ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key 2 = 0 ; _key 2 < _len ; _key 2 + + ) { args [ _key 2 ] = arguments [ _key 2 ] ; } if ( args . length < 2 ) { throw new Error ( 'deep Assign accept two and more argument ' ) ; } for ( var i = args . length - 1 ; i > - 1 ; i - - ) { if ( is Primitive ( args [ i ] ) ) { throw new Type Error ( 'deep Assign only accept non primitive type ' ) ; } } var target = args . shift ( ) ; args . for Each ( function ( source ) { return _deep Assign ( source , target ) ; } ) ; return target ; } 
function camelize ( str , is Big ) { return str . replace ( / ( ^ | [ ^a -z A -Z ] + ) ( [a -z A -Z ] ) / g , function ( match , spilt , initials , index ) { return ! is Big & & index = = = 0 ? initials . to Lower Case ( ) : initials . to Upper Case ( ) ; } ) ; } 
function get Deep Property ( obj , keys ) { var _ref = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : { } , _ref $throw Error = _ref . throw Error , throw Error = _ref $throw Error = = = undefined ? false : _ref $throw Error , backup = _ref . backup ; if ( is String ( keys ) ) { keys = keys . split ( ' . ' ) ; } if ( ! is Array ( keys ) ) { throw new Type Error ( 'keys of get Deep Property must be string or Array <string > ' ) ; } var read = [ ] ; var target = obj ; for ( var i = 0 , len = keys . length ; i < len ; i + + ) { var key = keys [ i ] ; if ( is Void ( target ) ) { if ( throw Error ) { throw new Error ( 'obj ' + ( read . length > 0 ? ' . ' + read . join ( ' . ' ) : ' itself ' ) + ' is ' + target ) ; } else { return backup ; } } target = target [ key ] ; read . push ( key ) ; } return target ; } 
function trans Object Attr Into Array ( obj ) { var fn = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : function ( a , b ) { return + a - + b ; } ; return _Object $keys ( obj ) . sort ( fn ) . reduce ( function ( order , key ) { return order . concat ( obj [ key ] ) ; } , [ ] ) ; } 
function run Rejectable Queue ( queue ) { for ( var _len = arguments . length , args = Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key + + ) { args [ _key - 1 ] = arguments [ _key ] ; } return new _Promise ( function ( resolve , reject ) { var step = function step ( index ) { if ( index > = queue . length ) { resolve ( ) ; return ; } var result = is Function ( queue [ index ] ) ? queue [ index ] . apply ( queue , _to Consumable Array ( args ) ) : queue [ index ] ; if ( result = = = false ) return reject ( 'stop ' ) ; return _Promise . resolve ( result ) . then ( function ( ) { return step ( index + 1 ) ; } ) . catch ( function ( err ) { return reject ( err | | 'stop ' ) ; } ) ; } ; step ( 0 ) ; } ) ; } 
function run Stoppable Queue ( queue ) { for ( var _len 2 = arguments . length , args = Array ( _len 2 > 1 ? _len 2 - 1 : 0 ) , _key 2 = 1 ; _key 2 < _len 2 ; _key 2 + + ) { args [ _key 2 - 1 ] = arguments [ _key 2 ] ; } var step = function step ( index ) { if ( index > = queue . length ) { return true ; } var result = is Function ( queue [ index ] ) ? queue [ index ] . apply ( queue , _to Consumable Array ( args ) ) : queue [ index ] ; if ( result = = = false ) return false ; return step ( + + index ) ; } ; return step ( 0 ) ; } 
function get Evt Type Cache ( target , type ) { var evt Id = target . _ _evt _id ; if ( ! evt Id ) { Object . define Property ( target , ' _ _evt _id ' , { writable : true , enumerable : false , configurable : true } ) ; evt Id = target . _ _evt _id = + + _evt Listener Cache . count ; } var type Cache Key = evt Id + ' _ ' + type ; var evt Type Cache = _evt Listener Cache [ type Cache Key ] ; if ( ! evt Type Cache ) { evt Type Cache = _evt Listener Cache [ type Cache Key ] = [ ] ; } return evt Type Cache ; } 
function emit Event Cache ( target , type , event Obj ) { var evt = _Object $create ( null ) ; evt . type = type ; evt . target = target ; if ( event Obj ) { _Object $assign ( evt , is Object ( event Obj ) ? event Obj : { data : event Obj } ) ; } get Evt Type Cache ( target , type ) . for Each ( function ( item ) { ( item [ 1 ] | | item [ 0 ] ) . apply ( target , [ evt ] ) ; } ) ; } 
function add Event Cache ( target , type , handler ) { var is Once = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : false ; var handler Wrap = arguments [ 4 ] ; if ( is Function ( is Once ) & & ! handler Wrap ) { handler Wrap = is Once ; is Once = undefined ; } var handlers = [ handler , undefined , is Once ] ; if ( is Once & & ! handler Wrap ) { handler Wrap = function handler Wrap ( ) { remove Event Cache ( target , type , handler , is Once ) ; for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } handler . apply ( target , args ) ; } ; } if ( handler Wrap ) { handlers [ 1 ] = handler Wrap ; } get Evt Type Cache ( target , type ) . push ( handlers ) ; } 
function remove Event Cache ( target , type , handler ) { var is Once = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : false ; var type Cache = get Evt Type Cache ( target , type ) ; if ( handler | | is Once ) { var handler Id = - 1 ; var handler Wrap = void 0 ; type Cache . find ( function ( item , i ) { if ( ( ! handler | | item [ 0 ] = = = handler ) & & ( ! is Once | | item [ 2 ] ) ) { handler Id = i ; handler Wrap = item [ 1 ] ; return true ; } } ) ; if ( handler Id ! = = - 1 ) { type Cache . splice ( handler Id , 1 ) ; } return handler Wrap ; } else { type Cache . length = 0 ; } } 
function set Attr ( el , attr Name , attr Val ) { if ( attr Val = = = undefined ) { el . remove Attribute ( attr Name ) ; } else { el . set Attribute ( attr Name , attr Val ) ; } } 
function add Class Name ( el , cls ) { if ( ! cls | | ! ( cls = cls . trim ( ) ) ) { return ; } var cls Arr = cls . split ( / \s + / ) ; if ( el . class List ) { cls Arr . for Each ( function ( c ) { return el . class List . add ( c ) ; } ) ; } else { var cur Cls = ' ' + ( el . class Name | | ' ' ) + ' ' ; cls Arr . for Each ( function ( c ) { cur Cls . index Of ( ' ' + c + ' ' ) = = = - 1 & & ( cur Cls + = ' ' + c ) ; } ) ; el . class Name = cur Cls . trim ( ) ; } } 
function remove Class Name ( el , cls ) { if ( ! cls | | ! ( cls = cls . trim ( ) ) ) { return ; } var cls Arr = cls . split ( / \s + / ) ; if ( el . class List ) { cls Arr . for Each ( function ( c ) { return el . class List . remove ( c ) ; } ) ; } else { var cur Cls = ' ' + el . class Name + ' ' ; cls Arr . for Each ( function ( c ) { var tar = ' ' + c + ' ' ; while ( cur Cls . index Of ( tar ) ! = = - 1 ) { cur Cls = cur Cls . replace ( tar , ' ' ) ; } } ) ; el . class Name = cur Cls . trim ( ) ; } } 
function remove Event ( el , type , handler ) { var once = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : false ; var capture = arguments . length > 4 & & arguments [ 4 ] ! = = undefined ? arguments [ 4 ] : false ; if ( capture ! = = undefined & & ! is Boolean ( capture ) & & supports Passive ) { capture = { passive : true } ; } if ( once ) { var handler Wrap = remove Event Cache ( el , type + ' _once ' , handler ) ; if ( handler Wrap ) { handler = handler Wrap ; } } el . remove Event Listener ( type , handler , capture ) ; } 
function add Event ( el , type , handler ) { var once = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : false ; var capture = arguments . length > 4 & & arguments [ 4 ] ! = = undefined ? arguments [ 4 ] : false ; if ( capture ! = = undefined & & ! is Boolean ( capture ) & & supports Passive ) { capture = { passive : true } ; } if ( once ) { var old Handler = handler ; handler = function ( ) { return function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } old Handler . apply ( this , args ) ; remove Event ( el , type , handler , once , capture ) ; } ; } ( ) ; add Event Cache ( el , type + ' _once ' , old Handler , handler ) ; } el . add Event Listener ( type , handler , capture ) ; } 
function add Delegate ( el , selector , type , handler ) { var capture = arguments . length > 4 & & arguments [ 4 ] ! = = undefined ? arguments [ 4 ] : false ; if ( capture ! = = undefined & & ! is Boolean ( capture ) & & supports Passive ) { capture = { passive : true } ; } var handler Wrap = function handler Wrap ( e ) { var target Els Arr = find Parents ( e . target | | e . src Element , el , true ) ; var target El Arr = query ( selector , el , true ) ; var ret El = void 0 ; if ( target El Arr . find ) { ret El = target El Arr . find ( function ( se El ) { return target Els Arr . find ( function ( tg El ) { return se El = = = tg El ; } ) ; } ) ; } else { 
function remove Delegate ( el , selector , type , handler ) { var capture = arguments . length > 4 & & arguments [ 4 ] ! = = undefined ? arguments [ 4 ] : false ; if ( capture ! = = undefined & & ! is Boolean ( capture ) & & supports Passive ) { capture = { passive : true } ; } var handler Wrap = remove Event Cache ( el , type + ' _delegate _ ' + selector , handler ) ; handler Wrap & & el . remove Event Listener ( type , handler Wrap , capture ) ; } 
function get Style ( el , key ) { return ( el . current Style | | document . default View . get Computed Style ( el , null ) ) [ key ] | | el . style [ key ] ; } 
function set Style ( el , key , val ) { if ( is Object ( key ) ) { for ( var k in key ) { set Style ( el , k , key [ k ] ) ; } } else { el . style [ key ] = val ; } } 
function query ( selector ) { var container = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : document ; var to Array = arguments [ 2 ] ; var ret Node List = container . query Selector All ( selector ) ; return to Array ? _Array $from ( ret Node List ) : ret Node List ; } 
function find Parents ( el ) { var end El = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : null ; var have El = arguments [ 2 ] ; var have End El = arguments [ 3 ] ; var ret Els = [ ] ; if ( have El ) { ret Els . push ( el ) ; } while ( el & & el . parent Node ! = = end El ) { el = el . parent Node ; el & & ret Els . push ( el ) ; } if ( have End El ) { ret Els . push ( end El ) ; } return ret Els ; } 
function get Legal Box ( _ref ) { var src = _ref . src , box = _ref . box ; if ( is String ( box ) & & box ) return box ; src = src . to Lower Case ( ) ; for ( var key in box Suffix Map ) { var suffix = box Suffix Map [ key ] ; if ( src . index Of ( suffix ) > - 1 ) return key ; } return 'native ' ; } 
function bind $ 1 ( fn , context ) { if ( fn . bind ) { return fn . bind ( context ) ; } else if ( fn . apply ) { return function _ _autobind _ _ ( ) { for ( var _len 2 = arguments . length , args = Array ( _len 2 ) , _key 3 = 0 ; _key 3 < _len 2 ; _key 3 + + ) { args [ _key 3 ] = arguments [ _key 3 ] ; } return fn . apply ( context , args ) ; } ; } else { return function _ _autobind _ _ ( ) { for ( var _len 3 = arguments . length , args = Array ( _len 3 ) , _key 4 = 0 ; _key 4 < _len 3 ; _key 4 + + ) { args [ _key 4 ] = arguments [ _key 4 ] ; } return fn . call . apply ( fn , [ context ] . concat ( _to Consumable Array ( args ) ) ) ; } ; } } 
function ( key ) { if ( ! _is Object ( key ) ) return false ; var data = get Weak ( key ) ; if ( data = = = true ) return uncaught Frozen Store ( _validate Collection ( this , NAME ) ) [ 'delete ' ] ( key ) ; return data & & _has ( data , this . _i ) & & delete data [ this . _i ] ; } 
function get ( key ) { if ( _is Object ( key ) ) { var data = get Weak ( key ) ; if ( data = = = true ) return uncaught Frozen Store ( _validate Collection ( this , WEAK _MAP ) ) . get ( key ) ; return data ? data [ this . _i ] : undefined ; } } 
function ( COLLECTION ) { _export ( _export . S , COLLECTION , { of : function of ( ) { var length = arguments . length ; var A = new Array ( length ) ; while ( length - - ) A [ length ] = arguments [ length ] ; return new this ( A ) ; } } ) ; } 
function is Descriptor ( desc ) { if ( ! desc | | ! desc . has Own Property ) { return false ; } var keys = [ 'value ' , 'initializer ' , 'get ' , 'set ' ] ; for ( var i = 0 , l = keys . length ; i < l ; i + + ) { if ( desc . has Own Property ( keys [ i ] ) ) { return true ; } } return false ; } 
function is Accessor Descriptor ( desc ) { return ! ! desc & & ( is Function ( desc . get ) | | is Function ( desc . set ) ) & & is Boolean ( desc . configurable ) & & is Boolean ( desc . enumerable ) & & desc . writable = = = undefined ; } 
function is Data Descriptor ( desc ) { return ! ! desc & & desc . has Own Property ( 'value ' ) & & is Boolean ( desc . configurable ) & & is Boolean ( desc . enumerable ) & & is Boolean ( desc . writable ) ; } 
function is Initializer Descriptor ( desc ) { return ! ! desc & & is Function ( desc . initializer ) & & is Boolean ( desc . configurable ) & & is Boolean ( desc . enumerable ) & & is Boolean ( desc . writable ) ; } 
function create Default Setter ( key ) { return function set ( new Value ) { _Object $define Property ( this , key , { configurable : true , writable : true , 
function compress One Arg Fn Array ( fns ) { var errmsg = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 'You must pass me an array of function ' ; if ( ! is Array ( fns ) | | fns . length < 1 ) { throw new Type Error ( errmsg ) ; } if ( fns . length = = = 1 ) { if ( ! is Function ( fns [ 0 ] ) ) { throw new Type Error ( errmsg ) ; } return fns [ 0 ] ; } return fns . reduce ( function ( prev , curr ) { if ( ! is Function ( curr ) | | ! is Function ( prev ) ) throw new Type Error ( errmsg ) ; return function ( value ) { return bind $ 1 ( curr , this ) ( bind $ 1 ( prev , this ) ( value ) ) ; } ; } ) ; } 
function get Bound Super ( obj , fn ) { if ( typeof _Weak Map = = = 'undefined ' ) { throw new Error ( 'Using @autobind on ' + fn . name + ' ( ) requires Weak Map support due to its use of super . ' + fn . name + ' ( ) ' ) ; } if ( ! map Store ) { map Store = new _Weak Map ( ) ; } if ( map Store . has ( obj ) = = = false ) { map Store . set ( obj , new _Weak Map ( ) ) ; } var super Store = map Store . get ( obj ) ; 
function autobind ( obj , prop , descriptor ) { if ( arguments . length = = = 1 ) return autobind Class ( ) ( obj ) ; var _ref = descriptor | | { } , fn = _ref . value , configurable = _ref . configurable ; if ( ! is Function ( fn ) ) { throw new Type Error ( ' @autobind can only be used on functions , not " ' + fn + ' " in ' + ( typeof fn = = = 'undefined ' ? 'undefined ' : _typeof ( fn ) ) + ' on property " ' + prop + ' " ' ) ; } var constructor = obj . constructor ; return { configurable : configurable , enumerable : false , get : function get ( ) { var _this = this ; var bound Fn = function bound Fn ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } return fn . call . apply ( fn , [ _this ] . concat ( _to Consumable Array ( args ) ) ) ; } ; 
function frozen ( obj , prop , descriptor ) { if ( descriptor = = = undefined ) { warn ( 'You are using @frozen on an undefined property . This property will become a frozen undefined forever , which is meaningless ' ) ; return { value : undefined , writable : false , enumerable : false , configurable : false } ; } descriptor . enumerable = false ; descriptor . configurable = false ; if ( is Accessor Descriptor ( descriptor ) ) { var _get = descriptor . get ; descriptor . set = undefined ; if ( ! is Function ( _get ) ) { warn ( 'You are using @frozen on one accessor descriptor without getter . This property will become a frozen undefined finally .Which maybe meaningless . ' ) ; return ; } return { get : function get ( ) { var value = bind $ 1 ( _get , this ) ( ) ; define Property $ 2 $ 1 ( this , prop , { value : value , writable : false , configurable : false , enumerable : false } ) ; return value ; } , set : undefined , configurable : false , enumerable : false } ; } 
function set ( value ) { if ( value = = = true ) { while ( waiting Queue . length > 0 ) { waiting Queue [ 0 ] ( ) ; waiting Queue . shift ( ) ; } } return value ; } 
function attr And Style Check ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } if ( args . length > 2 ) { return [ 'set ' ] . concat ( args ) ; } if ( args . length = = = 2 ) { if ( [ 'video ' , 'container ' , 'wrapper ' , 'video Element ' ] . index Of ( args [ 0 ] ) > - 1 ) { return [ 'get ' ] . concat ( args ) ; } return [ 'set ' , 'container ' ] . concat ( args ) ; } return [ 'get ' , 'container ' ] . concat ( args ) ; } 
function Plugin ( ) { var _ref = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : { } , id = _ref . id , name = _ref . name , _ref $level = _ref . level , level = _ref $level = = = undefined ? 0 : _ref $level , _ref $operable = _ref . operable , operable = _ref $operable = = = undefined ? true : _ref $operable , before Create = _ref . before Create , create = _ref . create , init = _ref . init , inited = _ref . inited , destroy = _ref . destroy , _ref $events = _ref . events , events = _ref $events = = = undefined ? { } : _ref $events , _ref $data = _ref . data , data = _ref $data = = = undefined ? { } : _ref $data , _ref $computed = _ref . computed , computed = _ref $computed = = = undefined ? { } : _ref $computed , _ref $methods = _ref . methods , methods = _ref $methods = = = undefined ? { } : _ref $methods , el = _ref . el , _ref $penetrate = _ref . penetrate , penetrate = _ref $penetrate = = = undefined ? false : _ref $penetrate , _ref $inner = _ref . inner , inner = _ref $inner = = = undefined ? true : _ref $inner , auto Focus = _ref . auto Focus , class Name = _ref . class Name ; var dispatcher = arguments [ 1 ] ; var option = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : { name : name } ; _class Call Check ( this , Plugin ) ; var _this = _possible Constructor Return ( this , ( Plugin . _ _proto _ _ | | _Object $get Prototype Of ( Plugin ) ) . call ( this ) ) ; _this . destroyed = false ; _this . VERSION = ' 0 . 1 1 . 0 ' ; _this . _ _operable = true ; _this . _ _level = 0 ; if ( is Empty ( dispatcher ) ) { Log . error ( 'Dispatcher .plugin ' , 'lack of dispatcher . Do you forget to pass arguments to super in plugin ? ' ) ; throw new Type Error ( 'lack of dispatcher ' ) ; } if ( ! is String ( id ) ) { throw new Type Error ( 'id of Plugin Config must be string ' ) ; } _this . _ _id = id ; _this . _ _dispatcher = dispatcher ; _this . $video Config = _this . _ _dispatcher . video Config ; _this . _ _wrap As Video ( _this . $video Config ) ; _this . before Create = _this . before Create | | before Create ; try { is Function ( _this . before Create ) & & _this . before Create ( { events : events , data : data , computed : computed , methods : methods } , option ) ; } catch ( error ) { _this . $throw Error ( error ) ; } * the create Function of plugin * @type {Function } * / _this . create = _this . create | | create ; _this . init = _this . init | | init ; _this . inited = _this . inited | | inited ; _this . destroy = _this . destroy | | destroy ; _this . $dom = _this . _ _dispatcher . dom . insert Plugin ( _this . _ _id , el , { penetrate : penetrate , inner : inner , class Name : class Name } ) ; _this . $auto Focus = is Boolean ( auto Focus ) ? auto Focus : inner ; * to tell us if the plugin can be operable , can be dynamic change * @type {boolean } * / _this . $operable = is Boolean ( option . operable ) ? option . operable : operable ; _this . _ _level = is Integer $ 2 ( option . level ) ? option . level : level ; _this . $config = option ; try { is Function ( _this . create ) & & _this . create ( ) ; } catch ( error ) { _this . $throw Error ( error ) ; } return _this ; } 
function Vessel ( dispatcher , target , config ) { var _this = this ; _class Call Check ( this , Vessel ) ; this . _ _dispatcher = dispatcher ; this . _ _target = target ; [ 'width ' , 'height ' , 'position ' , 'display ' ] . for Each ( function ( key ) { _Object $define Property ( _this , key , { get : function get ( ) { return this . _ _dispatcher . dom . get Style ( this . _ _target , key ) ; } , set : function set ( value ) { if ( is Number ( value ) ) { value = value + 'px ' ; } if ( ! is String ( value ) ) { throw new Error ( 'The value of ' + key + ' in ' + this . _ _target + 'Config must be string , but not ' + ( typeof value = = = 'undefined ' ? 'undefined ' : _typeof ( value ) ) + ' . ' ) ; } this . _ _dispatcher . dom . set Style ( this . _ _target , key , value ) ; 
function clear ( ) { for ( var that = _validate Collection ( this , NAME ) , data = that . _i , entry = that . _f ; entry ; entry = entry . n ) { entry . r = true ; if ( entry . p ) entry . p = entry . p . n = undefined ; delete data [ entry . i ] ; } that . _f = that . _l = undefined ; that [ SIZE ] = 0 ; } 
function get ( key ) { var entry = _collection Strong . get Entry ( _validate Collection ( this , MAP ) , key ) ; return entry & & entry . v ; } 
function set ( key , value ) { return _collection Strong . def ( _validate Collection ( this , MAP ) , key = = = 0 ? 0 : key , value ) ; } 
function get Event Target By Old Logic ( old Name ) { var target Key Reg = new Reg Exp ( ' ^ (c |w ) _ ' ) ; var matches = old Name . match ( target Key Reg ) ; if ( matches ) { var _name = old Name . replace ( target Key Reg , ' ' ) ; var _target = old Name . index Of ( 'c ' ) = = = 0 ? 'container ' : 'wrapper ' ; { Log . warn ( 'We no longer support event names like ' + old Name + ' . Please use ' + _name + ' and options like { target : \ ' ' + _target + ' \ ' } instead ' ) ; } return { name : _name , target : _target } ; } else if ( old Name = = = 'error ' ) { return { name : 'error ' , target : 'kernel ' } ; } return false ; } 
function destroy ( ) { for ( var _key in this . plugins ) { this . unuse ( _key ) ; } this . binder . destroy ( ) ; delete this . binder ; this . dom . destroy ( ) ; delete this . dom ; this . kernel . destroy ( ) ; delete this . kernel ; delete this . vm ; delete this . plugins ; delete this . order ; } 
function get SDLive Url ( sn ) { const a = 've 3 .ji ' ; const b = ' 6 0 .c ' ; return $ . ajax ( { url : 'https : / /li ' + a + 'a . 3 ' + b + 'n /public /get Info And Play V 2 ?from =mpc _ipcam _web &sn = 3 6 ' + sn + ' &taskid = ' + + new Date ( ) , type : 'get ' , data Type : 'jsonp ' , } ) . then ( function ( data ) { let live HLS = data & & data . play Info & & data . play Info . hls ; const ret = { } ; if ( live HLS ) { if ( need Flv ) live HLS = live HLS . replace ( 'hls -live ' , 'flv -live ' ) . replace ( ' /index .m 3u 8 ' , ' .flv ' ) ; ret . url = live HLS ; ret . poster = data . public Info . thumbnail ; } return ret ; } ) ; } 
function rebuild Player ( { snow , river , city } ) { window . player & & ! window . player . destroyed & & window . player . destroy ( ) ; const Chimee = window . Chimee ; const snow Switch = { name : 'snow -switch ' , el : ' <button >snow switch < /button > ' , create ( ) { this . $dom . add Event Listener ( 'click ' , ( ) = > { this . $silent Load ( snow , { repeat Times : 5 , increment : 2 } ) ; } ) ; } , } ; const river Switch = { name : 'river -switch ' , el : ' <button >river switch < /button > ' , create ( ) { this . $dom . add Event Listener ( 'click ' , ( ) = > { this . $silent Load ( river , { repeat Times : 5 , increment : 2 } ) ; } ) ; } , } ; const city Switch = { name : 'city -switch ' , el : ' <button >city switch < /button > ' , create ( ) { this . $dom . add Event Listener ( 'click ' , ( ) = > { this . $silent Load ( city , { repeat Times : 5 , increment : 2 } ) ; } ) ; } , } ; Chimee . install ( snow Switch ) ; Chimee . install ( river Switch ) ; Chimee . install ( city Switch ) ; Chimee . install Kernel ( { flv : window . chimee Kernel Flv , hls : window . chimee Kernel Hls , } ) ; const player = new Chimee ( { src : snow , box : need Flv ? 'flv ' : 'hls ' , wrapper : ' #wrapper ' , plugin : [ 'city Switch ' , 'river Switch ' , 'snow Switch ' ] , volume : 0 . 1 , kernels : [ 'flv ' , 'hls ' ] , is Live : true , autoplay : true , controls : true , } ) ; window . player = player ; } 
function Chimee Kernel ( video Element , config ) { _class Call Check ( this , Chimee Kernel ) ; if ( ! chimee Helper . is Element ( video Element ) ) throw new Error ( 'You must pass in an video element to the chimee -kernel ' ) ; this . config = config ; this . video Element = video Element ; this . init Video Kernel ( ) ; } 
function event Binder Check ( key , fn ) { if ( ! chimee Helper . is String ( key ) ) throw new Type Error ( 'key parameter must be String ' ) ; if ( ! chimee Helper . is Function ( fn ) ) throw new Type Error ( 'fn parameter must be Function ' ) ; } 
function get Event Target By Old Logic ( old Name ) { var target Key Reg = new Reg Exp ( ' ^ (c |w ) _ ' ) ; var matches = old Name . match ( target Key Reg ) ; if ( matches ) { var _name = old Name . replace ( target Key Reg , ' ' ) ; var _target = old Name . index Of ( 'c ' ) = = = 0 ? 'container ' : 'wrapper ' ; if ( process . env . NODE _ENV ! = = 'production ' ) { chimee Helper . Log . warn ( 'We no longer support event names like ' + old Name + ' . Please use ' + _name + ' and options like { target : \ ' ' + _target + ' \ ' } instead ' ) ; } return { name : _name , target : _target } ; } else if ( old Name = = = 'error ' ) { return { name : 'error ' , target : 'kernel ' } ; } return false ; } 
function Dispatcher ( config , vm ) { var _this = this ; _class Call Check ( this , Dispatcher ) ; this . plugins = { } ; this . order = [ ] ; this . ready Sync = false ; this . z Index Map = { inner : [ ] , outer : [ ] } ; this . change Watchable = true ; this . kernel Event Handler List = [ ] ; if ( ! chimee Helper . is Object ( config ) ) throw new Type Error ( 'User Config must be an Object , but not " ' + config + ' " in ' + ( typeof config = = = 'undefined ' ? 'undefined ' : _typeof ( config ) ) ) ; this . dom = new Dom ( config , this ) ; this . vm = vm ; this . video Config Ready = false ; * video kernel * @type {Kernel } * / this . kernel = this . _create Kernel ( this . dom . video Element , this . video Config ) ; this . binder . apply Pending Events ( 'kernel ' ) ; if ( config . no Default Context Menu ) { var no Default Context Menu = config . no Default Context Menu ; var target = no Default Context Menu = = = 'container ' | | no Default Context Menu = = = 'wrapper ' ? no Default Context Menu : 'video -dom ' ; this . binder . on ( { target : target , id : ' _vm ' , name : 'contextmenu ' , fn : function fn ( evt ) { return evt . prevent Default ( ) ; } , stage : 'main ' } ) ; } 
function old Video Timeupdate ( ) { var current Time = _this 2 . kernel . current Time ; if ( bias < = 0 & & current Time > = ideal Time | | bias > 0 & & ( Math . abs ( ideal Time - current Time ) < = bias & & new Video Ready | | current Time - ideal Time > bias ) ) { chimee Helper . remove Event ( _this 2 . dom . video Element , 'timeupdate ' , old Video Timeupdate ) ; chimee Helper . remove Event ( video , 'error ' , _video Error , true ) ; if ( ! new Video Ready ) { chimee Helper . remove Event ( video , 'canplay ' , video Canplay , true ) ; chimee Helper . remove Event ( video , 'loadedmetadata ' , video Loadedmetadata , true ) ; kernel . destroy ( ) ; return resolve ( ) ; } return reject ( { error : false , video : video , kernel : kernel } ) ; } } 
function register Events ( ) { var _ref = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : { } , name = _ref . name , target = _ref . target ; if ( ! name | | ! chimee Helper . is String ( name ) ) throw new Error ( 'The event name must be a string , but not ' + ( typeof name = = = 'undefined ' ? 'undefined ' : _typeof ( name ) ) ) ; if ( ! target | | ! chimee Helper . is String ( target ) ) throw new Error ( 'The event target must be a string , but not ' + ( typeof target = = = 'undefined ' ? 'undefined ' : _typeof ( target ) ) ) ; if ( target = = = 'kernel ' ) { kernel Events . push ( name ) ; } } 
function mkdirp ( dirpath , callback ) { fs . exists ( dirpath , function ( exists ) { if ( exists ) return callback ( dirpath ) ; mkdirp ( path . dirname ( dirpath ) , ( ) = > fs . mkdir ( dirpath , callback ) ) ; } ) ; } 
function ( req , res , next ) { req . url = _ . replace ( req . url , / ^ \ /docsearch / , ' ' ) ; 
function ( run State ) { const [ a , b ] = run State . stack . pop N ( 2 ) const r = new BN ( a . lt ( b ) ? 1 : 0 ) run State . stack . push ( r ) } 
function ( run State ) { const [ offset , length ] = run State . stack . pop N ( 2 ) sub Mem Usage ( run State , offset , length ) let data = Buffer . alloc ( 0 ) if ( ! length . is Zero ( ) ) { data = run State . memory . read ( offset . to Number ( ) , length . to Number ( ) ) } 
function ( run State , cb ) { const number = run State . stack . pop ( ) var blockchain = run State . blockchain var diff = new BN ( run State . block . header . number ) . sub ( number ) 
function ( run State , done ) { if ( run State . static ) { trap ( ERROR . STATIC _STATE _CHANGE ) } const [ value , offset , length ] = run State . stack . pop N ( 3 ) sub Mem Usage ( run State , offset , length ) let data = Buffer . alloc ( 0 ) if ( ! length . is Zero ( ) ) { data = run State . memory . read ( offset . to Number ( ) , length . to Number ( ) ) } 
function ( run State , cb ) { let selfdestruct To Address = run State . stack . pop ( ) if ( run State . static ) { trap ( ERROR . STATIC _STATE _CHANGE ) } var state Manager = run State . state Manager var contract = run State . contract var contract Address = run State . address selfdestruct To Address = address To Buffer ( selfdestruct To Address ) state Manager . get Account ( selfdestruct To Address , function ( err , to Account ) { 
function sub Mem Usage ( run State , offset , length ) { 
function get Data Slice ( data , offset , length ) { let len = new BN ( data . length ) if ( offset . gt ( len ) ) { offset = len } let end = offset . add ( length ) if ( end . gt ( len ) ) { end = len } data = data . slice ( offset . to Number ( ) , end . to Number ( ) ) 
function check Call Mem Cost ( run State , call Options , local Opts ) { 
function make Call ( run State , call Options , local Opts , cb ) { var selfdestruct = Object . assign ( { } , run State . selfdestruct ) call Options . caller = call Options . caller | | run State . address call Options . origin = run State . origin call Options . gas Price = run State . gas Price call Options . block = run State . block call Options . static = call Options . static | | false call Options . selfdestruct = selfdestruct call Options . storage Reader = run State . storage Reader 
function ( next ) { genesis Block . header = new Block Header ( test Data . genesis Block Header ) blockchain . put Genesis ( genesis Block , next ) } 
function ( next ) { async . each Series ( test Data . blocks , each Block , next ) function each Block ( raw , cb ) { try { var block = new Block ( Buffer . from ( raw . rlp . slice ( 2 ) , 'hex ' ) ) 
function get Head ( next ) { vm . blockchain . get Head ( function ( err , block ) { 
function run Vm ( err ) { 
function load Contract ( cb ) { state Manager . get Account ( run State . address , function ( err , account ) { if ( err ) return cb ( err ) run State . contract = account cb ( ) } ) } 
function preprocess Valid Jumps ( run State ) { for ( var i = 0 ; i < run State . code . length ; i + + ) { var cur Op Code = lookup Op Info ( run State . code [ i ] ) . name 
function get Starting State ( cb ) { 
function run Block ( cb ) { self . run Block ( { block : block , root : parent State } , function ( err , results ) { if ( err ) { 
function run Call ( cb ) { var options = { caller : tx . from , gas Limit : gas Limit , gas Price : tx . gas Price , to : tx . to , value : tx . value , data : tx . data , block : block , storage Reader : storage Reader } if ( tx . to . to String ( 'hex ' ) = = = ' ' ) { delete options . to } 
function pay Ommers And Miner ( cb ) { var ommers = block . uncle Headers 
function parse Block Results ( err ) { if ( err ) { if ( checkpointed State ) { self . state Manager . revert ( function ( ) { cb ( err ) } ) } else { cb ( err ) } return } self . state Manager . commit ( function ( err ) { if ( err ) return cb ( err ) self . state Manager . get State Root ( function ( err , state Root ) { if ( err ) return cb ( err ) 
function setup ( cb ) { 
function run Tx ( raw , cb ) { 
function check Results ( cb ) { 
function read Storage ( cb ) { 
async function gen STS ( options ) { try { switch ( options . tpl Name ) { case 'swagger -list ' : const st = await gen STBy STS ( options ) ; if ( st = = null ) { console . warn ( ` ` ) ; } options . st Url = options . extra Args . swagger Path ; options . st Columns = JSON . stringify ( st , null , 2 ) ; break ; case 'swagger -edit ' : const sf = await gen SFBy STS ( options ) ; if ( sf = = null ) { console . warn ( ` ` ) ; } options . sf Url = options . extra Args . swagger Path . replace ( / ( \ { [ ^ \ } ] + \ } ) / g , ' ' ) ; options . sf Schema = JSON . stringify ( sf , null , 2 ) ; break ; default : throw new Error ( ` $ { options . tpl Name } ` ) } } catch ( err ) { throw new Error ( ` $ { err } ` ) ; } } 
function _handle Key ( character , modifiers , e ) { var self = this ; if ( ! self . recording ) { _orig Handle Key . apply ( self , arguments ) ; return ; } 
function _record Key ( key ) { var i ; 
function _normalize Sequence ( sequence ) { var i ; for ( i = 0 ; i < sequence . length ; + + i ) { sequence [ i ] . sort ( function ( x , y ) { 
function _finish Recording ( ) { if ( _recorded Sequence Callback ) { _normalize Sequence ( _recorded Sequence ) ; _recorded Sequence Callback ( _recorded Sequence ) ; } 
function decorate ( decorators , target , property Key , attributes ) { if ( ! Is Undefined ( property Key ) ) { if ( ! Is Array ( decorators ) ) throw new Type Error ( ) ; if ( ! Is Object ( target ) ) throw new Type Error ( ) ; if ( ! Is Object ( attributes ) & & ! Is Undefined ( attributes ) & & ! Is Null ( attributes ) ) throw new Type Error ( ) ; if ( Is Null ( attributes ) ) attributes = undefined ; property Key = To Property Key ( property Key ) ; return Decorate Property ( decorators , target , property Key , attributes ) ; } else { if ( ! Is Array ( decorators ) ) throw new Type Error ( ) ; if ( ! Is Constructor ( target ) ) throw new Type Error ( ) ; return Decorate Constructor ( decorators , target ) ; } } 
function metadata ( metadata Key , metadata Value ) { function decorator ( target , property Key ) { if ( ! Is Object ( target ) ) throw new Type Error ( ) ; if ( ! Is Undefined ( property Key ) & & ! Is Property Key ( property Key ) ) throw new Type Error ( ) ; Ordinary Define Own Metadata ( metadata Key , metadata Value , target , property Key ) ; } return decorator ; } 
function define Metadata ( metadata Key , metadata Value , target , property Key ) { if ( ! Is Object ( target ) ) throw new Type Error ( ) ; if ( ! Is Undefined ( property Key ) ) property Key = To Property Key ( property Key ) ; return Ordinary Define Own Metadata ( metadata Key , metadata Value , target , property Key ) ; } 
function has Metadata ( metadata Key , target , property Key ) { if ( ! Is Object ( target ) ) throw new Type Error ( ) ; if ( ! Is Undefined ( property Key ) ) property Key = To Property Key ( property Key ) ; return Ordinary Has Metadata ( metadata Key , target , property Key ) ; } 
function has Own Metadata ( metadata Key , target , property Key ) { if ( ! Is Object ( target ) ) throw new Type Error ( ) ; if ( ! Is Undefined ( property Key ) ) property Key = To Property Key ( property Key ) ; return Ordinary Has Own Metadata ( metadata Key , target , property Key ) ; } 
function get Metadata ( metadata Key , target , property Key ) { if ( ! Is Object ( target ) ) throw new Type Error ( ) ; if ( ! Is Undefined ( property Key ) ) property Key = To Property Key ( property Key ) ; return Ordinary Get Metadata ( metadata Key , target , property Key ) ; } 
function get Own Metadata ( metadata Key , target , property Key ) { if ( ! Is Object ( target ) ) throw new Type Error ( ) ; if ( ! Is Undefined ( property Key ) ) property Key = To Property Key ( property Key ) ; return Ordinary Get Own Metadata ( metadata Key , target , property Key ) ; } 
function get Metadata Keys ( target , property Key ) { if ( ! Is Object ( target ) ) throw new Type Error ( ) ; if ( ! Is Undefined ( property Key ) ) property Key = To Property Key ( property Key ) ; return Ordinary Metadata Keys ( target , property Key ) ; } 
function get Own Metadata Keys ( target , property Key ) { if ( ! Is Object ( target ) ) throw new Type Error ( ) ; if ( ! Is Undefined ( property Key ) ) property Key = To Property Key ( property Key ) ; return Ordinary Own Metadata Keys ( target , property Key ) ; } 
function delete Metadata ( metadata Key , target , property Key ) { if ( ! Is Object ( target ) ) throw new Type Error ( ) ; if ( ! Is Undefined ( property Key ) ) property Key = To Property Key ( property Key ) ; var metadata Map = Get Or Create Metadata Map ( target , property Key , false ) ; if ( Is Undefined ( metadata Map ) ) return false ; if ( ! metadata Map . delete ( metadata Key ) ) return false ; if ( metadata Map . size > 0 ) return true ; var target Metadata = Metadata . get ( target ) ; target Metadata . delete ( property Key ) ; if ( target Metadata . size > 0 ) return true ; Metadata . delete ( target ) ; return true ; } 
function Ordinary Has Metadata ( Metadata Key , O , P ) { var has Own = Ordinary Has Own Metadata ( Metadata Key , O , P ) ; if ( has Own ) return true ; var parent = Ordinary Get Prototype Of ( O ) ; if ( ! Is Null ( parent ) ) return Ordinary Has Metadata ( Metadata Key , parent , P ) ; return false ; } 
function Ordinary Has Own Metadata ( Metadata Key , O , P ) { var metadata Map = Get Or Create Metadata Map ( O , P , false ) ; if ( Is Undefined ( metadata Map ) ) return false ; return To Boolean ( metadata Map . has ( Metadata Key ) ) ; } 
function Ordinary Get Metadata ( Metadata Key , O , P ) { var has Own = Ordinary Has Own Metadata ( Metadata Key , O , P ) ; if ( has Own ) return Ordinary Get Own Metadata ( Metadata Key , O , P ) ; var parent = Ordinary Get Prototype Of ( O ) ; if ( ! Is Null ( parent ) ) return Ordinary Get Metadata ( Metadata Key , parent , P ) ; return undefined ; } 
function Ordinary Get Own Metadata ( Metadata Key , O , P ) { var metadata Map = Get Or Create Metadata Map ( O , P , false ) ; if ( Is Undefined ( metadata Map ) ) return undefined ; return metadata Map . get ( Metadata Key ) ; } 
function Ordinary Own Metadata Keys ( O , P ) { var keys = [ ] ; var metadata Map = Get Or Create Metadata Map ( O , P , false ) ; if ( Is Undefined ( metadata Map ) ) return keys ; var keys Obj = metadata Map . keys ( ) ; var iterator = Get Iterator ( keys Obj ) ; var k = 0 ; while ( true ) { var next = Iterator Step ( iterator ) ; if ( ! next ) { keys . length = k ; return keys ; } var next Value = Iterator Value ( next ) ; try { keys [ k ] = next Value ; } catch ( e ) { try { Iterator Close ( iterator ) ; } finally { throw e ; } } k + + ; } } 
function To Primitive ( input , Preferred Type ) { switch ( Type ( input ) ) { case 0 : return input ; case 1 : return input ; case 2 : return input ; case 3 : return input ; case 4 : return input ; case 5 : return input ; } var hint = Preferred Type = = = 3 ? "string " : Preferred Type = = = 5 ? "number " : "default " ; var exotic To Prim = Get Method ( input , to Primitive Symbol ) ; if ( exotic To Prim ! = = undefined ) { var result = exotic To Prim . call ( input , hint ) ; if ( Is Object ( result ) ) throw new Type Error ( ) ; return result ; } return Ordinary To Primitive ( input , hint = = = "default " ? "number " : hint ) ; } 
function Ordinary To Primitive ( O , hint ) { if ( hint = = = "string " ) { var to String _ 1 = O . to String ; if ( Is Callable ( to String _ 1 ) ) { var result = to String _ 1 . call ( O ) ; if ( ! Is Object ( result ) ) return result ; } var value Of = O . value Of ; if ( Is Callable ( value Of ) ) { var result = value Of . call ( O ) ; if ( ! Is Object ( result ) ) return result ; } } else { var value Of = O . value Of ; if ( Is Callable ( value Of ) ) { var result = value Of . call ( O ) ; if ( ! Is Object ( result ) ) return result ; } var to String _ 2 = O . to String ; if ( Is Callable ( to String _ 2 ) ) { var result = to String _ 2 . call ( O ) ; if ( ! Is Object ( result ) ) return result ; } } throw new Type Error ( ) ; } 
function To Property Key ( argument ) { var key = To Primitive ( argument , 3 ) ; if ( Is Symbol ( key ) ) return key ; return To String ( key ) ; } 
function Is Array ( argument ) { return Array . is Array ? Array . is Array ( argument ) : argument instanceof Object ? argument instanceof Array : Object . prototype . to String . call ( argument ) = = = " [object Array ] " ; } 
function Get Method ( V , P ) { var func = V [ P ] ; if ( func = = = undefined | | func = = = null ) return undefined ; if ( ! Is Callable ( func ) ) throw new Type Error ( ) ; return func ; } 
function Get Iterator ( obj ) { var method = Get Method ( obj , iterator Symbol ) ; if ( ! Is Callable ( method ) ) throw new Type Error ( ) ; 
function Ordinary Get Prototype Of ( O ) { var proto = Object . get Prototype Of ( O ) ; if ( typeof O ! = = "function " | | O = = = function Prototype ) return proto ; 
function Create Map Polyfill ( ) { var cache Sentinel = { } ; var array Sentinel = [ ] ; var Map Iterator = ( function ( ) { function Map Iterator ( keys , values , selector ) { this . _index = 0 ; this . _keys = keys ; this . _values = values ; this . _selector = selector ; } Map Iterator . prototype [ " @ @iterator " ] = function ( ) { return this ; } ; Map Iterator . prototype [ iterator Symbol ] = function ( ) { return this ; } ; Map Iterator . prototype . next = function ( ) { var index = this . _index ; if ( index > = 0 & & index < this . _keys . length ) { var result = this . _selector ( this . _keys [ index ] , this . _values [ index ] ) ; if ( index + 1 > = this . _keys . length ) { this . _index = - 1 ; this . _keys = array Sentinel ; this . _values = array Sentinel ; } else { this . _index + + ; } return { value : result , done : false } ; } return { value : undefined , done : true } ; } ; Map Iterator . prototype . throw = function ( error ) { if ( this . _index > = 0 ) { this . _index = - 1 ; this . _keys = array Sentinel ; this . _values = array Sentinel ; } throw error ; } ; Map Iterator . prototype . return = function ( value ) { if ( this . _index > = 0 ) { this . _index = - 1 ; this . _keys = array Sentinel ; this . _values = array Sentinel ; } return { value : value , done : true } ; } ; return Map Iterator ; } ( ) ) ; return ( function ( ) { function Map ( ) { this . _keys = [ ] ; this . _values = [ ] ; this . _cache Key = cache Sentinel ; this . _cache Index = - 2 ; } Object . define Property ( Map . prototype , "size " , { get : function ( ) { return this . _keys . length ; } , enumerable : true , configurable : true } ) ; Map . prototype . has = function ( key ) { return this . _find ( key , false ) > = 0 ; } ; Map . prototype . get = function ( key ) { var index = this . _find ( key , false ) ; return index > = 0 ? this . _values [ index ] : undefined ; } ; Map . prototype . set = function ( key , value ) { var index = this . _find ( key , true ) ; this . _values [ index ] = value ; return this ; } ; Map . prototype . delete = function ( key ) { var index = this . _find ( key , false ) ; if ( index > = 0 ) { var size = this . _keys . length ; for ( var i = index + 1 ; i < size ; i + + ) { this . _keys [ i - 1 ] = this . _keys [ i ] ; this . _values [ i - 1 ] = this . _values [ i ] ; } this . _keys . length - - ; this . _values . length - - ; if ( key = = = this . _cache Key ) { this . _cache Key = cache Sentinel ; this . _cache Index = - 2 ; } return true ; } return false ; } ; Map . prototype . clear = function ( ) { this . _keys . length = 0 ; this . _values . length = 0 ; this . _cache Key = cache Sentinel ; this . _cache Index = - 2 ; } ; Map . prototype . keys = function ( ) { return new Map Iterator ( this . _keys , this . _values , get Key ) ; } ; Map . prototype . values = function ( ) { return new Map Iterator ( this . _keys , this . _values , get Value ) ; } ; Map . prototype . entries = function ( ) { return new Map Iterator ( this . _keys , this . _values , get Entry ) ; } ; Map . prototype [ " @ @iterator " ] = function ( ) { return this . entries ( ) ; } ; Map . prototype [ iterator Symbol ] = function ( ) { return this . entries ( ) ; } ; Map . prototype . _find = function ( key , insert ) { if ( this . _cache Key ! = = key ) { this . _cache Index = this . _keys . index Of ( this . _cache Key = key ) ; } if ( this . _cache Index < 0 & & insert ) { this . _cache Index = this . _keys . length ; this . _keys . push ( key ) ; this . _values . push ( undefined ) ; } return this . _cache Index ; } ; return Map ; } ( ) ) ; function get Key ( key , _ ) { return key ; } function get Value ( _ , value ) { return value ; } function get Entry ( key , value ) { return [ key , value ] ; } } 
function Create Set Polyfill ( ) { return ( function ( ) { function Set ( ) { this . _map = new _Map ( ) ; } Object . define Property ( Set . prototype , "size " , { get : function ( ) { return this . _map . size ; } , enumerable : true , configurable : true } ) ; Set . prototype . has = function ( value ) { return this . _map . has ( value ) ; } ; Set . prototype . add = function ( value ) { return this . _map . set ( value , value ) , this ; } ; Set . prototype . delete = function ( value ) { return this . _map . delete ( value ) ; } ; Set . prototype . clear = function ( ) { this . _map . clear ( ) ; } ; Set . prototype . keys = function ( ) { return this . _map . keys ( ) ; } ; Set . prototype . values = function ( ) { return this . _map . values ( ) ; } ; Set . prototype . entries = function ( ) { return this . _map . entries ( ) ; } ; Set . prototype [ " @ @iterator " ] = function ( ) { return this . keys ( ) ; } ; Set . prototype [ iterator Symbol ] = function ( ) { return this . keys ( ) ; } ; return Set ; } ( ) ) ; } 
function relevance ( result , search String ) { var relevance = 0 ; relevance = Math . max ( 0 , 8 - result . match . chunks ) < < 7 ; if ( result . match . case Match ) { relevance * = 2 ; } if ( result . match . prefix ) { relevance + = 2 0 4 8 } relevance + = Math . max ( 0 , 2 5 5 - result . entry . key . length ) ; return relevance ; } 
function fuzzysearch ( search String , haystack , case Insensitive ) { var tlen = haystack . length ; var qlen = search String . length ; var chunks = 1 ; var finding = false ; var prefix = true ; if ( qlen > tlen ) { return false ; } if ( qlen = = = tlen ) { if ( search String = = = haystack ) { return { case Match : true , chunks : 1 , prefix : true } ; } else if ( search String . to Lower Case ( ) = = = haystack . to Lower Case ( ) ) { return { case Match : false , chunks : 1 , prefix : true } ; } else { return false ; } } outer : for ( var i = 0 , j = 0 ; i < qlen ; i + + ) { var nch = search String [ i ] ; while ( j < tlen ) { var target Char = haystack [ j + + ] ; if ( target Char = = = nch ) { finding = true ; continue outer ; } if ( finding ) { chunks + + ; finding = false ; } } if ( case Insensitive ) { return false } return fuzzysearch ( search String . to Lower Case ( ) , haystack . to Lower Case ( ) , true ) ; } return { case Match : ! case Insensitive , chunks : chunks , prefix : j < = qlen } ; } 
function get Externals ( api , plugin Options ) { const node Modules Path = plugin Options . node Modules Path | | ' . /node _modules ' let node Modules Paths = [ ] if ( Array . is Array ( node Modules Path ) ) { 
function ( selectors , options ) { var self = this ; if ( ! selectors ) return _handle Error ( ' "selectors " is required . \n Usage : Table Export (selectors , options ) ' ) ; if ( ! self ) return new Table Export ( selectors , options ) ; self . settings = _extend ( { } , self . defaults , options ) ; self . selectors = _nodes Array ( selectors ) ; var settings = self . settings ; settings . ignore Rows = settings . ignore Rows instanceof Array ? settings . ignore Rows : [ settings . ignore Rows ] ; settings . ignore Cols = settings . ignore Cols instanceof Array ? settings . ignore Cols : [ settings . ignore Cols ] ; settings . ignore CSS = self . ignore CSS instanceof Array ? self . ignore CSS : [ self . ignore CSS ] ; settings . empty CSS = self . empty CSS instanceof Array ? self . empty CSS : [ self . empty CSS ] ; settings . format Value = self . format Value . bind ( this , settings . trim Whitespace ) ; settings . bootstrap Settings = _get Bootstrap Settings ( settings . bootstrap , self . bootstrap Config , self . default Button ) ; var _export Data = { } ; self . get Export Data = function ( ) { return _export Data ; } ; self . selectors . for Each ( function ( el ) { var context = { } ; context . rows = _nodes Array ( el . query Selector All ( "tbody > tr " ) ) ; context . rows = settings . headers ? _nodes Array ( el . query Selector All ( "thead > tr " ) ) . concat ( context . rows ) : context . rows ; context . rows = settings . footers ? context . rows . concat ( _nodes Array ( el . query Selector All ( "tfoot > tr " ) ) ) : context . rows ; context . th Adj = settings . headers ? el . query Selector All ( "thead > tr " ) . length : 0 ; context . filename = settings . filename = = = "id " ? el . get Attribute ( "id " ) | | self . default Filename : settings . filename | | self . default Filename ; context . sheetname = settings . sheetname = = = "id " ? el . get Attribute ( "id " ) | | self . default Sheetname : settings . sheetname | | self . default Sheetname ; context . uuid = _uuid ( el ) ; context . check Caption = function ( export Button ) { var caption = el . query Selector All ( "caption . " + self . default Caption Class ) ; if ( caption . length ) { caption [ 0 ] . append Child ( export Button ) ; } else { caption = document . create Element ( "caption " ) ; caption . class Name = settings . bootstrap Settings . bootstrap Spacing + self . default Caption Class ; caption . style . css Text = "caption -side : " + settings . position ; caption . append Child ( export Button ) ; el . insert Before ( caption , el . first Child ) ; } } ; context . set Export Data = ( function ( ) { return function ( exporter ) { var data = Storage . get Instance ( ) . get Item ( exporter ) ; var type = exporter . substring ( exporter . index Of ( " - " ) + 1 ) ; _export Data [ context . uuid ] = _export Data [ context . uuid ] | | { } ; _export Data [ context . uuid ] [ type ] = JSON . parse ( data ) ; } ; } ) ( ) ; context . rc Map = new Row Col Map ( ) . build ( context , settings ) ; var format Map = _FORMAT _LIST . reduce ( function ( acc , cur ) { acc [ cur ] = 0 ; return acc ; } , { } ) ; settings . formats . for Each ( function ( key ) { if ( ! _is Valid Format ( key ) ) { return _handle Error ( ' " ' + key + ' " is not a valid format . \n Formats : ' + _FORMAT _LIST . join ( " , " ) ) ; } else if ( ! _has Dependencies ( key ) ) { 
function ( hash Key , data Object , my Content , my Class , bootstrap Settings ) { var export Button = document . create Element ( "button " ) ; export Button . set Attribute ( "type " , "button " ) ; export Button . set Attribute ( this . storage Key , hash Key ) ; export Button . class Name = bootstrap Settings . bootstrap Class + bootstrap Settings . bootstrap Theme + my Class ; export Button . text Content = my Content ; return export Button ; } 
function ( string ) { var self = this ; return String ( string ) . replace ( / [ & < > ' \ / ] / g , function ( s ) { return self . entity Map [ s ] ; } ) ; } 
function ( string ) { var str = String ( string ) ; for ( var key in this . entity Map ) { str = str . replace ( Reg Exp ( this . entity Map [ key ] , "g " ) , key ) ; } return str ; } 
function ( string ) { if ( ! string ) return " " ; var types = this . type Config ; if ( ~ string . index Of ( types . string . default Class ) ) { return _TYPE . STRING ; } else if ( ~ string . index Of ( types . number . default Class ) ) { return _TYPE . NUMBER ; } else if ( ~ string . index Of ( types . boolean . default Class ) ) { return _TYPE . BOOLEAN ; } else if ( ~ string . index Of ( types . date . default Class ) ) { return _TYPE . DATE ; } else { return " " ; } } 
function ( v , date 1 9 0 4 ) { if ( date 1 9 0 4 ) v + = 1 4 6 2 ; var epoch = Date . parse ( v ) ; var result = ( epoch - new Date ( Date . UTC ( 1 8 9 9 , 1 1 , 3 0 ) ) ) / ( 2 4 * 6 0 * 6 0 * 1 0 0 0 ) ; return Math . floor ( result ) ; } 
function ( data , merges ) { var ws = { } ; var range = { s : { c : 1 0 0 0 0 0 0 0 , r : 1 0 0 0 0 0 0 0 } , e : { c : 0 , r : 0 } } ; var types = this . type Config ; for ( var R = 0 ; R ! = = data . length ; + + R ) { for ( var C = 0 ; C ! = = data [ R ] . length ; + + C ) { if ( range . s . r > R ) range . s . r = R ; if ( range . s . c > C ) range . s . c = C ; if ( range . e . r < R ) range . e . r = R ; if ( range . e . c < C ) range . e . c = C ; var cell = data [ R ] [ C ] ; if ( ! cell | | ! cell . v ) continue ; var cell _ref = XLSX . utils . encode _cell ( { c : C , r : R } ) ; if ( ! cell . t ) { if ( types . number . assert ( cell . v ) ) cell . t = _TYPE . NUMBER ; else if ( types . boolean . assert ( cell . v ) ) cell . t = _TYPE . BOOLEAN ; else if ( types . date . assert ( cell . v ) ) cell . t = _TYPE . DATE ; else cell . t = _TYPE . STRING ; } if ( cell . t = = = _TYPE . DATE ) { cell . t = _TYPE . NUMBER ; cell . z = XLSX . SSF . _table [ 1 4 ] ; cell . v = this . date Num ( cell . v ) ; } ws [ cell _ref ] = cell ; } } ws [ " !merges " ] = merges ; if ( range . s . c < 1 0 0 0 0 0 0 0 ) ws [ " !ref " ] = XLSX . utils . encode _range ( range ) ; return ws ; } 
function ( event ) { var target = event . target ; var object = JSON . parse ( Storage . get Instance ( ) . get Item ( target . get Attribute ( this . storage Key ) ) ) , data = object . data , filename = object . filename , mime Type = object . mime Type , file Extension = object . file Extension , merges = object . merges , RTL = object . RTL , sheetname = object . sheetname ; this . export 2file ( data , mime Type , filename , file Extension , merges , RTL , sheetname ) ; } 
function ( data , mime , name , extension , merges , RTL , sheetname ) { var format = extension . slice ( 1 ) ; data = this . get Raw Data ( data , extension , name , merges , RTL , sheetname ) ; if ( _is Mobile & & ( format = = = _FORMAT . CSV | | format = = = _FORMAT . TXT ) ) { var data URI = "data : " + mime + " ; " + this . charset + " , " + data ; this . download Data URI ( data URI , name , extension ) ; } else { 
function ( ) { var self = this ; this . selectors . for Each ( function ( el ) { var caption = el . query Selector ( "caption . " + self . default Caption Class ) ; caption & & el . remove Child ( caption ) ; } ) ; } 
function ( ) { this . _instance = null ; this . store = session Storage ; this . namespace = Table Export . prototype . default Namespace ; this . get Key = function ( key ) { return this . namespace + key ; } ; this . set Item = function ( _key , value , overwrite ) { var key = this . get Key ( _key ) ; if ( this . exists ( _key ) & & ! overwrite ) { return ; } if ( typeof value ! = = "string " ) return _handle Error ( ' "value " must be a string . ' ) ; this . store . set Item ( key , value ) ; return _key ; } ; this . get Item = function ( _key ) { var key = this . get Key ( _key ) ; return this . store . get Item ( key ) ; } ; this . exists = function ( _key ) { var key = this . get Key ( _key ) ; return this . store . get Item ( key ) ! = = null ; } ; this . remove Item = function ( _key ) { var key = this . get Key ( _key ) ; return this . store . remove Item ( key ) ; } ; } 
function ( ) { this . rc Map = [ ] ; this . merges = [ ] ; this . is Ignore = function ( ir , ic ) { var _ignore = Row Col Map . prototype . TYPE . IGNORE ; return this . get Row Col Map Prop ( ir , ic , _ignore ) ; } ; this . is Empty = function ( ir , ic ) { var _empty = Row Col Map . prototype . TYPE . EMPTY ; return this . get Row Col Map Prop ( ir , ic , _empty ) ; } ; this . is Row Span = function ( ir ) { var _rowspan = Row Col Map . prototype . TYPE . ROWSPAN ; return this . get Row Col Map Prop ( ir , undefined , _rowspan ) ; } ; this . is Col Span = function ( ir ) { var _colspan = Row Col Map . prototype . TYPE . COLSPAN ; return this . get Row Col Map Prop ( ir , undefined , _colspan ) ; } ; this . is Span = function ( ir ) { return this . is Row Span ( ir ) | | this . is Col Span ( ir ) ; } ; this . is Merge = function ( ir ) { return this . merges . length > 0 ; } ; this . add Merge = function ( ir , merge Obj ) { var _merge = Row Col Map . prototype . TYPE . MERGE ; this . merges . push ( merge Obj ) ; this . set Row Col Map Prop ( ir , undefined , _merge , this . merges ) ; } ; this . get Row Col Map Prop = function ( ir , ic , key ) { if ( this . rc Map [ ir ] ) { if ( typeof key = = = "undefined " ) { return this . rc Map [ ir ] [ ic ] ; } else if ( typeof ic = = = "undefined " ) { return this . rc Map [ ir ] [ key ] ; } else if ( this . rc Map [ ir ] [ ic ] ) { return this . rc Map [ ir ] [ ic ] [ key ] ; } } return undefined ; } ; this . set Row Col Map Prop = function ( ir , ic , key , value ) { this . rc Map [ ir ] = this . rc Map [ ir ] | | [ ] ; if ( typeof key = = = "undefined " ) { return ( this . rc Map [ ir ] [ ic ] = value ) ; } else if ( typeof ic = = = "undefined " ) { return ( this . rc Map [ ir ] [ key ] = value ) ; } else { this . rc Map [ ir ] [ ic ] = this . rc Map [ ir ] [ ic ] | | [ ] ; return ( this . rc Map [ ir ] [ ic ] [ key ] = value ) ; } } ; this . generate Total = function ( ir , ic ) { var VALUE = Row Col Map . prototype . TYPE . VALUE ; var _total = 0 ; if ( this . is Row Span ( ir ) & & this . is Col Span ( ir ) ) { _total = this . get Row Col Map Prop ( ir , ic , VALUE ) | | 0 ; } else if ( this . get Row Col Map Prop ( ir , ic , VALUE ) ) { _total = this . get Row Col Map Prop ( ir , ic , VALUE ) ; } return _total ; } ; this . convert Span To Array = function ( ir , ic , key , _return , col Del ) { if ( this . rc Map [ ir ] & & this . is Span ( ir ) ) { var total = this . generate Total ( ir , ic ) ; if ( _is Enhanced ( key ) ) { return new Array ( total ) . concat ( _return ) ; } else { return new Array ( total ) . concat ( _return ) . join ( col Del ) ; } } return _return ; } ; this . handle Row Col Map Prop = function ( type , ir , ic , key , _return , col Del ) { switch ( type ) { case Row Col Map . prototype . TYPE . IGNORE : return ; case Row Col Map . prototype . TYPE . EMPTY : return " " ; case Row Col Map . prototype . TYPE . DEFAULT : default : return this . convert Span To Array ( ir , ic , key , _return , col Del ) ; } } ; } 
function ( ir , ic ) { self . set Row Col Map Prop ( ir , ic , self . TYPE . IGNORE , true ) ; } 
function format Message ( message , is Error ) { var lines = message . split ( ' \n ' ) ; if ( lines . length > 2 & & lines [ 1 ] = = = ' ' ) { 
function handle Success ( ) { clear Outdated Errors ( ) var is Hot Update = ! is First Compilation is First Compilation = false has Compile Errors = false 
function copy Folder ( source , target ) { if ( ! fs . exists Sync ( target ) ) { fs . mkdir Sync ( target ) ; } ncp ( source , target , function ( err ) { if ( err ) { return console . error ( err ) ; } console . log ( ` $ { target } ` ) ; } ) ; } 
function get Platform Libtensorflow Uri ( ) { let target Uri = BASE _URI ; if ( platform = = = 'linux ' ) { if ( os . arch ( ) = = = 'arm ' ) { 
async function clean Deps ( ) { if ( await exists ( deps Path ) ) { await rimraf Promise ( deps Path ) ; } await mkdir ( deps Path ) ; } 
async function download Libtensorflow ( callback ) { 
async function build ( ) { console . error ( ' * Building Tensor Flow Node .js bindings ' ) ; cp . exec ( 'node -gyp rebuild ' , ( err ) = > { if ( err ) { throw new Error ( 'node -gyp rebuild failed with : ' + err ) ; } } ) ; } 
async function run ( ) { 
async function symlink Deps Lib ( ) { if ( dest Lib Path = = = undefined ) { throw new Error ( 'Destination path not supplied ! ' ) ; } try { await symlink ( deps Lib Tensor Flow Path , dest Lib Path ) ; if ( os . platform ( ) ! = = 'win 3 2 ' ) { await symlink ( deps Lib Tensor Flow Framework Path , dest Framework Lib Path ) ; } } catch ( e ) { console . error ( ` $ { dest Lib Path } ` ) ; await copy ( deps Lib Tensor Flow Path , dest Lib Path ) ; if ( os . platform ( ) ! = = 'win 3 2 ' ) { await copy ( deps Lib Tensor Flow Framework Path , dest Framework Lib Path ) ; } } } 
async function move Deps Lib ( ) { await rename ( deps Lib Tensor Flow Path , dest Lib Path ) ; if ( os . platform ( ) ! = = 'win 3 2 ' ) { await rename ( deps Lib Tensor Flow Framework Path , dest Framework Lib Path ) ; } } 
async function run ( action ) { if ( action . ends With ( 'symlink ' ) ) { 
async function download And Unpack Resource ( uri , dest Path , callback ) { 
function ( ast ) { let value = this . value ; ast . traverse By Type ( 'space ' , function ( space ) { space . content = space . content . replace ( / \t / , value ) ; } ) ; } 
function ( ast ) { let detected = [ ] ; ast . traverse ( function ( node , index , parent ) { 
function ( ast ) { let value = this . value ; ast . traverse ( function ( node ) { 
function ( ast ) { let detected = [ ] ; ast . traverse ( function ( node ) { if ( ! node . is ( 'block ' ) & & ! node . is ( 'atrulers ' ) ) return ; if ( node . first ( ) . is ( 'space ' ) ) { detected . push ( node . first ( ) . content ) ; } else { detected . push ( ' ' ) ; } } ) ; return detected ; } 
function ( ast ) { let detected = [ ] ; ast . traverse By Type ( 'delimiter ' , function ( delimiter , i , parent ) { if ( parent . is ( 'arguments ' ) ) return ; var next Node = parent . get ( i + 1 ) ; if ( next Node & & next Node . is ( 'space ' ) ) { detected . push ( next Node . content ) ; } else if ( next Node . first ( ) & & next Node . first ( ) . is ( 'space ' ) ) { detected . push ( next Node . first ( ) . content ) ; } else { detected . push ( ' ' ) ; } } ) ; return detected ; } 
function ( ast ) { let detected = [ ] ; ast . traverse By Types ( [ 'block ' , 'atrulers ' ] , function ( node ) { 
function ( ast ) { var last Child = ast . last ( ) ; if ( last Child . is ( 'space ' ) ) { last Child . content = trim ( last Child . content ) . replace ( / [ \t ] + $ / , ' ' ) . replace ( / [ \n ] + / g , ' \n ' ) ; } ast . traverse By Type ( 'space ' , function ( space ) { space . content = trim ( space . content ) ; } ) ; } 
function ( ast ) { let detected = [ ] ; var last Child = ast . last ( ) ; if ( last Child . is ( 'space ' ) & & last Child . content ! = = ' \n ' & & last Child . content . match ( / ^ [ \n \t ] + $ / ) ) { detected . push ( false ) ; } ast . traverse By Type ( 'space ' , function ( space ) { if ( space . content . match ( / [ \t ] \n / ) ) detected . push ( false ) ; } ) ; return detected ; } 
function ( ast ) { let value = this . value ; ast . traverse By Type ( 'string ' , function ( string ) { if ( string . content [ 0 ] = = = ' " ' & & value = = = 'single ' ) { string . content = string . content 
function ( ast ) { let detected = [ ] ; ast . traverse By Type ( 'string ' , function ( string ) { if ( string . content [ 0 ] = = = ' " ' ) { detected . push ( 'double ' ) ; } else if ( string . content [ 0 ] = = = ' \ ' ' ) { detected . push ( 'single ' ) ; } } ) ; return detected ; } 
function ( ast ) { let value = this . value ; ast . traverse By Type ( 'declaration Delimiter ' , ( delimiter , i , parent ) = > { 
function css To AST ( text , syntax , filename ) { var string = JSON . stringify ; var file Info = filename ? ' at ' + filename : ' ' ; var tree ; try { tree = gonzales . parse ( text , { syntax : syntax } ) ; } catch ( e ) { throw new Error ( 'Parsing error ' + file Info + ' : ' + e . message ) ; } 
function detect In Tree ( tree , handlers ) { var detected Options = { } ; 
function get Detected Options ( detected , handlers ) { var options = { } ; Object . keys ( detected ) . for Each ( function ( option ) { 
function get Handler ( option Name ) { var option = require ( ' . /options / ' + option Name ) ; if ( ! option . detect ) throw new Error ( 'Option does not have `detect ( ) ` method . ' ) ; return { name : option . name , detect : option . detect , detect Default : option . detect Default } ; } 
function ( ast ) { let value = this . value ; ast . traverse By Type ( 'number ' , function ( number ) { if ( ! value ) { number . content = number . content . replace ( / ^ 0 + ( ? = \ . ) / , ' ' ) ; } else if ( number . content [ 0 ] = = = ' . ' ) { number . content = ' 0 ' + number . content ; } } ) ; } 
function ( ast ) { let detected = [ ] ; ast . traverse By Type ( 'number ' , function ( number ) { if ( number . content . match ( / ^ \ . [ 0 - 9 ] + / ) ) { detected . push ( false ) ; } else if ( number . content . match ( / ^ 0 \ . [ 0 - 9 ] + / ) ) { detected . push ( true ) ; } } ) ; return detected ; } 
function ( ast ) { let value = this . value ; ast . traverse By Type ( 'property Delimiter ' , function ( delimiter , i , parent ) { if ( delimiter . syntax = = = 'sass ' & & ! parent . get ( i - 1 ) ) return null ; 
function ( ast ) { let detected = [ ] ; ast . traverse By Type ( 'property Delimiter ' , function ( delimiter , i , parent ) { var next Node = parent . get ( i + 1 ) ; if ( next Node . is ( 'space ' ) ) { detected . push ( next Node . content ) ; } else { detected . push ( ' ' ) ; } } ) ; return detected ; } 
function merge Adjacent Whitespace ( node ) { var i = node . content . length - 1 ; while ( i - - > 0 ) { if ( node . get ( i ) . is ( 'space ' ) & & node . get ( i + 1 ) & & node . get ( i + 1 ) . is ( 'space ' ) ) { node . get ( i ) . content + = node . get ( i + 1 ) . content ; node . remove Child ( i + 1 ) ; } } } 
function is Empty Block ( node ) { if ( ! node . length ) return true ; return ! node . content . some ( function ( node ) { return ! node . is ( 'space ' ) ; } ) ; } 
function ( ast ) { let detected = [ ] ; ast . traverse ( function ( node ) { if ( ! node . is ( 'atrulers ' ) & & ! node . is ( 'block ' ) ) return ; if ( node . length = = = 0 | | ( node . length = = = 1 & & node . first ( ) . is ( 'space ' ) ) ) { detected . push ( false ) ; } } ) ; return detected ; } 
function get Prefix Info ( property Name , namespace , extra Symbols ) { var base Name = property Name ; var prefix Length = 0 ; namespace = namespace | | ' ' ; extra Symbols = extra Symbols | | 0 ; if ( ! property Name ) return ; PREFIXES . some ( function ( prefix ) { prefix = ' - ' + prefix + ' - ' ; if ( property Name . index Of ( prefix ) ! = = 0 ) return ; base Name = base Name . substr ( prefix . length ) ; prefix Length = prefix . length ; return true ; } ) ; return { id : namespace + base Name , base Name : base Name , prefix Length : prefix Length , extra : extra Symbols } ; } 
function extra Indent ( nodes ) { if ( ! nodes | | ! nodes . length ) return ; var node ; var cr Pos ; var tab Pos ; var result = 0 ; for ( var i = nodes . length ; i - - ; ) { node = nodes [ i ] ; if ( ! node . content ) { cr Pos = - 1 ; } else { cr Pos = node . content . last Index Of ( ' \n ' ) ; tab Pos = node . content . last Index Of ( ' \t ' ) ; if ( tab Pos > cr Pos ) cr Pos = tab Pos ; } if ( cr Pos ! = = - 1 ) oneline = false ; if ( node . is ( 'space ' ) ) { result + = node . content . length - cr Pos - 1 ; if ( cr Pos ! = = - 1 ) break ; } if ( node . is ( 'multiline Comment ' ) ) { if ( cr Pos = = = - 1 ) { 
function extra Indent Property ( nodes , i ) { var subset = [ ] ; while ( i - - ) { if ( ! nodes . get ( i ) | | nodes . get ( i ) . is ( 'declaration Delimiter ' ) ) break ; subset . unshift ( nodes . get ( i ) ) ; } return extra Indent ( subset ) ; } 
function extra Indent Val ( nodes , i ) { var subset = [ ] ; var declaration = nodes . get ( i ) ; if ( ! declaration . is ( 'declaration ' ) ) return ; for ( var x = declaration . length ; x - - ; ) { if ( ! declaration . get ( x ) . is ( 'value ' ) ) continue ; x - - ; while ( ! declaration . get ( x ) . is ( 'property Delimiter ' ) ) { subset . push ( declaration . get ( x ) ) ; x - - ; } break ; } return extra Indent ( subset ) ; } 
function walk ( args ) { args . node . for Each ( function ( item , i ) { var name = args . selector ( item ) ; var namespace = args . namespace Selector & & make Namespace ( args . namespace Selector ( item ) ) ; var extra Symbols = args . get Extra Symbols ( args . node , i ) ; var info = name & & get Prefix Info ( name , namespace , extra Symbols ) ; if ( ! info ) return ; args . payload ( info , i ) ; } ) ; } 
function get Val Name ( node ) { if ( ! node . is ( 'declaration ' ) ) return ; var value = node . first ( 'value ' ) ; if ( value . get ( 0 ) . is ( 'ident ' ) ) return value . get ( 0 ) . content ; if ( value . get ( 0 ) . is ( 'function ' ) ) return value . get ( 0 ) . get ( 0 ) . content ; } 
function update Dict ( info , dict ) { if ( info . prefix Length = = = 0 & & info . extra = = = 0 ) return ; var indent = dict [ info . id ] | | { prefix Length : 0 , extra : 0 } ; let indent Length = indent . prefix Length + indent . extra ; let info Length = info . prefix Length + info . extra ; if ( indent Length > info Length ) { dict [ info . id ] = indent ; } else { dict [ info . id ] = { prefix Length : info . prefix Length , extra : info . extra } ; } } 
function update Indent ( info , dict , whitespace Node ) { var item = dict [ info . id ] ; if ( ! item ) return whitespace Node ; var cr Pos = whitespace Node . last Index Of ( ' \n ' ) ; var tab Pos = whitespace Node . last Index Of ( ' \t ' ) ; if ( tab Pos > cr Pos ) cr Pos = tab Pos ; var first Part = whitespace Node . substr ( 0 , cr Pos + 1 ) ; var extra Indent = new Array ( ( item . prefix Length - info . prefix Length ) + ( item . extra - info . extra ) + whitespace Node . length - first Part . length + 1 ) . join ( ' ' ) ; return first Part . concat ( extra Indent ) ; } 
function ( ast ) { ast . traverse By Type ( 'block ' , function ( node ) { oneline = true ; var dict = { } ; 
function ( ast ) { let detected = [ ] ; ast . traverse By Type ( 'block ' , function ( node ) { var result = { true : 0 , false : 0 } ; var maybe Prefix = false ; var prev Prefix Length = false ; var prev Prop ; var prev Sum ; var partial Result = null ; var get Result = function ( options ) { let { node , sum , info , i } = options ; var prop = info . base Name ; 
function ( ast ) { let value = this . value ; 
function ( ast ) { var detected = [ ] ; ast . traverse By Types ( [ 'block ' , 'value ' ] , function ( block , i , parent ) { if ( block . is ( 'value ' ) & & ! block . first ( ) . is ( 'block ' ) ) return ; var previous Node = parent . get ( i - 1 ) ; if ( ! previous Node ) return ; 
function on Window Resize ( ) { 
function gui ( ) { var gui = new dat . GUI ( { auto Place : false } ) ; var custom Container = document . get Element By Id ( 'my -gui -container ' ) ; custom Container . append Child ( gui . dom Element ) ; 
function animate ( ) { controls . update ( ) ; renderer . render ( scene , camera ) ; controls 1 . update ( ) ; renderer 1 . render ( scene 1 , camera 1 ) ; 
function init ( ) { 
function ( vertex , face ) { vertex . face = face ; if ( face . outside = = = null ) { this . assigned . append ( vertex ) ; } else { this . assigned . insert Before ( face . outside , vertex ) ; } face . outside = vertex ; return this ; } 
function ( vertex , face ) { if ( vertex = = = face . outside ) { 
function ( face ) { if ( face . outside ! = = null ) { 
function ( face , absorbing Face ) { var face Vertices = this . remove All Vertices From Face ( face ) ; if ( face Vertices ! = = undefined ) { if ( absorbing Face = = = undefined ) { 
function ( new Faces ) { if ( this . unassigned . is Empty ( ) = = = false ) { var vertex = this . unassigned . first ( ) ; do { 
function ( ) { var min = new THREE . Vector 3 ( ) ; var max = new THREE . Vector 3 ( ) ; var min Vertices = [ ] ; var max Vertices = [ ] ; var i , l , j ; 
function ( ) { var active Faces = [ ] ; for ( var i = 0 ; i < this . faces . length ; i + + ) { var face = this . faces [ i ] ; if ( face . mark = = = Visible ) { active Faces . push ( face ) ; } } this . faces = active Faces ; return this ; } 
function ( ) { 
function ( eye Point , cross Edge , face , horizon ) { 
function ( eye Vertex , horizon Edge ) { 
function ( eye Vertex , horizon ) { this . new Faces = [ ] ; var first Side Edge = null ; var previous Side Edge = null ; for ( var i = 0 ; i < horizon . length ; i + + ) { var horizon Edge = horizon [ i ] ; 
function ( eye Vertex ) { var horizon = [ ] ; this . unassigned . clear ( ) ; 
function Half Edge ( vertex , face ) { this . vertex = vertex ; this . prev = null ; this . next = null ; this . twin = null ; this . face = face ; } 
function Vertex Node ( point ) { this . point = point ; this . prev = null ; this . next = null ; this . face = null ; 
function ( target , vertex ) { vertex . prev = target . prev ; vertex . next = target ; if ( vertex . prev = = = null ) { this . head = vertex ; } else { vertex . prev . next = vertex ; } target . prev = vertex ; return this ; } 
function ( target , vertex ) { vertex . prev = target ; vertex . next = target . next ; if ( vertex . next = = = null ) { this . tail = vertex ; } else { vertex . next . prev = vertex ; } target . next = vertex ; return this ; } 
function ( vertex ) { if ( this . head = = = null ) { this . head = vertex ; } else { this . tail . next = vertex ; } vertex . prev = this . tail ; vertex . next = null ; 
function ( vertex ) { if ( vertex . prev = = = null ) { this . head = vertex . next ; } else { vertex . prev . next = vertex . next ; } if ( vertex . next = = = null ) { this . tail = vertex . prev ; } else { vertex . next . prev = vertex . prev ; } return this ; } 
function ( a , b ) { if ( a . prev = = = null ) { this . head = b . next ; } else { a . prev . next = b . next ; } if ( b . next = = = null ) { this . tail = a . prev ; } else { b . next . prev = a . prev ; } return this ; } 
function ( container ) { this . _container = container ; this . _modes = { load : { name : 'load ' , color : ' #FF 0 0 0 0 ' } , parse : { name : 'parse ' , color : ' # 0 0FF 0 0 ' } } ; this . _request Animation Frame ID = null ; this . _mode = null ; this . _value = null ; this . _total = null ; this . init = function ( ) { var container = document . create Element ( 'div ' ) ; container . class List . add ( 'progress ' ) ; container . class List . add ( 'container ' ) ; container . inner HTML = ' <div class = "progress load " > < /div > <div class = "progress parse " >Parsing data <div class = "beat " > ♥ < /div > < /div > ' ; this . _container . append Child ( container ) ; 
function on Window Resize ( ) { camera . aspect = container . offset Width / container . offset Height ; camera . update Projection Matrix ( ) ; renderer . set Size ( container . offset Width , container . offset Height ) ; } 
function animate ( ) { 
function info ( msg ) { if ( PDFJS . verbosity > = PDFJS . VERBOSITY _LEVELS . infos ) { console . log ( 'Info : ' + msg ) ; } } 
function warn ( msg ) { if ( PDFJS . verbosity > = PDFJS . VERBOSITY _LEVELS . warnings ) { console . log ( 'Warning : ' + msg ) ; } } 
function error ( msg ) { 
function combine Url ( base Url , url ) { if ( ! url ) { return base Url ; } if ( / ^ [a -z ] [a -z 0 - 9 + \ - . ] * : / i . test ( url ) ) { return url ; } var i ; if ( url . char At ( 0 ) = = = ' / ' ) { 
function is Valid Url ( url , allow Relative ) { if ( ! url ) { return false ; } 
function has Canvas Typed Arrays ( ) { var canvas = document . create Element ( 'canvas ' ) ; canvas . width = canvas . height = 1 ; var ctx = canvas . get Context ( ' 2d ' ) ; var image Data = ctx . create Image Data ( 1 , 1 ) ; return ( typeof image Data . data . buffer ! = = 'undefined ' ) ; } 
function Page View Port _clone ( args ) { args = args | | { } ; var scale = 'scale ' in args ? args . scale : this . scale ; var rotation = 'rotation ' in args ? args . rotation : this . rotation ; return new Page Viewport ( this . view Box . slice ( ) , scale , rotation , this . offset X , this . offset Y , args . dont Flip ) ; } 
function Page Viewport _convert To Viewport Rectangle ( rect ) { var tl = Util . apply Transform ( [ rect [ 0 ] , rect [ 1 ] ] , this . transform ) ; var br = Util . apply Transform ( [ rect [ 2 ] , rect [ 3 ] ] , this . transform ) ; return [ tl [ 0 ] , tl [ 1 ] , br [ 0 ] , br [ 1 ] ] ; } 
function create Promise Capability ( ) { var capability = { } ; capability . promise = new Promise ( function ( resolve , reject ) { capability . resolve = resolve ; capability . reject = reject ; } ) ; return capability ; } 
function message Handler Send ( action Name , data , transfers ) { var message = { action : action Name , data : data } ; this . post Message ( message , transfers ) ; } 
function message Handler Send With Promise ( action Name , data , transfers ) { var callback Id = this . callback Index + + ; var message = { action : action Name , data : data , callback Id : callback Id } ; var capability = create Promise Capability ( ) ; this . callbacks Capabilities [ callback Id ] = capability ; try { this . post Message ( message , transfers ) ; } catch ( e ) { capability . reject ( e ) ; } return capability . promise ; } 
function ( message , transfers ) { if ( transfers & & this . post Message Transfers ) { this . com Obj . post Message ( message , transfers ) ; } else { this . com Obj . post Message ( message ) ; } } 
function init ( ) { function animate ( ) { 
function hook Callbacks ( stack Helper ) { let stack = stack Helper . _stack ; * On window resize callback * / function on Window Resize ( ) { let three D = document . get Element By Id ( 'r 3d ' ) ; camera . canvas = { width : three D . client Width , height : three D . client Height , } ; camera . fit Box ( 2 ) ; renderer . set Size ( three D . client Width , three D . client Height ) ; * On key pressed callback * / function on Window Key Pressed ( event ) { ctrl Down = event . ctrl Key ; if ( ! ctrl Down ) { drag . start . x = null ; drag . start . y = null ; } } document . add Event Listener ( 'keydown ' , on Window Key Pressed , false ) ; document . add Event Listener ( 'keyup ' , on Window Key Pressed , false ) ; function on Mouse Move ( event ) { if ( ctrl Down ) { if ( drag . start . x = = = null ) { drag . start . x = event . client X ; drag . start . y = event . client Y ; } let threshold = 1 5 ; stack Helper . slice . intensity Auto = false ; let dynamic Range = stack . min Max [ 1 ] - stack . min Max [ 0 ] ; dynamic Range / = three D . client Width ; if ( Math . abs ( event . client X - drag . start . x ) > threshold ) { 
function on Window Resize ( ) { let three D = document . get Element By Id ( 'r 3d ' ) ; camera . canvas = { width : three D . client Width , height : three D . client Height , } ; camera . fit Box ( 2 ) ; renderer . set Size ( three D . client Width , three D . client Height ) ; 
function on Window Key Pressed ( event ) { ctrl Down = event . ctrl Key ; if ( ! ctrl Down ) { drag . start . x = null ; drag . start . y = null ; } } 
function on Mouse Move ( event ) { if ( ctrl Down ) { if ( drag . start . x = = = null ) { drag . start . x = event . client X ; drag . start . y = event . client Y ; } let threshold = 1 5 ; stack Helper . slice . intensity Auto = false ; let dynamic Range = stack . min Max [ 1 ] - stack . min Max [ 0 ] ; dynamic Range / = three D . client Width ; if ( Math . abs ( event . client X - drag . start . x ) > threshold ) { 
function handle Series ( series Container ) { 
function _filter By Extension ( extension , item ) { if ( item . extension . to Upper Case ( ) = = = extension . to Upper Case ( ) ) { return true ; } return false ; } 
function read Multiple Files ( evt ) { * Load sequence * / function load Sequence ( index , files ) { return ( Promise . resolve ( ) * Load group sequence * / function load Sequence Group ( files ) { const fetch Sequence = [ ] ; for ( let i = 0 ; i < files . length ; i + + ) { fetch Sequence . push ( new Promise ( ( resolve , reject ) = > { const my Reader = new File Reader ( ) ; 
function load Sequence ( index , files ) { return ( Promise . resolve ( ) 
function load Sequence Group ( files ) { const fetch Sequence = [ ] ; for ( let i = 0 ; i < files . length ; i + + ) { fetch Sequence . push ( new Promise ( ( resolve , reject ) = > { const my Reader = new File Reader ( ) ; 
function rgb To Hex ( r , g , b ) { return ' # ' + component To Hex ( r ) + component To Hex ( g ) + component To Hex ( b ) ; } 
function update Geometries ( ) { if ( stack Helper ) { 
function init ( ) { function animate ( ) { update Geometries ( ) ; render ( ) ; 
function init ( ) { function animate ( ) { 
function animate ( ) { 
function init ( ) { function animate ( ) { render ( ) ; 
function update Localizer ( ref Obj , target Localizers Helpers ) { let ref Helper = ref Obj . stack Helper ; let localizer Helper = ref Obj . localizer Helper ; let plane = ref Helper . slice . cartesian Equation ( ) ; localizer Helper . reference Plane = plane ; 
function Convex Geometry ( points ) { THREE . Geometry . call ( this ) ; this . type = 'Convex Geometry ' ; this . from Buffer Geometry ( new Convex Buffer Geometry ( points ) ) ; this . merge Vertices ( ) ; } 
function Convex Buffer Geometry ( points ) { THREE . Buffer Geometry . call ( this ) ; this . type = 'Convex Buffer Geometry ' ; 
function animate ( ) { 
function setup Editor ( ) { function distance Between ( point 1 , point 2 ) { return Math . sqrt ( Math . pow ( point 2 . x - point 1 . x , 2 ) + Math . pow ( point 2 . y - point 1 . y , 2 ) ) ; } function angle Between ( point 1 , point 2 ) { return Math . atan 2 ( point 2 . x - point 1 . x , point 2 . y - point 1 . y ) ; } function init Editor Stats ( ) { let nb Voxels = stack 2 . _columns * stack 2 . _rows * stack 2 . _frame . length ; let texture Size = 4 0 9 6 ; let texture Dimension = texture Size * texture Size ; for ( let i = 0 ; i < nb Voxels ; i + + ) { let raw Data Index = ~ ~ ( i / texture Dimension ) ; let in Raw Data Index = i % texture Dimension ; let value = stack 2 . raw Data [ raw Data Index ] [ in Raw Data Index ] ; editor Stats [ value ] + = 1 ; } update Editor Stats Dom ( ) ; } function update Editor Stats Dom ( ) { for ( let i = 0 ; i < 3 ; i + + ) { document . get Element By Id ( ` $ { i } ` ) . inner HTML = segments List [ i ] ; document . get Element By Id ( ` $ { i } ` ) . inner HTML = editor Stats [ i ] ; } } function map Canvas To Data ( ) { for ( let i = ijk BBox [ 0 ] ; i < ijk BBox [ 1 ] + 1 ; i + + ) { for ( let j = ijk BBox [ 2 ] ; j < ijk BBox [ 3 ] + 1 ; j + + ) { for ( let k = ijk BBox [ 4 ] ; k < ijk BBox [ 5 ] + 1 ; k + + ) { * * / function draw Circle ( x , y ) { context . begin Path ( ) ; context . arc ( x , y , cursor . size , false , Math . PI * 2 , false ) ; context . close Path ( ) ; context . fill ( ) ; context . stroke ( ) ; } function clear Canvas ( ) { context . clear Rect ( 0 , 0 , context . canvas . width , context . canvas . height ) ; } function add Event Listeners ( ) { function on Mouse Down ( e ) { if ( ! is Editing ) return ; is Drawing = true ; last Point = { x : e . page X - canvas Div . offset Left , y : e . page Y - canvas Div . offset Top , } ; } function on Mouse Move ( e ) { if ( ! is Editing ) return ; current Point = { x : e . page X - canvas Div . offset Left , y : e . page Y - canvas Div . offset Top , } ; context . stroke Style = cursor . color ; context . global Composite Operation = 'xor ' ; context . global Alpha = 0 . 5 ; context . fill Style = cursor . color ; if ( is Drawing ) { let dist = distance Between ( last Point , current Point ) ; let angle = angle Between ( last Point , current Point ) ; for ( let i = 0 ; i < dist ; i + = 5 ) { let x = last Point . x + Math . sin ( angle ) * i ; let y = last Point . y + Math . cos ( angle ) * i ; draw Circle ( x , y ) ; } last Point = current Point ; } else { clear Canvas ( ) ; } * * / function on Mouse Up ( e ) { if ( ! is Editing ) return ; is Drawing = false ; map Canvas To Data ( ) ; clear Canvas ( ) ; update Editor Stats Dom ( ) ; * * / function update DOM ( ) { * * / function on Key Down ( e ) { if ( e . key Code = = = 1 7 ) { is Editing = true ; is Drawing = false ; update DOM ( ) ; } } function on Key Up ( e ) { if ( e . key Code = = = 1 7 ) { is Editing = false ; is Drawing = false ; clear Canvas ( ) ; update DOM ( ) ; } } function disable Right Click ( e ) { e . prevent Default ( ) ; e . stop Propagation ( ) ; return false ; } 
function map Canvas To Data ( ) { for ( let i = ijk BBox [ 0 ] ; i < ijk BBox [ 1 ] + 1 ; i + + ) { for ( let j = ijk BBox [ 2 ] ; j < ijk BBox [ 3 ] + 1 ; j + + ) { for ( let k = ijk BBox [ 4 ] ; k < ijk BBox [ 5 ] + 1 ; k + + ) { 
function get Shortlinker ( ) { if ( global Scope . yoast . shortlinker = = = null ) { global Scope . yoast . shortlinker = new Shortlinker ( ) ; } return global Scope . yoast . shortlinker ; } 
function ( sentence Part Text , auxiliaries , locale ) { this . _sentence Part Text = sentence Part Text ; this . _auxiliaries = auxiliaries ; this . _locale = locale ; this . _is Passive = false ; } 
function ( i 1 8n , options = { } ) { Assessor . call ( this , i 1 8n , options ) ; this . type = "Content Assessor " ; const locale = ( options . has Own Property ( "locale " ) ) ? options . locale : "en _US " ; this . _assessments = [ new Flesch Reading Ease ( content Configuration ( locale ) . flesch Reading ) , new Subheading Distribution Too Long ( ) , paragraph Too Long , new Sentence Length In Text ( content Configuration ( locale ) . sentence Length ) , transition Words , passive Voice , text Presence , sentence Beginnings , 
function Deviation Fragment ( options ) { this . _location = options . location ; this . _fragment = options . word ; this . _syllables = options . syllables ; this . _regex = null ; this . _options = pick ( options , [ "not Followed By " , "also Followed By " ] ) ; } 
function sort Results ( assessment Results ) { return assessment Results . sort ( ( a , b ) = > { 
function map Result ( result ) { result . id = result . get Identifier ( ) ; result . rating = score To Rating ( result . score ) ; result . has Marks = result . has Marks ( ) ; result . marker = result . get Marker ( ) ; 
function map Results ( results ) { const mapped Results = [ ] ; for ( let i = 0 ; i < results . length ; i + + ) { if ( ! results [ i ] . text ) { continue ; } mapped Results . push ( map Result ( results [ i ] ) ) ; } return sort Results ( mapped Results ) ; } 
function ( participle , sentence Part , attributes ) { Participle . call ( this , participle , sentence Part , attributes ) ; this . set Sentence Part Passiveness ( this . is Passive ( ) ) ; } 
function ( args ) { this . keyword = args . keyword ; this . assessor = args . assessor ; this . i 1 8n = args . i 1 8n ; this . output = args . targets . output ; this . overall = args . targets . overall | | "overall Score " ; this . presenter Config = create Config ( args . i 1 8n ) ; this . _disable Marker Buttons = false ; this . _active Marker = false ; } 
function create Tokenizer ( ) { tokens = [ ] ; html Block Tokenizer = core ( function ( token ) { tokens . push ( token ) ; } ) ; html Block Tokenizer . add Rule ( content Regex , "content " ) ; html Block Tokenizer . add Rule ( greater Than Content Regex , "greater -than -sign -content " ) ; html Block Tokenizer . add Rule ( block Element Start Regex , "block -start " ) ; html Block Tokenizer . add Rule ( block Element End Regex , "block -end " ) ; html Block Tokenizer . add Rule ( inline Element Start Regex , "inline -start " ) ; html Block Tokenizer . add Rule ( inline Element End Regex , "inline -end " ) ; html Block Tokenizer . add Rule ( other Element Start Regex , "other -element -start " ) ; html Block Tokenizer . add Rule ( other Element End Regex , "other -element -end " ) ; } 
function get Blocks ( text ) { var blocks = [ ] , depth = 0 , block Start Tag = " " , current Block = " " , block End Tag = " " ; * We try to match the most deep blocks so discard any other blocks that have been started but not * finished . * / if ( " " ! = = block Start Tag & & " " ! = = block End Tag ) { blocks . push ( block Start Tag + current Block + block End Tag ) ; } else if ( " " ! = = current Block . trim ( ) ) { blocks . push ( current Block ) ; } block Start Tag = " " ; current Block = " " ; block End Tag = " " ; break ; } 
function format Number ( number ) { if ( Math . round ( number ) = = = number ) { return number ; } return Math . round ( number * 1 0 0 0 0 ) / 1 0 0 0 0 ; } 
function ( participle , sentence Part , attributes ) { Participle . call ( this , participle , sentence Part , attributes ) ; check Exception . call ( this ) ; } 
function ( participle Exception Regexes ) { var participle = this . get Participle ( ) ; var match = [ ] ; for Each ( participle Exception Regexes , function ( participle Exception Regex ) { var exception Match = participle . match ( participle Exception Regex ) ; if ( exception Match ) { match . push ( exception Match [ 0 ] ) ; } } ) ; if ( match . length > 0 ) { return true ; } return false ; } 
function get Sentence Beginning ( sentence , first Word Exceptions ) { const words = get Words ( strip Tags ( strip Spaces ( sentence ) ) ) ; if ( words . length = = = 0 ) { return " " ; } let first Word = words [ 0 ] . to Locale Lower Case ( ) ; if ( first Word Exceptions . index Of ( first Word ) > - 1 & & words . length > 1 ) { first Word + = " " + words [ 1 ] ; } return first Word ; } 
function text Presence Assessment ( paper , researcher , i 1 8n ) { const text = strip HTMLTags ( paper . get Text ( ) ) ; const url Title = create Anchor Opening Tag ( "https : / /yoa .st / 3 5h " ) ; const url Call To Action = create Anchor Opening Tag ( "https : / /yoa .st / 3 5i " ) ; if ( text . length < 5 0 ) { const result = new Assessment Result ( ) ; result . set Text ( i 1 8n . sprintf ( i 1 8n . dgettext ( "js -text -analysis " , " % 1 $s Not enough content % 2 $s : % 3 $s Please add some content to enable a good analysis % 2 $s . " ) , url Title , " < /a > " , url Call To Action ) ) ; result . set Score ( 3 ) ; return result ; } return new Assessment Result ( ) ; } 
function split On Words ( sentence , stopwords ) { const split Sentences = [ ] ; 
function create Sentence Parts ( sentences , language ) { const auxiliary Regex = language Variables [ language ] . auxiliary Regex ; const Sentence Part = language Variables [ language ] . Sentence Part ; const sentence Parts = [ ] ; for Each ( sentences , function ( part ) { const found Auxiliaries = sanitize Matches ( part . match ( auxiliary Regex | | [ ] ) ) ; sentence Parts . push ( new Sentence Part ( part , found Auxiliaries , language Variables [ language ] . locale ) ) ; } ) ; return sentence Parts ; } 
function split Sentence ( sentence , language ) { const stopword Regex = language Variables [ language ] . stopword Regex ; const stopwords = sentence . match ( stopword Regex ) | | [ ] ; const split Sentences = split On Words ( sentence , stopwords ) ; return create Sentence Parts ( split Sentences , language ) ; } 
function create Default Snippet Preview ( ) { var target Element = document . get Element By Id ( this . config . targets . snippet ) ; return new Snippet Preview ( { analyzer App : this , target Element : target Element , callbacks : { save Snippet Data : this . config . callbacks . save Snippet Data , } , } ) ; } 
function verify Arguments ( args ) { if ( ! is Object ( args . callbacks . get Data ) ) { throw new Missing Argument ( "The app requires an object with a getdata callback . " ) ; } if ( ! is Object ( args . targets ) ) { throw new Missing Argument ( " `targets ` is a required App argument , `targets ` is not an object . " ) ; } 
function ( args ) { if ( ! is Object ( args ) ) { args = { } ; } defaults Deep ( args , defaults ) ; verify Arguments ( args ) ; this . config = args ; if ( args . debounced Refresh = = = true ) { this . refresh = debounce ( this . refresh . bind ( this ) , input Debounce Delay ) ; } this . _pure Refresh = throttle ( this . _pure Refresh . bind ( this ) , this . config . type Delay ) ; this . callbacks = this . config . callbacks ; this . i 1 8n = this . construct I 1 8n ( this . config . translations ) ; this . initialize Assessors ( args ) ; this . pluggable = new Pluggable ( this ) ; this . get Data ( ) ; this . default Output Element = this . get Default Output Element ( args ) ; if ( this . default Output Element ! = = " " ) { this . show Loading Dialog ( ) ; } if ( is Valid Snippet Preview ( args . snippet Preview ) ) { this . snippet Preview = args . snippet Preview ; if ( this . snippet Preview . ref Obj ! = = this ) { this . snippet Preview . ref Obj = this ; this . snippet Preview . _i 1 8n = this . i 1 8n ; } } else if ( args . has Snippet Preview ) { this . snippet Preview = create Default Snippet Preview . call ( this ) ; } this . _assessor Options = { use Corner Stone : false , use Keyword Distribution : false , } ; this . init Snippet Preview ( ) ; this . init Assessor Presenters ( ) ; } 
function get Word Combinations ( text , combination Size , function Words ) { const sentences = get Sentences ( text ) ; let words , combination ; return flat Map ( sentences , function ( sentence ) { sentence = sentence . to Locale Lower Case ( ) ; sentence = normalize Quotes ( sentence ) ; words = get Words ( sentence ) ; return filter ( map ( words , function ( word , i ) { 
function calculate Occurrences ( word Combinations ) { const occurrences = { } ; for Each ( word Combinations , function ( word Combination ) { const combination = word Combination . get Combination ( ) ; if ( ! has ( occurrences , combination ) ) { occurrences [ combination ] = word Combination ; } occurrences [ combination ] . increment Occurrences ( ) ; } ) ; return values ( occurrences ) ; } 
function get Relevant Combinations ( word Combinations ) { word Combinations = word Combinations . filter ( function ( combination ) { return combination . get Occurrences ( ) ! = = 1 & & combination . get Relevance ( ) ! = = 0 ; } ) ; return word Combinations ; } 
function sort Combinations ( word Combinations ) { word Combinations . sort ( function ( combination A , combination B ) { const difference = combination B . get Relevance ( ) - combination A . get Relevance ( ) ; 
function filter One Character Word Combinations ( word Combinations ) { return word Combinations . filter ( function ( combination ) { return ! ( combination . get Length ( ) = = = 1 & & combination . get Words ( ) [ 0 ] . length < = 1 ) ; } ) ; } 
function filter Function Words Anywhere ( word Combinations , function Words ) { return word Combinations . filter ( function ( combination ) { return is Empty ( intersection ( function Words , combination . get Words ( ) ) ) ; } ) ; } 
function filter Function Words At Beginning ( word Combinations , function Words ) { return word Combinations . filter ( function ( combination ) { return ! includes ( function Words , combination . get Words ( ) [ 0 ] ) ; } ) ; } 
function filter Function Words At Ending ( word Combinations , function Words ) { return word Combinations . filter ( function ( combination ) { const words = combination . get Words ( ) ; const last Word Index = words . length - 1 ; return ! includes ( function Words , words [ last Word Index ] ) ; } ) ; } 
function filter Function Words At Beginning And Ending ( word Combinations , function Words ) { word Combinations = filter Function Words At Beginning ( word Combinations , function Words ) ; word Combinations = filter Function Words At Ending ( word Combinations , function Words ) ; return word Combinations ; } 
function filter On Density ( word Combinations , word Count , lower Limit , upper Limit ) { return word Combinations . filter ( function ( combination ) { return ( combination . get Density ( word Count ) > = lower Limit & & combination . get Density ( word Count ) < upper Limit ) ; } ) ; } 
function filter Ending With ( word Combinations , str , exceptions ) { word Combinations = word Combinations . filter ( function ( combination ) { const combinationstr = combination . get Combination ( ) ; for ( let i = 0 ; i < exceptions . length ; i + + ) { if ( combinationstr . ends With ( exceptions [ i ] ) ) { return true ; } } return ! combinationstr . ends With ( str ) ; } ) ; return word Combinations ; } 
function filter Function Words ( combinations , function Words ) { combinations = filter Function Words Anywhere ( combinations , function Words . filtered Anywhere ) ; combinations = filter Function Words At Beginning And Ending ( combinations , function Words . filtered At Beginning And Ending ) ; combinations = filter Function Words At Ending ( combinations , function Words . filtered At Ending ) ; combinations = filter Function Words At Beginning ( combinations , function Words . filtered At Beginning ) ; return combinations ; } 
function filter Combinations ( combinations , function Words , language ) { combinations = filter Function Words Anywhere ( combinations , special Characters ) ; combinations = filter One Character Word Combinations ( combinations ) ; combinations = filter Function Words ( combinations , function Words ) ; if ( language = = = "en " ) { combinations = filter Ending With ( combinations , " 's " , [ ] ) ; } return combinations ; } 
function get Relevant Words ( text , locale ) { let language = get Language ( locale ) ; if ( ! function Word Lists . has Own Property ( language ) ) { language = "en " ; } const function Words = function Word Lists [ language ] ; const words = get Word Combinations ( text , 1 , function Words . all ) ; const word Count = words . length ; let one Word Combinations = get Relevant Combinations ( calculate Occurrences ( words ) ) ; sort Combinations ( one Word Combinations ) ; one Word Combinations = take ( one Word Combinations , 1 0 0 ) ; const one Word Relevance Map = { } ; for Each ( one Word Combinations , function ( combination ) { one Word Relevance Map [ combination . get Combination ( ) ] = combination . get Relevance ( ) ; } ) ; const two Word Combinations = calculate Occurrences ( get Word Combinations ( text , 2 , function Words . all ) ) ; const three Word Combinations = calculate Occurrences ( get Word Combinations ( text , 3 , function Words . all ) ) ; const four Word Combinations = calculate Occurrences ( get Word Combinations ( text , 4 , function Words . all ) ) ; const five Word Combinations = calculate Occurrences ( get Word Combinations ( text , 5 , function Words . all ) ) ; let combinations = one Word Combinations . concat ( two Word Combinations , three Word Combinations , four Word Combinations , five Word Combinations ) ; combinations = filter Combinations ( combinations , function Words , language ) ; for Each ( combinations , function ( combination ) { combination . set Relevant Words ( one Word Relevance Map ) ; } ) ; combinations = get Relevant Combinations ( combinations ) ; sort Combinations ( combinations ) ; if ( word Count > = word Count Lower Limit ) { combinations = filter On Density ( combinations , word Count , density Lower Limit , density Upper Limit ) ; } return take ( combinations , relevant Word Limit ) ; } 
function Word Combination ( words , occurrences , function Words ) { this . _words = words ; this . _length = words . length ; this . _occurrences = occurrences | | 0 ; this . _function Words = function Words ; } 
function create Assessment ( name , score = 9 , text = "Excellent " ) { const assessment = new Assessment ( ) ; assessment . identifier = name ; assessment . get Result = ( ) = > { const result = new Assessment Result ( ) ; result . set Score ( score ) ; result . set Text ( text ) ; return result ; } ; return assessment ; } 
function Missing Argument Error ( message ) { Error . capture Stack Trace ( this , this . constructor ) ; this . name = this . constructor . name ; this . message = message ; } 
function create Tokenizer ( ) { tokens = [ ] ; url Tokenizer = core ( function ( token ) { tokens . push ( token ) ; } ) ; url Tokenizer . add Rule ( static Regex , "static " ) ; url Tokenizer . add Rule ( variable Regex , "variable " ) ; } 
function ( participle , sentence Part , attributes ) { this . set Participle ( participle ) ; this . set Sentence Part ( sentence Part ) ; this . _determines Sentence Part Is Passive = false ; attributes = attributes | | { } ; defaults ( attributes , default Attributes ) ; validate Attributes ( attributes ) ; this . _attributes = attributes ; } 
function base To String ( value ) { 
function get Subheadings Top Level ( text ) { const subheadings = [ ] ; const regex = / <h ( [ 2 - 3 ] ) ( ? : [ ^ > ] + ) ? > ( . * ? ) < \ /h \ 1 > / ig ; let match ; while ( ( match = regex . exec ( text ) ) ! = = null ) { subheadings . push ( match ) ; } return subheadings ; } 
function get Sentences From Block ( block ) { const sentence Tokenizer = new Sentence Tokenizer ( ) ; const { tokenizer , tokens } = sentence Tokenizer . create Tokenizer ( ) ; sentence Tokenizer . tokenize ( tokenizer , block ) ; return tokens . length = = = 0 ? [ ] : sentence Tokenizer . get Sentences From Tokens ( tokens ) ; } 
function create Blob URL ( url ) { const URL = window . URL | | window . webkit URL ; const Blob Builder = window . Blob Builder | | window . Web Kit Blob Builder | | window . Moz Blob Builder ; let blob ; try { blob = new Blob ( [ "import Scripts ( ' " + url + " ' ) ; " ] , { type : "application /javascript " } ) ; } catch ( e 1 ) { const blob Builder = new Blob Builder ( ) ; blob Builder . append ( "import Scripts ( ' " + url + " ' ) ; " ) ; blob = blob Builder . get Blob ( "application /javascript " ) ; } return URL . create Object URL ( blob ) ; } 
function create Worker ( url ) { let worker = null ; try { worker = new Worker ( url ) ; } catch ( e ) { try { const blob Url = create Blob URL ( url ) ; worker = new Worker ( blob Url ) ; } catch ( e 2 ) { throw e 2 ; } } return worker ; } 
function ( i 1 8n , options ) { this . type = "Assessor " ; this . set I 1 8n ( i 1 8n ) ; this . _assessments = [ ] ; this . _options = options | | { } ; if ( ! is Undefined ( this . _options . researcher ) ) { this . _researcher = this . _options . researcher ; } } 
function configure Store ( preloaded State = { } , extra Middleware = [ ] ) { const enhancers = configure Enhancers ( extra Middleware ) ; return create Store ( root Reducer , preloaded State , enhancers ) ; } 
function remove Links From Text ( text ) { const anchors = get Anchors From Text ( text ) ; if ( anchors . length > 0 ) { anchors . for Each ( function ( anchor ) { text = text . replace ( anchor , " " ) ; } ) ; } return text ; } 
function remove Images From Text ( text ) { const images = image In Text ( text ) ; const image Tags = match String With Regex ( text , " < /img > " ) ; if ( images . length > 0 ) { images . for Each ( function ( image ) { text = text . replace ( image , " " ) ; } ) ; image Tags . for Each ( function ( image Tag ) { text = text . replace ( image Tag , " " ) ; } ) ; } return text ; } 
function paragraph Has No Text ( text ) { 
function get Relevant Words ( text , locale ) { if ( ! is Equal ( text , previous Relevant Words . text ) | | ! is Equal ( locale , previous Relevant Words . locale ) ) { previous Relevant Words = { text , locale , data : calculate Relevant Words ( text , locale ) , } ; } return previous Relevant Words . data ; } 
function ( ) { var base URL = this . opts . base URL ; if ( this . has App ( ) & & ! is Empty ( this . ref Obj . raw Data . base Url ) & & this . opts . base URL = = = defaults . base URL ) { base URL = this . ref Obj . raw Data . base Url ; } return base URL ; } 
function update Unformatted Text ( key , value ) { this . element . input [ key ] . value = value ; this . data [ key ] = value ; } 
function rate Title Length ( title Length ) { var rating ; switch ( true ) { case title Length > 0 & & title Length < = 3 9 9 : case title Length > 6 0 0 : rating = "ok " ; break ; case title Length > = 4 0 0 & & title Length < = 6 0 0 : rating = "good " ; break ; default : rating = "bad " ; break ; } return rating ; } 
function rate Meta Desc Length ( meta Desc Length ) { var rating ; switch ( true ) { case meta Desc Length > 0 & & meta Desc Length < 1 2 0 : case meta Desc Length > maximum Meta Description Length : rating = "ok " ; break ; case meta Desc Length > = 1 2 0 & & meta Desc Length < = maximum Meta Description Length : rating = "good " ; break ; default : rating = "bad " ; break ; } return rating ; } 
function update Progress Bar ( element , value , maximum , rating ) { var bar Element , progress , all Classes = [ "snippet -editor _ _progress - -bad " , "snippet -editor _ _progress - -ok " , "snippet -editor _ _progress - -good " , ] ; element . value = value ; dom Manipulation . remove Classes ( element , all Classes ) ; dom Manipulation . add Class ( element , "snippet -editor _ _progress - - " + rating ) ; if ( ! this . has Progress Support ) { bar Element = element . get Elements By Class Name ( "snippet -editor _ _progress -bar " ) [ 0 ] ; progress = ( value / maximum ) * 1 0 0 ; bar Element . style . width = progress + " % " ; } } 
function ( opts ) { defaults Deep ( opts , defaults ) ; this . data = opts . data ; if ( ! is Undefined ( opts . analyzer App ) ) { this . ref Obj = opts . analyzer App ; this . i 1 8n = this . ref Obj . i 1 8n ; this . data = { title : this . ref Obj . raw Data . snippet Title | | " " , url Path : this . ref Obj . raw Data . snippet Cite | | " " , meta Desc : this . ref Obj . raw Data . snippet Meta | | " " , } ; 
function get Analyzer Title ( ) { var title = this . data . title ; if ( is Empty ( title ) ) { title = this . opts . default Value . title ; } if ( this . has Pluggable ( ) ) { title = this . ref Obj . pluggable . _apply Modifications ( "data _page _title " , title ) ; } return strip Spaces ( title ) ; } 
function ( ) { var meta Desc = this . data . meta Desc ; if ( is Empty ( meta Desc ) ) { meta Desc = this . opts . default Value . meta Desc ; } if ( this . has Pluggable ( ) ) { meta Desc = this . ref Obj . pluggable . _apply Modifications ( "data _meta _desc " , meta Desc ) ; } if ( ! is Empty ( this . opts . meta Description Date ) & & ! is Empty ( meta Desc ) ) { meta Desc = this . opts . meta Description Date + " - " + this . data . meta Desc ; } return strip Spaces ( meta Desc ) ; } 
function show Trace ( error Message ) { if ( is Undefined ( error Message ) ) { error Message = " " ; } if ( ! is Undefined ( console ) & & ! is Undefined ( console . trace ) ) { console . trace ( error Message ) ; } } 
function get Indices By Word ( word , text ) { var start Index = 0 ; var search String Length = word . length ; var index , indices = [ ] ; while ( ( index = text . index Of ( word , start Index ) ) > - 1 ) { 
function ( words , text ) { var matched Words = [ ] ; for Each ( words , function ( word ) { word = strip Spaces ( word ) ; if ( ! match Word In Sentence ( word , text ) ) { return ; } matched Words = matched Words . concat ( get Indices By Word ( word , text ) ) ; } ) ; return matched Words ; } 
function ( indices ) { indices = sort Indices ( indices ) ; var filtered = [ ] ; for ( var i = 0 ; i < indices . length ; i + + ) { 
function ( words , text ) { var matched Words = [ ] ; for Each ( words , function ( word ) { word = strip Spaces ( word ) ; if ( ! match Word In Sentence ( word , text ) ) { return matched Words ; } matched Words = matched Words . concat ( get Indices By Word ( word , text ) ) ; } ) ; matched Words = matched Words . sort ( function ( a , b ) { if ( a . index < b . index ) { return - 1 ; } if ( a . index > b . index ) { return 1 ; } return 0 ; } ) ; return matched Words ; } 
function create Measurement Element ( ) { const hidden Element = document . create Element ( "div " ) ; hidden Element . id = element Id ; 
function ( app ) { this . app = app ; this . loaded = false ; this . preload Threshold = 3 0 0 0 ; this . plugins = { } ; this . modifications = { } ; this . custom Tests = [ ] ; 
function ( paper ) { this . set Paper ( paper ) ; this . default Researches = { url Length : url Length , word Count In Text : word Count In Text , find Keyword In Page Title : find Keyword In Page Title , calculate Flesch Reading : calculate Flesch Reading , get Link Statistics : get Link Statistics , get Links : get Links , link Count : link Count , image Count : image Count , alt Tag Count : alt Tag Count , match Keyword In Subheadings : match Keyword In Subheadings , keyword Count : keyword Count , get Keyword Density : get Keyword Density , stop Words In Keyword : stop Words In Keyword , stop Words In Url : stop Words In Url , meta Description Length : meta Description Length , keyphrase Length : keyphrase Length , keyword Count In Url : keyword Count In Url , first Paragraph : find Keyword In First Paragraph , meta Description Keyword : meta Description Keyword , page Title Width : page Title Width , word Complexity : word Complexity , get Paragraph Length : get Paragraph Length , count Sentences From Text : count Sentences From Text , count Sentences From Description : count Sentences From Description , get Subheading Text Lengths : get Subheading Text Lengths , find Transition Words : find Transition Words , passive Voice : passive Voice , get Sentence Beginnings : get Sentence Beginnings , relevant Words : relevant Words , reading Time : reading Time , get Topic Density : get Topic Density , topic Count : topic Count , sentences , keyphrase Distribution : keyphrase Distribution , morphology : morphology , function Words In Keyphrase : function Words In Keyphrase , h 1s : h 1s , } ; this . _data = { } ; this . custom Researches = { } ; } 
function are Equal ( url A , url B ) { 
function is Internal Link ( url , host ) { const parsed Url = url Methods . parse ( url , false , true ) ; 
function ( word , locale ) { var number Of Syllables = 0 ; var vowel Regex = new Reg Exp ( " [ ^ " + syllable Matchers ( locale ) . vowels + " ] " , "ig " ) ; var found Vowels = word . split ( vowel Regex ) ; var filtered Words = filter ( found Vowels , function ( vowel ) { return vowel ! = = " " ; } ) ; number Of Syllables + = filtered Words . length ; return number Of Syllables ; } 
function ( word , locale ) { var full Word Deviations = syllable Matchers ( locale ) . deviations . words . full ; var deviation = find ( full Word Deviations , function ( full Word Deviation ) { return full Word Deviation . word = = = word ; } ) ; if ( ! is Undefined ( deviation ) ) { return deviation . syllables ; } return 0 ; } 
function create Deviation Fragments ( syllable Config ) { var deviation Fragments = [ ] ; var deviations = syllable Config . deviations ; if ( ! is Undefined ( deviations . words ) & & ! is Undefined ( deviations . words . fragments ) ) { deviation Fragments = flat Map ( deviations . words . fragments , function ( fragments , fragment Location ) { return map ( fragments , function ( fragment ) { fragment . location = fragment Location ; return new Deviation Fragment ( fragment ) ; } ) ; } ) ; } return deviation Fragments ; } 
function ( word , locale ) { var deviation Fragments = create Deviation Fragments Memoized ( syllable Matchers ( locale ) ) ; var remaining Parts = word ; var syllable Count = 0 ; for Each ( deviation Fragments , function ( deviation Fragment ) { if ( deviation Fragment . occurs In ( remaining Parts ) ) { remaining Parts = deviation Fragment . remove From ( remaining Parts ) ; syllable Count + = deviation Fragment . get Syllables ( ) ; } } ) ; return { word : remaining Parts , syllable Count : syllable Count } ; } 
function ( word , locale ) { var syllable Count = 0 ; syllable Count + = count Vowel Groups ( word , locale ) ; syllable Count + = count Vowel Deviations ( word , locale ) ; return syllable Count ; } 
function ( word , locale ) { var syllable Count = 0 ; var full Word Exclusion = count Full Word Deviations ( word , locale ) ; if ( full Word Exclusion ! = = 0 ) { return full Word Exclusion ; } var partial Exclusions = count Partial Word Deviations ( word , locale ) ; word = partial Exclusions . word ; syllable Count + = partial Exclusions . syllable Count ; syllable Count + = count Using Vowels ( word , locale ) ; return syllable Count ; } 
function ( text , locale ) { text = text . to Locale Lower Case ( ) ; var words = get Words ( text ) ; var syllable Counts = map ( words , function ( word ) { return count Syllables In Word ( word , locale ) ; } ) ; return sum ( syllable Counts ) ; } 
function ( array , language ) { if ( is Undefined ( language ) | | language = = = " " ) { language = "en " ; } const function Words = get ( get Function Words , [ language ] , [ ] ) ; if ( array . length > 1 ) { const array Filtered = filter ( array , function ( word ) { return ( ! includes ( function Words . all , word . trim ( ) . to Locale Lower Case ( ) ) ) ; } ) ; if ( array Filtered . length > 0 ) { return array Filtered ; } } return array ; } 
function ( keyphrase , language , morphology Data ) { if ( is Undefined ( keyphrase ) | | keyphrase = = = " " ) { return [ ] ; } const double Quotes = [ " “ " , " " , " 〝 " " 〞 " , 〟 " , " ‟ , " „ " , " \ " " ] if ( includes ( double Quotes , keyphrase [ 0 ] ) & & includes ( double Quotes , keyphrase [ keyphrase . length - 1 ] ) ) { keyphrase = keyphrase . substring ( 1 , keyphrase . length - 1 ) ; return [ unique ( [ ] . concat ( escape Reg Exp ( keyphrase ) , get Variations Apostrophe ( keyphrase ) ) ) ] ; } const words = filter Function Words ( get Words ( keyphrase ) , language ) ; const forms = [ ] ; const get Forms = get Forms For Language [ language ] ; / * * Only returns the keyword and the keyword with apostrophe variations if morphological forms cannot be built . * Otherwise additionally returns the morphological forms . * / if ( morphology Data = = = false | | is Undefined ( get Forms ) ) { words . for Each ( function ( word ) { const word To Lower Case = escape Reg Exp ( word . to Locale Lower Case ( language ) ) ; forms . push ( unique ( [ ] . concat ( word To Lower Case , get Variations Apostrophe ( word To Lower Case ) ) ) ) ; } ) ; } else { words . for Each ( function ( word ) { const word To Lower Case = escape Reg Exp ( word . to Locale Lower Case ( ) ) ; const forms Of This Word = language = = = "de " ? get Forms ( word To Lower Case , morphology Data ) . forms : get Forms ( word To Lower Case , morphology Data ) ; const variations Apostrophes = get Variations Apostrophe In Array ( forms Of This Word ) ; forms . push ( unique ( flatten ( forms Of This Word . concat ( variations Apostrophes ) ) ) . filter ( Boolean ) ) ; } ) ; } return forms ; } 
function ( keyphrase , synonyms , language = "en " , morphology Data ) { const synonyms Split = parse Synonyms ( synonyms ) ; const keyphrase Forms = build Forms ( keyphrase , language , morphology Data ) ; const synonyms Forms = synonyms Split . map ( synonym = > build Forms ( synonym , language , morphology Data ) ) ; return { keyphrase Forms : keyphrase Forms , synonyms Forms : synonyms Forms , } ; } 
function collect Forms ( keyphrase , synonyms , language = "en " , morphology Data ) { const collect Forms With Morphology Data = prime Morphology Data ( morphology Data ) ; return collect Forms With Morphology Data ( keyphrase , synonyms , language ) ; } 
function research ( paper , researcher ) { const language = get Language ( paper . get Locale ( ) ) ; const morphology Data = get ( researcher . get Data ( "morphology " ) , [ language ] , false ) ; return collect Forms ( paper . get Keyword ( ) , paper . get Synonyms ( ) , language , morphology Data ) ; } 
function Invalid Type Error ( message ) { Error . capture Stack Trace ( this , this . constructor ) ; this . name = this . constructor . name ; this . message = message ; } 
function get Regex From Double Array ( two Part Transition Words ) { const cache Key = flatten Deep ( two Part Transition Words ) . join ( " " ) ; if ( regex From Double Array Cache Key ! = = cache Key | | regex From Double Array = = = null ) { regex From Double Array Cache Key = cache Key ; regex From Double Array = create Regex From Double Array ( two Part Transition Words ) ; } return regex From Double Array ; } 
function ( sentence , two Part Transition Words ) { sentence = normalize Single Quotes ( sentence ) ; const two Part Transition Words Regex = get Regex From Double Array ( two Part Transition Words ) ; return sentence . match ( two Part Transition Words Regex ) ; } 
function ( sentence , transition Words ) { sentence = normalize Single Quotes ( sentence ) ; return transition Words . filter ( word = > match Word In Sentence ( word , sentence ) ) ; } 
function ( sentences , transition Words ) { const results = [ ] ; sentences . for Each ( sentence = > { const two Part Matches = match Two Part Transition Words ( sentence , transition Words . two Part Transition Words ( ) ) ; if ( two Part Matches ! = = null ) { results . push ( { sentence : sentence , transition Words : two Part Matches , } ) ; return ; } const transition Word Matches = match Transition Words ( sentence , transition Words . transition Words ) ; if ( transition Word Matches . length ! = = 0 ) { results . push ( { sentence : sentence , transition Words : transition Word Matches , } ) ; return ; } } ) ; return results ; } 
function Results ( { seo , readability , active Marker , on Mark } ) { return < Fragment > < Horizontal Container margin Top = " 0 " > < Score Icon score = { readability . score / 1 0 } / > < H 3 > Readability < / H 3 > < / Horizontal Container > < Analysis List results = { readability . results } marks Button Activated Result = { active Marker } marks Button Class Name = "yoast -text -mark " on Marks Button Click = { on Mark } / > < Horizontal Container > < Score Icon score = { seo . score / 1 0 } / > < H 3 > SEO < / H 3 > < / Horizontal Container > < Analysis List results = { seo . results } marks Button Activated Result = { active Marker } marks Button Class Name = "yoast -text -mark " on Marks Button Click = { on Mark } / > < / Fragment > ; } 
function get Indices Of Words ( text ) { const indices = [ ] ; const words = get Words ( text ) ; let start Search From = 0 ; words . for Each ( function ( word ) { const current Index = text . index Of ( word , start Search From ) ; indices . push ( current Index ) ; start Search From = current Index + word . length ; } ) ; return indices ; } 
function get Indices Of Character ( text , character To Find ) { const indices = [ ] ; if ( text . index Of ( character To Find ) > - 1 ) { for ( let i = 0 ; i < text . length ; i + + ) { if ( text [ i ] = = = character To Find ) { indices . push ( i ) ; } } } return indices ; } 
function combinations ( collection ) { function acc ( xs , array ) { const x = xs [ 0 ] ; if ( typeof x = = = "undefined " ) { return array ; } for ( let i = 0 , l = array . length ; i < l ; + + i ) { array . push ( array [ i ] . concat ( x ) ) ; } return acc ( xs . slice ( 1 ) , array ) ; } return acc ( collection , [ [ ] ] ) . slice ( 1 ) . concat ( [ [ ] ] ) ; } 
function replace Characters By Index ( text , indices , substitute ) { const modified Text Split By Letter = text . split ( " " ) ; indices . for Each ( function ( index ) { modified Text Split By Letter . splice ( index , 1 , substitute ) ; } ) ; return modified Text Split By Letter . join ( " " ) ; } 
function replace Turkish Is ( text ) { 
function ( values ) { this . _has Score = false ; this . _identifier = " " ; this . _has Marks = false ; this . _marker = empty Marker ; this . score = 0 ; this . text = " " ; this . marks = [ ] ; if ( is Undefined ( values ) ) { values = { } ; } if ( ! is Undefined ( values . score ) ) { this . set Score ( values . score ) ; } if ( ! is Undefined ( values . text ) ) { this . set Text ( values . text ) ; } if ( ! is Undefined ( values . marks ) ) { this . set Marks ( values . marks ) ; } } 
function ( sentence , locale ) { this . _sentence Text = sentence | | " " ; this . _locale = locale | | default Attributes . locale ; this . _is Passive = false ; } 
function ( app ) { var elems = [ "content " , "focus Keyword " , "synonyms " ] ; for ( var i = 0 ; i < elems . length ; i + + ) { document . get Element By Id ( elems [ i ] ) . add Event Listener ( "input " , app . refresh . bind ( app ) ) ; } document . get Element By Id ( "locale " ) . add Event Listener ( "input " , set Locale . bind ( app ) ) ; document . get Element By Id ( "premium " ) . add Event Listener ( "input " , set Premium . bind ( app ) ) ; } 
async function main ( ) { const browser File = document .get Element By Id ( "fileinput " ) .files [ 0 ] ; await upload Browser Data To Azure File (Aborter .none , browser File , file URL , { range Size : 4 * 1 0 2 4 * 1 0 2 4 , parallelism : 2 0 , progress : ev = > console .log (ev ) } ) ; * / 
async function main ( ) { 
async function main ( ) { 
async function stream To String ( readable Stream ) { return new Promise ( ( resolve , reject ) = > { const chunks = [ ] ; readable Stream . on ( "data " , data = > { chunks . push ( data . to String ( ) ) ; } ) ; readable Stream . on ( "end " , ( ) = > { resolve ( chunks . join ( " " ) ) ; } ) ; readable Stream . on ( "error " , reject ) ; } ) ; } 
function determine Frequency ( fu ) { let qstate = new qubits . QState ( num In Bits + num Out Bits ) . hadamard ( input Bits ) ; qstate = qstate . apply Function ( input Bits , out Bits , fu ) ; 
function find Period ( ) { let best So Far = 1 ; for ( let attempts = 0 ; attempts < 2 * num Out Bits ; attempts + = 1 ) { 
function symlink Dependencies ( pkg ) { let name = pkg . name ; let modules Path = path . join ( output Path , name , 'node _modules ' ) ; let dependencies = pkg . internal Dependencies ; 
function start ( ) { Promise . resolve ( ) . delay ( 5 0 0 ) . then ( ( ) = > checker . execute ( ) ) . catch ( console . error ) . then ( ( ) = > broker . stop ( ) ) . then ( ( ) = > checker . print Total ( ) ) ; } 
function ( id , file Name ) { console . info ( ` $ { id } $ { file Name } ` ) ; 
function authenticate ( ) { const auth Promtpts = [ { type : "text " , name : "username " , message : "Username " } , { type : "password " , name : "password " , message : "Password " } ] ; let session ; 
function search For Items ( session ) { const search Prompts = [ { type : "text " , name : "search Text " , message : "Search Query " } , { type : "list " , name : "item Types " , message : "Item Types " } , { type : "list " , name : "item Tags " , message : "Tags " } , { type : "number " , name : "number " , message : "How Many ? " } ] ; 
async function delete Items ( items , session ) { 
function ( ) { 
function ( query ) { 
function triage Friends ( s ) { outgoing = kb . each ( s , foaf ( 'knows ' ) ) incoming = kb . each ( undefined , foaf ( 'knows ' ) , s ) 
function ( kb , x , displayables ) { var t = kb . find Type URIs ( subject ) for ( var k = 0 ; k < displayables . length ; k + + ) { if ( $rdf . Util . media Type Class ( displayables [ k ] ) . uri in t ) { return true } } return false } 
function ( new Pane Options ) { var kb = UI . store var new Instance = new Pane Options . new Instance if ( ! new Instance ) { let uri = new Pane Options . new Base if ( uri . ends With ( ' / ' ) ) { uri = uri . slice ( 0 , - 1 ) new Pane Options . new Base = uri } new Instance = kb . sym ( uri ) } var content Type = mime . lookup ( new Instance . uri ) if ( ! content Type | | ! content Type . includes ( 'html ' ) ) { new Instance = $rdf . sym ( new Instance . uri + ' .html ' ) } new Pane Options . new Instance = new Instance 
function ( subject , my Document ) { var div = my Document . create Element ( 'div ' ) var kb = UI . store 
function ( subject ) { var kb = UI . store var ns = UI . ns var t = kb . find Type URIs ( subject ) if ( t [ ns . ldp ( 'Resource ' ) . uri ] ) return 'Sharing ' 
function ( kb , x , content Types ) { var cts = kb . fetcher . get Header ( x , 'content -type ' ) if ( cts ) { for ( var j = 0 ; j < cts . length ; j + + ) { for ( var k = 0 ; k < content Types . length ; k + + ) { if ( cts [ j ] . index Of ( content Types [ k ] ) > = 0 ) { return true } } } } return false } 
function ( subject ) { var n = UI . store . each ( subject , ns . wf ( 'message ' ) ) . length if ( n > 0 ) return 'Chat ( ' + n + ' ) ' 
function ( ) { var query = new $rdf . Query ( 'IRC log entries ' ) var v = [ ] var vv = [ 'chan ' , 'msg ' , 'date ' , 'list ' , 'pred ' , 'creator ' , 'content ' ] vv . map ( function ( x ) { query . vars . push ( v [ x ] = $rdf . variable ( x ) ) } ) query . pat . add ( v [ 'chan ' ] , ns . foaf ( 'chat Event List ' ) , v [ 'list ' ] ) 
function add New Predicate Object ( e ) { if ( UI . utils . get Target ( e ) . class Name ! = = 'bottom -border -active ' ) return var This = outline . User Input var target = UI . utils . get Target ( e ) 
function add New Object ( e ) { var predicate Td = UI . utils . get Target ( e ) . parent Node . parent Node 
function Click ( e ) { var target = UI . utils . get Target ( e ) if ( UI . utils . get Term ( target ) . term Type ! = = 'Literal ' ) return this . literal Modification ( target ) 
function paste From Clipboard ( address , selected Td ) { function term From ( from Code ) { var term = outline . clipboard [ from Code ] . shift ( ) if ( term = = = null ) { UI . log . warn ( 'no more element in clipboard ! ' ) return } switch ( from Code ) { case 'predicates ' : case 'objects ' : var all Array = outline . clipboard . all for ( var i = 0 ; true ; i + + ) { if ( term . same Term ( all Array [ i ] ) ) { all Array . splice ( i , 1 ) break } } break case 'all ' : throw new Error ( 'hostorical code not understood - what is the Collection ? ' ) } return term } var term switch ( selected Td . class Name ) { case 'undetermined selected ' : term = selected Td . next Sibling ? term From ( 'predicates ' ) : term From ( 'objects ' ) if ( ! term ) return break case 'pred selected ' : 
function start Fill In Text ( selected Td ) { switch ( this . what Sort Of Edit Cell ( selected Td ) ) { case 'Datatype Property -like ' : empty Node (selected Td ) ; this .last Modified =this .create Input Box In (selected Td , " " ) ; this .last Modified .select ( ) ; this .last Modified .add Event Listener ( 'keypress ' ,this .Auto Complete ,false ) ; this .Auto Complete ( 1 ) ; * / } } 
function perform Auto Complete Edit ( selected Td , menu ) { UI . utils . empty Node ( selected Td ) qp ( 'perform Auto Complete Edit . THIS IS = ' + this ) this . last Modified = this . create Input Box In ( selected Td , ' ' ) this . last Modified . select ( ) this . last Modified . add Event Listener ( 'keypress ' , this . get Auto Complete Handler ( menu ) , false ) 
function clear Input And Save ( e ) { if ( ! this . last Modified ) return if ( ! this . last Modified . is New ) { try { var obj = this . get Statement About ( this . last Modified ) . object } catch ( e ) { return } } var s = this . last Modified Stat if ( (s .object .term Type = = = 'Blank Node ' & & !this .stat Is Inverse ) | | s .subject .term Type = = = 'Blank Node ' & & this .stat Is Inverse ) { this .back Out ( ) return * / if ( this . stat Is Inverse ) { if ( s . subject . term Type = = = 'Blank Node ' ) { this . back Out ( ) return } } else { if ( s . object . term Type = = = 'Blank Node ' ) { this . back Out ( ) return } } 
function delete Triple ( selected Td , is Back Out ) { 
function removefromview ( ) { var tr Iterator for ( tr Iterator = removed Tr ; tr Iterator . child Nodes . length = = = 1 ; tr Iterator = tr Iterator . previous Sibling ) ; if ( tr Iterator = = = removed Tr ) { var the Next = tr Iterator . next Sibling if ( the Next . next Sibling & & the Next . child Nodes . length = = = 1 ) { var predicate Td = tr Iterator . first Child predicate Td . set Attribute ( 'rowspan ' , parse Int ( predicate Td . get Attribute ( 'rowspan ' ) ) - 1 ) the Next . insert Before ( tr Iterator . first Child , the Next . first Child ) } removed Tr . parent Node . remove Child ( removed Tr ) } else { 
function clipboard Init ( ) { outline . clipboard = { } outline . clipboard . objects = [ ] outline . clipboard . predicates = [ ] outline . clipboard . all = [ ] } 
function get Auto Complete Handler ( mode ) { qp ( ' \n \n * * * * * In get Auto Complete Handler * * * * * * mode = ' + mode ) if ( mode = = = 'Predicate Auto Complete ' ) { mode = 'predicate ' } else if ( mode ! = = 'Journal TAC ' ) { 
function Wild Card Buttons ( ) { var menu Div = my Document . get Element By Id ( outline . User Input . menu ID ) var div = menu Div . insert Before ( my Document . create Element ( 'div ' ) , menu Div . first Child ) var input 1 = div . append Child ( my Document . create Element ( 'input ' ) ) var input 2 = div . append Child ( my Document . create Element ( 'input ' ) ) input 1 . type = 'button ' ; input 1 . value = 'New . . . ' input 2 . type = 'button ' ; input 2 . value = 'Know its URI ' function highlight Input ( e ) { 
function ( e ) { if ( e . key Code = = = 1 3 ) { if ( outline . target Of ( e ) . tag Name ! = = 'TEXTAREA ' ) { this . clear Input And Save ( ) } else { 
function what Sort Of Edit Cell ( selected Td ) { if ( selected Td . next Sibling ) return 'predicate ' var predicate Term = this . get Statement About ( selected Td ) . predicate 
function create New ( e ) { outline . User Input . clear Menu ( ) var selected Td = outline . get Selection ( ) [ 0 ] var targetdoc = selected Td . parent Node . AJAR _statement . why var new Term = kb . next Symbol ( targetdoc ) outline . User Input . fill In Request ( 'object ' , selected Td , new Term ) 
function get Offset ( el ) { var _lf = 0 var _tp = 0 var oldlf = 0 var oldtp = 0 var newlf = 0 var newtp = 0 
function fill In Request ( type , selected Td , input Term ) { var tr = selected Td . parent Node var stat ; var is Inverse stat = tr . AJAR _statement ; is Inverse = tr . AJAR _inverse var req Term = ( type = = = 'object ' ) ? stat . object : stat . predicate var new Stat var do Next = false eventhandler = function (subject ) { return kb .any (req Term , UI .ns .link ( 'onfillin ' ) ) .value ) } * / } if ( type = = = 'predicate ' ) { 
function ( subject ) { var kb = UI . store var t = kb . find Type URIs ( subject ) 
function render Trip ( subject , this Div ) { var query = new $rdf . Query ( UI . utils . label ( subject ) ) var vars = [ 'date ' , 'transaction ' , 'comment ' , 'type ' , 'in _USD ' ] var v = { } vars . map ( function ( x ) { query . vars . push ( v [ x ] = $rdf . variable ( x ) ) } ) 
function ( ) { var total = { } var trans = kb . each ( undefined , TRIP ( 'trip ' ) , subject ) 
function ( subject ) { var target = kb . any ( subject , ns . meeting ( 'target ' ) ) | | subject var count = kb . each ( target , predicate ) . length if ( count > 0 ) { return UI . utils . label ( predicate ) + ' ' + count } return null } 
function ( subject ) { var kb = UI . store var t = kb . find Type URIs ( subject ) var QU = $rdf . Namespace ( 'http : / /www .w 3 .org / 2 0 0 0 / 1 0 /swap /pim /qif # ' ) var WF = $rdf . Namespace ( 'http : / /www .w 3 .org / 2 0 0 5 / 0 1 /wf /flow # ' ) if ( t [ 'http : / /www .w 3 .org /ns /pim /trip #Trip ' ] | | 
function complain ( message ) { var pre = dom . create Element ( 'pre ' ) pre . set Attribute ( 'style ' , 'background -color : pink ' ) div . append Child ( pre ) pre . append Child ( dom . create Text Node ( message ) ) } 
function ( kb , subject ) { if ( kb . updater . editable ( subject . doc ( ) , kb ) ) return subject . doc ( ) var store = kb . any ( subject . doc ( ) , QU ( 'annotation Store ' ) ) return store } 
function ( c ) { var sort By = kb . sym ( { 'http : / /www .w 3 .org / 2 0 0 5 / 0 1 /wf /flow #Task ' : 'http : / /purl .org /dc /elements / 1 . 1 /created ' , 'http : / /www .w 3 .org /ns /pim /trip #Trip ' : 
function ( uri , ok , body ) { if ( ok ) { 
function ( x , event , selected ) { if ( selected ) { current Subject = x } else { current Subject = null if ( current Mode = = = 1 ) deselect Object ( ) } 
function ( user ) { this . userlist = { } this . uris = { } var my Follows = kb . each ( kb . sym ( user ) , SIOC ( 'follows ' ) ) for ( var mf in my Follows ) { this . add ( kb . any ( my Follows [ mf ] , SIOC ( 'id ' ) ) , my Follows [ mf ] . uri ) } } 
function ( user ) { this . favorites = { } this . favorites URI = ' ' if ( ! user ) { 
function ( kb ) { this . kb = kb 
function ( s , doc , microblog Pane ) { var Tab Manager = function ( doc ) { this . tablist = { } this . doc = doc this . tab View = doc . create Element ( 'ul ' ) this . tab View . class Name = 'tabslist ' } Tab Manager . prototype . create = function ( id , caption , view , is Default ) { var tab = this . doc . create Element ( 'li ' ) tab . inner HTML = caption if ( is Default ) { tab . class Name = 'active ' } tab . id = id let change = this . change let tablist = this . tablist tab . add Event Listener ( 'click ' , function ( evt ) { change ( evt . target . id , tablist , doc ) } , false ) this . tablist [ id ] = { 'view ' : view . id , 'tab ' : tab } this . tab View . append Child ( tab ) } Tab Manager . prototype . get Tab View = function ( ) { return this . tab View } Tab Manager . prototype . change = function ( id , tablist , doc ) { for ( var tab in tablist ) { if ( tab = = = id ) { tablist [ id ] [ 'tab ' ] . class Name = 'active ' doc . get Element By Id ( tablist [ id ] [ 'view ' ] ) . class Name + = ' active ' } else { var view = doc . get Element By Id ( tablist [ tab ] . view ) view . class Name = view . class Name . replace ( / \w *active \w * / , ' ' ) tablist [ tab ] . tab . class Name = tablist [ id ] . tab . class Name . replace ( / \w *active \w * / , ' ' ) } } } this . microblog Pane = microblog Pane var accounts = kb . each ( s , FOAF ( 'holds Account ' ) ) for ( var a in accounts ) { if ( kb . whether ( accounts [ a ] , RDF ( 'type ' ) , SIOC ( 'User ' ) ) & & kb . whether ( kb . any ( accounts [ a ] , SIOC ( 'creator _of ' ) ) , RDF ( 'type ' ) , SIOCt ( 'Microblog ' ) ) ) { var account = accounts [ a ] break } } this . Ifollow = kb . whether ( kb . sym ( mb . get My URI ( ) ) , SIOC ( 'follows ' ) , account ) var resource Type = kb . any ( s , RDF ( 'type ' ) ) if ( resource Type . uri = = = SIOCt ( 'Microblog ' ) . uri | | resource Type . uri = = = SIOCt ( 'Microblog Post ' ) . uri ) { this . this Is Me = ( kb . any ( s , SIOC ( 'has _creator ' ) ) . uri = = = mb . get My URI ( ) ) } else if ( resource Type . uri = = = SIOC ( 'User ' ) . uri ) { this . this Is Me = ( s . uri = = = mb . get My URI ( ) ) } else if ( resource Type . uri = = = FOAF ( 'Person ' ) . uri ) { let me = UI . authn . current User ( ) let me Uri = me & & me . uri this . this Is Me = ( s . uri = = = me Uri ) } else { this . this Is Me = false } this . Tab = new Tab Manager ( doc ) } 
function ( uri , success , response Text , d ) { if ( success = = = true ) { for ( var triple in d ) { kb . add ( d [ triple ] . subject , d [ triple ] . predicate , d [ triple ] . object , d [ triple ] . why ) } xupdate Submit . disabled = false xupdate Status . value = ' ' mb Letter Count ( ) notify ( 'Microblog Updated . ' ) if ( that . this Is Me ) { doc . get Element By Id ( 'post Notification List ' ) . insert Before ( that . generate Post ( d [ 0 ] . subject ) , doc . get Element By Id ( 'post Notification List ' ) . child Nodes [ 0 ] ) } } else { notify ( 'There was a problem submitting your post . ' ) } } 
function ( ) { var id = mb . get User ( Post . creator ) . id var xupdate Status = doc . get Element By Id ( 'xupdate Status ' ) var xin Reply To Container = doc . get Element By Id ( 'xin Reply To Container ' ) var xupdate Submit = doc . get Element By Id ( 'xupdate Submit ' ) xupdate Status . value = ' @ ' + id + ' ' xupdate Status . focus ( ) xin Reply To Container . value = post . uri xupdate Submit . value = 'Reply ' } 
function ( a , success ) { if ( success ) { that . notify ( 'Post deleted . ' ) 
function ( a , success ) { if ( success ) { var delete Container = kb . statements Matching ( undefined , SIOC ( 'container _of ' ) , kb . sym ( doc . get Element By Id ( 'post _ ' + evt . target . parent Node . id ) . get Attribute ( 'content ' ) ) ) sparql Updater . batch _delete _statement ( delete Container , mbconfirm Delete Post ) } else { that . notify ( 'Oops , there was a problem , please try again ' ) evt . target . disabled = false } } 
function ( subject ) { var ns = UI . ns var kb = UI . store var t = kb . find Type URIs ( subject ) if ( t [ ns . rdfs ( 'Class ' ) . uri ] ) return 'creation forms ' 
function display Forms For Relation ( pred , allow Creation ) { var sts = kb . statements Matching ( subject , pred ) const outliner = panes . get Outliner ( dom ) if ( sts . length ) { for ( var i = 0 ; i < sts . length ; i + + ) { outliner . append Property TRs ( box , [ sts [ i ] ] ) var form = sts [ i ] . object var cell = dom . create Element ( 'td ' ) box . last Child . append Child ( cell ) if ( allow Creation ) { cell . append Child ( UI . widgets . new Button ( dom , kb , null , null , subject , form , store , function ( ok , body ) { if ( ok ) { 
function ( subject ) { var kb = UI . store var n = kb . each ( undefined , ns . rdf ( 'type ' ) , subject ) . length if ( n > 0 ) return 'List ( ' + n + ' ) ' 
function Constraint Equal To ( value ) { this . describe = function ( varstr ) { return varstr + ' = ' + value . to NT ( ) } this . test = function ( term ) { return value . same Term ( term ) } return this } 
function save Query ( selection , qs ) { 
function view And Save Query ( outline , selection ) { var qs = outline . qs UI . log . info ( 'outline .doucment is now ' + outline . document . location ) var q = save Query ( selection , qs ) for ( let i = 0 ; i < qs . listeners . length ; i + + ) { qs . listeners [ i ] . get Active View ( ) . view . draw Query ( q ) qs . listeners [ i ] . update Query Controls ( qs . listeners [ i ] . get Active View ( ) ) } } 
function Query Source ( ) { this . queries = [ ] this . listeners = [ ] this . add Query = function ( q ) { var i if ( q . name = = = null | | q . name = = = ' ' ) { q . name = 'Query # ' + ( this . queries . length + 1 ) } q . id = this . queries . length this . queries . push ( q ) for ( i = 0 ; i < this . listeners . length ; i + + ) { if ( this . listeners [ i ] ! = = null ) { this . listeners [ i ] . add Query ( q ) } } } this . remove Query = function ( q ) { var i for ( i = 0 ; i < this . listeners . length ; i + + ) { if ( this . listeners [ i ] ! = = null ) { this . listeners [ i ] . remove Query ( q ) } } if ( this . queries [ q . id ] ! = = null ) { delete this . queries [ q . id ] } } this . add Listener = function ( listener ) { var i this . listeners . push ( listener ) for ( i = 0 ; i < this . queries . length ; i + + ) { if ( this . queries [ i ] ! = = null ) { listener . add Query ( this . queries [ i ] ) } } } this . remove Listener = function ( listener ) { var i for ( i = 0 ; i < this . queries . length ; i + + ) { if ( this . queries [ i ] ! = = null ) { listener . remove Query ( this . queries [ i ] ) } } for ( i = 0 ; i < this . listeners . length ; i + + ) { if ( this . listeners [ i ] = = = listener ) { delete this . listeners [ i ] } } } } 
function ( subject ) { var n = UI . widgets . forms For ( subject ) . length UI . log . debug ( 'Form pane : forms for ' + subject + ' : ' + n ) if ( ! n ) return null return ' ' + n + ' forms ' } 
function ( store , subject ) { kb . fetcher . now Or When Fetched ( store . uri , subject , function ( ok , body ) { if ( ! ok ) return complain ( 'Cannot load store ' + store . uri + ' : ' + body ) mention ( "Where will this information be stored ? " ) var ele = dom .create Element ( 'input ' ) ; box .append Child (ele ) ; ele .set Attribute ( 'type ' , 'text ' ) ; ele .set Attribute ( 'size ' , ' 7 2 ' ) ; ele .set Attribute ( 'maxlength ' , ' 1 0 2 4 ' ) ; ele .set Attribute ( 'style ' , 'font -size : 8 0 % ; color : # 2 2 2 ; ' ) ; ele .value = store .uri * / UI . widgets . append Form ( dom , box , { } , subject , form , store , complain If Bad ) } } ) 
function ( kb , subject , path ) { if ( path . length = = = 0 ) return [ subject ] var oo = kb . each ( subject , path [ 0 ] ) var res = [ ] for ( var i = 0 ; i < oo . length ; i + + ) { res = res . concat ( followeach ( kb , oo [ i ] , path . slice ( 1 ) ) ) } return res } 
function ( subject , dom ) { var outliner = panes . get Outliner ( dom ) var kb = UI . store var arg = UI . ns . arg subject = kb . canon ( subject ) 
function ( subject ) { var kb = UI . store var t = kb . find Type URIs ( subject ) if ( t [ 'http : / /www .w 3 .org / 2 0 0 0 / 1 0 /swap /pim /qif #Period ' ] ) return 'period ' return null 
function ( cat Tail ) { var cats = kb . find Sub Classes NT ( ns . qu ( 'Transaction ' ) ) for ( var cat in cats ) { if ( cats . has Own Property ( cat ) ) { if ( cat . slice ( 1 , - 1 ) . split ( ' # ' ) [ 1 ] = = = cat Tail ) { return kb . sym ( cat . slice ( 1 , - 1 ) ) } } ; } ; return null } 
function statements As Tables ( sts , my Document , initial Roots ) { 
function property Tree ( subject ) { 
function object Tree ( obj ) { var res switch ( obj . term Type ) { case 'Named Node ' : let anchor = my Document . create Element ( 'a ' ) anchor . set Attribute ( 'href ' , obj . uri ) anchor . add Event Listener ( 'click ' , UI . widgets . open Href In Outline Mode , true ) anchor . append Child ( my Document . create Text Node ( UI . utils . label ( obj ) ) ) return anchor case 'Literal ' : if ( ! obj . datatype | | ! obj . datatype . uri ) { res = my Document . create Element ( 'div ' ) res . set Attribute ( 'style ' , 'white -space : pre -wrap ; ' ) res . text Content = obj . value return res } else if ( obj . datatype . uri = = = 'http : / /www .w 3 .org / 1 9 9 9 / 0 2 / 2 2 -rdf -syntax -ns #XMLLiteral ' ) { res = my Document . create Element ( 'div ' ) res . set Attribute ( 'class ' , 'embedded XHTML ' ) res . inner HTML = obj . value 
function ( subject , my Document ) { function alternative Rendering ( ) { var sz = UI . rdf . Serializer ( UI . store ) var res = sz . root Subjects ( sts ) var roots = res . roots var p = { } p . render = function ( s 2 ) { var div = my Document . create Element ( 'div ' ) div . set Attribute ( 'class ' , 'within Document Pane ' ) var plist = kb . statements Matching ( s 2 , undefined , undefined , subject ) outliner . append Property TRs ( div , plist , false , function ( pred , inverse ) { return true } ) return div } for ( var i = 0 ; i < roots . length ; i + + ) { var tr = my Document . create Element ( 'TR ' ) var root = roots [ i ] tr . style . vertical Align = 'top ' var td = outliner . outline Object TD ( root , undefined , tr ) tr . append Child ( td ) div . append Child ( tr ) outliner . outline Expand ( td , root , { 'pane ' : p } ) } } function main Rendering ( ) { var initial Roots = [ ] 
function ( subject ) { var kb = UI . store var ns = UI . ns var type URIs = kb . find Type URIs ( subject ) if ( ns . meeting ( 'Cluster ' ) . uri in type URIs ) { return 'Tabbed ' } return null } 
function ( subject ) { var kb = UI . store var ns = UI . ns var t = kb . find Type URIs ( subject ) if ( t [ ns . ldp ( 'Container ' ) . uri ] | | t [ ns . ldp ( 'Basic Container ' ) . uri ] ) { var contents = kb . each ( subject , ns . ldp ( 'contains ' ) ) var count = 0 contents . map ( function ( file ) { if ( UI . widgets . is Image ( file ) ) count + + } ) return count > 0 ? 'Slideshow ' : null } return null } 
function ( subject , dom ) { var style Sheet = 'https : / /leemark .github .io /better -simple -slideshow /css /simple -slideshow -styles .css ' UI . widgets . add Style Sheet ( dom , style Sheet ) var kb = UI . store var ns = UI . ns var div = dom . create Element ( 'div ' ) div . set Attribute ( 'class ' , 'bss -slides ' ) var t = kb . find Type URIs ( subject ) var predicate if ( t [ ns . ldp ( 'Basic Container ' ) . uri ] | | t [ ns . ldp ( 'Container ' ) . uri ] ) { predicate = ns . ldp ( 'contains ' ) } var images = kb . each ( subject , predicate ) 
function append Remove Icon ( node , subject , remove Node ) { var image = UI . utils . AJARImage ( outline Icons . src . icon _remove _node , 'remove ' , undefined , dom ) image . add Event Listener ( 'click ' , remove Node Icon Mouse Down Listener ) 
function remove And Refresh ( d ) { var table = d . parent Node var par = table . parent Node var placeholder = dom . create Element ( 'table ' ) placeholder . set Attribute ( 'style ' , 'width : 1 0 0 % ; ' ) par . replace Child ( placeholder , table ) table . remove Child ( d ) par . replace Child ( table , placeholder ) 
function append Property TRs ( parent , plist , inverse , predicate Filter ) { ONLY in the case (currently ) when all the values are tagged . Then we treat them as alternatives . * / if ( my Lang > 0 & & lang Tagged = = = dups + 1 ) { for ( let k = j ; k < = j + dups ; k + + ) { if ( outline . labeller . Language Preference & & sel ( plist [ k ] ) . lang . index Of ( outline . labeller . Language Preference ) > = 0 ) { tr . append Child ( this Outline . outline Object TD ( sel ( plist [ k ] ) , defaultpropview , undefined , s ) ) break } } j + = dups * This is to prevent the case where you have a long list of objects * shown , and dangling at the end is ' 1 more ' (which is easily ignored ) * Therefore more objects are shown than hidden . * / tr . show Nobj = function ( n ) { var pred Dups = k - dups var show = ( ( 2 * n ) < pred Dups ) ? n : pred Dups var show Later Array = [ ] if ( pred Dups ! = = 1 ) { predicate TD . set Attribute ( 'rowspan ' , ( show = = = pred Dups ) ? pred Dups : n + 1 ) var l if ( ( show < pred Dups ) & & ( show = = = 1 ) ) { 
function add Button Callbacks ( target , fire On ) { UI . log . debug ( 'Button callbacks for ' + fire On + ' added ' ) var make Icon Callback = function ( icon ) { return function Icon Callback ( req ) { if ( req . index Of ( ' # ' ) > = 0 ) { console . log ( ' @ @ make Icon Callback : Not expecting # in URI whose state changed : ' + req ) 
function selected ( node ) { var a = node . get Attribute ( 'class ' ) if ( a & & ( a . index Of ( 'selected ' ) > = 0 ) ) return true return false } 
function opt On Icon Mouse Down Listener ( e ) { 
function expand Mouse Down Listener ( e ) { 
function outline Expand ( p , subject 1 , options ) { options = options | | { } var pane = options . pane var already = ! ! options . already var immediate = options . immediate UI . log . info ( ' @outline Expand , dom is now ' + dom . location ) 
function render ( ) { subject = kb . canon ( subject ) if ( ! p | | ! p . parent Node | | ! p . parent Node . parent Node ) return false var new Table UI . log . info ( ' @ @ REPAINTING ' ) if ( ! already ) { 
function outline Collapse ( p , subject ) { var row = UI . utils . ancestor ( p , 'TR ' ) row = UI . utils . ancestor ( row . parent Node , 'TR ' ) 
function views Add Property View ( property , pviewfunc , is Default ) { if ( ! views . properties [ property ] ) { views . properties [ property ] = [ ] } views . properties [ property ] . push ( pviewfunc ) if ( is Default ) { 
function view As Boring Default ( obj ) { var tr = rep .append Child (document .create Element ( 'tr ' ) ) ; tr .append Child (document .create Text Node ( obj .elements .length ? ' ( ' + obj .elements .length + ' ) ' : ' (none ) ' ) ) ; * / for ( var i = 0 ; i < obj . elements . length ; i + + ) { var elt = obj . elements [ i ] var row = rep . append Child ( dom . create Element ( 'tr ' ) ) var numcell = row . append Child ( dom . create Element ( 'td ' ) ) numcell . set Attribute ( 'style ' , 'margin : 0 . 2em ; border : none ; padding : 0 ; vertical -align : top ; ' ) numcell . set Attribute ( 'not Selectable ' , 'false ' ) numcell . set Attribute ( 'about ' , obj . to NT ( ) ) numcell . inner HTML = ( i + 1 ) + ' ) ' row . append Child ( this Outline . outline Object TD ( elt ) ) } } else if ( obj . term Type = = = 'Graph ' ) { rep = panes . data Content Pane . statements As Tables ( obj . statements , dom ) rep . set Attribute ( 'class ' , 'nested Formula ' ) } else { UI . log . error ( 'Object ' + obj + ' has unknown term type : ' + obj . term Type ) rep = dom . create Text Node ( ' [unknown Term Type : ' + obj . term Type + ' ] ' ) } 
function view As Image ( obj ) { var img = UI . utils . AJARImage ( obj . uri , UI . utils . label ( obj ) , UI . utils . label ( obj ) , dom ) img . set Attribute ( 'class ' , 'outline Image ' ) return img } 
function read Dicom Data Set Implicit Undefined Length ( byte Stream , vr Callback ) { const elements = { } ; while ( byte Stream . position < byte Stream . byte Array . length ) { const element = read Dicom Element Implicit ( byte Stream , undefined , vr Callback ) ; elements [ element . tag ] = element ; 
function handle File Select ( evt ) { evt . stop Propagation ( ) ; evt . prevent Default ( ) ; 
function read Dicom Data Set Explicit Undefined Length ( byte Stream , warnings ) { const elements = { } ; while ( byte Stream . position < byte Stream . byte Array . length ) { const element = read Dicom Element Explicit ( byte Stream , warnings ) ; elements [ element . tag ] = element ; 
function sha 1 ( buffer , offset , length ) { offset = offset | | 0 ; length = length | | buffer . length ; var sub Array = dicom Parser . shared Copy ( buffer , offset , length ) ; var rusha = new Rusha ( ) ; return rusha . digest ( sub Array ) ; } 
function get Markdown To Text Converter ( ) { const remark = require ( 'remark ' ) const strip = require ( 'strip -markdown ' ) const converter = remark ( ) . use ( strip ) return ( md ) = > String ( converter . process Sync ( md ) ) } 
function ( password , private Key ) { 
function ( password , count ) { 
function ( data ) { 
function ( private Key , password ) { 
function ( sender Priv , recipient Pub , msg , iv , salt ) { 
function ( sender Priv , recipient Pub , msg ) { 
function ( recipient Private , sender Public , _payload ) { 
function ( ua , ua Length ) { let temp = [ ] ; for ( let i = 0 ; i < ua Length ; i + = 4 ) { let x = ua [ i ] * 0x 1 0 0 0 0 0 0 + ( ua [ i + 1 ] | | 0 ) * 0x 1 0 0 0 0 + ( ua [ i + 2 ] | | 0 ) * 0x 1 0 0 + ( ua [ i + 3 ] | | 0 ) ; temp . push ( ( x > 0x 7fffffff ) ? x - 0x 1 0 0 0 0 0 0 0 0 : x ) ; } return Crypto JS . lib . Word Array . create ( temp , ua Length ) ; } 
function ( dest Ua , cryptowords ) { for ( let i = 0 ; i < dest Ua . length ; i + = 4 ) { let v = cryptowords . words [ i / 4 ] ; if ( v < 0 ) v + = 0x 1 0 0 0 0 0 0 0 0 ; dest Ua [ i ] = ( v > > > 2 4 ) ; dest Ua [ i + 1 ] = ( v > > > 1 6 ) & 0xff ; dest Ua [ i + 2 ] = ( v > > > 8 ) & 0xff ; dest Ua [ i + 3 ] = v & 0xff ; } return dest Ua ; } 
function encode Block ( input , input Offset , output , output Offset ) { output [ output Offset + 0 ] = Alphabet [ input [ input Offset + 0 ] > > 3 ] ; output [ output Offset + 1 ] = Alphabet [ ( ( input [ input Offset + 0 ] & 0x 0 7 ) < < 2 ) | ( input [ input Offset + 1 ] > > 6 ) ] ; output [ output Offset + 2 ] = Alphabet [ ( input [ input Offset + 1 ] & 0x 3E ) > > 1 ] ; output [ output Offset + 3 ] = Alphabet [ ( ( input [ input Offset + 1 ] & 0x 0 1 ) < < 4 ) | ( input [ input Offset + 2 ] > > 4 ) ] ; output [ output Offset + 4 ] = Alphabet [ ( ( input [ input Offset + 2 ] & 0x 0F ) < < 1 ) | ( input [ input Offset + 3 ] > > 7 ) ] ; output [ output Offset + 5 ] = Alphabet [ ( input [ input Offset + 3 ] & 0x 7F ) > > 2 ] ; output [ output Offset + 6 ] = Alphabet [ ( ( input [ input Offset + 3 ] & 0x 0 3 ) < < 3 ) | ( input [ input Offset + 4 ] > > 5 ) ] ; output [ output Offset + 7 ] = Alphabet [ input [ input Offset + 4 ] & 0x 1F ] ; } 
function ( p ) { var dx = p . x - this . x , dy = p . y - this . y ; return dx * dx + dy * dy ; } 
function ( x , y ) { return Math . atan 2 ( this . x * y - this . y * x , this . x * x + this . y * y ) ; } 
function start Create Default Re Export Esms ( ) { return globby ( [ _path . resolve ( ` $ { input Lib Openfl Path } ` , ` ` ) ] ) . then ( paths = > { for ( let path of paths ) { 
function ( str , $parent ) { if ( ! str ) { return 0 ; } if ( ! Selectize . $test Input ) { Selectize . $test Input = $ ( ' <span / > ' ) . css ( { position : 'absolute ' , top : - 9 9 9 9 9 , left : - 9 9 9 9 9 , width : 'auto ' , padding : 0 , white Space : 'pre ' } ) . append To ( 'body ' ) ; } Selectize . $test Input . text ( str ) ; transfer Styles ( $parent , Selectize . $test Input , [ 'letter Spacing ' , 'font Size ' , 'font Family ' , 'font Weight ' , 'text Transform ' ] ) ; return Selectize . $test Input . width ( ) ; } 
function ( $input , settings _element ) { var i , n , tag Name , $children , order = 0 ; var options = settings _element . options ; var options Map = { } ; var read Data = function ( $el ) { var data = attr _data & & $el . attr ( attr _data ) ; if ( typeof data = = = 'string ' & & data . length ) { return JSON . parse ( data ) ; } return null ; } ; var add Option = function ( $option , group ) { $option = $ ( $option ) ; var value = hash _key ( $option . val ( ) ) ; if ( ! value & & ! settings . allow Empty Option ) return ; 
function ( ) { var self = this ; var settings = self . settings ; var event NS = self . event NS ; var $window = $ ( window ) ; var $document = $ ( document ) ; var $input = self . $input ; var $wrapper ; var $control ; var $control _input ; var $dropdown ; var $dropdown _content ; var $dropdown _parent ; var input Mode ; var timeout _blur ; var timeout _focus ; var classes ; var classes _plugins ; var input Id ; input Mode = self . settings . mode ; classes = $input . attr ( 'class ' ) | | ' ' ; $wrapper = $ ( ' <div > ' ) . add Class ( settings . wrapper Class ) . add Class ( classes ) . add Class ( input Mode ) ; $control = $ ( ' <div > ' ) . add Class ( settings . input Class ) . add Class ( 'items ' ) . append To ( $wrapper ) ; $control _input = $ ( ' <input type = "text " autocomplete = "off " / > ' ) . append To ( $control ) . attr ( 'tabindex ' , $input . is ( ' :disabled ' ) ? ' - 1 ' : self . tab Index ) ; $dropdown _parent = $ ( settings . dropdown Parent | | $wrapper ) ; $dropdown = $ ( ' <div > ' ) . add Class ( settings . dropdown Class ) . add Class ( input Mode ) . hide ( ) . append To ( $dropdown _parent ) ; $dropdown _content = $ ( ' <div > ' ) . add Class ( settings . dropdown Content Class ) . append To ( $dropdown ) ; if ( input Id = $input . attr ( 'id ' ) ) { $control _input . attr ( 'id ' , input Id + ' -selectized ' ) ; $ ( "label [for = ' " + input Id + " ' ] " ) . attr ( 'for ' , input Id + ' -selectized ' ) ; } if ( self . settings . copy Classes To Dropdown ) { $dropdown . add Class ( classes ) ; } $wrapper . css ( { width : $input [ 0 ] . style . width } ) ; if ( self . plugins . names . length ) { classes _plugins = 'plugin - ' + self . plugins . names . join ( ' plugin - ' ) ; $wrapper . add Class ( classes _plugins ) ; $dropdown . add Class ( classes _plugins ) ; } if ( ( settings . max Items = = = null | | settings . max Items > 1 ) & & self . tag Type = = = TAG _SELECT ) { $input . attr ( 'multiple ' , 'multiple ' ) ; } if ( self . settings . placeholder ) { $control _input . attr ( 'placeholder ' , settings . placeholder ) ; } 
function ( e ) { var self = this ; 
function ( trigger Dropdown ) { var i , j , k , n , groups , groups _order , option , option _html , optgroup , optgroups , html , html _children , has _create _option ; var $active , $active _before , $create ; if ( typeof trigger Dropdown = = = 'undefined ' ) { trigger Dropdown = true ; } var self = this ; var query = $ . trim ( self . $control _input . val ( ) ) ; var results = self . search ( query ) ; var $dropdown _content = self . $dropdown _content ; var active _before = self . $active Option & & hash _key ( self . $active Option . attr ( 'data -value ' ) ) ; 
function ( data ) { var key = hash _key ( data [ this . settings . value Field ] ) ; if ( typeof key = = = 'undefined ' | | key = = = null | | this . options . has Own Property ( key ) ) return false ; data . $order = data . $order | | + + this . order ; this . options [ key ] = data ; return key ; } 
function ( ) { var self = this ; self . loaded Searches = { } ; self . user Options = { } ; self . render Cache = { } ; var options = self . options ; $ . each ( self . options , function ( key , value ) { if ( self . items . index Of ( key ) = = - 1 ) { delete options [ key ] ; } } ) ; self . options = self . sifter . items = options ; self . last Query = null ; self . trigger ( 'option _clear ' ) ; } 
function ( values , silent ) { this . buffer = document . create Document Fragment ( ) ; var child Nodes = this . $control [ 0 ] . child Nodes ; for ( var i = 0 ; i < child Nodes . length ; i + + ) { this . buffer . append Child ( child Nodes [ i ] ) ; } var items = $ . is Array ( values ) ? values : [ values ] ; for ( var i = 0 , n = items . length ; i < n ; i + + ) { this . is Pending = ( i < n - 1 ) ; this . add Item ( items [ i ] , silent ) ; } var control = this . $control [ 0 ] ; control . insert Before ( this . buffer , control . first Child ) ; this . buffer = null ; } 
function ( value , silent ) { var self = this ; var $item , i , idx ; $item = ( value instanceof $ ) ? value : self . get Item ( value ) ; value = hash _key ( $item . attr ( 'data -value ' ) ) ; i = self . items . index Of ( value ) ; if ( i ! = = - 1 ) { $item . remove ( ) ; if ( $item . has Class ( 'active ' ) ) { idx = self . $active Items . index Of ( $item [ 0 ] ) ; self . $active Items . splice ( idx , 1 ) ; } self . items . splice ( i , 1 ) ; self . last Query = null ; if ( ! self . settings . persist & & self . user Options . has Own Property ( value ) ) { self . remove Option ( value , silent ) ; } if ( i < self . caret Pos ) { self . set Caret ( self . caret Pos - 1 ) ; } self . refresh State ( ) ; self . update Placeholder ( ) ; self . update Original Input ( { silent : silent } ) ; self . position Dropdown ( ) ; self . trigger ( 'item _remove ' , value , $item ) ; } } 
function ( ) { if ( ! this . is Required ) return false ; var invalid = ! this . items . length ; this . is Invalid = invalid ; this . $control _input . prop ( 'required ' , invalid ) ; this . $input . prop ( 'required ' , ! invalid ) ; } 
function ( ) { var self = this ; var trigger = self . is Open ; if ( self . settings . mode = = = 'single ' & & self . items . length ) { self . hide Input ( ) ; 
function ( $el ) { var caret = Math . min ( this . caret Pos , this . items . length ) ; var el = $el [ 0 ] ; var target = this . buffer | | this . $control [ 0 ] ; if ( caret = = = 0 ) { target . insert Before ( el , target . first Child ) ; } else { target . insert Before ( el , target . child Nodes [ caret ] ) ; } this . set Caret ( caret + 1 ) ; } 
function ( template Name , data ) { var value , id , label ; var html = ' ' ; var cache = false ; var self = this ; var regex _tag = / ^ [ \t \r \n ] * < ( [a -z ] [a -z 0 - 9 \ - _ ] * ( ? : \ : [a -z ] [a -z 0 - 9 \ - _ ] * ) ? ) / i ; if ( template Name = = = 'option ' | | template Name = = = 'item ' ) { value = hash _key ( data [ self . settings . value Field ] ) ; cache = ! ! value ; } 
function ( ) { var center = - this . y + this . wrapper Height / 2 ; var minor Phase = Math . max ( Math . floor ( - this . y / this . infinite Element Height ) - this . infinite Upper Buffer Size , 0 ) , major Phase = Math . floor ( minor Phase / this . infinite Length ) , phase = minor Phase - major Phase * this . infinite Length ; var top = 0 ; var i = 0 ; var update = [ ] ; 
function is Passive ( ) { var supports Passive Option = false ; try { add Event Listener ( "test " , null , Object . define Property ( { } , 'passive ' , { get : function ( ) { supports Passive Option = true ; } } ) ) ; } catch ( e ) { } return supports Passive Option ; } 
function _indicators Map ( fn ) { if ( that . indicators ) { for ( var i = that . indicators . length ; i - - ; ) { fn . call ( that . indicators [ i ] ) ; } } } 
function ( fn ) { var cache = { } ; return function ( input ) { if ( ! ( input in cache ) ) { cache [ input ] = fn ( input ) ; } return cache [ input ] ; } ; } 
function update Metrics ( ) { is Vw Dirty = false ; DPR = window . device Pixel Ratio ; css Cache = { } ; size Length Cache = { } ; pf . DPR = DPR | | 1 ; units . width = Math . max ( window . inner Width | | 0 , doc Elem . client Width ) ; units . height = Math . max ( window . inner Height | | 0 , doc Elem . client Height ) ; units . vw = units . width / 1 0 0 ; units . vh = units . height / 1 0 0 ; eval Id = [ units . height , units . width , DPR ] . join ( " - " ) ; units . em = pf . get Em Value ( ) ; units . rem = units . em ; } 
function parse Srcset ( input , set ) { function collect Characters ( reg Ex ) { var chars , match = reg Ex . exec ( input . substring ( pos ) ) ; if ( match ) { chars = match [ 0 ] ; pos + = chars . length ; return chars ; } } var input Length = input . length , url , descriptors , current Descriptor , state , c , * Adds descriptor properties to a candidate , pushes to the candidates array * @return undefined * / * Tokenizes descriptor properties prior to parsing * Returns undefined . * (Again , this fn is defined before it is used , in order to pass JSHINT . * Unfortunately this breaks the logical sequencing of the spec comments . : / ) * / function tokenize ( ) { 
function parse Descriptors ( ) { 
function tokenize ( ) { 
function parse Sizes ( str Value ) { 
function parse Component Values ( str ) { var chrctr ; var component = " " ; var component Array = [ ] ; var list Array = [ ] ; var paren Depth = 0 ; var pos = 0 ; var in Comment = false ; function push Component ( ) { if ( component ) { component Array . push ( component ) ; component = " " ; } } function push Component Array ( ) { if ( component Array [ 0 ] ) { list Array . push ( component Array ) ; component Array = [ ] ; } } 
function ( func , wait ) { var timeout , timestamp ; var later = function ( ) { var last = ( new Date ( ) ) - timestamp ; if ( last < wait ) { timeout = set Timeout ( later , wait - last ) ; } else { timeout = null ; func ( ) ; } } ; return function ( ) { timestamp = new Date ( ) ; if ( ! timeout ) { timeout = set Timeout ( later , wait ) ; } } ; } 
function Invocation ( job , fire Date , recurrence Rule , end Date ) { this . job = job ; this . fire Date = fire Date ; this . end Date = end Date ; this . recurrence Rule = recurrence Rule | | Doesnt Recur ; this . timer ID = null ; } 
function Range ( start , end , step ) { this . start = start | | 0 ; this . end = end | | 6 0 ; this . step = step | | 1 ; } 
function Recurrence Rule ( year , month , date , day Of Week , hour , minute , second ) { this . recurs = true ; this . year = ( year = = null ) ? null : year ; this . month = ( month = = null ) ? null : month ; this . date = ( date = = null ) ? null : date ; this . day Of Week = ( day Of Week = = null ) ? null : day Of Week ; this . hour = ( hour = = null ) ? null : hour ; this . minute = ( minute = = null ) ? null : minute ; this . second = ( second = = null ) ? 0 : second ; } 
function run On Date ( date , job ) { var now = Date . now ( ) ; var then = date . get Time ( ) ; return lt . set Timeout ( function ( ) { if ( then > Date . now ( ) ) run On Date ( date , job ) ; else job ( ) ; } , ( then < now ? 0 : then - now ) ) ; } 
function schedule Next Recurrence ( rule , job , prev Date , end Date ) { prev Date = ( prev Date instanceof Cron Date ) ? prev Date : new Cron Date ( ) ; var date = ( rule instanceof Recurrence Rule ) ? rule . _next Invocation Date ( prev Date ) : rule . next ( ) ; if ( date = = = null ) { return null ; } if ( ( end Date instanceof Cron Date ) & & date . get Time ( ) > end Date . get Time ( ) ) { return null ; } var inv = new Invocation ( job , date , rule , end Date ) ; schedule Invocation ( inv ) ; return inv ; } 
function schedule Job ( ) { if ( arguments . length < 2 ) { return null ; } var name = ( arguments . length > = 3 & & typeof arguments [ 0 ] = = = 'string ' ) ? arguments [ 0 ] : null ; var spec = name ? arguments [ 1 ] : arguments [ 0 ] ; var method = name ? arguments [ 2 ] : arguments [ 1 ] ; var callback = name ? arguments [ 3 ] : arguments [ 2 ] ; var job = new Job ( name , method , callback ) ; if ( job . schedule ( spec ) ) { return job ; } return null ; } 
function get Property Value ( css Rule : HTMLElement With Style Map | CSSStyle Rule | CSSKeyframe Rule , prop : string ) : string { try { 
function indent Str ( str : string , indent : number ) : string { let result = ' ' for ( let index = 0 ; index < indent ; index + + ) result + = ' ' return result + str } 
function map Values By Prop ( value : Jss Value , prop : string , rule : Style Rule ) { return value . map ( item = > object To Array ( item , prop , rule , false , true ) ) } 
function extend ( style , rule , sheet , new Style = { } ) { merge Extend ( style , rule , sheet , new Style ) merge Rest ( style , rule , sheet , new Style ) return new Style } 
function convert Case ( style ) { const converted = { } for ( const prop in style ) { const key = prop . index Of ( ' - - ' ) = = = 0 ? prop : hyphenate ( prop ) converted [ key ] = style [ prop ] } if ( style . fallbacks ) { if ( Array . is Array ( style . fallbacks ) ) converted . fallbacks = style . fallbacks . map ( convert Case ) else converted . fallbacks = convert Case ( style . fallbacks ) } return converted } 
function Resource Namespace ( stripe , resources ) { for ( var name in resources ) { var camel Case Name = name [ 0 ] . to Lower Case ( ) + name . substring ( 1 ) ; var resource = new resources [ name ] ( stripe ) ; this [ camel Case Name ] = resource ; } } 
function ( data ) { return qs . stringify ( data , { serialize Date : function ( d ) { return Math . floor ( d . get Time ( ) / 1 0 0 0 ) ; } } ) 
function ( args ) { if ( args . length < 1 | | ! is Plain Object ( args [ 0 ] ) ) { return { } ; } if ( ! utils . is Options Hash ( args [ 0 ] ) ) { return args . shift ( ) ; } var arg Keys = Object . keys ( args [ 0 ] ) ; var option Keys In Args = arg Keys . filter ( function ( key ) { return OPTIONS _KEYS . index Of ( key ) > - 1 ; } ) ; 
function ( args ) { var opts = { auth : null , headers : { } , } ; if ( args . length > 0 ) { var arg = args [ args . length - 1 ] ; if ( utils . is Auth Key ( arg ) ) { opts . auth = args . pop ( ) ; } else if ( utils . is Options Hash ( arg ) ) { var params = args . pop ( ) ; var extra Keys = Object . keys ( params ) . filter ( function ( key ) { return OPTIONS _KEYS . index Of ( key ) = = - 1 ; } ) ; if ( extra Keys . length ) { emit Warning ( 'Invalid options found ( ' + extra Keys . join ( ' , ' ) + ' ) ; ignoring . ' ) ; } if ( params . api _key ) { opts . auth = params . api _key ; } if ( params . idempotency _key ) { opts . headers [ 'Idempotency -Key ' ] = params . idempotency _key ; } if ( params . stripe _account ) { opts . headers [ 'Stripe -Account ' ] = params . stripe _account ; } if ( params . stripe _version ) { opts . headers [ 'Stripe -Version ' ] = params . stripe _version ; } } } return opts ; } 
function ( sub ) { var Super = this ; var Constructor = has Own . call ( sub , 'constructor ' ) ? sub . constructor : function ( ) { Super . apply ( this , arguments ) ; } ; 
function ( a , b ) { a = Buffer . from ( a ) ; b = Buffer . from ( b ) ; 
function ( obj ) { if ( typeof obj ! = = 'object ' ) { throw new Error ( 'Argument must be an object ' ) ; } Object . keys ( obj ) . for Each ( function ( key ) { if ( obj [ key ] = = = null | | obj [ key ] = = = undefined ) { delete obj [ key ] ; } } ) ; return obj ; } 
function ( obj ) { if ( obj . file & & obj . file . data ) { return obj . file . data instanceof Event Emitter ; } return false ; } 
function safe Exec ( cmd , cb ) { try { utils . _exec ( cmd , cb ) ; } catch ( e ) { cb ( e , null ) ; } } 
function get Item Callback ( args ) { if ( args . length = = = 0 ) { return undefined ; } var on Item = args [ 0 ] ; if ( typeof on Item ! = = 'function ' ) { throw Error ( 'The first argument to auto Paging Each , if present , must be a callback function ; receieved ' + typeof on Item ) ; } 
function memoized Promise ( promise Cache , cb ) { if ( promise Cache . current Promise ) { return promise Cache . current Promise ; } promise Cache . current Promise = new Promise ( cb ) . then ( function ( ret ) { promise Cache . current Promise = undefined ; return ret ; } ) ; return promise Cache . current Promise ; } 
function ( payload , header , secret , tolerance ) { this . signature . verify Header ( payload , header , secret , tolerance | | Webhook . DEFAULT _TOLERANCE ) ; var json Payload = JSON . parse ( payload ) ; return json Payload ; } 
function ( opts ) { if ( ! opts ) { throw new Error . Stripe Error ( { message : 'Options are required ' , } ) ; } opts . timestamp = Math . floor ( opts . timestamp ) | | Math . floor ( Date . now ( ) / 1 0 0 0 ) ; opts . scheme = opts . scheme | | signature . EXPECTED _SCHEME ; opts . signature = opts . signature | | signature . _compute Signature ( opts . timestamp + ' . ' + opts . payload , opts . secret ) ; var generated Header = [ 't = ' + opts . timestamp , opts . scheme + ' = ' + opts . signature , ] . join ( ' , ' ) ; return generated Header ; } 
function Stripe Resource ( stripe , url Data ) { this . _stripe = stripe ; this . _url Data = url Data | | { } ; this . base Path = utils . make URLInterpolator ( this . base Path | | stripe . get Api Field ( 'base Path ' ) ) ; this . resource Path = this . path ; this . path = utils . make URLInterpolator ( this . path ) ; if ( this . include Basic ) { this . include Basic . for Each ( function ( method Name ) { this [ method Name ] = Stripe Resource . BASIC _METHODS [ method Name ] ; } , this ) ; } this . initialize . apply ( this , arguments ) ; } 
function stripe Method ( spec ) { return function ( ) { var self = this ; var args = [ ] . slice . call ( arguments ) ; var callback = typeof args [ args . length - 1 ] = = 'function ' & & args . pop ( ) ; var request Promise = utils . callbackify Promise With Timeout ( make Request ( self , args , spec , { } ) , callback ) if ( spec . method Type = = = 'list ' ) { var auto Pagination Methods = make Auto Pagination Methods ( self , args , spec , request Promise ) ; Object . assign ( request Promise , auto Pagination Methods ) ; } return request Promise ; } ; } 
function multipart Data Generator ( method , data , headers ) { var segno = ( Math . round ( Math . random ( ) * 1e 1 6 ) + Math . round ( Math . random ( ) * 1e 1 6 ) ) . to String ( ) ; headers [ 'Content -Type ' ] = ( 'multipart /form -data ; boundary = ' + segno ) ; var buffer = Buffer . alloc ( 0 ) ; function push ( l ) { var prev Buffer = buffer ; var new Buffer = ( l instanceof Buffer ) ? l : Buffer . from ( l ) ; buffer = Buffer . alloc ( prev Buffer . length + new Buffer . length + 2 ) ; prev Buffer . copy ( buffer ) ; new Buffer . copy ( buffer , prev Buffer . length ) ; buffer . write ( ' \r \n ' , buffer . length - 2 ) ; } function q ( s ) { return ' " ' + s . replace ( / " | " / g , ' % 2 2 ' ) . replace ( / \r \n | \r | \n / g , ' ' ) + ' " ' ; } for ( var k in utils . flatten And Stringify ( data ) ) { var v = data [ k ] ; push ( ' - - ' + segno ) ; if ( v . has Own Property ( 'data ' ) ) { push ( 'Content -Disposition : form -data ; name = ' + q ( k ) + ' ; filename = ' + q ( v . name | | 'blob ' ) ) ; push ( 'Content -Type : ' + ( v . type | | 'application /octet -stream ' ) ) ; push ( ' ' ) ; push ( v . data ) ; } else { push ( 'Content -Disposition : form -data ; name = ' + q ( k ) ) ; push ( ' ' ) ; push ( v ) ; } } push ( ' - - ' + segno + ' - - ' ) ; return buffer ; } 
function ( cb ) { if ( Stripe . USER _AGENT _SERIALIZED ) { return cb ( Stripe . USER _AGENT _SERIALIZED ) ; } this . get Client User Agent Seeded ( Stripe . USER _AGENT , function ( cua ) { Stripe . USER _AGENT _SERIALIZED = cua ; cb ( Stripe . USER _AGENT _SERIALIZED ) ; } ) } 
function ( seed , cb ) { var self = this ; utils . safe Exec ( 'uname -a ' , function ( err , uname ) { var user Agent = { } ; for ( var field in seed ) { user Agent [ field ] = encode URIComponent ( seed [ field ] ) ; } 
function create Sharing Url ( network ) { return this . base Networks [ network ] . sharer . replace ( / @url / g , encode URIComponent ( this . url ) ) . replace ( / @title / g , encode URIComponent ( this . title ) ) . replace ( / @description / g , encode URIComponent ( this . description ) ) . replace ( / @quote / g , encode URIComponent ( this . quote ) ) . replace ( / @hashtags / g , this . generate Hashtags ( network , this . hashtags ) ) . replace ( / @media / g , this . media ) . replace ( / @twitteruser / g , this . twitter User ? ' &via = ' + this . twitter User : ' ' ) ; } 
function share ( network ) { this . open Sharer ( network , this . create Sharing Url ( network ) ) ; this . $root . $emit ( 'social _shares _open ' , network , this . url ) ; this . $emit ( 'open ' , network , this . url ) ; } 
function touch ( network ) { window . open ( this . create Sharing Url ( network ) , ' _self ' ) ; this . $root . $emit ( 'social _shares _open ' , network , this . url ) ; this . $emit ( 'open ' , network , this . url ) ; } 
function open Sharer ( network , url ) { var this $ 1 = this ; 
function mounted ( ) { if ( ! in Browser ) { return ; } var dual Screen Left = $window . screen Left ! = = undefined ? $window . screen Left : screen . left ; var dual Screen Top = $window . screen Top ! = = undefined ? $window . screen Top : screen . top ; var width = $window . inner Width ? $window . inner Width : ( document . document Element . client Width ? document . document Element . client Width : screen . width ) ; var height = $window . inner Height ? $window . inner Height : ( document . document Element . client Height ? document . document Element . client Height : screen . height ) ; this . popup . left = ( ( width / 2 ) - ( this . popup . width / 2 ) ) + dual Screen Left ; this . popup . top = ( ( height / 2 ) - ( this . popup . height / 2 ) ) + dual Screen Top ; } 
function load And Parse File ( filename , settings , next File ) { if ( settings . debug ) { debug ( 'load And Parse File ( \ ' ' + filename + ' \ ' ) ' ) ; debug ( 'total Files : ' + settings . total Files ) ; debug ( 'files Loaded : ' + settings . files Loaded ) ; } if ( filename ! = = null & & typeof filename ! = = 'undefined ' ) { $ . ajax ( { url : filename , async : settings . async , cache : settings . cache , data Type : 'text ' , success : function ( data , status ) { if ( settings . debug ) { debug ( 'Succeeded in downloading ' + filename + ' . ' ) ; debug ( data ) ; } parse Data ( data , settings ) ; next File ( ) ; } , error : function ( jq XHR , text Status , error Thrown ) { if ( settings . debug ) { debug ( 'Failed to download or parse ' + filename + ' . error Thrown : ' + error Thrown ) ; } if ( jq XHR . status = = = 4 0 4 ) { settings . total Files - = 1 ; } next File ( ) ; } } ) ; } } 
function parse Data ( data , settings ) { var parsed = ' ' ; var lines = data . split ( / \n / ) ; var reg Place Holder = / ( \ { \d + } ) / g ; var reg Rep Place Holder = / \ { ( \d + ) } / g ; var unicode RE = / ( \ \u . { 4 } ) / ig ; for ( var i = 0 , j = lines . length ; i < j ; i + + ) { var line = lines [ i ] ; line = line . trim ( ) ; if ( line . length > 0 & & line . match ( " ^ # " ) ! = " # " ) { 
function check Key Namespace ( key ) { var reg Dot = / \ . / ; if ( reg Dot . test ( key ) ) { var fullname = ' ' ; var names = key . split ( / \ . / ) ; for ( var i = 0 , j = names . length ; i < j ; i + + ) { var name = names [ i ] ; if ( i > 0 ) { fullname + = ' . ' ; } fullname + = name ; if ( eval ( 'typeof ' + fullname + ' = = "undefined " ' ) ) { eval ( fullname + ' = { } ; ' ) ; } } } } 
function unescape Unicode ( str ) { 
function ( x , left , right ) { if ( x < left ) { return left - x ; } else if ( x > right ) { return x - right ; } else { return 0 ; } } 
function ( event , g ) { var chart Pos = utils . find Pos ( g . canvas _ ) ; var box = { left : chart Pos . x , right : chart Pos . x + g . canvas _ . offset Width , top : chart Pos . y , bottom : chart Pos . y + g . canvas _ . offset Height } ; var pt = { x : utils . page X ( event ) , y : utils . page Y ( event ) } ; var dx = distance From Interval ( pt . x , box . left , box . right ) , dy = distance From Interval ( pt . y , box . top , box . bottom ) ; return Math . max ( dx , dy ) ; } 
function ( event , g , context ) { 
function ( event ) { if ( context . is Zooming ) { 
function ( event , g , context ) { if ( context . cancel Next Dblclick ) { context . cancel Next Dblclick = false ; return ; } 
function get Control Points ( p 0 , p 1 , p 2 , opt _alpha , opt _allow False Extrema ) { var alpha = ( opt _alpha ! = = undefined ) ? opt _alpha : 1 / 3 ; 
function smooth Plotter ( e ) { var ctx = e . drawing Context , points = e . points ; ctx . begin Path ( ) ; ctx . move To ( points [ 0 ] . canvasx , points [ 0 ] . canvasy ) ; 
function ( dygraph ) { this . dygraph _ = dygraph ; this . y Axes _ = [ ] ; this . x Axis _ = { } ; this . series _ = { } ; * A list of series in columnar order . * @type {Array . <string > } * / this . labels _ = [ ] ; this . highlight Series _ = this . get ( "highlight Series Opts " ) | | { } ; this . reparse Series ( ) ; } 
function ( opt _options ) { this . annotations _ = [ ] ; 
function ( dygraph ) { this . dygraph _ = dygraph ; this . points = [ ] ; this . set Names = [ ] ; this . annotations = [ ] ; this . y Axes _ = null ; 
function ( event , g , context B ) { 
function ( idx ) { 
function validate Native Format ( data ) { const first Row = data [ 0 ] ; const first X = first Row [ 0 ] ; if ( typeof first X ! = = 'number ' & & ! utils . is Date Like ( first X ) ) { throw new Error ( ` $ { typeof first X } $ { first X } ` ) ; } for ( let i = 1 ; i < first Row . length ; i + + ) { const val = first Row [ i ] ; if ( val = = = null | | val = = = undefined ) continue ; if ( typeof val = = = 'number ' ) continue ; if ( utils . is Array Like ( val ) ) continue ; 
function is Node ( o ) { return ( typeof Node = = = "object " ? o instanceof Node : typeof o = = = "object " & & typeof o . node Type = = = "number " & & typeof o . node Name = = = "string " ) ; } 
function ( options ) { for ( var property in options ) { if ( options . has Own Property ( property ) & & ! pixel Safe Options [ property ] ) { return true ; } } return false ; } 
function parse RGBA ( rgb Str ) { var bits = RGBA _RE . exec ( rgb Str ) ; if ( ! bits ) return null ; var r = parse Int ( bits [ 1 ] , 1 0 ) , g = parse Int ( bits [ 2 ] , 1 0 ) , b = parse Int ( bits [ 3 ] , 1 0 ) ; if ( bits [ 4 ] ) { return { r : r , g : g , b : b , a : parse Float ( bits [ 4 ] ) } ; } else { return { r : r , g : g , b : b } ; } } 
function ( dygraph , element , element Context , layout ) { this . dygraph _ = dygraph ; this . layout = layout ; this . element = element ; this . element Context = element Context ; this . height = dygraph . height _ ; this . width = dygraph . width _ ; 
function ( opt _lossless Only ) { if ( pending Actions . length < = 1 ) return ; 
function ( ctx , baseline X , baseline Y , path Back ) { ctx . line To ( baseline X , baseline Y ) ; if ( stacked Graph ) { for ( var i = path Back . length - 1 ; i > = 0 ; i - - ) { var pt = path Back [ i ] ; ctx . line To ( pt [ 0 ] , pt [ 1 ] ) ; } } } 
function ( opt _options ) { this . canvas _ = document . create Element ( "canvas " ) ; opt _options = opt _options | | { } ; this . direction _ = opt _options . direction | | null ; } 
function ( r ) { var div = document . create Element ( 'div ' ) ; div . style . position = 'absolute ' ; div . style . left = r . x + 'px ' ; div . style . top = r . y + 'px ' ; div . style . width = r . w + 'px ' ; div . style . height = r . h + 'px ' ; return div ; } 
function ( div ) { var size Span = document . create Element ( 'span ' ) ; size Span . set Attribute ( 'style ' , 'margin : 0 ; padding : 0 0 0 1em ; border : 0 ; ' ) ; div . append Child ( size Span ) ; var one Em Width = size Span . offset Width ; div . remove Child ( size Span ) ; return one Em Width ; } 
function generate Legend Dash HTML ( stroke Pattern , color , one Em Width ) { 
function Keycloak ( config , keycloak Config ) { 
function Grant Manager ( config ) { this . realm Url = config . realm Url ; this . client Id = config . client Id ; this . secret = config . secret ; this . public Key = config . public Key ; this . public = config . public ; this . bearer Only = config . bearer Only ; this . not Before = 0 ; this . rotation = new Rotation ( config ) ; } 
function Rotation ( config ) { this . realm Url = config . realm Url ; this . min Time Between Jwks Requests = config . min Time Between Jwks Requests ; this . jwks = [ ] ; this . last Time Reques Time = 0 ; } 
function Config ( config ) { if ( ! config ) { config = path . join ( process . cwd ( ) , 'keycloak .json ' ) ; } if ( typeof config = = = 'string ' ) { this . load Configuration ( config ) ; } else { this . configure ( config ) ; } } 
function resolve Value ( value ) { if ( typeof value ! = = 'string ' ) { return value ; } 
function Enforcer ( keycloak , config ) { this . keycloak = keycloak ; this . config = config | | { } ; if ( ! this . config . response _mode ) { this . config . response _mode = 'permissions ' ; } if ( ! this . config . resource _server _id ) { this . config . resource _server _id = this . keycloak . get Config ( ) . client Id ; } } 
function Token ( token , client Id ) { this . token = token ; this . client Id = client Id ; if ( token ) { try { const parts = token . split ( ' . ' ) ; this . header = JSON . parse ( Buffer . from ( parts [ 0 ] , 'base 6 4 ' ) . to String ( ) ) ; this . content = JSON . parse ( Buffer . from ( parts [ 1 ] , 'base 6 4 ' ) . to String ( ) ) ; this . signature = Buffer . from ( parts [ 2 ] , 'base 6 4 ' ) ; this . signed = parts [ 0 ] + ' . ' + parts [ 1 ] ; } catch ( err ) { this . content = { exp : 0 } ; } } } 
function filter ( a , cb ) { var n = [ ] ; each ( a , function ( v ) { if ( cb ( v ) ) { n . push ( v ) ; } } ) ; return n ; } 
function sanitize Html ( html , options , _recursing ) { var result = ' ' ; function Frame ( tag , attribs ) { var that = this ; this . tag = tag ; this . attribs = attribs | | { } ; this . tag Position = result . length ; this . text = ' ' ; * Filters user input css properties by whitelisted regex attributes . * * @param {object } abstract Syntax Tree - Object representation of CSS attributes . * @property {array [Declaration ] } abstract Syntax Tree .nodes [ 0 ] - Each object cointains prop and value key , i .e { prop : 'color ' , value : 'red ' } . * @param {object } allowed Styles - Keys are properties (i .e color ) , value is list of permitted regex rules (i .e /green /i ) . * @return {object } - Abstract Syntax Tree with filtered style attributes . * / function filter Css ( abstract Syntax Tree , allowed Styles ) { if ( ! allowed Styles ) { return abstract Syntax Tree ; } var filtered AST = clone Deep ( abstract Syntax Tree ) ; var ast Rules = abstract Syntax Tree . nodes [ 0 ] ; var selected Rule ; * Extracts the style attribues from an Abstract Syntax Tree and formats those * values in the inline style attribute format . * * @param {Abstract Syntax Tree } filtered AST * @return {string } - Example : "color :yellow ;text -align :center ;font -family :helvetica ; " * / function stringify Style Attributes ( filtered AST ) { return filtered AST . nodes [ 0 ] . nodes . reduce ( function ( extracted Attributes , attribute Object ) { extracted Attributes . push ( attribute Object . prop + ' : ' + attribute Object . value ) ; return extracted Attributes ; } , [ ] ) . join ( ' ; ' ) ; } function filter Declarations ( selected Rule ) { return function ( allowed Declarations List , attribute Object ) { 
function filter Css ( abstract Syntax Tree , allowed Styles ) { if ( ! allowed Styles ) { return abstract Syntax Tree ; } var filtered AST = clone Deep ( abstract Syntax Tree ) ; var ast Rules = abstract Syntax Tree . nodes [ 0 ] ; var selected Rule ; 
function stringify Style Attributes ( filtered AST ) { return filtered AST . nodes [ 0 ] . nodes . reduce ( function ( extracted Attributes , attribute Object ) { extracted Attributes . push ( attribute Object . prop + ' : ' + attribute Object . value ) ; return extracted Attributes ; } , [ ] ) . join ( ' ; ' ) ; } 
function filter Declarations ( selected Rule ) { return function ( allowed Declarations List , attribute Object ) { 
function read Uint 6 4 ( buffer , offset ) { var hi = ( buffer [ offset ] < < 2 4 | buffer [ offset + 1 ] < < 1 6 | buffer [ offset + 2 ] < < 8 | buffer [ offset + 3 ] < < 0 ) > > > 0 ; var lo = ( buffer [ offset + 4 ] < < 2 4 | buffer [ offset + 5 ] < < 1 6 | buffer [ offset + 6 ] < < 8 | buffer [ offset + 7 ] < < 0 ) > > > 0 ; return hi * 0x 1 0 0 0 0 0 0 0 0 + lo ; } 
function sync ( local , remote , ref , depth , callback ) { if ( typeof ref ! = = "string " ) throw new Type Error ( "ref must be string " ) ; if ( typeof depth ! = = "number " ) throw new Type Error ( "depth must be number " ) ; var has Cache = { } ; remote . read Ref ( ref , function ( err , hash ) { if ( ! hash ) return callback ( err ) ; import Commit ( hash , depth , function ( err ) { if ( err ) return callback ( err ) ; callback ( null , hash ) ; } ) ; } ) ; 
function check ( type , hash , callback ) { if ( typeof type ! = = "string " ) throw new Type Error ( "type must be string " ) ; if ( typeof hash ! = = "string " ) throw new Type Error ( "hash must be string " ) ; if ( has Cache [ hash ] ) return callback ( null , true ) ; local . has Hash ( hash , function ( err , has ) { if ( err ) return callback ( err ) ; has Cache [ hash ] = has ; callback ( null , has ) ; } ) ; } 
function pack ( hashes , opts , callback ) { if ( ! callback ) return pack . bind ( this , hashes , opts ) ; var repo = this ; var i = 0 , first = true , done = false ; return callback ( null , apply Parser ( { take : take } , encode Pack ) ) ; function take ( callback ) { if ( done ) return callback ( ) ; if ( first ) return read First ( callback ) ; var hash = hashes [ i + + ] ; if ( hash = = = undefined ) { return callback ( ) ; } repo . load Raw ( hash , function ( err , buffer ) { if ( err ) return callback ( err ) ; if ( ! buffer ) return callback ( new Error ( "Missing hash : " + hash ) ) ; 
function read Length ( ) { var byte = delta [ delta Offset + + ] ; var length = byte & 0x 7f ; var shift = 7 ; while ( byte & 0x 8 0 ) { byte = delta [ delta Offset + + ] ; length | = ( byte & 0x 7f ) < < shift ; shift + = 7 ; } return length ; } 
function $version ( byte ) { version = ( version < < 8 ) | byte ; if ( + + offset < 4 ) return $version ; if ( version > = 2 & & version < = 3 ) { offset = 0 ; return $num ; } throw new Error ( "Invalid version number " + num ) ; } 
function $num ( byte ) { num = ( num < < 8 ) | byte ; if ( + + offset < 4 ) return $num ; offset = 0 ; emit ( { version : version , num : num } ) ; return $header ; } 
function $header ( byte ) { if ( start = = = 0 ) start = position ; type = byte > > 4 & 0x 0 7 ; length = byte & 0x 0f ; if ( byte & 0x 8 0 ) { offset = 4 ; return $header 2 ; } return after Header ( ) ; } 
function emit Object ( ) { var body = bodec . join ( parts ) ; if ( body . length ! = = length ) { throw new Error ( "Body length mismatch " ) ; } var item = { type : num To Type [ type ] , size : length , body : body , offset : start } ; if ( ref ) item . ref = ref ; parts . length = 0 ; start = 0 ; offset = 0 ; type = 0 ; length = 0 ; ref = null ; emit ( item ) ; } 
function $body ( byte , i , chunk ) { if ( inf . write ( byte ) ) return $body ; var buf = inf . flush ( ) ; if ( buf . length ! = = length ) throw new Error ( "Length mismatch , expected " + length + " got " + buf . length ) ; inf . recycle ( ) ; if ( buf . length ) { parts . push ( buf ) ; } emit Object ( ) ; 
function $checksum ( byte ) { checksum + = to Hex ( byte ) ; if ( + + offset < 2 0 ) return $checksum ; var actual = sha 1sum . digest ( ) ; if ( checksum ! = = actual ) throw new Error ( "Checksum mismatch : " + actual + " ! = " + checksum ) ; } 
function ( ) { if ( p . current Session . player State = = = 'PLAYING ' ) { p . pause ( ) ; } else if ( p . current Session . player State = = = 'PAUSED ' ) { p . play ( ) ; } } 
function ( ) { if ( ! volume ) { return ; } else if ( volume . muted ) { p . unmute ( function ( err , status ) { if ( err ) return ; volume = status ; } ) ; } else { p . mute ( function ( err , status ) { if ( err ) return ; volume = status ; } ) ; } } 
function ( ) { if ( ! volume | | volume . level > = 1 ) { return ; } var new Volume = Math . min ( volume . level + volume Step , 1 ) ; p . set Volume ( new Volume , function ( err , status ) { if ( err ) { return ; } debug ( "volume up : %s " , status . level ) ; volume = status ; } ) ; } 
function ( elem ) { var pattern = new Reg Exp ( _filter Value , 'i ' ) ; var element = elem ; if ( pattern . test ( element . text Content ) ) { element . style . display = ' ' ; } else { element . style . display = 'none ' ; } } 
function ( ) { var collection = _log Container . child Nodes ; var i = collection . length ; if ( i = = = 0 ) { return ; } while ( i ) { _filter Element ( collection [ i - 1 ] ) ; i - = 1 ; } window . scroll To ( 0 , document . body . scroll Height ) ; } 
function ( filter Input , uri ) { var _url = new URL ( uri ) ; var _filter Value From URL = _url . search Params . get ( 'filter ' ) ; if ( typeof _filter Value From URL ! = = 'undefined ' & & _filter Value From URL ! = = null ) { _filter Value = _filter Value From URL ; filter Input . value = _filter Value ; 
function ( value , uri ) { var _url = new URL ( uri ) ; var _params = new URLSearch Params ( _url . search . slice ( 1 ) ) ; if ( value = = = ' ' ) { _params . delete ( 'filter ' ) ; } else { _params . set ( 'filter ' , value ) ; } _url . search = _params . to String ( ) ; window . history . replace State ( null , document . title , _url . to String ( ) ) ; } 
function init ( opts ) { var self = this ; 
function log ( data ) { var was Scrolled Bottom = _is Scrolled Bottom ( ) ; var div = document . create Element ( 'div ' ) ; var p = document . create Element ( 'p ' ) ; p . class Name = 'inner -line ' ; 
function Stats ( enabled ) { this . timer = { } ; if ( enabled = = = true ) { const config = new Configstore ( pkg . name ) ; let client ID = uuidv 4 ( ) ; if ( config . has ( 'client ID ' ) ) { client ID = config . get ( 'client ID ' ) ; } else { config . set ( 'client ID ' , client ID ) ; } const tracker = ua ( tracking ID , client ID ) ; tracker . set ( 'aip ' , 1 ) ; 
function ( arity , count ) { if ( typeof ( arity ) = = 'undefined ' | | typeof ( count ) = = 'undefined ' ) { throw 'Wrong arguments ' ; } if ( count = = 0 ) return 0 ; var byte Length = count * arity ; var img Side = Math . ceil ( Math . sqrt ( byte Length / 4 ) ) ; 
function x Model Handle ( gl , model , fpt ) { if ( typeof ( gl ) = = 'undefined ' | | typeof ( model ) = = 'undefined ' | | typeof ( fpt ) = = 'undefined ' ) { throw 'Web GL context and geometry model must be specified ' ; } this . _gl = gl ; this . _model = model ; this . _fpt = fpt ; this . id = x Model Handle . _instances Num + + ; this . stopped = false ; this . count = model . indices . length ; 
function x Viewer ( canvas ) { if ( typeof ( canvas ) = = 'undefined ' ) { throw 'Canvas has to be defined ' ; } this . _canvas = null ; if ( typeof ( canvas . node Name ) ! = 'undefined ' & & canvas . node Name = = 'CANVAS ' ) { this . _canvas = canvas ; } if ( typeof ( canvas ) = = 'string ' ) { this . _canvas = document . get Element By Id ( canvas ) ; } if ( this . _canvas = = null ) { throw 'You have to specify canvas either as an ID of HTML element or the element itself ' ; } this . perspective Camera = { fov : 4 5 , near : 0 , far : 0 } ; this . orthogonal Camera = { left : 0 , right : 0 , top : 0 , bottom : 0 , near : 0 , far : 0 } ; this . camera = 'perspective ' ; this . background = [ 2 3 0 , 2 3 0 , 2 3 0 , 2 5 5 ] ; this . highlighting Colour = [ 2 5 5 , 1 7 3 , 3 3 , 2 5 5 ] ; this . light A = [ 0 , 1 0 0 0 0 0 0 , 2 0 0 0 0 0 , 0 . 8 ] ; this . light B = [ 0 , - 5 0 0 0 0 0 , 5 0 0 0 0 , 0 . 2 ] ; this . navigation Mode = 'orbit ' ; this . rendering Mode = 'normal ' ; this . clipping Plane = [ 0 , 0 , 0 , 0 ] ; this . _last Clipping Point = [ 0 , 0 , 0 ] ; 
function ( b Box ) { var size = Math . max ( b Box [ 3 ] , b Box [ 4 ] , b Box [ 5 ] ) ; var ratio = Math . max ( viewer . _width , viewer . _height ) / Math . min ( viewer . _width , viewer . _height ) ; viewer . _distance = size / Math . tan ( viewer . perspective Camera . fov * Math . PI / 1 8 0 . 0 ) * ratio * 1 . 0 ; } 
function handle Mouse Down ( event ) { mouse Down = true ; last Mouse X = event . client X ; last Mouse Y = event . client Y ; start X = event . client X ; start Y = event . client Y ; * Occurs when mousedown event happens on underlying canvas . * * @event x Viewer #mouse Down * @type {object } * @param {Number } id - product ID of the element or null if there wasn 't any product under mouse * / viewer . _fire ( 'mouse Down ' , { id : id } ) ; / /keep information about the mouse button switch ( event . button ) { case 0 : button = 'left ' ; break ; case 1 : button = 'middle ' ; break ; case 2 : button = 'right ' ; break ; default : button = 'left ' ; break ; } viewer . _disable Text Selection ( ) ; } 
function Cleaver ( document , options , include Path ) { this . document = document . to String ( ) ; this . options = clone ( options ) | | { } ; this . path = path . resolve ( include Path | | ' . ' ) ; if ( ! debug Inited ) { if ( this . options . debug ) { debug . enable ( ' * ' ) ; } debug = debug ( 'cleaver ' ) ; debug Inited = true ; } helper = require ( ' . /helper ' ) ( this . path , this . options . debug ) ; this . templates = { layout : 'templates /layout .mustache ' , author : 'templates /author .mustache ' , slides : 'templates /default .mustache ' } ; this . resources = { style : 'resources /default .css ' , github Style : 'resources /github .css ' , script : 'resources /script .js ' } ; this . external = { style : [ ] } ; this . slides = [ ] ; this . override = false ; marked . set Options ( { gfm : true , highlight : function ( code , lang ) { try { return hljs . highlight ( lang , code ) . value ; } catch ( e ) { return code ; } } } ) ; } 
function clone ( obj ) { var key , copy = { } ; if ( ! obj ) { return ; } for ( key in obj ) { copy [ key ] = obj [ key ] ; } return copy ; } 
function navigate ( n ) { var position = current Position ( ) ; var num Slides = document . get Elements By Class Name ( 'slide ' ) . length ; var next Position = ( position - 1 + n ) % num Slides + 1 ; next Position = ( next Position - 1 + num Slides ) % num Slides + 1 ; document . get Element By Id ( 'slide - ' + position ) . class List . add ( 'hidden ' ) ; document . get Element By Id ( 'slide - ' + next Position ) . class List . remove ( 'hidden ' ) ; update Progress ( ) ; update URL ( ) ; update Tab Index ( ) ; } 
function update URL ( ) { try { window . history . replace State ( { } , null , ' # ' + current Position ( ) ) ; } catch ( e ) { window . location . hash = current Position ( ) ; } } 
function update Progress ( ) { var progress Bar = document . query Selector ( ' .progress -bar ' ) ; if ( progress Bar ! = = null ) { var num Slides = document . get Elements By Class Name ( 'slide ' ) . length ; var position = current Position ( ) - 1 ; var percent = ( num Slides = = = 1 ) ? 1 0 0 : 1 0 0 * position / ( num Slides - 1 ) ; progress Bar . style . width = percent . to String ( ) + ' % ' ; } } 
function update Tab Index ( ) { var all Links = document . query Selector All ( ' .slide a ' ) ; var position = current Position ( ) ; var current Page Links = document . get Element By Id ( 'slide - ' + position ) . query Selector All ( 'a ' ) ; var i ; for ( i = 0 ; i < all Links . length ; i + + ) { all Links [ i ] . set Attribute ( 'tabindex ' , - 1 ) ; } for ( i = 0 ; i < current Page Links . length ; i + + ) { current Page Links [ i ] . remove Attribute ( 'tabindex ' ) ; } } 
function toggle Full Screen ( ) { var doc Elem = document . document Element ; var doc = document ; doc Elem . request Fullscreen = doc Elem . request Fullscreen | | doc Elem . ms Request Fullscreen | | doc Elem . moz Request Full Screen | | doc Elem . webkit Request Fullscreen . bind ( doc Elem , Element . ALLOW _KEYBOARD _INPUT ) ; doc . exit Fullscreen = doc . exit Fullscreen | | doc . ms Exit Fullscreen | | doc . moz Cancel Full Screen | | doc . webkit Exit Fullscreen ; is Full Screen ( ) ? doc . exit Fullscreen ( ) : doc Elem . request Fullscreen ( ) ; } 
function pluck ( obj , fields ) { var plucked = { } ; if ( ! obj ) { return ; } fields . for Each ( function ( field ) { plucked [ field ] = obj [ field ] ; } ) ; return plucked ; } 
function load Single ( source ) { var promise ; if ( source . match ( / ^https ? : \ / \ / / ) ) { promise = http Get Promise ( source ) ; } else { promise = read File Promise ( normalize Path ( source ) ) ; } return promise ; } 
function populate Single ( filename , destination , key ) { return load Single ( filename ) . then ( function ( data ) { if ( data ) { if ( Object . prototype . to String . call ( destination [ key ] ) = = = ' [object Array ] ' ) { destination . loaded [ key ] = destination . loaded [ key ] | | [ ] ; destination . loaded [ key ] . push ( data ) ; } else { destination . loaded [ key ] = data ; } } } ) ; } 
function load ( map , options ) { var promises = [ ] ; var loaded = { } ; var filename ; options = options | | { } ; for ( var key in map ) { if ( map . has Own Property ( key ) ) { if ( ! map [ key ] | | map [ key ] . length = = = 0 ) { continue ; } filename = map [ key ] ; if ( ! options . external ) { filename = path . resolve ( ROOT _DIR , filename ) ; } promises . push ( load Single ( filename ) . then ( ( function ( _key ) { return function ( data ) { loaded [ _key ] = data ; } ; } ) ( key ) ) ) ; } } map . loaded = loaded ; return Q . all ( promises ) ; } 
function load Theme ( source , ctx ) { var promises = [ ] ; if ( ! fs . exists Sync ( source ) & & source . match ( / ^ [ \w - ] + \ / [ \w - ] + $ / ) ) { source = 'https : / /raw .githubusercontent .com / ' + source + ' /master / ' ; } if ( ! source . match ( / \ / $ / ) ) { source + = ' / ' ; } promises = [ load Settings ( source + 'settings .json ' , ctx ) , populate Single ( source + 'style .css ' , ctx . external , 'style ' ) , populate Single ( source + 'template .mustache ' , ctx . templates , 'slides ' ) , populate Single ( source + 'layout .mustache ' , ctx . templates , 'layout ' ) , populate Single ( source + 'script .js ' , ctx . external , 'script ' ) ] ; return Q . all ( promises ) ; } 
function load Settings ( source , ctx ) { return load Single ( source ) . then ( function ( data ) { if ( data ) { data = JSON . parse ( data ) ; ctx . override = data . override ; } } ) ; } 
function read File Promise ( filename ) { var deferred ; deferred = Q . defer ( ) ; fs . read File ( filename , 'utf - 8 ' , function ( err , contents ) { if ( err ) { if ( err . code = = = 'ENOENT ' ) { debug ( err . code + ' : ' + filename ) ; return deferred . resolve ( ) ; } debug ( err + ' ' + filename ) ; 
function http Get Promise ( url ) { var deferred = Q . defer ( ) , get ; var cb = function ( res ) { var data = ' ' ; res . on ( 'data ' , function ( chunk ) { data + = chunk ; } ) ; res . on ( 'err ' , function ( err ) { debug ( err + ' ' + url ) ; deferred . reject ( err ) ; } ) ; res . on ( 'end ' , function ( ) { if ( res . status Code ! = = 2 0 0 ) { debug ( res . status Code + ' : ' + url ) ; deferred . resolve ( ) ; } else { debug ( 'fetched ' + url ) ; deferred . resolve ( data ) ; } } ) ; } ; if ( url . match ( / ^https / ) ) { get = https . get ( url , cb ) ; } else { get = http . get ( url , cb ) ; } get . on ( 'error ' , function ( err ) { deferred . resolve ( ) ; debug ( err + ' : ' + url ) ; } ) ; return deferred . promise ; } 
function get User Home ( ) { return process . env . HOME | | process . env . HOMEPATH | | process . env . USERPROFILE ; } 
function Request ( method , url Path , cache ) { this . _method = method ; this . _url Path = url Path ; this . _cache = cache ; this . _query Params = [ ] ; 
function apply Request Plugins ( req ) { 
function response Plugin Applying Callback ( cb ) { 
function build Superagent Request ( ) { var req = superagent ( this . _method , this . _build Url ( ) ) ; if ( this . _agent ) { req . agent ( this . _agent ) ; } req . set ( this . _headers ) ; this . _query Params . for Each ( params = > req . query ( params ) ) ; var post Params = this . _post Params ; 
function log Request Error ( err ) { var { response } = err ; if ( ! response ) { logger . warning ( ` $ { this . _url Path } ` , err ) ; } else if ( response . not Found ) { 
function ( fn , opts , trim , base Path , prefix ) { var slash Pattern = is Windows ? / \ \ / g : / \ / / g var name = fn . substring ( base Path . length + trim . length , fn . length ) . replace ( / \ .jsx ? $ / , ' ' ) . replace ( slash Pattern , ' . ' ) if ( opts . label ) { name + = ' . ' + opts . label } if ( prefix ) { name = prefix + name } return name ; } 
function ( r , g , b ) { return { server : 1 6 + r * 3 6 + g * 6 + b , client : "rgb ( " + [ ( r * 4 2 . 5 ) | 0 , ( g * 4 2 . 5 ) | 0 , ( b * 4 2 . 5 ) | 0 , ] . join ( ' , ' ) + " ) " , } } 
function write Body ( req , res , context , start , page ) { 
function write Elements ( res , elements ) { 
function lazy Mixin Page Util Methods ( page ) { var proto = Object . get Prototype Of ( page ) ; if ( proto . _have Mixed In Page Util Methods ) return ; proto . _have Mixed In Page Util Methods = true ; Object . keys ( PAGE _MIXIN ) . for Each ( method = > { if ( proto [ method ] ) { throw new Error ( ` $ { ( proto . constructor | | { } ) . name } $ { method } ` ) ; } proto [ method ] = PAGE _MIXIN [ method ] ; } ) ; } 
function standardize Elements ( elements ) { 
function log Invocation ( name , func ) { return function ( ) { logger . debug ( ` $ { name } ` ) ; return func . apply ( this , [ ] . slice . call ( arguments ) ) ; } } 
function make Standard ( standardize , fn ) { return function ( ) { return standardize ( fn . apply ( null , [ ] . slice . call ( arguments ) ) ) ; } } 
function History ( options ) { this . win = ( options & & options . win ) | | window ; this . _has Push State = ! ! ( this . win & & this . win . history & & this . win . history . push State ) ; } 
function ( state , title , url ) { var win = this . win ; if ( this . can Client Navigate ( ) ) { win . history . push State ( state , title , url ) ; } else { this . navigation Window ( ) . location . href = url ; } } 
function ( state , title , url ) { var win = this . win ; if ( this . can Client Navigate ( ) ) { win . history . replace State ( state , title , url ) ; } else if ( url ! = = this . current Url ( ) ) { 
function add On Click Handler ( a , { reuse Dom , bundle Data } ) { a . onclick = function ( e ) { 
function get Webpack Config ( user Webpack Config Opt , wp Affecting Opts ) { let extend = ( data ) = > { return data } if ( user Webpack Config Opt ) { const user Webpack Config Path = path . resolve ( process . cwd ( ) , user Webpack Config Opt ) ; const user Webpack Config Func = require ( user Webpack Config Path ) ; extend = user Webpack Config Func . default ; } const base Config = require ( path . join ( _ _dirname , "webpack /webpack 4 .config .fn .js " ) ) . default ( wp Affecting Opts ) ; return extend ( base Config ) ; } 
function stats To Manifest ( stats ) { const js Chunks By Name = { } ; const css Chunks By Name = { } ; const js Chunks By Id = { } ; const css Chunks By Id = { } ; let file ; for ( const chunk of stats . compilation . chunks ) { for ( let i = 0 ; i < chunk . files . length ; i + + ) { file = chunk . files [ i ] ; if ( / \ .css $ / . test ( file ) ) { css Chunks By Id [ chunk . id ] = file ; if ( chunk . name ) { css Chunks By Name [ chunk . name ] = file ; } } else if ( / ^ ( ( ? !hot -update ) . ) * \ .js $ / . test ( file ) ) { 
function write Client Bootstrap File ( output Dir , opts ) { const output File = output Dir + " /entry .js " ; fs . write File Sync ( output File , ` $ { JSON . stringify ( opts . log Level ) } $ { JSON . stringify ( opts . timing Log Level ) } $ { JSON . stringify ( opts . gauge Log Level ) } ` ) ; return output File ; } 
function error Interceptor ( level , msg , meta ) { if ( meta instanceof Error ) { meta = { error : meta } ; } else if ( meta & & meta . status & & meta . response ) { meta = { error : meta } ; } if ( _ . is Plain Object ( meta ) ) { 
function normalize Error ( err ) { if ( err instanceof Error ) { return _ . pick By ( { message : err . message , stack : err . stack , } , val = > ! _ . is Empty ( val ) ) ; } if ( err & & err . status & & err . response ) { 
function wrap Logger ( get Logger For Config , opts ) { var main Logger = get Logger For Config ( 'main ' , opts ) , time Logger = get Logger For Config ( 'time ' , opts ) , gauge Logger = get Logger For Config ( 'gauge ' , opts ) , classify Time = make Time Classifier ( opts ) , classify Gauge = make Gauge Classifier ( opts ) 
function make Thresholds Sieve ( options , defaults ) { if ( ! options ) options = { } ; 
function canonical _uri ( src , base _path ) { var absolute _regex = / ^ \w + \ : \ / \ / / ; 
function merge _objs ( source , target ) { for ( var k in source ) { if ( source . has Own Property ( k ) ) { target [ k ] = source [ k ] ; 
function check _chain _group _scripts _ready ( chain _group ) { var any _scripts _ready = false ; for ( var i = 0 ; i < chain _group . scripts . length ; i + + ) { if ( chain _group . scripts [ i ] . ready & & chain _group . scripts [ i ] . exec _trigger ) { any _scripts _ready = true ; chain _group . scripts [ i ] . exec _trigger ( ) ; chain _group . scripts [ i ] . exec _trigger = null ; } } return any _scripts _ready ; } 
function create _script _load _listener ( elem , registry _item , flag , onload ) { elem . onload = elem . onreadystatechange = function ( ) { if ( ( elem . ready State & & elem . ready State ! = "complete " & & elem . ready State ! = "loaded " ) | | registry _item [ flag ] ) return ; elem . onload = elem . onreadystatechange = null ; onload ( ) ; } ; } 
function script _executed ( registry _item ) { registry _item . ready = registry _item . finished = true ; for ( var i = 0 ; i < registry _item . finished _listeners . length ; i + + ) { registry _item . finished _listeners [ i ] ( ) ; } registry _item . ready _listeners = [ ] ; registry _item . finished _listeners = [ ] ; } 
function request _script ( chain _opts , script _obj , registry _item , onload , preload _this _script ) { 
function create _sandbox ( ) { var global _defaults = { } , can _use _preloading = real _preloading | | xhr _or _cache _preloading , queue = [ ] , registry = { } , instance API ; 
function execute _preloaded _script ( chain _opts , script _obj , registry _item ) { var script ; function preload _execute _finished ( ) { if ( script ! = null ) { 
function do _script ( chain _opts , script _obj , chain _group , preload _this _script ) { var registry _item , registry _items , ready _cb = function ( ) { script _obj . ready _cb ( script _obj , function ( ) { execute _preloaded _script ( chain _opts , script _obj , registry _item ) ; } ) ; } , finished _cb = function ( ) { script _obj . finished _cb ( script _obj , chain _group ) ; } ; script _obj . src = canonical _uri ( script _obj . src , chain _opts [ _Base Path ] ) ; script _obj . real _src = script _obj . src + 
function ( ) { registry _item . ready = true ; for ( var i = 0 ; i < registry _item . ready _listeners . length ; i + + ) { registry _item . ready _listeners [ i ] ( ) ; } registry _item . ready _listeners = [ ] ; } 
function create _chain ( ) { var chained API , chain _opts = merge _objs ( global _defaults , { } ) , chain = [ ] , exec _cursor = 0 , scripts _currently _loading = false , chain _is _corked = false , group ; 
function chain _script _ready ( script _obj , exec _trigger ) { if ( chain _opts [ _Debug ] ) log _msg ( "script preload finished : " + script _obj . real _src ) ; script _obj . ready = true ; script _obj . exec _trigger = function ( ) { if ( chain _opts [ _Debug ] ) log _msg ( "script execute start : " + script _obj . real _src ) ; exec _trigger ( ) ; } advance _exec _cursor ( ) ; 
function chain _script _executed ( script _obj , chain _group ) { if ( chain _opts [ _Debug ] ) log _msg ( "script execution finished : " + script _obj . real _src ) ; script _obj . ready = script _obj . finished = true ; script _obj . exec _trigger = null ; 
function advance _exec _cursor ( ) { if ( chain _is _corked ) return ; while ( exec _cursor < chain . length ) { if ( is _func ( chain [ exec _cursor ] ) ) { if ( chain _opts [ _Debug ] ) log _msg ( " $LAB .wait ( ) executing : " + chain [ exec _cursor ] ) ; try { chain [ exec _cursor + + ] ( ) ; } catch ( err ) { if ( chain _opts [ _Debug ] ) log _error ( " $LAB .wait ( ) error caught : " , err ) ; } continue ; } else if ( ! chain [ exec _cursor ] . finished ) { if ( check _chain _group _scripts _ready ( chain [ exec _cursor ] ) ) continue ; break ; } exec _cursor + + ; } 
function init _script _chain _group ( ) { if ( ! group | | ! group . scripts ) { chain . push ( group = { scripts : [ ] , finished : true } ) ; } } 
function ( ) { if ( arguments . length > 0 ) { for ( var i = 0 ; i < arguments . length ; i + + ) { chain . push ( arguments [ i ] ) ; } group = chain [ chain . length - 1 ] ; } else group = false ; advance _exec _cursor ( ) ; return chained API ; } 
function build ( ) { console . log ( 'Creating an optimized production build . . . ' ) ; webpack ( config ) . run ( ( err ) = > { if ( err ) { console . error ( 'Failed to create a production build . Reason : ' ) ; console . error ( err . message | | err ) ; process . exit ( 1 ) ; } console . log ( chalk . green ( 'Compiled successfully . ' ) ) ; console . log ( ` $ { chalk . cyan ( 'dist ' ) } ` ) ; console . log ( ) ; } ) ; } 
function find Log Path ( app Name , file Name ) { file Name = file Name | | 'log .log ' ; var user Data = app Name ? null : utils . get User Data ( ) ; app Name = app Name | | get App Name ( ) ; var home Dir = os . homedir ? os . homedir ( ) : process . env . HOME ; var dir ; switch ( process . platform ) { case 'darwin ' : { dir = prepare Dir ( home Dir , 'Library ' , 'Logs ' , app Name ) . or ( user Data ) . or ( home Dir , 'Library ' , 'Application Support ' , app Name ) . result ; break ; } case 'win 3 2 ' : { dir = prepare Dir ( user Data ) . or ( process . env . APPDATA , app Name ) . or ( home Dir , 'App Data ' , 'Roaming ' , app Name ) . result ; break ; } default : { dir = prepare Dir ( user Data ) . or ( process . env . XDG _CONFIG _HOME , app Name ) . or ( home Dir , ' .config ' , app Name ) . or ( process . env . XDG _DATA _HOME , app Name ) . or ( home Dir , ' .local ' , 'share ' , app Name ) . result ; break ; } } if ( dir ) { return path . join ( dir , file Name ) ; } return false ; } 
function format ( msg , formatter , electron Log , remove Styles ) { remove Styles = remove Styles ! = = undefined ? remove Styles : false ; if ( typeof formatter = = = 'function ' ) { return formatter ( msg , electron Log ) ; } var date = new Date ( msg . date | | Date . now ( ) ) ; var variables = msg . variables ; var result = formatter ; for ( var i in variables ) { if ( ! variables . has Own Property ( i ) ) continue ; result = result . replace ( ' { ' + i + ' } ' , variables [ i ] ) ; } result = result . replace ( ' {level } ' , msg . level ) . replace ( ' {text } ' , stringify Array ( msg . data ) ) . replace ( ' {y } ' , String ( date . get Full Year ( ) ) ) . replace ( ' {m } ' , pad ( date . get Month ( ) + 1 ) ) . replace ( ' {d } ' , pad ( date . get Date ( ) ) ) . replace ( ' {h } ' , pad ( date . get Hours ( ) ) ) . replace ( ' {i } ' , pad ( date . get Minutes ( ) ) ) . replace ( ' {s } ' , pad ( date . get Seconds ( ) ) ) . replace ( ' {ms } ' , pad ( date . get Milliseconds ( ) , 3 ) ) . replace ( ' {z } ' , format Time Zone ( date . get Timezone Offset ( ) ) ) ; if ( remove Styles ) { result = result . replace ( / %c / g , ' ' ) ; } return result ; } 
function load Package Name ( ) { var package File ; try { if ( require . main . filename ) { package File = find ( path . dirname ( require . main . filename ) ) ; } } catch ( e ) { package File = null ; } if ( ! package File & & process . resources Path ) { package File = find ( path . join ( process . resources Path , 'app .asar ' ) ) ; var electron Module = path . join ( 'node _modules ' , 'electron ' , 'package .json ' ) ; if ( package File & & package File . index Of ( electron Module ) ! = = - 1 ) { package File = null ; } } if ( ! package File ) { package File = find ( process . cwd ( ) ) ; } if ( ! package File ) { return null ; } var content = fs . read File Sync ( package File , 'utf - 8 ' ) ; var package Data = JSON . parse ( content ) ; 
function generate Typedoc Docs ( typedoc Docs Dir ) { const public Api Config File = path . resolve ( _ _dirname , ' . . /src /ng 5 -slider /lib /public _api .json ' ) ; const public Api Config = JSON . parse ( fs . read File Sync ( public Api Config File , { encoding : 'utf 8 ' } ) ) ; const files = public Api Config . exports . map ( export Def = > path . resolve ( _ _dirname , ` $ { export Def . file } ` ) ) ; const theme Dir = path . resolve ( _ _dirname , ' . . /typedoc -theme ' ) ; 
function generate Component ( typedoc Html File , relative Typedoc Html File , demo App Docs Module Dir ) { const directory = path . dirname ( relative Typedoc Html File ) ; mkdirp . sync ( path . join ( demo App Docs Module Dir , directory ) ) ; const file Name = path . basename ( relative Typedoc Html File ) ; const component Html File Name = file Name . replace ( / \ .html $ / , ' .component .html ' ) ; const component Html File = path . join ( demo App Docs Module Dir , directory , component Html File Name ) ; const typedoc Html File Content = fs . read File Sync ( typedoc Html File , { encoding : 'utf 8 ' } ) ; const escaped Html File Content = fix Router Fragments ( fix Readme Md Links ( escape Html For Angular ( typedoc Html File Content ) ) ) ; fs . write File Sync ( component Html File , escaped Html File Content , { encoding : 'utf 8 ' } ) ; const component File Name = file Name . replace ( / \ .html $ / , ' .component ' ) ; const component Ts File Name = component File Name + ' .ts ' ; const component Ts File = path . join ( demo App Docs Module Dir , directory , component Ts File Name ) ; const component Name = generate Component Name ( file Name ) ; const component Ts File Content = ` $ { component Html File Name } $ { component Name } ` ; fs . write File Sync ( component Ts File , component Ts File Content , { encoding : 'utf 8 ' } ) ; 
function generate Component Name ( file Name ) { const bare Name = file Name . replace ( / \ .html $ / , ' ' ) . replace ( / [ . _ ] / g , ' ' ) ; return bare Name . char At ( 0 ) . to Upper Case ( ) + bare Name . substr ( 1 ) + 'Component ' ; } 
function generate Module File ( components Metadata , demo App Docs Module Dir ) { const imports = components Metadata . map ( component Metadata = > ` $ { component Metadata . name } $ { component Metadata . file } ` ) . join ( ' \n ' ) ; const components = components Metadata . map ( component Metadata = > ` $ { component Metadata . name } ` ) . join ( ' \n ' ) ; const routes = components Metadata . map ( component Metadata = > ` $ { component Metadata . route } $ { component Metadata . name } ` ) . join ( ' \n ' ) ; const module Ts File Contents = ` $ { imports } $ { routes } $ { components } $ { components } ` ; const module Ts File = path . join ( demo App Docs Module Dir , 'docs .module .ts ' ) ; fs . write File Sync ( module Ts File , module Ts File Contents , { encoding : 'utf 8 ' } ) ; } 
function generate Package Json ( ) { const main File = path . resolve ( _ _dirname , ' . . /package .json ' ) ; const lib Template File = path . resolve ( _ _dirname , ' . . /src /ng 5 -slider /package .json .template ' ) ; const lib File = path . resolve ( _ _dirname , ' . . /src /ng 5 -slider /package .json ' ) ; const lib Template Config = JSON . parse ( fs . read File Sync ( lib Template File , { encoding : 'utf 8 ' } ) ) ; const main Config = JSON . parse ( fs . read File Sync ( main File , { encoding : 'utf 8 ' } ) ) ; let lib Config = { } ; for ( let key of lib Template Config . keys To Copy From Main Package Json ) { lib Config [ key ] = main Config [ key ] ; } lib Config . dependencies = { } ; for ( let dependency of lib Template Config . dependencies To Copy From Main Package Json ) { lib Config . dependencies [ dependency ] = main Config . dependencies [ dependency ] ; } lib Config . peer Dependencies = { } ; for ( let dependency of lib Template Config . dependencies To Copy As Peer Dependencies From Main Package Json ) { lib Config . peer Dependencies [ dependency ] = main Config . dependencies [ dependency ] ; } lib Config = Object . assign ( { } , lib Config , lib Template Config , lib Config ) ; delete lib Config . keys To Copy From Main Package Json ; delete lib Config . dependencies To Copy From Main Package Json ; delete lib Config . dependencies To Copy As Peer Dependencies From Main Package Json ; for ( let dependency of lib Template Config . dependencies To Copy From Main Package Json ) { lib Config . ng Package . whitelisted Non Peer Dependencies . push ( dependency ) ; } const pretty Printed Lib Config = JSON . stringify ( lib Config , null , 2 ) ; fs . write File Sync ( lib File , pretty Printed Lib Config , { encoding : 'utf 8 ' } ) ; } 
function generate Public Api Ts ( ) { const config File = path . resolve ( _ _dirname , ' . . /src /ng 5 -slider /lib /public _api .json ' ) ; const ts File = path . resolve ( _ _dirname , ' . . /src /ng 5 -slider /lib /public _api .ts ' ) ; const config = JSON . parse ( fs . read File Sync ( config File , { encoding : 'utf 8 ' } ) ) ; let ts File Content = ' ' ; for ( let export Def of config . exports ) { if ( export Def . what instanceof Array ) { const whats = export Def . what . join ( ' , ' ) ; ts File Content + = ` $ { whats } $ { export Def . file } \n ` ; } else { ts File Content + = ` $ { export Def . what } $ { export Def . file } \n ` ; } } fs . write File Sync ( ts File , ts File Content , { encoding : 'utf 8 ' } ) ; } 
function readdir Recursively Sync ( dir ) { let results = [ ] ; const list = fs . readdir Sync ( dir ) ; for ( let file of list ) { file = path . resolve ( dir , file ) ; const stat = fs . stat Sync ( file ) ; if ( stat & & stat . is Directory ( ) ) { results = results . concat ( readdir Recursively Sync ( file ) ) ; } else { results . push ( file ) ; } } return results ; } 
function copy Readme Md ( source Readme Md ) { const lib Readme File = path . resolve ( _ _dirname , ' . . /src /ng 5 -slider /README .md ' ) ; const source Readme = fs . read File Sync ( source Readme Md , { encoding : 'utf 8 ' } ) ; fs . write File Sync ( lib Readme File , source Readme , { encoding : 'utf 8 ' } ) ; } 
function generate Template ( template File , snippets Dir ) { const title Template File = template File . replace ( ' .template .html ' , ' .title -template .html ' ) ; const output Template File = template File . replace ( ' .template .html ' , ' .html ' ) ; const code File = template File . replace ( ' .template .html ' , ' .ts ' ) ; const style File = template File . replace ( ' .template .html ' , ' .scss ' ) ; const title Template File Content = fs . read File Sync ( path . resolve ( snippets Dir , title Template File ) , { encoding : 'utf 8 ' } ) ; const template File Content = fs . read File Sync ( path . resolve ( snippets Dir , template File ) , { encoding : 'utf 8 ' } ) ; const template Tab Html = tab Html ( path . basename ( output Template File ) , template File Content , 'html ' ) ; let code File Content = fs . read File Sync ( path . resolve ( snippets Dir , code File ) , { encoding : 'utf 8 ' } ) ; 
function highlight ( code , lang ) { return prism . highlight ( code . trim ( ) , prism . languages [ lang ] ) ; } 
function tab Html ( tab Title , code Content , code Lang ) { return ` $ { escape ( tab Title ) } $ { code Lang } $ { code Lang } $ { escape Braces ( highlight ( code Content , code Lang ) ) } ` ; } 
function render Rule ( rule ) { const mark = ` $ { rule . recommended ? " ⭐ ️ " : " } {r u le .fix a ble ? " ️ : " " } ` const link = ` $ { rule . id } $ { rule . name } ` const description = rule . description | | " (no description ) " return ` $ { link } $ { description } $ { mark } ` } 
function render Deprecated Rule ( rule ) { const link = ` $ { rule . id } $ { rule . name } ` const replaced By = rule . replaced By . map ( name = > ` $ { name } $ { name } ` ) . join ( " and " ) return ` $ { link } $ { replaced By | | " (nothing ) " } ` } 
function parse Options ( context ) { const raw = context . options [ 0 ] | | { } const file Path = context . get Filename ( ) const version = get Configured Node Version ( raw . version , file Path ) const ignores = new Set ( raw . ignores | | [ ] ) return Object . freeze ( { version , ignores } ) } 
function nomalize Scope ( initial Scope , node ) { let scope = get Innermost Scope ( initial Scope , node ) while ( scope & & scope . block = = = node ) { scope = scope . upper } return scope } 
function merge ( x , y ) { for ( const key of Object . keys ( y ) ) { if ( typeof x [ key ] = = = "function " ) { if ( x [ key ] . _handlers = = null ) { const fs = [ x [ key ] , y [ key ] ] x [ key ] = dispatch . bind ( null , fs ) x [ key ] . _handlers = fs } else { x [ key ] . _handlers . push ( y [ key ] ) } } else { x [ key ] = y [ key ] } } return x } 
function define Visitor ( context , options ) { const test Info Prototype = { get is Strict ( ) { return nomalize Scope ( context . get Scope ( ) , this . node ) . is Strict } , } function is Not Supporting Version ( a Case ) { return ( ! a Case . supported | | options . version . intersects ( get Semver Range ( ` $ { a Case . supported } ` ) ) ) } function is Not Supporting On ( node ) { return a Case = > is Not Supporting Version ( a Case ) & & ( ! a Case . test | | a Case . test ( { node , _ _proto _ _ : test Info Prototype } ) ) } return ( keywords 
function is Not Supporting Version ( a Case ) { return ( ! a Case . supported | | options . version . intersects ( get Semver Range ( ` $ { a Case . supported } ` ) ) ) } 
function is Not Supporting On ( node ) { return a Case = > is Not Supporting Version ( a Case ) & & ( ! a Case . test | | a Case . test ( { node , _ _proto _ _ : test Info Prototype } ) ) } 
function read Package Json ( dir ) { const file Path = path . join ( dir , "package .json " ) try { const text = fs . read File Sync ( file Path , "utf 8 " ) const data = JSON . parse ( text ) if ( typeof data = = = "object " & & data ! = = null ) { data . file Path = file Path return data } } catch ( _err ) { 
function get ( option ) { if ( option & & option . allow Modules & & Array . is Array ( option . allow Modules ) ) { return option . allow Modules . map ( String ) } return null } 
function get Static Property Name ( node ) { let prop = null switch ( node & & node . type ) { case "Property " : case "Method Definition " : prop = node . key break case "Member Expression " : prop = node . property break 
function get Top Assignment ( leaf Node ) { let node = leaf Node 
function get Module Exports Nodes ( scope ) { const variable = scope . set . get ( "module " ) if ( variable = = null ) { return [ ] } return variable . references . map ( reference = > reference . identifier . parent ) . filter ( node = > node . type = = = "Member Expression " & & get Static Property Name ( node ) = = = "exports " ) } 
function get Exports Nodes ( scope ) { const variable = scope . set . get ( "exports " ) if ( variable = = null ) { return [ ] } return variable . references . map ( reference = > reference . identifier ) } 
function get Location ( node ) { const token = source Code . get Token After ( node ) return { start : node . loc . start , end : token . loc . end , } } 
function enforce Module Exports ( ) { const global Scope = context . get Scope ( ) const exports Nodes = get Exports Nodes ( global Scope ) const assign List = batch Assign Allowed ? create Assignment List ( get Module Exports Nodes ( global Scope ) ) : [ ] for ( const node of exports Nodes ) { 
function enforce Exports ( ) { const global Scope = context . get Scope ( ) const exports Nodes = get Exports Nodes ( global Scope ) const module Exports Nodes = get Module Exports Nodes ( global Scope ) const assign List = batch Assign Allowed ? create Assignment List ( exports Nodes ) : [ ] const batch Assign List = [ ] for ( const node of module Exports Nodes ) { 
function filter Never Ignored Files ( p ) { const basedir = path . dirname ( p . file Path ) const main File Path = typeof p . main = = = "string " ? path . join ( basedir , p . main ) : null return file Path = > path . join ( basedir , file Path ) ! = = main File Path & & file Path ! = = "package .json " & & ! NEVER _IGNORED . test ( path . relative ( basedir , file Path ) ) } 
function parse White List ( files ) { if ( ! files | | ! Array . is Array ( files ) ) { return null } const ig = ignore ( ) const ig N = ignore ( ) let has N = false for ( const file of files ) { if ( typeof file = = = "string " & & file ) { const body = file . replace ( SLASH _AT _BEGIN _AND _END , " " ) if ( file . starts With ( " ! " ) ) { ig N . add ( ` $ { body } ` ) ig N . add ( ` $ { body } ` ) has N = true } else { ig . add ( ` $ { body } ` ) ig . add ( ` $ { body } ` ) } } } return has N ? or ( ig . create Filter ( ) , not ( ig N . create Filter ( ) ) ) : ig . create Filter ( ) } 
function parse Npmignore ( basedir , files Field Exists ) { let file Path = path . join ( basedir , " .npmignore " ) if ( ! exists ( file Path ) ) { if ( files Field Exists ) { return null } file Path = path . join ( basedir , " .gitignore " ) if ( ! exists ( file Path ) ) { return null } } const ig = ignore ( ) ig . add ( fs . read File Sync ( file Path , "utf 8 " ) ) return not ( ig . create Filter ( ) ) } 
function normalize Value ( x ) { if ( Array . is Array ( x ) ) { return x } return Object . keys ( x ) . map ( pattern = > ( { include : [ pattern ] , exclude : [ ] , replace : x [ pattern ] , } ) ) } 
function create Match ( include Patterns , exclude Patterns ) { const include = include Patterns . map ( pattern = > new Minimatch ( pattern ) ) const exclude = exclude Patterns . map ( pattern = > new Minimatch ( pattern ) ) return file Path = > include . some ( m = > m . match ( file Path ) ) & & ! exclude . some ( m = > m . match ( file Path ) ) } 
function combine ( converters ) { return file Path = > { for ( const converter of converters ) { if ( converter . match ( file Path ) ) { return converter . convert ( file Path ) } } return file Path } } 
function parse ( option ) { if ( ! option | | ! option . convert Path | | typeof option . convert Path ! = = "object " ) { return null } const converters = [ ] for ( const pattern of normalize Value ( option . convert Path ) ) { const include = to String Array ( pattern . include ) const exclude = to String Array ( pattern . exclude ) const from Regexp = new Reg Exp ( String ( pattern . replace [ 0 ] ) ) 
function to Name ( type , path ) { const base Name = path . join ( " . " ) return type = = = Reference Tracker . CALL ? ` $ { base Name } ` : type = = = Reference Tracker . CONSTRUCT ? ` $ { base Name } ` : base Name } 
function report Item ( node , name , info ) { context . report ( { node , loc : node . loc , message : " { {name } } was deprecated since v { {version } } { {replace } } . " , data : { name , version : info . since , replace : to Replace Message ( info . replaced By ) , } , } ) } 
function render Footer ( rule ) { const docs Path = path . dirname ( path . resolve ( docs Root , ` $ { rule . name } ` ) ) const rule Path = path . relative ( docs Path , path . join ( rule Root , ` $ { rule . name } ` ) ) . replace ( / \ \ / gu , " / " ) const test Path = path . relative ( docs Path , path . join ( test Root , ` $ { rule . name } ` ) ) . replace ( / \ \ / gu , " / " ) return ` \n \n n - [ ul e Path } ) \ n [ es t Path } ) ` } 
function get ( option ) { if ( option & & option . try Extensions & & Array . is Array ( option . try Extensions ) ) { return option . try Extensions . map ( String ) } return null } 
function get Default Version ( filename ) { const info = get Package Json ( filename ) const node Version = info & & info . engines & & info . engines . node return semver . valid Range ( node Version ) | | DEFAULT _VERSION } 
function get Ignores Enum ( ) { return Object . keys ( OPTIONS . reduce ( ( retv , key ) = > { for ( const alias of FEATURES [ key ] . alias ) { retv [ alias ] = true } retv [ key ] = true return retv } , Object . create ( null ) ) ) } 
function is Ignored ( key , ignores ) { return ( ignores . index Of ( key ) ! = = - 1 | | FEATURES [ key ] . alias . some ( alias = > ignores . index Of ( alias ) ! = = - 1 ) ) } 
function parse Options ( options , default Version ) { let version = null let range = null let ignores = [ ] if ( typeof options = = = "number " ) { version = VERSION _MAP . get ( options ) } else if ( typeof options = = = "string " ) { version = options } else if ( typeof options = = = "object " ) { version = typeof options . version = = = "number " ? VERSION _MAP . get ( options . version ) : options . version ignores = options . ignores | | [ ] } range = semver . valid Range ( version ? ` $ { version } ` : default Version ) if ( ! version ) { version = default Version } return Object . freeze ( { version , features : Object . freeze ( OPTIONS . reduce ( ( retv , key ) = > { const feature = FEATURES [ key ] if ( is Ignored ( key , ignores ) ) { retv [ key ] = Object . freeze ( { name : feature . name , singular : Boolean ( feature . singular ) , supported : true , supported In Strict : true , } ) } else if ( typeof feature . node = = = "string " ) { retv [ key ] = Object . freeze ( { name : feature . name , singular : Boolean ( feature . singular ) , supported : ! semver . intersects ( range , ` $ { feature . node } ` ) , supported In Strict : ! semver . intersects ( range , ` $ { feature . node } ` ) , } ) } else { retv [ key ] = Object . freeze ( { name : feature . name , singular : Boolean ( feature . singular ) , supported : feature . node ! = null & & feature . node . sloppy ! = null & & ! semver . intersects ( range , ` $ { feature . node . sloppy } ` ) , supported In Strict : feature . node ! = null & & feature . node . strict ! = null & & ! semver . intersects ( range , ` $ { feature . node . strict } ` ) , } ) } return retv } , Object . create ( null ) ) ) , } ) } 
function has Unicode Code Point Escape ( raw ) { let match = null UNICODE _ESC . last Index = 0 while ( ( match = UNICODE _ESC . exec ( raw ) ) ! = null ) { if ( match [ 1 ] . length % 2 = = = 1 ) { return true } } return false } 
function has Pattern ( s , pattern ) { const m = pattern . exec ( s ) return m ! = null & & ( m [ 1 ] | | " " ) . length % 2 = = = 0 } 
function has Trailing Comma For Function ( node ) { const length = node . params . length return ( length > = 1 & & source Code . get Token After ( node . params [ length - 1 ] ) . value = = = " , " ) } 
function extends Null ( node ) { return ( node . super Class ! = null & & node . super Class . type = = = "Literal " & & node . super Class . value = = = null ) } 
function report ( node , key ) { const version = support Info . version const feature = support Info . features [ key ] if ( feature . supported ) { return } if ( ! feature . supported In Strict ) { context . report ( { node , message : " { {feature } } { {be } } not supported yet on Node { {version } } . " , data : { feature : feature . name , be : feature . singular ? "is " : "are " , version , } , } ) } else if ( ! nomalize Scope ( context . get Scope ( ) , node ) . is Strict ) { context . report ( { node , message : " { {feature } } { {be } } not supported yet on Node { {version } } . " , data : { feature : ` $ { feature . name } ` , be : feature . singular ? "is " : "are " , version , } , } ) } } 
function validate Reg Exp ( pattern , flags , node ) { if ( typeof pattern = = = "string " ) { if ( has Pattern ( pattern , REGEXP _NAMED _GROUP ) ) { report ( node , "regexp Named Capture Groups " ) } if ( has Pattern ( pattern , REGEXP _LOOKBEHIND ) ) { report ( node , "regexp Lookbehind " ) } if ( has Pattern ( pattern , REGEXP _UNICODE _PROPERTY ) ) { report ( node , "regexp Unicode Properties " ) } } if ( typeof flags = = = "string " ) { if ( flags . index Of ( "y " ) ! = = - 1 ) { report ( node , "regexp Y " ) } if ( flags . index Of ( "u " ) ! = = - 1 ) { report ( node , "regexp U " ) } if ( flags . index Of ( "s " ) ! = = - 1 ) { report ( node , "regexp S " ) } } } 
function validate Reg Exp Literal ( node ) { validate Reg Exp ( node . regex . pattern , node . regex . flags , node ) } 
function validate Reg Exp String ( node ) { const pattern Node = node . arguments [ 0 ] const flags Node = node . arguments [ 1 ] const pattern = pattern Node & & pattern Node . type = = = "Literal " & & typeof pattern Node . value = = = "string " ? pattern Node . value : null const flags = flags Node & & flags Node . type = = = "Literal " & & typeof flags Node . value = = = "string " ? flags Node . value : null validate Reg Exp ( pattern , flags , node ) } 
function get File Path ( is Module , id , options ) { try { return resolve . sync ( id , options ) } catch ( _err ) { if ( is Module ) { return null } return path . resolve ( options . basedir , id ) } } 
function get Module Name ( name Or Path ) { let end = name Or Path . index Of ( " / " ) if ( end ! = = - 1 & & name Or Path [ 0 ] = = = " @ " ) { end = name Or Path . index Of ( " / " , 1 + end ) } return end = = = - 1 ? name Or Path : name Or Path . slice ( 0 , end ) } 
function is Bin File ( file Path , bin Field , basedir ) { if ( ! bin Field ) { return false } if ( typeof bin Field = = = "string " ) { return file Path = = = path . resolve ( basedir , bin Field ) } return Object . keys ( bin Field ) . some ( key = > file Path = = = path . resolve ( basedir , bin Field [ key ] ) ) } 
function get Shebang Info ( source Code ) { const m = SHEBANG _PATTERN . exec ( source Code . text ) return { bom : source Code . has BOM , cr : Boolean ( m & & m [ 2 ] ) , length : ( m & & m [ 0 ] . length ) | | 0 , shebang : ( m & & m [ 1 ] & & ` $ { m [ 1 ] } \n ` ) | | " " , } } 
function get Existing Extensions ( file Path ) { const basename = path . basename ( file Path , path . extname ( file Path ) ) try { return fs . readdir Sync ( path . dirname ( file Path ) ) . filter ( filename = > path . basename ( filename , path . extname ( filename ) ) = = = basename ) . map ( filename = > path . extname ( filename ) ) } catch ( _error ) { return [ ] } } 
function forward Current To Head ( analyzer , node ) { const code Path = analyzer . code Path const state = Code Path . get State ( code Path ) const current Segments = state . current Segments const head Segments = state . head Segments const end = Math . max ( current Segments . length , head Segments . length ) let i = 0 let current Segment = null let head Segment = null 
function is Process Exit ( node ) { return ( node . type = = = "Call Expression " & & node . callee . type = = = "Member Expression " & & node . callee . computed = = = false & & node . callee . object . type = = = "Identifier " & & node . callee . object . name = = = "process " & & node . callee . property . type = = = "Identifier " & & node . callee . property . name = = = "exit " ) } 
function override Leave Node ( node ) { if ( is Process Exit ( node ) ) { this . current Node = node forward Current To Head ( this , node ) Code Path . get State ( this . code Path ) . make Throw ( ) this . original . leave Node ( node ) this . current Node = null } else { original Leave Node . call ( this , node ) } } 
function get Engines Node ( filename ) { const info = get Package Json ( filename ) return get Semver Range ( info & & info . engines & & info . engines . node ) } 
function exists Case Sensitive ( file Path ) { let dir Path = file Path while ( dir Path ! = = " " & & ! ROOT . test ( dir Path ) ) { const file Name = path . basename ( dir Path ) dir Path = path . dirname ( dir Path ) if ( fs . readdir Sync ( dir Path ) . index Of ( file Name ) = = = - 1 ) { return false } } return true } 
function get ( option ) { if ( option & & option . resolve Paths & & Array . is Array ( option . resolve Paths ) ) { return option . resolve Paths . map ( String ) } return null } 
function check File ( path ) { const formatter = path . match ( / \ .md $ / ) ? prettier Format : clang Format ; const source = fs . read File Sync ( path , 'utf 8 ' ) ; const formatted = formatter ( path , source ) ; if ( source ! = = formatted ) { return formatted ; } return null ; } 
function Listener ( component , . . . path ) { var assign ; this . component = component ; ( assign = path , this . key = assign [ 0 ] ) ; this . path = path . slice ( 1 , path . length ) ; this . depth = 0 ; this . attached = true ; this . process Value = value = > value ; this . change Listener = ( ) = > { } ; this . added Listeners = [ ] ; } 
function ( i ) { var nn = nodes [ i ] ; 
function Structure ( query , props , children , depth ) { if ( props = = = void 0 ) props = { } ; if ( depth = = = void 0 ) depth = 0 ; this . query = query ; this . props = Boolean ! = = props ? props : { } ; if ( is Component ( query ) | | query instanceof Component ) { this . $comp Children = flatten ( children | | [ ] ) . map ( filter Node ) ; this . children = [ ] ; } else { this . children = flatten ( children | | [ ] ) . map ( filter Node ) ; this . $comp Children = [ ] ; } this . html = null ; this . $attr Listeners = [ ] ; this . $style Listeners = [ ] ; this . $pointer = null ; this . $component = null ; this . $listener = null ; this . $redirect = null ; this . $destroyed = false ; this . $is Svg = query = = = 'svg ' ; this . $depth = depth ; } 
function serialize Attrs ( attributes , opts ) { if ( ! attributes ) { return ; } let output = ' ' ; let value ; Object . keys ( attributes ) . for Each ( key = > { value = attributes [ key ] ; if ( output ) { output + = ' ' ; } let is Bool Attr = value & & typeof value = = = 'boolean ' ; if ( is Bool Attr ) { output + = key ; } else { output + = key + ' = " ' + ( opts . decode Entities ? entities . encode XML ( value ) : value ) + ' " ' ; } } ) ; return output ; } 
function serialize Tag ( elem , opts ) { 
function serialize Dom ( dom , opts ) { if ( ! Array . is Array ( dom ) ) { dom = [ dom ] ; } opts = opts | | { } ; let output = ' ' ; for ( let i = 0 , len = dom . length ; i < len ; i + + ) { let elem = dom [ i ] ; if ( elem . removed ) { 
function init Refs ( ) { this . $refs = { } ; let ref Info = this . props & & this . props [ REF _DATA _ATTR ] ; let page Instance = this . $page | | this ; let ref Components = page Instance . _ _ref Components | | { } ; page Instance . _ _ref Components = ref Components ; if ( ref Info ) { if ( ref Info . char At ( 0 ) = = = ' [ ' ) { ref Components [ ref Info ] | | ( ref Components [ ref Info ] = [ ] ) ; ref Components [ ref Info ] . push ( this ) ; } else { ref Components [ ref Info ] = this ; } } let refs = this . $raw Ref Data ; if ( typeof refs = = = 'function ' ) { refs = refs ( ) ; } if ( ! refs ) { return ; } let result = { } ; Object . keys ( refs ) . for Each ( id = > { result [ id ] = { get ( ) { let value = refs [ id ] ; let is Select All = Array . is Array ( value ) ; is Select All & & ( value = value [ 0 ] ) ; let key = is Select All ? ` $ { value } ` : value ; let result = ref Components [ key ] ; is Select All & & ! result & & ( result = [ ] ) ; return result ; } , enumerable : true } ; } ) ; Object . define Properties ( this . $refs , result ) ; } 
function get Require Expression Module Id ( node , t ) { if ( t . is Call Expression ( node ) ) { let { arguments : args , callee } = node ; if ( t . is Identifier ( callee ) & & callee . name = = = 'require ' & & args . length = = = 1 & & t . is Literal ( args [ 0 ] ) ) { let id = args [ 0 ] . value ; return id ; } } } 
function remove Variable Declaration ( t , bind Var , remove Opts ) { let ref Paths = bind Var . reference Paths | | [ ] ; let removed ; 
function get Required Module Path ( value Path , module Name , t , remove Require Declaration = false ) { let bind Var = value Path . scope . bindings [ module Name ] ; if ( ! bind Var ) { throw value Path . build Code Frame Error ( ` $ { module Name } ` ) ; } let declare Node Path = bind Var . path ; let parent Statement Path = bind Var . path . get Statement Parent ( ) ; 
function transform Filter In Attribute ( element , tpl Opts , options ) { let attrs = element . attribs ; let filter Attrs = element . _has Filter Attrs ; if ( ! filter Attrs | | ! filter Attrs . length ) { return ; } let { logger , file } = tpl Opts ; let { filters } = options ; filter Attrs . for Each ( k = > { let value = attrs [ k ] ; attrs [ k ] = update Filter Call ( filters , logger , file , value ) ; } ) ; } 
function process File ( file , processor , build Manager ) { let { compile Context , logger } = build Manager ; let { handler , options : opts , rext } = processor ; logger . debug ( ` $ { file . path } $ { processor . name } ` , opts ) ; let result = handler ( file , Object . assign ( { config : opts } , compile Context ) ) ; if ( ! result ) { return ; } rext & & ( file . rext = rext ) ; if ( is Promise ( result ) ) { build Manager . add Async Task ( file , result ) ; return ; } if ( result . is Sfc Component ) { compile Component ( result , file , build Manager ) ; result = { content : file . content } ; } build Manager . update File Compile Result ( file , result ) ; } 
function compile ( file , build Manager ) { let { logger , rules } = build Manager ; let processors = find Match Processor ( file , rules , build Manager ) ; logger . debug ( 'compile file : ' , file . path , processors . length ) ; file . allow Release = true ; 
function get Custom Component Tags ( config ) { let { using Components } = config | | { } ; if ( ! using Components ) { return ; } return Object . keys ( using Components ) . map ( k = > to Hyphen ( k ) ) ; } 
function get Import Filter Modules ( used Filters , script File , build Manager ) { if ( ! used Filters ) { return ; } let filter Modules = [ ] ; let { file : filter File , filter Names : defined Filters } = script File . filters | | { } ; let has Filter Used = defined Filters & & used Filters . some ( item = > { if ( defined Filters . includes ( item ) ) { return true ; } return false ; } ) ; if ( ! has Filter Used ) { return filter Modules ; } if ( filter File ) { let src = relative ( filter File . path , script File . dirname ) ; if ( src . char At ( 0 ) ! = = ' . ' ) { src = ' . / ' + src ; } filter Modules . push ( { src , filters : defined Filters } ) ; } else { filter Modules . push ( { filters : defined Filters } ) ; } return filter Modules ; } 
function do Request ( req Opts ) { req Opts = Object . assign ( { } , req Opts ) ; if ( curr Request Num > = request Max Num ) { return new Promise ( ( resolve , reject ) = > { waiting Queues . push ( { options : req Opts , resolve , reject } ) ; } ) ; } curr Request Num + + ; let raw Complete = req Opts . complete ; req Opts . complete = function ( . . . args ) { curr Request Num - - ; raw Complete & & raw Complete ( . . . args ) ; if ( ! waiting Queues . length ) { return ; } let process Req Info = waiting Queues . shift ( ) ; do Request ( process Req Info . options ) . then ( res = > process Req Info . resolve ( res ) , err = > process Req Info . reject ( err ) ) ; } ; return raw Request ( req Opts ) ; } 
function get Include Template Element ( tpl File ) { let ast = tpl File . ast ; if ( ! ast ) { ast = tpl File . ast = parse Dom ( tpl File . content . to String ( ) ) ; } let children = ast . children ; for ( let i = 0 , len = children . length ; i < len ; i + + ) { let node = children [ i ] ; if ( node . type = = = 'tag ' & & node . name = = = 'template ' ) { return node ; } } } 
function normalize Props ( props ) { Object . keys ( props ) . for Each ( k = > { let prop Value = props [ k ] ; if ( prop Value & & prop Value . default ! = = undefined ) { prop Value . value = prop Value . default ; delete prop Value . default ; } } ) ; return props ; } 
function process App Specified Media Rule ( all App Types , app Type , rule ) { let result = match App Media Params ( all App Types , app Type , rule . params ) ; if ( ! result ) { return ; } let { removed , params } = result ; params & & ( params = params . trim ( ) ) ; if ( removed ) { 
function remove Un Use Decl ( decl , to Remove Prop Name ) { let nodes = decl . parent . nodes ; let curr Idx = nodes . index Of ( decl ) ; for ( let i = curr Idx - 1 ; i > = 0 ; i - - ) { let item = nodes [ i ] ; if ( item . type = = = 'decl ' & & item . prop = = = to Remove Prop Name ) { item . remove ( ) ; } } } 
function process App Specified Declaration ( all App Types , app Type , decl ) { let { prop , parent } = decl ; let result ; if ( ( result = SPECIFIED _APP _PROP _DECL _REGEXP . exec ( prop ) ) ) { let prop App = result [ 1 ] ; let is Match App = app Type = = = prop App ; if ( all App Types . includes ( prop App ) & & ! is Match App ) { 
function do Mixin ( target , source , k , opts ) { let { mixin Attr Name = MIXIN _ATTR _NAME , lifecycle Hook Map , mixin Strategy } = opts ; if ( k = = = mixin Attr Name ) { return ; } let mixin Handler = mixin Strategy & & mixin Strategy [ k ] ; if ( mixin Handler ) { target [ k ] = mixin Handler ( target [ k ] , source [ k ] ) ; } else if ( lifecycle Hook Map [ k ] ) { let child = target [ k ] ; let parent = source [ k ] ; if ( ! Array . is Array ( child ) ) { child = child ? [ child ] : [ ] ; } if ( ! Array . is Array ( parent ) ) { parent = parent ? [ parent ] : [ ] ; } child . unshift . apply ( child , parent ) ; target [ k ] = child ; } else if ( ! target . has Own Property ( k ) ) { target [ k ] = source [ k ] ; } } 
function flatten Mixins ( mixins , target , opts ) { mixins . for Each ( item = > { if ( typeof item = = = 'function ' ) { item = item ( true , opts ) ; 
function add Builtin Plugin ( plugin Name , app Type , plugins , insert At Top ) { let plugin Info = BUILTIN _PLUGINS [ plugin Name ] ; if ( typeof plugin Info = = = 'object ' ) { plugin Info = plugin Info [ app Type ] | | plugin Info . default ; } plugin Info = normalize View Plugins ( [ plugin Info ] , app Type ) [ 0 ] ; let plugin = Array . is Array ( plugin Info ) ? plugin Info [ 0 ] : plugin Info ; let has Builtin Plugin = plugins . some ( item = > ( plugin = = = ( Array . is Array ( item ) ? item [ 0 ] : item ) ) ) ; if ( ! has Builtin Plugin ) { plugins [ insert At Top ? 'unshift ' : 'push ' ] ( plugin Info ) ; } } 
function normalize View Plugins ( plugins , app Type ) { return plugins . map ( plugin Info = > { let plugin Item = plugin Info ; let plugin Options ; if ( Array . is Array ( plugin Info ) ) { plugin Item = plugin Info [ 0 ] ; plugin Options = plugin Info [ 1 ] ; } if ( typeof plugin Item = = = 'string ' ) { let plugin Path = BUILTIN _PLUGINS [ plugin Item ] ; if ( typeof plugin Path = = = 'function ' ) { plugin Path = plugin Path ( app Type ) ; } else if ( plugin Path & & typeof plugin Path = = = 'object ' ) { plugin Path = plugin Path [ app Type ] | | plugin Path . default ; } if ( plugin Path & & Array . is Array ( plugin Path ) ) { plugin Options = plugin Path [ 1 ] ; plugin Path = plugin Path [ 0 ] ; } plugin Path & & ( plugin Item = plugin Path ) ; } if ( typeof plugin Item = = = 'string ' ) { plugin Item = require ( plugin Item ) ; } return plugin Options ? [ plugin Item , plugin Options ] : plugin Item ; } ) ; } 
function handle On Tag ( file , tag Name , replace Tag Name ) { let tags = file . tags ; tags | | ( tags = file . tags = { } ) ; if ( replace Tag Name & & tags . has Own Property ( replace Tag Name ) ) { delete tags [ replace Tag Name ] ; } tags [ tag Name ] = true ; } 
function handle On Filter ( file , filter Name ) { let used Filters = file . filters ; used Filters | | ( used Filters = file . filters = [ ] ) ; if ( ! used Filters . includes ( filter Name ) ) { used Filters . push ( filter Name ) ; } } 
function init View Transform Options ( file , process Opts , build Manager , is Native View ) { let plugins = process Opts . plugins ; let { app Type , component Conf , build Conf } = build Manager ; if ( is Native View ) { return Object . assign ( { } , process Opts , { plugins : normalize View Plugins ( plugins , app Type ) } ) ; } let template Conf = ( component Conf & & component Conf . template ) | | { } ; if ( ! plugins | | ! plugins . length ) { plugins = [ 'syntax ' ] ; if ( template Conf . transform Tags ) { plugins . push ( 'tag Transform ' ) ; } 
function navigate To ( options ) { let { url , params } = options ; let query Idx = url . index Of ( ' ? ' ) ; if ( query Idx ! = = - 1 ) { let query = url . substr ( query Idx + 1 ) ; url = url . substring ( 0 , query Idx ) ; if ( query ) { query = parse Query ( query ) ; params = Object . assign ( { } , query , params ) ; } } if ( url . char At ( 0 ) = = = ' / ' ) { let url Parts = url . split ( ' / ' ) ; url Parts . pop ( ) ; 
function compile ( file , options ) { let config = options . config | | { } ; let presets = config . presets | | [ ] ; let ts Preset = ' @babel /preset -typescript ' ; if ( ! presets . includes ( ts Preset ) ) { config . presets = [ ts Preset ] . concat ( presets ) ; options . config = config ; } return parser Helper . compile ( file , options , 7 ) ; } 
function get Code Traverse Visitors ( t , init Config , opts ) { let { is Page , is Component , is Behavior , enable Mixin Support , filter Options } = opts ; let has Components = is Page | | is Component ; return { Object Property ( path ) { let prop = path . node ; let key = prop . key ; let key Name = key & & key . name ; if ( ! is Behavior & & key Name = = = 'config ' ) { 
function create Init Call Args ( declaration Path , config , opts , t ) { let { is Page , is Component , is App , get Init Options } = opts ; let call Args = [ declaration Path . node ] ; let init Options ; if ( opts . tpl Refs ) { init Options = { refs : opts . tpl Refs } ; } let extra Init Opts = get Init Options & & get Init Options ( config , { is Page , is Component , is App } ) ; if ( extra Init Opts ) { init Options | | ( init Options = { } ) ; Object . assign ( init Options , extra Init Opts ) ; } if ( init Options ) { 
function transform Mini Program ( t , path , declaration Path , config , opts ) { if ( t . is Object Expression ( declaration Path ) ) { 
function get Transform Options ( options , state ) { let transform Opts = Object . assign ( { } , options , state . opts ) ; transform Opts . base Id = options . extension Name ? get Framework Extend Id ( transform Opts . app Type , options . extension Name , true ) : get Base Id ( transform Opts . app Type , transform Opts . base Name ) ; return transform Opts ; } 
function transform Event Attr ( attrs , name , tpl Opts , opts , element ) { let value = attrs [ name ] ; let event Attr Name = name . replace ( EVENT _REGEXP , ' ' ) ; let [ event Type , . . . event Modifiers ] = event Attr Name . split ( ' . ' ) ; let { logger , file } = tpl Opts ; if ( event Modifiers . length ) { logger . warn ( ` $ { file . path } \ ` $ { name } \ ` ` , ` $ { event Modifiers . join ( ' . ' ) } ` ) ; } delete attrs [ name ] ; 
function remove Array Index Access Path ( paths , required Min Len ) { let result = [ ] ; 
function get Page Info ( page Path , prefix ) { let parts = page Path . split ( ' / ' ) ; let component Name = parts . pop ( ) ; let page Name = parts . join ( ' / ' ) ; prefix & & ( page Name = ` $ { prefix } $ { page Name } ` ) ; return { page Name , component Name } ; } 
function normalize Pages ( result , pages , prefix ) { let entry Page Name ; pages . for Each ( ( item , idx ) = > { let filter ; if ( typeof item = = = 'object ' ) { let { path , filter : page Filter } = item ; item = path ; filter = page Filter ; } let { page Name , component Name } = get Page Info ( item , prefix ) ; let page Info = { component : component Name } ; filter & & ( page Info . filter = filter ) ; result [ page Name ] = page Info ; if ( idx = = = 0 ) { entry Page Name = page Name ; } } ) ; return entry Page Name ; } 
function normalize Route Info ( pages , sub Packages ) { let result = { } ; let entry Page Name = normalize Pages ( result , pages ) ; sub Packages & & sub Packages . for Each ( item = > { let { root , pages : sub Pages } = item ; normalize Pages ( result , sub Pages , root ) ; } ) ; return { entry : entry Page Name , pages : result } ; } 
function normalize Display Pages ( pages ) { if ( ! pages ) { return ; } let result = { } ; Object . keys ( pages ) . for Each ( k = > { let item = pages [ k ] ; let { page Name } = get Page Info ( k ) ; result [ page Name ] = item ; } ) ; return result ; } 
function add Display Page Config ( pages , source Dir , config File ) { let path = relative ( config File . full Path , source Dir ) ; let { page Name } = get Page Info ( path ) ; let curr Page Display Info = pages [ page Name ] ; let page Config = JSON . parse ( config File . content ) ; let result = { } ; 
function normalize Window Config ( window Config ) { if ( ! window Config ) { return ; } let result = { } ; 
function add Feature Item ( logger , existed , name , params ) { if ( ! existed [ name ] ) { existed [ name ] = true ; let feature = { name } ; params & & ( feature . params = params ) ; return feature ; } logger . debug ( 'duplicated feature declaration ' , name ) ; return false ; } 
function normalize Feature Item ( item , existed , result , logger ) { let add Item ; if ( typeof item = = = 'string ' ) { add Item = add Feature Item ( logger , existed , item ) ; } else if ( Array . is Array ( item ) ) { let [ name , params ] = item ; add Item = add Feature Item ( logger , existed , name , params ) ; } else if ( item & & typeof item = = = 'object ' ) { let { name , params } = item ; add Item = add Feature Item ( logger , existed , name , params ) ; } if ( add Item ) { result . push ( add Item ) ; } } 
function get Used APIFeatures ( features , options ) { let { logger , get All Used APIFeatures } = options ; let result = [ ] ; let existed = { } ; features & & features . for Each ( item = > normalize Feature Item ( item , existed , result , logger ) ) ; let used Features = get All Used APIFeatures ( ) ; used Features & & used Features . for Each ( item = > { 
function normalize Debug Config ( info ) { if ( info . has Own Property ( 'debug ' ) ) { let debug = info . debug ; delete info . debug ; let value = debug ? 'debug ' : 'off ' ; let config = info . config ; if ( ! config ) { info . config = { log Level : value } ; } else if ( ! config . log Level ) { config . log Level = value ; } } } 
function compile ( file , options ) { if ( ! file . compile Ready & & ! file . owner . processed ) { return { content : file . content } ; } let { get All Page Config Files , source Dir , design Width } = options ; let obj = JSON . parse ( file . content . to String ( ) ) ; 
function generate SFC ( file , options ) { let { sub Files } = file ; if ( ! sub Files | | ! sub Files . length ) { sub Files = [ file ] ; } let result = ' ' ; let component Config = file . is Native Component ? file . import Components : get Component Config ( sub Files ) ; sub Files . for Each ( ( item , idx ) = > { if ( item . is Script ) { result + = wrap Content ( 'script ' , item ) ; } else if ( item . is Style ) { result + = wrap Content ( 'style ' , item ) ; } else if ( item . is Tpl ) { result + = wrap Content ( 'template ' , item ) ; result = add Import Components ( result , component Config ) ; } } ) ; return { content : result } ; } 
function normalize Quick App Page ( page Info ) { page Info = normalize Page ( page Info ) ; let { data , data Access Type } = page Info ; if ( data & & ! page Info [ data Access Type ] ) { page Info [ data Access Type ] = data ; delete page Info . data ; } 
function get Import Template Element ( tpl File , name ) { if ( ! name ) { return ; } let ast = tpl File . ast ; if ( ! ast ) { ast = tpl File . ast = parse Dom ( tpl File . content . to String ( ) ) ; } let children = ast . children ; for ( let i = 0 , len = children . length ; i < len ; i + + ) { let node = children [ i ] ; if ( node . type = = = 'tag ' & & node . name = = = 'template ' ) { let { attribs : attrs } = node ; if ( attrs & & attrs . name = = = name ) { return node ; } } } } 
function find Import Element ( node ) { let parent = node . parent ; if ( ! parent ) { return ; } let children = parent . children ; let found ; children . some ( item = > { if ( item . type = = = 'tag ' & & item . name = = = 'import ' ) { found = item ; return true ; } return false ; } ) ; if ( found ) { return found ; } return find Import Element ( parent ) ; } 
function parse Tpl Data Info ( value ) { value = value . substring ( 1 , value . length - 1 ) ; let items = value . split ( ' , ' ) ; let data Obj Attrs = { } ; items . for Each ( item = > { let colon Idx = item . index Of ( ' : ' ) ; if ( colon Idx ! = = - 1 ) { let key = item . substring ( 0 , colon Idx ) . trim ( ) ; let value = item . substr ( colon Idx + 1 ) . trim ( ) ; key = = = value | | ( data Obj Attrs [ key ] = value ) ; } } ) ; return Object . keys ( data Obj Attrs ) . length ? data Obj Attrs : null ; } 
function replace Template Variable ( value , data ) { return value . replace ( / \ { \ { ( . + ) \ } \ } / g , ( match , var Name ) = > { var Name = var Name . trim ( ) ; let new Var Name = data [ var Name ] ; if ( new Var Name ) { return ` $ { new Var Name } ` ; } return match ; } ) ; } 
function replace Element Attribute Variable ( attrs , data ) { let new Attrs = Object . assign ( { } , attrs ) ; attrs & & Object . keys ( attrs ) . for Each ( k = > { let value = attrs [ k ] ; if ( k . starts With ( ' : ' ) ) { 
function update Template Data Variable Name ( element , data ) { let { children } = element ; let result = [ ] ; children & & children . for Each ( item = > { let { type } = item . type ; let new Item = Object . assign ( { } , item ) ; if ( type = = = 'tag ' ) { let { attribs : attrs , children } = item ; new Item . attribs = replace Element Attribute Variable ( attrs , data ) ; if ( children ) { let new Children = update Template Data Variable Name ( item , data ) ; new Children & & ( new Item . children = new Children ) ; } } else if ( type = = = 'text ' ) { let { data : text Value } = item ; text Value = replace Template Variable ( text Value , data ) ; new Item . data = text Value ; } result . push ( new Item ) ; } ) ; return result ; } 
function transform Ext Name Element ( element ) { let { attribs : attrs } = element ; let src = attrs & & attrs . src ; if ( src ) { attrs . src = src . replace ( / \ .wxml $ / i , ' .swan ' ) ; } } 
function transform Template Element ( element ) { let { attribs : attrs } = element ; let data = attrs & & attrs . data ; if ( data ) { attrs . data = ` $ { data } ` ; } } 
function both For And IFAttr ( attrs ) { if ( ! attrs ) { return false ; } let has For Attr = FOR _DIRECTIVES . some ( item = > attrs [ item ] ) ; let has If = CONDITION _DIRECTIVES . some ( item = > attrs [ item ] ) ; return has For Attr & & has If ; } 
function should Polyfill ( import Name , name , path ) { let result ; if ( Array . is Array ( import Name ) ) { result = import Name . some ( item = > ( item = = = name ) ) ; } else { result = import Name = = = name ; } 
function proxy Data Getter ( ctx , prop ) { let proxy Props = ctx . _ _proxy Props ; proxy Props | | ( proxy Props = ctx . _ _proxy Props = { } ) ; if ( proxy Props [ prop ] ) { return ; } proxy Props [ prop ] = true ; let descriptor = Object . get Own Property Descriptor ( ctx , prop ) ; if ( descriptor & & descriptor . configurable ) { let new Descriptor = Object . assign ( { } , descriptor , { get ( ) { ctx . _ _deps & & ctx . _ _deps . push ( prop ) ; return descriptor . get & & descriptor . get . call ( ctx ) ; } } ) ; Object . define Property ( ctx , prop , new Descriptor ) ; } else { console . warn ( 'cannot configure the data prop descriptor info : ' , prop ) ; } } 
function add Data Change Watcher ( ctx , prop , deep ) { 
function collect Computed Prop Deps ( ctx , prop , getter ) { ctx . _ _deps = [ ] ; let value = getter . call ( ctx ) ; ctx . _ _computed Deps [ prop ] = ctx . _ _deps ; ctx . _ _deps = null ; return value ; } 
function find Change Computed Props ( all Deps , change Prop ) { let result = [ ] ; Object . keys ( all Deps ) . for Each ( k = > { let dep List = all Deps [ k ] ; if ( k ! = = change Prop & & dep List . index Of ( change Prop ) ! = = - 1 ) { result . push ( k ) ; } } ) ; return result ; } 
function init Global Components ( app Type , component Conf , source Dir ) { let { global : global Components } = component Conf ; if ( ! global Components ) { return ; } let result = { } ; Object . keys ( global Components ) . for Each ( k = > { let value = global Components [ k ] ; value = value . replace ( / ^okam \ / / , BUILTIN _COMPONENTS _PACKAGE _ROOT + app Type + ' / ' ) ; let is Rel Mod = value . char At ( 0 ) = = = ' . ' ; if ( is Rel Mod ) { value = path Util . join ( source Dir , value ) ; } result [ to Hyphen ( k ) ] = { is Npm Mod : ! is Rel Mod , mod Path : value } ; } ) ; return result ; } 
function init Dir Files ( dir , cache ) { let cache Dir Files = { } ; cache . set Dir File List Info ( dir , cache Dir Files ) ; let files = fs . readdir Sync ( dir ) ; for ( let i = 0 , len = files . length ; i < len ; i + + ) { let file = files [ i ] ; let full Path = path . resolve ( dir , file ) ; let stat = get File State ( full Path ) ; if ( ! stat | | stat . is Directory ( ) ) { continue ; } let file Name = get File Name ( full Path ) ; let file List = cache Dir Files [ file Name ] ; if ( ! file List ) { file List = cache Dir Files [ file Name ] = [ ] ; } file List . push ( full Path ) ; } return cache Dir Files ; } 
function get Comp Origin File Info By Type ( type , file Path No Extname , options ) { const component Ext Map = COMPONENT _FILE _EXT _NAMES [ type ] | | { } ; 
function get Comp Files Info By App Type ( file Path No Extname , options ) { let { app Type , wx 2swan , component Extname } = options ; 
function get Page Origin File Extnames ( page File Not Ext , build Manager ) { let { files : all Files , app Type , build Conf , component Extname } = build Manager ; 
function add Process Entry Pages ( pages , page File Map , all Page Files , file Dirname , build Manager ) { let { files : all Files , component Extname , logger , app Type , root } = build Manager ; pages . for Each ( p = > { let page File Not Ext = path . resolve ( file Dirname , p ) ; let page File = all Files . get By Full Path ( ` $ { page File Not Ext } $ { component Extname } ` ) ; 
function build Project ( timer , build Conf , build Manager ) { let { logger , output : output Opts } = build Conf ; let { on Build Start , on Build Done } = build Conf . script | | { } ; let hook Result = run Build Start Hook ( build Manager , on Build Start ) ; let build Result ; if ( hook Result instanceof Promise ) { build Result = hook Result . then ( code = > { logger . debug ( 'init build start done . . . ' , code ) ; return build Manager . build ( timer ) ; } ) ; } else { build Result = build Manager . build ( timer ) ; } let done Handler = build Done . bind ( null , timer , logger , output Opts . dir ) ; return build Result . then ( ( ) = > build Manager . release ( ) ) . then ( done Handler ) . then ( ( ) = > { run Build Done Hook ( build Manager , on Build Done ) ; } ) . catch ( done Handler ) ; } 
function run Build ( build Conf , build Manager ) { let timer = new Timer ( ) ; timer . start ( ) ; let { app Type , logger , root : root Dir , config Path } = build Conf ; logger . info ( 'build start . . . ' ) ; logger . info ( 'build app type : ' , colors . cyan ( app Type ) ) ; logger . info ( 'load process files from ' , colors . cyan ( get Relative Path ( root Dir ) ) ) ; if ( config Path ) { logger . info ( 'build by config ' , colors . cyan ( get Relative Path ( config Path ) ) ) ; } else if ( build Conf . use Default Config ) { logger . info ( 'build using default inner config ' ) ; } 
function compile ( file , options ) { let obj = json 5 . parse ( file . content . to String ( ) ) ; let result = JSON . stringify ( obj , null , 4 ) ; return { content : result } ; } 
function init Platform Info ( callback ) { api . get System Info ( { success ( info ) { callback & & callback ( null , info ) ; } , fail ( err ) { callback & & callback ( err ) ; } } ) ; } 
function add Sub File ( file ) { if ( ! file ) { return ; } this . sub Files | | ( this . sub Files = [ ] ) ; if ( ! this . sub Files . includes ( file ) ) { file . is Sub File = true ; file . owner = this ; this . sub Files . push ( file ) ; } } 
function create File ( file Info , root Dir ) { let { path : rel Path , full Path , data , is Virtual , is Script , is Style , is Template } = file Info ; if ( rel Path & & ! full Path ) { full Path = path . resolve ( root Dir , rel Path ) ; } let extname = path . extname ( full Path ) . slice ( 1 ) . to Lower Case ( ) ; let vf = { processor : FILE _EXT _PROCESSOR [ extname ] , dirname : path . dirname ( full Path ) , extname , full Path , path : rel Path | | relative ( full Path , root Dir ) , raw Content : data , is Virtual , is Script : is Script = = null ? is Script Type ( extname ) : is Script , is Style : is Style = = null ? is Style Type ( extname ) : is Style , is Img : is Img Type ( extname ) , is Tpl : is Template = = null ? is Tpl Type ( extname ) : is Template , is Json : is Json Type ( extname ) , add Deps , add Sub File , reset : reset File , source Map : null } ; Object . define Properties ( vf , { stream : { get : get File Stream } , content : { get : load File Content , set : update File Content } } ) ; return vf ; } 
function try To Resolve Require Mod Id ( t , path , state ) { let opts = state . opts | | { } ; let resolve Require Id = opts . resolve Dep Require Id ; let export Node = path . node ; let source = export Node . source ; if ( ! t . is String Literal ( source ) ) { return ; } let mod Id = source . value ; let new Mod Id = resolve Require Id ( mod Id ) ; if ( new Mod Id & & new Mod Id ! = = mod Id ) { let require Id Node = path . get ( 'source ' ) ; require Id Node . replace With ( t . string Literal ( new Mod Id ) ) ; } } 
function show Event Name Log ( name , new Name , event Modifiers , attrs , tpl Opts ) { let { logger , file , app Type } = tpl Opts ; NOT _SUPPORT _MODIFIERS . for Each ( item = > { if ( event Modifiers . includes ( item ) ) { logger . warn ( ` $ { file . path } $ { name } ` , ` $ { item } $ { app Type } ` ) ; } } ) ; if ( attrs . has Own Property ( new Name ) ) { logger . warn ( ` $ { file . path } $ { name } $ { new Name } ` ) ; } } 
function parse Handler By REGEXP ( handler String ) { 
function get Random String Not In ( string ) { const random String = Math . random ( ) . to String ( 3 6 ) . substr ( 2 ) ; if ( string . index Of ( random String ) = = = - 1 ) { return random String ; } return get Random String Not In ( string ) ; } 
function sort Default Processors ( processor Names , processors ) { if ( Array . is Array ( processor Names ) ) { processor Names . sort ( ( a , b ) = > { a = processors [ a ] ; b = processors [ b ] ; return ( a . order | | 0 ) - ( b . order | | 0 ) ; } ) ; } } 
function add File Extname Associated Processor ( extnames , processor Name , existed Map ) { if ( ! extnames ) { return ; } if ( ! Array . is Array ( extnames ) ) { extnames = [ extnames ] ; } extnames . for Each ( k = > { k = k . to Lower Case ( ) ; let processors = existed Map [ k ] ; if ( Array . is Array ( processors ) ) { processors . push ( processor Name ) ; } else if ( processors ) { existed Map [ k ] = [ processors , processor Name ] ; } else { existed Map [ k ] = processor Name ; } } ) ; } 
function remove File Extname Associated Processor ( extnames , processor Name , existed Map ) { if ( ! extnames ) { return ; } if ( ! Array . is Array ( extnames ) ) { extnames = [ extnames ] ; } extnames . for Each ( k = > { let curr Items = existed Map [ k ] ; if ( Array . is Array ( curr Items ) ) { let idx = curr Items . index Of ( processor Name ) ; if ( idx ! = = - 1 ) { curr Items . splice ( idx , 1 ) ; curr Items . length = = = 0 & & ( existed Map [ k ] = undefined ) ; } } else if ( curr Items = = = processor Name ) { existed Map [ k ] = undefined ; } } ) ; } 
function get File Extname Associated Processor ( processors ) { let result = Object . keys ( processors ) . reduce ( ( last Value , processor Name ) = > { let processor = processors [ processor Name ] ; let extnames = processor . extnames | | [ ] ; if ( ! Array . is Array ( extnames ) ) { extnames = [ extnames ] ; } add File Extname Associated Processor ( extnames , processor Name , last Value ) ; return last Value ; } , { } ) ; Object . keys ( result ) . for Each ( k = > sort Default Processors ( result [ k ] , processors ) ) ; return result ; } 
function init Processor Info ( name , info , existed Processors ) { let processor = info . processor ; if ( ! processor ) { return info ; } if ( typeof processor = = = 'string ' ) { 
function override Object Functions ( curr , old ) { if ( ! old ) { return curr ; } if ( ! curr & & curr ! = = undefined ) { return old ; } let result = { } ; Object . keys ( curr ) . for Each ( k = > { let v = curr [ k ] ; let old V = old [ k ] ; if ( typeof v = = = 'function ' & & typeof old V = = = 'function ' ) { let curr V = v ; v = function ( . . . args ) { old V . apply ( this , args ) ; curr V . apply ( this , args ) ; } ; } result [ k ] = v ; } ) ; return result ; } 
function override Processor ( existed Processor , extname Processor Map , opts ) { let old Extnames ; let new Extnames ; Object . keys ( opts ) . for Each ( k = > { let v = opts [ k ] ; if ( ! v ) { return ; } if ( k = = = 'extnames ' ) { old Extnames = existed Processor [ k ] ; new Extnames = v ; } if ( k = = = 'hook ' ) { v = override Object Functions ( v , existed Processor [ k ] ) ; } existed Processor [ k ] = v ; } ) ; let processor = opts . processor ; if ( processor ) { existed Processor . processor = resolve Processor ( processor ) ; } let processor Name = opts . name ; remove File Extname Associated Processor ( old Extnames , processor Name , extname Processor Map ) ; add File Extname Associated Processor ( new Extnames , processor Name , extname Processor Map ) ; } 
function update Refer Processor Info ( existed Processors , processor Name , refer Processor Name ) { let curr Processor = existed Processors [ processor Name ] ; if ( ! curr Processor | | curr Processor . processor ) { return ; } let refer Processor Info = existed Processors [ refer Processor Name ] ; if ( ! refer Processor Info ) { return ; } let deps = refer Processor Info . deps ; deps & & ! Array . is Array ( deps ) & & ( deps = [ deps ] ) ; let old Deps = curr Processor . deps ; old Deps & & ! Array . is Array ( old Deps ) & & ( old Deps = [ old Deps ] ) ; let old = Object . assign ( { } , curr Processor ) ; Object . assign ( curr Processor , refer Processor Info , old , { refer : refer Processor Name , deps : merge ( deps | | [ ] , old Deps | | [ ] ) , processor : refer Processor Info . processor } ) ; } 
function register Processor ( existed Processors , extname Processor Map , opts ) { let { name , processor , deps , rext , extnames , options , order , hook } = opts ; if ( ! name ) { throw new Error ( 'missing processor name to register ' ) ; } if ( existed Processors . has Own Property ( name ) ) { 
function generate Filter Code ( filter Obj Ast , t , options ) { if ( ! filter Obj Ast . properties . length ) { return ' ' ; } let { format = 'es 6 ' , using Babel 6 } = options | | { } ; let ast ; if ( format = = = 'es 6 ' ) { ast = generate ES 6Module Filter Code ( filter Obj Ast , t ) ; } else { ast = generate Common JSModule Filter Code ( filter Obj Ast , t ) ; } return generate Code ( ast , { auxiliary Comment Before : 'Auto generated filter code by okam ' } , using Babel 6 ) . code ; } 
function create APIDone Hook ( done , ctx ) { let hook Info = { res Data : null , res Exception : false , hook : null } ; hook Info . hook = ( err , res , complete , should Catch Exception ) = > { let result ; if ( err ! = null ) { result = err ; if ( should Catch Exception ) { try { let data = done ( result , null , ctx ) ; data = = null | | ( result = data ) ; } catch ( ex ) { 
function intercept Async APIDone ( sync , args , done Hook ) { let call Opts = args [ 0 ] ; let { success , fail , complete } = call Opts | | { } ; let has Intercepted = false ; if ( ! sync & & ( is Function ( success ) | | is Function ( fail ) | | is Function ( complete ) ) ) { has Intercepted = true ; let new Call Opts = Object . assign ( { } , call Opts ) ; new Call Opts . success = res = > { let data = done Hook ( null , res , complete , true ) ; success & & success ( data ) ; } ; new Call Opts . fail = err = > { err = done Hook ( err | | 'err ' , null , complete , true ) ; fail & & fail ( err ) ; } ; 
function intercept Promise Response ( has Intercepted , promise , done Hook Info ) { let { hook } = done Hook Info ; return promise . then ( res = > ( has Intercepted ? done Hook Info . res Data : hook ( null , res ) ) , err = > { 
function hook APIInit ( init , args , ctx ) { 
function hook APIDone ( done , sync , args , ctx ) { 
function execute API ( hook Info , raw Api , args ) { 
function proxy API ( ctx , raw Api , api Opts , . . . args ) { let { init , done , sync } = api Opts ; 
function get Default Build Config ( app Type ) { if ( app Type = = = 'base ' ) { throw new Error ( 'illegal app type ' , app Type ) ; } let default Conf Path = path . join ( _ _dirname , ' . . ' , 'config ' , ` $ { app Type } ` ) ; if ( file Util . is File Exists ( default Conf Path ) ) { return require ( default Conf Path ) ; } else { return require ( ' . . /config /base ' ) ; } } 
function init Build Options ( app Type , options , cli Opts = { } ) { app Type = cli Opts . type | | app Type | | 'swan ' ; let user Config = get User Build Config ( options , app Type , cli Opts . config ) ; let user Output File = user Config . output & & user Config . output . file ; 
function query Component Instance ( ctx , id ) { let is Select All = Array . is Array ( id ) ; is Select All & & ( id = id [ 0 ] ) ; 
function init Refs ( ) { this . $refs = { } ; let refs = this . $raw Ref Data ; if ( typeof refs = = = 'function ' ) { refs = refs ( ) ; } if ( ! refs ) { return ; } let result = { } ; Object . keys ( refs ) . for Each ( id = > { result [ id ] = { get : query Component Instance . bind ( null , this , refs [ id ] ) , enumerable : true } ; } ) ; Object . define Properties ( this . $refs , result ) ; } 
function normalize Tag Transform Info ( native Tag , transform Item ) { if ( typeof transform Item = = = 'string ' ) { return { transform Tag : transform Item , transform Opts : native Tag } ; } let transform Opts = Object . assign ( { } , transform Item ) ; transform Opts . tag = native Tag ; return { transform Tag : transform Item . tag , transform Opts } ; } 
function init Relations ( component , is Page ) { let relations = component . relations ; if ( ! relations | | is Page ) { 
function create Framework Extend Call Expression ( t , callee Name , extend Name , has Plugin Opt ) { let args = [ t . identifier ( extend Name ) ] ; if ( has Plugin Opt ) { args . push ( t . object Expression ( [ ] ) ) ; } return t . expression Statement ( t . call Expression ( t . member Expression ( t . identifier ( callee Name ) , t . identifier ( 'use ' ) ) , args ) ) ; } 
function prepare Polyfill Support ( polyfill , root Dir , logger ) { if ( ! polyfill ) { return ; } if ( ! Array . is Array ( polyfill ) ) { polyfill = [ polyfill ] ; } polyfill . for Each ( info = > { try { ensure ( info . desc , info . deps , root Dir ) ; } catch ( ex ) { logger . warn ( ex . to String ( ) ) ; } } ) ; } 
function get Plain Object Node Value ( node , path , t ) { let result ; if ( t . is Object Expression ( node ) ) { result = { } ; let props = node . properties | | [ ] ; for ( let i = 0 , len = props . length ; i < len ; i + + ) { let sub Node = props [ i ] ; let key Node = sub Node . key ; let key ; if ( t . is Literal ( key Node ) ) { key = key Node . value ; } else if ( t . is Identifier ( key Node ) ) { key = key Node . name ; } if ( ! key ) { continue ; } result [ key ] = get Plain Object Node Value ( sub Node . value , path , t ) ; } } else if ( t . is Array Expression ( node ) ) { result = [ ] ; node . elements . for Each ( item = > { result . push ( get Plain Object Node Value ( item , path , t ) ) ; } ) ; } else if ( t . is Null Literal ( node ) ) { result = null ; } else if ( t . is Literal ( node ) ) { result = node . value ; } else { throw path . build Code Frame Error ( 'only constant is supported ' ) ; } return result ; } 
function create Node ( value , t ) { if ( t . is Identifier ( value ) ) { return value ; } if ( Array . is Array ( value ) ) { let elements = [ ] ; value . for Each ( item = > { let node = create Node ( item , t ) ; node & & elements . push ( node ) ; } ) ; return t . array Expression ( elements ) ; } if ( Object . prototype . to String . call ( value ) = = = ' [object Object ] ' ) { let props = [ ] ; Object . keys ( value ) . for Each ( k = > { let node = create Node ( value [ k ] , t ) ; if ( node ) { props . push ( t . object Property ( t . identifier ( ` $ { k } ` ) , node ) ) ; } } ) ; return t . object Expression ( props ) ; } if ( value = = null ) { return t . null Literal ( ) ; } let value Type = typeof value ; switch ( value Type ) { case 'boolean ' : return t . boolean Literal ( value ) ; case 'string ' : return t . string Literal ( value ) ; case 'number ' : return t . numeric Literal ( value ) ; } } 
function remove Comments ( t , path , type ) { let comment Paths = path . get ( type ) ; if ( ! comment Paths | | ! comment Paths . length ) { return ; } let is Leading Type = type = = = LEADING _COMMENT _TYPE ; if ( is Leading Type ) { let parent Path = path . parent Path ; let is Parent Program = parent Path & & t . is Program ( parent Path . node ) ; 
function parse ( file , options ) { let result = sfc Parser ( file , options ) ; let file Dir = path . dirname ( file . full Path ) ; let { add File } = options ; let import Components = { } ; let { custom Blocks } = result ; custom Blocks & & custom Blocks . for Each ( item = > { let { type , attrs } = item ; if ( attrs & & type = = = 'import ' ) { let { name , src } = attrs ; import Components [ name ] = src ; src & & add File ( path . join ( file Dir , src + ' .ux ' ) ) ; } } ) ; file . import Components = import Components ; return result ; } 
function handle Proxy Event ( source , target , event Name , options ) { let { new Event Name , prepend Source Arg } = options | | { } ; source . on ( event Name , function ( . . . args ) { prepend Source Arg & & args . unshift ( source ) ; if ( typeof new Event Name = = = 'function ' ) { new Event Name . apply ( target , args ) ; } else { new Event Name | | ( new Event Name = event Name ) ; args . unshift ( new Event Name ) ; target . emit . apply ( target , args ) ; } } ) ; } 
function make Computed Observable ( ctx ) { let computed Info = ctx . $raw Computed | | { } ; if ( typeof computed Info = = = 'function ' ) { ctx . $raw Computed = computed Info = computed Info ( ) ; } let observer = new Computed Observer ( ctx , computed Info ) ; let ctx Props = { } ; Object . keys ( computed Info ) . for Each ( k = > { ctx Props [ k ] = { get : observer . get Getter ( k ) , set : observer . get Setter ( k ) , enumerable : true } ; } ) ; Object . define Properties ( ctx , ctx Props ) ; return observer ; } 
function make Props Observable ( ctx ) { let props = ctx . $raw Props ; if ( typeof props = = = 'function ' ) { props = ctx . $raw Props = props ( ) ; } if ( ! props ) { return ; } let observer = new Observer ( ctx , ctx [ prop Data Key ] | | { } , null , true ) ; let props Obj = { } ; Object . keys ( props ) . reduce ( ( last , item ) = > { last [ item ] = true ; return last ; } , props Obj ) ; Object . define Properties ( ctx , proxy Object ( observer , props Obj ) ) ; return observer ; } 
function make Data Observable ( ctx ) { const data = ctx . data ; if ( ! data ) { return ; } if ( is Plain Object ( data ) ) { let observer = new Observer ( ctx , data ) ; Object . define Properties ( ctx , proxy Object ( observer , data , ctx ) ) ; return observer ; } let err = new Error ( 'data require plain object ' ) ; err . is Type Error = true ; throw err ; } 
function init Mixin File ( mixins , build Manager , file ) { mixins & & mixins . for Each ( module Path = > { let { resolved Mod Ids : cache Resolve Mod Ids } = file ; let cache Info = cache Resolve Mod Ids [ module Path ] ; let mixin File = cache Info & & cache Info . file ; if ( mixin File & & ! mixin File . is Behavior ) { mixin File . is Behavior = true ; } } ) ; } 
function init Config Info ( build Manager , key , file , info ) { build Manager . logger . trace ( 'extract file config ' , file . path , info ) ; let { components , config = { } } = info ; if ( file . is Page Script ) { init Mixin File ( info . mixins , build Manager , file ) ; init Filter Config ( info . filters , build Manager , file ) ; config = normal Page Config ( config , components , file , build Manager ) ; } else if ( file . is Component Script ) { init Mixin File ( info . mixins , build Manager , file ) ; init Filter Config ( info . filters , build Manager , file ) ; config = normalize Component Config ( config , components , file , build Manager ) ; config . component = true ; } else { init Mixin File ( info . mixins , build Manager , file ) ; } file [ key ] = config ; } 
function init Local Polyfill Plugins ( polyfills , plugins ) { polyfills . for Each ( item = > { let plugin Item = polyfill Plugin [ item . type ] ; plugins . push ( [ plugin Item , { polyfill : item } ] ) ; } ) ; } 
function has Babel Dep Plugin ( plugins ) { return plugins . some ( item = > { let plugin Item = item ; if ( Array . is Array ( item ) ) { plugin Item = item [ 0 ] ; } if ( typeof plugin Item = = = 'string ' ) { return plugin Item = = = DEP _PLUGIN _NAME ; } return plugin Item = = = program Plugins . resolve Dep ; } ) ; } 
function normalize Babel Plugins ( plugins , file , build Manager ) { if ( typeof plugins = = = 'function ' ) { plugins = plugins ( file ) ; } plugins = plugins ? [ ] . concat ( plugins ) : [ ] ; if ( ! has Babel Dep Plugin ( plugins ) ) { 
function init Babel Processor Options ( file , processor Opts , build Manager ) { processor Opts = Object . assign ( { } , build Manager . babel Config , processor Opts ) ; 
function start Build ( build Conf , clear ) { 
function transform Mini Program Event Type ( element , event Type , opts ) { let { custom Component Tags } = opts | | { } ; let tag Name = element . name . to Lower Case ( ) ; let is Click Event = event Type = = = 'click ' ; if ( custom Component Tags ) { let is Custom Tag = custom Component Tags . some ( item = > item = = = tag Name ) ; if ( is Custom Tag ) { return event Type ; } } return is Click Event ? 'tap ' : event Type ; } 
function parse Wx Swan Event Name ( name , element , tpl Opts , opts ) { let event Attr Name = name . replace ( EVENT _REGEXP , ' ' ) ; let [ event Type , . . . event Modifiers ] = event Attr Name . split ( ' . ' ) ; let event Mode = 'bind ' ; event Type = transform Mini Program Event Type ( element , event Type , opts ) ; const includes Stop = event Modifiers . includes ( 'stop ' ) ; const includes Capture = event Modifiers . includes ( 'capture ' ) ; if ( includes Capture ) { event Mode = includes Stop ? 'capture -catch : ' : 'capture -bind : ' ; } else if ( includes Stop ) { event Mode = 'catch ' ; } event Attr Name = event Mode + event Type ; return { event Type , event Attr Name , event Modifiers } ; } 
function parse Event Name ( name , element , tpl Opts , opts ) { let event Attr Name = name . replace ( EVENT _REGEXP , ' ' ) ; let [ event Type , . . . event Modifiers ] = event Attr Name . split ( ' . ' ) ; let event Mode = 'on ' ; event Type = transform Mini Program Event Type ( element , event Type , opts ) ; let { logger , file } = tpl Opts ; ant Not Support Modifier . for Each ( item = > { if ( event Modifiers . includes ( item ) ) { logger . warn ( ` $ { file . path } $ { name } ` , ` $ { item } ` ) ; } } ) ; if ( event Modifiers . includes ( 'capture ' ) ) { event Mode = 'catch ' ; } let native Event = NATIVE _EVENT _MAP [ event Type . to Lower Case ( ) ] ; if ( native Event ) { event Type = native Event ; } let format Event Type = event Type . char At ( 0 ) . to Upper Case ( ) + event Type . substr ( 1 ) ; event Attr Name = event Mode + format Event Type ; return { event Type , event Attr Name , event Modifiers } ; } 
function register Api ( api Config ) { let base Api = base . $api ; api Config & & Object . keys ( api Config ) . for Each ( k = > { 
function get Event Name ( app Type , event Type ) { let event Name = event Type ; if ( app Type = = = 'ant ' ) { let format Event Type = event Type . char At ( 0 ) . to Upper Case ( ) + event Type . substr ( 1 ) ; event Name = format Event Type ; } if ( app Type = = = 'quick ' ) { event Name = to Hyphen ( event Type ) ; } return ` $ { EVENT _PREFIX [ app Type ] } $ { event Name } ` ; } 
function Vue ( options ) { let instance = Object . assign ( { } , options , observable Comp . methods , watch Comp . methods ) ; instance . created = observable Comp . created ; instance . $destroy = observable Comp . detached ; 
function transform Obj Class ( value , obj To Str ) { value = value . replace ( / [ \s * { } ] / g , ' ' ) . split ( ' , ' ) . map ( item = > { const arr = item . split ( ' : ' ) ; let key = arr [ 0 ] ; let first Char = key . char At ( 0 ) ; if ( first Char ! = = ' \ ' ' & & first Char ! = = ' \ " ' ) { key = ` $ { key } ` ; } / / support object abbrev case : {a , b } let expression = arr . length = = = 1 ? arr [ 0 ] : arr [ 1 ] ; let result = ` $ { expression } $ { key } ` ; return obj To Str ? ` $ { result } ` : result ; } ) ; return value . join ( obj To Str ? ' + \ ' \ ' + ' : ' , ' ) ; } 
function transform Array Class ( value , arr To Str ) { return value . replace ( / [ \s * [ \ ] ] / g , ' ' ) . split ( ' , ' ) . map ( item = > { if ( / ^ { . * } $ / . test ( item ) ) { return transform Obj Class ( item , arr To Str ) ; } else if ( arr To Str & & / ^ . + \ ? . + : . + $ / . test ( item ) ) { return ` $ { item } ` ; } return item ; } ) . join ( arr To Str ? ' + \ ' \ ' + ' : ' , ' ) ; } 
function compile ( file , options ) { let { env Config Key } = options ; let obj = JSON . parse ( file . content . to String ( ) ) ; let result = { } ; Object . keys ( obj ) . for Each ( k = > { if ( ! OKAM _ENV _KEY _REGEXP . test ( k ) ) { result [ k ] = obj [ k ] ; } } ) ; let app Spec Conf = obj [ env Config Key ] ; let is App Config = file . is App Config ; app Spec Conf & & Object . keys ( app Spec Conf ) . for Each ( k = > { let value = app Spec Conf [ k ] ; if ( value = = null ) { 
function init Extensions ( type , instance , base ) { let cache = plugin Cache ; if ( process . env . APP _TYPE = = = 'quick ' ) { if ( ! app Global . okam Plugin Cache ) { app Global . okam Plugin Cache = plugin Cache ; } cache = app Global . okam Plugin Cache ; } let existed Base = cache . base Classes [ type ] ; if ( ! existed Base ) { let plugins = cache . used Extensions [ type ] ; let args = [ { } ] ; plugins & & Array . prototype . push . apply ( args , plugins ) ; args . push ( base ) ; existed Base = mixin . apply ( this , args ) ; cache . base Classes [ type ] = existed Base ; } return mixin . apply ( this , [ instance , existed Base ] ) ; } 
function add Extension ( type , extension ) { if ( ! extension ) { return ; } let cache = plugin Cache ; if ( process . env . APP _TYPE = = = 'quick ' ) { cache = app Global . okam Plugin Cache ; } let existed Extensions = cache . used Extensions [ type ] ; if ( ! existed Extensions ) { existed Extensions = cache . used Extensions [ type ] = [ ] ; } existed Extensions . push ( extension ) ; } 
function init Component Data ( instance , options , is Page ) { let data = instance . data ; if ( is Function ( data ) ) { instance . data = instance . data ( ) ; } instance . $init & & instance . $init ( is Page , options ) ; } 
function merge Visitors ( plugins ) { let result = { } ; plugins . for Each ( item = > { let transform = item ; let options ; if ( Array . is Array ( item ) ) { [ transform , options ] = item ; } typeof transform = = = 'string ' & & ( transform = require ( transform ) ) ; Object . keys ( transform ) . for Each ( type = > { let visitor = transform [ type ] ; let list = result [ type ] ; list | | ( list = result [ type ] = [ ] ) ; list . push ( [ visitor , options ] ) ; } ) ; } ) ; return result ; } 
function compile Tpl ( file , options ) { let { config } = options ; let allow Cache = ! config | | config . cache = = null | | config . cache ; let content = file . content . to String ( ) ; const ast = file . ast | | parse Dom ( content ) ; allow Cache & & ( file . ast = ast ) ; let plugins = merge Visitors ( ( config & & config . plugins ) | | [ ] ) ; transform Ast ( ast , plugins , Object . assign ( { } , options , { file } ) ) ; let { keep Original Content } = config | | { } ; if ( ! keep Original Content ) { 
function parse ( file , options ) { let { root , config } = options ; let parse Opts = Object . assign ( { } , { pad : 'line ' } , config & & config . parse ) ; let result = compiler . parse Component ( file . content . to String ( ) , parse Opts ) ; let { custom Blocks } = result ; let { full Path : file Path } = file ; let tpl File = create Part File ( file , result . template , { is Template : true , root , file Path } ) ; let script File = create Part File ( file , result . script , { is Script : true , root , file Path } ) ; let style Files = result . styles . map ( ( item , index ) = > create Part File ( file , item , { is Style : true , index , root , file Path } ) ) ; 
function show Menu ( ) { const prompt = require ( ' @system .prompt ' ) const router = require ( ' @system .router ' ) const app Info = require ( ' @system .app ' ) . get Info ( ) prompt . show Context Menu ( { item List : [ ' 保 存 桌 面 ' , ' 关 于 ' , ' 消 ' ] , success : function ( ret ) { switch ( ret . index ) { case 0 : 
function create Shortcut ( ) { const prompt = require ( ' @system .prompt ' ) const shortcut = require ( ' @system .shortcut ' ) shortcut . has Installed ( { success : function ( ret ) { if ( ret ) { prompt . show Toast ( { message : ' 已 创 建 桌 面 图 标 ' } ) } else { shortcut . install ( { success : function ( ) { prompt . show Toast ( { message : ' 成 功 创 建 桌 面 图 标 ' } ) } , fail : function ( errmsg , errcode ) { prompt . show Toast ( { message : ` $ { errcode } $ { errmsg } ` } ) } } ) } } } ) } 
function normalize Props ( props ) { Object . keys ( props ) . for Each ( k = > { let prop Value = props [ k ] ; let default Value = null ; if ( prop Value & & prop Value . default ! = = undefined ) { default Value = prop Value . default ; } props [ k ] = default Value ; } ) ; return props ; } 
function query Ref Instance ( selector ) { let is Select All = Array . is Array ( selector ) ; is Select All & & ( selector = selector [ 0 ] ) ; let result ; if ( is Select All ) { if ( typeof this . select All Components = = = 'function ' ) { result = this . select All Components ( selector ) ; } result | | ( result = [ ] ) ; } else if ( typeof this . select Component = = = 'function ' ) { result = this . select Component ( selector ) ; } return result ; } 
function init Refs ( ) { this . $refs = { } ; let refs = this . $raw Ref Data ; if ( typeof refs = = = 'function ' ) { refs = refs ( ) ; } if ( ! refs ) { return ; } let result = { } ; const self = this ; Object . keys ( refs ) . for Each ( id = > { result [ id ] = { get ( ) { let value = refs [ id ] ; return query Ref Instance . call ( self , value ) ; } , enumerable : true } ; } ) ; Object . define Properties ( this . $refs , result ) ; } 
function fetch Data ( url , options ) { let { method = 'GET ' } = options | | { } ; method = method . to Upper Case ( ) ; return http Api . request ( Object . assign ( { url } , options , { method } ) ) ; } 
function find Match Transformer ( transformers , value , match Item ) { if ( ! value ) { return ; } let found ; transformers . some ( item = > { let match = item . match ; let is Match = false ; let type = typeof match ; if ( type = = = 'string ' ) { is Match = match = = = value ; } else if ( type = = = 'function ' ) { is Match = match ( match Item ) ; } else { 
function normalize Transformers ( transformer Map ) { let result = [ ] ; transformer Map & & Object . keys ( transformer Map ) . for Each ( k = > { let item = transformer Map [ k ] ; if ( item ) { item . transform . type = k ; result . push ( Object . assign ( { } , item , { name : k } ) ) ; } } ) ; return result ; } 
function transform ( transformers , element , tpl Opts , options ) { let { config } = tpl Opts ; let on Tag = config . on Tag ; if ( on Tag ) { on Tag ( element . name ) ; } 
function transform Text Node ( transformer , text Node , tpl Opts , options ) { let handler = find Match Transformer ( transformer , text Node . data , text Node ) ; handler & & handler . call ( this , text Node , tpl Opts , options ) ; } 
function get Git User ( ) { try { let name = exec Sync ( 'git config - -get user .name ' ) ; let email = exec Sync ( 'git config - -get user .email ' ) ; name = name & & name . to String ( ) . trim ( ) ; email = email & & ( ' < ' + email . to String ( ) . trim ( ) + ' > ' ) ; return ( name | | ' ' ) + ( email | | ' ' ) ; } catch ( e ) { return ' ' ; } } 
function traverse Files And Cb ( cur Dir , cb ) { let file Dirs = [ cur Dir ] ; while ( file Dirs . length ) { let curr Dir = file Dirs . pop ( ) ; let files = fs . readdir Sync ( curr Dir ) ; for ( let i = 0 , len = files . length ; i < len ; i + + ) { let file Name = files [ i ] ; if ( / ^ \ . / . test ( file Name ) ) { continue ; } let full Path = path . resolve ( curr Dir , file Name ) ; let stat = get File State ( full Path ) ; if ( ! stat ) { continue ; } let is Dir = stat . is Directory ( ) ; if ( is Dir ) { file Dirs . push ( full Path ) ; continue ; } if ( typeof cb = = = 'function ' ) { cb ( full Path ) ; } } } } 
function add Component Same Name Files ( script File , options ) { const { dirname : curr Dir , path : rel Path } = script File ; const script File Name = get File Name ( rel Path ) ; 
function analyse Native Component ( script File , options ) { 
function compile ( file , options ) { const { resolve : resolve Dep , logger } = options ; try { let component Conf = JSON . parse ( file . content . to String ( ) ) ; let using Components = component Conf [ USING _COMPONENT _KEY ] ; if ( ! using Components | | ! file . component ) { return { content : file . content } ; } let result = { } ; let script File = file . component ; Object . keys ( using Components ) . for Each ( k = > { let value = using Components [ k ] ; if ( ! value ) { return ; } let resolve Path = resolve Dep ( script File , value ) ; result [ to Hyphen ( k ) ] = resolve Path | | value ; let resolve Mod Info = script File . resolved Mod Ids [ value ] ; let component File = resolve Mod Info & & resolve Mod Info . file ; component File & & analyse Native Component ( component File , options ) ; } ) ; 
function update Array Item ( observer , idx , value ) { observer . set ( idx , value ) ; this [ idx ] = value ; } 
function make Array Observable ( arr , observer , proxy Arr Apis ) { 
function normalize Watch Item ( value ) { let handlers ; let options = { } ; let value Type = typeof value ; if ( value Type = = = 'function ' | | value Type = = = 'string ' ) { handlers = [ value ] ; } else if ( Array . is Array ( value ) ) { handlers = value ; } else { handlers = [ value . handler ] ; options . immediate = value . immediate ; } let watch Handler = function ( . . . args ) { for ( let i = 0 , len = handlers . length ; i < len ; i + + ) { let item = handlers [ i ] ; if ( typeof item = = = 'string ' ) { item = this [ item ] ; } item . apply ( this , args ) ; } } ; return { handler : watch Handler , options } ; } 
function get Anonymous Watcher Name ( ctx ) { let counter = ctx . _ _ $watch _counter ; if ( ! counter ) { counter = ctx . _ _ $watch _counter = 0 ; } let handler = create Anonymous Watcher Name ( counter ) ; ctx . _ _ $watch _counter = counter + 1 ; return handler ; } 
function watch Data Change ( express Or Func , callback , options ) { if ( typeof express Or Func = = = 'function ' ) { express Or Func = this . _ _add Computed Prop ( express Or Func ) ; } if ( typeof callback = = = 'function ' ) { let handler Name = get Anonymous Watcher Name ( this ) ; this [ handler Name ] = callback ; callback = handler Name ; } return this . _ _watch Data Change ( express Or Func , callback , options ) ; } 
function init Js Processor ( opts , default Babel Processor Name ) { let plugins = ( opts & & opts . plugins ) | | [ js Plugin ] ; register Processor ( { name : ( opts & & opts . processor ) | | default Babel Processor Name , 
function init Tpl Processor ( opts ) { register Processor ( { name : 'wxml 2swan ' , 
function init Style Processor ( opts ) { register Processor ( { name : 'wxss 2css ' , 
function init Wxs Processor ( opts , default Babel Processor Name ) { register Processor ( { name : 'wxs 2filter ' , processor ( file , options ) { let content = file . content . to String ( ) ; return { content : wxs 2filter ( content ) } ; } , extnames : [ 'wxs ' ] , rext : 'filter .js ' } ) ; } 
function init Processor ( options = { } , default Babel Processor Name ) { let { js , css , tpl , wxs } = options ; if ( tpl ! = = false ) { init Tpl Processor ( tpl ) ; } if ( css ! = = false ) { init Style Processor ( css ) ; } if ( js ! = = false ) { init Js Processor ( js , default Babel Processor Name ) ; } if ( wxs ! = = false ) { init Wxs Processor ( js , default Babel Processor Name ) ; } } 
function process ( file , options ) { let content = file . content . to String ( ) ; let { config : rules , logger } = options ; let result = content ; try { result = do Replacement ( content , rules | | [ ] , file ) ; } catch ( ex ) { let tip ; if ( ex = = = 'dev Server ' ) { tip = ' , please execute `npm run dev :server ` script or start with ` - -server ` option ' ; } logger . error ( 'unknown replacement variable : ' , ex + ( tip | | ' ' ) ) ; } return { content : result } ; } 
function transform Number To Array ( new Value ) { new Value = new Value . trim ( ) ; const word Array = new Value . split ( ' ' ) ; const number = word Array [ word Array . length - 1 ] ; const arr = [ ] ; if ( / ^ \d + $ / . test ( number ) ) { for ( let i = 1 ; i < + number + 1 ; i + + ) { arr . push ( i ) ; } new Value = new Value . replace ( number , ` $ { arr } ` ) ; } return new Value ; } 
function transform Of To In ( new Value ) { const word Array = new Value . trim ( ) . split ( ' ' ) ; const index = word Array . index Of ( 'of ' ) ; if ( index ! = = - 1 & & ! word Array . includes ( 'in ' ) ) { word Array [ index ] = 'in ' ; new Value = word Array . join ( ' ' ) ; } return new Value ; } 
function remove Braces ( value ) { 
function convert Media Query To JSExpression ( tokens , all App Types , app Type ) { let result = [ ] ; tokens . for Each ( item = > { item = item . trim ( ) ; if ( all App Types . includes ( item ) ) { result . push ( ` $ { item } $ { app Type } ` ) ; } else if ( item = = = 'and ' ) { result . push ( ' & & ' ) ; } else if ( item = = = ' , ' | | item = = = 'or ' ) { result . push ( ' | | ' ) ; } else if ( item = = = 'not ' ) { result . push ( ' ! ' ) ; } else if ( item = = = ' ( ' | | item = = = ' ) ' ) { result . push ( item ) ; } } ) ; let last Item = result [ result . length - 1 ] ; if ( last Item = = = ' & & ' | | last Item = = = ' | | ' ) { result . pop ( ) ; } 
function is App Media Match ( params , tokens , all App Types , app Type ) { let expression = convert Media Query To JSExpression ( tokens , all App Types , app Type ) ; try { return { value : eval ( expression ) , expression } ; } catch ( ex ) { throw new Error ( 'illegal style env media rule : ' + params ) ; } } 
function normalize App Media Query Tokens ( tokens ) { for ( let i = tokens . length - 1 ; i > = 0 ; i - - ) { let item = tokens [ i ] . trim ( ) ; if ( item & & item ! = = ' ( ' ) { break ; } tokens . pop ( ) ; } } 
function init App Media Target Info ( ctx , curr Token ) { let { all App Types , has App Media Type } = ctx ; let is App Media Target = all App Types . includes ( curr Token ) ; has App Media Type | | ( ctx . has App Media Type = is App Media Target ) ; if ( ! is App Media Target & & ! MEDIA _QUERY _OPERATORS . includes ( curr Token ) ) { return true ; } return false ; } 
function init App Media Query Token ( ctx , buffer , separator ) { let curr Token = buffer . trim ( ) ; let { tokens } = ctx ; if ( curr Token ) { if ( init App Media Target Info ( ctx , curr Token ) ) { return true ; } tokens . push ( buffer ) ; tokens . push ( separator ) ; return ' ' ; } buffer + = separator ; if ( buffer . trim ( ) ) { tokens . push ( buffer ) ; return ' ' ; } return buffer ; } 
function parse App Media Query Param ( all App Types , params ) { let ctx = { all App Types , has App Media Type : false , tokens : [ ] } ; let buffer = ' ' ; for ( let i = 0 , len = params . length ; i < len ; i + + ) { let c = params [ i ] ; if ( QUERY _PARAMS _SEPARATORS . includes ( c ) ) { buffer = init App Media Query Token ( ctx , buffer , c ) ; if ( buffer = = = true ) { buffer = ' ' ; break ; } } else { buffer + = c ; } } if ( buffer ) { let result = init App Media Target Info ( ctx , buffer . trim ( ) ) ; result | | ( ctx . tokens . push ( buffer ) ) ; } return ctx ; } 
function compile Pug ( file , options ) { let content = file . content . to String ( ) ; 
function init Js Processor ( opts , default Babel Processor Name ) { let plugins = ( opts & & opts . plugins ) | | [ adapter Plugin ] ; register Processor ( { name : ( opts & & opts . processor ) | | default Babel Processor Name , 
function init Processor ( options = { } , default Babel Processor Name ) { let { js } = options ; if ( js ! = = false ) { init Js Processor ( js , default Babel Processor Name ) ; } } 
function arr To Map ( arr ) { return arr . reduce ( ( prev , curr ) = > { prev [ curr ] = true ; return prev ; } , { } ) ; } 
function size To Value And Units ( size Value ) { var size Units = 0 ; if ( size Value ) { for ( size Units = 0 ; size Units < 4 & & parse Int ( size Value / 1 0 2 4 , 1 0 ) * 1 0 2 4 = = = size Value ; size Units + = 1 ) { size Value / = 1 0 2 4 ; } } else { size Value = ' ' ; } return { size Units : size Units , size Value : size Value } ; } 
function value And Units To Size ( size Value , size Units ) { var size Bytes = size Value ; var match , i , suffixes = 'bk MGT ' ; if ( parse Float ( size Value ) > 0 ) { size Bytes = parse Float ( size Value ) ; match = size Value . match ( new Reg Exp ( ' ^ \ \s * [ 0 - 9 . ] + \ \s * ( [ ' + suffixes + ' ] ) ' , 'i ' ) ) ; if ( match & & match . length > 1 ) { for ( size Units = 0 ; size Units < suffixes . length ; size Units + = 1 ) { if ( match [ 1 ] . to Lower Case ( ) = = = suffixes [ size Units ] . to Lower Case ( ) ) { break ; } } } for ( i = 0 ; i < parse Int ( size Units , 1 0 ) ; i + = 1 ) { size Bytes * = 1 0 2 4 ; } size Bytes = parse Int ( size Bytes , 1 0 ) ; } return size Bytes ; } 
function confirm ( params ) { params = _ . extend ( { text : 'Are you sure ? ' , yes Text : 'Yes ' , yes Class : 'btn -danger ' , no Text : 'Cancel ' , escaped Html : false , msg Confirmation : false , additional Text : ' ' , name : ' ' } , params ) ; $ ( ' #g -dialog -container ' ) . html ( Confirm Dialog Template ( { params : params } ) ) . girder Modal ( false ) . one ( 'hidden .bs .modal ' , function ( ) { $ ( ' #g -confirm -button ' ) . off ( 'click ' ) ; } ) ; const el = $ ( ' #g -dialog -container ' ) . find ( ' .modal -body >p :first -child ' ) ; if ( params . escaped Html ) { el . html ( params . text ) ; } else { el . text ( params . text ) ; } if ( params [ 'msg Confirmation ' ] ) { if ( params . escaped Html ) { $ ( ' .g -additional -text ' ) . html ( params . additional Text ) ; } else { $ ( ' .g -additional -text ' ) . text ( params . additional Text ) ; } } $ ( ' #g -confirm -button ' ) . off ( 'click ' ) . click ( function ( ) { if ( params [ 'msg Confirmation ' ] ) { const key = ` $ { params . yes Text . to Upper Case ( ) } $ { params . name } ` ; const msg = $ ( ' #g -confirm -text ' ) . val ( ) ; if ( msg . to Upper Case ( ) = = = key . to Upper Case ( ) ) { $ ( ' #g -dialog -container ' ) . modal ( 'hide ' ) ; params . confirm Callback ( ) ; } else if ( msg . to Upper Case ( ) = = = ' ' ) { $ ( ' .g -msg -error ' ) . html ( ` $ { key } ` ) ; $ ( ' .g -msg -error ' ) . css ( 'color ' , 'red ' ) ; } else { $ ( ' .g -msg -error ' ) . html ( ` $ { msg } $ { key } ` ) ; $ ( ' .g -msg -error ' ) . css ( 'color ' , 'red ' ) ; } } else { $ ( ' #g -dialog -container ' ) . modal ( 'hide ' ) ; params . confirm Callback ( ) ; } } ) ; } 
function login ( username , password , cors = cors Auth , otp Token = null ) { var auth = 'Basic ' + window . btoa ( username + ' : ' + password ) ; const headers = { 'Authorization ' : auth } ; if ( _ . is String ( otp Token ) ) { 
function wrap ( obj , func Name , wrapper ) { obj . prototype [ func Name ] = _ . wrap ( obj . prototype [ func Name ] , wrapper ) ; } 
function ( opts ) { opts = opts | | { } ; const defaults = { 
function number Outstanding Rest Requests ( category ) { if ( category ) { return _ . filter ( rest Xhr Pool , function ( xhr ) { return xhr . girder & & xhr . girder [ category ] ; } ) . length ; } return _ . size ( rest Xhr Pool ) ; } 
function cancel Rest Requests ( category ) { _ . each ( rest Xhr Pool , function ( xhr ) { if ( category & & ( ! xhr . girder | | ! xhr . girder [ category ] ) ) { return ; } if ( xhr . abort ) { xhr . abort ( ) ; } } ) ; } 
function sort Tasks ( obj ) { var nodes = _ . keys ( obj ) ; var edges = _ ( obj ) . chain ( ) . pairs ( ) . map ( function ( o ) { return _ . map ( o [ 1 ] . dependencies | | [ ] , function ( d ) { return [ d , o [ 0 ] ] ; } ) ; } ) . flatten ( true ) . value ( ) ; var sorted = toposort . array ( nodes , edges ) ; return sorted ; } 
function sort Operations ( op 1 , op 2 ) { var path Cmp = op 1 . path . locale Compare ( op 2 . path ) ; if ( path Cmp ! = = 0 ) { return path Cmp ; } var index 1 = method Order . index Of ( op 1 . method ) ; var index 2 = method Order . index Of ( op 2 . method ) ; if ( index 1 > - 1 & & index 2 > - 1 ) { return index 1 > index 2 ? 1 : ( index 1 < index 2 ? - 1 : 0 ) ; } if ( index 1 > - 1 ) { return - 1 ; } if ( index 2 > - 1 ) { return 1 ; } return op 1 . method . locale Compare ( op 2 . method ) ; } 
function Event Stream ( settings ) { const defaults = { timeout : null , stream Path : ' /notification /stream ' } ; 
function format Date ( datestr , resolution ) { datestr = datestr . replace ( ' ' , 'T ' ) ; 
function format Size ( size Bytes ) { if ( size Bytes < 1 0 2 4 ) { return size Bytes + ' B ' ; } var i , size Val = size Bytes , precision = 1 ; for ( i = 0 ; size Val > = 1 0 2 4 ; i + = 1 ) { size Val / = 1 0 2 4 ; } 
function format Count ( n , opts ) { n = n | | 0 ; opts = opts | | { } ; var i = 0 , base = opts . base | | 1 0 0 0 , sep = opts . sep | | ' ' , max Len = opts . max Len | | 3 , precision = max Len - 1 ; for ( ; n > base ; i + = 1 ) { n / = base ; } if ( ! i ) { precision = 0 ; } else if ( n > 1 0 0 ) { precision - = 2 ; } else if ( n > 1 0 ) { precision - = 1 ; } return n . to Fixed ( Math . max ( 0 , precision ) ) + sep + [ ' ' , 'k ' , 'M ' , 'G ' , 'T ' ] [ Math . min ( i , 4 ) ] ; } 
function locale Comparator ( model 1 , model 2 ) { var a 1 = model 1 . get ( this . sort Field ) , a 2 = model 2 . get ( this . sort Field ) ; if ( a 1 ! = = undefined & & a 1 . locale Compare ) { var result = a 1 . locale Compare ( a 2 ) * this . sort Dir ; if ( result | | ! this . secondary Sort Field ) { return result ; } a 1 = model 1 . get ( this . secondary Sort Field ) ; a 2 = model 2 . get ( this . secondary Sort Field ) ; return a 1 . locale Compare ( a 2 ) * this . sort Dir ; } return a 1 > a 2 ? this . sort Dir : ( a 1 < a 2 ? - this . sort Dir : 0 ) ; } 
function locale Sort ( a 1 , a 2 ) { if ( a 1 ! = = undefined & & a 1 . locale Compare ) { return a 1 . locale Compare ( a 2 ) ; } return a 1 > a 2 ? 1 : ( a 1 < a 2 ? - 1 : 0 ) ; } 
function define Flags ( options , all Option ) { var i = 0 , obj = { } ; if ( all Option ) { obj [ all Option ] = 1 ; } _ . each ( options , function ( opt ) { obj [ opt ] = 1 < < i ; if ( all Option ) { obj [ all Option ] | = obj [ opt ] ; } i + = 1 ; } ) ; return obj ; } 
function Stream ( json ) { var properties = JSON . parse ( json ) ; var has Prop = { } . has Own Property ; var key ; for ( key in properties ) { if ( has Prop . call ( properties , key ) ) { this [ key ] = properties [ key ] ; } } } 
function decode Session Id ( session Id ) { var fields ; 
function Archive ( config , properties ) { var has Prop = { } . has Own Property ; var id = properties . id ; var key ; for ( key in properties ) { if ( has Prop . call ( properties , key ) ) { this [ key ] = properties [ key ] ; } } this . stop = function ( callback ) { exports . stop Archive ( config , id , callback ) ; } ; this . delete = function ( callback ) { exports . delete Archive ( config , id , callback ) ; } ; } 
function Template ( style , fields ) { if ( ! ~ STYLES . index Of ( style ) ) throw new Error ( "Unsupported pass style " + style ) ; this . style = style ; this . fields = { } ; for ( var key in fields ) this . fields [ key ] = fields [ key ] ; this . keys Path = "keys " ; this . images = { } ; } 
function Zip ( output ) { this . output = output ; 
function File ( zip , filename , modified ) { this . zip = zip ; this . filename = filename ; this . modified = modified | | new Date ( ) ; 
function Pass ( template , fields , images ) { this . template = template ; this . fields = clone Object ( fields ) ; 
function add File ( filename ) { var file = zip . add File ( filename ) ; var sha = new SHAWrite Stream ( manifest , filename , file ) ; return sha ; } 
function sign Manifest ( template , manifest , callback ) { var identifier = template . pass Type Identifier ( ) . replace ( / ^pass . / , " " ) ; var args = [ "smime " , " -sign " , " -binary " , " -signer " , Path . resolve ( template . keys Path , identifier + " .pem " ) , " -certfile " , Path . resolve ( template . keys Path , "wwdr .pem " ) , " -passin " , "pass : " + template . password ] ; var sign = exec File ( "openssl " , args , { stdio : "pipe " } , function ( error , stdout , stderr ) { var trimmed Stderr = stderr . trim ( ) ; 
function clone Object ( object ) { var clone = { } ; if ( object ) { for ( var key in object ) clone [ key ] = object [ key ] ; } return clone ; } 
function SHAWrite Stream ( manifest , filename , output ) { this . output = output ; this . manifest = manifest ; this . filename = filename ; this . sha = Crypto . create Hash ( "sha 1 " ) ; output . on ( "close " , this . emit . bind ( this , "close " ) ) ; output . on ( "error " , this . emit . bind ( this , "error " ) ) ; } 
function nano Remainder ( ms Float ) { var modulo = 1e 6 ; var remainder = ( ms Float * 1e 6 ) % modulo ; var positive Remainder = remainder < 0 ? remainder + modulo : remainder ; return Math . floor ( positive Remainder ) ; } 
function get Epoch ( epoch ) { if ( ! epoch ) { return 0 ; } if ( typeof epoch . get Time = = = "function " ) { return epoch . get Time ( ) ; } if ( typeof epoch = = = "number " ) { return epoch ; } throw new Type Error ( "now should be milliseconds since UNIX epoch " ) ; } 
function compare Timers ( a , b ) { 
async function boot ( ) { 
async function boot ( ) { 
function ( naptime ) { var sleeping = true var now = new Date ( ) var alarm var starting MSeconds = now . get Time ( ) while ( sleeping ) { alarm = new Date ( ) var alarm MSeconds = alarm . get Time ( ) if ( alarm MSeconds - starting MSeconds > naptime ) { sleeping = false } } } 
async function boot ( ) { 
async function try Shutdown ( ) { if ( jobs To Complete = = = 0 ) { await new Promise ( ( resolve ) = > { set Timeout ( resolve , 5 0 0 ) } ) await worker . end ( ) process . exit ( ) } } 
function transform Match Call ( context : Conversion Context , path : Node Path ) { 
function transform Pattern Call ( context : Conversion Context , path : Node Path ) { const args = path . get ( 'arguments ' ) ; const collected = collect Clauses ( context , args ) ; if ( ! collected ) { return ; } const [ collected Params , collected Blocks , error Clause ] = collected ; const pattern = make Pattern ( context , path , collected Params , collected Blocks , error Clause ) ; if ( pattern ) { context . replace Path ( path , pattern ) ; } } 
function has Type Annotation ( path : Node Path ) : boolean { if ( ! path . node ) { return false ; } else if ( path . node . type Annotation ) { return true ; } else if ( path . is Assignment Pattern ( ) ) { return has Type Annotation ( path . get ( 'left ' ) ) ; } else { return false ; } } 
function ensure Constructor ( path : Node Path ) { let last Property ; const [ existing ] = path . get ( 'body .body ' ) . filter ( item = > { if ( item . is Class Property ( ) ) { last Property = item ; return false ; } return item . node . kind = = = 'constructor ' ; } ) ; if ( existing ) { return existing ; } let constructor Node ; if ( path . has ( 'super Class ' ) ) { const args = t . identifier ( 'args ' ) ; constructor Node = t . class Method ( 'constructor ' , t . identifier ( 'constructor ' ) , [ t . rest Element ( args ) ] , t . block Statement ( [ t . expression Statement ( t . call Expression ( t . super ( ) , [ t . spread Element ( args ) ] ) ) ] ) ) ; } else { constructor Node = t . class Method ( 'constructor ' , t . identifier ( 'constructor ' ) , [ ] , t . block Statement ( [ ] ) ) ; } if ( last Property ) { last Property . insert After ( constructor Node ) ; } else { path . get ( 'body ' ) . unshift Container ( 'body ' , constructor Node ) ; } } 
function get Function Inner Checks ( context : Conversion Context , path : Node Path , return Type : Node Path ) : ? Array < ? Node > { if ( ! path . node . async & & ! path . node . generator ) { return ; } if ( ! return Type . is Generic Type Annotation ( ) ) { return ; } const return Type Parameters = get Type Parameters ( return Type ) ; const id = return Type . get ( 'id ' ) ; const name = id . node . name ; if ( return Type Parameters . length = = = 0 ) { 
function ( item Data ) { var new Items = this . items . concat ( item Data ) , 
function ( new Height , widow Layout Style ) { var item Width Sum = this . left , row Width Without Spacing = this . width - ( this . items . length - 1 ) * this . spacing , clamped To Native Ratio , clamped Height , error Width Per Item , rounded Cumulative Errors , single Item Geometry , center Offset ; 
function create New Row ( layout Config , layout Data ) { var is Breakout Row ; 
function add Row ( layout Config , layout Data , row ) { layout Data . _rows . push ( row ) ; layout Data . _layout Items = layout Data . _layout Items . concat ( row . get Items ( ) ) ; 
function compute Layout ( layout Config , layout Data , item Layout Data ) { var laid Out Items = [ ] , item Added , current Row , next To Last Row Height ; 
function ( path , strategy ) { if ( typeof path ! = = 'string ' ) { throw new Error ( 'path should be a string ' ) ; } if ( ! util . is Folder ( path ) ) { throw new Error ( 'path should be a folder ' ) ; } if ( this . _remote Storage & & this . _remote Storage . access & & ! this . _remote Storage . access . check Path Permission ( path , 'r ' ) ) { throw new Error ( 'No access to path " ' + path + ' " . You have to claim access to it first . ' ) ; } if ( ! strategy . match ( / ^ (FLUSH |SEEN |ALL ) $ / ) ) { throw new Error ( "strategy should be 'FLUSH ' , 'SEEN ' , or 'ALL ' " ) ; } this . _root Paths [ path ] = strategy ; if ( strategy = = = 'ALL ' ) { if ( this . activate Handler ) { this . activate Handler ( path ) ; } else { this . pending Activations . push ( path ) ; } } } 
function ( cb ) { var i ; log ( ' [Caching ] Setting activate handler ' , cb , this . pending Activations ) ; this . activate Handler = cb ; for ( i = 0 ; i < this . pending Activations . length ; i + + ) { cb ( this . pending Activations [ i ] ) ; } delete this . pending Activations ; } 
function ( path ) { if ( this . _root Paths [ path ] ! = = undefined ) { return this . _root Paths [ path ] ; } else if ( path = = = ' / ' ) { return 'SEEN ' ; } else { return this . check Path ( containing Folder ( path ) ) ; } } 
function ( scope , mode ) { if ( typeof ( scope ) ! = = 'string ' | | scope . index Of ( ' / ' ) ! = = - 1 | | scope . length = = = 0 ) { throw new Error ( 'Scope should be a non -empty string without forward slashes ' ) ; } if ( ! mode . match ( / ^rw ? $ / ) ) { throw new Error ( 'Mode should be either \ 'r \ ' or \ 'rw \ ' ' ) ; } this . _adjust Root Paths ( scope ) ; this . scope Mode Map [ scope ] = mode ; } 
function ( scope ) { var saved Map = { } ; var name ; for ( name in this . scope Mode Map ) { saved Map [ name ] = this . scope Mode Map [ name ] ; } this . reset ( ) ; delete saved Map [ scope ] ; for ( name in saved Map ) { this . set ( name , saved Map [ name ] ) ; } } 
function ( new Scope ) { if ( ' * ' in this . scope Mode Map | | new Scope = = = ' * ' ) { this . root Paths = [ ' / ' ] ; } else if ( ! ( new Scope in this . scope Mode Map ) ) { this . root Paths . push ( ' / ' + new Scope + ' / ' ) ; this . root Paths . push ( ' /public / ' + new Scope + ' / ' ) ; } } 
function ( scope ) { if ( scope . name = = = ' * ' & & this . storage Type ) { if ( this . storage Type = = = ' 2 0 1 2 . 0 4 ' ) { return ' ' ; } else if ( this . storage Type . match ( / remotestorage - 0 [ 0 1 ] / ) ) { return 'root ' ; } } return scope . name ; } 
function Wire Client ( rs ) { this . rs = rs ; this . connected = false ; event Handling ( this , 'connected ' , 'not -connected ' ) ; if ( has Local Storage ) { const settings = get JSONFrom Local Storage ( SETTINGS _KEY ) ; if ( settings ) { set Timeout ( function ( ) { this . configure ( settings ) ; } . bind ( this ) , 0 ) ; } } this . _revision Cache = { } ; if ( this . connected ) { set Timeout ( this . _emit . bind ( this ) , 0 , 'connected ' ) ; } } 
function ( method , uri , token , headers , body , get Etag , fake Revision ) { if ( ( method = = = 'PUT ' | | method = = = 'DELETE ' ) & & uri [ uri . length - 1 ] = = = ' / ' ) { return Promise . reject ( 'Don \ 't ' + method + ' on directories ! ' ) ; } var revision ; var self = this ; if ( token ! = = Authorize . IMPLIED _FAKE _TOKEN ) { headers [ 'Authorization ' ] = 'Bearer ' + token ; } this . rs . _emit ( 'wire -busy ' , { method : method , is Folder : is Folder ( uri ) } ) ; return Wire Client . request ( method , uri , { body : body , headers : headers , response Type : 'arraybuffer ' } ) . then ( function ( response ) { if ( ! self . online ) { self . online = true ; self . rs . _emit ( 'network -online ' ) ; } self . rs . _emit ( 'wire -done ' , { method : method , is Folder : is Folder ( uri ) , success : true } ) ; if ( is Error Status ( response . status ) ) { log ( ' [Wire Client ] Error response status ' , response . status ) ; if ( get Etag ) { revision = strip Quotes ( response . get Response Header ( 'ETag ' ) ) ; } else { revision = undefined ; } if ( response . status = = = 4 0 1 ) { self . rs . _emit ( 'error ' , new Authorize . Unauthorized ( ) ) ; } return Promise . resolve ( { status Code : response . status , revision : revision } ) ; } else if ( is Success Status ( response . status ) | | ( response . status = = = 2 0 0 & & method ! = = 'GET ' ) ) { revision = strip Quotes ( response . get Response Header ( 'ETag ' ) ) ; log ( ' [Wire Client ] Successful request ' , revision ) ; return Promise . resolve ( { status Code : response . status , revision : revision } ) ; } else { var mime Type = response . get Response Header ( 'Content -Type ' ) ; if ( get Etag ) { revision = strip Quotes ( response . get Response Header ( 'ETag ' ) ) ; } else { revision = response . status = = = 2 0 0 ? fake Revision : undefined ; } var charset = determine Charset ( mime Type ) ; if ( should Be Treated As Binary ( response . response , mime Type ) ) { log ( ' [Wire Client ] Successful request with unknown or binary mime -type ' , revision ) ; return Promise . resolve ( { status Code : response . status , body : response . response , content Type : mime Type , revision : revision } ) ; } else { return get Text From Array Buffer ( response . response , charset ) . then ( function ( text Content ) { log ( ' [Wire Client ] Successful request ' , revision ) ; return Promise . resolve ( { status Code : response . status , body : text Content , content Type : mime Type , revision : revision } ) ; } ) ; } } } , function ( error ) { if ( self . online ) { self . online = false ; self . rs . _emit ( 'network -offline ' ) ; } self . rs . _emit ( 'wire -done ' , { method : method , is Folder : is Folder ( uri ) , success : false } ) ; return Promise . reject ( error ) ; } ) ; } 
function ( path , max Age , queue Get Request ) { var self = this ; if ( typeof ( max Age ) = = = 'number ' ) { return self . get Nodes ( paths From Root ( path ) ) . then ( function ( objs ) { var node = get Latest ( objs [ path ] ) ; if ( is Outdated ( objs , max Age ) ) { return queue Get Request ( path ) ; } else if ( node ) { return { status Code : 2 0 0 , body : node . body | | node . items Map , content Type : node . content Type } ; } else { return { status Code : 4 0 4 } ; } } ) ; } else { return self . get Nodes ( [ path ] ) . then ( function ( objs ) { var node = get Latest ( objs [ path ] ) ; if ( node ) { if ( is Folder ( path ) ) { for ( var i in node . items Map ) { 
function meta Title From File Name ( filename ) { if ( filename . substr ( - 1 ) = = = ' / ' ) { filename = filename . substr ( 0 , filename . length - 1 ) ; } return decode URIComponent ( filename ) ; } 
function base Name ( path ) { const parts = path . split ( ' / ' ) ; if ( path . substr ( - 1 ) = = = ' / ' ) { return parts [ parts . length - 2 ] + ' / ' ; } else { return parts [ parts . length - 1 ] ; } } 
function ( ) { this . rs . set Backend ( 'googledrive ' ) ; this . rs . authorize ( { auth URL : AUTH _URL , scope : AUTH _SCOPE , client Id : this . client Id } ) ; } 
function ( path , options ) { if ( path . substr ( - 1 ) = = = ' / ' ) { return this . _get Folder ( google Drive Path ( path ) , options ) ; } else { return this . _get File ( google Drive Path ( path ) , options ) ; } } 
function ( path , body , content Type , options ) { const full Path = google Drive Path ( path ) ; function put Done ( response ) { if ( response . status > = 2 0 0 & & response . status < 3 0 0 ) { const meta = JSON . parse ( response . response Text ) ; const etag Without Quotes = remove Quotes ( meta . etag ) ; return Promise . resolve ( { status Code : 2 0 0 , content Type : meta . mime Type , revision : etag Without Quotes } ) ; } else if ( response . status = = = 4 1 2 ) { return Promise . resolve ( { status Code : 4 1 2 , revision : 'conflict ' } ) ; } else { return Promise . reject ( "PUT failed with status " + response . status + " ( " + response . response Text + " ) " ) ; } } return this . _get File Id ( full Path ) . then ( ( id ) = > { if ( id ) { if ( options & & ( options . if None Match = = = ' * ' ) ) { return put Done ( { status : 4 1 2 } ) ; } return this . _update File ( id , full Path , body , content Type , options ) . then ( put Done ) ; } else { return this . _create File ( full Path , body , content Type , options ) . then ( put Done ) ; } } ) ; } 
function ( path , options ) { const full Path = google Drive Path ( path ) ; return this . _get File Id ( full Path ) . then ( ( id ) = > { if ( ! id ) { 
function ( ) { const url = BASE _URL + ' /drive /v 2 /about ?fields =user ' ; 
function ( id , path , body , content Type , options ) { const metadata = { mime Type : content Type } ; const headers = { 'Content -Type ' : 'application /json ; charset =UTF - 8 ' } ; if ( options & & options . if Match ) { headers [ 'If -Match ' ] = ' " ' + options . if Match + ' " ' ; } return this . _request ( 'PUT ' , BASE _URL + ' /upload /drive /v 2 /files / ' + id + ' ?upload Type =resumable ' , { body : JSON . stringify ( metadata ) , headers : headers } ) . then ( ( response ) = > { if ( response . status = = = 4 1 2 ) { return ( response ) ; } else { return this . _request ( 'PUT ' , response . get Response Header ( 'Location ' ) , { body : content Type . match ( / ^application \ /json / ) ? JSON . stringify ( body ) : body } ) ; } } ) ; } 
function ( path , body , content Type ) { return this . _get Parent Id ( path ) . then ( ( parent Id ) = > { const file Name = base Name ( path ) ; const metadata = { title : meta Title From File Name ( file Name ) , mime Type : content Type , parents : [ { kind : "drive #file Link " , id : parent Id } ] } ; return this . _request ( 'POST ' , BASE _URL + ' /upload /drive /v 2 /files ?upload Type =resumable ' , { body : JSON . stringify ( metadata ) , headers : { 'Content -Type ' : 'application /json ; charset =UTF - 8 ' } } ) . then ( ( response ) = > { return this . _request ( 'POST ' , response . get Response Header ( 'Location ' ) , { body : content Type . match ( / ^application \ /json / ) ? JSON . stringify ( body ) : body } ) ; } ) ; } ) ; } 
function ( path , options ) { return this . _get File Id ( path ) . then ( ( id ) = > { return this . _get Meta ( id ) . then ( ( meta ) = > { let etag Without Quotes ; if ( typeof ( meta ) = = = 'object ' & & typeof ( meta . etag ) = = = 'string ' ) { etag Without Quotes = remove Quotes ( meta . etag ) ; } if ( options & & options . if None Match & & ( etag Without Quotes = = = options . if None Match ) ) { return Promise . resolve ( { status Code : 3 0 4 } ) ; } if ( ! meta . download Url ) { if ( meta . export Links & & meta . export Links [ 'text /html ' ] ) { 
function ( path ) { return this . _get File Id ( path ) . then ( ( id ) = > { let query , fields , data , etag Without Quotes , items Map ; if ( ! id ) { return Promise . resolve ( { status Code : 4 0 4 } ) ; } query = ' \ ' ' + id + ' \ ' in parents ' ; fields = 'items (download Url ,etag ,file Size ,id ,mime Type ,title ) ' ; return this . _request ( 'GET ' , BASE _URL + ' /drive /v 2 /files ? ' + 'q = ' + encode URIComponent ( query ) + ' &fields = ' + encode URIComponent ( fields ) + ' &max Results = 1 0 0 0 ' , { } ) . then ( ( response ) = > { if ( response . status ! = = 2 0 0 ) { return Promise . reject ( 'request failed or something : ' + response . status ) ; } try { data = JSON . parse ( response . response Text ) ; } catch ( e ) { return Promise . reject ( 'non -JSON response from Google Drive ' ) ; } items Map = { } ; for ( const item of data . items ) { etag Without Quotes = remove Quotes ( item . etag ) ; if ( item . mime Type = = = GD _DIR _MIME _TYPE ) { this . _file Id Cache . set ( path + item . title + ' / ' , item . id ) ; items Map [ item . title + ' / ' ] = { ETag : etag Without Quotes } ; } else { this . _file Id Cache . set ( path + item . title , item . id ) ; items Map [ item . title ] = { ETag : etag Without Quotes , 'Content -Type ' : item . mime Type , 'Content -Length ' : item . file Size } ; } } 
function ( path ) { const foldername = parent Path ( path ) ; return this . _get File Id ( foldername ) . then ( ( parent Id ) = > { if ( parent Id ) { return Promise . resolve ( parent Id ) ; } else { return this . _create Folder ( foldername ) ; } } ) ; } 
function ( path ) { return this . _get Parent Id ( path ) . then ( ( parent Id ) = > { return this . _request ( 'POST ' , BASE _URL + ' /drive /v 2 /files ' , { body : JSON . stringify ( { title : meta Title From File Name ( base Name ( path ) ) , mime Type : GD _DIR _MIME _TYPE , parents : [ { id : parent Id } ] } ) , headers : { 'Content -Type ' : 'application /json ; charset =UTF - 8 ' } } ) . then ( ( response ) = > { const meta = JSON . parse ( response . response Text ) ; return Promise . resolve ( meta . id ) ; } ) ; } ) ; } 
function ( path ) { let id ; if ( path = = = ' / ' ) { 
function ( id ) { return this . _request ( 'GET ' , BASE _URL + ' /drive /v 2 /files / ' + id , { } ) . then ( function ( response ) { if ( response . status = = = 2 0 0 ) { return Promise . resolve ( JSON . parse ( response . response Text ) ) ; } else { return Promise . reject ( "request (getting metadata for " + id + " ) failed with status : " + response . status ) ; } } ) ; } 
function ( method , url , options ) { if ( ! options . headers ) { options . headers = { } ; } options . headers [ 'Authorization ' ] = 'Bearer ' + this . token ; this . rs . _emit ( 'wire -busy ' , { method : method , is Folder : is Folder ( url ) } ) ; return Wire Client . request . call ( this , method , url , options ) . then ( ( xhr ) = > { 
function un Hook Get Item URL ( rs ) { if ( ! rs . _orig Base Client Get Item URL ) { return ; } Base Client . prototype . get Item URL = rs . _orig Base Client Get Item URL ; delete rs . _orig Base Client Get Item URL ; } 
function ( event Name , handler ) { if ( typeof ( event Name ) ! = = 'string ' ) { throw new Error ( 'Argument event Name should be a string ' ) ; } if ( typeof ( handler ) ! = = 'function ' ) { throw new Error ( 'Argument handler should be a function ' ) ; } log ( ' [Eventhandling ] Adding event listener ' , event Name ) ; this . _validate Event ( event Name ) ; this . _handlers [ event Name ] . push ( handler ) ; } 
function ( event Name , handler ) { this . _validate Event ( event Name ) ; var hl = this . _handlers [ event Name ] . length ; for ( var i = 0 ; i < hl ; i + + ) { if ( this . _handlers [ event Name ] [ i ] = = = handler ) { this . _handlers [ event Name ] . splice ( i , 1 ) ; return ; } } } 
function Discover ( user Address ) { return new Promise ( ( resolve , reject ) = > { if ( user Address in cached Info ) { return resolve ( cached Info [ user Address ] ) ; } var web Finger = new Web Finger ( { tls _only : false , uri _fallback : true , request _timeout : 5 0 0 0 } ) ; return web Finger . lookup ( user Address , function ( err , response ) { if ( err ) { return reject ( err ) ; } else if ( ( typeof response . idx . links . remotestorage ! = = 'object ' ) | | ( typeof response . idx . links . remotestorage . length ! = = 'number ' ) | | ( response . idx . links . remotestorage . length < = 0 ) ) { log ( " [Discover ] Web Finger record for " + user Address + " does not have remotestorage defined in the links section " , JSON . stringify ( response . json ) ) ; return reject ( "Web Finger record for " + user Address + " does not have remotestorage defined in the links section . " ) ; } var rs = response . idx . links . remotestorage [ 0 ] ; var auth URL = rs . properties [ 'http : / /tools .ietf .org /html /rfc 6 7 4 9 #section - 4 . 2 ' ] | | rs . properties [ 'auth -endpoint ' ] ; var storage Api = rs . properties [ 'http : / /remotestorage .io /spec /version ' ] | | rs . type ; 
function ( ) { 
function ( settings ) { 
function ( path ) { var url = 'https : / /api .dropboxapi .com / 2 /files /list _folder ' ; var rev Cache = this . _rev Cache ; var self = this ; var process Response = function ( resp ) { var body , listing ; if ( resp . status ! = = 2 0 0 & & resp . status ! = = 4 0 9 ) { return Promise . reject ( 'Unexpected response status : ' + resp . status ) ; } try { body = JSON . parse ( resp . response Text ) ; } catch ( e ) { return Promise . reject ( e ) ; } if ( resp . status = = = 4 0 9 ) { if ( compare Api Error ( body , [ 'path ' , 'not _found ' ] ) ) { 
function ( path , options ) { if ( ! this . connected ) { return Promise . reject ( "not connected (path : " + path + " ) " ) ; } var url = 'https : / /content .dropboxapi .com / 2 /files /download ' ; var self = this ; var saved Rev = this . _rev Cache . get ( path ) ; if ( saved Rev = = = null ) { 
function ( path , body , content Type , options ) { var self = this ; if ( ! this . connected ) { throw new Error ( "not connected (path : " + path + " ) " ) ; } 
function ( path , options ) { if ( ! this . connected ) { throw new Error ( "not connected (path : " + path + " ) " ) ; } 
function ( path ) { var url = 'https : / /api .dropboxapi .com / 2 /sharing /create _shared _link _with _settings ' ; var options = { body : { path : get Dropbox Path ( path ) } } ; return this . _request ( 'POST ' , url , options ) . then ( ( response ) = > { if ( response . status ! = = 2 0 0 & & response . status ! = = 4 0 9 ) { return Promise . reject ( new Error ( 'Invalid response status : ' + response . status ) ) ; } var body ; try { body = JSON . parse ( response . response Text ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Invalid response body : ' + response . response Text ) ) ; } if ( response . status = = = 4 0 9 ) { if ( compare Api Error ( body , [ 'shared _link _already _exists ' ] ) ) { return this . _get Shared Link ( path ) ; } return Promise . reject ( new Error ( 'API error : ' + body . error _summary ) ) ; } return Promise . resolve ( body . url ) ; } ) . then ( ( link ) = > { this . _item Refs [ path ] = link ; if ( has Local Storage ) { local Storage . set Item ( SETTINGS _KEY + ' :shares ' , JSON . stringify ( this . _item Refs ) ) ; } return Promise . resolve ( link ) ; } , ( error ) = > { error . message = 'Sharing Dropbox file or folder ( " ' + path + ' " ) failed : ' + error . message ; return Promise . reject ( error ) ; } ) ; } 
function ( ) { var url = 'https : / /api .dropboxapi .com / 2 /users /get _current _account ' ; return this . _request ( 'POST ' , url , { } ) . then ( function ( response ) { var info = response . response Text ; try { info = JSON . parse ( info ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Could not query current account info : Invalid API response : ' + info ) ) ; } return Promise . resolve ( { email : info . email } ) ; } ) ; } 
function ( method , url , options ) { var self = this ; if ( ! options . headers ) { options . headers = { } ; } options . headers [ 'Authorization ' ] = 'Bearer ' + this . token ; if ( typeof options . body = = = 'object ' & & ! is Binary Data ( options . body ) ) { options . body = JSON . stringify ( options . body ) ; options . headers [ 'Content -Type ' ] = 'application /json ; charset =UTF - 8 ' ; } this . rs . _emit ( 'wire -busy ' , { method : method , is Folder : is Folder ( url ) } ) ; return Wire Client . request . call ( this , method , url , options ) . then ( function ( xhr ) { 
function ( ) { 
function ( params ) { var url = 'https : / /content .dropboxapi .com / 2 /files /upload ' ; var args = { path : get Dropbox Path ( params . path ) , mode : { ' .tag ' : 'overwrite ' } , mute : true } ; if ( params . if Match ) { args . mode = { ' .tag ' : 'update ' , update : params . if Match } ; } return this . _request ( 'POST ' , url , { body : params . body , headers : { 'Content -Type ' : 'application /octet -stream ' , 'Dropbox -API -Arg ' : JSON . stringify ( args ) } } ) . then ( ( response ) = > { if ( response . status ! = = 2 0 0 & & response . status ! = = 4 0 9 ) { return Promise . resolve ( { status Code : response . status } ) ; } var body = response . response Text ; try { body = JSON . parse ( body ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Invalid API result : ' + body ) ) ; } if ( response . status = = = 4 0 9 ) { if ( compare Api Error ( body , [ 'path ' , 'conflict ' ] ) ) { return this . _get Metadata ( params . path ) . then ( function ( metadata ) { return Promise . resolve ( { status Code : 4 1 2 , revision : metadata . rev } ) ; } ) ; } return Promise . reject ( new Error ( 'API error : ' + body . error _summary ) ) ; } this . _rev Cache . set ( params . path , body . rev ) ; return Promise . resolve ( { status Code : response . status , revision : body . rev } ) ; } ) ; } 
function ( path ) { const url = 'https : / /api .dropboxapi .com / 2 /files /delete ' ; const request Body = { path : get Dropbox Path ( path ) } ; return this . _request ( 'POST ' , url , { body : request Body } ) . then ( ( response ) = > { if ( response . status ! = = 2 0 0 & & response . status ! = = 4 0 9 ) { return Promise . resolve ( { status Code : response . status } ) ; } var response Body = response . response Text ; try { response Body = JSON . parse ( response Body ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Invalid response body : ' + response Body ) ) ; } if ( response . status = = = 4 0 9 ) { if ( compare Api Error ( response Body , [ 'path _lookup ' , 'not _found ' ] ) ) { return Promise . resolve ( { status Code : 4 0 4 } ) ; } return Promise . reject ( new Error ( 'API error : ' + response Body . error _summary ) ) ; } return Promise . resolve ( { status Code : 2 0 0 } ) ; } ) . then ( ( result ) = > { if ( result . status Code = = = 2 0 0 | | result . status Code = = = 4 0 4 ) { this . _rev Cache . delete ( path ) ; delete this . _item Refs [ path ] ; } return Promise . resolve ( result ) ; } , ( error ) = > { error . message = 'Could not delete Dropbox file or folder ( " ' + path + ' " ) : ' + error . message ; return Promise . reject ( error ) ; } ) ; } 
function ( path ) { var url = 'https : / /api .dropbox .com / 2 /sharing /list _shared _links ' ; var options = { body : { path : get Dropbox Path ( path ) , direct _only : true } } ; return this . _request ( 'POST ' , url , options ) . then ( ( response ) = > { if ( response . status ! = = 2 0 0 & & response . status ! = = 4 0 9 ) { return Promise . reject ( new Error ( 'Invalid response status : ' + response . status ) ) ; } var body ; try { body = JSON . parse ( response . response Text ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Invalid response body : ' + response . response Text ) ) ; } if ( response . status = = = 4 0 9 ) { return Promise . reject ( new Error ( 'API error : ' + response . error _summary ) ) ; } if ( ! body . links . length ) { return Promise . reject ( new Error ( 'No links returned ' ) ) ; } return Promise . resolve ( body . links [ 0 ] . url ) ; } , ( error ) = > { error . message = 'Could not get link to a shared file or folder ( " ' + path + ' " ) : ' + error . message ; return Promise . reject ( error ) ; } ) ; } 
function hook Sync ( rs ) { if ( rs . _dropbox Orig Sync ) { return ; } 
function un Hook Sync ( rs ) { if ( ! rs . _dropbox Orig Sync ) { return ; } 
function hook Sync Cycle ( rs ) { if ( rs . _dropbox Orig Sync Cycle ) { return ; } 
function un Hook Sync Cycle ( rs ) { if ( ! rs . _dropbox Orig Sync Cycle ) { return ; } 
function hook Get Item URL ( rs ) { if ( rs . _orig Base Client Get Item URL ) { return ; } rs . _orig Base Client Get Item URL = Base Client . prototype . get Item URL ; Base Client . prototype . get Item URL = function ( ) { throw new Error ( 'get Item URL is not implemented for Dropbox yet ' ) ; } ; } 
function hook Remote ( rs ) { if ( rs . _orig Remote ) { return ; } rs . _orig Remote = rs . remote ; rs . remote = rs . dropbox ; } 
function un Hook Remote ( rs ) { if ( rs . _orig Remote ) { rs . remote = rs . _orig Remote ; delete rs . _orig Remote ; } } 
function hook It ( rs ) { hook Remote ( rs ) ; if ( rs . sync ) { hook Sync ( rs ) ; } else { 
function un Hook It ( rs ) { un Hook Remote ( rs ) ; un Hook Sync ( rs ) ; un Hook Get Item URL ( rs ) ; un Hook Sync Cycle ( rs ) ; } 
function ( paths ) { var misses = [ ] , from Cache = { } ; for ( let i = 0 , len = paths . length ; i < len ; i + + ) { if ( this . changes Queued [ paths [ i ] ] ! = = undefined ) { from Cache [ paths [ i ] ] = util . deep Clone ( this . changes Queued [ paths [ i ] ] | | undefined ) ; } else if ( this . changes Running [ paths [ i ] ] ! = = undefined ) { from Cache [ paths [ i ] ] = util . deep Clone ( this . changes Running [ paths [ i ] ] | | undefined ) ; } else { misses . push ( paths [ i ] ) ; } } if ( misses . length > 0 ) { return this . get Nodes From Db ( misses ) . then ( function ( nodes ) { for ( let i in from Cache ) { nodes [ i ] = from Cache [ i ] ; } return nodes ; } ) ; } else { return Promise . resolve ( from Cache ) ; } } 
function ( nodes ) { for ( var i in nodes ) { this . changes Queued [ i ] = nodes [ i ] | | false ; } this . maybe Flush ( ) ; return Promise . resolve ( ) ; } 
function ( ) { if ( this . commit Slowness Warning ) { clear Interval ( this . commit Slowness Warning ) ; this . commit Slowness Warning = null ; } if ( Object . keys ( this . changes Queued ) . length > 0 ) { this . changes Running = this . changes Queued ; this . changes Queued = { } ; this . set Nodes In Db ( this . changes Running ) . then ( this . flush Changes Queued . bind ( this ) ) ; } } 
function ( paths ) { return new Promise ( ( resolve , reject ) = > { let transaction = this . db . transaction ( [ 'nodes ' ] , 'readonly ' ) ; let nodes = transaction . object Store ( 'nodes ' ) ; let retrieved Nodes = { } ; this . gets Running + + ; paths . map ( function ( path ) { nodes . get ( path ) . onsuccess = function ( evt ) { retrieved Nodes [ path ] = evt . target . result ; } ; } ) ; transaction . oncomplete = function ( ) { resolve ( retrieved Nodes ) ; this . gets Running - - ; } . bind ( this ) ; transaction . onerror = transaction . onabort = function ( ) { reject ( 'get transaction error /abort ' ) ; this . gets Running - - ; } . bind ( this ) ; } ) ; } 
function ( nodes ) { return new Promise ( ( resolve , reject ) = > { let transaction = this . db . transaction ( [ 'nodes ' ] , 'readwrite ' ) ; let nodes Store = transaction . object Store ( 'nodes ' ) ; let start Time = new Date ( ) . get Time ( ) ; this . puts Running + + ; log ( ' [Indexed DB ] Starting put ' , nodes , this . puts Running ) ; for ( var path in nodes ) { var node = nodes [ path ] ; if ( typeof ( node ) = = = 'object ' ) { try { nodes Store . put ( node ) ; } catch ( e ) { log ( ' [Indexed DB ] Error while putting ' , node , e ) ; throw e ; } } else { try { nodes Store . delete ( path ) ; } catch ( e ) { log ( ' [Indexed DB ] Error while removing ' , nodes Store , node , e ) ; throw e ; } } } transaction . oncomplete = function ( ) { this . puts Running - - ; log ( ' [Indexed DB ] Finished put ' , nodes , this . puts Running , ( new Date ( ) . get Time ( ) - start Time ) + 'ms ' ) ; resolve ( ) ; } . bind ( this ) ; transaction . onerror = function ( ) { this . puts Running - - ; reject ( 'transaction error ' ) ; } . bind ( this ) ; transaction . onabort = function ( ) { reject ( 'transaction abort ' ) ; this . puts Running - - ; } . bind ( this ) ; } ) ; } 
function ( callback ) { let db Name = this . db . name ; this . db . close ( ) ; Indexed DB . clean ( this . db . name , ( ) = > { Indexed DB . open ( db Name , ( err , other ) = > { if ( err ) { log ( ' [Indexed DB ] Error while resetting local storage ' , err ) ; } else { 
function ( cb ) { return new Promise ( ( resolve ) = > { let transaction = this . db . transaction ( [ 'nodes ' ] , 'readonly ' ) ; let cursor Req = transaction . object Store ( 'nodes ' ) . open Cursor ( ) ; cursor Req . onsuccess = ( evt ) = > { let cursor = evt . target . result ; if ( cursor ) { cb ( this . migrate ( cursor . value ) ) ; cursor . continue ( ) ; } else { resolve ( ) ; } } ; } ) ; } 
function extract Features ( chunk ) { 
function ( ) { this . var Name = " " ; this . type = " " ; this . options = { } ; this . next = null ; this . head = null ; this . compiled = null ; this . endian = "be " ; this . constructor Fn = null ; this . alias = null ; } 
function ( ) { return { ' / ' : { page : ' / ' } , ' /install ' : { page : ' /install ' } , ' /design -assets ' : { page : ' /design -assets ' } , ' /contribute ' : { page : ' /contribute ' } , ' /contribute /code ' : { page : ' /contribute /code ' } , ' /contribute /components ' : { page : ' /contribute /components ' } , ' /roadmap ' : { page : ' /roadmap ' } , ' /components /actionmenu ' : { page : ' /components /actionmenu ' } , ' /components /avatar ' : { page : ' /components /avatar ' } , ' /components /badge ' : { page : ' /components /badge ' } , ' /components /banner ' : { page : ' /components /banner ' } , ' /components /breadcrumb ' : { page : ' /components /breadcrumb ' } , ' /components /button ' : { page : ' /components /button ' } , ' /components /card ' : { page : ' /components /card ' } , ' /components /checkbox ' : { page : ' /components /checkbox ' } , ' /components /circularprogress ' : { page : ' /components /circularprogress ' } , ' /components /code ' : { page : ' /components /code ' } , ' /components /datepicker ' : { page : ' /components /datepicker ' } , ' /components /dialog ' : { page : ' /components /dialog ' } , ' /components /dialog -modal -example ' : { page : ' /components /dialog -modal -example ' } , ' /components /drawer ' : { page : ' /components /drawer ' } , ' /components /dropdown ' : { page : ' /components /dropdown ' } , ' /components /emptystate ' : { page : ' /components /emptystate ' } , ' /components /errors ' : { page : ' /components /errors ' } , ' /components /form ' : { page : ' /components /form ' } , ' /components /icon ' : { page : ' /components /icon ' } , ' /components /layout ' : { page : ' /components /layout ' } , ' /components /linearprogress ' : { page : ' /components /linearprogress ' } , ' /components /link ' : { page : ' /components /link ' } , ' /components /radio ' : { page : ' /components /radio ' } , ' /components /row ' : { page : ' /components /row ' } , ' /components /starrating ' : { page : ' /components /starrating ' } , ' /components /switch ' : { page : ' /components /switch ' } , ' /components /tab ' : { page : ' /components /tab ' } , ' /components /table ' : { page : ' /components /table ' } , ' /components /tag ' : { page : ' /components /tag ' } , ' /components /text ' : { page : ' /components /text ' } , ' /components /textarea ' : { page : ' /components /textarea ' } , ' /components /textinput ' : { page : ' /components /textinput ' } , ' /components /theme ' : { page : ' /components /theme ' } , ' /components /tooltip ' : { page : ' /components /tooltip ' } , ' /components /viewtoggle ' : { page : ' /components /viewtoggle ' } , ' /core /build ' : { page : ' /core /build ' } , ' /core /usage ' : { page : ' /core /usage ' } , ' /core /color ' : { page : ' /core /color ' } , ' /core /motion ' : { page : ' /core /motion ' } , ' /core /spacing ' : { page : ' /core /spacing ' } , ' /core /typography ' : { page : ' /core /typography ' } , ' /patterns /iconography ' : { page : ' /patterns /iconography ' } , ' /patterns /voice -tone ' : { page : ' /patterns /voice -tone ' } } } 
function get Id From URL ( url ) { var id = url . replace ( youtube Regexp , ' $ 1 ' ) ; if ( id . includes ( ' ; ' ) ) { var pieces = id . split ( ' ; ' ) ; if ( pieces [ 1 ] . includes ( ' % ' ) ) { var uri Component = decode URIComponent ( pieces [ 1 ] ) ; id = ( "http : / /youtube .com " + uri Component ) . replace ( youtube Regexp , ' $ 1 ' ) ; } else { id = pieces [ 0 ] ; } } else if ( id . includes ( ' # ' ) ) { id = id . split ( ' # ' ) [ 0 ] ; } return id } 
function get Time From URL ( url ) { if ( url = = = void 0 ) url = ' ' ; var times = url . match ( time Regexp ) ; if ( ! times ) { return 0 } var full = times [ 0 ] ; var minutes = times [ 1 ] ; var seconds = times [ 2 ] ; if ( typeof seconds ! = = 'undefined ' ) { seconds = parse Int ( seconds , 1 0 ) ; minutes = parse Int ( minutes , 1 0 ) ; } else if ( full . includes ( 'm ' ) ) { minutes = parse Int ( minutes , 1 0 ) ; seconds = 0 ; } else { seconds = parse Int ( minutes , 1 0 ) ; minutes = 0 ; } return seconds + ( minutes * 6 0 ) } 
function on Tables Selected ( tables ) { 
function on Table Data Collected ( err , data ) { bail On Error ( err ) ; var table Name , models = { } , model ; for ( table Name in data . table Structure ) { model = steps . table To Object ( { name : table Name , columns : data . table Structure [ table Name ] , comment : data . table Comments [ table Name ] } , opts ) ; models [ model . name ] = model ; } data . models = steps . find References ( models ) ; 
function on Data Output ( ) { if ( ! opts . output Dir ) { return ; } if ( opts . interactive ) { console . log ( ' \n \n \n ' ) ; } var dir = path . resolve ( opts . output Dir ) ; console . log ( 'Demo app generated in ' + dir + ' . To run : ' ) ; console . log ( 'cd ' + dir ) ; console . log ( 'npm install ' ) ; console . log ( 'npm start ' ) ; console . log ( ) ; console . log ( 'Then point your browser at http : / /localhost : 3 0 0 0 ' ) ; } 
function get Offset ( cursor , default Offset ) { if ( typeof cursor = = = 'undefined ' | | cursor = = = null ) { return default Offset ; } let offset = cursor To Offset ( cursor ) ; if ( is Na N ( offset ) ) { return default Offset ; } return offset ; } 
function import Specifier ( name , def ) { return { type : def = = = true ? 'Import Default Specifier ' : 'Import Specifier ' , id : { type : 'Identifier ' , name : name } , name : null } ; } 
function rule Codes ( flags , value ) { var flag = flags . FLAG var result = [ ] var length var index if ( ! value ) { return result } if ( flag = = = 'long ' ) { index = 0 length = value . length while ( index < length ) { result . push ( value . substr ( index , 2 ) ) index + = 2 } return result } return value . split ( flag = = = 'num ' ? ' , ' : ' ' ) } 
function affix ( aff ) { var rules = { } var replacement Table = [ ] var conversion = { in : [ ] , out : [ ] } var compound Rule Codes = { } var lines = [ ] var flags = { } var compound Rules = [ ] var index var length var parts var line var rule Type var entries var count var remove var add var source var entry var rule Length var position var rule var last var value var offset var character flags [ key Type ] = [ ] 
function add ( buf ) { var self = this var flags = self . flags var lines = buf . to String ( 'utf 8 ' ) . split ( ' \n ' ) var length = lines . length var index = - 1 var line var forbidden var word var model var flag 
function suggest ( value ) { var self = this var replacement Table = self . replacement Table var conversion = self . conversion var groups = self . flags . KEY var suggestions = [ ] var weighted = { } var memory var replacement var edits = [ ] var values var index var length var offset var position var count var other Offset var other Count var other Character var character var group var before var after var upper var insensitive var first Level var prev var next var next Character var max var distance var end var size var normalized var suggestion var current Case value = normalize ( trim ( value ) , conversion . in ) if ( ! value | | self . correct ( value ) ) { return [ ] } current Case = casing ( value ) 
function generate ( context , memory , words , edits ) { var characters = context . flags . TRY var character Length = characters . length var data = context . data var flags = context . flags var result = [ ] var upper var length var index var word var position var count var before var after var next After var next Next After var character var next Character var inject var offset 
function check ( value , double ) { var state = memory . state [ value ] var corrected if ( state ! = = Boolean ( state ) ) { result . push ( value ) corrected = form ( context , value ) state = corrected & & ! flag ( flags , no Suggest Type , data [ corrected ] ) memory . state [ value ] = state if ( state ) { memory . weighted [ value ] = double ? 1 0 : 0 memory . suggestions . push ( value ) } } if ( state ) { memory . weighted [ value ] + + } } 
function add ( word , rules ) { 
function flag ( values , value , flags ) { return flags & & own . call ( values , value ) & & flags . index Of ( values [ value ] ) ! = = - 1 } 
function normalize ( value , patterns ) { var length = patterns . length var index = - 1 var pattern while ( + + index < length ) { pattern = patterns [ index ] value = value . replace ( pattern [ 0 ] , pattern [ 1 ] ) } return value } 
function form ( context , value , all ) { var dict = context . data var flags = context . flags var alternative value = trim ( value ) if ( ! value ) { return null } value = normalize ( value , context . conversion . in ) if ( exact ( context , value ) ) { if ( ! all & & flag ( flags , 'FORBIDDENWORD ' , dict [ value ] ) ) { return null } return value } 
function NSpell ( aff , dic ) { var length var index var dictionaries if ( ! ( this instanceof NSpell ) ) { return new NSpell ( aff , dic ) } if ( typeof aff = = = 'string ' | | buffer ( aff ) ) { if ( typeof dic = = = 'string ' | | buffer ( dic ) ) { dictionaries = [ { dic : dic } ] } } else if ( aff ) { if ( 'length ' in aff ) { dictionaries = aff aff = aff [ 0 ] & & aff [ 0 ] . aff } else { if ( aff . dic ) { dictionaries = [ aff ] } aff = aff . aff } } if ( ! aff ) { throw new Error ( 'Missing `aff ` in dictionary ' ) } aff = affix ( aff ) this . data = { } this . compound Rule Codes = aff . compound Rule Codes this . replacement Table = aff . replacement Table this . conversion = aff . conversion this . compound Rules = aff . compound Rules this . rules = aff . rules this . flags = aff . flags length = dictionaries ? dictionaries . length : 0 index = - 1 while ( + + index < length ) { dic = dictionaries [ index ] if ( dic & & dic . dic ) { this . dictionary ( dic . dic ) } } } 
function add ( value , model ) { var self = this var dict = self . data var codes = model & & own . call ( dict , model ) ? dict [ model ] . concat ( ) : [ ] push ( dict , value , codes , self ) return self } 
function parse ( buf , options , dict ) { var index var last var value 
function parse Line ( line , options , dict ) { var word var codes var result var hash Offset var slash Offset 
function casing ( value ) { var head = exact ( value . char At ( 0 ) ) var rest = value . slice ( 1 ) if ( ! rest ) { return head } rest = exact ( rest ) if ( head = = = rest ) { return head } if ( head = = = 'u ' & & rest = = = 'l ' ) { return 's ' } return null } 
function apply ( value , rule , rules ) { var entries = rule . entries var words = [ ] var index = - 1 var length = entries . length var entry var next var continuation Rule var continuation var position var count while ( + + index < length ) { entry = entries [ index ] if ( ! entry . match | | value . match ( entry . match ) ) { next = value if ( entry . remove ) { next = next . replace ( entry . remove , ' ' ) } if ( rule . type = = = 'SFX ' ) { next + = entry . add } else { next = entry . add + next } words . push ( next ) continuation = entry . continuation if ( continuation & & continuation . length ! = = 0 ) { position = - 1 count = continuation . length while ( + + position < count ) { continuation Rule = rules [ continuation [ position ] ] if ( continuation Rule ) { words = words . concat ( apply ( next , continuation Rule , rules ) ) } } } } } return words } 
function spell ( word ) { var self = this var dict = self . data var flags = self . flags var value = form ( self , word , true ) 
function add ( buf ) { var self = this var compound = self . compound Rules var compound Codes = self . compound Rule Codes var index = - 1 var length = compound . length var rule var source var character var offset var count parse ( buf , self , self . data ) 
function exact ( context , value ) { var data = context . data var flags = context . flags var codes = own . call ( data , value ) ? data [ value ] : null var compound var index var length if ( codes ) { return ! flag ( flags , 'ONLYINCOMPOUND ' , codes ) } compound = context . compound Rules length = compound . length index = - 1 
function ( entry Path , attributes ) { if ( this . options . template Adapter Instance ) { this . template Adapter = this . options . template Adapter Instance ; } else { var template Adapter Module = attributes . template Adapter | | this . defaults . template Adapter , template Adapter Options = { entry Path : entry Path } , template Engine = require ( attributes . template Engine | | this . defaults . template Engine ) ; template Adapter Options = this . set Template Finder ( template Adapter Options ) ; this . template Adapter = require ( template Adapter Module ) ( template Adapter Options , template Engine ) ; } } 
function ( ) { var ret Val , parsed Options ; if ( this . model ) { ret Val = this . model . to JSON ( ) ; } else if ( this . collection ) { ret Val = { models : this . collection . to JSON ( ) , meta : this . collection . meta , params : this . collection . params } ; } 
function ( data ) { if ( this . app ) { data . _app = this . app ; } if ( this . model ) { data . _model = this . model ; } if ( this . collection ) { data . _collection = this . collection ; } data . _view = this ; return data ; } 
function ( ) { var attributes = { } , fetch Summary = { } , model Utils = this . app . model Utils , non Attribute Options = this . non Attribute Options ; if ( this . attributes ) { _ . extend ( attributes , _ . result ( this , 'attributes ' ) ) ; } if ( this . id ) { attributes . id = _ . result ( this , "id " ) ; } if ( this . class Name ) { attributes [ 'class ' ] = _ . result ( this , "class Name " ) ; } 
function ( ) { var template = this . get Template ( ) , data ; this . _pre Render ( ) ; data = this . get Template Data ( ) ; data = this . decorate Template Data ( data ) ; if ( template = = null ) { throw new Error ( this . name + " : template \ " " + this . get Template Name ( ) + " \ " not found . " ) ; } return template ( data ) ; } 
function ( ) { var html = this . get Inner Html ( ) , attributes = this . get Attributes ( ) , tag Name = _ . result ( this , "tag Name " ) , attr String ; attr String = _ . inject ( attributes , function ( memo , value , key ) { return memo + = " " + key + " = \ " " + _ . escape ( value ) + " \ " " ; } , ' ' ) ; return " < " + tag Name + attr String + " > " + html + " < / " + tag Name + " > " ; } 
function ( ) { var params = { } , fetch Options , fetch Spec ; if ( this . options . fetch _params ) { if ( ! _ . is Object ( this . options . fetch _params ) ) { throw new Error ( 'fetch _params must be an object for lazy loaded views ' ) ; } params = this . options . fetch _params ; } else if ( this . options . param _name ) { params [ this . options . param _name ] = this . options . param _value ; } if ( this . options . fetch _options ) { if ( ! _ . is Object ( this . options . fetch _options ) ) { throw new Error ( 'fetch _options must be an object for lazy loaded views ' ) ; } fetch Options = this . options . fetch _options ; } if ( this . options . model _id ! = null ) { params . id = this . options . model _id ; } if ( this . options . model _name ! = null ) { fetch Spec = { model : { model : this . options . model _name , params : params } } ; } else if ( this . options . collection _name ! = null ) { fetch Spec = { collection : { collection : this . options . collection _name , params : params } } ; } 
function ( callback ) { var _base View = this ; 
function get App Attributes ( attrs , req , res ) { if ( typeof attrs = = = 'function ' ) { attrs = attrs ( req , res ) ; } return attrs | | { } ; } 
function action Call ( action , params ) { action . call ( router , params , router . get Render Callback ( route ) ) ; } 
function ( pattern , controller , options ) { var real Action , action , handler , route , route Obj , router Context = this ; route = parse Route Definitions ( [ controller , options ] ) ; real Action = this . get Action ( route ) ; if ( is Server ) { action = real Action ; } else { action = function ( params , callback ) { var self = this ; var my Load Number = + + load Number ; function next ( ) { 
function ( view Path , locals , route ) { if ( typeof view Path ! = = 'string ' ) { locals = view Path ; view Path = route . controller + ' / ' + route . action ; } return [ view Path , locals ] ; } 
function marshal Public Key ( jwk ) { const byte Len = curve Lengths [ jwk . crv ] return Buffer . concat ( [ Buffer . from ( [ 4 ] ) , 
function unmarshal Public Key ( curve , key ) { const byte Len = curve Lengths [ curve ] if ( ! key . slice ( 0 , 1 ) . equals ( Buffer . from ( [ 4 ] ) ) ) { throw new Error ( 'Invalid key format ' ) } const x = new BN ( key . slice ( 1 , byte Len + 1 ) ) const y = new BN ( key . slice ( 1 + byte Len ) ) return { kty : 'EC ' , crv : curve , x : to Base 6 4 ( x , byte Len ) , y : to Base 6 4 ( y , byte Len ) , ext : true } } 
function pbkdf 2 ( password , salt , iterations , key Size , hash ) { const hasher = hash Name [ hash ] if ( ! hasher ) { throw new Error ( ` $ { hash } ` ) } const dek = forge Pbkdf 2 ( password , salt , iterations , key Size , hasher ) return forge Util . encode 6 4 ( dek ) } 
function get Raw Header ( _block ) { if ( typeof _block . difficulty ! = = 'string ' ) { _block . difficulty = ' 0x ' + _block . difficulty . to String ( 1 6 ) } const block = new Ethereum Block ( _block ) return block . header } 
function init Matic ( ) { if ( ! matic ) { matic = new Matic ( { matic Provider : process . env . MATIC _PROVIDER , parent Provider : process . env . PARENT _PROVIDER , root Chain Address : process . env . ROOTCHAIN _ADDRESS , matic Weth Address : process . env . MATIC _WETH _ADDRESS , syncer Url : process . env . SYNCER _URL , watcher Url : process . env . WATCHER _URL , withdraw Manager Address : process . env . WITHDRAWMANAGER _ADDRESS , } ) matic . wallet = ' <private -key > ' 
function match Path ( pathname , options = { } ) { if ( typeof options = = = 'string ' ) options = { path : options } ; const { path , exact = false , strict = false , sensitive = false } = options ; const paths = [ ] . concat ( path ) ; return paths . reduce ( ( matched , p ) = > { if ( matched ) return matched ; const { regexp , keys } = compile Path ( p , { end : exact , strict , sensitive } ) ; const match = regexp . exec ( pathname ) ; if ( ! match ) return null ; const [ url , . . . values ] = match ; const is Exact = pathname = = = url ; if ( exact & & ! is Exact ) return null ; return { path : p , 
function generated Reducer ( state = fn . default State , action ) { const builtin State = builtin Reducer ( state , action , page ) ; if ( builtin State ) return builtin State ; if ( Object . has Own Property . call ( fn , action . type ) & & typeof fn [ action . type ] = = = 'function ' ) { return produce ( state , ( draft ) = > { try { return fn [ action . type ] ( draft , action ) ; } catch ( e ) { if ( process . env . NODE _ENV ! = = 'production ' ) { throw e ; } console . error ( 'It "s called by rrc -loader -helper : ' + e ) ; send Error ( e ) ; return state ; } } ) ; } return state ; } 
function Redirect ( { computed Match , to , push = false } ) { return ( < Router Context . Consumer > { ( context ) = > { invariant ( context , 'You should not use <Redirect > outside a <Router > ' ) ; const { history , static Context } = context ; const method = push ? history . push : history . replace ; const location = create Location ( computed Match ? typeof to = = = 'string ' ? generate Path ( to , computed Match . params ) : { . . . to , pathname : generate Path ( to . pathname , computed Match . params ) } : to ) ; < / Router Context . Consumer > ) ; } 
function get Effect Log ( effect ) { let data , log if ( effect . root ) { data = effect . effect log = get Log Prefix ( 'run ' , effect ) log . formatter . add Call ( data . saga . name , data . args ) log Result ( effect , log . formatter ) } else if ( data = as Effect . take ( effect . effect ) ) { log = get Log Prefix ( 'take ' , effect ) log . formatter . add Value ( data ) log Result ( effect , log . formatter ) } else if ( data = as Effect . put ( effect . effect ) ) { log = get Log Prefix ( 'put ' , effect ) log Result ( Object . assign ( { } , effect , { result : data } ) , log . formatter ) } else if ( data = as Effect . call ( effect . effect ) ) { log = get Log Prefix ( 'call ' , effect ) log . formatter . add Call ( data . fn . name , data . args ) log Result ( effect , log . formatter ) } else if ( data = as Effect . cps ( effect . effect ) ) { log = get Log Prefix ( 'cps ' , effect ) log . formatter . add Call ( data . fn . name , data . args ) log Result ( effect , log . formatter ) } else if ( data = as Effect . fork ( effect . effect ) ) { if ( ! data . detached ) { log = get Log Prefix ( 'fork ' , effect ) } else { log = get Log Prefix ( 'spawn ' , effect ) } log . formatter . add Call ( data . fn . name , data . args ) log Result ( effect , log . formatter ) } else if ( data = as Effect . join ( effect . effect ) ) { log = get Log Prefix ( 'join ' , effect ) log Result ( effect , log . formatter ) } else if ( data = as Effect . race ( effect . effect ) ) { log = get Log Prefix ( 'race ' , effect ) log Result ( effect , log . formatter , true ) } else if ( data = as Effect . cancel ( effect . effect ) ) { log = get Log Prefix ( 'cancel ' , effect ) log . formatter . append Data ( data . name ) } else if ( data = as Effect . select ( effect . effect ) ) { log = get Log Prefix ( 'select ' , effect ) log . formatter . add Call ( data . selector . name , data . args ) log Result ( effect , log . formatter ) } else if ( is . array ( effect . effect ) ) { log = get Log Prefix ( 'parallel ' , effect ) log Result ( effect , log . formatter , true ) } else if ( is . iterator ( effect . effect ) ) { log = get Log Prefix ( ' ' , effect ) log . formatter . add Value ( effect . effect . name ) log Result ( effect , log . formatter , true ) } else { log = get Log Prefix ( 'unkown ' , effect ) log Result ( effect , log . formatter ) } return log } 
function object Is ( x , y ) { if ( x = = = y ) { return x ! = = 0 | | 1 / x = = = 1 / y ; } return x ! = = x & & y ! = = y ; } 
function entities ( state = { users : { } , repos : { } } , action ) { if ( action . response & & action . response . entities ) { return merge ( { } , state , action . response . entities ) } return state } 
function error Message ( state = null , action ) { const { type , error } = action if ( type = = = Action Types . RESET _ERROR _MESSAGE ) { return null } else if ( error ) { return action . error } return state } 
function fork Queue ( name , main Task , cb ) { let tasks = [ ] , result , completed = false add Task ( main Task ) function abort ( err ) { cancel All ( ) cb ( err , true ) } function add Task ( task ) { tasks . push ( task ) task . cont = ( res , is Err ) = > { if ( completed ) { return } remove ( tasks , task ) task . cont = noop if ( is Err ) { abort ( res ) } else { if ( task = = = main Task ) { result = res } if ( ! tasks . length ) { completed = true cb ( result ) } } } 
function cancel Main ( ) { if ( main Task . is Running & & ! main Task . is Cancelled ) { main Task . is Cancelled = true next ( TASK _CANCEL ) } } 
function cancel ( ) { if ( iterator . _is Running & & ! iterator . _is Cancelled ) { iterator . _is Cancelled = true task Queue . cancel All ( ) end ( TASK _CANCEL ) } } 
function next ( arg , is Err ) { getting TASK _CANCEL automatically cancels the main task We can get this value here - By cancelling the parent task manually - By joining a Cancelled task * * / main Task . is Cancelled = true next . cancel ( ) result = is . func ( iterator . return ) ? iterator . return ( TASK _CANCEL ) : { done : true , value : TASK _CANCEL } } else if ( arg = = = CHANNEL _END ) { This Generator has ended , terminate the main task and notify the fork queue * * / main Task . is Main Running = false main Task . cont & & main Task . cont ( result . value ) } } catch ( error ) { if ( main Task . is Cancelled ) { log Error ( error ) } main Task . is Main Running = false main Task . cont ( error , true ) } } 
function curr Cb ( res , is Err ) { if ( effect Settled ) { return } effect Settled = true cb . cancel = noop 
function do Set Attribute ( el , props , prop Name ) { if ( prop Name = = = 'class Name ' ) { el . set Attribute ( 'class ' , props . class Name ) ; } else if ( props [ prop Name ] & & props [ prop Name ] . constructor = = = Function ) { return ; } else { el . set Attribute ( prop Name , props [ prop Name ] ) ; } } 
function update Attributes ( el , prev Props , props ) { var prop Name ; if ( ! props | | prev Props = = = props ) { return ; } 
function component Did Update ( prev Props , prev State ) { var el = this . el ; var props = this . props ; 
function update Event Listeners ( el , prev Events , events ) { var event Name ; if ( ! prev Events | | ! events | | prev Events = = = events ) { return ; } for ( event Name in events ) { 
function add Event Listeners ( el , event Name , handlers ) { var handler ; var i ; if ( ! handlers ) { return ; } 
function remove Event Listeners ( el , event Name , handlers ) { var handler ; var i ; if ( ! handlers ) { return ; } 
function make Hooks Safe ( routes , store ) { if ( Array . is Array ( routes ) ) { return routes . map ( route = > make Hooks Safe ( route , store ) ) ; } const on Enter = routes . on Enter ; if ( on Enter ) { routes . on Enter = function safe On Enter ( . . . args ) { try { store . get State ( ) ; } catch ( err ) { if ( on Enter . length = = = 3 ) { args [ 2 ] ( ) ; } 
function wait For Ping ( ) { function ping Listener ( evt ) { if ( evt . data . source = = = 'mobx -devtools -content -script ' & & evt . data . payload = = = 'backend :ping ' ) { debug Connection ( ' [content Script - > BACKEND ] ' , evt ) ; const content Script Id = evt . data . content Script Id ; window . remove Event Listener ( 'message ' , ping Listener ) ; clear Timeout ( handshake Failed Timeout ) ; const payload = 'content Script :pong ' ; debug Connection ( ' [content Script - > BACKEND ] ' , payload ) ; window . post Message ( { source : 'mobx -devtools -backend ' , payload , content Script Id , backend Id } , ' * ' ) ; const hello Listener = ( e ) = > { if ( e . data . source = = = 'mobx -devtools -content -script ' & & e . data . payload = = = 'backend :hello ' & & e . data . content Script Id = = = content Script Id & & e . data . backend Id = = = backend Id ) { debug Connection ( ' [content Script - > BACKEND ] ' , e ) ; window . remove Event Listener ( 'message ' , hello Listener ) ; window . remove Event Listener ( 'message ' , fail Listener ) ; 
function auth ( req ) { if ( ! req ) { throw new Type Error ( 'argument req is required ' ) } if ( typeof req ! = = 'object ' ) { throw new Type Error ( 'argument req is required to be an object ' ) } 
function get Authorization ( req ) { if ( ! req . headers | | typeof req . headers ! = = 'object ' ) { throw new Type Error ( 'argument req is required to have headers property ' ) } return req . headers . authorization } 
function parse ( string ) { if ( typeof string ! = = 'string ' ) { return undefined } 
function install ( cef _version ) { download Cef ( cef _version , function ( err ) { if ( err ) { util . log ( 'Failed to add dependencies ' , 'error ' ) ; throw err ; } copy Dll Wrapper ( function ( err ) { if ( err ) { util . log ( 'Failed to copy dll _wrapper .gyp ' ) ; throw err ; } util . log ( 'Done ! ' ) ; } ) ; } ) ; } 
function download Cef ( version , cb ) { var zlib = require ( 'zlib ' ) , tar = require ( 'tar ' ) , dist Url = 'https : / /github .com /downloads /appjs /appjs ' , version = version , dirname = 'cef _binary _ ' + version + ' _ ' + platform + ' _ ' + arch , file Name = dirname + ' .tar .gz ' ; var tarball Url = dist Url + ' / ' + file Name , gunzip = zlib . create Gunzip ( ) , extracter = tar . Extract ( { path : deps Dir } ) ; var error Handler = function ( err , res ) { if ( err | | res . status Code ! = 2 0 0 ) { cb ( err | | new Error ( res . status Code + ' status code downloading tarball ' ) ) ; } } ; var finish = function ( ) { if ( platform = = 'win 3 2 ' ) { try { fs . rmdir Sync ( path . join ( deps Dir , 'cef ' ) ) ; } catch ( e ) { } ; fs . rename ( path . join ( deps Dir , dirname ) , path . join ( deps Dir , 'cef ' ) , cb ) ; } else { try { fs . unlink Sync ( path . join ( deps Dir , 'cef ' ) ) ; } catch ( e ) { } ; fs . symlink ( path . join ( deps Dir , dirname ) , path . join ( deps Dir , 'cef ' ) , cb ) ; } } ; gunzip . on ( 'error ' , error Handler ) extracter . on ( 'error ' , error Handler ) extracter . on ( 'end ' , finish ) fs . exists ( path . join ( deps Dir , dirname ) , function ( exists ) { if ( ! exists ) { download ( tarball Url , error Handler ) . pipe ( gunzip ) . pipe ( extracter ) ; } else { finish ( ) ; } } ) ; } 
function download ( url , on Error ) { var request = require ( 'request ' ) ; util . log ( 'Downloading cef tarball for ' + platform + ' - ' + arch + ' . . . ' ) ; var request Opts = { uri : url , on Response : true } 
function ( options ) { var noop = function ( ) { } ; this . is Cordova App = options . is Cordova App ; this . real Url = options . real Url ; this . file = options . file ; this . content Type = options . content Type | | this . file . type | | 'application /octet -stream ' ; this . metadata = options . metadata | | { 'title ' : this . file . name , 'mime Type ' : this . content Type } ; this . token = options . token ; this . on Complete = options . on Complete | | noop ; this . on Progress = options . on Progress | | noop ; this . on Error = options . on Error | | noop ; this . offset = options . offset | | 0 ; this . chunk Size = options . chunk Size | | 0 ; this . retry Handler = new Retry Handler ( ) ; this . url = options . url ; if ( ! this . url ) { var params = options . params | | { } ; 
function ( element , options ) { this . $element = $ ( element ) this . options = $ . extend ( { } , $ . fn . carousel . defaults , options ) this . options . slide & & this . slide ( this . options . slide ) this . options . pause = = 'hover ' & & this . $element . on ( 'mouseenter ' , $ . proxy ( this . pause , this ) ) . on ( 'mouseleave ' , $ . proxy ( this . cycle , this ) ) } 
function check Glob ( filename , globs ) { 
function get CORSRequest ( ) { var xhr = new root . XMLHttp Request ( ) ; if ( 'with Credentials ' in xhr ) { xhr . with Credentials = this . with Credentials ? true : false ; return xhr ; } else if ( ! ! root . XDomain Request ) { return new XDomain Request ( ) ; } else { throw new Error ( 'CORS is not supported by your browser ' ) ; } } 
function get Reply Method ( request ) { let target = find Target From Parent Info ( request ) ; if ( target ) { return ( . . . a ) = > { if ( 'is Destroyed ' in target & & target . is Destroyed ( ) ) return ; target . send ( . . . a ) ; } ; } else { d ( "Using reply to main process " ) ; return ( . . . a ) = > ipc . send ( . . . a ) ; } } 
function listen To Ipc ( channel ) { return Observable . create ( ( subj ) = > { let listener = ( event , . . . args ) = > { d ( ` $ { channel } $ { JSON . stringify ( args ) } ` ) ; subj . next ( args ) ; } ; d ( ` $ { channel } ` ) ; ipc . on ( channel , listener ) ; return new Subscription ( ( ) = > ipc . remove Listener ( channel , listener ) ) ; } ) ; } 
function get Send Method ( window Or Web View ) { if ( ! window Or Web View ) return ( . . . a ) = > ipc . send ( . . . a ) ; if ( 'web Contents ' in window Or Web View ) { return ( . . . a ) = > { d ( ` $ { JSON . stringify ( a ) } ` ) ; if ( ! window Or Web View . web Contents . is Destroyed ( ) ) { window Or Web View . web Contents . send ( . . . a ) ; } else { throw new Error ( ` ` ) ; } } ; } else { return ( . . . a ) = > { d ( ` $ { JSON . stringify ( a ) } ` ) ; window Or Web View . send ( . . . a ) ; } ; } } 
function listener For Id ( id , timeout ) { return listen To Ipc ( response Channel ) . do ( ( [ x ] ) = > d ( ` $ { x . id } $ { id } $ { JSON . stringify ( x ) } ` ) ) . filter ( ( [ receive ] ) = > receive . id = = = id & & id ) . take ( 1 ) . merge Map ( ( [ receive ] ) = > { if ( receive . error ) { let e = new Error ( receive . error . message ) ; e . stack = receive . error . stack ; return Observable . throw ( e ) ; } return Observable . of ( receive . result ) ; } ) . timeout ( timeout ) ; } 
function find Target From Parent Info ( parent Info = window . parent Info ) { if ( ! parent Info ) return null ; if ( 'guest Instance Id ' in parent Info ) { return require ( 'electron ' ) . remote . get Guest Web Contents ( parent Info . guest Instance Id ) ; } if ( 'web Contents Id ' in parent Info ) { return web Contents . from Id ( parent Info . web Contents Id ) ; } return null ; } 
function object And Parent Given Path ( path ) { let obj = global | | window ; let parent = obj ; for ( let part of path . split ( ' . ' ) ) { parent = obj ; obj = obj [ part ] ; } d ( ` $ { parent } $ { obj } ` ) ; if ( typeof ( parent ) ! = = 'object ' ) { throw new Error ( ` $ { path } ` ) ; } return [ parent , obj ] ; } 
async function eval Remote Method ( path , args ) { let [ parent , obj ] = object And Parent Given Path ( path ) ; let result = obj ; if ( obj & & typeof ( obj ) = = = 'function ' ) { d ( "obj is function ! " ) ; let res = obj . apply ( parent , args ) ; result = res ; if ( typeof ( res ) = = = 'object ' & & res & & 'then ' in res ) { d ( "result is Promise ! " ) ; result = await res ; } } return result ; } 
function execute Main Process Method ( module Name , method Chain , args ) { const the Module = electron [ module Name ] ; const path = method Chain . join ( ' . ' ) ; return get ( the Module , path ) . apply ( the Module , args ) ; } 
function fix ( a , b ) { if ( ! a | | ! b ) { return a ; } for ( let k in b ) { 
function ( str , gga ) { if ( gga . length ! = = 1 6 ) { throw new Error ( 'Invalid GGA length : ' + str ) ; } return { 'time ' : parse Time ( gga [ 1 ] ) , 'lat ' : parse Coord ( gga [ 2 ] , gga [ 3 ] ) , 'lon ' : parse Coord ( gga [ 4 ] , gga [ 5 ] ) , 'alt ' : parse Dist ( gga [ 9 ] , gga [ 1 0 ] ) , 'quality ' : parse GGAFix ( gga [ 6 ] ) , 'satellites ' : parse Number ( gga [ 7 ] ) , 'hdop ' : parse Number ( gga [ 8 ] ) , 
function ( str , gsa ) { if ( gsa . length ! = = 1 9 & & gsa . length ! = = 2 0 ) { throw new Error ( 'Invalid GSA length : ' + str ) ; } var sats = [ ] ; for ( var i = 3 ; i < 1 5 ; i + + ) { if ( gsa [ i ] ! = = ' ' ) { sats . push ( parse Int ( gsa [ i ] , 1 0 ) ) ; } } return { 'mode ' : parse GSAMode ( gsa [ 1 ] ) , 'fix ' : parse GSAFix ( gsa [ 2 ] ) , 'satellites ' : sats , 'pdop ' : parse Number ( gsa [ 1 5 ] ) , 'hdop ' : parse Number ( gsa [ 1 6 ] ) , 'vdop ' : parse Number ( gsa [ 1 7 ] ) , 'system Id ' : gsa . length > 1 9 ? parse Number ( gsa [ 1 8 ] ) : null } ; } 
function ( str , rmc ) { if ( rmc . length ! = = 1 3 & & rmc . length ! = = 1 4 & & rmc . length ! = = 1 5 ) { throw new Error ( 'Invalid RMC length : ' + str ) ; } return { 'time ' : parse Time ( rmc [ 1 ] , rmc [ 9 ] ) , 'status ' : parse RMC _GLLStatus ( rmc [ 2 ] ) , 'lat ' : parse Coord ( rmc [ 3 ] , rmc [ 4 ] ) , 'lon ' : parse Coord ( rmc [ 5 ] , rmc [ 6 ] ) , 'speed ' : parse Knots ( rmc [ 7 ] ) , 'track ' : parse Number ( rmc [ 8 ] ) , 
function ( str , vtg ) { if ( vtg . length ! = = 1 0 & & vtg . length ! = = 1 1 ) { throw new Error ( 'Invalid VTG length : ' + str ) ; } if ( vtg [ 2 ] = = = ' ' & & vtg [ 8 ] = = = ' ' & & vtg [ 6 ] = = = ' ' ) { return { 'track ' : null , 'track Magetic ' : null , 'speed ' : null , 'faa ' : null } ; } if ( vtg [ 2 ] ! = = 'T ' ) { throw new Error ( 'Invalid VTG track mode : ' + str ) ; } if ( vtg [ 8 ] ! = = 'K ' | | vtg [ 6 ] ! = = 'N ' ) { throw new Error ( 'Invalid VTG speed tag : ' + str ) ; } return { 'track ' : parse Number ( vtg [ 1 ] ) , 
function ( str , gsv ) { if ( gsv . length % 4 % 3 = = = 0 ) { throw new Error ( 'Invalid GSV length : ' + str ) ; } var sats = [ ] ; for ( var i = 4 ; i < gsv . length - 3 ; i + = 4 ) { var prn = parse Number ( gsv [ i ] ) ; var snr = parse Number ( gsv [ i + 3 ] ) ; sats . push ( { 'prn ' : prn , 'elevation ' : parse Number ( gsv [ i + 1 ] ) , 'azimuth ' : parse Number ( gsv [ i + 2 ] ) , 'snr ' : snr , 'status ' : prn ! = = null ? ( snr ! = = null ? 'tracking ' : 'in view ' ) : null } ) ; } return { 'msg Number ' : parse Number ( gsv [ 2 ] ) , 'msgs Total ' : parse Number ( gsv [ 1 ] ) , 
function ( str , gll ) { if ( gll . length ! = = 9 & & gll . length ! = = 8 ) { throw new Error ( 'Invalid GLL length : ' + str ) ; } return { 'time ' : parse Time ( gll [ 5 ] ) , 'status ' : parse RMC _GLLStatus ( gll [ 6 ] ) , 'lat ' : parse Coord ( gll [ 1 ] , gll [ 2 ] ) , 'lon ' : parse Coord ( gll [ 3 ] , gll [ 4 ] ) , 'faa ' : gll . length = = = 9 ? parse FAA ( gll [ 7 ] ) : null } ; } 
function type At Offset ( base Type : any , offset Field Name : string ) : any { return j Binary . Template ( { base Type : base Type , read : function ( context ) { if ( + context [ offset Field Name ] = = = 0 ) { return null ; } else { return this . binary . read ( this . base Type , + context [ offset Field Name ] ) ; } } } ) ; } 
function tuple Less Or Equal ( t 1 : Array < number > , t 2 : Array < number > ) : boolean { if ( t 1 . length ! = t 2 . length ) throw new Error ( 'Comparing non -equal length tuples ' ) ; for ( var i = 0 ; i < t 1 . length ; i + + ) { if ( t 1 [ i ] > t 2 [ i ] ) { return false ; } else if ( t 1 [ i ] < t 2 [ i ] ) { return true ; } } return true ; } 
function tuple Range Overlaps ( tuple Range 1 : Array < Array < number > > , tuple Range 2 : Array < Array < number > > ) : boolean { return ( 
function concat Array Buffers ( buffers : Array Buffer [ ] ) : Array Buffer { var total Bytes = buffers . map ( b = > b . byte Length ) . reduce ( ( a , b ) = > a + b , 0 ) ; var output = new Uint 8Array ( total Bytes ) ; var position = 0 ; buffers . for Each ( buf = > { output . set ( new Uint 8Array ( buf ) , position ) ; position + = buf . byte Length ; } ) ; return output . buffer ; } 
function parse Bed Feature ( f ) : Gene { var position = new Contig Interval ( f . contig , f . start , f . stop ) , x = f . rest . split ( ' \t ' ) ; 
function is Alignment In Range ( read : Sam Read , idx Range : Contig Interval < number > , contained : boolean ) : boolean { 
function read Alignments To End ( buffer : Array Buffer , ref Name : string , idx Range : Contig Interval < number > , contained : boolean , offset : Virtual Offset , blocks : Inflated Block [ ] , alignments : Sam Read [ ] ) { 
function fetch Alignments ( remote File : Remote File , ref Name : string , idx Range : Contig Interval < number > , contained : boolean , chunks : Chunk [ ] ) : Q . Promise < Sam Read [ ] > { var num Requests = 0 , alignments = [ ] , deferred = Q . defer ( ) ; function fetch ( chunks : Chunk [ ] ) { if ( chunks . length = = = 0 ) { deferred . resolve ( alignments ) ; return ; } 
function y For Row ( row : number , height : number = style . READ _HEIGHT , spacing : number = style . READ _SPACING ) : number { return ( row * ( height + spacing ) ) ; } 
function pileup ( reads : Interval [ ] ) : number [ ] { var rows = new Array ( reads . length ) , last Reads = [ ] ; 
function add To Pileup ( read : Interval , pileup : Array < Interval [ ] > ) : number { var chosen Row = - 1 ; for ( var i = 0 ; i < pileup . length ; i + + ) { var reads = pileup [ i ] ; var ok = true ; for ( var j = 0 ; j < reads . length ; j + + ) { if ( reads [ j ] . intersects ( read ) ) { ok = false ; break ; } } if ( ok ) { chosen Row = i ; break ; } } if ( chosen Row = = - 1 ) { chosen Row = pileup . length ; pileup [ chosen Row ] = [ ] ; 
function get Arrow Index ( read : Alignment ) : number { var i , op , ops = read . cigar Ops ; if ( read . get Strand ( ) = = ' - ' ) { for ( i = 0 ; i < ops . length ; i + + ) { op = ops [ i ] ; if ( op . op = = 'S ' ) continue ; if ( op . op = = 'M ' ) return i ; return - 1 ; } } else { for ( i = ops . length - 1 ; i > = 0 ; i - - ) { op = ops [ i ] ; if ( op . op = = 'S ' ) continue ; if ( op . op = = 'M ' ) return i ; return - 1 ; } } return - 1 ; } 
function make Cigar String ( cigar Ops : Array < Cigar Op > ) { return cigar Ops . map ( ( { op , length } ) = > length + op ) . join ( ' ' ) ; } 
function compute Index Chunks ( buffer ) { var BLOCK _SIZE = 6 5 5 3 6 ; var view = new j Data View ( buffer , 0 , buffer . byte Length , true ) ; var min Block Index = Infinity ; var contig Start Offsets = [ ] ; view . get Int 3 2 ( ) ; 
function optimize Chunk List ( chunk List : Chunk [ ] , minimum Offset : Virtual Offset ) : Chunk [ ] { chunk List . sort ( ( a , b ) = > { var result = a . chunk _beg . compare To ( b . chunk _beg ) ; if ( result = = = 0 ) { result = a . chunk _end . compare To ( b . chunk _end ) ; } return result ; } ) ; var new Chunks = [ ] ; chunk List . for Each ( chunk = > { if ( chunk . chunk _end . is Less Than ( minimum Offset ) ) { return ; 
function parse Sequence Record ( buffer : Array Buffer , file Offset : number ) : Sequence Record { var jb = new j Binary ( buffer , two Bit Types . TYPE _SET ) ; var header = jb . read ( 'Sequence Record ' ) ; var dna Offset = jb . tell ( ) + 8 * header . mask Block Count + 4 ; return { num Bases : header . dna Size , unknown Block Starts : header . n Block Starts , unknown Block Lengths : header . n Block Sizes , num Mask Blocks : header . mask Block Count , mask Block Starts : [ ] , mask Block Lengths : [ ] , dna Offset From Header : dna Offset , offset : file Offset } ; } 
function TEXT _STYLE ( mode : number , font Size : number ) : string { if ( mode = = Display Mode . LOOSE ) { return ` $ { font Size } ` ; } else if ( mode = = Display Mode . TIGHT ) { return ` $ { font Size } ` ; } else { return ` $ { font Size } ` ; } } 
function create DTrace ( name ) { 
function has Props And Vals ( obj , kv ) { if ( typeof ( obj ) ! = = 'object ' | | typeof ( kv ) ! = = 'object ' ) { return ( false ) ; } if ( Object . keys ( kv ) . length = = = 0 ) { return ( true ) ; } return ( Object . keys ( kv ) . every ( function ( k ) { return ( obj [ k ] & & obj [ k ] = = = kv [ k ] ) ; } ) ) ; } 
function register Runner ( runner _id , active _at , callback ) { if ( typeof ( active _at ) = = = 'function ' ) { callback = active _at ; active _at = new Date ( ) ; } if ( typeof ( active _at ) = = = 'string ' ) { active _at = new Date ( active _at ) ; } runners [ runner _id ] = { runner _id : runner _id , active _at : active _at , idle : false } ; return callback ( null ) ; } 
function create Workflow ( workflow , meta , callback ) { if ( typeof ( meta ) = = = 'function ' ) { callback = meta ; meta = { } ; } if ( _wf Names ( ) . index Of ( workflow . name ) ! = = - 1 ) { return callback ( new e . Backend Invalid Argument Error ( 'Workflow .name must be unique . A workflow with name " ' + workflow . name + ' " already exists ' ) ) ; } else { workflows [ workflow . uuid ] = clone ( workflow ) ; return callback ( null , workflow ) ; } } 
function get Workflow ( uuid , meta , callback ) { if ( typeof ( meta ) = = = 'function ' ) { callback = meta ; meta = { } ; } if ( workflows [ uuid ] ) { return callback ( null , clone ( workflows [ uuid ] ) ) ; } else { return callback ( new e . Backend Resource Not Found Error ( sprintf ( 'Workflow with uuid \ ' %s \ ' does not exist ' , uuid ) ) ) ; } } 
function delete Workflow ( workflow , meta , callback ) { if ( typeof ( meta ) = = = 'function ' ) { callback = meta ; meta = { } ; } if ( workflows [ workflow . uuid ] ) { return callback ( null , ( delete workflows [ workflow . uuid ] ) ) ; } else { return callback ( null , false ) ; } } 
function update Workflow ( workflow , meta , callback ) { if ( typeof ( meta ) = = = 'function ' ) { callback = meta ; meta = { } ; } if ( workflows [ workflow . uuid ] ) { if ( _wf Names ( ) . index Of ( workflow . name ) ! = = - 1 & & workflows [ workflow . uuid ] . name ! = = workflow . name ) { return callback ( new e . Backend Invalid Argument Error ( 'Workflow .name must be unique . A workflow with name " ' + workflow . name + ' " already exists ' ) ) ; } else { workflows [ workflow . uuid ] = clone ( workflow ) ; return callback ( null , workflow ) ; } } else { return callback ( new e . Backend Resource Not Found Error ( 'Workflow does not exist . Cannot Update . ' ) ) ; } } 
function create Job ( job , meta , callback ) { if ( typeof ( meta ) = = = 'function ' ) { callback = meta ; meta = { } ; } job . created _at = job . created _at | | new Date ( ) . to ISOString ( ) ; jobs [ job . uuid ] = clone ( job ) ; queued _jobs . push ( job . uuid ) ; if ( typeof ( job . locks ) ! = = 'undefined ' ) { locked _targets [ job . uuid ] = job . locks ; } return callback ( null , job ) ; } 
function ( uuid , prop , cb ) { if ( jobs [ uuid ] ) { return cb ( null , jobs [ uuid ] [ prop ] ) ; } else { return cb ( new e . Backend Resource Not Found Error ( sprintf ( 'Job with uuid \ ' %s \ ' does not exist ' , uuid ) ) ) ; } } 
function validate Job Target ( job , callback ) { 
function next Job ( index , callback ) { if ( typeof ( index ) = = = 'function ' ) { callback = index ; index = 0 ; } if ( queued _jobs . length = = = 0 ) { return callback ( null , null ) ; } var slice = queued _jobs . slice ( index , index + 1 ) ; if ( slice . length = = = 0 ) { return callback ( null , null ) ; } else { return get Job ( slice [ 0 ] , callback ) ; } } 
function run Job ( uuid , runner _id , callback ) { var idx = queued _jobs . index Of ( uuid ) ; if ( idx = = = - 1 ) { return callback ( new e . Backend Precondition Failed Error ( 'Only queued jobs can be run ' ) ) ; } else { queued _jobs . splice ( idx , 1 ) ; jobs [ uuid ] . runner _id = runner _id ; jobs [ uuid ] . execution = 'running ' ; return callback ( null , clone ( jobs [ uuid ] ) ) ; } } 
function finish Job ( job , callback ) { if ( ! jobs [ job . uuid ] ) { return callback ( new e . Backend Resource Not Found Error ( sprintf ( 'Job with uuid \ ' %s \ ' does not exist ' , job . uuid ) ) ) ; } else if ( jobs [ job . uuid ] . execution ! = = 'running ' & & jobs [ job . uuid ] . execution ! = = 'canceled ' ) { return callback ( new e . Backend Precondition Failed Error ( 'Only running jobs can be finished ' ) ) ; } else { if ( job . execution = = = 'running ' ) { job . execution = 'succeeded ' ; } var info = jobs [ job . uuid ] . info ; job . runner _id = null ; jobs [ job . uuid ] = clone ( job ) ; if ( info ) { jobs [ job . uuid ] . info = info ; } if ( typeof ( job . locks ) ! = = 'undefined ' ) { delete locked _targets [ job . uuid ] ; } return callback ( null , job ) ; } } 
function update Job ( job , meta , callback ) { if ( typeof ( meta ) = = = 'function ' ) { callback = meta ; meta = { } ; } if ( ! jobs [ job . uuid ] ) { return callback ( new e . Backend Resource Not Found Error ( sprintf ( 'Job with uuid \ ' %s \ ' does not exist ' , job . uuid ) ) ) ; } else { jobs [ job . uuid ] = clone ( job ) ; return callback ( null , job ) ; } } 
function cancel Job ( uuid , cb ) { if ( typeof ( uuid ) = = = 'undefined ' ) { return cb ( new e . Backend Internal Error ( 'cancel Job uuid (String ) required ' ) ) ; } jobs [ uuid ] . execution = 'canceled ' ; delete jobs [ uuid ] . runner _id ; if ( typeof ( jobs [ uuid ] . locks ) ! = = 'undefined ' ) { delete locked _targets [ uuid ] ; } return cb ( null , jobs [ uuid ] ) ; } 
function update Job Property ( uuid , prop , val , meta , callback ) { if ( typeof ( meta ) = = = 'function ' ) { callback = meta ; meta = { } ; } if ( ! jobs [ uuid ] ) { return callback ( new e . Backend Resource Not Found Error ( sprintf ( 'Job with uuid \ ' %s \ ' does not exist ' , uuid ) ) ) ; } else { jobs [ uuid ] [ prop ] = val ; return callback ( null ) ; } } 
function queue Job ( job , callback ) { if ( ! jobs [ job . uuid ] ) { return callback ( new e . Backend Resource Not Found Error ( sprintf ( 'Job with uuid \ ' %s \ ' does not exist ' , job . uuid ) ) ) ; } else if ( jobs [ job . uuid ] . execution ! = = 'running ' ) { return callback ( new e . Backend Precondition Failed Error ( 'Only running jobs can be queued again ' ) ) ; } else { job . runner _id = null ; job . execution = 'queued ' ; jobs [ job . uuid ] = clone ( job ) ; queued _jobs . push ( job . uuid ) ; return callback ( null , job ) ; } } 
function pause Job ( job , callback ) { if ( ! jobs [ job . uuid ] ) { return callback ( new e . Backend Resource Not Found Error ( sprintf ( 'Job with uuid \ ' %s \ ' does not exist ' , job . uuid ) ) ) ; } else if ( jobs [ job . uuid ] . execution ! = = 'running ' ) { return callback ( new e . Backend Precondition Failed Error ( 'Only running jobs can be paused ' ) ) ; } else { job . runner _id = null ; job . execution = 'waiting ' ; jobs [ job . uuid ] = clone ( job ) ; waiting _jobs . push ( job . uuid ) ; return callback ( null , job ) ; } } 
function resume Job ( job , callback ) { if ( ! jobs [ job . uuid ] ) { return callback ( new e . Backend Resource Not Found Error ( sprintf ( 'Job with uuid \ ' %s \ ' does not exist ' , job . uuid ) ) ) ; } else if ( jobs [ job . uuid ] . execution ! = = 'waiting ' ) { return callback ( new e . Backend Precondition Failed Error ( 'Only waiting jobs can be resumed ' ) ) ; } else { job . runner _id = null ; job . execution = 'queued ' ; jobs [ job . uuid ] = clone ( job ) ; waiting _jobs = waiting _jobs . filter ( function ( j ) { return ( j ! = = job . uuid ) ; } ) ; queued _jobs . push ( job . uuid ) ; return callback ( null , job ) ; } } 
function next Jobs ( start , stop , callback ) { if ( queued _jobs . length = = = 0 ) { return callback ( null , null ) ; } var slice = queued _jobs . slice ( start , stop + 1 ) ; if ( slice . length = = = 0 ) { return callback ( null , null ) ; } else { return callback ( null , slice ) ; } } 
function get Runner ( runner _id , callback ) { if ( ! runners [ runner _id ] ) { return callback ( new e . Backend Resource Not Found Error ( sprintf ( 'Runner with uuid \ ' %s \ ' does not exist ' , runner _id ) ) ) ; } else { return callback ( null , runners [ runner _id ] . active _at ) ; } } 
function get Runners ( callback ) { var the Runners = { } ; Object . keys ( runners ) . for Each ( function ( uuid ) { the Runners [ uuid ] = runners [ uuid ] . active _at ; } ) ; return callback ( null , the Runners ) ; } 
function idle Runner ( runner _id , callback ) { if ( ! runners [ runner _id ] ) { return callback ( new e . Backend Resource Not Found Error ( sprintf ( 'Runner with uuid \ ' %s \ ' does not exist ' , runner _id ) ) ) ; } else { runners [ runner _id ] . idle = true ; return callback ( null ) ; } } 
function is Runner Idle ( runner _id , callback ) { if ( ! runners [ runner _id ] | | ( runners [ runner _id ] . idle = = = true ) ) { return callback ( true ) ; } else { return callback ( false ) ; } } 
function wake Up Runner ( runner _id , callback ) { if ( ! runners [ runner _id ] ) { return callback ( new e . Backend Resource Not Found Error ( sprintf ( 'Runner with uuid \ ' %s \ ' does not exist ' , runner _id ) ) ) ; } else { runners [ runner _id ] . idle = false ; return callback ( null ) ; } } 
function get Runner Jobs ( runner _id , callback ) { var wf _runner _jobs = Object . keys ( jobs ) . filter ( function ( uuid ) { return jobs [ uuid ] . runner _id = = = runner _id ; } ) ; return callback ( null , wf _runner _jobs ) ; } 
function get Workflows ( params , callback ) { if ( typeof ( params ) = = = 'function ' ) { callback = params ; params = { } ; } var wfs = [ ] ; var r Workflows = Object . keys ( workflows ) . map ( function ( uuid ) { return clone ( workflows [ uuid ] ) ; } ) ; r Workflows . for Each ( function ( wf ) { if ( has Props And Vals ( wf , params ) ) { wfs . push ( wf ) ; } } ) ; return callback ( null , wfs ) ; } 
function get Jobs ( params , callback ) { var executions = [ 'queued ' , 'failed ' , 'succeeded ' , 'canceled ' , 'running ' , 'retried ' , 'waiting ' ] ; var execution ; var offset ; var limit ; var r Jobs = [ ] ; var the Jobs = [ ] ; if ( typeof ( params ) = = = 'object ' ) { execution = params . execution ; delete params . execution ; offset = params . offset ; delete params . offset ; limit = params . limit ; delete params . limit ; } if ( typeof ( params ) = = = 'function ' ) { callback = params ; params = { } ; } if ( ( typeof ( execution ) ! = = 'undefined ' ) & & ( executions . index Of ( execution ) = = = - 1 ) ) { return callback ( new e . Backend Invalid Argument Error ( 'excution is required and must be one of " ' + executions . join ( ' " , " ' ) + ' " ' ) ) ; } if ( typeof ( execution ) ! = = 'undefined ' ) { r Jobs = Object . keys ( jobs ) . filter ( function ( uuid ) { return ( jobs [ uuid ] . execution = = = execution ) ; } ) . map ( function ( uuid ) { return clone ( jobs [ uuid ] ) ; } ) ; } else { r Jobs = Object . keys ( jobs ) . map ( function ( uuid ) { return clone ( jobs [ uuid ] ) ; } ) ; } r Jobs . for Each ( function ( job ) { if ( has Props And Vals ( job . params , params ) ) { the Jobs . push ( job ) ; } } ) ; if ( typeof ( offset ) ! = = 'undefined ' & & typeof ( limit ) ! = = 'undefined ' ) { return callback ( null , the Jobs . slice ( offset , limit ) ) ; } else { return callback ( null , the Jobs ) ; } } 
function add Info ( uuid , info , meta , callback ) { if ( typeof ( meta ) = = = 'function ' ) { callback = meta ; meta = { } ; } if ( ! jobs [ uuid ] ) { return callback ( new e . Backend Resource Not Found Error ( 'Job does not exist . Cannot Update . ' ) ) ; } else { if ( ! util . is Array ( jobs [ uuid ] . info ) ) { jobs [ uuid ] . info = [ ] ; } jobs [ uuid ] . info . push ( info ) ; return callback ( null ) ; } } 
function get Info ( uuid , meta , callback ) { if ( typeof ( meta ) = = = 'function ' ) { callback = meta ; meta = { } ; } if ( ! jobs [ uuid ] ) { return callback ( new e . Backend Resource Not Found Error ( 'Job does not exist . Cannot get info . ' ) ) ; } else { if ( ! util . is Array ( jobs [ uuid ] . info ) ) { jobs [ uuid ] . info = [ ] ; } return callback ( null , clone ( jobs [ uuid ] . info ) ) ; } } 
function ( el , ordinal ) { var $el = $ ( el ) ; if ( $el . data ( 'popup -visible ' ) ) return ; / / Initialize if not initialized . Required for : $ ( ' #popup ' ) .popup ( 'show ' ) if ( ! $el . data ( 'popup -initialized ' ) ) { methods . _init ( el ) ; } $el . attr ( 'data -popup -initialized ' , 'true ' ) ; var $body = $ ( 'body ' ) ; var options = $el . data ( 'popupoptions ' ) ; var $wrapper = $ ( ' # ' + el . id + ' _wrapper ' ) ; var $background = $ ( ' # ' + el . id + ' _background ' ) ; / / `beforeopen ` callback event callback ( el , ordinal , options . beforeopen ) ; / / Remember last clicked place lastclicked [ el . id ] = ordinal ; / / Add popup id to visible Popups Array set Timeout ( function ( ) { visible Popups Array . push ( el . id ) ; } , 0 ) ; / / Calculating maximum z -index if ( options . autozindex ) { var elements = document . get Elements By Tag Name ( ' * ' ) ; var len = elements . length ; var maxzindex = 0 ; for ( var i = 0 ; i < len ; i + + ) { var elementzindex = $ ( elements [ i ] ) . css ( 'z -index ' ) ; if ( elementzindex ! = = 'auto ' ) { elementzindex = parse Int ( elementzindex , 1 0 ) ; if ( maxzindex < elementzindex ) { maxzindex = elementzindex ; } } } zindexvalues [ el . id ] = maxzindex ; / / Add z -index to the background if ( options . background ) { if ( zindexvalues [ el . id ] > = 0 ) { $ ( ' # ' + el . id + ' _background ' ) . css ( { z Index : ( zindexvalues [ el . id ] + 1 ) } ) ; } } / / Add z -index to the wrapper if ( zindexvalues [ el . id ] > = 0 ) { $wrapper . css ( { z Index : ( zindexvalues [ el . id ] + 2 ) } ) ; } } if ( options . detach ) { $wrapper . prepend ( el ) ; $el . show ( ) ; } else { $el . show ( ) ; } opentimer = set Timeout ( function ( ) { $wrapper . css ( { visibility : 'visible ' , opacity : 1 } ) ; $ ( 'html ' ) . add Class ( 'popup _visible ' ) . add Class ( 'popup _visible _ ' + el . id ) ; $wrapper . add Class ( 'popup _wrapper _visible ' ) ; } , 2 0 ) ; / / 2 0ms required for opening animation to occur in FF / / Disable background layer scrolling when popup is opened if ( options . scrolllock ) { $body . css ( 'overflow ' , 'hidden ' ) ; if ( $body . height ( ) > $window . height ( ) ) { $body . css ( 'margin -right ' , bodymarginright + scrollbarwidth ) ; } } $el . css ( { 'visibility ' : 'visible ' , 'opacity ' : 1 } ) ; / / Show background if ( options . background ) { $background . css ( { 'visibility ' : 'visible ' , 'opacity ' : options . opacity } ) ; / / Fix IE 8 issue with background not appearing set Timeout ( function ( ) { $background . css ( { 'opacity ' : options . opacity } ) ; } , 0 ) ; } $el . data ( 'popup -visible ' , true ) ; / / Position popup methods . reposition ( el , ordinal ) ; / / Remember which element had focus before opening a popup $el . data ( 'focusedelementbeforepopup ' , document . active Element ) ; / / Make holder div programatically focusable with tabindex : - 1 (tabindex : 0 is keyboard focusable ) $el . attr ( 'tabindex ' , - 1 ) ; / / Focus the popup or user specified element . / / Initial timeout of 5 0ms is set to give some time to popup to show after clicking on / / `open ` element , and after animation is complete to prevent background scrolling . set Timeout ( function ( ) { if ( options . focuselement = = = 'closebutton ' ) { / / e .g . focuselement : 'closebutton ' $ ( ' # ' + el . id + ' . ' + el . id + closesuffix + ' :first ' ) . focus ( ) ; } else if ( options . focuselement ) { / / e .g . focuselement : ' #my -close -button ' $ ( options . focuselement ) . focus ( ) ; } else if ( options . focuselement = = = true | | options . keepfocus ) { / / e .g . focuselement :true OR keepfocus :true $el . focus ( ) ; } } , options . focusdelay ) ; / / Hide main content from screen readers if ( options . keepfocus ) { $ ( options . pagecontainer ) . attr ( 'aria -hidden ' , true ) ; } / / Reveal popup content to screen readers $el . attr ( 'aria -hidden ' , false ) ; callback ( el , ordinal , options . onopen ) ; if ( transitionsupport ) { $wrapper . one ( 'transitionend ' , function ( ) { callback ( el , ordinal , options . opentransitionend ) ; } ) ; } else { callback ( el , ordinal , options . opentransitionend ) ; } / / Handler : Reposition tooltip when window is resized if ( options . type = = 'tooltip ' ) { $ ( window ) . on ( 'resize . ' + el . id , function ( ) { methods . reposition ( el , ordinal ) ; } ) ; } } 
function ( el , outer Click ) { / / Get index of popup ID inside of visible Popups Array var popup Id Index = $ . in Array ( el . id , visible Popups Array ) ; / / If popup is not opened , ignore the rest of the function if ( popup Id Index = = = - 1 ) { return ; } if ( opentimer ) clear Timeout ( opentimer ) ; var $body = $ ( 'body ' ) ; var $el = $ ( el ) ; var options = $el . data ( 'popupoptions ' ) ; var $wrapper = $ ( ' # ' + el . id + ' _wrapper ' ) ; var $background = $ ( ' # ' + el . id + ' _background ' ) ; $el . data ( 'popup -visible ' , false ) ; if ( visible Popups Array . length = = = 1 ) { $ ( 'html ' ) . remove Class ( 'popup _visible ' ) . remove Class ( 'popup _visible _ ' + el . id ) ; } else { if ( $ ( 'html ' ) . has Class ( 'popup _visible _ ' + el . id ) ) { $ ( 'html ' ) . remove Class ( 'popup _visible _ ' + el . id ) ; } } / / Remove popup from the visible Popups Array visible Popups Array . splice ( popup Id Index , 1 ) ; if ( $wrapper . has Class ( 'popup _wrapper _visible ' ) ) { $wrapper . remove Class ( 'popup _wrapper _visible ' ) ; } / / Focus back on saved element if ( options . keepfocus & & ! outer Click ) { set Timeout ( function ( ) { if ( $ ( $el . data ( 'focusedelementbeforepopup ' ) ) . is ( ' :visible ' ) ) { $el . data ( 'focusedelementbeforepopup ' ) . focus ( ) ; } } , 0 ) ; } / / Hide popup $wrapper . css ( { 'visibility ' : 'hidden ' , 'opacity ' : 0 } ) ; $el . css ( { 'visibility ' : 'hidden ' , 'opacity ' : 0 } ) ; / / Hide background if ( options . background ) { $background . css ( { 'visibility ' : 'hidden ' , 'opacity ' : 0 } ) ; } / / Reveal main content to screen readers $ ( options . pagecontainer ) . attr ( 'aria -hidden ' , false ) ; / / Hide popup content from screen readers $el . attr ( 'aria -hidden ' , true ) ; / / `onclose ` callback event callback ( el , lastclicked [ el . id ] , options . onclose ) ; if ( transitionsupport & & $el . css ( 'transition -duration ' ) ! = = ' 0s ' ) { $el . one ( 'transitionend ' , function ( ) { if ( ! ( $el . data ( 'popup -visible ' ) ) ) { if ( options . detach ) { $el . detach ( ) ; } else { $el . hide ( ) ; } } / / Re -enable scrolling of background layer , if needed if ( options . scrolllock ) { set Timeout ( function ( ) { if ( $ . grep ( visible Popups Array , function ( eid ) { return $ ( " # " + eid ) . data ( 'popupoptions ' ) . scrolllock } ) . length ) { / / Some "scolllock =true " popup is currently visible , leave scrolling disabled return ; } $body . css ( { overflow : 'visible ' , 'margin -right ' : bodymarginright } ) ; } , 1 0 ) ; / / 1 0ms added for CSS transition in Firefox which doesn 't like overflow :auto } callback ( el , lastclicked [ el . id ] , options . closetransitionend ) ; } ) ; } else { if ( options . detach ) { $el . detach ( ) ; } else { $el . hide ( ) ; } / / Re -enable scrolling of background layer , if needed if ( options . scrolllock ) { set Timeout ( function ( ) { if ( $ . grep ( visible Popups Array , function ( eid ) { return $ ( " # " + eid ) . data ( 'popupoptions ' ) . scrolllock } ) . length ) { / / Some "scrolllock =true " popup is currently visible , leave scrolling disabled return ; } $body . css ( { overflow : 'visible ' , 'margin -right ' : bodymarginright } ) ; } , 1 0 ) ; / / 1 0ms added for CSS transition in Firefox which doesn 't like overflow :auto } callback ( el , lastclicked [ el . id ] , options . closetransitionend ) ; } if ( options . type = = 'tooltip ' ) { $ ( window ) . off ( 'resize . ' + el . id ) ; } } 
function ( el , ordinal ) { if ( $ ( el ) . data ( 'popup -visible ' ) ) { methods . hide ( el ) ; } else { set Timeout ( function ( ) { methods . show ( el , ordinal ) ; } , 0 ) ; } } 
function ( el , ordinal ) { var $el = $ ( el ) ; var options = $el . data ( 'popupoptions ' ) ; var $wrapper = $ ( ' # ' + el . id + ' _wrapper ' ) ; ordinal = ordinal | | 0 ; / / Tooltip type if ( options . type = = 'tooltip ' ) { / / TODO : this static assignments should probably be moved to init method $wrapper . css ( { 'position ' : 'absolute ' } ) ; var $tooltipanchor ; if ( options . tooltipanchor ) { $tooltipanchor = $ ( options . tooltipanchor ) ; } else if ( options . openelement ) { $tooltipanchor = $ ( options . openelement ) . filter ( ' [data -popup -ordinal = " ' + ordinal + ' " ] ' ) ; } else { $tooltipanchor = $ ( ' . ' + el . id + opensuffix + ' [data -popup -ordinal = " ' + ordinal + ' " ] ' ) ; } var link Offset = $tooltipanchor . offset ( ) | | { left : 0 , top : 0 } ; / / Horizontal position for tooltip if ( options . horizontal = = 'right ' ) { $wrapper . css ( 'left ' , link Offset . left + $tooltipanchor . outer Width ( ) + options . offsetleft ) ; } else if ( options . horizontal = = 'leftedge ' ) { $wrapper . css ( 'left ' , link Offset . left + options . offsetleft ) ; } else if ( options . horizontal = = 'left ' ) { $wrapper . css ( 'right ' , $window . width ( ) - link Offset . left - options . offsetleft ) ; } else if ( options . horizontal = = 'rightedge ' ) { $wrapper . css ( 'right ' , $window . width ( ) - link Offset . left - $tooltipanchor . outer Width ( ) - options . offsetleft ) ; } else { $wrapper . css ( 'left ' , link Offset . left + ( $tooltipanchor . outer Width ( ) / 2 ) - ( $el . outer Width ( ) / 2 ) - parse Float ( $el . css ( 'margin Left ' ) ) + options . offsetleft ) ; } / / Vertical position for tooltip if ( options . vertical = = 'bottom ' ) { $wrapper . css ( 'top ' , link Offset . top + $tooltipanchor . outer Height ( ) + options . offsettop ) ; } else if ( options . vertical = = 'bottomedge ' ) { $wrapper . css ( 'top ' , link Offset . top + $tooltipanchor . outer Height ( ) - $el . outer Height ( ) + options . offsettop ) ; } else if ( options . vertical = = 'top ' ) { $wrapper . css ( 'bottom ' , $window . height ( ) - link Offset . top - options . offsettop ) ; } else if ( options . vertical = = 'topedge ' ) { $wrapper . css ( 'bottom ' , $window . height ( ) - link Offset . top - $el . outer Height ( ) - options . offsettop ) ; } else { $wrapper . css ( 'top ' , link Offset . top + ( $tooltipanchor . outer Height ( ) / 2 ) - ( $el . outer Height ( ) / 2 ) - parse Float ( $el . css ( 'margin Top ' ) ) + options . offsettop ) ; } / / Overlay type } else if ( options . type = = 'overlay ' ) { / / TODO all static assignments in this block should probably be moved to init method / / Horizontal position for overlay if ( options . horizontal ) { $wrapper . css ( 'text -align ' , options . horizontal ) ; } else { $wrapper . css ( 'text -align ' , 'center ' ) ; } / / Vertical position for overlay if ( options . vertical ) { $el . css ( 'vertical -align ' , options . vertical ) ; } else { $el . css ( 'vertical -align ' , 'middle ' ) ; } if ( options . absolute ) { $wrapper . css ( { position : 'absolute ' , top : window . scroll Y } ) ; } if ( ! options . background ) { $wrapper . css ( { 'pointer -events ' : 'none ' } ) ; / / If popup doesnt fit the viewport , and if background doesn 't exist , add scrollbar to popup div instead of wrapper if ( ! options . absolute & & ! is In Viewport ( el ) ) { $el . css ( 'overflow ' , 'auto ' ) ; $el [ 0 ] . style . Webkit Overflow Scrolling = 'touch ' ; / / for smooth scrolling in overflow :auto divs in i OS $el . css ( 'max -height ' , 'calc ( 1 0 0 % - ' + $el . css ( 'margin -top ' ) + ' - ' + $el . css ( 'margin -bottom ' ) + ' ) ' ) ; } } } } 
function ( el ) { var generic Close Button ; if ( $ ( el ) . data ( 'popupoptions ' ) . closebuttonmarkup ) { generic Close Button = $ ( options . closebuttonmarkup ) . add Class ( el . id + ' _close ' ) ; } else { generic Close Button = ' <button class = "popup _close ' + el . id + ' _close " title = "Close " aria -label = "Close " > <span aria -hidden = "true " > × < /span > < /button > ' ; } if ( $ ( el ) . data ( 'popup -initialized ' ) ) { $ ( el ) . append ( generic Close Button ) ; } } 
function ( el , ordinal , func ) { var options = $ ( el ) . data ( 'popupoptions ' ) ; var openelement ; var elementclicked ; if ( typeof options = = = 'undefined ' ) return ; openelement = options . openelement ? options . openelement : ( ' . ' + el . id + opensuffix ) ; elementclicked = $ ( openelement + ' [data -popup -ordinal = " ' + ordinal + ' " ] ' ) ; if ( typeof func = = 'function ' ) { func . call ( $ ( el ) , el , elementclicked ) ; } } 
function ( el ) { var bounding = el . get Bounding Client Rect ( ) ; return ( bounding . top > = 0 & & bounding . left > = 0 & & bounding . bottom < = ( window . inner Height | | document . document Element . client Height ) & & bounding . right < = ( window . inner Width | | document . document Element . client Width ) ) ; } 
function Cordova Auth ( options ) { this . client Id = options . client Id ; this . domain = options . domain ; this . redirect Uri = options . package Identifier + ' : / / ' + options . domain + ' /cordova / ' + options . package Identifier + ' /callback ' ; this . auth 0 = new auth 0 . Web Auth ( { client ID : this . client Id , domain : this . domain } ) ; this . client = new auth 0 . Authentication ( this . auth 0 , { client ID : this . client Id , domain : this . domain , _telemetry Info : telemetry } ) ; } 
function main ( ) { var app = new App ( ) ; function intent Handler ( url ) { Auth 0Cordova . on Redirect Uri ( url ) ; } window . handle Open URL = intent Handler ; app . run ( ' #app ' ) ; } 
function Web View ( ) { this . tab = null ; this . handler = null ; this . open = this . open . bind ( this ) ; this . handle First Load End = this . handle First Load End . bind ( this ) ; this . handle Load Error = this . handle Load Error . bind ( this ) ; this . handle Exit = this . handle Exit . bind ( this ) ; this . clear Events = this . clear Events . bind ( this ) ; this . close = this . close . bind ( this ) ; } 
function process Props ( props ) { const { title , label , key , value } = props ; const clone Props = { . . . props } ; 
function Reporter ( options ) { var _default Output File = path . resolve ( process . cwd ( ) , ' . / _test -output ' , 'protractor -results .txt ' ) ; options . output File = options . output File | | _default Output File ; init Output File ( options . output File ) ; options . app Dir = options . app Dir | | ' . / ' ; var _root = { app Dir : options . app Dir , suites : [ ] } ; log ( 'App Dir : ' + options . app Dir , + 1 ) ; var _current Suite ; this . suite Started = function ( suite ) { _current Suite = { description : suite . description , status : null , specs : [ ] } ; _root . suites . push ( _current Suite ) ; log ( 'Suite : ' + suite . description , + 1 ) ; } ; this . suite Done = function ( suite ) { var statuses = _current Suite . specs . map ( function ( spec ) { return spec . status ; } ) ; statuses = _ . uniq ( statuses ) ; var status = statuses . index Of ( 'failed ' ) > = 0 ? 'failed ' : statuses . join ( ' , ' ) ; _current Suite . status = status ; log ( 'Suite ' + _current Suite . status + ' : ' + suite . description , - 1 ) ; } ; this . spec Started = function ( spec ) { } ; this . spec Done = function ( spec ) { var current Spec = { description : spec . description , status : spec . status } ; if ( spec . failed Expectations . length > 0 ) { current Spec . failed Expectations = spec . failed Expectations ; 
function regular Expressions ( ) { var regex File = path . join ( process . cwd ( ) , 'regex _rules .json ' ) var regex = require ( regex File ) return regex } 
function parse Headers ( filename , header Lines , only = null ) { const headers = Object . create ( null ) ; for ( let line of header Lines ) { if ( line = = = ' ' ) continue ; let [ name , value ] = line . match ( / ^ ( . * ? ) \ : \s + ( . * ) $ / ) . slice ( 1 ) ; if ( only & & ! match ( name , only ) ) continue ; const key = ( name | | ' ' ) . to Lower Case ( ) ; value = ( value | | ' ' ) . trim ( ) . replace ( / ^ " ( . * ) " $ / , ' $ 1 ' ) ; if ( Array . is Array ( headers [ key ] ) ) headers [ key ] . push ( value ) ; else if ( headers [ key ] ) headers [ key ] = [ headers [ key ] , value ] ; else headers [ key ] = value ; } return headers ; } 
function write Headers ( file , headers , only = null ) { for ( let name in headers ) { let value = headers [ name ] ; if ( only & & ! match ( name , only ) ) continue ; if ( Array . is Array ( value ) ) for ( let item of value ) file . write ( ` $ { name } $ { item } \n ` ) ; else file . write ( ` $ { name } $ { value } \n ` ) ; } } 
function match ( name , regexps ) { for ( let regexp of regexps ) if ( regexp . test ( name ) ) return true ; return false ; } 
function parse ( buffer , headers ) { var params = get Parsing Params ( headers ) ; var strategy = PARSING _STRATEGIES [ params . content Type ] | | function ( ) { return null ; } ; try { return strategy ( buffer , params . charset ) ; } catch ( err ) { 
function show Help And Die ( message ) { if ( message ) { console . error ( message ) ; } console . error ( commander . help Information ( ) ) ; process . exit ( 1 ) ; } 
function render Page ( res , template Name , config , user Stash ) { var page Stash = extend Object ( { base Url : robohydra Admin Base Url Path , render Partial : render Partial } , user Stash ) ; var template String = template Data ( template Name ) ; var main Content = ejs . render ( template String , page Stash ) ; var layout Stash = extend Object ( { base Url : robohydra Admin Base Url Path , title : "Robo Hydra Admin " , current Section : " / " , hydra Name : config . robohydra . name , start Time : config . robohydra . start Timestamp , render Partial : render Partial , content : main Content } , user Stash ) ; res . headers [ 'content -type ' ] = 'text /html ' ; res . send ( ejs . render ( main Layout Template String , layout Stash ) ) ; } 
function read Body Params ( req ) { if ( req . headers [ 'content -type ' ] ! = = 'application /x -www -form -urlencoded ' ) { deprecation Warning ( "make sure you correctly set Content -Type to " + " application /x -www -form -urlencoded " ) ; try { return qs . parse ( req . raw Body . to String ( ) ) ; } catch ( e ) { return null ; } } return req . body ; } 
function Abstract Robo Hydra Head ( props ) { 
function robohydra Head Type ( settings ) { var parent Class = settings . parent Class | | Robo Hydra Head ; var new Constructor Function = function ( props ) { if ( ! props & & settings . default Props ) { deprecation Warning ( "deprecated 'default Props ' , please use 'default Property Object ' instead " ) ; props = settings . default Props ; } props = props | | settings . default Property Object | | { } ; 
function create Robo Hydra Server ( config , extra Vars ) { var summoner ; try { summoner = new Robo Hydra Summoner ( config . plugins , config . summoner , { extra Vars : extra Vars , extra Plugin Load Paths : config . plugin Load Paths } ) ; } catch ( e ) { console . error ( e . message | | e ) ; process . exit ( 1 ) ; } 
function serve Static File ( path , res , opts ) { opts = opts | | { } ; var fs Object = opts . fs | | fs ; var mime Object = opts . mime | | mime ; var headers = opts . headers | | { } ; var index Files = opts . index Files | | [ 'index .html ' , 'index .htm ' , 'home .html ' , 'home .htm ' ] ; fs Object . stat ( path , function ( err , stats ) { if ( ! err ) { if ( stats . is File ( ) ) { var mtime = stats . mtime , modified Since = headers [ 'if -modified -since ' ] ; 
function proxy Request ( req , res , proxy To , opts ) { opts = opts | | { } ; var http Request Function = opts . http Request Function | | http . request ; var https Request Function = opts . https Request Function | | https . request ; var set Host Header = opts . set Host Header ; var proxy Url = proxy To ; if ( typeof ( proxy To ) = = = 'string ' ) { proxy Url = url . parse ( proxy To , true ) ; } var proxy To Host = proxy Url . hostname ; var proxy To Port = proxy Url . port | | ( proxy Url . protocol = = = 'https : ' ? 4 4 3 : 8 0 ) ; var proxy To Path = proxy Url . pathname + ( proxy Url . search = = = null ? " " : proxy Url . search ) ; var request Function = ( proxy Url . protocol = = = 'https : ' ) ? https Request Function : http Request Function ; var headers = { } ; for ( var h in req . headers ) { headers [ h ] = req . headers [ h ] ; } if ( set Host Header ) { headers . host = proxy To Host + ( proxy Url . port ? " : " + proxy Url . port : " " ) ; } var proxy Req = request Function ( { host : proxy To Host , port : proxy To Port , method : req . method , path : proxy To Path , headers : headers } , function ( proxy Res ) { 
function extend Object ( obj ) { for ( var i = 1 , len = arguments . length ; i < len ; i + + ) { for ( var p in arguments [ i ] ) { if ( arguments [ i ] . has Own Property ( p ) ) { obj [ p ] = arguments [ i ] [ p ] ; } } } return obj ; } 
function Request ( props ) { 
function Response ( cb ) { this . body = new Buffer ( 0 ) ; this . status Code = 2 0 0 ; this . headers = { } ; this . ended = false ; var end Handlers = [ ] ; if ( typeof cb = = = 'function ' ) { end Handlers . push ( cb ) ; } this . _event Handlers = { head : [ ] , data : [ ] , end : end Handlers } ; } 
function ( extra Vars ) { this . extra Vars = extend Object ( { } , extra Vars | | { } ) ; this . _plugins = [ ] ; this . _head Map = { } ; this . current Scenario = { plugin : ' *default * ' , scenario : ' *default * ' } ; this . test Results = { ' *default * ' : { ' *default * ' : { result : undefined , passes : [ ] , failures : [ ] } } } ; Object . define Property ( this , 'scenario Results ' , { get : function ( ) { deprecation Warning ( "scenario Results is deprecated , please use test Results instead " ) ; return this . test Results ; } } ) ; 
function Big Iq 5 0License Provider ( big Ip , options ) { const injected Logger = options ? options . logger : undefined ; let logger Options = options ? options . logger Options : undefined ; if ( injected Logger ) { this . logger = injected Logger ; util . set Logger ( injected Logger ) ; } else { logger Options = logger Options | | { log Level : 'none ' } ; logger Options . module = module ; this . logger = Logger . get Logger ( logger Options ) ; util . set Logger Options ( logger Options ) ; } logger = this . logger ; this . big Ip = big Ip ; } 
function list Private Key ( key Type , folder , name , no Retry ) { let private Key Name ; 
function Cloud Provider ( options ) { const logger = options ? options . logger : undefined ; let logger Options = options ? options . logger Options : undefined ; this . options = { } ; if ( options ) { Object . keys ( options ) . for Each ( ( option ) = > { this . options [ option ] = options [ option ] ; } ) ; } this . cl Options = { } ; if ( options & & options . cl Options ) { Object . keys ( options . cl Options ) . for Each ( ( option ) = > { this . cl Options [ option ] = options . cl Options [ option ] ; } ) ; } 
function create Traffic Group ( big Ip , traffic Group ) { let create Group = true ; big Ip . list ( ' /tm /cm /traffic -group ' ) . then ( ( response ) = > { response . for Each ( ( group ) = > { if ( group . name = = = traffic Group ) { create Group = false ; } } ) ; if ( create Group ) { return big Ip . create ( ' /tm /cm /traffic -group ' , { name : traffic Group , partition : ' /Common ' } ) ; } return q ( ) ; } ) . catch ( ( err ) = > { return q . reject ( err ) ; } ) ; } 
function handle Join ( provider , big Ip , master Iid , options ) { const deferred = q . defer ( ) ; logger . info ( 'Cluster action JOIN ' ) ; logger . info ( 'Initializing encryption ' ) ; init Encryption . call ( this , provider , big Ip ) . then ( ( ) = > { let promise ; 
function handle Update ( provider , big Ip , master Iid , master Bad Or New , options ) { logger . info ( 'Cluster action UPDATE ' ) ; if ( this . instance . is Master & & ! master Bad Or New ) { return check For Disconnected Devices . call ( this , big Ip ) ; } else if ( ! this . instance . is Master ) { 
function handle Messages ( provider , big Ip , options ) { const deferred = q . defer ( ) ; const instance Ids Being Added = [ ] ; const actions = [ ] ; const action Promises = [ ] ; let message Metadata = [ ] ; if ( this . instance . is Master & & ! options . block Sync ) { actions . push ( Cloud Provider . MESSAGE _ADD _TO _CLUSTER ) ; } if ( ! this . instance . is Master ) { actions . push ( Cloud Provider . MESSAGE _SYNC _COMPLETE ) ; } provider . get Messages ( actions , { to Instance Id : this . instance Id } ) . then ( ( messages ) = > { const read Promises = [ ] ; const messages Array = messages ? messages . slice ( ) : [ ] ; logger . debug ( 'Handling ' , messages . length , 'message (s ) ' ) ; messages Array . for Each ( ( message ) = > { message Metadata . push ( { action : message . action , to Instance Id : message . to Instance Id , from Instance Id : message . from Instance Id } ) ; read Promises . push ( read Message Data . call ( this , provider , big Ip , message . data ) ) ; } ) ; logger . silly ( 'number of messages to read : ' , read Promises . length ) ; return q . all ( read Promises ) ; } ) . then ( ( read Messages ) = > { let metadata ; let message Data ; const already Adding = function ( instance Id ) { return instance Ids Being Added . find ( ( element ) = > { return instance Id = = = element . to Instance Id ; } ) ; } ; const read Messages Array = read Messages ? read Messages . slice ( ) : [ ] ; logger . silly ( 'number of read messages : ' , read Messages Array . length ) ; for ( let i = 0 ; i < read Messages Array . length ; + + i ) { metadata = message Metadata [ i ] ; logger . silly ( 'metadata : ' , metadata ) ; try { message Data = JSON . parse ( read Messages Array [ i ] ) ; } catch ( err ) { logger . warn ( 'JSON .parse error : ' , err ) ; message Data = undefined ; deferred . reject ( new Error ( 'Unable to JSON parse message ' ) ) ; } if ( message Data ) { let discard = false ; switch ( metadata . action ) { 
function become Master ( provider , big Ip , options ) { let has Ucs = false ; logger . info ( 'Becoming master . ' ) ; logger . info ( 'Checking for backup UCS . ' ) ; return provider . get Stored Ucs ( ) . then ( ( response ) = > { if ( response ) { has Ucs = true ; return load Ucs ( provider , big Ip , response , options . cloud ) ; } return q ( ) ; } ) . then ( ( ) = > { 
function join Cluster ( provider , big Ip , master Iid , options ) { const TEMP _USER _NAME _LENGHTH = 1 0 ; 
function get Autoscale Process Count ( ) { const actions = 'cluster -action update | -c update |cluster -action join | -c join ' ; const grep Command = ` $ { actions } ` ; return util . get Process Count ( grep Command ) . then ( ( response ) = > { return q ( response ) ; } ) . catch ( ( err ) = > { logger . error ( 'Could not determine if another autoscale script is running ' ) ; return q . reject ( err ) ; } ) ; } 
function check For Disconnected Devices ( big Ip ) { return big Ip . cluster . get Cm Sync Status ( ) . then ( ( response ) = > { logger . silly ( 'cm Sync Status : ' , response ) ; const disconnected = response ? response . disconnected : [ ] ; const hostnames = [ ] ; const hostnames To Remove = [ ] ; 
function init Encryption ( provider , big Ip ) { const PRIVATE _KEY _OUT _FILE = ' /tmp /temp Private Key .pem ' ; let passphrase ; if ( provider . has Feature ( Cloud Provider . FEATURE _ENCRYPTION ) ) { logger . debug ( 'Generating public /private keys for autoscaling . ' ) ; return crypto Util . generate Random Bytes ( PASSPHRASE _LENGTH , 'base 6 4 ' ) . then ( ( response ) = > { passphrase = response ; return crypto Util . generate Key Pair ( PRIVATE _KEY _OUT _FILE , { passphrase , key Length : ' 3 0 7 2 ' } ) ; } ) . then ( ( public Key ) = > { return provider . put Public Key ( this . instance Id , public Key ) ; } ) . then ( ( ) = > { return big Ip . install Private Key ( PRIVATE _KEY _OUT _FILE , AUTOSCALE _PRIVATE _KEY _FOLDER , AUTOSCALE _PRIVATE _KEY , { passphrase } ) ; } ) . then ( ( ) = > { return big Ip . save ( ) ; } ) . catch ( ( err ) = > { logger . info ( 'init Encryption error ' , err & & err . message ? err . message : err ) ; return q . reject ( err ) ; } ) ; } return q ( ) ; } 
function get Master Instance ( instances ) { let instance Id ; const instance Ids = Object . keys ( instances ) ; for ( let i = 0 ; i < instance Ids . length ; i + + ) { instance Id = instance Ids [ i ] ; if ( instances [ instance Id ] . is Master ) { return { id : instance Id , instance : instances [ instance Id ] } ; } } return null ; } 
function mark Versions ( instances ) { let highest Version = ' 0 . 0 . 0 ' ; let instance ; Object . keys ( instances ) . for Each ( ( instance Id ) = > { instance = instances [ instance Id ] ; if ( instance . version & & util . version Compare ( instance . version , highest Version ) > 0 ) { highest Version = instance . version ; } } ) ; Object . keys ( instances ) . for Each ( ( instance Id ) = > { instance = instances [ instance Id ] ; if ( ! instance . version | | util . version Compare ( instance . version , highest Version ) = = = 0 ) { instance . version Ok = true ; } else { instance . version Ok = false ; } } ) ; } 
function is Master External Value Ok ( master Id , instances ) { const instance Ids = Object . keys ( instances ) ; let instance ; let has External ; for ( let i = 0 ; i < instance Ids . length ; i + + ) { instance = instances [ instance Ids [ i ] ] ; if ( instance . external ) { has External = true ; break ; } } if ( has External ) { return ! ! instances [ master Id ] . external ; } return true ; } 
function is Master Expired ( instance ) { const master Status = instance . master Status | | { } ; let is Expired = false ; let disconnected Ms ; if ( master Status . status ! = = Cloud Provider . STATUS _OK ) { disconnected Ms = new Date ( ) - new Date ( master Status . last Status Change ) ; logger . silly ( 'master has been disconnected for ' , disconnected Ms . to String ( ) , 'ms ' ) ; if ( disconnected Ms > MAX _DISCONNECTED _MS ) { logger . info ( 'master has been disconnected for too long ( ' , disconnected Ms . to String ( ) , 'ms ) ' ) ; is Expired = true ; } } return is Expired ; } 
function load Ucs ( provider , big Ip , ucs Data , cloud Provider ) { const time Stamp = Date . now ( ) ; const original Path = ` $ { time Stamp } ` ; const updated Path = ` $ { time Stamp } ` ; const update Script = ` $ { _ _dirname } ` ; const deferred = q . defer ( ) ; let original File ; const pre Load = function ( ) { 
function Generic Node Provider ( options ) { Generic Node Provider . super _ . call ( this , options ) ; this . logger Options = options ? options . logger Options : undefined ; logger = options ? options . logger : undefined ; if ( logger ) { this . logger = logger ; cloud Util . set Logger ( logger ) ; crypto Util . set Logger ( logger ) ; } else if ( this . logger Options ) { this . logger Options . module = module ; logger = Logger . get Logger ( this . logger Options ) ; cloud Util . set Logger Options ( this . logger Options ) ; crypto Util . set Logger Options ( this . logger Options ) ; this . logger = logger ; } else { 
function get Data From Prop Path ( path Array , obj ) { if ( path Array . length = = = 0 ) { return undefined ; } return path Array . reduce ( ( result , prop ) = > { if ( typeof result ! = = 'object ' | | result = = = null ) { return { } ; } if ( prop = = = ' ' ) { return result ; } return result [ prop ] ; } , obj ) ; } 
function Big Ip Gtm ( big Ip Core , options ) { const logger = options ? options . logger : undefined ; let logger Options = options ? options . logger Options : undefined ; if ( logger ) { this . logger = logger ; util . set Logger ( logger ) ; } else { logger Options = logger Options | | { log Level : 'none ' } ; logger Options . module = module ; this . logger = Logger . get Logger ( logger Options ) ; util . set Logger Options ( logger Options ) ; } this . core = big Ip Core ; this . partition = 'Common ' ; } 
function prepare Args For Reboot ( ) { const deferred = q . defer ( ) ; let startup Scripts ; let startup Commands ; let startup Commands Changed ; const STARTUP _DIR = ' /config / ' ; const STARTUP _FILE = ` $ { STARTUP _DIR } ` ; const REBOOT _SIGNAL = ipc . signal Base Path + signals . REBOOT ; if ( ! fs . exists Sync ( STARTUP _DIR ) ) { logger . debug ( 'No /config directory . Skipping . ' ) ; deferred . resolve ( ) ; return deferred . promise ; } try { startup Commands = fs . read File Sync ( STARTUP _FILE , 'utf 8 ' ) ; } catch ( err ) { logger . warn ( 'Error reading starup file . ' ) ; deferred . reject ( err ) ; return deferred . promise ; } try { startup Scripts = fs . readdir Sync ( REBOOT _SCRIPTS _DIR ) ; } catch ( err ) { logger . warn ( 'Error reading directory with reboot args . ' ) ; deferred . reject ( err ) ; return deferred . promise ; } 
function Big Ip ( options ) { const logger = options ? options . logger : undefined ; let logger Options = options ? options . logger Options : undefined ; let dependent Options = { } ; if ( logger ) { this . logger = logger ; util . set Logger ( logger ) ; crypto Util . set Logger ( logger ) ; local Key Util . set Logger ( logger ) ; authn . set Logger ( logger ) ; dependent Options = { logger : this . logger } ; } else { logger Options = logger Options | | { log Level : 'none ' } ; logger Options . module = module ; this . logger = Logger . get Logger ( logger Options ) ; util . set Logger Options ( logger Options ) ; crypto Util . set Logger Options ( logger Options ) ; local Key Util . set Logger Options ( logger Options ) ; authn . set Logger Options ( logger Options ) ; dependent Options = { logger Options } ; } 
function check Task ( task Path , task Id To Check , options ) { const func = function ( ) { const deferred = q . defer ( ) ; this . list ( ` $ { task Path } $ { task Id To Check } ` , undefined , util . NO _RETRY ) . then ( ( response ) = > { const status Attribute = ( options & & options . status Attribute ) ? options . status Attribute : ' _task State ' ; const task State = response [ status Attribute ] ; if ( task State = = = 'VALIDATING ' | | task State = = = 'STARTED ' ) { 
function ( passwords Value ) { const set = passwords Value . split ( ' ,new : ' ) ; if ( set . length = = = 2 ) { root Passwords . old = set [ 0 ] . split ( 'old : ' ) [ 1 ] ; root Passwords . new = set [ 1 ] ; } } 
function Gtm Dns Provider ( options ) { const logger = options ? options . logger : undefined ; const logger Options = options ? options . logger Options : undefined ; Gtm Dns Provider . super _ . call ( this , options ) ; this . big Ip = new Big Ip ( { logger , logger Options } ) ; } 
function get First Available Address ( ) { let highest Last Octet = 0 ; used Addresses . for Each ( ( address ) = > { const octets = address . split ( ' . ' ) ; const this Last Octet = parse Int ( octets [ 3 ] , 1 0 ) ; if ( this Last Octet > highest Last Octet ) { highest Last Octet = this Last Octet ; } } ) ; highest Last Octet + = 1 ; if ( highest Last Octet > 2 5 5 ) { this . logger . error ( 'No available addresses for GTM server ' ) ; return null ; } return ` $ { highest Last Octet } ` ; } 
function Big Iq 5 4License Provider ( big Ip , options ) { const injected Logger = options ? options . logger : undefined ; let logger Options = options ? options . logger Options : undefined ; this . constructor Options = { } ; if ( options ) { Object . keys ( options ) . for Each ( ( option ) = > { this . constructor Options [ option ] = options [ option ] ; } ) ; } if ( injected Logger ) { this . logger = injected Logger ; util . set Logger ( injected Logger ) ; } else { logger Options = logger Options | | { log Level : 'none ' } ; logger Options . module = module ; this . logger = Logger . get Logger ( logger Options ) ; util . set Logger Options ( logger Options ) ; } this . big Ip = big Ip ; } 
function IControl ( options ) { const opts = options | | { } ; const logger = options ? options . logger : undefined ; let logger Options = options ? options . logger Options : undefined ; if ( logger ) { this . logger = logger ; } else { logger Options = logger Options | | { log Level : 'none ' } ; logger Options . module = module ; this . logger = Logger . get Logger ( logger Options ) ; } 
function encrypt ( public Key Data Or File , data ) { const deferred = q . defer ( ) ; let public Key Promise ; const get Public Key = function get Public Key ( public Key File ) { const public Key Deferred = q . defer ( ) ; fs . read File ( public Key File , ( err , public Key ) = > { if ( err ) { logger . warn ( 'Error reading public key : ' , err ) ; public Key Deferred . reject ( err ) ; } else { public Key Deferred . resolve ( public Key ) ; } } ) ; return public Key Deferred . promise ; } ; if ( typeof data ! = = 'string ' ) { deferred . reject ( new Error ( 'data must be a string ' ) ) ; return deferred . promise ; } if ( public Key Data Or File . starts With ( ' - - - - -BEGIN PUBLIC KEY - - - - - ' ) ) { public Key Promise = q ( public Key Data Or File ) ; } else { public Key Promise = get Public Key ( public Key Data Or File ) ; } public Key Promise . then ( ( public Key ) = > { let encrypted ; try { encrypted = crypto . public Encrypt ( public Key , util . create Buffer From ( data ) ) ; deferred . resolve ( encrypted . to String ( 'base 6 4 ' ) ) ; } catch ( err ) { logger . warn ( 'Error encrypting data : ' , err ) ; deferred . reject ( err ) ; } } ) . catch ( ( err ) = > { logger . warn ( 'Unable to get public key : ' , err ) ; deferred . reject ( err ) ; } ) ; return deferred . promise ; } 
function get Label ( log Level , module Logging , verbose Label ) { let parts ; let label = ' ' ; if ( module Logging ) { if ( log Level = = = 'debug ' | | log Level = = = 'silly ' | | verbose Label ) { parts = module Logging . filename . split ( ' / ' ) ; label = ` $ { parts [ parts . length - 2 ] } $ { parts . pop ( ) } ` ; } } return label ; } 
function get License Provider ( pool Name , options ) { const method Options = { } ; Object . assign ( method Options , options ) ; const factory Options = { } ; Object . assign ( factory Options , this . constructor Options ) ; let license Provider ; if ( method Options . auto Api Type ) { return get Api Type . call ( this , pool Name , method Options ) . then ( ( api Type ) = > { 
function force Reset User Password ( user ) { const deferred = q . defer ( ) ; crypto Util . generate Random Bytes ( 2 4 , 'hex ' ) . then ( ( random Bytes ) = > { util . run Shell Command ( ` $ { random Bytes } \n $ { random Bytes } $ { user } ` ) ; deferred . resolve ( random Bytes ) ; } ) . catch ( ( err ) = > { deferred . reject ( err ) ; } ) ; return deferred . promise ; } 
function jscoverage _open Warning Dialog ( ) { var id ; if ( jscoverage _is Report ) { id = 'report Warning Dialog ' ; } else { id = 'warning Dialog ' ; } var dialog = document . get Element By Id ( id ) ; dialog . style . display = 'block ' ; } 
function jscoverage _init ( w ) { try { / / in Safari , "import " is a syntax error Components . utils [ 'import ' ] ( 'resource : / /app /modules /jscoverage .jsm ' ) ; jscoverage _is Inverted Mode = true ; return ; } catch ( e ) { } / / check if we are in inverted mode if ( w . opener ) { try { if ( w . opener . top . _ $jscoverage ) { jscoverage _is Inverted Mode = true ; if ( ! w . _ $jscoverage ) { w . _ $jscoverage = w . opener . top . _ $jscoverage ; } } else { jscoverage _is Inverted Mode = false ; } } catch ( e ) { try { if ( w . opener . _ $jscoverage ) { jscoverage _is Inverted Mode = true ; if ( ! w . _ $jscoverage ) { w . _ $jscoverage = w . opener . _ $jscoverage ; } } else { jscoverage _is Inverted Mode = false ; } } catch ( e 2 ) { jscoverage _is Inverted Mode = false ; } } } else { jscoverage _is Inverted Mode = false ; } if ( ! jscoverage _is Inverted Mode ) { if ( ! w . _ $jscoverage ) { w . _ $jscoverage = { } ; } } } 
function jscoverage _find Pos ( obj ) { var result = 0 ; do { result + = obj . offset Top ; obj = obj . offset Parent ; } while ( obj ) ; return result ; } 
function jscoverage _get Viewport Height ( ) { / / #JSCOVERAGE _IF /MSIE / .test (navigator .user Agent ) if ( self . inner Height ) { / / all except Explorer return self . inner Height ; } else if ( document . document Element & & document . document Element . client Height ) { / / Explorer 6 Strict Mode return document . document Element . client Height ; } else if ( document . body ) { / / other Explorers return document . body . client Height ; } else { throw "Couldn 't calculate viewport height " ; } / / #JSCOVERAGE _ENDIF } 
function jscoverage _begin Lengthy Operation ( ) { jscoverage _in Lengthy Operation = true ; var progress Bar = document . get Element By Id ( 'progress Bar ' ) ; progress Bar . style . visibility = 'visible ' ; Progress Bar . set Percentage ( progress Bar , 0 ) ; var progress Label = document . get Element By Id ( 'progress Label ' ) ; progress Label . style . visibility = 'visible ' ; / / #JSCOVERAGE _IF if ( ! / Opera |Web Kit / . test ( navigator . user Agent ) ) { var tabs = document . get Element By Id ( 'tabs ' ) . get Elements By Tag Name ( 'div ' ) ; var i ; for ( i = 0 ; i < tabs . length ; i + + ) { tabs . item ( i ) . style . cursor = 'wait ' ; } } } 
function jscoverage _end Lengthy Operation ( ) { var progress Bar = document . get Element By Id ( 'progress Bar ' ) ; Progress Bar . set Percentage ( progress Bar , 1 0 0 ) ; set Timeout ( function ( ) { jscoverage _in Lengthy Operation = false ; progress Bar . style . visibility = 'hidden ' ; var progress Label = document . get Element By Id ( 'progress Label ' ) ; progress Label . style . visibility = 'hidden ' ; progress Label . inner HTML = ' ' ; var tabs = document . get Element By Id ( 'tabs ' ) . get Elements By Tag Name ( 'div ' ) ; var i ; for ( i = 0 ; i < tabs . length ; i + + ) { tabs . item ( i ) . style . cursor = ' ' ; } } , 5 0 ) ; } 
function jscoverage _get Boolean Value ( s ) { s = s . to Lower Case ( ) ; if ( s = = = 'false ' | | s = = = 'f ' | | s = = = 'no ' | | s = = = 'n ' | | s = = = 'off ' | | s = = = ' 0 ' ) { return false ; } return true ; } 
function jscoverage _init Tab Contents ( query String ) { var show Missing Column = false ; var url = null ; var window URL = null ; var parameters , parameter , i , index , name , value ; if ( query String . length > 0 ) { / / chop off the question mark query String = query String . substring ( 1 ) ; parameters = query String . split ( / & | ; / ) ; for ( i = 0 ; i < parameters . length ; i + + ) { parameter = parameters [ i ] ; index = parameter . index Of ( ' = ' ) ; if ( index = = = - 1 ) { / / still works with old syntax url = decode URIComponent ( parameter ) ; } else { name = parameter . substr ( 0 , index ) ; value = decode URIComponent ( parameter . substr ( index + 1 ) ) ; if ( name = = = 'missing ' | | name = = = 'm ' ) { show Missing Column = jscoverage _get Boolean Value ( value ) ; } else if ( name = = = 'url ' | | name = = = 'u ' | | name = = = 'frame ' | | name = = = 'f ' ) { url = value ; } else if ( name = = = 'window ' | | name = = = 'w ' ) { window URL = value ; } } } } var checkbox = document . get Element By Id ( 'checkbox ' ) ; checkbox . checked = show Missing Column ; if ( show Missing Column ) { jscoverage _append Missing Column ( ) ; } var is Valid URL = function ( url ) { var result = jscoverage _is Valid URL ( url ) ; if ( ! result ) { alert ( 'Invalid URL : ' + url ) ; } return result ; } ; if ( url ! = = null & & is Valid URL ( url ) ) { / / this will automatically propagate to the input field frames [ 0 ] . location = url ; } else if ( window URL ! = = null & & is Valid URL ( window URL ) ) { window . open ( window URL ) ; } / / if the browser tab is absent , we have to initialize the summary tab if ( ! document . get Element By Id ( 'browser Tab ' ) ) { jscoverage _recalculate Summary Tab ( ) ; } } 
function jscoverage _make Table ( ) { var coverage = _ $jscoverage [ jscoverage _current File ] ; var lines = coverage . source ; / / this can happen if there is an error in the original Java Script file if ( ! lines ) { lines = [ ] ; } var rows = [ ' <table id = "source Table " > ' ] ; var i = 0 ; var progress Bar = document . get Element By Id ( 'progress Bar ' ) ; var table HTML ; var current Conditional End = 0 ; function join Table Rows ( ) { table HTML = rows . join ( ' ' ) ; Progress Bar . set Percentage ( progress Bar , 6 0 ) ; set Timeout ( append Table , 1 0 0 ) ; } function append Table ( ) { var source Div = document . get Element By Id ( 'source Div ' ) ; source Div . inner HTML = table HTML ; Progress Bar . set Percentage ( progress Bar , 8 0 ) ; set Timeout ( jscoverage _scroll To Line , 0 ) ; } while ( i < lines . length ) { var line Number = i + 1 ; if ( line Number = = = current Conditional End ) { current Conditional End = 0 ; } else if ( current Conditional End = = = 0 & & coverage . conditionals & & coverage . conditionals [ line Number ] ) { current Conditional End = coverage . conditionals [ line Number ] ; } var row = ' <tr > ' ; row + = ' <td class = "numeric " > ' + line Number + ' < /td > ' ; var times Executed = coverage [ line Number ] ; if ( times Executed ! = = undefined & & times Executed ! = = null ) { if ( current Conditional End ! = = 0 ) { row + = ' <td class = "y numeric " > ' ; } else if ( times Executed = = = 0 ) { row + = ' <td class = "r numeric " id = "line - ' + line Number + ' " > ' ; } else { row + = ' <td class = "g numeric " > ' ; } row + = times Executed ; row + = ' < /td > ' ; } else { row + = ' <td > < /td > ' ; } row + = ' <td > <pre > ' + lines [ i ] + ' < /pre > < /td > ' ; row + = ' < /tr > ' ; row + = ' \n ' ; rows [ line Number ] = row ; i + + ; } rows [ i + 1 ] = ' < /table > ' ; Progress Bar . set Percentage ( progress Bar , 4 0 ) ; set Timeout ( join Table Rows , 0 ) ; } 
function jscoverage _recalculate Source Tab ( ) { if ( ! jscoverage _current File ) { jscoverage _end Lengthy Operation ( ) ; return ; } var progress Label = document . get Element By Id ( 'progress Label ' ) ; progress Label . inner HTML = 'Calculating coverage . . . ' ; var progress Bar = document . get Element By Id ( 'progress Bar ' ) ; Progress Bar . set Percentage ( progress Bar , 2 0 ) ; set Timeout ( jscoverage _make Table , 0 ) ; } 
function jscoverage _init Tab Control ( ) { var tabs = document . get Element By Id ( 'tabs ' ) ; var i ; var child ; var tab Num = 0 ; for ( i = 0 ; i < tabs . child Nodes . length ; i + + ) { child = tabs . child Nodes . item ( i ) ; if ( child . node Type = = = 1 ) { if ( child . class Name ! = = 'disabled ' ) { child . onclick = jscoverage _tab _click ; } tab Num + + ; } } jscoverage _select Tab ( 0 ) ; } 
function jscoverage _select Tab ( tab ) { if ( typeof tab ! = = 'number ' ) { tab = jscoverage _tab Index Of ( tab ) ; } var tabs = document . get Element By Id ( 'tabs ' ) ; var tab Pages = document . get Element By Id ( 'tab Pages ' ) ; var node List ; var tab Num ; var i ; var node ; node List = tabs . child Nodes ; tab Num = 0 ; for ( i = 0 ; i < node List . length ; i + + ) { node = node List . item ( i ) ; if ( node . node Type ! = = 1 ) { continue ; } if ( node . class Name ! = = 'disabled ' ) { if ( tab Num = = = tab ) { node . class Name = 'selected ' ; } else { node . class Name = ' ' ; } } tab Num + + ; } node List = tab Pages . child Nodes ; tab Num = 0 ; for ( i = 0 ; i < node List . length ; i + + ) { node = node List . item ( i ) ; if ( node . node Type ! = = 1 ) { continue ; } if ( tab Num = = = tab ) { node . class Name = 'selected Tab Page ' ; } else { node . class Name = 'Tab Page ' ; } tab Num + + ; } } 
function jscoverage _tab Index Of ( tab ) { if ( typeof tab = = = 'string ' ) { tab = document . get Element By Id ( tab ) ; } var tabs = document . get Element By Id ( 'tabs ' ) ; var i ; var child ; var tab Num = 0 ; for ( i = 0 ; i < tabs . child Nodes . length ; i + + ) { child = tabs . child Nodes . item ( i ) ; if ( child . node Type = = = 1 ) { if ( child = = = tab ) { return tab Num ; } tab Num + + ; } } / / #JSCOVERAGE _IF 0 throw "Tab not found " ; / / #JSCOVERAGE _ENDIF } 
function compare Ascending ( a , b ) { var ac = a . criteria , bc = b . criteria ; 
function base Clone ( value , deep , callback , stack A , stack B ) { if ( callback ) { var result = callback ( value ) ; if ( typeof result ! = 'undefined ' ) { return result ; } } 
function base Flatten ( array , is Shallow , is Arg Arrays , from Index ) { var index = ( from Index | | 0 ) - 1 , length = array ? array . length : 0 , result = [ ] ; while ( + + index < length ) { var value = array [ index ] ; if ( value & & typeof value = = 'object ' & & typeof value . length = = 'number ' & & ( is Array ( value ) | | is Arguments ( value ) ) ) { 
function base Is Equal ( a , b , callback , is Where , stack A , stack B ) { 
function create Bound ( func , bitmask , partial Args , partial Right Args , this Arg , arity ) { var is Bind = bitmask & 1 , is Bind Key = bitmask & 2 , is Curry = bitmask & 4 , is Curry Bound = bitmask & 8 , is Partial = bitmask & 1 6 , is Partial Right = bitmask & 3 2 , key = func ; if ( ! is Bind Key & & ! is Function ( func ) ) { throw new Type Error ; } if ( is Partial & & ! partial Args . length ) { bitmask & = ~ 1 6 ; is Partial = partial Args = false ; } if ( is Partial Right & & ! partial Right Args . length ) { bitmask & = ~ 3 2 ; is Partial Right = partial Right Args = false ; } var bind Data = func & & func . _ _bind Data _ _ ; if ( bind Data ) { if ( is Bind & & ! ( bind Data [ 1 ] & 1 ) ) { bind Data [ 4 ] = this Arg ; } if ( ! is Bind & & bind Data [ 1 ] & 1 ) { bitmask | = 8 ; } if ( is Curry & & ! ( bind Data [ 1 ] & 4 ) ) { bind Data [ 5 ] = arity ; } if ( is Partial ) { push . apply ( bind Data [ 2 ] | | ( bind Data [ 2 ] = [ ] ) , partial Args ) ; } if ( is Partial Right ) { push . apply ( bind Data [ 3 ] | | ( bind Data [ 3 ] = [ ] ) , partial Right Args ) ; } bind Data [ 1 ] | = bitmask ; return create Bound . apply ( null , bind Data ) ; } 
function clone ( value , deep , callback , this Arg ) { 
function merge ( object ) { var args = arguments , length = 2 ; if ( ! is Object ( object ) ) { return object ; } 
function omit ( object , callback , this Arg ) { var index Of = get Index Of ( ) , is Func = typeof callback = = 'function ' , result = { } ; if ( is Func ) { callback = lodash . create Callback ( callback , this Arg , 3 ) ; } else { var props = base Flatten ( arguments , true , false , 1 ) ; } for In ( object , function ( value , key , object ) { if ( is Func ? ! callback ( value , key , object ) : index Of ( props , key ) < 0 ) { result [ key ] = value ; } } ) ; return result ; } 
function transform ( object , callback , accumulator , this Arg ) { var is Arr = is Array ( object ) ; callback = base Create Callback ( callback , this Arg , 4 ) ; if ( accumulator = = null ) { if ( is Arr ) { accumulator = [ ] ; } else { var ctor = object & & object . constructor , proto = ctor & & ctor . prototype ; accumulator = create Object ( proto ) ; } } ( is Arr ? for Each : for Own ) ( object , function ( value , index , object ) { return callback ( accumulator , value , index , object ) ; } ) ; return accumulator ; } 
function pluck ( collection , property ) { var index = - 1 , length = collection ? collection . length : 0 ; if ( typeof length = = 'number ' ) { var result = Array ( length ) ; while ( + + index < length ) { result [ index ] = collection [ index ] [ property ] ; } } return result | | map ( collection , property ) ; } 
function reduce Right ( collection , callback , accumulator , this Arg ) { var noaccum = arguments . length < 3 ; callback = base Create Callback ( callback , this Arg , 4 ) ; for Each Right ( collection , function ( value , index , collection ) { accumulator = noaccum ? ( noaccum = false , value ) : callback ( accumulator , value , index , collection ) ; } ) ; return accumulator ; } 
function sample ( collection , n , guard ) { var length = collection ? collection . length : 0 ; if ( typeof length ! = 'number ' ) { collection = values ( collection ) ; } if ( n = = null | | guard ) { return collection ? collection [ random ( length - 1 ) ] : undefined ; } var result = shuffle ( collection ) ; result . length = native Min ( native Max ( 0 , n ) , result . length ) ; return result ; } 
function sort By ( collection , callback , this Arg ) { var index = - 1 , length = collection ? collection . length : 0 , result = Array ( typeof length = = 'number ' ? length : 0 ) ; callback = lodash . create Callback ( callback , this Arg , 3 ) ; for Each ( collection , function ( value , key , collection ) { var object = result [ + + index ] = get Object ( ) ; object . criteria = callback ( value , key , collection ) ; object . index = index ; object . value = value ; } ) ; length = result . length ; result . sort ( compare Ascending ) ; while ( length - - ) { var object = result [ length ] ; result [ length ] = object . value ; release Object ( object ) ; } return result ; } 
function difference ( array ) { var index = - 1 , index Of = get Index Of ( ) , length = array ? array . length : 0 , seen = base Flatten ( arguments , true , true , 1 ) , result = [ ] ; var is Large = length > = large Array Size & & index Of = = = base Index Of ; if ( is Large ) { var cache = create Cache ( seen ) ; if ( cache ) { index Of = cache Index Of ; seen = cache ; } else { is Large = false ; } } while ( + + index < length ) { var value = array [ index ] ; if ( index Of ( seen , value ) < 0 ) { result . push ( value ) ; } } if ( is Large ) { release Object ( seen ) ; } return result ; } 
function flatten ( array , is Shallow , callback , this Arg ) { 
function intersection ( array ) { var args = arguments , args Length = args . length , args Index = - 1 , caches = get Array ( ) , index = - 1 , index Of = get Index Of ( ) , length = array ? array . length : 0 , result = [ ] , seen = get Array ( ) ; while ( + + args Index < args Length ) { var value = args [ args Index ] ; caches [ args Index ] = index Of = = = base Index Of & & ( value ? value . length : 0 ) > = large Array Size & & create Cache ( args Index ? args [ args Index ] : seen ) ; } outer : while ( + + index < length ) { var cache = caches [ 0 ] ; value = array [ index ] ; if ( ( cache ? cache Index Of ( cache , value ) : index Of ( seen , value ) ) < 0 ) { args Index = args Length ; ( cache | | seen ) . push ( value ) ; while ( - - args Index ) { cache = caches [ args Index ] ; if ( ( cache ? cache Index Of ( cache , value ) : index Of ( args [ args Index ] , value ) ) < 0 ) { continue outer ; } } result . push ( value ) ; } } while ( args Length - - ) { cache = caches [ args Length ] ; if ( cache ) { release Object ( cache ) ; } } release Array ( caches ) ; release Array ( seen ) ; return result ; } 
function uniq ( array , is Sorted , callback , this Arg ) { 
function bind ( func , this Arg ) { return arguments . length > 2 ? create Bound ( func , 1 7 , native Slice . call ( arguments , 2 ) , null , this Arg ) : create Bound ( func , 1 , null , null , this Arg ) ; } 
function bind All ( object ) { var funcs = arguments . length > 1 ? base Flatten ( arguments , true , false , 1 ) : functions ( object ) , index = - 1 , length = funcs . length ; while ( + + index < length ) { var key = funcs [ index ] ; object [ key ] = create Bound ( object [ key ] , 1 , null , null , object ) ; } return object ; } 
function bind Key ( object , key ) { return arguments . length > 2 ? create Bound ( key , 1 9 , native Slice . call ( arguments , 2 ) , null , object ) : create Bound ( key , 3 , null , null , object ) ; } 
function curry ( func , arity ) { arity = typeof arity = = 'number ' ? arity : ( + arity | | func . length ) ; return create Bound ( func , 4 , null , null , null , arity ) ; } 
function wrap ( value , wrapper ) { if ( ! is Function ( wrapper ) ) { throw new Type Error ; } return function ( ) { var args = [ value ] ; push . apply ( args , arguments ) ; return wrapper . apply ( this , args ) ; } ; } 
function mixin ( object , source ) { var ctor = object , is Func = ! source | | is Function ( ctor ) ; if ( ! source ) { ctor = lodash Wrapper ; source = object ; object = lodash ; } for Each ( functions ( source ) , function ( method Name ) { var func = object [ method Name ] = source [ method Name ] ; if ( is Func ) { ctor . prototype [ method Name ] = function ( ) { var value = this . _ _wrapped _ _ , args = [ value ] ; push . apply ( args , arguments ) ; var result = func . apply ( object , args ) ; if ( value & & typeof value = = 'object ' & & value = = = result ) { return this ; } result = new ctor ( result ) ; result . _ _chain _ _ = this . _ _chain _ _ ; return result ; } ; } } ) ; } 
function ( ) { var target = arguments [ 0 ] ; for ( var i = 1 , l = arguments . length ; i < l ; i + + ) { var extension = arguments [ i ] ; 
function ( ) { this . mixin . deep = this . mixin . supplement = true ; var ret = this . mixin . apply ( this , arguments ) ; this . mixin . deep = this . mixin . supplement = false ; return ret ; } 
function ( args ) { var x = _ . is Finite ( args . x ) ? args . x : 2 ; return _ . template ( ' <filter > <fe Gaussian Blur std Deviation = " $ {std Deviation } " / > < /filter > ' , { std Deviation : _ . is Finite ( args . y ) ? [ x , args . y ] : x } ) ; } 
function ( args ) { return _ . template ( ' <filter > <fe Gaussian Blur in = "Source Alpha " std Deviation = " $ {blur } " / > <fe Offset dx = " $ {dx } " dy = " $ {dy } " result = "offsetblur " / > <fe Flood flood -color = " $ {color } " / > <fe Composite in 2 = "offsetblur " operator = "in " / > <fe Merge > <fe Merge Node / > <fe Merge Node in = "Source Graphic " / > < /fe Merge > < /filter > ' , { dx : args . dx | | 0 , dy : args . dy | | 0 , color : args . color | | 'black ' , blur : _ . is Finite ( args . blur ) ? args . blur : 4 } ) ; } 
function ( args ) { var amount = _ . is Finite ( args . amount ) ? args . amount : 1 ; return _ . template ( ' <filter > <fe Color Matrix type = "matrix " values = " $ {a } $ {b } $ {c } 0 0 $ {d } $ {e } $ {f } 0 0 $ {g } $ {b } $ {h } 0 0 0 0 0 1 0 " / > < /filter > ' , { a : 0 . 2 1 2 6 + 0 . 7 8 7 4 * ( 1 - amount ) , b : 0 . 7 1 5 2 - 0 . 7 1 5 2 * ( 1 - amount ) , c : 0 . 0 7 2 2 - 0 . 0 7 2 2 * ( 1 - amount ) , d : 0 . 2 1 2 6 - 0 . 2 1 2 6 * ( 1 - amount ) , e : 0 . 7 1 5 2 + 0 . 2 8 4 8 * ( 1 - amount ) , f : 0 . 0 7 2 2 - 0 . 0 7 2 2 * ( 1 - amount ) , g : 0 . 2 1 2 6 - 0 . 2 1 2 6 * ( 1 - amount ) , h : 0 . 0 7 2 2 + 0 . 9 2 7 8 * ( 1 - amount ) } ) ; } 
function ( args ) { var amount = _ . is Finite ( args . amount ) ? args . amount : 1 ; return _ . template ( ' <filter > <fe Color Matrix type = "saturate " values = " $ {amount } " / > < /filter > ' , { amount : 1 - amount } ) ; } 
function create Element ( el , attrs , children ) { if ( ! el ) return undefined ; 
function VElement ( el ) { this . node = el ; if ( ! this . node . id ) { this . node . id = _ . unique Id ( 'v _ ' ) ; } } 
function ( sx , sy ) { sy = ( typeof sy = = = 'undefined ' ) ? sx : sy ; var transform Attr = this . attr ( 'transform ' ) | | ' ' , transform = parse Transform String ( transform Attr ) ; 
function ( without Transformations , target ) { 
function ( x , y ) { var svg = this . svg ( ) . node ; var p = svg . create SVGPoint ( ) ; p . x = x ; p . y = y ; try { var global Point = p . matrix Transform ( svg . get Screen CTM ( ) . inverse ( ) ) ; var global To Local Matrix = this . node . get Transform To Element ( svg ) . inverse ( ) ; } catch ( e ) { 
function ( position , reference , target ) { 
function point ( x , y ) { if ( ! ( this instanceof point ) ) return new point ( x , y ) ; var xy ; if ( y = = = undefined & & Object ( x ) ! = = x ) { xy = x . split ( _ . index Of ( x , " @ " ) = = = - 1 ? " " : " @ " ) ; this . x = parse Int ( xy [ 0 ] , 1 0 ) ; this . y = parse Int ( xy [ 1 ] , 1 0 ) ; } else if ( Object ( x ) = = = x ) { this . x = x . x ; this . y = x . y ; } else { this . x = x ; this . y = y ; } } 
function ( r ) { if ( r . contains Point ( this ) ) { return this ; } this . x = mmin ( mmax ( this . x , r . x ) , r . x + r . width ) ; this . y = mmin ( mmax ( this . y , r . y ) , r . y + r . height ) ; return this ; } 
function ( p ) { p = point ( p ) ; 
function ( len ) { var s = ( len | | 1 ) / this . magnitude ( ) ; this . x = s * this . x ; this . y = s * this . y ; return this ; } 
function ( o ) { o = ( o & & point ( o ) ) | | point ( 0 , 0 ) ; var x = this . x ; var y = this . y ; this . x = sqrt ( ( x - o . x ) * ( x - o . x ) + ( y - o . y ) * ( y - o . y ) ) ; 
function ( o , angle ) { angle = ( angle + 3 6 0 ) % 3 6 0 ; this . to Polar ( o ) ; this . y + = to Rad ( angle ) ; var p = point . from Polar ( this . x , this . y , o ) ; this . x = p . x ; this . y = p . y ; return this ; } 
function ( ref , distance ) { var theta = to Rad ( point ( ref ) . theta ( this ) ) ; return this . offset ( cos ( theta ) * distance , - sin ( theta ) * distance ) ; } 
function ( dx , dy , ref ) { 
function line ( p 1 , p 2 ) { if ( ! ( this instanceof line ) ) return new line ( p 1 , p 2 ) ; this . start = point ( p 1 ) ; this . end = point ( p 2 ) ; } 
function rect ( x , y , w , h ) { if ( ! ( this instanceof rect ) ) return new rect ( x , y , w , h ) ; if ( y = = = undefined ) { y = x . y ; w = x . width ; h = x . height ; x = x . x ; } this . x = x ; this . y = y ; this . width = w ; this . height = h ; } 
function ( p , angle ) { p = point ( p ) ; var center = point ( this . x + this . width / 2 , this . y + this . height / 2 ) ; var result ; if ( angle ) p . rotate ( center , angle ) ; 
function ( r ) { this . x + = r . x ; this . y + = r . y ; this . width + = r . width ; this . height + = r . height ; return this ; } 
function ellipse ( c , a , b ) { if ( ! ( this instanceof ellipse ) ) return new ellipse ( c , a , b ) ; c = point ( c ) ; this . x = c . x ; this . y = c . y ; this . a = a ; this . b = b ; } 
function ( p , angle ) { p = point ( p ) ; if ( angle ) p . rotate ( point ( this . x , this . y ) , angle ) ; var dx = p . x - this . x ; var dy = p . y - this . y ; var result ; if ( dx = = = 0 ) { result = this . bbox ( ) . point Nearest To Point ( p ) ; if ( angle ) return result . rotate ( point ( this . x , this . y ) , - angle ) ; return result ; } var m = dy / dx ; var m Squared = m * m ; var a Squared = this . a * this . a ; var b Squared = this . b * this . b ; var x = sqrt ( 1 / ( ( 1 / a Squared ) + ( m Squared / b Squared ) ) ) ; x = dx < 0 ? - x : x ; var y = m * x ; result = point ( this . x + x , this . y + y ) ; if ( angle ) return result . rotate ( point ( this . x , this . y ) , - angle ) ; return result ; } 
function ( points ) { var control Points = this . get Curve Control Points ( points ) ; var path = [ 'M ' , points [ 0 ] . x , points [ 0 ] . y ] ; for ( var i = 0 ; i < control Points [ 0 ] . length ; i + + ) { path . push ( 'C ' , control Points [ 0 ] [ i ] . x , control Points [ 0 ] [ i ] . y , control Points [ 1 ] [ i ] . x , control Points [ 1 ] [ i ] . y , points [ i + 1 ] . x , points [ i + 1 ] . y ) ; } return path ; } 
function ( knots ) { var first Control Points = [ ] ; var second Control Points = [ ] ; var n = knots . length - 1 ; var i ; 
function ( rhs ) { var n = rhs . length ; 
function ( model , opt ) { opt = opt | | { } ; if ( _ . is Undefined ( opt . inbound ) & & _ . is Undefined ( opt . outbound ) ) { opt . inbound = opt . outbound = true ; } var links = [ ] ; this . each ( function ( cell ) { var source = cell . get ( 'source ' ) ; var target = cell . get ( 'target ' ) ; if ( source & & source . id = = = model . id & & opt . outbound ) { links . push ( cell ) ; } if ( target & & target . id = = = model . id & & opt . inbound ) { links . push ( cell ) ; } } ) ; return links ; } 
function ( model ) { _ . each ( this . get Connected Links ( model ) , function ( link ) { link . set ( link . get ( 'source ' ) . id = = = model . id ? 'source ' : 'target ' , g . point ( 0 , 0 ) ) ; } ) ; } 
function ( attrs , value , opt ) { var current Attrs = this . get ( 'attrs ' ) ; var delim = ' / ' ; if ( _ . is String ( attrs ) ) { 
function ( ) { var el ; if ( ! this . el ) { var attrs = _ . extend ( { id : this . id } , _ . result ( this , 'attributes ' ) ) ; if ( this . class Name ) attrs [ 'class ' ] = _ . result ( this , 'class Name ' ) ; el = V ( _ . result ( this , 'tag Name ' ) , attrs ) . node ; } else { el = _ . result ( this , 'el ' ) } this . set Element ( el , false ) ; } 
function ( el ) { var $el = this . $ ( el ) ; if ( $el . length = = = 0 | | $el [ 0 ] = = = this . el ) { 
function ( selector , filter ) { var $selected = this . find By Selector ( selector ) ; 
function ( selector , attr , gradient ) { var $selected = this . find By Selector ( selector ) ; 
function ( el , selector ) { if ( el = = = this . el ) { return selector ; } var index = $ ( el ) . index ( ) ; selector = el . tag Name + ' :nth -child ( ' + ( index + 1 ) + ' ) ' + ' ' + ( selector | | ' ' ) ; return this . get Selector ( $ ( el ) . parent ( ) [ 0 ] , selector + ' ' ) ; } 
function ( cell , rendering Only Attrs ) { var all Attrs = this . model . get ( 'attrs ' ) ; var rotatable = V ( this . $ ( ' .rotatable ' ) [ 0 ] ) ; if ( rotatable ) { var rotation = rotatable . attr ( 'transform ' ) ; rotatable . attr ( 'transform ' , ' ' ) ; } var relatively Positioned = [ ] ; _ . each ( rendering Only Attrs | | all Attrs , function ( attrs , selector ) { 
function ( ) { var markup = this . model . markup | | this . model . get ( 'markup ' ) ; if ( markup ) { var nodes = V ( markup ) ; V ( this . el ) . append ( nodes ) ; } else { throw new Error ( 'properties .markup is missing while the default render ( ) implementation is used . ' ) ; } this . update ( ) ; this . resize ( ) ; this . rotate ( ) ; this . translate ( ) ; return this ; } 
function ( evt , x , y ) { if ( 
function ( idx , value ) { idx = idx | | 0 ; var labels = this . get ( 'labels ' ) | | [ ] ; 
function ( ) { this . $el . empty ( ) ; 
function ( ) { 
function ( end Type ) { function watch End ( link , end ) { end = end | | { } ; var previous End = link . previous ( end Type ) | | { } ; 
function ( vertex ) { this . model . set ( 'attrs ' , this . model . get ( 'attrs ' ) | | { } ) ; var attrs = this . model . get ( 'attrs ' ) ; 
function ( vertices ) { var source Point = g . point ( this . _source Point ) ; var target Point = g . point ( this . _target Point ) ; 
function ( end , selector Or Point , reference Selector Or Point ) { var spot ; if ( this . _is Point ( selector Or Point ) ) { 
function ( vertices ) { vertices = ( vertices | | [ ] ) . slice ( ) ; var manhattan Vertices = [ ] ; 
function find Middle Vertex ( p 1 , p 2 , preferred Direction ) { var direction = best Direction ( p 1 , p 2 , preferred Direction ) ; if ( direction = = = 'down ' | | direction = = = 'up ' ) { return { x : p 1 . x , y : p 2 . y , d : direction } ; } return { x : p 2 . x , y : p 1 . y , d : direction } ; } 
function ( ) { this . model . trigger ( 'batch :start ' ) ; this . _z = this . model . get ( 'z ' ) ; this . model . set ( 'z ' , Number . MAX _VALUE ) ; 
function ( grid Width , grid Height , padding ) { grid Width = grid Width | | 1 ; grid Height = grid Height | | 1 ; padding = padding | | 0 ; 
function ( cell ) { var id = _ . is String ( cell ) ? cell : cell . id ; var $view = this . $ ( ' [model -id = " ' + id + ' " ] ' ) ; if ( $view . length ) { return $view . data ( 'view ' ) ; } return undefined ; } 
function ( p ) { p = g . point ( p ) ; var views = _ . map ( this . model . get Elements ( ) , this . find View By Model ) ; return _ . filter ( views , function ( view ) { return g . rect ( V ( view . el ) . bbox ( false , this . viewport ) ) . contains Point ( p ) ; } , this ) ; } 
function ( r ) { r = g . rect ( r ) ; var views = _ . map ( this . model . get Elements ( ) , this . find View By Model ) ; return _ . filter ( views , function ( view ) { return r . intersect ( g . rect ( V ( view . el ) . bbox ( false , this . viewport ) ) ) ; } , this ) ; } 
function ( command ) { return _ . is Array ( command ) ? _ . find ( command , function ( single Cmd ) { return ! this . _validate Command ( single Cmd ) ; } , this ) : this . _validate Command ( command ) ; } 
function ( command ) { 
function ( selection , graph , opt ) { opt = opt | | { } ; 
function ( graph , opt ) { opt = opt | | { } ; if ( opt . use Local Storage & & this . length = = = 0 & & window . local Storage ) { this . reset ( JSON . parse ( local Storage . get Item ( 'joint .ui .Clipboard .cells ' ) ) ) ; } graph . trigger ( 'batch :start ' ) ; this . each ( function ( cell ) { cell . unset ( 'z ' ) ; if ( ( cell instanceof joint . dia . Link ) & & opt . link ) { cell . set ( opt . link ) ; } graph . add Cell ( cell . to JSON ( ) ) ; } ) ; graph . trigger ( 'batch :stop ' ) ; } 
function ( ) { this . _magnets = [ ] ; var $link = this . $ ( ' .link ' ) ; var magnet Elements = this . options . cell View . $ ( ' [magnet = "true " ] ' ) ; if ( this . options . magnet Filter ) { if ( _ . is Function ( this . options . magnet Filter ) ) { 
function ( path , options ) { var cell = this . options . cell View . model ; var value = joint . util . get By Path ( cell . attributes , path , ' / ' ) ; if ( _ . is Undefined ( value ) & & ! _ . is Undefined ( options . default Value ) ) { value = options . default Value ; } if ( options . value Reg Exp ) { if ( _ . is Undefined ( value ) ) { throw new Error ( 'Inspector : default Value must be present when value Reg Exp is used . ' ) ; } var value Match = value . match ( new Reg Exp ( options . value Reg Exp ) ) ; value = value Match & & value Match [ 2 ] ; } return value ; } 
function ( type , value , target Element ) { switch ( type ) { case 'number ' : value = parse Float ( value ) ; break ; case 'toggle ' : value = target Element . checked ; break ; default : value = value ; break ; } return value ; } 
function init Layout Graph ( input Graph ) { var g = new CDigraph ( ) ; input Graph . each Node ( function ( u , value ) { if ( value = = = undefined ) value = { } ; g . add Node ( u , { width : value . width , height : value . height } ) ; if ( value . has Own Property ( 'rank ' ) ) { g . node ( u ) . pref Rank = value . rank ; } } ) ; 
function normalize ( g ) { var dummy Count = 0 ; g . each Edge ( function ( e , s , t , a ) { var source Rank = g . node ( s ) . rank ; var target Rank = g . node ( t ) . rank ; if ( source Rank + 1 < target Rank ) { for ( var u = s , rank = source Rank + 1 , i = 0 ; rank < target Rank ; + + rank , + + i ) { var v = ' _D ' + ( + + dummy Count ) ; var node = { width : a . width , height : a . height , edge : { id : e , source : s , target : t , attrs : a } , rank : rank , dummy : true } ; 
function undo Normalize ( g ) { g . each Node ( function ( u , a ) { if ( a . dummy ) { if ( 'index ' in a ) { var edge = a . edge ; if ( ! g . has Edge ( edge . id ) ) { g . add Edge ( edge . id , edge . source , edge . target , edge . attrs ) ; } var points = g . edge ( edge . id ) . points ; points [ a . index ] = { x : a . x , y : a . y , ul : a . ul , ur : a . ur , dl : a . dl , dr : a . dr } ; } g . del Node ( u ) ; } } ) ; } 
function fixup Edge Points ( g ) { g . each Edge ( function ( e , s , t , a ) { if ( a . reversed ) a . points . reverse ( ) ; } ) ; } 
function delegate Property ( f ) { return function ( ) { if ( ! arguments . length ) return f ( ) ; f . apply ( null , arguments ) ; return self ; } ; } 
function order ( g , max Sweeps ) { if ( arguments . length < 2 ) { max Sweeps = DEFAULT _MAX _SWEEPS ; } var layer Graphs = init Layer Graphs ( g ) ; 
function save Best ( g ) { var graph = g . graph ( ) ; var cc = cross Count ( g ) ; if ( ! ( 'order CC ' in graph ) | | graph . order CC > cc ) { graph . order CC = cc ; graph . order = { } ; g . each Node ( function ( u , value ) { if ( 'order ' in value ) { graph . order [ u ] = value . order ; } } ) ; return true ; } return false ; } 
function cross Count ( g ) { var cc = 0 ; var ordering = util . ordering ( g ) ; for ( var i = 1 ; i < ordering . length ; + + i ) { cc + = two Layer Cross Count ( g , ordering [ i - 1 ] , ordering [ i ] ) ; } return cc ; } 
function undir Edge Id ( u , v ) { return u < v ? u . to String ( ) . length + ' : ' + u + ' - ' + v : v . to String ( ) . length + ' : ' + v + ' - ' + u ; } 
function horizontal Compaction ( g , layering , pos , root , align ) { var sink = { } , 
function run ( g , use Simplex ) { var self Loops = remove Self Loops ( g ) ; 
function acyclic ( g ) { var on Stack = { } , visited = { } , reverse Count = 0 ; function dfs ( u ) { if ( u in visited ) return ; visited [ u ] = on Stack [ u ] = true ; g . out Edges ( u ) . for Each ( function ( e ) { var t = g . target ( e ) , value ; if ( u = = = t ) { console . error ( 'Warning : found self loop " ' + e + ' " for node " ' + u + ' " ' ) ; } else if ( t in on Stack ) { value = g . edge ( e ) ; g . del Edge ( e ) ; value . reversed = true ; + + reverse Count ; g . add Edge ( e , t , u , value ) ; } else { dfs ( t ) ; } } ) ; delete on Stack [ u ] ; } g . each Node ( function ( u ) { dfs ( u ) ; } ) ; util . log ( 2 , 'Acyclic Phase : reversed ' + reverse Count + ' edge (s ) ' ) ; return reverse Count ; } 
function undo ( g ) { g . each Edge ( function ( e , s , t , a ) { if ( a . reversed ) { delete a . reversed ; g . del Edge ( e ) ; g . add Edge ( e , t , s , a ) ; } } ) ; } 
function find Min Slack ( ) { var result , e Slack = Number . POSITIVE _INFINITY ; min Len . for Each ( function ( mle ) { if ( remaining . has ( mle . u ) ! = = remaining . has ( mle . v ) ) { var mle Slack = rank Util . slack ( g , mle . u , mle . v , mle . len ) ; if ( mle Slack < e Slack ) { if ( ! remaining . has ( mle . u ) ) { result = { tree Node : mle . u , graph Node : mle . v , len : mle . len , reversed : false , weight : mle . weight } ; } else { result = { tree Node : mle . v , graph Node : mle . u , len : - mle . len , reversed : true , weight : mle . weight } ; } e Slack = mle Slack ; } } } ) ; return result ; } 
function incidence Id ( u , v ) { return u < v ? u . length + ' : ' + u + ' - ' + v : v . length + ' : ' + v + ' - ' + u ; } 
function slack ( graph , u , v , min Len ) { return Math . abs ( graph . node ( u ) . rank - graph . node ( v ) . rank ) - min Len ; } 
function init Cut Values ( graph , spanning Tree ) { compute Low Lim ( spanning Tree ) ; spanning Tree . each Edge ( function ( id , u , v , tree Value ) { tree Value . cut Value = 0 ; } ) ; 
function dfs ( n ) { var children = spanning Tree . successors ( n ) ; for ( var c in children ) { var child = children [ c ] ; dfs ( child ) ; } if ( n ! = = spanning Tree . graph ( ) . root ) { set Cut Value ( graph , spanning Tree , n ) ; } } 
function compute Low Lim ( tree ) { var post Order Num = 0 ; function dfs ( n ) { var children = tree . successors ( n ) ; var low = post Order Num ; for ( var c in children ) { var child = children [ c ] ; dfs ( child ) ; low = Math . min ( low , tree . node ( child ) . low ) ; } tree . node ( n ) . low = low ; tree . node ( n ) . lim = post Order Num + + ; } dfs ( tree . graph ( ) . root ) ; } 
function set Cut Value ( graph , tree , child ) { var parent Edge = tree . in Edges ( child ) [ 0 ] ; 
function in Subtree ( tree , n , root ) { return ( tree . node ( root ) . low < = tree . node ( n ) . lim & & tree . node ( n ) . lim < = tree . node ( root ) . lim ) ; } 
function leave Edge ( tree ) { var edges = tree . edges ( ) ; for ( var n in edges ) { var e = edges [ n ] ; var tree Value = tree . edge ( e ) ; if ( tree Value . cut Value < 0 ) { return e ; } } return null ; } 
function enter Edge ( graph , tree , e ) { var source = tree . source ( e ) ; var target = tree . target ( e ) ; var lower = tree . node ( target ) . lim < tree . node ( source ) . lim ? target : source ; 
function exchange ( graph , tree , e , f ) { tree . del Edge ( e ) ; var source = graph . source ( f ) ; var target = graph . target ( f ) ; 
function redirect ( v ) { var edges = tree . in Edges ( v ) ; for ( var i in edges ) { var e = edges [ i ] ; var u = tree . source ( e ) ; var value = tree . edge ( e ) ; redirect ( u ) ; tree . del Edge ( e ) ; value . reversed = ! value . reversed ; tree . add Edge ( e , v , u , value ) ; } } 
function adjust Ranks ( graph , tree ) { function dfs ( p ) { var children = tree . successors ( p ) ; children . for Each ( function ( c ) { var min Len = minimum Length ( graph , p , c ) ; graph . node ( c ) . rank = graph . node ( p ) . rank + min Len ; dfs ( c ) ; } ) ; } dfs ( tree . graph ( ) . root ) ; } 
function minimum Length ( graph , u , v ) { var out Edges = graph . out Edges ( u , v ) ; if ( out Edges . length > 0 ) { return util . max ( out Edges . map ( function ( e ) { return graph . edge ( e ) . min Len ; } ) ) ; } var in Edges = graph . in Edges ( u , v ) ; if ( in Edges . length > 0 ) { return - util . max ( in Edges . map ( function ( e ) { return graph . edge ( e ) . min Len ; } ) ) ; } } 
function log ( level ) { if ( log . level > = level ) { console . log . apply ( console , Array . prototype . slice . call ( arguments , 1 ) ) ; } } 
function Set ( initial Keys ) { this . _size = 0 ; this . _keys = { } ; if ( initial Keys ) { for ( var i = 0 , il = initial Keys . length ; i < il ; + + i ) { this . add ( initial Keys [ i ] ) ; } } } 
function values ( o ) { var ks = Object . keys ( o ) , len = ks . length , result = new Array ( len ) , i ; for ( i = 0 ; i < len ; + + i ) { result [ i ] = o [ ks [ i ] ] ; } return result ; } 
function dijkstra All ( g , weight Func , incident Func ) { var results = { } ; g . nodes ( ) . for Each ( function ( u ) { results [ u ] = dijkstra ( g , u , weight Func , incident Func ) ; } ) ; return results ; } 
function is Acyclic ( g ) { try { topsort ( g ) ; } catch ( e ) { if ( e instanceof topsort . Cycle Exception ) return false ; throw e ; } return true ; } 
function topsort ( g ) { if ( ! g . is Directed ( ) ) { throw new Error ( "topsort can only be applied to a directed graph . Bad input : " + g ) ; } var visited = { } ; var stack = { } ; var results = [ ] ; function visit ( node ) { if ( node in stack ) { throw new Cycle Exception ( ) ; } if ( ! ( node in visited ) ) { stack [ node ] = true ; visited [ node ] = true ; g . predecessors ( node ) . for Each ( function ( pred ) { visit ( pred ) ; } ) ; delete stack [ node ] ; results . push ( node ) ; } } var sinks = g . sinks ( ) ; if ( g . order ( ) ! = = 0 & & sinks . length = = = 0 ) { throw new Cycle Exception ( ) ; } g . sinks ( ) . for Each ( function ( sink ) { visit ( sink ) ; } ) ; return results ; } 
function ( elements , dimension ) { return _ . reduce ( elements , function ( max , el ) { return Math . max ( el . get ( 'size ' ) [ dimension ] , max ) ; } , 0 ) ; } 
function create Canvas ( ) { canvas = document . create Element ( 'canvas ' ) ; canvas . width = image Width ; canvas . height = image Height ; 
function on ( el , types , fn , context ) { types . split ( ' ' ) . for Each ( function ( type ) { L . Dom Event . on ( el , type , fn , context ) } ) } 
function ( eventaur , settings ) { var gith = this ; this . settings = settings | | { } ; 
function ( eventaur , port ) { var gith = this ; 
function get User Media ( constraints ) { if ( props ( 'navigator .media Devices .get User Media ' ) . had By ( window ) ) { let medias = props ( 'navigator .media Devices ' ) . from ( window ) return medias . get User Media ( constraints ) } let user Media Getter = navigator . get User Media | | navigator . webkit Get User Media | | navigator . moz Get User Media | | navigator . ms Get User Media if ( ! user Media Getter ) { throw new Error ( 'get User Media is not supported by this browser ' ) } return new Promise ( ( resolve , reject ) = > { user Media Getter ( constraints , resolve , reject ) } ) } 
function build Config ( wanted Env ) { let is Valid = wanted Env & & wanted Env . length > 0 & & allowed Envs . index Of ( wanted Env ) ! = = - 1 ; let valid Env = is Valid ? wanted Env : 'dev ' ; let config = require ( path . join ( _ _dirname , 'cfg / ' + valid Env ) ) ; return config ; } 
async function barcode Decoder ( image , options ) { 
function create Image Data ( image ) { const canvas = document . create Element ( 'canvas ' ) const ctx = canvas . get Context ( ' 2d ' ) const width = image . natural Width const height = image . natural Height canvas . width = width canvas . height = height ctx . draw Image ( image , 0 , 0 ) return ctx . get Image Data ( 0 , 0 , image . natural Width , image . natural Height ) } 
async function get Image Data From Source ( source ) { const is String Source = typeof source = = = 'string ' const is URLSource = is String Source ? is Url ( source ) : false const { tag Name } = source return new Promise ( ( resolve , reject ) = > { 
function stdopts ( opts ) { opts = opts | | { } opts . keys = opts . keys ! = = false 
function get _timeout _delay ( date , settings ) { var now = get _now ( ) ; var diff = ( ( now . get Time ( ) - date . get Time ( ) ) / 1 0 0 0 ) ; var diff _abs = Math . abs ( diff ) ; if ( is Na N ( diff ) ) return ; var last _limit = 0 ; for ( var i in settings . units ) { var unit = settings . units [ i ] ; 
function get _date ( element , settings ) { var date = element . data ( "easydate .date " ) ; if ( is Na N ( date ) ) { var timestamp ; var time = Date . parse ( timestamp = element . attr ( "title " ) ) | | Date . parse ( timestamp = element . html ( ) ) ; if ( ! is Na N ( time ) ) { date = new Date ( ) ; date . set Time ( time ) ; element . data ( "easydate .date " , date ) ; if ( settings . set _title & & ! element . attr ( "title " ) ) element . attr ( "title " , timestamp ) ; } } return date ; } 
function update _time ( element ) { var settings = element . data ( "easydate .settings " ) ; var element _id = $ . data ( element [ 0 ] ) ; elements [ element _id ] = element ; delete updates [ element _id ] ; var date = get _date ( element , settings ) ; if ( is Na N ( date ) ) return ; element . html ( format _date ( date , settings ) ) ; if ( settings . live ) { var timeout = get _timeout _delay ( date , settings ) ; if ( ! is Na N ( timeout ) ) { if ( timeout > 2 1 4 7 4 8 3 6 4 7 ) timeout = 2 1 4 7 4 8 3 6 4 7 ; 
function parse ( s , buf , offset ) { var i = ( buf & & offset ) | | 0 , ii = 0 ; buf = buf | | [ ] ; s . to Lower Case ( ) . replace ( / [ 0 - 9a -f ] { 2 } / g , function ( oct ) { if ( ii < 1 6 ) { 
function ( req , res , next ) { var props = get Props ( req . query ) ; 
function ( type ) { var qp = { error : type , state : props . state } ; res . redirect ( props . redirect _uri + " ? " + qs . stringify ( qp ) ) ; } 
function ( req , res , next ) { var props = get Props ( req . body ) ; 
function ( req , res , next ) { var props = get Props ( req . query ) ; 
function ( req , res , next ) { var props = get Props ( req . body ) ; var retry = function ( message ) { req . session . oauth 2Authc Error = message ; res . redirect ( 3 0 3 , " /oauth 2 /authc ? " + qs . stringify ( props ) ) ; } ; 
function ( props ) { var inst , cls = this , key = props [ cls . key Attr ] ; if ( key & & _ . has ( cls . cache , key ) ) { inst = cls . cache [ key ] ; 
function init ( ) { if ( api . initialized ) { return ; } var test Range ; var implements Dom Range = false , implements Text Range = false ; 
function split Data Node ( node , index ) { var new Node = node . clone Node ( false ) ; new Node . delete Data ( 0 , index ) ; node . delete Data ( index , node . length - index ) ; insert After ( new Node , node ) ; return new Node ; } 
function is Non Text Partially Selected ( node , range ) { return ( node . node Type ! = 3 ) & & ( dom . is Ancestor Of ( node , range . start Container , true ) | | dom . is Ancestor Of ( node , range . end Container , true ) ) ; } 
function Range Iterator ( range , clone Partially Selected Text Nodes ) { this . range = range ; this . clone Partially Selected Text Nodes = clone Partially Selected Text Nodes ; if ( ! range . collapsed ) { this . sc = range . start Container ; this . so = range . start Offset ; this . ec = range . end Container ; this . eo = range . end Offset ; var root = range . common Ancestor Container ; if ( this . sc = = = this . ec & & dom . is Character Data Node ( this . sc ) ) { this . is Single Character Data Node = true ; this . _first = this . _last = this . _next = this . sc ; } else { this . _first = this . _next = ( this . sc = = = root & & ! dom . is Character Data Node ( this . sc ) ) ? this . sc . child Nodes [ this . so ] : dom . get Closest Ancestor In ( this . sc , root , true ) ; this . _last = ( this . ec = = = root & & ! dom . is Character Data Node ( this . ec ) ) ? this . ec . child Nodes [ this . eo - 1 ] : dom . get Closest Ancestor In ( this . ec , root , true ) ; } } } 
function Range Node Iterator ( range , node Types , filter ) { this . nodes = get Nodes In Range ( range , node Types , filter ) ; this . _next = this . nodes [ 0 ] ; this . _position = 0 ; } 
function ( fragment Str ) { 
function ( fragment Str ) { assert Not Detached ( this ) ; var doc = get Range Document ( this ) ; var el = doc . create Element ( "body " ) ; el . inner HTML = fragment Str ; return dom . fragment From Node Children ( el ) ; } 
function ( range , touching Is Intersecting ) { assert Range Valid ( this ) ; if ( get Range Document ( range ) ! = get Range Document ( this ) ) { throw new DOMException ( "WRONG _DOCUMENT _ERR " ) ; } var start Comparison = dom . compare Points ( this . start Container , this . start Offset , range . end Container , range . end Offset ) , end Comparison = dom . compare Points ( this . end Container , this . end Offset , range . start Container , range . start Offset ) ; return touching Is Intersecting ? start Comparison < = 0 & & end Comparison > = 0 : start Comparison < 0 & & end Comparison > 0 ; } 
function get Text Range Boundary Position ( text Range , whole Range Container Element , is Start , is Collapsed ) { var working Range = text Range . duplicate ( ) ; working Range . collapse ( is Start ) ; var container Element = working Range . parent Element ( ) ; For the particular case of a boundary within a text node containing line breaks (within a <pre > element , for example ) , we need a slightly complicated approach to get the boundary 's offset in IE . The facts : - Each line break is represented as \r in the text node 's data /node Value properties - Each line break is represented as \r \n in the Text Range 's 'text ' property - The 'text ' property of the Text Range does not contain trailing line breaks To get round the problem presented by the final fact above , we can use the fact that Text Range 's move Start ( ) and move End ( ) methods return the actual number of characters moved , which is not necessarily the same as the number of characters it was instructed to move . The simplest approach is to use this to store the characters moved when moving both the start and end of the range to the start of the document body and subtracting the start offset from the end offset (the "move -negative -gazillion " method ) . However , this is extremely slow when the document is large and the range is near the end of it . Clearly doing the mirror image (i .e . moving the range boundaries to the end of the document ) has the same problem . Another approach that works is to use move Start ( ) to move the start boundary of the range up to the end boundary one character at a time and incrementing a counter with the value returned by the move Start ( ) call . However , the check for whether the start boundary has reached the end boundary is expensive , so this method is slow (although unlike "move -negative -gazillion " is largely unaffected by the location of the range within the document ) . The method below is a hybrid of the two methods above . It uses the fact that a string containing the Text Range 's 'text ' property with each \r \n converted to a single \r character cannot be longer than the text of the Text Range , so the start of the range is moved that length initially and then a character at a time to make up for any trailing line breaks not contained in the 'text ' property . This has good performance in most situations compared to the previous two methods . * / var temp Range = working Range . duplicate ( ) ; var range Length = temp Range . text . replace ( / \r \n / g , " \r " ) . length ; offset = temp Range . move Start ( "character " , range Length ) ; while ( ( comparison = temp Range . compare End Points ( "Start To End " , temp Range ) ) = = - 1 ) { offset + + ; temp Range . move Start ( "character " , 1 ) ; } } else { offset = working Range . text . length ; } boundary Position = new Dom Position ( boundary Node , offset ) ; } else { 
function create Boundary Text Range ( boundary Position , is Start ) { var boundary Node , boundary Parent , boundary Offset = boundary Position . offset ; var doc = dom . get Document ( boundary Position . node ) ; var working Node , child Nodes , working Range = doc . body . create Text Range ( ) ; var node Is Data Node = dom . is Character Data Node ( boundary Position . node ) ; if ( node Is Data Node ) { boundary Node = boundary Position . node ; boundary Parent = boundary Node . parent Node ; } else { child Nodes = boundary Position . node . child Nodes ; boundary Node = ( boundary Offset < child Nodes . length ) ? child Nodes [ boundary Offset ] : null ; boundary Parent = boundary Position . node ; } 
function ( sel , range ) { var ranges = sel . get All Ranges ( ) , removed = false ; sel . remove All Ranges ( ) ; for ( var i = 0 , len = ranges . length ; i < len ; + + i ) { if ( removed | | range ! = = ranges [ i ] ) { sel . add Range ( ranges [ i ] ) ; } else { 
function ( needle ) { if ( arr . index Of ) { return arr . index Of ( needle ) ! = = - 1 ; } else { for ( var i = 0 , length = arr . length ; i < length ; i + + ) { if ( arr [ i ] = = = needle ) { return true ; } } return false ; } } 
function _wrap Matches In Node ( text Node ) { var parent Node = text Node . parent Node , temp Element = _get Temp Element ( parent Node . owner Document ) ; 
function parse ( element Or Html , rules , context , clean Up ) { wysihtml 5 . lang . object ( current Rules ) . merge ( default Rules ) . merge ( rules ) . get ( ) ; context = context | | element Or Html . owner Document | | document ; var fragment = context . create Document Fragment ( ) , is String = typeof ( element Or Html ) = = = "string " , element , new Node , first Child ; if ( is String ) { element = wysihtml 5 . dom . get As Dom ( element Or Html , context ) ; } else { element = element Or Html ; } while ( element . first Child ) { first Child = element . first Child ; element . remove Child ( first Child ) ; new Node = _convert ( first Child , clean Up ) ; if ( new Node ) { fragment . append Child ( new Node ) ; } } 
function ( iframe ) { 
function ( method ) { var range = this . get Range ( ) , body = this . doc . body , new Range , first Node , last Node , text Nodes , range Backup ; 
function ( html ) { var range = rangy . create Range ( this . doc ) , node = range . create Contextual Fragment ( html ) , last Child = node . last Child ; this . insert Node ( node ) ; if ( last Child ) { this . set After ( last Child ) ; } } 
function ( node ) { var range = this . get Range ( ) ; if ( ! range ) { return ; } try { 
function ( ) { var win = this . doc . default View , selection = win . get Selection ( ) ; selection . modify ( "extend " , "left " , "lineboundary " ) ; selection . modify ( "extend " , "right " , "lineboundary " ) ; } 
function ( text Nodes , range ) { var first Node = text Nodes [ 0 ] , last Node = text Nodes [ text Nodes . length - 1 ] ; var merges = [ ] , current Merge ; var range Start Node = first Node , range End Node = last Node ; var range Start Offset = 0 , range End Offset = last Node . length ; var text Node , preceding Text Node ; for ( var i = 0 , len = text Nodes . length ; i < len ; + + i ) { text Node = text Nodes [ i ] ; preceding Text Node = this . get Adjacent Mergeable Text Node ( text Node . parent Node , false ) ; if ( preceding Text Node ) { if ( ! current Merge ) { current Merge = new Merge ( preceding Text Node ) ; merges . push ( current Merge ) ; } current Merge . text Nodes . push ( text Node ) ; if ( text Node = = = first Node ) { range Start Node = current Merge . first Text Node ; range Start Offset = range Start Node . length ; } if ( text Node = = = last Node ) { range End Node = current Merge . first Text Node ; range End Offset = current Merge . get Length ( ) ; } } else { current Merge = null ; } } 
function ( command ) { var obj = wysihtml 5 . commands [ command ] , method = obj & & obj . value ; if ( method ) { return method . call ( obj , this . composer , command ) ; } else { try { 
function ( composer , command , value ) { var anchors = this . state ( composer , command ) ; if ( anchors ) { 
function _add Class ( element , class Name , class Reg Exp ) { if ( element . class Name ) { _remove Class ( element , class Reg Exp ) ; element . class Name + = " " + class Name ; } else { element . class Name = class Name ; } } 
function _is Blank Text Node ( node ) { return node . node Type = = = wysihtml 5 . TEXT _NODE & & ! wysihtml 5 . lang . string ( node . data ) . trim ( ) ; } 
function _get Previous Sibling That Is Not Blank ( node ) { var previous Sibling = node . previous Sibling ; while ( previous Sibling & & _is Blank Text Node ( previous Sibling ) ) { previous Sibling = previous Sibling . previous Sibling ; } return previous Sibling ; } 
function _get Next Sibling That Is Not Blank ( node ) { var next Sibling = node . next Sibling ; while ( next Sibling & & _is Blank Text Node ( next Sibling ) ) { next Sibling = next Sibling . next Sibling ; } return next Sibling ; } 
function _add Line Break Before And After ( node ) { var doc = node . owner Document , next Sibling = _get Next Sibling That Is Not Blank ( node ) , previous Sibling = _get Previous Sibling That Is Not Blank ( node ) ; if ( next Sibling & & ! _is Line Break Or Block Element ( next Sibling ) ) { node . parent Node . insert Before ( doc . create Element ( "br " ) , next Sibling ) ; } if ( previous Sibling & & ! _is Line Break Or Block Element ( previous Sibling ) ) { node . parent Node . insert Before ( doc . create Element ( "br " ) , node ) ; } } 
function _remove Line Break Before And After ( node ) { var next Sibling = _get Next Sibling That Is Not Blank ( node ) , previous Sibling = _get Previous Sibling That Is Not Blank ( node ) ; if ( next Sibling & & _is Line Break ( next Sibling ) ) { next Sibling . parent Node . remove Child ( next Sibling ) ; } if ( previous Sibling & & _is Line Break ( previous Sibling ) ) { previous Sibling . parent Node . remove Child ( previous Sibling ) ; } } 
function _exec Command ( doc , command , node Name , class Name ) { if ( class Name ) { var event Listener = dom . observe ( doc , "DOMNode Inserted " , function ( event ) { var target = event . target , display Style ; if ( target . node Type ! = = wysihtml 5 . ELEMENT _NODE ) { return ; } display Style = dom . get Style ( "display " ) . from ( target ) ; if ( display Style . substr ( 0 , 6 ) ! = = "inline " ) { 
function ( composer , command , value ) { value = typeof ( value ) = = = "object " ? value : { src : value } ; var doc = composer . doc , image = this . state ( composer ) , text Node , i , parent ; if ( image ) { 
function ( avoid Hidden Fields ) { var field , field Name , new Value , focused Element = document . query Selector ( " :focus " ) , fields = this . container . query Selector All ( SELECTOR _FIELDS ) , length = fields . length , i = 0 ; for ( ; i < length ; i + + ) { field = fields [ i ] ; 
function ( element To Change ) { var that = this , first Field = this . container . query Selector ( SELECTOR _FORM _ELEMENTS ) ; this . element To Change = element To Change ; this . _observe ( ) ; this . _interpolate ( ) ; if ( element To Change ) { this . interval = set Interval ( function ( ) { that . _interpolate ( true ) ; } , 5 0 0 ) ; } dom . add Class ( this . link , CLASS _NAME _OPENED ) ; this . container . style . display = " " ; this . fire ( "show " ) ; if ( first Field & & ! element To Change ) { try { first Field . focus ( ) ; } catch ( e ) { } } } 
function ( ) { this . observe ( "paste :composer " , function ( ) { var keep Scroll Position = true , that = this ; that . composer . selection . execute And Restore ( function ( ) { wysihtml 5 . quirks . clean Pasted HTML ( that . composer . element ) ; that . parse ( that . composer . element ) ; } , keep Scroll Position ) ; } ) ; this . observe ( "paste :textarea " , function ( ) { var value = this . textarea . get Value ( ) , new Value ; new Value = this . parse ( value ) ; this . textarea . set Value ( new Value ) ; } ) ; } 
function get Parameter List ( parameters ) { if ( parameters = = null ) { return [ ] ; } if ( typeof parameters ! = "object " ) { return OAuth . decode Form ( parameters + " " ) ; } if ( parameters instanceof Array ) { return parameters ; } var list = [ ] ; for ( var p in parameters ) { list . push ( [ p , parameters [ p ] ] ) ; } return list ; } 
function get Parameter Map ( parameters ) { if ( parameters = = null ) { return { } ; } if ( typeof parameters ! = "object " ) { return OAuth . get Parameter Map ( OAuth . decode Form ( parameters + " " ) ) ; } if ( parameters instanceof Array ) { var map = { } ; for ( var p = 0 ; p < parameters . length ; + + p ) { var key = parameters [ p ] [ 0 ] ; if ( map [ key ] = = = undefined ) { 
function complete Request ( message , accessor ) { if ( message . method = = null ) { message . method = "GET " ; } var map = OAuth . get Parameter Map ( message . parameters ) ; if ( map . oauth _consumer _key = = null ) { OAuth . set Parameter ( message , "oauth _consumer _key " , accessor . consumer Key | | " " ) ; } if ( map . oauth _token = = null & & accessor . token ! = null ) { OAuth . set Parameter ( message , "oauth _token " , accessor . token ) ; } if ( map . oauth _version = = null ) { OAuth . set Parameter ( message , "oauth _version " , " 1 . 0 " ) ; } if ( map . oauth _timestamp = = null ) { OAuth . set Parameter ( message , "oauth _timestamp " , OAuth . timestamp ( ) ) ; } if ( map . oauth _nonce = = null ) { OAuth . set Parameter ( message , "oauth _nonce " , OAuth . nonce ( 6 ) ) ; } OAuth . Signature Method . sign ( message , accessor ) ; } 
function get Authorization Header ( realm , parameters ) { var header = 'OAuth realm = " ' + OAuth . percent Encode ( realm ) + ' " ' ; var list = OAuth . get Parameter List ( parameters ) ; for ( var p = 0 ; p < list . length ; + + p ) { var parameter = list [ p ] ; var name = parameter [ 0 ] ; if ( name . index Of ( "oauth _ " ) = = 0 ) { header + = ' , ' + OAuth . percent Encode ( name ) + ' = " ' + OAuth . percent Encode ( parameter [ 1 ] ) + ' " ' ; } } return header ; } 
function correct Timestamp From Src ( parameter Name ) { parameter Name = parameter Name | | "oauth _timestamp " ; var scripts = document . get Elements By Tag Name ( 'script ' ) ; if ( scripts = = null | | ! scripts . length ) return ; var src = scripts [ scripts . length - 1 ] . src ; if ( ! src ) return ; var q = src . index Of ( " ? " ) ; if ( q < 0 ) return ; parameters = OAuth . get Parameter Map ( OAuth . decode Form ( src . substring ( q + 1 ) ) ) ; var t = parameters [ parameter Name ] ; if ( t = = null ) return ; OAuth . correct Timestamp ( t ) ; } 
function sign ( message ) { var base String = OAuth . Signature Method . get Base String ( message ) ; var signature = this . get Signature ( base String ) ; OAuth . set Parameter ( message , "oauth _signature " , signature ) ; return signature ; 
function initialize ( name , accessor ) { var consumer Secret ; if ( accessor . accessor Secret ! = null & & name . length > 9 & & name . substring ( name . length - 9 ) = = " -Accessor " ) { consumer Secret = accessor . accessor Secret ; } else { consumer Secret = accessor . consumer Secret ; } this . key = OAuth . percent Encode ( consumer Secret ) + " & " + OAuth . percent Encode ( accessor . token Secret ) ; } 
function new Method ( name , accessor ) { var impl = OAuth . Signature Method . REGISTERED [ name ] ; if ( impl ! = null ) { var method = new impl ( ) ; method . initialize ( name , accessor ) ; return method ; } var err = new Error ( "signature _method _rejected " ) ; var acceptable = " " ; for ( var r in OAuth . Signature Method . REGISTERED ) { if ( acceptable ! = " " ) acceptable + = ' & ' ; acceptable + = OAuth . percent Encode ( r ) ; } err . oauth _acceptable _signature _methods = acceptable ; throw err ; } 
function register Method Class ( names , class Constructor ) { for ( var n = 0 ; n < names . length ; + + n ) { OAuth . Signature Method . REGISTERED [ names [ n ] ] = class Constructor ; } } 
function make Subclass ( get Signature Function ) { var super Class = OAuth . Signature Method ; var sub Class = function ( ) { super Class . call ( this ) ; } ; sub Class . prototype = new super Class ( ) ; 
function process Initial Data ( value , name ) { if ( name = = View . prototype . model Name ) { options . model = def . models [ name ] . unique ( value ) ; } else if ( def . models [ name ] ) { options . data [ name ] = def . models [ name ] . unique ( value ) ; } else { options . data [ name ] = value ; } } 
function add Animation ( alpha , trail , i , lines ) { var name = [ 'opacity ' , trail , ~ ~ ( alpha * 1 0 0 ) , i , lines ] . join ( ' - ' ) , start = 0 . 0 1 + i / lines * 1 0 0 , z = Math . max ( 1 - ( 1 - alpha ) / trail * ( 1 0 0 - start ) , alpha ) , prefix = use Css Animations . substring ( 0 , use Css Animations . index Of ( 'Animation ' ) ) . to Lower Case ( ) , pre = prefix & & ' - ' + prefix + ' - ' | | ' ' if ( ! animations [ name ] ) { sheet . insert Rule ( ' @ ' + pre + 'keyframes ' + name + ' { ' + ' 0 % {opacity : ' + z + ' } ' + start + ' % {opacity : ' + alpha + ' } ' + ( start + 0 . 0 1 ) + ' % {opacity : 1 } ' + ( start + trail ) % 1 0 0 + ' % {opacity : ' + alpha + ' } ' + ' 1 0 0 % {opacity : ' + z + ' } ' + ' } ' , sheet . css Rules . length ) animations [ name ] = 1 } return name } 
function vendor ( el , prop ) { var s = el . style , pp , i if ( s [ prop ] ! = = undefined ) return prop prop = prop . char At ( 0 ) . to Upper Case ( ) + prop . slice ( 1 ) for ( i = 0 ; i < prefixes . length ; i + + ) { pp = prefixes [ i ] + prop if ( s [ pp ] ! = = undefined ) return pp } } 
function css ( el , prop ) { for ( var n in prop ) el . style [ vendor ( el , n ) | | n ] = prop [ n ] return el } 
function merge ( obj ) { for ( var i = 1 ; i < arguments . length ; i + + ) { var def = arguments [ i ] for ( var n in def ) if ( obj [ n ] = = = undefined ) obj [ n ] = def [ n ] } return obj } 
function pos ( el ) { var o = { x : el . offset Left , y : el . offset Top } while ( ( el = el . offset Parent ) ) o . x + = el . offset Left , o . y + = el . offset Top return o } 
function Spinner ( o ) { if ( ! this . spin ) return new Spinner ( o ) this . opts = merge ( o | | { } , Spinner . defaults , defaults ) } 
function ( c ) { var j = $ ( [ 0 ] ) , i = - 1 , l = this . length ; while ( + + i < l & & ( j . context = j [ 0 ] = this [ i ] ) & & c . call ( j [ 0 ] , i , j ) ! = = false 
function split Val ( string , separator ) { var val , i , l ; if ( string = = = null | | string . length < 1 ) return [ ] ; val = string . split ( separator ) ; for ( i = 0 , l = val . length ; i < l ; i = i + 1 ) val [ i ] = $ . trim ( val [ i ] ) ; return val ; } 
function install Filtered Mouse Move ( element ) { element . on ( "mousemove " , function ( e ) { var lastpos = last Mouse Position ; if ( lastpos = = = undefined | | lastpos . x ! = = e . page X | | lastpos . y ! = = e . page Y ) { $ ( e . target ) . trigger ( "mousemove -filtered " , e ) ; } } ) ; } 
function thunk ( formula ) { var evaluated = false , value ; return function ( ) { if ( evaluated = = = false ) { value = formula ( ) ; evaluated = true ; } return value ; } ; } 
function check Formatter ( formatter , formatter Name ) { if ( $ . is Function ( formatter ) ) return true ; if ( ! formatter ) return false ; throw new Error ( formatter Name + " must be a function or a falsy value " ) ; } 
function default Tokenizer ( input , selection , select Callback , opts ) { var original = input , 
function clazz ( Super Class , methods ) { var constructor = function ( ) { } ; constructor . prototype = new Super Class ; constructor . prototype . constructor = constructor ; constructor . prototype . parent = Super Class . prototype ; constructor . prototype = $ . extend ( constructor . prototype , methods ) ; return constructor ; } 
function ( ) { var element = this . opts . element , select 2 = element . data ( "select 2 " ) ; if ( this . property Observer ) { delete this . property Observer ; this . property Observer = null ; } if ( select 2 ! = = undefined ) { select 2 . container . remove ( ) ; select 2 . dropdown . remove ( ) ; element . remove Class ( "select 2 -offscreen " ) . remove Data ( "select 2 " ) . off ( " .select 2 " ) . prop ( "autofocus " , this . autofocus | | false ) ; if ( this . element Tab Index ) { element . attr ( { tabindex : this . element Tab Index } ) ; } else { element . remove Attr ( "tabindex " ) ; } element . show ( ) ; } } 
function ( element ) { if ( element . is ( "option " ) ) { return { id : element . prop ( "value " ) , text : element . text ( ) , element : element . get ( ) , css : element . attr ( "class " ) , disabled : element . prop ( "disabled " ) , locked : equal ( element . attr ( "locked " ) , "locked " ) | | equal ( element . data ( "locked " ) , true ) } ; } else if ( element . is ( "optgroup " ) ) { return { text : element . attr ( "label " ) , children : [ ] , element : element . get ( ) , css : element . attr ( "class " ) } ; } } 
function ( opts ) { var element , select , id Key , ajax Url , self = this ; element = opts . element ; if ( element . get ( 0 ) . tag Name . to Lower Case ( ) = = = "select " ) { this . select = select = opts . element ; } if ( select ) { 
function ( ) { var el = this . opts . element , sync ; el . on ( "change .select 2 " , this . bind ( function ( e ) { if ( this . opts . element . data ( "select 2 -change -triggered " ) ! = = true ) { this . init Selection ( ) ; } } ) ) ; sync = this . bind ( function ( ) { var enabled , readonly , self = this ; 
function ( ) { var enabled = this . _enabled & & ! this . _readonly , disabled = ! enabled ; if ( enabled = = = this . enabled Interface ) return false ; this . container . toggle Class ( "select 2 -container -disabled " , disabled ) ; this . close ( ) ; this . enabled Interface = enabled ; return true ; } 
function ( ) { var $dropdown = this . dropdown , offset = this . container . offset ( ) , height = this . container . outer Height ( false ) , width = this . container . outer Width ( false ) , drop Height = $dropdown . outer Height ( false ) , view Port Right = $ ( window ) . scroll Left ( ) + $ ( window ) . width ( ) , viewport Bottom = $ ( window ) . scroll Top ( ) + $ ( window ) . height ( ) , drop Top = offset . top + height , drop Left = offset . left , enough Room Below = drop Top + drop Height < = viewport Bottom , enough Room Above = ( offset . top - drop Height ) > = this . body ( ) . scroll Top ( ) , drop Width = $dropdown . outer Width ( false ) , enough Room On Right = drop Left + drop Width < = view Port Right , above Now = $dropdown . has Class ( "select 2 -drop -above " ) , body Offset , above , css , results List Node ; if ( this . opts . dropdown Auto Width ) { results List Node = $ ( ' .select 2 -results ' , $dropdown ) [ 0 ] ; $dropdown . add Class ( 'select 2 -drop -auto -width ' ) ; $dropdown . css ( 'width ' , ' ' ) ; 
function ( ) { var event ; if ( this . opened ( ) ) return false ; if ( this . _enabled = = = false | | this . _readonly = = = true ) return false ; event = $ . Event ( "select 2 -opening " ) ; this . opts . element . trigger ( event ) ; return ! event . is Default Prevented ( ) ; } 
function ( ) { var cid = this . container Id , scroll = "scroll . " + cid , resize = "resize . " + cid , orient = "orientationchange . " + cid , mask , mask Css ; this . container . add Class ( "select 2 -dropdown -open " ) . add Class ( "select 2 -container -active " ) ; this . clear Dropdown Alignment Preference ( ) ; if ( this . dropdown [ 0 ] ! = = this . body ( ) . children ( ) . last ( ) [ 0 ] ) { this . dropdown . detach ( ) . append To ( this . body ( ) ) ; } 
function ( ) { if ( ! this . opened ( ) ) return ; var cid = this . container Id , scroll = "scroll . " + cid , resize = "resize . " + cid , orient = "orientationchange . " + cid ; 
function ( delta ) { var choices = this . find Highlightable Choices ( ) , index = this . highlight ( ) ; while ( index > - 1 & & index < choices . length ) { index + = delta ; var choice = $ ( choices [ index ] ) ; if ( choice . has Class ( "select 2 -result -selectable " ) & & ! choice . has Class ( "select 2 -disabled " ) & & ! choice . has Class ( "select 2 -selected " ) ) { this . highlight ( index ) ; break ; } } } 
function ( index ) { var choices = this . find Highlightable Choices ( ) , choice , data ; if ( arguments . length = = = 0 ) { return index Of ( choices . filter ( " .select 2 -highlighted " ) [ 0 ] , choices . get ( ) ) ; } if ( index > = choices . length ) index = choices . length - 1 ; if ( index < 0 ) index = 0 ; this . results . find ( " .select 2 -highlighted " ) . remove Class ( "select 2 -highlighted " ) ; choice = $ ( choices [ index ] ) ; choice . add Class ( "select 2 -highlighted " ) ; this . ensure Highlight Visible ( ) ; data = choice . data ( "select 2 -data " ) ; if ( data ) { this . opts . element . trigger ( { type : "select 2 -highlight " , val : this . id ( data ) , choice : data } ) ; } } 
function ( event ) { var el = $ ( event . target ) . closest ( " .select 2 -result -selectable " ) ; if ( el . length > 0 & & ! el . is ( " .select 2 -highlighted " ) ) { var choices = this . find Highlightable Choices ( ) ; this . highlight ( choices . index ( el ) ) ; } else if ( el . length = = 0 ) { 
function ( options ) { var index = this . highlight ( ) , highlighted = this . results . find ( " .select 2 -highlighted " ) , data = highlighted . closest ( ' .select 2 -result ' ) . data ( "select 2 -data " ) ; if ( data ) { this . highlight ( index ) ; this . on Select ( data , options ) ; } else if ( options & & options . no Focus ) { this . close ( ) ; } } 
function ( ) { var placeholder Option ; return this . opts . element . attr ( "placeholder " ) | | this . opts . element . attr ( "data -placeholder " ) | | 
function ( ) { if ( this . select ) { var first Option = this . select . children ( ) . first ( ) ; if ( this . opts . placeholder Option ! = = undefined ) { 
function ( trigger Change ) { var data = this . selection . data ( "select 2 -data " ) ; if ( data ) { 
function ( ) { var opts = this . parent . prepare Opts . apply ( this , arguments ) , self = this ; if ( opts . element . get ( 0 ) . tag Name . to Lower Case ( ) = = = "select " ) { 
function ( ) { var placeholder = this . get Placeholder ( ) ; if ( this . is Placeholder Option Selected ( ) & & placeholder ! = = undefined ) { 
function ( data , initial , no Highlight Update ) { var selected = 0 , self = this , show Search Input = true ; 
function ( show Search Input ) { if ( this . show Search Input = = = show Search Input ) return ; this . show Search Input = show Search Input ; this . dropdown . find ( " .select 2 -search " ) . toggle Class ( "select 2 -search -hidden " , ! show Search Input ) ; this . dropdown . find ( " .select 2 -search " ) . toggle Class ( "select 2 -offscreen " , ! show Search Input ) ; 
function ( data , options ) { if ( ! this . trigger Select ( data ) ) { return ; } var old = this . opts . element . val ( ) , old Data = this . data ( ) ; this . opts . element . val ( this . id ( data ) ) ; this . update Selection ( data ) ; this . opts . element . trigger ( { type : "select 2 -selected " , val : this . id ( data ) , choice : data } ) ; this . close ( ) ; if ( ! options | | ! options . no Focus ) this . selection . focus ( ) ; if ( ! equal ( old , this . id ( data ) ) ) { this . trigger Change ( { added : data , removed : old Data } ) ; } } 
function ( ) { var val , trigger Change = false , data = null , self = this , old Data = this . data ( ) ; if ( arguments . length = = = 0 ) { return this . opts . element . val ( ) ; } val = arguments [ 0 ] ; if ( arguments . length > 1 ) { trigger Change = arguments [ 1 ] ; } if ( this . select ) { this . select . val ( val ) . find ( " :selected " ) . each 2 ( function ( i , elm ) { data = self . option To Data ( elm ) ; return false ; } ) ; this . update Selection ( data ) ; this . set Placeholder ( ) ; if ( trigger Change ) { this . trigger Change ( { added : data , removed : old Data } ) ; } } else { 
function ( value , trigger Change ) { var data ; if ( arguments . length = = = 0 ) { data = this . selection . data ( "select 2 -data " ) ; if ( data = = undefined ) data = null ; return data ; } else { if ( ! value | | value = = = " " ) { this . clear ( trigger Change ) ; } else { data = this . data ( ) ; this . opts . element . val ( ! value ? " " : this . id ( value ) ) ; this . update Selection ( value ) ; if ( trigger Change ) { this . trigger Change ( { added : value , removed : data } ) ; } } } } 
function ( ) { var selector = " .select 2 -choices " , selection ; this . search Container = this . container . find ( " .select 2 -search -field " ) ; this . selection = selection = this . container . find ( selector ) ; var _this = this ; this . selection . on ( "mousedown " , " .select 2 -search -choice " , function ( e ) { 
function ( ) { var data ; if ( this . opts . element . val ( ) = = = " " & & this . opts . element . text ( ) = = = " " ) { this . update Selection ( [ ] ) ; this . close ( ) ; 
function ( ) { var placeholder = this . get Placeholder ( ) , max Width = this . get Max Search Width ( ) ; if ( placeholder ! = = undefined & & this . get Val ( ) . length = = = 0 & & this . search . has Class ( "select 2 -focused " ) = = = false ) { this . search . val ( placeholder ) . add Class ( "select 2 -default " ) ; 
function ( ) { this . clear Placeholder ( ) ; 
function ( data ) { var ids = [ ] , filtered = [ ] , self = this ; 
function ( data , options ) { if ( ! this . trigger Select ( data ) ) { return ; } this . add Selected Choice ( data ) ; this . opts . element . trigger ( { type : "selected " , val : this . id ( data ) , choice : data } ) ; if ( this . select | | ! this . opts . close On Select ) this . postprocess Results ( ) ; if ( this . opts . close On Select ) { this . close ( ) ; this . search . width ( 1 0 ) ; } else { if ( this . count Selectable Results ( ) > 0 ) { this . search . width ( 1 0 ) ; this . resize Search ( ) ; if ( this . get Maximum Selection Size ( ) > 0 & & this . val ( ) . length > = this . get Maximum Selection Size ( ) ) { 
function ( selected ) { var val = this . get Val ( ) , data , index ; selected = selected . closest ( " .select 2 -search -choice " ) ; if ( selected . length = = = 0 ) { throw "Invalid argument : " + selected + " . Must be .select 2 -search -choice " ; } data = selected . data ( "select 2 -data " ) ; if ( ! data ) { 
function ( ) { var val ; if ( this . select ) { val = this . select . val ( ) ; return val = = = null ? [ ] : val ; } else { val = this . opts . element . val ( ) ; return split Val ( val , this . opts . separator ) ; } } 
function ( val ) { var unique ; if ( this . select ) { this . select . val ( val ) ; } else { unique = [ ] ; 
function ( val , trigger Change ) { var old Data , self = this , change Details ; if ( arguments . length = = = 0 ) { return this . get Val ( ) ; } old Data = this . data ( ) ; if ( ! old Data . length ) old Data = [ ] ; 
function ( ) { var val = [ ] , self = this ; 
function Sub Emitter Socket ( ) { this . sock = new Sub Socket ; this . sock . onmessage = this . onmessage . bind ( this ) ; this . bind = this . sock . bind . bind ( this . sock ) ; this . connect = this . sock . connect . bind ( this . sock ) ; this . close = this . sock . close . bind ( this . sock ) ; this . listeners = [ ] ; } 
function Pub Emitter Socket ( ) { this . sock = new Pub Socket ; this . emit = this . sock . send . bind ( this . sock ) ; this . bind = this . sock . bind . bind ( this . sock ) ; this . connect = this . sock . connect . bind ( this . sock ) ; this . close = this . sock . close . bind ( this . sock ) ; } 
function to Reg Exp ( str ) { if ( str instanceof Reg Exp ) return str ; str = escape ( str ) ; str = str . replace ( / \ \ \ * / g , ' ( . + ) ' ) ; return new Reg Exp ( ' ^ ' + str + ' $ ' ) ; } 
function Req Socket ( ) { Socket . call ( this ) ; this . n = 0 ; this . ids = 0 ; this . callbacks = { } ; this . identity = this . get ( 'identity ' ) ; this . use ( queue ( ) ) ; } 
function ( ) { let result , expr ; if ( this . token = = = " @ " ) return this . node ( "silent " ) ( this . next ( ) . read _expr ( ) ) ; if ( this . token = = = " + " ) return this . node ( "unary " ) ( " + " , this . next ( ) . read _expr ( ) ) ; if ( this . token = = = " - " ) return this . node ( "unary " ) ( " - " , this . next ( ) . read _expr ( ) ) ; if ( this . token = = = " ! " ) return this . node ( "unary " ) ( " ! " , this . next ( ) . read _expr ( ) ) ; if ( this . token = = = " ~ " ) return this . node ( "unary " ) ( " ~ " , this . next ( ) . read _expr ( ) ) ; if ( this . token = = = " ( " ) { expr = this . next ( ) . read _expr ( ) ; expr . parenthesized Expression = true ; this . expect ( " ) " ) & & this . next ( ) ; return this . handle Dereferencable ( expr ) ; } if ( this . token = = = " ` " ) { 
function ( ) { const result = this . node ( "new " ) ; this . expect ( this . tok . T _NEW ) & & this . next ( ) ; let args = [ ] ; if ( this . token = = = this . tok . T _CLASS ) { const what = this . node ( "class " ) ; 
function ( ) { if ( this . token = = = this . tok . T _NS _SEPARATOR | | this . token = = = this . tok . T _STRING | | this . token = = = this . tok . T _NAMESPACE ) { let result = this . read _namespace _name ( true ) ; if ( this . token = = = this . tok . T _DOUBLE _COLON ) { result = this . read _static _getter ( result ) ; } return result ; } else if ( this . is ( "VARIABLE " ) ) { return this . read _variable ( true , false , false ) ; } else { this . expect ( [ this . tok . T _STRING , "VARIABLE " ] ) ; } } 
function Node ( kind , docs , location ) { this . kind = kind ; if ( docs ) { this . leading Comments = docs ; } if ( location ) { this . loc = location ; } } 
function ( ) { let expect = null ; let short Form = false ; const result = this . node ( Array Expr ) ; if ( this . token = = = this . tok . T _ARRAY ) { this . next ( ) . expect ( " ( " ) ; expect = " ) " ; } else { short Form = true ; expect = " ] " ; } let items = [ ] ; if ( this . next ( ) . token ! = = expect ) { items = this . read _array _pair _list ( short Form ) ; } if (items [i ] = = = null ) { this .raise Error ( "Cannot use empty array elements in arrays " ) ; } } * / this . expect ( expect ) ; this . next ( ) ; return result ( short Form , items ) ; } 
function ( short Form ) { if ( this . token = = = " , " | | ( ! short Form & & this . token = = = " ) " ) | | ( short Form & & this . token = = = " ] " ) ) { return null ; } if ( this . token = = = " & " ) { return this . next ( ) . read _variable ( true , false , true ) ; } else { const entry = this . node ( Array Entry ) ; const expr = this . read _expr ( ) ; if ( this . token = = = this . tok . T _DOUBLE _ARROW ) { if ( this . next ( ) . token = = = " & " ) { return entry ( expr , this . next ( ) . read _variable ( true , false , true ) ) ; } else { return entry ( expr , this . read _expr ( ) ) ; } } return expr ; } } 
function ( ) { let location = null ; const args = Array . prototype . slice . call ( arguments ) ; args . push ( docs ) ; if ( typeof result . pre Build = = = "function " ) { result . pre Build ( arguments ) ; } if ( self . with Positions | | self . with Source ) { let src = null ; if ( self . with Source ) { src = parser . lexer . _input . substring ( start . offset , parser . prev [ 2 ] ) ; } if ( self . with Positions ) { location = new Location ( src , start , new Position ( parser . prev [ 0 ] , parser . prev [ 1 ] , parser . prev [ 2 ] ) ) ; } else { location = new Location ( src , null , null ) ; } 
function ( ) { const result = this . node ( "while " ) ; this . expect ( this . tok . T _WHILE ) & & this . next ( ) ; let test = null ; let body = null ; let short Form = false ; if ( this . expect ( " ( " ) ) this . next ( ) ; test = this . read _expr ( ) ; if ( this . expect ( " ) " ) ) this . next ( ) ; if ( this . token = = = " : " ) { short Form = true ; body = this . read _short _form ( this . tok . T _ENDWHILE ) ; } else { body = this . read _statement ( ) ; } return result ( test , body , short Form ) ; } 
function ( ) { const result = this . node ( "do " ) ; this . expect ( this . tok . T _DO ) & & this . next ( ) ; let test = null ; let body = null ; body = this . read _statement ( ) ; if ( this . expect ( this . tok . T _WHILE ) ) { if ( this . next ( ) . expect ( " ( " ) ) this . next ( ) ; test = this . read _expr ( ) ; if ( this . expect ( " ) " ) ) this . next ( ) ; if ( this . expect ( " ; " ) ) this . next ( ) ; } return result ( test , body ) ; } 
function ( ) { const result = this . node ( "for " ) ; this . expect ( this . tok . T _FOR ) & & this . next ( ) ; let init = [ ] ; let test = [ ] ; let increment = [ ] ; let body = null ; let short Form = false ; if ( this . expect ( " ( " ) ) this . next ( ) ; if ( this . token ! = = " ; " ) { init = this . read _list ( this . read _expr , " , " ) ; if ( this . expect ( " ; " ) ) this . next ( ) ; } else { this . next ( ) ; } if ( this . token ! = = " ; " ) { test = this . read _list ( this . read _expr , " , " ) ; if ( this . expect ( " ; " ) ) this . next ( ) ; } else { this . next ( ) ; } if ( this . token ! = = " ) " ) { increment = this . read _list ( this . read _expr , " , " ) ; if ( this . expect ( " ) " ) ) this . next ( ) ; } else { this . next ( ) ; } if ( this . token = = = " : " ) { short Form = true ; body = this . read _short _form ( this . tok . T _ENDFOR ) ; } else { body = this . read _statement ( ) ; } return result ( init , test , increment , body , short Form ) ; } 
function ( ) { const result = this . node ( "foreach " ) ; this . expect ( this . tok . T _FOREACH ) & & this . next ( ) ; let source = null ; let key = null ; let value = null ; let body = null ; let short Form = false ; if ( this . expect ( " ( " ) ) this . next ( ) ; source = this . read _expr ( ) ; if ( this . expect ( this . tok . T _AS ) ) { this . next ( ) ; value = this . read _foreach _variable ( ) ; if ( this . token = = = this . tok . T _DOUBLE _ARROW ) { key = value ; value = this . next ( ) . read _foreach _variable ( ) ; } } 
function ( ) { if ( this . token = = = this . tok . T _LIST | | this . token = = = " [ " ) { const is Short = this . token = = = " [ " ; const result = this . node ( "list " ) ; this . next ( ) ; if ( ! is Short & & this . expect ( " ( " ) ) this . next ( ) ; const assign List = this . read _array _pair _list ( is Short ) ; if ( this . expect ( is Short ? " ] " : " ) " ) ) this . next ( ) ; return result ( assign List , is Short ) ; } else { return this . read _variable ( false , false , false ) ; } } 
function ( ) { let ch ; while ( this . offset < this . size ) { ch = this . input ( ) ; if ( ch ! = = " 0 " & & ch ! = = " 1 " ) { if ( ch ) this . unput ( 1 ) ; break ; } } return this . tok . T _LNUMBER ; } 
function ( ) { const ch = this . _input [ this . offset - 1 ] ; const fn = this . token Terminals [ ch ] ; if ( fn ) { return fn . apply ( this , [ ] ) ; } else { return this . yytext ; } } 
function ( text , double Quote ) { if ( ! double Quote ) { 
function ( ) { if ( this . is ( "T _MAGIC _CONST " ) ) { return this . get _magic _constant ( ) ; } else { let value , node ; switch ( this . token ) { 
function ( expr ) { let result , offset ; const node = this . node ( "offsetlookup " ) ; if ( this . token = = = " [ " ) { offset = this . next ( ) . read _expr ( ) ; if ( this . expect ( " ] " ) ) this . next ( ) ; result = node ( expr , offset ) ; } else if ( this . token = = = this . tok . T _DOLLAR _OPEN _CURLY _BRACES ) { offset = this . read _encapsed _string _item ( false ) ; result = node ( expr , offset ) ; } return result ; } 
function ( is Double Quote ) { const encapsed Part = this . node ( "encapsedpart " ) ; let curly = false ; let result = this . node ( ) , offset , node , name ; 
function ( expect , is Binary = false ) { let node = this . node ( "encapsed " ) ; this . next ( ) ; const start = this . lexer . yylloc . prev _offset - ( is Binary ? 1 : 0 ) ; const value = [ ] ; let type = null ; if ( expect = = = " ` " ) { type = this . ast . encapsed . TYPE _SHELL ; } else if ( expect = = = ' " ' ) { type = this . ast . encapsed . TYPE _STRING ; } else { type = this . ast . encapsed . TYPE _HEREDOC ; } 
function ( ) { const revert = this . offset ; if ( this . _input [ this . offset - 1 ] = = = " < " & & this . _input [ this . offset ] = = = " < " & & this . _input [ this . offset + 1 ] = = = " < " ) { this . offset + = 3 ; 
function ( ) { 
function ( ) { let ch = this . input ( ) ; if ( ch = = = " $ " ) { ch = this . input ( ) ; if ( ch = = = " { " ) { this . begin ( "ST _LOOKING _FOR _VARNAME " ) ; return this . tok . T _DOLLAR _OPEN _CURLY _BRACES ; } else if ( this . is _LABEL _START ( ) ) { const tok = this . consume _VARIABLE ( ) ; return tok ; } } else if ( ch = = = " { " ) { if ( this . _input [ this . offset ] = = = " $ " ) { this . begin ( "ST _IN _SCRIPTING " ) ; return this . tok . T _CURLY _OPEN ; } } else if ( ch = = = " ` " ) { this . pop State ( ) ; return " ` " ; } 
function ( ) { let result = [ ] ; while ( this . token ! = = this . EOF & & this . token ! = = " } " ) { const statement = this . read _top _statement ( ) ; if ( statement ) { if ( Array . is Array ( statement ) ) { result = result . concat ( statement ) ; } else { result . push ( statement ) ; } } } return result ; } 
function ( ) { switch ( this . token ) { case this . tok . T _FUNCTION : return this . read _function ( false , false ) ; 
function ( ) { return this . read _list ( function ( ) { this . expect ( this . tok . T _STRING ) ; const result = this . node ( "constant " ) ; let const Name = this . node ( "identifier " ) ; const name = this . text ( ) ; this . next ( ) ; const Name = const Name ( name ) ; if ( this . expect ( " = " ) ) { return result ( const Name , this . next ( ) . read _expr ( ) ) ; } else { 
function ( ) { const result = [ ] ; while ( this . token ! = this . EOF & & this . token ! = = " ) " ) { this . expect ( this . tok . T _STRING ) ; const directive = this . node ( "declaredirective " ) ; let key = this . node ( "identifier " ) ; const name = this . text ( ) ; this . next ( ) ; key = key ( name ) ; let value = null ; if ( this . expect ( " = " ) ) { value = this . next ( ) . read _expr ( ) ; } result . push ( directive ( key , value ) ) ; if ( this . token ! = = " , " ) break ; this . next ( ) ; } return result ; } 
function ( ) { switch ( this . token ) { case this . tok . T _FUNCTION : return this . read _function ( false , false ) ; 
function ( ) { switch ( this . token ) { case " { " : return this . read _code _block ( false ) ; case this . tok . T _IF : return this . read _if ( ) ; case this . tok . T _SWITCH : return this . read _switch ( ) ; case this . tok . T _FOR : return this . read _for ( ) ; case this . tok . T _FOREACH : return this . read _foreach ( ) ; case this . tok . T _WHILE : return this . read _while ( ) ; case this . tok . T _DO : return this . read _do ( ) ; case this . tok . T _COMMENT : return this . read _comment ( ) ; case this . tok . T _DOC _COMMENT : return this . read _doc _comment ( ) ; case this . tok . T _RETURN : { const result = this . node ( "return " ) ; let expr = null ; if ( ! this . next ( ) . is ( "EOS " ) ) { expr = this . read _expr ( ) ; } this . expect End Of Statement ( ) ; return result ( expr ) ; } 
function ( top ) { const result = this . node ( "block " ) ; this . expect ( " { " ) & & this . next ( ) ; const body = top ? this . read _top _statements ( ) : this . read _inner _statements ( ) ; this . expect ( " } " ) & & this . next ( ) ; return result ( null , body ) ; } 
function ( lexer , ast ) { this . lexer = lexer ; this . ast = ast ; this . tok = lexer . tok ; this . EOF = lexer . EOF ; this . token = null ; this . prev = null ; this . debug = false ; this . php 7 = true ; this . extract Doc = false ; this . extract Tokens = false ; this . suppress Errors = false ; const map It = function ( item ) { return [ item , null ] ; } ; this . entries = { IDENTIFIER : new Map ( [ this . tok . T _ABSTRACT , this . tok . T _ARRAY , this . tok . T _AS , this . tok . T _BREAK , this . tok . T _CALLABLE , this . tok . T _CASE , this . tok . T _CATCH , this . tok . T _CLASS , this . tok . T _CLASS _C , this . tok . T _CLONE , this . tok . T _CONST , this . tok . T _CONTINUE , this . tok . T _DECLARE , this . tok . T _DEFAULT , this . tok . T _DIR , this . tok . T _DO , this . tok . T _ECHO , this . tok . T _ELSE , this . tok . T _ELSEIF , this . tok . T _EMPTY , this . tok . T _ENDDECLARE , this . tok . T _ENDFOR , this . tok . T _ENDFOREACH , this . tok . T _ENDIF , this . tok . T _ENDSWITCH , this . tok . T _ENDWHILE , this . tok . T _EVAL , this . tok . T _EXIT , this . tok . T _EXTENDS , this . tok . T _FILE , this . tok . T _FINAL , this . tok . T _FINALLY , this . tok . T _FUNC _C , this . tok . T _FOR , this . tok . T _FOREACH , this . tok . T _FUNCTION , this . tok . T _GLOBAL , this . tok . T _GOTO , this . tok . T _IF , this . tok . T _IMPLEMENTS , this . tok . T _INCLUDE , this . tok . T _INCLUDE _ONCE , this . tok . T _INSTANCEOF , this . tok . T _INSTEADOF , this . tok . T _INTERFACE , this . tok . T _ISSET , this . tok . T _LINE , this . tok . T _LIST , this . tok . T _LOGICAL _AND , this . tok . T _LOGICAL _OR , this . tok . T _LOGICAL _XOR , this . tok . T _METHOD _C , this . tok . T _NAMESPACE , this . tok . T _NEW , this . tok . T _NS _C , this . tok . T _PRINT , this . tok . T _PRIVATE , this . tok . T _PROTECTED , this . tok . T _PUBLIC , this . tok . T _REQUIRE , this . tok . T _REQUIRE _ONCE , this . tok . T _RETURN , this . tok . T _STATIC , this . tok . T _SWITCH , this . tok . T _THROW , this . tok . T _TRAIT , this . tok . T _TRY , this . tok . T _UNSET , this . tok . T _USE , this . tok . T _VAR , this . tok . T _WHILE , this . tok . T _YIELD ] . map ( map It ) ) , VARIABLE : new Map ( [ this . tok . T _VARIABLE , " $ " , " & " , this . tok . T _NS _SEPARATOR , this . tok . T _STRING , this . tok . T _NAMESPACE , this . tok . T _STATIC ] . map ( map It ) ) , SCALAR : new Map ( [ this . tok . T _CONSTANT _ENCAPSED _STRING , this . tok . T _START _HEREDOC , this . tok . T _LNUMBER , this . tok . T _DNUMBER , this . tok . T _ARRAY , " [ " , this . tok . T _CLASS _C , this . tok . T _TRAIT _C , this . tok . T _FUNC _C , this . tok . T _METHOD _C , this . tok . T _LINE , this . tok . T _FILE , this . tok . T _DIR , this . tok . T _NS _C , ' " ' , 'b " ' , 'B " ' , " - " , this . tok . T _NS _SEPARATOR ] . map ( map It ) ) , T _MAGIC _CONST : new Map ( [ this . tok . T _CLASS _C , this . tok . T _TRAIT _C , this . tok . T _FUNC _C , this . tok . T _METHOD _C , this . tok . T _LINE , this . tok . T _FILE , this . tok . T _DIR , this . tok . T _NS _C ] . map ( map It ) ) , T _MEMBER _FLAGS : new Map ( [ this . tok . T _PUBLIC , this . tok . T _PRIVATE , this . tok . T _PROTECTED , this . tok . T _STATIC , this . tok . T _ABSTRACT , this . tok . T _FINAL ] . map ( map It ) ) , EOS : new Map ( [ " ; " , this . EOF , this . tok . T _INLINE _HTML ] . map ( map It ) ) , EXPR : new Map ( [ " @ " , " - " , " + " , " ! " , " ~ " , " ( " , " ` " , this . tok . T _LIST , this . tok . T _CLONE , this . tok . T _INC , this . tok . T _DEC , this . tok . T _NEW , this . tok . T _ISSET , this . tok . T _EMPTY , this . tok . T _INCLUDE , this . tok . T _INCLUDE _ONCE , this . tok . T _REQUIRE , this . tok . T _REQUIRE _ONCE , this . tok . T _EVAL , this . tok . T _INT _CAST , this . tok . T _DOUBLE _CAST , this . tok . T _STRING _CAST , this . tok . T _ARRAY _CAST , this . tok . T _OBJECT _CAST , this . tok . T _BOOL _CAST , this . tok . T _UNSET _CAST , this . tok . T _EXIT , this . tok . T _PRINT , this . tok . T _YIELD , this . tok . T _STATIC , this . tok . T _FUNCTION , 
function ( ) { const result = this . node ( "namespace " ) ; let body ; this . expect ( this . tok . T _NAMESPACE ) & & this . next ( ) ; if ( this . token = = " { " ) { this . current Namespace = [ " " ] ; body = this . next ( ) . read _top _statements ( ) ; this . expect ( " } " ) & & this . next ( ) ; return result ( [ " " ] , body , true ) ; } else { const name = this . read _namespace _name ( ) ; if ( this . token = = " ; " ) { this . current Namespace = name ; body = this . next ( ) . read _top _statements ( ) ; this . expect ( this . EOF ) ; return result ( name . name , body , false ) ; } else if ( this . token = = " { " ) { this . current Namespace = name ; body = this . next ( ) . read _top _statements ( ) ; this . expect ( " } " ) & & this . next ( ) ; return result ( name . name , body , true ) ; } else if ( this . token = = = " ( " ) { 
function ( resolve Reference ) { const result = this . node ( ) ; let relative = false ; if ( this . token = = = this . tok . T _NAMESPACE ) { this . next ( ) . expect ( this . tok . T _NS _SEPARATOR ) & & this . next ( ) ; relative = true ; } const names = this . read _list ( this . tok . T _STRING , this . tok . T _NS _SEPARATOR , true ) ; if ( ! relative & & names . length = = = 1 & & ( resolve Reference | | this . token ! = = " ( " ) ) { if ( names [ 0 ] . to Lower Case ( ) = = = "parent " ) { return result ( "parentreference " , names [ 0 ] ) ; } else if ( names [ 0 ] . to Lower Case ( ) = = = "self " ) { return result ( "selfreference " , names [ 0 ] ) ; } } return result ( "classreference " , names , relative ) ; } 
function ( ) { let result = this . node ( "usegroup " ) ; let items = [ ] ; let name = null ; this . expect ( this . tok . T _USE ) & & this . next ( ) ; const type = this . read _use _type ( ) ; items . push ( this . read _use _declaration ( false ) ) ; if ( this . token = = = " , " ) { items = items . concat ( this . next ( ) . read _use _declarations ( false ) ) ; } else if ( this . token = = = " { " ) { name = items [ 0 ] . name ; items = this . next ( ) . read _use _declarations ( type = = = null ) ; this . expect ( " } " ) & & this . next ( ) ; } result = result ( name , type , items ) ; this . expect ( " ; " ) & & this . next ( ) ; return result ; } 
function ( typed ) { const result = this . node ( "useitem " ) ; let type = null ; if ( typed ) type = this . read _use _type ( ) ; const name = this . read _namespace _name ( ) ; const alias = this . read _use _alias ( ) ; return result ( name . name , alias , type ) ; } 
function ( typed ) { const result = [ this . read _use _declaration ( typed ) ] ; while ( this . token = = = " , " ) { this . next ( ) ; if ( typed ) { if ( this . token ! = = this . tok . T _FUNCTION & & this . token ! = = this . tok . T _CONST & & this . token ! = = this . tok . T _STRING ) { break ; } } else if ( this . token ! = = this . tok . T _STRING & & this . token ! = = this . tok . T _NS _SEPARATOR ) { break ; } result . push ( this . read _use _declaration ( typed ) ) ; } return result ; } 
function ( ) { let result = null ; if ( this . token = = = this . tok . T _AS ) { if ( this . next ( ) . expect ( this . tok . T _STRING ) ) { const alias Name = this . node ( "identifier " ) ; const name = this . text ( ) ; this . next ( ) ; result = alias Name ( name ) ; } } return result ; } 
function ( ) { if ( this . token = = = this . tok . T _FUNCTION ) { this . next ( ) ; return this . ast . useitem . TYPE _FUNCTION ; } else if ( this . token = = = this . tok . T _CONST ) { this . next ( ) ; return this . ast . useitem . TYPE _CONST ; } return null ; } 
function ( ) { const result = this . node ( "if " ) ; let body = null ; let alternate = null ; let short Form = false ; let test = null ; test = this . next ( ) . read _if _expr ( ) ; if ( this . token = = = " : " ) { short Form = true ; this . next ( ) ; body = this . node ( "block " ) ; const items = [ ] ; while ( this . token ! = = this . EOF & & this . token ! = = this . tok . T _ENDIF ) { if ( this . token = = = this . tok . T _ELSEIF ) { alternate = this . read _elseif _short ( ) ; break ; } else if ( this . token = = = this . tok . T _ELSE ) { alternate = this . read _else _short ( ) ; break ; } items . push ( this . read _inner _statement ( ) ) ; } body = body ( null , items ) ; this . expect ( this . tok . T _ENDIF ) & & this . next ( ) ; this . expect End Of Statement ( ) ; } else { body = this . read _statement ( ) ; if ( this . token = = = this . tok . T _ELSEIF ) { alternate = this . read _if ( ) ; } else if ( this . token = = = this . tok . T _ELSE ) { alternate = this . next ( ) . read _statement ( ) ; } } return result ( test , body , alternate , short Form ) ; } 
function ( ) { const result = this . node ( "if " ) ; let alternate = null ; let test = null ; let body = null ; const items = [ ] ; test = this . next ( ) . read _if _expr ( ) ; if ( this . expect ( " : " ) ) this . next ( ) ; body = this . node ( "block " ) ; while ( this . token ! = this . EOF & & this . token ! = = this . tok . T _ENDIF ) { if ( this . token = = = this . tok . T _ELSEIF ) { alternate = this . read _elseif _short ( ) ; break ; } else if ( this . token = = = this . tok . T _ELSE ) { alternate = this . read _else _short ( ) ; break ; } items . push ( this . read _inner _statement ( ) ) ; } body = body ( null , items ) ; return result ( test , body , alternate , true ) ; } 
function ( engine ) { this . engine = engine ; this . tok = this . engine . tokens . names ; this . EOF = 1 ; this . debug = false ; this . all _tokens = true ; this . comment _tokens = false ; this . mode _eval = false ; this . asp _tags = false ; this . short _tags = true ; this . php 7 = true ; this . yyprevcol = 0 ; this . keywords = { _ _class _ _ : this . tok . T _CLASS _C , _ _trait _ _ : this . tok . T _TRAIT _C , _ _function _ _ : this . tok . T _FUNC _C , _ _method _ _ : this . tok . T _METHOD _C , _ _line _ _ : this . tok . T _LINE , _ _file _ _ : this . tok . T _FILE , _ _dir _ _ : this . tok . T _DIR , _ _namespace _ _ : this . tok . T _NS _C , exit : this . tok . T _EXIT , die : this . tok . T _EXIT , function : this . tok . T _FUNCTION , const : this . tok . T _CONST , return : this . tok . T _RETURN , try : this . tok . T _TRY , catch : this . tok . T _CATCH , finally : this . tok . T _FINALLY , throw : this . tok . T _THROW , if : this . tok . T _IF , elseif : this . tok . T _ELSEIF , endif : this . tok . T _ENDIF , else : this . tok . T _ELSE , while : this . tok . T _WHILE , endwhile : this . tok . T _ENDWHILE , do : this . tok . T _DO , for : this . tok . T _FOR , endfor : this . tok . T _ENDFOR , foreach : this . tok . T _FOREACH , endforeach : this . tok . T _ENDFOREACH , declare : this . tok . T _DECLARE , enddeclare : this . tok . T _ENDDECLARE , instanceof : this . tok . T _INSTANCEOF , as : this . tok . T _AS , switch : this . tok . T _SWITCH , endswitch : this . tok . T _ENDSWITCH , case : this . tok . T _CASE , default : this . tok . T _DEFAULT , break : this . tok . T _BREAK , continue : this . tok . T _CONTINUE , goto : this . tok . T _GOTO , echo : this . tok . T _ECHO , print : this . tok . T _PRINT , class : this . tok . T _CLASS , interface : this . tok . T _INTERFACE , trait : this . tok . T _TRAIT , extends : this . tok . T _EXTENDS , implements : this . tok . T _IMPLEMENTS , new : this . tok . T _NEW , clone : this . tok . T _CLONE , var : this . tok . T _VAR , eval : this . tok . T _EVAL , include : this . tok . T _INCLUDE , include _once : this . tok . T _INCLUDE _ONCE , require : this . tok . T _REQUIRE , require _once : this . tok . T _REQUIRE _ONCE , namespace : this . tok . T _NAMESPACE , use : this . tok . T _USE , insteadof : this . tok . T _INSTEADOF , global : this . tok . T _GLOBAL , isset : this . tok . T _ISSET , empty : this . tok . T _EMPTY , _ _halt _compiler : this . tok . T _HALT _COMPILER , static : this . tok . T _STATIC , abstract : this . tok . T _ABSTRACT , final : this . tok . T _FINAL , private : this . tok . T _PRIVATE , protected : this . tok . T _PROTECTED , public : this . tok . T _PUBLIC , unset : this . tok . T _UNSET , list : this . tok . T _LIST , array : this . tok . T _ARRAY , callable : this . tok . T _CALLABLE , or : this . tok . T _LOGICAL _OR , and : this . tok . T _LOGICAL _AND , xor : this . tok . T _LOGICAL _XOR } ; this . cast Keywords = { int : this . tok . T _INT _CAST , integer : this . tok . T _INT _CAST , real : this . tok . T _DOUBLE _CAST , double : this . tok . T _DOUBLE _CAST , float : this . tok . T _DOUBLE _CAST , string : this . tok . T _STRING _CAST , binary : this . tok . T _STRING _CAST , array : this . tok . T _ARRAY _CAST , object : this . tok . T _OBJECT _CAST , bool : this . tok . T _BOOL _CAST , boolean : this . tok . T _BOOL _CAST , unset : this . tok . T _UNSET _CAST } ; } 
function ( ) { const result = this . node ( "class " ) ; const flag = this . read _class _scope ( ) ; 
function ( ) { const result = this . token ; if ( result = = this . tok . T _FINAL ) { this . next ( ) ; return [ 0 , 0 , 2 ] ; } else if ( result = = this . tok . T _ABSTRACT ) { this . next ( ) ; return [ 0 , 0 , 1 ] ; } return [ 0 , 0 , 0 ] ; } 
function ( ) { let result = [ ] ; while ( this . token ! = = this . EOF & & this . token ! = = " } " ) { if ( this . token = = = this . tok . T _COMMENT ) { result . push ( this . read _comment ( ) ) ; continue ; } if ( this . token = = = this . tok . T _DOC _COMMENT ) { result . push ( this . read _doc _comment ( ) ) ; continue ; } 
function ( flags ) { const result = this . node ( "propertystatement " ) ; const properties = this . read _list ( function read _variable _declaration ( ) { const result = this . node ( "property " ) ; this . expect ( this . tok . T _VARIABLE ) ; let prop Name = this . node ( "identifier " ) ; const name = this . text ( ) . substring ( 1 ) ; 
function ( flags ) { if ( this . expect ( this . tok . T _CONST ) ) { this . next ( ) ; } const result = this . node ( "classconstant " ) ; const items = this . read _list ( function read _constant _declaration ( ) { const result = this . node ( "constant " ) ; let const Name = null ; let value = null ; if ( this . token = = = this . tok . T _STRING | | ( this . php 7 & & this . is ( "IDENTIFIER " ) ) ) { const Name = this . node ( "identifier " ) ; const name = this . text ( ) ; this . next ( ) ; const Name = const Name ( name ) ; } else { this . expect ( "IDENTIFIER " ) ; } if ( this . expect ( " = " ) ) { value = this . next ( ) . read _expr ( ) ; } return result ( const Name , value ) ; } , " , " ) ; return result ( null , items , flags ) ; } 
function read _constant _declaration ( ) { const result = this . node ( "constant " ) ; let const Name = null ; let value = null ; if ( this . token = = = this . tok . T _STRING | | ( this . php 7 & & this . is ( "IDENTIFIER " ) ) ) { const Name = this . node ( "identifier " ) ; const name = this . text ( ) ; this . next ( ) ; const Name = const Name ( name ) ; } else { this . expect ( "IDENTIFIER " ) ; } if ( this . expect ( " = " ) ) { value = this . next ( ) . read _expr ( ) ; } return result ( const Name , value ) ; } 
function ( as Interface ) { const result = [ - 1 , - 1 , - 1 ] ; if ( this . is ( "T _MEMBER _FLAGS " ) ) { let idx = 0 , val = 0 ; do { switch ( this . token ) { case this . tok . T _PUBLIC : idx = 0 ; val = 0 ; break ; case this . tok . T _PROTECTED : idx = 0 ; val = 1 ; break ; case this . tok . T _PRIVATE : idx = 0 ; val = 2 ; break ; case this . tok . T _STATIC : idx = 1 ; val = 1 ; break ; case this . tok . T _ABSTRACT : idx = 2 ; val = 1 ; break ; case this . tok . T _FINAL : idx = 2 ; val = 2 ; break ; } if ( as Interface ) { if ( idx = = 0 & & val = = 2 ) { 
function ( ) { const result = this . node ( "interface " ) ; if ( this . token ! = = this . tok . T _INTERFACE ) { this . error ( this . tok . T _INTERFACE ) ; this . next ( ) ; return null ; } this . next ( ) . expect ( this . tok . T _STRING ) ; let prop Name = this . node ( "identifier " ) ; const name = this . text ( ) ; this . next ( ) ; prop Name = prop Name ( name ) ; let prop Extends = null ; if ( this . token = = = this . tok . T _EXTENDS ) { prop Extends = this . next ( ) . read _name _list ( ) ; } this . expect ( " { " ) ; const body = this . next ( ) . read _interface _body ( ) ; return result ( prop Name , prop Extends , body ) ; } 
function ( ) { let result = [ ] ; while ( this . token ! = = this . EOF & & this . token ! = = " } " ) { if ( this . token = = = this . tok . T _COMMENT ) { result . push ( this . read _comment ( ) ) ; continue ; } if ( this . token = = = this . tok . T _DOC _COMMENT ) { result . push ( this . read _doc _comment ( ) ) ; continue ; } 
function ( ) { const result = this . node ( "trait " ) ; 
function ( ) { 
function ( ) { const node = this . node ( ) ; let trait = null ; let method ; if ( this . is ( "IDENTIFIER " ) ) { method = this . node ( "identifier " ) ; const method Name = this . text ( ) ; this . next ( ) ; method = method ( method Name ) ; } else { method = this . read _namespace _name ( ) ; if ( this . token = = = this . tok . T _DOUBLE _COLON ) { this . next ( ) ; if ( this . token = = = this . tok . T _STRING | | ( this . php 7 & & this . is ( "IDENTIFIER " ) ) ) { trait = method ; method = this . node ( "identifier " ) ; const method Name = this . text ( ) ; this . next ( ) ; method = method ( method Name ) ; } else { this . expect ( this . tok . T _STRING ) ; } } else { 
function ( ) { this . expect ( this . tok . T _TRY ) ; const result = this . node ( "try " ) ; let always = null ; const catches = [ ] ; const body = this . next ( ) . read _statement ( ) ; 
function ( read _only , encapsed , byref ) { let result ; 
function ( what , encapsed ) { const result = this . node ( "staticlookup " ) ; let offset , name ; if ( this . next ( ) . is ( [ this . tok . T _VARIABLE , " $ " ] ) ) { offset = this . read _reference _variable ( encapsed , false ) ; } else if ( this . token = = = this . tok . T _STRING | | this . token = = = this . tok . T _CLASS | | ( this . php 7 & & this . is ( "IDENTIFIER " ) ) ) { offset = this . node ( "identifier " ) ; name = this . text ( ) ; this . next ( ) ; offset = offset ( name ) ; } else if ( this . token = = = " { " ) { offset = this . node ( "literal " ) ; name = this . next ( ) . read _expr ( ) ; this . expect ( " } " ) & & this . next ( ) ; offset = offset ( "literal " , name , null ) ; this . expect ( " ( " ) ; } else { this . error ( [ this . tok . T _VARIABLE , this . tok . T _STRING ] ) ; 
function ( ) { let offset = this . node ( ) ; if ( this . token = = = this . tok . T _STRING ) { const text = this . text ( ) ; this . next ( ) ; offset = offset ( "identifier " , text ) ; } else if ( this . token = = = this . tok . T _NUM _STRING ) { const num = this . text ( ) ; this . next ( ) ; offset = offset ( "number " , num , null ) ; } else if ( this . token = = = this . tok . T _VARIABLE ) { const name = this . text ( ) . substring ( 1 ) ; this . next ( ) ; offset = offset ( "variable " , name , false , false ) ; } else { this . expect ( [ this . tok . T _STRING , this . tok . T _NUM _STRING , this . tok . T _VARIABLE ] ) ; 
function ( encapsed , byref ) { let result = this . read _simple _variable ( byref ) ; let offset ; while ( this . token ! = this . EOF ) { const node = this . node ( ) ; if ( this . token = = " { " & & ! encapsed ) { 
function ( byref ) { let result = this . node ( "variable " ) ; let name ; if ( this . expect ( [ this . tok . T _VARIABLE , " $ " ] ) & & this . token = = = this . tok . T _VARIABLE ) { 
function ( options ) { if ( typeof this = = = "function " ) { return new this ( options ) ; } this . tokens = tokens ; this . lexer = new lexer ( this ) ; this . ast = new AST ( ) ; this . parser = new parser ( this . lexer , this . ast ) ; if ( options & & typeof options = = = "object " ) { 
function ( ) { const result = this . node ( "switch " ) ; this . expect ( this . tok . T _SWITCH ) & & this . next ( ) ; this . expect ( " ( " ) & & this . next ( ) ; const test = this . read _expr ( ) ; this . expect ( " ) " ) & & this . next ( ) ; const short Form = this . token = = = " : " ; const body = this . read _switch _case _list ( ) ; return result ( test , body , short Form ) ; } 
function ( ) { 
function ( stop Token ) { const result = this . node ( "case " ) ; let test = null ; let body = null ; const items = [ ] ; if ( this . token = = = this . tok . T _CASE ) { test = this . next ( ) . read _expr ( ) ; } else if ( this . token = = = this . tok . T _DEFAULT ) { 
function ( ) { while ( this . offset < this . size ) { const ch = this . input ( ) ; if ( ch = = = " \n " | | ch = = = " \r " ) { return this . tok . T _COMMENT ; } else if ( ch = = = " ? " & & ! this . asp Tag Mode & & this . _input [ this . offset ] = = = " > " ) { this . unput ( 1 ) ; return this . tok . T _COMMENT ; } else if ( ch = = = " % " & & this . asp Tag Mode & & this . _input [ this . offset ] = = = " > " ) { this . unput ( 1 ) ; return this . tok . T _COMMENT ; } } return this . tok . T _COMMENT ; } 
function ( ) { let ch = this . input ( ) ; let token = this . tok . T _COMMENT ; if ( ch = = = " * " ) { 
function ( token ) { const body = this . node ( "block " ) ; const items = [ ] ; if ( this . expect ( " : " ) ) this . next ( ) ; while ( this . token ! = this . EOF & & this . token ! = = token ) { items . push ( this . read _inner _statement ( ) ) ; } if ( this . expect ( token ) ) this . next ( ) ; this . expect End Of Statement ( ) ; return body ( null , items ) ; } 
function ( item , separator , preserve First Separator ) { const result = [ ] ; if ( this . token = = separator ) { if ( preserve First Separator ) result . push ( null ) ; this . next ( ) ; } if ( typeof item = = = "function " ) { do { result . push ( item . apply ( this , [ ] ) ) ; if ( this . token ! = separator ) { break ; } } while ( this . next ( ) . token ! = this . EOF ) ; } else { if ( this . expect ( item ) ) { result . push ( this . text ( ) ) ; } else { return [ ] ; } while ( this . next ( ) . token ! = this . EOF ) { if ( this . token ! = separator ) break ; 
function ( ) { return this . read _list ( function ( ) { const node = this . node ( "staticvariable " ) ; let variable = this . node ( "variable " ) ; 
function ( ) { const text = this . text ( ) ; let result = this . ast . prepare ( text . substring ( 0 , 2 ) = = = " / * " ? "commentblock " : "commentline " , null , this ) ; const offset = this . lexer . yylloc . first _offset ; 
function find Chunk File ( chunk , chunk Id , output File Path ) { for ( let i = 0 ; i < chunk . files . length ; i + + ) { const chunk File = chunk . files [ i ] ; let normalized Output File Path = output File Path . replace ( / ^ \ . \ / / , ' ' ) ; if ( ! / \ .js $ / . test ( chunk File ) ) { normalized Output File Path = normalized Output File Path . substr ( 0 , normalized Output File Path . length - 3 ) ; } if ( normalized Output File Path = = = chunk File ) { return chunk File ; } } if ( chunk . id = = = chunk Id ) { return chunk . files [ 0 ] ; } return undefined ; 
function find Ancestor Distance ( src , target , current Distance ) { if ( target = = = src ) { return current Distance ; } const distances = [ ] ; src . get Parents ( ) . for Each ( ( src Parent Chunk Group ) = > { const distance = find Ancestor Distance ( src Parent Chunk Group , target , current Distance + 1 ) ; if ( distance > = 0 ) { distances . push ( distance ) ; } } ) ; if ( distances . length = = = 0 ) { return - 1 ; } return Math . min ( . . . distances ) ; } 
function find Nearest Common Parent Chunk ( chunk Groups , current Distance = 0 ) { 
function ( element ) { if ( ! element | | ! element . get Attribute ) return { } ; var _params = { } , _dataparams = _query To Object ( element . get Attribute ( "data -params " ) | | ' ' ) ; 
function ( page , data ) { if ( page . flag Ani Bind = = true ) return ; 
function ( string ) { var obj = { } ; if ( typeof string = = "string " ) { string . split ( " & " ) . for Each ( function ( part ) { var arr Part = part . split ( " = " ) ; if ( arr Part . length > 1 ) { obj [ arr Part [ 0 ] ] = part . replace ( arr Part [ 0 ] + " = " , " " ) ; } } ) ; } return obj ; } 
function update Props ( dom Node , old Virtual Node , old Props , new Virtual Node , new Props ) { if ( old Props ) { for ( var name in old Props ) { if ( name = = = 'ref ' | | name = = = 'on ' ) continue if ( name in EVENT _LISTENER _PROPS ) continue if ( ! new Props | | ! ( name in new Props ) ) { if ( name = = = 'dataset ' ) { update Props ( dom Node . dataset , null , old Props & & old Props . dataset , null , null ) } else if ( name ! = = 'inner HTML ' & & old Virtual Node & & SVG _TAGS . has ( old Virtual Node . tag ) ) { dom Node . remove Attribute ( SVG _ATTRIBUTE _TRANSLATIONS . get ( name ) | | name ) } else { 
function initialize ( component ) { if ( typeof component . update ! = = 'function ' ) { throw new Error ( 'Etch components must implement `update (props , children ) ` . ' ) } let virtual Node = component . render ( ) if ( ! is Valid Virtual Node ( virtual Node ) ) { let name Part = component . constructor & & component . constructor . name ? ' in ' + component . constructor . name : ' ' throw new Error ( 'invalid falsy value ' + virtual Node + ' returned from render ( ) ' + name Part ) } apply Context ( component , virtual Node ) component . refs = { } component . virtual Node = virtual Node component . element = render ( component . virtual Node , { refs : component . refs , listener Context : component } ) } 
function update ( component , replace Node = true ) { if ( sync Updates In Progress Counter > 0 ) { update Sync ( component , replace Node ) return Promise . resolve ( ) } let scheduler = get Scheduler ( ) if ( ! components With Pending Updates . has ( component ) ) { components With Pending Updates . add ( component ) scheduler . update Document ( function ( ) { components With Pending Updates . delete ( component ) update Sync ( component , replace Node ) } ) } return scheduler . get Next Update Promise ( ) } 
function update Sync ( component , replace Node = true ) { if ( ! is Valid Virtual Node ( component . virtual Node ) ) { throw new Error ( ` $ { component . constructor ? component . constructor . name + ' instance ' : component } ` ) } if ( component . element = = null ) { throw new Error ( ` $ { component . constructor ? component . constructor . name + ' instance ' : component } ` ) } let new Virtual Node = component . render ( ) if ( ! is Valid Virtual Node ( new Virtual Node ) ) { const name Part = component . constructor & & component . constructor . name ? ' in ' + component . constructor . name : ' ' throw new Error ( 'invalid falsy value ' + new Virtual Node + ' returned from render ( ) ' + name Part ) } apply Context ( component , new Virtual Node ) sync Updates In Progress Counter + + let old Virtual Node = component . virtual Node let old Dom Node = component . element let new Dom Node = patch ( old Virtual Node , new Virtual Node , { refs : component . refs , listener Context : component } ) component . virtual Node = new Virtual Node if ( new Dom Node ! = = old Dom Node & & ! replace Node ) { throw new Error ( 'The root node type changed on update , but the update was performed with the replace Node option set to false ' ) } else { component . element = new Dom Node } 
function destroy ( component , remove Node = true ) { if ( sync Updates In Progress Counter > 0 | | sync Destructions In Progress Counter > 0 ) { destroy Sync ( component , remove Node ) return Promise . resolve ( ) } let scheduler = get Scheduler ( ) scheduler . update Document ( function ( ) { destroy Sync ( component , remove Node ) } ) return scheduler . get Next Update Promise ( ) } 
function destroy Sync ( component , remove Node = true ) { sync Destructions In Progress Counter + + destroy Child Components ( component . virtual Node ) if ( sync Destructions In Progress Counter = = = 1 & & remove Node ) component . element . remove ( ) sync Destructions In Progress Counter - - } 
function make Original ( user Theme = { } ) { 
function enlarge UUID ( short Id , translator ) { var uu 1 = translator ( short Id ) ; var left Pad = " " ; var m ; 
function load Tasks ( grunt ) { grunt . load Npm Tasks ( 'grunt -simple -mocha ' ) ; grunt . load Npm Tasks ( 'grunt -mocha -nyc ' ) ; grunt . load Npm Tasks ( 'grunt -mkdir ' ) ; grunt . load Npm Tasks ( 'grunt -browserify ' ) ; grunt . load Npm Tasks ( 'grunt -contrib -uglify ' ) ; } 
function update Config ( config ) { config = config | | { } ; if ( argv . src & & argv . src . length ) { config . src = [ ] ; let s , p ; const named = { } ; _ . each ( argv . src , item = > { s = item . split ( ' : ' ) ; if ( s . length > 1 ) { p = s [ 0 ] ; named [ p ] = named [ p ] | | [ ] ; named [ p ] . push ( s . slice ( 1 ) ) ; } else { config . src . push ( item ) ; } } ) ; if ( _ . keys ( named ) . length ) config . src . push ( named ) ; } if ( argv . dest ) config . dest = argv . dest ; if ( argv . clean ) config . clean = Boolean ( argv . clean ) ; if ( argv . base ) { config . app = config . app | | { } ; config . app . base = argv . base ; } 
function _add Metas To Doc ( $ , meta List ) { if ( ! _ . is Array ( meta List ) | | meta List . length = = = 0 ) return ; const $head = $ ( 'head ' ) ; let last Meta ; const existing Metas = $head . find ( 'meta ' ) ; if ( existing Metas . length > 0 ) { last Meta = existing Metas . eq ( existing Metas . length - 1 ) ; } else { last Meta = Html Parser . DOM . N _TAB + Html Parser . DOM . get Meta Elem ( meta List [ 0 ] ) ; last Meta = $head . prepend ( last Meta ) . find ( 'meta ' ) ; meta List . shift ( ) ; 
function _insert Before First ( $container , selector , elem ) { const found Elems = $container . find ( selector ) ; if ( found Elems . length > 0 ) { found Elems . eq ( 0 ) . before ( elem ) ; } else { $container . append ( elem ) ; } } 
function set Title Size ( ) { var sb = template Opts . sidebar . enabled ; var nb = template Opts . navbar . enabled ; if ( ! sb & & ! nb ) return ; var $a = sb ? $ ( ' .sidebar -title a ' ) : $ ( ' .navbar -title a ' ) ; 
function clean Filter ( ) { sb Search . reset ( ) ; if ( ! template Opts . sidebar . enabled | | ! $sidebar Nodes ) return ; set Filter Btn States ( ) ; if ( $txt Search ) $txt Search . val ( ' ' ) ; $sidebar Nodes . remove Class ( 'hidden ' ) ; if ( $btn Clean ) $btn Clean . hide ( ) ; $ ( ' .toolbar -buttons > span ' ) . css ( 'color ' , ' #fff ' ) ; 
function apply Search ( str Search ) { sb Search . parse ( str Search ) ; set Filter Btn States ( ) ; $sidebar Nodes . each ( function ( ) { var node = $ ( this ) ; var show = true ; if ( sb Search . scope . length > 0 ) { show = sb Search . has Scope ( node . attr ( 'data -scope ' ) ) ; } if ( show & & sb Search . kind . length > 0 ) { show = sb Search . has Kind ( node . attr ( 'data -kind ' ) ) ; } if ( show & & sb Search . keywords . length > 0 ) { 
function filter Sidebar Nodes ( str Search ) { if ( ! template Opts . sidebar . enabled ) return ; str Search = ( str Search | | ' ' ) . trim ( ) . to Lower Case ( ) ; if ( ! str Search ) { clean Filter ( ) ; return ; } if ( $btn Clean ) $btn Clean . show ( ) ; 
function toggle Sub Tree ( elem , fold ) { fold = typeof fold ! = = 'boolean ' ? ! elem . has Class ( 'members -folded ' ) 
function toggle Ham Menu ( show ) { if ( ! $nbm Btn ) return ; var fn = show ? 'add Class ' : 'remove Class ' ; $nbm Btn [ fn ] ( 'toggled ' ) ; $nav Overlay [ fn ] ( 'toggled ' ) ; 
function break Navbar Menu ( ) { 
function check Open Details ( ) { if ( docma . location . hash ) { var elem = $ ( 'details # ' + $ . escape Selector ( docma . location . hash ) ) ; if ( elem & & elem [ 0 ] ) elem . attr ( 'open ' , ' ' ) ; } } 
function get Filter Click Handler ( filter ) { var is Kind = filter = = = 'kind ' ; var has = is Kind ? sb Search . has Kind : sb Search . has Scope ; var add = is Kind ? sb Search . add Kind : sb Search . add Scope ; var remove = is Kind ? sb Search . remove Kind : sb Search . remove Scope ; return function ( event ) { var btn = $ ( this ) ; 
function _redirecting ( ) { if ( PATH _ROUTING ) { var redirect Path = session Storage . get Item ( 'redirect Path ' ) | | null ; if ( redirect Path ) { session Storage . remove Item ( 'redirect Path ' ) ; docma . info ( 'Redirecting to : ' , redirect Path ) ; page . redirect ( redirect Path ) ; return true ; } } return false ; } 
function get File Sync ( filename , base Path = null ) { const c Path = Path . resolve ( Path . join ( base Path | | process . cwd ( ) , filename ) ) ; return fs . path Exists Sync ( c Path ) ? c Path : null ; } 
function _promise Append JQuery ( obj ) { const document = obj . document | | obj ; 
function get Template ( name Or Template , load From Cache ) { if ( ! name Or Template ) { return ; } if ( typeof name Or Template = = = 'function ' & & name Or Template . template ) { 
function get With Resolved Data ( ctx , cur , down ) { return function ( data ) { return ctx . push ( data ) . _get ( cur , down ) ; } ; } 
function Docma Web ( data ) { this . _ = data | | { } ; * Provides configuration data of the generated SPA , which is originally set * at build -time , by the user . * See { @link api / #Docma ~Build Configuration |build configuration } for more * details on how these settings take affect . * @name Docma Web #app * @type {Object } * * @property {String } title * Document title for the main file of the generated app . * (Value of the ` &lt ;title / > ` tag . ) * @property {Array } meta * Array of arbitrary objects set for main document meta (tags ) . * @property {String } base * Base path of the generated web app . * @property {String } entrance * Name of the initial content displayed , when the web app is first * loaded . * @property {String |Object } routing * Routing settings for the generated SPA . * @property {String } server * Server /host type of the generated SPA . * / Object . define Property ( this , 'app ' , { configurable : false , get : function ( ) { return this . _ . app | | null ; } } ) ; Object . define Property ( this , 'apis ' , { configurable : false , get : function ( ) { return this . _ . apis | | { } ; } } ) ; Object . define Property ( this , 'routes ' , { configurable : false , get : function ( ) { return this . _ . routes | | { } ; } } ) ; Object . define Property ( this , 'template ' , { configurable : false , get : function ( ) { return this . _ . template | | { } ; } } ) ; * Similar to `window .location ` but with differences and additional * information . * * @name Docma Web #location * @type {Object } * @readonly * * @property {String } origin * Gets the protocol , hostname and port number of the current URL . * @property {String } host * Gets the hostname and port number of the current URL . * @property {String } hostname * Gets the domain name of the web host . * @property {String } protocol * Gets the web protocol used , without ` : ` suffix . * @property {String } href * Gets the href (URL ) of the current location . * @property {String } entrance * Gets the application entrance route , which is set at Docma build -time . * @property {String } base * Gets the base path of the application URL , which is set at Docma build -time . * @property {String } fullpath * Gets the path and filename of the current URL . * @property {String } pathname * Gets the path and filename of the current URL , without the base . * @property {String } path * Gets the path , filename and query -string of the current URL , without the base . * @property {String } hash * Gets the anchor ` # ` of the current URL , without ` # ` prefix . * @property {String } query * Gets the querystring part of the current URL , without ` ? ` prefix . * @property {Function } get Query ( ) * Gets the value of the given querystring parameter . * / Object . define Property ( this , 'location ' , { configurable : false , get : function ( ) { var fullpath = Utils . _ensure Slash ( true , window . location . pathname , true ) , base = Utils . _ensure Slash ( true , docma . app . base , true ) , pathname = fullpath ; if ( fullpath . slice ( 0 , base . length ) = = = base ) { pathname = fullpath . slice ( base . length - 1 , fullpath . length ) ; } return { host : window . location . host , hostname : window . location . hostname , origin : window . location . origin , port : window . location . port , protocol : ( window . location . protocol | | ' ' ) . replace ( / : $ / , ' ' ) , entrance : Utils . _ensure Slash ( true , docma . app . entrance , false ) , base : base , hash : ( window . location . hash | | ' ' ) . replace ( / ^ # / , ' ' ) , query : ( window . location . search | | ' ' ) . replace ( / ^ \ ? / , ' ' ) , href : window . location . href , fullpath : fullpath , pathname : pathname , path : pathname + ( window . location . search | | ' ' ) , get Query : function ( name , query ) { * Gets the route information for the current rendered content being * displayed . * * @name Docma Web #current Route * @type {Docma Web .Route } * @readonly * * @property {String } type * Type of the current route . If a generated JSDoc API * documentation is being displayed , this is set to ` "api " ` . * If any other HTML content (such as a converted markdown ) is * being displayed ; this is set to ` "content " ` . * @property {String } name * Name of the current route . For `api ` routes , this is the name * of the grouped JS files parsed . If no name is given , this is * set to ` " _def _ " ` by default . For `content ` routes , this is * either the custom name given at build -time or , by default ; the * name of the generated HTML file ; lower -cased , without the * extension . e .g . ` "README .md " ` will have the route name * ` "readme " ` after the build . * @property {String } path * Path of the current route . * / Object . define Property ( this , 'current Route ' , { configurable : false , get : function ( ) { return this . _ . current Route | | null ; } } ) ; Object . define Property ( this , 'documentation ' , { configurable : false , get : function ( ) { return this . _ . documentation | | [ ] ; } } ) ; Object . define Property ( this , 'symbols ' , { configurable : false , get : function ( ) { return this . _ . symbols | | [ ] ; } } ) ; } 
function set Opt ( old Prop , old Type , target , rename ) { const types = utils . ensure Array ( old Type ) ; if ( old Prop in opts & & types . index Of ( type Of ( opts [ old Prop ] ) ) > = 0 ) { target [ rename | | old Prop ] = opts [ old Prop ] ; } } 
function clean Name ( name ) { 
function check Root Dir ( ) { return fs . path Exists ( root Dir Path ) . then ( exists = > { if ( ! exists ) { 
function get Tree Line ( tree Node , add Class ) { var cls = 'item -tree -line ' ; if ( add Class ) cls + = ' ' + add Class ; if ( tree Node = = = 'parent ' ) cls + = ' item -tree -parent ' ; return ' <img class = " ' + cls + ' " src = "img /tree - ' + tree Node + ' .png " width = " ' + app . TREE _NODE _WIDTH + ' " height = " ' + app . SIDEBAR _NODE _HEIGHT + ' " / > ' ; } 
function get Tree Line Imgs ( levels , tree Node , has Children , last Node Levels ) { 
function compute Input Variants ( str , n ) { var variants = [ str ] ; for ( var i = 1 ; i < n ; i + + ) { var pos = Math . floor ( Math . random ( ) * str . length ) ; var chr = String . from Char Code ( ( str . char Code At ( pos ) + Math . floor ( Math . random ( ) * 1 2 8 ) ) % 1 2 8 ) ; variants [ i ] = str . substring ( 0 , pos ) + chr + str . substring ( pos + 1 , str . length ) ; } return variants ; } 
function Benchmark ( name , run , setup , tear Down ) { this . name = name ; this . run = run ; this . Setup = setup ? setup : function ( ) { } ; this . Tear Down = tear Down ? tear Down : function ( ) { } ; } 
function Benchmark Suite ( name , reference , benchmarks ) { this . name = name ; this . reference = reference ; this . benchmarks = benchmarks ; Benchmark Suite . suites . push ( this ) ; } 
function Run Next Setup ( ) { if ( index < length ) { try { suite . benchmarks [ index ] . Setup ( ) ; } catch ( e ) { suite . Notify Error ( e ) ; return null ; } return Run Next Benchmark ; } suite . Notify Result ( ) ; return null ; } 
function Format Message ( type , arg 0 , arg 1 , arg 2 ) { var arg 0 = No Side Effects To String ( arg 0 ) ; var arg 1 = No Side Effects To String ( arg 1 ) ; var arg 2 = No Side Effects To String ( arg 2 ) ; try { return % Format Message String ( type , arg 0 , arg 1 , arg 2 ) ; } catch ( e ) { return " <error > " ; } } 
function Get Column Number ( message ) { var script = % Message Get Script ( message ) ; var start _position = % Message Get Start Position ( message ) ; var location = script . location From Position ( start _position , true ) ; if ( location = = null ) return - 1 ; return location . column ; } 
function Get Source Line ( message ) { var script = % Message Get Script ( message ) ; var start _position = % Message Get Start Position ( message ) ; var location = script . location From Position ( start _position , true ) ; if ( location = = null ) return " " ; return location . source Text ; } 
function Call Site ( receiver , fun , pos , strict _mode ) { 
function ( ) { var formatted _stack _trace = UNDEFINED ; var holder = this ; while ( holder ) { var formatted _stack _trace = GET _PRIVATE ( holder , formatted Stack Trace Symbol ) ; if ( IS _UNDEFINED ( formatted _stack _trace ) ) { 
function Set Up Error ( error _function ) { % Function Set Instance Class Name ( error _function , 'Error ' ) ; var name = error _function . name ; var prototype = new Global Object ( ) ; if ( name ! = = 'Error ' ) { % Internal Set Prototype ( error _function , Global Error ) ; % Internal Set Prototype ( prototype , Global Error . prototype ) ; } % Function Set Prototype ( error _function , prototype ) ; % Add Named Property ( error _function . prototype , 'name ' , name , DONT _ENUM ) ; % Add Named Property ( error _function . prototype , 'message ' , ' ' , DONT _ENUM ) ; % Add Named Property ( error _function . prototype , 'constructor ' , error _function , DONT _ENUM ) ; % Set Code ( error _function , function ( m ) { if ( IS _UNDEFINED ( new . target ) ) return new error _function ( m ) ; try { capture Stack Trace ( this , error _function ) ; } catch ( e ) { } 
function send Packet ( socket , src MAC , type , server IP , your IP ) { 
function Float 3 2x 4Constructor ( c 0 , c 1 , c 2 , c 3 ) { if ( ! IS _UNDEFINED ( new . target ) ) { throw Make Type Error ( k Not Constructor , "Float 3 2x 4 " ) ; } return % Create Float 3 2x 4 ( TO _NUMBER ( c 0 ) , TO _NUMBER ( c 1 ) , TO _NUMBER ( c 2 ) , TO _NUMBER ( c 3 ) ) ; } 
function String Pad ( this String , max Length , fill String ) { max Length = TO _LENGTH ( max Length ) ; var string Length = this String . length ; if ( max Length < = string Length ) return " " ; if ( IS _UNDEFINED ( fill String ) ) { fill String = " " ; } else { fill String = TO _STRING ( fill String ) ; if ( fill String = = = " " ) { 
function Timer Event ( label , color , pause , thread _id ) { assert ( thread _id > = 0 & & thread _id < k Num Threads , "invalid thread id " ) ; this . label = label ; this . color = color ; this . pause = pause ; this . ranges = [ ] ; this . thread _id = thread _id ; this . index = + + num _timer _event ; } 
function assert ( something , message ) { if ( ! something ) { var error = new Error ( message ) ; error _output ( error . stack ) ; } } 
function ( timestamp ) { int _timestamp = parse Int ( timestamp ) ; assert ( int _timestamp > = last _timestamp , "Inconsistent timestamps . " ) ; last _timestamp = int _timestamp ; distortion + = distortion _per _entry ; return int _timestamp / 1 0 0 0 - distortion ; } 
function Spread Arguments ( ) { var count = arguments . length ; var args = new Internal Array ( ) ; for ( var i = 0 ; i < count ; + + i ) { var array = arguments [ i ] ; var length = array . length ; for ( var j = 0 ; j < length ; + + j ) { args . push ( array [ j ] ) ; } } return args ; } 
function Is Reg Exp ( o ) { if ( ! IS _RECEIVER ( o ) ) return false ; var is _regexp = o [ match Symbol ] ; if ( ! IS _UNDEFINED ( is _regexp ) ) return TO _BOOLEAN ( is _regexp ) ; return IS _REGEXP ( o ) ; } 
function Reg Exp Initialize ( object , pattern , flags ) { pattern = IS _UNDEFINED ( pattern ) ? ' ' : TO _STRING ( pattern ) ; flags = IS _UNDEFINED ( flags ) ? ' ' : TO _STRING ( flags ) ; % Reg Exp Initialize And Compile ( object , pattern , flags ) ; return object ; } 
function Reg Exp Constructor ( pattern , flags ) { var newtarget = new . target ; var pattern _is _regexp = Is Reg Exp ( pattern ) ; if ( IS _UNDEFINED ( newtarget ) ) { newtarget = Global Reg Exp ; 
function Reg Exp Compile JS ( pattern , flags ) { if ( ! IS _REGEXP ( this ) ) { throw Make Type Error ( k Incompatible Method Receiver , "Reg Exp .prototype .compile " , this ) ; } if ( IS _REGEXP ( pattern ) ) { if ( ! IS _UNDEFINED ( flags ) ) throw Make Type Error ( k Reg Exp Flags ) ; flags = Pattern Flags ( pattern ) ; pattern = REGEXP _SOURCE ( pattern ) ; } Reg Exp Initialize ( this , pattern , flags ) ; 
function Reg Exp Exec JS ( string ) { if ( ! IS _REGEXP ( this ) ) { throw Make Type Error ( k Incompatible Method Receiver , 'Reg Exp .prototype .exec ' , this ) ; } string = TO _STRING ( string ) ; var last Index = this . last Index ; 
function Reg Exp Split ( string , limit ) { 
function String Replace Global Reg Exp With Function ( subject , regexp , replace ) { var result Array = reusable Replace Array ; if ( result Array ) { reusable Replace Array = null ; } else { 
function Capture String ( string , last Capture Info , index ) { 
function Get Substitution ( matched , string , position , captures , replacement ) { var match Length = matched . length ; var string Length = string . length ; var captures Length = captures . length ; var tail Pos = position + match Length ; var result = " " ; var pos , expansion , peek , next , scaled Index , advance , new Scaled Index ; var next = % String Index Of ( replacement , ' $ ' , 0 ) ; if ( next < 0 ) { result + = replacement ; return result ; } if ( next > 0 ) result + = % _Sub String ( replacement , 0 , next ) ; while ( true ) { expansion = ' $ ' ; pos = next + 1 ; if ( pos < replacement . length ) { peek = % _String Char Code At ( replacement , pos ) ; if ( peek = = 3 6 ) { 
function Advance String Index ( string , index , unicode ) { var increment = 1 ; if ( unicode ) { var first = % _String Char Code At ( string , index ) ; if ( first > = 0x D 8 0 0 & & first < = 0x DBFF & & string . length > index + 1 ) { var second = % _String Char Code At ( string , index + 1 ) ; if ( second > = 0x DC 0 0 & & second < = 0x DFFF ) { increment = 2 ; } } } return increment ; } 
function Reg Exp Get Last Match ( ) { var reg Exp Subject = LAST _SUBJECT ( Reg Exp Last Match Info ) ; return % _Sub String ( reg Exp Subject , Reg Exp Last Match Info [ CAPTURE 0 ] , Reg Exp Last Match Info [ CAPTURE 1 ] ) ; } 
function Reg Exp Make Capture Getter ( n ) { return function foo ( ) { var index = n * 2 ; if ( index > = NUMBER _OF _CAPTURES ( Reg Exp Last Match Info ) ) return ' ' ; var match Start = Reg Exp Last Match Info [ CAPTURE ( index ) ] ; var match End = Reg Exp Last Match Info [ CAPTURE ( index + 1 ) ] ; if ( match Start = = - 1 | | match End = = - 1 ) return ' ' ; return % _Sub String ( LAST _SUBJECT ( Reg Exp Last Match Info ) , match Start , match End ) ; } ; } 
function Reg Exp Get Flags ( ) { if ( ! IS _RECEIVER ( this ) ) { throw Make Type Error ( k Reg Exp Non Object , "Reg Exp .prototype .flags " , TO _STRING ( this ) ) ; } var result = ' ' ; if ( this . global ) result + = 'g ' ; if ( this . ignore Case ) result + = 'i ' ; if ( this . multiline ) result + = 'm ' ; if ( this . unicode ) result + = 'u ' ; if ( this . sticky ) result + = 'y ' ; return result ; } 
function Reg Exp Get Ignore Case ( ) { if ( ! IS _REGEXP ( this ) ) { 
function Reg Exp Get Multiline ( ) { if ( ! IS _REGEXP ( this ) ) { 
function Big Integer ( a , b , c ) { this . array = new Array ( ) ; if ( a ! = null ) if ( "number " = = typeof a ) this . from Number ( a , b , c ) ; else if ( b = = null & & "string " ! = typeof a ) this . from String ( a , 2 5 6 ) ; else this . from String ( a , b ) ; } 
function am 1 ( i , x , w , j , c , n ) { var this _array = this . array ; var w _array = w . array ; while ( - - n > = 0 ) { var v = x * this _array [ i + + ] + w _array [ j ] + c ; c = Math . floor ( v / 0x 4 0 0 0 0 0 0 ) ; w _array [ j + + ] = v & 0x 3ffffff ; } return c ; } 
function bnp Copy To ( r ) { var this _array = this . array ; var r _array = r . array ; for ( var i = this . t - 1 ; i > = 0 ; - - i ) r _array [ i ] = this _array [ i ] ; r . t = this . t ; r . s = this . s ; } 
function bnp From Int ( x ) { var this _array = this . array ; this . t = 1 ; this . s = ( x < 0 ) ? - 1 : 0 ; if ( x > 0 ) this _array [ 0 ] = x ; else if ( x < - 1 ) this _array [ 0 ] = x + DV ; else this . t = 0 ; } 
function bnp Clamp ( ) { var this _array = this . array ; var c = this . s & BI _DM ; while ( this . t > 0 & & this _array [ this . t - 1 ] = = c ) - - this . t ; } 
function bn Compare To ( a ) { var this _array = this . array ; var a _array = a . array ; var r = this . s - a . s ; if ( r ! = 0 ) return r ; var i = this . t ; r = i - a . t ; if ( r ! = 0 ) return r ; while ( - - i > = 0 ) if ( ( r = this _array [ i ] - a _array [ i ] ) ! = 0 ) return r ; return 0 ; } 
function bn Bit Length ( ) { var this _array = this . array ; if ( this . t < = 0 ) return 0 ; return BI _DB * ( this . t - 1 ) + nbits ( this _array [ this . t - 1 ] ^ ( this . s & BI _DM ) ) ; } 
function bnp DLShift To ( n , r ) { var this _array = this . array ; var r _array = r . array ; var i ; for ( i = this . t - 1 ; i > = 0 ; - - i ) r _array [ i + n ] = this _array [ i ] ; for ( i = n - 1 ; i > = 0 ; - - i ) r _array [ i ] = 0 ; r . t = this . t + n ; r . s = this . s ; } 
function bnp DRShift To ( n , r ) { var this _array = this . array ; var r _array = r . array ; for ( var i = n ; i < this . t ; + + i ) r _array [ i - n ] = this _array [ i ] ; r . t = Math . max ( this . t - n , 0 ) ; r . s = this . s ; } 
function bnp LShift To ( n , r ) { var this _array = this . array ; var r _array = r . array ; var bs = n % BI _DB ; var cbs = BI _DB - bs ; var bm = ( 1 < < cbs ) - 1 ; var ds = Math . floor ( n / BI _DB ) , c = ( this . s < < bs ) & BI _DM , i ; for ( i = this . t - 1 ; i > = 0 ; - - i ) { r _array [ i + ds + 1 ] = ( this _array [ i ] > > cbs ) | c ; c = ( this _array [ i ] & bm ) < < bs ; } for ( i = ds - 1 ; i > = 0 ; - - i ) r _array [ i ] = 0 ; r _array [ ds ] = c ; r . t = this . t + ds + 1 ; r . s = this . s ; r . clamp ( ) ; } 
function bnp RShift To ( n , r ) { var this _array = this . array ; var r _array = r . array ; r . s = this . s ; var ds = Math . floor ( n / BI _DB ) ; if ( ds > = this . t ) { r . t = 0 ; return ; } var bs = n % BI _DB ; var cbs = BI _DB - bs ; var bm = ( 1 < < bs ) - 1 ; r _array [ 0 ] = this _array [ ds ] > > bs ; for ( var i = ds + 1 ; i < this . t ; + + i ) { r _array [ i - ds - 1 ] | = ( this _array [ i ] & bm ) < < cbs ; r _array [ i - ds ] = this _array [ i ] > > bs ; } if ( bs > 0 ) r _array [ this . t - ds - 1 ] | = ( this . s & bm ) < < cbs ; r . t = this . t - ds ; r . clamp ( ) ; } 
function bnp Sub To ( a , r ) { var this _array = this . array ; var r _array = r . array ; var a _array = a . array ; var i = 0 , c = 0 , m = Math . min ( a . t , this . t ) ; while ( i < m ) { c + = this _array [ i ] - a _array [ i ] ; r _array [ i + + ] = c & BI _DM ; c > > = BI _DB ; } if ( a . t < this . t ) { c - = a . s ; while ( i < this . t ) { c + = this _array [ i ] ; r _array [ i + + ] = c & BI _DM ; c > > = BI _DB ; } c + = this . s ; } else { c + = this . s ; while ( i < a . t ) { c - = a _array [ i ] ; r _array [ i + + ] = c & BI _DM ; c > > = BI _DB ; } c - = a . s ; } r . s = ( c < 0 ) ? - 1 : 0 ; if ( c < - 1 ) r _array [ i + + ] = BI _DV + c ; else if ( c > 0 ) r _array [ i + + ] = c ; r . t = i ; r . clamp ( ) ; } 
function bnp Multiply To ( a , r ) { var this _array = this . array ; var r _array = r . array ; var x = this . abs ( ) , y = a . abs ( ) ; var y _array = y . array ; var i = x . t ; r . t = i + y . t ; while ( - - i > = 0 ) r _array [ i ] = 0 ; for ( i = 0 ; i < y . t ; + + i ) r _array [ i + x . t ] = x . am ( 0 , y _array [ i ] , r , i , 0 , x . t ) ; r . s = 0 ; r . clamp ( ) ; if ( this . s ! = a . s ) Big Integer . ZERO . sub To ( r , r ) ; } 
function bnp Square To ( r ) { var x = this . abs ( ) ; var x _array = x . array ; var r _array = r . array ; var i = r . t = 2 * x . t ; while ( - - i > = 0 ) r _array [ i ] = 0 ; for ( i = 0 ; i < x . t - 1 ; + + i ) { var c = x . am ( i , x _array [ i ] , r , 2 * i , 0 , 1 ) ; if ( ( r _array [ i + x . t ] + = x . am ( i + 1 , 2 * x _array [ i ] , r , 2 * i + 1 , c , x . t - i - 1 ) ) > = BI _DV ) { r _array [ i + x . t ] - = BI _DV ; r _array [ i + x . t + 1 ] = 1 ; } } if ( r . t > 0 ) r _array [ r . t - 1 ] + = x . am ( i , x _array [ i ] , r , 2 * i , 0 , 1 ) ; r . s = 0 ; r . clamp ( ) ; } 
function bnp Div Rem To ( m , q , r ) { var pm = m . abs ( ) ; if ( pm . t < = 0 ) return ; var pt = this . abs ( ) ; if ( pt . t < pm . t ) { if ( q ! = null ) q . from Int ( 0 ) ; if ( r ! = null ) this . copy To ( r ) ; return ; } if ( r = = null ) r = nbi ( ) ; var y = nbi ( ) , ts = this . s , ms = m . s ; var pm _array = pm . array ; var nsh = BI _DB - nbits ( pm _array [ pm . t - 1 ] ) ; 
function bnp Inv Digit ( ) { var this _array = this . array ; if ( this . t < 1 ) return 0 ; var x = this _array [ 0 ] ; if ( ( x & 1 ) = = 0 ) return 0 ; var y = x & 3 ; 
function mont Reduce ( x ) { var x _array = x . array ; while ( x . t < = this . mt 2 ) 
function bn Int Value ( ) { var this _array = this . array ; if ( this . s < 0 ) { if ( this . t = = 1 ) return this _array [ 0 ] - BI _DV ; else if ( this . t = = 0 ) return - 1 ; } else if ( this . t = = 1 ) return this _array [ 0 ] ; else if ( this . t = = 0 ) return 0 ; 
function bn To Byte Array ( ) { var this _array = this . array ; var i = this . t , r = new Array ( ) ; r [ 0 ] = this . s ; var p = BI _DB - ( i * BI _DB ) % 8 , d , k = 0 ; if ( i - - > 0 ) { if ( p < BI _DB & & ( d = this _array [ i ] > > p ) ! = ( this . s & BI _DM ) > > p ) r [ k + + ] = d | ( this . s < < ( BI _DB - p ) ) ; while ( i > = 0 ) { if ( p < 8 ) { d = ( this _array [ i ] & ( ( 1 < < p ) - 1 ) ) < < ( 8 - p ) ; d | = this _array [ - - i ] > > ( p + = BI _DB - 8 ) ; } else { d = ( this _array [ i ] > > ( p - = 8 ) ) & 0xff ; if ( p < = 0 ) { p + = BI _DB ; - - i ; } } if ( ( d & 0x 8 0 ) ! = 0 ) d | = - 2 5 6 ; if ( k = = 0 & & ( this . s & 0x 8 0 ) ! = ( d & 0x 8 0 ) ) + + k ; if ( k > 0 | | d ! = this . s ) r [ k + + ] = d ; } } return r ; } 
function bnp Bitwise To ( a , op , r ) { var this _array = this . array ; var a _array = a . array ; var r _array = r . array ; var i , f , m = Math . min ( a . t , this . t ) ; for ( i = 0 ; i < m ; + + i ) r _array [ i ] = op ( this _array [ i ] , a _array [ i ] ) ; if ( a . t < this . t ) { f = a . s & BI _DM ; for ( i = m ; i < this . t ; + + i ) r _array [ i ] = op ( this _array [ i ] , f ) ; r . t = this . t ; } else { f = this . s & BI _DM ; for ( i = m ; i < a . t ; + + i ) r _array [ i ] = op ( f , a _array [ i ] ) ; r . t = a . t ; } r . s = op ( this . s , a . s ) ; r . clamp ( ) ; } 
function bn Not ( ) { var this _array = this . array ; var r = nbi ( ) ; var r _array = r . array ; for ( var i = 0 ; i < this . t ; + + i ) r _array [ i ] = BI _DM & ~ this _array [ i ] ; r . t = this . t ; r . s = ~ this . s ; return r ; } 
function bn Get Lowest Set Bit ( ) { var this _array = this . array ; for ( var i = 0 ; i < this . t ; + + i ) if ( this _array [ i ] ! = 0 ) return i * BI _DB + lbit ( this _array [ i ] ) ; if ( this . s < 0 ) return this . t * BI _DB ; return - 1 ; } 
function bnp DMultiply ( n ) { var this _array = this . array ; this _array [ this . t ] = this . am ( 0 , n - 1 , this , 0 , 0 , this . t ) ; + + this . t ; this . clamp ( ) ; } 
function bnp DAdd Offset ( n , w ) { var this _array = this . array ; while ( this . t < = w ) this _array [ this . t + + ] = 0 ; this _array [ w ] + = n ; while ( this _array [ w ] > = BI _DV ) { this _array [ w ] - = BI _DV ; if ( + + w > = this . t ) this _array [ this . t + + ] = 0 ; + + this _array [ w ] ; } } 
function bnp Mod Int ( n ) { var this _array = this . array ; if ( n < = 0 ) return 0 ; var d = BI _DV % n , r = ( this . s < 0 ) ? n - 1 : 0 ; if ( this . t > 0 ) if ( d = = 0 ) r = this _array [ 0 ] % n ; else for ( var i = this . t - 1 ; i > = 0 ; - - i ) r = ( d * r + this _array [ i ] ) % n ; return r ; } 
function pkcs 1pad 2 ( s , n ) { if ( n < s . length + 1 1 ) { alert ( "Message too long for RSA " ) ; return null ; } var ba = new Array ( ) ; var i = s . length - 1 ; while ( i > = 0 & & n > 0 ) ba [ - - n ] = s . char Code At ( i - - ) ; ba [ - - n ] = 0 ; var rng = new Secure Random ( ) ; var x = new Array ( ) ; while ( n > 2 ) { 
function RSASet Public ( N , E ) { if ( N ! = null & & E ! = null & & N . length > 0 & & E . length > 0 ) { this . n = parse Big Int ( N , 1 6 ) ; this . e = parse Int ( E , 1 6 ) ; } else alert ( "Invalid RSA public key " ) ; } 
function pkcs 1unpad 2 ( d , n ) { var b = d . to Byte Array ( ) ; var i = 0 ; while ( i < b . length & & b [ i ] = = 0 ) + + i ; if ( b . length - i ! = n - 1 | | b [ i ] ! = 2 ) return null ; + + i ; while ( b [ i ] ! = 0 ) if ( + + i > = b . length ) return null ; var ret = " " ; while ( + + i < b . length ) ret + = String . from Char Code ( b [ i ] ) ; return ret ; } 
function RSASet Private ( N , E , D ) { if ( N ! = null & & E ! = null & & N . length > 0 & & E . length > 0 ) { this . n = parse Big Int ( N , 1 6 ) ; this . e = parse Int ( E , 1 6 ) ; this . d = parse Big Int ( D , 1 6 ) ; } else alert ( "Invalid RSA private key " ) ; } 
function Add Bound Method ( obj , method Name , implementation , length , type ) { % Check Is Bootstrapping ( ) ; var internal Name = % Create Private Symbol ( method Name ) ; 
function supported Locales Of ( service , locales , options ) { if ( IS _NULL ( Internal Reg Exp Match ( Get Service RE ( ) , service ) ) ) { throw Make Error ( k Wrong Service Type , service ) ; } 
function lookup Supported Locales Of ( requested Locales , available Locales ) { var matched Locales = new Internal Array ( ) ; for ( var i = 0 ; i < requested Locales . length ; + + i ) { 
function get Get Option ( options , caller ) { if ( IS _UNDEFINED ( options ) ) throw Make Error ( k Default Options Missing , caller ) ; var get Option = function get Option ( property , type , values , default Value ) { if ( ! IS _UNDEFINED ( options [ property ] ) ) { var value = options [ property ] ; switch ( type ) { case 'boolean ' : value = TO _BOOLEAN ( value ) ; break ; case 'string ' : value = TO _STRING ( value ) ; break ; case 'number ' : value = TO _NUMBER ( value ) ; break ; default : throw Make Error ( k Wrong Value Type ) ; } if ( ! IS _UNDEFINED ( values ) & & % _Call ( Array Index Of , values , value ) = = = - 1 ) { throw Make Range Error ( k Value Out Of Range , value , caller , property ) ; } return value ; } return default Value ; } return get Option ; } 
function resolve Locale ( service , requested Locales , options ) { requested Locales = initialize Locale List ( requested Locales ) ; var get Option = get Get Option ( options , service ) ; var matcher = get Option ( 'locale Matcher ' , 'string ' , [ 'lookup ' , 'best fit ' ] , 'best fit ' ) ; var resolved ; if ( matcher = = = 'lookup ' ) { resolved = lookup Matcher ( service , requested Locales ) ; } else { resolved = best Fit Matcher ( service , requested Locales ) ; } return resolved ; } 
function lookup Matcher ( service , requested Locales ) { if ( IS _NULL ( Internal Reg Exp Match ( Get Service RE ( ) , service ) ) ) { throw Make Error ( k Wrong Service Type , service ) ; } 
function parse Extension ( extension ) { var extension Split = % _Call ( String Split , extension , ' - ' ) ; 
function set Options ( in Options , extension Map , key Values , get Option , out Options ) { var extension = ' ' ; var update Extension = function update Extension ( key , value ) { return ' - ' + key + ' - ' + TO _STRING ( value ) ; } var update Property = function update Property ( property , type , value ) { if ( type = = = 'boolean ' & & ( typeof value = = = 'string ' ) ) { value = ( value = = = 'true ' ) ? true : false ; } if ( ! IS _UNDEFINED ( property ) ) { define WEProperty ( out Options , property , value ) ; } } for ( var key in key Values ) { if ( HAS _OWN _PROPERTY ( key Values , key ) ) { var value = UNDEFINED ; var map = key Values [ key ] ; if ( ! IS _UNDEFINED ( map . property ) ) { 
function freeze Array ( input ) { var array = [ ] ; var l = input . length ; for ( var i = 0 ; i < l ; i + + ) { if ( i in input ) { % object _define _property ( array , i , { value : input [ i ] , configurable : false , writable : false , enumerable : true } ) ; } } % object _define _property ( array , 'length ' , { value : l , writable : false } ) ; return array ; } 
function get Optimal Language Tag ( original , resolved ) { 
function get Available Locales Of ( service ) { var available = % Available Locales Of ( service ) ; for ( var i in available ) { if ( HAS _OWN _PROPERTY ( available , i ) ) { var parts = Internal Reg Exp Match ( / ^ ( [a -z ] { 2 , 3 } ) - ( [A -Z ] [a -z ] { 3 } ) - ( [A -Z ] { 2 } ) $ / , i ) ; if ( ! IS _NULL ( parts ) ) { 
function define WEProperty ( object , property , value ) { % object _define _property ( object , property , { value : value , writable : true , enumerable : true } ) ; } 
function add WEProperty If Defined ( object , property , value ) { if ( ! IS _UNDEFINED ( value ) ) { define WEProperty ( object , property , value ) ; } } 
function define WECProperty ( object , property , value ) { % object _define _property ( object , property , { value : value , writable : true , enumerable : true , configurable : true } ) ; } 
function add WECProperty If Defined ( object , property , value ) { if ( ! IS _UNDEFINED ( value ) ) { define WECProperty ( object , property , value ) ; } } 
function to Title Case Word ( word ) { return % String To Upper Case ( % _Call ( String Substr , word , 0 , 1 ) ) + % String To Lower Case ( % _Call ( String Substr , word , 1 ) ) ; } 
function to Title Case Timezone Location ( location ) { var match = Internal Reg Exp Match ( Get Timezone Name Location Part RE ( ) , location ) if ( IS _NULL ( match ) ) throw Make Range Error ( k Expected Location , location ) ; var result = to Title Case Word ( match [ 1 ] ) ; if ( ! IS _UNDEFINED ( match [ 2 ] ) & & 2 < match . length ) { 
function canonicalize Language Tag ( locale ID ) { 
function initialize Locale List ( locales ) { var seen = new Internal Array ( ) ; if ( ! IS _UNDEFINED ( locales ) ) { 
function is Valid Language Tag ( locale ) { 
function Build Language Tag REs ( ) { var alpha = ' [a -z A -Z ] ' ; var digit = ' [ 0 - 9 ] ' ; var alphanum = ' ( ' + alpha + ' | ' + digit + ' ) ' ; var regular = ' (art -lojban |cel -gaulish |no -bok |no -nyn |zh -guoyu |zh -hakka | ' + 'zh -min |zh -min -nan |zh -xiang ) ' ; var irregular = ' (en -GB -oed |i -ami |i -bnn |i -default |i -enochian |i -hak | ' + 'i -klingon |i -lux |i -mingo |i -navajo |i -pwn |i -tao |i -tay | ' + 'i -tsu |sgn -BE -FR |sgn -BE -NL |sgn -CH -DE ) ' ; var grandfathered = ' ( ' + irregular + ' | ' + regular + ' ) ' ; var private Use = ' (x ( - ' + alphanum + ' { 1 , 8 } ) + ) ' ; var singleton = ' ( ' + digit + ' | [A -WY -Za -wy -z ] ) ' ; LANGUAGE _SINGLETON _RE = new Global Reg Exp ( ' ^ ' + singleton + ' $ ' , 'i ' ) ; var extension = ' ( ' + singleton + ' ( - ' + alphanum + ' { 2 , 8 } ) + ) ' ; var variant = ' ( ' + alphanum + ' { 5 , 8 } | ( ' + digit + alphanum + ' { 3 } ) ) ' ; LANGUAGE _VARIANT _RE = new Global Reg Exp ( ' ^ ' + variant + ' $ ' , 'i ' ) ; var region = ' ( ' + alpha + ' { 2 } | ' + digit + ' { 3 } ) ' ; var script = ' ( ' + alpha + ' { 4 } ) ' ; var ext Lang = ' ( ' + alpha + ' { 3 } ( - ' + alpha + ' { 3 } ) { 0 , 2 } ) ' ; var language = ' ( ' + alpha + ' { 2 , 3 } ( - ' + ext Lang + ' ) ? | ' + alpha + ' { 4 } | ' + alpha + ' { 5 , 8 } ) ' ; var lang Tag = language + ' ( - ' + script + ' ) ? ( - ' + region + ' ) ? ( - ' + variant + ' ) * ( - ' + extension + ' ) * ( - ' + private Use + ' ) ? ' ; var language Tag = ' ^ ( ' + lang Tag + ' | ' + private Use + ' | ' + grandfathered + ' ) $ ' ; LANGUAGE _TAG _RE = new Global Reg Exp ( language Tag , 'i ' ) ; } 
function initialize Collator ( collator , locales , options ) { if ( % Is Initialized Intl Object ( collator ) ) { throw Make Type Error ( k Reinitialize Intl , "Collator " ) ; } if ( IS _UNDEFINED ( options ) ) { options = { } ; } var get Option = get Get Option ( options , 'collator ' ) ; var internal Options = { } ; define WEProperty ( internal Options , 'usage ' , get Option ( 'usage ' , 'string ' , [ 'sort ' , 'search ' ] , 'sort ' ) ) ; var sensitivity = get Option ( 'sensitivity ' , 'string ' , [ 'base ' , 'accent ' , 'case ' , 'variant ' ] ) ; if ( IS _UNDEFINED ( sensitivity ) & & internal Options . usage = = = 'sort ' ) { sensitivity = 'variant ' ; } define WEProperty ( internal Options , 'sensitivity ' , sensitivity ) ; define WEProperty ( internal Options , 'ignore Punctuation ' , get Option ( 'ignore Punctuation ' , 'boolean ' , UNDEFINED , false ) ) ; var locale = resolve Locale ( 'collator ' , locales , options ) ; * Map of Unicode extensions to option properties , and their values and types , * for a collator . * / var COLLATOR _KEY _MAP = { 'kn ' : { 'property ' : 'numeric ' , 'type ' : 'boolean ' } , 'kf ' : { 'property ' : 'case First ' , 'type ' : 'string ' , 'values ' : [ 'false ' , 'lower ' , 'upper ' ] } } ; set Options ( options , extension Map , COLLATOR _KEY _MAP , get Option , internal Options ) ; var collation = 'default ' ; var extension = ' ' ; if ( HAS _OWN _PROPERTY ( extension Map , 'co ' ) & & internal Options . usage = = = 'sort ' ) { var ALLOWED _CO _VALUES = [ 'big 5han ' , 'dict ' , 'direct ' , 'ducet ' , 'gb 2 3 1 2 ' , 'phonebk ' , 'phonetic ' , 'pinyin ' , 'reformed ' , 'searchjl ' , 'stroke ' , 'trad ' , 'unihan ' , 'zhuyin ' ] ; if ( % _Call ( Array Index Of , ALLOWED _CO _VALUES , extension Map . co ) ! = = - 1 ) { extension = ' -u -co - ' + extension Map . co ; 
function compare ( collator , x , y ) { return % Internal Compare ( % Get Impl From Initialized Intl Object ( collator ) , TO _STRING ( x ) , TO _STRING ( y ) ) ; } 
function get Number Option ( options , property , min , max , fallback ) { var value = options [ property ] ; if ( ! IS _UNDEFINED ( value ) ) { value = TO _NUMBER ( value ) ; if ( NUMBER _IS _NAN ( value ) | | value < min | | value > max ) { throw Make Range Error ( k Property Value Out Of Range , property ) ; } return % math _floor ( value ) ; } return fallback ; } 
function initialize Number Format ( number Format , locales , options ) { if ( % Is Initialized Intl Object ( number Format ) ) { throw Make Type Error ( k Reinitialize Intl , "Number Format " ) ; } if ( IS _UNDEFINED ( options ) ) { options = { } ; } var get Option = get Get Option ( options , 'numberformat ' ) ; var locale = resolve Locale ( 'numberformat ' , locales , options ) ; var internal Options = { } ; define WEProperty ( internal Options , 'style ' , get Option ( 'style ' , 'string ' , [ 'decimal ' , 'percent ' , 'currency ' ] , 'decimal ' ) ) ; var currency = get Option ( 'currency ' , 'string ' ) ; if ( ! IS _UNDEFINED ( currency ) & & ! is Well Formed Currency Code ( currency ) ) { throw Make Range Error ( k Invalid Currency Code , currency ) ; } if ( internal Options . style = = = 'currency ' & & IS _UNDEFINED ( currency ) ) { throw Make Type Error ( k Currency Code ) ; } var currency Display = get Option ( 'currency Display ' , 'string ' , [ 'code ' , 'symbol ' , 'name ' ] , 'symbol ' ) ; if ( internal Options . style = = = 'currency ' ) { define WEProperty ( internal Options , 'currency ' , % String To Upper Case ( currency ) ) ; define WEProperty ( internal Options , 'currency Display ' , currency Display ) ; } * Map of Unicode extensions to option properties , and their values and types , * for a number format . * / var NUMBER _FORMAT _KEY _MAP = { 'nu ' : { 'property ' : UNDEFINED , 'type ' : 'string ' } } ; var extension = set Options ( options , extension Map , NUMBER _FORMAT _KEY _MAP , get Option , internal Options ) ; var requested Locale = locale . locale + extension ; var resolved = % object _define _properties ( { } , { currency : { writable : true } , currency Display : { writable : true } , locale : { writable : true } , maximum Fraction Digits : { writable : true } , minimum Fraction Digits : { writable : true } , minimum Integer Digits : { writable : true } , numbering System : { writable : true } , requested Locale : { value : requested Locale , writable : true } , style : { value : internal Options . style , writable : true } , use Grouping : { writable : true } } ) ; if ( HAS _OWN _PROPERTY ( internal Options , 'minimum Significant Digits ' ) ) { define WEProperty ( resolved , 'minimum Significant Digits ' , UNDEFINED ) ; } if ( HAS _OWN _PROPERTY ( internal Options , 'maximum Significant Digits ' ) ) { define WEProperty ( resolved , 'maximum Significant Digits ' , UNDEFINED ) ; } var formatter = % Create Number Format ( requested Locale , internal Options , resolved ) ; if ( internal Options . style = = = 'currency ' ) { % object _define _property ( resolved , 'currency Display ' , { value : currency Display , writable : true } ) ; } % Mark As Initialized Intl Object Of Type ( number Format , 'numberformat ' , formatter ) ; number Format [ resolved Symbol ] = resolved ; if ( FLAG _intl _extra ) { % object _define _property ( resolved , 'pattern ' , pattern Accessor ) ; % object _define _property ( number Format , 'resolved ' , resolved Accessor ) ; } return number Format ; } 
function format Number ( formatter , value ) { 
function to LDMLString ( options ) { var get Option = get Get Option ( options , 'dateformat ' ) ; var ldml String = ' ' ; var option = get Option ( 'weekday ' , 'string ' , [ 'narrow ' , 'short ' , 'long ' ] ) ; ldml String + = append To LDMLString ( option , { narrow : 'EEEEE ' , short : 'EEE ' , long : 'EEEE ' } ) ; option = get Option ( 'era ' , 'string ' , [ 'narrow ' , 'short ' , 'long ' ] ) ; ldml String + = append To LDMLString ( option , { narrow : 'GGGGG ' , short : 'GGG ' , long : 'GGGG ' } ) ; option = get Option ( 'year ' , 'string ' , [ ' 2 -digit ' , 'numeric ' ] ) ; ldml String + = append To LDMLString ( option , { ' 2 -digit ' : 'yy ' , 'numeric ' : 'y ' } ) ; option = get Option ( 'month ' , 'string ' , [ ' 2 -digit ' , 'numeric ' , 'narrow ' , 'short ' , 'long ' ] ) ; ldml String + = append To LDMLString ( option , { ' 2 -digit ' : 'MM ' , 'numeric ' : 'M ' , 'narrow ' : 'MMMMM ' , 'short ' : 'MMM ' , 'long ' : 'MMMM ' } ) ; option = get Option ( 'day ' , 'string ' , [ ' 2 -digit ' , 'numeric ' ] ) ; ldml String + = append To LDMLString ( option , { ' 2 -digit ' : 'dd ' , 'numeric ' : 'd ' } ) ; var hr 1 2 = get Option ( 'hour 1 2 ' , 'boolean ' ) ; option = get Option ( 'hour ' , 'string ' , [ ' 2 -digit ' , 'numeric ' ] ) ; if ( IS _UNDEFINED ( hr 1 2 ) ) { ldml String + = append To LDMLString ( option , { ' 2 -digit ' : 'jj ' , 'numeric ' : 'j ' } ) ; } else if ( hr 1 2 = = = true ) { ldml String + = append To LDMLString ( option , { ' 2 -digit ' : 'hh ' , 'numeric ' : 'h ' } ) ; } else { ldml String + = append To LDMLString ( option , { ' 2 -digit ' : 'HH ' , 'numeric ' : 'H ' } ) ; } option = get Option ( 'minute ' , 'string ' , [ ' 2 -digit ' , 'numeric ' ] ) ; ldml String + = append To LDMLString ( option , { ' 2 -digit ' : 'mm ' , 'numeric ' : 'm ' } ) ; option = get Option ( 'second ' , 'string ' , [ ' 2 -digit ' , 'numeric ' ] ) ; ldml String + = append To LDMLString ( option , { ' 2 -digit ' : 'ss ' , 'numeric ' : 's ' } ) ; option = get Option ( 'time Zone Name ' , 'string ' , [ 'short ' , 'long ' ] ) ; ldml String + = append To LDMLString ( option , { short : 'z ' , long : 'zzzz ' } ) ; return ldml String ; } 
function from LDMLString ( ldml String ) { 
function to Date Time Options ( options , required , defaults ) { if ( IS _UNDEFINED ( options ) ) { options = { } ; } else { options = TO _OBJECT ( options ) ; } var needs Default = true ; if ( ( required = = = 'date ' | | required = = = 'any ' ) & & ( ! IS _UNDEFINED ( options . weekday ) | | ! IS _UNDEFINED ( options . year ) | | ! IS _UNDEFINED ( options . month ) | | ! IS _UNDEFINED ( options . day ) ) ) { needs Default = false ; } if ( ( required = = = 'time ' | | required = = = 'any ' ) & & ( ! IS _UNDEFINED ( options . hour ) | | ! IS _UNDEFINED ( options . minute ) | | ! IS _UNDEFINED ( options . second ) ) ) { needs Default = false ; } if ( needs Default & & ( defaults = = = 'date ' | | defaults = = = 'all ' ) ) { % object _define _property ( options , 'year ' , { value : 'numeric ' , writable : true , enumerable : true , configurable : true } ) ; % object _define _property ( options , 'month ' , { value : 'numeric ' , writable : true , enumerable : true , configurable : true } ) ; % object _define _property ( options , 'day ' , { value : 'numeric ' , writable : true , enumerable : true , configurable : true } ) ; } if ( needs Default & & ( defaults = = = 'time ' | | defaults = = = 'all ' ) ) { % object _define _property ( options , 'hour ' , { value : 'numeric ' , writable : true , enumerable : true , configurable : true } ) ; % object _define _property ( options , 'minute ' , { value : 'numeric ' , writable : true , enumerable : true , configurable : true } ) ; % object _define _property ( options , 'second ' , { value : 'numeric ' , writable : true , enumerable : true , configurable : true } ) ; } return options ; } 
function initialize Date Time Format ( date Format , locales , options ) { if ( % Is Initialized Intl Object ( date Format ) ) { throw Make Type Error ( k Reinitialize Intl , "Date Time Format " ) ; } if ( IS _UNDEFINED ( options ) ) { options = { } ; } var locale = resolve Locale ( 'dateformat ' , locales , options ) ; options = to Date Time Options ( options , 'any ' , 'date ' ) ; var get Option = get Get Option ( options , 'dateformat ' ) ; * Map of Unicode extensions to option properties , and their values and types , * for a date /time format . * / var DATETIME _FORMAT _KEY _MAP = { 'ca ' : { 'property ' : UNDEFINED , 'type ' : 'string ' } , 'nu ' : { 'property ' : UNDEFINED , 'type ' : 'string ' } } ; var extension = set Options ( options , extension Map , DATETIME _FORMAT _KEY _MAP , get Option , internal Options ) ; var requested Locale = locale . locale + extension ; var resolved = % object _define _properties ( { } , { calendar : { writable : true } , day : { writable : true } , era : { writable : true } , hour 1 2 : { writable : true } , hour : { writable : true } , locale : { writable : true } , minute : { writable : true } , month : { writable : true } , numbering System : { writable : true } , [ pattern Symbol ] : { writable : true } , requested Locale : { value : requested Locale , writable : true } , second : { writable : true } , time Zone : { writable : true } , time Zone Name : { writable : true } , tz : { value : tz , writable : true } , weekday : { writable : true } , year : { writable : true } } ) ; var formatter = % Create Date Time Format ( requested Locale , { skeleton : ldml String , time Zone : tz } , resolved ) ; if ( resolved . time Zone = = = "Etc /Unknown " ) { throw Make Range Error ( k Unsupported Time Zone , tz ) ; } % Mark As Initialized Intl Object Of Type ( date Format , 'dateformat ' , formatter ) ; date Format [ resolved Symbol ] = resolved ; if ( FLAG _intl _extra ) { % object _define _property ( resolved , 'pattern ' , pattern Accessor ) ; % object _define _property ( date Format , 'resolved ' , resolved Accessor ) ; } return date Format ; } 
function format Date ( formatter , date Value ) { var date Ms ; if ( IS _UNDEFINED ( date Value ) ) { date Ms = % Date Current Time ( ) ; } else { date Ms = TO _NUMBER ( date Value ) ; } if ( ! NUMBER _IS _FINITE ( date Ms ) ) throw Make Range Error ( k Date Range ) ; return % Internal Date Format ( % Get Impl From Initialized Intl Object ( formatter ) , new Global Date ( date Ms ) ) ; } 
function canonicalize Time Zone ID ( tz ID ) { 
function initialize Break Iterator ( iterator , locales , options ) { if ( % Is Initialized Intl Object ( iterator ) ) { throw Make Type Error ( k Reinitialize Intl , "v 8Break Iterator " ) ; } if ( IS _UNDEFINED ( options ) ) { options = { } ; } var get Option = get Get Option ( options , 'breakiterator ' ) ; var internal Options = { } ; define WEProperty ( internal Options , 'type ' , get Option ( 'type ' , 'string ' , [ 'character ' , 'word ' , 'sentence ' , 'line ' ] , 'word ' ) ) ; var locale = resolve Locale ( 'breakiterator ' , locales , options ) ; var resolved = % object _define _properties ( { } , { requested Locale : { value : locale . locale , writable : true } , type : { value : internal Options . type , writable : true } , locale : { writable : true } } ) ; var internal Iterator = % Create Break Iterator ( locale . locale , internal Options , resolved ) ; % Mark As Initialized Intl Object Of Type ( iterator , 'breakiterator ' , internal Iterator ) ; iterator [ resolved Symbol ] = resolved ; if ( FLAG _intl _extra ) { % object _define _property ( iterator , 'resolved ' , resolved Accessor ) ; } return iterator ; } 
function cached Or New Service ( service , locales , options , defaults ) { var use Options = ( IS _UNDEFINED ( defaults ) ) ? options : defaults ; if ( IS _UNDEFINED ( locales ) & & IS _UNDEFINED ( options ) ) { check Date Cache Current ( ) ; if ( IS _UNDEFINED ( default Objects [ service ] ) ) { default Objects [ service ] = new saved Objects [ service ] ( locales , use Options ) ; } return default Objects [ service ] ; } return new saved Objects [ service ] ( locales , use Options ) ; } 
function to Locale Date Time ( date , locales , options , required , defaults , service ) { if ( ! ( date instanceof Global Date ) ) { throw Make Type Error ( k Method Invoked On Wrong Type , "Date " ) ; } if ( Is Na N ( date ) ) return 'Invalid Date ' ; var internal Options = to Date Time Options ( options , required , defaults ) ; var date Format = cached Or New Service ( service , locales , options , internal Options ) ; return format Date ( date Format , date ) ; } 
function ( options ) { this . options = Object . extend ( { canvas Height : 1 0 0 , canvas Width : 1 0 0 , pixel Width : 2 , pixel Height : 2 , render Diffuse : false , render Shadows : false , render Highlights : false , render Reflections : false , ray Depth : 2 } , options | | { } ) ; this . options . canvas Height / = this . options . pixel Height ; this . options . canvas Width / = this . options . pixel Width ; } 
function to Absolute Path ( path ) { if ( typeof path ! = = 'string ' ) { return null ; } const parts = path . split ( ' / ' ) ; const n = normalize Path ( parts ) ; if ( ! n ) { return null ; } return ` $ { n . join ( ' / ' ) } ` ; } 
function locate Acpi Device ( dev ) { if ( ! dev . is Device ( ) ) { return null ; } const addr = dev . address ( ) ; const slot Id = ( ( addr > > > 1 6 ) & 0xffff ) > > > 0 ; const func Id = ( addr & 0xffff ) > > > 0 ; let bus Id = 0 ; if ( dev . is Root Bridge ( ) ) { bus Id = dev . get Root Bridge Bus Number ( ) ; return { bus : bus Id , slot : slot Id , func : func Id , } ; } const parent Dev = dev . parent ( ) ; if ( parent Dev = = = null ) { return null ; } if ( ! parent Dev . is Device ( ) ) { return null ; } if ( parent Dev . is Root Bridge ( ) ) { bus Id = parent Dev . get Root Bridge Bus Number ( ) ; return { bus : bus Id , slot : slot Id , func : func Id , } ; } const parent Location = locate Acpi Device ( parent Dev ) ; if ( parent Location = = = null ) { return null ; } const pci Parent = pci Accessor Factory . get ( { bus : parent Location . bus , slot : parent Location . slot , func : parent Location . func , } ) ; const header = pci Parent . read ( pci Parent . fields ( ) . HEADER _TYPE ) ; 
function to Int Array ( str ) { var w 1 , w 2 , u , r 4 = [ ] , r = [ ] , i = 0 ; var s = str + ' \ 0 \ 0 \ 0 ' ; 
function add ( x , y ) { var lsb = ( x & 0xffff ) + ( y & 0xffff ) ; var msb = ( x > > > 1 6 ) + ( y > > > 1 6 ) + ( lsb > > > 1 6 ) ; return ( msb < < 1 6 ) | ( lsb & 0xffff ) ; } 
function seed _mix ( ) { a ^ = b < < 1 1 ; d = add ( d , a ) ; b = add ( b , c ) ; b ^ = c > > > 2 ; e = add ( e , b ) ; c = add ( c , d ) ; c ^ = d < < 8 ; f = add ( f , c ) ; d = add ( d , e ) ; d ^ = e > > > 1 6 ; g = add ( g , d ) ; e = add ( e , f ) ; e ^ = f < < 1 0 ; h = add ( h , e ) ; f = add ( f , g ) ; f ^ = g > > > 4 ; a = add ( a , f ) ; g = add ( g , h ) ; g ^ = h < < 8 ; b = add ( b , g ) ; h = add ( h , a ) ; h ^ = a > > > 9 ; c = add ( c , h ) ; a = add ( a , b ) ; } 
function Unary Constraint ( v , strength ) { Unary Constraint . super Constructor . call ( this , strength ) ; this . my Output = v ; this . satisfied = false ; this . add Constraint ( ) ; } 
function Binary Constraint ( var 1 , var 2 , strength ) { Binary Constraint . super Constructor . call ( this , strength ) ; this . v 1 = var 1 ; this . v 2 = var 2 ; this . direction = Direction . NONE ; this . add Constraint ( ) ; } 
function Scale Constraint ( src , scale , offset , dest , strength ) { this . direction = Direction . NONE ; this . scale = scale ; this . offset = offset ; Scale Constraint . super Constructor . call ( this , src , dest , strength ) ; } 
function Equality Constraint ( var 1 , var 2 , strength ) { Equality Constraint . super Constructor . call ( this , var 1 , var 2 , strength ) ; } 
function Variable ( name , initial Value ) { this . value = initial Value | | 0 ; this . constraints = new Ordered Collection ( ) ; this . determined By = null ; this . mark = 0 ; this . walk Strength = Strength . WEAKEST ; this . stay = true ; this . name = name ; } 
function Weak Map Constructor ( iterable ) { if ( IS _UNDEFINED ( new . target ) ) { throw Make Type Error ( k Constructor Not Function , "Weak Map " ) ; } % Weak Collection Initialize ( this ) ; if ( ! IS _NULL _OR _UNDEFINED ( iterable ) ) { var adder = this . set ; if ( ! IS _CALLABLE ( adder ) ) { throw Make Type Error ( k Property Not Function , adder , 'set ' , this ) ; } for ( var next Item of iterable ) { if ( ! IS _RECEIVER ( next Item ) ) { throw Make Type Error ( k Iterator Value Not An Object , next Item ) ; } % _Call ( adder , this , next Item [ 0 ] , next Item [ 1 ] ) ; } } } 
function Weak Set Constructor ( iterable ) { if ( IS _UNDEFINED ( new . target ) ) { throw Make Type Error ( k Constructor Not Function , "Weak Set " ) ; } % Weak Collection Initialize ( this ) ; if ( ! IS _NULL _OR _UNDEFINED ( iterable ) ) { var adder = this . add ; if ( ! IS _CALLABLE ( adder ) ) { throw Make Type Error ( k Property Not Function , adder , 'add ' , this ) ; } for ( var value of iterable ) { % _Call ( adder , this , value ) ; } } } 
function sc _alert ( ) { var len = arguments . length ; var s = " " ; var i ; for ( i = 0 ; i < len ; i + + ) { s + = sc _to Display String ( arguments [ i ] ) ; } return alert ( s ) ; } 
function sc _error ( ) { var a = [ sc _jsstring 2symbol ( " *error * " ) ] ; for ( var i = 0 ; i < arguments . length ; i + + ) { a [ i + 1 ] = arguments [ i ] ; } throw a ; } 
function sc _with Handler Lambda ( handler , body ) { try { return body ( ) ; } catch ( e ) { if ( ! e . _internal Exception ) return handler ( e ) ; else throw e ; } } 
function sc _putprop Bang ( sym , key , val ) { var ht = sc _properties [ sym ] ; if ( ! ht ) { ht = new Object ( ) ; sc _properties [ sym ] = ht ; } ht [ key ] = val ; } 
function sc _getprop ( sym , key ) { var ht = sc _properties [ sym ] ; if ( ht ) { if ( key in ht ) return ht [ key ] ; else return false ; } else return false ; } 
function sc _equal ( x ) { for ( var i = 1 ; i < arguments . length ; i + + ) if ( x ! = = arguments [ i ] ) return false ; return true ; } 
function sc _less ( x ) { for ( var i = 1 ; i < arguments . length ; i + + ) { if ( x > = arguments [ i ] ) return false ; x = arguments [ i ] ; } return true ; } 
function sc _greater ( x , y ) { for ( var i = 1 ; i < arguments . length ; i + + ) { if ( x < = arguments [ i ] ) return false ; x = arguments [ i ] ; } return true ; } 
function sc _less Equal ( x , y ) { for ( var i = 1 ; i < arguments . length ; i + + ) { if ( x > arguments [ i ] ) return false ; x = arguments [ i ] ; } return true ; } 
function sc _greater Equal ( x , y ) { for ( var i = 1 ; i < arguments . length ; i + + ) { if ( x < arguments [ i ] ) return false ; x = arguments [ i ] ; } return true ; } 
function sc _plus ( ) { var sum = 0 ; for ( var i = 0 ; i < arguments . length ; i + + ) sum + = arguments [ i ] ; return sum ; } 
function sc _multi ( ) { var product = 1 ; for ( var i = 0 ; i < arguments . length ; i + + ) product * = arguments [ i ] ; return product ; } 
function sc _minus ( x ) { if ( arguments . length = = = 1 ) return - x ; else { var res = x ; for ( var i = 1 ; i < arguments . length ; i + + ) res - = arguments [ i ] ; return res ; } } 
function sc _div ( x ) { if ( arguments . length = = = 1 ) return 1 / x ; else { var res = x ; for ( var i = 1 ; i < arguments . length ; i + + ) res / = arguments [ i ] ; return res ; } } 
function sc _modulo ( x , y ) { var remainder = x % y ; 
function sc _gcd ( ) { var gcd = 0 ; for ( var i = 0 ; i < arguments . length ; i + + ) gcd = sc _euclid _gcd ( gcd , arguments [ i ] ) ; return gcd ; } 
function sc _lcm ( ) { var lcm = 1 ; for ( var i = 0 ; i < arguments . length ; i + + ) { var f = Math . round ( arguments [ i ] / sc _euclid _gcd ( arguments [ i ] , lcm ) ) ; lcm * = Math . abs ( f ) ; } return lcm ; } 
function sc _cons Star ( ) { var res = arguments [ arguments . length - 1 ] ; for ( var i = arguments . length - 2 ; i > = 0 ; i - - ) res = new sc _Pair ( arguments [ i ] , res ) ; return res ; } 
function sc _last Pair ( l ) { if ( ! sc _is Pair ( l ) ) sc _error ( "sc _last Pair : pair expected " ) ; var res = l ; var cdr = l . cdr ; while ( sc _is Pair ( cdr ) ) { res = cdr ; cdr = res . cdr ; } return res ; } 
function sc _is List ( o ) { var rabbit ; var turtle ; var rabbit = o ; var turtle = o ; while ( true ) { if ( rabbit = = = null | | ( rabbit instanceof sc _Pair & & rabbit . cdr = = = null ) ) return true ; 
function sc _list ( ) { var res = null ; var a = arguments ; for ( var i = a . length - 1 ; i > = 0 ; i - - ) res = new sc _Pair ( a [ i ] , res ) ; return res ; } 
function sc _iota ( num , init ) { var res = null ; if ( ! init ) init = 0 ; for ( var i = num - 1 ; i > = 0 ; i - - ) res = new sc _Pair ( i + init , res ) ; return res ; } 
function sc _make List ( nb Els , fill ) { var res = null ; for ( var i = 0 ; i < nb Els ; i + + ) res = new sc _Pair ( fill , res ) ; return res ; } 
function sc _length ( l ) { var res = 0 ; while ( l ! = = null ) { res + + ; l = l . cdr ; } return res ; } 
function sc _remq ( o , l ) { var dummy = { cdr : null } ; var tail = dummy ; while ( l ! = = null ) { if ( l . car ! = = o ) { tail . cdr = sc _cons ( l . car , null ) ; tail = tail . cdr ; } l = l . cdr ; } return dummy . cdr ; } 
function sc _remq Bang ( o , l ) { var dummy = { cdr : null } ; var tail = dummy ; var needs Assig = true ; while ( l ! = = null ) { if ( l . car = = = o ) { needs Assig = true ; } else { if ( needs Assig ) { tail . cdr = l ; needs Assig = false ; } tail = l ; } l = l . cdr ; } tail . cdr = null ; return dummy . cdr ; } 
function sc _delete ( o , l ) { var dummy = { cdr : null } ; var tail = dummy ; while ( l ! = = null ) { if ( ! sc _is Equal ( l . car , o ) ) { tail . cdr = sc _cons ( l . car , null ) ; tail = tail . cdr ; } l = l . cdr ; } return dummy . cdr ; } 
function sc _delete Bang ( o , l ) { var dummy = { cdr : null } ; var tail = dummy ; var needs Assig = true ; while ( l ! = = null ) { if ( sc _is Equal ( l . car , o ) ) { needs Assig = true ; } else { if ( needs Assig ) { tail . cdr = l ; needs Assig = false ; } tail = l ; } l = l . cdr ; } tail . cdr = null ; return dummy . cdr ; } 
function sc _append ( ) { if ( arguments . length = = = 0 ) return null ; var res = arguments [ arguments . length - 1 ] ; for ( var i = arguments . length - 2 ; i > = 0 ; i - - ) res = sc _dual Append ( arguments [ i ] , res ) ; return res ; } 
function sc _append Bang ( ) { var res = null ; for ( var i = 0 ; i < arguments . length ; i + + ) res = sc _dual Append Bang ( res , arguments [ i ] ) ; return res ; } 
function sc _reverse ( l 1 ) { var res = null ; while ( l 1 ! = = null ) { res = sc _cons ( l 1 . car , res ) ; l 1 = l 1 . cdr ; } return res ; } 
function sc _list Tail ( l , k ) { var res = l ; for ( var i = 0 ; i < k ; i + + ) { res = res . cdr ; } return res ; } 
function sc _memq ( o , l ) { while ( l ! = = null ) { if ( l . car = = = o ) return l ; l = l . cdr ; } return false ; } 
function sc _memv ( o , l ) { while ( l ! = = null ) { if ( l . car = = = o ) return l ; l = l . cdr ; } return false ; } 
function sc _member ( o , l ) { while ( l ! = = null ) { if ( sc _is Equal ( l . car , o ) ) return l ; l = l . cdr ; } return false ; } 
function sc _assq ( o , al ) { while ( al ! = = null ) { if ( al . car . car = = = o ) return al . car ; al = al . cdr ; } return false ; } 
function sc _assv ( o , al ) { while ( al ! = = null ) { if ( al . car . car = = = o ) return al . car ; al = al . cdr ; } return false ; } 
function sc _assoc ( o , al ) { while ( al ! = = null ) { if ( sc _is Equal ( al . car . car , o ) ) return al . car ; al = al . cdr ; } return false ; } 
function sc _is Char Alphabetic ( c ) { return sc _is Char Of Class ( c . val , SC _LOWER _CLASS ) | | sc _is Char Of Class ( c . val , SC _UPPER _CLASS ) ; } 
function sc _is Char Whitespace ( c ) { var tmp = c . val ; return tmp = = = " " | | tmp = = = " \r " | | tmp = = = " \n " | | tmp = = = " \t " | | tmp = = = " \f " ; } 
function sc _is Vector Equal ( v 1 , v 2 , comp ) { if ( v 1 . length ! = = v 2 . length ) return false ; for ( var i = 0 ; i < v 1 . length ; i + + ) if ( ! comp ( v 1 [ i ] , v 2 [ i ] ) ) return false ; return true ; } 
function sc _make Vector ( size , fill ) { var a = new sc _Vector ( size ) ; if ( fill ! = = undefined ) sc _vector Fill Bang ( a , fill ) ; return a ; } 
function sc _vector ( ) { var a = new sc _Vector ( ) ; for ( var i = 0 ; i < arguments . length ; i + + ) a . push ( arguments [ i ] ) ; return a ; } 
function sc _vector 2list ( a ) { var res = null ; for ( var i = a . length - 1 ; i > = 0 ; i - - ) res = sc _cons ( a [ i ] , res ) ; return res ; } 
function sc _list 2vector ( l ) { var a = new sc _Vector ( ) ; while ( l ! = = null ) { a . push ( l . car ) ; l = l . cdr ; } return a ; } 
function sc _vector Fill Bang ( a , fill ) { for ( var i = 0 ; i < a . length ; i + + ) a [ i ] = fill ; } 
function sc _copy Vector ( a , len ) { if ( len < = a . length ) return a . slice ( 0 , len ) ; else { var tmp = a . concat ( ) ; tmp . length = len ; return tmp ; } } 
function sc _vector Copy Bang ( target , tstart , source , sstart , send ) { if ( ! sstart ) sstart = 0 ; if ( ! send ) send = source . length ; 
function sc _apply ( proc ) { var args = new Array ( ) ; 
function sc _map ( proc , l 1 ) { if ( l 1 = = = undefined ) return null ; 
function sc _map Bang ( proc , l 1 ) { if ( l 1 = = = undefined ) return null ; 
function sc _for Each ( proc , l 1 ) { if ( l 1 = = = undefined ) return undefined ; 
function sc _filter ( proc , l 1 ) { var dummy = { cdr : null } ; var tail = dummy ; while ( l 1 ! = = null ) { if ( proc ( l 1 . car ) ! = = false ) { tail . cdr = sc _cons ( l 1 . car , null ) ; tail = tail . cdr ; } l 1 = l 1 . cdr ; } return dummy . cdr ; } 
function sc _filter Bang ( proc , l 1 ) { var head = sc _cons ( "dummy " , l 1 ) ; var it = head ; var next = l 1 ; while ( next ! = = null ) { if ( proc ( next . car ) ! = = false ) { it . cdr = next it = next ; } next = next . cdr ; } it . cdr = null ; return head . cdr ; } 
function sc _filter Map ( proc , l 1 , l 2 , l 3 ) { if ( l 2 = = = undefined ) return sc _filter Map 1 ( proc , l 1 ) ; else if ( l 3 = = = undefined ) return sc _filter Map 2 ( proc , l 1 , l 2 ) ; 
function sc _any ( proc , l ) { var revres = null ; while ( l ! = = null ) { var tmp = proc ( l . car ) ; if ( tmp ! = = false ) return tmp ; l = l . cdr ; } return false ; } 
function sc _every ( proc , l ) { var revres = null ; var tmp = true ; while ( l ! = = null ) { tmp = proc ( l . car ) ; if ( tmp = = = false ) return false ; l = l . cdr ; } return tmp ; } 
function sc _every Pred ( proc , l ) { var tmp = sc _every ( proc , l ) ; if ( tmp ! = = false ) return true ; return false ; } 
function sc _make Promise ( proc ) { var is Result Ready = false ; var result = undefined ; return function ( ) { if ( ! is Result Ready ) { var tmp = proc ( ) ; if ( ! is Result Ready ) { is Result Ready = true ; result = tmp ; } } return result ; } ; } 
function sc _call With Values ( producer , consumer ) { var produced = producer ( ) ; if ( produced instanceof sc _Values ) return consumer . apply ( null , produced . values ) ; else return consumer ( produced ) ; } 
function sc _js Call ( o , fun ) { var args = new Array ( ) ; for ( var i = 2 ; i < arguments . length ; i + + ) args [ i - 2 ] = arguments [ i ] ; return fun . apply ( o , args ) ; } 
function sc _js Method Call ( o , field ) { var args = new Array ( ) ; for ( var i = 2 ; i < arguments . length ; i + + ) args [ i - 2 ] = arguments [ i ] ; return o [ field ] . apply ( o , args ) ; } 
function sc _js New ( c ) { var eval Str = "new c ( " ; eval Str + = arguments . length > 1 ? "arguments [ 1 ] " : " " ; for ( var i = 2 ; i < arguments . length ; i + + ) eval Str + = " , arguments [ " + i + " ] " ; eval Str + = " ) " ; return eval ( eval Str ) ; } 
function sc _pregexp Match ( re , s ) { var reg = ( re instanceof Reg Exp ) ? re : sc _pregexp ( re ) ; var tmp = reg . exec ( sc _string 2jsstring ( s ) ) ; if ( tmp = = null ) return false ; var res = null ; for ( var i = tmp . length - 1 ; i > = 0 ; i - - ) { if ( tmp [ i ] ! = = null ) { res = sc _cons ( sc _jsstring 2string ( tmp [ i ] ) , res ) ; } else { res = sc _cons ( false , res ) ; } } return res ; } 
function sc _pregexp Replace ( re , s 1 , s 2 ) { var reg ; var jss 1 = sc _string 2jsstring ( s 1 ) ; var jss 2 = sc _string 2jsstring ( s 2 ) ; if ( re instanceof Reg Exp ) { if ( re . global ) reg = re ; else reg = new Reg Exp ( re . source ) ; } else { reg = new Reg Exp ( sc _string 2jsstring ( re ) ) ; } return jss 1 . replace ( reg , jss 2 ) ; } 
function sc _pregexp Split ( re , s ) { var reg = ( ( re instanceof Reg Exp ) ? re : new Reg Exp ( sc _string 2jsstring ( re ) ) ) ; var jss = sc _string 2jsstring ( s ) ; var tmp = jss . split ( reg ) ; if ( tmp = = null ) return false ; return sc _vector 2list ( tmp ) ; } 
function sc _hashtable Put Bang ( ht , key , val ) { var hash = sc _hash ( key ) ; ht [ hash ] = new sc _Hashtable Element ( key , val ) ; } 
function sc _hashtable Get ( ht , key ) { var hash = sc _hash ( key ) ; if ( hash in ht ) return ht [ hash ] . val ; else return false ; } 
function sc _hashtable For Each ( ht , f ) { for ( var v in ht ) { if ( ht [ v ] instanceof sc _Hashtable Element ) f ( ht [ v ] . key , ht [ v ] . val ) ; } } 
function sc _hashtable Contains ( ht , key ) { var hash = sc _hash ( key ) ; if ( hash in ht ) return true ; else return false ; } 
function sc _bind Exit Lambda ( proc ) { var escape _obj = new sc _Bind Exit Exception ( ) ; var escape = function ( res ) { escape _obj . res = res ; throw escape _obj ; } ; try { return proc ( escape ) ; } catch ( e ) { if ( e = = = escape _obj ) { return e . res ; } throw e ; } } 
function sc _Token ( type , val , pos ) { this . type = type ; this . val = val ; this . pos = pos ; } 
function sc _read ( port ) { if ( port = = = undefined ) 
function sc _read Char ( port ) { if ( port = = = undefined ) 
function sc _peek Char ( port ) { if ( port = = = undefined ) 
function sc _basename ( p ) { var i = p . last Index Of ( ' / ' ) ; if ( i > = 0 ) return p . substring ( i + 1 , p . length ) ; else return ' ' ; } 
function sc _with Input From Port ( p , thunk ) { try { var tmp = SC _DEFAULT _IN ; 
function sc _with Output To Port ( p , thunk ) { try { var tmp = SC _DEFAULT _OUT ; 
function sc _with Output To Procedure ( proc , thunk ) { var t = function ( s ) { proc ( sc _jsstring 2string ( s ) ) ; } ; return sc _with Output To Port ( new sc _Generic Output Port ( t ) , thunk ) ; } 
function sc _write ( o , p ) { if ( p = = = undefined ) 
function sc _display ( o , p ) { if ( p = = = undefined ) 
function sc _write Char ( c , p ) { if ( p = = = undefined ) 
function sc _write Circle ( o , p ) { if ( p = = = undefined ) 
function sc _print ( s ) { if ( arguments . length = = = 1 ) { sc _display ( s ) ; sc _newline ( ) ; } else { for ( var i = 0 ; i < arguments . length ; i + + ) sc _display ( arguments [ i ] ) ; sc _newline ( ) ; } } 
function sc _format ( s , args ) { var len = s . length ; var p = new sc _String Output Port ( ) ; var i = 0 , j = 1 ; while ( i < len ) { var i 2 = s . index Of ( " ~ " , i ) ; if ( i 2 = = - 1 ) { p . append JSString ( s . substring ( i , len ) ) ; return p . close ( ) ; } else { if ( i 2 > i ) { if ( i 2 = = ( len - 1 ) ) { p . append JSString ( s . substring ( i , len ) ) ; return p . close ( ) ; } else { p . append JSString ( s . substring ( i , i 2 ) ) ; i = i 2 ; } } switch ( s . char Code At ( i 2 + 1 ) ) { case 6 5 : case 9 7 : 
function sc _is Equal ( o 1 , o 2 ) { return ( ( o 1 = = = o 2 ) | | ( sc _is Pair ( o 1 ) & & sc _is Pair ( o 2 ) & & sc _is Pair Equal ( o 1 , o 2 , sc _is Equal ) ) | | ( sc _is Vector ( o 1 ) & & sc _is Vector ( o 2 ) & & sc _is Vector Equal ( o 1 , o 2 , sc _is Equal ) ) ) ; } 
function sc _symbol Append ( ) { var res = sc _SYMBOL _PREFIX ; for ( var i = 0 ; i < arguments . length ; i + + ) res + = arguments [ i ] . slice ( 1 ) ; return res ; } 
function sc _string ( ) { for ( var i = 0 ; i < arguments . length ; i + + ) arguments [ i ] = arguments [ i ] . val ; return " " . concat . apply ( " " , arguments ) ; } 
function sc _is Substring _at ( s 1 , s 2 , i ) { return s 2 = = s 1 . substring ( i , i + s 2 . length ) ; } 
function Array Species Create ( array , length ) { length = INVERT _NEG _ZERO ( length ) ; var constructor = % Array Species Constructor ( array ) ; return new constructor ( length ) ; } 
function Sparse Join ( array , keys , convert ) { var keys _length = keys . length ; var elements = new Internal Array ( keys _length ) ; for ( var i = 0 ; i < keys _length ; i + + ) { var e = array [ keys [ i ] ] ; elements [ i ] = IS _STRING ( e ) ? e : convert ( e ) ; } return % String Builder Concat ( elements , keys _length , ' ' ) ; } 
function Sparse Slice ( array , start _i , del _count , len , deleted _elements ) { 
function Sparse Move ( array , start _i , del _count , len , num _additional _args ) { 
function Simple Slice ( array , start _i , del _count , len , deleted _elements ) { for ( var i = 0 ; i < del _count ; i + + ) { var index = start _i + i ; if ( index in array ) { var current = array [ index ] ; % Create Data Property ( deleted _elements , i , current ) ; } } } 
function Array To String ( ) { var array ; var func ; if ( IS _ARRAY ( this ) ) { func = this . join ; if ( func = = = Array Join ) { return Join ( this , this . length , ' , ' , Convert To String ) ; } array = this ; } else { array = TO _OBJECT ( this ) ; func = array . join ; } if ( ! IS _CALLABLE ( func ) ) { return % _Call ( Object To String , array ) ; } return % _Call ( func , array ) ; } 
function Array Pop ( ) { CHECK _OBJECT _COERCIBLE ( this , "Array .prototype .pop " ) ; var array = TO _OBJECT ( this ) ; var n = TO _LENGTH ( array . length ) ; if ( n = = 0 ) { array . length = n ; return ; } n - - ; var value = array [ n ] ; % Delete Property _Strict ( array , n ) ; array . length = n ; return value ; } 
function Array Push ( ) { CHECK _OBJECT _COERCIBLE ( this , "Array .prototype .push " ) ; var array = TO _OBJECT ( this ) ; var n = TO _LENGTH ( array . length ) ; var m = arguments . length ; 
function Sparse Reverse ( array , len ) { var keys = Get Sorted Array Keys ( array , % Get Array Keys ( array , len ) ) ; var high _counter = keys . length - 1 ; var low _counter = 0 ; while ( low _counter < = high _counter ) { var i = keys [ low _counter ] ; var j = keys [ high _counter ] ; var j _complement = len - j - 1 ; var low , high ; if ( j _complement < = i ) { high = j ; while ( keys [ - - high _counter ] = = j ) { } low = j _complement ; } if ( j _complement > = i ) { low = i ; while ( keys [ + + low _counter ] = = i ) { } high = len - i - 1 ; } var current _i = array [ low ] ; if ( ! IS _UNDEFINED ( current _i ) | | low in array ) { var current _j = array [ high ] ; if ( ! IS _UNDEFINED ( current _j ) | | high in array ) { array [ low ] = current _j ; array [ high ] = current _i ; } else { array [ high ] = current _i ; delete array [ low ] ; } } else { var current _j = array [ high ] ; if ( ! IS _UNDEFINED ( current _j ) | | high in array ) { array [ low ] = current _j ; delete array [ high ] ; } } } } 
function Copy From Prototype ( obj , length ) { var max = 0 ; for ( var proto = % object _get _prototype _of ( obj ) ; proto ; proto = % object _get _prototype _of ( proto ) ) { var indices = IS _PROXY ( proto ) ? length : % Get Array Keys ( proto , length ) ; if ( IS _NUMBER ( indices ) ) { 
function ( obj , from , to ) { for ( var proto = % object _get _prototype _of ( obj ) ; proto ; proto = % object _get _prototype _of ( proto ) ) { var indices = IS _PROXY ( proto ) ? to : % Get Array Keys ( proto , to ) ; if ( IS _NUMBER ( indices ) ) { 
function Inner Array Filter ( f , receiver , array , length , result ) { var result _length = 0 ; for ( var i = 0 ; i < length ; i + + ) { if ( i in array ) { var element = array [ i ] ; if ( % _Call ( f , receiver , element , i , array ) ) { % Create Data Property ( result , result _length , element ) ; result _length + + ; } } } return result ; } 
function Array Some ( f , receiver ) { CHECK _OBJECT _COERCIBLE ( this , "Array .prototype .some " ) ; 
function Inner Array Index Of ( array , element , index , length ) { if ( length = = 0 ) return - 1 ; if ( IS _UNDEFINED ( index ) ) { index = 0 ; } else { index = INVERT _NEG _ZERO ( TO _INTEGER ( index ) ) ; 
function Array Copy Within ( target , start , end ) { CHECK _OBJECT _COERCIBLE ( this , "Array .prototype .copy Within " ) ; var array = TO _OBJECT ( this ) ; var length = TO _LENGTH ( array . length ) ; return Inner Array Copy Within ( target , start , end , array , length ) ; } 
function Array Find ( predicate , this Arg ) { CHECK _OBJECT _COERCIBLE ( this , "Array .prototype .find " ) ; var array = TO _OBJECT ( this ) ; var length = TO _INTEGER ( array . length ) ; return Inner Array Find ( predicate , this Arg , array , length ) ; } 
function Array Find Index ( predicate , this Arg ) { CHECK _OBJECT _COERCIBLE ( this , "Array .prototype .find Index " ) ; var array = TO _OBJECT ( this ) ; var length = TO _INTEGER ( array . length ) ; return Inner Array Find Index ( predicate , this Arg , array , length ) ; } 
function Inner Array Fill ( value , start , end , array , length ) { var i = IS _UNDEFINED ( start ) ? 0 : TO _INTEGER ( start ) ; var end = IS _UNDEFINED ( end ) ? length : TO _INTEGER ( end ) ; if ( i < 0 ) { i + = length ; if ( i < 0 ) i = 0 ; } else { if ( i > length ) i = length ; } if ( end < 0 ) { end + = length ; if ( end < 0 ) end = 0 ; } else { if ( end > length ) end = length ; } if ( ( end - i ) > 0 & & % object _is _frozen ( array ) ) { throw Make Type Error ( k Array Functions On Frozen ) ; } for ( ; i < end ; i + + ) array [ i ] = value ; return array ; } 
function Array Fill ( value , start , end ) { CHECK _OBJECT _COERCIBLE ( this , "Array .prototype .fill " ) ; var array = TO _OBJECT ( this ) ; var length = TO _LENGTH ( array . length ) ; return Inner Array Fill ( value , start , end , array , length ) ; } 
function Array Includes ( search Element , from Index ) { CHECK _OBJECT _COERCIBLE ( this , "Array .prototype .includes " ) ; var array = TO _OBJECT ( this ) ; var length = TO _LENGTH ( array . length ) ; return Inner Array Includes ( search Element , from Index , array , length ) ; } 
function Array From ( array Like , mapfn , receiver ) { var items = TO _OBJECT ( array Like ) ; var mapping = ! IS _UNDEFINED ( mapfn ) ; if ( mapping ) { if ( ! IS _CALLABLE ( mapfn ) ) { throw Make Type Error ( k Called Non Callable , mapfn ) ; } } var iterable = Get Method ( items , iterator Symbol ) ; var k ; var result ; var mapped Value ; var next Value ; if ( ! IS _UNDEFINED ( iterable ) ) { result = % Is Constructor ( this ) ? new this ( ) : [ ] ; k = 0 ; for ( next Value of { [ iterator Symbol ] ( ) { return Get Iterator ( items , iterable ) } } ) { if ( mapping ) { mapped Value = % _Call ( mapfn , receiver , next Value , k ) ; } else { mapped Value = next Value ; } % Create Data Property ( result , k , mapped Value ) ; k + + ; } result . length = k ; return result ; } else { var len = TO _LENGTH ( items . length ) ; result = % Is Constructor ( this ) ? new this ( len ) : new Global Array ( len ) ; for ( k = 0 ; k < len ; + + k ) { next Value = items [ k ] ; if ( mapping ) { mapped Value = % _Call ( mapfn , receiver , next Value , k ) ; } else { mapped Value = next Value ; } % Create Data Property ( result , k , mapped Value ) ; } result . length = k ; return result ; } } 
function Array Of ( . . . args ) { var length = args . length ; var constructor = this ; 
function Global Parse Int ( string , radix ) { if ( IS _UNDEFINED ( radix ) | | radix = = = 1 0 | | radix = = = 0 ) { 
function Global Parse Float ( string ) { 
function Object Is Prototype Of ( V ) { if ( ! IS _RECEIVER ( V ) ) return false ; var O = TO _OBJECT ( this ) ; return % Has In Prototype Chain ( V , O ) ; } 
function Get Method ( obj , p ) { var func = obj [ p ] ; if ( IS _NULL _OR _UNDEFINED ( func ) ) return UNDEFINED ; if ( IS _CALLABLE ( func ) ) return func ; throw Make Type Error ( k Called Non Callable , typeof func ) ; } 
function Object Set Prototype Of ( obj , proto ) { CHECK _OBJECT _COERCIBLE ( obj , "Object .set Prototype Of " ) ; if ( proto ! = = null & & ! IS _RECEIVER ( proto ) ) { throw Make Type Error ( k Proto Object Or Null , proto ) ; } if ( IS _RECEIVER ( obj ) ) { % Set Prototype ( obj , proto ) ; } return obj ; } 
function Object Set Proto ( proto ) { CHECK _OBJECT _COERCIBLE ( this , "Object .prototype . _ _proto _ _ " ) ; if ( ( IS _RECEIVER ( proto ) | | IS _NULL ( proto ) ) & & IS _RECEIVER ( this ) ) { % Set Prototype ( this , proto ) ; } } 
function Number To String JS ( radix ) { 
function Number To Fixed JS ( fraction Digits ) { var x = this ; if ( ! IS _NUMBER ( this ) ) { if ( ! IS _NUMBER _WRAPPER ( this ) ) { throw Make Type Error ( k Incompatible Method Receiver , "Number .prototype .to Fixed " , this ) ; } 
function Number To Exponential JS ( fraction Digits ) { var x = this ; if ( ! IS _NUMBER ( this ) ) { if ( ! IS _NUMBER _WRAPPER ( this ) ) { throw Make Type Error ( k Incompatible Method Receiver , "Number .prototype .to Exponential " , this ) ; } 
function Number To Precision JS ( precision ) { var x = this ; if ( ! IS _NUMBER ( this ) ) { if ( ! IS _NUMBER _WRAPPER ( this ) ) { throw Make Type Error ( k Incompatible Method Receiver , "Number .prototype .to Precision " , this ) ; } 
function Get Iterator ( obj , method ) { if ( IS _UNDEFINED ( method ) ) { method = obj [ iterator Symbol ] ; } if ( ! IS _CALLABLE ( method ) ) { throw Make Type Error ( k Not Iterable , obj ) ; } var iterator = % _Call ( method , obj ) ; if ( ! IS _RECEIVER ( iterator ) ) { throw Make Type Error ( k Not An Iterator , iterator ) ; } return iterator ; } 
function Create String Iterator ( string ) { CHECK _OBJECT _COERCIBLE ( string , 'String .prototype [Symbol .iterator ] ' ) ; var s = TO _STRING ( string ) ; var iterator = new String Iterator ; SET _PRIVATE ( iterator , string Iterator Iterated String Symbol , s ) ; SET _PRIVATE ( iterator , string Iterator Next Index Symbol , 0 ) ; return iterator ; } 
function String Iterator Next ( ) { var iterator = this ; var value = UNDEFINED ; var done = true ; if ( ! IS _RECEIVER ( iterator ) | | ! HAS _DEFINED _PRIVATE ( iterator , string Iterator Next Index Symbol ) ) { throw Make Type Error ( k Incompatible Method Receiver , 'String Iterator .prototype .next ' ) ; } var s = GET _PRIVATE ( iterator , string Iterator Iterated String Symbol ) ; if ( ! IS _UNDEFINED ( s ) ) { var position = GET _PRIVATE ( iterator , string Iterator Next Index Symbol ) ; var length = TO _UINT 3 2 ( s . length ) ; if ( position > = length ) { SET _PRIVATE ( iterator , string Iterator Iterated String Symbol , UNDEFINED ) ; } else { var first = % _String Char Code At ( s , position ) ; value = % _String Char From Code ( first ) ; done = false ; position + + ; if ( first > = 0x D 8 0 0 & & first < = 0x DBFF & & position < length ) { var second = % _String Char Code At ( s , position ) ; if ( second > = 0x DC 0 0 & & second < = 0x DFFF ) { value + = % _String Char From Code ( second ) ; position + + ; } } SET _PRIVATE ( iterator , string Iterator Next Index Symbol , position ) ; } } return % _Create Iter Result Object ( value , done ) ; } 
function Fluid Field ( canvas ) { function add Fields ( x , s , dt ) { for ( var i = 0 ; i < size ; i + + ) x [ i ] + = dt * s [ i ] ; } function set _bnd ( b , x ) { if ( b = = = 1 ) { for ( var i = 1 ; i < = width ; i + + ) { x [ i ] = x [ i + row Size ] ; x [ i + ( height + 1 ) * row Size ] = x [ i + height * row Size ] ; } for ( var j = 1 ; i < = height ; i + + ) { x [ j * row Size ] = - x [ 1 + j * row Size ] ; x [ ( width + 1 ) + j * row Size ] = - x [ width + j * row Size ] ; } } else if ( b = = = 2 ) { for ( var i = 1 ; i < = width ; i + + ) { x [ i ] = - x [ i + row Size ] ; x [ i + ( height + 1 ) * row Size ] = - x [ i + height * row Size ] ; } for ( var j = 1 ; j < = height ; j + + ) { x [ j * row Size ] = x [ 1 + j * row Size ] ; x [ ( width + 1 ) + j * row Size ] = x [ width + j * row Size ] ; } } else { for ( var i = 1 ; i < = width ; i + + ) { x [ i ] = x [ i + row Size ] ; x [ i + ( height + 1 ) * row Size ] = x [ i + height * row Size ] ; } for ( var j = 1 ; j < = height ; j + + ) { x [ j * row Size ] = x [ 1 + j * row Size ] ; x [ ( width + 1 ) + j * row Size ] = x [ width + j * row Size ] ; } } var max Edge = ( height + 1 ) * row Size ; x [ 0 ] = 0 . 5 * ( x [ 1 ] + x [ row Size ] ) ; x [ max Edge ] = 0 . 5 * ( x [ 1 + max Edge ] + x [ height * row Size ] ) ; x [ ( width + 1 ) ] = 0 . 5 * ( x [ width ] + x [ ( width + 1 ) + row Size ] ) ; x [ ( width + 1 ) + max Edge ] = 0 . 5 * ( x [ width + max Edge ] + x [ ( width + 1 ) + height * row Size ] ) ; } function lin _solve ( b , x , x 0 , a , c ) { if ( a = = = 0 & & c = = = 1 ) { for ( var j = 1 ; j < = height ; j + + ) { var current Row = j * row Size ; + + current Row ; for ( var i = 0 ; i < width ; i + + ) { x [ current Row ] = x 0 [ current Row ] ; + + current Row ; } } set _bnd ( b , x ) ; } else { var inv C = 1 / c ; for ( var k = 0 ; k < iterations ; k + + ) { for ( var j = 1 ; j < = height ; j + + ) { var last Row = ( j - 1 ) * row Size ; var current Row = j * row Size ; var next Row = ( j + 1 ) * row Size ; var last X = x [ current Row ] ; + + current Row ; for ( var i = 1 ; i < = width ; i + + ) last X = x [ current Row ] = ( x 0 [ current Row ] + a * ( last X + x [ + + current Row ] + x [ + + last Row ] + x [ + + next Row ] ) ) * inv C ; } set _bnd ( b , x ) ; } } } function diffuse ( b , x , x 0 , dt ) { var a = 0 ; lin _solve ( b , x , x 0 , a , 1 + 4 * a ) ; } function lin _solve 2 ( x , x 0 , y , y 0 , a , c ) { if ( a = = = 0 & & c = = = 1 ) { for ( var j = 1 ; j < = height ; j + + ) { var current Row = j * row Size ; + + current Row ; for ( var i = 0 ; i < width ; i + + ) { x [ current Row ] = x 0 [ current Row ] ; y [ current Row ] = y 0 [ current Row ] ; + + current Row ; } } set _bnd ( 1 , x ) ; set _bnd ( 2 , y ) ; } else { var inv C = 1 / c ; for ( var k = 0 ; k < iterations ; k + + ) { for ( var j = 1 ; j < = height ; j + + ) { var last Row = ( j - 1 ) * row Size ; var current Row = j * row Size ; var next Row = ( j + 1 ) * row Size ; var last X = x [ current Row ] ; var last Y = y [ current Row ] ; + + current Row ; for ( var i = 1 ; i < = width ; i + + ) { last X = x [ current Row ] = ( x 0 [ current Row ] + a * ( last X + x [ current Row ] + x [ last Row ] + x [ next Row ] ) ) * inv C ; last Y = y [ current Row ] = ( y 0 [ current Row ] + a * ( last Y + y [ + + current Row ] + y [ + + last Row ] + y [ + + next Row ] ) ) * inv C ; } } set _bnd ( 1 , x ) ; set _bnd ( 2 , y ) ; } } } function diffuse 2 ( x , x 0 , y , y 0 , dt ) { var a = 0 ; lin _solve 2 ( x , x 0 , y , y 0 , a , 1 + 4 * a ) ; } function advect ( b , d , d 0 , u , v , dt ) { var Wdt 0 = dt * width ; var Hdt 0 = dt * height ; var Wp 5 = width + 0 . 5 ; var Hp 5 = height + 0 . 5 ; for ( var j = 1 ; j < = height ; j + + ) { var pos = j * row Size ; for ( var i = 1 ; i < = width ; i + + ) { var x = i - Wdt 0 * u [ + + pos ] ; var y = j - Hdt 0 * v [ pos ] ; if ( x < 0 . 5 ) x = 0 . 5 ; else if ( x > Wp 5 ) x = Wp 5 ; var i 0 = x | 0 ; var i 1 = i 0 + 1 ; if ( y < 0 . 5 ) y = 0 . 5 ; else if ( y > Hp 5 ) y = Hp 5 ; var j 0 = y | 0 ; var j 1 = j 0 + 1 ; var s 1 = x - i 0 ; var s 0 = 1 - s 1 ; var t 1 = y - j 0 ; var t 0 = 1 - t 1 ; var row 1 = j 0 * row Size ; var row 2 = j 1 * row Size ; d [ pos ] = s 0 * ( t 0 * d 0 [ i 0 + row 1 ] + t 1 * d 0 [ i 0 + row 2 ] ) + s 1 * ( t 0 * d 0 [ i 1 + row 1 ] + t 1 * d 0 [ i 1 + row 2 ] ) ; } } set _bnd ( b , d ) ; } function project ( u , v , p , div ) { var h = - 0 . 5 / Math . sqrt ( width * height ) ; for ( var j = 1 ; j < = height ; j + + ) { var row = j * row Size ; var previous Row = ( j - 1 ) * row Size ; var prev Value = row - 1 ; var current Row = row ; var next Value = row + 1 ; var next Row = ( j + 1 ) * row Size ; for ( var i = 1 ; i < = width ; i + + ) { div [ + + current Row ] = h * ( u [ + + next Value ] - u [ + + prev Value ] + v [ + + next Row ] - v [ + + previous Row ] ) ; p [ current Row ] = 0 ; } } set _bnd ( 0 , div ) ; set _bnd ( 0 , p ) ; lin _solve ( 0 , p , div , 1 , 4 ) ; var w Scale = 0 . 5 * width ; var h Scale = 0 . 5 * height ; for ( var j = 1 ; j < = height ; j + + ) { var prev Pos = j * row Size - 1 ; var current Pos = j * row Size ; var next Pos = j * row Size + 1 ; var prev Row = ( j - 1 ) * row Size ; var current Row = j * row Size ; var next Row = ( j + 1 ) * row Size ; for ( var i = 1 ; i < = width ; i + + ) { u [ + + current Pos ] - = w Scale * ( p [ + + next Pos ] - p [ + + prev Pos ] ) ; v [ current Pos ] - = h Scale * ( p [ + + next Row ] - p [ + + prev Row ] ) ; } } set _bnd ( 1 , u ) ; set _bnd ( 2 , v ) ; } function dens _step ( x , x 0 , u , v , dt ) { add Fields ( x , x 0 , dt ) ; diffuse ( 0 , x 0 , x , dt ) ; advect ( 0 , x , x 0 , u , v , dt ) ; } function vel _step ( u , v , u 0 , v 0 , dt ) { add Fields ( u , u 0 , dt ) ; add Fields ( v , v 0 , dt ) ; var temp = u 0 ; u 0 = u ; u = temp ; var temp = v 0 ; v 0 = v ; v = temp ; diffuse 2 ( u , u 0 , v , v 0 , dt ) ; project ( u , v , u 0 , v 0 ) ; var temp = u 0 ; u 0 = u ; u = temp ; var temp = v 0 ; v 0 = v ; v = temp ; advect ( 1 , u , u 0 , u 0 , v 0 , dt ) ; advect ( 2 , v , v 0 , u 0 , v 0 , dt ) ; project ( u , v , u 0 , v 0 ) ; } var ui Callback = function ( d , u , v ) { } ; function Field ( dens , u , v ) { 
function Log Reader ( dispatch Table , timed Range , pairwise Timed Range ) { this . dispatch Table _ = dispatch Table ; this . timed Range _ = timed Range ; this . pairwise Timed Range _ = pairwise Timed Range ; if ( pairwise Timed Range ) { this . timed Range _ = true ; } this . line Num _ = 0 ; this . csv Parser _ = new Csv Parser ( ) ; this . has Seen Timer Marker _ = false ; this . log Lines Since Last Timer Marker _ = [ ] ; } 
function Array Buffer Slice ( start , end ) { if ( ! IS _ARRAYBUFFER ( this ) ) { throw Make Type Error ( k Incompatible Method Receiver , 'Array Buffer .prototype .slice ' , this ) ; } var relative Start = TO _INTEGER ( start ) ; if ( ! IS _UNDEFINED ( end ) ) { end = TO _INTEGER ( end ) ; } var first ; var byte _length = % _Array Buffer Get Byte Length ( this ) ; if ( relative Start < 0 ) { first = Max Simple ( byte _length + relative Start , 0 ) ; } else { first = Min Simple ( relative Start , byte _length ) ; } var relative End = IS _UNDEFINED ( end ) ? byte _length : end ; var fin ; if ( relative End < 0 ) { fin = Max Simple ( byte _length + relative End , 0 ) ; } else { fin = Min Simple ( relative End , byte _length ) ; } if ( fin < first ) { fin = first ; } var new Len = fin - first ; var constructor = Species Constructor ( this , Global Array Buffer , true ) ; var result = new constructor ( new Len ) ; if ( ! IS _ARRAYBUFFER ( result ) ) { throw Make Type Error ( k Incompatible Method Receiver , 'Array Buffer .prototype .slice ' , result ) ; } 
function Make Mirror ( value , opt _transient ) { var mirror ; 
function Value Mirror ( type , value , transient ) { % _Call ( Mirror , this , type ) ; this . value _ = value ; if ( ! transient ) { this . allocate Handle _ ( ) ; } else { this . allocate Transient Handle _ ( ) ; } } 
function Object Mirror ( value , type , transient ) { type = type | | Mirror Type . OBJECT _TYPE ; % _Call ( Value Mirror , this , type , value , transient ) ; } 
function Unresolved Function Mirror ( value ) { 
function Property Mirror ( mirror , name , details ) { % _Call ( Mirror , this , Mirror Type . PROPERTY _TYPE ) ; this . mirror _ = mirror ; this . name _ = name ; this . value _ = details [ 0 ] ; this . details _ = details [ 1 ] ; this . is _interceptor _ = details [ 2 ] ; if ( details . length > 3 ) { this . exception _ = details [ 3 ] ; this . getter _ = details [ 4 ] ; this . setter _ = details [ 5 ] ; } } 
function Internal Property Mirror ( name , value ) { % _Call ( Mirror , this , Mirror Type . INTERNAL _PROPERTY _TYPE ) ; this . name _ = name ; this . value _ = value ; } 
function Frame Mirror ( break _id , index ) { % _Call ( Mirror , this , Mirror Type . FRAME _TYPE ) ; this . break _id _ = break _id ; this . index _ = index ; this . details _ = new Frame Details ( break _id , index ) ; } 
function Scope Mirror ( frame , fun , index , opt _details ) { % _Call ( Mirror , this , Mirror Type . SCOPE _TYPE ) ; if ( frame ) { this . frame _index _ = frame . index _ ; } else { this . frame _index _ = UNDEFINED ; } this . scope _index _ = index ; this . details _ = new Scope Details ( frame , fun , index , opt _details ) ; } 
function Script Mirror ( script ) { % _Call ( Mirror , this , Mirror Type . SCRIPT _TYPE ) ; this . script _ = script ; this . context _ = new Context Mirror ( script . context _data ) ; this . allocate Handle _ ( ) ; } 
function serialize Location Fields ( location , content ) { if ( ! location ) { return ; } content . position = location . position ; var line = location . line ; if ( ! IS _UNDEFINED ( line ) ) { content . line = line ; } var column = location . column ; if ( ! IS _UNDEFINED ( column ) ) { content . column = column ; } } 
function String Concat ( other ) { 
function String Match JS ( pattern ) { CHECK _OBJECT _COERCIBLE ( this , "String .prototype .match " ) ; if ( ! IS _NULL _OR _UNDEFINED ( pattern ) ) { var matcher = pattern [ match Symbol ] ; if ( ! IS _UNDEFINED ( matcher ) ) { return % _Call ( matcher , pattern , this ) ; } } var subject = TO _STRING ( this ) ; 
function String Replace ( search , replace ) { CHECK _OBJECT _COERCIBLE ( this , "String .prototype .replace " ) ; 
function Expand Replacement ( string , subject , match Info , result ) { var length = string . length ; var next = % String Index Of ( string , ' $ ' , 0 ) ; if ( next < 0 ) { if ( length > 0 ) result + = string ; return result ; } if ( next > 0 ) result + = % _Sub String ( string , 0 , next ) ; while ( true ) { var expansion = ' $ ' ; var position = next + 1 ; if ( position < length ) { var peek = % _String Char Code At ( string , position ) ; if ( peek = = 3 6 ) { 
function String Search ( pattern ) { CHECK _OBJECT _COERCIBLE ( this , "String .prototype .search " ) ; if ( ! IS _NULL _OR _UNDEFINED ( pattern ) ) { var searcher = pattern [ search Symbol ] ; if ( ! IS _UNDEFINED ( searcher ) ) { return % _Call ( searcher , pattern , this ) ; } } var subject = TO _STRING ( this ) ; 
function String Slice ( start , end ) { CHECK _OBJECT _COERCIBLE ( this , "String .prototype .slice " ) ; var s = TO _STRING ( this ) ; var s _len = s . length ; var start _i = TO _INTEGER ( start ) ; var end _i = s _len ; if ( ! IS _UNDEFINED ( end ) ) { end _i = TO _INTEGER ( end ) ; } if ( start _i < 0 ) { start _i + = s _len ; if ( start _i < 0 ) { start _i = 0 ; } } else { if ( start _i > s _len ) { return ' ' ; } } if ( end _i < 0 ) { end _i + = s _len ; if ( end _i < 0 ) { return ' ' ; } } else { if ( end _i > s _len ) { end _i = s _len ; } } if ( end _i < = start _i ) { return ' ' ; } return % _Sub String ( s , start _i , end _i ) ; } 
function String Split JS ( separator , limit ) { CHECK _OBJECT _COERCIBLE ( this , "String .prototype .split " ) ; if ( ! IS _NULL _OR _UNDEFINED ( separator ) ) { var splitter = separator [ split Symbol ] ; if ( ! IS _UNDEFINED ( splitter ) ) { return % _Call ( splitter , separator , this , limit ) ; } } var subject = TO _STRING ( this ) ; limit = ( IS _UNDEFINED ( limit ) ) ? k Max Uint 3 2 : TO _UINT 3 2 ( limit ) ; var length = subject . length ; var separator _string = TO _STRING ( separator ) ; if ( limit = = = 0 ) return [ ] ; 
function String Substr ( start , length ) { CHECK _OBJECT _COERCIBLE ( this , "String .prototype .substr " ) ; var s = TO _STRING ( this ) ; var size = s . length ; start = TO _INTEGER ( start ) ; length = IS _UNDEFINED ( length ) ? size : TO _INTEGER ( length ) ; if ( start < 0 ) start = Max Simple ( size + start , 0 ) ; length = Min Simple ( Max Simple ( length , 0 ) , size - start ) ; if ( length < = 0 ) return ' ' ; return % _Sub String ( s , start , start + length ) ; } 
function String Repeat ( count ) { CHECK _OBJECT _COERCIBLE ( this , "String .prototype .repeat " ) ; var s = TO _STRING ( this ) ; var n = TO _INTEGER ( count ) ; if ( n < 0 | | n = = = INFINITY ) throw Make Range Error ( k Invalid Count Value ) ; 
function String Code Point At ( pos ) { CHECK _OBJECT _COERCIBLE ( this , "String .prototype .code Point At " ) ; var string = TO _STRING ( this ) ; var size = string . length ; pos = TO _INTEGER ( pos ) ; if ( pos < 0 | | pos > = size ) { return UNDEFINED ; } var first = % _String Char Code At ( string , pos ) ; if ( first < 0x D 8 0 0 | | first > 0x DBFF | | pos + 1 = = size ) { return first ; } var second = % _String Char Code At ( string , pos + 1 ) ; if ( second < 0x DC 0 0 | | second > 0x DFFF ) { return first ; } return ( first - 0x D 8 0 0 ) * 0x 4 0 0 + second + 0x 2 4 0 0 ; } 
function String Raw ( call Site ) { "use strict " ; var number Of Substitutions = arguments . length ; var cooked = TO _OBJECT ( call Site ) ; var raw = TO _OBJECT ( cooked . raw ) ; var literal Segments = TO _LENGTH ( raw . length ) ; if ( literal Segments < = 0 ) return " " ; var result = TO _STRING ( raw [ 0 ] ) ; for ( var i = 1 ; i < literal Segments ; + + i ) { if ( i < number Of Substitutions ) { result + = TO _STRING ( arguments [ i ] ) ; } result + = TO _STRING ( raw [ i ] ) ; } return result ; } 
function Create Resolving Functions ( promise ) { var already Resolved = false ; 
function Promise ( executor ) { if ( executor = = = promise Raw Symbol ) { return % _New Object ( Global Promise , new . target ) ; } if ( IS _UNDEFINED ( new . target ) ) throw Make Type Error ( k Not APromise , this ) ; if ( ! IS _CALLABLE ( executor ) ) { throw Make Type Error ( k Resolver Not AFunction , executor ) ; } var promise = Promise Init ( % _New Object ( Global Promise , new . target ) ) ; var callbacks = Create Resolving Functions ( promise ) ; var debug _is _active = DEBUG _IS _ACTIVE ; try { if ( debug _is _active ) % Debug Push Promise ( promise , Promise ) ; executor ( callbacks . resolve , callbacks . reject ) ; } catch ( e ) { % _Call ( callbacks . reject , UNDEFINED , e ) ; } finally { if ( debug _is _active ) % Debug Pop Promise ( ) ; } return promise ; } 
function Promise Set ( promise , status , value ) { SET _PRIVATE ( promise , promise State Symbol , status ) ; SET _PRIVATE ( promise , promise Result Symbol , value ) ; 
function Resolve Promise ( promise , resolution ) { if ( resolution = = = promise ) { return Reject Promise ( promise , Make Type Error ( k Promise Cyclic , resolution ) ) ; } if ( IS _RECEIVER ( resolution ) ) { 
function Reject Promise ( promise , reason ) { 
function New Promise Capability ( C ) { if ( C = = = Global Promise ) { 
function Promise Reject ( r ) { if ( ! IS _RECEIVER ( this ) ) { throw Make Type Error ( k Called On Non Object , Promise Resolve ) ; } if ( this = = = Global Promise ) { 
function Promise Then ( on Resolve , on Reject ) { var status = GET _PRIVATE ( this , promise State Symbol ) ; if ( IS _UNDEFINED ( status ) ) { throw Make Type Error ( k Not APromise , this ) ; } var constructor = Species Constructor ( this , Global Promise ) ; on Resolve = IS _CALLABLE ( on Resolve ) ? on Resolve : Promise Id Resolve Handler ; on Reject = IS _CALLABLE ( on Reject ) ? on Reject : Promise Id Reject Handler ; var deferred = New Promise Capability ( constructor ) ; switch ( status ) { case k Pending : Promise Attach Callbacks ( this , deferred , on Resolve , on Reject ) ; break ; case k Fulfilled : Promise Enqueue ( GET _PRIVATE ( this , promise Result Symbol ) , on Resolve , deferred , k Fulfilled ) ; break ; case k Rejected : if ( ! HAS _DEFINED _PRIVATE ( this , promise Has Handler Symbol ) ) { 
function Promise Resolve ( x ) { if ( ! IS _RECEIVER ( this ) ) { throw Make Type Error ( k Called On Non Object , Promise Resolve ) ; } if ( Is Promise ( x ) & & x . constructor = = = this ) return x ; var promise Capability = New Promise Capability ( this ) ; var resolve Result = % _Call ( promise Capability . resolve , UNDEFINED , x ) ; return promise Capability . promise ; } 
function Promise All ( iterable ) { if ( ! IS _RECEIVER ( this ) ) { throw Make Type Error ( k Called On Non Object , "Promise .all " ) ; } var deferred = New Promise Capability ( this ) ; var resolutions = new Internal Array ( ) ; var count ; function Create Resolve Element Function ( index , values , promise Capability ) { var already Called = false ; return ( x ) = > { if ( already Called = = = true ) return ; already Called = true ; values [ index ] = x ; if ( - - count = = = 0 ) { var values Array = [ ] ; % Move Array Contents ( values , values Array ) ; % _Call ( promise Capability . resolve , UNDEFINED , values Array ) ; } } ; } try { var i = 0 ; count = 1 ; for ( var value of iterable ) { var next Promise = this . resolve ( value ) ; + + count ; next Promise . then ( Create Resolve Element Function ( i , resolutions , deferred ) , deferred . reject ) ; SET _PRIVATE ( deferred . reject , promise Combined Deferred Symbol , deferred ) ; + + i ; } 
function Promise Race ( iterable ) { if ( ! IS _RECEIVER ( this ) ) { throw Make Type Error ( k Called On Non Object , Promise Race ) ; } var deferred = New Promise Capability ( this ) ; try { for ( var value of iterable ) { this . resolve ( value ) . then ( deferred . resolve , deferred . reject ) ; SET _PRIVATE ( deferred . reject , promise Combined Deferred Symbol , deferred ) ; } } catch ( e ) { deferred . reject ( e ) } return deferred . promise ; } 
function Promise Has User Defined Reject Handler Check ( handler , deferred ) { if ( handler ! = = Promise Id Reject Handler ) { var combined Deferred = GET _PRIVATE ( handler , promise Combined Deferred Symbol ) ; if ( IS _UNDEFINED ( combined Deferred ) ) return true ; if ( Promise Has User Defined Reject Handler Recursive ( combined Deferred . promise ) ) { return true ; } } else if ( Promise Has User Defined Reject Handler Recursive ( deferred . promise ) ) { return true ; } return false ; } 
function receive ( intf , src IP , dest IP , u 8 , header Offset ) { const src Port = udp Header . get Src Port ( u 8 , header Offset ) ; const dest Port = udp Header . get Dest Port ( u 8 , header Offset ) ; const data Length = udp Header . get Data Length ( u 8 , header Offset ) - udp Header . header Length ; const data Offset = header Offset + udp Header . header Length ; debug ( 'recv UDP over IP 4 ' , src Port , dest Port , data Length ) ; const socket = UDPSocket . lookup Receive ( dest Port ) ; if ( ! socket ) { return ; } const u 8data = u 8 . subarray ( data Offset ) ; if ( socket . onmessage ) set Immediate ( ( ) = > socket . onmessage ( src IP , src Port , u 8data ) ) ; } 
function Set Constructor ( iterable ) { if ( IS _UNDEFINED ( new . target ) ) { throw Make Type Error ( k Constructor Not Function , "Set " ) ; } % _Set Initialize ( this ) ; if ( ! IS _NULL _OR _UNDEFINED ( iterable ) ) { var adder = this . add ; if ( ! IS _CALLABLE ( adder ) ) { throw Make Type Error ( k Property Not Function , adder , 'add ' , this ) ; } for ( var value of iterable ) { % _Call ( adder , this , value ) ; } } } 
function Map Constructor ( iterable ) { if ( IS _UNDEFINED ( new . target ) ) { throw Make Type Error ( k Constructor Not Function , "Map " ) ; } % _Map Initialize ( this ) ; if ( ! IS _NULL _OR _UNDEFINED ( iterable ) ) { var adder = this . set ; if ( ! IS _CALLABLE ( adder ) ) { throw Make Type Error ( k Property Not Function , adder , 'set ' , this ) ; } for ( var next Item of iterable ) { if ( ! IS _RECEIVER ( next Item ) ) { throw Make Type Error ( k Iterator Value Not An Object , next Item ) ; } % _Call ( adder , this , next Item [ 0 ] , next Item [ 1 ] ) ; } } } 
function Apply Patch Multi Chunk ( script , diff _array , new _source , preview _only , change _log ) { var old _source = script . source ; 
function Collect New ( node _list ) { for ( var i = 0 ; i < node _list . length ; i + + ) { link _to _original _script _list . push ( node _list [ i ] ) ; Collect New ( node _list [ i ] . children ) ; } } 
function Gather Compile Info ( source , script ) { 
function Reset Indexes ( new _parent _index , old _parent _index ) { var previous _sibling = - 1 ; while ( current _index < compile _info . length & & compile _info [ current _index ] . outer _index = = old _parent _index ) { var saved _index = current _index ; compile _info [ saved _index ] . outer _index = new _parent _index ; if ( previous _sibling ! = - 1 ) { compile _info [ previous _sibling ] . next _sibling _index = saved _index ; } previous _sibling = saved _index ; current _index + + ; Reset Indexes ( saved _index , old _index _map [ saved _index ] ) ; } if ( previous _sibling ! = - 1 ) { compile _info [ previous _sibling ] . next _sibling _index = - 1 ; } } 
function Patch Function Code ( old _node , change _log ) { var new _info = old _node . corresponding _node . info ; if ( old _node . live _shared _function _infos ) { old _node . live _shared _function _infos . for Each ( function ( old _info ) { % Live Edit Replace Function Code ( new _info . raw _array , old _info . raw _array ) ; 
function Link To Old Script ( old _info _node , old _script , report _array ) { if ( old _info _node . live _shared _function _infos ) { old _info _node . live _shared _function _infos . for Each ( function ( info ) { % Live Edit Function Set Script ( info . info , old _script ) ; } ) ; report _array . push ( { name : old _info _node . info . function _name } ) ; } else { report _array . push ( { name : old _info _node . info . function _name , not _found : true } ) ; } } 
function Temporary Remove Break Points ( original _script , change _log ) { var script _break _points = Get Script Break Points ( original _script ) ; var break _points _update _report = [ ] ; change _log . push ( { break _points _update : break _points _update _report } ) ; var break _point _old _positions = [ ] ; for ( var i = 0 ; i < script _break _points . length ; i + + ) { var break _point = script _break _points [ i ] ; break _point . clear ( ) ; 
function Build Code Info Tree ( code _info _array ) { 
function Mark Changed Functions ( code _info _tree , chunks ) { 
function Process Internals ( info _node ) { info _node . new _start _pos = chunk _it . Translate Pos ( info _node . info . start _position ) ; var child _index = 0 ; var code _changed = false ; var source _changed = false ; 
function Find Corresponding Functions ( old _code _tree , new _code _tree ) { 
function Find Function Infos ( compile _info ) { var wrappers = [ ] ; for ( var i = 0 ; i < shared _infos . length ; i + + ) { var wrapper = shared _infos [ i ] ; if ( wrapper . start _position = = compile _info . start _position & & wrapper . end _position = = compile _info . end _position ) { wrappers . push ( wrapper ) ; } } if ( wrappers . length > 0 ) { return wrappers ; } } 
function Function Compile Info ( raw _array ) { this . function _name = raw _array [ 0 ] ; this . start _position = raw _array [ 1 ] ; this . end _position = raw _array [ 2 ] ; this . param _num = raw _array [ 3 ] ; this . code = raw _array [ 4 ] ; this . code _scope _info = raw _array [ 5 ] ; this . scope _info = raw _array [ 6 ] ; this . outer _index = raw _array [ 7 ] ; this . shared _function _info = raw _array [ 8 ] ; this . next _sibling _index = null ; this . raw _array = raw _array ; } 
function Patch Positions ( old _info _node , diff _array , report _array ) { if ( old _info _node . live _shared _function _infos ) { old _info _node . live _shared _function _infos . for Each ( function ( info ) { % Live Edit Patch Function Positions ( info . raw _array , diff _array ) ; } ) ; report _array . push ( { name : old _info _node . info . function _name } ) ; } else { 
function Is Function Context Locals Changed ( function _info 1 , function _info 2 ) { var scope _info 1 = function _info 1 . scope _info ; var scope _info 2 = function _info 2 . scope _info ; var scope _info 1 _text ; var scope _info 2 _text ; if ( scope _info 1 ) { scope _info 1 _text = scope _info 1 . to String ( ) ; } else { scope _info 1 _text = " " ; } if ( scope _info 2 ) { scope _info 2 _text = scope _info 2 . to String ( ) ; } else { scope _info 2 _text = " " ; } if ( scope _info 1 _text ! = scope _info 2 _text ) { return "Variable map changed : [ " + scope _info 1 _text + " ] = > [ " + scope _info 2 _text + " ] " ; } 
function Check Stack Activations ( old _shared _wrapper _list , new _shared _list , change _log ) { var old _shared _list = new Global Array ( ) ; for ( var i = 0 ; i < old _shared _wrapper _list . length ; i + + ) { old _shared _list [ i ] = old _shared _wrapper _list [ i ] . info ; } var result = % Live Edit Check And Drop Activations ( old _shared _list , new _shared _list , true ) ; if ( result [ old _shared _wrapper _list . length ] ) { 
function Set Script Source ( script , new _source , preview _only , change _log ) { var old _source = script . source ; var diff = Compare Strings ( old _source , new _source ) ; return Apply Patch Multi Chunk ( script , diff , new _source , preview _only , change _log ) ; } 
function Apply Single Chunk Patch ( script , change _pos , change _len , new _str , change _log ) { var old _source = script . source ; 
function Describe Change Tree ( old _code _tree ) { function Process Old Node ( node ) { var child _infos = [ ] ; for ( var i = 0 ; i < node . children . length ; i + + ) { var child = node . children [ i ] ; if ( child . status ! = Function Status . UNCHANGED ) { child _infos . push ( Process Old Node ( child ) ) ; } } var new _child _infos = [ ] ; if ( node . textually _unmatched _new _nodes ) { for ( var i = 0 ; i < node . textually _unmatched _new _nodes . length ; i + + ) { var child = node . textually _unmatched _new _nodes [ i ] ; new _child _infos . push ( Process New Node ( child ) ) ; } } var res = { name : node . info . function _name , positions : Describe Positions ( node ) , status : node . status , children : child _infos , new _children : new _child _infos } ; if ( node . status _explanation ) { res . status _explanation = node . status _explanation ; } if ( node . textual _corresponding _node ) { res . new _positions = Describe Positions ( node . textual _corresponding _node ) ; } return res ; } function Process New Node ( node ) { var child _infos = [ ] ; 
function Validate Index ( index , length ) { var number Index = TO _NUMBER ( index ) ; var access Index = TO _INTEGER ( number Index ) ; if ( number Index ! = = access Index ) { throw Make Range Error ( k Invalid Atomic Access Index ) ; } if ( access Index < 0 | | access Index > = length ) { throw Make Range Error ( k Invalid Atomic Access Index ) ; } return access Index ; } 
function Atomics Compare Exchange JS ( sta , index , old Value , new Value ) { Check Shared Integer Typed Array ( sta ) ; index = Validate Index ( index , % _Typed Array Get Length ( sta ) ) ; old Value = TO _NUMBER ( old Value ) ; new Value = TO _NUMBER ( new Value ) ; return % _Atomics Compare Exchange ( sta , index , old Value , new Value ) ; } 
function Atomics Futex Wait JS ( ia , index , value , timeout ) { Check Shared Integer 3 2Typed Array ( ia ) ; index = Validate Index ( index , % _Typed Array Get Length ( ia ) ) ; if ( IS _UNDEFINED ( timeout ) ) { timeout = INFINITY ; } else { timeout = TO _NUMBER ( timeout ) ; if ( NUMBER _IS _NAN ( timeout ) ) { timeout = INFINITY ; } else { timeout = Max Simple ( 0 , timeout ) ; } } return % Atomics Futex Wait ( ia , index , value , timeout ) ; } 
function To Positive Integer ( x , range Error Index ) { var i = TO _INTEGER ( x ) + 0 ; if ( i < 0 ) throw Make Range Error ( range Error Index ) ; return i ; } 
function Make Break Point ( source _position , opt _script _break _point ) { var break _point = new Break Point ( source _position , opt _script _break _point ) ; break _points . push ( break _point ) ; return break _point ; } 
function Break Point ( source _position , opt _script _break _point ) { this . source _position _ = source _position ; if ( opt _script _break _point ) { this . script _break _point _ = opt _script _break _point ; } else { this . number _ = next _break _point _number + + ; } this . active _ = true ; this . condition _ = null ; } 
function Script Break Point ( type , script _id _or _name , opt _line , opt _column , opt _group Id , opt _position _alignment ) { this . type _ = type ; if ( type = = Debug . Script Break Point Type . Script Id ) { this . script _id _ = script _id _or _name ; } else if ( type = = Debug . Script Break Point Type . Script Name ) { this . script _name _ = script _id _or _name ; } else if ( type = = Debug . Script Break Point Type . Script Reg Exp ) { this . script _regexp _object _ = new Global Reg Exp ( script _id _or _name ) ; } else { throw Make Error ( k Debugger , "Unexpected breakpoint type " + type ) ; } this . line _ = opt _line | | 0 ; this . column _ = opt _column ; this . group Id _ = opt _group Id ; this . position _alignment _ = IS _UNDEFINED ( opt _position _alignment ) ? Debug . Break Position Alignment . Statement : opt _position _alignment ; this . active _ = true ; this . condition _ = null ; this . break _points _ = [ ] ; } 
function Update Script Break Points ( script ) { for ( var i = 0 ; i < script _break _points . length ; i + + ) { var break _point = script _break _points [ i ] ; if ( ( break _point . type ( ) = = Debug . Script Break Point Type . Script Name | | break _point . type ( ) = = Debug . Script Break Point Type . Script Reg Exp ) & & break _point . matches Script ( script ) ) { break _point . set ( script ) ; } } } 
function script By Id ( script Id ) { var scripts = Debug . scripts ( ) ; for ( var script of scripts ) { if ( script . id = = script Id ) return script ; } return UNDEFINED ; } 
function Object To Protocol Object _ ( object , mirror _serializer ) { var content = { } ; for ( var key in object ) { 
function Array To Protocol Array _ ( array , mirror _serializer ) { var json = [ ] ; for ( var i = 0 ; i < array . length ; i + + ) { json . push ( Value To Protocol Value _ ( array [ i ] , mirror _serializer ) ) ; } return json ; } 
function Value To Protocol Value _ ( value , mirror _serializer ) { 
function run Richards ( ) { var scheduler = new Scheduler ( ) ; scheduler . add Idle Task ( ID _IDLE , 0 , null , COUNT ) ; var queue = new Packet ( null , ID _WORKER , KIND _WORK ) ; queue = new Packet ( queue , ID _WORKER , KIND _WORK ) ; scheduler . add Worker Task ( ID _WORKER , 1 0 0 0 , queue ) ; queue = new Packet ( null , ID _DEVICE _A , KIND _DEVICE ) ; queue = new Packet ( queue , ID _DEVICE _A , KIND _DEVICE ) ; queue = new Packet ( queue , ID _DEVICE _A , KIND _DEVICE ) ; scheduler . add Handler Task ( ID _HANDLER _A , 2 0 0 0 , queue ) ; queue = new Packet ( null , ID _DEVICE _B , KIND _DEVICE ) ; queue = new Packet ( queue , ID _DEVICE _B , KIND _DEVICE ) ; queue = new Packet ( queue , ID _DEVICE _B , KIND _DEVICE ) ; scheduler . add Handler Task ( ID _HANDLER _B , 3 0 0 0 , queue ) ; scheduler . add Device Task ( ID _DEVICE _A , 4 0 0 0 , null ) ; scheduler . add Device Task ( ID _DEVICE _B , 5 0 0 0 , null ) ; scheduler . schedule ( ) ; if ( scheduler . queue Count ! = EXPECTED _QUEUE _COUNT | | scheduler . hold Count ! = EXPECTED _HOLD _COUNT ) { var msg = "Error during execution : queue Count = " + scheduler . queue Count + " , hold Count = " + scheduler . hold Count + " . " ; throw new Error ( msg ) ; } } 
function Scheduler ( ) { this . queue Count = 0 ; this . hold Count = 0 ; this . blocks = new Array ( NUMBER _OF _IDS ) ; this . list = null ; this . current Tcb = null ; this . current Id = null ; } 
function Task Control Block ( link , id , priority , queue , task ) { this . link = link ; this . id = id ; this . priority = priority ; this . queue = queue ; this . task = task ; if ( queue = = null ) { this . state = STATE _SUSPENDED ; } else { this . state = STATE _SUSPENDED _RUNNABLE ; } } 
function Idle Task ( scheduler , v 1 , count ) { this . scheduler = scheduler ; this . v 1 = v 1 ; this . count = count ; } 
function Worker Task ( scheduler , v 1 , v 2 ) { this . scheduler = scheduler ; this . v 1 = v 1 ; this . v 2 = v 2 ; } 
function Packet ( link , id , kind ) { this . link = link ; this . id = id ; this . kind = kind ; this . a 1 = 0 ; this . a 2 = new Array ( DATA _SIZE ) ; } 
function Proxy Create Revocable ( target , handler ) { var p = new Global Proxy ( target , handler ) ; return { proxy : p , revoke : ( ) = > % JSProxy Revoke ( p ) } ; } 
function Install Getter ( object , name , getter , attributes , prefix ) { % Check Is Bootstrapping ( ) ; if ( IS _UNDEFINED ( attributes ) ) attributes = DONT _ENUM ; Set Function Name ( getter , name , IS _UNDEFINED ( prefix ) ? "get " : prefix ) ; % Function Remove Prototype ( getter ) ; % Define Getter Property Unchecked ( object , name , getter , attributes ) ; % Set Native Flag ( getter ) ; } 
function Install Getter Setter ( object , name , getter , setter , attributes ) { % Check Is Bootstrapping ( ) ; if ( IS _UNDEFINED ( attributes ) ) attributes = DONT _ENUM ; Set Function Name ( getter , name , "get " ) ; Set Function Name ( setter , name , "set " ) ; % Function Remove Prototype ( getter ) ; % Function Remove Prototype ( setter ) ; % Define Accessor Property Unchecked ( object , name , getter , setter , DONT _ENUM ) ; % Set Native Flag ( getter ) ; % Set Native Flag ( setter ) ; } 
function Set Up Locked Prototype ( constructor , fields , methods ) { % Check Is Bootstrapping ( ) ; var prototype = constructor . prototype ; 
function Post Natives ( utils ) { % Check Is Bootstrapping ( ) ; for ( ; ! IS _UNDEFINED ( imports ) ; imports = imports . next ) { imports ( exports _container ) ; } 
function Create Array Iterator ( array , kind ) { var object = TO _OBJECT ( array ) ; var iterator = new Array Iterator ; SET _PRIVATE ( iterator , array Iterator Object Symbol , object ) ; SET _PRIVATE ( iterator , array Iterator Next Index Symbol , 0 ) ; SET _PRIVATE ( iterator , array Iteration Kind Symbol , kind ) ; return iterator ; } 
function Array Iterator Next ( ) { var iterator = this ; var value = UNDEFINED ; var done = true ; if ( ! IS _RECEIVER ( iterator ) | | ! HAS _DEFINED _PRIVATE ( iterator , array Iterator Next Index Symbol ) ) { throw Make Type Error ( k Incompatible Method Receiver , 'Array Iterator .prototype .next ' , this ) ; } var array = GET _PRIVATE ( iterator , array Iterator Object Symbol ) ; if ( ! IS _UNDEFINED ( array ) ) { var index = GET _PRIVATE ( iterator , array Iterator Next Index Symbol ) ; var item Kind = GET _PRIVATE ( iterator , array Iteration Kind Symbol ) ; var length = TO _UINT 3 2 ( array . length ) ; 
function get CFunc ( ident ) { try { var func = global Scope [ 'Module ' ] [ ' _ ' + ident ] ; 
function ccall Func ( func , return Type , arg Types , args ) { var stack = 0 ; function to C ( value , type ) { if ( type = = 'string ' ) { if ( value = = = null | | value = = = undefined | | value = = = 0 ) return 0 ; 
function set Value ( ptr , value , type , no Safe ) { type = type | | 'i 8 ' ; if ( type . char At ( type . length - 1 ) = = = ' * ' ) type = 'i 3 2 ' ; 
function add Pre Run ( func ) { if ( ! Module [ 'pre Run ' ] ) Module [ 'pre Run ' ] = [ ] ; else if ( typeof Module [ 'pre Run ' ] = = 'function ' ) Module [ 'pre Run ' ] = [ Module [ 'pre Run ' ] ] ; Module [ 'pre Run ' ] . push ( func ) ; } 
function ( filedes ) { 
function copy String ( element , value ) { var offset = _ _ _utsname _struct _layout [ element ] ; for ( var i = 0 ; i < value . length ; i + + ) { HEAP 8 [ ( ( ( name ) + ( offset + i ) ) | 0 ) ] = value . char Code At ( i ) } HEAP 8 [ ( ( ( name ) + ( offset + i ) ) | 0 ) ] = 0 } 
function Typed Array Default Constructor ( typed Array ) { switch ( % _Class Of ( typed Array ) ) { macro TYPED _ARRAY _CONSTRUCTOR _CASE ( ARRAY _ID , NAME , ELEMENT _SIZE ) case "NAME " : return Global NAME ; endmacro TYPED _ARRAYS ( TYPED _ARRAY _CONSTRUCTOR _CASE ) } 
function component Will Mount ( ) { 
function updater ( prev State ) { var state = this . constructor . get Derived State From Props ( next Props , prev State ) ; return state ! = = null & & state ! = = undefined ? state : null ; } 
function find Package ( directory ) { const file = path . resolve ( directory , 'package .json ' ) if ( fs . exists Sync ( file ) & & fs . stat Sync ( file ) . is File ( ) ) { return require ( file ) } const parent = path . resolve ( directory , ' . . ' ) return parent = = = directory ? null : find Package ( parent ) } 
function is Multisource ( arg ) { return Array . is Array ( arg ) & & ! ( typeof arg [ 0 ] = = = 'number ' & & ( arg . length = = = 1 | | typeof arg [ 1 ] = = = 'number ' ) ) & & ! ( arg . length < 3 2 & & arg . every ( ch = > Array . is Array ( ch ) | | Array Buffer . is View ( ch ) ) ) } 
function parse Args ( audio , time , duration , options ) { 
function resolve Path ( file Name , depth = 2 ) { if ( ! is Browser & & is Relative ( file Name ) & & ! is URL ( file Name ) ) { var caller Path = callsites ( ) [ depth ] . get File Name ( ) file Name = path . dirname ( caller Path ) + path . sep + file Name file Name = path . normalize ( file Name ) } return file Name } 
function multi Select ( Table , Checkbox ) { var _class , _temp , _initialise Props ; return _temp = _class = function ( _Component ) { _inherits ( Multi Select , _Component ) ; function Multi Select ( props ) { _class Call Check ( this , Multi Select ) ; var _this = _possible Constructor Return ( this , _Component . call ( this , props ) ) ; _initialise Props . call ( _this ) ; var obj = _this . get Checked Or Indeter ( props . data ) ; _this . state = _extends ( { } , obj , { data : ( 0 , _util . Object Assign ) ( props . data ) } ) ; return _this ; } Multi Select . prototype . component Will Receive Props = function component Will Receive Props ( next Props ) { if ( 'data ' in next Props ) { var obj = this . get Checked Or Indeter ( next Props . data ) ; this . set State ( _extends ( { } , obj , { data : ( 0 , _util . Object Assign ) ( next Props . data ) } ) ) ; } } ; Multi Select . prototype . get Checked Or Indeter = function get Checked Or Indeter ( data ) { var obj = { } ; var check Status = this . set Checked ( data ) ; if ( ! check Status ) { obj . checked All = false ; obj . indeterminate = false ; return obj ; } if ( check Status = = 'indeter ' ) { obj . indeterminate = true ; obj . checked All = false ; } else if ( check Status = = 'all ' ) { obj . checked All = true ; obj . indeterminate = false ; } return obj ; } ; Multi Select . prototype . set Checked = function set Checked ( data ) { if ( ! this . is Array ( data ) ) return false ; if ( data . length = = 0 ) return false ; var count = 0 ; var disabled Count = 0 ; data . for Each ( function ( da ) { if ( da . _checked & & ! da . _disabled ) { count + + ; } if ( da . _disabled ) { disabled Count + + ; } } ) ; if ( data . length = = count + disabled Count ) { return "all " ; } return count = = 0 ? false : "indeter " ; } ; Multi Select . prototype . is Array = function is Array ( o ) { return Object . prototype . to String . call ( o ) = = ' [object Array ] ' ; } ; Multi Select . prototype . render = function render ( ) { var columns = this . props . columns ; var data = this . state . data ; return _react 2 [ "default " ] . create Element ( Table , _extends ( { } , this . props , { columns : this . get Default Columns ( columns ) , data : data } ) ) ; } ; return Multi Select ; } ( _react . Component ) , _class . default Props = { prefix Cls : "u -table -mult -select " , get Selected Data Func : function get Selected Data Func ( ) { } } , _initialise Props = function _initialise Props ( ) { var _this 2 = this ; this . on All Check Change = function ( ) { var _state = _this 2 . state , data = _state . data , checked All = _state . checked All , indeterminate = _state . indeterminate ; var check = false ; if ( checked All ) { check = false ; } else { 
function render Select ( Select , Icon ) { var _class , _temp 2 ; return _temp 2 = _class = function ( _Component ) { _inherits ( Select Render , _Component ) ; function Select Render ( ) { var _temp , _this , _ret ; _class Call Check ( this , Select Render ) ; for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } return _ret = ( _temp = ( _this = _possible Constructor Return ( this , _Component . call . apply ( _Component , [ this ] . concat ( args ) ) ) , _this ) , _this . state = { value : _this . props . value , editable : false } , _this . handle Change = function ( e ) { var value = e ; if ( _this . props . on Change ) { _this . props . on Change ( value ) ; } _this . set State ( { value : value } ) ; set Timeout ( function ( ) { _this . set State ( { editable : false } ) ; } , 0 ) ; } , _this . check = function ( ) { _this . set State ( { editable : false } ) ; if ( _this . props . on Change ) { _this . props . on Change ( _this . state . value ) ; } } , _this . edit = function ( ) { _this . set State ( { editable : true } ) ; } , _temp ) , _possible Constructor Return ( _this , _ret ) ; } Select Render . prototype . render = function render ( ) { var _this 2 = this ; var _state = this . state , value = _state . value , editable = _state . editable ; var _props = this . props , isclick Trigger = _props . isclick Trigger , data Source = _props . data Source ; var cell Content = " " ; if ( editable ) { cell Content = isclick Trigger ? _react 2 [ "default " ] . create Element ( "div " , { class Name : "editable -cell -input -wrapper " } , _react 2 [ "default " ] . create Element ( Select , _extends ( { } , this . props , { value : this . state . value , on Blur : function on Blur ( value ) { console . log ( value ) ; 
function sort By ( arr , prop , desc ) { var props = [ ] , ret = [ ] , i = 0 , len = arr . length ; if ( typeof prop = = 'string ' ) { for ( ; i < len ; i + + ) { var o I = arr [ i ] ; ( props [ i ] = new String ( o I & & o I [ prop ] | | ' ' ) ) . _obj = o I ; } } else if ( typeof prop = = 'function ' ) { for ( ; i < len ; i + + ) { var _o I = arr [ i ] ; ( props [ i ] = new String ( _o I & & prop ( _o I ) | | ' ' ) ) . _obj = _o I ; } } else { throw ' 参 数 类 型 错 误 ' ; } props . sort ( ) ; for ( i = 0 ; i < len ; i + + ) { ret [ i ] = props [ i ] . _obj ; } if ( desc ) ret . reverse ( ) ; return ret ; } 
function Object Assign ( obj ) { var b = obj instanceof Array ; var tag Obj = b ? [ ] : { } ; if ( b ) { 
function sort ( Table , Icon ) { var _class , _temp , _initialise Props ; var Icon Type = [ { 'type ' : 'flat ' , 'icon ' : 'uf -symlist ' , 'order ' : 'flatscend ' } , { 'type ' : 'up ' , 'icon ' : 'uf -sortup ' , 'order ' : 'ascend ' } , { 'type ' : 'down ' , 'icon ' : 'uf -sortdown ' , 'order ' : 'descend ' } ] ; return _temp = _class = function ( _Component ) { _inherits ( Sort Table , _Component ) ; function Sort Table ( props ) { _class Call Check ( this , Sort Table ) ; var _this 2 = _possible Constructor Return ( this , _Component . call ( this , props ) ) ; _initialise Props . call ( _this 2 ) ; var flat Columns = [ ] ; _this 2 . _to Flat Column ( props . columns , - 1 , flat Columns ) ; _this 2 . state = { data : _this 2 . props . data , columns : props . columns , flat Columns : flat Columns } ; return _this 2 ; } *column 扁 平 化 处 理 ， 适 应 多 表 头 避 免 递 归 操 作 * * / Sort Table . prototype . _to Flat Column = function _to Flat Column ( columns ) { var parent Index = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : - 1 ; var flat Columns = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : [ ] ; var _this = this ; var children = [ ] ; * column 当 前 的 排 序 的 列 * 当 有 的 列 不 排 序 时 ， 将 该 列 的order Num 置 为 ‘ ’ ， 并 动 态 的 修 改 其 他 列 的order Num 。 * / 
function filter Column ( Table , Popover ) { var _class , _temp , _initialise Props ; return _temp = _class = function ( _Component ) { _inherits ( Filter Column , _Component ) ; function Filter Column ( props ) { _class Call Check ( this , Filter Column ) ; var _this = _possible Constructor Return ( this , _Component . call ( this , props ) ) ; _initialise Props . call ( _this ) ; var columns = props . columns ; _this . state = { columns : _this . set Colum Order By Index ( ( 0 , _util . Object Assign ) ( columns ) ) , show Modal : false , screen Y : 0 } ; return _this ; } Filter Column . prototype . component Will Receive Props = function component Will Receive Props ( next Props ) { if ( next Props . columns ! = this . props . columns ) { this . set State ( { columns : this . set Colum Order By Index ( ( 0 , _util . Object Assign ) ( next Props . columns ) ) } ) ; } this . set State ( { show Modal : next Props . show Filter Popover ? true : false } ) ; } ; Filter Column . prototype . render = function render ( ) { var _props = this . props , data = _props . data , prefix Cls = _props . prefix Cls , scroll Pro = _props . scroll ; var _state = this . state , columns = _state . columns , show Modal = _state . show Modal ; var locale = ( 0 , _tool . get Component Locale ) ( this . props , this . context , 'Table ' , function ( ) { return _i 1 8n 2 [ "default " ] ; } ) ; var _columns = [ ] , width State = 0 , scroll = scroll Pro ; columns . for Each ( function ( da ) { if ( da . ifshow ) { _columns . push ( da ) ; if ( da . width ) { width State + + ; } } } ) ; 
function render Input ( Form , Input , Icon ) { var _class , _temp 2 ; return _temp 2 = _class = function ( _Component ) { _inherits ( Input Render , _Component ) ; function Input Render ( ) { var _temp , _this , _ret ; _class Call Check ( this , Input Render ) ; for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } return _ret = ( _temp = ( _this = _possible Constructor Return ( this , _Component . call . apply ( _Component , [ this ] . concat ( args ) ) ) , _this ) , _this . state = { value : _this . props . value , editable : false } , _this . handle Change = function ( e ) { var value = e ; _this . set State ( { value : value } ) ; } , _this . check = function ( ) { if ( typeof _this . flag = = = "undefined " | | _this . flag ) { _this . props . check ( _this . flag , _this . obj ) ; _this . set State ( { editable : false } ) ; if ( _this . props . on Change ) { _this . props . on Change ( _this . state . value ) ; } _this . flag = undefined ; } } , _this . check Validate = function ( flag , obj ) { _this . flag = flag ; _this . obj = obj ; } , _this . edit = function ( ) { _this . set State ( { editable : true } ) ; } , _this . handle Keydown = function ( event ) { if ( event . key Code = = 1 3 ) { _this . check ( ) ; } else if ( event . key Code = = 9 ) { } } , _this . format Currency = function ( money ) { if ( money & & money ! = null & & ! ! Number ( money ) ) { money = String ( money ) ; var left = money . split ( " . " ) [ 0 ] , right = money . split ( " . " ) [ 1 ] ; right = right ? right . length > = 2 ? " . " + right . substr ( 0 , 2 ) : " . " + right + " 0 " : " . 0 0 " ; var temp = left . split ( " " ) . reverse ( ) . join ( " " ) . match ( / ( \d { 1 , 3 } ) / g ) ; return ( Number ( money ) < 0 ? " - " : " " ) + temp . join ( " , " ) . split ( " " ) . reverse ( ) . join ( " " ) + right ; } else if ( money = = = 0 ) { 
function render Checkbox ( Checkbox , Icon ) { return function ( _Component ) { _inherits ( Checkbox Render , _Component ) ; function Checkbox Render ( ) { var _temp , _this , _ret ; _class Call Check ( this , Checkbox Render ) ; for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } return _ret = ( _temp = ( _this = _possible Constructor Return ( this , _Component . call . apply ( _Component , [ this ] . concat ( args ) ) ) , _this ) , _this . state = { value : _this . props . value , editable : false } , _this . handle Change = function ( e ) { var value = e . target . value ; _this . set State ( { value : value } ) ; } , _this . check = function ( ) { _this . set State ( { editable : false } ) ; if ( _this . props . on Change ) { _this . props . on Change ( _this . state . value ) ; } } , _this . edit = function ( ) { _this . set State ( { editable : true } ) ; } , _this . handle Keydown = function ( event ) { if ( event . key Code = = 1 3 ) { _this . check ( ) ; } } , _temp ) , _possible Constructor Return ( _this , _ret ) ; } Checkbox Render . prototype . render = function render ( ) { var _state = this . state , value = _state . value , editable = _state . editable ; var cell Content = " " ; if ( editable ) { cell Content = _react 2 [ "default " ] . create Element ( "div " , { class Name : "editable -cell -input -wrapper " } , _react 2 [ "default " ] . create Element ( Checkbox , { on Change : this . handle Change , on Key Down : this . handle Keydown , on Blur : this . check , auto Focus : true , value : value } ) ) ; } else { cell Content = _react 2 [ "default " ] . create Element ( "div " , { class Name : "editable -cell -text -wrapper " } , value | | " " , _react 2 [ "default " ] . create Element ( Icon , { type : "uf -pencil " , class Name : "editable -cell -icon " , on Click : this . edit } ) ) ; } return _react 2 [ "default " ] . create Element ( "div " , { class Name : "editable -cell " } , cell Content ) ; } ; return Checkbox Render ; } ( _react . Component ) ; } 
function drag Column ( Table ) { return function ( _Component ) { _inherits ( Drag Column , _Component ) ; function Drag Column ( props ) { _class Call Check ( this , Drag Column ) ; var _this = _possible Constructor Return ( this , _Component . call ( this , props ) ) ; _this . set Colum Order By Index = function ( _column ) { _column . for Each ( function ( da , i ) { da . drag Index = i ; da . drg Hover = false ; } ) ; return _column ; } ; _this . on Drop = function ( event , data ) { var drag Source = data . drag Source , drag Targ = data . drag Targ ; var columns = _this . state . columns ; var source Index = - 1 , target Index = - 1 ; source Index = columns . find Index ( function ( da , i ) { return da . key = = drag Source . key ; } ) ; target Index = columns . find Index ( function ( da , i ) { return da . key = = drag Targ . key ; } ) ; 
function minimize ( dfa ) { const table = dfa . get Transition Table ( ) ; const all States = Object . keys ( table ) ; const alphabet = dfa . get Alphabet ( ) ; const accepting = dfa . get Accepting State Numbers ( ) ; current Transition Map = { } ; const non Accepting = new Set ( ) ; all States . for Each ( state = > { state = Number ( state ) ; const is Accepting = accepting . has ( state ) ; if ( is Accepting ) { current Transition Map [ state ] = accepting ; } else { non Accepting . add ( state ) ; current Transition Map [ state ] = non Accepting ; } } ) ; 
function are Equivalent ( s 1 , s 2 , table , alphabet ) { for ( const symbol of alphabet ) { if ( ! go To Same Set ( s 1 , s 2 , table , symbol ) ) { return false ; } } return true ; } 
function go To Same Set ( s 1 , s 2 , table , symbol ) { if ( ! current Transition Map [ s 1 ] | | ! current Transition Map [ s 2 ] ) { return false ; } const original Transition S 1 = table [ s 1 ] [ symbol ] ; const original Transition S 2 = table [ s 2 ] [ symbol ] ; 
function is Simple Range ( class Range ) { const { from , to } = class Range ; return ( from . code Point > = DIGIT _ 0 _CP & & from . code Point < = DIGIT _ 9 _CP & & to . code Point > = DIGIT _ 0 _CP & & to . code Point < = DIGIT _ 9 _CP ) | | ( from . code Point > = UPPER _A _CP & & from . code Point < = UPPER _Z _CP & & to . code Point > = UPPER _A _CP & & to . code Point < = UPPER _Z _CP ) | | ( from . code Point > = LOWER _A _CP & & from . code Point < = LOWER _Z _CP & & to . code Point > = LOWER _A _CP & & to . code Point < = LOWER _Z _CP ) ; } 
function get Range ( text ) { const range = text . match ( / \d + / g ) . map ( Number ) ; if ( Number . is Finite ( range [ 1 ] ) & & range [ 1 ] < range [ 0 ] ) { throw new Syntax Error ( ` $ { text } ` ) ; } return range ; } 
function check Class Range ( from , to ) { if ( from . kind = = = 'control ' | | to . kind = = = 'control ' | | ( ! is Na N ( from . code Point ) & & ! is Na N ( to . code Point ) & & from . code Point > to . code Point ) ) { throw new Syntax Error ( ` $ { from . value } $ { to . value } ` ) ; } } 
function Char ( value , kind , loc ) { let symbol ; let code Point ; switch ( kind ) { case 'decimal ' : { code Point = Number ( value . slice ( 1 ) ) ; symbol = String . from Code Point ( code Point ) ; break ; } case 'oct ' : { code Point = parse Int ( value . slice ( 1 ) , 8 ) ; symbol = String . from Code Point ( code Point ) ; break ; } case 'hex ' : case 'unicode ' : { if ( value . last Index Of ( ' \ \u ' ) > 0 ) { let [ lead , trail ] = value . split ( ' \ \u ' ) . slice ( 1 ) ; lead = parse Int ( lead , 1 6 ) ; trail = parse Int ( trail , 1 6 ) ; code Point = ( lead - 0xd 8 0 0 ) * 0x 4 0 0 + ( trail - 0xdc 0 0 ) + 0x 1 0 0 0 0 ; symbol = String . from Code Point ( code Point ) ; } else { const hex = value . slice ( 2 ) . replace ( ' { ' , ' ' ) ; code Point = parse Int ( hex , 1 6 ) ; if ( code Point > 0x 1 0ffff ) { throw new Syntax Error ( ` $ { value } ` ) ; } symbol = String . from Code Point ( code Point ) ; } break ; } case 'meta ' : { switch ( value ) { case ' \ \t ' : symbol = ' \t ' ; code Point = symbol . code Point At ( 0 ) ; break ; case ' \ \n ' : symbol = ' \n ' ; code Point = symbol . code Point At ( 0 ) ; break ; case ' \ \r ' : symbol = ' \r ' ; code Point = symbol . code Point At ( 0 ) ; break ; case ' \ \v ' : symbol = ' \v ' ; code Point = symbol . code Point At ( 0 ) ; break ; case ' \ \f ' : symbol = ' \f ' ; code Point = symbol . code Point At ( 0 ) ; break ; case ' \ \b ' : symbol = ' \b ' ; code Point = symbol . code Point At ( 0 ) ; case ' \ \ 0 ' : symbol = ' \ 0 ' ; code Point = 0 ; case ' . ' : symbol = ' . ' ; code Point = Na N ; break ; default : code Point = Na N ; } break ; } case 'simple ' : { symbol = value ; code Point = symbol . code Point At ( 0 ) ; break ; } } return Node ( { type : 'Char ' , value , kind , symbol , code Point , } , loc ) ; } 
function check Flags ( flags ) { const seen = new Set ( ) ; for ( const flag of flags ) { if ( seen . has ( flag ) | | ! valid Flags . includes ( flag ) ) { throw new Syntax Error ( ` $ { flags } ` ) ; } seen . add ( flag ) ; } return flags . split ( ' ' ) . sort ( ) . join ( ' ' ) ; } 
function Group Ref Or Dec Char ( text , text Loc ) { const reference = Number ( text . slice ( 1 ) ) ; if ( reference > 0 & & reference < = capturing Groups Count ) { return Node ( { type : 'Backreference ' , kind : 'number ' , number : reference , reference , } , text Loc ) ; } return Char ( text , 'decimal ' , text Loc ) ; } 
function validate Unicode Group Name ( name , state ) { const is Unicode Name = u Re . test ( name ) | | ucp Re . test ( name ) ; const is Unicode State = ( state = = = 'u ' | | state = = = 'xu ' | | state = = = 'u _class ' ) ; if ( is Unicode Name & & ! is Unicode State ) { throw new Syntax Error ( ` $ { name } \ ` \ ` ` ) ; } } 
function Named Group Ref Or Chars ( text , text Loc ) { const group Name = text . slice ( 3 , - 1 ) ; if ( named Groups . has Own Property ( group Name ) ) { return Node ( { type : 'Backreference ' , kind : 'name ' , number : named Groups [ group Name ] , reference : group Name , } , text Loc ) ; } 
function Node ( node , loc ) { if ( yy . options . capture Locations ) { node . loc = { source : parsing String . slice ( loc . start Offset , loc . end Offset ) , start : { line : loc . start Line , column : loc . start Column , offset : loc . start Offset , } , end : { line : loc . end Line , column : loc . end Column , offset : loc . end Offset , } , } ; } return node ; } 
function loc ( start , end ) { if ( ! yy . options . capture Locations ) { return null ; } return { start Offset : start . start Offset , end Offset : end . end Offset , start Line : start . start Line , end Line : end . end Line , start Column : start . start Column , end Column : end . end Column , } ; } 
function sort Char Class ( a , b ) { const a Value = get Sort Value ( a ) ; const b Value = get Sort Value ( b ) ; if ( a Value = = = b Value ) { 
function is Meta ( expression , value = null ) { return expression . type = = = 'Char ' & & expression . kind = = = 'meta ' & & ( value ? expression . value = = = value : / ^ \ \ [dws ] $ / i . test ( expression . value ) ) ; } 
function ast Traverse ( root , options = { } ) { const pre = options . pre ; const post = options . post ; const skip Property = options . skip Property ; function visit ( node , parent , prop , idx ) { if ( ! node | | typeof node . type ! = = 'string ' ) { return ; } let res = undefined ; if ( pre ) { res = pre ( node , parent , prop , idx ) ; } if ( res ! = = false ) { 
function char ( c ) { const in State = new NFAState ( ) ; const out State = new NFAState ( { accepting : true , } ) ; return new NFA ( in State . add Transition ( c , out State ) , out State ) ; } 
function alt Pair ( first , second ) { first . out . accepting = false ; second . out . accepting = true ; first . out . add Transition ( EPSILON , second . in ) ; return new NFA ( first . in , second . out ) ; } 
function alt ( first , . . . fragments ) { for ( let fragment of fragments ) { first = alt Pair ( first , fragment ) ; } return first ; } 
function or Pair ( first , second ) { const in State = new NFAState ( ) ; const out State = new NFAState ( ) ; in State . add Transition ( EPSILON , first . in ) ; in State . add Transition ( EPSILON , second . in ) ; out State . accepting = true ; first . out . accepting = false ; second . out . accepting = false ; first . out . add Transition ( EPSILON , out State ) ; second . out . add Transition ( EPSILON , out State ) ; return new NFA ( in State , out State ) ; } 
function or ( first , . . . fragments ) { for ( let fragment of fragments ) { first = or Pair ( first , fragment ) ; } return first ; } 
function rep Explicit ( fragment ) { const in State = new NFAState ( ) ; const out State = new NFAState ( { accepting : true , } ) ; 
function rep ( fragment ) { fragment . in . add Transition ( EPSILON , fragment . out ) ; fragment . out . add Transition ( EPSILON , fragment . in ) ; return fragment ; } 
function rewrite Number Ranges ( path ) { const { node } = path ; node . expressions . for Each ( ( expression , i ) = > { if ( is Full Number Range ( expression ) ) { path . get Child ( i ) . replace ( { type : 'Char ' , value : ' \ \d ' , kind : 'meta ' , } ) ; } } ) ; } 
function rewrite Word Ranges ( path , has IFlag , has UFlag ) { const { node } = path ; let number Path = null ; let lower Case Path = null ; let upper Case Path = null ; let underscore Path = null ; let u 0 1 7f Path = null ; let u 2 1 2a Path = null ; node . expressions . for Each ( ( expression , i ) = > { 
function rewrite Whitespace Ranges ( path ) { const { node } = path ; let space Path = null ; let t Path = null ; let n Path = null ; let r Path = null ; let f Path = null ; node . expressions . for Each ( ( expression , i ) = > { 
function gen ( node ) { if ( node & & ! generator [ node . type ] ) { throw new Error ( ` $ { node . type } ` ) ; } return node ? generator [ node . type ] ( node ) : ' ' ; } 
function preserves In Char Class ( value , index , parent ) { if ( value = = = ' ^ ' ) { 
function combine Repeating Pattern Left ( alternative , child , index ) { const { node } = alternative ; const nb Possible Lengths = Math . ceil ( index / 2 ) ; let i = 0 ; while ( i < nb Possible Lengths ) { const start Index = index - 2 * i - 1 ; let right , left ; if ( i = = = 0 ) { right = child ; left = alternative . get Child ( start Index ) ; } else { right = Node Path . get For Node ( { type : 'Alternative ' , expressions : [ . . . node . expressions . slice ( index - i , index ) , child . node ] } ) ; left = Node Path . get For Node ( { type : 'Alternative ' , expressions : [ . . . node . expressions . slice ( start Index , index - i ) ] } ) ; } if ( right . has Equal Source ( left ) ) { for ( let j = 0 ; j < 2 * i + 1 ; j + + ) { alternative . get Child ( start Index ) . remove ( ) ; } child . replace ( { type : 'Repetition ' , expression : i = = = 0 ? right . node : { type : 'Group ' , capturing : false , expression : right . node } , quantifier : { type : 'Quantifier ' , kind : 'Range ' , from : 2 , to : 2 , greedy : true } } ) ; return start Index ; } i + + ; } return index ; } 
function combine With Previous Repetition ( alternative , child , index ) { const { node } = alternative ; let i = 0 ; while ( i < index ) { let previous Child = alternative . get Child ( i ) ; if ( previous Child . node . type = = = 'Repetition ' & & previous Child . node . quantifier . greedy ) { let left = previous Child . get Child ( ) ; let right ; if ( left . node . type = = = 'Group ' & & ! left . node . capturing ) { left = left . get Child ( ) ; } if ( i + 1 = = = index ) { right = child ; if ( right . node . type = = = 'Group ' & & ! right . node . capturing ) { right = right . get Child ( ) ; } } else { right = Node Path . get For Node ( { type : 'Alternative ' , expressions : [ . . . node . expressions . slice ( i + 1 , index + 1 ) ] } ) ; } if ( left . has Equal Source ( right ) ) { for ( let j = i ; j < index ; j + + ) { alternative . get Child ( i + 1 ) . remove ( ) ; } increase Quantifier By One ( previous Child . node . quantifier ) ; return i ; } } i + + ; } return index ; } 
function combine Repetition With Previous ( alternative , child , index ) { const { node } = alternative ; if ( child . node . type = = = 'Repetition ' & & child . node . quantifier . greedy ) { let right = child . get Child ( ) ; let left ; if ( right . node . type = = = 'Group ' & & ! right . node . capturing ) { right = right . get Child ( ) ; } let right Length ; if ( right . node . type = = = 'Alternative ' ) { right Length = right . node . expressions . length ; left = Node Path . get For Node ( { type : 'Alternative ' , expressions : [ . . . node . expressions . slice ( index - right Length , index ) ] } ) ; } else { right Length = 1 ; left = alternative . get Child ( index - 1 ) ; if ( left . node . type = = = 'Group ' & & ! left . node . capturing ) { left = left . get Child ( ) ; } } if ( left . has Equal Source ( right ) ) { for ( let j = index - right Length ; j < index ; j + + ) { alternative . get Child ( index - right Length ) . remove ( ) ; } increase Quantifier By One ( child . node . quantifier ) ; return index - right Length ; } } return index ; } 
function get Surrogate Pair From Code Point ( code Point ) { const lead = Math . floor ( ( code Point - 0x 1 0 0 0 0 ) / 0x 4 0 0 ) + 0xd 8 0 0 ; const trail = ( code Point - 0x 1 0 0 0 0 ) % 0x 4 0 0 + 0xdc 0 0 ; return { lead : lead . to String ( 1 6 ) , trail : trail . to String ( 1 6 ) } ; } 
function disjunction To List ( node ) { if ( node . type ! = = 'Disjunction ' ) { throw new Type Error ( ` $ { node . type } ` ) ; } const list = [ ] ; if ( node . left & & node . left . type = = = 'Disjunction ' ) { list . push ( . . . disjunction To List ( node . left ) , node . right ) ; } else { list . push ( node . left , node . right ) ; } return list ; } 
function increase Quantifier By One ( quantifier ) { if ( quantifier . kind = = = ' * ' ) { quantifier . kind = ' + ' ; } else if ( quantifier . kind = = = ' + ' ) { quantifier . kind = 'Range ' ; quantifier . from = 2 ; delete quantifier . to ; } else if ( quantifier . kind = = = ' ? ' ) { quantifier . kind = 'Range ' ; quantifier . from = 1 ; quantifier . to = 2 ; } else if ( quantifier . kind = = = 'Range ' ) { quantifier . from + = 1 ; if ( quantifier . to ) { quantifier . to + = 1 ; } } } 
function Scroll Wrapper ( { children , . . . props } ) { return ( < div { . . . props } > < section style = { { . . . style } } > < h 1 > ⬇ Scroll Down ⬇ < /h 1 > < / section > { children } < section style = { { . . . style } } > < h 1 > ⬆ ︎ Scroll up ⬆ ︎ < /h 1 > < / section > < / div > ) } 
function create Flow ( ) { fs . write File Sync ( path . join ( process . cwd ( ) , pkg . main + ' .flow ' ) , create Flow File ( ) , 'utf - 8 ' , ) fs . write File Sync ( path . join ( process . cwd ( ) , pkg . module + ' .flow ' ) , create Flow File ( ) , 'utf - 8 ' , ) } 
function install ( name , algorithm ) { if ( typeof name ! = = 'string ' | | name = = = ' ' ) { throw new Type Error ( 'The algorithm name must be an non -empty string . ' ) ; } if ( typeof algorithm ! = = 'object ' | | algorithm = = = null | | Array . is Array ( algorithm ) ) { throw new Type Error ( 'The algorithm object must be an object . ' ) ; } if ( typeof algorithm . hash ! = = 'function ' ) { throw new Type Error ( 'The hash property of the algorithm object should be a function . ' ) ; } if ( typeof algorithm . verify ! = = 'function ' ) { throw new Type Error ( 'The verify property of the algorithm object should be a function . ' ) ; } if ( typeof algorithm . identifiers ! = = 'function ' ) { throw new Type Error ( 'The identifiers property of the algorithm object should be a function . ' ) ; } if ( funcs [ name ] ! = = undefined ) { throw new Type Error ( ` $ { name } ` ) ; } const idfs = algorithm . identifiers ( ) ; for ( const an of queue ) { if ( funcs [ an ] . identifiers ( ) . some ( idf = > idfs . index Of ( idf ) ! = = - 1 ) ) { throw new Error ( 'The identifiers property of the algorithm object clashes with the ones of another algorithm . ' ) ; } } funcs [ name ] = Object . assign ( { } , algorithm ) ; Object . freeze ( funcs [ name ] ) ; queue . push ( name ) ; } 
function uninstall ( name ) { if ( typeof name ! = = 'string ' | | name = = = ' ' ) { throw new Type Error ( 'The algorithm name must be an non -empty string . ' ) ; } const hash Func = funcs [ name ] ; if ( ! hash Func ) { throw new Type Error ( ` $ { name } ` ) ; } delete funcs [ name ] ; queue . splice ( queue . index Of ( name ) , 1 ) ; } 
function use ( name ) { if ( name = = = undefined ) { if ( queue . length = = = 0 ) { throw new Error ( 'No algorithm installed . ' ) ; } name = queue [ queue . length - 1 ] ; } else if ( typeof name ! = = 'string ' | | name = = = ' ' ) { throw new Type Error ( 'The algorithm name must be an non -empty string . ' ) ; } const hash Func = funcs [ name ] ; if ( ! hash Func ) { throw new Type Error ( ` $ { name } ` ) ; } return hash Func ; } 
function which ( hashstr ) { if ( typeof hashstr ! = = 'string ' | | hashstr = = = ' ' ) { throw new Type Error ( 'The hashstr param must be an non -empty string . ' ) ; } const fields = hashstr . split ( ' $ ' ) ; if ( fields . length < 3 | | fields [ 0 ] ! = = ' ' ) { throw new Type Error ( 'The hashstr param provided is not in a supported format . ' ) ; } const idf = fields [ 1 ] ; if ( queue . length = = = 0 ) { throw new Error ( 'No algorithm installed . ' ) ; } for ( const name of queue ) { if ( funcs [ name ] . identifiers ( ) . index Of ( idf ) = = = - 1 ) continue ; return name ; } return null ; } 
function verify ( hashstr , password ) { const name = which ( hashstr ) ; if ( name = = = null ) { throw new Type Error ( 'No compatible algorithm installed . ' ) ; } return use ( name ) . verify ( hashstr , password ) ; } 
function replace Primitive ( node , value , yaml ) { return yaml . substr ( 0 , node . start _mark . pointer ) + String ( value ) + yaml . substring ( node . end _mark . pointer ) ; } 
function replace Node ( node , value , yaml ) { let indented Value = indent ( value , node . start _mark . column ) ; let line Start = node . start _mark . pointer - node . start _mark . column ; return yaml . substr ( 0 , line Start ) + indented Value + yaml . substring ( get Node End Mark ( node ) . pointer ) ; } 
function get Node End Mark ( ast ) { if ( is Array ( ast . value ) & & ast . value . length ) { let last Item = last ( ast . value ) ; if ( is Array ( last Item ) & & last Item . length ) { return get Node End Mark ( last ( last Item ) ) ; } return get Node End Mark ( last Item ) ; } return ast . end _mark ; } 
function clean Dump ( value ) { let yaml = dump ( value ) . replace ( / \n $ / , ' ' ) ; if ( EOL ! = = ' \n ' ) { yaml = yaml . replace ( / \n / g , EOL ) ; } return yaml ; } 
function set Node Remark ( ast , remark , yaml ) { let index = get Node End Mark ( ast ) . pointer ; while ( index < yaml . length & & yaml [ index ] ! = = ' # ' & & yaml [ index ] ! = = EOL ) { + + index ; } if ( EOL = = = yaml [ index ] | | index = = = yaml . length ) { return yaml . substr ( 0 , index ) + ' # ' + remark + yaml . substring ( index ) ; } else { while ( index < yaml . length & & ( yaml [ index ] = = = ' # ' | | yaml [ index ] = = = ' ' ) ) { + + index ; } let end = index ; while ( end < yaml . length & & yaml [ end ] ! = = EOL ) { + + end ; } return yaml . substr ( 0 , index ) + remark + yaml . substring ( end ) ; } } 
function get Node ( ast , path ) { if ( path . length ) { if ( ast . tag = = = MAP _TAG ) { let value = ast . value ; for ( let i = 0 ; i < value . length ; + + i ) { let [ key Node , val Node ] = value [ i ] ; if ( path [ 0 ] = = = key Node . value ) { return get Node ( val Node , path . slice ( 1 ) ) ; } } return undefined ; } else if ( ast . tag = = = SEQ _TAG ) { return ast . value [ path [ 0 ] ] & & get Node ( ast . value [ path [ 0 ] ] , path . slice ( 1 ) ) ; } } return ast ; } 
function update Seq ( ast , new Json , yaml ) { var values = ( 0 , _js Yaml . load ) ( ( 0 , _yaml Js . serialize ) ( ast ) ) ; var min = Math . min ( values . length , new Json . length ) ; if ( values . length > min ) { for ( var i = values . length - 1 ; i > = min ; - - i ) { yaml = remove Array Element ( ast . value [ i ] , yaml ) ; } } else if ( new Json . length > min ) { yaml = insert After Node ( ast , clean Dump ( new Json . slice ( min ) ) , yaml ) ; } for ( var i = min - 1 ; i > = 0 ; - - i ) { yaml = change Array Element ( ast . value [ i ] , clean Dump ( new Json [ i ] ) , yaml ) ; } return yaml ; } 
function update Map ( ast , new Json , json , yaml ) { 
function insert After Node ( node , value , yaml ) { var indented Value = indent ( value , node . start _mark . column ) ; return yaml . substr ( 0 , get Node End Mark ( node ) . pointer ) + _os . EOL + indented Value + yaml . substring ( get Node End Mark ( node ) . pointer ) ; } 
function remove Array Element ( node , yaml ) { var index = node . start _mark . pointer - node . start _mark . column - 1 ; return yaml . substr ( 0 , index ) + yaml . substring ( get Node End Mark ( node ) . pointer ) ; } 
function change Array Element ( node , value , yaml ) { var indented Value = indent ( value , node . start _mark . column ) ; 
function get Node End Mark ( _x ) { var _again = true ; _function : while ( _again ) { var ast = _x ; _again = false ; if ( ( 0 , _lodash . is Array ) ( ast . value ) & & ast . value . length ) { var last Item = ( 0 , _lodash . last ) ( ast . value ) ; if ( ( 0 , _lodash . is Array ) ( last Item ) & & last Item . length ) { _x = ( 0 , _lodash . last ) ( last Item ) ; _again = true ; last Item = undefined ; continue _function ; } _x = last Item ; _again = true ; last Item = undefined ; continue _function ; } return ast . end _mark ; } } 
function indent ( str , depth ) { return str . split ( _os . EOL ) . filter ( function ( line ) { return line ; } ) . map ( function ( line ) { return ( 0 , _lodash . repeat ) ( SPACE , depth ) + line ; } ) . join ( _os . EOL ) ; } 
function clean Dump ( value ) { var yaml = ( 0 , _js Yaml . dump ) ( value ) . replace ( / \n $ / , ' ' ) ; if ( _os . EOL ! = = ' \n ' ) { yaml = yaml . replace ( / \n / g , _os . EOL ) ; } return yaml ; } 
function get Node Remark ( ast , yaml ) { var index = get Node End Mark ( ast ) . pointer ; while ( index < yaml . length & & yaml [ index ] ! = = ' # ' & & yaml [ index ] ! = = _os . EOL ) { + + index ; } if ( _os . EOL = = = yaml [ index ] | | index = = = yaml . length ) { return ' ' ; } else { while ( index < yaml . length & & ( yaml [ index ] = = = ' # ' | | yaml [ index ] = = = ' ' ) ) { + + index ; } var end = index ; while ( end < yaml . length & & yaml [ end ] ! = = _os . EOL ) { + + end ; } return yaml . substring ( index , end ) ; } } 
function get Node ( _x 2 , _x 3 ) { var _left ; var _again 2 = true ; _function 2 : while ( _again 2 ) { var ast = _x 2 , path = _x 3 ; _again 2 = false ; if ( path . length ) { if ( ast . tag = = = MAP _TAG ) { var value = ast . value ; for ( var i = 0 ; i < value . length ; + + i ) { var _value $i = _sliced To Array ( value [ i ] , 2 ) ; var key Node = _value $i [ 0 ] ; var val Node = _value $i [ 1 ] ; if ( path [ 0 ] = = = key Node . value ) { _x 2 = val Node ; _x 3 = path . slice ( 1 ) ; _again 2 = true ; value = i = _value $i = key Node = val Node = undefined ; continue _function 2 ; } } return undefined ; } else if ( ast . tag = = = SEQ _TAG ) { if ( ! ( _left = ast . value [ path [ 0 ] ] ) ) { return _left ; } _x 2 = ast . value [ path [ 0 ] ] ; _x 3 = path . slice ( 1 ) ; _again 2 = true ; value = i = _value $i = key Node = val Node = undefined ; continue _function 2 ; } } return ast ; } } 
function get Rect ( el ) { if ( el & & typeof ( el . get Bounding Client Rect ) = = = 'function ' ) { return el . get Bounding Client Rect ( ) ; } if ( el = = = window | | el = = = document ) { return { top : 0 , left : 0 , bottom : window . inner Height , height : window . inner Height , width : window . inner Width , right : window . inner Width } ; } return { top : 0 , left : 0 , right : 0 , bottom : 0 , width : 0 , height : 0 } ; } 
function sanitize Props ( props , to Remove ) { props = { . . . props } ; for ( let i = 0 , l = to Remove . length ; i < l ; i + = 1 ) { delete props [ to Remove [ i ] ] } return props ; } 
function mock Prepare Hosts ( command ) { 
function get Servers ( ) { var interfaces = os . network Interfaces ( ) var result = [ ] for ( var key in interfaces ) { var addresses = interfaces [ key ] for ( var i = addresses . length ; i - - ; ) { var address = addresses [ i ] if ( address . family = = = 'IPv 4 ' & & ! address . internal ) { var subnet = ip . subnet ( address . address , address . netmask ) var current = ip . to Long ( subnet . first Address ) var last = ip . to Long ( subnet . last Address ) - 1 while ( current + + < last ) result . push ( ip . from Long ( current ) ) } } } return result } 
function ping Server ( address ) { return new Promise ( function ( resolve ) { var socket = new net . Socket ( ) socket . set Timeout ( 1 0 0 0 , close ) socket . connect ( 8 0 , address , close ) socket . once ( 'error ' , close ) function close ( ) { socket . destroy ( ) resolve ( address ) } } ) } 
function parse All ( data ) { if ( ! data | | ! data [ 0 ] ) { return [ ] } if ( process . platform . includes ( 'linux ' ) ) { var rows = data [ 0 ] . split ( ' \n ' ) return rows . map ( function ( row ) { return parse Linux ( row , servers ) } ) . filter ( Boolean ) } else if ( process . platform . includes ( 'win 3 2 ' ) ) { var win Rows = data [ 0 ] . split ( ' \n ' ) . splice ( 1 ) return win Rows . map ( function ( row ) { return parse Win 3 2 ( row , servers ) } ) . filter ( Boolean ) } return data [ 0 ] . trim ( ) . split ( ' \n ' ) . map ( function ( row ) { return parse Row ( row , servers ) } ) . filter ( Boolean ) } 
function parse One ( data ) { if ( ! data | | ! data [ 0 ] ) { return } if ( process . platform . includes ( 'linux ' ) ) { 
function create Webpack ( { alias = { } , context , name = 'index ' } ) { const pkg Json = require ( path . join ( context , 'package .json ' ) ) ; const ENV = process . env . NODE _ENV | | 'development ' ; const is Prod = ENV = = = 'production ' ; const has Public = fs . exists Sync ( path . join ( context , 'public ' ) ) ; const plugins = has Public ? [ new Copy Webpack Plugin ( [ { from : 'public ' } ] ) ] : [ ] ; return { context , devtool : is Prod ? 'source -map ' : 'cheap -eval -source -map ' , entry : [ ` $ { name } ` , is Prod ? null : 'webpack -plugin -serve /client ' ] . filter ( ( entry ) = > entry ) , mode : ENV , output : { chunk Filename : ` ` , filename : ` ` , global Object : ` ` , path : path . join ( context , 'build ' ) } , resolve : { alias : { . . . alias , 'koa ' : 'empty ' , 'koa -websocket ' : 'empty ' , 'node -lmdb ' : 'empty ' , 'package -json ' : 'empty ' , 'snappy ' : 'empty ' } , extensions : [ ' .js ' , ' .jsx ' , ' .ts ' , ' .tsx ' ] } , module : { rules : [ { test : / \ . (js |ts |tsx ) $ / , exclude : / (node _modules ) / , use : [ require . resolve ( 'thread -loader ' ) , { loader : require . resolve ( 'babel -loader ' ) , options : require ( ' @polkadot /dev -react /config /babel ' ) } ] } , { test : [ / \ .bmp $ / , / \ .gif $ / , / \ .jpe ?g $ / , / \ .png $ / ] , use : [ { loader : require . resolve ( 'url -loader ' ) , options : { limit : 1 0 0 0 0 , name : 'static / [name ] . [hash : 8 ] . [ext ] ' } } ] } , { test : [ / \ .eot $ / , / \ .ttf $ / , / \ .svg $ / , / \ .woff $ / , / \ .woff 2 $ / ] , use : [ { loader : require . resolve ( 'file -loader ' ) , options : { name : 'static / [name ] . [hash : 8 ] . [ext ] ' } } ] } ] } , node : { child _process : 'empty ' , dgram : 'empty ' , fs : 'empty ' , net : 'empty ' , tls : 'empty ' } , optimization : { runtime Chunk : 'single ' , split Chunks : { cache Groups : { vendor Other : { chunks : 'initial ' , enforce : true , name : 'vendor ' , test : / node _modules \ / (asn 1 |bn \ .js |buffer |cuint |elliptic |lodash |moment |readable -stream |rxjs ) / } , vendor React : { chunks : 'initial ' , enforce : true , name : 'react ' , test : / node _modules \ / (i 1 8next |react ) / } } } } , performance : { hints : false } , plugins : plugins . concat ( [ new webpack . Ignore Plugin ( / ^ \ . \ /locale $ / , / moment $ / ) , new webpack . Define Plugin ( { 'process .env ' : { NODE _ENV : JSON . stringify ( ENV ) , VERSION : JSON . stringify ( pkg Json . version ) , DEBUG : JSON . stringify ( DEBUG ) } } ) , new Html Webpack Plugin ( { inject : true , template : path . join ( context , ` $ { has Public ? 'public / ' : ' ' } $ { name } ` ) , PAGE _TITLE : 'PRE Light Client ' } ) , new webpack . optimize . Split Chunks Plugin ( ) , new Webpack Plugin Serve ( { live Reload : true , port : 3 0 0 0 , static : path . join ( process . cwd ( ) , ' /build ' ) } ) ] ) , watch : ! is Prod } ; } 
function time Passed ( t ) { if ( t > 0 ) this . find ( " .wcp -time -current " ) . text ( parse Time ( t , this . vlc . length ) ) ; else if ( this . find ( " .wcp -time -current " ) . text ( ) ! = " " & & this . find ( " .wcp -time -total " ) . text ( ) = = " " ) this . find ( " .wcp -time -current " ) . text ( " " ) ; if ( typeof opts [ this . context ] . subtitles = = = 'undefined ' ) opts [ this . context ] . subtitles = [ ] ; if ( opts [ this . context ] . subtitles . length > 0 ) { 
function single Resize ( width , height ) { this . canvas . width = width ; this . canvas . height = height ; var container = $ ( this . context ) , canvas Parent = $ ( this . canvas ) . parent ( ) [ 0 ] ; if ( opts [ this . context ] . aspect Ratio ! = "Default " & & opts [ this . context ] . aspect Ratio . index Of ( " : " ) > - 1 ) { var res = opts [ this . context ] . aspect Ratio . split ( " : " ) ; var ratio = gcd ( this . canvas . width , this . canvas . height ) ; } var dest Aspect = container . width ( ) / container . height ( ) ; if ( ratio ) var source Aspect = ( ratio * parse Float ( res [ 0 ] ) ) / ( ratio * parse Float ( res [ 1 ] ) ) ; else var source Aspect = this . canvas . width / this . canvas . height ; if ( opts [ this . context ] . crop ! = "Default " & & opts [ this . context ] . crop . index Of ( " : " ) > - 1 ) { var res = opts [ this . context ] . crop . split ( " : " ) ; var ratio = gcd ( this . canvas . width , this . canvas . height ) ; var source Aspect = ( ratio * parse Float ( res [ 0 ] ) ) / ( ratio * parse Float ( res [ 1 ] ) ) ; } var cond = dest Aspect > source Aspect ; if ( opts [ this . context ] . crop ! = "Default " & & opts [ this . context ] . crop . index Of ( " : " ) > - 1 ) { if ( cond ) { canvas Parent . style . height = " 1 0 0 % " ; canvas Parent . style . width = ( ( ( container . height ( ) * source Aspect ) / container . width ( ) ) * 1 0 0 ) + " % " ; } else { canvas Parent . style . height = ( ( ( container . width ( ) / source Aspect ) / container . height ( ) ) * 1 0 0 ) + " % " ; canvas Parent . style . width = " 1 0 0 % " ; } var source Aspect = this . canvas . width / this . canvas . height ; future Width = ( ( ( canvas Parent . offset Height * source Aspect ) / canvas Parent . offset Width ) * canvas Parent . offset Width ) ; if ( future Width < canvas Parent . offset Width ) { var source Aspect = this . canvas . height / this . canvas . width ; this . canvas . style . width = canvas Parent . offset Width + "px " ; this . canvas . style . height = ( ( ( canvas Parent . offset Width * source Aspect ) / canvas Parent . offset Height ) * canvas Parent . offset Height ) + "px " ; } else { this . canvas . style . height = canvas Parent . offset Height + "px " ; this . canvas . style . width = ( ( ( canvas Parent . offset Height * source Aspect ) / canvas Parent . offset Width ) * canvas Parent . offset Width ) + "px " ; } } else { if ( cond ) { canvas Parent . style . height = ( 1 0 0 * opts [ this . context ] . zoom ) + " % " ; canvas Parent . style . width = ( ( ( container . height ( ) * source Aspect ) / container . width ( ) ) * 1 0 0 * opts [ this . context ] . zoom ) + " % " ; } else { canvas Parent . style . height = ( ( ( container . width ( ) / source Aspect ) / container . height ( ) ) * 1 0 0 * opts [ this . context ] . zoom ) + " % " ; canvas Parent . style . width = ( 1 0 0 * opts [ this . context ] . zoom ) + " % " ; } this . canvas . style . height = " 1 0 0 % " ; this . canvas . style . width = " 1 0 0 % " ; } } 
function ( opts ) { var fs = require ( 'fs ' ) ; if ( opts . config File ) { try { config = JSON . parse ( fs . read File Sync ( opts . config File , 'utf - 8 ' ) ) ; if ( config ) { for ( var key in opts ) { if ( typeof opts [ key ] ! = = 'undefined ' ) { config [ key ] = opts [ key ] ; } } } opts = config ; } catch ( e ) { throw new Error ( 'Could not read or parse configuration file - ' + e ) ; } delete opts . config File ; } return opts ; } 
function ( opts ) { opts . selenium = opts . selenium | | 'http : / /localhost : 4 4 4 4 /wd /hub ' ; if ( typeof opts . selenium = = = 'string ' ) { if ( opts . selenium = = = 'ondemand .saucelabs .com ' | | opts . selenium = = = 'hub .browserstack .com ' ) { opts . selenium = opts . selenium + ' /wd /hub ' ; } if ( ! opts . selenium . match ( / ^http (s ) ? : \ / \ / / ) ) { opts . selenium = 'http : / / ' + opts . selenium } var url = require ( 'url ' ) ; opts . selenium = url . parse ( opts . selenium ) ; } if ( typeof opts . username ! = = 'undefined ' ) { opts . selenium . user = opts . username ; } if ( typeof opts . accesskey ! = = 'undefined ' ) { opts . selenium . pwd = opts . accesskey ; } if ( typeof opts . selenium . port ! = = 'number ' ) { opts . selenium . port = parse Int ( opts . selenium . port , 1 0 ) ; } if ( is Na N ( opts . selenium . port ) ) { opts . selenium . port = null ; } return opts ; } 
function ( opts ) { var browser Config = { } ; 
function ( opts ) { opts . accesskey = opts . accesskey | | opts . password ; delete opts . password ; if ( opts . selenium . hostname . match ( / ondemand .saucelabs .com / ) ) { opts . SAUCE _USERNAME = opts . SAUCE _USERNAME | | opts . username ; opts . SAUCE _ACCESSKEY = opts . SAUCE _ACCESSKEY | | opts . accesskey ; if ( typeof opts . SAUCE _USERNAME ! = = 'undefined ' & & typeof opts . SAUCE _ACCESSKEY ! = = 'undefined ' ) { opts . selenium . auth = opts . SAUCE _USERNAME + ' : ' + opts . SAUCE _ACCESSKEY ; delete opts . SAUCE _ACCESSKEY ; delete opts . SAUCE _USERNAME ; } } else if ( opts . selenium . hostname . match ( / hub .browserstack .com / ) ) { opts . BROWSERSTACK _USERNAME = opts . BROWSERSTACK _USERNAME | | opts . username ; opts . BROWSERSTACK _KEY = opts . BROWSERSTACK _KEY | | opts . accesskey ; if ( typeof opts . BROWSERSTACK _USERNAME ! = = 'undefined ' ) { opts . browsers . for Each ( function ( browser ) { browser [ 'browserstack .user ' ] = opts . BROWSERSTACK _USERNAME ; browser [ 'browserstack .key ' ] = opts . BROWSERSTACK _KEY ; } ) ; delete opts . BROWSERSTACK _USERNAME ; delete opts . BROWSERSTACK _KEY ; delete opts . selenium . user ; delete opts . selenium . pwd ; } } delete opts . username ; delete opts . password ; return opts ; } 
function ( opts ) { if ( opts . pre Script File ) { var path = require ( 'path ' ) ; opts . pre Script = require ( path . resolve ( opts . pre Script File ) ) ; delete opts . pre Script File ; } opts . pre Script = opts . pre Script | | function ( browser ) { return ; } ; return opts ; } 
function ( opts ) { opts . actions = opts . actions | | 'scroll ' ; if ( typeof opts . actions = = = 'string ' ) { opts . actions = opts . actions . split ( / [ , ; ] / ) ; } else if ( typeof opts . actions = = = 'function ' ) { opts . actions = [ opts . actions ] ; } return opts ; } 
function ( opts ) { opts . metrics = opts . metrics | | require ( ' . /metrics ' ) . built Ins ; if ( typeof opts . metrics = = = 'string ' ) { opts . metrics = opts . metrics . split ( / [ , ; ] / ) ; } else if ( typeof opts . metrics = = = 'function ' ) { opts . metrics = [ opts . metrics ] ; } return opts ; } 
function Scroll Action ( opt _callback , opt _distance _func ) { var self = this ; this . begin Measuring Hook = function ( ) { } this . end Measuring Hook = function ( ) { } this . callback _ = opt _callback ; this . distance _func _ = opt _distance _func ; } 
function mock Xhr Generator ( file ) { var xhr = new Mock Http Request ( ) ; xhr . upload = { } ; xhr . onsend = function ( ) { if ( xhr . upload . onloadstart ) { xhr . upload . onloadstart ( ) ; } var total = file & & file . size | | 1 0 2 4 , done = 0 ; function start ( ) { set Timeout ( progress , 1 0 0 0 ) ; } function progress ( ) { xhr . upload . onprogress ( { total : total , loaded : done } ) ; if ( done < total ) { set Timeout ( progress , 2 0 0 ) ; done = Math . min ( total , done + 2 5 4 0 0 0 ) ; } else if ( ! file . abort ) { set Timeout ( finish , 1 0 0 0 ) ; } } function finish ( ) { xhr . receive ( 2 0 0 , ' { "message " : "OK " } ' ) ; } start ( ) ; } ; return xhr ; } 
function limit Update ( limit , update ) { la ( check . fn ( limit ) , 'expected limit function ' , limit ) const filter = R . filter ( version = > limit ( update . name , version ) ) return R . evolve ( { versions : filter } ) ( update ) } 
function filter Versions ( from Version , to Version ) { var diff = semver . diff ( from Version , to Version ) 
function get Local Module Version ( name ) { check . verify . string ( name , 'missing name string ' ) try { var filename = path . join ( 'node _modules ' , name , 'package .json ' ) var contents = fs . read File Sync ( filename , 'utf - 8 ' ) var pkg = JSON . parse ( contents ) return pkg . version } catch ( error ) { console . error ( 'could not fetch version for local module ' , name ) console . error ( error ) return null } } 
function clean Version Pair ( name Version ) { check . verify . array ( name Version , 'expected an array ' ) console . assert ( name Version . length = = = 2 , 'expected 2 items , name and version ' + name Version ) var name = name Version [ 0 ] check . verify . string ( name , 'could not get module name from ' + name Version ) var version = name Version [ 1 ] check . verify . string ( version , 'could not get module version from ' + name Version ) version = clean Version ( version , name ) if ( ! version ) { return } name Version [ 1 ] = version return name Version } 
function fetch Versions ( options , name Version ) { 
function next Versions ( options , name Version Pairs , check Latest Only ) { check . verify . object ( options , 'expected object with options ' ) check . verify . array ( name Version Pairs , 'expected array ' ) name Version Pairs = clean Versions ( name Version Pairs ) const verbose = verbose Log ( options ) verbose ( 'checking NPM registry ' ) var MAX _CHECK _TIMEOUT = options . check Version Timeout | | 1 0 0 0 0 var fetch Promises = name Version Pairs . map ( fetch Versions . bind ( null , options ) ) var fetch All Promise = q . all ( fetch Promises ) . timeout ( MAX _CHECK _TIMEOUT , 'timed out waiting for NPM after ' + MAX _CHECK _TIMEOUT + 'ms ' ) return fetch All Promise . then ( _ . partial ( filter Fetched Versions , check Latest Only ) , q . reject ) } 
function revert ( module Name ) { if ( module Name ) { console . log ( 'reverting module ' , JSON . stringify ( module Name ) ) } var to Check = get Dependencies To Check ( { } , module Name ) debug ( 'need to check ' ) debug ( to Check ) var install Promises = to Check . map ( function ( info ) { la ( is Revert Info ( info ) , 'invalid revert info ' , info ) return install Module . bind ( null , { name : info . name , version : info . version , tldr : false } ) } ) return install Promises . reduce ( q . when , q ( ) ) } 
function install Module ( options , results ) { check . verify . object ( options , 'missing options ' ) la ( check . unempty String ( options . name ) , 'expected module name string ' , options . name , 'all options ' , options ) check . verify . string ( options . version , 'expected version string ' ) if ( options . keep ) { console . assert ( typeof options . keep = = = 'boolean ' , 'invalid keep ' ) } if ( results ) { check . verify . array ( results , 'missing results ' ) } var cmd = form Install Command ( [ [ { name : options . name , version : options . version , works : true } ] ] ) check . verify . unempty String ( cmd , 'could not form install command ' ) cmd = cmd . trim ( ) var module Version = options . name + ' @ ' + options . version var npm if ( options . keep ) { console . log ( ' ' , cmd ) var args = cmd . split ( ' ' ) args . shift ( ) args . push ( ' - -save -exact ' ) npm = spawn ( NPM _PATH , args ) } else { if ( ! options . tldr ) { console . log ( ' installing ' , module Version ) } npm = spawn ( NPM _PATH , [ 'install ' , module Version ] ) } / / eslint -disable -next -line no -unused -vars var test Output = ' ' var test Errors = ' ' npm . stdout . set Encoding ( 'utf - 8 ' ) npm . stderr . set Encoding ( 'utf - 8 ' ) function has Error ( str ) { return / error / i . test ( str ) } npm . stdout . on ( 'data ' , function ( data ) { if ( has Error ( data ) ) { console . log ( 'stdout : ' , data ) } test Output + = data } ) npm . stderr . on ( 'data ' , function ( data ) { if ( has Error ( data ) ) { console . log ( 'stderr : ' , data ) } test Errors + = data } ) npm . on ( 'error ' , function ( err ) { console . error ( 'error : ' , err ) test Errors + = err . to String ( ) } ) var deferred = q . defer ( ) npm . on ( 'exit ' , function ( code ) { if ( code ) { console . error ( 'npm returned ' , code ) console . error ( 'errors : \n ' + test Errors ) deferred . reject ( { code : code , errors : test Errors } ) } else { if ( ! options . tldr ) { console . log ( module Version , 'installed successfully ' ) } deferred . resolve ( results ) } } ) return deferred . promise } 
function available ( module Name , options ) { options = options | | { } var to Check = get Dependencies To Check ( options , module Name ) la ( check . array ( to Check ) , 'expected object of deps to check , was ' , to Check ) var to Check Hash = _ . zip Object ( _ . pluck ( to Check , 'name ' ) , _ . pluck ( to Check , 'version ' ) ) log ( 'need to check these dependencies ' ) log ( to Check Hash ) var next Versions Promise = next Versions ( options , to Check ) return next Versions Promise . then ( function ( info ) { return report Available ( info , to Check Hash , options ) } , function ( error ) { console . error ( 'Could not fetch available modules \n ' , error ) } ) } 
function check All Updates ( options ) { options = options | | { } var module Name = options . names var check Latest Only = ! ! options . latest var check Command = options . test Command if ( check Command ) { verify . unempty String ( check Command , 'invalid test command ' + check Command ) } var all = options . all if ( all ) { check Latest Only = true console . log ( 'will check only latest versions because testing all ' ) } if ( check . string ( options . without ) ) { options . without = [ options . without ] } if ( check . string ( module Name ) ) { module Name = [ module Name ] } check Latest Only = ! ! check Latest Only if ( check Command ) { check . verify . string ( check Command , 'expected string test command ' ) } var to Check = get Dependencies To Check ( options , module Name ) check . verify . array ( to Check , 'dependencies to check should be an array ' ) make Sure Valid Module ( module Name , to Check ) var test Versions Bound = test Versions . bind ( null , { modules : to Check , command : check Command , all : all , color : options . color , keep : options . keep , allowed : options . allow | | options . allowed , tldr : options . tldr , type : options . type , limit : options . limit } ) return is Online ( ) . then ( function ( online ) { if ( ! online ) { throw new Error ( 'Need to be online to check new modules ' ) } } ) . then ( function ( ) { if ( is Single Specific Version ( module Name ) ) { var nv = name Version Parser ( module Name [ 0 ] ) console . log ( 'checking only specific : ' , nv . name , nv . version ) var list = [ { name : nv . name , versions : [ nv . version ] } ] return test Versions Bound ( list ) } else { var next Versions Promise = next Versions ( options , to Check , check Latest Only ) return next Versions Promise . then ( test Versions Bound ) } } ) } 
function print Current Modules ( infos ) { check . verify . array ( infos , 'expected array of modules ' ) var modules = [ ] infos . for Each ( function ( name Version Array ) { check . verify . array ( name Version Array , 'expected name version in ' + modules ) modules . push ( { name : name Version Array [ 0 ] , version : name Version Array [ 1 ] } ) } ) print ( modules ) } 
function serialize Methods ( o ) { var v ; for ( var k in o ) { v = o [ k ] ; if ( _ . is Object ( v ) & & ! _ . is Array ( v ) & & ! _ . is Function ( v ) ) { serialize Methods ( v ) ; } else { o [ k ] = serialize Functions ( v ) ; } } } 
function get Arp Table ( callback ) { var arp = spawn ( 'arp ' , [ ' -a ' ] ) var arp Str = [ ] arp . stdout . set Encoding ( 'utf 8 ' ) arp . stdout . on ( 'data ' , function ( data ) { arp Str . push ( data ) } ) arp . on ( 'close ' , function ( x ) { callback ( null , parse Arp Table ( arp Str ) ) 
function parse Arp Table ( arp Str ) { var arp Arr = [ ] var arpt = arp Str . join ( ) arpt = arpt . split ( ' \n ' ) var x for ( x in arpt ) { var entry = arpt [ x ] var arp Obj = { } 
function storage For ( key , model Name , options = { } ) { if ( arguments . length = = = 2 & & typeof model Name = = = 'object ' ) { options = model Name ; model Name = null ; } assert ( 'The options argument must be an object ' , typeof options = = = 'object ' ) ; 
function create Storage ( context , key , model Key , options ) { const owner = get Owner ( context ) ; const factory Type = 'storage ' ; const storage Factory = ` $ { factory Type } $ { key } ` ; let storage Key ; owner . register Options For Type ( factory Type , { instantiate : false } ) ; if ( options . legacy Key ) { deprecate ( 'Using legacy Key has been deprecated and will be removed in version 2 . 0 . 0 ' , false , { id : 'ember -local -storage .storage For .options .legacy Key ' , until : ' 2 . 0 . 0 ' , url : 'https : / /github .com /funkensturm /ember -local -storage #deprecations ' } ) ; storage Key = options . legacy Key ; } else { storage Key = model Key ? ` $ { storage Factory } $ { model Key } ` : storage Factory ; } storage Key = _build Key ( context , storage Key ) ; const initial State = { } , default State = { _storage Key : storage Key } , Storage Factory = owner . lookup ( storage Factory ) ; if ( ! Storage Factory ) { throw new Type Error ( ` $ { storage Factory } ` ) ; } if ( typeof ( Storage Factory . initial State ) = = = 'function ' ) { initial State . _initial Content = Storage Factory . initial State . call ( context ) ; } else if ( Storage Factory . initial State ) { throw new Type Error ( 'initial State property must be a function ' ) ; } assign ( initial State , default State ) ; if ( Storage Factory . create ) { return Storage Factory . create ( initial State ) ; } return Ember . Object . create ( Storage Factory ) ; } 
function _get Namespace ( app Config , addon Config ) { 
function _build Key ( context , key ) { let app Config = get Owner ( context ) . resolve Registration ( 'config :environment ' ) ; let addon Config = app Config & & app Config [ 'ember -local -storage ' ] | | { } ; let namespace = _get Namespace ( app Config , addon Config ) ; let delimiter = addon Config . key Delimiter | | ' : ' ; return namespace ? ` $ { namespace } $ { delimiter } $ { key } ` : key ; } 
function build Xml Input ( options ) { debug ( 'build Xml Input ' , options ) ; var data = { } , root ; var params = options . params | | { } ; root = data [ options . op Type + 'Request ' ] = [ ] ; 
function _to Json ( next ) { options . xml Converter ( response . body , options , function ( error , data ) { if ( error ) return next ( error ) ; debug ( 'Parsed XML ' , data ) ; timer ( 'time to parsed XML ' , Date . now ( ) - _start Time ) ; next ( null , data ) ; } ) ; } 
function items Callback ( error , items Response ) { if ( error ) throw error ; var items = items Response . search Result . item ; console . log ( 'Found ' , items . length , 'items ' ) ; for ( var i = 0 ; i < items . length ; i + + ) { console . log ( ' - ' + items [ i ] . title ) ; } } 
function _is Array Of Value Pairs ( el ) { if ( _ . is Array ( el ) ) { if ( _ . all ( el , _is Value Pair ) ) return true ; } return false ; } 
function _is Value Pair ( el ) { if ( _ . is Object ( el ) & & _ . size ( el ) = = = 2 ) { var keys = _ . keys ( el ) ; if ( new Reg Exp ( / ^ @ / ) . test ( keys [ 0 ] ) & & keys [ 1 ] = = = ' _ _value _ _ ' ) { return true ; } } return false ; } 
function _can Flatten Key ( key , request Context ) { 
function _flatten Silly Array ( parent Obj , key , request Context ) { 
function get Exe ( ) { switch ( process . platform ) { case "darwin " : return "mkcert - " + MKCERT _VERSION + " -darwin -amd 6 4 " case "linux " : return "mkcert - " + MKCERT _VERSION + " -linux -amd 6 4 " case "win 3 2 " : return "mkcert - " + MKCERT _VERSION + " -windows -amd 6 4 .exe " default : console . warn ( "Cannot generate the localhost certificate on your " + "platform . Please , consider contacting the developer if you can help . " ) process . exit ( 0 ) } } 
function download ( url , path ) { console . log ( "Downloading the mkcert executable . . . " ) const file = fs . create Write Stream ( path ) return new Promise ( resolve = > { function get ( url , file ) { https . get ( url , ( response ) = > { if ( response . status Code = = = 3 0 2 ) get ( response . headers . location , file ) else response . pipe ( file ) . on ( "finish " , resolve ) } ) } get ( url , file ) } ) } 
function mkcert ( app Data Path , exe ) { const log Path = path . join ( app Data Path , "mkcert .log " ) const err Path = path . join ( app Data Path , "mkcert .err " ) 
function remove ( app Data Path = CERT _PATH ) { if ( fs . exists Sync ( app Data Path ) ) { fs . readdir Sync ( app Data Path ) . for Each ( file = > fs . unlink Sync ( path . join ( app Data Path , file ) ) ) fs . rmdir Sync ( app Data Path ) } } 
function is Breaking Change ( { header , body , footer } ) { const re = / ^BREAKING \s +CHANGES ? : \s + / ; return ( re . test ( header . subject ) | | re . test ( body | | ' ' ) | | re . test ( footer | | ' ' ) ) ; } 
function track ( tracking Fn , options = { send Return Value : true } ) { let decorator = function ( target , name , descriptor ) { const has Descriptor = typeof descriptor . value ! = = "undefined " ; const fn = has Descriptor ? descriptor . value : target ; function track Decorator ( ) { let fn Return Value = fn . apply ( this , arguments ) , value = null ; if ( options . send Return Value ) { value = fn Return Value ; } track Event ( typeof tracking Fn = = = "string " ? Object . assign ( { name : tracking Fn , data : value } , options ) : tracking Fn . apply ( this , [ value ] ) ) ; return fn Return Value ; } ; if ( has Descriptor ) { descriptor . value = track Decorator ; } else { target = track Decorator ; } } ; decorator . send Return Value = function ( value = true ) { options . send Return Value = ! ! value ; return this ; } ; return decorator ; } 
function clone ( v ) { if ( v = = = null | | typeof v ! = = "object " ) { return v ; } if ( is Array ( v ) ) { var arr = v . slice ( ) ; for ( var i = 0 ; i < v . length ; i + + ) { arr [ i ] = clone ( arr [ i ] ) ; } return arr ; } else { var obj = { } ; for ( var k in v ) { obj [ k ] = clone ( v [ k ] ) ; } return obj ; } } 
function alert V 2 ( ) { var base URL = ' /v 2 /alerts / ' ; var saved Searchbase URL = base URL + "saved -searches / " ; var close Action Path = " /close / " ; var acknowledge Action Path = " /acknowledge / " ; var un Acknowledge Action Path = " /unacknowledge / " ; var add Note Action Path = " /notes / " ; var snooze Action Path = " /snooze / " ; var escalate To Next Action Path = " /escalate / " ; var assign Action Path = " /assign / " ; var add Team Action Path = " /teams / " ; var tags Action Path = " /tags / " ; var details Action Path = " /details / " ; var custom Action Path = " /actions / " ; var recipients Path = " /recipients / " ; var list Logs Path = " /logs / " ; var list Notes Path = " /notes / " ; return { get : function ( identifier , config , cb ) { var path = api . get Path ( base URL , identifier , null ) ; api . get ( path , config , cb ) } , create : function ( data , config , cb ) { api . post ( base URL , data , config , cb ) } , delete : function ( identifier , config , cb ) { var path = api . get Path ( base URL , identifier , null ) ; api . delete ( path , config , cb ) } , get Request Status : function ( request Id , config , cb ) { var path = base URL + "requests / " + request Id ; api . get ( path , config , cb ) } , list : function ( params , config , cb ) { var path = api . get Path With List Params ( base URL , params ) ; api . get ( path , config , cb ) } , acknowledge : function ( identifier , data , config , cb ) { var path = api . get Path ( base URL , identifier , acknowledge Action Path ) ; api . post ( path , data , config , cb ) ; } , close : function ( identifier , data , config , cb ) { var path = api . get Path ( base URL , identifier , close Action Path ) ; api . post ( path , data , config , cb ) ; } , add Note : function ( identifier , data , config , cb ) { var path = api . get Path ( base URL , identifier , add Note Action Path ) ; api . post ( path , data , config , cb ) ; } , unacknowledge : function ( identifier , data , config , cb ) { var path = api . get Path ( base URL , identifier , un Acknowledge Action Path ) ; api . post ( path , data , config , cb ) ; } , snooze : function ( identifier , data , config , cb ) { var path = api . get Path ( base URL , identifier , snooze Action Path ) ; api . post ( path , data , config , cb ) ; } , escalate To Next : function ( identifier , data , config , cb ) { var path = api . get Path ( base URL , identifier , escalate To Next Action Path ) ; api . post ( path , data , config , cb ) ; } , assign : function ( identifier , data , config , cb ) { var path = api . get Path ( base URL , identifier , assign Action Path ) ; api . post ( path , data , config , cb ) ; } , add Team : function ( identifier , data , config , cb ) { var path = api . get Path ( base URL , identifier , add Team Action Path ) ; api . post ( path , data , config , cb ) ; } , add Tags : function ( identifier , data , config , cb ) { var path = api . get Path ( base URL , identifier , tags Action Path ) ; api . post ( path , data , config , cb ) ; } , remove Tags : function ( identifier , data , config , cb ) { if ( data . tags = = = undefined ) { return new Error ( "tags param can not be empty . " ) ; } var path = api . get Path With Data ( base URL , identifier , tags Action Path , data ) ; api . delete ( path , config , cb ) ; } , add Details : function ( identifier , data , config , cb ) { var path = api . get Path ( base URL , identifier , details Action Path ) ; api . post ( path , data , config , cb ) ; } , remove Details : function ( identifier , data , config , cb ) { if ( data . keys = = = undefined ) { return new Error ( "details param can not be empty . " ) ; } var path = api . get Path With Data ( base URL , identifier , details Action Path , data ) ; api . delete ( path , config , cb ) ; } , execute Action : function ( identifier , data , config , cb ) { if ( data . action = = = undefined ) { return new Error ( "action param can not be empty . " ) ; } var path = api . get Path ( base URL , identifier , custom Action Path + data . action ) ; api . post ( path , data , config , cb ) ; } , list Alert Recipients : function ( identifier , config , cb ) { var path = api . get Path ( base URL , identifier , recipients Path ) ; api . get ( path , config , cb ) ; } , list Alert Logs : function ( identifier , data , config , cb ) { var path = api . get Path With Data ( base URL , identifier , list Logs Path , data ) ; api . get ( path , config , cb ) ; } , list Alert Notes : function ( identifier , data , config , cb ) { var path = api . get Path With Data ( base URL , identifier , list Notes Path , data ) ; api . get ( path , config , cb ) ; } , get Saved Search : function ( identifier , config , cb ) { var path = api . get Path ( saved Searchbase URL , identifier , null ) ; api . get ( path , config , cb ) } , create Saved Search : function ( data , config , cb ) { api . post ( saved Searchbase URL , data , config , cb ) } , update Saved Search : function ( identifier , data , config , cb ) { var path = api . get Path ( saved Searchbase URL , identifier , null ) ; api . patch ( path , data , config , cb ) } , list Saved Searches : function ( config , cb ) { api . get ( saved Searchbase URL , config , cb ) } } ; } 
function ( identifier , config , cb ) { var path = api . get Path ( base URL , identifier , null ) ; api . get ( path , config , cb ) } 
function ( request Id , config , cb ) { var path = base URL + "requests / " + request Id ; api . get ( path , config , cb ) } 
function ( params , config , cb ) { var path = api . get Path With List Params ( base URL , params ) ; api . get ( path , config , cb ) } 
function ( identifier , data , config , cb ) { if ( data . tags = = = undefined ) { return new Error ( "tags param can not be empty . " ) ; } var path = api . get Path With Data ( base URL , identifier , tags Action Path , data ) ; api . delete ( path , config , cb ) ; } 
function ( identifier , data , config , cb ) { var path = api . get Path ( base URL , identifier , details Action Path ) ; api . post ( path , data , config , cb ) ; } 
function ( identifier , data , config , cb ) { if ( data . keys = = = undefined ) { return new Error ( "details param can not be empty . " ) ; } var path = api . get Path With Data ( base URL , identifier , details Action Path , data ) ; api . delete ( path , config , cb ) ; } 
function ( identifier , data , config , cb ) { if ( data . action = = = undefined ) { return new Error ( "action param can not be empty . " ) ; } var path = api . get Path ( base URL , identifier , custom Action Path + data . action ) ; api . post ( path , data , config , cb ) ; } 
function ( identifier , data , config , cb ) { var path = api . get Path With Data ( base URL , identifier , list Logs Path , data ) ; api . get ( path , config , cb ) ; } 
function ( identifier , data , config , cb ) { var path = api . get Path ( saved Searchbase URL , identifier , null ) ; api . patch ( path , data , config , cb ) } 
function alert ( ) { var base URL = ' /v 1 /json /alert / ' ; var default Operations = [ 'get ' , 'list ' , 'create ' , 'delete ' , 'delete By Id ' ] ; var ops = { base URL : base URL , close : function ( data , config , cb ) { api . post ( this . base URL + 'close ' , data , config , cb ) ; } , count : function ( data , config , cb ) { api . get ( this . base URL + 'count ' , data , config , cb ) ; } , list Alert Notes : function ( data , config , cb ) { api . get ( this . base URL + 'note ' , data , config , cb ) ; } , list Alert Logs : function ( data , config , cb ) { api . get ( this . base URL + 'log ' , data , config , cb ) ; } , list Alert Recipients : function ( data , config , cb ) { api . get ( this . base URL + 'recipient ' , data , config , cb ) ; } , acknowledge : function ( data , config , cb ) { api . post ( this . base URL + 'acknowledge ' , data , config , cb ) ; } , snooze : function ( data , config , cb ) { api . post ( this . base URL + 'snooze ' , data , config , cb ) ; } , renotify : function ( data , config , cb ) { api . post ( this . base URL + 'renotify ' , data , config , cb ) ; } , take Ownership : function ( data , config , cb ) { api . post ( this . base URL + 'take Ownership ' , data , config , cb ) ; } , assign : function ( data , config , cb ) { api . post ( this . base URL + 'assign ' , data , config , cb ) ; } , add Team : function ( data , config , cb ) { api . post ( this . base URL + 'team ' , data , config , cb ) ; } , add Recipient : function ( data , config , cb ) { api . post ( this . base URL + 'recipient ' , data , config , cb ) ; } , add Note : function ( data , config , cb ) { api . post ( this . base URL + 'note ' , data , config , cb ) ; } , add Tags : function ( data , config , cb ) { api . post ( this . base URL + 'tags ' , data , config , cb ) ; } , remove Tags : function ( data , config , cb ) { if ( data . tags = = = undefined ) { return new Error ( "tags param can not be empty . " ) ; } api . delete ( this . base URL + 'tags ' , data , config , cb ) ; } , add Details : function ( data , config , cb ) { api . post ( this . base URL + 'details ' , data , config , cb ) ; } , remove Details : function ( data , config , cb ) { if ( data . keys = = = undefined ) { return new Error ( "details param can not be empty . " ) ; } api . delete ( this . base URL + 'details ' , data , config , cb ) ; } , execute Action : function ( data , config , cb ) { api . post ( this . base URL + 'execute Action ' , data , config , cb ) ; } } ; ops = operations . attach ( ops , default Operations ) ; return ops ; } 
function ( data , config , cb ) { if ( data . tags = = = undefined ) { return new Error ( "tags param can not be empty . " ) ; } api . delete ( this . base URL + 'tags ' , data , config , cb ) ; } 
function ( data , config , cb ) { if ( data . keys = = = undefined ) { return new Error ( "details param can not be empty . " ) ; } api . delete ( this . base URL + 'details ' , data , config , cb ) ; } 
function Buffered Metrics Logger ( opts ) { this . aggregator = opts . aggregator | | new Aggregator ( opts . default Tags ) ; this . reporter = opts . reporter | | new Data Dog Reporter ( opts . api Key , opts . app Key , opts . agent ) ; this . host = opts . host ; this . prefix = opts . prefix | | ' ' ; this . flush Interval Seconds = opts . flush Interval Seconds ; if ( this . flush Interval Seconds ) { debug ( 'Auto -flushing every %d seconds ' , this . flush Interval Seconds ) ; } else { debug ( 'Auto -flushing is disabled ' ) ; } var self = this ; var auto Flush Callback = function ( ) { self . flush ( ) ; if ( self . flush Interval Seconds ) { var interval = self . flush Interval Seconds * 1 0 0 0 ; var tid = set Timeout ( auto Flush Callback , interval ) ; 
function Metric ( key , tags , host ) { this . key = key ; this . tags = tags | | [ ] ; this . host = host | | ' ' ; } 
function Gauge ( key , tags , host ) { Metric . call ( this , key , tags , host ) ; this . value = 0 ; } 
function Counter ( key , tags , host ) { Metric . call ( this , key , tags , host ) ; this . value = 0 ; } 
function Histogram ( key , tags , host ) { Metric . call ( this , key , tags , host ) ; this . min = Infinity ; this . max = - Infinity ; this . sum = 0 ; this . count = 0 ; this . samples = [ ] ; this . percentiles = [ 0 . 7 5 , 0 . 8 5 , 0 . 9 5 , 0 . 9 9 ] ; } 
function init ( opts ) { opts = opts | | { } ; if ( ! opts . flush Interval Seconds & & opts . flush Interval Seconds ! = = 0 ) { opts . flush Interval Seconds = 1 5 ; } shared Logger = new loggers . Buffered Metrics Logger ( opts ) ; } 
function call On Shared Logger ( func Name ) { if ( shared Logger = = = null ) { init ( ) ; } var args = Array . prototype . slice . call ( arguments , 1 ) ; shared Logger [ func Name ] . apply ( shared Logger , args ) ; } 
function Data Dog Reporter ( api Key , app Key , agent ) { api Key = api Key | | process . env . DATADOG _API _KEY ; app Key = app Key | | process . env . DATADOG _APP _KEY ; if ( ! api Key ) { throw new Error ( 'DATADOG _API _KEY environment variable not set ' ) ; } 
async function optimize ( file ) { check ( file ) ; const name = get Name ( file ) ; log ( 'reading file ' + path . basename ( name ) ) ; const data = await read File ( name , 'utf 8 ' ) ; return on Data Read ( file , data ) ; } 
async function on Data Read ( filename , data ) { log ( 'file ' + path . basename ( filename ) + ' read ' ) ; const ext = path . extname ( filename ) . replace ( / ^ \ . / , ' ' ) ; const optimized Data = await minify [ ext ] ( data ) ; let b 6 4Optimize ; if ( ext = = = 'css ' ) [ , b 6 4Optimize ] = await try To Catch ( minify . img , filename , optimized Data ) ; return b 6 4Optimize | | optimized Data ; } 
function apply Options ( options ) { const settings = { } ; options = options | | { } ; Object . assign ( settings , defaults , options ) ; return settings ; } 
function redirect ( options , ctx ) { 
function factory ( options ) { options = apply Options ( options ) ; return ( ctx , next ) = > { 
function parse Forwarded ( value ) { const forwarded = { } value . trim ( ) . split ( ' ; ' ) . for Each ( ( part ) = > { const pair = part . trim ( ) . split ( ' = ' ) ; forwarded [ pair [ 0 ] ] = pair [ 1 ] ; } ) ; return forwarded ; } 
function forwarded Resolver ( ctx ) { const header = ctx . request . header [ 'forwarded ' ] ; if ( ! header ) { return false ; } else { const forwarded = parse Forwarded ( header ) ; return forwarded . proto = = = 'https ' ; } } 
function load Rc Config ( callback ) { const sync = typeof callback ! = = 'function ' ; if ( sync ) { const fp = rc Loader . for ( this . resource Path ) ; if ( typeof fp ! = = 'string ' ) { 
function infer Master ( ) { var inferred = _ . find ( self . nested Locales , { name : self . default Locale } ) | | self . nested Locales [ 0 ] ; if ( ( self . nested Locales . length > 1 ) & & ( ! _ . find ( self . nested Locales , function ( locale ) { return locale . children & & locale . children . length ; } ) ) ) { var others = _ . filter ( self . nested Locales , function ( locale ) { return locale . name ! = = inferred . name ; } ) ; self . nested Locales = [ inferred ] ; if ( others . length ) { inferred . children = others ; } } } 
function workflow Guid Workflow Locale ( ) { return self . apos . docs . db . ensure Index ( { workflow Guid : 1 , workflow Locale : 1 } , { sparse : 1 , unique : 1 } ) 
function replace Ids Recursively ( doc ) { _ . each ( doc , function ( val , key ) { if ( key = = = 'workflow Guid And Locale Duplicates ' ) { 
function fallback ( callback ) { return async . series ( [ via Basis , no Basis ] , callback ) ; function via Basis ( callback ) { return self . apos . migrations . each Doc ( { workflow Locale : basis } , 5 , function ( doc , callback ) { if ( ! self . include Type ( doc . type ) ) { return set Immediate ( callback ) ; } doc . workflow Resolve Deferred = true ; var after Save Options = _ . assign ( { } , options , { permissions : false , workflow Missing Locales Live : self . apos . argv . live ? true : 'live Only ' } ) ; return self . doc After Save ( req , doc , after Save Options , callback ) ; } , callback ) ; } function no Basis ( callback ) { var locale Names = Object . keys ( self . locales ) ; var orphans ; return async . series ( [ find , fix ] , callback ) ; function find ( callback ) { const query = [ { $match : { workflow Locale : { $in : locale Names } } } , { $group : { _id : " $workflow Guid " , count : { $sum : 1 } } } , { $match : { count : { $lt : locale Names . length } } } ] ; return self . apos . docs . db . aggregate ( query ) . to Array ( function ( err , _orphans ) { if ( err ) { return callback ( err ) ; } orphans = _orphans ; return callback ( null ) ; } ) ; } function fix ( callback ) { var seen = { } ; if ( ! orphans . length ) { return callback ( null ) ; } 
function get Workflow Guids ( callback ) { return self . apos . docs . db . find With Projection ( { _id : { $in : _ . pluck ( related , ' _id ' ) } } , { _id : 1 , workflow Guid : 1 , type : 1 } ) . to Array ( function ( err , guid Docs ) { if ( err ) { return fail ( err ) ; } _ . each ( guid Docs , function ( guid Doc ) { var related One = _ . find ( related , { _id : guid Doc . _id } ) ; if ( related One ) { related One . workflow Guid = guid Doc . workflow Guid ; ids By Guid [ related One . workflow Guid ] = related One . _id ; related One . type = guid Doc . type ; } } ) ; 
function resolve To Source ( callback ) { return async . series ( [ _ . partial ( self . resolve Relationships , req , draft , to . workflow Locale ) , _ . partial ( self . resolve Relationships , req , from , to . workflow Locale ) ] , callback ) ; } 
function cross Correct Pass ( callback ) { return async . series ( [ find , correct ] , callback ) ; function find ( callback ) { return self . apos . docs . db . find With Projection ( { parked Id : { $exists : 1 } } ) . to Array ( function ( err , _pages ) { if ( err ) { return callback ( err ) ; } pages = _pages ; return callback ( null ) ; } ) ; } function correct ( callback ) { var parked Ids By Workflow Guid = { } ; _ . each ( pages , function ( page ) { parked Ids By Workflow Guid [ page . workflow Guid ] = page . parked Id ; } ) ; return async . each Series ( _ . keys ( parked Ids By Workflow Guid ) , function ( workflow Guid , callback ) { return self . apos . docs . db . update ( { workflow Guid : workflow Guid } , { $set : { parked Id : parked Ids By Workflow Guid [ workflow Guid ] } } , { multi : true } , callback ) ; } , callback ) ; } } 
function get Content Type ( file ) { var mime Type = mime . lookup ( file . unzip Path | | file . path ) | | 'application /octet -stream ' ; var charset = mime . charset ( mime Type ) ; return charset ? mime Type + ' ; charset = ' + charset . to Lower Case ( ) : mime Type ; } 
function to Aws Params ( file ) { var params = { } ; var headers = file . s 3 . headers | | { } ; for ( var header in headers ) { if ( header = = = 'x -amz -acl ' ) { params . ACL = headers [ header ] ; } else if ( header = = = 'Content -MD 5 ' ) { params . Content MD 5 = headers [ header ] ; } else { params [ pascal Case ( header ) ] = headers [ header ] ; } } params . Key = file . s 3 . path ; params . Body = file . contents ; return params ; } 
function init File ( file ) { if ( ! file . s 3 ) { file . s 3 = { } ; file . s 3 . headers = { } ; file . s 3 . path = file . relative . replace ( / \ \ / g , ' / ' ) ; } return file ; } 
function file Should Be Deleted ( key , whitelist ) { for ( var i = 0 ; i < whitelist . length ; i + + ) { var expr = whitelist [ i ] ; if ( expr instanceof Reg Exp ) { if ( expr . test ( key ) ) { return false ; } } else if ( typeof expr = = = 'string ' ) { if ( expr = = = key ) { return false ; } } else { throw new Error ( 'whitelist param can only contain regular expressions or strings ' ) ; } } return true ; } 
function Publisher ( AWSConfig , cache Options ) { this . config = AWSConfig ; this . client = new AWS . S 3 ( AWSConfig ) ; var bucket = this . config . params . Bucket ; if ( ! bucket ) { throw new Error ( 'Missing `params .Bucket ` config value . ' ) ; } 
function Zarin Pal ( Merchant ID , sandbox ) { if ( typeof Merchant ID = = = 'string ' & & Merchant ID . length = = = config . merchant IDLength ) { this . merchant = Merchant ID ; } else { console . error ( 'The Merchant ID must be ' + config . merchant IDLength + ' Characters . ' ) ; return false ; } this . sandbox = sandbox | | false ; this . url = ( sandbox = = = true ) ? config . sandbox : config . https ; } 
function deferred ( ) { var out Resolve = function ( ) { } ; 
function load Node Struct ( xpub , version _public ) { string To UTF 8 ( xpub , _xpub , XPUB _SIZE ) ; if ( _hdnode _deserialize ( _xpub , version _public , 0 , _hdnode , 0 ) ! = = 0 ) { throw new Error ( "Wrong XPUB type ! ! " ) ; 
function process Message ( event ) { var data = event [ 'data ' ] ; var type = data [ 'type ' ] ; switch ( type ) { case 'derive Address Range ' : var addresses = derive Address Range ( data [ 'node ' ] , data [ 'first Index ' ] , data [ 'last Index ' ] , data [ 'version ' ] , data [ 'address Format ' ] ) ; self . post Message ( { 'addresses ' : addresses , 'first Index ' : data [ 'first Index ' ] , 'last Index ' : data [ 'last Index ' ] , 'i ' : data [ 'i ' ] } ) ; break ; case 'derive Node ' : var node = derive Node ( data [ 'xpub ' ] , data [ 'index ' ] , data [ 'version ' ] ) ; self . post Message ( { 'xpub ' : node , 'i ' : data [ 'i ' ] } ) ; break ; default : throw new Error ( 'Unknown message type : ' + type ) ; } } 
function format Error ( error : mixed ) : Error { if ( typeof error = = = 'object ' & & error ! = null & & error instanceof Error ) { return error ; } if ( typeof error = = = 'object ' & & error ! = null & & error . message ! = null ) { return new Error ( error . message ) ; } return new Error ( JSON . stringify ( error ) ) ; } 
function search ( effective Utxos , target , cost Of Change ) { if ( effective Utxos . length = = = 0 ) { return null ; } let tries = max Tries ; const selected = [ ] ; 
async function parse Response ( header , response , active = false , id ) { const rows = [ ] ; _ . each ( response , ( value , key ) = > { let row = [ ] ; if ( active ) { _ . each ( response [ key ] . active , ( active Value ) = > { row = [ ] ; 
async function display ( header , items , type , active = false , parse = false , id ) { let rows ; if ( type = = = 'txt ' ) { await text ( header , items ) ; } else if ( type = = = 'txt Horizontal ' ) { const opts = { head : header , chars : { top : ' ' , 'top -mid ' : ' ' , 'top -left ' : ' ' , 'top -right ' : ' ' , bottom : ' ' , 'bottom -mid ' : ' ' , 'bottom -left ' : ' ' , 'bottom -right ' : ' ' , left : ' ' , 'left -mid ' : ' ' , mid : ' ' , 'mid -mid ' : ' ' , right : ' ' , 'right -mid ' : ' ' , middle : ' ' . repeat ( 2 ) } , style : { 'padding -left ' : 0 , 'padding -right ' : 0 , head : [ 'white ' ] , border : [ 'white ' ] } } ; if ( parse ) { rows = await parse Response ( header , items , active , id ) ; await horizontal ( rows , opts ) ; } else { await horizontal ( items , opts ) ; } } else if ( type = = = 'pretty Horizontal ' ) { const opts = { head : header , style : { 'padding -left ' : 0 , 'padding -right ' : 0 , head : [ 'blue ' ] } } ; if ( parse ) { rows = await parse Response ( header , items , active , id ) ; await horizontal ( rows , opts ) ; } else { await horizontal ( items , opts ) ; } } else if ( type = = = 'txt Vertical ' ) { const style = { chars : { top : ' ' , 'top -mid ' : ' ' , 'top -left ' : ' ' , 'top -right ' : ' ' , bottom : ' ' , 'bottom -mid ' : ' ' , 'bottom -left ' : ' ' , 'bottom -right ' : ' ' , left : ' ' , 'left -mid ' : ' ' , mid : ' ' , 'mid -mid ' : ' ' , right : ' ' , 'right -mid ' : ' ' , middle : ' ' . repeat ( 3 ) } , style : { 'padding -left ' : 0 , 'padding -right ' : 0 , head : [ 'white ' ] } } ; if ( parse ) { rows = await parse Response ( header , items , active , id ) ; await vertical ( header , rows , style ) ; } else { await vertical ( header , items , style ) ; } } else if ( type = = = 'pretty Vertical ' ) { const style = { style : { 'padding -left ' : 0 , 'padding -right ' : 0 , head : [ 'blue ' ] } } ; if ( parse ) { rows = await parse Response ( header , items , active , id ) ; await vertical ( header , rows , style ) ; } else { await vertical ( header , items , style ) ; } } else { await pretty ( header , items ) ; } } 
function shutdown Handler ( context , shutdown Fn ) { const assignment = context . assignment | | process . env . NODE _TYPE | | process . env . assignment | | 'unknown -assignment ' ; const is Process Restart = process . env . process _restart ; const restart On Failure = assignment ! = = 'exectution _controller ' ; const api = { exiting : false , exit } ; const shutdown Timeout = _ . get ( context , 'sysconfig .teraslice .shutdown _timeout ' , 2 0 * 1 0 0 0 ) ; const events = context . apis . foundation . get System Events ( ) ; const logger = context . apis . foundation . make Logger ( { module : ` $ { assignment } ` } ) ; if ( assignment = = = 'execution _controller ' & & is Process Restart ) { logger . fatal ( 'Execution Controller runtime error led to a restart , terminating execution with failed status , please use the recover api to return slicer to a consistent state ' ) ; process . exit ( 0 ) ; } function flush Logs ( ) { return Promise . resolve ( ) . then ( ( ) = > this . logger . flush ( ) ) . then ( ( ) = > Promise . delay ( 1 0 0 0 ) ) ; } let start Time ; function exiting In ( ) { if ( ! api . exiting ) { return ` $ { shutdown Timeout } ` ; } const elapsed = Date . now ( ) - start Time ; return ` $ { shutdown Timeout - elapsed } ` ; } function exit ( event , err ) { if ( api . exiting ) return ; api . exiting = true ; start Time = Date . now ( ) ; Promise . race ( [ shutdown Fn ( event , err ) , Promise . delay ( shutdown Timeout - 2 0 0 0 ) ] ) . then ( ( ) = > { logger . info ( ` $ { assignment } $ { Date . now ( ) - start Time } ` ) ; } ) . catch ( ( error ) = > { logger . error ( ` $ { assignment } ` , error ) ; } ) . then ( ( ) = > { const code = process . exit Code | | 0 ; logger . trace ( ` $ { code } ` ) ; return flush Logs ( ) . finally ( ( ) = > { process . exit ( ) ; } ) ; } ) ; } process . on ( 'SIGINT ' , ( ) = > { logger . info ( ` $ { assignment } $ { exiting In ( ) } ` ) ; if ( ! api . exiting ) { process . exit Code = 0 ; } exit ( 'SIGINT ' ) ; } ) ; process . on ( 'SIGTERM ' , ( ) = > { logger . info ( ` $ { assignment } $ { exiting In ( ) } ` ) ; if ( ! api . exiting ) { process . exit Code = 0 ; } exit ( 'SIGTERM ' ) ; } ) ; process . on ( 'uncaught Exception ' , ( err ) = > { logger . fatal ( err , ` $ { assignment } $ { exiting In ( ) } ` ) ; if ( ! api . exiting ) { process . exit Code = restart On Failure ? 1 : 0 ; } exit ( 'uncaught Exception ' , err ) ; } ) ; process . once ( 'unhandled Rejection ' , ( err ) = > { logger . fatal ( err , ` $ { assignment } $ { exiting In ( ) } ` ) ; if ( ! api . exiting ) { process . exit Code = restart On Failure ? 1 : 0 ; } exit ( 'unhandled Rejection ' , err ) ; } ) ; 
function _get Cluster State ( ) { return k 8s . list ( 'app =teraslice ' , 'pods ' ) . then ( k 8s Pods = > k 8s State . gen ( k 8s Pods , cluster State , cluster Name Label ) ) . catch ( ( err ) = > { 
function allocate Slicer ( execution ) { const ex Svc Resource = new K 8s Resource ( 'services ' , 'execution _controller ' , context . sysconfig . teraslice , execution ) ; const ex Service = ex Svc Resource . resource ; execution . slicer _port = _ . get ( ex Service , 'spec .ports [ 0 ] .target Port ' ) ; execution . slicer _hostname = _ . get ( ex Service , 'metadata .name ' ) ; const ex Job Resource = new K 8s Resource ( 'jobs ' , 'execution _controller ' , context . sysconfig . teraslice , execution ) ; const ex Job = ex Job Resource . resource ; logger . debug ( ` \n \n $ { JSON . stringify ( ex Job , null , 2 ) } ` ) ; 
function allocate Workers ( execution ) { const kr = new K 8s Resource ( 'deployments ' , 'worker ' , context . sysconfig . teraslice , execution ) ; const worker Deployment = kr . resource ; logger . debug ( ` \n \n $ { JSON . stringify ( worker Deployment , null , 2 ) } ` ) ; return k 8s . post ( worker Deployment , 'deployment ' ) . then ( result = > logger . debug ( ` $ { JSON . stringify ( result ) } ` ) ) . catch ( ( err ) = > { const error = new TSError ( err , { reason : 'Error submitting k 8s worker deployment ' } ) ; return Promise . reject ( error ) ; } ) ; } 
async function add Workers ( execution Context , num Workers ) { await k 8s . scale Execution ( execution Context . ex _id , num Workers , 'add ' ) ; return { action : 'add ' , ex _id : execution Context . ex _id , worker Num : num Workers } ; } 
async function remove Workers ( ex Id , num Workers ) { await k 8s . scale Execution ( ex Id , num Workers , 'remove ' ) ; return { action : 'remove ' , ex _id : ex Id , worker Num : num Workers } ; } 
function make Prometheus ( stats , default Labels = { } ) { const metric Mapping = { processed : 'teraslice _slices _processed ' , failed : 'teraslice _slices _failed ' , queued : 'teraslice _slices _queued ' , job _duration : ' ' , 
function load Connector ( type ) { const local Path = ` $ { _ _dirname } $ { type } ` ; const paths = { } ; paths [ local Path ] = true ; paths [ type ] = true ; const err = ` $ { type } \n ` ; return get Module ( type , paths , err ) ; } 
function new Processor ( context , op Config , job Config ) { const job Logger = context . logger ; job Logger . info ( 'Drop _property asset loaded . ' ) ; return function processor ( data , slice Logger , msg ) { data . for Each ( ( doc ) = > { if ( doc . has Own Property ( op Config . property ) ) { delete doc [ op Config . property ] ; } } ) ; return data ; } ; } 
function get Offsets ( size , total , delimiter ) { if ( total = = = 0 ) { return [ ] ; } if ( total < size ) { return [ { length : total , offset : 0 } ] ; } const full Chunks = Math . floor ( total / size ) ; const delta = delimiter . length ; const length = size + delta ; const chunks = [ ] ; for ( let chunk = 1 ; chunk < full Chunks ; chunk + = 1 ) { chunks . push ( { length , offset : ( chunk * size ) - delta } ) ; } 
function get Chunk ( reader Client , slice , op Config , logger , metadata ) { const delimiter = op Config . line _delimiter ; async function get Margin ( offset , length ) { let margin = ' ' ; return new Promise ( async ( resolve ) = > { while ( margin . index Of ( delimiter ) = = = - 1 ) { 
function finish Execution ( ex Id , err ) { if ( err ) { const error = new TSError ( err , { reason : ` $ { ex Id } ` , context : { ex _id : ex Id , } } ) ; logger . error ( error ) ; } return get Execution Context ( ex Id ) . then ( ( execution ) = > { const status = execution . _status ; if ( [ 'stopping ' , 'stopped ' ] . includes ( status ) ) { logger . debug ( ` $ { ex Id } ` ) ; return true ; } logger . debug ( ` $ { ex Id } ` ) ; return cluster Service . stop Execution ( ex Id ) . catch ( ( stop Err ) = > { const stop Error = new TSError ( stop Err , { reason : 'error finishing the execution ' , context : { ex _id : ex Id , } } ) ; logger . error ( stop Error ) ; } ) ; } ) ; } 
function get Active Execution ( ex Id ) { const str = terminal Status List ( ) . map ( state = > ` $ { state } ` ) . join ( 'OR ' ) ; const query = ` $ { ex Id } $ { str . trim ( ) } ` ; return search Execution Contexts ( query , null , 1 , ' _created :desc ' ) . then ( ( ex ) = > { if ( ex . length = = = 0 ) { const error = new Error ( ` $ { ex Id } ` ) ; error . code = 4 0 4 ; return Promise . reject ( error ) ; } return ex [ 0 ] ; } ) ; } 
function register API ( name , api ) { if ( Object . prototype . has Own Property . call ( context . apis , name ) ) { throw new Error ( ` $ { name } ` ) ; } else { context . apis [ name ] = api ; } } 
function gen ( k 8s Pods , cluster State , cluster Name Label ) { 
function Node ( data , prev , next ) { this . next = next ; if ( next ) { next . prev = this ; } this . prev = prev ; if ( prev ) { prev . next = this ; } this . value = data ; } 
function error Handler ( err ) { 
function allocate Workers ( execution , num Of Workers Requested ) { const ex Id = execution . ex _id ; const job Id = execution . job _id ; const job Str = JSON . stringify ( execution ) ; const sorted Nodes = _ . order By ( cluster State , 'available ' , 'desc ' ) ; let workers Requested = num Of Workers Requested ; let avail Workers = _available Workers ( false , true ) ; const dispatch = _make Dispatch ( ) ; while ( workers Requested > 0 & & avail Workers > 0 ) { for ( let i = 0 ; i < sorted Nodes . length ; i + = 1 ) { 
function get Record ( record Id , index Arg , fields ) { logger . trace ( ` $ { record Id } ` ) ; const query = { index : index Arg | | index Name , type : record Type , id : record Id } ; if ( fields ) { query . _source = fields ; } return elasticsearch . get ( query ) ; } 
function create ( record , index Arg = index Name ) { logger . trace ( 'creating record ' , log Record ? record : null ) ; const query = { index : index Arg , type : record Type , id : record [ id Field ] , body : record , refresh : force Refresh } ; return elasticsearch . create ( query ) ; } 
function verify Status Update ( ex Id , desired Status ) { if ( ! desired Status | | ! _is Valid Status ( desired Status ) ) { const error = new Error ( ` $ { desired Status } ` ) ; error . status Code = 4 2 2 ; return Promise . reject ( error ) ; } return get Status ( ex Id ) . then ( ( status ) = > { 
function _attach Rooms Socket IO ( ) { if ( ! io ) return ; 
function _to Records ( raw Data , delimiter , slice ) { 
function raw ( incoming Data , logger , op Config , metadata , slice ) { const data = _to Records ( incoming Data , op Config . line _delimiter , slice ) ; return data . map ( ( record ) = > { try { return Data Entity . make ( { data : record } , metadata ) ; } catch ( err ) { if ( op Config . _dead _letter _action = = = 'log ' ) { logger . error ( err , 'Bad record : ' , record ) ; } else if ( op Config . _dead _letter _action = = = 'throw ' ) { throw err ; } return null ; } } ) ; } 
function tsv ( incoming Data , logger , op Config , metadata , slice ) { return csv ( incoming Data , logger , op Config , metadata , slice ) ; } 
function determine Worker ENV ( worker ) { const options = { } ; if ( worker . service _context ) { const env Config = JSON . parse ( worker . service _context ) ; _ . assign ( options , env Config ) ; options . _ _process _restart = true ; options . service _context = worker . service _context ; } return options ; } 
function Transform Stream Close Readable ( transform Stream ) { 
function Transform Stream Close Readable Internal ( transform Stream ) { assert ( transform Stream . _errored = = = false ) ; assert ( transform Stream . _readable Closed = = = false ) ; try { Readable Stream Default Controller Close ( transform Stream . _readable Controller ) ; } catch ( e ) { assert ( false ) ; } transform Stream . _readable Closed = true ; } 
function Transform Stream Readable Ready Promise ( transform Stream ) { assert ( transform Stream . _backpressure Change Promise ! = = undefined , ' _backpressure Change Promise should have been initialized ' ) ; if ( transform Stream . _backpressure = = = false ) { return Promise . resolve ( ) ; } assert ( transform Stream . _backpressure = = = true , ' _backpressure should have been initialized ' ) ; return transform Stream . _backpressure Change Promise ; } 
function pipe Loop ( ) { current Write = Promise . resolve ( ) ; if ( shutting Down = = = true ) { return Promise . resolve ( ) ; } return writer . _ready Promise . then ( ( ) = > { return Readable Stream Default Reader Read ( reader ) . then ( ( { value , done } ) = > { if ( done = = = true ) { return undefined ; } current Write = Writable Stream Default Writer Write ( writer , value ) ; return current Write ; } ) ; } ) . then ( pipe Loop ) ; } 
function Readable Stream Add Read Into Request ( stream ) { assert ( Is Readable Stream BYOBReader ( stream . _reader ) = = = true ) ; assert ( stream . _state = = = 'readable ' | | stream . _state = = = 'closed ' ) ; const promise = new Promise ( ( resolve , reject ) = > { const read Into Request = { _resolve : resolve , _reject : reject } ; stream . _reader . _read Into Requests . push ( read Into Request ) ; } ) ; return promise ; } 
function Readable Stream Reader Generic Cancel ( reader , reason ) { const stream = reader . _owner Readable Stream ; assert ( stream ! = = undefined ) ; return Readable Stream Cancel ( stream , reason ) ; } 
function Readable Stream Default Controller Close ( controller ) { const stream = controller . _controlled Readable Stream ; assert ( controller . _close Requested = = = false ) ; assert ( stream . _state = = = 'readable ' ) ; controller . _close Requested = true ; if ( controller . _queue . length = = = 0 ) { Readable Stream Close ( stream ) ; } } 
function Readable Byte Stream Controller Close ( controller ) { const stream = controller . _controlled Readable Stream ; assert ( controller . _close Requested = = = false ) ; assert ( stream . _state = = = 'readable ' ) ; if ( controller . _total Queued Bytes > 0 ) { controller . _close Requested = true ; return ; } if ( controller . _pending Pull Intos . length > 0 ) { const first Pending Pull Into = controller . _pending Pull Intos [ 0 ] ; if ( first Pending Pull Into . bytes Filled > 0 ) { const e = new Type Error ( 'Insufficient bytes to fill elements in the given buffer ' ) ; Readable Byte Stream Controller Error ( controller , e ) ; throw e ; } } Readable Stream Close ( stream ) ; } 
function through ( fn , keep Open ) { if ( keep Open = = = void 0 ) { keep Open = false ; } return duplex _ 1 . create Duplex ( function ( input , output ) { var next Input = function ( ) { input . next ( ) . then ( function ( _a ) { var value = _a . value ; if ( value = = null ) { if ( ! keep Open ) { return output . return ( ) ; } } return pump _ 1 . pump ( wrap _async _iterable _iterator _ 1 . wrap Async Iterable Iterator ( fn ( value ) ) , function ( value ) { return output . unshift ( value ) ; } ) . then ( next Input ) ; } ) ; } ; next Input ( ) ; } ) ; } 
function Stored Promise ( init ) { this . _resolve = value = > { this . _resolved = true ; this . _value = value } this . _reject = value = > { this . _rejected = true ; this . _value = value ; } init ( value = > { this . _resolve ( value ) } , value = > { this . _reject ( value ) } ) ; } 
function Writable Stream Add Write Request ( stream ) { assert ( Is Writable Stream Locked ( stream ) = = = true ) ; assert ( stream . _state = = = 'writable ' ) ; const promise = new Promise ( ( resolve , reject ) = > { const write Request = { _resolve : resolve , _reject : reject } ; stream . _write Requests . push ( write Request ) ; } ) ; return promise ; } 
function Is Writable Stream Default Writer ( x ) { if ( ! type Is Object ( x ) ) { return false ; } if ( ! Object . prototype . has Own Property . call ( x , ' _owner Writable Stream ' ) ) { return false ; } return true ; } 
function Writable Stream Default Writer Abort ( writer , reason ) { const stream = writer . _owner Writable Stream ; assert ( stream ! = = undefined ) ; return Writable Stream Abort ( stream , reason ) ; } 
function Writable Stream Default Controller Abort ( controller , reason ) { controller . _queue = [ ] ; const sink Abort Promise = Promise Invoke Or Fallback Or Noop ( controller . _underlying Sink , 'abort ' , [ reason ] , 'close ' , [ controller ] ) ; return sink Abort Promise . then ( ( ) = > undefined ) ; } 
function Writable Stream Default Controller Error ( controller , e ) { const stream = controller . _controlled Writable Stream ; assert ( stream . _state = = = 'writable ' | | stream . _state = = = 'closing ' ) ; Writable Stream Error ( stream , e ) ; controller . _queue = [ ] ; } 
function pipe ( ) { var _this = this ; var items = [ ] ; for ( var _i = 0 ; _i < arguments . length ; _i + + ) { items [ _i ] = arguments [ _i ] ; } var _done = false ; var targets = items . map ( wrap _async _iterable _iterator _ 1 . wrap Async Iterable Iterator ) ; var call = function ( method Name , value ) { return new Promise ( function ( resolve , reject ) { var remaining = targets . concat ( ) ; var next = function ( _a ) { var value = _a . value , done = _a . done ; if ( ! _done ) { _done = done ; } 
function validate ( object , schema , options ) { options = mixin ( { } , validate . defaults , options ) ; var errors = [ ] ; if ( schema . type = = = 'array ' ) validate Property ( object , object , ' ' , schema , options , errors ) ; else validate Object ( object , schema , options , errors ) ; 
function update Display ( ) { var value = $ ( " #show " ) . val ( ) ; switch ( value ) { case "runtime " : $ ( " .load " ) . hide ( ) ; $ ( " .runtime " ) . show ( ) ; break ; case "load " : $ ( " .load " ) . show ( ) ; $ ( " .runtime " ) . hide ( ) ; break ; default : $ ( " .load " ) . show ( ) ; $ ( " .runtime " ) . show ( ) ; break ; } } 
function ( event Type , handler ) { if ( this . deferred Events = = = null ) this . deferred Events = { } ; var handlers = this . deferred Events [ event Type ] ; if ( handlers = = = undefined ) handlers = this . deferred Events [ event Type ] = [ ] ; handlers . push ( { event Type : event Type , handler : handler } ) ; } 
function ( ) { qx . Bootstrap . execute Pending Defers ( ) ; qx . $ $loader . delay Defer = false ; qx . $ $loader . script Loaded = true ; function done ( ) { var ready Handlers = [ ] ; if ( qx . $ $loader . deferred Events ) { Object . keys ( qx . $ $loader . deferred Events ) . for Each ( function ( event Type ) { var handlers = qx . $ $loader . deferred Events [ event Type ] ; handlers . for Each ( function ( handler ) { qx . event . Registration . add Listener ( window , event Type , handler . handler ) ; if ( event Type = = = "ready " ) ready Handlers . push ( handler . handler ) ; } ) ; } ) ; } if ( window . qx & & qx . event & & qx . event . handler & & qx . event . handler . Application ) { qx . event . handler . Application . on Script Loaded ( ) ; qx . $ $loader . application Handler Ready = true ; } else { qx . $ $loader . application Handler Ready = false ; ready Handlers . for Each ( function ( handler ) { handler ( null ) ; } ) ; } } if ( qx . $ $loader . splashscreen ) qx . $ $loader . splashscreen . load Complete ( done ) ; else done ( ) ; } 
function ( ) { var l = qx . $ $loader ; l . decode Uris ( l . css Before , "resource Uri " ) . for Each ( function ( uri ) { load Css ( uri ) ; } ) ; all Scripts = l . decode Uris ( l . uris Before , "resource Uri " ) ; if ( ! l . boot Is Inline ) { var add = l . decode Uris ( l . packages [ l . parts [ l . boot ] [ 0 ] ] . uris ) ; Array . prototype . push . apply ( all Scripts , add ) ; } function begin ( ) { flush Script Queue ( function ( ) { 
function load Script ( uri , callback ) { var elem = document . create Element ( "script " ) ; elem . charset = "utf - 8 " ; elem . src = uri ; elem . onreadystatechange = elem . onload = function ( ) { if ( ! this . ready State | | ready State Value [ this . ready State ] ) { elem . onreadystatechange = elem . onload = null ; if ( typeof callback = = = "function " ) { callback ( ) ; } } } ; elem . onerror = function ( ) { if ( console & & typeof console . error = = "function " ) console . error ( "Cannot load script " + uri ) ; callback & & callback ( "Cannot load script " + uri ) ; } if ( qx . $ $loader . is Load Parallel ) { elem . async = null ; } var head = document . get Elements By Tag Name ( "head " ) [ 0 ] ; head . append Child ( elem ) ; } 
function load Css ( uri ) { var elem = document . create Element ( "link " ) ; elem . rel = "stylesheet " ; elem . type = "text /css " ; elem . href = uri ; var head = document . get Elements By Tag Name ( "head " ) [ 0 ] ; head . append Child ( elem ) ; } 
function ( classname ) { this . base ( arguments ) ; this . init Type ( ) ; var args = qx . lang . Array . from Arguments ( arguments ) ; var t = this ; this . _ _classes = [ ] ; args . for Each ( function ( arg ) { if ( qx . lang . Type . is Array ( arg ) ) { qx . lang . Array . append ( t . _ _classes , arg ) ; } else { t . _ _classes . push ( arg ) ; } } ) ; this . set ( { include : [ ] , exclude : [ ] } ) ; } 
function ( ) { var t = this ; var Console = qx . tool . compiler . Console . get Instance ( ) ; var analyser = this . get Analyser ( ) ; var db = analyser . get Database ( ) ; var all Deps = new qx . tool . compiler . utils . Indexed Array ( ) ; var exclude = { } ; var fatal Compile Errors = [ ] ; this . _ _load Deps = null ; var parts By Name = { } ; var parts = [ ] ; var boot Part = null ; var class Data By Classname = { } ; if ( this . _ _parts & & this . _ _parts . length ) { parts = [ ] ; t . _ _parts . for Each ( part = > { if ( parts By Name [ part . get Name ( ) ] ) { throw new Error ( Console . decode ( "qx .tool .compiler .application .duplicate Part Names " , part . get Name ( ) ) ) ; } var part Data = { name : part . get Name ( ) , include : part . get Include ( ) , exclude : part . get Exclude ( ) , classes : [ ] , depends On : { } , combine : part . get Combine ( ) , minify : part . get Minify ( ) } ; part Data . match = qx . tool . compiler . app . Application . create Wildcard Match Function ( part . get Include ( ) , part . get Exclude ( ) ) ; parts By Name [ part . get Name ( ) ] = part Data ; parts . push ( part Data ) ; } ) ; boot Part = parts By Name . boot ; if ( ! boot Part ) { throw new Error ( Console . decode ( "qx .tool .compiler .application .no Boot Part " ) ) ; } } else { boot Part = { name : "boot " , include : [ " * " ] , exclude : [ ] , classes : [ ] , depends On : { } , combine : false , minify : false , match : function ( ) { return true ; } } ; parts By Name . boot = boot Part ; parts . push ( boot Part ) ; } function create Class Data ( classname ) { if ( class Data By Classname [ classname ] ) { return class Data By Classname [ classname ] ; } var class Data = class Data By Classname [ classname ] = { classname : classname , parts : { } , best : null , actual : null } ; parts . for Each ( part = > { if ( part = = = boot Part ) { return ; } var result = part . match ( classname ) ; if ( result ! = = null ) { class Data . parts [ part . name ] = result ; var last Match = class Data . best & & class Data . parts [ class Data . best . name ] ; if ( last Match = = = undefined | | last Match = = = null ) { class Data . best = part ; * We could say that when a class is ` .require `d , then we treat any of it 's `construct :true ` dependencies as `require :true ` * The problem is given this example : * qx .core .Init .defer ( ) * qx .event .Registration .add Listener * qx .event .Registration .get Manager * qx .event .Manager .construct * new qx .util .Deferred Call * * new qx .util .Deferred Call is a runtime only dependency so is not available . * * So the theory is that deferred calls tend to be about initialisation , so prioritising constructor dependencies * may be helpful * / / * * Recursively finds all the dependencies for a class which have not already been added * to the list of classes to load . * * @param classname {String } * @param deps {String [ ] } array to modify * / function compile All Remaining Deps ( classname , deps ) { var checked = { } ; var dep Names = { } ; dep Names [ classname ] = true ; function search ( classname ) { if ( checked [ classname ] ) { return ; } checked [ classname ] = true ; var info = db . class Info [ classname ] ; if ( info & & info . depends On ) { for ( var dep Name in info . depends On ) { var dd = info . depends On [ dep Name ] ; if ( dd . load | | dd . require | | dd . defer | | dd . construct ) { if ( ! all Deps . contains ( dep Name ) ) { dep Names [ dep Name ] = true ; } search ( dep Name ) ; } } } } search ( classname ) ; for ( var dep Name in dep Names ) { deps . push ( dep Name ) ; } } var add Dep Depth = 0 ; function add Dep ( classname ) { if ( exclude [ classname ] ) { return ; } if ( all Deps . contains ( classname ) | | stack . contains ( classname ) ) { return ; } var info = db . class Info [ classname ] ; if ( ! info ) { return ; } if ( info . fatal Compile Error ) { fatal Compile Errors . push ( classname ) ; } add Dep Depth + + ; var environment Load Deps = { } ; if ( info . environment & & info . environment . required ) { for ( var key in info . environment . required ) { var env Info = info . environment . required [ key ] ; if ( env Info . defer ) { environment Load Deps [ env Info . class Name ] = true ; } } } var defer Deps = [ ] ; if ( info . depends On ) { stack . push ( classname ) ; for ( var dep Name in info . depends On ) { var dd = info . depends On [ dep Name ] ; if ( dd . load | | dd . require | | environment Load Deps [ dep Name ] ) { add Dep ( dep Name ) ; } else if ( dd . defer ) { defer Deps . push ( dep Name ) ; } else if ( ! all Deps . contains ( dep Name ) ) { needed . push ( dep Name ) ; } } stack . remove ( classname ) ; } if ( parts & & ! all Deps . contains ( classname ) ) { var class Data = create Class Data ( classname ) ; var part = class Data . best | | boot Part ; part . classes . push ( classname ) ; class Data . actual = part ; } all Deps . push ( classname ) ; defer Deps . for Each ( function ( dep Name ) { var deps = [ ] ; compile All Remaining Deps ( dep Name , deps ) ; deps . for Each ( add Dep ) ; } ) ; if ( add Dep Depth = = = 1 ) { while ( needed Index < needed . get Length ( ) ) { classname = needed . get Item ( needed Index + + ) ; add Dep ( classname ) ; } } add Dep Depth - - ; } exclude = { } ; t . _ _expand Classnames ( t . get Exclude ( ) ) . for Each ( name = > exclude [ name ] = true ) ; / / Start the ball rolling add Dep ( "qx .core .Object " ) ; t . get Required Classes ( ) . for Each ( function ( classname ) { add Dep ( classname ) ; } ) ; if ( t . get Theme ( ) ) { add Dep ( t . get Theme ( ) ) ; } / * parts .for Each ( (part ) = > { if (part ! = = boot Part ) { t . _ _expand Classnames (part .include ) .for Each ( (name ) = > add Dep (name ) ) ; } } ) ; * / while ( needed Index < needed . length ) { var classname = needed [ needed Index + + ] ; add Dep ( classname ) ; } if ( parts & & parts . length > 1 ) { / / Calculate inter -part dependencies parts . for Each ( part = > { var checked = { } ; function check ( classname ) { if ( checked [ classname ] ) { return ; } checked [ classname ] = true ; var class Data = class Data By Classname [ classname ] ; if ( class Data . actual ! = = part ) { part . depends On [ class Data . actual . name ] = true ; } for ( var dep Name in db . class Info . depends On ) { check ( dep Name ) ; } } part . classes . for Each ( check ) ; part . depends On = Object . keys ( part . depends On ) ; } ) ; / / Check for recursive dependencies parts . for Each ( part = > { var checked = { } ; function check ( partname ) { if ( checked [ partname ] ) { return false ; } checked [ partname ] = true ; var check Part = parts By Name [ partname ] ; if ( check Part = = = part ) { return true ; } return part . depends On . some ( check ) ; } if ( part . depends On . some ( check ) ) { Console . print ( "qx .tool .compiler .application .part Recursive " , part . name ) ; } } ) ; } / * * Done * / this . _ _load Deps = all Deps . to Array ( ) ; var required Libs = { } ; this . _ _load Deps . for Each ( classname = > { let class Info = db . class Info [ classname ] ; if ( class Info . assets ) { class Info . assets . for Each ( asset = > { var pos = asset . index Of ( ' / ' ) ; if ( pos > - 1 ) { var ns = asset . substring ( 0 , pos ) ; if ( analyser . find Library ( ns ) ) required Libs [ ns ] = true ; } } ) ; } required Libs [ class Info . library Name ] = true ; } ) ; this . _ _required Libs = [ ] ; for ( let ns in required Libs ) { if ( analyser . find Library ( ns ) ) { this . _ _required Libs . push ( ns ) ; } else { Console . print ( "qx .tool .compiler .application .missing Required Library " , ns ) ; } } this . _ _parts Deps = parts ; this . _ _fatal Compile Errors = fatal Compile Errors . length ? fatal Compile Errors : null ; } 
function compile All Remaining Deps ( classname , deps ) { var checked = { } ; var dep Names = { } ; dep Names [ classname ] = true ; function search ( classname ) { if ( checked [ classname ] ) { return ; } checked [ classname ] = true ; var info = db . class Info [ classname ] ; if ( info & & info . depends On ) { for ( var dep Name in info . depends On ) { var dd = info . depends On [ dep Name ] ; if ( dd . load | | dd . require | | dd . defer | | dd . construct ) { if ( ! all Deps . contains ( dep Name ) ) { dep Names [ dep Name ] = true ; } search ( dep Name ) ; } } } } search ( classname ) ; for ( var dep Name in dep Names ) { deps . push ( dep Name ) ; } } 
function ( ) { var uris = [ ] ; var db = this . get Analyser ( ) . get Database ( ) ; function add ( classname ) { var def = db . class Info [ classname ] ; uris . push ( def . library Name + " : " + classname . replace ( / \ . / g , " / " ) + " .js " ) ; } this . _ _load Deps . for Each ( add ) ; return uris ; } 
function ( res Manager , environment ) { var assets = [ ] ; var analyser = this . get Analyser ( ) ; var db = analyser . get Database ( ) ; 
function ( ) { var result = { } ; this . _ _classes . for Each ( name = > result [ name ] = true ) ; this . _ _expand Classnames ( this . get Include ( ) ) . for Each ( name = > result [ name ] = true ) ; this . _ _expand Classnames ( this . get Exclude ( ) ) . for Each ( name = > delete result [ name ] ) ; 
function ( names ) { var t = this ; var result = { } ; names . for Each ( function ( name ) { var pos = name . index Of ( " * " ) ; if ( pos < 0 ) { result [ name ] = true ; } else { var prefix = name . substring ( 0 , pos ) ; t . get Analyser ( ) . get Libraries ( ) . for Each ( function ( lib ) { var symbols = lib . get Known Symbols ( ) ; for ( var symbol in symbols ) { if ( symbols [ symbol ] = = "class " & & symbol . starts With ( prefix ) ) { result [ symbol ] = true ; } } } ) ; } } ) ; return Object . keys ( result ) ; } 
function ( value , old Value ) { var loader = path . join ( _ _dirname , "loader - " + ( this . is Browser App ( ) ? "browser " : "server " ) + " .tmpl .js " ) ; this . set Loader Template ( loader ) ; this . set Theme ( null ) ; } 
function ( value ) { if ( ! value ) { return null ; } if ( ! qx . lang . Type . is Array ( value ) ) { return [ value ] ; } return value ; } 
function ( include , exclude ) { var code = [ ] ; if ( exclude ) { exclude . for Each ( spec = > { var pos ; if ( ( pos = spec . index Of ( " * " ) ) > - 1 ) { code . push ( " if (value .starts With ( \ " " + spec . substring ( 0 , pos ) + " \ " ) ) \n return null ; / / " + spec ) ; } else { code . push ( " if (value = = = \ " " + spec + " \ " ) \n return null ; " ) ; } } ) ; } if ( include ) { include . for Each ( spec = > { var pos ; pos = - 1 ; var ns Depth = 0 ; while ( ( pos = spec . index Of ( " . " , pos + 1 ) ) > - 1 ) { ns Depth + + ; } if ( ( pos = spec . index Of ( " * " ) ) > - 1 ) { code . push ( " if (value .starts With ( \ " " + spec . substring ( 0 , pos ) + " \ " ) ) \n return " + ns Depth + " ; / / " + spec ) ; } else { code . push ( " if (value = = = \ " " + spec + " \ " ) \n return \ "exact \ " ; " ) ; } } ) ; } code . push ( " return null ; " ) ; return new Function ( "value " , code . join ( " \n " ) ) ; } 
async function ( compile Info ) { var t = this ; var application = compile Info . application ; var target Uri = t . _get Output Root Uri ( application ) ; var app Root Dir = this . get Application Root ( application ) ; var map To = this . get Path Mapping ( path . join ( app Root Dir , this . get Output Dir ( ) , "transpiled / " ) ) ; var source Uri = map To ? map To : target Uri + "transpiled / " ; 
function Abstract Error ( msg , code , constr ) { Error . capture Stack Trace ( this , constr | | this ) ; this . message = msg | | "Error " ; this . code = code | | "EUNKNOWN " ; } 
function mkpath ( dir , cb ) { dir = path . normalize ( dir ) ; var segs = dir . split ( path . sep ) ; var made = " " ; async . each Series ( segs , function ( seg , cb ) { if ( made . length | | ! seg . length ) { made + = " / " ; } made + = seg ; fs . exists ( made , function ( exists ) { if ( ! exists ) { fs . mkdir ( made , function ( err ) { if ( err & & err . code = = = "EEXIST " ) { err = null ; } cb ( err ) ; } ) ; return ; } fs . stat ( made , function ( err , stat ) { if ( err ) { cb ( err ) ; } else if ( stat . is Directory ( ) ) { cb ( null ) ; } else { cb ( new Error ( "Cannot create " + made + " (in " + dir + " ) because it exists and is not a directory " , "ENOENT " ) ) ; } } ) ; } ) ; } , function ( err ) { cb ( err ) ; } ) ; } 
function promisify This ( fn , self , . . . args ) { return new Promise ( ( resolve , reject ) = > { args = args . slice ( ) ; args . push ( function ( err , result ) { if ( err ) { reject ( err ) ; } else { resolve ( result ) ; } } ) ; try { fn . apply ( self , args ) ; } catch ( ex ) { reject ( ex ) ; } } ) ; } 
function ( db Filename ) { this . base ( arguments ) ; this . _ _db Filename = db Filename | | "db .json " ; this . _ _libraries = [ ] ; this . _ _libraries By Namespace = { } ; this . _ _initial Classes To Scan = new qx . tool . compiler . utils . Indexed Array ( ) ; this . _ _locales = [ "en " ] ; this . _ _cldrs = { } ; this . _ _translations = { } ; this . _ _class Files = { } ; this . _ _environment Checks = { } ; } 
function ( ) { var t = this ; var p ; if ( ! this . _ _opened ) { this . _ _opened = true ; var res Manager = null ; if ( this . is Process Resources ( ) ) { res Manager = new qx . tool . compiler . resources . Manager ( this ) ; } this . _ _res Manager = res Manager ; p = Promise . all ( [ util . promisify This ( t . load Database , t ) , new Promise ( ( resolve , reject ) = > { if ( res Manager ) { log . debug ( "Loading resource database " ) ; return util . promisify This ( res Manager . load Database , res Manager ) . then ( resolve ) . catch ( reject ) ; } resolve ( ) ; return undefined ; } ) ] ) ; } else { p = Promise . resolve ( ) ; } return p . then ( ( ) = > { log . debug ( "Scanning source code " ) ; return util . promisify This ( t . initial Scan , t ) ; } ) . then ( ( ) = > { log . debug ( "Saving database " ) ; return t . save Database ( ) ; } ) ; } 
function ( cb ) { var t = this ; if ( ! this . _ _db ) { this . _ _db = { } ; } async . parallel ( [ 
function ( cb ) { if ( ! t . _ _res Manager ) { cb ( null ) ; return ; } t . _ _res Manager . find All Resources ( function ( err ) { if ( err ) { cb ( err ) ; return ; } log . debug ( "found all resources " ) ; cb ( null ) ; } ) ; } 
function ( cb ) { async . each ( t . _ _libraries , function ( library , cb ) { library . scan For Classes ( err = > { log . debug ( "Finished scanning for " + library . get Namespace ( ) ) ; cb ( err ) ; } ) ; } , err = > { log . debug ( "Finished scanning for all libraries " ) ; cb ( err ) ; } ) ; } 
function ( cb ) { var t = this ; async . waterfall ( [ function read Db ( cb ) { fs . exists ( t . get Db Filename ( ) , function ( exists ) { if ( exists ) { fs . read File ( t . get Db Filename ( ) , { encoding : "utf - 8 " } , cb ) ; } else { cb ( null , null ) ; } } ) ; } , function parse Db ( data , cb ) { if ( data & & data . trim ( ) . length ) { log . debug ( "Parsing database " ) ; t . _ _db = jsonlint . parse ( data ) ; } else { log . debug ( "No database to parse " ) ; t . _ _db = { } ; } cb ( null , t . _ _db ) ; } ] , function ( err , result ) { log . debug ( "loaded database : err = " + err ) ; cb ( ) ; } ) ; } 
function read Db ( cb ) { fs . exists ( t . get Db Filename ( ) , function ( exists ) { if ( exists ) { fs . read File ( t . get Db Filename ( ) , { encoding : "utf - 8 " } , cb ) ; } else { cb ( null , null ) ; } } ) ; } 
function parse Db ( data , cb ) { if ( data & & data . trim ( ) . length ) { log . debug ( "Parsing database " ) ; t . _ _db = jsonlint . parse ( data ) ; } else { log . debug ( "No database to parse " ) ; t . _ _db = { } ; } cb ( null , t . _ _db ) ; } 
async function ( ) { log . debug ( "saving generator database " ) ; this . fire Data Event ( "save Database " , this . _ _db ) ; await qx . tool . compiler . utils . Json . save Json Async ( this . get Db Filename ( ) , this . _ _db ) . then ( ( ) = > this . _ _res Manager & & this . _ _res Manager . save Database ( ) ) ; } 
function ( cb ) { var t = this ; if ( ! this . _ _db ) { this . _ _db = { } ; } var db = this . _ _db ; var meta Written Log = { } ; var compiled Classes = { } ; var meta Fixup Descendants = { } ; var listener Id = this . add Listener ( "compiled Class " , function ( evt ) { var data = evt . get Data ( ) ; if ( data . old Db Class Info ) { if ( data . old Db Class Info . extends ) { meta Fixup Descendants [ data . old Db Class Info . extends ] = true ; } if ( data . old Db Class Info . implement ) { data . old Db Class Info . implement . for Each ( name = > meta Fixup Descendants [ name ] = true ) ; } if ( data . old Db Class Info . include ) { data . old Db Class Info . include . for Each ( name = > meta Fixup Descendants [ name ] = true ) ; } } if ( data . db Class Info . extends ) { meta Fixup Descendants [ data . db Class Info . extends ] = true ; } if ( data . db Class Info . implement ) { data . db Class Info . implement . for Each ( name = > meta Fixup Descendants [ name ] = true ) ; } if ( data . db Class Info . include ) { data . db Class Info . include . for Each ( name = > meta Fixup Descendants [ name ] = true ) ; } compiled Classes [ data . class File . get Class Name ( ) ] = data ; } ) ; 
function ( cb ) { t . get Class Info ( classes [ class Index + + ] , ( err , db Class Info ) = > { if ( db Class Info ) { var deps = db Class Info . depends On ; for ( var dep Name in deps ) { t . _add Required Class ( dep Name ) ; } } if ( err & & err . code = = = "ENOCLASSFILE " ) { console . error ( err . message ) ; err = null ; } return cb ( err ) ; } ) ; } 
function ( err ) { if ( err ) { cb & & cb ( err ) ; return ; } classes . for Each ( function ( class Name ) { var info = t . _ _db . class Info [ class Name ] ; var deps = get Indirect Load Dependencies ( class Name ) ; deps . for Each ( function ( dep Name ) { if ( ! info . depends On ) { info . depends On = { } ; } if ( ! info . depends On [ dep Name ] ) { info . depends On [ dep Name ] = { } ; } info . depends On [ dep Name ] . load = true ; } ) ; } ) ; t . remove Listener By Id ( listener Id ) ; analyze Meta ( ) . then ( ( ) = > cb ( ) ) . catch ( err = > cb ( err ) ) ; } 
function ( class Name ) { let t = this ; 
function ( class Name , force Scan , cb ) { var t = this ; if ( ! this . _ _db ) { this . _ _db = { } ; } var db = this . _ _db ; if ( typeof force Scan = = "function " ) { cb = force Scan ; force Scan = false ; } if ( ! db . class Info ) { db . class Info = { } ; } var library = t . get Library From Classname ( class Name ) ; if ( ! library ) { let err = new Error ( "Cannot find class file " + class Name ) ; err . code = "ENOCLASSFILE " ; cb & & cb ( err ) ; return ; } var source Class Filename = qx . tool . compiler . Class File . get Source Path ( library , class Name ) ; var output Class Filename = qx . tool . compiler . Class File . get Output Path ( this , class Name ) ; function scan File ( stat , output Stat ) { var db Class Info = db . class Info [ class Name ] ; if ( db Class Info & & output Stat ) { var db Mtime = null ; try { db Mtime = db Class Info . mtime & & new Date ( db Class Info . mtime ) ; } catch ( e ) { } if ( db Mtime & & db Mtime . get Time ( ) = = stat . mtime . get Time ( ) ) { if ( output Stat . mtime . get Time ( ) > = stat . mtime . get Time ( ) ) { cb & & cb ( null , db Class Info ) ; return ; } } } 
async function ( locale ) { var t = this ; var cldr = this . _ _cldrs [ locale ] ; if ( cldr ) { return cldr ; } return qx . tool . compiler . app . Cldr . load CLDR ( locale ) . then ( cldr = > t . _ _cldrs [ locale ] = cldr ) ; } 
async function ( library , locale ) { var t = this ; var id = locale + " : " + library . get Namespace ( ) ; var translation = t . _ _translations [ id ] ; if ( ! translation ) { translation = t . _ _translations [ id ] = new qx . tool . compiler . app . Translation ( library , locale ) ; await translation . check Read ( ) ; } return translation ; } 
function ( library , locales ) { const Promisify = qx . tool . compiler . utils . Promisify ; return Promise . all ( locales . map ( locale = > { var translation = new qx . tool . compiler . app . Translation ( library , locale ) ; return translation . read ( ) . then ( ( ) = > { let unused Entries = { } ; for ( let msgid in translation . get Entries ( ) ) unused Entries [ msgid ] = true ; return Promise . all ( this . _ _classes . map ( async classname = > { if ( ! classname . starts With ( library . get Namespace ( ) ) ) { return ; } let db Class Info = await Promisify . call ( cb = > this . get Class Info ( classname , cb ) ) ; if ( ! db Class Info . translations ) return ; db Class Info . translations . for Each ( function ( src ) { var entry = translation . get Or Create Entry ( src . msgid ) ; delete unused Entries [ src . msgid ] ; if ( src . msgid _plural ) { entry . msgid _plural = src . msgid _plural ; } if ( ! entry . comments ) { entry . comments = { } ; } entry . comments . extracted = src . comment ; entry . comments . reference = { } ; let ref = entry . comments . reference ; const file Name = classname . replace ( / \ . / g , " / " ) + " .js " ; const fn Add Reference = line No = > { let arr = ref [ file Name ] ; if ( ! arr ) arr = ref [ file Name ] = [ ] ; if ( ! arr . includes ( src . line No ) ) { arr . push ( line No ) ; } } ; if ( qx . lang . Type . is Array ( src . line No ) ) { src . line No . for Each ( fn Add Reference ) ; } else { fn Add Reference ( src . line No ) ; } } ) ; } ) ) . then ( ( ) = > { Object . keys ( unused Entries ) . for Each ( msgid = > { var entry = translation . get Entry ( msgid ) ; if ( entry ) { if ( ! entry . comments ) { entry . comments = { } ; } entry . comments . extracted = "NO LONGER USED " ; entry . comments . reference = { } ; } } ) ; } ) ; } ) . then ( ( ) = > translation . write ( ) ) ; } ) ) ; } 
function ( name ) { var t = this ; for ( var j = 0 ; j < t . _ _libraries . length ; j + + ) { var library = t . _ _libraries [ j ] ; var info = library . get Symbol Type ( name ) ; if ( info ) { return info ; } } return null ; } 
function ( class Name ) { var t = this ; var info = this . _ _class Files [ class Name ] ; if ( info ) { return info . library ; } for ( var j = 0 ; j < t . _ _libraries . length ; j + + ) { var library = t . _ _libraries [ j ] ; info = library . get Symbol Type ( class Name ) ; if ( info & & ( info . symbol Type = = "class " | | info . symbol Type = = "member " ) ) { return library ; } } return null ; } 
function ( class Name ) { var library = this . get Library From Classname ( class Name ) ; if ( ! library ) { return null ; } var path = library . get Root Dir ( ) + " / " + library . get Source Path ( ) + " / " + class Name . replace ( / \ . / g , " / " ) + " .js " ; return path ; } 
function ( key , value ) { if ( typeof key = = "object " ) { var map = key ; for ( key in map ) { this . _ _environment Checks [ key ] = map [ key ] ; } } else if ( value = = = undefined ) { delete this . _ _environment Checks [ key ] ; } else { this . _ _environment Checks [ key ] = value ; } } 
function ( ) { if ( this . _ _qooxdoo Version ) { return this . _ _qooxdoo Version ; } if ( ! this . _ _qooxdoo Version ) { let lib = this . find Library ( "qx " ) ; if ( lib ) { this . _ _qooxdoo Version = lib . get Version ( ) ; } } return this . _ _qooxdoo Version ; } 
function ( ) { var m = this . _ _db Filename . match ( / ( ^ . * ) \ / ( [ ^ / ] + ) $ / ) ; var res Db ; if ( m & & m . length = = 3 ) { res Db = m [ 1 ] + " /resource -db .json " ; } else { res Db = "resource -db .json " ; } return res Db ; } 
function ( comment ) { var current = { name : " @description " , body : " " } ; var cmds = [ current ] ; if ( typeof comment = = "string " ) { comment = comment . split ( " \n " ) ; } comment . for Each ( function ( line ) { 
function ( ) { - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Below is your actual application code . . . - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * / 
async function ( ) { this . argv . watch = true ; this . argv [ "machine -readable " ] = false ; this . argv [ "feedback " ] = false ; return this . base ( arguments ) . then ( ( ) = > this . run Web Server ( ) ) ; } 
function ( ) { - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Below is your actual application code . . . Remove or edit the following code to create your application . - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * / var login = new $ { namespace } . page . Login ( ) ; var overview = new $ { namespace } . page . Overview ( ) ; 
function ( ) { return path . join ( process . cwd ( ) , qx . tool . cli . Config Schemas . lockfile . filename ) ; } 
async function ( ) { let contrib _json _path = this . get Contrib File Name ( ) ; if ( ! await fs . exists Async ( contrib _json _path ) ) { return { version : qx . tool . cli . Config Schemas . lockfile . version , libraries : [ ] } ; } return qx . tool . compiler . utils . Json . load Json Async ( contrib _json _path ) ; } 
async function ( repo _name , library _name ) { let library = ( await this . get Contrib Data ( ) ) . libraries . find ( lib = > lib . repo _name = = = repo _name & & lib . library _name = = = library _name ) ; return library ? library . repo _tag : false ; } 
async function ( library _name ) { return ( await this . get Contrib Data ( ) ) . libraries . find ( lib = > lib . library _name = = = library _name ) ; } 
function ( read From File = false ) { if ( ! read From File & & this . _ _cache & & typeof this . _ _cache = = "object " ) { return this . _ _cache ; } try { this . _ _cache = jsonlint . parse ( fs . read File Sync ( this . get Cache Path ( ) , "UTF - 8 " ) ) ; } catch ( e ) { this . _ _cache = { repos : { list : [ ] , data : { } } , compat : { } } ; } return this . _ _cache ; } 
async function ( ) { await qx . tool . cli . Utils . make Parent Dir ( this . get Cache Path ( ) ) ; await fs . write File Async ( this . get Cache Path ( ) , JSON . stringify ( this . _ _cache , null , 2 ) , "UTF - 8 " ) ; } 
async function ( path ) { return fs . write File Async ( path , JSON . stringify ( this . _ _cache , null , 2 ) , "UTF - 8 " ) . catch ( e = > console . error ( ` $ { path } ` + e . message ) ) ; } 
function expand Member Expression ( str ) { var segs = str . split ( " . " ) ; var expr = types . member Expression ( types . identifier ( segs [ 0 ] ) , types . identifier ( segs [ 1 ] ) ) ; for ( var i = 2 ; i < segs . length ; i + + ) { expr = types . member Expression ( expr , types . identifier ( segs [ i ] ) ) ; } return expr ; } 
function ( analyser , class Name , library ) { this . base ( arguments ) ; this . _ _analyser = analyser ; this . _ _class Name = class Name ; this . _ _meta Stack = [ ] ; this . _ _meta Definitions = { } ; this . _ _library = library ; this . _ _source Filename = qx . tool . compiler . Class File . get Source Path ( library , class Name ) ; this . _ _required Classes = { } ; this . _ _environment Checks = { provided : { } , required : { } } ; this . _ _required Assets = [ ] ; this . _ _translations = [ ] ; this . _ _markers = [ ] ; this . _ _have Markers For = { } ; this . _ _scope = { parent : null , vars : { } , unresolved : { } } ; this . _ _task Queue Drains = [ ] ; this . _ _task Queue = async . queue ( function ( task , cb ) { task ( cb ) ; } ) ; this . _ _task Queue . drain = this . _on Task Queue Drain ; this . _ _task Queue . error = err = > { this . error ( err . stack | | err ) ; } ; } 
function ( callback ) { var t = this ; var class Name = this . _ _class Name ; t . _ _fatal Compile Error = false ; t . _ _num Classes Defined = 0 ; fs . read File ( this . get Source Path ( ) , { encoding : "utf - 8 " } , function ( err , src ) { if ( err ) { callback ( err ) ; return ; } try { let options = t . _ _analyser . get Babel Options ( ) | | { } ; options . modules = false ; var config = { babelrc : false , source File Name : t . get Source Path ( ) , filename : t . get Source Path ( ) , source Maps : true , "presets " : [ [ require . resolve ( " @babel /preset -env " ) , options ] ] , plugins : [ t . _babel Class Plugin ( ) ] , parser Opts : { source Type : "script " } , pass Per Preset : true } ; var result = babel Core . transform ( src , config ) ; } catch ( ex ) { if ( ex . _babel ) { console . log ( ex ) ; } t . add Marker ( "compiler .syntax Error " , ex . loc , ex . message , ex . code Frame ) ; t . _ _fatal Compile Error = true ; t . _compile Db Class Info ( ) ; callback ( ) ; return ; } if ( ! t . _ _num Classes Defined ) { t . add Marker ( "compiler .missing Class Def " ) ; t . _ _fatal Compile Error = true ; t . _compile Db Class Info ( ) ; callback ( ) ; return ; } if ( ! t . _ _meta Definitions [ class Name ] ) { t . add Marker ( "compiler .wrong Class Name " , null , class Name , Object . keys ( t . _ _meta Definitions ) . join ( " , " ) ) ; t . _compile Db Class Info ( ) ; } var pos = class Name . last Index Of ( " . " ) ; var name = pos > - 1 ? class Name . substring ( pos + 1 ) : class Name ; var output Path = t . get Output Path ( ) ; util . mk Parent Path ( output Path , function ( err ) { if ( err ) { callback ( err ) ; return ; } fs . write File ( output Path , result . code + " \n \n / / # source Mapping URL = " + name + " .js .map ?dt = " + ( new Date ( ) . get Time ( ) ) , { encoding : "utf - 8 " } , function ( err ) { if ( err ) { callback ( err ) ; return ; } fs . write File ( output Path + " .map " , JSON . stringify ( result . map , null , 2 ) , { encoding : "utf - 8 " } , function ( err ) { if ( err ) { callback ( err ) ; return ; } t . _wait For Task Queue Drain ( function ( ) { callback ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } 
function ( db Class Info ) { delete db Class Info . unresolved ; delete db Class Info . depends On ; delete db Class Info . assets ; delete db Class Info . translations ; delete db Class Info . markers ; delete db Class Info . fatal Compile Error ; for ( var key in this . _ _db Class Info ) { db Class Info [ key ] = this . _ _db Class Info [ key ] ; } } 
function ( ) { var t = this ; var db Class Info = this . _ _db Class Info = { } ; 
function ( ) { var t = this ; function get Key Name ( key ) { var key Name = key . type = = "String Literal " ? key . value : key . name ; return key Name ; } function enter Function ( path , is Class Member ) { var node = path . node ; if ( node . id ) { t . add Declaration ( node . id . name ) ; } t . push Scope ( node . id ? node . id . name : null , node , is Class Member ) ; for ( var i = 0 ; i < node . params . length ; i + + ) { t . add Declaration ( node . params [ i ] . name ) ; } } function exit Function ( path ) { var node = path . node ; t . pop Scope ( node ) ; } var FUNCTION _DECL _OR _EXPR = { enter : enter Function , exit : exit Function } ; function get Js Doc ( comment ) { if ( ! comment ) { return null ; } if ( ! qx . lang . Type . is Array ( comment ) ) { comment = [ comment ] ; } var result = { } ; comment . for Each ( comment = > { var tmp = qx . tool . compiler . jsdoc . Parser . parse Comment ( comment . value ) ; for ( var key in tmp ) { var value = tmp [ key ] ; if ( ! result [ key ] ) { result [ key ] = value ; } else { qx . lang . Array . append ( result [ key ] , value ) ; } } } ) ; return result ; } function make Meta ( section Name , function Name , node ) { var meta ; if ( function Name ) { var section = t . _ _class Meta [ section Name ] ; if ( section = = = undefined ) { section = t . _ _class Meta [ section Name ] = { } ; } meta = section [ function Name ] ; if ( meta = = = undefined ) { meta = section [ function Name ] = { } ; } } else { meta = t . _ _class Meta [ section Name ] ; if ( meta = = = undefined ) { meta = t . _ _class Meta [ section Name ] = { } ; } } meta . location = node . loc ; if ( node . leading Comments ) { var jsdoc = get Js Doc ( node . leading Comments ) ; if ( jsdoc ) { if ( jsdoc [ " @ignore " ] ) { jsdoc [ " @ignore " ] . for Each ( function ( elem ) { t . add Ignore ( elem . body ) ; } ) ; } meta . jsdoc = jsdoc ; } } if ( section Name = = = "members " | | section Name = = = "statics " ) { if ( node . type = = "Object Method " | | node . value . type = = = "Function Expression " ) { meta . type = "function " ; } else { meta . type = "variable " ; } if ( function Name . starts With ( " _ _ " ) ) { meta . access = "private " ; } else if ( function Name . starts With ( " _ " ) ) { meta . access = "protected " ; } else { meta . access = "public " ; } } return meta ; } var needs Qx Core Environment = false ; var COLLECT _CLASS _NAMES _VISITOR = { Member Expression ( path ) { var self = this ; var str = collapse Member Expression ( path . node ) ; t . _require Class ( str , { location : path . node . loc } ) ; var info = t . _ _analyser . get Symbol Type ( str ) ; if ( info & & info . symbol Type = = "class " ) { self . collected Classes . push ( str ) ; } } } ; const CODE _ELIMINATION _VISITOR = { Call Expression ( path ) { const name = collapse Member Expression ( path . node . callee ) ; if ( ( name = = = "qx .core .Environment .select " | | name = = = "qx .core .Environment .get " ) & & types . is Literal ( path . node . arguments [ 0 ] ) ) { const arg = path . node . arguments [ 0 ] ; const env = t . _ _analyser . get Environment ( ) ; const env Value = env [ arg . value ] ; if ( env Value ! = = undefined ) { if ( name = = = "qx .core .Environment .get " ) { path . skip ( ) ; path . replace With Source String ( format Value As Code ( env Value ) ) ; return ; } else if ( name = = = "qx .core .Environment .select " ) { const sub Path = path . get ( "arguments . 1 " ) ; let option = sub Path . node . properties . find ( prop = > prop . key . value = = = env Value . to String ( ) ) ; if ( ! option ) { 
function ( class Name ) { var pos = class Name . last Index Of ( " . " ) ; var meta = { class Name : class Name , package Name : pos > - 1 ? class Name . substring ( 0 , pos ) : null , name : pos > - 1 ? class Name . substring ( pos + 1 ) : class Name , super Class : null , interfaces : [ ] , mixins : [ ] , function Name : null } ; this . _ _meta Stack . push ( meta ) ; this . _ _class Meta = meta ; this . _ _meta Definitions [ class Name ] = meta ; this . _ _num Classes Defined + + ; } 
function ( class Name ) { if ( ! this . _ _meta Stack . length ) { throw new Error ( "No _ _meta Stack entries to pop " ) ; } let meta = this . _ _meta Stack [ this . _ _meta Stack . length - 1 ] ; if ( class Name & & meta . class Name ! = class Name ) { throw new Error ( "Wrong _ _meta Stack entries to pop , expected " + class Name + " found " + meta . class Name ) ; } this . _ _meta Stack . pop ( ) ; meta = this . _ _meta Stack [ this . _ _meta Stack . length - 1 ] | | null ; this . _ _class Meta = meta ; } 
function ( function Name , node , is Class Member ) { this . _ _scope = { function Name : function Name , parent : this . _ _scope , vars : { } , unresolved : { } , is Class Member : ! ! is Class Member } ; } 
function ( node ) { var old = this . _ _scope ; var scope = this . _ _scope = this . _ _scope . parent ; var unresolved = scope . unresolved ; for ( var name in old . unresolved ) { var entry = unresolved [ name ] ; if ( ! entry ) { entry = unresolved [ name ] = { name : name , locations : [ ] } ; } entry . locations . push . apply ( entry . locations , old . unresolved [ name ] . locations ) ; } } 
function ( name , value Name ) { if ( this . _ _scope . vars [ name ] = = = undefined ) { this . _ _scope . vars [ name ] = value Name | | true ; var unresolved = this . _ _scope . unresolved ; delete unresolved [ name ] ; var re = new Reg Exp ( name + " \ \ . " ) ; for ( var tmp in unresolved ) { if ( re . test ( tmp ) ) { delete unresolved [ tmp ] ; } } } } 
function ( name ) { var pos = name . index Of ( " . " ) ; if ( pos > - 1 ) { name = name . substring ( 0 , pos ) ; } for ( var tmp = this . _ _scope ; tmp ; tmp = tmp . parent ) { if ( tmp . vars [ name ] ! = = undefined ) { return true ; } } return false ; } 
function ( name , loc ) { var str = " " ; for ( var i = 0 ; i < name . length ; i + + ) { if ( i ) { str + = " . " ; } str + = name [ i ] ; if ( qx . tool . compiler . Class File . GLOBAL _SYMBOLS [ str ] | | this . is Ignored ( str ) ) { return ; } } name = name . join ( " . " ) ; if ( name = = this . _ _class Name | | name . starts With ( this . _ _class Name + " . " ) | | name . starts With ( " ( " ) ) { return ; } if ( name = = "qx .ui .tooltip .Tool Tip " ) debugger ; var scope = this . _ _scope ; if ( scope . vars [ name ] ! = = undefined ) { return ; } if ( ! scope . unresolved [ name ] ) { scope . unresolved [ name ] = { name : name , locations : loc ? [ loc ] : [ ] , load : this . is Load Scope ( ) , defer : this . _ _in Defer } ; } else if ( loc ) { scope . unresolved [ name ] . locations . push ( loc ) ; } } 
function ( name ) { delete this . _ _scope . unresolved [ name ] ; var stub = name + " . " ; for ( var id in this . _ _scope . unresolved ) { if ( id . starts With ( stub ) ) { delete this . _ _scope . unresolved [ id ] ; } } } 
function ( name ) { var scope = this . _ _scope ; if ( ! scope . ignore ) { scope . ignore = { } ; } var segs = name . split ( " , " ) ; segs . for Each ( name = > { if ( name . ends With ( " . * " ) ) { scope . ignore [ name ] = name . substring ( 0 , name . length - 2 ) ; } else if ( name . ends With ( " * " ) ) { scope . ignore [ name ] = name . substring ( 0 , name . length - 1 ) ; } else { scope . ignore [ name ] = true ; } } ) ; } 
function ( name ) { for ( var tmp = this . _ _scope ; tmp ; tmp = tmp . parent ) { if ( tmp . ignore ) { if ( tmp . ignore [ name ] ) { return true ; } for ( var key in tmp . ignore ) { if ( tmp . ignore [ key ] ! = = true ) { if ( name . starts With ( tmp . ignore [ key ] ) ) { return true ; } } } } } return false ; } 
function ( name , location ) { var t = this ; var required Opts = { load : t . is Load Scope ( ) , defer : t . _ _in Defer , construct : t . _ _class Meta & & t . _ _class Meta . function Name = = " $ $constructor " , location : location } ; var dest = t . _ _environment Checks . required [ name ] ; if ( ! dest ) { dest = t . _ _environment Checks . required [ name ] = { } ; } if ( required Opts . load ) { dest . load = true ; } if ( required Opts . defer ) { dest . defer = true ; } if ( required Opts . construct ) { dest . construct = true ; } t . _require Class ( "qx .core .Environment " , { location : location } ) ; if ( qx . tool . compiler . Class File . ENVIRONMENT _CONSTANTS [ name ] = = = undefined ) { var entry = qx . tool . compiler . Class File . ENVIRONMENT _CHECKS [ name ] ; if ( entry & & entry . class Name ) { t . _require Class ( entry . class Name , { load : required Opts . load , location : location } ) ; dest . class Name = entry . class Name ; } else if ( ! entry ) { t . _require Class ( name , { load : required Opts . load , location : location } ) ; } } } 
function ( msg Id , pos ) { msg Id = "qx .tool .compiler . " + msg Id ; 
function ( name , opts ) { if ( qx . lang . Type . is Array ( name ) ) { name . for Each ( name = > this . _require Class ( name ) ) ; return null ; } let t = this ; if ( name = = this . _ _class Name ) { return null ; } if ( ! name ) { throw new Error ( "No classname " ) ; } if ( this . is Ignored ( name ) ) { return null ; } let require Opts = { load : t . is Load Scope ( ) , defer : t . _ _in Defer , construct : t . _ _class Meta & & t . _ _class Meta . function Name = = " $ $constructor " } ; if ( opts ) { for ( let key in opts ) { require Opts [ key ] = opts [ key ] ; } } let info = t . _ _analyser . get Symbol Type ( name ) ; let symbol Type = info ? info . symbol Type : null ; let class Name = info ? info . class Name : null ; if ( symbol Type ! = "package " & & class Name & & class Name ! = t . _ _class Name ) { 
function ( path ) { if ( path . index Of ( " / " ) < 0 & & path . index Of ( " . " ) > - 1 ) { path = path . replace ( / \ . / g , " / " ) ; } if ( ! qx . lang . Array . contains ( this . _ _required Assets , path ) ) { this . _ _required Assets . push ( path ) ; } } 
function ( library , class Name ) { return path Module . join ( library . get Root Dir ( ) , library . get Source Path ( ) , class Name . replace ( / \ . / g , path Module . sep ) + " .js " ) ; } 
function ( analyser , class Name ) { var filename = path Module . join ( analyser . get Output Dir ( ) , "transpiled " , class Name . replace ( / \ . / g , path Module . sep ) + " .js " ) ; return filename ; } 
function ( array , search Element ) { var min Index = 0 ; var max Index = array . length - 1 ; var current Index ; var current Element ; while ( min Index < = max Index ) { current Index = ( min Index + max Index ) / 2 | 0 ; current Element = array [ current Index ] ; if ( current Element < search Element ) { min Index = current Index + 1 ; } else if ( current Element > search Element ) { max Index = current Index - 1 ; } else { return current Index ; } } return - 1 ; } 
async function ( ) { let compile = await this . parse Compile Config ( ) ; for ( let target of compile . targets ) { await this . _ _remove Path ( path . join ( process . cwd ( ) , target . output Path ) ) ; } await this . _ _remove Path ( path . join ( process . cwd ( ) , "contrib " ) ) ; } 
function get Pages ( files , metalsmith , done ) { var metadata = metalsmith . metadata ( ) ; var pages = [ ] ; var order = { } ; if ( metadata . site . pages ) metadata . site . pages . for Each ( ( url , index ) = > typeof url = = "string " ? order [ url ] = index : null ) ; var unordered Pages = [ ] ; function add Page ( url , title ) { var page = { url : url , title : title } ; var index = order [ url ] ; if ( index ! = = undefined ) pages [ index ] = page ; else unordered Pages . push ( page ) ; } for ( var filename in files ) { var file = files [ filename ] ; if ( filename = = "index .html " ) add Page ( " / " , file . title | | "Home Page " ) ; else if ( file . permalink | | file . navigation ) add Page ( file . permalink | | filename , file . title | | "Home Page " ) ; } unordered Pages . for Each ( page = > pages . push ( page ) ) ; metadata . site . pages = pages ; done ( ) ; } 
function load Partials ( files , metalsmith , done ) { var metadata = metalsmith . metadata ( ) ; fs . readdir Async ( " . /partials " , "utf 8 " ) . then ( files = > { var promises = files . map ( filename = > { var m = filename . match ( / ^ ( . + ) \ . ( [ ^ . ] + ) $ / ) ; if ( ! m ) return ; var name = m [ 1 ] ; var ext = m [ 2 ] ; return fs . read File Async ( "partials / " + filename , "utf 8 " ) . then ( data = > { var fn ; try { fn = dot . template ( data ) ; } catch ( err ) { console . log ( "Failed to load partial " + filename + " : " + err ) ; return ; } fn . name = filename ; metadata . partials [ filename ] = fn ; if ( ext = = "html " ) metadata . partials [ name ] = fn ; } ) ; } ) ; return Promise . all ( promises ) ; } ) . then ( ( ) = > done ( ) ) . catch ( err = > done ( err ) ) ; } 
function generate Site ( ) { return new Promise ( ( resolve , reject ) = > { Metalsmith ( _ _dirname ) . metadata ( { site : { title : "Qooxdoo Application Server " , description : "Mini website used by \ "qx serve \ " " , email : "info @qooxdoo .org " , twitter _username : "qooxdoo " , github _username : "qooxdoo " , pages : [ " / " , " /about / " ] } , baseurl : " " , url : " " , lang : "en " , partials : { } } ) . source ( ' . /src ' ) . destination ( ' . /build ' ) . clean ( true ) . use ( load Partials ) . use ( markdown ( ) ) . use ( get Pages ) . use ( layouts ( { engine : 'dot ' } ) ) . build ( function ( err ) { if ( err ) reject ( err ) ; else resolve ( ) ; } ) ; } ) ; } 
function compile Scss ( ) { return new Promise ( ( resolve , reject ) = > { sass . render ( { file : "sass /qooxdoo .scss " , out File : "build /qooxdoo .css " } , function ( err , result ) { if ( err ) reject ( err ) ; else resolve ( result ) ; } ) ; } ) . then ( result = > fs . write File Async ( "build /qooxdoo .css " , result . css , "utf 8 " ) ) ; } 
function ( ) { return { command : "list [repository ] " , describe : "if no repository name is given , lists all available contribs that are compatible with the project 's qooxdoo version ( \ " - -all \ " lists incompatible ones as well ) . Otherwise , list all compatible contrib libraries . " , builder : { all : { alias : "a " , describe : "Show all versions , including incompatible ones " } , verbose : { alias : "v " , describe : "Verbose logging " } , quiet : { alias : "q " , describe : "No output " } , json : { alias : "j " , describe : "Output list as JSON literal " } , installed : { alias : "i " , describe : "Show only installed libraries " } , namespace : { alias : "n " , describe : "Display library namespace " } , match : { alias : "m " , describe : "Filter by regular expression (case -insensitive ) " } , "libraries " : { alias : "l " , describe : "List libraries only (no repositories ) " } , "short " : { alias : "s " , describe : "Omit title and description to make list more compact " } , "noheaders " : { alias : "H " , describe : "Omit header and footer " } } , handler : function ( argv ) { return new qx . tool . cli . commands . contrib . List ( argv ) . process ( ) . catch ( e = > { console . error ( e . stack | | e . message ) ; process . exit ( 1 ) ; } ) ; } } ; } 
async function ( ) { this . _ _repositories = [ ] ; this . _ _libraries = { } ; this . _ _latest Compatible = { } ; const local Path Repo Name = this . self ( arguments ) . local Path Repo Name ; let repos _cache = this . get Cache ( ) . repos ; 
async function ( qooxdoo _version ) { if ( this . argv . installed ) { 
async function ( ) { 
function ( library , locale ) { this . base ( arguments ) ; this . set Library ( library ) ; if ( locale ) { this . set Locale ( locale ) ; } this . _ _translations = { } ; this . _ _headers = { } ; } 
async function ( ) { if ( ! this . _ _mtime ) { return this . read ( ) ; } var po File = this . get Po Filename ( ) ; let stat = await qx . tool . compiler . files . Utils . safe Stat ( po File ) ; if ( stat & & this . _ _mtime = = stat . mtime ) { return undefined ; } return this . read ( ) ; } 
function ( ) { var t = this ; if ( t . _ _on Read ) { return t . _ _on Read ; } return t . _ _on Read = new Promise ( ( resolve , reject ) = > { t . _ _translations = { } ; t . _ _headers = { } ; var po File = this . get Po Filename ( ) ; fs . stat ( po File , function ( err , stat ) { if ( err ) { if ( err . code = = "ENOENT " ) { resolve ( ) ; return undefined ; } reject ( err ) ; return undefined ; } t . _ _mtime = stat . mtime ; return read File ( po File , { encoding : "utf 8 " } ) . then ( data = > { var entry = null ; var last Key = null ; function save Entry ( ) { if ( entry ) { var key ; if ( entry . msgctxt ) { key = entry . msgctxt + " : " + entry . msgid ; } else { key = entry . msgid ; } t . _ _translations [ key ] = entry ; } entry = null ; last Key = null ; } function set ( key , value , append ) { var index = null ; var m = key . match ( / ^ ( [ ^ [ ] + ) \ [ ( [ 0 - 9 ] + ) \ ] $ / ) ; if ( m ) { key = m [ 1 ] ; index = parse Int ( m [ 2 ] ) ; if ( entry [ key ] = = = undefined ) { entry [ key ] = [ ] ; } if ( ! append | | typeof entry [ key ] [ index ] ! = = "string " ) { entry [ key ] [ index ] = value ; } else { entry [ key ] [ index ] + = value ; } } else if ( ! append | | typeof entry [ key ] ! = = "string " ) { entry [ key ] = value ; } else { entry [ key ] + = value ; } } data . split ( " \n " ) . for Each ( function ( line , line No ) { line = line . trim ( ) ; if ( ! line ) { save Entry ( ) ; return ; } if ( ! entry ) { entry = { } ; } 
function ( filename , cb ) { var t = this ; var lines = [ ] ; function write ( key , value ) { if ( value = = = undefined | | value = = = null ) { return ; } value = value . replace ( / \t / g , " \ \t " ) . replace ( / \r / g , " \ \r " ) . replace ( / \n / g , " \ \n " ) . replace ( / " / g , " \ \ \ " " ) ; lines . push ( key + " \ " " + value + " \ " " ) ; } for ( var msgid in t . _ _translations ) { var entry = t . _ _translations [ msgid ] ; if ( entry . comments ) { if ( entry . comments . translator ) { lines . push ( " # " + entry . comments . translator ) ; } if ( entry . comments . extracted ) { lines . push ( " # . " + entry . comments . extracted ) ; } if ( entry . comments . reference ) { let ref Str = " # : " ; const ref = entry . comments . reference ; for ( let classname in ref ) { if ( ref [ classname ] ) { for ( let line No of ref [ classname ] ) { const add Str = " " + classname + " : " + line No ; if ( ref Str . length + add Str . length > 7 8 ) { 
function ( id ) { var t = this ; var entry = t . _ _translations [ id ] ; if ( ! entry ) { entry = t . _ _translations [ id ] = { msgid : id } ; } return entry ; } 
async function ( ) { let qooxdoo Json Path = path . join ( process . cwd ( ) , "qooxdoo .json " ) ; let data = { } ; if ( await fs . exists Async ( qooxdoo Json Path ) ) { data = await this . parse Json File ( qooxdoo Json Path ) ; } else { if ( await fs . exists Async ( path . join ( process . cwd ( ) , "Manifest .json " ) ) ) { data . libraries = [ { path : " . " } ] ; } if ( await fs . exists Async ( path . join ( process . cwd ( ) , "compile .json " ) ) ) { data . applications = [ { path : " . " } ] ; } else if ( await fs . exists Async ( path . join ( process . cwd ( ) , "demo /default /compile .json " ) ) ) { data . applications = [ { path : "demo /default " } ] ; } } return data ; } 
async function ( ) { let { libraries } = await this . get Project Data ( ) ; if ( libraries instanceof Array & & libraries . length ) { return path . resolve ( process . cwd ( ) , libraries [ 0 ] . path ) ; } throw new qx . tool . cli . Utils . User Error ( "Cannot find library path - are you in the right directory ? " ) ; } 
async function ( ) { let { applications } = await this . get Project Data ( ) ; if ( applications instanceof Array & & applications . length ) { return path . resolve ( process . cwd ( ) , applications [ 0 ] . path ) ; } throw new qx . tool . cli . Utils . User Error ( "Cannot find application path - are you in the right directory ? " ) ; } 
async function ( file Path ) { var data = await fs . read File Async ( file Path , "utf 8 " ) ; try { let compile Ast = Json To Ast . parse To Ast ( data , { verbose : true } ) ; let compile Json = Json To Ast . ast To Object ( compile Ast ) ; return compile Json ; } catch ( e ) { throw new qx . tool . cli . Utils . User Error ( ` $ { file Path } ` + e . message ) ; } } 
async function ( ) { let compile Json Path = null ; try { path . join ( await this . get Application Path ( ) , "compile .json " ) ; } catch ( ex ) { 
async function ( ) { let qxpath = await this . get App Qx Path ( ) ; return path . is Absolute ( qxpath ) ? qxpath : path . resolve ( qxpath ) ; } 
async function ( lib Path ) { let manifest Path = path . join ( lib Path , "Manifest .json " ) ; let manifest = await this . parse Json File ( manifest Path ) ; let version ; try { version = manifest . info . version ; } catch ( e ) { throw new qx . tool . cli . Utils . User Error ( ` ` ) ; } if ( ! semver . valid ( version ) ) { throw new qx . tool . cli . Utils . User Error ( ` $ { manifest Path } $ { version } ` ) ; } return version ; } 
function ( cmd , args ) { let opts = { env : process . env } ; return new Promise ( ( resolve , reject ) = > { let exe = child _process . spawn ( cmd , args , opts ) ; 
function ( cmd ) { return new Promise ( ( resolve , reject ) = > { child _process . exec ( cmd , ( err , stdout , stderr ) = > { if ( err ) { reject ( err ) ; } if ( stderr ) { reject ( new Error ( stderr ) ) ; } resolve ( stdout ) ; } ) ; } ) ; } 
function ( yargs , class Names , package Name ) { let pkg = null ; package Name . split ( " . " ) . for Each ( seg = > { if ( pkg = = = null ) { pkg = window [ seg ] ; } else { pkg = pkg [ seg ] ; } } ) ; class Names . for Each ( cmd = > { require ( " . . / . . / . . / " + package Name . replace ( / \ . / g , " / " ) + " / " + cmd ) ; let data = pkg [ cmd ] . get Yargs Command ( ) ; yargs . command ( data ) ; } ) ; } 
function ( msg Id , . . . args ) { for ( var i = 0 ; i < args . length ; i + + ) { var arg = args [ i ] ; if ( typeof arg ! = = "string " & & typeof arg ! = = "number " & & arg ! = = null ) { args [ i ] = String ( arg ) ; } } if ( this . is Machine Readable ( ) ) { let str = " # # " + msg Id + " : " + JSON . stringify ( args ) ; console . log ( str ) ; } else { var writer = this . get Writer ( ) ; let str = this . decode ( msg Id , . . . args ) ; if ( writer ) { writer ( str , msg Id , . . . args ) ; } else { console . log ( str ) ; } } } 
function ( msg Id , . . . args ) { var msg = qx . tool . compiler . Console . MESSAGE _IDS [ msg Id ] | | msg Id ; var str = qx . lang . String . format ( msg . message , args | | [ ] ) ; return str ; } 
function ( obj , type ) { for ( var id in obj ) { this . MESSAGE _IDS [ id ] = { id : id , message : obj [ id ] , type : type | | "message " } ; } } 
function ( marker , show Position ) { var msg = qx . tool . compiler . Console . MESSAGE _IDS [ marker . msg Id ] | | marker . msg Id ; var str = " " ; var pos = marker . pos ; if ( show Position ! = = false & & pos & & pos . start & & pos . start . line ) { str + = " [ " + pos . start . line ; if ( pos . start . column ) { str + = " , " + pos . start . column ; } if ( pos . end & & pos . end . line & & pos . end . line ! = = pos . start . line & & pos . end . column ! = = pos . start . column ) { str + = " to " + pos . end . line ; if ( pos . end . column ) { str + = " , " + pos . end . column ; } } str + = " ] " ; } str + = qx . lang . String . format ( msg . message , marker . args | | [ ] ) ; return str ; } 
async function ( ) { var parsed Args = await this . _ _parse Impl ( ) ; var config = { } ; var contrib Config = { version : qx . tool . cli . Config Schemas . lockfile . version } ; if ( parsed Args . config ) { config = await this . _ _load Json ( parsed Args . config ) ; let lockfile = qx . tool . cli . Config Schemas . lockfile . filename ; try { var name = path . join ( path . dirname ( parsed Args . config ) , lockfile ) ; contrib Config = await this . _ _load Json ( name ) ; } catch ( ex ) { 
function ( parsed Args , config , contrib Config ) { if ( parsed Args . config ) { var default Target = parsed Args . target | | config . default Target ; if ( default Target ) { for ( var i = 0 ; i < config . targets . length ; i + + ) { if ( config . targets [ i ] . type = = = default Target ) { config . target = config . targets [ i ] ; break ; } } } if ( ! config . target ) { if ( config . targets & & ( config . targets . length > 0 ) ) { config . target = config . targets [ 0 ] ; } } } else { var target = config . target = { } ; if ( parsed Args . target ) { target . type = parsed Args . target ; } if ( parsed Args . output Path ) { target . output Path = parsed Args . output Path ; } } if ( ! config . locales ) { config . locales = [ ] ; } if ( parsed Args . locales ) { parsed Args . locales . for Each ( function ( locale ) { if ( config . locales . index Of ( locale ) < 0 ) { config . locales . push ( locale ) ; } } ) ; } if ( typeof parsed Args . write All Translations = = "boolean " ) { config . write All Translations = parsed Args . write All Translations ; } if ( parsed Args . environment ) { if ( ! config . environment ) { config . environment = { } ; } for ( var key in parsed Args . environment ) { config . environment [ key ] = parsed Args . environment [ key ] ; } } if ( ! config . applications ) { config . applications = [ ] ; } parsed Args . applications . for Each ( function ( app ) { if ( ! app . app Class ) { throw new Error ( "Missing - -app -class <classname > argument " ) ; } var config App = { class : app . app Class } ; if ( app . theme ) { config App . theme = app . theme ; } if ( app . name ) { config App . name = app . name ; } config . applications . push ( config App ) ; } ) ; if ( parsed Args . libraries ) { if ( ! config . libraries ) { config . libraries = [ ] ; } parsed Args . libraries . for Each ( function ( a Path ) { config . libraries . push ( a Path ) ; } ) ; } 
async function ( ) { let apps = [ ] ; let argv = this . argv ; let result = { target : argv . target , output Path : argv . output Path | | null , locales : null , write All Translations : argv . write All Translations , environment : { } , applications : apps , libraries : argv . library | | [ ] , config : argv . config File | | "compile .json " , continuous : argv . continuous , verbose : argv . verbose } ; if ( argv . set ) { argv . set . for Each ( function ( kv ) { var m = kv . match ( / ^ ( [ ^ = \s ] + ) ( = ( . + ) ) ? $ / ) ; if ( m ) { var key = m [ 1 ] ; var value = m [ 3 ] ; try { result . environment [ key ] = Function ( " \ "use strict \ " ;return ( " + value + " ) " ) ( ) ; } catch ( error ) { throw new Error ( "Failed to translate environment value ' " + value + " ' to a js datatype - " + error ) ; } } else { throw new Error ( "Failed to parse environment setting commandline option ' " + kv + " ' " ) ; } } ) ; } if ( argv . locale & & argv . locale . length ) { result . locales = argv . locale ; } return result ; } 
function ( class Name , theme ) { this . base ( arguments ) ; this . _ _applications = [ ] ; if ( class Name ) { var app = new qx . tool . compiler . app . Application ( class Name ) ; if ( theme ) { app . set Theme ( theme ) ; } this . add Application ( app ) ; } } 
function ( ) { var analyser = this . get Analyser ( ) ; 
function ( ) { return { command : "migrate [options ] " , desc : "migrates a qooxdoo application to the next major version " , usage : "migrate " , builder : { "verbose " : { alias : "v " , describe : "enables additional progress output to console " , type : "boolean " } } , handler : function ( argv ) { return new qx . tool . cli . commands . Migrate ( argv ) . process ( ) . catch ( e = > { console . error ( e . stack | | e . message ) ; process . exit ( 1 ) ; } ) ; } } ; } 
async function ( ) { var t = this ; var compile Ast = null ; var compile Json = { } ; var config Json ; var lets = { } ; function get Macro ( name ) { var value = lets [ name ] ; value = replace Macros ( value ) ; return value ; } function replace Macros ( value ) { if ( ! value ) { return " " ; } 
async function ( ) { if ( this . argv [ "machine -readable " ] ) { qx . tool . compiler . Console . get Instance ( ) . set Machine Readable ( true ) ; } else if ( this . argv [ "feedback " ] ) { this . _ _gauge = new Gauge ( ) ; this . _ _gauge . show ( "Compiling " , 0 ) ; const TYPES = { "error " : "ERROR " , "warning " : "Warning " } ; qx . tool . compiler . Console . get Instance ( ) . set Writer ( ( str , msg Id ) = > { msg Id = qx . tool . compiler . Console . MESSAGE _IDS [ msg Id ] ; if ( msg Id . type ! = = "message " ) { this . _ _gauge . hide ( ) ; console . log ( TYPES [ msg Id . type ] + " : " + str ) ; this . _ _gauge . show ( ) ; } else { this . _ _gauge . show ( str ) ; } } ) ; } var config = this . _ _config = await this . parse ( this . argv ) ; if ( ! config ) { throw new qx . tool . cli . Utils . User Error ( "Error : Cannot find any configuration " ) ; } var maker = this . _ _maker = await this . create Maker From Config ( config ) ; if ( ! maker ) { throw new qx . tool . cli . Utils . User Error ( "Error : Cannot find anything to make " ) ; } let errors = await this . _ _check Dependencies ( maker , config . contribs ) ; if ( errors . length > 0 ) { if ( this . argv . warn As Error ) { throw new qx . tool . cli . Utils . User Error ( errors . join ( " \n " ) ) ; } else { console . log ( errors . join ( " \n " ) ) ; } } if ( this . argv [ "clean " ] ) { await maker . erase Output Dir ( ) ; await qx . tool . compiler . files . Utils . safe Unlink ( maker . get Analyser ( ) . get Db Filename ( ) ) ; await qx . tool . compiler . files . Utils . safe Unlink ( maker . get Analyser ( ) . get Res Db Filename ( ) ) ; } var analyser = maker . get Analyser ( ) ; var target = maker . get Target ( ) ; if ( this . _ _gauge ) { maker . add Listener ( "writing Applications " , ( ) = > this . _ _gauge . show ( "Writing Applications " , 0 ) ) ; maker . add Listener ( "written Applications " , ( ) = > this . _ _gauge . show ( "Writing Applications " , 1 ) ) ; maker . add Listener ( "writing Application " , evt = > this . _ _gauge . pulse ( "Writing Application " + evt . get Data ( ) . get Name ( ) ) ) ; analyser . add Listener ( "compiling Class " , evt = > this . _ _gauge . pulse ( "Compiling " + evt . get Data ( ) . class File . get Class Name ( ) ) ) ; if ( target instanceof qx . tool . compiler . targets . Build Target ) { target . add Listener ( "minifying Application " , evt = > this . _ _gauge . pulse ( "Minifying " + evt . get Data ( ) . application . get Name ( ) + " " + evt . get Data ( ) . filename ) ) ; } } else { maker . add Listener ( "writing Application " , evt = > qx . tool . compiler . Console . print ( "qx .tool .cli .compile .writing Application " , evt . get Data ( ) . get Name ( ) ) ) ; if ( target instanceof qx . tool . compiler . targets . Build Target ) { target . add Listener ( "minifying Application " , evt = > qx . tool . compiler . Console . print ( "qx .tool .cli .compile .minifying Application " , evt . get Data ( ) . application . get Name ( ) , evt . get Data ( ) . filename ) ) ; } if ( this . argv . verbose ) { var start Times = { } ; analyser . add Listener ( "compiling Class " , evt = > { var classname = evt . get Data ( ) . class File . get Class Name ( ) ; start Times [ classname ] = new Date ( ) ; qx . tool . compiler . Console . print ( "qx .tool .cli .compile .compiling Class " , classname ) ; } ) ; analyser . add Listener ( "compiled Class " , evt = > { var classname = evt . get Data ( ) . class File . get Class Name ( ) ; var start Time = start Times [ classname ] ; var end Time = new Date ( ) ; var diff = end Time . get Time ( ) - start Time . get Time ( ) ; qx . tool . compiler . Console . print ( "qx .tool .cli .compile .compiled Class " , classname , qx . tool . cli . Utils . format Time ( diff ) ) ; } ) ; } } maker . add Listener ( "writing Applications " , e = > this . dispatch Event ( e . clone ( ) ) ) ; maker . add Listener ( "written Applications " , e = > { this . dispatch Event ( e . clone ( ) ) ; if ( this . argv . verbose ) { console . log ( " \n Completed all applications , libraries used are : " ) ; maker . get Analyser ( ) . get Libraries ( ) . for Each ( lib = > { console . log ( ` $ { lib . get Namespace ( ) } $ { lib . get Root Dir ( ) } ` ) ; } ) ; } } ) ; maker . add Listener ( "writing Application " , e = > this . dispatch Event ( e . clone ( ) ) ) ; maker . add Listener ( "written Application " , e = > this . dispatch Event ( e . clone ( ) ) ) ; analyser . add Listener ( "compiling Class " , e = > this . dispatch Event ( e . clone ( ) ) ) ; analyser . add Listener ( "compiled Class " , e = > this . dispatch Event ( e . clone ( ) ) ) ; analyser . add Listener ( "save Database " , e = > this . dispatch Event ( e . clone ( ) ) ) ; target . add Listener ( "check Environment " , e = > this . dispatch Event ( e . clone ( ) ) ) ; var p = qx . tool . compiler . files . Utils . safe Stat ( "source /index .html " ) . then ( stat = > stat & & qx . tool . compiler . Console . print ( "qx .tool .cli .compile .legacy Files " , "source /index .html " ) ) ; 
async function ( data ) { var t = this ; var maker = null ; var output Path = data . target . output Path ; if ( ! output Path ) { throw new qx . tool . cli . Utils . User Error ( "Missing output -path for target " + data . target . type ) ; } maker = new qx . tool . compiler . makers . App Maker ( ) ; if ( ! this . argv [ "erase " ] ) { maker . set No Erase ( true ) ; } if ( ! data . target ) { throw new qx . tool . cli . Utils . User Error ( "No target specified " ) ; } var target Class = data . target . target Class ? this . resolve Target Class ( data . target . target Class ) : null ; if ( ! target Class & & data . target . type ) { target Class = this . resolve Target Class ( data . target . type ) ; } if ( ! target Class ) { throw new qx . tool . cli . Utils . User Error ( "Cannot find target class : " + ( data . target . target Class | | data . target . type ) ) ; } var target = new target Class ( output Path ) ; if ( data . target . uri ) { qx . tool . compiler . Console . print ( "qx .tool .cli .compile .deprecated Uri " , "target .uri " , data . target . uri ) ; } if ( data . target . write Compile Info ) { target . set Write Compile Info ( true ) ; } target . set Write Library Info ( this . argv . write Library Info ) ; target . set Update Po Files ( this . argv . update Po Files ) ; maker . set Target ( target ) ; maker . set Locales ( data . locales | | [ "en " ] ) ; if ( data . write All Translations ) { maker . set Write All Translations ( data . write All Translations ) ; } if ( typeof data . target . typescript = = "string " ) { maker . set ( { output Typescript : true , output Typescript To : data . target . typescript } ) ; } else if ( typeof data . target . typescript = = "boolean " ) { maker . set ( { output Typescript : true } ) ; } if ( this . argv [ "typescript " ] ) { maker . set ( { output Typescript : true } ) ; } if ( data . environment ) { maker . set Environment ( data . environment ) ; } if ( data . target . environment ) { target . set Environment ( data . target . environment ) ; } if ( data [ "path -mappings " ] ) { for ( var from in data [ "path -mappings " ] ) { var to = data [ "path -mappings " ] [ from ] ; target . add Path Mapping ( from , to ) ; } } function merge Array ( dest , . . . srcs ) { srcs . for Each ( function ( src ) { if ( src ) { src . for Each ( function ( elem ) { if ( ! qx . lang . Array . contains ( dest , src ) ) { dest . push ( elem ) ; } } ) ; } } ) ; return dest ; } let babel Options = data . babel Options | | { } ; qx . lang . Object . merge With ( babel Options , data . target . babel Options | | { } ) ; maker . get Analyser ( ) . set Babel Options ( babel Options ) ; var add Created At = data . target [ "add Created At " ] | | t . argv [ "add Created At " ] ; if ( add Created At ) { maker . get Analyser ( ) . set Add Created At ( true ) ; } var app Names = null ; if ( t . argv [ "app -name " ] ) { app Names = t . argv [ "app -name " ] . split ( " , " ) ; } let has Explicit Default App = false ; let default App = null ; data . applications . for Each ( function ( app Data , app Index ) { if ( app Names & & app Names . index Of ( app Data . name ) = = = - 1 ) { return ; } var app = new qx . tool . compiler . app . Application ( app Data [ "class " ] ) ; [ "type " , "theme " , "name " , "environment " , "output Path " , "boot Path " , "loader Template " ] . for Each ( name = > { if ( app Data [ name ] ! = = undefined ) { var fname = "set " + qx . lang . String . first Up ( name ) ; app [ fname ] ( app Data [ name ] ) ; } } ) ; if ( app . is Browser App ( ) ) { var set Default ; if ( app Data . write Index Html To Root ! = = undefined ) { qx . tool . compiler . Console . print ( "qx .tool .cli .compile .deprecated Compile See Other " , "application .write Index Html To Root " , "application .default " ) ; set Default = app Data . write Index Html To Root ; } else if ( app Data [ "default " ] ! = = undefined ) { set Default = app Data [ "default " ] ; } if ( set Default ! = = undefined ) { if ( set Default ) { if ( has Explicit Default App ) { throw new qx . tool . cli . Utils . User Error ( "Error : Can only set one application to be the default application ! " ) ; } has Explicit Default App = true ; default App = app ; } } else if ( ! default App ) { default App = app ; } } if ( app Data . uri ) { qx . tool . compiler . Console . print ( "qx .tool .cli .compile .deprecated Uri " , "application .uri " , app Data . uri ) ; } if ( app Data . title ) { app . set Title ( app Data . title ) ; } 
async function ( maker , contribs ) { let errors = [ ] ; let libs = maker . get Analyser ( ) . get Libraries ( ) ; const SDK _VERSION = await this . get User Qx Version ( ) ; 
function ( type ) { if ( ! type ) { return null ; } if ( type . $ $type = = "Class " ) { return type ; } if ( type = = "build " ) { return qx . tool . compiler . targets . Build Target ; } if ( type = = "source " ) { return qx . tool . compiler . targets . Source Target ; } if ( type = = "typescript " ) { throw new qx . tool . cli . Utils . User Error ( "Typescript targets are no longer supported - please use `typescript : true ` in source target instead " ) ; } if ( type ) { var target Class ; if ( type . index Of ( " . " ) < 0 ) { target Class = qx . Class . get By Name ( "qx .tool .compiler .targets . " + type ) ; } else { target Class = qx . Class . get By Name ( type ) ; } return target Class ; } return null ; } 
function ( analyser ) { this . base ( arguments ) ; this . _ _analyser = analyser ; this . _ _db Filename = analyser . get Res Db Filename ( ) | | "resource -db .json " ; this . _ _handlers = [ new qx . tool . compiler . resources . Image Handler ( ) , new qx . tool . compiler . resources . Meta Handler ( ) , new qx . tool . compiler . resources . Scss Handler ( this . _ _analyser ) ] ; } 
function ( callback ) { var t = this ; async . waterfall ( [ function read Db ( callback ) { fs . exists ( t . _ _db Filename , function ( exists ) { if ( exists ) { fs . read File ( t . _ _db Filename , { encoding : "utf - 8 " } , callback ) ; } else { callback ( null , null ) ; } } ) ; } , function parse Db ( data , callback ) { t . _ _db = data & & data . trim ( ) . length ? jsonlint . parse ( data ) : { } ; callback ( null , t . _ _db ) ; } ] , callback ) ; } 
function ( callback ) { log . debug ( "saving resource manager database " ) ; return qx . tool . compiler . utils . Json . save Json Async ( this . _ _db Filename , this . _ _db ) ; } 
function ( uri ) { var t = this ; 
function scan Dir ( root Dir , dir , resource , do Not Copy , callback ) { 
function ( src Paths ) { var t = this ; var db = this . _ _db ; 
async function ( data ) { let t = this ; let result = { } ; return new Promise ( ( resolve , reject ) = > { async . for Each ( data . libraries , function ( path , cb ) { t . _ _add Library ( path , result , cb ) ; } , function ( err ) { if ( err ) { reject ( err ) ; } else { resolve ( result ) ; } } ) ; } ) ; } 
function ( root Dir , result , cb ) { var lib = new qx . tool . compiler . app . Library ( ) ; lib . load Manifest ( root Dir , function ( err ) { if ( ! err ) { let s = lib . get Namespace ( ) ; let libs = s . split ( " . " ) ; result [ libs [ 0 ] ] = false ; } return cb & & cb ( err , lib ) ; } ) ; } 
function ( str ) { if ( str = = = null ) { return null ; } str = str . trim ( ) ; if ( ! str ) { return null ; } var ast = Json To Ast . parse To Ast ( str ) ; var json = Json To Ast . ast To Object ( ast ) ; return json ; } 
async function ( filename ) { if ( ! await fs . exists Async ( filename ) ) { return null ; } var data = await fs . read File Async ( filename , "utf 8 " ) ; try { return qx . tool . compiler . utils . Json . parse Json ( data ) ; } catch ( ex ) { throw new Error ( "Failed to load " + filename + " : " + ex ) ; } } 
async function ( filename , data ) { if ( ! data ) { if ( await fs . exists Async ( filename ) ) { fs . unlink Async ( filename ) ; } } else { await fs . write File Async ( filename , JSON . stringify ( data , null , 2 ) , "utf 8 " ) ; } } 
async function ( compile Info ) { var t = this ; var _arguments = arguments ; var application = compile Info . application ; var target Uri = t . _get Output Root Uri ( application ) ; var app Root Dir = this . get Application Root ( application ) ; 
function ( from , to , filter ) { var t = this ; function copy ( stat From , stat To ) { if ( stat From . is Directory ( ) ) { var p ; if ( stat To = = = null ) { p = mkdir ( to ) ; } else { p = Promise . resolve ( ) ; } return p . then ( ( ) = > readdir ( from ) . then ( files = > Promise . all ( files . map ( file = > t . sync ( from + " / " + file , to + " / " + file , filter ) ) ) ) ) ; } else if ( stat From . is File ( ) ) { return qx . Promise . resolve ( filter ? filter ( from , to ) : true ) . then ( result = > result & & t . copy File ( from , to ) ) ; } return undefined ; } return new Promise ( ( resolve , reject ) = > { var stat From = null ; var stat To = null ; stat ( from ) . then ( tmp = > { stat From = tmp ; return stat ( to ) . then ( tmp = > stat To = tmp ) . catch ( err = > { if ( err . code ! = = "ENOENT " ) { throw err ; } } ) ; } ) . then ( ( ) = > { if ( ! stat To | | stat From . is Directory ( ) ! = stat To . is Directory ( ) ) { return t . delete Recursive ( to ) . then ( ( ) = > copy ( stat From , stat To ) ) ; } else if ( stat From . is Directory ( ) | | ( stat From . mtime . get Time ( ) > stat To . mtime . get Time ( ) | | stat From . size ! = stat To . size ) ) { return copy ( stat From , stat To ) ; } return undefined ; } ) . then ( resolve ) . catch ( reject ) ; } ) ; } 
function ( from , to ) { return new Promise ( ( resolve , reject ) = > { util . mk Parent Path ( to , function ( ) { var rs = fs . create Read Stream ( from , { flags : "r " , encoding : "binary " } ) ; var ws = fs . create Write Stream ( to , { flags : "w " , encoding : "binary " } ) ; rs . on ( "end " , function ( ) { resolve ( ) ; } ) ; rs . on ( "error " , reject ) ; ws . on ( "error " , reject ) ; rs . pipe ( ws ) ; } ) ; } ) ; } 
function ( filename ) { return new Promise ( ( resolve , reject ) = > { fs . stat ( filename , function ( err , stats ) { if ( err & & err . code ! = "ENOENT " ) { reject ( err ) ; } else { resolve ( err ? null : stats ) ; } } ) ; } ) ; } 
function ( filename ) { return new Promise ( ( resolve , reject ) = > { fs . unlink ( filename , function ( err ) { if ( err & & err . code ! = "ENOENT " ) { reject ( err ) ; } else { resolve ( ) ; } } ) ; } ) ; } 
async function ( filename , length ) { if ( await this . safe Stat ( filename ) & & length > 1 ) { var last File = null ; for ( var i = length ; i > 0 ; i - - ) { var tmp = filename + " . " + i ; if ( i = = length ) { await this . safe Unlink ( tmp ) ; } else if ( await this . safe Stat ( tmp ) ) { await rename ( tmp , last File ) ; } last File = tmp ; } await rename ( filename , last File ) ; } } 
function ( name ) { return new Promise ( ( resolve , reject ) = > { rimraf ( name , err = > { if ( err ) { reject ( err ) ; } else { resolve ( ) ; } } ) ; } ) ; } 
function ( dir ) { var drive Prefix = " " ; if ( process . platform = = = "win 3 2 " & & dir . match ( / ^ [a -z A -Z ] : / ) ) { drive Prefix = dir . substring ( 0 , 2 ) ; dir = dir . substring ( 2 ) ; } dir = dir . replace ( / \ \ / g , " / " ) ; var segs = dir . split ( " / " ) ; if ( ! segs . length ) { return drive Prefix + dir ; } var current Dir ; var index ; if ( segs [ 0 ] . length ) { current Dir = " " ; index = 0 ; } else { current Dir = " / " ; index = 1 ; } function bump To Next ( next Seg ) { index + + ; if ( current Dir . length & & current Dir ! = = " / " ) { current Dir + = " / " ; } current Dir + = next Seg ; return next ( ) ; } function next ( ) { if ( index = = segs . length ) { if ( process . platform = = = "win 3 2 " ) { current Dir = current Dir . replace ( / \ / / g , " \ \ " ) ; } return Promise . resolve ( drive Prefix + current Dir ) ; } let next Seg = segs [ index ] ; if ( next Seg = = " . " | | next Seg = = " . . " ) { return bump To Next ( next Seg ) ; } return new Promise ( ( resolve , reject ) = > { fs . readdir ( current Dir . length = = 0 ? " . " : drive Prefix + current Dir , { encoding : "utf 8 " } , ( err , files ) = > { if ( err ) { reject ( err ) ; return ; } let next Lower Case = next Seg . to Lower Case ( ) ; let exact = false ; let insensitive = null ; for ( let i = 0 ; i < files . length ; i + + ) { if ( files [ i ] = = = next Seg ) { exact = true ; break ; } if ( files [ i ] . to Lower Case ( ) = = = next Lower Case ) { insensitive = files [ i ] ; } } if ( ! exact & & insensitive ) { next Seg = insensitive ; } bump To Next ( next Seg ) . then ( resolve ) ; } ) ; } ) ; } return new Promise ( ( resolve , reject ) = > { fs . stat ( drive Prefix + dir , err = > { if ( err ) { if ( err . code = = "ENOENT " ) { resolve ( drive Prefix + dir ) ; } else { reject ( err ) ; } } else { next ( ) . then ( resolve ) ; } } ) ; } ) ; } 
function ( ) { if ( qx . core . Environment . get ( "runtime .name " ) = = "rhino " ) { qx . log . Logger . register ( qx . log . appender . Rhino Console ) ; } else if ( qx . core . Environment . get ( "runtime .name " ) = = "node .js " ) { qx . log . Logger . register ( qx . log . appender . Node Console ) ; } if ( window . arguments ) { try { this . _arguments To Settings ( window . arguments ) ; } catch ( ex ) { this . error ( ex . to String ( ) ) ; return ; } } this . info ( "Hello World ! " ) ; } 
function ( args ) { var opts ; for ( var i = 0 , l = args . length ; i < l ; i + + ) { if ( args [ i ] . index Of ( "settings = " ) = = 0 ) { opts = args [ i ] . substr ( 9 ) ; break ; } else if ( args [ i ] . index Of ( " 'settings = " ) = = 0 ) { opts = / 'settings \ = ( . * ? ) ' / . exec ( args [ i ] ) [ 1 ] ; break ; } } if ( opts ) { opts = opts . replace ( / \ \ \ { / g , " { " ) . replace ( / \ \ \ } / g , " } " ) ; opts = qx . lang . Json . parse ( opts ) ; for ( var prop in opts ) { var value = opts [ prop ] ; if ( typeof value = = "string " ) { value = value . replace ( / \ $ $ / g , " " ) ; } try { qx . core . Environment . add ( prop , value ) ; } catch ( ex ) { this . error ( "Unable to define command -line setting " + prop + " : " + ex ) ; } } } } 
function Sortable Directive ( $timeout ) { return { restrict : 'A ' , scope : { is Sortable : ' =sortable ' , on Sortable Sort : ' & ' } , link : function ( $scope , $element , $attrs ) { var root El = $element [ 0 ] , drag El , next El , drop El ; function isbefore ( a , b ) { if ( a . parent Node = = b . parent Node ) { for ( var cur = a ; cur ; cur = cur . previous Sibling ) { if ( cur = = = b ) { return true ; } } } return false ; } ; function on Drag Enter ( e ) { var target = e . target ; if ( isbefore ( drag El , target ) ) { target . parent Node . insert Before ( drag El , target ) ; } else if ( target . next Sibling & & target . has Attribute ( 'draggable ' ) ) { target . parent Node . insert Before ( drag El , target . next Sibling . next Sibling ) ; } } ; function on Drag End ( evt ) { evt . prevent Default ( ) ; drag El . class List . remove ( 'dt -clone ' ) ; $element . off ( 'dragend ' , on Drag End ) ; $element . off ( 'dragenter ' , on Drag Enter ) ; if ( next El ! = = drag El . next Sibling ) { $scope . on Sortable Sort ( { event : evt , column Id : angular . element ( drag El ) . attr ( 'data -id ' ) } ) ; } } ; function on Drag Start ( evt ) { if ( ! $scope . is Sortable ) return false ; evt = evt . original Event | | evt ; drag El = evt . target ; next El = drag El . next Sibling ; drag El . class List . add ( 'dt -clone ' ) ; evt . data Transfer . effect Allowed = 'move ' ; evt . data Transfer . set Data ( 'Text ' , drag El . text Content ) ; $element . on ( 'dragenter ' , on Drag Enter ) ; $element . on ( 'dragend ' , on Drag End ) ; } ; $element . on ( 'dragstart ' , on Drag Start ) ; $scope . $on ( ' $destroy ' , ( ) = > { $element . off ( 'dragstart ' , on Drag Start ) ; } ) ; } } } 
function Resizable Directive ( $document , $timeout ) { return { restrict : 'A ' , scope : { is Resizable : ' =resizable ' , min Width : ' = ' , max Width : ' = ' , on Resize : ' & ' } , link : function ( $scope , $element , $attrs ) { if ( $scope . is Resizable ) { $element . add Class ( 'resizable ' ) ; } var handle = angular . element ( ` ` ) , parent = $element . parent ( ) , prev Screen X ; handle . on ( 'mousedown ' , function ( event ) { if ( ! $element [ 0 ] . class List . contains ( 'resizable ' ) ) { return false ; } event . stop Propagation ( ) ; event . prevent Default ( ) ; $document . on ( 'mousemove ' , mousemove ) ; $document . on ( 'mouseup ' , mouseup ) ; } ) ; function mousemove ( event ) { event = event . original Event | | event ; var width = parent [ 0 ] . client Width , movement X = event . movement X | | event . moz Movement X | | ( event . screen X - prev Screen X ) , new Width = width + ( movement X | | 0 ) ; prev Screen X = event . screen X ; if ( ( ! $scope . min Width | | new Width > = $scope . min Width ) & & ( ! $scope . max Width | | new Width < = $scope . max Width ) ) { parent . css ( { width : new Width + 'px ' } ) ; } } function mouseup ( ) { if ( $scope . on Resize ) { $timeout ( function ( ) { let width = parent [ 0 ] . client Width ; if ( width < $scope . min Width ) { width = $scope . min Width ; } $scope . on Resize ( { width : width } ) ; } ) ; } $document . unbind ( 'mousemove ' , mousemove ) ; $document . unbind ( 'mouseup ' , mouseup ) ; } $element . append ( handle ) ; } } ; } 
function Scale Columns ( cols By Group , max Width , total Flex Grow ) { 
function Get Total Flex Grow ( columns ) { var total Flex Grow = 0 ; for ( let c of columns ) { total Flex Grow + = c . flex Grow | | 0 ; } return total Flex Grow ; } 
function Force Fill Column Widths ( all Columns , expected Width , start Idx ) { var content Width = 0 , columns To Resize = start Idx > - 1 ? all Columns . slice ( start Idx , all Columns . length ) . filter ( ( c ) = > { return c . can Auto Resize } ) : all Columns . filter ( ( c ) = > { return c . can Auto Resize } ) ; all Columns . for Each ( ( c ) = > { if ( ! c . can Auto Resize ) { content Width + = c . width ; } else { content Width + = ( c . $ $old Width | | c . width ) ; } } ) ; var remaining Width = expected Width - content Width , addition Width Per Column = remaining Width / columns To Resize . length , exceeds Window = content Width > expected Width ; columns To Resize . for Each ( ( column ) = > { if ( exceeds Window ) { column . width = column . $ $old Width | | column . width ; } else { if ( ! column . $ $old Width ) { column . $ $old Width = column . width ; } var new Size = column . $ $old Width + addition Width Per Column ; if ( column . min With & & new Size < column . min Width ) { column . width = column . min Width ; } else if ( column . max Width & & new Size > column . max Width ) { column . width = column . max Width ; } else { column . width = new Size ; } } } ) ; } 
function PDU ( ) { this . type = asn 1ber . pdu Types . Get Request PDU ; this . reqid = 1 ; this . error = 0 ; this . error Index = 0 ; this . varbinds = [ new Var Bind ( ) ] ; } 
function concat Buffers ( buffers ) { var total , cur = 0 , buf ; 
function clear Request ( reqs , reqid ) { var self = this ; var entry = reqs [ reqid ] ; if ( entry ) { if ( entry . timeout ) { clear Timeout ( entry . timeout ) ; } delete reqs [ reqid ] ; } } 
function parse Single Oid ( oid ) { if ( typeof oid ! = = 'string ' ) { return oid ; } if ( oid [ 0 ] ! = = ' . ' ) { throw new Error ( 'Invalid OID format ' ) ; } oid = oid . split ( ' . ' ) . filter ( function ( s ) { return s . length > 0 ; } ) . map ( function ( s ) { return parse Int ( s , 1 0 ) ; } ) ; return oid ; } 
function parse Oids ( options ) { if ( options . oid ) { options . oid = parse Single Oid ( options . oid ) ; } if ( options . oids ) { options . oids = options . oids . map ( parse Single Oid ) ; } } 
function defaults ( targ , _defs ) { [ ] . slice . call ( arguments , 1 ) . for Each ( function ( def ) { Object . keys ( def ) . for Each ( function ( key ) { if ( ! targ . has Own Property ( key ) ) { targ [ key ] = def [ key ] ; } } ) ; } ) ; } 
function encode ( pkt ) { var version , community , reqid , err , erridx , vbs , pdu , message ; 
function parse ( buf ) { var pkt , oid , bvb , vb , hdr , vbhdr ; pkt = new Packet ( ) ; 
function compare Oids ( oid A , oid B ) { var mlen , i ; 
function msg Received ( msg , rinfo ) { var self = this , now = Date . now ( ) , pkt , entry ; if ( msg . length = = = 0 ) { 
function Session ( options ) { var self = this ; self . options = options | | { } ; defaults ( self . options , exports . default Options ) ; self . reqs = { } ; self . socket = dgram . create Socket ( self . options . family ) ; self . socket . on ( 'message ' , msg Received . bind ( self ) ) ; self . socket . on ( 'close ' , function ( ) { 
function in Tree ( root , oid ) { var i ; if ( oid . length < = root . length ) { return false ; } for ( i = 0 ; i < root . length ; i + + ) { if ( oid [ i ] ! = = root [ i ] ) { return false ; } } return true ; } 
function result ( error , varbinds ) { if ( combined Timeout Expired ) { return ; } if ( error ) { clear Timeout ( combined Timeout Timer ) ; callback ( error ) ; } else { if ( in Tree ( options . start Oid , varbinds [ 0 ] . oid ) ) { if ( varbinds [ 0 ] . value = = = 'end Of Mib View ' | | varbinds [ 0 ] . value = = = 'no Such Object ' | | varbinds [ 0 ] . value = = = 'no Such Instance ' ) { clear Timeout ( combined Timeout Timer ) ; callback ( null , vbs ) ; } else if ( vbs . length & & compare Oids ( vbs . slice ( - 1 ) [ 0 ] . oid , varbinds [ 0 ] . oid ) ! = = 1 ) { return callback ( new Error ( 'OID not increasing ' ) ) ; } else { vbs . push ( varbinds [ 0 ] ) ; var next = { oid : varbinds [ 0 ] . oid } ; defaults ( next , options ) ; self . get Next ( next , result ) ; } } else { clear Timeout ( combined Timeout Timer ) ; callback ( null , vbs ) ; } } } 
function length Array ( len ) { var arr = [ ] ; if ( len < = 1 2 7 ) { 
function wrapper ( type , contents ) { var buf , len , i ; 
function oid Int ( val ) { var bytes = [ ] ; bytes . push ( val % 1 2 8 ) ; val = parse Int ( val / 1 2 8 , 1 0 ) ; while ( val > 1 2 7 ) { bytes . push ( 1 2 8 + val % 1 2 8 ) ; val = parse Int ( val / 1 2 8 , 1 0 ) ; } bytes . push ( val + 1 2 8 ) ; return bytes . reverse ( ) ; } 
function oid Array ( oid ) { var bytes , i , val ; 
function int Array ( val ) { var array = [ ] , enc Val = val , bytes ; if ( val = = = 0 ) { array . push ( 0 ) ; } else { if ( val < 0 ) { bytes = Math . floor ( 1 + Math . log ( - val ) / LOG 2 5 6 ) ; 
function encode Integerish ( val , type ) { var i , arr , buf ; 
function type And Length ( buf ) { var res , len , i ; res = { type : buf [ 0 ] , len : 0 , header : 1 } ; if ( buf [ 1 ] < 1 2 8 ) { 
function proxies Remaining ( proxy Data ) { return Object . keys ( proxy Data ) . filter ( key = > proxy Data [ key ] = = null ) ; } 
function maybe Get New Token ( ) { let user = options . user | | options . username ; if ( ! options . passcode & & ( ! user | | ! options . password ) ) { throw new Error ( "missing username or password " ) ; } if ( ! options . no _token ) { org = new Organization ( c ) ; c . org = org ; let arg 1 = { password : options . password } ; 
function load Keys Into Map ( org , cb ) { var uuid = uuid V 4 ( ) ; var re = new Reg Exp ( ' ( ? : \r \n | \r | \n ) ' , 'g ' ) ; var keypair = new Node RSA ( { b : opt . options . keystrength } ) ; var public Key Pem = keypair . export Key ( 'pkcs 8 -public -pem ' ) . replace ( re , ' \ \n ' ) ; var private Key Pem = keypair . export Key ( 'pkcs 8 -private -pem ' ) . replace ( re , ' \ \n ' ) ; var options = { env : opt . options . env , kvm : opt . options . privkeysmap , key : 'private _ _ ' + uuid , value : private Key Pem } ; common . log Write ( sprintf ( 'provisioning new key %s ' , uuid ) ) ; org . kvms . put ( options , function ( e , result ) { if ( e ) return cb ( e , result ) ; options . kvm = opt . options . pubkeysmap ; options . key = 'public _ _ ' + uuid ; options . value = public Key Pem ; org . kvms . put ( options , function ( e , result ) { if ( e ) return cb ( e , result ) ; options . kvm = opt . options . kidmap ; options . key = 'current Kid ' ; options . value = uuid ; org . kvms . put ( options , function ( e , result ) { if ( e ) return cb ( e , result ) ; cb ( null , result ) ; } ) ; } ) ; } ) ; } 
function resolve Expiry ( subject ) { var pattern = new Reg Exp ( ' ^ ( [ 1 - 9 ] [ 0 - 9 ] * ) ( [smhdw ] ) $ ' , 'i ' ) ; var multipliers = { s : 1 , m : 6 0 , h : 6 0 * 6 0 , d : 6 0 * 6 0 * 2 4 , w : 6 0 * 6 0 * 2 4 * 7 , y : 6 0 * 6 0 * 2 4 * 3 6 5 } ; var match = pattern . exec ( subject ) ; if ( match ) { return match [ 1 ] * multipliers [ match [ 2 ] ] * 1 0 0 0 ; } return - 1 ; } 
function insure Fresh Token ( conn , cb ) { var rh = conn . request Headers ; if ( rh & & rh . authorization & & conn . user & & rh . authorization . index Of ( 'Bearer ' ) = = = 0 ) { var stashed Token = token Mgmt . current Token ( conn . user , conn . login Base Url , conn . mgmt Server ) ; if ( token Mgmt . is Invalid Or Expired ( stashed Token ) ) { return conn . refresh Token ( stashed Token , function ( e , result ) { if ( e ) { throw new Error ( 'error refreshing token : ' + e ) ; } cb ( merge ( true , { headers : rh } ) ) ; } ) ; } else { cb ( merge ( true , { headers : rh } ) ) ; } } else { cb ( merge ( true , { headers : rh } ) ) ; } } 
function load Key Into Map ( org , cb ) { var re = new Reg Exp ( ' ( ? : \r \n | \r | \n ) ' , 'g ' ) ; var pemcontent = fs . read File Sync ( opt . options . pemfile , "utf 8 " ) . replace ( re , ' \n ' ) ; var options = { env : opt . options . env , kvm : opt . options . mapname , key : opt . options . entryname , value : pemcontent } ; common . log Write ( 'storing new key ' ) ; org . kvms . put ( options , cb ) ; } 
function rev Env Reducer ( org , name , revision ) { return ( p , env ) = > p . then ( ( ) = > org . proxies . undeploy ( { name , revision , environment : env . name } ) ) ; } 
function ( arg ) { var value = arg . value ; var flag = arg . flag ; var result = null ; if ( value ) { value = Array . is Array ( value ) ? value : [ value ] ; result = [ ] ; value . for Each ( function ( path ) { result . push ( flag ) ; result . push ( path ) ; } ) ; } return result ; } 
function get Cosmi Config ( ) { try { const config = cosmiconfig ( 'iopipe ' , { cache : false , sync : true , rc Extensions : true } ) . load ( ) ; if ( config ! = = null ) { return config . config ; } } catch ( err ) { void 0 ; 
function require From String ( src , args ) { if ( ! src ) { return undefined ; } 
function get Plugins ( plugins ) { if ( typeof plugins ! = = 'object ' | | ! Array . is Array ( plugins ) ) return undefined ; return plugins . filter ( Boolean ) . map ( plugin = > { if ( Array . is Array ( plugin ) ) { 
function get Cosmi Config ( ) { try { const config = require ( config Path ) ; if ( typeof config = = = 'object ' & & typeof config . iopipe = = = 'object ' ) { return config . iopipe ; } } catch ( err ) { Function . prototype ; 
function execute Uploaded ( ) { console . log ( 'Running acceptance test invocations ' ) ; Promise . all ( arns . map ( arn = > { return lambda . invoke ( { Invocation Type : 'Request Response ' , Function Name : arn , Payload : JSON . stringify ( { test : true } ) } ) . promise ( ) ; } ) ) . then ( ( [ fn 1 , fn 2 , fn 3 , fn 4 ] ) = > { const bool = every ( [ fn 1 . Status Code = = = 2 0 0 , fn 1 . Payload = = = ' "callback " ' , fn 2 . Status Code = = = 2 0 0 , fn 2 . Payload = = = ' "context .succeed " ' , fn 3 . Status Code = = = 2 0 0 , fn 3 . Function Error = = = 'Handled ' , fn 3 . Payload = = = JSON . stringify ( { error Message : 'context .fail ' } ) , fn 4 . Status Code = = = 2 0 0 , fn 4 . Payload = = = ' "context .done " ' ] ) ; if ( bool ) { console . log ( 'Acceptance test passed . ' ) ; return process . exit ( 0 ) ; } console . error ( 'Acceptance test failed . ' ) ; console . error ( 'Results : ' , JSON . stringify ( [ fn 1 , fn 2 , fn 3 , fn 4 ] ) ) ; return process . exit ( 1 ) ; } ) . catch ( err = > { console . error ( err ) ; process . exit ( 1 ) ; } ) ; } 
function setup Timeout Capture ( wrapper Instance ) { const { context , send Report , config } = wrapper Instance ; const { get Remaining Time In Millis = ( ) = > 0 } = context ; 
function center ( node ) { return node . target Links . length ? node . depth : node . source Links . length ? min ( node . source Links , target Depth ) - 1 : 0 ; } 
function scale Sankey Size ( graph , margin ) { var max Column = max ( graph . nodes , function ( node ) { return node . column ; } ) ; var current Width = x 1 - x 0 ; var current Height = y 1 - y 0 ; var new Width = current Width + margin . right + margin . left ; var new Height = current Height + margin . top + margin . bottom ; var scale X = current Width / new Width ; var scale Y = current Height / new Height ; x 0 = x 0 * scale X + margin . left ; x 1 = margin . right = = 0 ? x 1 : x 1 * scale X ; y 0 = y 0 * scale Y + margin . top ; y 1 = y 1 * scale Y ; graph . nodes . for Each ( function ( node ) { node . x 0 = x 0 + node . column * ( ( x 1 - x 0 - dx ) / max Column ) ; node . x 1 = node . x 0 + dx ; } ) ; return scale Y ; } 
function compute Node Depths ( graph ) { var nodes , next , x ; for ( nodes = graph . nodes , next = [ ] , x = 0 ; nodes . length ; + + x , nodes = next , next = [ ] ) { nodes . for Each ( function ( node ) { node . depth = x ; node . source Links . for Each ( function ( link ) { if ( next . index Of ( link . target ) < 0 & & ! link . circular ) { next . push ( link . target ) ; } } ) ; } ) ; } for ( nodes = graph . nodes , next = [ ] , x = 0 ; nodes . length ; + + x , nodes = next , next = [ ] ) { nodes . for Each ( function ( node ) { node . height = x ; node . target Links . for Each ( function ( link ) { if ( next . index Of ( link . source ) < 0 & & ! link . circular ) { next . push ( link . source ) ; } } ) ; } ) ; } 
function compute Node Breadths ( graph , iterations , id ) { var columns = nest ( ) . key ( function ( d ) { return d . column ; } ) . sort Keys ( ascending ) . entries ( graph . nodes ) . map ( function ( d ) { return d . values ; } ) ; initialize Node Breadth ( id ) ; resolve Collisions ( ) ; for ( var alpha = 1 , n = iterations ; n > 0 ; - - n ) { relax Left And Right ( alpha * = 0 . 9 9 , id ) ; resolve Collisions ( ) ; } function initialize Node Breadth ( id ) { 
function sort Link Column Ascending ( link 1 , link 2 ) { if ( link Column Distance ( link 1 ) = = link Column Distance ( link 2 ) ) { return link 1 . circular Link Type = = 'bottom ' ? sort Link Source YDescending ( link 1 , link 2 ) : sort Link Source YAscending ( link 1 , link 2 ) ; } else { return link Column Distance ( link 2 ) - link Column Distance ( link 1 ) ; } } 
function link Perpendicular YTo Link Target ( longer Link , shorter Link ) { 
function sort Source Links ( graph , y 1 , id , move Nodes ) { graph . nodes . for Each ( function ( node ) { 
function self Linking ( link , id ) { return get Node ID ( link . source , id ) = = get Node ID ( link . target , id ) ; } 
function ascending Source Breadth ( a , b ) { return ascending Breadth ( a . source , b . source ) | | a . index - b . index } 
function ascending Target Breadth ( a , b ) { return ascending Breadth ( a . target , b . target ) | | a . index - b . index } 
function ascending Breadth ( a , b ) { if ( a . part Of Cycle = = = b . part Of Cycle ) { return a . y 0 - b . y 0 } else { if ( a . circular Link Type = = = 'top ' | | b . circular Link Type = = = 'bottom ' ) { return - 1 } else { return 1 } } } 
function find ( node By Id , id ) { var node = node By Id . get ( id ) if ( ! node ) throw new Error ( 'missing : ' + id ) return node } 
function compute Node Links ( graph ) { graph . nodes . for Each ( function ( node , i ) { node . index = i node . source Links = [ ] node . target Links = [ ] } ) var node By Id = map ( graph . nodes , id ) graph . links . for Each ( function ( link , i ) { link . index = i var source = link . source var target = link . target if ( typeof source ! = = 'object ' ) { source = link . source = find ( node By Id , source ) } if ( typeof target ! = = 'object ' ) { target = link . target = find ( node By Id , target ) } source . source Links . push ( link ) target . target Links . push ( link ) } ) return graph } 
function relax Left And Right ( alpha , id ) { var columns Length = columns . length columns . for Each ( function ( nodes ) { var n = nodes . length var depth = nodes [ 0 ] . depth nodes . for Each ( function ( node ) { 
function resolve Collisions ( ) { columns . for Each ( function ( nodes ) { var node , dy , y = y 0 , n = nodes . length , i 
function compute Link Breadths ( graph ) { graph . nodes . for Each ( function ( node ) { node . source Links . sort ( ascending Target Breadth ) node . target Links . sort ( ascending Source Breadth ) } ) graph . nodes . for Each ( function ( node ) { var y 0 = node . y 0 var y 1 = y 0 
function identify Circles ( graph , id , sort Nodes ) { var circular Link ID = 0 if ( sort Nodes = = = null ) { 
function select Circular Link Types ( graph , id ) { var number Of Tops = 0 var number Of Bottoms = 0 graph . links . for Each ( function ( link ) { if ( link . circular ) { 
function link Angle ( link ) { var adjacent = Math . abs ( link . y 1 - link . y 0 ) var opposite = Math . abs ( link . target . x 0 - link . source . x 1 ) return Math . atan ( opposite / adjacent ) } 
function circular Links Cross ( link 1 , link 2 ) { if ( link 1 . source . column < link 2 . target . column ) { return false } else if ( link 1 . target . column > link 2 . source . column ) { return false } else { return true } } 
function number Of Non Self Linking Cycles ( node , id ) { var source Count = 0 node . source Links . for Each ( function ( l ) { source Count = l . circular & & ! self Linking ( l , id ) ? source Count + 1 : source Count } ) var target Count = 0 node . target Links . for Each ( function ( l ) { target Count = l . circular & & ! self Linking ( l , id ) ? target Count + 1 : target Count } ) return source Count + target Count } 
function only Circular Link ( link ) { var node Source Links = link . source . source Links var source Count = 0 node Source Links . for Each ( function ( l ) { source Count = l . circular ? source Count + 1 : source Count } ) var node Target Links = link . target . target Links var target Count = 0 node Target Links . for Each ( function ( l ) { target Count = l . circular ? target Count + 1 : target Count } ) if ( source Count > 1 | | target Count > 1 ) { return false } else { return true } } 
function calc Vertical Buffer ( links , circular Link Gap , id ) { links . sort ( sort Link Column Ascending ) links . for Each ( function ( link , i ) { var buffer = 0 if ( self Linking ( link , id ) & & only Circular Link ( link ) ) { link . circular Path Data . vertical Buffer = buffer + link . width / 2 } else { var j = 0 for ( j ; j < i ; j + + ) { if ( circular Links Cross ( links [ i ] , links [ j ] ) ) { var buffer Over This Link = links [ j ] . circular Path Data . vertical Buffer + links [ j ] . width / 2 + circular Link Gap buffer = buffer Over This Link > buffer ? buffer Over This Link : buffer } } link . circular Path Data . vertical Buffer = buffer + link . width / 2 } } ) return links } 
function create Circular Path String ( link ) { var path String = ' ' 
function resolve Node Link Overlaps ( graph , y 0 , y 1 , id ) { graph . links . for Each ( function ( link ) { if ( link . circular ) { return } if ( link . target . column - link . source . column > 1 ) { var column To Test = link . source . column + 1 var max Column To Test = link . target . column - 1 var i = 1 var number Of Columns To Test = max Column To Test - column To Test + 1 for ( column To Test , ( i = 1 ) ; column To Test < = max Column To Test ; column To Test + + , i + + ) { graph . nodes . for Each ( function ( node ) { if ( node . column = = column To Test ) { var t = i / ( number Of Columns To Test + 1 ) 
function nodes Overlap ( node A , node B ) { 
function adjust Node Height ( node , dy , sankey Y 0 , sankey Y 1 ) { if ( ( node . y 0 + dy > = sankey Y 0 ) & & ( node . y 1 + dy < = sankey Y 1 ) ) { node . y 0 = node . y 0 + dy node . y 1 = node . y 1 + dy node . target Links . for Each ( function ( l ) { l . y 1 = l . y 1 + dy } ) node . source Links . for Each ( function ( l ) { l . y 0 = l . y 0 + dy } ) } return node } 
function Pastebin ( config ) { if ( typeof config = = = 'string ' ) { config = { api _dev _key : config } ; } this . config = _ . extend ( conf . defaults , config ) ; } 
function run With Callback ( promise Func , callback ) { if ( ! _ . is Function ( callback ) ) { throw new Error ( 'This function requires a callback ! ' ) ; } promise Func . then ( function ( data ) { callback ( null , data ) ; } ) . catch ( function ( err ) { callback ( err , null ) ; } ) ; } 
function Poloniex ( key , secret ) { if ( key & & secret ) { authenticated = true ; } 
function ( options , callback ) { if ( ! ( 'headers ' in options ) ) { options . headers = { } ; } options . json = true ; options . headers [ 'User -Agent ' ] = Poloniex . USER _AGENT ; options . strict SSL = Poloniex . STRICT _SSL ; options . timeout = Poloniex . TIMEOUT ; return new Promise ( function ( resolve , reject ) { request ( options , function ( err , response , body ) { 
function ( command , parameters , callback ) { if ( typeof parameters = = = 'function ' ) { callback = parameters ; parameters = { } ; } parameters | | ( parameters = { } ) ; parameters . command = command ; const options = { method : 'GET ' , url : PUBLIC _API _URL , qs : parameters } ; options . qs . command = command ; return this . _request ( options , callback ) ; } 
function ( command , parameters , callback ) { if ( typeof parameters = = = 'function ' ) { callback = parameters ; parameters = { } ; } parameters | | ( parameters = { } ) ; parameters . command = command ; parameters . nonce = nonce ( ) ; const options = { method : 'POST ' , url : PRIVATE _API _URL , form : parameters , headers : this . _get Private Headers ( parameters ) } ; return this . _request ( options , callback ) ; } 
function ( currency A , currency B , callback ) { if ( typeof currency B = = = 'function ' ) { callback = currency B ; currency B = null ; } const parameters = { currency Pair : join Currencies ( currency A , currency B ) } ; return this . _private ( 'return Open Orders ' , parameters , callback ) ; } 
function spawn Child Process ( bin , args , option ) { const result = spawn Cancelable Child ( bin , args , option ) ; return result . process ; } 
function spawn Cancelable Child ( bin , args , option ) { let inner Cancel = null ; let is Canceled = false ; const canceller = function ( ) { if ( is Canceled ) { return ; } is Canceled = true ; if ( typeof inner Cancel = = = 'function ' ) { inner Cancel ( ) ; } } ; const process = new Promise ( function ( resolve , reject ) { if ( is Canceled ) { reject ( ) ; return ; } console . log ( 'spawn : ' + bin + ' ' + args . join ( ' ' ) ) ; const proc = child Process . spawn ( bin , args , option ) ; inner Cancel = function ( ) { proc . kill ( 'SIGINT ' ) ; } ; proc . on ( 'exit ' , function ( status ) { resolve ( status ) ; } ) ; } ) ; return { canceller , process , } ; } 
function Cas Strategy ( options , verify ) { if ( typeof options = = 'function ' ) { verify = options ; options = undefined ; } options = options | | { } ; if ( ! verify ) { throw new Type Error ( 'Cas Strategy requires a verify callback ' ) ; } if ( ! options . cas URL ) { throw new Type Error ( 'Cas Strategy requires a cas URL option ' ) ; } Strategy . call ( this ) ; this . name = 'cas ' ; this . _verify = verify ; this . _pass Req To Callback = options . pass Req To Callback ; this . cas Base Url = options . cas URL ; this . cas Pgt Url = options . pgt URL | | undefined ; this . cas Property Map = options . property Map | | { } ; this . cas Session Key = options . session Key | | 'cas ' ; this . cas = new CAS ( { base _url : this . cas Base Url , version : 2 , external _pgt _url : this . cas Pgt Url , ssl _cert : options . ssl Cert , ssl _key : options . ssl Key , ssl _ca : options . ssl CA } ) ; } 
function Pgt Server ( cas URL , pgt URL , server Certificate , server Key , server CA ) { var parsed URL = url . parse ( pgt URL ) ; var cas = new CAS ( { base _url : cas URL , version : 2 . 0 , pgt _server : true , pgt _host : parsed URL . hostname , pgt _port : parsed URL . port , ssl _key : server Key , ssl _cert : server Certificate , ssl _ca : server CA | | null } ) ; } 
function ( element , link ) { / / Normalize the link parameter if ( angular . is Function ( link ) ) { link = { post : link } ; } var compiled Contents ; return { pre : ( link & & link . pre ) ? link . pre : null , post : function ( scope , element , attrs , trvw ) { / / Compile our template if ( ! compiled Contents ) { compiled Contents = $compile ( trvw . get Node Tpl ( ) ) ; } / / Add the compiled template compiled Contents ( scope , function ( clone ) { element . append ( clone ) ; } ) ; / / Call the post -linking function , if any if ( link & & link . post ) { link . post . apply ( null , arguments ) ; } } } ; } 
function ( scope , element , attrs , trvw ) { / / Compile our template if ( ! compiled Contents ) { compiled Contents = $compile ( trvw . get Node Tpl ( ) ) ; } / / Add the compiled template compiled Contents ( scope , function ( clone ) { element . append ( clone ) ; } ) ; / / Call the post -linking function , if any if ( link & & link . post ) { link . post . apply ( null , arguments ) ; } } 
function ( href , attributes ) { var head = document . head | | document . get Elements By Tag Name ( 'head ' ) [ 0 ] ; var link = document . create Element ( 'link ' ) ; link . href = href ; link . rel = 'stylesheet ' ; for ( var key in attributes ) { if ( ! attributes . has Own Property ( key ) ) { continue ; } var value = attributes [ key ] ; link . set Attribute ( 'data - ' + key , value ) ; } head . append Child ( link ) ; } 
function ( css Text , attributes , extra Options ) { extra Options = extra Options | | { } ; var style = document . create Element ( 'style ' ) ; style . type = 'text /css ' ; for ( var key in attributes ) { if ( ! attributes . has Own Property ( key ) ) { continue ; } var value = attributes [ key ] ; style . set Attribute ( 'data - ' + key , value ) ; } if ( style . sheet ) { 
function ( base Dir , import Path ) { var parts = import Path . split ( ' / ' ) ; var pathname = path . join ( base Dir , import Path ) ; if ( parts [ 0 ] = = = 'node _modules ' ) { 
function ( image File , mime Type ) { 
function ( options , callback ) { if ( _ . is Function ( options ) & & ! callback ) { callback = options ; options = { } ; } options = _ . clone ( options ) ; bootcode ( function ( err , code ) { if ( err ) { return callback ( err ) ; } if ( ! code ) { return callback ( new Error ( 'sandbox : bootcode missing ! ' ) ) ; } options . boot Code = code ; 
function extend ( klass , instance , override , methods ) { var extendee = instance ? klass . prototype : klass ; initialize Class ( klass ) ; iterate Over Object ( methods , function ( name , method ) { var original = extendee [ name ] ; var existed = has Own Property ( extendee , name ) ; if ( typeof override = = = 'function ' ) { method = wrap Native ( extendee [ name ] , method , override ) ; } if ( override ! = = false | | ! extendee [ name ] ) { define Property ( extendee , name , method ) ; } 
function multi Args ( args , fn ) { var result = [ ] , i , len ; for ( i = 0 , len = args . length ; i < len ; i + + ) { result . push ( args [ i ] ) ; if ( fn ) fn . call ( args , args [ i ] , i ) ; } return result ; } 
function get Range ( start , stop , fn , step ) { var arr = [ ] , i = parse Int ( start ) , down = step < 0 ; while ( ( ! down & & i < = stop ) | | ( down & & i > = stop ) ) { arr . push ( i ) ; if ( fn ) fn . call ( this , i ) ; i + = step | | 1 ; } return arr ; } 
function get Reg Exp Flags ( reg , add ) { var flags = reg . to String ( ) . match ( / [ ^ / ] * $ / ) [ 0 ] ; if ( add ) { flags = ( flags + add ) . split ( ' ' ) . sort ( ) . join ( ' ' ) . replace ( / ( [gimy ] ) \ 1 + / g , ' $ 1 ' ) ; } return flags ; } 
function stringify ( thing , stack ) { var type = typeof thing , thing Is Object , thing Is Array , klass , value , arr , key , i , len ; 
function entry At Index ( arr , args , str ) { var result = [ ] , length = arr . length , loop = args [ args . length - 1 ] ! = = false , r ; multi Args ( args , function ( index ) { if ( is Boolean ( index ) ) return false ; if ( loop ) { index = index % length ; if ( index < 0 ) index = length + index ; } r = str ? arr . char At ( index ) | | ' ' : arr [ index ] ; result . push ( r ) ; } ) ; return result . length < 2 ? result [ 0 ] : result ; } 
function build Object Instance Methods ( set , target ) { extend Similar ( target , true , false , set , function ( methods , name ) { methods [ name + ( name = = = 'equal ' ? 's ' : ' ' ) ] = function ( ) { return object [ name ] . apply ( null , [ this ] . concat ( multi Args ( arguments ) ) ) ; } } ) ; } 
function array Index Of ( arr , search , from Index , increment ) { var length = arr . length , from Right = increment = = - 1 , start = from Right ? length - 1 : 0 , index = to Integer With Default ( from Index , start ) ; if ( index < 0 ) { index = length + index ; } if ( ( ! from Right & & index < 0 ) | | ( from Right & & index > = length ) ) { index = start ; } while ( ( from Right & & index > = 0 ) | | ( ! from Right & & index < length ) ) { if ( arr [ index ] = = = search ) { return index ; } index + = increment ; } return - 1 ; } 
function ( fn , scope ) { var length = this . length , index = 0 ; check First Argument Exists ( arguments ) ; while ( index < length ) { if ( index in this & & fn . call ( scope , this [ index ] , index , this ) ) { return true ; } index + + ; } return false ; } 
function ( fn , scope ) { var length = this . length , index = 0 , result = new Array ( length ) ; check First Argument Exists ( arguments ) ; while ( index < length ) { if ( index in this ) { result [ index ] = fn . call ( scope , this [ index ] , index , this ) ; } index + + ; } return result ; } 
function ( fn , scope ) { var length = this . length , index = 0 ; check Callback ( fn ) ; while ( index < length ) { if ( index in this ) { fn . call ( scope , this [ index ] , index , this ) ; } index + + ; } } 
function build Trim ( ) { var support = get Trimmable Characters ( ) . match ( / ^ \s + $ / ) ; try { string . prototype . trim . call ( [ 1 ] ) ; } catch ( e ) { support = false ; } extend ( string , true , ! support , { 'trim ' : function ( ) { return this . to String ( ) . trim Left ( ) . trim Right ( ) ; } , 'trim Left ' : function ( ) { return this . replace ( regexp ( ' ^ [ ' + get Trimmable Characters ( ) + ' ] + ' ) , ' ' ) ; } , 'trim Right ' : function ( ) { return this . replace ( regexp ( ' [ ' + get Trimmable Characters ( ) + ' ] + $ ' ) , ' ' ) ; } } ) ; } 
function ( scope ) { var fn = this , args = multi Args ( arguments ) . slice ( 1 ) , nop , bound ; if ( ! is Function ( this ) ) { throw new Type Error ( 'Function .prototype .bind called on a non -function ' ) ; } bound = function ( ) { return fn . apply ( fn . prototype & & this instanceof fn ? this : scope , args . concat ( multi Args ( arguments ) ) ) ; } bound . prototype = this . prototype ; return bound ; } 
function multi Match ( el , match , scope , params ) { var result = true ; if ( el = = = match ) { 
function array Each ( arr , fn , start Index , loop ) { var length , index , i ; if ( start Index < 0 ) start Index = arr . length + start Index ; i = is Na N ( start Index ) ? 0 : start Index ; length = loop = = = true ? arr . length + i : arr . length ; while ( i < length ) { index = i % arr . length ; if ( ! ( index in arr ) ) { return iterate Over Sparse Array ( arr , fn , i , loop ) ; } else if ( fn . call ( arr , arr [ index ] , index , arr ) = = = false ) { break ; } i + + ; } } 
function get Min Or Max ( obj , map , which , all ) { var edge , result = [ ] , max = which = = = 'max ' , min = which = = = 'min ' , is Array = Array . is Array ( obj ) ; iterate Over Object ( obj , function ( key ) { var el = obj [ key ] , test = transform Argument ( el , map , obj , is Array ? [ el , parse Int ( key ) , obj ] : [ ] ) ; if ( is Undefined ( test ) ) { throw new Type Error ( 'Cannot compare with undefined ' ) ; } if ( test = = = edge ) { result . push ( el ) ; } else if ( is Undefined ( edge ) | | ( max & & test > edge ) | | ( min & & test < edge ) ) { result = [ el ] ; edge = test ; } } ) ; if ( ! is Array ) result = array Flatten ( result , 1 ) ; return all ? result : result [ 0 ] ; } 
function collate Strings ( a , b ) { var a Value , b Value , a Char , b Char , a Equiv , b Equiv , index = 0 , tiebreaker = 0 ; a = get Collation Ready String ( a ) ; b = get Collation Ready String ( b ) ; do { a Char = get Collation Character ( a , index ) ; b Char = get Collation Character ( b , index ) ; a Value = get Collation Value ( a Char ) ; b Value = get Collation Value ( b Char ) ; if ( a Value = = = - 1 | | b Value = = = - 1 ) { a Value = a . char Code At ( index ) | | null ; b Value = b . char Code At ( index ) | | null ; } a Equiv = a Char ! = = a . char At ( index ) ; b Equiv = b Char ! = = b . char At ( index ) ; if ( a Equiv ! = = b Equiv & & tiebreaker = = = 0 ) { tiebreaker = a Equiv - b Equiv ; } index + = 1 ; } while ( a Value ! = null & & b Value ! = null & & a Value = = = b Value ) ; if ( a Value = = = b Value ) return tiebreaker ; return a Value < b Value ? - 1 : 1 ; } 
function ( ) { var result = [ ] , tmp ; multi Args ( arguments , function ( a ) { if ( is Object Primitive ( a ) ) { try { tmp = array . prototype . slice . call ( a , 0 ) ; if ( tmp . length > 0 ) { a = tmp ; } } catch ( e ) { } ; } result = result . concat ( a ) ; } ) ; return result ; } 
function ( f , index , loop ) { var result = [ ] ; array Each ( this , function ( el , i , arr ) { if ( multi Match ( el , f , arr , [ el , i , arr ] ) ) { result . push ( el ) ; } } , index , loop ) ; return result ; } 
function ( f , start Index , loop ) { var index = array Find ( this , f , start Index , loop , true ) ; return is Undefined ( index ) ? - 1 : index ; } 
function ( start , end ) { var i , len ; if ( is Undefined ( start ) ) return this ; if ( is Undefined ( end ) ) end = start ; for ( i = 0 , len = end - start ; i < = len ; i + + ) { this . splice ( start , 1 ) ; } return this ; } 
function ( num ) { if ( is Undefined ( num ) ) return this [ this . length - 1 ] ; var start = this . length - num < 0 ? 0 : this . length - num ; return this . slice ( start ) ; } 
function ( map ) { var arr = map ? this . map ( map ) : this ; return arr . length > 0 ? arr . reduce ( function ( a , b ) { return a + b ; } ) : 0 ; } 
function ( map ) { var arr = map ? this . map ( map ) : this ; return arr . length > 0 ? arr . sum ( ) / arr . length : 0 ; } 
function ( num , padding ) { var pad = arguments . length > 1 ; var arr = this ; var result = [ ] ; var divisor = ceil ( this . length / num ) ; get Range ( 0 , num - 1 , function ( i ) { var index = i * divisor ; var group = arr . slice ( index , index + divisor ) ; if ( pad & & group . length < divisor ) { get Range ( 1 , divisor - group . length , function ( ) { group = group . add ( padding ) ; } ) ; } result . push ( group ) ; } ) ; return result ; } 
function ( map , desc ) { var arr = this . clone ( ) ; arr . sort ( function ( a , b ) { var a Property , b Property , comp ; a Property = transform Argument ( a , map , arr , [ a ] ) ; b Property = transform Argument ( b , map , arr , [ b ] ) ; if ( is String ( a Property ) & & is String ( b Property ) ) { comp = collate Strings ( a Property , b Property ) ; } else if ( a Property < b Property ) { comp = - 1 ; } else if ( a Property > b Property ) { comp = 1 ; } else { comp = 0 ; } return comp * ( desc ? - 1 : 1 ) ; } ) ; return arr ; } 
function ( ) { var arr = this . concat ( ) , i = arr . length , j , x ; while ( i ) { j = ( math . random ( ) * i ) | 0 ; x = arr [ - - i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = x ; } return arr ; } 
function ( ) { var args = multi Args ( arguments ) ; return this . map ( function ( el , i ) { return [ el ] . concat ( args . map ( function ( k ) { return ( i in k ) ? k [ i ] : null ; } ) ) ; } ) ; } 
function ( el , index ) { if ( ! is Number ( number ( index ) ) | | is Na N ( index ) ) index = this . length ; array . prototype . splice . apply ( this , [ index , 0 ] . concat ( el ) ) ; return this ; } 
function ( ) { var i , arr = this ; multi Args ( arguments , function ( f ) { i = 0 ; while ( i < arr . length ) { if ( multi Match ( arr [ i ] , f , arr , [ arr [ i ] , i , arr ] ) ) { arr . splice ( i , 1 ) ; } else { i + + ; } } } ) ; return arr ; } 
function ( all ) { var result = [ ] ; array Each ( this , function ( el , i ) { if ( is Array ( el ) ) { result . push ( el . compact ( ) ) ; } else if ( all & & el ) { result . push ( el ) ; } else if ( ! all & & el ! = null & & el . value Of ( ) = = = el . value Of ( ) ) { result . push ( el ) ; } } ) ; return result ; } 
function ( map , fn ) { var arr = this , result = { } , key ; array Each ( arr , function ( el , index ) { key = transform Argument ( el , map , arr , [ el , index , arr ] ) ; if ( ! result [ key ] ) result [ key ] = [ ] ; result [ key ] . push ( el ) ; } ) ; if ( fn ) { iterate Over Object ( result , fn ) ; } return result ; } 
function keys With Coercion ( obj ) { if ( obj & & obj . value Of ) { obj = obj . value Of ( ) ; } return object . keys ( obj ) ; } 
function build Enumerable Methods ( names , mapping ) { extend Similar ( object , false , false , names , function ( methods , name ) { methods [ name ] = function ( obj , arg 1 , arg 2 ) { var result , coerced = keys With Coercion ( obj ) ; result = array . prototype [ name ] . call ( coerced , function ( key ) { if ( mapping ) { return transform Argument ( obj [ key ] , arg 1 , obj , [ key , obj [ key ] , obj ] ) ; } else { return multi Match ( obj [ key ] , arg 1 , obj , [ key , obj [ key ] , obj ] ) ; } } , arg 2 ) ; if ( is Array ( result ) ) { 
function get Localization ( locale Code , fallback ) { var loc ; if ( ! is String ( locale Code ) ) locale Code = ' ' ; loc = Localizations [ locale Code ] | | Localizations [ locale Code . slice ( 0 , 2 ) ] ; if ( fallback = = = false & & ! loc ) { throw new Error ( 'Invalid locale . ' ) ; } return loc | | Current Localization ; } 
function add Date Input Format ( locale , format , match , variant ) { locale . compiled Formats . unshift ( { variant : variant , locale : locale , reg : regexp ( ' ^ ' + format + ' $ ' , 'i ' ) , to : match } ) ; } 
function collect Date Arguments ( args , allow Duration ) { var obj , arr ; if ( is Object ( args [ 0 ] ) ) { return args ; } else if ( is Number ( args [ 0 ] ) & & ! is Number ( args [ 1 ] ) ) { return [ args [ 0 ] ] ; } else if ( is String ( args [ 0 ] ) & & allow Duration ) { return [ get Date Params From String ( args [ 0 ] ) , args [ 1 ] ] ; } obj = { } ; Date Argument Units . for Each ( function ( u , i ) { obj [ u . unit ] = args [ i ] ; } ) ; return [ obj ] ; } 
function get Format Match ( match , arr ) { var obj = { } , value , num ; arr . for Each ( function ( key , i ) { value = match [ i + 1 ] ; if ( is Undefined ( value ) | | value = = = ' ' ) return ; if ( key = = = 'year ' ) { obj . year As String = value . replace ( / ' / , ' ' ) ; } num = parse Float ( value . replace ( / ' / , ' ' ) . replace ( / , / , ' . ' ) ) ; obj [ key ] = ! is Na N ( num ) ? num : value . to Lower Case ( ) ; } ) ; return obj ; } 
function get Week Number ( date ) { date = date . clone ( ) ; var dow = call Date Get ( date , 'Day ' ) | | 7 ; date . add Days ( 4 - dow ) . reset ( ) ; return 1 + floor ( date . days Since ( date . clone ( ) . beginning Of Year ( ) ) / 7 ) ; } 
function format Date ( date , format , relative , locale Code ) { var adu , loc = get Localization ( locale Code ) , caps = regexp ( / ^ [A -Z ] / ) , value , shortcut ; if ( ! date . is Valid ( ) ) { return 'Invalid Date ' ; } else if ( Date [ format ] ) { format = Date [ format ] ; } else if ( is Function ( format ) ) { adu = get Adjusted Unit With Month Fallback ( date ) ; format = format . apply ( date , adu . concat ( loc ) ) ; } if ( ! format & & relative ) { adu = adu | | get Adjusted Unit With Month Fallback ( date ) ; 
function compare Date ( d , find , buffer , force UTC ) { var p , t , min , max , min Offset , max Offset , override , capitalized , accuracy = 0 , lo Buffer = 0 , hi Buffer = 0 ; p = get Extended Date ( find , null , null , force UTC ) ; if ( buffer > 0 ) { lo Buffer = hi Buffer = buffer ; override = true ; } if ( ! p . date . is Valid ( ) ) return false ; if ( p . set & & p . set . specificity ) { Date Units . for Each ( function ( u , i ) { if ( u . unit = = = p . set . specificity ) { accuracy = u . multiplier ( p . date , d - p . date ) - 1 ; } } ) ; capitalized = simple Capitalize ( p . set . specificity ) ; if ( p . set [ 'edge ' ] | | p . set [ 'shift ' ] ) { p . date [ 'beginning Of ' + capitalized ] ( ) ; } if ( p . set . specificity = = = 'month ' ) { max = p . date . clone ( ) [ 'end Of ' + capitalized ] ( ) . get Time ( ) ; } if ( ! override & & p . set [ 'sign ' ] & & p . set . specificity ! = 'millisecond ' ) { 
function prepare Time ( format , loc , iso ) { var time Suffix Mapping = { 'h ' : 0 , 'm ' : 1 , 's ' : 2 } , add ; loc = loc | | English ; return format . replace ( / { ( [a -z ] ) } / g , function ( full , token ) { var separators = [ ] , is Hours = token = = = 'h ' , token Is Required = is Hours & & ! iso ; if ( token = = = 't ' ) { return loc [ 'ampm ' ] . join ( ' | ' ) ; } else { if ( is Hours ) { separators . push ( ' : ' ) ; } if ( add = loc [ 'time Suffixes ' ] [ time Suffix Mapping [ token ] ] ) { separators . push ( add + ' \ \s * ' ) ; } return separators . length = = = 0 ? ' ' : ' ( ? : ' + separators . join ( ' | ' ) + ' ) ' + ( token Is Required ? ' ' : ' ? ' ) ; } } ) ; } 
function check Month Traversal ( date , target Month ) { if ( target Month < 0 ) { target Month = target Month % 1 2 + 1 2 ; } if ( target Month % 1 2 ! = call Date Get ( date , 'Month ' ) ) { call Date Set ( date , 'Date ' , 0 ) ; } } 
function build Date Methods ( ) { extend Similar ( date , true , false , Date Units , function ( methods , u , i ) { var unit = u . unit , caps = simple Capitalize ( unit ) , multiplier = u . multiplier ( ) , since , until ; u . add Method = 'add ' + caps + 's ' ; 
function apply Error Margin ( ms ) { var num = ms / multiplier , fraction = num % 1 , error = u . error | | 0 . 9 9 9 ; if ( fraction & & math . abs ( fraction % 1 ) > error ) { num = round ( num ) ; } return parse Int ( num ) ; } 
function build Relative Aliases ( ) { var special = 'today ,yesterday ,tomorrow ,weekday ,weekend ,future ,past ' . split ( ' , ' ) ; var weekdays = English [ 'weekdays ' ] . slice ( 0 , 7 ) ; var months = English [ 'months ' ] . slice ( 0 , 1 2 ) ; extend Similar ( date , true , false , special . concat ( weekdays ) . concat ( months ) , function ( methods , name ) { methods [ 'is ' + simple Capitalize ( name ) ] = function ( utc ) { return this . is ( name , 0 , utc ) ; } ; } ) ; } 
function ( locale Code , set ) { var loc = get Localization ( locale Code , false ) ; Current Localization = loc ; 
function ( week ) { var weekday = call Date Get ( this , 'Day ' ) | | 7 ; if ( is Undefined ( week ) ) return ; this . set ( { 'month ' : 0 , 'date ' : 4 } ) ; this . set ( { 'weekday ' : 1 } ) ; if ( week > 1 ) { this . add Weeks ( week - 1 ) ; } if ( weekday ! = = 1 ) { this . advance ( { 'days ' : weekday - 1 } ) ; } return this . get Time ( ) ; } 
function ( iso ) { var offset = this . _utc ? 0 : this . get Timezone Offset ( ) ; var colon = iso = = = true ? ' : ' : ' ' ; if ( ! offset & & iso ) return 'Z ' ; return pad Number ( floor ( - offset / 6 0 ) , 2 , true ) + colon + pad Number ( math . abs ( offset % 6 0 ) , 2 ) ; } 
function ( f , locale Code ) { if ( is String ( f ) ) { locale Code = f ; f = null ; } return format Date ( this , f , true , locale Code ) ; } 
function ( d , margin , utc ) { var tmp , comp ; if ( ! this . is Valid ( ) ) return ; if ( is String ( d ) ) { d = d . trim ( ) . to Lower Case ( ) ; comp = this . clone ( ) . utc ( utc ) ; switch ( true ) { case d = = = 'future ' : return this . get Time ( ) > new date ( ) . get Time ( ) ; case d = = = 'past ' : return this . get Time ( ) < new date ( ) . get Time ( ) ; case d = = = 'weekday ' : return call Date Get ( comp , 'Day ' ) > 0 & & call Date Get ( comp , 'Day ' ) < 6 ; case d = = = 'weekend ' : return call Date Get ( comp , 'Day ' ) = = = 0 | | call Date Get ( comp , 'Day ' ) = = = 6 ; case ( tmp = English [ 'weekdays ' ] . index Of ( d ) % 7 ) > - 1 : return call Date Get ( comp , 'Day ' ) = = = tmp ; case ( tmp = English [ 'months ' ] . index Of ( d ) % 1 2 ) > - 1 : return call Date Get ( comp , 'Month ' ) = = = tmp ; } } return compare Date ( this , d , margin , utc ) ; } 
function ( unit ) { var params = { } , recognized ; unit = unit | | 'hours ' ; if ( unit = = = 'date ' ) unit = 'days ' ; recognized = Date Units . some ( function ( u ) { return unit = = = u . unit | | unit = = = u . unit + 's ' ; } ) ; params [ unit ] = unit . match ( / ^days ? / ) ? 1 : 0 ; return recognized ? this . set ( params , true ) : this ; } 
function build Number To Date Alias ( u , multiplier ) { var unit = u . unit , methods = { } ; function base ( ) { return round ( this * multiplier ) ; } function after ( ) { return create Date ( arguments ) [ u . add Method ] ( this ) ; } function before ( ) { return create Date ( arguments ) [ u . add Method ] ( - this ) ; } methods [ unit ] = base ; methods [ unit + 's ' ] = base ; methods [ unit + 'Before ' ] = before ; methods [ unit + 's Before ' ] = before ; methods [ unit + 'Ago ' ] = before ; methods [ unit + 's Ago ' ] = before ; methods [ unit + 'After ' ] = after ; methods [ unit + 's After ' ] = after ; methods [ unit + 'From Now ' ] = after ; methods [ unit + 's From Now ' ] = after ; number . extend ( methods ) ; } 
function ( start , end ) { this . start = date . create ( start ) ; this . end = date . create ( end ) ; } 
function ( obj ) { var self = this , arr = obj . start & & obj . end ? [ obj . start , obj . end ] : [ obj ] ; return arr . every ( function ( d ) { return d > = self . start & & d < = self . end ; } ) ; } 
function ( increment , fn ) { var current = this . start . clone ( ) , result = [ ] , index = 0 , params , is Day ; if ( is String ( increment ) ) { current . advance ( get Date Params From String ( increment , 0 ) , true ) ; params = get Date Params From String ( increment ) ; is Day = increment . to Lower Case ( ) = = = 'day ' ; } else { params = { 'milliseconds ' : increment } ; } while ( current < = this . end ) { result . push ( current ) ; if ( fn ) fn ( current , index ) ; if ( is Day & & call Date Get ( current , 'Hours ' ) = = = 2 3 ) { 
function ( range ) { return new Date Range ( this . start < range . start ? this . start : range . start , this . end > range . end ? this . end : range . end ) ; } 
function set Delay ( fn , ms , after , scope , args ) { var index ; 
function ( ms , limit ) { var fn = this , queue = [ ] , lock = false , execute , rounded , per Execution , result ; ms = ms | | 1 ; limit = limit | | Infinity ; rounded = ceil ( ms ) ; per Execution = round ( rounded / ms ) | | 1 ; execute = function ( ) { if ( lock | | queue . length = = 0 ) return ; 
function ( ms ) { var fn = this ; var args = multi Args ( arguments ) . slice ( 1 ) ; set Delay ( fn , ms , fn , fn , args ) ; return fn ; } 
function ( ms ) { var fn = this ; function debounced ( ) { debounced . cancel ( ) ; set Delay ( debounced , ms , fn , this , arguments ) ; } ; return debounced ; } 
function ( num ) { var fn = this , counter = 0 , stored Arguments = [ ] ; if ( ! is Number ( num ) ) { num = 1 ; } else if ( num = = = 0 ) { fn . call ( ) ; return fn ; } return function ( ) { var ret ; stored Arguments . push ( multi Args ( arguments ) ) ; counter + + ; if ( counter = = num ) { ret = fn . call ( this , stored Arguments ) ; counter = 0 ; stored Arguments = [ ] ; return ret ; } } } 
function ( ) { var fn = this , curried = multi Args ( arguments ) ; return function ( ) { var args = multi Args ( arguments ) ; curried . for Each ( function ( arg , index ) { if ( arg ! = null | | index > = args . length ) args . splice ( index , 0 , arg ) ; } ) ; return fn . apply ( this , args ) ; } } 
function abbreviate Number ( num , round To , str , mid , limit , bytes ) { var fixed = num . to Fixed ( 2 0 ) , decimal Place = fixed . search ( / \ . / ) , numeral Place = fixed . search ( / [ 1 - 9 ] / ) , significant = decimal Place - numeral Place , unit , i , divisor ; if ( significant > 0 ) { significant - = 1 ; } i = math . max ( math . min ( ( significant / 3 ) . floor ( ) , limit = = = false ? str . length : limit ) , - mid ) ; unit = str . char At ( i + mid - 1 ) ; if ( significant < - 9 ) { i = - 3 ; round To = significant . abs ( ) - 9 ; unit = str . slice ( 0 , 1 ) ; } divisor = bytes ? ( 2 ) . pow ( 1 0 * i ) : ( 1 0 ) . pow ( i * 3 ) ; return ( num / divisor ) . round ( round To | | 0 ) . format ( ) + unit . trim ( ) ; } 
function ( n 1 , n 2 ) { var min , max ; if ( arguments . length = = 1 ) n 2 = n 1 , n 1 = 0 ; min = math . min ( n 1 | | 0 , is Undefined ( n 2 ) ? 1 : n 2 ) ; max = math . max ( n 1 | | 0 , is Undefined ( n 2 ) ? 1 : n 2 ) + 1 ; return floor ( ( math . random ( ) * ( max - min ) ) + min ) ; } 
function ( place , thousands , decimal ) { var i , str , split , integer , fraction , result = ' ' ; if ( is Undefined ( thousands ) ) { thousands = ' , ' ; } if ( is Undefined ( decimal ) ) { decimal = ' . ' ; } str = ( is Number ( place ) ? round ( this , place | | 0 ) . to Fixed ( math . max ( place , 0 ) ) : this . to String ( ) ) . replace ( / ^ - / , ' ' ) ; split = str . split ( ' . ' ) ; integer = split [ 0 ] ; fraction = split [ 1 ] ; for ( i = integer . length ; i > 0 ; i - = 3 ) { if ( i < integer . length ) { result = thousands + result ; } result = integer . slice ( math . max ( 0 , i - 3 ) , i ) + result ; } if ( fraction ) { result + = decimal + repeat String ( ( place | | 0 ) - fraction . length , ' 0 ' ) + fraction ; } return ( this < 0 ? ' - ' : ' ' ) + result ; } 
function ( ) { var suffix , num = this . abs ( ) , last = parse Int ( num . to String ( ) . slice ( - 2 ) ) ; return this + get Ordinalized Suffix ( last ) ; } 
function build Number ( ) { extend Similar ( number , true , false , 'round ,floor ,ceil ' , function ( methods , name ) { methods [ name ] = function ( precision ) { return round ( this , precision , name ) ; } } ) ; extend Similar ( number , true , false , 'abs ,pow ,sin ,asin ,cos ,acos ,tan ,atan ,exp ,pow ,sqrt ' , function ( methods , name ) { methods [ name ] = function ( a , b ) { return math [ name ] ( this , a , b ) ; } } ) ; } 
function build Type Methods ( ) { extend Similar ( object , false , false , Class Names , function ( methods , name ) { var method = 'is ' + name ; Object Type Methods . push ( method ) ; methods [ method ] = type Checks [ name ] ; } ) ; } 
function ( obj , prop , fn ) { if ( ! define Property Support ) return ; var value = obj [ prop ] ; object . define Property ( obj , prop , { 'enumerable ' : true , 'configurable ' : true , 'get ' : function ( ) { return value ; } , 'set ' : function ( to ) { value = fn . call ( obj , prop , value , to ) ; } } ) ; } 
function ( obj , fn ) { var keys = object . keys ( obj ) ; keys . for Each ( function ( key ) { fn . call ( obj , key , obj [ key ] ) ; } ) ; return keys ; } 
function ( target , source , deep , resolve ) { var key , val ; 
function ( obj , fn ) { var values = [ ] ; iterate Over Object ( obj , function ( k , v ) { values . push ( v ) ; if ( fn ) fn . call ( obj , v ) ; } ) ; return values ; } 
function ( obj , deep ) { var target ; 
function ( str , deep ) { var result = object . extended ( ) , split ; str = str & & str . to String ? str . to String ( ) : ' ' ; str . replace ( / ^ . * ? \ ? / , ' ' ) . split ( ' & ' ) . for Each ( function ( p ) { var split = p . split ( ' = ' ) ; if ( split . length ! = = 2 ) return ; set Params Object ( result , split [ 0 ] , decode URIComponent ( split [ 1 ] ) , deep ) ; } ) ; return result ; } 
function ( obj , arg ) { var fn = arg ; if ( ! is Function ( arg ) ) { fn = function ( ) { if ( arg ) obj [ arg ] ( ) ; } } fn . call ( obj , obj ) ; return obj ; } 
function get Acronym ( word ) { var inflector = string . Inflector ; var word = inflector & & inflector . acronyms [ word ] ; if ( is String ( word ) ) { return word ; } } 
function ( reg , pos , c ) { var str = this , source ; if ( is Defined ( pos ) ) str = str . slice ( 0 , pos ) ; if ( is Undefined ( c ) ) c = true ; source = is Reg Exp ( reg ) ? reg . source . replace ( ' $ ' , ' ' ) : escape Reg Exp ( reg ) ; return regexp ( source + ' $ ' , c ? ' ' : 'i ' ) . test ( str ) ; } 
function ( search , fn ) { var match , i , len ; if ( is Function ( search ) ) { fn = search ; search = / [ \s \S ] / g ; } else if ( ! search ) { search = / [ \s \S ] / g } else if ( is String ( search ) ) { search = regexp ( escape Reg Exp ( search ) , 'gi ' ) ; } else if ( is Reg Exp ( search ) ) { search = regexp ( search . source , get Reg Exp Flags ( search , 'g ' ) ) ; } match = this . match ( search ) | | [ ] ; if ( fn ) { for ( i = 0 , len = match . length ; i < len ; i + + ) { match [ i ] = fn . call ( this , match [ i ] , i , match ) | | match [ i ] ; } } return match ; } 
function ( n ) { var result = ' ' ; n = n | | 0 ; this . codes ( function ( c ) { result + = chr ( c + n ) ; } ) ; return result ; } 
function ( fn ) { var codes = [ ] , i , len ; for ( i = 0 , len = this . length ; i < len ; i + + ) { var code = this . char Code At ( i ) ; codes . push ( code ) ; if ( fn ) fn . call ( this , code , i ) ; } return codes ; } 
function ( fn ) { var paragraphs = this . trim ( ) . split ( / [ \r \n ] { 2 , } / ) ; paragraphs = paragraphs . map ( function ( p ) { if ( fn ) var s = fn . call ( p ) ; return s ? s : p ; } ) ; return paragraphs ; } 
function ( ) { return this . trim ( ) . replace ( / ( [ \r \n \s ] ) + /g , f nction (m a tch , w itespace ) { return whitespace = = = ' ' ? w itespace : ' ' ; } ) ; } 
function ( ) { return this . replace ( / [ - \s ] + / g , ' _ ' ) . replace ( string . Inflector & & string . Inflector . acronym Reg Exp , function ( acronym , index ) { return ( index > 0 ? ' _ ' : ' ' ) + acronym . to Lower Case ( ) ; } ) . replace ( / ( [A -Z \d ] + ) ( [A -Z ] [a -z ] ) / g , ' $ 1 _ $ 2 ' ) . replace ( / ( [a -z \d ] ) ( [A -Z ] ) / g , ' $ 1 _ $ 2 ' ) . to Lower Case ( ) ; } 
function ( first ) { return this . underscore ( ) . replace ( / ( ^ | _ ) ( [ ^ _ ] + ) / g , function ( match , pre , word , index ) { var acronym = get Acronym ( word ) , capitalize = first ! = = false | | index > 0 ; if ( acronym ) return capitalize ? acronym : acronym . to Lower Case ( ) ; return capitalize ? word . capitalize ( ) : word ; } ) ; } 
function ( ) { var str = this , args = arguments . length > 0 ? arguments : [ ' ' ] ; flattened Args ( args , function ( tag ) { str = str . replace ( regexp ( ' < \ / ? ' + escape Reg Exp ( tag ) + ' [ ^ < > ] * > ' , 'gi ' ) , ' ' ) ; } ) ; return str ; } 
function ( ) { var str = this , args = arguments . length > 0 ? arguments : [ ' \ \S + ' ] ; flattened Args ( args , function ( t ) { var reg = regexp ( ' < ( ' + t + ' ) [ ^ < > ] * ( ? : \ \ / > | > . * ? < \ \ / \ \ 1 > ) ' , 'gi ' ) ; str = str . replace ( reg , ' ' ) ; } ) ; return str ; } 
function ( length , split , from , ellipsis ) { var pos , prepend = ' ' , append = ' ' , str = this . to String ( ) , chars = ' [ ' + get Trimmable Characters ( ) + ' ] + ' , space = ' [ ^ ' + get Trimmable Characters ( ) + ' ] * ' , reg = regexp ( chars + space + ' $ ' ) ; ellipsis = is Undefined ( ellipsis ) ? ' . . . ' : string ( ellipsis ) ; if ( str . length < = length ) { return str ; } switch ( from ) { case 'left ' : pos = str . length - length ; prepend = ellipsis ; str = str . slice ( pos ) ; reg = regexp ( ' ^ ' + space + chars ) ; break ; case 'middle ' : pos = floor ( length / 2 ) ; append = ellipsis + str . slice ( str . length - pos ) . trim Left ( ) ; str = str . slice ( 0 , pos ) ; break ; default : pos = length ; append = ellipsis ; str = str . slice ( 0 , pos ) ; } if ( split = = = false & & this . slice ( pos , pos + 1 ) . match ( / \S / ) ) { str = str . remove ( reg ) ; } return prepend + str + append ; } 
function ( num ) { var result = ' ' , str = this ; if ( ! is Number ( num ) | | num < 1 ) return ' ' ; while ( num ) { if ( num & 1 ) { result + = str ; } if ( num > > = 1 ) { str + = str ; } } return result ; } 
function ( base ) { var str = this . replace ( / , / g , ' ' ) ; return str . match ( / \ . / ) ? parse Float ( str ) : parse Int ( str , base | | 1 0 ) ; } 
function ( all ) { var last Responded ; return this . to Lower Case ( ) . replace ( all ? / [ \s \S ] / g : / ^ \S / , function ( lower ) { var upper = lower . to Upper Case ( ) , result ; result = last Responded ? lower : upper ; last Responded = upper ! = = lower ; return result ; } ) ; } 
function ( ) { var assign = { } ; multi Args ( arguments , function ( a , i ) { if ( is Object ( a ) ) { simple Merge ( assign , a ) ; } else { assign [ i + 1 ] = a ; } } ) ; return this . replace ( / \ { ( [ ^ { ] + ? ) \ } / g , function ( m , key ) { return has Own Property ( assign , key ) ? assign [ key ] : m ; } ) ; } 
function ( word ) { acronyms [ word . to Lower Case ( ) ] = word ; var all = object . keys ( acronyms ) . map ( function ( key ) { return acronyms [ key ] ; } ) ; Inflector . acronym Reg Exp = regexp ( all . join ( ' | ' ) , 'g ' ) ; } 
function ( singular , plural ) { var singular First = singular . first ( ) , singular Rest = singular . from ( 1 ) , plural First = plural . first ( ) , plural Rest = plural . from ( 1 ) , plural First Upper = plural First . to Upper Case ( ) , plural First Lower = plural First . to Lower Case ( ) , singular First Upper = singular First . to Upper Case ( ) , singular First Lower = singular First . to Lower Case ( ) ; remove From Array ( uncountables , singular ) ; remove From Array ( uncountables , plural ) ; if ( singular First Upper = = plural First Upper ) { Inflector . plural ( new regexp ( ' ( { 1 } ) { 2 } $ ' . assign ( singular First , singular Rest ) , 'i ' ) , ' $ 1 ' + plural Rest ) ; Inflector . plural ( new regexp ( ' ( { 1 } ) { 2 } $ ' . assign ( plural First , plural Rest ) , 'i ' ) , ' $ 1 ' + plural Rest ) ; Inflector . singular ( new regexp ( ' ( { 1 } ) { 2 } $ ' . assign ( plural First , plural Rest ) , 'i ' ) , ' $ 1 ' + singular Rest ) ; } else { Inflector . plural ( new regexp ( ' { 1 } { 2 } $ ' . assign ( singular First Upper , singular Rest ) ) , plural First Upper + plural Rest ) ; Inflector . plural ( new regexp ( ' { 1 } { 2 } $ ' . assign ( singular First Lower , singular Rest ) ) , plural First Lower + plural Rest ) ; Inflector . plural ( new regexp ( ' { 1 } { 2 } $ ' . assign ( plural First Upper , plural Rest ) ) , plural First Upper + plural Rest ) ; Inflector . plural ( new regexp ( ' { 1 } { 2 } $ ' . assign ( plural First Lower , plural Rest ) ) , plural First Lower + plural Rest ) ; Inflector . singular ( new regexp ( ' { 1 } { 2 } $ ' . assign ( plural First Upper , plural Rest ) ) , singular First Upper + singular Rest ) ; Inflector . singular ( new regexp ( ' { 1 } { 2 } $ ' . assign ( plural First Lower , plural Rest ) ) , singular First Lower + singular Rest ) ; } } 
function ( first ) { var add = array . is Array ( first ) ? first : multi Args ( arguments ) ; uncountables = uncountables . concat ( add ) ; } 
function ( type ) { if ( param Matches Type ( type , 'singulars ' ) ) singulars = [ ] ; if ( param Matches Type ( type , 'plurals ' ) ) plurals = [ ] ; if ( param Matches Type ( type , 'uncountables ' ) ) uncountables = [ ] ; if ( param Matches Type ( type , 'humans ' ) ) humans = [ ] ; if ( param Matches Type ( type , 'acronyms ' ) ) acronyms = { } ; } 
function ( ) { var str = run Replacements ( this , humans ) , acronym ; str = str . replace ( / _id $ / g , ' ' ) ; str = str . replace ( / ( _ ) ? ( [a -z \d ] * ) / gi , function ( match , _ , word ) { acronym = has Own Property ( acronyms , word ) ? acronyms [ word ] : null ; return ( _ ? ' ' : ' ' ) + ( acronym | | word . to Lower Case ( ) ) ; } ) ; return capitalize ( str ) ; } 
function ( ) { var full Stop Punctuation = / [ . : ; ! ] $ / , has Punctuation , last Had Punctuation , is First Or Last ; return this . spacify ( ) . humanize ( ) . words ( function ( word , index , words ) { has Punctuation = full Stop Punctuation . test ( word ) ; is First Or Last = index = = 0 | | index = = words . length - 1 | | has Punctuation | | last Had Punctuation ; last Had Punctuation = has Punctuation ; if ( is First Or Last | | Downcased . index Of ( word ) = = = - 1 ) { return capitalize ( word ) ; } else { return word ; } } ) . join ( ' ' ) ; } 
function ( separator ) { var str = this ; if ( separator = = = undefined ) separator = ' - ' ; if ( str . normalize ) { str = str . normalize ( ) ; } str = str . replace ( / [ ^a -z 0 - 9 \ - _ ] + / gi , separator ) if ( separator ) { str = str . replace ( new regexp ( ' ^ {sep } + | {sep } + $ | ( {sep } ) {sep } + ' . assign ( { 'sep ' : escape Reg Exp ( separator ) } ) , 'g ' ) , ' $ 1 ' ) ; } return encode URI ( str . to Lower Case ( ) ) ; } 
function ( all ) { var str = this ; if ( all ! = = false ) { str = str . zenkaku ( 'k ' ) ; } return str . replace ( / [ \u 3 0A 1 - \u 3 0F 6 ] / g , function ( c ) { return c . shift ( - 9 6 ) ; } ) ; } 
function ( done ) { var dependencies = [ ] , add Package To Dependencies = function ( pkg ) { dependencies . push ( pkg . name ) ; } ; this . bundler . on ( 'package ' , add Package To Dependencies ) ; return this . compile ( function ( err ) { this . bundler . remove Listener ( 'package ' , add Package To Dependencies ) ; return done ( err , _ . uniq ( dependencies ) . sort ( ) ) ; } . bind ( this ) ) ; } 
function Foscam ( config ) { if ( ! config ) { throw new Error ( 'no config was supplied ' ) ; } this . username = config . username ; this . password = config . password ; this . address = config . host ; this . port = config . port | | 8 8 ; this . protocol = config . protocol | | 'http ' ; this . reject Unauthorized Certs = 'reject Unauthorized Certs ' in config ? config . reject Unauthorized Certs : true ; this . base Url = this . protocol + ' : / / ' + this . address + ' : ' + this . port ; this . url = this . base Url + ' /cgi -bin /CGIProxy .fcgi ' ; this . stream Url = this . base Url + ' /cgi -bin /CGIStream .cgi ' ; this . rp Client = rp . defaults ( { reject Unauthorized : this . reject Unauthorized Certs , qs : { usr : this . username , pwd : this . password } } ) ; } 
function put ( point , data , octree , octant , depth ) { let children = octant . children ; let exists = false ; let done = false ; let i , l ; if ( octant . contains ( point , octree . bias ) ) { if ( children = = = null ) { if ( octant . points = = = null ) { octant . points = [ ] ; octant . data = [ ] ; } else { for ( i = 0 , l = octant . points . length ; ! exists & & i < l ; + + i ) { exists = octant . points [ i ] . equals ( point ) ; } } if ( exists ) { octant . data [ i - 1 ] = data ; done = true ; } else if ( octant . points . length < octree . max Points | | depth = = = octree . max Depth ) { octant . points . push ( point . clone ( ) ) ; octant . data . push ( data ) ; + + octree . point Count ; done = true ; } else { octant . split ( ) ; octant . redistribute ( octree . bias ) ; children = octant . children ; } } if ( children ! = = null ) { + + depth ; for ( i = 0 , l = children . length ; ! done & & i < l ; + + i ) { done = put ( point , data , octree , children [ i ] , depth ) ; } } } return done ; } 
function fetch ( point , octree , octant ) { const children = octant . children ; let result = null ; let i , l ; let points ; if ( octant . contains ( point , octree . bias ) ) { if ( children ! = = null ) { for ( i = 0 , l = children . length ; result = = = null & & i < l ; + + i ) { result = fetch ( point , octree , children [ i ] ) ; } } else if ( octant . points ! = = null ) { points = octant . points ; for ( i = 0 , l = points . length ; result = = = null & & i < l ; + + i ) { if ( point . equals ( points [ i ] ) ) { result = octant . data [ i ] ; } } } } return result ; } 
function move ( point , position , octree , octant , parent , depth ) { const children = octant . children ; let result = null ; let i , l ; let points ; if ( octant . contains ( point , octree . bias ) ) { if ( octant . contains ( position , octree . bias ) ) { 
function find Points ( point , radius , skip Self , octant , result ) { const children = octant . children ; let i , l ; if ( children ! = = null ) { let child ; for ( i = 0 , l = children . length ; i < l ; + + i ) { child = children [ i ] ; if ( child . contains ( point , radius ) ) { find Points ( point , radius , skip Self , child , result ) ; } } } else if ( octant . points ! = = null ) { const points = octant . points ; const r Sq = radius * radius ; let p ; for ( i = 0 , l = points . length ; i < l ; + + i ) { p = points [ i ] ; if ( p . equals ( point ) ) { if ( ! skip Self ) { result . push ( { point : p . clone ( ) , data : octant . data [ i ] } ) ; } } else if ( p . distance To Squared ( point ) < = r Sq ) { result . push ( { point : p . clone ( ) , data : octant . data [ i ] } ) ; } } } } 
function cull ( octant , region , result ) { const children = octant . children ; let i , l ; b . min = octant . min ; b . max = octant . max ; if ( region . intersects Box ( b ) ) { if ( children ! = = null ) { for ( i = 0 , l = children . length ; i < l ; + + i ) { cull ( children [ i ] , region , result ) ; } } else { result . push ( octant ) ; } } } 
function find Octants By Level ( octant , level , depth , result ) { const children = octant . children ; let i , l ; if ( depth = = = level ) { result . push ( octant ) ; } else if ( children ! = = null ) { + + depth ; for ( i = 0 , l = children . length ; i < l ; + + i ) { find Octants By Level ( children [ i ] , level , depth , result ) ; } } } 
function find Entry Octant ( tx 0 , ty 0 , tz 0 , txm , tym , tzm ) { let entry = 0 ; 
function find Next Octant ( current Octant , tx 1 , ty 1 , tz 1 ) { let min ; let exit = 0 ; 
function raycast Octant ( octant , tx 0 , ty 0 , tz 0 , tx 1 , ty 1 , tz 1 , raycaster , intersects ) { const children = octant . children ; let current Octant ; let txm , tym , tzm ; if ( tx 1 > = 0 . 0 & & ty 1 > = 0 . 0 & & tz 1 > = 0 . 0 ) { if ( children = = = null ) { * order as the t -values . Hence , if the first value is found to be the * greatest , the fourth one will be returned . If the second value is the * greatest , the fifth one will be returned , etc . * / switch ( current Octant ) { case 0 : raycast Octant ( children [ flags ] , tx 0 , ty 0 , tz 0 , txm , tym , tzm , raycaster , intersects ) ; current Octant = find Next Octant ( current Octant , txm , tym , tzm ) ; break ; case 1 : raycast Octant ( children [ flags ^ 1 ] , tx 0 , ty 0 , tzm , txm , tym , tz 1 , raycaster , intersects ) ; current Octant = find Next Octant ( current Octant , txm , tym , tz 1 ) ; break ; case 2 : raycast Octant ( children [ flags ^ 2 ] , tx 0 , tym , tz 0 , txm , ty 1 , tzm , raycaster , intersects ) ; current Octant = find Next Octant ( current Octant , txm , ty 1 , tzm ) ; break ; case 3 : raycast Octant ( children [ flags ^ 3 ] , tx 0 , tym , tzm , txm , ty 1 , tz 1 , raycaster , intersects ) ; current Octant = find Next Octant ( current Octant , txm , ty 1 , tz 1 ) ; break ; case 4 : raycast Octant ( children [ flags ^ 4 ] , txm , ty 0 , tz 0 , tx 1 , tym , tzm , raycaster , intersects ) ; current Octant = find Next Octant ( current Octant , tx 1 , tym , tzm ) ; break ; case 5 : raycast Octant ( children [ flags ^ 5 ] , txm , ty 0 , tzm , tx 1 , tym , tz 1 , raycaster , intersects ) ; current Octant = find Next Octant ( current Octant , tx 1 , tym , tz 1 ) ; break ; case 6 : raycast Octant ( children [ flags ^ 6 ] , txm , tym , tz 0 , tx 1 , ty 1 , tzm , raycaster , intersects ) ; current Octant = find Next Octant ( current Octant , tx 1 , ty 1 , tzm ) ; break ; case 7 : raycast Octant ( children [ flags ^ 7 ] , txm , tym , tzm , tx 1 , ty 1 , tz 1 , raycaster , intersects ) ; 
function deferred ( options ) { let args = null ; const promise = new Promise ( ( resolve , reject ) = > args = [ resolve , reject , options ] ) ; promise . defer = function defer ( ) { if ( ! args ) throw new Error ( 'defer has already been called ' ) ; const callback = callback Builder . apply ( undefined , args ) ; args = null ; return callback ; } ; return promise ; } 
function with Timeout ( promise , delay , message ) { let timeout ; const timeout Promise = new Promise ( ( resolve , reject ) = > { 
function wait On ( emitter , event , wait Error ) { if ( wait Error ) { return new Promise ( ( resolve , reject ) = > { function unbind ( ) { emitter . remove Listener ( 'error ' , on Error ) ; emitter . remove Listener ( event , on Event ) ; } function on Event ( value ) { unbind ( ) ; resolve ( value ) ; } function on Error ( err ) { unbind ( ) ; reject ( err ) ; } emitter . on ( 'error ' , on Error ) ; emitter . on ( event , on Event ) ; } ) ; } return new Promise ( ( resolve ) = > emitter . once ( event , resolve ) ) ; } 
function promisify ( orig , options ) { if ( typeof orig ! = = 'function ' ) { throw new Type Error ( 'promisify requires a function ' ) ; } if ( orig [ k Custom Promisified Symbol ] ) { const fn = orig [ k Custom Promisified Symbol ] ; if ( typeof fn ! = = 'function ' ) { throw new Type Error ( 'The [util .promisify .custom ] property must be a function ' ) ; } Object . define Property ( fn , k Custom Promisified Symbol , { value : fn , enumerable : false , writable : false , configurable : true } ) ; return fn ; } function fn ( ) { const args = to Array ( arguments ) ; return new Promise ( ( resolve , reject ) = > { args . push ( callback Builder ( resolve , reject , options ) ) ; try { orig . apply ( this , args ) ; } catch ( err ) { reject ( err ) ; } } ) ; } Object . set Prototype Of ( fn , Object . get Prototype Of ( orig ) ) ; Object . define Property ( fn , k Custom Promisified Symbol , { value : fn , enumerable : false , writable : false , configurable : true } ) ; return Object . define Properties ( fn , get Own Property Descriptors ( orig ) ) ; } 
function promisify Method ( obj , method Name , options ) { if ( ! obj ) { 
function promisify Methods ( obj , method Names , options ) { if ( ! obj ) { 
function promisify All ( obj , options ) { if ( ! obj ) { 
function patch Promise ( ) { const props = { } ; for ( let method of methods ) { if ( Promise . prototype [ method . name ] & & Promise . prototype [ method . name ] ! = = method ) { throw new Error ( ' `Promise ` already defines method ` ' + method . name + ' ` ' ) ; } props [ method . name ] = { configurable : true , enumerable : false , writable : true , value : method } ; } Object . define Properties ( Promise . prototype , props ) ; } 
function unpatch Promise ( ) { for ( let method of methods ) { if ( Promise . prototype [ method . name ] = = = method ) { delete Promise . prototype [ method . name ] ; } } } 
function as Checked Callback ( promise , cb , use Own Method ) { let called = false ; if ( use Own Method ) { promise . as Callback ( after ) ; } else { as Callback ( promise , after ) ; } function after ( ) { expect ( called ) . to Be Falsy ( ) ; called = true ; return cb . apply ( this , arguments ) ; } } 
function as Callback ( promise , cb ) { promise . then ( ( res ) = > cb ( null , res ) , cb ) ; } 
function interpolate ( min , max , ratio ) { return Math . floor ( ratio * ( ( max + 0 . 5 ) - min ) + min ) ; } 
function sample ( gen , count , raw ) { if ( arguments . length < 2 ) { count = DEFAULT _COUNT ; } var rng = new PRNG ( Date . now ( ) & 0xffffffff ) ; var results = new Array ( count ) ; for ( var i = 0 ; i < count ; i + + ) { results [ i ] = gen ( rng , Math . floor ( i / 2 ) + 1 ) ; } return raw ? results : results . map ( get Root ) ; } 
function ( root , children Func ) { if ( ! ( this instanceof Rose Tree ) ) { return new Rose Tree ( root , children Func ) ; } this . root = root ; this . _children = children Func ? new Thunk ( children Func ) : empty Thunk ; } 
function flatten ( tree ) { if ( ! ( tree . root instanceof Rose Tree ) ) { throw new Type Error ( "Can 't call flatten when elements aren 't trees " ) ; } return new Rose Tree ( tree . root . root , function ( ) { var inner Children = tree . root . children ( ) ; var outer Children = tree . children ( ) . map ( flatten ) ; return outer Children . concat ( inner Children ) ; } ) ; } 
function fmap ( f , tree ) { return new Rose Tree ( f ( tree . root ) , function ( ) { return tree . children ( ) . map ( fmap . bind ( null , f ) ) ; } ) ; } 
function filter Subtrees ( pred , tree ) { return new Rose Tree ( tree . root , function ( ) { return tree . children ( ) . filter ( function ( subtree ) { return pred ( subtree . root ) ; } ) . map ( filter Subtrees . bind ( null , pred ) ) ; } ) ; } 
function array To Rose Trees ( array , fun ) { return array . map ( function ( element ) { return new Rose Tree ( element , function ( ) { return fun ( element ) ; } ) ; } ) ; } 
function roseify ( f ) { var roseified = function ( ) { var rest Args = [ ] . slice . call ( arguments , 1 ) ; return array To Rose Trees ( f . apply ( null , arguments ) , function ( value ) { return roseified . apply ( null , [ value ] . concat ( rest Args ) ) ; } ) ; } ; return roseified ; } 
function ( xts ) { return new Rose Tree ( xts . map ( function ( tree ) { return tree . root ; } ) , function ( ) { return exports . array ( xts , try Removing ) ; } ) ; } 
function State ( options ) { const state = { options } const states = options . children state . path = path From URI ( options . uri ) state . params = params From URI ( options . uri ) state . query Params = query Params From URI ( options . uri ) state . states = states state . data = options . data state . enter = options . enter | | util . noop state . update = options . update state . exit = options . exit | | util . noop function init ( router , name , parent ) { state . router = router state . name = name state . is Default = name = = ' _default _ ' state . parent = parent state . parents = get Parents ( ) state . root = state . parent ? state . parents [ state . parents . length - 1 ] : state state . children = util . object To Array ( states ) state . full Name = get Full Name ( ) state . as Public = make Public API ( ) each Child State ( ( name , child State ) = > { child State . init ( router , name , state ) } ) } function full Path ( ) { let result = state . path let state Parent = state . parent while ( state Parent ) { if ( state Parent . path ) result = state Parent . path + ' / ' + result state Parent = state Parent . parent } return result } function get Parents ( ) { const parents = [ ] let parent = state . parent while ( parent ) { parents . push ( parent ) parent = parent . parent } return parents } function get Full Name ( ) { const result = state . parents . reduce Right ( ( acc , parent ) = > { return acc + parent . name + ' . ' } , ' ' ) + state . name return state . is Default ? result . replace ( ' . _default _ ' , ' ' ) : result } function all Query Params ( ) { return state . parents . reduce ( ( acc , parent ) = > { return util . merge Objects ( acc , parent . query Params ) } , util . copy Object ( state . query Params ) ) } function make Public API ( ) { return { name : state . name , full Name : state . full Name , data : options . data | | { } , parent : state . parent & & state . parent . as Public } } function each Child State ( callback ) { for ( let name in states ) callback ( name , states [ name ] ) } function matches ( paths ) { const params = { } const non Rest State Paths = state . paths . filter ( p = > p [ p . length - 1 ] ! = = ' * ' ) if ( non Rest State Paths . length > paths . length ) return false for ( let i = 0 ; i < paths . length ; i + + ) { const path = paths [ i ] const that Path = state . paths [ i ] if ( ! that Path ) return false const is Rest = that Path [ that Path . length - 1 ] = = = ' * ' if ( is Rest ) { const name = param Name ( that Path ) params [ name ] = paths . slice ( i ) . join ( ' / ' ) return params } const is Dynamic = that Path [ 0 ] = = = ' : ' if ( is Dynamic ) { const name = param Name ( that Path ) params [ name ] = path } else if ( that Path ! = path ) return false } return params } function interpolate ( params ) { const path = state . full Path ( ) . replace ( PARAMS , p = > params [ param Name ( p ) ] | | ' ' ) const query Params = all Query Params ( ) const passed Query Params = Object . keys ( params ) . filter ( p = > query Params [ p ] ) const query = passed Query Params . map ( p = > p + ' = ' + params [ p ] ) . join ( ' & ' ) return path + ( query . length ? ( ' ? ' + query ) : ' ' ) } function to String ( ) { return state . full Name } state . init = init state . full Path = full Path state . all Query Params = all Query Params state . matches = matches state . interpolate = interpolate state . to String = to String return state } 
function init ( router , name , parent ) { state . router = router state . name = name state . is Default = name = = ' _default _ ' state . parent = parent state . parents = get Parents ( ) state . root = state . parent ? state . parents [ state . parents . length - 1 ] : state state . children = util . object To Array ( states ) state . full Name = get Full Name ( ) state . as Public = make Public API ( ) each Child State ( ( name , child State ) = > { child State . init ( router , name , state ) } ) } 
function full Path ( ) { let result = state . path let state Parent = state . parent while ( state Parent ) { if ( state Parent . path ) result = state Parent . path + ' / ' + result state Parent = state Parent . parent } return result } 
function get Parents ( ) { const parents = [ ] let parent = state . parent while ( parent ) { parents . push ( parent ) parent = parent . parent } return parents } 
function get Full Name ( ) { const result = state . parents . reduce Right ( ( acc , parent ) = > { return acc + parent . name + ' . ' } , ' ' ) + state . name return state . is Default ? result . replace ( ' . _default _ ' , ' ' ) : result } 
function matches ( paths ) { const params = { } const non Rest State Paths = state . paths . filter ( p = > p [ p . length - 1 ] ! = = ' * ' ) if ( non Rest State Paths . length > paths . length ) return false for ( let i = 0 ; i < paths . length ; i + + ) { const path = paths [ i ] const that Path = state . paths [ i ] if ( ! that Path ) return false const is Rest = that Path [ that Path . length - 1 ] = = = ' * ' if ( is Rest ) { const name = param Name ( that Path ) params [ name ] = paths . slice ( i ) . join ( ' / ' ) return params } const is Dynamic = that Path [ 0 ] = = = ' : ' if ( is Dynamic ) { const name = param Name ( that Path ) params [ name ] = path } else if ( that Path ! = path ) return false } return params } 
function interpolate ( params ) { const path = state . full Path ( ) . replace ( PARAMS , p = > params [ param Name ( p ) ] | | ' ' ) const query Params = all Query Params ( ) const passed Query Params = Object . keys ( params ) . filter ( p = > query Params [ p ] ) const query = passed Query Params . map ( p = > p + ' = ' + params [ p ] ) . join ( ' & ' ) return path + ( query . length ? ( ' ? ' + query ) : ' ' ) } 
function is In ( full State Name ) { let current = state while ( current ) { if ( current . full Name = = full State Name ) return true current = current . parent } return false } 
function Router ( declarative States ) { const router = { } const states = state Trees ( declarative States ) const event Callbacks = { } let options = util . copy Object ( default Options ) let first Transition = true let ignore Next URLChange = false let current Path Query let current Params Diff = { } let current State let previous State let transition let leaf States let url Changed let initialized let hash Slash String function set State ( state , params , acc ) { const from State = transition ? State With Params ( transition . current State , transition . to Params ) : current State const diff = util . object Diff ( from State & & from State . params , params ) const to State = State With Params ( state , params , current Path Query , diff ) if ( prevent Transition ( from State , to State , diff ) ) { if ( transition & & transition . exiting ) cancel Transition ( ) return } if ( transition ) cancel Transition ( ) * Return whether the passed state is the same as the current one * in which case the router can ignore the change . * / function prevent Transition ( current , new State , diff ) { if ( ! current ) return false return ( new State . state = = current . state ) & & ( Object . keys ( diff . all ) . length = = 0 ) } function not Found ( state ) { logger . log ( 'State not found : { 0 } ' , state ) if ( options . not Found ) return set State ( leaf States [ options . not Found ] , { } ) else throw new Error ( 'State " ' + state + ' " could not be found ' ) } function configure ( with Options ) { util . merge Objects ( options , with Options ) return router } function init ( init State , init Params ) { if ( options . enable Logs | | Router . log ) Router . enable Logs ( ) if ( options . intercept Anchors ) intercept Anchors ( router ) hash Slash String = ' # ' + options . hash Prefix + ' / ' logger . log ( 'Router init ' ) init States ( ) log State Tree ( ) init State = ( init State ! = = undefined ) ? init State : url Path Query ( ) logger . log ( 'Initializing to state { 0 } ' , init State | | ' " " ' ) transition To ( init State , init Params ) listen To URLChanges ( ) initialized = true return router } function terminate ( ) { window . onhashchange = null window . onpopstate = null options = util . copy Object ( default Options ) logger . enabled = false logger . log = logger . error = util . noop } function listen To URLChanges ( ) { function on URLChange ( evt ) { if ( ignore Next URLChange ) { ignore Next URLChange = false return } const new State = evt . state | | url Path Query ( ) logger . log ( 'URL changed : { 0 } ' , new State ) url Changed = true set State For Path Query ( new State ) } window [ is Hash Mode ( ) ? 'onhashchange ' : 'onpopstate ' ] = on URLChange } function init States ( ) { const state Array = util . object To Array ( states ) add Default States ( state Array ) each Root State ( ( name , state ) = > { state . init ( router , name ) } ) assert Path Uniqueness ( state Array ) leaf States = register Leaf States ( state Array , { } ) assert No Ambiguous Paths ( ) } function assert Path Uniqueness ( states ) { const paths = { } states . for Each ( state = > { if ( paths [ state . path ] ) { const full Paths = states . map ( s = > s . full Path ( ) | | 'empty ' ) throw new Error ( 'Two sibling states have the same path ( ' + full Paths + ' ) ' ) } paths [ state . path ] = 1 assert Path Uniqueness ( state . children ) } ) } function assert No Ambiguous Paths ( ) { const paths = { } for ( var name in leaf States ) { const path = util . normalize Path Query ( leaf States [ name ] . full Path ( ) ) if ( paths [ path ] ) throw new Error ( 'Ambiguous state paths : ' + path ) paths [ path ] = 1 } } function add Default States ( states ) { states . for Each ( state = > { var children = util . object To Array ( state . states ) * Request a programmatic state change . * * Two notations are supported : * transition To ( 'my .target .state ' , {id : 3 3 , filter : 'desc ' } ) * transition To ( 'target / 3 3 ?filter =desc ' ) * / function transition To ( path Query Or Name ) { const name = leaf States [ path Query Or Name ] const params = ( name ? arguments [ 1 ] : null ) | | { } const acc = name ? arguments [ 2 ] : arguments [ 1 ] logger . log ( 'Changing state to { 0 } ' , path Query Or Name | | ' " " ' ) url Changed = false if ( name ) set State By Name ( name , params , acc ) else set State For Path Query ( path Query Or Name , acc ) } function replace Params ( new Params ) { if ( ! current State ) return const new Uri = router . link ( current State . state . full Name , new Params ) current State = State With Params ( current State . state , new Params , new Uri ) history . replace State ( new Uri , document . title , new Uri ) } function back To ( state Name , default Params , acc ) { const params = leaf States [ state Name ] . last Params | | default Params transition To ( state Name , params , acc ) } function set State For Path Query ( path Query , acc ) { let state , params , _state , _params current Path Query = util . normalize Path Query ( path Query ) const pq = current Path Query . split ( ' ? ' ) const path = pq [ 0 ] const query = pq [ 1 ] const paths = util . parse Paths ( path ) const query Params = util . parse Query Params ( query ) for ( var name in leaf States ) { _state = leaf States [ name ] _params = _state . matches ( paths ) if ( _params ) { state = _state params = util . merge Objects ( _params , query Params ) break } } if ( state ) set State ( state , params , acc ) else not Found ( current Path Query ) } function set State By Name ( name , params , acc ) { const state = leaf States [ name ] if ( ! state ) return not Found ( name ) const path Query = interpolate ( state , params ) set State For Path Query ( path Query , acc ) } function add State ( name , state ) { if ( states [ name ] ) throw new Error ( 'A state already exist in the router with the name ' + name ) state = state Tree ( state ) states [ name ] = state * Read the path /query from the URL . * / function url Path Query ( ) { const hash Slash = location . href . index Of ( hash Slash String ) let path Query if ( hash Slash > - 1 ) path Query = location . href . slice ( hash Slash + hash Slash String . length ) else if ( is Hash Mode ( ) ) path Query = ' / ' else path Query = ( location . pathname + location . search ) . slice ( 1 ) return util . normalize Path Query ( path Query ) } function is Hash Mode ( ) { return options . url Sync = = 'hash ' } function link ( state Name , params ) { const state = leaf States [ state Name ] if ( ! state ) throw new Error ( 'Cannot find state ' + state Name ) const interpolated = interpolate ( state , params ) const uri = util . normalize Path Query ( interpolated ) return is Hash Mode ( ) ? ' # ' + options . hash Prefix + uri : uri } function interpolate ( state , params ) { const encoded Params = { } for ( let key in params ) { if ( params [ key ] ! = = undefined ) encoded Params [ key ] = encode URIComponent ( params [ key ] ) } return state . interpolate ( encoded Params ) } function get Current ( ) { return current State & & current State . as Public } function get Previous ( ) { return previous State & & previous State . as Public } function get Params Diff ( ) { return current Params Diff } function all States Rec ( states , acc ) { acc . push . apply ( acc , states ) states . for Each ( state = > all States Rec ( state . children , acc ) ) return acc } function all States ( ) { return all States Rec ( util . object To Array ( states ) , [ ] ) } function find State ( by ) { const filter Fn = ( typeof by = = = 'object ' ) ? state = > by = = = state . options : state = > by = = = state . full Name const state = all States ( ) . filter ( filter Fn ) [ 0 ] return state & & state . as Public } function is First Transition ( ) { return previous State = = null } function on ( event Name , cb ) { event Callbacks [ event Name ] = cb return router } function state Trees ( states ) { return util . map Values ( states , state Tree ) } function state Tree ( state ) { if ( state . children ) state . children = state Trees ( state . children ) return State ( state ) } function log State Tree ( ) { if ( ! logger . enabled ) return function indent ( level ) { if ( level = = 0 ) return ' ' return new Array ( 2 + ( level - 1 ) * 4 ) . join ( ' ' ) + ' ─ ─ ' } const state Tree = function ( state ) { const path = util . normalize Path Query ( state . full Path ( ) ) const path Str = ( state . children . length = = 0 ) ? ' ( @ path ) ' . replace ( 'path ' , path ) : ' ' const str = indent ( state . parents . length ) + state . name + path Str + ' \n ' return str + state . children . map ( state Tree ) . join ( ' ' ) } let msg = ' \n State tree \n \n ' msg + = util . object To Array ( states ) . map ( state Tree ) . join ( ' ' ) msg + = ' \n ' logger . log ( msg ) } 
function set State ( state , params , acc ) { const from State = transition ? State With Params ( transition . current State , transition . to Params ) : current State const diff = util . object Diff ( from State & & from State . params , params ) const to State = State With Params ( state , params , current Path Query , diff ) if ( prevent Transition ( from State , to State , diff ) ) { if ( transition & & transition . exiting ) cancel Transition ( ) return } if ( transition ) cancel Transition ( ) 
function prevent Transition ( current , new State , diff ) { if ( ! current ) return false return ( new State . state = = current . state ) & & ( Object . keys ( diff . all ) . length = = 0 ) } 
function not Found ( state ) { logger . log ( 'State not found : { 0 } ' , state ) if ( options . not Found ) return set State ( leaf States [ options . not Found ] , { } ) else throw new Error ( 'State " ' + state + ' " could not be found ' ) } 
function init ( init State , init Params ) { if ( options . enable Logs | | Router . log ) Router . enable Logs ( ) if ( options . intercept Anchors ) intercept Anchors ( router ) hash Slash String = ' # ' + options . hash Prefix + ' / ' logger . log ( 'Router init ' ) init States ( ) log State Tree ( ) init State = ( init State ! = = undefined ) ? init State : url Path Query ( ) logger . log ( 'Initializing to state { 0 } ' , init State | | ' " " ' ) transition To ( init State , init Params ) listen To URLChanges ( ) initialized = true return router } 
function terminate ( ) { window . onhashchange = null window . onpopstate = null options = util . copy Object ( default Options ) logger . enabled = false logger . log = logger . error = util . noop } 
function transition To ( path Query Or Name ) { const name = leaf States [ path Query Or Name ] const params = ( name ? arguments [ 1 ] : null ) | | { } const acc = name ? arguments [ 2 ] : arguments [ 1 ] logger . log ( 'Changing state to { 0 } ' , path Query Or Name | | ' " " ' ) url Changed = false if ( name ) set State By Name ( name , params , acc ) else set State For Path Query ( path Query Or Name , acc ) } 
function replace Params ( new Params ) { if ( ! current State ) return const new Uri = router . link ( current State . state . full Name , new Params ) current State = State With Params ( current State . state , new Params , new Uri ) history . replace State ( new Uri , document . title , new Uri ) } 
function back To ( state Name , default Params , acc ) { const params = leaf States [ state Name ] . last Params | | default Params transition To ( state Name , params , acc ) } 
function add State ( name , state ) { if ( states [ name ] ) throw new Error ( 'A state already exist in the router with the name ' + name ) state = state Tree ( state ) states [ name ] = state 
function url Path Query ( ) { const hash Slash = location . href . index Of ( hash Slash String ) let path Query if ( hash Slash > - 1 ) path Query = location . href . slice ( hash Slash + hash Slash String . length ) else if ( is Hash Mode ( ) ) path Query = ' / ' else path Query = ( location . pathname + location . search ) . slice ( 1 ) return util . normalize Path Query ( path Query ) } 
function link ( state Name , params ) { const state = leaf States [ state Name ] if ( ! state ) throw new Error ( 'Cannot find state ' + state Name ) const interpolated = interpolate ( state , params ) const uri = util . normalize Path Query ( interpolated ) return is Hash Mode ( ) ? ' # ' + options . hash Prefix + uri : uri } 
function find State ( by ) { const filter Fn = ( typeof by = = = 'object ' ) ? state = > by = = = state . options : state = > by = = = state . full Name const state = all States ( ) . filter ( filter Fn ) [ 0 ] return state & & state . as Public } 
function state Tree ( state ) { if ( state . children ) state . children = state Trees ( state . children ) return State ( state ) } 
function Transition ( from State With Params , to State With Params , params Diff , acc , router , logger ) { let root = { root : null , inclusive : true } let enters let exits const from State = from State With Params & & from State With Params . state const to State = to State With Params . state const params = to State With Params . params const is Update = ( from State = = to State ) const transition = { from : from State , to : to State , to Params : params , cancel , run , cancelled : false , current State : from State } 
function transition Root ( from State , to State , is Update , params Diff ) { let closest Common Parent const parents = [ from State ] . concat ( from State . parents ) . reverse ( ) 
function exec Cmd ( i ) { var cmd = cmdlines [ i ] ; if ( ! cmd ) return ; var child = exec ( cmd , function ( error , stdout , stderr ) { if ( stdout ) { console . log ( ' - - exec stdout : ' ) ; console . log ( stdout ) ; } if ( stderr ) { console . log ( ' - - exec stderr : ' ) ; console . log ( stderr ) ; } if ( error ) { console . log ( ' - - exec error : ' ) ; console . log ( error ) ; } exec Cmd ( + + i ) ; } ) ; } 
function ( bytes , byte Offset , byte Length ) { try { UTF 8 . get String From Bytes ( bytes , byte Offset , byte Length , true ) ; } catch ( e ) { return true ; } return false ; } 
function ( ) { 
function MIDIFile Header ( buffer ) { let a ; 
function emit Error ( current Domain , err ) { util . _extend ( err , { domain : current Domain , domain _thrown : true } ) ; current Domain . emit ( 'error ' , err ) ; current Domain . exit ( ) ; } 
function start ( ) { 
function start Listening ( ) { if ( should Bind ) { try { bind ( self . fd , self . port , self . host ) ; listen ( self . fd , self . options . backlog ) ; } catch ( e ) { self . kill ( 'SIGKILL ' ) ; throw e ; } } self . callback & & self . callback ( ) ; self . emit ( 'listening ' ) ; } 
function sum ( arr , prop ) { return arr . reduce ( function ( sum , obj ) { return sum + obj . stats [ prop ] ; } , 0 ) ; } 
function traverse ( file ) { file = master . resolve ( file ) ; fs . stat ( file , function ( err , stat ) { if ( ! err ) { if ( stat . is Directory ( ) ) { if ( ~ exports . ignore Directories . index Of ( basename ( file ) ) ) return ; fs . readdir ( file , function ( err , files ) { files . map ( function ( f ) { return file + ' / ' + f ; } ) . for Each ( traverse ) ; } ) ; } else { watch ( file ) ; } } } ) ; } 
function watch ( file ) { if ( ! ~ extensions . index Of ( extname ( file ) ) ) return ; fs . watch File ( file , { interval : interval } , function ( curr , prev ) { if ( curr . mtime > prev . mtime ) { console . log ( ' \ 0 3 3 [ 3 6mchanged \ 0 3 3 [ 0m \ 0 3 3 [ 9 0m - %s \ 0 3 3 [ 0m ' , file ) ; master . restart Workers ( signal ) ; } } ) ; } 
function detect Geo CSV ( buf ) { var lines = buf . to String ( ) . split ( / \r \n | \r | \n / g ) . filter ( function ( line ) { return line ! = = ' ' ; } ) ; return lines . length > 0 & & 
function install Watcher ( starting Folder , callback ) { bs . init ( { server : config . commands . build . output , port : config . commands . build . port , ui : false , open : false , log Level : 'silent ' } ) const watcher = create Watcher ( path . join ( starting Folder , ' * * /data .xml ' ) ) watcher . on ( 'change ' , ( ) = > { callback ( ) bs . reload ( ) } ) } 
function install Development Watcher ( starting Folder , callback ) { const build Folder = config . commands . build . output 
function create Dir ( dir ) { if ( fs . exists Sync ( dir ) ) { return false } mkdirp . sync ( dir ) return true } 
function find All Files ( base Dir , { ignored Folders = [ ] , max Depth = undefined } = { } ) { let list = [ ] function search ( dir , depth ) { fs . readdir Sync ( dir ) . for Each ( file = > { file = path . join ( dir , file ) 
function get Element Height ( element ) { var clone = element . clone Node ( true ) clone . style . css Text = 'visibility : hidden ; display : block ; margin : - 9 9 9px 0 ' var height = ( element . parent Node . append Child ( clone ) ) . client Height element . parent Node . remove Child ( clone ) return height } 
function load Data File ( filename ) { let xml = fs . read File Sync ( filename , 'utf - 8 ' ) 
function normalize Keys ( keys , json ) { Object . keys ( json ) . filter ( k = > keys . includes ( k ) ) . for Each ( k = > { json [ k ] = normalize ( json [ k ] ) } ) return json } 
async function build ( data File Path , presskit , { company = { } , products = [ ] , analytics = ' ' } = { } ) { const build Folder = create And Get Build Folder ( ) const page Folder = get Page Folder ( build Folder , data File Path , presskit . type ) 
function create And Get Build Folder ( ) { const destination = config . commands . build . output sfs . create Dir ( destination ) return destination } 
function get Absolute Page Url ( data File Path , page Type ) { const build Folder = create And Get Build Folder ( ) const page Folder = get Page Folder ( build Folder , data File Path , page Type ) const html File Path = get Html File Path ( page Folder ) const relative Path = path . posix . relative ( build Folder , html File Path ) return path . posix . join ( config . commands . build . base Url , relative Path ) } 
function get Images Folder ( data File ) { const stat = fs . stat Sync ( data File ) const data File Folder = stat . is File ( ) ? path . dirname ( data File ) : data File return path . join ( data File Folder , images Folder Name ) } 
function get Images ( source ) { if ( ! fs . exists Sync ( source ) ) { console . error ( ` $ { source } ` , ' 🤔 ' ) return } const images = { header : null , screenshots : [ ] , logos : [ ] } sfs . find All Files ( source ) . for Each ( file Path With Source = > { 
function sort Screenshots By Categories ( images ) { const clone = { . . . images } 
async function create Thumbnails ( target , images ) { for ( const x of images ) { const image Path = path . join ( target , x ) const thumb Path = path . join ( target , ` $ { x } ` ) try { 
function export Archives ( images , source , target ) { if ( ! images ) return create Archive ( 'images .zip ' , target , source , images . screenshots ) create Archive ( 'logo .zip ' , target , source , images . logos ) } 
function parse XML ( xml ) { if ( ! xml ) { throw new Error ( 'XML input was null or empty ' ) } let data new XMLParser ( OPTIONS ) . parse String ( xml , function ( err , result ) { if ( err | | ! result ) { throw new Error ( 'Failed to parse XML file ' ) } 
function create Template ( type , destination ) { const template Path = get Template Path ( assets , type ) if ( ! template Path ) { throw new Error ( 'Missing template ! Make sure your presskit has a "type " field (product /company ) ' ) } register Partials ( assets ) register Helpers ( destination ) const template = fs . read File Sync ( template Path , 'utf - 8 ' ) return handlebars . compile ( template ) } 
function get Template Path ( folder , type ) { switch ( type ) { case 'product ' : return path . join ( folder , 'product .html ' ) case 'company ' : return path . join ( folder , 'company .html ' ) } } 
function register Partials ( folder ) { const partials Folder = path . join ( folder , ' _includes ' ) const partials = fs . readdir Sync ( partials Folder ) . filter ( is Valid Partial ) . reduce ( ( result , partial ) = > { const ext = path . extname ( partial ) const file Full Path = path . join ( partials Folder , partial ) const data = fs . read File Sync ( file Full Path , 'utf - 8 ' ) 
function ( image ) { const image Name = path . join ( 'images ' , image ) const thumb Name = path . join ( 'images ' , ` $ { image } ` ) const thumb Path = path . join ( destination , thumb Name ) if ( fs . exists Sync ( thumb Path ) ) return thumb Name return image Name } 
async function generate ( entry Point ) { console . log ( ` $ { chalk . green ( entry Point ) } ` ) clean Build Folder ( ) const pages = find Data ( entry Point ) if ( count Data Files ( pages ) = = = 0 ) { console . log ( ' ' ) console . warn ( 'No data files found ! ' ) return } if ( ! pages . company ) { console . log ( ' ' ) console . error ( 'No company data file found ! ' ) return } await generate HTML ( pages ) await export Additional Assets ( ) console . log ( ' ' ) console . log ( 'Done ! 👌 ' ) if ( config . commands . build . watch ) { const port = config . commands . build . port const address = chalk . green ( ` $ { port } ` ) show Header ( ` $ { address } ` ) start Watcher ( entry Point , ( ) = > generate HTML ( find Data ( entry Point ) ) ) } } 
function create Relation ( type , product ) { return { type , text : product . presskit . title , path : get Absolute Page Url ( product . path , product . presskit . type ) } } 
async function copy Mandatory Files ( ) { const build Dir = create And Get Build Folder ( ) for ( const f of assets To Copy ) { const filepath = path . resolve ( f ) 
function count Data Files ( pages ) { let count = 0 count + = ( pages . company ? 1 : 0 ) count + = pages . products . length return count } 
function is Data File ( filename ) { const ext = path . extname ( filename ) const filename Without Ext = path . basename ( filename , ext ) return filename Without Ext = = = 'data ' & & ext = = = ' .xml ' } 
function start Watcher ( entry Point , callback ) { if ( config . commands . build . dev ) { 
function colorize ( colorizer , args ) { return Array . from ( args ) . map ( el = > colorizer ( el ) ) } 
function run Build Command ( launch Options ) { config . commands . build = launch Options parse Entry Point ( launch Options . entry Point , ( err , entry ) = > { if ( err ) { console . warn ( 'No valid entry point provided . Use current directory instead ' ) console . log ( ' ' ) generator . generate ( process . cwd ( ) ) return } generator . generate ( entry ) } ) } 
function zip ( name , destination , source , files ) { if ( files & & files . length > 0 ) { const filename = path . join ( destination , name ) const output = fs . create Write Stream ( filename ) const archive = archiver ( 'zip ' , { store : true } ) archive . on ( 'error ' , ( err ) = > { throw err } ) archive . pipe ( output ) files . for Each ( ( f ) = > { archive . append ( fs . create Read Stream ( path . join ( source , f ) ) , { name : f } ) } ) archive . finalize ( ) return filename } } 
function is Prototype ( value ) { var Ctor = value & & value . constructor , proto = ( typeof Ctor = = 'function ' & & Ctor . prototype ) | | object Proto $ 4 ; return value = = = proto ; } 
function hash Has ( key ) { var data = this . _ _data _ _ ; return native Create ? ( data [ key ] ! = = undefined ) : has Own Property $ 6 . call ( data , key ) ; } 
function reduce ( collection , iteratee , accumulator ) { var func = is Array ( collection ) ? array Reduce : base Reduce , init Accum = arguments . length < 3 ; return func ( collection , base Iteratee ( iteratee , 4 ) , accumulator , init Accum , base Each ) ; } 
function assign Value ( object , key , value ) { var obj Value = object [ key ] ; if ( ! ( has Own Property $a . call ( object , key ) & & eq ( obj Value , value ) ) | | ( value = = = undefined & & ! ( key in object ) ) ) { base Assign Value ( object , key , value ) ; } } 
function base Keys In ( object ) { if ( ! is Object ( object ) ) { return native Keys In ( object ) ; } var is Proto = is Prototype ( object ) , result = [ ] ; for ( var key in object ) { if ( ! ( key = = 'constructor ' & & ( is Proto | | ! has Own Property $b . call ( object , key ) ) ) ) { result . push ( key ) ; } } return result ; } 
function is Empty ( value ) { if ( value = = null ) { return true ; } if ( is Array Like ( value ) & & ( is Array ( value ) | | typeof value = = 'string ' | | typeof value . splice = = 'function ' | | is Buffer ( value ) | | is Typed Array ( value ) | | is Arguments ( value ) ) ) { return ! value . length ; } var tag = get Tag $ 1 ( value ) ; if ( tag = = map Tag $ 3 | | tag = = set Tag $ 3 ) { return ! value . size ; } if ( is Prototype ( value ) ) { return ! base Keys ( value ) . length ; } for ( var key in value ) { if ( has Own Property $c . call ( value , key ) ) { return false ; } } return true ; } 
function some ( collection , predicate , guard ) { var func = is Array ( collection ) ? array Some : base Some ; if ( guard & & is Iteratee Call ( collection , predicate , guard ) ) { predicate = undefined ; } return func ( collection , base Iteratee ( predicate , 3 ) ) ; } 
function init Clone By Tag ( object , tag , is Deep ) { var Ctor = object . constructor ; switch ( tag ) { case array Buffer Tag $ 2 : return clone Array Buffer ( object ) ; case bool Tag $ 2 : case date Tag $ 2 : return new Ctor ( + object ) ; case data View Tag $ 3 : return clone Data View ( object , is Deep ) ; case float 3 2Tag $ 1 : case float 6 4Tag $ 1 : case int 8Tag $ 1 : case int 1 6Tag $ 1 : case int 3 2Tag $ 1 : case uint 8Tag $ 1 : case uint 8Clamped Tag $ 1 : case uint 1 6Tag $ 1 : case uint 3 2Tag $ 1 : return clone Typed Array ( object , is Deep ) ; case map Tag $ 4 : return new Ctor ; case number Tag $ 2 : case string Tag $ 3 : return new Ctor ( object ) ; case regexp Tag $ 2 : return clone Reg Exp ( object ) ; case set Tag $ 4 : return new Ctor ; case symbol Tag $ 2 : return clone Symbol ( object ) ; } } 
function for Each Right ( collection , iteratee ) { var func = is Array ( collection ) ? array Each Right : base Each Right ; return func ( collection , cast Function ( iteratee ) ) ; } 
function compile TS ( module ) { var exit Code = 0 ; var tmp Dir = path . join ( options . tmp Dir , "tsreq " ) ; var relative Folder = path . dirname ( path . relative ( process . cwd ( ) , module . filename ) ) ; var jsname = path . join ( tmp Dir , relative Folder , path . basename ( module . filename , " .ts " ) + " .js " ) ; if ( ! is Modified ( module . filename , jsname ) ) { return jsname ; } var argv = [ "node " , "tsc .js " , ! ! options . emit On Error ? " " : " - -no Emit On Error " , " - -nolib " , " - -root Dir " , process . cwd ( ) , " - -target " , options . target ES 5 ? "ES 5 " : "ES 3 " , ! ! options . module Kind ? " - -module " : " " , ! ! options . module Kind ? options . module Kind : " " , " - -out Dir " , tmp Dir , lib Path , options . node Lib ? path . resolve ( _ _dirname , "typings /node .d .ts " ) : null , module . filename ] ; var proc = merge ( merge ( { } , process ) , { argv : compact ( argv ) , exit : function ( code ) { if ( code ! = = 0 & & options . exit On Error ) { console . error ( 'Fatal Error . Unable to compile Type Script file . Exiting . ' ) ; process . exit ( code ) ; } exit Code = code ; } } ) ; var sandbox = { process : proc , require : require , module : module , Buffer : Buffer , set Timeout : set Timeout , clear Timeout : clear Timeout , _ _filename : tsc } ; tsc Script . run In New Context ( sandbox ) ; if ( exit Code ! = = 0 ) { throw new Error ( 'Unable to compile Type Script file . ' ) ; } return jsname ; } 
function to Hex String ( num ) { var str = num . to String ( 1 6 ) ; while ( str . length < 2 ) { str = ' 0 ' + str ; } return str ; } 
function to Color Hex String ( ref ) { var results = [ ] ; for ( var j = 0 , len = ref . length ; j < len ; j + + ) { results . push ( to Hex String ( ref [ j ] ) ) ; } return ' # ' + results . join ( ' ' ) ; } 
function reset Styles ( stack ) { var stack Clone = stack . slice ( 0 ) ; stack . length = 0 ; return stack Clone . reverse ( ) . map ( function ( tag ) { return ' < / ' + tag + ' > ' ; } ) . join ( ' ' ) ; } 
function range ( low , high ) { const results = [ ] ; for ( var j = low ; j < = high ; j + + ) { results . push ( j ) ; } return results ; } 
function category For Code ( code ) { code = parse Int ( code , 1 0 ) ; var result = null ; if ( code = = = 0 ) { result = 'all ' ; } else if ( code = = = 1 ) { result = 'bold ' ; } else if ( ( 2 < code & & code < 5 ) ) { result = 'underline ' ; } else if ( ( 4 < code & & code < 7 ) ) { result = 'blink ' ; } else if ( code = = = 8 ) { result = 'hide ' ; } else if ( code = = = 9 ) { result = 'strike ' ; } else if ( ( 2 9 < code & & code < 3 8 ) | | code = = = 3 9 | | ( 8 9 < code & & code < 9 8 ) ) { result = 'foreground -color ' ; } else if ( ( 3 9 < code & & code < 4 8 ) | | code = = = 4 9 | | ( 9 9 < code & & code < 1 0 8 ) ) { result = 'background -color ' ; } return result ; } 
function update Sticky Stack ( sticky Stack , token , data ) { if ( token ! = = 'text ' ) { sticky Stack = sticky Stack . filter ( not Category ( category For Code ( data ) ) ) ; sticky Stack . push ( { token : token , data : data , category : category For Code ( data ) } ) ; } return sticky Stack ; } 
function VFile ( options ) { var prop var index var length if ( ! options ) { options = { } } else if ( typeof options = = = 'string ' | | buffer ( options ) ) { options = { contents : options } } else if ( 'message ' in options & & 'messages ' in options ) { return options } if ( ! ( this instanceof VFile ) ) { return new VFile ( options ) } this . data = { } this . messages = [ ] this . history = [ ] this . cwd = process . cwd ( ) 
function assert Part ( part , name ) { if ( part . index Of ( path . sep ) ! = = - 1 ) { throw new Error ( ' ` ' + name + ' ` cannot be a path : did not expect ` ' + path . sep + ' ` ' ) } } 
function message ( reason , position , origin ) { var file Path = this . path var message = new VMessage ( reason , position , origin ) if ( file Path ) { message . name = file Path + ' : ' + message . name message . file = file Path } message . fatal = false this . messages . push ( message ) return message } 
async function init Project ( answers , install = true ) { const inquirer = require ( 'inquirer ' ) ; let template Name ; if ( answers . name ) { template Name = answers . name ; } else { 
function get Config ( project Dir , app Name , env ) { if ( ! [ 'dev ' , 'test ' , 'prod ' ] . includes ( env ) ) exit ( ` $ { env } ` ) ; process . env . NODE _ENV = { dev : 'development ' , test : 'testing ' , prod : 'production ' } [ env ] ; const config Path = path . join ( project Dir , 'basys .json ' ) ; let project Config ; try { project Config = fs . read File Sync ( config Path , 'utf 8 ' ) ; } catch ( e ) { exit ( ` $ { config Path } \n ` ) ; } try { project Config = JSON 5 . parse ( project Config ) ; } catch ( e ) { exit ( ` $ { config Path } $ { e . message } \n ` + 'You can use JSON 5 (https : / /json 5 .org ) which is an extension of the JSON format , that includes : \n ' + ' - comments , \n - unquoted and single -quoted object keys , \n - trailing commas , \n - single -quoted and multi -line strings . \n ' , ) ; } 
function code Config ( config ) { const conf = Object . create ( null ) ; for ( const key in config . custom ) { conf [ key ] = config . custom [ key ] ; } for ( const key of [ 'host ' , 'port ' , 'backend Port ' ] ) { conf [ key ] = config [ key ] ; } return conf ; } 
function monitor Server Status ( host , port , once , on Change ) { const socket = net . connect ( { host , port } ) ; let connected = true ; let reconnect = true ; socket . on ( 'connect ' , ( ) = > { connected = true ; on Change ( true ) ; if ( once ) { reconnect = false ; socket . destroy ( ) ; } } ) ; socket . on ( 'error ' , ( ) = > { } ) ; socket . on ( 'close ' , err = > { if ( reconnect ) { if ( connected ) { connected = false ; on Change ( false ) ; } set Timeout ( ( ) = > socket . connect ( { host , port } ) , 5 0 0 ) ; } } ) ; return socket ; } 
function ( cb ) { var id = new Buffer ( 8 ) , time = Date . now ( ) - this . epoch ; id . fill ( 0 ) ; 
function o ( pattern String , action ) { if ( typeof action = = = 'undefined ' ) { return [ pattern String , ' $ $ = $ 1 ; ' ] ; } action = action . replace ( / \bnew / g , ' $ &yy . ' ) ; return [ pattern String , ' $ $ = ' + action + ' ; ' ] ; } 
function Route ( spec ) { var route ; if ( this ) { 
function create Visitor ( handlers ) { node Types . for Each ( function ( node Type ) { if ( typeof handlers [ node Type ] = = = 'undefined ' ) { throw new Error ( 'No handler defined for ' + node Type . display Name ) ; } } ) ; return { visit : function ( node , context ) { return this . handlers [ node . display Name ] . call ( this , node , context ) ; } , handlers : handlers } ; } 
function write Top ( d , loc ) { if ( d . index Of ( ' \n ' ) ! = - 1 ) { throw 'Can not write content having \ \n ' } this . chunks . unshift ( chunk ( d , loc ) ) } 
function update Indent ( ) { var str = ' ' for ( var idx = 0 ; idx < this . indent Level ; idx + + ) { str + = this . indent Unit } this . current Indent = str } 
function parse Opts ( argv ) { var last Opt , parsed , opts = { } argv . for Each ( function ( arg ) { parsed = r Option . exec ( arg ) if ( parsed ) { last Opt = parsed [ 1 ] opts [ last Opt ] = true return } opts [ last Opt ] = arg } ) return opts } 
function run ( opts ) { throw If Required Option ( opts , 'src ' ) 
function _eval ( opts ) { throw If Required Option ( opts , 'src ' ) var src = opts [ 'src ' ] 
function compile ( opts ) { var src Path = opts [ 'src ' ] | | process . cwd ( ) var dst Path = opts [ 'dst ' ] var format = opts [ 'format ' ] | | 'cjs ' var to Stdout = dst Path = = = 'stdout ' var stat = fs . stat Sync ( src Path ) if ( ! src Path ) { src Path = path . cwd ( ) } 
function compile File ( src Path , dst Path , format , to Stdout ) { if ( ! fs . exists Sync ( dst Path ) ) { make Path ( dst Path ) } fs . read File ( src Path , 'utf 8 ' , function ( err , data ) { if ( err ) throw err var cwd = process . cwd ( ) var smap Dst Path = dst Path + ' .map ' var smap Src Path = path . relative ( path . dirname ( path . join ( cwd , dst Path ) ) , path . join ( cwd , src Path ) ) var result = ram . compile ( data , { filename : src Path , format : format , source Map : ! to Stdout , source Map Cfg : { source : smap Src Path , source Content : data } } ) if ( to Stdout ) { process . stdout . write ( result . js + ' \n ' ) return } if ( result . js ) { result . js = result . js + ' \n / / # source Mapping URL = ' + path . basename ( dst Path ) + ' .map ' fs . write File ( dst Path , result . js , 'utf 8 ' , function ( err ) { if ( err ) throw err } ) } if ( result . source Map ) { fs . write File ( smap Dst Path , result . source Map , 'utf 8 ' , function ( err ) { if ( err ) throw err } ) } } ) } 
function make Path ( dir Path ) { dir Path = path . dirname ( dir Path ) . split ( path . sep ) dir Path . reduce ( function ( dir Path , p ) { dir Path = path . join ( dir Path , p ) if ( ! fs . exists Sync ( dir Path ) ) { try { fs . mkdir Sync ( dir Path ) } catch ( e ) { throw 'Could not make path ' + dir Path } } return dir Path } , ' ' ) } 
function read From Stdin ( cb ) { var chunks = [ ] var stdin = process . stdin stdin . resume ( ) stdin . set Encoding ( 'utf 8 ' ) stdin . on ( 'data ' , function ( chunk ) { chunks . push ( chunk ) } ) stdin . on ( 'end ' , function ( ) { cb ( chunks . join ( ' ' ) ) } ) } 
function walk ( node , parent , ctx ) { if ( ! node ) { return } 
function is RIdent ( node ) { return node & & node . type & & node . type = = = T . IDENT & & node . content = = = 'R ' } 
function src To Chunks ( src , opts , ctx ) { opts = opts | | { } var ast = parse ( src , opts ) 
function chunks To Source Map ( chunks , cfg ) { var loc var out Line = 0 var out Column = 0 var smap = sourcemap . new Source Map ( ) var acc = ' ' chunks . for Each ( function ( chunk ) { if ( chunk . content = = = ' \n ' ) { out Line = out Line + 1 out Column = 0 } loc = chunk . loc if ( loc ) { smap . add ( 
function parse ( src , opts ) { var parser = new Parser ( ) parser . yy = { parse Error : util . parse Error , filename : opts . filename } return parser . parse ( src ) } 
function walk ( node , parent , ctx ) { if ( ! node ) { return } node . parent = parent 
function write Common JSStub ( ast , ctx ) { 
function write IIFEStub ( ctx ) { write Ramda Function As Global Stub ( ctx ) ctx . write Top ( ' ; (function ( ) { ' ) ctx . new Line ( ) ctx . new Line ( ) ctx . write ( ' } ) ( ) ' ) } 
function write Ramda Function As Global Stub ( ctx ) { ctx . new Line Top ( ) ctx . new Line Top ( ) Object . keys ( ctx . used Ramda Fns ) . for Each ( function ( key ) { ctx . new Line Top ( ) ctx . write Top ( 'var ' + key + ' = R . ' + key ) } ) } 
function for Methods ( obj , props , callback ) { var prop ; if ( typeof props = = = "string " ) { 
function crc 1 6 ( octet _nums ) { var crc = octet _nums [ 0 ] ; for ( var b = 1 ; b < octet _nums . length ; b + + ) { crc = _updcrc ( octet _nums [ b ] , crc ) ; } crc = _updcrc ( 0 , _updcrc ( 0 , crc ) ) ; 
function verify 3 2 ( bytes _arr , crc ) { try { _ _verify ( this . crc 3 2 ( bytes _arr ) , crc ) ; } catch ( err ) { err . input = bytes _arr . slice ( 0 ) ; throw err ; } } 
function ( hdr ) { 
function send _files ( session , files , options ) { if ( ! options ) options = { } ; 
function save _to _disk ( packets , name ) { var blob = new Blob ( packets ) ; var url = URL . create Object URL ( blob ) ; var el = document . create Element ( "a " ) ; el . style . display = "none " ; el . href = url ; el . download = name ; document . body . append Child ( el ) ; 
function offer _parameters ( params ) { if ( ! params . name ) { throw new Zmodem . Error ( "validation " , "Need “name ” ! " ) ; } if ( typeof params . name ! = = "string " ) { throw new Zmodem . Error ( "validation " , " “name ” ( " + p r ms .nam e + " ust be a string ! " ) ; } 
function strip _ignored _bytes ( octets ) { for ( var o = octets . length - 1 ; o > = 0 ; o - - ) { switch ( octets [ o ] ) { case XON : case XON _HIGH : case XOFF : case XOFF _HIGH : octets . splice ( o , 1 ) ; continue ; } } return octets ; } 
function find _subarray ( haystack , needle ) { var h = 0 , n ; var start = Date . now ( ) ; HAYSTACK : while ( h ! = = - 1 ) { h = haystack . index Of ( needle [ 0 ] , h ) ; if ( h = = = - 1 ) break HAYSTACK ; for ( n = 1 ; n < needle . length ; n + + ) { if ( haystack [ h + n ] ! = = needle [ n ] ) { h + + ; continue HAYSTACK ; } } return h ; } return - 1 ; } 
function register Action ( resource ) { return client . send Command ( { id : Lime . Guid ( ) , method : Lime . Command Method . SET , type : 'application /vnd .iris .event Track +json ' , uri : ' /event -track ' , resource : resource } ) . catch ( e = > console . log ( e ) ) ; } 
function wrap IPv 6Address ( host , port ) { if ( ! port ) { if ( host . index Of ( ' [ ' ) = = = 0 ) return host host = host . split ( ' : ' ) port = host [ 1 ] host = host [ 0 ] } return ' [ ' + host + ' ] : ' + port } 
function request ( snek ) { snek . options . body = snek . options . data ; const type = snek . options . response Type = = = 'arraybuffer ' ? 'array Buffer ' : 'text ' ; return window . fetch ( snek . options . url , snek . options ) . then ( ( r ) = > r [ type ] ( ) . then ( ( raw ) = > { const headers = { } ; for ( const [ k , v ] of r . headers . entries ( ) ) { headers [ k . to Lower Case ( ) ] = v ; } return { raw , headers , status Code : r . status , status Text : r . status Text , } ; } ) ) ; } 
function mime Of Buffer ( input ) { const buf = new Uint 8Array ( input ) ; if ( ! ( buf & & buf . length > 1 ) ) return null ; if ( buf [ 0 ] = = = 0x FF & & buf [ 1 ] = = = 0x D 8 & & buf [ 2 ] = = = 0x FF ) { return { ext : 'jpg ' , mime : 'image /jpeg ' , } ; } if ( buf [ 0 ] = = = 0x 8 9 & & buf [ 1 ] = = = 0x 5 0 & & buf [ 2 ] = = = 0x 4E & & buf [ 3 ] = = = 0x 4 7 ) { return { ext : 'png ' , mime : 'image /png ' , } ; } if ( buf [ 0 ] = = = 0x 4 7 & & buf [ 1 ] = = = 0x 4 9 & & buf [ 2 ] = = = 0x 4 6 ) { return { ext : 'gif ' , mime : 'image /gif ' , } ; } if ( buf [ 8 ] = = = 0x 5 7 & & buf [ 9 ] = = = 0x 4 5 & & buf [ 1 0 ] = = = 0x 4 2 & & buf [ 1 1 ] = = = 0x 5 0 ) { return { ext : 'webp ' , mime : 'image /webp ' , } ; } if ( buf [ 0 ] = = = 0x 4 6 & & buf [ 1 ] = = = 0x 4C & & buf [ 2 ] = = = 0x 4 9 & & buf [ 3 ] = = = 0x 4 6 ) { return { ext : 'flif ' , mime : 'image /flif ' , } ; } 
function parse _status _block ( block ) { var match ; var parsed = { } ; if ( ( match = block . match ( / bssid = ( [A -Fa -f 0 - 9 : ] { 1 7 } ) / ) ) ) { parsed . bssid = match [ 1 ] . to Lower Case ( ) ; } if ( ( match = block . match ( / freq = ( [ 0 - 9 ] + ) / ) ) ) { parsed . frequency = parse Int ( match [ 1 ] , 1 0 ) ; } if ( ( match = block . match ( / mode = ( [ ^ \s ] + ) / ) ) ) { parsed . mode = match [ 1 ] ; } if ( ( match = block . match ( / key _mgmt = ( [ ^ \s ] + ) / ) ) ) { parsed . key _mgmt = match [ 1 ] . to Lower Case ( ) ; } if ( ( match = block . match ( / [ ^b ]ssid = ( [ ^ \n ] + ) / ) ) ) { parsed . ssid = match [ 1 ] ; } if ( ( match = block . match ( / [ ^b ]pairwise _cipher = ( [ ^ \n ] + ) / ) ) ) { parsed . pairwise _cipher = match [ 1 ] ; } if ( ( match = block . match ( / [ ^b ]group _cipher = ( [ ^ \n ] + ) / ) ) ) { parsed . group _cipher = match [ 1 ] ; } if ( ( match = block . match ( / p 2p _device _address = ( [A -Fa -f 0 - 9 : ] { 1 7 } ) / ) ) ) { parsed . p 2p _device _address = match [ 1 ] ; } if ( ( match = block . match ( / wpa _state = ( [ ^ \s ] + ) / ) ) ) { parsed . wpa _state = match [ 1 ] ; } if ( ( match = block . match ( / ip _address = ( [ ^ \n ] + ) / ) ) ) { parsed . ip = match [ 1 ] ; } if ( ( match = block . match ( / [ ^ _ ]address = ( [A -Fa -f 0 - 9 : ] { 1 7 } ) / ) ) ) { parsed . mac = match [ 1 ] . to Lower Case ( ) ; } if ( ( match = block . match ( / uuid = ( [ ^ \n ] + ) / ) ) ) { parsed . uuid = match [ 1 ] ; } if ( ( match = block . match ( / [ ^s ]id = ( [ 0 - 9 ] + ) / ) ) ) { parsed . id = parse Int ( match [ 1 ] , 1 0 ) ; } return parsed ; } 
function parse _command _interface ( callback ) { return function ( error , stdout , stderr ) { if ( error ) { callback ( error ) ; } else { var output = parse _command _block ( stdout . trim ( ) ) ; if ( output . result = = = 'FAIL ' ) { callback ( new Error ( output . result ) ) ; } else { callback ( error , parse _command _block ( stdout . trim ( ) ) ) ; } } } ; } 
function parse _scan _results ( block ) { var match ; var results = [ ] ; var lines ; lines = block . split ( ' \n ' ) . map ( function ( item ) { return item + " \n " ; } ) ; lines . for Each ( function ( entry ) { var parsed = { } ; if ( ( match = entry . match ( / ( [A -Fa -f 0 - 9 : ] { 1 7 } ) \t / ) ) ) { parsed . bssid = match [ 1 ] . to Lower Case ( ) ; } if ( ( match = entry . match ( / \t ( [ \d ] + ) \t + / ) ) ) { parsed . frequency = parse Int ( match [ 1 ] , 1 0 ) ; } if ( ( match = entry . match ( / ( [ - ] [ 0 - 9 ] + ) \t / ) ) ) { parsed . signal Level = parse Int ( match [ 1 ] , 1 0 ) ; } if ( ( match = entry . match ( / \t ( \ [ . + \ ] ) \t / ) ) ) { parsed . flags = match [ 1 ] ; } if ( ( match = entry . match ( / \t ( [ ^ \t ] { 1 , 3 2 } ( ? = \n ) ) / ) ) ) { parsed . ssid = match [ 1 ] ; } if ( ! ( Object . keys ( parsed ) . length = = = 0 & & parsed . constructor = = = Object ) ) { results . push ( parsed ) ; } } ) ; return results ; } 
function parse _scan _results _interface ( callback ) { return function ( error , stdout , stderr ) { if ( error ) { callback ( error ) ; } else { callback ( error , parse _scan _results ( stdout . trim ( ) ) ) ; } } ; } 
function set ( interface , variable , value , callback ) { var command = [ 'wpa _cli -i ' , interface , 'set ' , variable , value ] . join ( ' ' ) ; return this . exec ( command , parse _command _interface ( callback ) ) ; } 
function parse _status _block ( block ) { var match ; var parsed = { interface : block . match ( / ^ ( [ ^ \s ] + ) / ) [ 1 ] } ; if ( ( match = block . match ( / Link encap : \s * ( [ ^ \s ] + ) / ) ) ) { parsed . link = match [ 1 ] . to Lower Case ( ) ; } if ( ( match = block . match ( / HWaddr \s + ( [ ^ \s ] + ) / ) ) ) { parsed . address = match [ 1 ] . to Lower Case ( ) ; } if ( ( match = block . match ( / inet 6 \s +addr : \s * ( [ ^ \s ] + ) / ) ) ) { parsed . ipv 6 _address = match [ 1 ] ; } if ( ( match = block . match ( / inet \s +addr : \s * ( [ ^ \s ] + ) / ) ) ) { parsed . ipv 4 _address = match [ 1 ] ; } if ( ( match = block . match ( / Bcast : \s * ( [ ^ \s ] + ) / ) ) ) { parsed . ipv 4 _broadcast = match [ 1 ] ; } if ( ( match = block . match ( / Mask : \s * ( [ ^ \s ] + ) / ) ) ) { parsed . ipv 4 _subnet _mask = match [ 1 ] ; } if ( ( match = block . match ( / UP / ) ) ) { parsed . up = true ; } if ( ( match = block . match ( / BROADCAST / ) ) ) { parsed . broadcast = true ; } if ( ( match = block . match ( / RUNNING / ) ) ) { parsed . running = true ; } if ( ( match = block . match ( / MULTICAST / ) ) ) { parsed . multicast = true ; } if ( ( match = block . match ( / LOOPBACK / ) ) ) { parsed . loopback = true ; } return parsed ; } 
function parse _status ( callback ) { return function ( error , stdout , stderr ) { if ( error ) callback ( error ) ; else callback ( error , stdout . trim ( ) . split ( ' \n \n ' ) . map ( parse _status _block ) ) ; } ; } 
function up ( options , callback ) { return this . exec ( 'ifconfig ' + options . interface + ' ' + options . ipv 4 _address + ' netmask ' + options . ipv 4 _subnet _mask + ' broadcast ' + options . ipv 4 _broadcast + ' up ' , callback ) ; } 
function enable ( options , callback ) { var file = options . interface + ' -wpa _supplicant .conf ' ; var command = 'wpa _passphrase " ' + options . ssid + ' " " ' + options . passphrase + ' " > ' + file + ' & & wpa _supplicant -i ' + options . interface + ' -B -D ' + options . driver + ' -c ' + file + ' & & rm -f ' + file ; return this . exec ( command , callback ) ; } 
function manual ( options , callback ) { var command = [ 'wpa _supplicant ' , ' -i ' , options . interface , ' -s -B -P /run /wpa _supplicant / ' + options . interface + ' .pid ' , ' -D ' , options . drivers . join ( ' , ' ) , ' -C /run /wpa _supplicant ' ] . join ( ' ' ) ; return this . exec ( command , callback ) ; } 
function expand _r ( options , lines , prefix ) { Object . get Own Property Names ( options ) . for Each ( function ( key ) { var full = prefix . concat ( key ) ; var value = options [ key ] ; if ( Array . is Array ( value ) ) { value . for Each ( function ( val ) { lines . push ( full . concat ( val ) . join ( ' ' ) ) ; } ) ; } else if ( typeof ( value ) = = 'object ' ) { expand _r ( value , lines , full ) ; } else { lines . push ( full . concat ( value ) . join ( ' ' ) ) ; } } ) ; } 
function enable ( options , callback ) { var file = options . interface + ' -udhcpd .conf ' ; var commands = [ ] . concat ( 'cat < <EOF > ' + file + ' & & udhcpd ' + file + ' & & rm -f ' + file , expand ( options ) ) ; return this . exec ( commands . join ( ' \n ' ) , callback ) ; } 
function parse _cell ( cell ) { var parsed = { } ; var match ; if ( ( match = cell . match ( / BSS ( [ 0 - 9A -Fa -f : - ] { 1 7 } ) \ (on / ) ) ) { parsed . address = match [ 1 ] . to Lower Case ( ) ; } if ( ( match = cell . match ( / freq : ( [ 0 - 9 ] + ) / ) ) ) { parsed . frequency = parse Int ( match [ 1 ] , 1 0 ) ; } if ( ( match = cell . match ( / signal : ( - ? [ 0 - 9 . ] + ) d Bm / ) ) ) { parsed . signal = parse Float ( match [ 1 ] ) ; } if ( ( match = cell . match ( / last seen : ( [ 0 - 9 ] + ) ms ago / ) ) ) { parsed . last Seen Ms = parse Int ( match [ 1 ] , 1 0 ) ; } if ( ( match = cell . match ( / SSID : \ \x 0 0 / ) ) ) { delete parsed . ssid ; } else if ( ( match = cell . match ( / SSID : ( [ ^ \n ] * ) / ) ) ) { parsed . ssid = match [ 1 ] ; } if ( ( match = cell . match ( / DS Parameter set : channel ( [ 0 - 9 ] + ) / ) ) ) { parsed . channel = parse Int ( match [ 1 ] , 1 0 ) ; } else if ( ( match = cell . match ( / \ * primary channel : ( [ 0 - 9 ] + ) / ) ) ) { parsed . channel = parse Int ( match [ 1 ] , 1 0 ) ; } if ( ( match = cell . match ( / RSN : [ \s * ] +Version : 1 / ) ) ) { parsed . security = 'wpa 2 ' ; } else if ( ( match = cell . match ( / WPA : [ \s * ] +Version : 1 / ) ) ) { parsed . security = 'wpa ' ; } else if ( ( match = cell . match ( / capability : ESS Privacy / ) ) ) { parsed . security = 'wep ' ; } else if ( ( match = cell . match ( / capability : ESS / ) ) ) { parsed . security = 'open ' ; } return parsed ; } 
function scan ( options , callback ) { var interface , show _hidden if ( typeof options = = = 'string ' ) { var interface = options ; var show _hidden = false ; } else { var interface = options . iface ; var show _hidden = options . show _hidden | | false ; } this . exec ( 'iw dev ' + interface + ' scan ' , parse _scan ( show _hidden , callback ) ) ; } 
function parse _status _block ( block ) { var match ; 
function enable ( options , callback ) { var file = options . interface + ' -hostapd .conf ' ; var commands = [ 'cat < <EOF > ' + file + ' & & hostapd -B ' + file + ' & & rm -f ' + file ] ; Object . get Own Property Names ( options ) . for Each ( function ( key ) { commands . push ( key + ' = ' + options [ key ] ) ; } ) ; return this . exec ( commands . join ( ' \n ' ) , callback ) ; } 
function parse _cell ( cell ) { var parsed = { } ; var match ; if ( ( match = cell . match ( / Address \s * [ : | = ] \s * ( [A -Fa -f 0 - 9 : ] { 1 7 } ) / ) ) ) { parsed . address = match [ 1 ] . to Lower Case ( ) ; } if ( ( match = cell . match ( / Channel \s * ( [ 0 - 9 ] + ) / ) ) ) { parsed . channel = parse Int ( match [ 1 ] , 1 0 ) ; } if ( ( match = cell . match ( / Frequency \s * [ : | = ] \s * ( [ 0 - 9 \ . ] + ) \s *GHz / ) ) ) { parsed . frequency = parse Float ( match [ 1 ] ) ; } if ( ( match = cell . match ( / Mode \s * [ : | = ] \s * ( [ ^ \s ] + ) / ) ) ) { parsed . mode = match [ 1 ] . to Lower Case ( ) ; } if ( ( match = cell . match ( / Quality \s * [ : | = ] \s * ( [ 0 - 9 ] + ) / ) ) ) { parsed . quality = parse Int ( match [ 1 ] , 1 0 ) ; } if ( ( match = cell . match ( / Signal level \s * [ : | = ] \s * ( - ? [ 0 - 9 ] + ) / ) ) ) { parsed . signal = parse Int ( match [ 1 ] , 1 0 ) ; } if ( ( match = cell . match ( / Noise level \s * [ : | = ] \s * ( - ? [ 0 - 9 ] + ) / ) ) ) { parsed . noise = parse Int ( match [ 1 ] , 1 0 ) ; } if ( ( match = cell . match ( / ESSID \s * [ : | = ] \s * " ( [ ^ " ] + ) " / ) ) ) { parsed . ssid = match [ 1 ] ; } if ( ( match = cell . match ( / WPA 2 \s +Version / ) ) ) { parsed . security = 'wpa 2 ' ; } else if ( ( match = cell . match ( / WPA \s +Version / ) ) ) { parsed . security = 'wpa ' ; } else if ( ( match = cell . match ( / Encryption key \s * [ : | = ] \s *on / ) ) ) { parsed . security = 'wep ' ; } else if ( ( match = cell . match ( / Encryption key \s * [ : | = ] \s *off / ) ) ) { parsed . security = 'open ' ; } return parsed ; } 
function parse _scan ( show _hidden , callback ) { return function ( error , stdout , stderr ) { if ( error ) callback ( error ) ; else if ( show _hidden ) { callback ( error , stdout . split ( / Cell [ 0 - 9 ] + - / ) . map ( parse _cell ) . filter ( has _keys ) . sort ( by _signal ) ) ; } else { callback ( error , stdout . split ( / Cell [ 0 - 9 ] + - / ) . map ( parse _cell ) . filter ( has _ssid ) . sort ( by _signal ) ) ; } } ; } 
function create Item Content ( cfg , item ) { var data = item . children | | cfg . data ; var frag = document . create Document Fragment ( ) ; var label = _ . el ( 'span ' ) ; var icon Prepend = _ . el ( 'i ' ) ; var icon Append = _ . el ( 'i ' ) ; var prepend Classes = [ 'fa ' ] ; var append Classes = [ 'fa ' ] ; 
function el ( element ) { var classes = [ ] ; var tag = element ; var el ; if ( is Element ( element ) ) { return element ; } classes = element . split ( ' . ' ) ; if ( classes . length > 1 ) { tag = classes [ 0 ] ; } el = document . create Element ( tag ) ; add Class ( el , classes . slice ( 1 ) ) ; return el ; } 
function closest ( element , test ) { var el = element ; while ( el ) { if ( test ( el ) ) { return el ; } el = el . parent Node ; } return null ; } 
function add Class ( element , class Name ) { var class Names = class Name ; function _add Class ( el , cn ) { if ( ! el . class Name ) { el . class Name = cn ; } else if ( ! has Class ( el , cn ) ) { if ( el . class List ) { el . class List . add ( cn ) ; } else { el . class Name + = ' ' + cn ; } } } if ( ! is Array ( class Name ) ) { class Names = class Name . trim ( ) . split ( / \s + / ) ; } class Names . for Each ( _add Class . bind ( null , element ) ) ; return element ; } 
function remove Class ( element , class Name ) { var class Names = class Name ; function _remove Class ( el , cn ) { var class Regex ; if ( el . class List ) { el . class List . remove ( cn ) ; } else { class Regex = new Reg Exp ( ' ( ? : ^ | \ \s ) ' + cn + ' ( ? ! \ \S ) ' , 'g ' ) ; el . class Name = el . class Name . replace ( class Regex , ' ' ) . trim ( ) ; } } if ( ! is Array ( class Name ) ) { class Names = class Name . trim ( ) . split ( / \s + / ) ; } class Names . for Each ( _remove Class . bind ( null , element ) ) ; return element ; } 
function has Class ( element , class Name ) { if ( ! element | | ! ( 'class Name ' in element ) ) { return false ; } return element . class Name . split ( / \s + / ) . index Of ( class Name ) ! = = - 1 ; } 
function next Siblings ( element ) { var next = element . next Sibling ; var siblings = [ ] ; while ( next ) { siblings . push ( next ) ; next = next . next Sibling ; } return siblings ; } 
function previous Siblings ( element ) { var prev = element . previous Sibling ; var siblings = [ ] ; while ( prev ) { siblings . push ( prev ) ; prev = prev . previous Sibling ; } return siblings ; } 
function unique Country Data ( data , type , parent ) { var hash = data . reduce ( function each ( prev , curr ) { if ( ! ( curr [ type ] in prev ) ) { if ( parent ) { if ( parent . label = = = curr [ parent . type ] ) { prev [ curr [ type ] ] = curr ; } } else if ( curr [ type ] ) { prev [ curr [ type ] ] = curr ; } } return prev ; } , { } ) ; return Object . keys ( hash ) . map ( function each ( item ) { return extend ( hash [ item ] , { label : item , type : type = = = 'name ' ? 'country ' : type } ) ; } ) ; } 
function includes Filter Match ( text ) { if ( ! configuration _ 1 . Configuration . includes Filter | | configuration _ 1 . Configuration . includes Filter . length = = = 0 ) return true ; if ( text = = = null | | text = = = undefined ) return false ; return text . includes ( configuration _ 1 . Configuration . includes Filter ) ; } 
function preferred Provider For ( uri ) { 
function provider Exists ( uri ) { let provider Origin = ( new URL ( uri ) ) . origin let provider Config Uri = provider Origin + ' / .well -known /openid -configuration ' return fetch ( provider Config Uri , { method : 'HEAD ' } ) . then ( result = > { if ( result . ok ) { return provider Origin } return null } ) } 
function discover From Headers ( web Id ) { return fetch ( web Id , { method : 'OPTIONS ' } ) . then ( response = > { if ( response . ok ) { return parse Provider Link ( response . headers ) } return null } ) } 
function validate Provider Uri ( provider , web Id ) { if ( ! provider ) { let error = new Error ( ` $ { web Id } ` ) error . status Code = 4 0 0 throw error } if ( ! valid Url . is Uri ( provider ) ) { let error = new Error ( ` $ { web Id } $ { provider } ` ) error . status Code = 4 0 0 throw error } } 
function authenticate ( auth Request ) { let debug = auth Request . host . debug | | console . log . bind ( console ) let web Id = authenticated User ( auth Request ) if ( web Id ) { debug ( 'User is already authenticated as ' , web Id ) init Subject Claim ( auth Request , web Id ) } else { 
function ( el ) { var class Name = el . class Name var list Class = class Name . split ( ' ' ) this . class List = list Class this . el = el } 
function ( el ) { this . el = el if ( typeof el . class List ! = = 'undefined ' ) { 
function ( obj , src ) { var result = false var key for ( key in obj ) { if ( obj . has Own Property ( key ) & & key = = = src ) result = true } return result } 
function ( v ) { var result = 0 var key for ( key in v ) { v . has Own Property ( key ) & & result + + } return result } 
function ( el , check ) { var cls = el . class List var size = cls . length var result = false var i = 0 for ( i ; i < size ; i + + ) { if ( cls [ i ] . to String ( ) = = = check ) result = true } return result } 
function ( v , search , val ) { var defined = Object . create ( null ) defined . is = false defined . count = 0 var length = v . length var i for ( i = 0 ; i < length ; i + + ) { if ( is Define ( v [ i ] [ search ] ) ) { if ( is Define ( val ) & & v [ i ] [ search ] = = = val ) { defined . is = true defined . count + = 1 } } } return defined } 
function ( el , classid ) { create El . enter = el var c Elm _exits = create El . $exits . length 
function ( el , classid ) { create El . exit = el var c Elm _enter = create El . $enter . length 
function ( rw ) { var result var rgsize = create El . register . length var i for ( i = 0 ; i < rgsize ; i + + ) { if ( create El . register [ i ] . raw Name = = = rw ) result = create El . register [ i ] . classid } return result } 
function ( css ) { css = css . split ( ' - ' ) var result = css [ 0 ] = = = 'float ' ? 'css Float ' : css [ 0 ] var size = css . length var i for ( i = 0 ; i < size ; i + + ) { if ( i > 0 ) result + = css [ i ] . char At ( 0 ) . to Upper Case ( ) + css [ i ] . substr ( 1 ) } return result } 
function ( arg , class Id , callback ) { var view = in View ( ' . ' + class Id ) arg = = = 'on ' ? view . on ( 'enter ' , callback . enter ) . on ( 'exit ' , callback . exit ) : arg = = = 'once ' ? view . once ( 'enter ' , callback . enter ) . once ( 'exit ' , callback . exit ) : console . warn ( ' [in -view ] event handler not found ' ) } 
function ( $m ) { var convert var key for ( key in $m ) { if ( $m . has Own Property ( key ) & & $m [ key ] = = = true ) { if ( is Define ( convert ) ) convert + = ' . ' + key else convert = key } } return convert } 
function ( arg ) { var result switch ( arg ) { case 'on ' : result = arg break case 'once ' : result = arg break case 'class ' : result = arg break case 'style ' : result = arg break case 'enter ' : result = arg break case 'leave ' : result = arg break case 'animate ' : result = arg break case 'parent ' : result = arg break default : console . warn ( ' [in -view ] argument $ {arg } undefined ' ) } return result } 
function ( bidd , callback ) { if ( ! is Define ( bidd . arg ) ) callback ( ) if ( bidd . arg = = = 'on ' | | bidd . arg = = = 'once ' & & obj Length ( bidd . modifiers ) = = = 0 ) callback ( ) } 
function ( clss , el ) { if ( is String ( clss ) ) class List ( el ) . add ( clss ) if ( is Object ( clss ) ) { var class Arr = el . class Name . split ( ' ' ) var key for ( key in clss ) { if ( class Arr . index Of ( key ) & & clss [ key ] = = = false ) class List ( el ) . remove ( key ) if ( clss . has Own Property ( key ) & & clss [ key ] = = = true ) class List ( el ) . add ( key ) } } if ( is Array ( clss ) ) { var i for ( i = 0 ; i < clss . length ; i + + ) { class List ( el ) . add ( clss [ i ] ) } } } 
function ( css , el ) { var style = el . style if ( is Object ( css ) ) { var key for ( key in css ) { if ( is Define ( style [ cssjs ( key ) ] ) ) style [ cssjs ( key ) ] = css [ key ] } } if ( is Array ( css ) ) { var size = css . length var i for ( i = 0 ; i < size ; i + + ) { if ( is Define ( style [ cssjs ( css [ i ] ) ] ) ) style [ cssjs ( css [ i ] ) ] = " " } } } 
function ( data ) { var inverse = [ [ 'In ' , 'Out ' ] , [ 'X ' , 'Y ' ] , [ 'Down ' , 'Up ' ] , [ 'Left ' , 'Right ' ] ] var i = 0 var size = inverse . length var result for ( i ; i < size ; i + + ) { var index = inverse [ i ] if ( index . index Of ( data ) > = 0 ) { var colm = index . index Of ( data ) result = colm = = = 0 ? index [ 1 ] : index [ 0 ] } } return result } 
function ( an , type ) { var data = an var animate var result if ( / ^ [a -z ] + [A -Z ] [a -z ] + $ / . test ( data ) ) { animate = data . match ( / ^ ( [a -z ] + ) ( [A -Z ] [a -z ] + ) $ / ) if ( type = = = 'toggle ' & & is Define ( animate _inverse ( animate [ 2 ] ) ) ) { result = animate [ 1 ] + animate _inverse ( animate [ 2 ] ) } } if ( / ^ [a -z ] + [A -Z ] [a -z ] + [A -Z ] $ / . test ( data ) ) { animate = data . match ( / ^ ( [a -z ] + ) ( [A -Z ] [a -z ] + ) ( [A -Z ] ) $ / ) if ( type = = = 'toggle ' & & is Define ( animate _inverse ( animate [ 2 ] ) ) ) { result = animate [ 1 ] + animate _inverse ( animate [ 2 ] ) + animate [ 3 ] } if ( type = = = 'toggle .inverse ' & & is Define ( animate _inverse ( animate [ 2 ] ) ) ) { var direct = is Define ( animate _inverse ( animate [ 3 ] ) ) ? animate _inverse ( animate [ 3 ] ) : animate [ 3 ] result = animate [ 1 ] + animate _inverse ( animate [ 2 ] ) + direct } } if ( / ^ [a -z ] + [A -Z ] [a -z ] + [A -Z ] [a -z ] + $ / . test ( data ) ) { animate = data . match ( / ^ ( [a -z ] + ) ( [A -Z ] [a -z ] + ) ( [A -Z ] [a -z ] + ) $ / ) if ( type = = = 'toggle ' & & is Define ( animate _inverse ( animate [ 2 ] ) ) ) { result = animate [ 1 ] + animate _inverse ( animate [ 2 ] ) + animate [ 3 ] } if ( type = = = 'toggle .inverse ' & & is Define ( animate _inverse ( animate [ 2 ] ) ) ) { var direct = is Define ( animate _inverse ( animate [ 3 ] ) ) ? animate _inverse ( animate [ 3 ] ) : animate [ 3 ] result = animate [ 1 ] + animate _inverse ( animate [ 2 ] ) + direct } } if ( / ^ [a -z ] + [A -Z ] [a -z ] + [A -Z ] [a -z ] + [A -Z ] [a -z ] + $ / . test ( data ) ) { animate = data . match ( / ^ ( [a -z ] + ) ( [A -Z ] [a -z ] + ) ( [A -Z ] [a -z ] + ) ( [A -Z ] [a -z ] + ) $ / ) if ( type = = = 'toggle ' & & is Define ( animate _inverse ( animate [ 2 ] ) ) ) { result = animate [ 1 ] + animate _inverse ( animate [ 2 ] ) + animate [ 3 ] } if ( type = = = 'toggle .inverse ' & & is Define ( animate _inverse ( animate [ 2 ] ) ) ) { var direct = is Define ( animate _inverse ( animate [ 3 ] ) ) ? animate _inverse ( animate [ 3 ] ) : animate [ 3 ] + is Define ( animate _inverse ( animate [ 4 ] ) ) ? animate _inverse ( animate [ 4 ] ) : animate [ 4 ] result = animate [ 1 ] + animate _inverse ( animate [ 2 ] ) + direct } } return result } 
function ( el , callback ) { var size = el . length var i = 0 for ( i ; i < size ; i + + ) { callback ( el [ i ] , i ) } } 
function ( cls , el , mdf ) { var display = el . get Attribute ( 'animate -display ' ) if ( display ! = = null ) { el . style . display = dispay } else { var none = el . get Attribute ( 'animate -display -none ' ) if ( none = = = null | | none ! = = 'false ' ) { el . style . display = 'block ' } } if ( is String ( cls ) ) { if ( is Define ( mdf ) ) { var inverse Anim = animate _direction ( cls , mdf ) if ( is Define ( inverse Anim ) & & class List ( el ) . has Class ( inverse Anim ) ) { var rm Class = { } rm Class [ inverse Anim ] = false object _class ( rm Class , el ) } } var has Toggling = false if ( class List ( el ) . has Class ( cls ) ) { has Toggling = true var rm Class = { } rm Class [ cls ] = false object _class ( rm Class , el ) } if ( is Define ( mdf ) & & has Toggling ) { var inverse Anim = animate _direction ( cls , mdf ) if ( is Define ( inverse Anim ) ) { object _class ( inverse Anim , el ) } } else { var animate = ! class List ( el ) . has Class ( 'animated ' ) ? [ 'animated ' , cls ] : cls object _class ( animate , el ) } } if ( is Array ( cls ) ) { var i = 0 var size = cls . length var i Class var animate for ( i ; i < size ; i + + ) { if ( class List ( el ) . has Class ( cls [ i ] ) ) { var rm Class = { } rm Class [ cls [ i ] ] = false i Class = i object _class ( rm Class , el ) } } if ( is Define ( mdf ) & & mdf = = = 'toggle ' ) { var get Class = is Define ( i Class ) & & size > 0 & & ( i Class + 1 ) < size ? cls [ ( i Class + 1 ) ] : cls [ 0 ] animate = ! class List ( el ) . has Class ( 'animated ' ) ? [ 'animated ' , get Class ] : get Class } else { animate = ! class List ( el ) . has Class ( 'animated ' ) ? cls . push ( 'animated ' ) : cls } object _class ( animate , el ) } } 
function ( el ) { var normal = el . query Selector All ( ' [animate ] ' ) var toggle = el . query Selector All ( ' [animate -toggle ] ' ) var inverse = el . query Selector All ( ' [animate -toggle -inverse ] ' ) if ( normal ! = = null ) element _looping ( normal , function ( els ) { var attr = els . get Attribute ( 'animate ' ) object _animation ( attr , els ) } ) if ( toggle ! = = null ) element _looping ( toggle , function ( els ) { var attr = els . get Attribute ( 'animate -toggle ' ) object _animation ( attr , els , 'toggle ' ) } ) if ( inverse ! = = null ) element _looping ( inverse , function ( els ) { var attr = els . get Attribute ( 'animate -toggle -inverse ' ) object _animation ( attr , els , 'toggle .inverse ' ) } ) } 
function ( el , $bd ) { 
function ( el , att ) { var result = false if ( / ^ \ . [ \w ] + / . test ( att ) ) { var class Name = att . match ( / ^ \ . ( [ \w ] + ) / ) [ 1 ] var g Class = el . class Name . split ( ' ' ) if ( g Class . index Of ( class Name ) > - 1 ) { result = true } } if ( / ^ \ # [ \w ] + / . test ( att ) ) { var id Name = att . match ( / ^ \ # ( [ \w ] + ) / ) [ 1 ] if ( el . has Attribute ( 'id ' ) & & el . get Attribute ( 'id ' ) = = = id Name ) result = true } if ( / ^ \ [ [ \w ] + = \ " [ \w ] + \ " \ ] $ / . test ( att ) ) { var attr = att . match ( / ^ \ [ ( [ \w ] + ) = \ " ( [ \w ] + ) \ " \ ] $ / ) var att Name = attr [ 1 ] var attval = attr [ 2 ] if ( el . has Attribute ( att Name ) & & el . get Attribute ( att Name ) = = = attval ) result = true } if ( / ^ \ [ [ \w ] + = \ ' [ \w ] + \ ' \ ] $ / . test ( att ) ) { var attr = att . match ( / ^ \ [ ( [ \w ] + ) = \ ' ( [ \w ] + ) \ ' \ ] $ / ) var att Name = attr [ 1 ] var attval = attr [ 2 ] if ( el . has Attribute ( att Name ) & & el . get Attribute ( att Name ) = = = attval ) result = true } return result } 
function ( $arg , $opt ) { var last Enter = 0 var last Exit = 0 update Life Cycle ( function ( ) { if ( is Define ( $opt ) & & is Object ( $opt ) & & is String ( $arg ) ) { if ( count Entered > last Enter ) { is Define ( $opt . enter ) & & has Att ( create El . enter , $arg ) & & $opt . enter ( create El . enter ) last Enter = count Entered } if ( count Exits > last Exit ) { is Define ( $opt . exit ) & & has Att ( create El . exit , $arg ) & & $opt . exit ( create El . exit ) last Exit = count Exits } } } ) } 
function find Workspace Root ( initial ) { if ( ! initial ) { initial = process . cwd ( ) ; } let previous = null ; let current = path . normalize ( initial ) ; do { const manifest = read Package JSON ( current ) ; const workspaces = extract Workspaces ( manifest ) ; if ( workspaces ) { const relative Path = path . relative ( current , initial ) ; if ( relative Path = = = ' ' | | micromatch ( [ relative Path ] , workspaces ) . length > 0 ) { return current ; } else { return null ; } } previous = current ; current = path . dirname ( current ) ; } while ( current ! = = previous ) ; return null ; } 
function madgwick AHRSupdate IMU ( gx , gy , gz , ax , ay , az ) { let recip Norm ; let s 0 , s 1 , s 2 , s 3 ; let q Dot 1 , q Dot 2 , q Dot 3 , q Dot 4 ; let v 2q 0 , v 2q 1 , v 2q 2 , v 2q 3 , v 4q 0 , v 4q 1 , v 4q 2 , v 8q 1 , v 8q 2 , q 0q 0 , q 1q 1 , q 2q 2 , q 3q 3 ; 
function madgwick AHRSupdate ( gx , gy , gz , ax , ay , az , mx , my , mz , delta Time Sec ) { recip Sample Freq = delta Time Sec | | recip Sample Freq ; let recip Norm ; let s 0 , s 1 , s 2 , s 3 ; let q Dot 1 , q Dot 2 , q Dot 3 , q Dot 4 ; let hx , hy ; let v 2q 0mx , v 2q 0my , v 2q 0mz , v 2q 1mx , v 2bx , v 2bz , v 4bx , v 4bz , v 2q 0 , v 2q 1 , v 2q 2 , v 2q 3 , v 2q 0q 2 , v 2q 2q 3 ; let q 0q 0 , q 0q 1 , q 0q 2 , q 0q 3 , q 1q 1 , q 1q 2 , q 1q 3 , q 2q 2 , q 2q 3 , q 3q 3 ; 
function mahony AHRSupdate IMU ( gx , gy , gz , ax , ay , az ) { let recip Norm ; let halfvx , halfvy , halfvz ; let halfex , halfey , halfez ; 
function mahony AHRSupdate ( gx , gy , gz , ax , ay , az , mx , my , mz , delta Time Sec ) { recip Sample Freq = delta Time Sec | | recip Sample Freq ; let recip Norm ; let q 0q 0 , q 0q 1 , q 0q 2 , q 0q 3 , q 1q 1 , q 1q 2 , q 1q 3 , q 2q 2 , q 2q 3 , q 3q 3 ; let hx , hy , bx , bz ; let halfvx , halfvy , halfvz , halfwx , halfwy , halfwz ; let halfex , halfey , halfez ; 
function ( ) { var self = this ; console . log ( 'starting capture . . . ' ) ; var req = get _req ( ) ; req . onreadystatechange = function start _capture _response ( ) { if ( req . ready State = = = 4 ) { if ( req . status = = 2 0 0 ) { console . log ( 'started . ' ) ; j Query ( " #start " ) . hide ( ) ; j Query ( " #stop " ) . show ( ) ; htracr . ui . pulse _logo ( ) ; } else { var error = eval ( " ( " + req . response Text + " ) " ) ; alert ( "Sorry , I can 't start the sniffer ; it says \ " " + error . message + " \ " . " ) ; console . log ( "start problem : " + error ) ; } } } ; req . open ( "POST " , " /start " , true ) ; req . send ( " " ) ; return false ; } 
function ( ) { var self = this ; console . log ( 'stopping capture . . . ' ) ; var req = get _req ( ) ; req . onreadystatechange = function stop _capture _response ( ) { if ( req . ready State = = = 4 ) { self . update _state ( ) ; console . log ( 'stopped . ' ) ; j Query ( " #stop " ) . hide ( ) ; j Query ( " #start " ) . show ( ) ; htracr . ui . unpulse _logo ( true ) ; } } ; req . open ( "POST " , " /stop " , true ) ; req . send ( " " ) ; return false ; } 
function ( ) { var self = this ; console . log ( 'updating . . . ' ) ; var req = get _req ( ) ; req . onreadystatechange = function update _state _response ( ) { if ( req . ready State = = = 4 ) { if ( req . status = = = 2 0 0 ) { var capture = JSON . parse ( req . response Text ) ; if ( capture . error ) { alert ( capture . error . message ) ; } htracr . ui . update ( capture ) ; console . log ( 'updated . ' ) ; } else { console . log ( 'no updates . ' ) ; } } } ; req . open ( "GET " , " /conns " , true ) ; req . send ( " " ) ; return false ; } 
function ( ) { var self = this ; console . log ( 'clearing . . . ' ) ; var req = get _req ( ) ; req . onreadystatechange = function clear _state _response ( ) { if ( req . ready State = = = 4 ) { htracr . ui . clear ( ) ; } } ; req . open ( "POST " , " /clear " , true ) ; req . send ( " " ) ; return false ; } 
function ( ) { var self = this ; console . log ( 'getting servers . . . ' ) ; var req = get _req ( ) ; var server _names ; req . onreadystatechange = function get _servers _response ( ) { if ( req . ready State = = = 4 ) { server _names = JSON . parse ( req . response Text ) ; } } ; req . open ( "GET " , " /servers " , false ) ; req . send ( " " ) ; return server _names ; } 
function ( packet _id ) { var req = get _req ( ) ; var data ; req . onreadystatechange = function packet _fetch ( ) { if ( req . ready State = = = 4 & & req . status = = = 2 0 0 ) { data = j Query ( ' <div / > ' ) . text ( JSON . parse ( req . response Text ) . data ) . html ( ) ; } } ; 
function get _req ( ) { var self = this ; var req ; if ( window . XMLHttp Request ) { try { req = new XMLHttp Request ( ) ; } catch ( e 1 ) { req = false ; } } else if ( window . Active XObject ) { try { req = new Active XObject ( "Microsoft .XMLHTTP " ) ; } catch ( e 2 ) { req = false ; } } return req ; } 
function ( capture ) { var self = this ; self . clear ( ) ; self . capture = capture ; self . capture _idx = index _capture ( capture ) ; self . render ( ) ; } 
function ( ) { var self = this ; self . clear _ui ( ) ; self . resize ( ) ; self . draw _scale ( ) ; self . capture _idx . servers . for Each ( function ( bundle ) { var server _name = bundle [ 0 ] ; var conn _ids = bundle [ 1 ] ; var i ; self . y + = self . server _pad ; self . draw _server _label ( server _name ) ; self . y + = self . server _pad ; conn _ids . for Each ( function ( conn _id ) { var conn = self . capture . sessions [ server _name ] [ conn _id ] ; htracr . connection ( conn ) . draw ( di , [ server _name , conn _id , undefined , 0 ] ) ; i = 0 ; conn . http _reqs . for Each ( function ( http _req ) { var msg = htracr . http _msg ( http _req ) ; msg . kind = "req " ; msg . draw ( di , [ server _name , conn _id , 'http _reqs ' , i ] ) ; i + = 1 ; } ) ; i = 0 ; conn . http _ress . for Each ( function ( http _req ) { var msg = htracr . http _msg ( http _req ) ; msg . kind = "res " ; msg . draw ( di , [ server _name , conn _id , 'http _ress ' , i ] ) ; i + = 1 ; } ) ; i = 0 ; conn . packets . for Each ( function ( packet ) { var pkt = htracr . packet ( packet ) ; pkt . draw ( di , [ server _name , conn _id , 'packets ' , i ] ) ; i + = 1 ; } ) ; self . y + = self . conn _pad ; } ) ; self . draw _referers ( ) ; self . draw _locations ( ) ; } ) ; } 
function ( ) { var self = this ; var idx = self . capture _idx ; self . w = ( ( idx . end - idx . start ) / 1 0 0 0 * self . pix _per _sec ) + margin [ 1 ] + margin [ 3 ] ; self . h = margin [ 0 ] + margin [ 2 ] ; for ( var s in idx . servers ) { self . h + = ( self . server _pad * 2 ) ; self . h + = ( ( idx . servers [ s ] [ 1 ] . length ) * self . conn _pad ) ; } console . log ( "resizing to " + self . w + " x " + self . h ) ; paper . set Size ( self . w , self . h ) ; labels . set Size ( self . label _w , self . h ) ; } 
function ( ) { var self = this ; var start _x = time _x ( self . capture _idx . start ) ; var end _x = time _x ( self . capture _idx . end ) ; var end _y = self . h - margin [ 2 ] ; var end _attrs = { stroke : " # 6 6 6 " , "stroke -width " : " 1 " } ; var label _attrs = { fill : "white " , "font -size " : " 1 6 " , "opacity " : " . 5 " } ; paper . path ( "M " + start _x + " , " + margin [ 0 ] + " " + "L " + start _x + " , " + end _y ) . attr ( end _attrs ) ; var m ; if ( self . pix _per _sec < = 1 0 0 0 ) { m = 1 0 0 0 ; } else if ( self . pix _per _sec < = 2 0 0 0 ) { m = 5 0 0 ; } else if ( self . pix _per _sec < = 3 5 0 0 ) { m = 2 5 0 ; } else if ( self . pix _per _sec < = 5 0 0 0 ) { m = 1 0 0 ; } else { m = 5 0 ; } for ( var i = self . capture _idx . start ; i < self . capture _idx . end ; i + = m ) { var i _x = time _x ( i ) ; paper . path ( "M " + i _x + " , " + margin [ 0 ] + " " + "L " + i _x + " , " + end _y ) . attr ( { stroke : " # 4 4 4 " , "stroke -width " : " 1 " } ) ; paper . text ( i _x , end _y + 1 0 , ( ( i - self . capture _idx . start ) / 1 0 0 0 ) + "s " ) . attr ( label _attrs ) ; paper . text ( i _x , margin [ 0 ] - 2 0 , ( ( i - self . capture _idx . start ) / 1 0 0 0 ) + "s " ) . attr ( label _attrs ) ; } paper . path ( "M " + end _x + " , " + margin [ 0 ] + " " + "L " + end _x + " , " + end _y ) . attr ( end _attrs ) ; } 
function ( val ) { var self = this ; console . log ( "zooming to " + val + " . . . " ) ; self . pix _per _sec = val ; self . render ( ) ; } 
function ( start , end , y _adj , attrs ) { var start _x = time _x ( start ) | | margin [ 3 ] ; var end _x = time _x ( end ) | | ui . w - margin [ 1 ] ; var y = ui . y + y _adj ; var e = paper . path ( "M " + start _x + " , " + y + " " + "L " + end _x + " , " + y ) . attr ( attrs | | { } ) ; return e ; } 
function ( when , len , attrs ) { var x = time _x ( when ) ; var end _y = ui . y + len ; var e = paper . path ( "M " + x + " , " + ui . y + " " + "L " + x + " , " + end _y ) . attr ( attrs | | { } ) ; return e ; } 
function ( name , value , cursor , single ) { if ( value ) { if ( ! htracr . ui . urls [ name ] ) { ui . urls [ name ] = { } ; } if ( single = = = true ) { ui . urls [ name ] [ value ] = cursor ; } else { if ( ! ui . urls [ name ] [ value ] ) { ui . urls [ name ] [ value ] = [ ] ; } ui . urls [ name ] [ value ] . push ( cursor ) ; } } } 
function time _x ( t ) { var self = this ; if ( t = = = null ) { return null ; } var delta = t - ui . capture _idx . start ; if ( delta < 0 ) { console . log ( 'Negative delta for time ' + t ) ; } var pix = delta * ui . pix _per _sec / 1 0 0 0 ; var x = margin [ 3 ] + pix ; return x ; } 
function index _capture ( capture ) { function server _sortfunc ( a , b ) { return capture . sessions [ a [ 0 ] ] [ a [ 1 ] [ a [ 1 ] . length - 1 ] ] . start - capture . sessions [ b [ 0 ] ] [ b [ 1 ] [ b [ 1 ] . length - 1 ] ] } function conn _sortfunc ( a , b ) { return a . start - b . start ; } var servers = [ ] ; var start ; var end ; for ( var server _id in capture . sessions ) { if ( capture . sessions . has Own Property ( server _id ) ) { var conns = [ ] ; for ( var conn _id in capture . sessions [ server _id ] ) { if ( capture . sessions [ server _id ] . has Own Property ( conn _id ) ) { var conn = capture . sessions [ server _id ] [ conn _id ] ; if ( conn . http _reqs . length ) { conns . push ( conn ) ; } } } conns . sort ( conn _sortfunc ) ; var conn _ids = [ ] ; conns . for Each ( function ( conn ) { conn _ids . push ( conn . local _port ) ; } ) if ( conn _ids . length ) { if ( ! start | | conns [ 0 ] . start < start ) { start = conns [ 0 ] . start | | capture . start ; } if ( ! end | | conns [ conns . length - 1 ] . end > end ) { end = conns [ conns . length - 1 ] . end | | capture . end ; } servers . push ( [ server _id , conn _ids ] ) ; } } } servers . sort ( server _sortfunc ) ; return { start : start , end : end , servers : servers } ; } 
function wmic ( callback ) { var args = [ 'PROCESS ' , 'get ' , 'Parent Process Id ,Process Id ' ] ; var options = { windows Hide : true , windows Verbatim Arguments : true } ; bin ( 'wmic ' , args , options , function ( err , stdout , code ) { if ( err ) { callback ( err ) ; return ; } if ( code ! = = 0 ) { callback ( new Error ( 'pidtree wmic command exited with code ' + code ) ) ; return ; } 
function list ( PID , options , callback ) { if ( typeof options = = = 'function ' ) { callback = options ; options = { } ; } if ( typeof options ! = = 'object ' ) { options = { } ; } PID = parse Int ( PID , 1 0 ) ; if ( is Na N ( PID ) | | PID < - 1 ) { callback ( new Type Error ( 'The pid provided is invalid ' ) ) ; return ; } get All ( function ( err , list ) { if ( err ) { callback ( err ) ; return ; } 
function list ( pid , options , callback ) { if ( typeof options = = = 'function ' ) { callback = options ; options = undefined ; } if ( typeof callback = = = 'function ' ) { pidtree ( pid , options , callback ) ; return ; } return pify ( pidtree , pid , options ) ; } 
function get ( callback ) { if ( file = = = undefined ) { callback ( new Error ( os . platform ( ) + ' is not supported yet , please open an issue (https : / /github .com /simonepri /pidtree ) ' ) ) ; } var list = require ( ' . / ' + file ) ; list ( callback ) ; } 
function run ( cmd , args , options , done ) { if ( typeof options = = = 'function ' ) { done = options ; options = undefined ; } var executed = false ; var ch = spawn ( cmd , args , options ) ; var stdout = ' ' ; var stderr = ' ' ; ch . stdout . on ( 'data ' , function ( d ) { stdout + = d . to String ( ) ; } ) ; ch . stderr . on ( 'data ' , function ( d ) { stderr + = d . to String ( ) ; } ) ; ch . on ( 'error ' , function ( err ) { if ( executed ) return ; executed = true ; done ( new Error ( err ) ) ; } ) ; ch . on ( 'close ' , function ( code ) { if ( executed ) return ; executed = true ; if ( stderr ) { return done ( new Error ( stderr ) ) ; } done ( null , stdout , code ) ; } ) ; } 
function ps ( callback ) { var args = [ ' -A ' , ' -o ' , 'ppid ,pid ' ] ; bin ( 'ps ' , args , function ( err , stdout , code ) { if ( err ) return callback ( err ) ; if ( code ! = = 0 ) { return callback ( new Error ( 'pidtree ps command exited with code ' + code ) ) ; } 
function reg New Model ( name , schema , opts ) { var model = MRModel . apply ( moonridge Singleton , arguments ) models [ name ] = model return model } 
function bootstrap ( ) { var server = RPC . apply ( null , arguments ) var io = server . io var all Queries = [ ] Object . keys ( models ) . for Each ( function ( model Name ) { var model = models [ model Name ] model . _expose Callback ( server ) } ) io . use ( function ( socket , next ) { const registered LQs = { } socket . moonridge = { registered LQs : registered LQs , user : { privilege _level : 0 } } 
function ( socket ) { if ( this . listeners [ socket . id ] ) { delete this . listeners [ socket . id ] if ( Object . keys ( this . listeners ) . length = = = 0 ) { this . destroy ( ) 
function model Instance ( data ) { var self = this ; 
function Parser ( input ) { var o = ( this ! = = exports ) ? this : { } ; o . input = input ; o . pos = 0 ; o . line = 1 ; o . line Pos = 0 ; } 
function ( assemble , next ) { grunt . verbose . writeln ( 'Validating options ' ) ; if ( utils . ends With Dot ( assemble . options . ext ) ) { grunt . warn ( 'Invalid ext " ' + assemble . options . ext + ' " . ext cannot end with a period . ' ) ; done ( false ) ; } 
function ( assemble , next ) { grunt . verbose . writeln ( 'Assembling default layout ' . cyan ) ; 
function ( assemble , next ) { grunt . verbose . writeln ( 'Assembling partials ' . cyan ) ; 
function ( assemble , next ) { grunt . verbose . writeln ( 'Assembling data ' . cyan ) ; 
function ( build Done ) { 
function ( assemble , next ) { grunt . verbose . writeln ( ( ' \n ' + 'Assembling pages . . . ' ) . yellow ) ; async . for Each ( assemble . options . pages . slice ( ) , function ( page , done ) { grunt . verbose . writeln ( require ( 'util ' ) . inspect ( page ) ) ; build ( page , assemble , function ( err , result ) { grunt . log . write ( 'Assembling ' + ( page . dest ) . cyan + ' ' ) ; if ( err ) { grunt . verbose . write ( ' ' ) ; grunt . log . error ( ) ; grunt . warn ( err ) ; done ( false ) ; return ; } 
function ( current Page , assemble , callback ) { var options = assemble . options ; grunt . verbose . writeln ( 'Currentpage : ' + current Page ) ; var page Context = current Page . data ; var layout = _ . clone Deep ( options . default Layout ) ; var data = options . data ; var pages = options . pages ; var collections = options . collections ; var context = { } ; grunt . verbose . writeln ( 'Variables loaded ' ) ; try { 
function ( grunt , context , data ) { var current Grunt Config Data = grunt . config . data ; grunt . config . data = _ . extend ( { } , grunt . config . data , context , data ) ; var processed = grunt . config . process ( data | | context ) ; grunt . config . data = current Grunt Config Data ; return processed ; } 
function ( src , assemble , callback ) { var layout Stack = [ ] ; var layout Name = 'layout ' ; var default Layout = assemble . engine . start Delimiter + ' body ' + assemble . engine . end Delimiter ; 
function reduce Source With Rule ( source , rule , condition ) { if ( rule ) { if ( condition & & source . condition ! = = condition ) { 
function install ( Vue , options ) { var type = Object . prototype . to String . call ( options ) ; if ( type = = = ' [object String ] ' ) { Vue . component ( options , feather ) ; } else if ( type = = = ' [object Object ] ' ) { if ( options . props ) { if ( options . props . base Class ) { feather . props . base Class = options . props . base Class ; } if ( options . props . class Prefix ) { feather . props . class Prefix = options . props . class Prefix ; } } feather . mixins = [ options ] ; Vue . component ( options . name | | 'icon ' , feather ) ; } else { Vue . component ( 'icon ' , feather ) ; } } 
function cross Browser ( property , value , prefix ) { function ucase ( string ) { return string . char At ( 0 ) . to Upper Case ( ) + string . slice ( 1 ) ; } var vendor = [ 'webkit ' , 'moz ' , 'ms ' , 'o ' ] , properties = { } ; for ( var i = 0 ; i < vendor . length ; i + + ) { if ( prefix ) { value = value . replace ( prefix , ' - ' + vendor [ i ] + ' - ' + prefix ) ; } properties [ ucase ( vendor [ i ] ) + ucase ( property ) ] = value ; } properties [ property ] = value ; return properties ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; var userargs = JSON . parse ( decode URIComponent ( args [ "userargs " ] ) ) ; result . ok ( screenshot JNEXT . hello ( { userargs : userargs } ) ) ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; result Objs [ result . callback Id ] = result ; args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; vibration . get Instance ( ) . vibration _request ( result . callback Id , args ) ; result . no Result ( true ) ; } 
function ( success , fail , args ) { var userargs = JSON . parse ( decode URIComponent ( args [ "userargs " ] ) ) ; success ( template . get Instance ( ) . hello ( { userargs : userargs } ) ) ; } 
function ( success , fail , args ) { 
function ( success , fail , args ) { args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; success ( gse Crypto . get Instance ( ) . hash ( args ) ) ; } 
function Template ( dispatch ) { / / / / Properties (GET /SET ) : / / this . constructor . prototype . _ _define Getter _ _ ( "bool " , dispatch . get Boolean ) ; this . constructor . prototype . _ _define Setter _ _ ( "bool " , dispatch . set Boolean ) ; this . constructor . prototype . _ _define Getter _ _ ( "string " , dispatch . get String ) ; this . constructor . prototype . _ _define Setter _ _ ( "string " , dispatch . set String ) ; this . constructor . prototype . _ _define Getter _ _ ( "integer " , dispatch . get Integer ) ; this . constructor . prototype . _ _define Setter _ _ ( "integer " , dispatch . set Integer ) ; / / / / Functions : / / this . constructor . prototype . add = function ( first , second ) { return dispatch . add ( first , second ) ; } ; this . constructor . prototype . log = function ( msg ) { return dispatch . log ( msg ) ; } ; / / / / Callbacks : / / this . constructor . prototype . on Event = function ( callback ) { return dispatch . on Event ( callback ) ; } ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; var values = { value : args } ; result . ok ( curljs . get Instance ( ) . get ( result . callback Id , values ) , false ) ; } 
function Clipboard ( dispatch ) { / / / / Functions : / / this . constructor . prototype . set Text = function ( value ) { return dispatch . set Text ( value ) ; } ; this . constructor . prototype . get Text = function ( ) { return dispatch . get Text ( ) ; } ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; result . ok ( screen Display . get Instance ( ) . sdgetsize ( ) , false ) ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; result Objs [ result . callback Id ] = result ; read Callback = result . callback Id ; var views = qnx . webplatform . get Web Views ( ) ; var handle = null ; var group = null ; var z = - 1 ; for ( var i = 0 ; i < views . length ; i + + ) { if ( views [ i ] . visible & & views [ i ] . z Order > z ) { z = views [ i ] . z Order ; group = views [ i ] . window Group ; handle = views [ i ] . js Screen Window Handle ; } } if ( handle ! = = null ) { var values = { group : group , handle : handle } ; result . ok ( barcodescanner . get Instance ( ) . start Read ( result . callback Id , values ) , true ) ; } else { result . error ( "Failed to find window handle " , false ) ; } } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; result . ok ( password Crypto . get Instance ( ) . ping ( ) , false ) ; } 
function ( ) { if ( cordova . plugins & & cordova . plugins . simplexpbeacon ) { cordova . plugins . simplexpbeacon . plugin Version ( function ( data ) { console . log ( 'XXXX DATA : ' + data ) ; var json = JSON . parse ( data ) ; console . log ( 'XXXX json .status : ' + json . status ) ; if ( json . status = = = 'OK ' ) { app . log Message ( 'Plugin Version : ' + json . plugin _version ) ; } else { app . log Message ( 'Failed to get Plugin Version : ' + json . desc ) ; } } ) ; cordova . plugins . simplexpbeacon . initialise Bluetooth ( function ( data ) { console . log ( 'XXXX DATA : ' + data ) ; var json = JSON . parse ( data ) ; console . log ( 'XXXX json .status : ' + json . status ) ; if ( json . status = = = 'OK ' ) { app . log Message ( 'Bluetooth initialised ' ) ; bluetooth Initialised = true ; } else { app . log Message ( 'Bluetooth failed to initialise : ' + json . desc ) ; } } ) ; cordova . plugins . simplexpbeacon . add Beacon Uuid To Monitor ( " 8AEFB 0 3 1 - 6C 3 2 - 4 8 6F - 8 2 5B -E 2 6FA 1 9 3 4 8 7D " , function ( data ) { console . log ( 'XXXX DATA : ' + data ) ; var json = JSON . parse ( data ) ; console . log ( 'XXXX json .status : ' + json . status ) ; if ( json . status = = = 'OK ' ) { app . log Message ( 'Beacon added ' ) ; bluetooth Initialised = true ; } else { app . log Message ( 'Failed to add beacon : ' + json . desc ) ; } } ) ; } else { app . log Message ( 'Simplexp Xp Beacon Plugin was not found ' ) ; } } 
function ( ) { cordova . plugins . simplexpbeacon . remove Beacon Uuid To Monitor ( " 8AEFB 0 3 1 - 6C 3 2 - 4 8 6F - 8 2 5B -E 2 6FA 1 9 3 4 8 7D " , function ( data ) { console . log ( 'XXXX DATA : ' + data ) ; var json = JSON . parse ( data ) ; console . log ( 'XXXX json .status : ' + json . status ) ; if ( json . status = = = 'OK ' ) { app . log Message ( 'Beacon removed ' ) ; bluetooth Initialised = true ; } else { app . log Message ( 'Failed to remove beacon : ' + json . desc ) ; } } ) ; cordova . plugins . simplexpbeacon . terminate Bluetooth ( function ( data ) { console . log ( 'XXXX DATA : ' + data ) ; var json = JSON . parse ( data ) ; console . log ( 'XXXX json .status : ' + json . status ) ; if ( json . status = = = 'OK ' ) { app . log Message ( 'Bluetooth terminated ' ) ; } else { app . log Message ( 'Bluetooth failed to terminated : ' + json . desc ) ; } bluetooth Initialised = false ; } ) ; } 
function ( ) { $ ( " #btn Start Monitor " ) . click ( app . start Monitor Mode ) ; $ ( " #btn Stop Monitor " ) . click ( app . stop Monitor Mode ) ; $ ( document ) . one ( "mobileinit " , function ( ) { app . received Event ( 'deviceready ' ) ; } ) ; $ . get Script ( 'js /jquery .mobile - 1 . 4 . 4 .min .js ' ) ; } 
function ( id ) { console . log ( 'XXXX Received Event : ' + id ) ; $ ( " #btn Start Monitor " ) . prop ( 'disabled ' , false ) ; $ ( " #btn Stop Monitor " ) . prop ( 'disabled ' , true ) ; bt Le Handler . initialise ( ) ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; result . ok ( gse Crypto . get Instance ( ) . hash ( result . callback Id , args ) , false ) ; } 
function ( success , fail , args ) { args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; / / look for the UIWeb View in the set of Web Views . var views = qnx . webplatform . get Web Views ( ) ; var handle = null ; var z = - 1 ; for ( var i = 0 ; i < views . length ; i + + ) { if ( views [ i ] . visible & & views [ i ] . z Order > z ) { z = views [ i ] . z Order ; handle = views [ i ] . js Screen Window Handle ; } } if ( handle ! = = null ) { var values = { value : args , handle : handle } ; success ( preventsleep . get Instance ( ) . set Prevent Sleep ( values ) ) ; } else { success ( "Unable to get window handle " ) ; } } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; result . ok ( led . get Instance ( ) . start Led ( args ) , false ) ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; result . ok ( simple Bt Spp Plugin . get Instance ( ) . initialise Bluetooth ( ) , false ) ; } 
function set Text ( text ) { var text Div = document . get Element By Id ( "smart Poster Display _Text " ) ; clear Kids ( text Div ) ; text Div . append Child ( document . create Text Node ( text ) ) ; } 
function ( success , fail , args ) { args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; vibration . get Instance ( ) . vibration _request ( args ) ; success ( ) ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; var values = { value : args } ; result . ok ( clipboardjs . get Instance ( ) . set Text ( result . callback Id , values ) , false ) ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; var views = qnx . webplatform . get Web Views ( ) ; var handle = null ; var z = - 1 ; for ( var i = 0 ; i < views . length ; i + + ) { if ( views [ i ] . visible & & views [ i ] . z Order > z ) { z = views [ i ] . z Order ; handle = views [ i ] . js Screen Window Handle ; } } if ( handle ! = = null ) { var values = { value : args , handle : handle } ; result . ok ( prevent Sleep . get Instance ( ) . set Prevent Sleep ( result . callback Id , values ) , false ) ; } else { result . error ( "Unable to get window handle " , false ) ; } } 
function kat SHA ( ) { var which = Array ( "raw " , "hex " , "b 6 4 " ) ; var test Vectors = kat SHAvector ; var message = " " ; message + = " <h 2 >SHA KAT < /h 2 > " ; message + = " <table > " ; for ( var i = 0 ; i < test Vectors . length ; + + i ) { var suite = test Vectors [ i ] ; for ( var j = 0 ; j < which . length ; + + j ) { var encoding = which [ j ] ; var to Hash = suite [ encoding ] ; var params = { input : { } } ; params . input [ encoding ] = to Hash ; var results = suite . results ; for ( var k = 0 ; k < results . length ; + + k ) { var kat = results [ k ] ; var alg = kat . alg ; params . alg = alg ; var live = community . gse Crypto . hash ( params ) . output ; var match = kat . hex = = live . hex ; message + = ( " <tr > " ) ; message + = ( " <td class = ' " + ( match ? "pass " : "fail " ) + " ' > " + match + " < /td > " ) ; match = kat . b 6 4 = = live . b 6 4 ; message + = ( " <td class = ' " + ( match ? "pass " : "fail " ) + " ' > " + match + " < /td > " ) ; message + = ( " <td > " + JSON . stringify ( params ) + " < /td > " ) ; message + = ( " <td > " + kat . hex + " <br / > " + live . hex + " < /td > " ) ; message + = ( " <td > " + kat . b 6 4 + " <br / > " + live . b 6 4 + " < /td > " ) ; message + = ( " < /tr > " ) ; } } } message + = ( " < /table > " ) ; log ( message ) ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; if ( ! initialise Bluetooth Callback Id ) { initialise Bluetooth Callback Id = result . callback Id ; result Objs [ result . callback Id ] = result ; result . ok ( simple Xp Beacon Plugin . get Instance ( ) . initialise Bluetooth ( result . callback Id ) , true ) ; } else { result . error ( "Initialise Bluetooth failure " , false ) ; } } 
function ( ) { if ( com & & com . blackberry . community . simplebeaconplugin ) { console . log ( 'XXXX Plugin Version is : ' + com . blackberry . community . simplebeaconplugin . plugin Version ( ) ) ; var json = JSON . parse ( com . blackberry . community . simplebeaconplugin . initialise Bluetooth ( ) ) ; console . log ( 'XXXX json .status : ' + json . status ) ; if ( json . status = = = 'OK ' ) { app . log Message ( 'Bluetooth initialised ' ) ; bluetooth Initialised = true ; } else { app . log Message ( 'Bluetooth failed to initialise : ' + json . desc ) ; } } else { app . log Message ( 'Simple Beacon Plugin was not found ' ) ; } } 
function ( ) { var json = JSON . parse ( com . blackberry . community . simplebeaconplugin . terminate Bluetooth ( ) ) ; console . log ( 'XXXX json .status : ' + json . status ) ; if ( json . status = = = 'OK ' ) { app . log Message ( 'Bluetooth terminated ' ) ; } else { app . log Message ( 'Bluetooth failed to terminated : ' + json . desc ) ; } bluetooth Initialised = false ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; result . ok ( audiorec . get Instance ( ) . record ( ) , false ) ; } 
function make Get Call ( method ) { var recall = new blackberry . transport . Remote Function Call ( TEMPLATE _EXTENSION _URL + " / " + method ) ; / /return recall .make Sync Call ( ) ; recall . make Sync Call ( ) ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; result . ok ( mongoose . get Instance ( ) . start ( args ) , false ) ; } 
function kat AES ( ) { var plain Text = kat AESCBCvector . plain Text ; var vectors = kat AESCBCvector . vectors ; var message = " <table > <tbody > " ; for ( var i = 0 ; i < vectors . length ; + + i ) { var vector = vectors [ i ] ; var params = { alg : "aes " , mode : "cbc " , key : { hex : vector . key } , iv : { hex : vector . iv } , input : { hex : vector . result } } ; var result = community . gse Crypto . decrypt ( params ) ; if ( result . error ) { alert ( result . error ) ; } else { var match = result . output . hex = = plain Text ; var match Text = match ? "pass " : "fail " ; message + = " <tr > <td class = ' " ; message + = match Text ; message + = " ' > " ; message + = match Text ; message + = " < /td > <td > " ; message + = result . output . hex ; message + = " < /td > < /tr > " ; } } log ( message ) ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; result . ok ( email Sender . get Instance ( ) . send Email ( result . callback Id , args ) , false ) ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) ; args = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; result . ok ( u Pn P . get Instance ( ) . discover ( result . callback Id , args ) , false ) ; } 
function ( e ) { var target = get Target ( e ) ; if ( ! target ) return ; e . prevent Default ( ) ; PUSH ( { url : target . href , hash : target . hash , timeout : target . get Attribute ( 'data -timeout ' ) , transition : target . get Attribute ( 'data -transition ' ) } ) ; } 
function ( options ) { var key ; var data = { } ; var xhr = PUSH . xhr ; options . container = options . container | | options . transition ? document . query Selector ( ' .content ' ) : document . body ; for ( key in bars ) { options [ key ] = options [ key ] | | document . query Selector ( bars [ key ] ) ; } if ( xhr & & xhr . ready State < 4 ) { xhr . onreadystatechange = noop ; xhr . abort ( ) } xhr = new XMLHttp Request ( ) ; xhr . open ( 'GET ' , options . url , true ) ; xhr . set Request Header ( 'X -PUSH ' , 'true ' ) ; xhr . onreadystatechange = function ( ) { if ( options . _timeout ) clear Timeout ( options . _timeout ) ; if ( xhr . ready State = = 4 ) xhr . status = = 2 0 0 ? success ( xhr , options ) : failure ( options . url ) ; } ; if ( ! PUSH . id ) { cache Replace ( { id : + new Date , url : window . location . href , title : document . title , timeout : options . timeout , transition : null } ) ; } if ( options . timeout ) { options . _timeout = set Timeout ( function ( ) { xhr . abort ( 'timeout ' ) ; } , options . timeout ) ; } xhr . send ( ) ; if ( xhr . ready State & & ! options . ignore Push ) cache Push ( ) ; } 
function ( xhr , options ) { var key ; var bar Element ; var data = parse XHR ( xhr , options ) ; if ( ! data . contents ) return location Replace ( options . url ) ; if ( data . title ) document . title = data . title ; if ( options . transition ) { for ( key in bars ) { bar Element = document . query Selector ( bars [ key ] ) if ( data [ key ] ) swap Content ( data [ key ] , bar Element ) ; else if ( bar Element ) bar Element . parent Node . remove Child ( bar Element ) ; } } swap Content ( data . contents , options . container , options . transition , function ( ) { cache Replace ( { id : options . id | | + new Date , url : data . url , title : data . title , timeout : options . timeout , transition : options . transition } , options . id ) ; trigger State Change ( ) ; } ) ; if ( ! options . ignore Push & & window . _gaq ) _gaq . push ( [ ' _track Pageview ' ] ) 
function ( swap , container , transition , complete ) { var enter ; var container Direction ; var swap Direction ; if ( ! transition ) { if ( container ) container . inner HTML = swap . inner HTML ; else if ( swap . class List . contains ( 'content ' ) ) document . body . append Child ( swap ) ; else document . body . insert Before ( swap , document . query Selector ( ' .content ' ) ) ; } else { enter = / in $ / . test ( transition ) ; if ( transition = = 'fade ' ) { container . class List . add ( 'in ' ) ; container . class List . add ( 'fade ' ) ; swap . class List . add ( 'fade ' ) ; } if ( / slide / . test ( transition ) ) { swap . class List . add ( enter ? 'right ' : 'left ' ) ; swap . class List . add ( 'slide ' ) ; container . class List . add ( 'slide ' ) ; } container . parent Node . insert Before ( swap , container ) ; } if ( ! transition ) complete & & complete ( ) ; if ( transition = = 'fade ' ) { container . offset Width ; 
function ( success , fail , args , env ) { if ( ! processing ) { processing = true ; var result = new Plugin Result ( args , env ) ; result Objs [ result . callback Id ] = result ; var value ; if ( args & & args [ "input " ] ) { value = JSON . parse ( decode URIComponent ( args [ "input " ] ) ) ; audio Meta Data . get Instance ( ) . audio Meta Data Get Meta Data ( result . callback Id , value ) ; result . no Result ( true ) ; } } } 
function merge ( ) { var k , obj var res = { } var objs = Array . prototype . slice . call ( arguments ) for ( var i = 0 , l = objs . length ; i < l ; i + + ) { obj = objs [ i ] for ( k in obj ) { if ( obj . has Own Property ( k ) ) { res [ k ] = obj [ k ] } } } return res } 
function parse _tag ( str , parsers ) { if ( typeof str ! = = 'string ' | | str [ 0 ] ! = = ' @ ' ) { return null } var data = parsers . reduce ( function ( state , parser ) { var result try { result = parser ( state . source , merge ( { } , state . data ) ) } catch ( err ) { state . data . errors = ( state . data . errors | | [ ] ) . concat ( parser . name + ' : ' + err . message ) } if ( result ) { state . source = state . source . slice ( result . source . length ) state . data = merge ( state . data , result . data ) } return state } , { source : str , data : { } } ) . data data . optional = ! ! data . optional data . type = data . type = = = undefined ? ' ' : data . type data . name = data . name = = = undefined ? ' ' : data . name data . description = data . description = = = undefined ? ' ' : data . description return data } 
function parse _block ( source , opts ) { var trim = opts . trim ? function trim ( s ) { return s . trim ( ) } : function trim ( s ) { return s } var source _str = source . map ( function ( line ) { return trim ( line . source ) } ) . join ( ' \n ' ) source _str = trim ( source _str ) var start = source [ 0 ] . number 
function mkextract ( opts ) { var chunk = null var indent = 0 var number = 0 opts = merge ( { } , { trim : true , dotted _names : false , parsers : [ PARSERS . parse _tag , PARSERS . parse _type , PARSERS . parse _name , PARSERS . parse _description ] } , opts | | { } ) return function extract ( line ) { var result = null var start Pos = line . index Of ( MARKER _START ) var end Pos = line . index Of ( MARKER _END ) 
function Parser ( opts ) { opts = opts | | { } stream . Transform . call ( this , { object Mode : true } ) this . _extract = parse . mkextract ( opts ) } 
function tokenize ( content ) { var tokens = [ ] ; var parser = new htmlparser . Parser ( { onopentag : function ( name , attribs ) { } , ontext : function ( text ) { var start = parser . start Index ; tokens . push ( { value : text , index : start , offset : text . length } ) ; } , onclosetag : function ( tagname ) { } } ) ; parser . write ( content ) ; parser . end ( ) ; return tokens ; } 
function tokenize Define ( infos ) { return tokenize . split ( function ( text , tok ) { var _infos = _ . is Function ( infos ) ? infos . apply ( null , arguments ) : _ . clone ( infos ) ; if ( ! _infos ) return null ; 
function tokenize Check ( ) { var fn = tokenize . serie . apply ( tokenize , arguments ) ; return function ( text , opts , callback ) { try { callback ( null , fn ( text , opts ) ) ; } catch ( err ) { callback ( err ) ; } } ; } 
function parse File ( input ) { file Content = fs . read File Sync ( input , { encoding : "utf - 8 " } ) ; var ext = path . extname ( input ) ; if ( ext = = ' .html ' ) return tokenize HTML ( file Content ) ; return file Content ; } 
function soft Replace ( content Block , native String , localized String ) { var escaped String = ignore Extra Spaces ( ignore Empty Attrs ( utils . escape Reg Exp Special Chars ( native String ) ) ) ; var regex = new Reg Exp ( ' ( [ > " \ ' ] \ \s * ) ( ' + escaped String + ' ) ( \ \s * [ < " \ ' ] ) ' , 'g ' ) ; return content Block . replace ( regex , ' $ 1 ' + localized String + ' $ 3 ' ) ; } 
function ignore Extra Spaces ( string ) { return string . replace ( / ( \s + ) / g , ' \ \s + ' ) . replace ( / ( < \ \ \ / ) / g , ' < \ / \ \s * ' ) . replace ( / ( < ) / g , ' < \ \s * ' ) . replace ( / ( > ) / g , ' \ \s * > ' ) ; } 
function generate Nonce ( length ) { return generate Secure Random ( length ) . then ( ( nonce ) = > { const nonce String = base 6 4js . from Byte Array ( nonce ) ; return nonce String ; } ) ; } 
function _is Equal Array ( a , b ) { if ( a = = = b ) { return true ; } if ( ( a = = = undefined ) | | ( b = = = undefined ) ) { return false ; } var i = a . length ; if ( i ! = = b . length ) { return false ; } while ( i - - ) { if ( a [ i ] ! = = b [ i ] ) { return false ; } } return true ; } 
function _destroy Node ( node ) { 
function _context Get Create And Order Nodes ( render Node , prev ) { 
function _context Next ( ) { 
function _context Prev ( ) { 
function _context Get ( context Node Or Id ) { if ( this . _nodes By Id & & ( ( context Node Or Id instanceof String ) | | ( typeof context Node Or Id = = = 'string ' ) ) ) { var render Node = this . _nodes By Id [ context Node Or Id ] ; if ( ! render Node ) { return undefined ; } 
function _context Set ( context Node Or Id , set ) { var context Node = this . _nodes By Id ? _context Get . call ( this , context Node Or Id ) : context Node Or Id ; if ( context Node ) { var node = context Node . node ; if ( ! node ) { if ( context Node . next ) { if ( context Node . index < this . _context State . next Set Index ) { Layout Utility . error ( 'Nodes must be layed out in the same order as they were requested ! ' ) ; } this . _context State . next Set Index = context Node . index ; } else if ( context Node . prev ) { if ( context Node . index > this . _context State . prev Set Index ) { Layout Utility . error ( 'Nodes must be layed out in the same order as they were requested ! ' ) ; } this . _context State . prev Set Index = context Node . index ; } node = _context Get Create And Order Nodes . call ( this , context Node . render Node , context Node . prev ) ; node . _view Sequence = context Node . view Sequence ; node . _layout Count + + ; if ( node . _layout Count = = = 1 ) { this . _context State . add Count + + ; } context Node . node = node ; } node . uses True Size = context Node . uses True Size ; node . true Size Requested = context Node . true Size Requested ; node . set ( set , this . _context . size ) ; context Node . set = set ; } return set ; } 
function _resolve Config Size ( render Node ) { if ( render Node instanceof Render Node ) { var result = null ; var target = render Node . get ( ) ; if ( target ) { result = _resolve Config Size ( target ) ; if ( result ) { return result ; } } if ( render Node . _child ) { return _resolve Config Size ( render Node . _child ) ; } } else if ( render Node instanceof Surface ) { return render Node . size ? { render Node : render Node , size : render Node . size } : undefined ; } else if ( render Node . options & & render Node . options . size ) { return { render Node : render Node , size : render Node . options . size } ; } return undefined ; } 
function _context Resolve Size ( context Node Or Id , parent Size ) { var context Node = this . _nodes By Id ? _context Get . call ( this , context Node Or Id ) : context Node Or Id ; var resolve Size = this . _pool . resolve Size ; if ( ! context Node ) { resolve Size [ 0 ] = 0 ; resolve Size [ 1 ] = 0 ; return resolve Size ; } 
function _get Rounded Value 3D ( prop , def , precision , lock Value ) { if ( ! prop | | ! prop . init ) { return def ; } return [ prop . enabled [ 0 ] ? ( Math . round ( ( prop . cur State . x + ( ( prop . end State . x - prop . cur State . x ) * lock Value ) ) / precision ) * precision ) : prop . end State . x , prop . enabled [ 1 ] ? ( Math . round ( ( prop . cur State . y + ( ( prop . end State . y - prop . cur State . y ) * lock Value ) ) / precision ) * precision ) : prop . end State . y , prop . enabled [ 2 ] ? ( Math . round ( ( prop . cur State . z + ( ( prop . end State . z - prop . cur State . z ) * lock Value ) ) / precision ) * precision ) : prop . end State . z ] ; } 
function _set Property Value ( prop , prop Name , end State , default Value , immediate , is Translate ) { 
function _init Flow Layout Node ( node , spec ) { if ( ! spec & & this . options . flow Options . insert Spec ) { node . set Spec ( this . options . flow Options . insert Spec ) ; } } 
function _for Each Renderable ( callback ) { if ( this . _nodes By Id ) { for ( var key in this . _nodes By Id ) { callback ( this . _nodes By Id [ key ] ) ; } } else { var sequence = this . _view Sequence . get Head ( ) ; while ( sequence ) { var renderable = sequence . get ( ) ; if ( renderable ) { callback ( renderable ) ; } sequence = sequence . get Next ( ) ; } } } 
function _get Actual Direction ( direction ) { 
function _get View Sequence At Index ( index , start View Sequence ) { if ( this . _view Sequence . get At Index ) { return this . _view Sequence . get At Index ( index , start View Sequence ) ; } var view Sequence = start View Sequence | | this . _view Sequence ; var i = view Sequence ? view Sequence . get Index ( ) : index ; if ( index > i ) { while ( view Sequence ) { view Sequence = view Sequence . get Next ( ) ; if ( ! view Sequence ) { return undefined ; } i = view Sequence . get Index ( ) ; if ( i = = = index ) { return view Sequence ; } else if ( index < i ) { return undefined ; } } } else if ( index < i ) { while ( view Sequence ) { view Sequence = view Sequence . get Previous ( ) ; if ( ! view Sequence ) { return undefined ; } i = view Sequence . get Index ( ) ; if ( i = = = index ) { return view Sequence ; } else if ( index > i ) { return undefined ; } } } return view Sequence ; } 
function _init Layout Node ( node , spec ) { if ( ! spec & & this . options . flow Options . insert Spec ) { node . set Spec ( this . options . flow Options . insert Spec ) ; } } 
function _is Sequentially Scrolling Optimized ( ) { return ! this . _layout . capabilities | | ( this . _layout . capabilities . sequential Scrolling Optimized = = = undefined ) | | this . _layout . capabilities . sequential Scrolling Optimized ; } 
function _update Spring ( ) { var spring Value = this . _scroll . scroll Force Count ? undefined : this . _scroll . spring Position ; if ( this . _scroll . spring Value ! = = spring Value ) { this . _scroll . spring Value = spring Value ; if ( spring Value = = = undefined ) { if ( this . _scroll . spring Force Id ! = = undefined ) { this . _scroll . pe . detach ( this . _scroll . spring Force Id ) ; this . _scroll . spring Force Id = undefined ; 
function _mouse Down ( event ) { 
function _touch Start ( event ) { 
function _touch Move ( event ) { if ( ! this . options . enabled ) { return ; } 
function _touch End ( event ) { 
function _scroll Update ( event ) { if ( ! this . options . enabled ) { return ; } var offset = Array . is Array ( event . delta ) ? event . delta [ this . _direction ] : event . delta ; this . scroll ( offset ) ; } 
function _set Particle ( position , velocity , phase ) { if ( position ! = = undefined ) { 
function _calc Scroll Offset ( normalize , refresh Particle ) { 
function _calc Bounds ( size , scroll Offset ) { 
function _calc Scroll To Offset ( size , scroll Offset ) { var scroll To Render Node = this . _scroll . scroll To Render Node | | this . _scroll . ensure Visible Render Node ; if ( ! scroll To Render Node ) { return ; } 
function _snap To Page ( ) { 
function _normalize Prev View Sequence ( scroll Offset ) { var count = 0 ; var normalized Scroll Offset = scroll Offset ; var normalize Next Prev = false ; var node = this . _nodes . get Start Enum Node ( false ) ; while ( node ) { if ( ! node . _invalidated | | ! node . _view Sequence ) { break ; } if ( normalize Next Prev ) { this . _view Sequence = node . _view Sequence ; normalized Scroll Offset = scroll Offset ; normalize Next Prev = false ; } if ( ( node . scroll Length = = = undefined ) | | node . true Size Requested | | ( scroll Offset < 0 ) ) { break ; } scroll Offset - = node . scroll Length ; count + + ; if ( node . scroll Length ) { if ( this . options . alignment ) { normalize Next Prev = ( scroll Offset > = 0 ) ; } else { if ( Math . round ( scroll Offset ) > = 0 ) { this . _view Sequence = node . _view Sequence ; normalized Scroll Offset = scroll Offset ; } } } node = node . _prev ; } return normalized Scroll Offset ; } 
function _get Visible Item ( first ) { var result = { } ; var diff ; var prev Diff = 1 0 0 0 0 0 0 0 ; var diff Delta = ( first & & this . options . alignment ) ? - this . _context Size Cache [ this . _direction ] : ( ( ! first & & ! this . options . alignment ) ? this . _context Size Cache [ this . _direction ] : 0 ) ; var scroll Offset = this . _scroll . unnormalized Scroll Offset ; var node = this . _nodes . get Start Enum Node ( true ) ; while ( node ) { if ( ! node . _invalidated | | ( node . scroll Length = = = undefined ) ) { break ; } if ( node . _view Sequence ) { diff = Math . abs ( diff Delta - ( scroll Offset + ( ! first ? node . scroll Length : 0 ) ) ) ; if ( diff > = prev Diff ) { break ; } prev Diff = diff ; result . scroll Offset = scroll Offset ; result . _node = node ; scroll Offset + = node . scroll Length ; } node = node . _next ; } scroll Offset = this . _scroll . unnormalized Scroll Offset ; node = this . _nodes . get Start Enum Node ( false ) ; while ( node ) { if ( ! node . _invalidated | | ( node . scroll Length = = = undefined ) ) { break ; } if ( node . _view Sequence ) { scroll Offset - = node . scroll Length ; diff = Math . abs ( diff Delta - ( scroll Offset + ( ! first ? node . scroll Length : 0 ) ) ) ; if ( diff > = prev Diff ) { break ; } prev Diff = diff ; result . scroll Offset = scroll Offset ; result . _node = node ; } node = node . _prev ; } if ( ! result . _node ) { return undefined ; } result . scroll Length = result . _node . scroll Length ; if ( this . options . alignment ) { result . visible Perc = ( Math . min ( result . scroll Offset + result . scroll Length , 0 ) - Math . max ( result . scroll Offset , - this . _context Size Cache [ this . _direction ] ) ) / result . scroll Length ; } else { result . visible Perc = ( Math . min ( result . scroll Offset + result . scroll Length , this . _context Size Cache [ this . _direction ] ) - Math . max ( result . scroll Offset , 0 ) ) / result . scroll Length ; } result . index = result . _node . _view Sequence . get Index ( ) ; result . view Sequence = result . _node . _view Sequence ; result . render Node = result . _node . render Node ; return result ; } 
function _go To Sequence ( view Sequence , next , no Animation ) { if ( no Animation ) { this . _view Sequence = view Sequence ; this . _scroll . spring Position = undefined ; _update Spring . call ( this ) ; this . halt ( ) ; this . _scroll . scroll Delta = 0 ; _set Particle . call ( this , 0 , 0 , ' _go To Sequence ' ) ; this . _scroll . scroll Dirty = true ; } else { this . _scroll . scroll To Sequence = view Sequence ; this . _scroll . scroll To Render Node = view Sequence . get ( ) ; this . _scroll . ensure Visible Render Node = undefined ; this . _scroll . scroll To Direction = next ; this . _scroll . scroll Dirty = true ; } } 
function _ensure Visible Sequence ( view Sequence , next ) { this . _scroll . scroll To Sequence = undefined ; this . _scroll . scroll To Render Node = undefined ; this . _scroll . ensure Visible Render Node = view Sequence . get ( ) ; this . _scroll . scroll To Direction = next ; this . _scroll . scroll Dirty = true ; } 
function _go To Page ( amount , no Animation ) { 
function _layout ( size , scroll Offset , nested ) { 
function _inner Render ( ) { var specs = this . _specs ; for ( var i 3 = 0 , j 3 = specs . length ; i 3 < j 3 ; i 3 + + ) { if ( specs [ i 3 ] . render Node ) { specs [ i 3 ] . target = specs [ i 3 ] . render Node . render ( ) ; } } 
function List Layout ( context , options ) { 
function _set Pull To Refresh State ( pull To Refresh , state ) { if ( pull To Refresh . state ! = = state ) { pull To Refresh . state = state ; if ( pull To Refresh . node & & pull To Refresh . node . set Pull To Refresh Status ) { pull To Refresh . node . set Pull To Refresh Status ( state ) ; } } } 
function View Stack Layout ( context , options ) { var set = { size : context . size , translate : [ 0 , 0 , 0 ] } ; this . _size [ 0 ] = context . size [ 0 ] ; this . _size [ 1 ] = context . size [ 1 ] ; var views = context . get ( 'views ' ) ; var transferables = context . get ( 'transferables ' ) ; var visible Count = 0 ; for ( var i = 0 ; i < views . length ; i + + ) { var item = this . _view Stack [ i ] ; switch ( item . state ) { case Item State . HIDDEN : context . set ( views [ i ] , { size : context . size , translate : [ context . size [ 0 ] * 2 , context . size [ 1 ] * 2 , 0 ] } ) ; break ; case Item State . HIDE : case Item State . HIDING : case Item State . VISIBLE : case Item State . SHOW : case Item State . SHOWING : if ( visible Count < 2 ) { visible Count + + ; 
function _create Layout ( ) { this . _renderables = { views : [ ] , transferables : [ ] } ; this . _view Stack = [ ] ; this . layout = new Layout Controller ( { layout : View Stack Layout . bind ( this ) , layout Options : this . options , data Source : this . _renderables } ) ; this . add ( this . layout ) ; this . layout . on ( 'layoutend ' , _process Animations . bind ( this ) ) ; } 
function _get View Spec ( item , view , id , callback ) { if ( ! item . view ) { return ; } var spec = view . get Spec ( id ) ; if ( spec & & ! spec . true Size Requested ) { callback ( spec ) ; } else { Timer . after ( _get View Spec . bind ( this , item , view , id , callback ) , 1 ) ; } } 
function _get Transferable ( item , view , id ) { 
function _init Transferable Animations ( item , prev Item , callback ) { var callback Count = 0 ; function wait For All ( ) { callback Count - - ; if ( callback Count = = = 0 ) { callback ( ) ; } } for ( var source Id in item . options . transfer . items ) { if ( _init Transferable Animation . call ( this , item , prev Item , source Id , wait For All ) ) { callback Count + + ; } } if ( ! callback Count ) { callback ( ) ; } } 
function _end Transferable Animations ( item ) { for ( var j = 0 ; j < item . transferables . length ; j + + ) { var transferable = item . transferables [ j ] ; for ( var i = 0 ; i < this . _renderables . transferables . length ; i + + ) { if ( this . _renderables . transferables [ i ] = = = transferable . render Node ) { this . _renderables . transferables . splice ( i , 1 ) ; break ; } } transferable . source . show ( transferable . original Source ) ; transferable . target . show ( transferable . original Target ) ; } item . transferables = [ ] ; this . layout . reflow Layout ( ) ; } 
function _process Animations ( event ) { var prev Item ; for ( var i = 0 ; i < this . _view Stack . length ; i + + ) { var item = this . _view Stack [ i ] ; switch ( item . state ) { case Item State . HIDE : item . state = Item State . HIDING ; _init Hide Animation . call ( this , item , prev Item , event . size ) ; _update State . call ( this ) ; break ; case Item State . SHOW : item . state = Item State . SHOWING ; _init Show Animation . call ( this , item , prev Item , event . size ) ; _update State . call ( this ) ; break ; } prev Item = item ; } } 
function _init Show Animation ( item , prev Item , size ) { var spec = item . options . show . animation ? item . options . show . animation . call ( undefined , true , size ) : { } ; item . start Spec = spec ; item . end Spec = { opacity : 1 , transform : Transform . identity } ; item . mod . halt ( ) ; if ( spec . transform ) { item . mod . set Transform ( spec . transform ) ; } if ( spec . opacity ! = = undefined ) { item . mod . set Opacity ( spec . opacity ) ; } if ( spec . align ) { item . mod . set Align ( spec . align ) ; } if ( spec . origin ) { item . mod . set Origin ( spec . origin ) ; } var start Show Animation = _start Show Animation . bind ( this , item , spec ) ; var wait And Show = item . wait ? function ( ) { item . wait . then ( start Show Animation , start Show Animation ) ; } : start Show Animation ; if ( prev Item ) { _init Transferable Animations . call ( this , item , prev Item , wait And Show ) ; } else { wait And Show ( ) ; } } 
function _start Show Animation ( item , spec ) { if ( ! item . halted ) { var callback = item . show Callback ; if ( spec . transform ) { item . mod . set Transform ( Transform . identity , item . options . show . transition , callback ) ; callback = undefined ; } if ( spec . opacity ! = = undefined ) { item . mod . set Opacity ( 1 , item . options . show . transition , callback ) ; callback = undefined ; } _start Transferable Animations . call ( this , item , callback ) ; } } 
function _halt Item At Frame ( item , perc ) { item . mod . halt ( ) ; item . halted = true ; if ( item . start Spec & & ( perc ! = = undefined ) ) { if ( ( item . start Spec . opacity ! = = undefined ) & & ( item . end Spec . opacity ! = = undefined ) ) { item . mod . set Opacity ( _interpolate ( item . start Spec . opacity , item . end Spec . opacity , perc ) ) ; } if ( item . start Spec . transform & & item . end Spec . transform ) { var transform = [ ] ; for ( var i = 0 ; i < item . start Spec . transform . length ; i + + ) { transform . push ( _interpolate ( item . start Spec . transform [ i ] , item . end Spec . transform [ i ] , perc ) ) ; } item . mod . set Transform ( transform ) ; } } } 
function _init Hide Animation ( item , prev Item , size ) { var start Hide Animation = _start Hide Animation . bind ( this , item , prev Item , size ) ; if ( item . wait ) { item . wait . then ( start Hide Animation , start Hide Animation ) ; } else { start Hide Animation ( ) ; } } 
function _start Hide Animation ( item , prev Item , size ) { var spec = item . options . hide . animation ? item . options . hide . animation . call ( undefined , false , size ) : { } ; item . end Spec = spec ; item . start Spec = { opacity : 1 , transform : Transform . identity } ; if ( ! item . halted ) { item . mod . halt ( ) ; var callback = item . hide Callback ; if ( spec . transform ) { item . mod . set Transform ( spec . transform , item . options . hide . transition , callback ) ; callback = undefined ; } if ( spec . opacity ! = = undefined ) { item . mod . set Opacity ( spec . opacity , item . options . hide . transition , callback ) ; callback = undefined ; } if ( callback ) { callback ( ) ; } } } 
function _set Item Options ( item , options , callback ) { item . options = { show : { transition : this . options . show . transition | | this . options . transition , animation : this . options . show . animation | | this . options . animation } , hide : { transition : this . options . hide . transition | | this . options . transition , animation : this . options . hide . animation | | this . options . animation } , transfer : { transition : this . options . transfer . transition | | this . options . transition , items : this . options . transfer . items | | { } , z Index : this . options . transfer . z Index , fast Resize : this . options . transfer . fast Resize } } ; if ( options ) { item . options . show . transition = ( options . show ? options . show . transition : undefined ) | | options . transition | | item . options . show . transition ; if ( options & & options . show & & ( options . show . animation ! = = undefined ) ) { item . options . show . animation = options . show . animation ; } else if ( options & & ( options . animation ! = = undefined ) ) { item . options . show . animation = options . animation ; } item . options . transfer . transition = ( options . transfer ? options . transfer . transition : undefined ) | | options . transition | | item . options . transfer . transition ; item . options . transfer . items = ( options . transfer ? options . transfer . items : undefined ) | | item . options . transfer . items ; item . options . transfer . z Index = ( options . transfer & & ( options . transfer . z Index ! = = undefined ) ) ? options . transfer . z Index : item . options . transfer . z Index ; item . options . transfer . fast Resize = ( options . transfer & & ( options . transfer . fast Resize ! = = undefined ) ) ? options . transfer . fast Resize : item . options . transfer . fast Resize ; } item . show Callback = function ( ) { item . show Callback = undefined ; item . state = Item State . VISIBLE ; _update State . call ( this ) ; _end Transferable Animations . call ( this , item ) ; item . end Spec = undefined ; item . start Spec = undefined ; if ( callback ) { callback ( ) ; } } . bind ( this ) ; } 
function _update State ( ) { var prev Item ; var invalidated = false ; var hidden View Count = 0 ; var i = 0 ; while ( i < this . _view Stack . length ) { if ( this . _view Stack [ i ] . state = = = Item State . HIDDEN ) { hidden View Count + + ; for ( var j = 0 ; j < this . _view Stack . length ; j + + ) { if ( ( this . _view Stack [ j ] . state ! = = Item State . HIDDEN ) & & ( this . _view Stack [ j ] . view = = = this . _view Stack [ i ] . view ) ) { this . _view Stack [ i ] . view = undefined ; this . _renderables . views . splice ( i , 1 ) ; this . _view Stack . splice ( i , 1 ) ; i - - ; hidden View Count - - ; break ; } } } i + + ; } while ( hidden View Count > this . options . keep Hidden Views In DOMCount ) { this . _view Stack [ 0 ] . view = undefined ; this . _renderables . views . splice ( 0 , 1 ) ; this . _view Stack . splice ( 0 , 1 ) ; hidden View Count - - ; } for ( i = hidden View Count ; i < ( Math . min ( this . _view Stack . length - hidden View Count , 2 ) + hidden View Count ) ; i + + ) { var item = this . _view Stack [ i ] ; if ( item . state = = = Item State . QUEUED ) { if ( ! prev Item | | ( prev Item . state = = = Item State . VISIBLE ) | | ( prev Item . state = = = Item State . HIDING ) ) { if ( prev Item & & ( prev Item . state = = = Item State . VISIBLE ) ) { prev Item . state = Item State . HIDE ; prev Item . wait = item . wait ; } item . state = Item State . SHOW ; invalidated = true ; } break ; } else if ( ( item . state = = = Item State . VISIBLE ) & & item . hide ) { item . state = Item State . HIDE ; } if ( ( item . state = = = Item State . SHOW ) | | ( item . state = = = Item State . HIDE ) ) { this . layout . reflow Layout ( ) ; } prev Item = item ; } if ( invalidated ) { _update State . call ( this ) ; this . layout . reflow Layout ( ) ; } } 
function Wheel Layout ( context , options ) { 
function Proportional Layout ( context , options ) { 
function Base ( options ) { this . _event Output = new Event Handler ( ) ; this . _pool = [ ] ; Event Handler . set Output Handler ( this , this . _event Output ) ; if ( options ) { for ( var key in options ) { this [ key ] = options [ key ] ; } } } 
function _create Renderable ( id , data ) { var option = this . options . create Renderables [ Array . is Array ( id ) ? id [ 0 ] : id ] ; if ( option instanceof Function ) { return option . call ( this , id , data ) ; } else if ( ! option ) { return undefined ; } if ( ( data ! = = undefined ) & & ( data instanceof Object ) ) { return data ; } var surface = new Surface ( { classes : this . classes , content : data ? ( ' <div > ' + data + ' < /div > ' ) : undefined } ) ; if ( Array . is Array ( id ) ) { for ( var i = 0 ; i < id . length ; i + + ) { surface . add Class ( id [ i ] ) ; } } else { surface . add Class ( id ) ; } return surface ; } 
function _set Date To Scroll Wheels ( date ) { for ( var i = 0 ; i < this . scroll Wheels . length ; i + + ) { var scroll Wheel = this . scroll Wheels [ i ] ; var component = scroll Wheel . component ; var item = scroll Wheel . scroll Controller . get First Visible Item ( ) ; var view Sequence = item ? item . view Sequence : scroll Wheel . view Sequence ; if ( view Sequence ) { var render Node = view Sequence . get ( ) ; var current Value = component . get Component ( render Node . date ) ; var dest Value = component . get Component ( date ) ; 
function _get Date From Scroll Wheels ( ) { var date = new Date ( this . _date ) ; for ( var i = 0 ; i < this . scroll Wheels . length ; i + + ) { var scroll Wheel = this . scroll Wheels [ i ] ; var component = scroll Wheel . component ; var item = scroll Wheel . scroll Controller . get First Visible Item ( ) ; if ( item & & item . render Node ) { component . set Component ( date , component . get Component ( item . render Node . date ) ) ; } } return date ; } 
function _create Layout ( ) { this . container = new Container Surface ( this . options . container ) ; this . container . set Classes ( this . classes ) ; this . layout = new Layout Controller ( { layout : Proportional Layout , layout Options : { ratios : [ ] } , direction : Utility . Direction . X } ) ; this . container . add ( this . layout ) ; this . add ( this . container ) ; } 
function _click Item ( scroll Wheel , event ) { if ( scroll Wheel & & event & & event . target ) { scroll Wheel . scroll Controller . go To Render Node ( event . target ) ; } } 
function _update Components ( ) { this . scroll Wheels = [ ] ; this . _scrolling Count = 0 ; var data Source = [ ] ; var size Ratios = [ ] ; for ( var i = 0 ; i < this . _components . length ; i + + ) { var component = this . _components [ i ] ; component . create Renderable = _create Renderable . bind ( this ) ; var view Sequence = new Virtual View Sequence ( { factory : component , value : component . create ( new Date ( this . _date . get Time ( ) ) ) } ) ; var options = Layout Utility . combine Options ( this . options . scroll Controller , { layout : Wheel Layout , layout Options : this . options . wheel Layout , flow : false , direction : Utility . Direction . Y , data Source : view Sequence , auto Pipe Events : true } ) ; var scroll Controller = new Scroll Controller ( options ) ; scroll Controller . on ( 'scrollstart ' , _scroll Wheel Scroll Start . bind ( this ) ) ; scroll Controller . on ( 'scrollend ' , _scroll Wheel Scroll End . bind ( this ) ) ; scroll Controller . on ( 'pagechange ' , _scroll Wheel Page Change . bind ( this ) ) ; var scroll Wheel = { component : component , scroll Controller : scroll Controller , view Sequence : view Sequence } ; this . scroll Wheels . push ( scroll Wheel ) ; component . on ( 'click ' , _click Item . bind ( this , scroll Wheel ) ) ; data Source . push ( scroll Controller ) ; size Ratios . push ( component . size Ratio ) ; } this . layout . set Data Source ( data Source ) ; this . layout . set Layout Options ( { ratios : size Ratios } ) ; } 
function Overlay Layout ( context , options ) { var height = ( context . size [ 1 ] - options . item Size ) / 2 ; context . set ( 'top ' , { size : [ context . size [ 0 ] , height ] , translate : [ 0 , 0 , 1 ] } ) ; context . set ( 'middle ' , { size : [ context . size [ 0 ] , context . size [ 1 ] - ( height * 2 ) ] , translate : [ 0 , height , 1 ] } ) ; context . set ( 'bottom ' , { size : [ context . size [ 0 ] , height ] , translate : [ 0 , context . size [ 1 ] - height , 1 ] } ) ; } 
function _create Overlay ( ) { this . overlay = new Layout Controller ( { layout : Overlay Layout , layout Options : { item Size : this . options . wheel Layout . item Size } , data Source : this . _overlay Renderables } ) ; this . add ( this . overlay ) ; } 
function Tab Bar Layout ( context , options ) { 
function _set Selected Item ( index ) { if ( index ! = = this . _selected Item Index ) { var old Index = this . _selected Item Index ; this . _selected Item Index = index ; this . layout . set Layout Options ( { selected Item Index : index } ) ; if ( ( old Index > = 0 ) & & this . _renderables . items [ old Index ] . remove Class ) { this . _renderables . items [ old Index ] . remove Class ( 'selected ' ) ; } if ( this . _renderables . items [ index ] . add Class ) { this . _renderables . items [ index ] . add Class ( 'selected ' ) ; } if ( old Index > = 0 ) { this . _event Output . emit ( 'tabchange ' , { target : this , index : index , old Index : old Index , item : this . _renderables . items [ index ] , old Item : ( ( old Index > = 0 ) & & ( old Index < this . _renderables . items . length ) ) ? this . _renderables . items [ old Index ] : undefined } ) ; } } } 
function _create Renderable ( id , data ) { var option = this . options . create Renderables [ id ] ; if ( option instanceof Function ) { return option . call ( this , id , data ) ; } else if ( ! option ) { return undefined ; } if ( ( data ! = = undefined ) & & ( data instanceof Object ) ) { return data ; } var surface = new Surface ( { classes : this . classes , content : data ? ( ' <div > ' + data + ' < /div > ' ) : undefined } ) ; surface . add Class ( id ) ; if ( id = = = 'item ' ) { if ( this . options . tab Bar Layout & & this . options . tab Bar Layout . item Size & & ( this . options . tab Bar Layout . item Size = = = true ) ) { surface . set Size ( this . layout . get Direction ( ) ? [ undefined , true ] : [ true , undefined ] ) ; } } return surface ; } 
function _create Renderables ( ) { this . tab Bar = new Tab Bar ( this . options . tab Bar ) ; this . animation Controller = new Animation Controller ( this . options . animation Controller ) ; this . _renderables = { tab Bar : this . tab Bar , content : this . animation Controller } ; } 
function _create Layout ( ) { this . layout = new Layout Controller ( this . options . layout Controller ) ; this . layout . set Layout ( Tab Bar Controller . DEFAULT _LAYOUT . bind ( this ) ) ; this . layout . set Data Source ( this . _renderables ) ; this . add ( this . layout ) ; } 
function _set Listeners ( ) { this . tab Bar . on ( 'tabchange ' , function ( event ) { _update View . call ( this , event ) ; this . _event Output . emit ( 'tabchange ' , { target : this , index : event . index , old Index : event . old Index , item : this . _items [ event . index ] , old Item : ( ( event . old Index > = 0 ) & & ( event . old Index < this . _items . length ) ) ? this . _items [ event . old Index ] : undefined } ) ; } . bind ( this ) ) ; } 
function _update View ( event ) { var index = this . tab Bar . get Selected Item Index ( ) ; this . animation Controller . halt ( ) ; if ( index > = 0 ) { this . animation Controller . show ( this . _items [ index ] . view ) ; } else { this . animation Controller . hide ( ) ; } } 
function _layout Line ( next , end Reached ) { if ( ! line Nodes . length ) { return 0 ; } 
function _resolve Node Size ( node ) { var local Item Size = item Size ; if ( get Item Size ) { local Item Size = get Item Size ( node . render Node , size ) ; } if ( ( local Item Size [ 0 ] = = = true ) | | ( local Item Size [ 1 ] = = = true ) ) { var result = context . resolve Size ( node , size ) ; if ( local Item Size [ 0 ] ! = = true ) { result [ 0 ] = item Size [ 0 ] ; } if ( local Item Size [ 1 ] ! = = true ) { result [ 1 ] = item Size [ 1 ] ; } return result ; } else { return local Item Size ; } } 
function Collection Layout ( context _ , options ) { 
function Cover Layout ( context , options ) { 
function Font Layout ( context , options ) { 
async function move ( src , dest ) { const files = await fs . readdir ( src ) ; for ( const file of files ) { await fs . move ( path . join ( src , file ) , path . join ( dest , file ) , { overwrite : true } ) ; } await fs . rmdir ( src ) ; } 
function Dynamo DBFormatter ( ) { var datatypes = typeof ( window ) = = = "undefined " ? require ( " . /datatypes " ) . Dynamo DBDatatype : window . Dynamo DBDatatype ; var t = new datatypes ( ) ; var Empty Condition Array = "Need to pass in an array with 1 or more Condition Objects . " ; var Bad Element In Condition Array = "Only Condition objects are allowed as members of the array . " ; var Invalid Condition = "Need to pass in a valid Condition Object . " ; this . set Custom Agent = function ( request ) { var is Browser = typeof ( window ) = = = "undefined " ; var prefix = is Browser ? " " : "X -Amz - " ; var sdk = is Browser ? "nodejs " : "js " ; var current Header = request . http Request . headers [ prefix + 'User -Agent ' ] ; request . http Request . headers [ prefix + 'User -Agent ' ] = current Header + " /document -sdk - " + sdk ; } function format Attr Val Input ( attr Value Map ) { var attribute Value Map = { } ; for ( var attr in attr Value Map ) { var value = attr Value Map [ attr ] ; attribute Value Map [ attr ] = t . format Data Type ( value ) ; } return attribute Value Map ; } function format Conditions ( conditions ) { if ( conditions . prototype & & conditions . prototype . instance Of = = = "Dynamo DBCondition Object " ) { conditions = [ conditions ] ; } else { if ( Array . is Array ( conditions ) ) { if ( conditions . length = = = 0 ) { throw new Error ( Empty Condition Array ) ; } for ( var index = 0 ; index < conditions . length ; index + + ) { var condition = conditions [ index ] ; if ( ! ( condition . prototype ) | | ! ( condition . prototype . instance Of = = = "Dynamo DBCondition Object " ) ) { throw new Error ( Bad Element In Condition Array ) ; } } } else { throw new Error ( Invalid Condition ) ; } } var expected = { } ; for ( var index = 0 ; index < conditions . length ; index + + ) { var condition = conditions [ index ] ; expected [ condition . key ] = condition . format ( ) ; } return expected ; } function format Updates ( updates ) { var attr Updates = { } ; for ( var attr in updates ) { if ( updates . has Own Property ( attr ) ) { var action Value = { } ; var value = updates [ attr ] . Value ; var action = updates [ attr ] . Action ; action Value . Action = action ; if ( value ! = = undefined ) { action Value . Value = t . format Data Type ( value ) ; } attr Updates [ attr ] = action Value ; } } return attr Updates ; } function handle Write Request ( request ) { var request Copy = { } ; if ( request . Delete Request ) { var key = request . Delete Request . Key ; request Copy . Delete Request = { } ; request Copy . Delete Request . Key = format Attr Val Input ( key ) ; } else { var item = request . Put Request . Item ; request Copy . Put Request = { } ; request Copy . Put Request . Item = format Attr Val Input ( item ) ; } return request Copy ; } function format Request Items ( requests ) { var request Items = { } ; for ( var table in requests ) { if ( requests . has Own Property ( table ) ) { request Items [ table ] = { } ; var request = requests [ table ] ; if ( Array . is Array ( request ) ) { var write Requests = [ ] ; for ( var w Index in request ) { write Requests . push ( handle Write Request ( request [ w Index ] ) ) ; } request Items [ table ] = write Requests ; } else { if ( request . Attributes To Get ) { request Items [ table ] . Attributes To Get = request . Attributes To Get ; } if ( request . Consistent Read ) { request Items [ table ] . Consistent Read = request . Consistent Read ; } if ( request . Projection Expression ) { request Items [ table ] . Projection Expression = request . Projection Expression ; } if ( request . Expression Attribute Names ) { request Items [ table ] . Expression Attribute Names = request . Expression Attribute Names ; } if ( request . Keys ) { var keys = [ ] ; for ( var g Index in request . Keys ) { var key = request . Keys [ g Index ] ; keys . push ( format Attr Val Input ( key ) ) ; } request Items [ table ] . Keys = keys ; } } } } return request Items ; } var input Map = { "Attribute Updates " : format Updates , "Exclusive Start Key " : format Attr Val Input , "Expected " : format Conditions , "Expression Attribute Values " : format Attr Val Input , "Item " : format Attr Val Input , "Key " : format Attr Val Input , "Key Conditions " : format Conditions , "Request Items " : format Request Items , "Scan Filter " : format Conditions , "Query Filter " : format Conditions } ; function format Attr Val Output ( item ) { var attr List = { } ; for ( var attribute in item ) { var keys = Object . keys ( item [ attribute ] ) ; var key = keys [ 0 ] ; var value = item [ attribute ] [ key ] ; value = t . format Wire Type ( key , value ) ; attr List [ attribute ] = value ; } return attr List ; } function format Items ( items ) { for ( var index in items ) { items [ index ] = format Attr Val Output ( items [ index ] ) ; } return items ; } function handle Collection Key ( metrics ) { var collection Key = metrics . Item Collection Key ; metrics . Item Collection Key = format Attr Val Output ( collection Key ) ; return metrics ; } function handle Batch Metrics ( metrics ) { for ( var table in metrics ) { if ( metrics . has Own Property ( table ) ) { var list Of Keys = metrics [ table ] ; for ( var index in list Of Keys ) { list Of Keys [ index ] = handle Collection Key ( list Of Keys [ index ] ) ; } } } return metrics ; } function format Metrics ( metrics ) { var collection Key = metrics . Item Collection Key ; if ( collection Key ) { metrics = handle Collection Key ( metrics ) ; } else { metrics = handle Batch Metrics ( metrics ) ; } return metrics ; } function format Responses ( responses ) { for ( var table in responses ) { if ( responses . has Own Property ( table ) ) { var list Of Items = responses [ table ] ; for ( var index in list Of Items ) { list Of Items [ index ] = format Attr Val Output ( list Of Items [ index ] ) ; } } } return responses ; } function format Unprocessed Items ( unprocessed Items ) { for ( var table in unprocessed Items ) { if ( unprocessed Items . has Own Property ( table ) ) { var table Info = unprocessed Items [ table ] ; for ( var index in table Info ) { var request = table Info [ index ] ; if ( request . Delete Request ) { table Info [ index ] . Delete Request . Key = format Attr Val Output ( request . Delete Request . Key ) ; } else { table Info [ index ] . Put Request . Item = format Attr Val Output ( request . Put Request . Item ) ; } } } } return unprocessed Items ; } function format Unprocessed Keys ( unprocessed Keys ) { for ( var table in unprocessed Keys ) { if ( unprocessed Keys . has Own Property ( table ) ) { var table Info = unprocessed Keys [ table ] ; var list Of Keys = table Info . Keys ; for ( var index in list Of Keys ) { table Info . Keys [ index ] = format Attr Val Output ( list Of Keys [ index ] ) ; } } } return unprocessed Keys ; } this . format Output = function ( response ) { var output Map = { "Attributes " : format Attr Val Output , "Item " : format Attr Val Output , "Items " : format Items , "Item Collection Metrics " : format Metrics , "Last Evaluated Key " : format Attr Val Output , "Responses " : format Responses , "Unprocessed Keys " : format Unprocessed Keys , "Unprocessed Items " : format Unprocessed Items } ; var data = response . data ; if ( data ) { for ( var key in data ) { if ( data . has Own Property ( key ) ) { var format Func = output Map [ key ] ; if ( format Func ) { response . data [ key ] = format Func ( data [ key ] ) ; } } } } } ; this . format Input = function ( request ) { var params Copy = { } ; var params = request . params ; for ( var key in params ) { if ( params . has Own Property ( key ) ) { var param = params [ key ] ; var format Func = input Map [ key ] ; if ( format Func ) { param = format Func ( param ) ; } params Copy [ key ] = param ; } } request . params = params Copy ; } ; } 
function parse Command Options ( command , not Managed ) { let possible Command Options = [ ] ; let possible Command Options Short = [ ] ; const parsed Options = { managed : { } , unmanaged : { } , } ; const get Name = ( name , option ) = > { if ( name ) { return name . length = = = 1 ? ' - ' + name : ' - - ' + name ; } const short Option = option . alias ? ' / ' + bold ( ' - ' + option . alias ) : ' ' ; return ' - - ' + option . name + short Option ; } ; if ( command & & command . options ) { const options = object To Array ( command . options ) ; possible Command Options = options . map ( ( option ) = > option . name ) ; possible Command Options Short = options . reduce ( ( previous , option ) = > { if ( option . alias ) { return previous . concat ( option . alias ) ; } return previous ; } , [ ] ) ; options . for Each ( ( option ) = > { let value ; let name ; 
function convert ( value , mapping ) { const val = mapping . converter ( value ) ; const validation Result = is Valid ( val , mapping . validator ) ; if ( validation Result = = = true ) { return val ; } 
function update Dependencies ( dependencies , name , path ) { const local = { . . . dependencies } ; Object . keys ( local ) . for Each ( ( dependency ) = > { if ( is String ( local [ dependency ] ) ) { local [ dependency ] = { version : local [ dependency ] , } ; } local [ dependency ] = { . . . local [ dependency ] , context : path , extension : name , } ; } ) ; return local ; } 
function remove From Exports ( exports , dependencies = { } ) { const local Exports = { . . . exports } ; Object . keys ( local Exports ) . for Each ( ( exported ) = > { if ( dependencies [ exported ] ) { delete local Exports [ exported ] ; } } ) ; return local Exports ; } 
function get Keys ( obj = { } , flag = false , old Path = ' ' , all Keys = [ ] , all Groups = [ ] ) { let is Value = true ; Object . keys ( obj ) . for Each ( ( key ) = > { const value = obj [ key ] ; const new Path = old Path + key ; if ( is Plain Object ( value ) & & key ! = = RAW & & key ! = = ' _ _meta ' ) { is Value = true ; if ( new Path ! = = 'settings ' ) { all Groups . push ( true ) ; all Keys . push ( new Path ) ; } const keys = get Keys ( value , flag , ` $ { new Path } ` , all Keys , all Groups ) ; 
async function show List Of Templates ( ) { const spinner = ora ( 'Fetching list of official templates ' ) . start ( ) ; const templates = await get Official Templates ( ) ; spinner . stop ( ) ; const choices = templates . map ( ( template ) = > ( { name : ` $ { template . name } $ { template . description & & ' - ' + template . description } ` , short : template . name , value : template . full _name , } ) ) ; const { option } = await inquirer . prompt ( [ { type : 'rawlist ' , name : 'option ' , message : 'Select a template ' , choices , } ] ) ; return option ; } 
function sha 2 5 6x 2 ( buffer ) { var tmp = create Hash ( 'sha 2 5 6 ' ) . update ( buffer ) . digest ( ) return create Hash ( 'sha 2 5 6 ' ) . update ( tmp ) . digest ( ) } 
function encode ( payload ) { var checksum = checksum Fn ( payload ) return base 5 8 . encode ( Buffer . concat ( [ payload , checksum ] , payload . length + 4 ) ) } 
function main ( ) { return new Promise ( ( resolve ) = > { fsx . read File ( path . resolve ( _ _dirname , ' . . /package .json ' ) , 'utf 8 ' , ( err , data ) = > { if ( err ) { throw err ; } resolve ( data ) ; } ) ; } ) . then ( ( data ) = > JSON . parse ( data ) ) . then ( ( package Data ) = > { const { author , version , description , keywords , repository , license , bugs , homepage , peer Dependencies , dependencies , } = package Data ; const minimal Package = { name : ' @boundlessgeo /sdk ' , author , version , description , keywords , repository , license , bugs , homepage , peer Dependencies , dependencies , } ; return new Promise ( ( resolve ) = > { const build Path = path . resolve ( _ _dirname , ' . . /dist /package .json ' ) ; const data = JSON . stringify ( minimal Package , null , 2 ) ; fsx . write File ( build Path , data , ( err ) = > { if ( err ) { throw ( err ) ; } process . stdout . write ( ` $ { build Path } \n ` ) ; resolve ( ) ; } ) ; } ) ; } ) ; } 
function get Version ( obj , key ) { if ( obj . metadata = = = undefined ) { return undefined ; } return obj . metadata [ key ] ; } 
function auth Tile Loader ( fetch Options ) { return function ( tile , src ) { fetch ( src , fetch Options ) . then ( r = > r . blob ( ) ) . then ( ( img Data ) = > { tile . get Image ( ) . src = URL . create Object URL ( img Data ) ; } ) . catch ( ( ) = > { console . error ( 'Error fetchimg image at : ' , src ) ; } ) ; } ; } 
function auth Vector Tile Loader ( fetch Options ) { return function ( tile , url ) { const loader = ( ) = > { fetch ( url , fetch Options ) . then ( r = > r . array Buffer ( ) ) . then ( ( source ) = > { const format = tile . get Format ( ) ; tile . set Projection ( format . read Projection ( source ) ) ; tile . set Features ( format . read Features ( source ) ) ; tile . set Extent ( format . get Last Extent ( ) ) ; } ) . catch ( ( err ) = > { tile . on Error ( ) ; } ) ; } ; tile . set Loader ( loader ) ; } ; } 
function configure Tile Source ( gl Source , map Projection , time , fetch Options ) { const tile _url = gl Source . tiles [ 0 ] ; const common Props = { attributions : gl Source . attribution , min Zoom : gl Source . minzoom , max Zoom : 'maxzoom ' in gl Source ? gl Source . maxzoom : 2 2 , tile Size : gl Source . tile Size | | 5 1 2 , cross Origin : 'cross Origin ' in gl Source ? gl Source . cross Origin : 'anonymous ' , projection : map Projection , } ; 
function configure Image Source ( gl Source ) { const coords = gl Source . coordinates ; return new Image Static Source ( { url : gl Source . url , image Extent : [ coords [ 0 ] [ 0 ] , coords [ 3 ] [ 1 ] , coords [ 1 ] [ 0 ] , coords [ 0 ] [ 1 ] ] , projection : 'EPSG : 4 3 2 6 ' , } ) ; } 
function configure Mvt Source ( gl Source , access Token , fetch Options ) { if ( gl Source . tiles ) { return new Promise ( ( resolve , reject ) = > { 
function configure Geojson Source ( gl Source , map View , base Url , wrap X , fetch Options ) { const use _bbox = ( typeof gl Source . data = = = 'string ' & & gl Source . data . index Of ( BBOX _STRING ) > = 0 ) ; const vector _src = new Vector Source ( { strategy : use _bbox ? bbox Strategy : all Strategy , loader : get Loader Function ( gl Source , map View . get Projection ( ) , base Url , fetch Options ) , use Spatial Index : true , wrap X : wrap X , } ) ; 
function configure Source ( gl Source , map View , access Token , base Url , time , wrap X , fetch Options ) { let src ; 
function get Layer Group Name ( layer _group ) { const all _names = [ ] ; for ( let i = 0 , ii = layer _group . length ; i < ii ; i + + ) { all _names . push ( layer _group [ i ] . id ) ; } return ` $ { layer _group [ 0 ] . source } $ { all _names . join ( ' , ' ) } ` ; } 
function hydrate Layer Group ( layers Def , layer Group ) { const hydrated _group = [ ] ; for ( let i = 0 , ii = layer Group . length ; i < ii ; i + + ) { 
function increment Version ( metadata , version ) { const new _metadata = Object . assign ( { } , metadata ) ; new _metadata [ version ] = get Version ( metadata , version ) + 1 ; return { metadata : new _metadata , } ; } 
function place Layer ( state , layer , target Id ) { const new _layers = state . layers . slice ( ) ; const idx 1 = get Layer Index By Id ( new _layers , layer . id ) ; const idx 2 = get Layer Index By Id ( new _layers , target Id ) ; if ( idx 1 ! = = - 1 ) { new _layers . splice ( idx 1 , 1 ) ; } const new Index = ( target Id & & idx 2 ! = = - 1 ) ? idx 2 : new _layers . length ; new _layers . splice ( new Index , 0 , layer ) ; return Object . assign ( { } , state , { layers : new _layers , } , increment Version ( state . metadata , LAYER _VERSION _KEY ) ) ; } 
function change Target ( state , action ) { const layer Idx = get Layer Index By Id ( state . layers , action . layer Id ) ; const layer = state . layers [ layer Idx ] ; const layer Group = get Group ( layer ) ; const target Idx = get Layer Index By Id ( state . layers , action . target Id ) ; if ( layer Group ) { return false ; } let i , ii ; if ( layer Idx < target Idx ) { 
function order Layer ( state , action ) { let layer = null , target = null ; for ( let i = 0 , ii = state . layers . length ; i < ii ; i + + ) { if ( state . layers [ i ] . id = = = action . layer Id ) { layer = state . layers [ i ] ; } if ( state . layers [ i ] . id = = = action . target Id ) { target = state . layers [ i ] ; } } if ( layer ! = = null ) { let target Id = action . target Id ; let target Group = get Group ( target ) ; let layer Group = get Group ( layer ) ; if ( layer Group ! = = target Group ) { target Id = change Target ( state , action ) ; } if ( target Id ! = = false ) { return place Layer ( state , layer , target Id ) ; } } return state ; } 
function move Group ( state , action ) { const place _at = get Layer Index By Id ( state . layers , action . place At ) ; const n _layers = state . layers . length ; 
function add Layer ( state , action ) { 
function remove Layer ( state , action ) { const new _layers = [ ] ; for ( let i = 0 , ii = state . layers . length ; i < ii ; i + + ) { if ( state . layers [ i ] . id ! = = action . layer Id ) { new _layers . push ( state . layers [ i ] ) ; } } return Object . assign ( { } , state , { layers : new _layers , } , increment Version ( state . metadata , LAYER _VERSION _KEY ) ) ; } 
function clear Layer Filter ( state , action ) { const new _layers = [ ] ; for ( let i = 0 , ii = state . layers . length ; i < ii ; i + + ) { if ( state . layers [ i ] . id = = = action . layer Id ) { const new Props = Object . assign ( { } , state . layers [ i ] ) ; delete new Props . filter ; new _layers . push ( new Props ) ; } else { new _layers . push ( state . layers [ i ] ) ; } } return Object . assign ( { } , state , { layers : new _layers , } , increment Version ( state . metadata , LAYER _VERSION _KEY ) ) ; } 
function update Layer ( state , action ) { 
function add Source ( state , action ) { const new _source = { } ; new _source [ action . source Name ] = Object . assign ( { } , action . source Def ) ; if ( action . source Def . type = = = 'geojson ' ) { if ( action . source Def . data = = = undefined | | action . source Def . data = = = null ) { new _source [ action . source Name ] . data = { } ; } else if ( typeof action . source Def . data = = = 'object ' ) { new _source [ action . source Name ] . data = Object . assign ( { } , action . source Def . data ) ; } else { new _source [ action . source Name ] . data = action . source Def . data ; } } const new _metadata = { } ; new _metadata [ data Version Key ( action . source Name ) ] = 0 ; const new _sources = Object . assign ( { } , state . sources , new _source ) ; return Object . assign ( { } , state , { metadata : Object . assign ( { } , state . metadata , new _metadata ) , sources : new _sources , } , increment Version ( state . metadata , SOURCE _VERSION _KEY ) ) ; } 
function remove Source ( state , action ) { const new _sources = Object . assign ( { } , state . sources ) ; delete new _sources [ action . source Name ] ; return Object . assign ( { } , state , { sources : new _sources , } , increment Version ( state . metadata , SOURCE _VERSION _KEY ) ) ; } 
function change Data ( state , source Name , data ) { const source = state . sources [ source Name ] ; if ( ! source ) { return state ; } const src _mixin = { } ; 
function add Features ( state , action ) { const source = state . sources [ action . source Name ] ; if ( ! source ) { return state ; } const data = source . data ; 
function cluster Points ( state , action ) { const source = state . sources [ action . source Name ] ; if ( ! source ) { return state ; } const src _mixin = [ ] ; const cluster _settings = { } ; if ( typeof action . cluster ! = = 'undefined ' ) { cluster _settings . cluster = action . cluster ; 
function remove Features ( state , action ) { 
function set Layer In Group Visible ( state , action ) { const updated _layers = [ ] ; for ( let i = 0 , ii = state . layers . length ; i < ii ; i + + ) { const layer = state . layers [ i ] ; if ( layer . metadata & & layer . metadata [ GROUP _KEY ] = = = action . group Id ) { updated _layers . push ( { . . . layer , layout : { . . . layer . layout , visibility : layer . id = = = action . layer Id ? 'visible ' : 'none ' , } , } ) ; } else { updated _layers . push ( layer ) ; } } return Object . assign ( { } , state , { layers : updated _layers , } , increment Version ( state . metadata , LAYER _VERSION _KEY ) ) ; } 
function set Visibility ( state , action ) { let updated = false ; const updated _layers = [ ] ; for ( let i = 0 , ii = state . layers . length ; i < ii ; i + + ) { const layer = state . layers [ i ] ; if ( layer . id = = = action . layer Id ) { updated _layers . push ( { . . . layer , layout : { . . . layer . layout , visibility : action . visibility , } , } ) ; updated = true ; } else { updated _layers . push ( layer ) ; } } if ( updated ) { return Object . assign ( { } , state , { layers : updated _layers , } , increment Version ( state . metadata , LAYER _VERSION _KEY ) ) ; } 
function set Context ( state , action ) { let metadata = increment Version ( state . metadata , SOURCE _VERSION _KEY ) ; metadata = increment Version ( metadata . metadata , LAYER _VERSION _KEY ) ; return Object . assign ( { } , action . context , { metadata : Object . assign ( { } , metadata . metadata , action . context . metadata ) } ) ; } 
function update Metadata ( state , action ) { return Object . assign ( { } , state , { metadata : Object . assign ( { } , state . metadata , action . metadata ) , } ) ; } 
function add Group ( state , action ) { const groups = state . metadata ? Object . assign ( { } , state . metadata [ GROUPS _KEY ] ) : { } ; groups [ action . id ] = action . config ; const metadata = { } ; metadata [ GROUPS _KEY ] = groups ; return Object . assign ( { } , state , { metadata : Object . assign ( { } , state . metadata , metadata ) , } ) ; } 
function remove Group ( state , action ) { const groups = state . metadata ? Object . assign ( { } , state . metadata [ GROUPS _KEY ] ) : { } ; delete groups [ action . id ] ; const metadata = { } ; metadata [ GROUPS _KEY ] = groups ; return Object . assign ( { } , state , { metadata : Object . assign ( { } , state . metadata , metadata ) , } ) ; } 
function update Source ( state , action ) { const old _source = state . sources [ action . source Name ] ; const new _source = { } ; new _source [ action . source Name ] = Object . assign ( { } , old _source , action . source Def ) ; const new _sources = Object . assign ( { } , state . sources , new _source ) ; let metadata ; if ( new _source [ action . source Name ] . type = = = 'geojson ' ) { metadata = increment Version ( state . metadata , data Version Key ( action . source Name ) ) ; } else { metadata = increment Version ( state . metadata , SOURCE _VERSION _KEY ) ; } return Object . assign ( { } , state , { sources : Object . assign ( { } , state . sources , new _sources ) , } , metadata ) ; } 
function set Zoom ( state , action ) { let zoom = Math . min ( DEFAULT _ZOOM . MAX , action . zoom ) ; zoom = Math . max ( DEFAULT _ZOOM . MIN , zoom ) ; return Object . assign ( { } , state , { zoom } ) ; } 
function fit Extent ( state , action ) { const extent = action . extent ; const resolution = get Resolution For Extent ( extent , action . size , action . projection ) ; const zoom = get Zoom For Resolution ( resolution , action . projection ) ; const center = [ ( extent [ 0 ] + extent [ 2 ] ) / 2 , ( extent [ 1 ] + extent [ 3 ] ) / 2 ] ; return Object . assign ( { } , state , { center , zoom } ) ; } 
function get Remote Legend ( href ) { let ref = null ; const div = ( < div ref = { ( me ) = > { ref = me ; } } / > ) ; 
function propose Float ( value , default Value ) { const proposed = parse Float ( value ) ; if ( typeof proposed = = = 'number ' & & is Finite ( proposed ) ) { return proposed ; } return default Value ; } 
function map Dispatch To Props ( dispatch ) { return { move Slide : ( count ) = > { dispatch ( bookmark Action . move Slide ( count ) ) ; } , zoom To : ( coords , zoom Level ) = > { dispatch ( map Actions . set View ( coords , zoom Level ) ) ; } } ; } 
function add Action ( state , action ) { const action _id = uuid . v 4 ( ) ; const new _action = { } ; new _action [ action _id ] = action ; const new _actions = Object . assign ( { } , state . actions , new _action ) ; return Object . assign ( { } , state , { actions : new _actions } ) ; } 
function finished Action ( state , action ) { const new _actions = Object . assign ( { } , state . actions ) ; delete new _actions [ action . id ] ; return Object . assign ( { } , state , { actions : new _actions } ) ; } 
function add Points ( source Name , n _points = 1 0 ) { for ( let i = 0 ; i < n _points ; i + + ) { 
function to Jss Rules ( css Rules , options ) { const jss Rules = { } function strip Unit ( value ) { if ( ! options . unit | | 
function strip Zeros ( a Input ) { var a = a Input ; 
function decode Params ( names , types , data , use Numbered Params = true ) { 
function encode Signature ( method ) { const signature = ` $ { method . name } $ { utils . get Keys ( method . inputs , 'type ' ) . join ( ' , ' ) } ` ; const signature Encoded = ` $ { ( new Buffer ( utils . keccak 2 5 6 ( signature ) , 'hex ' ) ) . slice ( 0 , 4 ) . to String ( 'hex ' ) } ` ; return signature Encoded ; } 
function encode Method ( method , values ) { const params Encoded = encode Params ( utils . get Keys ( method . inputs , 'type ' ) , values ) . substring ( 2 ) ; return ` $ { encode Signature ( method ) } $ { params Encoded } ` ; } 
function decode Method ( method , data ) { const output Names = utils . get Keys ( method . outputs , 'name ' , true ) ; const output Types = utils . get Keys ( method . outputs , 'type ' ) ; return decode Params ( output Names , output Types , utils . hex Or Buffer ( data ) ) ; } 
function decode Event ( event Object , data , topics , use Numbered Params = true ) { const non Indexed = event Object . inputs . filter ( ( input ) = > ! input . indexed ) const non Indexed Names = utils . get Keys ( non Indexed , 'name ' , true ) ; const non Indexed Types = utils . get Keys ( non Indexed , 'type ' ) ; const event = decode Params ( non Indexed Names , non Indexed Types , utils . hex Or Buffer ( data ) , use Numbered Params ) ; const topic Offset = event Object . anonymous ? 0 : 1 ; event Object . inputs . filter ( ( input ) = > input . indexed ) . map ( ( input , i ) = > { const topic = new Buffer ( topics [ i + topic Offset ] . slice ( 2 ) , 'hex ' ) ; const coder = get Param Coder ( input . type ) ; event [ input . name ] = coder . decode ( topic , 0 ) . value ; } ) ; event . _event Name = event Object . name ; return event ; } 
function decode Log Item ( event Object , log , use Numbered Params = true ) { if ( event Object & & log . topics [ 0 ] = = = event Signature ( event Object ) ) { return decode Event ( event Object , log . data , log . topics , use Numbered Params ) } } 
function log Decoder ( abi , use Numbered Params = true ) { const event Map = { } abi . filter ( item = > item . type = = = 'event ' ) . map ( item = > { event Map [ event Signature ( item ) ] = item } ) return function ( log Items ) { return log Items . map ( log = > decode Log Item ( event Map [ log . topics [ 0 ] ] , log , use Numbered Params ) ) . filter ( i = > i ) } } 
function loader ( content ) { const { add Dependency , resource , resource Path } = this ; 
function ( ) { var client = redis . client ( ) ; return client . keys Async ( 'bull : * :id ' ) . then ( function ( keys ) { return _ . map ( keys , function ( key ) { return key . slice ( 5 , - 3 ) ; } ) ; } ) ; } 
function ( q Name ) { if ( ! q Name | | q Name . length = = = 0 ) { throw new Error ( 'You must specify a queue name . ' ) ; } var client = redis . client ( ) ; return client . keys Async ( 'bull : ' + q Name + ' : * ' ) . then ( function ( keys ) { if ( keys . length ) { return client . del ( keys ) ; } } ) ; } 
function ( q Name ) { if ( this . _q . name ! = = q Name ) { this . _q . name = q Name ; var queue Opts = { redis : { host : redis . redis Opts . host , port : redis . redis Opts . port , DB : redis . redis Opts . db , opts : { auth _pass : redis . redis Opts . auth _pass } } } ; this . _q . instance = new bull ( q Name , queue Opts ) ; } return this . _q . instance ; } 
function ( q Name , id ) { var q = queue . get ( q Name ) ; return q . get Job ( id ) . then ( function ( job ) { if ( ! job ) { return job ; } return job . get State ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ; } 
function ( q Name , data , opts ) { var q = queue . get ( q Name ) ; return q . add ( data , opts ) . then ( function ( job ) { if ( ! job ) { return job ; } return job . get State ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ; } 
function ( q Name , id ) { var q = queue . get ( q Name ) ; return q . get Job ( id ) . then ( function ( job ) { return job . remove ( ) ; } ) ; } 
function ( q Name , type ) { var client = redis . client ( ) ; var key = 'bull : ' + q Name + ' : ' + type ; if ( type = = = 'wait ' | | type = = = 'active ' ) { return client . llen Async ( key ) ; } else if ( type = = = 'delayed ' ) { return client . zcard Async ( key ) ; } else if ( type = = = 'completed ' | | type = = = 'failed ' ) { return client . scard Async ( key ) ; } throw new Error ( 'You must provide a valid job type . ' ) ; } 
function ( q Name , type , offset , limit ) { var q = queue . get ( q Name ) ; if ( ! ( offset > = 0 ) ) { offset = 0 ; } if ( ! ( limit > = 0 ) ) { limit = 3 0 ; } if ( type = = = 'wait ' | | type = = = 'active ' ) { return q . get Jobs ( type , 'LIST ' , offset , offset + limit - 1 ) . then ( function ( jobs ) { return Promise . all ( _ . map ( jobs , function ( job ) { if ( ! job ) { return null ; } return job . get State ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ) ; } ) ; } else if ( type = = = 'delayed ' ) { return q . get Jobs ( type , 'ZSET ' , offset , offset + limit - 1 ) . then ( function ( jobs ) { return Promise . all ( _ . map ( jobs , function ( job ) { if ( ! job ) { return null ; } return job . get State ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ) ; } ) ; } else if ( type = = = 'completed ' | | type = = = 'failed ' ) { var client = redis . client ( ) ; var key = 'bull : ' + q Name + ' : ' + type ; return client . smembers Async ( key ) . then ( function ( ids ) { var _ids = ids . slice ( offset , offset + limit ) ; return Promise . all ( _ . map ( _ids , function ( id ) { return q . get Job ( id ) . then ( function ( job ) { if ( ! job ) { return null ; } return job . get State ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ; } ) ) ; } ) ; } throw new Error ( 'You must provide a valid job type . ' ) ; } 
function ( opts ) { this . _client = Promise . promisify All ( redis . create Client ( opts ) ) ; if ( opts . db ) { this . _client . select Async ( opts . db ) ; } this . redis Opts = opts ; } 
function ( ) { var multi = this . _client . multi ( ) ; multi . exec Async = Promise . promisify ( multi . exec ) ; return multi ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; Object . define Property ( exports , " _ _es Module " , { value : true } ) ; exports . react Component = react Component ; var _react = _ _webpack _require _ _ ( 1 ) ; var _react 2 = _interop Require Default ( _react ) ; function _interop Require Default ( obj ) { return obj & & obj . _ _es Module ? obj : { default : obj } ; } function react Component ( ) { return _react 2 . default . create Element ( 'div ' , null , _react 2 . default . create Element ( 'p ' , null , 'I am the webpack application , and I \ 'm using System JS \ ' version of react . ' ) , _react 2 . default . create Element ( 'p ' , null , 'I don \ 't have to bundle react in with me , which makes my bundle a lot smaller . ' ) , _react 2 . default . create Element ( 'p ' , null , 'I exported a react component from the entry module of my webpack config , and that export made it to the System JS app that loaded me , who was able to render my react component to the DOM . ' ) ) ; } $ _ _register _ _main _ _exports ( exports ) ; } 
function ( repo , commit ) { return commit . get Tree ( ) . then ( function ( tree ) { return Git . Diff . tree To Workdir ( repo , tree ) ; } ) . then ( function ( diff ) { return diff . patches ( ) ; } ) ; } 
function get Status ( file ) { var status ; if ( file . is New ( ) ) status = 'new ' ; else if ( file . is Modified ( ) ) status = 'modified ' ; else if ( file . is Deleted ( ) ) status = 'deleted ' ; else if ( file . is Type Change ( ) ) status = 'typechange ' ; else if ( file . is Renamed ( ) ) status = 'renamed ' ; else if ( file . is Ignored ( ) ) status = 'ignored ' ; debug ( ' %s %s ' , status , file . path ( ) ) ; return { 'path ' : file . path ( ) , 'status ' : status } ; } 
function ial ( app , opts ) { Object . define Property ( app . context , 'i 1 8n ' , { get : function ( ) { if ( this . _i 1 8n ) { return this . _i 1 8n } const i 1 8n = new I 1 8n ( opts ) i 1 8n . request = this . request this . _i 1 8n = i 1 8n 
function register Methods ( helpers , i 1 8n ) { I 1 8n . res Methods . for Each ( method = > { helpers [ method ] = i 1 8n [ method ] . bind ( i 1 8n ) } ) } 
function handle Group ( self , group , width , max Columns ) { if ( group . length = = = 0 ) { return ; } var min Rows = Math . ceil ( group . length / max Columns ) ; for ( var row = 0 ; row < min Rows ; row + + ) { for ( var col = 0 ; col < max Columns ; col + + ) { var idx = row * max Columns + col ; if ( idx > = group . length ) { break ; } var item = group [ idx ] ; self . _write To Output ( item ) ; if ( col < max Columns - 1 ) { for ( var s = 0 ; s < width - item . length ; s + + ) { self . _write To Output ( ' ' ) ; } } } self . _write To Output ( ' \r \n ' ) ; } self . _write To Output ( ' \r \n ' ) ; } 
function emit Keypress Events ( stream , iface ) { if ( stream [ KEYPRESS _DECODER ] ) return ; if ( String Decoder = = = undefined ) String Decoder = require ( 'string _decoder ' ) . String Decoder ; stream [ KEYPRESS _DECODER ] = new String Decoder ( 'utf 8 ' ) ; stream [ ESCAPE _DECODER ] = emit Keys ( stream ) ; stream [ ESCAPE _DECODER ] . next ( ) ; const escape Code Timeout = ( ) = > stream [ ESCAPE _DECODER ] . next ( ' ' ) ; let timeout Id ; function on Data ( b ) { if ( stream . listener Count ( 'keypress ' ) > 0 ) { var r = stream [ KEYPRESS _DECODER ] . write ( b ) ; if ( r ) { clear Timeout ( timeout Id ) ; if ( iface ) { iface . _saw Key Press = r . length = = = 1 ; } for ( var i = 0 ; i < r . length ; i + + ) { if ( r [ i ] = = = ' \t ' & & typeof r [ i + 1 ] = = = 'string ' & & iface ) { iface . is Completion Enabled = false ; } try { stream [ ESCAPE _DECODER ] . next ( r [ i ] ) ; 
function cursor To ( stream , x , y ) { if ( stream = = = null | | stream = = = undefined ) return ; if ( typeof x ! = = 'number ' & & typeof y ! = = 'number ' ) return ; if ( typeof x ! = = 'number ' ) throw new Error ( 'ERR _INVALID _CURSOR _POS ' ) ; if ( typeof y ! = = 'number ' ) { stream . write ( CSI ` $ { x + 1 } ` ) ; } else { stream . write ( CSI ` $ { y + 1 } $ { x + 1 } ` ) ; } } 
function move Cursor ( stream , dx , dy ) { if ( stream = = = null | | stream = = = undefined ) return ; if ( dx < 0 ) { stream . write ( CSI ` $ { - dx } ` ) ; } else if ( dx > 0 ) { stream . write ( CSI ` $ { dx } ` ) ; } if ( dy < 0 ) { stream . write ( CSI ` $ { - dy } ` ) ; } else if ( dy > 0 ) { stream . write ( CSI ` $ { dy } ` ) ; } } 
function clear Line ( stream , dir ) { if ( stream = = = null | | stream = = = undefined ) return ; if ( dir < 0 ) { 
function arguments Are Shallowly Equal ( equality Check , prev , next ) { if ( prev = = = null | | next = = = null | | prev . length ! = = next . length ) { return false ; } 
function get Observable Value _from Dynamic Key _from Observable ( key , root , helper Options , read Options ) { 
function to Compute ( value ) { if ( value ) { if ( value . is Computed ) { return value ; } if ( value . compute ) { return value . compute ; } else { return make Compute Like ( value ) ; } } return value ; } 
function Helper Options ( scope , node List , expr Data , string Only ) { this . metadata = { rendered : false } ; this . string Only = string Only ; this . scope = scope ; this . node List = node List ; this . expr Data = expr Data ; } 
function value Should Be Inserted As HTML ( value ) { return value ! = = null & & typeof value = = = "object " & & ( typeof value [ to DOMSymbol ] = = = "function " | | typeof value [ view Insert Symbol ] = = = "function " | | typeof value . node Type = = = "number " ) ; } 
function ( scope , node List , mode , expr Data , truthy Renderer , falsey Renderer , string Only ) { if ( mode = = = " ^ " ) { var temp = truthy Renderer ; truthy Renderer = falsey Renderer ; falsey Renderer = temp ; } var value , helper Options = new Helper Options ( scope , node List , expr Data , string Only ) ; 
function ( expression String , state ) { expression String = expression String . trim ( ) ; var expr Data , partial Name = expression String . split ( / \s + / ) . shift ( ) ; if ( partial Name ! = = expression String ) { expr Data = core . expression . parse ( expression String ) ; } return function ( scope , parent Section Node List ) { 
function ( mode , expression String , state ) { var expr Data = core . expression . parse ( expression String ) , 
function ( mode , expression String , state ) { 
function ( template ) { 
function ( key , root , original Key ) { this . root = root ; this . key = key ; 
function debugger Helper ( left , right ) { 
function ( helper Options ) { 
function ( process ) { var sub Section = new Text Section ( ) ; this . last ( ) . add ( { process : process , truthy : sub Section } ) ; this . stack . push ( sub Section ) ; } 
function ( key , root , source Text ) { this . key = key ; this . root Expr = root ; can Reflect . set Key Value ( this , source Text Symbol , source Text ) ; } 
function normalize Value ( value ) { if ( Array . is Array ( value ) ) { return value ; } if ( is Plain Object ( value ) ) { return [ value ] ; } return [ { name : value } ] ; } 
function infer Type ( type ) { if ( ! type ) return ' ' ; function iterate Types ( sub Tree ) { return map ( normalize Value ( sub Tree ) , infer Type ) . join ( ' , ' ) ; } switch ( type . name ) { case 'array Of ' : return ` $ { iterate Types ( type . value ) } ` ; case 'custom ' : return COMMON _PROP _TYPES _TO _LINKS _MAP [ type . raw ] | | type . raw ; case 'enum ' : return ` $ { iterate Types ( type . value ) } ` ; case 'shape ' : case 'shape Of ' : 
function generate Markdown Table ( api ) { if ( is Empty ( api . props ) ) return ' ' ; return HEADER . concat ( join ( map ( api . props , ( description , prop Name ) = > join ( [ ` \ ` $ { prop Name } \ ` ` , description . required ? 'true ' : ' ' , infer Type ( description . type ) , replace Newline With Break ( get Value ( description , 'default Value .value ' , ' ' ) ) , replace Newline With Break ( description . description ) , ] , ' | ' ) ) , ' \n ' ) ) ; } 
function build Docs ( api ) { const view = build Template View ( api ) ; 
function ( section , mode , stache , line No ) { if ( mode = = = " > " ) { 
function ( ) { var last Element = state . section Element Stack [ state . section Element Stack . length - 1 ] ; return state . section Element Stack . length ? last Element . type = = = "section " | | last Element . type = = = "custom " : true ; } 
function ( overwrites ) { var cur = { tag : state . node & & state . node . tag , attr : state . attr & & state . attr . name , 
function ( node , callback ) { if ( ! node . attributes ) { node . attributes = [ ] ; } node . attributes . unshift ( callback ) ; } 
function safe Step ( callback , step Fn ) { var err ; try { step Fn ( ) ; } catch ( error ) { err = error ; } callback ( err ) ; } 
function flush ( callback ) { 
function setup ( options ) { var child Runner = Child Runner . current ( ) ; if ( child Runner ) { _deep Merge ( _config , child Runner . parent Scope . WCT . _config ) ; 
function _deep Merge ( target , source ) { Object . keys ( source ) . for Each ( function ( key ) { if ( target [ key ] ! = = null & & typeof target [ key ] = = = 'object ' & & ! Array . is Array ( target [ key ] ) ) { _deep Merge ( target [ key ] , source [ key ] ) ; } else { target [ key ] = source [ key ] ; } } ) ; } 
function parse Url ( url ) { var parts = url . match ( / ^ ( . * ? ) ( ? : \ ? ( . * ) ) ? $ / ) ; return { base : parts [ 1 ] , params : get Params ( parts [ 2 ] | | ' ' ) , } ; } 
function expand Url ( url , base ) { if ( ! base ) return url ; if ( url . match ( / ^ ( \ / |https ? : \ / \ / ) / ) ) return url ; if ( base . substr ( base . length - 1 ) ! = = ' / ' ) { base = base + ' / ' ; } return base + url ; } 
function merge Params ( target , source ) { Object . keys ( source ) . for Each ( function ( key ) { if ( ! ( key in target ) ) { target [ key ] = [ ] ; } target [ key ] = target [ key ] . concat ( source [ key ] ) ; } ) ; } 
function script Prefix ( filename ) { var scripts = document . query Selector All ( 'script [src * = " ' + filename + ' " ] ' ) ; if ( scripts . length ! = = 1 ) { return null ; } var script = scripts [ 0 ] . src ; return script . substring ( 0 , script . index Of ( filename ) ) ; } 
function get Titles ( runnable ) { var titles = [ ] ; while ( runnable & & ! runnable . root & & runnable . title ) { titles . unshift ( runnable . title ) ; runnable = runnable . parent ; } return titles ; } 
function HTML ( runner ) { var output = document . create Element ( 'div ' ) ; output . id = 'mocha ' ; document . body . append Child ( output ) ; runner . on ( 'suite ' , function ( _test ) { this . total = runner . total ; } . bind ( this ) ) ; Mocha . reporters . HTML . call ( this , runner ) ; } 
function draw Favicon Arc ( context , total , start , length , color ) { var arc Start = ARC _OFFSET + Math . PI * 2 * ( start / total ) ; var arc End = ARC _OFFSET + Math . PI * 2 * ( ( start + length ) / total ) ; context . begin Path ( ) ; context . stroke Style = color ; context . line Width = ARC _WIDTH ; context . arc ( 1 6 , 1 6 , 1 6 - ARC _WIDTH / 2 , arc Start , arc End ) ; context . stroke ( ) ; } 
function load Suites ( files ) { files . for Each ( function ( file ) { if ( / \ .js ( \ ? . * ) ? $ / . test ( file ) ) { js Suites $ 1 . push ( file ) ; } else if ( / \ .html ( \ ? . * ) ? $ / . test ( file ) ) { html Suites $ 1 . push ( file ) ; } else { throw new Error ( 'Unknown resource type : ' + file ) ; } } ) ; } 
function load Js Suites ( _reporter , done ) { debug ( 'load Js Suites ' , js Suites $ 1 ) ; var loaders = js Suites $ 1 . map ( function ( file ) { 
function _run Mocha ( reporter , done , waited ) { if ( get ( 'wait For Frameworks ' ) & & ! waited ) { var wait For = ( get ( 'wait For ' ) | | when Frameworks Ready ) . bind ( window ) ; wait For ( _run Mocha . bind ( null , reporter , done , true ) ) ; return ; } debug ( ' _run Mocha ' ) ; var mocha = window . mocha ; var Mocha = window . Mocha ; mocha . reporter ( reporter . child Reporter ( window . location ) ) ; mocha . suite . title = reporter . suite Title ( window . location ) ; mocha . grep ( GREP ) ; 
function inject Mocha ( Mocha ) { _inject Prototype ( Console , Mocha . reporters . Base . prototype ) ; _inject Prototype ( HTML , Mocha . reporters . HTML . prototype ) ; 
function load Sync ( ) { debug ( 'Loading environment scripts : ' ) ; var a 1 1y Suite Script Path = 'web -component -tester /data /a 1 1y Suite .js ' ; var scripts = get ( 'environment Scripts ' ) ; var a 1 1y Suite Will Be Loaded = window . _ _generated By Wct | | scripts . index Of ( a 1 1y Suite Script Path ) > - 1 ; 
function listen For Errors ( ) { window . add Event Listener ( 'error ' , function ( event ) { global Errors . push ( event . error ) ; } ) ; 
function extend Interfaces ( helper Name , helper Factory ) { interface Extensions . push ( function ( ) { var Mocha = window . Mocha ; 
function add Local Gulp Tasks ( subfile , submodule , tasks ) { var gulp Mod = find Module ( function ( mod ) { return ( path . basename ( path . dirname ( mod . id ) ) = = = 'gulp ' ) ; } , submodule ) ; var local Inst = gulp Mod . exports ; 
function load Files ( pattern , root Dir ) { 
function ( args , callback ) { let child = this . run Protractor ( args ) . on ( 'exit ' , function ( code ) { if ( child ) { child . kill ( ) ; } if ( callback ) { callback ( code ) ; } } ) ; } 
function ( callback , verbose , start Options ) { log ( PLUGIN _NAME + ' - Webdriver standalone server will be started ' ) ; let callback Was Called = false ; let log Output = true ; let command ; let selenium Pid = null ; function _intercept Log Data ( data ) { let data String = data . to String ( ) ; if ( log Output & & verbose ) { log ( data String ) ; } if ( data String . index Of ( WEB _DRIVER _LOG _STARTED _NEW ) > = 0 | | data String . index Of ( WEB _DRIVER _LOG _STARTED ) > = 0 ) { log ( PLUGIN _NAME + ' - Webdriver standalone server is started ' ) ; callback Was Called = true ; log Output = false ; callback ( ) ; } else if ( data String . index Of ( WEB _DRIVER _LOG _STOPPED ) > = 0 ) { log Output = true ; if ( verbose ) { log ( data String ) ; } } else if ( data String . index Of ( SELENIUM _PID ) > = 0 ) { selenium Pid = parse Int ( data String . split ( SELENIUM _PID ) [ 1 ] . substr ( 1 ) . trim ( ) , 1 0 ) ; log ( PLUGIN _NAME + ' - Webdriver standalone server PID is detected : ' + selenium Pid ) ; } } command = child Process . spawn ( COMMAND _RELATIVE _PATH + WEB _DRIVER _COMMAND , [ WEB _DRIVER _START _COMMAND ] . concat ( start Options & & start Options . args ? start Options . args : [ ] ) , { 'cwd ' : protractor Dir To Use } ) ; command . once ( 'close ' , function ( error Code ) { log ( PLUGIN _NAME + ' - Webdriver standalone server will be closed ' ) ; if ( ! callback Was Called ) { callback ( error Code ) ; } } ) ; command . stderr . on ( 'data ' , _intercept Log Data ) ; command . stdout . on ( 'data ' , _intercept Log Data ) ; return function ( ) { if ( selenium Pid ) { process . kill ( selenium Pid , 'SIGINT ' ) ; } } ; } 
function ( opts Or Callback , cb ) { let callback = cb ? cb : opts Or Callback ; let options = cb ? opts Or Callback : null ; let args = [ 'update ' , ' - -standalone ' ] ; let browsers = [ 'chrome ' ] ; if ( options ) { if ( options . browsers & & options . browsers . length > 0 ) { browsers = options . browsers ; } browsers . for Each ( function ( element ) { args . push ( ' - - ' + element ) ; } ) ; if ( options . args ) { args = args . concat ( options . args ) ; } } child Process . spawn ( COMMAND _RELATIVE _PATH + WEB _DRIVER _COMMAND , args , { 'cwd ' : protractor Dir To Use , 'stdio ' : 'inherit ' } ) . once ( 'close ' , callback ) ; } 
function ( callback , verbose , update Options , start Options ) { log ( PLUGIN _NAME + ' - Webdriver standalone will be updated ' ) ; return new Promise ( ( resolve ) = > { this . web Driver Update ( update Options , ( ) = > { log ( PLUGIN _NAME + ' - Webdriver standalone is updated ' ) ; resolve ( this . web Driver Standalone Start ( callback , verbose , start Options ) ) ; } ) ; } ) ; } 
function ( ) { ! fs . exists Sync ( _ _dirname + ' /target ' ) & & fs . mkdir Sync ( _ _dirname + ' /target ' ) ; ! fs . exists Sync ( _ _dirname + ' /target /e 2e ' ) & & fs . mkdir Sync ( _ _dirname + ' /target /e 2e ' ) ; var reporter Path = path . resolve ( path . join ( _ _dirname , ' /target /e 2e ' ) ) ; console . info ( 'The JUnit report will be generated into the following path : ' , reporter Path ) ; jasmine . get Env ( ) . add Reporter ( new reporters . JUnit Xml Reporter ( { 'save Path ' : reporter Path , 'consolidate ' : true , 'consolidate All ' : true } ) ) ; } 
function sha 2 5 6stream ( ) { var sha 2 5 6 = create Hash ( 'sha 2 5 6 ' ) ; var stream = new Transform ( ) ; stream . _transform = function ( chunk , encoding , callback ) { this . push ( chunk ) ; sha 2 5 6 . update ( chunk ) ; callback ( ) ; } ; stream . on ( 'finish ' , ( ) = > { stream . emit ( 'sha 2 5 6 ' , sha 2 5 6 . digest ( 'hex ' ) ) ; } ) ; return stream ; } 
function download ( url ) { var req = request . get ( url ) ; 
function download String ( url ) { return new Promise ( ( resolve , reject ) = > { request ( { url , 
function tmpdir ( ) { return new Promise ( ( resolve ) = > { var dir = fs Temp . template ( 't 2 -sdk - %s ' ) . mkdir Sync ( ) ; resolve ( { path : dir , cleanup : ( ) = > { try { fs . remove Sync ( dir ) ; } catch ( e ) { 
function extract ( checksum Verify , filename , sdk Stream , root , strip , name , decompress ) { return tmpdir ( ) . then ( destdir = > { 
function extract Tools ( checksum Verify , filename , sdk Stream ) { var root = path . join ( SDK _PATHS . sdk , get Platform ( ) ) ; return extract ( checksum Verify , filename , sdk Stream , root , 2 , 'Tessel build tools ' , bz 2 ( ) ) ; } 
function extract Rustlib ( checksum Verify , filename , sdk Stream , rust Version ) { var root = path . join ( SDK _PATHS . rustlib , rust Version ) ; return extract ( checksum Verify , filename , sdk Stream , root , 0 , 'MIPS libstd ' , zlib . create Gunzip ( ) ) ; } 
function transform Key ( value ) { return Object . keys ( replacements ) . reduce ( ( value , key ) = > value . replace ( key , replacements [ key ] ) , value ) ; } 
function close Command ( error ) { 
function USBProcess ( id , daemon ) { active & & !closed = Process is running as usual !active & & !closed = Process has been sent a signal but not completely closed (resources freed ) !active & & closed = Process has stopped running and has already been destroyed * / 
function Remote Writable Stream ( process , daemon , write Header Func , close Header Func ) { 
function Remote Readable Stream ( process , daemon , ack Header Func ) { 
function log And Finish ( tessel ) { 
function Tessel ( connection ) { if ( connection = = = undefined ) { throw new Error ( 'Cannot create a Tessel with an undefined connection type ' ) ; } this . usb Connection = undefined ; this . lan Connection = undefined ; this . lan Prefer = false ; this . close = ( ) = > { 
function ( module Path ) { var asset Root = path . resolve ( _ _dirname , ' . . / . . / . . / . . ' ) ; return module Path . starts With ( asset Root ) & & ! module Path . starts With ( asset Root + path . sep + 'node ' + path . sep + 'node _modules ' ) ; } 
function ( path ) { var p = path ; const ar = p . index Of ( ' - > ' ) ; if ( ar > = 0 ) { p = p . substring ( ar + 2 ) ; } const cu = p . index Of ( ' / { ' ) ; if ( cu > 0 ) { p = p . substring ( 0 , cu ) ; } return p ; } 
function Chart Js Provider ( ) { var options = { } ; var Chart Js = { Chart : Chart , get Options : function ( type ) { var type Options = type & & options [ type ] | | { } ; return angular . extend ( { } , options , type Options ) ; } } ; this . set Options = function ( type , custom Options ) { 
function hex To Rgb ( hex ) { var bigint = parse Int ( hex , 1 6 ) , r = ( bigint > > 1 6 ) & 2 5 5 , g = ( bigint > > 8 ) & 2 5 5 , b = bigint & 2 5 5 ; return [ r , g , b ] ; } 
function ( str , delim ) { var res = [ ] ; var segs = str . split ( delim ) ; var accum = ' ' ; for ( let i = 0 ; i < segs . length ; i + + ) { var seg = segs [ i ] ; if ( seg . ends With ( ' \ \ ' ) ) { accum + = seg . substring ( 0 , seg . length - 1 ) + delim ; } else { accum + = seg ; res . push ( accum ) ; accum = ' ' ; } } return res ; } 
function ( input ) { var dollar Curly = input . index Of ( ' $ { ' ) ; if ( dollar Curly > = 0 ) { var end Curly = input . index Of ( ' } ' , dollar Curly ) ; if ( end Curly > = 0 ) { return { start : dollar Curly , stop : end Curly , expr : input . substring ( dollar Curly + 2 , end Curly ) } ; } } return null ; } 
function ( input , it ) { var output = input ; var expr ; while ( ( expr = this . get Expr ( output ) ) ! = = null ) { var evals To = $parse ( expr . expr ) ( { it : it } ) ; output = output . substring ( 0 , expr . start ) + evals To + output . substring ( expr . stop + 1 ) ; } return output ; } 
function find Median Range ( values ) { var result = [ null , null ] ; if ( values . length > 0 ) { var n = values . length ; 
function update Selected Item ( datum ) { d 3 . event . stop Propagation ( ) ; selection = utils . set Selection ( datum = = selection . current ( ) ? null : datum , options ) ; var item = selection . current ( ) | | geo Object ; options . update Info Card ( selection . info ( ) ) ; var projection = path . projection ( ) ; projection . center ( item . center ) . scale ( item . scale ) ; map Layer . select All ( 'path ' ) . attr ( 'stroke ' , selection . stroke Color ) . attr ( 'fill ' , selection . fill Color ) . attr ( 'class ' , selection . class Name ) . transition ( ) . duration ( 6 0 0 ) . ease ( 'cubic -in -out ' ) . attr ( 'd ' , path ) ; text Layer . attr ( 'hidden ' , selection . hide Labels ) ; text Layer . select All ( 'text ' ) . attr ( 'fill ' , selection . text Fill ) . transition ( ) . duration ( 4 0 0 ) . ease ( 'cubic -in -out ' ) . attr ( 'font -size ' , selection . text Size ) . attr ( 'transform ' , selection . text Position ) ; } 
function ( selector , context , skip Filtering ) { 
function uki ( val , context ) { if ( typeof val = = = "string " ) { return selector . find ( val , context ) ; } if ( val . length = = = undefined ) { val = [ val ] ; } if ( val . length > 0 & & utils . is Function ( val [ 0 ] . type Name ) ) { return new collection . Collection ( val ) ; } return builder . build ( val ) ; } 
function ( ) { var e = this . base Event ; if ( e . prevent Default ) { e . prevent Default ( ) ; } else { e . return Value = false ; } this . is Default Prevented = fun . FT ; } 
function dom Handler ( e ) { e = e | | env . root . event ; var wrapped = wrap Dom Event ( e ) ; evt . trigger ( this , normalize ( wrapped ) ) ; } 
function ( name , value ) { if ( arguments . length > 1 ) { for ( var i = this . length - 1 ; i > = 0 ; i - - ) { utils . prop ( this [ i ] , name , value ) ; } return this ; } else { return this [ 0 ] ? utils . prop ( this [ 0 ] , name ) : " " ; } } 
function ( index ) { var range = this . _visible Range ( ) , dm = this . metrics ( ) . row Dimensions ( index ) , max Y = dm . top + dm . height , min Y = dm . top ; if ( max Y > = range . to ) { this . scrollable Parent ( ) . scroll ( 0 , max Y - range . to + 
function ( ) { var range = this . _rendering Range ( ) ; if ( ! range ) { return ; } var packs = this . child Views ( ) , from PX = packs [ 0 ] & & packs [ 0 ] . from PX , to PX = packs [ 0 ] & & packs [ packs . length - 1 ] . to PX , i , h = range . to - range . from ; if ( packs . length & & from PX < = range . from & & to PX > = range . to ) { 
function ( type ) { return Focusable . _dom For Event . call ( this , type ) | | Container . prototype . dom For Event . call ( this , type ) ; } 
function ( ) { var result = [ ] , indexes = this . selection ( ) . indexes ( ) ; for ( var i = 0 , l = indexes . length ; i < l ; i + + ) { var item = this . _data . slice ( indexes [ i ] , indexes [ i ] + 1 ) [ 0 ] ; if ( item ) result . push ( item ) ; } ; return result ; } 
function ( template , context , partials ) { if ( ! includes ( " # " , template ) & & ! includes ( " ^ " , template ) ) { return template ; } var that = this ; 
function ( template , context , partials , in _recursion ) { 
function ( name , context ) { name = trim ( name ) ; var value ; if ( is _kinda _truthy ( context [ name ] ) ) { value = context [ name ] ; } else if ( is _kinda _truthy ( this . context [ name ] ) ) { value = this . context [ name ] ; } if ( typeof value = = = "function " ) { return value . apply ( context ) ; } if ( value ! = = undefined ) { return value ; } 
function ( template , view , partials , send _fun ) { var renderer = new Renderer ( ) ; if ( send _fun ) { renderer . send = send _fun ; } renderer . render ( template , view , partials ) ; if ( ! send _fun ) { return renderer . buffer . join ( " \n " ) ; } } 
function ( tag Name , options , children ) { var e = env . doc . create Element ( tag Name ) ; utils . for Each ( options | | { } , function ( value , name ) { if ( name = = 'style ' ) { e . style . css Text = value ; } else if ( name = = 'html ' ) { e . inner HTML = value ; } else if ( name = = 'class Name ' ) { e . class Name = value ; } else { e . set Attribute ( name , value ) ; } } ) ; children & & utils . for Each ( children , function ( c ) { e . append Child ( c ) ; } ) ; return e ; } 
function ( elem , ignore Scroll ) { var rect = elem . get Bounding Client Rect ( ) ; var result = { top : rect . top | 0 , left : rect . left | 0 , right : rect . right | 0 , bottom : rect . bottom | 0 , width : ( rect . right - rect . left ) | 0 , height : ( rect . bottom - rect . top ) | 0 } ; if ( ignore Scroll ) { return result ; } var body = env . doc . body ; result . top + = env . root . page YOffset | | body . scroll Top ; result . top + = env . root . page XOffset | | body . scroll Left ; return result ; } 
function ( id ) { if ( ! arguments . length ) { return this . dom ( ) . id ; } if ( this . dom ( ) . id ) { view . unregister Id ( this ) ; } this . dom ( ) . id = id ; view . register Id ( this ) ; return this ; } 
function ( value ) { if ( ! arguments . length ) { return this . dom ( ) . style ; } this . dom ( ) . style . css Text = style To String ( value ) ; return this ; } 
function ( pos ) { if ( ! arguments . length ) { return this . _style To Pos ( this . dom ( ) . style ) ; } pos = this . _expand Pos ( pos ) ; this . add Style ( pos ) ; return this ; } 
function Drag Controls ( _objects , _camera , _dom Element ) { if ( _objects . is Camera ) { console . warn ( 'THREE .Drag Controls : Constructor now expects ( objects , camera , dom Element ) ' ) ; var temp = _objects ; _objects = _camera ; _camera = temp ; } var _plane = new Plane ( ) ; var _raycaster = new Raycaster ( ) ; var _mouse = new Vector 2 ( ) ; var _offset = new Vector 3 ( ) ; var _intersection = new Vector 3 ( ) ; var _selected = null , _hovered = null ; 
function ( context ) { var _children = [ ] ; _children . push ( React . DOM . i ( { class Name : 'icon ' + context . icon } ) ) ; React . Children . for Each ( context . children , function ( child ) { _children . push ( child ) ; } ) ; context . children = _children ; } 
function ( context ) { context . icon = 'loading ' ; context . disabled = true ; if ( this . props . loading Message ) { context . children = this . props . loading Message ; } } 
function normalize Events ( events , rtn , prefix ) { rtn = rtn | | { } ; if ( prefix ) { prefix + = ' : ' ; } else { prefix = ' ' ; } var value , value Type ; for ( var key in events ) { if ( events . has Own Property ( key ) ) { value = events [ key ] ; value Type = typeof value ; if ( value Type = = = 'string ' | | value Type = = = 'function ' ) { rtn [ prefix + key ] = value ; } else if ( value ) { normalize Events ( value , rtn , prefix + key ) ; } } } return rtn ; } 
function manage Event ( type , data ) { var _data = { type : type } ; for ( var name in data ) { if ( data . has Own Property ( name ) ) { _data [ name ] = data [ name ] ; } } var watched Events = get State ( ' _ _watched Events ' , this ) ; if ( ! watched Events ) { watched Events = [ ] ; set State ( { _ _watched Events : watched Events } , this ) ; } _data . context = _data . context | | this ; watched Events . push ( _data ) ; 
function _watched Events Bind All ( context ) { var watched Events = get State ( ' _ _watched Events ' , context ) ; if ( watched Events ) { var data ; for ( var name in watched Events ) { if ( watched Events . has Own Property ( name ) ) { data = watched Events [ name ] ; var target = get Target ( data . target , context ) ; if ( target ) { target [ data . type ] ( data . event , data . callback , data . context ) ; } } } } } 
function _watched Events Unbind All ( keep Registered Events , context ) { var watched Events = get State ( ' _ _watched Events ' , context ) ; if ( watched Events ) { var data ; for ( var name in watched Events ) { if ( watched Events . has Own Property ( name ) ) { data = watched Events [ name ] ; var target = get Target ( data . target , context ) ; if ( target ) { target . off ( data . event , data . callback , data . context ) ; } } } if ( ! keep Registered Events ) { set State ( { _ _watched Events : [ ] } , context ) ; } } } 
function create Handler ( event , callback , context , dont Wrap Callback ) { if ( ! dont Wrap Callback ) { var _callback = callback , no Arg ; if ( typeof callback = = = 'object ' ) { 
function ( identifier , options Or Handler ) { if ( typeof options Or Handler ! = = 'function ' ) { 
function ( ) { var args = Array . prototype . slice . call ( arguments ) , target = this ; 
function ( target , ev , callback , context ) { var data = ev ? { event : ev , callback : callback , target : target , context : context } : target ; manage Event . call ( this , 'on ' , data ) ; } 
function S 3Receiver ( s 3Client Opts ) { s 3Client Opts = s 3Client Opts | | { } ; s 3Client Opts = _ . extend ( { } , global Opts , s 3Client Opts ) ; var was Max Bytes Per Upstream Quota Exceeded ; var was Max Bytes Per File Quota Exceeded ; var max Bytes Per Upstream = s 3Client Opts . max Bytes | | undefined ; var max Bytes Per File = s 3Client Opts . max Bytes Per File | | undefined ; var receiver = Writable ( { object Mode : true } ) ; receiver . once ( 'error ' , ( unused Err ) = > { 
function _strip Keys With Undefined Values ( dictionary ) { for ( let k in dictionary ) { if ( dictionary [ k ] = = = undefined ) { delete dictionary [ k ] ; } } return dictionary ; } 
function _build S 3Client ( s 3Client Opts ) { var s 3Constructor Argins = _strip Keys With Undefined Values ( { api Version : ' 2 0 0 6 - 0 3 - 0 1 ' , region : s 3Client Opts . region , access Key Id : s 3Client Opts . key , secret Access Key : s 3Client Opts . secret , endpoint : s 3Client Opts . endpoint } ) ; return new AWS . S 3 ( s 3Constructor Argins ) ; } 
function _upload File ( incoming Fd , incoming File Stream , handle Progress , s 3Client Opts , done ) { 
function get Parameter Value ( parameter , context ) { var path = parameter . path | | parameter ; var value = ( path [ 0 ] = = = ' . ' ) ? JSPath . apply ( path , context ) : path ; 
function fault Handler ( context , error ) { debug ( 'default error Handler : %s ' , error . stack ? error . stack : error . message ) ; if ( context . response ) { context . response . status Code = 5 0 0 ; context . response . end ( error . message ) ; } } 
function normalize Protocol ( protocol ) { if ( protocol & & protocol . length > 0 & & protocol . char At ( protocol . length - 1 ) ! = = ' : ' ) { return protocol + ' : ' } return protocol } 
function grab The Right Icon ( raw Text ) { 
function safe Body ( body ) { if ( Array . is Array ( body ) ) { return body ; } return Object . keys ( body ) . sort ( ) . map ( idx = > body [ idx ] ) ; } 
function build Svg ( path , { size : { width , height } , VIEW _BOX } , path Options ) { const svg Options = { view Box : ` $ { VIEW _BOX } $ { VIEW _BOX } ` , 'shape -rendering ' : 'optimize Speed ' , } ; const svg Options Str = Object . entries ( svg Options ) . map ( ( [ key , value ] ) = > ` $ { key } $ { encode URIComponent ( value ) } ` ) . join ( ' ' ) ; const path Options Str = Object . entries ( path Options ) . map ( ( [ key , value ] ) = > ` $ { key } $ { encode URIComponent ( value ) } ` ) . join ( ' ' ) ; const svg = ` $ { width } $ { height } $ { svg Options Str } $ { path Options Str } $ { path } ` ; const sprite = Sprite . from Image ( ` $ { svg } ` ) ; sprite . _generated Svg Texture = true ; return sprite ; } 
function read File ( in Path , use Header , regex ) { var index = 0 ; var out Data = [ ] ; var read Stream = fs . create Read Stream ( in Path ) . pipe ( split ( ) ) . on ( 'data ' , function ( line ) { line = line . to String ( ) . match ( regex ) ; if ( line ) { if ( use Header & & index = = 0 ) { set Header Row As Keys ( line ) ; } else if ( use Header ) { 
function request Promise ( options ) { return new Promise ( ( resolve , reject ) = > { request ( options , ( error , response ) = > { if ( ! error & & response . status Code = = = 2 0 0 ) { resolve ( response ) ; } else if ( error ) { reject ( error ) ; } else { reject ( new Error ( ` $ { response . status Code } ` ) ) ; } } ) ; } ) ; } 
function prettify ( result ) { const collection = { } ; Object . keys ( result ) . for Each ( key = > { const readable Key = aliases [ key ] ; let value = result [ key ] ; if ( key = = = 'published ' ) { value = moment ( value ) . format ( 'LLL ' ) ; } if ( key = = = 'properties Count ' ) { const array = [ ] ; value . for Each ( item = > { array . push ( [ item . property , item . count ] ) ; } ) ; if ( array . length ! = = 0 ) { value = array . join ( ' \n ' ) . replace ( / , / g , ' : ' ) ; } } if ( KEY _BYTE . index Of ( key ) ! = = - 1 ) { value = numeral ( value ) . format ( ' 0 . 0b ' ) . replace ( / ^ 0 \ . 0B $ / , ' 0 ' ) ; } if ( KEY _PERCENT . index Of ( key ) ! = = - 1 ) { value = numeral ( value ) . format ( ' 0 . 0 % ' ) . replace ( / ^ 0 \ . 0 % $ / , ' 0 ' ) ; } if ( KEY _NUMBER . index Of ( key ) ! = = - 1 ) { value = numeral ( value ) . format ( ' 0 . 0 0 0 ' ) ; } if ( Array . is Array ( value ) ) { const max Len = 6 4 ; value = value . map ( val = > { if ( val . length > max Len ) { return ` $ { val . substring ( 0 , max Len ) } ` ; } return val ; } ) ; value = value . join ( ' \n ' ) = = = ' ' ? 'N /A ' : value . join ( ' \n ' ) ; } collection [ readable Key ] = value ; } ) ; return collection ; } 
function ( name , index , length ) { this . name = name ; this . start = index ; this . length = length ; this . args = [ ] ; } 
function ( is Macro Available , usid ) { this . current Directive = null ; this . matches = [ ] ; this . is Macro Available = is Macro Available ; this . usid = usid ; this . data = { } ; 
function ( match , value , index , length ) { if ( ! this . current Macro ) return ; this . current Macro . args . push ( { start : index + value . length , index : index , length : length , value : value } ) ; } 
function ( obj , from ) { for ( var key in from ) { if ( ! from . has Own Property ( key ) ) continue ; obj [ key ] = from [ key ] ; } return obj ; } 
function ( match , str Until Value , name , value , index ) { var self = this ; var contains Template = false ; 
function get Prop Type ( prop Value ) { const prop Type = typeof prop Value ; if ( Array . is Array ( prop Value ) ) { return 'array ' ; } if ( prop Value instanceof Reg Exp ) { 
function _get Object With Fallback ( object , key Property , label Property ) { if ( has In ( object , label Property ) ) { return object ; } else if ( has In ( object , key Property ) ) { 
function _load Single Object ( object , key Property , label Property , object Loader ) { if ( has In ( object , label Property ) ) { 
function load Object Data ( object , key Property , label Property , object Loader , on Loading Start = ( ) = > { } , on Loading End = ( ) = > { } ) { if ( is Nil ( object ) ) { return Promise . resolve ( object ) ; } 
function get Total Count ( response ) { let range = response . headers [ 'content -range ' ] ; let index = range . index Of ( ' / ' ) ; let total Count = range . substring ( index + 1 ) ; return parse Int ( total Count , 1 0 ) ; } 
function show Message ( message , message Btn ) { var ui Message = document . query Selector All ( message ) , ui Message Btn = document . query Selector All ( message Btn ) , time Out = 2 0 0 0 , 
function ui Message ( ) { 
function ( err ) { notify . on Error ( { title : "Error in " + err . plugin , message : err . message } ) ( err ) ; this . emit ( 'end ' ) ; } 
function default _headers ( class _context ) { class _context = class _context | | { } ; let headers = { } ; if ( class _context . token ) { headers . Token = class _context . token ; } if ( ! is Browser ) { headers [ 'User -Agent ' ] = ` $ { pkg . version } ` ; } return headers ; } 
function version ( ) { const url = ` $ { config . api _url } ` ; const method = 'GET ' ; const headers = default _headers ( ) ; const options = Object . assign ( { } , headers , { url , method } ) ; return request ( options ) ; } 
function get Token By Name ( account , device _id , names = null ) { return co ( function * ( ) { const tokens = yield account . devices . token List ( device _id ) ; if ( ! tokens | | ! tokens [ 0 ] ) return ; let token ; if ( names ) { names = Array . is Array ( names ) ? names : [ names ] ; for ( const name of names ) { token = tokens . find ( ( token ) = > token . name . index Of ( name ) > = 0 ) ; if ( token ) break ; } } else { token = tokens [ 0 ] ; } if ( ! token ) throw ` $ { device _id } $ { names } ` ; return token . token ; } ) . catch ( ( error ) = > { throw error ; } ) ; } 
function env _to _obj ( environment ) { return environment . reduce ( ( pv , cv ) = > { pv [ cv . key ] = cv . value ; return pv ; } , { } ) ; } 
function index ( drag Handler El ) { var opt = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : { } ; if ( opt . min Translate = = null ) { opt . min Translate = 1 0 ; } var store = get Pure Store ( ) ; var destroy = function destroy ( ) { Drag Event Service . off ( drag Handler El , 'end ' , drag Handler El . _draggble Event Handler ) ; hp . off DOM ( drag Handler El , 'selectstart ' , prevent Select ) ; delete drag Handler El . _draggble Event Handler ; } ; if ( drag Handler El . _draggble Event Handler ) { destroy ( ) ; } drag Handler El . _draggble Event Handler = start ; Drag Event Service . on ( drag Handler El , 'start ' , drag Handler El . _draggble Event Handler ) ; hp . on DOM ( drag Handler El , 'selectstart ' , prevent Select ) ; return destroy ; function start ( e , mouse ) { 
function make Next ( browser ) { return function next ( code ) { exit Code + = code ; current Run + + ; if ( code = = = 0 ) { 
function ( options ) { var self = this if ( ! ( self instanceof Device ) ) return new Device ( options ) Event Emitter . call ( self ) self . config = options self . host = self . config . addresses [ 0 ] self . _playing = false } 
function ( ) { var build Request = build JSONRequest . bind ( this ) ; if ( arguments . length = = 2 ) { 
function ( base URL , relative URL , opts ) { opts = opts | | { } ; 
function get Longest Array ( arrays ) { var lengths = arrays . map ( array = > array . length ) return Math . max . apply ( null , lengths ) } 
function reject After ( milliseconds , error Message ) { return new Promise ( ( resolve , reject ) = > { later ( reject , new Error ( error Message ) , milliseconds ) ; } ) ; } 
function load Script ( src ) { return new Promise ( resolve = > { const script = document . create Element ( 'script ' ) ; script . onload = resolve ; script . src = src ; document . head . append Child ( script ) ; } ) ; } 
function load Stylesheet ( href ) { return new Promise ( resolve = > { const link = document . create Element ( 'link ' ) ; link . onload = resolve ; link . rel = 'stylesheet ' link . type = 'text /css ' ; link . href = href ; document . head . append Child ( link ) ; } ) ; } 
function md 5crypt ( password , salt , magic ) { var rearranged = ' ' , mixin , final , m , v , i ; m = crypto . create Hash ( 'md 5 ' ) ; m . update ( password + magic + salt ) ; mixin = crypto . create Hash ( 'md 5 ' ) . update ( password + salt + password ) . digest ( "binary " ) ; for ( i = 0 ; i < password . length ; i + + ) { m . update ( mixin [ i % 1 6 ] ) ; } 
function deploy ( req , res ) { var stack Name = req . params . stack , region Name = req . params . region , name = req . remote User . name ; function _deploy ( to _revision ) { async . waterfall ( [ dreadnot . deploy . bind ( dreadnot , stack Name , region Name , to _revision , name ) , function ( number , callback ) { dreadnot . get Deployment Summary ( stack Name , region Name , number , callback ) ; } ] , res . respond ) ; } 
function save Warning ( req , res ) { var text = req . body . action = = = 'save ' ? req . body . warning _text : ' ' ; dreadnot . set Warning ( req . remote User , text , function ( err ) { if ( err ) { res . respond ( err ) ; } else { get Warning ( req , res ) ; } } ) ; } 
function handle Error ( err , req , res ) { switch ( err . name ) { case 'Not Found Error ' : res . send ( err , 4 0 4 ) ; break ; default : res . send ( err , 5 0 0 ) ; } } 
function response Callback ( req , res ) { return function ( err , data ) { if ( err ) { handle Error ( err , req , res ) ; } else { res . send ( data ) ; } } ; } 
function Cloud Monitoring ( options , log ) { this . _options = options ; this . log = log | | logmagic . local ( 'cloudmonitoring ' ) ; this . default Suppression Duration = options . default Suppression Duration | | DEFAULT _SUPPRESSION _DURATION ; this . monitoring Api Uri = options . monitoring Api Uri | | DEFAULT _MONITORING _API _URI ; this . keystone Client = new Keystone Client ( options . auth Uri | | DEFAULT _AUTH _URI , { username : options . username , api Key : options . api Key } ) ; } 
function Nagios ( options , log ) { var parsed = url . parse ( options . url ) ; 
function New Relic ( license _key , options , log ) { this . url = "https : / /api .newrelic .com " ; this . _options = options ; this . license _key = license _key ; if ( ! this . _options . has Own Property ( 'user ' ) ) { this . _options [ 'user ' ] = 'dreadnot ' ; } this . log = log | | logmagic . local ( 'sensu ' ) ; } 
function Pager Duty ( options , log ) { var parsed = url . parse ( options . url ) ; delete parsed . host ; this . url = url . format ( parsed ) ; this . users = options . users ; this . schedules = options . schedules ; this . log = log | | logmagic . local ( 'pagerduty ' ) ; this . pagerduty _auth = sprintf ( 'Token token = %s ' , options . password ) ; } 
function Stack ( name , dreadnot , config ) { var self = this , log Name = sprintf ( 'deploy .stack . %s ' , name ) , sink Name = sprintf ( 'stack . %s ' , name ) , module Name ; if ( config . stacks [ name ] . has Own Property ( 'module _name ' ) ) { module Name = config . stacks [ name ] . module _name ; } else { module Name = name ; } this . name = name ; this . dreadnot = dreadnot ; this . module = require ( path . join ( path . resolve ( dreadnot . stackdir ) , module Name ) ) ; this . config = config ; this . stack Config = config . stacks [ name ] ; this . log = logmagic . local ( log Name ) ; this . log Root = path . join ( config . data _root , 'logs ' , name ) ; this . newest Deployments = { } ; this . repo = this . stack Config . repo | | name ; this . current = null ; this . _cache = { } ; this . _waiting = { } ; logmagic . register Sink ( sink Name , function ( module Name , lvl , msg , obj ) { var both = module Name . split ( ' . ' ) . slice ( - 2 ) , log Path = [ 'regions ' , both [ 0 ] , 'deployments ' , both [ 1 ] , 'log ' ] . join ( ' . ' ) ; 
function Graphite ( host , port , event Port , secure , log ) { this . client = graphite . create Client ( sprintf ( 'plaintext : / / %s : %s / ' , host , port ) ) ; this . secure = secure ; this . host = host ; this . port = port ; this . event Port = event Port ; this . log = log | | logmagic . local ( 'graphite ' ) ; } 
function render ( req , res , template , data , options ) { res . render ( template , misc . merge ( { user : req . remote User , title : dreadnot . config . name , env : dreadnot . config . env , url : req . original Url , emsg : res . emsg , wmsg : dreadnot . warning , helpers : view Helpers , data : data } , options | | { } ) ) ; } 
function handle Error ( req , res , err ) { switch ( err . name ) { case 'Not Found Error ' : render ( req , res , 'error ' , err , { status : 4 0 4 } ) ; break ; default : render ( req , res , 'error ' , err , { status : 5 0 0 } ) ; } } 
function render Callback ( req , res , template ) { return function ( err , data ) { if ( err ) { handle Error ( req , res , err ) ; } else { render ( req , res , template , data ) ; } } ; } 
function get Login ( req , res ) { var next = req . param ( 'next ' ) ; render ( req , res , 'login .jade ' , { next : next } ) ; } 
function attempt Login ( req , res ) { var username = req . param ( 'username ' ) , password = req . param ( 'password ' ) , next = req . param ( 'next ' , ' / ' ) ; authdb . validate ( username , password , function ( err , valid ) { if ( valid ) { req . session . authed = true ; req . session . username = username ; res . redirect ( next ) ; } else { res . emsg = 'Invalid Username or Password ' ; render ( req , res , 'login .jade ' , { next : next } ) ; } } ) ; } 
function get Stacks ( req , res ) { var data = { } ; async . auto ( { stacks : function ( callback ) { dreadnot . get Stack Summaries ( function ( err , stacks ) { data . stacks = stacks ; callback ( err ) ; } ) ; } , regions : [ 'stacks ' , function ( callback ) { async . for Each ( data . stacks , function ( stack , callback ) { dreadnot . get Region Summaries ( stack . name , function ( err , regions ) { if ( err ) { callback ( err ) ; return ; } stack . regions = regions ; async . for Each ( stack . regions , function ( region , callback ) { 
function get Deployments ( req , res ) { async . parallel ( { stack : dreadnot . get Stack Summary . bind ( dreadnot , req . params . stack ) , region : dreadnot . get Region Summary . bind ( dreadnot , req . params . stack , req . params . region ) , deployments : dreadnot . get Deployment Summaries . bind ( dreadnot , req . params . stack , req . params . region ) } , render Callback ( req , res , 'deployments .jade ' ) ) ; } 
function get Deployment ( req , res ) { async . parallel ( { stack : dreadnot . get Stack Summary . bind ( dreadnot , req . params . stack ) , region : dreadnot . get Region Summary . bind ( dreadnot , req . params . stack , req . params . region ) , deployment : dreadnot . get Deployment Summary . bind ( dreadnot , req . params . stack , req . params . region , req . params . deployment ) } , render Callback ( req , res , 'deployment .jade ' ) ) ; } 
function deploy ( req , res ) { var stack Name = req . params . stack , region Name = req . params . region , to = req . body . to _revision , user ; dreadnot . deploy ( stack Name , region Name , to , req . remote User . name , function ( err , number ) { if ( err ) { res . respond ( err ) ; return ; } else { res . redirect ( sprintf ( ' /stacks / %s /regions / %s /deployments / %s ' , stack Name , region Name , number ) ) ; } } ) ; } 
function Jenkins ( options , log ) { var parsed = url . parse ( options . url ) ; if ( options . username & & options . password ) { parsed [ 'auth ' ] = util . format ( ' %s : %s ' , options . username , options . password ) ; } this . _url = url . format ( parsed ) ; this . _options = options ; this . log = log | | logmagic . local ( 'jenkins ' ) ; } 
function Document ( options ) { Repository . call ( this , options ) ; options = options | | { } ; var default Conf = { host : 'https : / /nubiz -opensource .documents .azure .com : 4 4 3 / ' , master Key : ' 1A 5vu Edjyl 3zrqxu MASl B / 4QGwll Qs Iroyr Pm VXVslkfnax YSEv A /H 4QUr RCp 4IUi G 6r Ou XUx EHX 0SCGfsj Pu A = = ' , db Name : 'node -viewmodel ' } ; this . options = _ . defaults ( options , default Conf ) ; } 
function Repository ( options ) { options = options | | { } ; this . repository Type = ( typeof ( options . type ) = = = 'string ' ) ? options . type : null ; Event Emitter . call ( this ) ; } 
function ( query , query Options , callback ) { if ( ! query Options ) { callback = query ; query = { } ; query Options = { } ; } else if ( ! callback ) { callback = query Options ; query Options = { } ; } this . find ( query , query Options , function ( err , items ) { if ( err ) { return callback ( err ) ; } callback ( null , items [ 0 ] ) ; } ) ; } 
function ( obj ) { var res = _ . assign ( _ . assign ( { } , this ) , obj ) ; for ( var f in this ) { if ( _ . is Function ( this [ f ] ) ) { res [ f ] = this [ f ] ; } } if ( _ . is Function ( res . check Connection ) ) { res . check Connection ( ) ; } return res ; } 
function generate Entity ( obj ) { var entity = _ . clone ( obj ) ; for ( var property in entity ) { if ( property ! = = ' _metadata ' ) { if ( _ . is Array ( entity [ property ] ) ) { entity [ property ] = eg . String ( JSON . stringify ( entity [ property ] ) ) ; continue ; } if ( _ . is Boolean ( entity [ property ] ) ) { entity [ property ] = eg . Boolean ( entity [ property ] ) ; continue ; } if ( _ . is Date ( entity [ property ] ) ) { entity [ property ] = eg . Date Time ( entity [ property ] ) ; continue ; } if ( _ . is String ( entity [ property ] ) ) { entity [ property ] = eg . String ( entity [ property ] ) ; continue ; } if ( _ . is Object ( entity [ property ] ) ) { entity [ property ] = eg . String ( JSON . stringify ( entity [ property ] ) ) ; continue ; } entity [ property ] = eg . Entity ( entity [ property ] ) ; } } return entity ; } 
function Azure Table ( options ) { Repository . call ( this , options ) ; options = options | | { } ; var azure Conf = { storage Account : 'nodeeventstore ' , storage Access Key : 'a XJaod 9 6t 9 8 0Ab Nw G 9Vh 6T 3ew PQnv MWAn 2 8 9Wft 9RTv +he XQBx Ls Y 3Z 4w 6 6CI 7NN 1 2 + 1HUn HM 8S 3s Ubc I 5zctg = = ' , storage Table Host : 'https : / /nodeeventstore .table .core .windows .net / ' } ; this . options = _ . defaults ( options , azure Conf ) ; } 
function View Model ( attr , repository , version ) { if ( ! repository ) { var err Msg = 'Please pass in a valid repository ' ; console . log ( err Msg ) ; throw new Error ( err Msg ) ; } for ( var f in Repository . prototype ) { if ( ! _ . is Function ( repository [ f ] ) ) { var err Msg = 'Please pass in a valid repository ' ; console . log ( err Msg ) ; throw new Error ( err Msg ) ; } } if ( attr . id ) { this . id = _ . clone ( attr . id ) ; } 
function ( name , func ) { wrapper . prototype [ name ] = function ( ) { var args = slice . call ( arguments ) ; unshift . call ( args , this . _wrapped ) ; return result ( func . apply ( _ , args ) , this . _chain ) ; } ; } 
function ( name , factory ) { 
function ( fn , context ) { return fn . call ( context | | global , _ . bind ( r , this ) , _ , this ) ; } 
function ( abbr , syntax , profile , context Node ) { if ( ! abbr ) return ' ' ; syntax = syntax | | default Syntax ; 
function ( ) { if ( global . console & & global . console . log ) global . console . log . apply ( global . console , arguments ) ; } 
function ( child , position ) { child = child | | new Abbreviation Node ; child . parent = this ; if ( _ . is Undefined ( position ) ) { this . children . push ( child ) ; } else { this . children . splice ( position , 0 , child ) ; } return child ; } 
function ( ) { var node = new Abbreviation Node ( ) ; var attrs = [ 'abbreviation ' , 'counter ' , ' _name ' , ' _text ' , 'repeat Count ' , 'has Implicit Repeat ' , 'start ' , 'end ' , 'content ' , 'padding ' ] ; _ . each ( attrs , function ( a ) { node [ a ] = this [ a ] ; } , this ) ; 
function ( ) { var parent = this . parent ; var ix = _ . index Of ( parent . children , this ) ; var items = _ . flatten ( arguments ) ; splice Fn . apply ( parent . children , [ ix , 1 ] . concat ( items ) ) ; 
function ( name , value ) { this [ name ] = value ; _ . each ( this . children , function ( child ) { child . update Property ( name , value ) ; } ) ; return this ; } 
function ( fn ) { if ( ! _ . is Function ( fn ) ) { var elem Name = fn . to Lower Case ( ) ; fn = function ( item ) { return item . name ( ) . to Lower Case ( ) = = elem Name ; } ; } var result = [ ] ; _ . each ( this . children , function ( child ) { if ( fn ( child ) ) result . push ( child ) ; result = result . concat ( child . find All ( fn ) ) ; } ) ; return _ . compact ( result ) ; } 
function ( name , value ) { if ( arguments . length = = 2 ) { this . _data [ name ] = value ; if ( name = = 'resource ' & & require ( 'elements ' ) . is ( value , 'snippet ' ) ) { 
function ( ) { var attrs = [ ] ; var res = this . matched Resource ( ) ; if ( require ( 'elements ' ) . is ( res , 'element ' ) & & _ . is Array ( res . attributes ) ) { attrs = attrs . concat ( res . attributes ) ; } return optimize Attributes ( attrs . concat ( this . _attributes ) ) ; } 
function ( name , value ) { if ( arguments . length = = 2 ) { 
function ( ) { var utils = require ( 'utils ' ) ; var start = this . start ; var end = this . end ; var content = this . content ; 
function ( ) { if ( ! this . children . length ) return null ; var deepest Child = this ; while ( deepest Child . children . length ) { deepest Child = _ . last ( deepest Child . children ) ; } return deepest Child ; } 
function parse Abbreviation ( abbr ) { abbr = require ( 'utils ' ) . trim ( abbr ) ; var root = new Abbreviation Node ; var context = root . add Child ( ) , ch ; var stream = require ( 'string Stream ' ) . create ( abbr ) ; var loop Protector = 1 0 0 0 , multiplier ; while ( ! stream . eol ( ) & & - - loop Protector > 0 ) { ch = stream . peek ( ) ; switch ( ch ) { case ' ( ' : 
function extract Attributes ( attr Set , attrs ) { attr Set = require ( 'utils ' ) . trim ( attr Set ) ; var result = [ ] ; var stream = require ( 'string Stream ' ) . create ( attr Set ) ; stream . eat Space ( ) ; while ( ! stream . eol ( ) ) { stream . start = stream . pos ; if ( stream . eat While ( re Word ) ) { var attr Name = stream . current ( ) ; var attr Value = ' ' ; if ( stream . peek ( ) = = ' = ' ) { stream . next ( ) ; stream . start = stream . pos ; var quote = stream . peek ( ) ; if ( quote = = ' " ' | | quote = = " ' " ) { stream . next ( ) ; if ( consume Quoted Value ( stream , quote ) ) { attr Value = stream . current ( ) ; 
function unroll ( node ) { for ( var i = node . children . length - 1 , j , child , max Count ; i > = 0 ; i - - ) { child = node . children [ i ] ; if ( child . is Repeating ( ) ) { max Count = j = child . repeat Count ; child . repeat Count = 1 ; child . update Property ( 'counter ' , 1 ) ; child . update Property ( 'max Count ' , max Count ) ; while ( - - j > 0 ) { child . parent . add Child ( child . clone ( ) , i + 1 ) . update Property ( 'counter ' , j + 1 ) . update Property ( 'max Count ' , max Count ) ; } } } 
function squash ( node ) { for ( var i = node . children . length - 1 ; i > = 0 ; i - - ) { var n = node . children [ i ] ; if ( n . is Group ( ) ) { n . replace ( squash ( n ) . children ) ; } else if ( n . is Empty ( ) ) { n . remove ( ) ; } } _ . each ( node . children , squash ) ; return node ; } 
function ( abbr , options ) { options = options | | { } ; var tree = parse Abbreviation ( abbr ) ; if ( options . context Node ) { 
function locate Output Placeholder ( text ) { var range = require ( 'range ' ) ; var result = [ ] ; var stream = require ( 'string Stream ' ) . create ( text ) ; while ( ! stream . eol ( ) ) { if ( stream . peek ( ) = = ' \ \ ' ) { stream . next ( ) ; } else { stream . start = stream . pos ; if ( stream . match ( output Placeholder , true ) ) { result . push ( range . create ( stream . start , output Placeholder ) ) ; continue ; } } stream . next ( ) ; } return result ; } 
function replace Output Placeholders ( source , value ) { var utils = require ( 'utils ' ) ; var ranges = locate Output Placeholder ( source ) ; ranges . reverse ( ) ; _ . each ( ranges , function ( r ) { source = utils . replace Substring ( source , value , r ) ; } ) ; return source ; } 
function insert Pasted Content ( node , content , overwrite ) { var nodes With Placeholders = node . find All ( function ( item ) { return has Output Placeholder ( item ) ; } ) ; if ( has Output Placeholder ( node ) ) nodes With Placeholders . unshift ( node ) ; if ( nodes With Placeholders . length ) { _ . each ( nodes With Placeholders , function ( item ) { item . content = replace Output Placeholders ( item . content , content ) ; _ . each ( item . _attributes , function ( attr ) { attr . value = replace Output Placeholders ( attr . value , content ) ; } ) ; } ) ; } else { 
function tokener ( value , type , conf ) { var w = walker , c = conf | | { } ; tokens . push ( { charstart : isset ( c [ 'char ' ] ) ? c [ 'char ' ] : w . chnum , charend : isset ( c . charend ) ? c . charend : w . chnum , linestart : isset ( c . line ) ? c . line : w . linenum , lineend : isset ( c . lineend ) ? c . lineend : w . linenum , value : value , type : type | | value } ) ; } 
function error ( m , config ) { var w = walker , conf = config | | { } , c = isset ( conf [ 'char ' ] ) ? conf [ 'char ' ] : w . chnum , l = isset ( conf . line ) ? conf . line : w . linenum ; return { name : "Parse Error " , message : m + " at line " + ( l + 1 ) + ' char ' + ( c + 1 ) , walker : w , tokens : tokens } ; } 
function white ( ) { var c = walker . ch , token = ' ' , conf = get Conf ( ) ; while ( c = = = " " | | c = = = " \t " ) { token + = c ; c = walker . next Char ( ) ; } tokener ( token , 'white ' , conf ) ; } 
function tokenize ( ) { var ch = walker . ch ; if ( ch = = = " " | | ch = = = " \t " ) { return white ( ) ; } if ( ch = = = ' / ' ) { return comment ( ) ; } if ( ch = = = ' " ' | | ch = = = " ' " ) { return str ( ) ; } if ( ch = = = ' ( ' ) { return brace ( ) ; } if ( ch = = = ' - ' | | ch = = = ' . ' | | is Digit ( ch ) ) { 
function get Newline ( content , pos ) { return content . char At ( pos ) = = ' \r ' & & content . char At ( pos + 1 ) = = ' \n ' ? ' \r \n ' : content . char At ( pos ) ; } 
function ( source ) { 
function ( ) { var res = require ( 'resources ' ) ; if ( ! res ) { return ' \n ' ; } var nl = res . get Variable ( 'newline ' ) ; return _ . is String ( nl ) ? nl : ' \n ' ; } 
function ( str , how Many ) { var result = [ ] ; for ( var i = 0 ; i < how Many ; i + + ) result . push ( str ) ; return result . join ( ' ' ) ; } 
function ( strings ) { var lengths = _ . map ( strings , function ( s ) { return _ . is String ( s ) ? s . length : + s ; } ) ; var max = _ . max ( lengths ) ; return _ . map ( lengths , function ( l ) { var pad = max - l ; return pad ? this . repeat String ( ' ' , pad ) : ' ' ; } , this ) ; } 
function ( text , pad ) { var pad Str = ( _ . is Number ( pad ) ) ? this . repeat String ( require ( 'resources ' ) . get Variable ( 'indentation ' ) | | ' \t ' , pad ) : pad ; var result = [ ] ; var lines = this . split By Lines ( text ) ; var nl = this . get Newline ( ) ; result . push ( lines [ 0 ] ) ; for ( var j = 1 ; j < lines . length ; j + + ) result . push ( nl + pad Str + lines [ j ] ) ; return result . join ( ' ' ) ; } 
function ( text , pad ) { var lines = this . split By Lines ( text ) ; for ( var i = 0 ; i < lines . length ; i + + ) { if ( lines [ i ] . search ( pad ) = = 0 ) lines [ i ] = lines [ i ] . substr ( pad . length ) ; } return lines . join ( this . get Newline ( ) ) ; } 
function ( str , symbol , replace ) { var i = 0 ; var il = str . length ; var sl = symbol . length ; var match Count = 0 ; while ( i < il ) { if ( str . char At ( i ) = = ' \ \ ' ) { 
function ( str , vars ) { vars = vars | | { } ; var resolver = _ . is Function ( vars ) ? vars : function ( str , p 1 ) { return p 1 in vars ? vars [ p 1 ] : null ; } ; var res = require ( 'resources ' ) ; return require ( 'tab Stops ' ) . process Text ( str , { variable : function ( data ) { var new Value = resolver ( data . token , data . name , data ) ; if ( new Value = = = null ) { 
function ( str , value , start , end ) { if ( _ . is Object ( start ) & & 'end ' in start ) { end = start . end ; start = start . start ; } if ( _ . is String ( end ) ) end = start + end . length ; if ( _ . is Undefined ( end ) ) end = start ; if ( start < 0 | | start > str . length ) return str ; return str . substring ( 0 , start ) + value + str . substring ( end ) ; } 
function ( text , start , end ) { var range = require ( 'range ' ) . create ( start , end ) ; var re Space = / [ \s \n \r \u 0 0a 0 ] / ; 
function ( text , from ) { var len = text . length , start = 0 , end = len - 1 ; 
function ( start , len ) { if ( _ . is Undefined ( start ) | | start = = = null ) return null ; if ( start instanceof Range ) return start ; if ( _ . is Object ( start ) & & 'start ' in start & & 'end ' in start ) { len = start . end - start . start ; start = start . start ; } return new Range ( start , len ) ; } 
function ( start , end ) { if ( _ . is Number ( start ) & & _ . is Number ( end ) ) { end - = start ; } return this . create ( start , end ) ; } 
function ( fn , options ) { this . _list . push ( _ . extend ( { order : 0 } , options | | { } , { fn : fn } ) ) ; } 
function ( fn ) { this . _list = _ . without ( this . _list , _ . find ( this . _list , function ( item ) { return item . fn = = = fn ; } ) ) ; } 
function ( skip Value , args ) { args = args | | [ ] ; var result = null ; _ . find ( this . list ( ) , function ( h ) { result = h . fn . apply ( h , args ) ; if ( result ! = = skip Value ) return true ; } ) ; return result ; } 
function ( open , close ) { var brace Count = 0 , ch ; var pos = this . pos , len = this . string . length ; while ( pos < len ) { ch = this . string . char At ( pos + + ) ; if ( ch = = open ) { brace Count + + ; } else if ( ch = = close ) { brace Count - - ; if ( brace Count < 1 ) { this . pos = pos ; return true ; } } } return false ; } 
function ( pattern , consume , case Insensitive ) { if ( typeof pattern = = "string " ) { var cased = case Insensitive ? function ( str ) { return str . to Lower Case ( ) ; } : function ( str ) { return str ; } ; if ( cased ( this . string ) . index Of ( cased ( pattern ) , this . pos ) = = this . pos ) { if ( consume ! = = false ) this . pos + = pattern . length ; return true ; } } else { var match = this . string . slice ( this . pos ) . match ( pattern ) ; if ( match & & consume ! = = false ) this . pos + = match [ 0 ] . length ; return match ; } } 
function ( node , syntax ) { return resolvers . exec ( null , _ . to Array ( arguments ) ) | | this . find Snippet ( syntax , node . name ( ) ) ; } 
function ( name ) { if ( ! name ) return null ; if ( ! ( name in cache ) ) { cache [ name ] = require ( 'utils ' ) . deep Merge ( { } , system Settings [ name ] , user Settings [ name ] ) ; } var data = cache [ name ] , subsections = _ . rest ( arguments ) , key ; while ( data & & ( key = subsections . shift ( ) ) ) { if ( key in data ) { data = data [ key ] ; } else { return null ; } } return data ; } 
function ( syntax , name , memo ) { if ( ! syntax | | ! name ) return null ; memo = memo | | [ ] ; var names = [ name ] ; 
function ( syntax , name , min Score ) { min Score = min Score | | 0 . 3 ; var payload = this . get All Snippets ( syntax ) ; var sc = require ( 'string -score ' ) ; name = normalize Name ( name ) ; var scores = _ . map ( payload , function ( value , key ) { return { key : key , score : sc . score ( value . nk , name , 0 . 1 ) } ; } ) ; var result = _ . last ( _ . sort By ( scores , 'score ' ) ) ; if ( result & & result . score > = min Score ) { var k = result . key ; return payload [ k ] . parsed Value ; 
function humanize Action Name ( name ) { return require ( 'utils ' ) . trim ( name . char At ( 0 ) . to Upper Case ( ) + name . substring ( 1 ) . replace ( / _ [a -z ] / g , function ( str ) { return ' ' + str . char At ( 1 ) . to Upper Case ( ) ; } ) ) ; } 
function ( name , fn , options ) { name = name . to Lower Case ( ) ; options = options | | { } ; if ( ! options . label ) { options . label = humanize Action Name ( name ) ; } actions [ name ] = { name : name , fn : fn , options : options } ; } 
function ( name , args ) { if ( ! _ . is Array ( args ) ) { args = _ . rest ( arguments ) ; } var action = this . get ( name ) ; if ( action ) { return action . fn . apply ( emmet , args ) ; } else { emmet . log ( 'Action " %s " is not defined ' , name ) ; return false ; } } 
function ( title , menu ) { var item = null ; _ . find ( menu | | this . get Menu ( ) , function ( val ) { if ( val . type = = 'action ' ) { if ( val . label = = title | | val . name = = title ) { return item = val . name ; } } else { return item = this . get Action Name For Menu Title ( title , val . items ) ; } } , this ) ; return item | | null ; } 
function ( name , syntax ) { if ( ! name & & syntax ) { 
function ( editor ) { var allowed Syntaxes = { 'html ' : 1 , 'xml ' : 1 , 'xsl ' : 1 } ; var syntax = String ( editor . get Syntax ( ) ) ; if ( syntax in allowed Syntaxes ) { var content = String ( editor . get Content ( ) ) ; var tag = require ( 'html Matcher ' ) . find ( content , editor . get Caret Pos ( ) ) ; if ( tag & & tag . type = = 'tag ' ) { var start Tag = tag . open ; var context Node = { name : start Tag . name , attributes : [ ] } ; 
function ( editor , fn ) { var content = String ( editor . get Content ( ) ) ; var il = content . length ; var expr Start = editor . get Caret Pos ( ) - 1 ; var expr End = expr Start + 1 ; 
function ( editor , hint ) { var syntax = hint | | 'html ' ; if ( ! require ( 'resources ' ) . has Syntax ( syntax ) ) { syntax = 'html ' ; } if ( syntax = = 'html ' & & ( this . is Style ( editor ) | | this . is Inline CSS ( editor ) ) ) { syntax = 'css ' ; } return syntax ; } 
function ( editor ) { var syntax = editor . get Syntax ( ) ; 
function ( editor ) { var content = String ( editor . get Content ( ) ) ; var caret Pos = editor . get Caret Pos ( ) ; var tag = require ( 'html Matcher ' ) . tag ( content , caret Pos ) ; return tag & & tag . open . name . to Lower Case ( ) = = 'style ' & & tag . inner Range . cmp ( caret Pos , 'lte ' , 'gte ' ) ; } 
function ( editor ) { var content = String ( editor . get Content ( ) ) ; var caret Pos = editor . get Caret Pos ( ) ; var tree = require ( 'xml Edit Tree ' ) . parse From Position ( content , caret Pos , true ) ; if ( tree ) { var attr = tree . item From Position ( caret Pos , true ) ; return attr & & attr . name ( ) . to Lower Case ( ) = = 'style ' & & attr . value Range ( true ) . cmp ( caret Pos , 'lte ' , 'gte ' ) ; } return false ; } 
function ( node ) { if ( node . children . length | | node . _text | | this . is Snippet ( node ) ) { return false ; } var r = node . matched Resource ( ) ; return r & & r . is _empty ; } 
function ( node ) { return ( this . has Tags In Content ( node ) & & this . is Block ( node ) ) | | _ . any ( node . children , function ( child ) { return this . is Block ( child ) ; } , this ) ; } 
function ( text , child Content , options ) { options = _ . extend ( { keep Variable : true , append If No Child : true } , options | | { } ) ; var child Variable Replaced = false ; var utils = require ( 'utils ' ) ; text = utils . replace Variables ( text , function ( variable , name , data ) { var output = variable ; if ( name = = 'child ' ) { 
function ( input ) { var output = [ ] ; var chr 1 , chr 2 , chr 3 , enc 1 , enc 2 , enc 3 , enc 4 , cdp 1 , cdp 2 , cdp 3 ; var i = 0 , il = input . length , b 6 4 = chars ; while ( i < il ) { cdp 1 = input . char Code At ( i + + ) ; cdp 2 = input . char Code At ( i + + ) ; cdp 3 = input . char Code At ( i + + ) ; chr 1 = cdp 1 & 0xff ; chr 2 = cdp 2 & 0xff ; chr 3 = cdp 3 & 0xff ; enc 1 = chr 1 > > 2 ; enc 2 = ( ( chr 1 & 3 ) < < 4 ) | ( chr 2 > > 4 ) ; enc 3 = ( ( chr 2 & 1 5 ) < < 2 ) | ( chr 3 > > 6 ) ; enc 4 = chr 3 & 6 3 ; if ( is Na N ( cdp 2 ) ) { enc 3 = enc 4 = 6 4 ; } else if ( is Na N ( cdp 3 ) ) { enc 4 = 6 4 ; } output . push ( b 6 4 . char At ( enc 1 ) + b 6 4 . char At ( enc 2 ) + b 6 4 . char At ( enc 3 ) + b 6 4 . char At ( enc 4 ) ) ; } return output . join ( ' ' ) ; } 
function ( data ) { var o 1 , o 2 , o 3 , h 1 , h 2 , h 3 , h 4 , bits , i = 0 , ac = 0 , tmp Arr = [ ] ; var b 6 4 = chars , il = data . length ; if ( ! data ) { return data ; } data + = ' ' ; do { 
function create Matcher ( text ) { var memo = { } , m ; return { open : function ( i ) { var m = this . matches ( i ) ; return m & & m . type = = 'open ' ? m : null ; } , close : function ( i ) { var m = this . matches ( i ) ; return m & & m . type = = 'close ' ? m : null ; } , matches : function ( i ) { var key = 'p ' + i ; if ( ! ( key in memo ) ) { if ( text . char At ( i ) = = ' < ' ) { var substr = text . slice ( i ) ; if ( m = substr . match ( re Open Tag ) ) { memo [ key ] = open Tag ( i , m ) ; } else if ( m = substr . match ( re Close Tag ) ) { memo [ key ] = close Tag ( i , m ) ; } else { * Returns original text * @returns {String } * / text : function ( ) { return text ; } } ; } 
function ( text , options ) { 
function ( node , offset ) { var max Num = 0 ; var options = { tabstop : function ( data ) { var group = parse Int ( data . group ) ; if ( group > max Num ) max Num = group ; if ( data . placeholder ) return ' $ { ' + ( group + offset ) + ' : ' + data . placeholder + ' } ' ; else return ' $ { ' + ( group + offset ) + ' } ' ; } } ; _ . each ( [ 'start ' , 'end ' , 'content ' ] , function ( p ) { node [ p ] = this . process Text ( node [ p ] , options ) ; } , this ) ; return max Num ; } 
function ( name , value , description ) { var prefs = name ; if ( _ . is String ( name ) ) { prefs = { } ; prefs [ name ] = { value : value , description : description } ; } _ . each ( prefs , function ( v , k ) { defaults [ k ] = is Value Obj ( v ) ? v : { value : v } ; } ) ; } 
function ( name , value ) { var prefs = name ; if ( _ . is String ( name ) ) { prefs = { } ; prefs [ name ] = value ; } _ . each ( prefs , function ( v , k ) { if ( ! ( k in defaults ) ) { throw 'Property " ' + k + ' " is not defined . You should define it first with `define ` method of current module ' ; } 
function ( name ) { if ( name in preferences ) return preferences [ name ] ; if ( name in defaults ) return defaults [ name ] . value ; return void 0 ; } 
function ( name ) { var val = this . get ( name ) ; if ( _ . is Undefined ( val ) | | val = = = null | | val = = = ' ' ) { return null ; } val = _ . map ( val . split ( ' , ' ) , require ( 'utils ' ) . trim ) ; if ( ! val . length ) { return null ; } return val ; } 
function ( name ) { var result = { } ; _ . each ( this . get Array ( name ) , function ( val ) { var parts = val . split ( ' : ' ) ; result [ parts [ 0 ] ] = parts [ 1 ] ; } ) ; return result ; } 
function ( name ) { if ( ! _ . is Array ( name ) ) name = [ name ] ; _ . each ( name , function ( key ) { if ( key in preferences ) delete preferences [ key ] ; if ( key in defaults ) delete defaults [ key ] ; } ) ; } 
function ( tree , filters , profile ) { var utils = require ( 'utils ' ) ; profile = require ( 'profile ' ) . get ( profile ) ; _ . each ( list ( filters ) , function ( filter ) { var name = utils . trim ( filter . to Lower Case ( ) ) ; if ( name & & name in registered Filters ) { tree = registered Filters [ name ] ( tree , profile ) ; } } ) ; return tree ; } 
function ( syntax , profile , additional Filters ) { profile = require ( 'profile ' ) . get ( profile ) ; var filters = list ( profile . filters | | require ( 'resources ' ) . find Item ( syntax , 'filters ' ) | | basic Filters ) ; if ( profile . extra Filters ) { filters = filters . concat ( list ( profile . extra Filters ) ) ; } if ( additional Filters ) { filters = filters . concat ( list ( additional Filters ) ) ; } if ( ! filters | | ! filters . length ) { 
function ( value , start , end ) { 
function ( name ) { if ( _ . is Number ( name ) ) return this . list ( ) [ name ] ; if ( _ . is String ( name ) ) return _ . find ( this . list ( ) , function ( prop ) { return prop . name ( ) = = = name ; } ) ; return name ; } 
function ( name ) { if ( ! _ . is Array ( name ) ) name = [ name ] ; 
function ( name , value , pos ) { var element = this . get ( name ) ; if ( element ) return element . value ( value ) ; if ( ! _ . is Undefined ( value ) ) { 
function ( name ) { var element = this . get ( name ) ; if ( element ) { this . _update Source ( ' ' , element . full Range ( ) ) ; this . _children = _ . without ( this . _children , element ) ; } } 
function ( val ) { if ( ! _ . is Undefined ( val ) & & this . _name ! = = ( val = String ( val ) ) ) { this . _update Source ( val , this . _positions . name , this . _positions . name + this . _name . length ) ; this . _name = val ; } return this . _name ; } 
function ( pos , is Absolute ) { return _ . find ( this . list ( ) , function ( elem ) { return elem . range ( is Absolute ) . inside ( pos ) ; } ) ; } 
function ( val ) { if ( ! _ . is Undefined ( val ) & & this . _value ! = = ( val = String ( val ) ) ) { this . parent . _update Source ( val , this . value Range ( ) ) ; this . _value = val ; } return this . _value ; } 
function ( val ) { if ( ! _ . is Undefined ( val ) & & this . _name ! = = ( val = String ( val ) ) ) { this . parent . _update Source ( val , this . name Range ( ) ) ; this . _name = val ; } return this . _name ; } 
function trim Whitespace Tokens ( tokens , mask ) { mask = mask | | ( WHITESPACE _REMOVE _FROM _START | WHITESPACE _REMOVE _FROM _END ) ; var whitespace = [ 'white ' , 'line ' ] ; if ( ( mask & WHITESPACE _REMOVE _FROM _END ) = = WHITESPACE _REMOVE _FROM _END ) while ( tokens . length & & _ . include ( whitespace , _ . last ( tokens ) . type ) ) { tokens . pop ( ) ; } if ( ( mask & WHITESPACE _REMOVE _FROM _START ) = = WHITESPACE _REMOVE _FROM _START ) while ( tokens . length & & _ . include ( whitespace , tokens [ 0 ] . type ) ) { tokens . shift ( ) ; } return tokens ; } 
function find Selector Range ( it ) { var tokens = [ ] , token ; var start = it . position ( ) , end ; while ( token = it . next ( ) ) { if ( token . type = = ' { ' ) break ; tokens . push ( token ) ; } trim Whitespace Tokens ( tokens ) ; if ( tokens . length ) { start = tokens [ 0 ] . start ; end = _ . last ( tokens ) . end ; } else { end = start ; } return range ( start , end - start ) ; } 
function find Value Range ( it ) { 
function find Parts ( str ) { var stream = require ( 'string Stream ' ) . create ( str ) ; var ch ; var result = [ ] ; var sep = / [ \s \u 0 0a 0 , ] / ; var add = function ( ) { stream . next ( ) ; result . push ( range ( stream . start , stream . current ( ) ) ) ; stream . start = stream . pos ; } ; 
function is Valid Identifier ( it ) { 
function ( ) { var start = this . _positions . content Start ; var source = this . source ; var utils = require ( 'utils ' ) ; _ . each ( this . list ( ) , function ( p ) { p . style Before = source . substring ( start , p . name Position ( ) ) ; 
function ( is Absolute ) { var parts = find Parts ( this . value ( ) ) ; if ( is Absolute ) { var offset = this . value Position ( true ) ; _ . each ( parts , function ( p ) { p . shift ( offset ) ; } ) ; } return parts ; } 
function ( val ) { if ( ! _ . is Undefined ( val ) & & this . _end ! = = val ) { this . parent . _update Source ( val , this . _positions . end , this . _positions . end + this . _end . length ) ; this . _end = val ; } return this . _end ; } 
function ( content , pos , is Backward ) { var result = ' ' ; var len = content . length ; var offset = pos ; var stop Chars = ' { } / \ \ < > \n \r ' ; var brace Pos = - 1 , ch ; 
function ( ) { var start = this . name Range ( ) . end ; var source = this . source ; _ . each ( this . list ( ) , function ( p ) { p . style Before = source . substring ( start , p . name Position ( ) ) ; if ( p . value Position ( ) ! = = - 1 ) { p . style Separator = source . substring ( p . name Position ( ) + p . name ( ) . length , p . value Position ( ) - p . style Quote . length ) ; } start = p . range ( ) . end ; } ) ; } 
function ( name , value , pos ) { var list = this . list ( ) ; var start = this . name Range ( ) . end ; var edit Tree = require ( 'edit Tree ' ) ; var styles = _ . pick ( this . options , 'style Before ' , 'style Separator ' , 'style Quote ' ) ; if ( _ . is Undefined ( pos ) ) pos = list . length ; var donor = list [ pos ] ; if ( donor ) { start = donor . full Range ( ) . start ; } else if ( donor = list [ pos - 1 ] ) { start = donor . range ( ) . end ; } if ( donor ) { styles = _ . pick ( donor , 'style Before ' , 'style Separator ' , 'style Quote ' ) ; } value = styles . style Quote + value + styles . style Quote ; var attribute = new XMLEdit Element ( this , edit Tree . create Token ( start + styles . style Before . length , name ) , edit Tree . create Token ( start + styles . style Before . length + name . length + styles . style Separator . length , value ) ) ; _ . extend ( attribute , styles ) ; 
function ( content , pos , is Backward ) { var len = content . length , i ; var range = require ( 'range ' ) ; 
function ( editor ) { var range = require ( 'range ' ) . create ( editor . get Selection Range ( ) ) ; var content = String ( editor . get Content ( ) ) ; if ( range . length ( ) ) { 
function ( abbr , text , syntax , profile , context Node ) { var filters = require ( 'filters ' ) ; var utils = require ( 'utils ' ) ; syntax = syntax | | emmet . default Syntax ( ) ; profile = require ( 'profile ' ) . get ( profile , syntax ) ; require ( 'tab Stops ' ) . reset Tabstop Index ( ) ; var data = filters . extract From Abbreviation ( abbr ) ; var parsed Tree = require ( 'abbreviation Parser ' ) . parse ( data [ 0 ] , { syntax : syntax , pasted Content : text , context Node : context Node } ) ; if ( parsed Tree ) { var filters List = filters . compose List ( syntax , profile , data [ 1 ] ) ; filters . apply ( parsed Tree , filters List , profile ) ; return utils . replace Variables ( parsed Tree . to String ( ) ) ; } return null ; } 
function toggle HTMLComment ( editor ) { var range = require ( 'range ' ) . create ( editor . get Selection Range ( ) ) ; var info = require ( 'editor Utils ' ) . output Info ( editor ) ; if ( ! range . length ( ) ) { 
function toggle CSSComment ( editor ) { var range = require ( 'range ' ) . create ( editor . get Selection Range ( ) ) ; var info = require ( 'editor Utils ' ) . output Info ( editor ) ; if ( ! range . length ( ) ) { 
function css Item From Position ( rule , abs Pos ) { 
function search Comment ( text , from , start Token , end Token ) { var comment Start = - 1 ; var comment End = - 1 ; var has Match = function ( str , start ) { return text . substr ( start , str . length ) = = str ; } ; 
function generic Comment Toggle ( editor , comment Start , comment End , range ) { var editor Utils = require ( 'editor Utils ' ) ; var content = editor Utils . output Info ( editor ) . content ; var caret Pos = editor . get Caret Pos ( ) ; var new Content = null ; var utils = require ( 'utils ' ) ; function remove Comment ( str ) { return str . replace ( new Reg Exp ( ' ^ ' + utils . escape For Regexp ( comment Start ) + ' \ \s * ' ) , function ( str ) { caret Pos - = str . length ; return ' ' ; } ) . replace ( new Reg Exp ( ' \ \s * ' + utils . escape For Regexp ( comment End ) + ' $ ' ) , ' ' ) ; } 
function remove Comment ( str ) { return str . replace ( new Reg Exp ( ' ^ ' + utils . escape For Regexp ( comment Start ) + ' \ \s * ' ) , function ( str ) { caret Pos - = str . length ; return ' ' ; } ) . replace ( new Reg Exp ( ' \ \s * ' + utils . escape For Regexp ( comment End ) + ' $ ' ) , ' ' ) ; } 
function make Possible Ranges HTML ( source , tokens , offset ) { offset = offset | | 0 ; var range = require ( 'range ' ) ; var result = [ ] ; var attr Start = - 1 , attr Name = ' ' , attr Value = ' ' , attr Value Range , tag Name ; _ . each ( tokens , function ( tok ) { switch ( tok . type ) { case 'tag ' : tag Name = source . substring ( tok . start , tok . end ) ; if ( / ^ < [ \w \ : \ - ] / . test ( tag Name ) ) { 
function class Name Ranges ( class Name , offset ) { offset = offset | | 0 ; var result = [ ] ; var stream = require ( 'string Stream ' ) . create ( class Name ) ; var range = require ( 'range ' ) ; 
function make Possible Ranges CSS ( property ) { 
function matched Range For CSSProperty ( rule , sel Range , is Backward ) { var property = null ; var possible Ranges , cur Range = null , ix ; var list = rule . list ( ) ; var search Fn , nearest Item Fn ; if ( is Backward ) { list . reverse ( ) ; search Fn = function ( p ) { return p . range ( true ) . start < = sel Range . start ; } ; nearest Item Fn = function ( r ) { return r . start < sel Range . start ; } ; } else { search Fn = function ( p ) { return p . range ( true ) . end > = sel Range . end ; } ; nearest Item Fn = function ( r ) { return r . end > sel Range . start ; } ; } 
function get Range For Next Item In CSS ( rule , offset , sel Range ) { var tree = require ( 'css Edit Tree ' ) . parse ( rule , { offset : offset } ) ; 
function get Range For Prev Item In CSS ( rule , offset , sel Range ) { var tree = require ( 'css Edit Tree ' ) . parse ( rule , { offset : offset } ) ; var cur Range = matched Range For CSSProperty ( tree , sel Range , true ) ; if ( ! cur Range ) { 
function match Pair ( editor , direction ) { direction = String ( ( direction | | 'out ' ) . to Lower Case ( ) ) ; var info = require ( 'editor Utils ' ) . output Info ( editor ) ; var range = require ( 'range ' ) ; var sel = range . create ( editor . get Selection Range ( ) ) ; var content = info . content ; 
function get Reflected CSSName ( name ) { name = require ( 'css Edit Tree ' ) . base Name ( name ) ; var vendor Prefix = ' ^ ( ? : \ \ - \ \w + \ \ - ) ? ' , m ; if ( name = = 'opacity ' | | name = = 'filter ' ) { return new Reg Exp ( vendor Prefix + ' ( ? :opacity |filter ) $ ' ) ; } else if ( m = name . match ( / ^border -radius - (top |bottom ) (left |right ) / ) ) { 
function reflect Value ( donor , receiver ) { var value = get Reflected Value ( donor . name ( ) , donor . value ( ) , receiver . name ( ) , receiver . value ( ) ) ; receiver . value ( value ) ; } 
function get Reflected Value ( cur Name , cur Value , ref Name , ref Value ) { var css Edit Tree = require ( 'css Edit Tree ' ) ; var utils = require ( 'utils ' ) ; cur Name = css Edit Tree . base Name ( cur Name ) ; ref Name = css Edit Tree . base Name ( ref Name ) ; if ( cur Name = = 'opacity ' & & ref Name = = 'filter ' ) { return ref Value . replace ( / opacity = [ ^ ) ] * / i , 'opacity = ' + Math . floor ( parse Float ( cur Value ) * 1 0 0 ) ) ; } else if ( cur Name = = 'filter ' & & ref Name = = 'opacity ' ) { var m = cur Value . match ( / opacity = ( [ ^ ) ] * ) / i ) ; return m ? utils . prettify Number ( parse Int ( m [ 1 ] ) / 1 0 0 ) : ref Value ; } return cur Value ; } 
function increment Number ( editor , step ) { var utils = require ( 'utils ' ) ; var action Utils = require ( 'action Utils ' ) ; var has Sign = false ; var has Decimal = false ; var r = action Utils . find Expression Bounds ( editor , function ( ch , pos , content ) { if ( utils . is Numeric ( ch ) ) return true ; if ( ch = = ' . ' ) { 
function decode From Base 6 4 ( editor , data , pos ) { 
function update Image Size CSS ( editor ) { var offset = editor . get Caret Pos ( ) ; 
function get Image Size For Source ( editor , src , callback ) { var file Content ; var au = require ( 'action Utils ' ) ; if ( src ) { 
function is Single Property ( snippet ) { var utils = require ( 'utils ' ) ; snippet = utils . trim ( snippet ) ; 
function normalize Value ( value ) { if ( value . char At ( 0 ) = = ' - ' & & ! / ^ \ - [ \ . \d ] / . test ( value ) ) { value = value . replace ( / ^ \ - + / , ' ' ) ; } if ( value . char At ( 0 ) = = ' # ' ) { return normalize Hex Color ( value ) ; } return get Keyword ( value ) ; } 
function find Prefixes ( property , no Autofill ) { var result = [ ] ; _ . each ( vendor Prefixes , function ( obj , prefix ) { if ( has Prefix ( property , prefix ) ) { result . push ( prefix ) ; } } ) ; if ( ! result . length & & ! no Autofill ) { 
function parse List ( list ) { var result = _ . map ( ( list | | ' ' ) . split ( ' , ' ) , require ( 'utils ' ) . trim ) ; return result . length ? result : null ; } 
function ( abbr , value , syntax ) { syntax = syntax | | 'css ' ; var resources = require ( 'resources ' ) ; var auto Insert Prefixes = prefs . get ( 'css .auto Insert Vendor Prefixes ' ) ; 
function ( abbr , syntax ) { var snippet = this . expand ( abbr , null , syntax ) ; if ( _ . is Array ( snippet ) ) { return snippet . join ( ' \n ' ) ; } if ( ! _ . is String ( snippet ) ) return snippet . data ; return String ( snippet ) ; } 
function ( snippet ) { var utils = require ( 'utils ' ) ; snippet = utils . trim ( snippet ) ; if ( snippet . index Of ( ' : ' ) = = - 1 ) { return { name : snippet , value : default Value } ; } var pair = snippet . split ( ' : ' ) ; return { name : utils . trim ( pair . shift ( ) ) , 
function parse Linear Gradient ( gradient ) { var direction = default Linear Directions [ 0 ] ; 
function resolve Property Name ( name , syntax ) { var res = require ( 'resources ' ) ; var prefs = require ( 'preferences ' ) ; var snippet = res . find Snippet ( syntax , name ) ; if ( ! snippet & & prefs . get ( 'css .fuzzy Search ' ) ) { snippet = res . fuzzy Find Snippet ( syntax , name , parse Float ( prefs . get ( 'css .fuzzy Search Min Score ' ) ) ) ; } if ( snippet ) { if ( ! _ . is String ( snippet ) ) { snippet = snippet . data ; } return require ( 'css Resolver ' ) . split Snippet ( snippet ) . name ; } } 
function fill Implied Positions ( color Stops ) { var from = 0 ; _ . each ( color Stops , function ( cs , i ) { 
function textual Direction ( direction ) { var angle = parse Float ( direction ) ; if ( ! _ . is Na N ( angle ) ) { switch ( angle % 3 6 0 ) { case 0 : return 'left ' ; case 9 0 : return 'bottom ' ; case 1 8 0 : return 'right ' ; case 2 4 0 : return 'top ' ; } } return direction ; } 
function old Webkit Direction ( direction ) { direction = textual Direction ( direction ) ; if ( re Deg . test ( direction ) ) throw "The direction is an angle that can ’t be converted . " ; var v = function ( pos ) { return ~ direction . index Of ( pos ) ? ' 1 0 0 % ' : ' 0 ' ; } ; return v ( 'right ' ) + ' ' + v ( 'bottom ' ) + ' , ' + v ( 'left ' ) + ' ' + v ( 'top ' ) ; } 
function get Properties For Gradient ( gradient , property Name ) { var props = [ ] ; var css = require ( 'css Resolver ' ) ; if ( prefs . get ( 'css .gradient .fallback ' ) & & ~ property Name . to Lower Case ( ) . index Of ( 'background ' ) ) { props . push ( { name : 'background -color ' , value : ' $ { 1 : ' + gradient . color Stops [ 0 ] . color + ' } ' } ) ; } _ . each ( prefs . get Array ( 'css .gradient .prefixes ' ) , function ( prefix ) { var name = css . prefixed ( property Name , prefix ) ; if ( prefix = = 'webkit ' & & prefs . get ( 'css .gradient .old Webkit ' ) ) { try { props . push ( { name : name , value : module . old Webkit Linear Gradient ( gradient ) } ) ; } catch ( e ) { } } props . push ( { name : name , value : module . to String ( gradient , prefix ) } ) ; } ) ; return props . sort ( function ( a , b ) { return b . name . length - a . name . length ; } ) ; } 
function paste Gradient ( property , gradient , value Range ) { var rule = property . parent ; var utils = require ( 'utils ' ) ; var align Vendor = require ( 'preferences ' ) . get ( 'css .align Vendor ' ) ; 
function find Gradient ( css Prop ) { var value = css Prop . value ( ) ; var gradient = null ; var matched Part = _ . find ( css Prop . value Parts ( ) , function ( part ) { return gradient = module . parse ( part . substring ( value ) ) ; } ) ; if ( matched Part & & gradient ) { return { gradient : gradient , value Range : matched Part } ; } return null ; } 
function expand Gradient Outside Value ( editor , syntax ) { var property Name = prefs . get ( 'css .gradient .default Property ' ) ; if ( ! property Name ) return false ; 
function find Gradient From Position ( content , pos ) { var css Prop = null ; var css Rule = require ( 'css Edit Tree ' ) . parse From Position ( content , pos , true ) ; if ( css Rule ) { css Prop = css Rule . item From Position ( pos , true ) ; if ( ! css Prop ) { 
function ( gradient ) { var result = null ; require ( 'utils ' ) . trim ( gradient ) . replace ( / ^ ( [ \w \ - ] + ) \ ( ( . + ? ) \ ) $ / , function ( str , type , definition ) { 
function ( gradient ) { if ( _ . is String ( gradient ) ) gradient = this . parse ( gradient ) ; if ( ! gradient ) return null ; var color Stops = _ . map ( gradient . color Stops , _ . clone ) ; 
function ( gradient , prefix ) { if ( gradient . type = = 'linear ' ) { var fn = ( prefix ? ' - ' + prefix + ' - ' : ' ' ) + 'linear -gradient ' ; 
function ( regexp , fn , options ) { if ( _ . is String ( regexp ) ) regexp = new Reg Exp ( regexp ) ; generators . add ( function ( node , syntax ) { var m ; if ( ( m = regexp . exec ( node . name ( ) ) ) ) { return fn ( m , node , syntax ) ; } return null ; } , options ) ; } 
function ( name , collection ) { if ( ! element Types [ collection ] ) element Types [ collection ] = [ ] ; var col = this . get Collection ( collection ) ; if ( ! _ . include ( col , name ) ) col . push ( name ) ; } 
function ( name , collection ) { if ( collection in element Types ) { element Types [ collection ] = _ . without ( this . get Collection ( collection ) , name ) ; } } 
function process Class Name ( name , item ) { name = transform Class Name ( name , item , 'element ' ) ; name = transform Class Name ( name , item , 'modifier ' ) ; 
function process ( tree , profile ) { if ( tree . name ) bem Parse ( tree , profile ) ; var abbr Utils = require ( 'abbreviation Utils ' ) ; _ . each ( tree . children , function ( item ) { process ( item , profile ) ; if ( ! abbr Utils . is Snippet ( item ) & & item . start ) should Run Html Filter = true ; } ) ; return tree ; } 
function get Indentation ( node ) { if ( _ . include ( prefs . get Array ( 'format .no Indent Tags ' ) | | [ ] , node . name ( ) ) ) { return ' ' ; } return require ( 'resources ' ) . get Variable ( 'indentation ' ) ; } 
function process Snippet ( item , profile , level ) { item . start = item . end = ' ' ; if ( ! is Very First Child ( item ) & & profile . tag _nl ! = = false & & should Add Line Break ( item , profile ) ) { 
function should Break Inside Inline ( node , profile ) { var abbr Utils = require ( 'abbreviation Utils ' ) ; var has Block Elems = _ . any ( node . children , function ( child ) { if ( abbr Utils . is Snippet ( child ) ) return false ; return ! abbr Utils . is Inline ( child ) ; } ) ; if ( ! has Block Elems ) { return should Format Inline ( node , profile ) ; } return true ; } 
function process Tag ( item , profile , level ) { item . start = item . end = placeholder ; var utils = require ( 'utils ' ) ; var abbr Utils = require ( 'abbreviation Utils ' ) ; var is Unary = abbr Utils . is Unary ( item ) ; var nl = utils . get Newline ( ) ; var indent = get Indentation ( item ) ; 
function make Attributes String ( tag , profile ) { var attrs = ' ' ; var other Attrs = [ ] ; var attr Quote = profile . attribute Quote ( ) ; var cursor = profile . cursor ( ) ; _ . each ( tag . attribute List ( ) , function ( a ) { var attr Name = profile . attribute Name ( a . name ) ; switch ( attr Name . to Lower Case ( ) ) { 
function process Tag ( item , profile , level ) { if ( ! item . parent ) 
function make Attributes String ( node , profile ) { var attr Quote = profile . attribute Quote ( ) ; var cursor = profile . cursor ( ) ; return _ . map ( node . attribute List ( ) , function ( a ) { var attr Name = profile . attribute Name ( a . name ) ; return ' ' + attr Name + ' = ' + attr Quote + ( a . value | | cursor ) + attr Quote ; } ) . join ( ' ' ) ; } 
function insert Commas ( words ) { var len = words . length ; var total Commas = 0 ; if ( len > 3 & & len < = 6 ) { total Commas = randint ( 0 , 1 ) ; } else if ( len > 6 & & len < = 1 2 ) { total Commas = randint ( 0 , 2 ) ; } else { total Commas = randint ( 1 , 4 ) ; } _ . each ( _ . range ( total Commas ) , function ( ix ) { if ( ix < words . length - 1 ) { words [ ix ] + = ' , ' ; } } ) ; } 
function ( lang , data ) { if ( _ . is String ( data ) ) { data = { words : _ . compact ( data . split ( ' ' ) ) } ; } else if ( _ . is Array ( data ) ) { data = { words : data } ; } langs [ lang ] = data ; } 
function ( err , res ) { if ( err ) return sender . emit ( 'transmission Error ' , err , data . channel URI ) ; sender . emit ( 'transmitted ' , res , data . channel URI ) ; } 
function sanitize ( sender , data ) { data = _ . defaults ( { } , { client _id : sender . client _id , client _secret : sender . client _secret } , data ) ; return _ . reduce ( data , function ( acc , value , key ) { if ( ! _ . is Undefined ( value ) ) { acc [ key ] = value ; } return acc ; } , { } ) ; } 
function get Missing Props ( data ) { var contains Key = _ . partial ( _ . contains , _ . keys ( data ) ) ; return _ . filter ( required , function ( req ) { return ! contains Key ( req ) ; } ) ; } 
function send Required Errors ( sender , missing Props ) { _ . for Each ( missing Props , function ( prop ) { sender . emit ( 'error ' , prop + ' is missing ' ) ; } ) ; } 
function Sender ( options ) { Event Emitter . call ( this ) ; _ . extend ( this , _ . defaults ( options | | { } , { retries : 4 } ) ) ; } 
function filter Out Meta With Id ( metas ) { metas = Array . prototype . slice . call ( metas | | [ ] ) ; return metas . filter ( function ( meta ) { return ! meta . id ; } ) ; } 
function append Child ( parent , childrens ) { if ( childrens . length = = = undefined ) childrens = [ childrens ] ; var doc Frag = document . create Document Fragment ( ) ; 
function get Logical Partitions ( disk , index , offset , extended Partition Offset , limit ) { return _ _awaiter ( this , void 0 , void 0 , function * ( ) { if ( extended Partition Offset = = = undefined ) { extended Partition Offset = offset ; } if ( limit = = = undefined ) { limit = Infinity ; } const result = [ ] ; if ( limit < = 0 ) { return result ; } const buf = yield read From Disk ( disk , offset , MBR _SIZE ) ; for ( const p of get Partitions From MBRBuf ( buf ) ) { if ( ! p . extended ) { result . push ( mbr Partition Dict ( p , offset , index ) ) ; } else if ( limit > 0 ) { const logical Partitions = yield get Logical Partitions ( disk , index + 1 , extended Partition Offset + p . byte Offset ( ) , extended Partition Offset , limit - 1 ) ; result . push ( . . . logical Partitions ) ; return result ; } } return result ; } ) ; } 
function get Partitions ( disk , { offset = 0 , include Extended = true , get Logical = true , } = { offset : 0 , include Extended : true , get Logical : true , } ) { return _ _awaiter ( this , void 0 , void 0 , function * ( ) { return yield call With Disk ( get Disk Partitions , disk , { offset , include Extended , get Logical , } ) ; } ) ; } 
function mejs Compile ( mejs File , options ) { options = options | | { } if ( typeof mejs File = = = 'string ' ) { options . mini = false mejs File = mejs Compile . precompile From Glob ( mejs File , options ) } if ( ! ( mejs File instanceof File ) ) throw new Type Error ( String ( mejs File ) + ' is not File object ' ) const sandbox = options . sandbox | | { console : console } sandbox . module = { exports : { } } run In New Context ( mejs File . contents . to String ( ) , sandbox , { filename : mejs File . path } ) return sandbox . module . exports } 
function process Template ( template , variables ) { for ( let variable Name of Object . keys ( variables ) ) { let value = variables [ variable Name ] ; template = replace Variable ( template , variable Name , value ) ; } template = evaluate Conditions ( template , variables ) ; return template ; } 
function replace Variable ( template , name , value ) { let key = ` $ { name } ` ; let reg = new Reg Exp ( helper . escape Reg Exp ( key ) , 'g ' ) ; let encoded Reg = new Reg Exp ( helper . escape Reg Exp ( ` $ { name } ` ) , 'g ' ) ; let encoded Value = JSON . stringify ( value ) . replace ( / < \ /script / gi , ' < \ \ /script ' ) ; return template . replace ( reg , value ) . replace ( encoded Reg , encoded Value ) ; } 
function evaluate Conditions ( template , variables ) { let source ; do { source = template ; template = process Simple Conditions ( template , variables ) ; template = process If Else Conditions ( template , variables ) ; } while ( source ! = = template ) ; return template ; } 
function process Condition ( template , variables , matcher ) { 
function evaluate Condition ( condition Code , variables ) { let trimmed Condition = condition Code . trim ( ) ; if ( $Debug ) { if ( ! / ^ ! ? ( ' [ ^ ' ] * ' | " [ ^ " ] * " ) $ / . test ( trimmed Condition ) ) { throw new Error ( 'Invalid expected value : ' + trimmed Condition ) ; } } let negate = trimmed Condition . char At ( 0 ) = = = ' ! ' ; let expected Value = trimmed Condition . slice ( negate ? 2 : 1 , - 1 ) ; return negate ? expected Value ! = = variables . $Env : expected Value = = = variables . $Env ; } 
function default Key Generator ( request ) { let protocol = request . protocol ; let host = request . get ( 'Host ' ) ; let url = request . original Url ; return protocol + ' : ' + host + url ; } 
function get Orders Statistics ( metric Keys = [ 'item _sold _minecraft ' , 'prepaid _card _redeemed _minecraft ' ] ) { return fetch ( ` $ { CORE _API } ` , { method : 'POST ' , body : JSON . stringify ( { metric Keys } ) , headers : { 'user -agent ' : USER _AGENT , 'content -type ' : 'application /json ' , 'accept ' : 'application /json ' } } ) . then ( handle Errors ) . then ( res = > res . json ( ) ) } 
function signout ( { username , password } ) { return fetch ( ` $ { YGGDRASIL _API } ` , { method : 'POST ' , body : JSON . stringify ( { username , password } ) , headers : { 'user -agent ' : USER _AGENT , 'content -type ' : 'application /json ' , 'accept ' : 'application /json ' } } ) . then ( handle Errors ) . then ( res = > null ) } 
function lookup Profiles ( names , agent = 'minecraft ' ) { return fetch ( ` $ { CORE _API } $ { agent } ` , { method : 'POST ' , body : JSON . stringify ( names ) , headers : { 'user -agent ' : USER _AGENT , 'content -type ' : 'application /json ' , 'accept ' : 'application /json ' } } ) . then ( handle Errors ) . then ( res = > res . json ( ) ) } 
function get Session ( profile Id ) { return fetch ( ` $ { SESSION _API } $ { profile Id } ` , { headers : { 'user -agent ' : USER _AGENT , 'accept ' : 'application /json ' } } ) . then ( handle Errors ) . then ( res = > { if ( res . status = = = 2 0 4 ) throw new Error ( 'no such profile ' ) return res . json ( ) } ) . then ( ( { id , name , properties } ) = > { const { timestamp , textures } = JSON . parse ( Base 6 4 . decode ( properties [ 0 ] . value ) ) const { SKIN , CAPE } = textures return { id , name , timestamp , skin : SKIN & & SKIN . url , cape : CAPE & & CAPE . url , is Slim : SKIN & & SKIN . metadata & & SKIN . metadata . model = = = 'slim ' } } ) } 
function refresh ( { access Token , client Token , selected Profile } ) { return fetch ( ` $ { YGGDRASIL _API } ` , { method : 'POST ' , body : JSON . stringify ( { access Token , client Token , selected Profile , request User : true } ) , headers : { 'user -agent ' : USER _AGENT , 'content -type ' : 'application /json ' , 'accept ' : 'application /json ' } } ) . then ( handle Errors ) . then ( res = > res . json ( ) ) } 
function upload Skin ( { access Token } , profile Id , file , is Slim = false ) { const form = new Form Data ( ) form . append ( 'model ' , is Slim ? 'slim ' : ' ' ) form . append ( 'file ' , file ) return fetch ( ` $ { CORE _API } $ { profile Id } ` , { method : 'PUT ' , body : form , headers : { 'user -agent ' : USER _AGENT , 'authorization ' : ` $ { access Token } ` } } ) . then ( handle Errors ) . then ( res = > null ) } 
function get User ( { access Token } ) { return fetch ( ` $ { CORE _API } ` , { headers : { 'user -agent ' : USER _AGENT , 'authorization ' : ` $ { access Token } ` , 'accept ' : 'application /json ' } } ) . then ( handle Errors ) . then ( res = > res . json ( ) ) } 
function invalidate ( { access Token , client Token } ) { return fetch ( ` $ { YGGDRASIL _API } ` , { method : 'POST ' , body : JSON . stringify ( { access Token , client Token } ) , headers : { 'user -agent ' : USER _AGENT , 'content -type ' : 'application /json ' } } ) . then ( handle Errors ) . then ( res = > null ) } 
function get User Cape Data ( { access Token } , profile Id ) { return fetch ( ` $ { CORE _API } $ { profile Id } ` , { headers : { 'user -agent ' : USER _AGENT , 'authorization ' : ` $ { access Token } ` , 'accept ' : 'application /json ' } } ) . then ( handle Errors ) . then ( res = > res . json ( ) ) } 
function get Blocked Servers ( ) { return fetch ( ` $ { SESSION _API } ` , { headers : { 'user -agent ' : USER _AGENT } } ) . then ( handle Errors ) . then ( res = > res . text ( ) ) . then ( text = > text . split ( ' \n ' ) . slice ( 0 , - 1 ) ) } 
function status ( ) { return fetch ( ` $ { STATUS _API } ` , { headers : { 'user -agent ' : USER _AGENT , 'accept ' : 'application /json ' } } ) . then ( handle Errors ) 
function get Profile History ( profile Id ) { 
function authenticate ( { username , password , client Token , agent } ) { return fetch ( ` $ { YGGDRASIL _API } ` , { method : 'POST ' , body : JSON . stringify ( { agent , username , password , client Token , request User : true } ) , headers : { 'user -agent ' : USER _AGENT , 'Content -Type ' : 'application /json ' , 'accept ' : 'application /json ' } } ) . then ( handle Errors ) . then ( res = > res . json ( ) ) } 
function is Valid ( { access Token , client Token } ) { return fetch ( ` $ { YGGDRASIL _API } ` , { method : 'POST ' , body : JSON . stringify ( { access Token , client Token } ) , headers : { 'user -agent ' : USER _AGENT , 'content -type ' : 'application /json ' } } ) . then ( handle Errors ) . then ( res = > true ) . catch ( err = > { if ( err . message = = = 'Invalid token ' ) return false throw err } ) } 
function lookup Profile At ( name , date , agent = 'minecraft ' ) { const has Date = typeof date ! = = 'undefined ' const query = has Date ? ` $ { agent } $ { name } $ { date } ` : ` $ { agent } $ { name } ` return fetch ( ` $ { CORE _API } $ { query } ` , { headers : { 'user -agent ' : USER _AGENT , 'accept ' : 'application /json ' } } ) . then ( handle Errors ) . then ( res = > { if ( res . status = = = 2 0 4 ) throw new Error ( ` $ { name } ` ) return res . json ( ) } ) } 
function set Skin ( { access Token } , profile Id , skin Url , is Slim = false ) { const params = new URLSearch Params ( ) params . append ( 'model ' , is Slim ? 'slim ' : ' ' ) params . append ( 'url ' , skin Url ) return fetch ( ` $ { CORE _API } $ { profile Id } ` , { method : 'POST ' , body : params , headers : { 'user -agent ' : USER _AGENT , 'authorization ' : ` $ { access Token } ` } } ) . then ( handle Errors ) . then ( res = > null ) } 
function is Secure ( { access Token } ) { return fetch ( ` $ { CORE _API } ` , { headers : { 'user -agent ' : USER _AGENT , 'authorization ' : ` $ { access Token } ` } } ) . then ( handle Errors ) . then ( res = > { 
function answer Challenges ( { access Token } , answers ) { return fetch ( ` $ { CORE _API } ` , { method : 'POST ' , body : JSON . stringify ( answers ) , 
function reset Skin ( { access Token } , profile Id ) { return fetch ( ` $ { CORE _API } $ { profile Id } ` , { method : 'DELETE ' , headers : { 'user -agent ' : USER _AGENT , 'authorization ' : ` $ { access Token } ` } } ) . then ( handle Errors ) . then ( res = > null ) } 
function coerce Controller Alias ( property ) { return computed ( property , { get ( ) { let controller Name = this . get ( 'controller Name ' ) | | this . get ( 'route Name ' ) ; let controller = this . get ( 'controller ' ) | | this . controller For ( controller Name ) ; return controller . get ( property ) ; } , set ( key , value ) { let controller Name = this . get ( 'controller Name ' ) | | this . get ( 'route Name ' ) ; let controller = this . get ( 'controller ' ) | | this . controller For ( controller Name ) ; controller . set ( property , value ) ; return value ; } } ) ; } 
function encode ( ) { var data = this . data ; var length = 1 1 ; var sender = this . sender ; var target = this . target ; var header = new Buffer ( 9 ) ; var content = ! data | | is Buffer ( data ) ? data : this . encode ( data ) ; if ( content ) length + = content . length ; header . write UInt 8 ( length , 0 ) ; header . write UInt 8 ( sender . subnet , 1 ) ; header . write UInt 8 ( sender . id , 2 ) ; header . write UInt 1 6BE ( sender . type , 3 ) ; header . write UInt 1 6BE ( this . code , 5 ) ; header . write UInt 8 ( target . subnet , 7 ) ; header . write UInt 8 ( target . id , 8 ) ; return content ? Buffer . concat ( [ header , content ] ) : header ; } 
function is Valid ( message ) { if ( ! Constants . equals ( message . slice ( 4 , 1 6 ) ) ) return false ; var checksum = message . read UInt 1 6BE ( message . length - 2 ) ; return checksum = = = crc ( message . slice ( 1 6 , - 2 ) ) ; } 
function source ( message ) { var ip = [ ] ; for ( var i = 0 ; i < 4 ; i + + ) ip . push ( message [ i ] ) ; return ip . join ( ' . ' ) ; } 
function parse ( resource ) { if ( typeof resource = = = 'object ' ) return resource ; var config = url . parse ( resource ) ; return { port : config . port , device : config . auth , gateway : config . hostname } ; } 
function get Component Descendants ( root , component , only Children , include Self ) { var node = rquery _get DOMNode ( component ) , descendants = [ ] ; if ( only Children ) { descendants = node . children ; } else { descendants = node . get Elements By Tag Name ( ' * ' ) ; } 
function Html ( args ) { this . _vm = null ; if ( debug Mode & & ! is Browser ) { this . _vm = require ( 'vm ' ) ; this . _sandbox = Object . create ( null ) ; this . _vm . create Context ( this . _sandbox ) ; } 
function flush Deferred Padding ( blocks ) { if ( ! padding ) return ; let prev Block = blocks [ blocks . length - 2 ] ; prev Block . text + = padding ; } 
function read Config ( config ) { if ( us . is String ( config ) ) { if ( ! fs . exists Sync ( config ) ) { throw 'place give in a sprite config or config file ! ' ; } var content = fs . read File Sync ( config ) . to String ( ) ; config = z Tool . json Parse ( content ) ; } else if ( us . is Array ( config ) ) { config = { input : config } ; } config = config | | { } ; 
function adjust Old Property ( config ) { if ( ! config . input . css Source & & 'css Root ' in config . input ) { config . input . css Source = config . input . css Root ; delete config . input . css Root ; } if ( ! config . output . css Dist & & 'css Root ' in config . output ) { config . output . css Dist = config . output . css Root ; delete config . output . css Root ; } if ( ! config . output . image Dist & & 'image Root ' in config . output ) { config . output . image Dist = config . output . image Root ; delete config . output . image Root ; } if ( ! config . output . max Single Size & & 'max Size ' in config . output ) { config . output . max Single Size = config . output . max Size ; delete config . output . max Size ; } return config ; } 
function read Style Sheet ( file Name ) { file Name = path . join ( sprite Config . workspace , file Name ) ; if ( ! fs . exists Sync ( file Name ) ) { return null ; } var content = fs . read File Sync ( file Name ) ; var style Sheet = CSSOM . parse ( content . to String ( ) ) ; return style Sheet ; } 
function ( ) { var background , value ; if ( ! this [ 'background ' ] ) { 
function ( ) { var background = ' ' , style = this ; if ( style . get Property Value ( 'background ' ) ) { return ; } var position Text = this . remove Property ( 'background -position -x ' ) + ' ' + this . remove Property ( 'background -position -y ' ) ; style . set Property ( 'background -position ' , position Text . trim ( ) , null ) ; var to Merge Attrs = [ 'background -color ' , 'background -image ' , 'background -position ' , 'background -repeat ' , 'background -attachment ' , 'background -origin ' , 'background -clip ' ] ; for ( var i = 0 , item ; item = to Merge Attrs [ i ] ; i + + ) { if ( style . has Own Property ( item ) ) { background + = this . remove Property ( item ) + ' ' ; } } if ( background . trim ( ) ) { style . set Property ( 'background ' , background . trim ( ) , null ) ; } } 
function ( obj , override ) { for ( var i in obj ) { if ( us . is Function ( obj [ i ] ) ) { continue ; } else if ( this [ i ] & & ! override ) { continue ; } this . set Property ( i , obj [ i ] , null ) ; } } 
function collect Style Rules ( style Sheet , result , style Sheet Url ) { if ( ! result ) { result = { * typeof style = = = 'CSSStyle Declaration ' * 给 style 对 象 扩 展 基 本 的 方 法 * / var style = us . extend ( rule . style , Base CSSStyle Declaration ) ; if ( style [ 'background -size ' ] ) { return ; } if ( style [ 'background ' ] ) { * background 定 位 是 right center bottom 的 图 片 不 合 并 * 因 为 这 三 个 的 定 位 方 式 比 较 特 殊 , 浏 览 器 有 个 自 动 适 应 的 特 性 * 把 刚 刚 拆 分 的 background 属 性 合 并 并 返 回 * / style . merge Backgound ( ) ; return ; } if ( regexp . ignore Repeat . test ( style [ 'background -repeat ' ] ) | | regexp . ignore Repeat . test ( style [ 'background -repeat -x ' ] ) | | regexp . ignore Repeat . test ( style [ 'background -repeat -y ' ] ) ) { 
function get Image Url ( style , dir ) { var format = sprite Config . input . format , ignore Images = sprite Config . input . ignore Images , background Image = style [ 'background -image ' ] , url = null , ext , match ; if ( ! background Image ) { return null ; } if ( background Image . index Of ( ' , ' ) > - 1 ) { 
function read Images Info ( style Obj List , on Done ) { 
function read Image Info ( file Name , callback ) { file Name = path . join ( sprite Config . workspace , file Name ) ; fs . create Read Stream ( file Name ) . pipe ( new PNG ( ) ) . on ( 'parsed ' , function ( ) { var image Info = { image : this , width : this . width , height : this . height } ; get Image Size ( this , function ( size ) { image Info . size = size ; callback ( image Info ) ; } ) ; } ) . on ( 'error ' , function ( e ) { info ( ' > >Skip : ' + e . message + ' of " ' + file Name + ' " ' ) ; callback ( null ) ; } ) ; } 
function get Image Size ( image , callback ) { var size = 0 ; image . pack ( ) . on ( 'data ' , function ( chunk ) { size + = chunk . length ; } ) . on ( 'end ' , function ( ) { callback ( size ) ; } ) ; } 
function set Image Width Height ( style Obj , image Info ) { var w = 0 , h = 0 , mw = image Info . width , mh = image Info . height ; * 最 后 的 大 小 还 要 加 上 config 中 配 置 的 margin 值 * 这 里 之 所 以 用 w / h 来 表 示 宽 高 , 而 不 是 用 with / height * 是 因 为 packer 算 法 限 定 死 了 , 值 读 取 传 入 元 素 的 w / h 值 * / style Obj . w = mw + sprite Config . output . margin ; style Obj . h = mh + sprite Config . output . margin ; } 
function position Images ( style Obj List ) { var style Obj , sprite Array = [ ] , arr = [ ] , exist Arr = [ ] , * 限 制 图 片 大 小 的 算 法 是 : * 1 . 先 把 图 片 按 从 大 到 小 排 序 * 2 . 顺 序 叠 加 图 片 size , 超 过max Size 时 , 另 起 一 个 数 组 * 3 . 最 终 把 一 个 数 组 , 拆 成 N 个 总 szie 小 于 max Size 的 数 组 * / arr . sort ( function ( a , b ) { return b . image Info . size - a . image Info . size ; } ) ; var total = 0 , ret = [ ] ; arr . for Each ( function ( style Obj ) { total + = style Obj . image Info . size ; if ( total > max Size ) { if ( ret . length ) { * packer 算 法 需 要 把 最 大 的 一 个 放 在 首 位 . . . * 排 序 算 法 会 对 结 果 造 成 比 较 大 的 影 响 * / arr . sort ( function ( a , b ) { return b . w * b . h - a . w * a . h ; } ) ; * root 的 值 就 是 packer 定 位 的 结 果 * root .w / root .h 表 示 图 片 排 列 后 的 总 宽 高 * 各 个 小 图 片 的 坐 标 这 在 arr 的 元 素 中 , 新 增 了 一 个 fit 属 性 * fit .x / fit .y 表 示 定 位 后 元 素 的 坐 标 * / arr . root = packer . root ; } ) ; if ( exist Arr . length ) { sprite Array . push ( exist Arr ) ; } return sprite Array ; } 
function draw Image And Position Background ( sprite Task , callback ) { var combined Css Rules , sprite Array = sprite Task . sprite Array , fileversion = sprite Task . fileversion ; * 若 最 后 一 个 元 素 , 没 有root 属 性 , 说 明 它 的 样 式 都 是 复 用 已 合 并 的 图 片 的 , * 直 接 替 换 样 式 即 可 * / var style Obj Arr = sprite Array . pop ( ) ; style Obj Arr . for Each ( function ( style Obj ) { var image Info = style Obj . image Info , image Name = image Info . image Name ; style Obj . fit = image Info . fit ; if ( ! combined Css Rules [ image Name ] ) { combined Css Rules [ image Name ] = [ ] ; } 
function create Png ( width , height ) { var png = new PNG ( { width : width , height : height } ) ; for ( var y = 0 ; y < png . height ; y + + ) { for ( var x = 0 ; x < png . width ; x + + ) { var idx = ( png . width * y + x ) < < 2 ; png . data [ idx ] = 0 ; png . data [ idx + 1 ] = 0 ; png . data [ idx + 2 ] = 0 ; png . data [ idx + 3 ] = 0 ; } } return png ; } 
function create Sprite Image Name ( css File Name , index , total ) { var name = ' ' ; if ( css File Name ) { 
function replace And Position Background ( image Name , style Obj , combined Selectors , fileversion ) { style Obj . css Rules . for Each ( function ( style ) { if ( sprite Config . output . combine CSSRule ) { 
function set Px Value ( style , attr , new Value ) { var value ; if ( style [ attr ] ) { value = parse Int ( style [ attr ] ) ; } else { value = 0 ; style [ style . length + + ] = attr ; } value = value - new Value ; value = value ? value + 'px ' : ' 0 ' ; style [ attr ] = value ; } 
function combine Sprite Tasks ( sprite Task Array ) { var combined Style Sheet Array = [ ] , combined Style Obj List = { length : 0 } , combined File Name , combined Sprite Task ; 
function export Css File ( sprite Task ) { var css Content List = [ ] , style Sheet Array = sprite Task . style Sheet Array , css Content = ' ' , compress Options = sprite Config . output . compress , file Name , file Name 2 , 
function style Sheet To String ( style Sheet ) { var result = " " ; var rules = style Sheet . css Rules , rule ; for ( var i = 0 ; i < rules . length ; i + + ) { rule = rules [ i ] ; if ( rule instanceof CSSOM . CSSImport Rule ) { result + = style Sheet To String ( rule . style Sheet ) + ' \n ' ; } else { result + = rule . css Text + ' \n ' ; } } return result ; } 
function Proposer ( paxos , promise ) { this . _paxos = paxos this . collapsed = true this . promise = Monotonic . increment ( promise , 0 ) this . proposals = [ ] this . register = { body : { promise : paxos . log . head . body . promise , body : paxos . log . head . body . body , previous : paxos . log . head . body . previous } , previous : null } this . proposal = null } 
function Paxos ( now , id , options ) { assert ( arguments . length = = 3 ) 
function Recorder ( paxos ) { var entry = paxos . log . head . body this . register = { body : { promise : entry . promise , body : entry . body , previous : entry . previous } , previous : null } this . _paxos = paxos } 
function Shaper ( parliament Size , government , recovered ) { this . _parliament Size = government . majority . length * 2 - 1 this . _should Expand = parliament Size ! = this . _parliament Size this . _government = government this . _seen = { } this . _expandable = [ ] this . _arriving = [ ] this . decided = false this . _governments = [ ] this . outbox = { } this . _representative = null this . _should Naturalize = this . _government . majority . length + this . _government . minority . length + this . _government . constituents . length ! = this . _government . acclimated . length this . _should Recover ( recovered ) | | this . _should Contract ( ) } 
function track ( event , properties ) { RNSensors Analytics & & RNSensors Analytics . track & & RNSensors Analytics . track ( event , properties ) ; } 
function track End ( event , properties ) { RNSensors Analytics & & RNSensors Analytics . track End & & RNSensors Analytics . track End ( event , properties ) ; } 
function track Installation ( event , properties = null ) { RNSensors Analytics & & RNSensors Analytics . track Installation & & RNSensors Analytics . track Installation ( event , properties ) ; } 
function ( ) { 
function ( target , handler ) { 
function ( target ) { if ( typeof Array . prototype . filter ! = "function " ) { console . log ( "Your browser doesn 't support Array filter , untrack disabled " ) ; return ; } 
function ( e ) { e . data . handler . over = true ; $ . iframe Tracker . retrieve Focus ( ) ; try { e . data . handler . over Callback ( this , e ) ; } catch ( ex ) { } } 
function ( e ) { e . data . handler . over = false ; $ . iframe Tracker . retrieve Focus ( ) ; try { e . data . handler . out Callback ( this , e ) ; } catch ( ex ) { } } 
function ( ) { if ( document . active Element & & document . active Element . tag Name = = = "IFRAME " ) { $ . iframe Tracker . focus Retriever . focus ( ) ; $ . iframe Tracker . focus Retrieved = true ; } } 
function ( e ) { for ( var i in this . handlers List ) { if ( this . handlers List [ i ] . over = = = true ) { try { this . handlers List [ i ] . blur Callback ( e ) ; } catch ( ex ) { } } } } 
function func With Return From Snippet ( js ) { 
function parse Argv ( argv ) { var parsed = { args : [ ] , help : false , color : null , paginate : null , output Mode : OM _LONG , json Indent : 2 , level : null , strict : false , pids : null , pids Type : null , time Format : TIME _UTC 
function handle Log Line ( file , line , opts , stylize ) { curr Line = line ; 
function emit Record ( rec , line , opts , stylize ) { var short = false ; switch ( opts . output Mode ) { case OM _SHORT : short = true ; case OM _LONG : * `client _req ` is the typical field name for an *HTTP client request * object * serialized by the restify -clients library . Render the * client request somewhat like `curl ` debug output shows it . * / if ( rec . client _req & & typeof ( rec . client _req ) = = = 'object ' ) { var client _req = rec . client _req ; delete rec . client _req ; var headers = client _req . headers ; delete client _req . headers ; var host Header Line = ' ' ; if ( ! headers | | ! ( Object . has Own Property . call ( headers , 'host ' ) | | Object . has Own Property . call ( headers , 'Host ' ) | | Object . has Own Property . call ( headers , 'HOST ' ) ) ) { if ( Object . has Own Property . call ( client _req , 'address ' ) ) { host Header Line = ' \n Host : ' + client _req . address ; if ( Object . has Own Property . call ( client _req , 'port ' ) ) { * Handle `res .header ` or `res .headers ` as either a string or * an object of header key /value pairs . Prefer `res .header ` if set , * because that 's what Bunyan 's own `res ` serializer specifies , * because that 's the value in Node .js 's core HTTP server response * implementation that has all the implicit headers . * * Note : `res .header ` (string ) typically includes the 'HTTP / 1 . 1 . . . ' * status line . * / var header Types = { string : true , object : true } ; var headers ; var headers Str = ' ' ; var headers Have Status Line = false ; if ( res . header & & header Types [ typeof ( res . header ) ] ) { headers = res . header ; delete res . header ; } else if ( res . headers & & header Types [ typeof ( res . headers ) ] ) { headers = res . headers ; delete res . headers ; } if ( headers = = = undefined ) { } else if ( typeof ( headers ) = = = 'string ' ) { headers Str = headers . trim Right ( ) ; * Add a 'HTTP / 1 . 1 . . . ' status line if the headers didn 't already * include it . * / if ( ! headers Have Status Line & & res . status Code ! = = undefined ) { s + = format ( 'HTTP / 1 . 1 %s %s \n ' , res . status Code , http . STATUS _CODES [ res . status Code ] ) ; } delete res . status Code ; s + = headers Str ; if ( res . body ! = = undefined ) { var body = ( typeof ( res . body ) = = = 'object ' ? JSON . stringify ( res . body , null , 2 ) : res . body ) ; if ( body . length > 0 ) { s + = ' \n \n ' + body } ; delete res . body ; } else { s = s . trim Right ( ) ; } if ( res . trailer ) { s + = ' \n ' + res . trailer ; } delete res . trailer ; if ( s ) { details . push ( indent ( s ) ) ; } / / E .g . for extra 'foo ' field on 'res ' , add 'res .foo ' at / / top -level . This *does * have the potential to stomp on a / / literal 'res .foo ' key . Object . keys ( res ) . for Each ( function ( k ) { rec [ 'res . ' + k ] = res [ k ] ; } ) ; } if ( rec . res & & typeof ( rec . res ) = = = 'object ' ) { _res ( rec . res ) ; delete rec . res ; } if ( rec . client _res & & typeof ( rec . client _res ) = = = 'object ' ) { _res ( rec . client _res ) ; delete rec . client _res ; } if ( rec . err & & rec . err . stack ) { var err = rec . err if ( typeof ( err . stack ) ! = = 'string ' ) { details . push ( indent ( err . stack . to String ( ) ) ) ; } else { details . push ( indent ( err . stack ) ) ; } delete err . message ; delete err . name ; delete err . stack ; / / E .g . for extra 'foo ' field on 'err ' , add 'err .foo ' at / / top -level . This *does * have the potential to stomp on a / / literal 'err .foo ' key . Object . keys ( err ) . for Each ( function ( k ) { rec [ 'err . ' + k ] = err [ k ] ; } ) delete rec . err ; } var leftover = Object . keys ( rec ) ; for ( var i = 0 ; i < leftover . length ; i + + ) { var key = leftover [ i ] ; var value = rec [ key ] ; var stringified = false ; if ( typeof ( value ) ! = = 'string ' ) { value = JSON . stringify ( value , null , 2 ) ; stringified = true ; } if ( value . index Of ( ' \n ' ) ! = = - 1 | | value . length > 5 0 ) { details . push ( indent ( key + ' : ' + value ) ) ; } else if ( ! stringified & & ( value . index Of ( ' ' ) ! = - 1 | | value . length = = = 0 ) ) { extras . push ( key + ' = ' + JSON . stringify ( value ) ) ; } else { extras . push ( key + ' = ' + value ) ; } } extras = stylize ( ( extras . length ? ' ( ' + extras . join ( ' , ' ) + ' ) ' : ' ' ) , 'none ' ) ; details = stylize ( ( details . length ? details . join ( ' \n - - \n ' ) + ' \n ' : ' ' ) , 'none ' ) ; if ( ! short ) emit ( format ( ' %s %s : %s on %s %s : %s %s \n %s ' , time , level , name Str , hostname | | ' <no -hostname > ' , src , oneline Msg , extras , details ) ) ; else emit ( format ( ' %s %s %s : %s %s \n %s ' , time , level , name Str , oneline Msg , extras , details ) ) ; break ; case OM _INSPECT : emit ( util . inspect ( rec , false , Infinity , true ) + ' \n ' ) ; break ; case OM _BUNYAN : emit ( JSON . stringify ( rec , null , 0 ) + ' \n ' ) ; break ; case OM _JSON : emit ( JSON . stringify ( rec , null , opts . json Indent ) + ' \n ' ) ; break ; case OM _SIMPLE : / * JSSTYLED * / / / <http : / /logging .apache .org /log 4j / 1 . 2 /apidocs /org /apache /log 4j /Simple Layout .html > if ( ! is Valid Record ( rec ) ) { return emit ( line + ' \n ' ) ; } emit ( format ( ' %s - %s \n ' , upper Name From Level [ rec . level ] | | 'LVL ' + rec . level , rec . msg ) ) ; break ; default : throw new Error ( 'unknown output mode : ' + opts . output Mode ) ; } } 
function drain Stdout And Exit ( code ) { if ( _DEBUG ) warn ( ' (drain Stdout And Exit ( %d ) ) ' , code ) ; stdout . on ( 'drain ' , function ( ) { cleanup And Exit ( code ) ; } ) ; if ( stdout Flushed ) { cleanup And Exit ( code ) ; } } 
function process Stdin ( opts , stylize , callback ) { var leftover = ' ' ; 
function process Pids ( opts , stylize , callback ) { var leftover = ' ' ; * Get the PIDs to dtrace . * * @param cb {Function } `function (err Code , pids ) ` * / function get Pids ( cb ) { if ( opts . pids Type = = = 'num ' ) { return cb ( null , opts . pids ) ; } if ( process . platform = = = 'sunos ' ) { exec File ( ' /bin /pgrep ' , [ ' -lf ' , opts . pids ] , function ( pids Err , stdout , stderr ) { if ( pids Err ) { warn ( 'bunyan : error getting PIDs for " %s " : %s \n %s \n %s ' , opts . pids , pids Err . message , stdout , stderr ) ; return cb ( 1 ) ; } var pids = stdout . trim ( ) . split ( ' \n ' ) . map ( function ( line ) { return line . trim ( ) . split ( / \s + / ) [ 0 ] } ) . filter ( function ( pid ) { return Number ( pid ) ! = = process . pid } ) ; if ( pids . length = = = 0 ) { warn ( 'bunyan : error : no matching PIDs found for " %s " ' , opts . pids ) ; return cb ( 2 ) ; } cb ( null , pids ) ; } ) ; } else { var regex = opts . pids ; if ( regex & & / [a -z A -Z 0 - 9 _ ] / . test ( regex [ 0 ] ) ) { 
function get Pids ( cb ) { if ( opts . pids Type = = = 'num ' ) { return cb ( null , opts . pids ) ; } if ( process . platform = = = 'sunos ' ) { exec File ( ' /bin /pgrep ' , [ ' -lf ' , opts . pids ] , function ( pids Err , stdout , stderr ) { if ( pids Err ) { warn ( 'bunyan : error getting PIDs for " %s " : %s \n %s \n %s ' , opts . pids , pids Err . message , stdout , stderr ) ; return cb ( 1 ) ; } var pids = stdout . trim ( ) . split ( ' \n ' ) . map ( function ( line ) { return line . trim ( ) . split ( / \s + / ) [ 0 ] } ) . filter ( function ( pid ) { return Number ( pid ) ! = = process . pid } ) ; if ( pids . length = = = 0 ) { warn ( 'bunyan : error : no matching PIDs found for " %s " ' , opts . pids ) ; return cb ( 2 ) ; } cb ( null , pids ) ; } ) ; } else { var regex = opts . pids ; if ( regex & & / [a -z A -Z 0 - 9 _ ] / . test ( regex [ 0 ] ) ) { 
function finish ( code ) { if ( leftover ) { handle Log Line ( null , leftover , opts , stylize ) ; leftover = ' ' ; } callback ( code ) ; } 
function process File ( file , opts , stylize , callback ) { var stream = fs . create Read Stream ( file ) ; if ( / \ .gz $ / . test ( file ) ) { stream = stream . pipe ( require ( 'zlib ' ) . create Gunzip ( ) ) ; } 
function debug ( ) { let a = [ . . . arguments ] a = a . map ( d = > d instanceof Error ? d . to String ( ) : d ) write ( { debug : true , time : new Date ( ) . get Time ( ) , name , data : a } ) if ( rd ) rd . apply ( rd , arguments ) } 
function search ( q , es Client , options ) { es Client = to Es Client ( es Client ) ; options = Object . assign ( { from : 0 , size : 2 5 , throw On Invalid : false } , options ) ; return p Try ( ( ) = > parse Query ( q , options ) ) . then ( ( params ) = > { if ( ! params ) { return { total : 0 , results : [ ] } ; } const match Queries = build Match Queries ( params ) ; const filter Query = build Filter Query ( params ) ; const script Score = build Script Score ( params ) ; 
function parse Search Query ( query , options ) { options = Object . assign ( { throw On Invalid : false } , options ) ; 
function has Property ( obj , name ) { if ( typeof obj = = = 'undefined ' | | obj = = = null ) { return false ; } 
function parse Path ( path ) { var str = path . replace ( / ( [ ^ \ \ ] ) \ [ / g , ' $ 1 . [ ' ) ; var parts = str . match ( / ( \ \ \ . | [ ^ . ] + ? ) + / g ) ; return parts . map ( function map Matches ( value ) { var regexp = / ^ \ [ ( \d + ) \ ] $ / ; var m Arr = regexp . exec ( value ) ; var parsed = null ; if ( m Arr ) { parsed = { i : parse Float ( m Arr [ 1 ] ) } ; } else { parsed = { p : value . replace ( / \ \ ( [ . \ [ \ ] ] ) / g , ' $ 1 ' ) } ; } return parsed ; } ) ; } 
function internal Get Path Value ( obj , parsed , path Depth ) { var temporary Value = obj ; var res = null ; path Depth = ( typeof path Depth = = = 'undefined ' ? parsed . length : path Depth ) ; for ( var i = 0 ; i < path Depth ; i + + ) { var part = parsed [ i ] ; if ( temporary Value ) { if ( typeof part . p = = = 'undefined ' ) { temporary Value = temporary Value [ part . i ] ; } else { temporary Value = temporary Value [ part . p ] ; } if ( i = = = ( path Depth - 1 ) ) { res = temporary Value ; } } } return res ; } 
function internal Set Path Value ( obj , val , parsed ) { var temp Obj = obj ; var path Depth = parsed . length ; var part = null ; 
function set Path Value ( obj , path , val ) { var parsed = parse Path ( path ) ; internal Set Path Value ( obj , val , parsed ) ; return obj ; } 
function configured Formatter ( options = { } ) { let { type Format } = options ; if ( type Format = = = undefined ) { if ( process . env . NODE _ENV = = = 'development ' | | process . env . NODE _ENV = = = 'dev ' ) { type Format = 'console ' ; } else { type Format = 'json ' ; } } if ( type Format = = = 'json ' ) { return combine ( timestamp ( ) , add Meta Format ( options ) , json Format ) ; } if ( type Format = = = 'console ' ) { return combine ( timestamp ( ) , colorize ( ) , console Format ) ; } throw new Error ( ` $ { type Format } ` ) ; } 
function ( test ) { var self = this , runner ; runner = this . runner = cluster . fork ( { WORKER _SCRIPT : ' . /runner ' , WORKER _TEST : test , WORKER _PORT : this . get Port ( ) , REQUESTED _PORTS : this . requested Ports , WORKER _MAX _MEMORY : this . max Memory , WORKER _MAX _TESTS : this . max Tests , WORKER _SLOW : this . slow , WORKER _TIMEOUT : this . timeout , TEST _TYPE : this . test Type , SUPPORT _FILES : this . support Files , REPORTS _URL : this . reports Url , COMPILER _MODULES : this . compiler Modules } ) ; runner . on ( 'message ' , function ( message ) { switch ( message . type ) { case 'test Results ' : case 'suite Done ' : self . emit ( message . type , message ) ; break ; default : try { message . runner Id = runner . id self . server . send ( message ) ; } catch ( e ) { self . disconnect Now ( ) ; } } } ) ; runner . on ( 'exit ' , function ( ) { self . _on Done ( ) ; } ) ; runner . on ( 'disconnect ' , function ( ) { self . _on Done ( ) ; } ) ; } 
function ( ) { var self = this ; this . server . on ( 'message ' , function ( message ) { switch ( message . type ) { case 'ready For Tests ' : self . emit ( 'ready For Tests ' ) ; break ; default : self . runner . send ( message ) ; } } ) ; } 
function ( ) { if ( this . total Tests > this . tests Finished & & ! this . has Failing Test ) { console . log ( " \n Error ! Expected to run " + this . total Tests + ' tests but actually ran ' + this . tests Finished + ' in test suite ' + process . env . WORKER _TEST ) ; } } 
function ( ) { var memory = Math . round ( process . memory Usage ( ) . rss / ( 1 0 2 4 * 1 0 2 4 ) ) ; if ( ! this . memory Warning & & memory > this . get Max Memory ( ) ) { this . memory Warning = true ; console . log ( " \n Warning ! Memory usage exceeded " + this . get Max Memory ( ) + 'MB for test suite ' + process . env . WORKER _TEST + ' . ' + 'Please split these tests into smaller suites . ' ) ; } } 
function ( ) { var self = this ; return new Promise ( function ( resolve , reject ) { var configuration = new Cucumber Configuration ( ) , runtime = Cucumber . Runtime ( configuration ) , formatters = configuration . get Formatters ( ) , event Mediator = new Event Emitter ( ) , intercept Formatter = new Intercept Formatter ( event Mediator ) ; formatters . for Each ( function ( formatter ) { runtime . attach Listener ( formatter ) ; } ) ; runtime . attach Listener ( intercept Formatter ) ; runtime . start ( function ( ) { resolve ( ) ; } ) ; event Mediator . on ( 'scenario end ' , function ( ) { self . tests Finished + + ; self . total Tests + + ; self . check Memory ( ) ; } ) ; event Mediator . on ( 'fail ' , function ( ) { self . has Failing Test = true ; } ) ; event Mediator . on ( 'end ' , function ( ) { self . check Finished Tests ( ) ; self . check Test Count ( ) ; self . check Memory ( ) ; process . send ( { type : 'suite Done ' , data : process . env . WORKER _TEST } ) ; cluster . worker . kill ( 0 ) ; } ) ; } ) ; } 
function Mocha Worker Reporter ( runner ) { EVENTS . for Each ( function ( event Name ) { runner . on ( event Name , function ( test , error ) { var data = { 'event ' : event Name , 'test ' : clean ( test , error ) } ; try { process . send ( { type : 'test Results ' , data : data } ) ; } catch ( e ) { console . log ( 'Mocha Worker Reporter : Error sending test results . ' , JSON . stringify ( data ) , e . message , e . stack ) ; process . exit ( 1 ) ; } } ) ; } ) ; } 
function ( ) { var self = this , runner ; process . send ( { type : 'runner Id ' , runner Id : cluster . worker . id } ) ; Minor Test . port = process . env . WORKER _PORT ; Minor Test . requested Ports = this . get Requested Ports ( ) ; switch ( process . env . TEST _TYPE ) { case 'cucumber ' : runner = new Cucumber Runner ( ) ; break ; case 'mocha ' : default : runner = new Mocha Runner ( ) ; } return runner . start ( ) ; } 
function ( ) { if ( this . started ) { throw new Error ( 'The server was already started ' ) ; } process . env . NODE _ENV = 'production ' ; process . env . FUNCTIONAL _TEST = true ; this . port = process . env . WORKER _PORT ; this . requested Ports = process . env . REQUESTED _PORTS ; return this . _start Server ( ) ; } 
function ( ) { var self = this ; if ( typeof this . Server ! = = 'function ' ) { throw new Error ( 'You must specify a Minor JS HTTP server ' ) ; } this . http Server = new this . Server ( ) ; return this . http Server . initialize ( this . _get Base Path ( ) , this . port ) . then ( function ( ) { return self . http Server . listen ( ) ; } ) . then ( function ( ) { self . started = true ; process . send ( { type : 'ready For Tests ' } ) ; } ) ; } 
function ( ) { var self = this ; return new Promise ( function ( resolve , reject ) { self . mocha = new Mocha ( { ui : 'bdd ' , reporter : path . join ( _ _dirname , ' . . /reporters /mocha _worker _reporter ' ) , slow : process . env . WORKER _SLOW | | self . SLOW , timeout : process . env . WORKER _TIMEOUT | | self . TIMEOUT , bail : true } ) ; self . mocha . add File ( process . env . WORKER _TEST ) ; self . runner = self . mocha . run ( function ( failures ) { resolve ( ) ; } ) ; self . runner . on ( 'suite ' , function ( suite ) { self . total Tests = suite . total ; } ) ; self . runner . on ( 'test end ' , function ( ) { self . tests Finished + + ; self . check Memory ( ) ; } ) ; self . runner . on ( 'fail ' , function ( ) { self . has Failing Test = true ; } ) ; self . runner . on ( 'end ' , function ( ) { self . check Finished Tests ( ) ; self . check Test Count ( ) ; self . check Memory ( ) ; process . send ( { type : 'suite Done ' , data : process . env . WORKER _TEST } ) ; cluster . worker . kill ( 0 ) ; } ) ; } ) ; } 
function ( options ) { var self = this ; if ( options = = null ) { options = { } ; } this . options = extend ( { requested Ports : 0 , type : this . TYPE _MOCHA , compiler Modules : [ ] } , options ) ; this . event Mediator = new Event Emitter ( ) ; this . event Mediator . on ( 'bail ' , this . _bail . bind ( this ) ) ; switch ( this . options . type ) { case this . TYPE _CUCUMBER : this . reporter = new Cucumber Reporter ( this . event Mediator ) ; break ; case this . TYPE _MOCHA : default : this . reporter = new Mocha Reporter ( this . event Mediator ) ; } this . _set Colors ( ) ; this . _handle Signals ( ) ; cluster . setup Master ( { exec : path . join ( _ _dirname , 'fork _worker .js ' ) , silent : false } ) ; this . _load Test Suites ( ) . then ( function ( tests ) { return self . _process Tests ( self . _batch Tests ( tests ) ) ; } ) . then ( function ( ) { self . event Mediator . emit ( 'start ' ) ; return self . _get Open Ports ( self . options . requested Ports ) ; } ) . then ( function ( ports ) { for ( var i = 0 ; i < self . _get Max Servers ( ) ; i + + ) { var port Block Size = self . options . requested Ports + 1 , port Block Start = i * port Block Size , port = ports [ port Block Start ] , requested Ports = ports . slice ( port Block Start + 1 , port Block Start + port Block Size ) ; self . _create Server Worker ( port , requested Ports ) ; } } ) . done ( ) ; } 
function ( test Paths ) { var batch Count = this . options . batch Count var current Batch = this . options . current Batch if ( ! batch Count & & ! current Batch ) { return test Paths } var batch Size = Math . floor ( test Paths . length / batch Count ) var end = ( batch Size * current Batch ) var start = ( end - batch Size ) if ( batch Count = = = current Batch ) { end = undefined } return test Paths . slice ( start , end ) } 
function ( ) { var missed Suites = _ . difference ( this . original Tests , this . finished Suites ) ; if ( missed Suites . length > 0 & & ! this . has Failing Test ) { console . log ( " \n Error ! Expected to run " + this . original Tests . length + ' test suites but actually ran ' + this . finished Suites . length + ' . Missing ' + missed Suites . length + ' test ' + ( missed Suites . length > 1 ? 'suites ' : 'suite ' ) + ' . Suites not run : ' ) ; console . log ( missed Suites ) ; } } 
function ( port , requested Ports ) { var self = this , server Instance = this . _get Server Instance ( port , requested Ports ) ; this . servers . push ( server Instance ) ; server Instance . on ( 'ready For Tests ' , function ( ) { self . _run Test On Server ( server Instance ) ; } ) ; server Instance . on ( 'done ' , function ( ) { self . _increment Done ( ) ; } ) ; server Instance . on ( 'test Results ' , this . reporter . handle Test Results . bind ( this . reporter ) ) ; server Instance . on ( 'suite Done ' , function ( suite ) { self . finished Suites Count + + ; self . finished Suites . push ( suite . data ) ; } ) ; } 
function ( ) { return new Promise ( function ( resolve , reject ) { portfinder . get Port ( function ( error , port ) { if ( error ) { reject ( error ) ; } else { resolve ( port ) ; } } ) ; } ) ; } 
function ( requested Port Count ) { var self = this , promises = [ ] , total Ports = this . _get Max Servers ( ) * ( requested Port Count + 1 ) ; for ( var i = 0 ; i < total Ports ; i + + ) { promises . push ( ( function ( ) { return self . _get Open Port ( ) ; } ) ( ) ) ; } return Promise . all ( promises ) ; } 
function ( port , requested Ports ) { return new Server Instance ( { port : port , requested Ports : requested Ports , server : this . options . server , max Memory : this . options . max Memory , max Tests : this . options . max Tests , slow : this . options . slow , timeout : this . options . timeout , type : this . options . type , reports Url : this . options . reports Url , support Files : this . options . support Files | | [ ] , compiler Modules : this . options . compiler Modules } ) ; } 
function ( ) { var self = this ; process . on ( 'SIGINT ' , function handle Interupt Signal ( ) { self . _shutdown ( ) ; } ) ; process . on ( 'uncaught Exception ' , function handle Exception ( error ) { console . log ( error . stack ) ; self . _bail ( ) ; self . _shutdown ( 1 ) ; } ) ; } 
function ( ) { if ( this . _is Test File Specified ( ) ) { this . _check Path Exists ( this . options . test Path ) ; return Promise . resolve ( [ this . options . test Path ] ) ; } var directory = this . _get Test Directory ( ) ; this . _check Path Exists ( directory ) ; var pattern = path . join ( directory , ' / * * / * . {js ,coffee ,feature } ' ) ; return Promise . promisify ( glob ) ( pattern ) ; } 
function ( server ) { var test = this . _get Test ( ) ; if ( ! test ) { server . disconnect Now ( ) ; this . _finish ( ) ; return ; } server . run ( test ) ; } 
function ( ) { if ( process . env . TEST _COLORS ! = = undefined ) { this . reporter . set Colors ( process . env . TEST _COLORS = = 0 ? false : true ) ; } } 
function ( tests ) { this . original Tests = [ ] . concat ( tests ) ; this . tests = tests ; this . tests Count = tests . length ; console . log ( 'Running ' + this . tests Count + ' test ' + ( this . tests Count > 1 ? 'suites ' : 'suite ' ) ) ; } 
function Cucumber Reporter ( event Mediator ) { var options = { snippets : true , stream : process . stdout , use Colors : true } ; this . failure Count = 0 ; this . event Mediator = event Mediator ; this . formatter = Dot Formatter ( options ) ; 
function ( ) { var event = Cucumber . Runtime . Ast Tree Walker . Event ( 'After All Features ' , Cucumber . Ast . Features ( ) ) ; this . formatter . hear ( event , function ( ) { } ) ; } 
function ( results ) { var packet = results . data , payload = this . hydrate Payload ( packet . name , packet . payload ) ; var event = Cucumber . Runtime . Ast Tree Walker . Event ( packet . name , payload ) ; this . formatter . hear ( event , function ( ) { } ) ; if ( packet . payload & & packet . payload . step Result ) { var status = event . get Payload Item ( 'step Result ' ) . get Status ( ) ; if ( status = = = Cucumber . Status . FAILED | | status = = = Cucumber . Status . AMBIGUOUS ) { this . failure Count + + ; this . event Mediator . emit ( 'bail ' ) ; } } } 
function ( event Name , payload ) { var result ; switch ( event Name ) { case 'Before Scenario ' : case 'Scenario ' : case 'After Scenario ' : result = { scenario : new Cucumber . Ast . Scenario ( payload . scenario . keyword , payload . scenario . name , payload . scenario . description , payload . scenario . uri , payload . scenario . line , payload . scenario . scenario Outline Line , payload . scenario . background ) } ; for ( index in payload . scenario . steps ) { var step = payload . scenario . steps [ index ] ; result . scenario . add Step ( step ) ; } result . scenario . failed = payload . scenario . failed ; break ; case 'Before Feature ' : case 'Feature ' : case 'After Feature ' : result = new Cucumber . Ast . Feature ( payload . feature . keyword , payload . feature . name , payload . feature . description , payload . feature . uri , payload . feature . line , payload . feature . background ) ; break ; case 'Before Features ' : case 'Features ' : case 'After Features ' : result = new Cucumber . Ast . Features ( ) ; for ( index in payload . features ) { var feature = payload . features [ index ] ; result . add Feature ( feature ) ; } break ; case 'Before Step ' : case 'Step ' : case 'After Step ' : result = { step : this . hydrate Step ( payload . step ) } ; break ; case 'Step Result ' : var step Result = extend ( { } , payload . step Result ) ; step Result . step = this . hydrate Step ( step Result . step ) ; result = { step Result : this . hydrate Step Result ( step Result ) } ; break ; case 'Background ' : result = { background : new Cucumber . Ast . Background ( payload . background . keyword , payload . background . name , payload . background . description , payload . background . uri , payload . background . line ) } ; for ( index in payload . background . steps ) { var step = payload . background . steps [ index ] ; result . background . add Step ( step ) ; } break ; default : throw new Error ( 'Invalid payload ' + event Name ) ; break ; } return result ; } 
function get Display Name ( path ) { const component Name = get Name ( path ) const filename = get File Name ( file ) if ( filename ) { if ( filename = = = component Name ) { return component Name } return component Name ? ` $ { filename } $ { component Name } ` : filename } else { return component Name } } 
function get Name ( path ) { let named Node path . find ( parent Path = > { if ( parent Path . is Object Property ( ) ) { 
function closest ( element , selector ) { while ( element & & element . node Type ! = = DOCUMENT _NODE _TYPE ) { if ( typeof element . matches = = = 'function ' & & element . matches ( selector ) ) { return element ; } element = element . parent Node ; } } 
function delegate ( elements , selector , type , callback , use Capture ) { 
function listener ( element , selector , type , callback ) { return function ( e ) { e . delegate Target = closest _ 1 ( e . target , selector ) ; if ( e . delegate Target ) { callback . call ( element , e ) ; } } } 
function listen Node ( node , type , callback ) { node . add Event Listener ( type , callback ) ; return { destroy : function ( ) { node . remove Event Listener ( type , callback ) ; } } } 
function listen Node List ( node List , type , callback ) { Array . prototype . for Each . call ( node List , function ( node ) { node . add Event Listener ( type , callback ) ; } ) ; return { destroy : function ( ) { Array . prototype . for Each . call ( node List , function ( node ) { node . remove Event Listener ( type , callback ) ; } ) ; } } } 
function listen Selector ( selector , type , callback ) { return delegate _ 1 ( document . body , selector , type , callback ) ; } 
function get Attribute Value ( suffix , element ) { var attribute = 'data -clipboard - ' + suffix ; if ( ! element . has Attribute ( attribute ) ) { return ; } return element . get Attribute ( attribute ) ; } 
function read Logical Segment ( path , offset , segment ) { segment . type = SEGMENT _TYPE . LOGICAL ; const segment Byte = path . read UInt 8 ( offset ) ; const type = get Bits ( segment Byte , 2 , 5 ) < < 2 ; const format = get Bits ( segment Byte , 0 , 2 ) ; segment . info = { type , type Description : LOGICAL _SEGMENT _TYPE _DESCRIPTIONS [ type ] , format , format Description : LOGICAL _SEGMENT _FORMAT _DESCRIPTIONS [ format ] } ; let shift ; switch ( format ) { case 0 : segment . info . value = path . read UInt 8 ( offset + 1 ) ; shift = 2 ; break ; case 1 : segment . info . value = path . read UInt 1 6LE ( offset + 2 ) ; shift = 4 ; break ; case 2 : segment . info . value = path . read UInt 3 2LE ( offset + 2 ) ; shift = 6 ; break ; default : break ; } return shift ; } 
function logical ASCIIAddress Info ( address ) { const split String = address . split ( ' : ' ) ; const prefix = split String [ 0 ] . replace ( / [ 0 - 9 ] / gi , ' ' ) ; const info = { } ; switch ( prefix ) { case "S " : case "I " : case "N " : case "O " : case "B " : info . addrtype = prefix ; info . datatype = "INT " ; info . size = 2 ; info . data Type = 4 ; info . write Function = ( buffer , offset , value ) = > buffer . write Int 1 6LE ( value , offset ) ; info . read Function = ( buffer , offset ) = > buffer . read Int 1 6LE ( offset ) ; break ; case "L " : 
function Typed Read Reply Parser Array ( data ) { const info = Typed Read Parser Info ( data ) ; const values = [ ] ; let offset = info . Length ; let read Function = null ; switch ( info . data Type ID ) { case 3 : read Function = function ( data , offset ) { return String . from Char Code ( data [ offset ] ) ; } ; break ; case 4 : read Function = function ( data , offset ) { return data . read Int 1 6LE ( offset ) ; 
function Typed Read Reply Parser ( data ) { const info = Typed Read Parser Info ( data ) ; let offset = info . Length ; let value = null ; switch ( info . data Type ID ) { case PCCCData Type . Binary : case PCCCData Type . Bit String : case PCCCData Type . Byte : value = buffer . read UInt 8 ( offset ) ; break ; case PCCCData Type . Integer : value = buffer . read Int 3 2LE ( offset ) ; 
function Asset Loader ( manifest , loader ) { this . assets = load Assets ( manifest , loader , function ( err ) { if ( err ) { console . error ( err ) ; } } ) ; } 
function Font Loader ( font Families Array , delegate , timeout ) { 
function ( size Watcher ) { var watched Element = size Watcher . get Watched Element ( ) ; if ( size Watcher = = = this . _adobe Blank Size Watcher ) { this . _adobe Blank Loaded ( watched Element ) ; } else { this . _element Size Changed ( watched Element ) ; } } 
function Size Watcher ( element , options ) { this . _element = element ; this . _delegate = options . delegate ; this . _size = null ; this . _continuous = ! ! options . continuous ; this . _direction = options . direction ? options . direction : Size Watcher . directions . both ; this . _dimension = options . dimension ? options . dimension : Size Watcher . dimensions . both ; this . _size Increase Watcher Content Elm = null ; this . _size Decrease Watcher Elm = null ; this . _size Increase Watcher Elm = null ; this . _state = Size Watcher . states . initialized ; this . _generate Scroll Watchers ( options . size ) ; this . _append Scroll Watchers To Element ( options . container ) ; } 
function AStar ( is Walkable ) { this . dest X = 0 ; this . dest Y = 0 ; this . scale X = 1 ; this . scale Y = 1 ; this . open Nodes = { } ; this . closed Nodes = { } ; this . open Heap = new Binary Heap ( function ( a , b ) { return a . f - b . f ; } ) ; this . is Walkable = is Walkable ; } 
function Nine Patch ( image ) { this . img = image ; var imgw = image . width - 1 ; var imgh = image . height - 1 ; var context = get Context For Image ( image ) ; var first Div = imgw ; var second Div = imgw ; var pixel ; var alpha ; for ( var x = 0 ; x < imgw ; x + + ) { pixel = context . get Image Data ( x , imgh , 1 , 1 ) . data ; alpha = pixel [ 3 ] ; if ( first Div = = = imgw & & alpha > 0 ) { first Div = x ; } if ( first Div < imgw & & alpha = = = 0 ) { second Div = x ; break ; } } this . w 1 = first Div ; this . w 2 = second Div - first Div ; this . w 3 = imgw - second Div ; first Div = second Div = imgh ; for ( var y = 0 ; y < imgh ; y + + ) { pixel = context . get Image Data ( imgw , y , 1 , 1 ) . data ; alpha = pixel [ 3 ] ; if ( first Div = = = imgh & & alpha > 0 ) { first Div = y ; } if ( first Div < imgh & & alpha = = = 0 ) { second Div = y ; break ; } } this . h 1 = first Div ; this . h 2 = second Div - first Div ; this . h 3 = imgh - second Div ; } 
function Mouse ( canvas ) { this . x = 0 ; this . y = 0 ; this . buttons = [ false , false , false ] ; this . touches = [ ] ; this . onmouseup = undefined ; var self = this ; canvas . add Event Listener ( "mousedown " , function ( event ) { rel Mouse Coords ( canvas , event , self ) ; self . buttons [ event . button ] = true ; update Touch From Mouse ( ) ; } ) ; canvas . add Event Listener ( "mouseup " , function ( event ) { rel Mouse Coords ( canvas , event , self ) ; self . buttons [ event . button ] = false ; update Touch From Mouse ( ) ; if ( self . onmouseup ) { self . onmouseup ( self . x , self . y ) ; } } ) ; canvas . add Event Listener ( "mousemove " , function ( event ) { rel Mouse Coords ( canvas , event , self ) ; update Touch From Mouse ( ) ; } ) ; function update Touch From Mouse ( ) { if ( self . supports Touch ( ) ) { return ; } var idx = touch Index By Id ( "mouse " ) ; if ( self . is Pressed ( 0 ) ) { if ( idx ! = = undefined ) { var touch = self . touches [ idx ] ; touch . x = self . x ; touch . y = self . y ; } else { self . touches . push ( { id : "mouse " , x : self . x , y : self . y } ) ; } } else if ( idx ! = = undefined ) { self . touches . splice ( idx , 1 ) ; } } function update Mouse From Touch ( touch ) { self . x = touch . x ; self . y = touch . y ; if ( self . buttons [ 0 ] = = = false ) { self . buttons [ 0 ] = true ; } } function touch Index By Id ( id ) { for ( var i = 0 ; i < self . touches . length ; i + + ) { if ( self . touches [ i ] . id = = = id ) { return i ; } } return undefined ; } function each Changed Touch ( event , on Change Func ) { var touches = event . changed Touches ; for ( var i = 0 ; i < touches . length ; i + + ) { on Change Func ( touches [ i ] ) ; } } canvas . add Event Listener ( "touchstart " , function ( event ) { each Changed Touch ( event , function ( touch ) { var t = { id : touch . identifier } ; rel Mouse Coords ( canvas , touch , t ) ; if ( self . touches . length = = = 0 ) { t . is Mouse = true ; update Mouse From Touch ( t ) ; } self . touches . push ( t ) ; } ) ; } ) ; canvas . add Event Listener ( "touchmove " , function ( event ) { each Changed Touch ( event , function ( touch ) { var idx = touch Index By Id ( touch . identifier ) ; var t = self . touches [ idx ] ; rel Mouse Coords ( canvas , touch , t ) ; if ( t . is Mouse ) { update Mouse From Touch ( t ) ; } } ) ; } ) ; canvas . add Event Listener ( "touchend " , function ( event ) { each Changed Touch ( event , function ( touch ) { var idx = touch Index By Id ( touch . identifier ) ; var t = self . touches . splice ( idx , 1 ) [ 0 ] ; if ( t . is Mouse ) { if ( self . touches . length = = = 0 ) { self . buttons [ 0 ] = false ; } else { self . touches [ 0 ] . is Mouse = true ; update Mouse From Touch ( self . touches [ 0 ] ) ; } } if ( self . onmouseup ) { self . onmouseup ( t . x , t . y ) ; } } ) ; } ) ; } 
function ( game , config ) { var particle Count = Math . floor ( random . in Range ( config . qty Min , config . qty Max ) ) ; for ( var i = 0 ; i < particle Count ; i + + ) { var particle = game . prefabs . instantiate ( game . entities , config . prefab ) ; 
function ( prefab ) { this . prefab = prefab ; this . origin = { "x " : 0 , "y " : 0 } ; this . spread Type = "random " ; this . angle = 0 ; this . arc Width = Math . PI / 2 ; this . qty Min = 1 ; this . qty Max = 1 ; this . size Min = 1 ; this . size Max = 1 ; this . velocity Min = 0 . 5 ; this . velocity Max = 0 . 5 ; this . acceleration X = 0 ; this . acceleration Y = 0 ; this . life Span Min = 0 ; this . life Span Max = 5 0 0 ; } 
function center Entity On Point ( game , entity , point ) { var size = game . entities . get Component ( entity , "size " ) ; var position = game . entities . add Component ( entity , "position " ) ; position . x = point . x - ( size . width / 2 ) ; position . y = point . y - ( size . height / 2 ) ; } 
function choose Point In Entity ( game , entity ) { var position = game . entities . get Component ( entity , "position " ) ; var size = game . entities . get Component ( entity , "size " ) ; if ( size = = = undefined ) { return { "x " : position . x , "y " : position . y } ; } return { "x " : random . in Range ( position . x , ( position . x + size . width ) ) , "y " : random . in Range ( position . y , ( position . y + size . height ) ) } ; } 
function make Canvas ( width , height ) { var c = document . create Element ( "canvas " ) ; c . width = width ; c . height = height ; 
function make Buffer ( width , height , draw Fun ) { var canvas = make Canvas ( width , height ) ; var ctx = canvas . get Context ( " 2d " ) ; 
function flip Buffer Horizontally ( buffer ) { return make Buffer ( buffer . width , buffer . height , function ( context ) { context . scale ( - 1 , 1 ) ; context . draw Image ( buffer , - buffer . width , 0 ) ; } ) ; } 
function flip Buffer Vertically ( buffer ) { return make Buffer ( buffer . width , buffer . height , function ( context ) { context . scale ( 1 , - 1 ) ; context . draw Image ( buffer , 0 , - buffer . height ) ; } ) ; } 
function rotate Clockwise ( buffer ) { var w = buffer . height ; var h = buffer . width ; var w 2 = Math . floor ( w / 2 ) ; var h 2 = Math . floor ( h / 2 ) ; return make Buffer ( w , h , function ( context ) { context . translate ( w 2 , h 2 ) ; context . rotate ( Math . PI / 2 ) ; context . draw Image ( buffer , - h 2 , - w 2 ) ; } ) ; } 
function chrome Storage Get ( keys , callback ) { window . chrome . storage . sync . get ( keys , function ( data ) { if ( window . chrome . runtime . last Error ) { callback ( window . chrome . runtime . last Error ) ; } else { callback ( undefined , data ) ; } } ) ; } 
function chrome Storage Set ( data , callback ) { window . chrome . storage . sync . set ( data , function ( ) { callback ( window . chrome . runtime . last Error ) ; } ) ; } 
function Accelerometer ( ) { this . alpha = 0 ; this . beta = 0 ; this . gamma = 0 ; var self = this ; window . add Event Listener ( "deviceorientation " , function ( event ) { self . alpha = event . alpha ; self . beta = event . beta ; self . gamma = event . gamma ; } , false ) ; } 
function Sound Manager ( manifest ) { this . muted = false ; this . looping = { } ; this . context = new window . Audio Context ( ) ; this . gain Node = this . context . create Gain ( ) ; this . gain Node . connect ( this . context . destination ) ; this . volume = this . gain Node . gain . value ; this . install Safari Workaround ( ) ; this . assets = new Asset Loader ( manifest , load Sound . bind ( undefined , this . context ) ) ; } 
function ( program , callback ) { var config = config Helpers . get Config ( ) ; config . plugins = config . plugins | | { } ; var load Plugin = function ( plugin Name , cb ) { plugin Helpers . load Plugin ( plugin Name , program , cb ) ; } ; Object . keys ( config . plugins ) . for Each ( load Plugin ) ; node Helpers . invoke ( callback ) ; } 
function ( plugin Name , program , application Server , callback ) { var config = config Helpers . get Config ( ) ; 
function ( plugin Name , callback ) { var config = config Helpers . get Config ( ) ; if ( config . plugins [ plugin Name ] = = = undefined ) { logger . error ( 'Plugin ' + plugin Name + ' not installed ! ' ) ; } else if ( plugin Helpers . loaded Plugins [ plugin Name ] = = = undefined ) { logger . error ( 'Plugin ' + plugin Name + ' not loaded ! ' ) ; } else { var options = config . plugins [ plugin Name ] ; try { var plugin = plugin Helpers . loaded Plugins [ plugin Name ] ; delete plugin Helpers . loaded Plugins [ plugin Name ] ; node Helpers . clear Require Cache ( config Helpers . module Path ( options . name ) ) ; if ( plugin . on Exit ! = = undefined ) { return plugin . on Exit ( options , config , function ( err ) { if ( err ) { logger . raw ( err ) ; logger . info ( ' \t ' + symbols . err + ' \t ' + options . display Name + ' ' ) ; } else { logger . info ( ' \t ' + symbols . ok + ' \t ' + options . display Name + ' ' ) ; } delete plugin Helpers . started Plugins [ plugin Name ] ; node Helpers . invoke ( callback , err ) ; } ) ; } else { delete plugin Helpers . started Plugins [ plugin Name ] ; logger . info ( ' \t ' + symbols . ok + ' \t ' + options . display Name + ' ' ) ; } } catch ( err ) { logger . raw ( err ) ; logger . error ( 'Plugin ' + options . display Name + ' failed for termination . ' ) ; return node Helpers . invoke ( callback , err ) ; } } return node Helpers . invoke ( callback ) ; } 
function ( program , app , callback ) { var attach Plugin = function ( plugin Name , cb ) { plugin Helpers . start ( plugin Name , program , app , cb ) ; } ; var plugins = Object . keys ( plugin Helpers . loaded Plugins ) async . each Series ( plugins , attach Plugin , function ( ) { callback ( ) ; } ) ; } 
function ( callback ) { var plugins = Object . keys ( plugin Helpers . loaded Plugins | | { } ) ; async . each Series ( plugins , plugin Helpers . stop , callback ) ; } 
function ( program , callback ) { var cozy Light = require ( ' . /cozy -light ' ) ; application Helpers . reset Default Port ( ) ; cozy Light . set Started ( ) ; 
function ( apporplugin ) { try { config Helpers . enable ( apporplugin ) ; logger . info ( apporplugin + ' enabled ' ) ; } catch ( err ) { logger . error ( 'Cannot enable given app or plugin , ' + apporplugin + ' cannot find it in the config file . ' ) ; } } 
function ( apporplugin ) { try { config Helpers . disable ( apporplugin ) ; logger . info ( apporplugin + ' disabled ' ) ; } catch ( err ) { logger . error ( 'Cannot disable given app or plugin , ' + apporplugin + ' cannot find it in the config file . ' ) ; logger . raw ( err ) ; } } 
function ( callback ) { var cozy Light = require ( ' . /cozy -light ' ) ; if ( cozy Light . get Status ( ) = = = 'started ' ) { cozy Light . set Stopped ( ) ; logger . info ( 'Stopping apps . . . ' ) ; return application Helpers . stop All ( function ( app Err ) { if ( app Err ) { logger . error ( 'An error occurred while stopping applications ' ) ; logger . raw ( app Err ) ; } logger . info ( 'Stopping plugins . . . ' ) ; plugin Helpers . stop All ( function ( plugin Err ) { if ( plugin Err ) { logger . error ( 'An error occurred while stopping plugins ' ) ; logger . raw ( plugin Err ) ; } logger . info ( 'Stopping server . . . ' ) ; var timeout = node Helpers . throw Timeout ( 'main server is too slow to stop . . . ' , 5 0 0 0 ) ; main App Helper . stop ( function ( ) { clear Timeout ( timeout ) ; logger . info ( ' \t ' + symbols . ok + ' \tmain server ' ) ; node Helpers . invoke ( callback ) ; } ) ; } ) ; } ) ; } logger . debug ( 'Apps already stopped ' ) ; return node Helpers . invoke ( callback ) ; } 
function ( callback ) { var cozy Light = require ( ' . /cozy -light ' ) ; logger . info ( 'Restarting . . . ' ) ; actions . stop ( function ( ) { config Helpers . load Config File ( ) ; cozy Light . routes = { } ; logger . info ( 'Starting all apps . . . ' ) ; plugin Helpers . load All ( this . program , function ( ) { actions . start ( this . program , function ( ) { logger . info ( ' . . .Cozy Light was properly restarted . ' ) ; node Helpers . invoke ( callback ) ; actions Event . emit ( 'restarted ' ) ; } ) ; } ) ; } ) ; } 
function ( app , callback ) { var cozy Light = require ( ' . /cozy -light ' ) ; logger . info ( 'Fetching data . . . ' ) ; npm Helpers . fetch Manifest ( app , function add App To Config ( fetch Err , manifest , type ) { if ( fetch Err ) { logger . raw ( fetch Err ) ; logger . error ( 'Cannot find given app manifest . ' ) ; logger . error ( 'Make sure it lives on Github ' ) ; logger . error ( 'or in the given directory . ' ) ; logger . error ( app + ' installation failed . ' ) ; node Helpers . invoke ( callback , fetch Err ) ; } else { var config = config Helpers . get Config ( ) ; var app Name = manifest . name ; if ( config . apps [ app Name ] ) { logger . info ( 'App ' + app Name + ' already installed . . . ' ) ; return node Helpers . invoke ( callback , null , manifest , type ) ; } else { logger . info ( 'Installing app ' + app Name + ' . . . ' ) ; var setup Cb = function ( install Err ) { if ( install Err ) { logger . raw ( install Err ) ; logger . error ( app Name + ' installation failed . ' ) ; node Helpers . invoke ( callback , install Err , manifest , type ) ; } else { logger . info ( app Name + ' installed . Enjoy ! ' ) ; if ( cozy Light . get Status ( ) ! = = 'started ' ) { config Helpers . add App ( app Name , manifest ) ; node Helpers . invoke ( callback , null , manifest , type ) ; } else { config Helpers . watcher . one ( function ( ) { callback ( ) ; } ) ; config Helpers . add App ( app Name , manifest ) ; } } } ; if ( type = = = 'file ' ) { return npm Helpers . link ( app , setup Cb ) ; } else if ( type = = = 'url ' ) { if ( app . split ( ' @ ' ) > 1 ) { app = app . split ( ' @ ' ) [ 0 ] ; } return npm Helpers . install ( app , setup Cb ) ; } } } } ) ; } 
function ( app , callback ) { var cozy Light = require ( ' . /cozy -light ' ) ; var config = config Helpers . get Config ( ) ; logger . info ( 'Uninstalling ' + app + ' . . . ' ) ; if ( config . apps [ app ] = = = undefined ) { logger . error ( app + ' is not installed . ' ) ; node Helpers . invoke ( callback , true ) ; } else { var module = config . apps [ app ] . name ; npm Helpers . uninstall ( module , function remove App From Config ( err ) { if ( err ) { logger . raw ( err ) ; logger . error ( 'npm did not uninstall ' + app + ' correctly . ' ) ; node Helpers . invoke ( callback , err ) ; } else { logger . info ( app + ' successfully uninstalled . ' ) ; config Helpers . watcher . one ( callback ) ; config Helpers . remove App ( app ) ; } } ) ; } } 
function ( plugin , program , callback ) { var cozy Light = require ( ' . /cozy -light ' ) ; if ( typeof ( program ) = = = 'function ' ) callback = program ; logger . info ( 'Fetching data . . . ' ) ; npm Helpers . fetch Manifest ( plugin , function add Plugin To Config ( fetch Err , manifest , type ) { if ( fetch Err ) { logger . raw ( fetch Err ) ; logger . error ( 'Cannot find given plugin manifest . ' ) ; logger . error ( 'Make sure it lives on Github ' ) ; logger . error ( 'or in the given directory . ' ) ; logger . error ( plugin + ' installation failed . ' ) ; node Helpers . invoke ( callback , fetch Err ) ; } else { var config = config Helpers . get Config ( ) ; var plugin Name = manifest . name ; if ( config . plugins [ plugin Name ] ) { logger . info ( 'Plugin ' + plugin Name + ' already installed . . . ' ) ; return node Helpers . invoke ( callback , null , manifest , type ) ; } else { logger . info ( 'Installing plugin ' + plugin Name + ' . . . ' ) ; var setup Cb = function ( install Err ) { if ( install Err ) { logger . raw ( install Err ) ; logger . error ( plugin Name + ' installation failed . ' ) ; node Helpers . invoke ( callback , install Err , manifest , type ) ; } else { logger . info ( plugin Name + ' installed . Enjoy ! ' ) ; if ( cozy Light . get Status ( ) ! = = 'started ' ) { config Helpers . add Plugin ( plugin Name , manifest ) ; node Helpers . invoke ( callback , null , manifest , type ) ; } else { config Helpers . watcher . one ( function ( ) { plugin Helpers . load Plugin ( plugin Name , program ) ; node Helpers . invoke ( callback ) ; } ) ; config Helpers . add Plugin ( plugin Name , manifest ) ; } } } ; if ( type = = = 'file ' ) { return npm Helpers . link ( plugin , setup Cb ) ; } else if ( type = = = 'url ' ) { return npm Helpers . install ( plugin , setup Cb ) ; } } } } ) ; } 
function ( plugin , callback ) { var cozy Light = require ( ' . /cozy -light ' ) ; var config = config Helpers . get Config ( ) ; logger . info ( 'Removing ' + plugin + ' . . . ' ) ; if ( config . plugins [ plugin ] = = = undefined ) { logger . error ( plugin + ' is not installed . ' ) ; node Helpers . invoke ( callback , true ) ; } else { var module = config . plugins [ plugin ] . name ; npm Helpers . uninstall ( module , function remove Plugin From Config ( err ) { if ( err ) { logger . raw ( err ) ; logger . error ( 'npm did not uninstall ' + plugin + ' correctly . ' ) ; node Helpers . invoke ( callback , err ) ; } else { logger . info ( plugin + ' successfully uninstalled . ' ) ; plugin Helpers . stop ( plugin , function ( ) { plugin Helpers . unload Plugin ( plugin ) ; config Helpers . watcher . one ( callback ) ; config Helpers . remove Plugin ( plugin ) ; } ) ; } } ) ; } } 
async function p _setup ( ) { try { 
function ( distro Name , actions , callback ) { if ( distros [ distro Name ] ! = = undefined ) { var distro = distros [ distro Name ] ; logger . info ( 'Installing plugins . . . ' ) ; async . each Series ( distro . plugins , function add Plugin ( plugin Name , cb ) { actions . install Plugin ( plugin Name , cb ) ; } , function install Apps ( err ) { if ( err ) { callback ( err ) ; } else { logger . info ( 'Installing apps . . . ' ) ; async . each Series ( distro . apps , function add App ( app Name , cb ) { actions . install App ( app Name , cb ) ; } , callback ) ; } } ) ; } else { throw new Error ( 'Unknown distro , can \ 't install it ' ) ; } } 
function ( distro Name ) { logger . raw ( ' \n \x 1B [ 3 6m * ' + distro Name + ' \x 1B [ 3 9m ' ) ; var log Attribute List = function ( key ) { logger . raw ( ' \x 1B [ 3 2m ' + key + ' : \x 1B [ 3 9m ' ) ; var list = distros [ distro Name ] [ key ] ; if ( list ! = = undefined & & list . length > 0 ) { list . for Each ( function display List Element ( key Name ) { logger . raw ( ' - ' + key Name . split ( ' / ' ) [ 1 ] ) ; } ) ; } else { logger . raw ( ' no ' + key ) ; } } ; log Attribute List ( 'plugins ' ) ; log Attribute List ( 'apps ' ) ; } 
function save Wallet ( filename , wallet Data ) { return new Promise ( ( resolve , reject ) = > { fs . write File ( filename , JSON . stringify ( wallet Data , null , 2 ) , function ( err ) { if ( err ) return reject ( console . error ( err ) ) 
function open Wallet ( filename ) { try { 
function change Addr From Mnemonic ( wallet Info , index , BITBOX ) { 
async function get UTXOs ( wallet Info , BITBOX ) { try { const ret Array = [ ] 
function ( cozy Home , port ) { fs . mkdirs Sync ( cozy Home ) ; config Helpers . set Home Path ( cozy Home ) ; config Helpers . set Main App Port ( parse Int ( port ) ) ; config Helpers . set Default Apps Port ( parse Int ( port ) + 1 0 0 ) ; config Helpers . copy Dependency ( 'pouchdb ' ) ; config Helpers . create Config File ( ) ; config Helpers . watcher = config Watcher ; config Helpers . watcher . init ( config Helpers . get Config Path ( ) ) ; return config Helpers . load Config File ( ) ; } 
function ( ) { var file Path = config Helpers . get Config Path ( ) ; config = JSON . parse ( fs . read File Sync ( file Path , 'utf - 8 ' ) ) ; return config ; } 
function ( ) { var config String = JSON . stringify ( config , null , 2 ) ; fs . write File Sync ( config Helpers . get Config Path ( ) , config String ) ; } 
function ( ) { var exists = fs . exists Sync ( config Helpers . get Config Path ( ) ) ; if ( ! exists ) { config = { apps : { } , plugins : { } } ; config Helpers . save Config ( ) ; } } 
function ( name ) { var dest Path = config Helpers . module Path ( name ) ; var source Path = path Extra . join ( _ _dirname , ' . . ' , 'node _modules ' , name ) ; if ( ! fs . exists Sync ( dest Path ) ) { fs . copy Sync ( source Path , dest Path ) ; } } 
function ( app , manifest ) { if ( manifest . type = = = undefined ) { manifest . type = 'classic ' ; } config . apps [ app ] = { name : manifest . name , display Name : manifest . display Name , version : manifest . version , description : manifest . description , type : manifest . type } ; config Helpers . save Config ( ) ; } 
function ( app ) { var ret = false ; if ( config . apps [ app ] ! = = undefined ) { delete config . apps [ app ] ; config Helpers . save Config ( ) ; ret = true ; } return ret ; } 
function ( plugin , manifest ) { if ( config . plugins = = = undefined ) { config . plugins = { } ; } config . plugins [ plugin ] = { name : manifest . name , display Name : manifest . display Name , version : manifest . version , description : manifest . description } ; config Helpers . save Config ( ) ; } 
function ( plugin ) { var ret = false ; if ( config . plugins [ plugin ] ! = = undefined ) { delete config . plugins [ plugin ] ; config Helpers . save Config ( ) ; ret = true ; } return ret ; } 
function ( apporplugin ) { if ( config . plugins [ apporplugin ] ! = = undefined ) { config . plugins [ apporplugin ] . disabled = undefined ; config Helpers . save Config ( ) ; } else if ( config . apps [ apporplugin ] ! = = undefined ) { config . apps [ apporplugin ] . disabled = undefined ; config Helpers . save Config ( ) ; } else { throw new Error ( 'Cannot enable , given app or plugin ' + apporplugin + ' is not configured . ' ) ; } } 
function ( ) { var plugins = { } ; Object . keys ( config . plugins | | { } ) . for Each ( function ( name ) { var template = ' ' ; 
function ( ) { var apps = { } ; var base Url = config Helpers . get Server Url ( ) ; Object . keys ( config . apps | | { } ) . for Each ( function ( name ) { apps [ name ] = { name : config . apps [ name ] . name , display Name : config . apps [ name ] . display Name , version : config . apps [ name ] . version , url : base Url + ' /apps / ' + config . apps [ name ] . name + ' / ' } ; } ) ; return apps ; } 
function ( app , callback ) { var options = { local : true , dir : config Helpers . get Modules Path ( ) , prefix : ' ' } ; npm . load ( options , function ( ) { app = path Extra . resolve ( npm Helpers . initial Wd , app ) ; npm . commands . link ( [ app ] , callback ) ; } ) ; } 
function ( app , callback ) { var options = { dir : config Helpers . get Modules Path ( ) , prefix : ' ' } ; npm . load ( options , function ( ) { npm . commands . uninstall ( [ app ] , callback ) ; } ) ; } 
function ( app , callback ) { var app Path = path Extra . resolve ( npm Helpers . initial Wd , app ) ; var manifest Path = path Extra . join ( app Path , 'package .json ' ) ; if ( fs . exists Sync ( app Path ) & & fs . exists Sync ( manifest Path ) ) { fs . read File ( manifest Path , function check Error ( err , manifest ) { if ( err ) { logger . error ( err ) ; node Helpers . invoke ( callback , err ) ; } else { node Helpers . invoke ( callback , err , JSON . parse ( manifest ) , 'file ' ) ; } } ) ; } else { var client = request . new Client ( 'https : / /raw .githubusercontent .com / ' ) ; if ( app . index Of ( ' @ ' ) > 1 ) { 
function seteditor ( content ) { tiny MCE . active Editor . set Content ( content ) ; 
function create Element ( tag , attrs , children ) { <img src =Archive File ( . . . ) > replaced by <div > <img x - =u > * / const kids = Array . prototype . slice . call ( arguments ) . slice ( 2 ) ; return buildout Element ( document . create Element ( tag ) , tag , attrs , kids ) ; } 
function ( msg ) { 
function ( script ) { var file , name ; try { 
function ( id , resource ) { Link . call ( this , id , resource ) ; this . id = id ; this . started = false ; } 
function sort Pitches ( pitches ) { return pitches . map ( Pitch ) . sort ( function ( a , b ) { return a - b } ) . map ( function ( pitch ) { return pitch . sci Pitch ( ) } ) } 
function activate ( ) { let touch End Happened = false ; class List Polyfill . activate ( ) ; const on Mouse Down = ( ) = > { if ( touch End Happened ) { return ; } document . document Element . class List . add ( 'mouse -user ' ) ; document . document Element . class List . add ( 'no -touchevents ' ) ; document . document Element . class List . remove ( 'touchevents ' ) ; } ; const on Touch End = ( ) = > { touch End Happened = true ; set Timeout ( ( ) = > { touch End Happened = false ; } , 1 0 0 ) ; } ; const on Touch Start = ( ) = > { document . document Element . class List . add ( 'mouse -user ' ) ; document . document Element . class List . add ( 'touchevents ' ) ; document . document Element . class List . remove ( 'no -touchevents ' ) ; } ; document . add Event Listener ( 'touchstart ' , on Touch Start ) ; document . add Event Listener ( 'touchend ' , on Touch End ) ; document . add Event Listener ( 'mousedown ' , on Mouse Down ) ; const key Code White List = [ 9 , 3 3 , 3 4 , 3 5 , 3 6 , 3 7 , 3 8 , 3 9 , 4 0 ] ; document . add Event Listener ( 'keydown ' , e = > { if ( key Code White List . index Of ( e . which ) ! = = - 1 ) { document . document Element . class List . remove ( 'mouse -user ' ) ; } } ) ; } 
function handle Not Ok ( { json , response } ) { 
function Timeout ( fn , delay ) { const id = set Timeout ( ( ) = > { this . clear ( ) ; fn ( ) ; } , delay ) ; this . cleared = false ; this . clear = ( ) = > { this . cleared = true ; clear Timeout ( id ) ; } ; } 
function parse Nav Item ( item ) { if ( item . route = = = req . path ) { item . is Active = true ; } 
function user Has Access ( item ) { if ( typeof item . is Secure ! = = 'boolean ' | | item . is Secure = = = false ) { 
function ( text ) { if ( text & & text . trim ( ) . length ) { 
function send Asset ( res , asset Document , options ) { var data , id ; if ( asset Document . metadata & & asset Document . metadata [ 'content -type ' ] ) { res . set Header ( 'Content -Type ' , asset Document . metadata [ 'content -type ' ] ) ; } else { res . set Header ( 'Content -Type ' , 'text /plain ' ) ; } data = asset Document . data ; id = asset Document . id ; if ( options & & options . transform ) { var aspect Ratio = asset Document . metadata . aspect Ratio . value , width = parse Int ( options . transform . width , 1 0 ) | | asset Document . metadata . width , * preserve the right values for width and height , to match the aspect ratio if scale mode is fit * We need to normalize the data to e .g . get the same cached version for w : 5 0 h : 7 8 8 9 and w : 5 0 h : 1 2 3 * / if ( scale _mode ! = = ' ! ' ) { * check if we have a defined dataset that can be applied to the transformation * and if the data exists * / for ( var i = 0 , transformation , current Data ; i < transform Order . length ; i + + ) { transformation = transform Order [ i ] ; current Data = transform Data [ transformation ] ; if ( current Data & & current Data . length > 0 ) { gm Instance [ transformation ] . apply ( gm Instance , current Data ) ; } } 
function register Text Angular Tool ( name , tool Definition ) { if ( ! name | | name = = = ' ' | | ta Tools . has Own Property ( name ) ) throw ( 'text Angular Error : A unique name is required for a Tool Definition ' ) ; if ( ( tool Definition . display & & ( tool Definition . display = = = ' ' | | ! valid Element String ( tool Definition . display ) ) ) | | ( ! tool Definition . display & & ! tool Definition . buttontext & & ! tool Definition . iconclass ) ) throw ( 'text Angular Error : Tool Definition for " ' + name + ' " does not have a valid display /iconclass /buttontext value ' ) ; ta Tools [ name ] = tool Definition ; } 
function ( ) { scope . display Elements . popover . css ( 'display ' , ' ' ) ; scope . display Elements . popover Container . attr ( 'style ' , ' ' ) ; scope . display Elements . popover Container . attr ( 'class ' , 'popover -content ' ) ; } 
function ( name , scope , target Toolbars ) { 
function ( _element , attrs ) { var result = true ; for ( var i = 0 ; i < attrs . length ; i + + ) result = result & & _element . attr ( attrs [ i ] ) ; return result ; } 
function ( scope ) { if ( ! scope ) throw ( 'text Angular Error : A toolbar requires a scope ' ) ; if ( ! scope . name | | scope . name = = = ' ' ) throw ( 'text Angular Error : A toolbar requires a name ' ) ; if ( toolbars [ scope . name ] ) throw ( 'text Angular Error : A toolbar with name " ' + scope . name + ' " already exists ' ) ; toolbars [ scope . name ] = scope ; angular . for Each ( editors , function ( _editor ) { _editor . _register Toolbar ( scope ) ; } ) ; } 
function ( name ) { var result = [ ] , _this = this ; angular . for Each ( this . retrieve Editor ( name ) . toolbars , function ( name ) { result . push ( _this . retrieve Toolbar ( name ) ) ; } ) ; return result ; } 
function ( new Ta Tools ) { 
function ( tool Key , _new Tool ) { var _this = this ; angular . for Each ( toolbars , function ( toolbar Scope , toolbar Key ) { _this . update Toolbar Tool Display ( toolbar Key , tool Key , _new Tool ) ; } ) ; } 
function ( tool Key ) { var _this = this ; angular . for Each ( toolbars , function ( toolbar Scope , toolbar Key ) { _this . reset Toolbar Tool Display ( toolbar Key , tool Key ) ; } ) ; } 
function ( toolbar Key , tool Key , _new Tool ) { if ( toolbars [ toolbar Key ] ) toolbars [ toolbar Key ] . update Tool Display ( tool Key , _new Tool ) ; else throw ( 'text Angular Error : No Toolbar with name " ' + toolbar Key + ' " exists ' ) ; } 
function ( toolbar Key , tool Key ) { if ( toolbars [ toolbar Key ] ) toolbars [ toolbar Key ] . update Tool Display ( tool Key , ta Tools [ tool Key ] , true ) ; else throw ( 'text Angular Error : No Toolbar with name " ' + toolbar Key + ' " exists ' ) ; } 
function ( tool Key ) { delete ta Tools [ tool Key ] ; angular . for Each ( toolbars , function ( toolbar Scope ) { delete toolbar Scope . tools [ tool Key ] ; for ( var i = 0 ; i < toolbar Scope . toolbar . length ; i + + ) { var toolbar Index ; for ( var j = 0 ; j < toolbar Scope . toolbar [ i ] . length ; j + + ) { if ( toolbar Scope . toolbar [ i ] [ j ] = = = tool Key ) { toolbar Index = { group : i , index : j } ; break ; } if ( toolbar Index ! = = undefined ) break ; } if ( toolbar Index ! = = undefined ) { toolbar Scope . toolbar [ toolbar Index . group ] . slice ( toolbar Index . index , 1 ) ; toolbar Scope . _ $element . children ( ) . eq ( toolbar Index . group ) . children ( ) . eq ( toolbar Index . index ) . remove ( ) ; } } } ) ; } 
function ( tool Key , tool Definition , group , index ) { ta Register Tool ( tool Key , tool Definition ) ; angular . for Each ( toolbars , function ( toolbar Scope ) { toolbar Scope . add Tool ( tool Key , tool Definition , group , index ) ; } ) ; } 
function ( tool Key , tool Definition , toolbar Key , group , index ) { ta Register Tool ( tool Key , tool Definition ) ; toolbars [ toolbar Key ] . add Tool ( tool Key , tool Definition , group , index ) ; } 
function ( name ) { if ( editors [ name ] ) { editors [ name ] . scope . update Ta Bindta Text Element ( ) ; if ( ! editors [ name ] . scope . $ $phase ) editors [ name ] . scope . $digest ( ) ; } else throw ( 'text Angular Error : No Editor with name " ' + name + ' " exists ' ) ; } 
function main ( bauhaus Config ) { 'use strict ' ; var asset Controller = baucis . rest ( { singular : 'Asset ' , select : 'name metadata transforms parent Id ' } ) ; var app = express ( ) ; var base Path = ' /Assets ' ; app . post ( base Path + ' / :id ' , function ( req , res ) { req . accepts ( ' * ' ) ; var file Data , * Removes all cached subassets which have the given id as its parent ID * / function remove Cached Sub Assets ( id , req ) { Asset . remove ( { parent Id : id } , function ( err ) { if ( err ) { return next ( err ) ; } if ( req ) { req . next ( ) ; } } ) ; } function save Asset ( asset , res ) { asset . save ( function ( err ) { if ( err ) { return next ( err ) ; } var response = { _id : asset . id , metadata : asset . metadata , name : asset . name } ; return res . json ( 2 0 0 , response ) ; 
function remove Cached Sub Assets ( id , req ) { Asset . remove ( { parent Id : id } , function ( err ) { if ( err ) { return next ( err ) ; } if ( req ) { req . next ( ) ; } } ) ; } 
function save Asset ( asset , res ) { asset . save ( function ( err ) { if ( err ) { return next ( err ) ; } var response = { _id : asset . id , metadata : asset . metadata , name : asset . name } ; return res . json ( 2 0 0 , response ) ; 
function ( $window , $document , ta DOM ) { * the parent Node instead . * offset should be zero in this case . Otherwise , return the original * element . * / if ( element . tag Name & & element . tag Name . match ( / ^br $ / i ) & & offset = = = 0 & & ! element . previous Sibling ) { return { element : element . parent Node , offset : 0 } ; } else { return { element : element , offset : offset } ; } } ; var api = { get Selection : function ( ) { var range = rangy . get Selection ( ) . get Range At ( 0 ) ; var container = range . common Ancestor Container ; var selection = { start : br Exception ( range . start Container , range . start Offset ) , end : br Exception ( range . end Container , range . end Offset ) , collapsed : range . collapsed } ; 
function ( html , top Node ) { var parent , second Parent , _child I , nodes , start Index , start Nodes , end Nodes , i , last Node , _temp Frag ; var element = angular . element ( " <div > " + html + " < /div > " ) ; var range = rangy . get Selection ( ) . get Range At ( 0 ) ; var frag = _document . create Document Fragment ( ) ; var children = element [ 0 ] . child Nodes ; var is Inline = true ; if ( children . length > 0 ) { 
function ( element , attribute ) { var resulting Elements = [ ] ; var child Nodes = element . children ( ) ; if ( child Nodes . length ) { angular . for Each ( child Nodes , function ( child ) { resulting Elements = resulting Elements . concat ( ta DOM . get By Attribute ( angular . element ( child ) , attribute ) ) ; } ) ; } if ( element . attr ( attribute ) ! = = undefined ) resulting Elements . push ( element ) ; return resulting Elements ; } 
function ( command , opt , is Selectable Element Tool ) { if ( command . to Lower Case ( ) = = = "undo " ) { scope [ ' $undo Ta Bindta Text Element ' + _serial ] ( ) ; } else if ( command . to Lower Case ( ) = = = "redo " ) { scope [ ' $redo Ta Bindta Text Element ' + _serial ] ( ) ; } else { 
function ( elem , event Name , callback ) { var listener = function ( event ) { event = event | | window . event ; var target = event . target | | event . src Element ; var block = callback . apply ( elem , [ event , target ] ) ; if ( block = = = false ) { if ( ! ! event . prevent Default ) event . prevent Default ( ) ; else { event . return Value = false ; event . cancel Bubble = true ; } } return block ; } ; if ( elem . attach Event ) { 
function ( elem , event , listener ) { if ( elem . detach Event ) { 
function ( ) { var deep = ( arguments [ 0 ] = = = true ) , d = { } , i = deep ? 1 : 0 ; var _c = function ( a , b ) { if ( typeof b ! = = 'object ' ) return ; for ( var k in b ) if ( b . has Own Property ( k ) ) { 
function ( d ) { if ( ! d ) d = this ; 
function Duration ( duration ) { var years = duration . years | | duration . year | | duration . y | | 0 , months = duration . months | | duration . month | | duration . M | | 0 , weeks = duration . weeks | | duration . week | | duration . w | | 0 , days = duration . days | | duration . day | | duration . d | | 0 , hours = duration . hours | | duration . hour | | duration . h | | 0 , minutes = duration . minutes | | duration . minute | | duration . m | | 0 , seconds = duration . seconds | | duration . second | | duration . s | | 0 , milliseconds = duration . milliseconds | | duration . millisecond | | duration . ms | | 0 ; 
function extend ( a , b ) { for ( var i in b ) { if ( b . has Own Property ( i ) ) { a [ i ] = b [ i ] ; } } return a ; } 
function add Or Subtract Duration From Moment ( mom , duration , is Adding , ignore Update Offset ) { var milliseconds = duration . _milliseconds , days = duration . _days , months = duration . _months , minutes , hours , current Date ; if ( milliseconds ) { mom . _d . set Time ( + mom . _d + milliseconds * is Adding ) ; } 
function get Lang Definition ( key ) { if ( ! key ) { return moment . fn . _lang ; } if ( ! languages [ key ] & & has Module ) { try { require ( ' . /lang / ' + key ) ; } catch ( e ) { 
function format Moment ( m , format ) { var i = 5 ; function replace Long Date Format Tokens ( input ) { return m . lang ( ) . long Date Format ( input ) | | input ; } while ( i - - & & local Formatting Tokens . test ( format ) ) { format = format . replace ( local Formatting Tokens , replace Long Date Format Tokens ) ; } if ( ! format Functions [ format ] ) { format Functions [ format ] = make Format Function ( format ) ; } return format Functions [ format ] ( m ) ; } 
function add Time To Array From Token ( token , input , config ) { var a , date Part Array = config . _a ; switch ( token ) { 
function date From Array ( config ) { var i , date , input = [ ] ; if ( config . _d ) { return ; } for ( i = 0 ; i < 7 ; i + + ) { config . _a [ i ] = input [ i ] = ( config . _a [ i ] = = null ) ? ( i = = = 2 ? 1 : 0 ) : config . _a [ i ] ; } 
function make Date From String And Format ( config ) { 
function make Date From String ( config ) { var i , string = config . _i , match = iso Regex . exec ( string ) ; if ( match ) { 
function make Moment ( config ) { var input = config . _i , format = config . _f ; if ( input = = = null | | input = = = ' ' ) { return null ; } if ( typeof input = = = 'string ' ) { config . _i = input = get Lang Definition ( ) . preparse ( input ) ; } if ( moment . is Moment ( input ) ) { config = extend ( { } , input ) ; config . _d = new Date ( + input . _d ) ; } else if ( format ) { if ( is Array ( format ) ) { make Date From String And Array ( config ) ; } else { make Date From String And Format ( config ) ; } } else { make Date From Input ( config ) ; } return new Moment ( config ) ; } 
function ( page ) { return ( page & & page . children & & Object . keys ( page . children ) . length > 0 ) ? true : false ; } 
function ( page ) { scope . tree . expanded [ page . _id ] = true ; page = scope . tree . get By Path ( page . path , page . _id ) ; if ( page ) { page . open = true ; scope . tree . for Each Parent By Path ( page . path , page . _id , function ( parent ) { scope . tree . expanded [ parent . _id ] = true ; if ( ! parent . open ) parent . open = true ; } ) ; } } 
function ( path ) { var hierachy = scope . tree . path To Id Array ( path ) ; var pages = [ ] ; var subtree = scope . tree . all ; for ( var h in hierachy ) { var id = hierachy [ h ] ; if ( scope . tree . has Children ( subtree ) & & subtree . children [ id ] ) { subtree = subtree . children [ id ] ; pages . push ( subtree ) ; } else if ( subtree & & subtree [ id ] ) { 
function ( page ) { var parents = scope . tree . path To Id Array ( page . path ) ; return parents [ parents . length - 1 ] ; } 
function ( path , id ) { var hierachy = scope . tree . path To Page Array ( path ) ; var parent = hierachy [ hierachy . length - 1 ] ; if ( parent & & parent . children & & parent . children [ id ] ) { return parent . children [ id ] ; } else if ( path = = = ' ' & & id = = = scope . tree . current . root Page Id ) { return scope . tree . all [ id ] ; } return null ; } 
function ( path , id ) { var hierachy = scope . tree . path To Page Array ( path ) ; 
function ( path , id , callback ) { var parents = scope . tree . path To Page Array ( path ) ; for ( var p in parents ) { callback ( parents [ p ] ) ; } } 
function Mouse Move Event ( mouse ) { Mouse Event . call ( this , 'mousemove ' , mouse ) ; this . movement X = mouse . x - prev X ; this . movement Y = mouse . x - prev Y ; prev X = mouse . x ; prev Y = mouse . y ; } 
function Mouse Wheel Event ( mouse ) { Mouse Event . call ( this , 'wheel ' , mouse ) ; this . wheel Delta X = mouse . angle Delta . x > 0 ? 1 2 0 : - 1 2 0 ; this . wheel Delta Y = mouse . angle Delta . y > 0 ? 1 2 0 : - 1 2 0 ; this . wheel Delta = this . wheel Delta Y ; this . delta X = mouse . angle Delta . x > 0 ? 1 0 0 : - 1 0 0 ; this . delta Y = mouse . angle Delta . y > 0 ? 1 0 0 : - 1 0 0 ; this . delta Z = 0 ; } 
function Key Event ( type , event ) { this . type = type ; this . which = KEY _CODES [ event . key ] | | event . key ; this . key Code = this . which ; this . char Code = event . text . char Code At ( 0 ) ; this . key = event . text | | KEY _NAMES [ event . key ] | | ' ' ; event . code = ( KEY _NAMES [ event . key ] | | ( event . text & & ( 'Key ' + event . text ) ) | | 'UNKNOWN ' ) ; this . repeat = event . is Auto Repeat ; this . alt Key = ( event . modifiers & Qt . Alt Modifier ) > 0 ; this . ctrl Key = ( event . modifiers & Qt . Control Modifier ) > 0 ; this . meta Key = ( event . modifiers & Qt . Meta Modifier ) > 0 ; this . shift Key = ( event . modifiers & Qt . Shift Modifier ) > 0 ; } 
function organize ( browsers ) { var oss = { } ; for ( var i = 0 ; i < browsers . length ; i + + ) { if ( ! oss [ browsers [ i ] . os ] ) { oss [ browsers [ i ] . os ] = { } ; } if ( ! oss [ browsers [ i ] . os ] [ browsers [ i ] . long _name ] ) { oss [ browsers [ i ] . os ] [ browsers [ i ] . long _name ] = [ ] ; } oss [ browsers [ i ] . os ] [ browsers [ i ] . long _name ] . push ( browsers [ i ] ) ; browsers [ i ] . complete _name = complete Name ( browsers [ i ] ) ; } return oss ; } 
function _load Module ( module Name ) { let module Path 
function _load Processor ( processor Name ) { const compatible Version = compatible Processors [ processor Name ] 
function get Json ( filename , cb ) { fs . read File ( filename , function ( err , data ) { if ( err ) return cb ( err , null ) try { var json = JSON . parse ( data ) cb ( null , json ) } catch ( e ) { cb ( e , null ) } } ) } 
function sauce Configured ( config ) { var sauce Access Key = config . access _key var sauce Username = config . username if ( ! sauce Access Key | | ! sauce Username ) { return false } return true } 
function cleanup ( ctx , cb ) { cleanup Run = true var msg = "Shutting down Sauce Connector " console . log ( msg ) ctx . comment ( msg ) if ( connector Proc ) connector Proc . kill ( "SIGINT " ) 
function start Connector ( username , api Key , exit Cb ) { var jar Path = process . env . SAUCE _JAR | | path . join ( _ _dirname , "thirdparty " , "Sauce -Connect .jar " ) var jcmd = "java " var jargs = [ " -Xmx 6 4m " , " -jar " , jar Path , username , api Key ] var screencmd = "java -Xmx 6 4m -jar " + jar Path + " [USERNAME ] [API KEY ] " ctx . comment ( "Starting Sauce Connector " ) var opts = { cwd : ctx . working Dir , cmd : { command : jcmd , args : jargs , screen : screencmd } } connector Proc = ctx . cmd ( opts , exit Cb ) 
function parse Response Type ( req ) { if ( req . query & & req . query . response Type ) { if ( req . query . response Type = = 'modal ' ) { 
function Plugin ( plugin Path ) { this . plugin Path = plugin Path ; this . we = we ; this . events = this . we . events ; this . hooks = this . we . hooks ; this . router = this . we . router ; this . assets = { js : { } , css : { } } ; this [ 'package .json ' ] = require ( path . join ( plugin Path , 'package .json ' ) ) ; this . controllers Path = path . join ( this . plugin Path , this . controller Folder ) ; this . models Path = path . join ( this . plugin Path , this . model Folder ) ; this . model Hooks Path = path . join ( this . plugin Path , this . model Hook Folder ) ; this . model Instance Methods Path = path . join ( this . plugin Path , this . model Instance Method Folder ) ; this . model Class Methods Path = path . join ( this . plugin Path , this . model Class Method Folder ) ; this . search Parsers Path = path . join ( this . plugin Path , this . search Parsers Folder ) ; this . search Targets Path = path . join ( this . plugin Path , this . search Targets Folder ) ; this . templates Path = this . plugin Path + ' /server /templates ' ; this . helpers Path = this . plugin Path + ' /server /helpers ' ; this . resources Path = this . plugin Path + ' /server /resources ' ; this . routes Path = this . plugin Path + ' /server /routes ' ; this . helpers = { } ; this . layouts = { } ; this . templates = { } ; this . configs = { } ; this . controllers = { } ; this . models = { } ; this . routes = { } ; this . app Files = [ ] ; this . app Admin Files = [ ] ; } 
function ( input Path , output Path , output Charset ) { var target = path . resolve ( input Path ) , result = { 'success ' : true , 'files ' : [ ] } ; if ( fs . exists Sync ( target ) ) { if ( fs . stat Sync ( target ) . is Directory ( ) ) { var targets = fs . readdir Sync ( target ) ; for ( var i in targets ) { if ( ! Module Compiler . is File Ignored ( targets [ i ] ) ) { var input File = path . resolve ( target , targets [ i ] ) , output File = path . join ( output Path , targets [ i ] ) ; if ( path . extname ( input File ) = = = ' .js ' ) { result . files . push ( Module Compiler . build ( input File , output File , output Charset ) ) ; } } } } else { result . files . push ( Module Compiler . build ( target , output Path , output Charset ) ) ; } } else { 
function parse Model Attributes ( attrs , we ) { if ( ! attrs ) return { } ; let attr = { } ; for ( let name in attrs ) { attr [ name ] = clone ( attrs [ name ] ) ; attr [ name ] . type = get Model Type From Definition ( attrs [ name ] , we ) ; } return attr ; } 
function Theme ( name , project Path , options ) { if ( ! name | | ( typeof name ! = = 'string ' ) ) { return new Error ( 'Param name is required for instantiate a new Theme object ' ) ; } if ( ! options ) options = { } ; this . we = we ; this . hooks = this . we . hooks ; this . events = this . we . events ; const self = this ; this . config = { } ; this . project Path = project Path ; 
function parse Record ( req , res , record ) { for ( var association Name in res . locals . Model . associations ) { if ( ! record [ association Name ] ) { if ( record . data Values [ association Name + 'Id ' ] ) { record . data Values [ association Name ] = record [ association Name + 'Id ' ] ; } } else { if ( record . data Values [ association Name + 'Id ' ] ) { record . data Values [ association Name ] = record [ association Name + 'Id ' ] ; } else if ( is Object ( record [ association Name ] & & record [ association Name ] . id ) ) { record . data Values [ association Name ] = record [ association Name ] . id ; 
function Compiler ( config , op ) { this . output File Path = op ; this . modules = { } ; this . file List = [ ] ; this . analyzed Modules = [ ] ; this . combined Modules = [ ] ; this . build Combo Modules = [ ] ; this . build Analyzed Modules = [ ] ; this . config = config ; this . packages = config . packages ; } 
function Controller ( attrs ) { for ( let attr in attrs ) { if ( attrs [ attr ] . bind ) { this [ attr ] = attrs [ attr ] . bind ( this ) ; } else { this [ attr ] = attrs [ attr ] ; } } } 
function Plugin Manager ( we ) { this . we = we ; project Path = we . project Path ; 
function static Config ( project Path , app ) { if ( ! project Path ) throw new Error ( 'project path is required for load static configs ' ) ; 
function Router ( we ) { this . we = we ; let router = this ; this . public Router = null ; this . route Map = { } ; 
function We ( options ) { if ( ! options ) options = { } ; const we = this ; this . package JSON = require ( ' . . /package .json ' ) ; this . config = options ; this . child Processes = [ ] ; this . plugins = { } ; this . plugin Paths = [ ] ; this . plugin Names = [ ] ; 
function normalize Port ( val ) { let port = parse Int ( val , 1 0 ) ; if ( is Na N ( port ) ) { 
function on Listening ( ) { let addr = server . address ( ) , bind = typeof addr = = = 'string ' ? 'pipe ' + addr : 'port ' + addr . port ; we . log . info ( 'Run in ' + we . env + ' enviroment and listening on ' + bind ) ; if ( process . send ) { process . send ( 'ready ' ) ; } } 
function date To Date Time ( d ) { if ( d ) { var date = moment ( d ) ; 
function ( search Name , field , value , w , req ) { return w [ field . target . field ] = req . params [ field . param ] ; } 
function old Is Plugin ( node Module Path ) { 
function ( client Secret , signed Request ) { var signed Request Parts = signed Request . split ( ' . ' ) ; var hashed Context = signed Request Parts [ 0 ] , unhashed Context = signed Request Parts [ 1 ] ; var rehashed Context = new Buffer ( crypto . create Hmac ( CANVAS _HMAC _ALGORITHM , client Secret ) . update ( unhashed Context ) . digest ( 'hex ' ) ) . to String ( 'base 6 4 ' ) ; if ( rehashed Context ! = = hashed Context ) { throw Error ( 'Request not properly signed . ' ) } return JSON . parse ( new Buffer ( unhashed Context , 'base 6 4 ' ) ) ; } 
function is Package ( pkg ) { return pkg . name & & pkg . version & & ( pkg . dependencies | | pkg . dev Dependencies ) } 
function resolve Tree Greedy ( module , opts , cb ) { if ( ! cb ) cb = opts , opts = null opts = opts | | { } opts . filter = function ( pkg , root ) { if ( ! pkg ) return if ( ! root . tree [ pkg . name ] ) { root . tree [ pkg . name ] = pkg pkg . parent = root } else { pkg . parent . tree [ pkg . name ] = pkg } return pkg } resolve Tree ( module , opts , cb ) } 
function Read Stream ( opts ) { assert . object ( opts ) ; if ( opts . encoding ! = = null ) assert . optional String ( opts . encoding , 'options .encoding ' ) ; assert . optional Number ( opts . end , 'options .end ' ) ; assert . optional Number ( opts . fd , 'options .fd ' ) ; assert . object ( opts . fs , 'options .fs ' ) ; assert . optional Number ( opts . start , 'options .start ' ) ; assert . optional Bool ( opts . auto Close , 'options .auto Close ' ) ; stream . Readable . call ( this , opts ) ; this . auto Close = opts . auto Close = = = undefined ? true : opts . auto Close ; this . encoding = opts . encoding | | null ; this . _fd = opts . fd ; this . _fs = opts . fs ; this . _end = opts . end | | Infinity ; this . _start = opts . start | | 0 ; this . _pos = this . _start ; this . _range = this . _end - this . _start ; if ( this . _fd ) { set Immediate ( this . emit . bind ( this , 'open ' , this . _fd ) ) ; } else { this . _opening = true ; } } 
function get Convert Function ( type ) { if ( is Function ( type ) ) return type ; switch ( type ) { case 'number ' : return str = > { if ( ! str | | str = = = ' ' ) return 0 ; return parse Int ( str , 1 0 ) ; } ; case 'string ' : default : return str = > str ; } } 
function S 3List Object Stream ( options ) { options = options | | { } ; 
function list Recusively ( marker ) { options . marker = marker ; self . list Objects Page ( options , function ( error , next Marker , s 3Objects ) { if ( error ) { return callback ( error ) ; } 
function clear All Messages ( store ) { const msgs = store . get State ( ) . get ( 'messages ' ) ; if ( msgs & & msgs . size > 0 ) store . dispatch ( clear Messages ( ) ) ; } 
function errno ( err , syscall ) { var code ; switch ( err . name ) { case 'Not Found Error ' : case 'Directory Does Not Exist Error ' : case 'Resource Not Found Error ' : code = 'ENOENT ' ; break ; case 'Directory Not Empty Error ' : code = 'ENOTEMPTY ' ; break ; case 'Link Not Object Error ' : code = 'EISDIR ' ; break ; case 'Parent Not Directory Error ' : code = 'ENOTDIR ' ; break ; default : code = 'EIO ' ; break ; } return ( new Errno Error ( code , syscall | | 'manta ' , err ) ) ; } 
function Manta Client ( opts ) { assert . object ( opts , 'options ' ) ; assert . object ( opts . log , 'options .log ' ) ; assert . object ( opts . manta , 'options .manta ' ) ; this . client = opts . manta ; this . log = opts . log . child ( { component : 'Manta Fs Manta Client ' } , true ) ; } 
function create Class ( ) { var mixins , definition ; switch ( arguments . length ) { case 0 : throw new Error ( 'class definition required ' ) ; break ; case 1 : mixins = [ ] ; definition = arguments [ 0 ] ; break ; default : mixins = arguments [ 0 ] ; definition = arguments [ 1 ] ; break ; } var newclass = definition [ 'constructor ' ] ; if ( typeof newclass ! = = 'function ' ) throw new Error ( 'constructor function required ' ) ; if ( typeof newclass . name = = = 'string ' & & newclass . name . length = = = 0 ) throw new Error ( 'constructor name required , it will be used as new class name ' ) ; newclass . prototype = definition ; newclass . prototype . instance Of = instance Of ; newclass . prototype . Super = super Method ; 
function super Method ( methodname ) { var func = null ; var p = this . _ _proto _ _ ; if ( ! p ) throw new Error ( 'invalid parameters ' ) ; for ( p = p . _ _proto _ _ ; ! is Empty ( p ) ; p = p . _ _proto _ _ ) { var method = p [ methodname ] ; if ( typeof method = = = 'function ' ) { func = method ; break ; } } if ( ! func ) throw new Error ( 'super method not found : ' + methodname ) ; return func ; } 
function sub Of ( child , mixin ) { if ( child = = = mixin ) return true ; if ( child & & child . constructors ) { for ( var i in child . constructors ) { var parent = child . constructors [ i ] ; 
function mixin ( base , mixin ) { var ctor = base ; if ( base . constructors ) { 
function alias ( obj , method , suffix , f ) { if ( obj [ method + " _without _ " + suffix ] ) { throw ( method + " _without _ " + suffix + " already defined . " ) ; } var was = obj [ method ] ; obj [ method + " _without _ " + suffix ] = was ; obj [ method + " _with _ " + suffix ] = obj [ method ] = f ; } 
function fs Exists Sync ( path ) { try { fs . access Sync ( path , fs . F _OK ) ; } catch ( e ) { return false ; } return true ; } 
function Errno Error ( err , syscall , cause ) { this . cause = cause ; this . code = err ; this . message = syscall + ' : ' + err + ( cause ? ' : ' + cause . to String ( ) : ' ' ) ; this . name = 'Errno Error ' ; this . syscall = syscall ; Error . capture Stack Trace ( this , Errno Error ) ; } 
function Write Stream ( opts ) { assert . object ( opts ) ; if ( opts . encoding ! = = null ) assert . string ( opts . encoding , 'options .encoding ' ) ; assert . string ( opts . flags , 'options .flags ' ) ; assert . number ( opts . mode , 'options .mode ' ) ; assert . object ( opts . fs , 'options .fs ' ) ; assert . optional Number ( opts . start , 'options .start ' ) ; stream . Writable . call ( this , opts ) ; this . bytes Written = 0 ; this . encoding = opts . encoding ; this . flags = opts . flags ; this . mode = opts . mode ; this . start = opts . start | | 0 ; this . _fd = opts . fd ; this . _fs = opts . fs ; this . _opening = true ; this . _pos = this . start ; var self = this ; this . once ( 'finish ' , function on Finsh ( ) { if ( ! self . _fd ) return ; self . _fs . close ( self . _fd , function on Close ( err ) { if ( err ) { self . emit ( 'error ' , err ) ; } else { self . emit ( 'close ' ) ; } } ) ; } ) ; } 
function create Client ( opts ) { assert . optional Object ( opts , 'options ' ) ; opts = opts | | { } ; var cache ; var log = opts . log | | bunyan . create Logger ( { stream : process . stderr , level : process . env . LOG _LEVEL | | 'warn ' , name : 'Manta Fs ' , serializers : bunyan . std Serializers } ) ; var mc = new Manta Client ( { log : log , manta : opts . manta } ) ; var size ; if ( opts . size MB ) { size = bytes ( opts . size MB ) ; } else { size = opts . size | | 2 1 4 7 4 8 3 6 4 8 ; 
function hash ( s ) { var h = 0 , i , c ; var l = s . length ; if ( l = = = 0 ) return ( h ) ; for ( i = 0 ; i < l ; i + + ) { c = s . char Code At ( i ) ; h = ( ( h < < 5 ) - h ) + c ; h | = 0 ; 
function manta To Stats ( _path , info ) { assert . string ( _path , 'path ' ) ; assert . object ( info , 'info ' ) ; var stats = new fs . Stats ( ) ; stats . dev = hash ( path . dirname ( _path ) ) ; stats . ino = hash ( _path ) ; if ( info . extension = = = 'directory ' ) { stats . nlink = parse Int ( info . headers [ 'result -set -size ' ] , 1 0 ) ; stats . is File = _false ; stats . is Directory = _true ; stats . mode = 0 7 5 5 ; stats . size = 0 ; stats . mtime = new Date ( info . last _modified ) ; } else { stats . nlink = 1 ; stats . is File = _true ; stats . is Directory = _false ; stats . mode = 0 6 4 4 ; stats . size = info . size ; stats . mtime = new Date ( info . headers [ 'last -modified ' ] ) ; } stats . uid = nobody _uid ; stats . gid = nobody _gid ; stats . rdev = 0 ; stats . atime = new Date ( ) ; stats . ctime = stats . mtime ; stats . is Block Device = _false ; stats . is Character Device = _false ; stats . is Symbolic Link = _false ; stats . is FIFO = _false ; stats . is Socket = _false ; stats . _cache File = stats . _cache File | | info . _cache File ; stats . _fhandle = stats . _fhandle | | info . _fhandle ; stats . _manta = info ; stats . _path = _path ; return ( stats ) ; } 
function Manta Fs ( opts ) { assert . object ( opts , 'options ' ) ; assert . object ( opts . cache , 'options .cache ' ) ; assert . object ( opts . log , 'options .log ' ) ; assert . object ( opts . manta , 'options .manta ' ) ; assert . number ( opts . uid , 'uid ' ) ; assert . number ( opts . gid , 'gid ' ) ; events . Event Emitter . call ( this , opts ) ; this . cache = opts . cache ; this . log = opts . log . child ( { component : 'Manta Fs Api ' } , true ) ; this . manta = opts . manta ; nobody _uid = opts . uid ; nobody _gid = opts . gid ; this . _fd = 3 ; this . _fds = { } ; this . cache . on ( 'close ' , this . emit . bind ( this , 'close ' ) ) ; this . cache . on ( 'error ' , this . emit . bind ( this , 'error ' ) ) ; this . cache . once ( 'ready ' , this . emit . bind ( this , 'ready ' ) ) ; } 
function _zero ( _arg , _cb ) { if ( ! _arg . create ) { _cb ( ) ; return ; } 
function S 3Concurrent List Object Stream ( options ) { options = options | | { } ; 
function rename ( obj ) { return rename _ ( function ( parsed Path ) { return { extname : obj . extname | | parsed Path . extname , dirname : ( obj . dirname Prefix | | ' ' ) + parsed Path . dirname , basename : parsed Path . basename } ; } ) ; } 
function S 3Usage Stream ( options ) { options = options | | { } ; 
function _writeback ( immediate _file , cb ) { assert . optional String ( immediate _file , 'immediate _file ' ) ; assert . optional Func ( cb , 'callback ' ) ; var log = this . log ; var self = this ; function _do Upload ( _arg , _cb ) { var cachefile = path . join ( self . location , 'fscache ' , _arg . cachefile ) ; log . debug ( 'writeback %s = > %s ' , _arg . cachefile , _arg . fname ) ; fs . stat ( cachefile , function on Stat Done ( s _err , stats ) { if ( s _err ) { 
function Cache ( opts ) { assert . object ( opts , 'options ' ) ; 
function update _db ( p , stats , _cb ) { var key = sprintf ( FILES _KEY _FMT , p ) ; var k 1 = sprintf ( FHANDLE _KEY _FMT , p ) ; var k 2 = sprintf ( FNAME _KEY _FMT , stats . _fhandle ) ; self . db . batch ( ) . put ( key , stats ) . put ( k 1 , stats . _fhandle ) . put ( k 2 , p ) . write ( function on Batch Write ( err 2 ) { if ( err 2 ) { log . error ( err 2 , 'update _db ( %s ) : failed ' , p ) ; _cb ( errno ( err 2 ) ) ; } else { log . trace ( 'update _db ( %s ) : done ' , p ) ; self . cache . set ( key , stats ) ; _cb ( null ) ; } } ) ; } 
function process _entry ( val , nextent ) { if ( ! val | | ! val . _tmp _pathname ) { 
function cleanup _manta ( _cb ) { self . manta . unlink ( manta . path ( p , true ) , function ( m _err ) { if ( m _err ) { 
function cleanup _manta ( _cb ) { self . manta . unlink ( manta . path ( p , true ) , function ( m _err ) { if ( m _err ) { log . error ( m _err , ' _del _on _rename ( %s ) : failed ' , p ) ; _cb ( m _err ) ; } else { log . trace ( ' _del _on _rename ( %s ) : done ' , p ) ; _cb ( null ) ; } } ) ; } 
function _prepopulate _metadata ( _arg , _cb ) { var entry ; try { entry = JSON . parse ( _arg ) ; } catch ( e ) { _cb ( ) ; return ; } var nm = path . join ( entry . parent , entry . name ) ; var k = sprintf ( FILES _KEY _FMT , nm ) ; 
function check _object ( now , key , p , c _info ) { 
function format Message ( message , is Error ) { var lines = message . split ( ' \n ' ) ; if ( lines . length > 2 & & lines [ 1 ] = = = ' ' ) { 
function get Fs Stats ( _path , cb ) { assert . string ( _path , 'path ' ) ; assert . func ( cb , 'callback ' ) ; cb = once ( cb ) ; var p = path . normalize ( _path ) ; statvfs ( p , function on Stat Vfs ( err , stats ) { if ( err ) { cb ( err ) ; return ; } var available = stats . bsize * stats . bavail ; stats . available MB = Math . floor ( available / ( 1 0 2 4 * 1 0 2 4 ) ) ; cb ( null , stats ) ; } ) ; } 
function ( soajs , id , cb ) { check For Mongo ( soajs ) ; var id 1 ; try { id 1 = mongo . Object Id ( id ) ; return id 1 ; } catch ( e ) { soajs . log . error ( e ) ; throw e ; } } 
function ( soajs , combo , cb ) { check For Mongo ( soajs ) ; mongo . find One ( combo . collection , combo . condition | | { } , combo . fields | | null , combo . options | | null , cb ) ; } 
function ( soajs , combo , cb ) { check For Mongo ( soajs ) ; mongo . remove ( combo . collection , combo . condition , cb ) ; } 
function call ( ) { var args = [ xdhq , 3 ] ; var i = 0 ; while ( i < arguments . length ) args . push ( arguments [ i + + ] ) ; njsq . _call . apply ( null , args ) ; } 
function split ( keys And Values , keys , values ) { for ( var prop in keys And Values ) { keys . push ( prop ) ; values . push ( keys And Values [ prop ] ) ; } } 
function init BLModel ( req , res , cb ) { let model Name = config . model ; if ( req . soajs . services Config & & req . soajs . services Config . model ) { model Name = req . soajs . services Config . model ; } if ( process . env . SOAJS _TEST & & req . soajs . inputmask Data . model ) { model Name = req . soajs . inputmask Data . model ; } BLModule . init ( model Name , function ( error , BL ) { if ( error ) { req . soajs . log . error ( error ) ; return res . json ( req . soajs . build Response ( { "code " : 6 0 1 , "msg " : config . errors [ 6 0 1 ] } ) ) ; } else { return cb ( BL ) ; } } ) ; } 
function pseudo Server _ ( create Callback , callbacks , head ) { var client = new net . Socket ( ) ; client . connect ( p Port , p Addr , ( ) = > { let relaunch = true ; client . write ( handle String ( token ) ) ; if ( is Token Empty ( ) ) { if ( head = = = undefined ) head = " " ; client . write ( handle String ( head ) ) ; } client . on ( 'readable ' , ( ) = > { if ( client . _xdh DOM = = = undefined ) { let offset = 0 ; let query = get Query ( client ) ; if ( is Token Empty ( ) ) { [ token , offset ] = get String ( query , offset ) ; if ( is Token Empty ( ) ) throw get String ( query , offset ) [ 0 ] ; if ( w Port ! = " : 0 " ) { let complete URL = "http : / / " + w Addr + w Port + " / " + cgi + " .php ? _token = " + token ; console . log ( complete URL ) ; console . log ( new Array ( complete URL . length + 1 ) . join ( ' ^ ' ) ) ; console . log ( "Open above URL in a web browser . Enjoy ! " ) ; open ( complete URL ) ; } } else { let returned Token = " " ; [ returned Token , offset ] = get String ( query , offset ) ; if ( returned Token = = " " ) throw get String ( query , offset ) [ 0 ] ; if ( returned Token ! = token ) throw "Unmatched token ! ! ! " ; } client . _xdh DOM = create Callback ( ) ; client . _xdh DOM . _xdh Socket = client ; client . _xdh DOM . _xdh Is DEMO = true ; client . _xdh DOM . _xdh Type = types . UNDEFINED ; client . write ( add String ( add String ( Buffer . from ( " " ) , main Protocol Label ) , main Protocol Version ) ) ; } else if ( relaunch ) { let query = " " ; let offset = 0 ; let error Message = " " ; let notification = " " ; pseudo Server ( create Callback , callbacks ) ; / / Useless to give 'head ' , as it will no more be used . query = get Query ( client ) ; [ error Message , offset ] = get String ( query , offset ) ; if ( error Message ! = " " ) throw ( error Message ) ; [ notification , offset ] = get String ( query , offset ) ; if ( notification ! = " " ) console . log ( notification ) ; get String ( query , offset ) ; / / Language . client . write ( handle String ( "NJS " ) ) ; relaunch = false ; } else { let query ; let cont = true ; query = get Query ( client ) ; if ( client . _xdh DOM . _xdh Type = = = types . UNDEFINED ) { let id , action ; id = get Id ( query ) ; action = get Action ( query ) ; callbacks [ action ] ( client . _xdh DOM , id ) ; if ( client . _xdh DOM . _xdh Type = = = types . UNDEFINED ) { cont = false ; stand By ( client ) ; } else cont = client . _xdh DOM . _xdh Type = = = types . VOID ; } while ( cont ) { if ( client . _xdh DOM . _xdh Callback ! = undefined ) { let type = client . _xdh DOM . _xdh Type ; client . _xdh DOM . _xdh Type = types . UNDEFINED ; if ( type = = = types . VOID ) client . _xdh DOM . _xdh Callback ( ) ; else client . _xdh DOM . _xdh Callback ( get Response ( query , type ) ) ; if ( client . _xdh DOM . _xdh Type = = = types . UNDEFINED ) { cont = false ; stand By ( client ) ; } else if ( client . _xdh DOM . _xdh Type ! = = types . VOID ) cont = false ; } else { if ( client . _xdh DOM . _xdh Type ! = = types . VOID ) get Response ( query , client . _xdh DOM . _xdh Type ) ; client . _xdh DOM . _xdh Type = types . UNDEFINED ; cont = false ; stand By ( client ) ; } } } } ) ; } ) ; client . on ( 'error ' , ( err ) = > { throw "Unable to connect to ' " + p Addr + " : " + p Port + " ' ! ! ! " ; } ) ; } 
function call _ ( dom , command , type ) { var i = 3 ; var data = Buffer . from ( command + ' \x 0 0 ' ) ; var amount = arguments [ i + + ] ; dom . _xdh Type = type ; while ( amount - - ) data = add ( data , arguments [ i + + ] ) ; amount = arguments [ i + + ] ; while ( amount - - ) data = add ( data , arguments [ i + + ] ) ; dom . _xdh Callback = arguments [ i + + ] ; dom . _xdh Socket . write ( data ) ; } 
function get Asset Dir ( ) { var dir = path . dirname ( process . argv [ 1 ] ) ; if ( is Dev ( ) ) { let epeios Path = get Epeios Path ( ) ; return path . resolve ( epeios Path , "tools /xdhq /examples /common / " , path . relative ( path . resolve ( epeios Path , "tools /xdhq /examples /NJS / " ) , path . resolve ( dir ) ) ) ; / / No final ' / ' . } else return path . resolve ( dir ) ; } 
function unsplit ( keys , values ) { var i = 0 ; var keys Values = { } ; while ( i < keys . length ) { keys Values [ keys [ i ] ] = values [ i ] ; i + + ; } return keys Values ; } 
function ( req , cb ) { let config = req . soajs . config ; let login Mode = config . login Mode ; if ( req . soajs . tenant Oauth & & req . soajs . tenant Oauth . login Mode ) { login Mode = req . soajs . tenant Oauth . login Mode ; } function get Local ( ) { let condition = { 'user Id ' : req . soajs . inputmask Data [ 'username ' ] } ; let combo = { collection : user Collection Name , condition : condition } ; lib Product . model . find Entry ( req . soajs , combo , function ( err , record ) { if ( record ) { let hash Config = { "hash Iterations " : config . hash Iterations , "seed Length " : config . seed Length } ; if ( req . soajs . services Config & & req . soajs . services Config . oauth ) { if ( req . soajs . services Config . oauth . hash Iterations & & req . soajs . services Config . oauth . seed Length ) { hash Config = { "hash Iterations " : req . soajs . services Config . oauth . hash Iterations , "seed Length " : req . soajs . services Config . oauth . seed Length } ; } } core Hasher . init ( hash Config ) ; core Hasher . compare ( req . soajs . inputmask Data . password , record . password , function ( err , result ) { if ( err | | ! result ) { return cb ( 4 1 3 ) ; } delete record . password ; if ( record . t Id & & req . soajs . tenant ) { if ( record . t Id . to String ( ) ! = = req . soajs . tenant . id ) { return cb ( 4 0 3 ) ; } } 
function ( req , cb ) { let config = req . soajs . config ; let login Mode = config . login Mode ; if ( req . soajs . tenant Oauth & & req . soajs . tenant Oauth . login Mode ) { login Mode = req . soajs . tenant Oauth . login Mode ; } let criteria = { "user Id .login Mode " : login Mode , "user Id .id " : req . soajs . inputmask Data . user Id } ; let combo = { collection : token Collection Name , condition : criteria } ; lib Product . model . remove Entry ( req . soajs , combo , function ( error , result ) { let data = { config : req . soajs . config , error : error , code : 4 0 4 } ; check If Error ( req , cb , data , function ( ) { return cb ( null , result . result ) ; } ) ; } ) ; } 
function ( req , cb ) { let criteria = { "client Id " : req . soajs . inputmask Data . client Id } ; let combo = { collection : token Collection Name , condition : criteria } ; lib Product . model . remove Entry ( req . soajs , combo , function ( error , result ) { let data = { config : req . soajs . config , error : error , code : 4 0 4 } ; check If Error ( req , cb , data , function ( ) { return cb ( null , result . result ) ; } ) ; } ) ; } 
function ( req , cb ) { if ( req . soajs & & req . soajs . tenant Oauth & & req . soajs . tenant Oauth . secret & & req . soajs . tenant & & req . soajs . tenant . id ) { let secret = req . soajs . tenant Oauth . secret ; let tenant Id = req . soajs . tenant . id . to String ( ) ; let basic = Auth . generate ( tenant Id , secret ) ; return cb ( null , basic ) ; } else return cb ( { "code " : 4 0 6 , "msg " : req . soajs . config . errors [ 4 0 6 ] } ) ; } 
function require Model ( file Path , cb ) { 
function no Callback Handler ( ctx , connect Middleware , next ) { connect Middleware ( ctx . req , ctx . res ) return next ( ) } 
function with Callback Handler ( ctx , connect Middleware , next ) { return new Promise ( ( resolve , reject ) = > { connect Middleware ( ctx . req , ctx . res , err = > { if ( err ) reject ( err ) else resolve ( next ( ) ) } ) } ) } 
function koa Connect ( connect Middleware ) { const handler = connect Middleware . length < 3 ? no Callback Handler : with Callback Handler return function koa Connect ( ctx , next ) { return handler ( ctx , connect Middleware , next ) } } 
function wait For ( test Fx , on Ready , time Out Millis ) { var maxtime Out Millis = time Out Millis ? time Out Millis : 3 0 0 1 , 
function make Ordinal ( words ) { 
function to Words ( number , as Ordinal ) { var words ; var num = parse Int ( number , 1 0 ) ; if ( ! is Finite ( num ) ) { throw new Type Error ( 'Not a finite number : ' + number + ' ( ' + typeof number + ' ) ' ) ; } if ( ! is Safe Number ( num ) ) { throw new Range Error ( 'Input is not a safe number , it ’s either too large or too small . ' ) ; } words = generate Words ( num ) ; return as Ordinal ? make Ordinal ( words ) : words ; } 
function to Ordinal ( number ) { var num = parse Int ( number , 1 0 ) ; if ( ! is Finite ( num ) ) { throw new Type Error ( 'Not a finite number : ' + number + ' ( ' + typeof number + ' ) ' ) ; } if ( ! is Safe Number ( num ) ) { throw new Range Error ( 'Input is not a safe number , it ’s either too large or too small . ' ) ; } var str = String ( num ) ; var last Two Digits = Math . abs ( num % 1 0 0 ) ; var between Eleven And Thirteen = last Two Digits > = 1 1 & & last Two Digits < = 1 3 ; var last Char = str . char At ( str . length - 1 ) ; return str + ( between Eleven And Thirteen ? 'th ' : last Char = = = ' 1 ' ? 'st ' : last Char = = = ' 2 ' ? 'nd ' : last Char = = = ' 3 ' ? 'rd ' : 'th ' ) ; } 
function get Permission ( ) { var permission = Notification API . permission ; var permission Granted = false ; if ( permission = = = 'granted ' ) { permission Granted = true ; } return permission Granted ; } 
function ( title , options , callback ) { var auto Close = 0 ; if ( options . auto Close & & ( typeof options . auto Close = = = 'number ' ) ) { auto Close = options . auto Close ; } 
function ( arguments Array ) { 
function merge Profiles ( what , user Obj , update Prof , update Creds , callback ) { var final Profile , final Creds ; if ( update Prof ! = undefined ) { final Profile = { } ; for ( prop in user Obj . profile ) final Profile [ prop ] = user Obj . profile [ prop ] ; for ( prop in update Prof ) final Profile [ prop ] = update Prof [ prop ] ; } if ( update Creds ! = undefined ) { final Creds = { } ; for ( prop in user Obj . credentials ) final Creds [ prop ] = user Obj . profile [ prop ] ; for ( prop in update Creds ) final Creds [ prop ] = update Creds [ prop ] ; } what . update ( user Obj . id , final Profile , final Creds , function ( d ) { if ( ! d . success | | d . resp . error Code ) { callback ( { success : false , error : "Failed to update user info " , resp : d . resp } ) ; return ; } callback ( { success : true , resp : d . resp } ) ; } ) } 
function Okta APIGroups ( api Token , domain , preview ) { if ( api Token = = undefined | | domain = = undefined ) { throw new Error ( "Okta API requires an API token and a domain " ) ; } this . domain = domain ; if ( preview = = undefined ) this . preview = false ; else this . preview = preview ; this . request = new Network Abstraction ( api Token , domain , preview ) ; this . helpers = require ( ' . /Okta APIGroups Helpers .js ' ) } 
function Okta APISessions ( api Token , domain , preview ) { if ( api Token = = undefined | | domain = = undefined ) { throw new Error ( "Okta API requires an API token and a domain " ) ; } this . domain = domain ; if ( preview = = undefined ) this . preview = false ; else this . preview = preview ; this . request = new Network Abstraction ( api Token , domain , preview ) ; } 
function Okta API ( api Token , domain , preview ) { if ( api Token = = undefined | | domain = = undefined ) { throw new Error ( "Okta API requires an API token and a domain " ) ; } this . domain = domain ; if ( preview = = undefined ) this . preview = false ; else this . preview = preview ; this . request = new Network Abstraction ( api Token , domain , preview ) ; this . users = new Okta APIUsers ( api Token , domain , preview ) ; this . groups = new Okta APIGroups ( api Token , domain , preview ) ; this . sessions = new Okta APISessions ( api Token , domain , preview ) ; this . apps = new Okta APIApps ( api Token , domain , preview ) ; this . events = new Okta APIEvents ( api Token , domain , preview ) ; } 
function construct Group ( name , description ) { var profile = { } ; profile . name = name ; profile . description = description ; return profile ; } 
function change ( evt ) { evt = evt | | win . event ; if ( 'readystatechange ' = = = evt . type ) { readystate . change ( doc Ready State ( ) ) ; if ( complete ! = = doc Ready State ( ) ) return ; } if ( 'load ' = = = evt . type ) readystate . change ( 'complete ' ) ; else readystate . change ( 'interactive ' ) ; 
function UTF 8Array To String ( u 8Array , idx ) { var u 0 , u 1 , u 2 , u 3 , u 4 , u 5 ; var str = ' ' ; while ( 1 ) { 
function string To UTF 8 ( str , out Ptr , max Bytes To Write ) { assert ( typeof max Bytes To Write = = 'number ' , 'string To UTF 8 (str , out Ptr , max Bytes To Write ) is missing the third parameter that specifies the length of the output buffer ! ' ) ; return string To UTF 8Array ( str , HEAPU 8 , out Ptr , max Bytes To Write ) ; } 
function string To UTF 1 6 ( str , out Ptr , max Bytes To Write ) { assert ( typeof max Bytes To Write = = 'number ' , 'string To UTF 1 6 (str , out Ptr , max Bytes To Write ) is missing the third parameter that specifies the length of the output buffer ! ' ) ; 
function string To UTF 3 2 ( str , out Ptr , max Bytes To Write ) { assert ( typeof max Bytes To Write = = 'number ' , 'string To UTF 3 2 (str , out Ptr , max Bytes To Write ) is missing the third parameter that specifies the length of the output buffer ! ' ) ; 
function length Bytes UTF 3 2 ( str ) { var len = 0 ; for ( var i = 0 ; i < str . length ; + + i ) { 
function int Array From String ( stringy , dont Add Null , length ) { var len = length > 0 ? length : length Bytes UTF 8 ( stringy ) + 1 ; var u 8array = new Array ( len ) ; var num Bytes Written = string To UTF 8Array ( stringy , u 8array , 0 , u 8array . length ) ; if ( dont Add Null ) u 8array . length = num Bytes Written ; return u 8array ; } 
function stack Alloc ( size ) { size = size | 0 ; var ret = 0 ; ret = STACKTOP ; STACKTOP = ( STACKTOP + size ) | 0 ; STACKTOP = ( STACKTOP + 1 5 ) & - 1 6 ; if ( ( STACKTOP | 0 ) > = ( STACK _MAX | 0 ) ) abort ( ) ; return ret | 0 ; } 
function dyn Call _iiiiii ( index , a 1 , a 2 , a 3 , a 4 , a 5 ) { index = index | 0 ; a 1 = a 1 | 0 ; a 2 = a 2 | 0 ; a 3 = a 3 | 0 ; a 4 = a 4 | 0 ; a 5 = a 5 | 0 ; return FUNCTION _TABLE _iiiiii [ index & 3 1 ] ( a 1 | 0 , a 2 | 0 , a 3 | 0 , a 4 | 0 , a 5 | 0 ) | 0 ; } 
function construct Profile ( first Name , last Name , email , login , mobile Phone , custom Attribs ) { var profile = { } ; profile . login = ( login ? login : email ) ; profile . email = email ; profile . first Name = first Name ; profile . last Name = last Name ; profile . mobile Phone = mobile Phone ; if ( custom Attribs ! = undefined ) { for ( prop in custom Attribs ) { profile [ prop ] = custom Attribs [ prop ] ; } } return profile ; } 
function construct Credentials ( password , question , answer ) { var credentials = { } ; if ( password ) credentials . password = construct Password ( password ) ; if ( question & & answer ) credentials . recovery _question = construct Recovery Question ( question , answer ) ; return credentials ; } 
function ( method , where , what , query , callback ) { var opts = { } ; if ( what = = undefined ) opts . body = " " ; else opts . body = JSON . stringify ( what ) ; opts . headers = { } ; opts . headers [ 'Content -Length ' ] = opts . body . length ; opts . headers [ 'Content -Type ' ] = "application /json " ; opts . headers [ 'Authorization ' ] = "SSWS " + api Key ; opts . method = method ; opts . uri = url . parse ( where ) ; if ( query ! = null ) opts . qs = query ; request ( opts , function ( error , client Resp , resp ) { handle Response ( error , false , client Resp , resp , callback ) } ) ; } 
function ( method , where , query , follow Link , callback ) { var opts = { } ; 
function construct App Model ( id , name , label , created , last Updated , status , features , sign On Mode , accessibility , visibility , credentials , settings , links , embedded ) { var model = { } ; if ( id ) model . id = id ; if ( name ) model . name = name ; if ( label ) model . label = label ; if ( created ) model . created = created ; if ( last Updated ) model . last Updated = last Updated ; if ( status ) model . status = status ; if ( features ) model . features = features ; if ( sign On Mode ) model . sign On Mode = sign On Mode ; if ( accessibility ) model . accessibility = accessibility ; if ( visibility ) model . visibility = visibility ; if ( credentials ) model . credentials = credentials ; if ( settings ) model . settings = settings ; if ( links ) model . links = links ; if ( embedded ) model . embedded = embedded ; return model ; } 
function construct App User Model ( id , external Id , created , last Updated , scope , status , status Changed , password Changed , sync State , last Sync , credentials , last Sync , links ) { var model = { } ; if ( id ) model . id = id ; if ( external Id ) model . external Id = external Id ; if ( created ) model . created = created ; if ( last Updated ) model . last Updated = last Updated ; if ( scope ) model . scope = scope ; if ( status ) model . status = status ; if ( status Changed ) model . status Changed = status Changed ; if ( password Changed ) model . password Changed = password Changed ; if ( sync State ) model . sync State = sync State ; if ( last Sync ) model . last Sync = last Sync ; if ( credentials ) model . credentials = credentials ; if ( last Sync ) model . last Sync = last Sync ; if ( links ) model . links = links ; return model ; } 
function construct App Group Model ( id , last Updated , priority , links ) { var model = { } ; if ( id ) model . id = id ; if ( last Updated ) model . last Updated = last Updated ; if ( priority ) model . priority = priority ; if ( links ) model . links = links ; return model ; } 
function generate ( state ) { return function proxy ( fn , context ) { var rs = this ; if ( rs . is ( state ) ) { set Timeout ( function ( ) { fn . call ( context , rs . ready State ) ; } , 0 ) ; } else { if ( ! rs . _events [ state ] ) rs . _events [ state ] = [ ] ; rs . _events [ state ] . push ( { fn : fn , context : context } ) ; } return rs ; } ; } 
function options ( options = [ ] , value , placeholder ) { if ( placeholder ) { options . unshift ( { label : placeholder } ) ; } return options { item . label } < / option > ) ; } ) ; } 
function ( raw Errors ) { var normalized Errors = [ ] ; if ( typeof raw Errors = = = 'string ' | | ( typeof raw Errors = = = 'object ' & & ! Array . is Array ( raw Errors ) ) ) { 
function jsonp ( opts ) { var prefix = opts . prefix | | ' _ _jp ' ; 
function get Result Severity ( result , config ) { 
function ( input Node , options = { } ) { this . formatter = require ( 'eslint /lib /formatters /stylish ' ) if ( ! ( this instanceof Standard Validation Filter ) ) { return new Standard Validation Filter ( input Node , options ) } 
function _bool To Num ( value , num True , num False , default Val ) { if ( typeof value = = = 'boolean ' ) { return value ? num True : num False ; } return typeof value = = = 'number ' ? value : default Val ; } 
function update Input ( new Node , old Node ) { const new Value = new Node . value ; const old Value = old Node . value ; update Attribute ( new Node , old Node , 'checked ' ) ; update Attribute ( new Node , old Node , 'disabled ' ) ; if ( new Value ! = = old Value ) { old Node . set Attribute ( 'value ' , new Value ) ; old Node . value = new Value ; } if ( new Value = = = 'null ' ) { old Node . value = ' ' ; old Node . remove Attribute ( 'value ' ) ; } if ( ! new Node . has Attribute NS ( null , 'value ' ) ) { old Node . remove Attribute ( 'value ' ) ; } else if ( old Node . type = = = 'range ' ) { 
function ( ) { if ( ( cached Width = element . offset Width ) ! = last Width | | ( cached Height = element . offset Height ) ! = last Height ) { dirty = true ; last Width = cached Width ; last Height = cached Height ; } reset ( ) ; } 
function ( element , callback ) { var me = this ; var element Type = Object . prototype . to String . call ( element ) ; var is Collection Typed = me . _is Collection Typed = ( ' [object Array ] ' = = = element Type | | ( ' [object Node List ] ' = = = element Type ) | | ( ' [object HTMLCollection ] ' = = = element Type ) | | ( 'undefined ' ! = = typeof j Query & & element instanceof window . j Query ) | | 
function rand Int ( start , end ) { return Math . floor ( Math . random ( ) * ( end - start ) ) + start ; } 
function wrap Fn ( mocker , fn ) { return function ( ) { 
function Mocker ( obj , method Name , mock Fn ) { this . obj = obj ; this . method Name = method Name ; this . original Fn = obj [ method Name ] ; this . history = [ ] ; 
function pass ( part , suite Index , test Index ) { var o ; var is Suite = false ; if ( typeof test Index = = = 'number ' ) { o = suites [ suite Index ] . tests [ test Index ] ; } else { is Suite = true ; o = suites [ suite Index ] ; } display . pass ( part , o ) ; if ( is Suite ) { 
function fail ( part , suite Index , test Index , msg ) { if ( typeof test Index = = = 'string ' ) { msg = test Index ; test Index = undefined ; } var o ; var is Suite = false ; if ( typeof test Index = = = 'number ' ) { o = suites [ suite Index ] . tests [ test Index ] ; if ( typeof msg = = = 'string ' ) { suites [ suite Index ] . tests [ test Index ] [ part ] . failmsg = msg ; } display . details ( 'test ' , o ) ; } else { is Suite = true ; o = suites [ suite Index ] ; if ( typeof msg = = = 'string ' ) { suites [ suite Index ] [ part ] . failmsg = msg ; } display . details ( 'suite ' , o ) ; } display . fail ( part , o ) ; 
function run ( part , suite Index , test Index ) { var local ; var o ; var is Suite = true ; if ( typeof test Index = = = 'number ' ) { is Suite = false ; o = suites [ suite Index ] . tests [ test Index ] ; } else { o = suites [ suite Index ] ; } if ( part = = = 'setup ' ) { if ( is Suite ) { display . suite Border ( ) ; display . details ( 'suite ' , o ) ; 
function prepare Json ( shares ) { let json = [ ] ; for ( let i = 0 ; i < shares . length ; i + + ) { let share = shares [ i ] ; json [ i ] = { } ; json [ i ] . id = share . id ; let status = ' ? ' ; switch ( share . state ) { case 0 : status = 'stopped ' ; break ; case 1 : status = 'running ' ; break ; case 2 : status = 'errored ' ; break ; default : status = 'unknown ' ; } json [ i ] . status = status ; json [ i ] . config Path = share . config . storage Path ; json [ i ] . uptime = pretty Ms ( share . meta . uptime Ms ) ; json [ i ] . restarts = share . meta . num Restarts | | 0 ; json [ i ] . peers = share . meta . farmer State . total Peers | | 0 ; json [ i ] . allocs = fix Contract Value ( share . meta . farmer State . contract Count ) ; json [ i ] . data Received Count = fix Contract Value ( share . meta . farmer State . data Received Count ) ; json [ i ] . delta = share . meta . farmer State . ntp Status . delta ; json [ i ] . port = share . meta . farmer State . port Status . listen Port ; json [ i ] . shared = share . meta . farmer State . space Used ; json [ i ] . shared Percent = share . meta . farmer State . percent Used ; var bridge Cx Stat = share . meta . farmer State . bridges Connection Status ; switch ( bridge Cx Stat ) { case 0 : json [ i ] . bridge Connection Status = 'disconnected ' ; break ; case 1 : json [ i ] . bridge Connection Status = 'connecting ' ; break ; case 2 : json [ i ] . bridge Connection Status = 'confirming ' ; break ; case 3 : json [ i ] . bridge Connection Status = 'connected ' ; break ; default : break ; } } return JSON . stringify ( json ) ; } 
function ( content ) { 
function ( is Relevant Tag Attr , usid , root , parse Dynamic Routes ) { this . current Directive = null ; this . matches = [ ] ; this . is Relevant Tag Attr = is Relevant Tag Attr ; this . usid = usid ; this . ident = function ( ) { return " _ _ _ _ " + usid + Math . random ( ) + " _ _ _ _ " ; } ; this . data = { } ; this . root = root ; this . parse Dynamic Routes = parse Dynamic Routes ; } 
function ( match , str Until Value , name , value , index ) { var self = this ; var expression = value ; if ( ! this . is Relevant Tag Attr ( this . current Tag , name ) ) { return ; } 
function validate And Format Center ( center ) { 
function ( new Value ) { var function To Execute = new Value ? 'add Class ' : 'remove Class ' ; var elements = this . _element DOM . find ( 'div ' ) ; for ( var iterator = 0 ; iterator < elements . length ; iterator + + ) { var element = angular . element ( elements [ iterator ] ) ; if ( element . has Class ( 'angular -mapboxgl -map -loader ' ) ) { element [ function To Execute ] ( 'angular -mapboxgl -map -loading ' ) ; } } } 
function Date Time Picker ( $md Util , $md Media , $document , picker ) { return { restrict : 'E ' , require : [ ' ^ng Model ' , 'sm Date Time Picker ' ] , scope : { week Start Day : ' @ ' , start View : ' @ ' , mode : ' @ ' , format : ' @ ' , min Date : ' @ ' , max Date : ' @ ' , fname : ' @ ' , label : ' @ ' , is Required : ' @ ' , disable : ' = ' , no Floating Label : ' = ' , disable Year Selection : ' @ ' , close On Select : ' @ ' , on Date Selected Call : ' & ' } , controller : [ ' $scope ' , ' $element ' , ' $md Util ' , ' $md Media ' , ' $document ' , ' $parse ' , SMDate Time Picker Ctrl ] , controller As : 'vm ' , bind To Controller : true , template : function ( element , attributes ) { var input Type = ' ' ; if ( attributes . has Own Property ( 'on Focus ' ) ) { input Type = ' <input name = " { {vm .fname } } " ng -model = "vm .value " ' + 'type = "text " placeholder = " { {vm .label } } " ' + ' aria -label = " { {vm .fname } } " ng -focus = "vm .show ( ) " data -ng -required = "vm .is Required " ng -disabled = "vm .disable " ' + ' server -error class = "sm -input -container " / > ' ; } else { input Type = ' <input class = " " name = " { {vm .fname } } " ng -model = "vm .value " ' + ' type = "text " placeholder = " { {vm .label } } " ' + ' aria -label = " { {vm .fname } } " aria -hidden = "true " data -ng -required = "vm .is Required " ng -disabled = "vm .disable " / > ' + ' <md -button tabindex = " - 1 " class = "sm -picker -icon md -icon -button " aria -label = "show Calender " ng -disabled = "vm .disable " aria -hidden = "true " type = "button " ng -click = "vm .show ( ) " > ' + ' <svg fill = " # 0 0 0 0 0 0 " height = " 2 4 " view Box = " 0 0 2 4 2 4 " width = " 2 4 " xmlns = "http : / /www .w 3 .org / 2 0 0 0 /svg " > <path d = "M 7 1 0l 5 5 5 - 5z " / > <path d = "M 0 0h 2 4v 2 4H 0z " fill = "none " / > < /svg > ' + ' < /md -button > ' ; } return ' <md -input -container class = "sm -input -container md -icon -float md -block " md -no -float = "vm .no Floating Label " > ' + input Type + ' <div id = "picker " class = "sm -calender -pane md -whiteframe -z 2 " > ' + ' <sm -date -picker ' + ' id = " { {vm .fname } }Picker " ' + ' initial -date = "vm .initial Date " ' + ' ng -model = "vm .value " ' + ' mode = " { {vm .mode | | \ 'date \ ' } } " ' + ' disable -year -selection = { {vm .disable Year Selection } } ' + ' close -on -select = " { {vm .close On Select } } " ' + ' start -view = " { {vm .start View } } " ' + ' data -min -date = "vm .min Date " ' + ' data -max -date = "vm .max Date " ' + ' data -format = " { {vm .format } } " ' + ' data -on -select -call = "vm .on Date Selected (date ) " ' + ' data -week -start -day = " { {vm .week Start Day } } " > ' + ' < /sm -date -picker > ' + ' < /div > ' + ' <div > < /div > ' ' < /md -input -container > ' ; } , link : function ( scope , $element , attr , ctrl ) { var ng Model Ctrl = ctrl [ 0 ] ; var picker Ctrl = ctrl [ 1 ] ; picker Ctrl . configure Ng Model ( ng Model Ctrl ) ; } } } 
function picker ( ) { var massage Path = 'X ' ; var cancel Label = 'Cancel ' ; var ok Label = 'Ok ' ; var clear Label = 'Clear ' ; var custom Range Label = 'Custom Range ' ; var format = 'MM -DD -YYYY ' ; var custom Header = { date : 'ddd , MMM DD ' , date Time : 'ddd , MMM DD HH :mm ' , time : 'HH :mm ' , } 
function sm Range Picker ( picker ) { return { restrict : 'E ' , require : [ ' ^ ?ng Model ' , 'sm Range Picker ' ] , scope : { format : ' @ ' , divider : ' @ ' , week Start Day : ' @ ' , custom To Home : ' @ ' , close On Select : ' @ ' , mode : ' @ ' , show Custom : ' @ ' , custom List : ' = ' , min Date : ' @ ' , max Date : ' @ ' , allow Clear : ' @ ' , allow Empty : ' @ ' , range Select Call : ' & ' } , terminal : true , controller : [ ' $scope ' , 'picker ' , Range Picker Ctrl ] , controller As : 'vm ' , bind To Controller : true , template Url : 'picker /range -picker .html ' , link : function ( scope , element , att , ctrls ) { var ng Model Ctrl = ctrls [ 0 ] ; var cal Ctrl = ctrls [ 1 ] ; cal Ctrl . configure Ng Model ( ng Model Ctrl ) ; } } ; } 
function sm Time Picker New ( $md Util , $md Media , $document , $timeout , picker ) { return { restrict : 'E ' , replace : true , scope : { value : ' = ' , start Date : ' @ ' , week Start Day : ' @ ' , start View : ' @ ' , mode : ' @ ' , format : ' @ ' , min Date : ' @ ' , max Date : ' @ ' , fname : ' @ ' , lable : ' @ ' , is Required : ' @ ' , disable : ' = ' , form : ' = ' , close On Select : ' @ ' } , template Url : 'picker /sm -time -picker .html ' , link : function ( scope , $element , attr ) { var input Pane = $element [ 0 ] . query Selector ( ' .sm -input -container ' ) ; var calender Pane = $element [ 0 ] . query Selector ( ' .sm -calender -pane ' ) ; var c Element = angular . element ( calender Pane ) ; scope . ng Massaged Tempalte Path = picker . massage Path ; 
function error Handling Config ( config ) { if ( is Object ( config ) ) { if ( is Defined ( config . object Max Depth ) ) { min Err Config . object Max Depth = is Valid Object Max Depth ( config . object Max Depth ) ? config . object Max Depth : Na N ; } if ( is Defined ( config . url Error Params Enabled ) & & is Boolean ( config . url Error Params Enabled ) ) { min Err Config . url Error Params Enabled = config . url Error Params Enabled ; } } else { return min Err Config ; } } 
function for Each ( obj , iterator , context ) { var key , length ; if ( obj ) { if ( is Function ( obj ) ) { for ( key in obj ) { if ( key ! = = 'prototype ' & & key ! = = 'length ' & & key ! = = 'name ' & & obj . has Own Property ( key ) ) { iterator . call ( context , obj [ key ] , key , obj ) ; } } } else if ( is Array ( obj ) | | is Array Like ( obj ) ) { var is Primitive = typeof obj ! = = 'object ' ; for ( key = 0 , length = obj . length ; key < length ; key + + ) { if ( is Primitive | | key in obj ) { iterator . call ( context , obj [ key ] , key , obj ) ; } } } else if ( obj . for Each & & obj . for Each ! = = for Each ) { obj . for Each ( iterator , context , obj ) ; } else if ( is Blank Object ( obj ) ) { 
function is Error ( value ) { var tag = to String . call ( value ) ; switch ( tag ) { case ' [object Error ] ' : return true ; case ' [object Exception ] ' : return true ; case ' [object DOMException ] ' : return true ; default : return value instanceof Error ; } } 
function copy ( source , destination , max Depth ) { var stack Source = [ ] ; var stack Dest = [ ] ; max Depth = is Valid Object Max Depth ( max Depth ) ? max Depth : Na N ; if ( destination ) { if ( is Typed Array ( destination ) | | is Array Buffer ( destination ) ) { throw ng Min Err ( 'cpta ' , 'Can \ 't copy ! Typed Array destination cannot be mutated . ' ) ; } if ( source = = = destination ) { throw ng Min Err ( 'cpi ' , 'Can \ 't copy ! Source and destination are identical . ' ) ; } 
function ( ) { if ( is Defined ( jq . name _ ) ) return jq . name _ ; var el ; var i , ii = ng Attr Prefixes . length , prefix , name ; for ( i = 0 ; i < ii ; + + i ) { prefix = ng Attr Prefixes [ i ] ; el = window . document . query Selector ( ' [ ' + prefix . replace ( ' : ' , ' \ \ : ' ) + 'jq ] ' ) ; if ( el ) { name = el . get Attribute ( prefix + 'jq ' ) ; break ; } } return ( jq . name _ = name ) ; } 
function serialize Object ( obj , max Depth ) { var seen = [ ] ; 
function JQLite ( element ) { if ( element instanceof JQLite ) { return element ; } var arg Is String ; if ( is String ( element ) ) { element = trim ( element ) ; arg Is String = true ; } if ( ! ( this instanceof JQLite ) ) { if ( arg Is String & & element . char At ( 0 ) ! = = ' < ' ) { throw jq Lite Min Err ( 'nosel ' , 'Looking up elements via selectors is not supported by jq Lite ! See : http : / /docs .angularjs .org /api /angular .element ' ) ; } return new JQLite ( element ) ; } if ( arg Is String ) { jq Lite Add Nodes ( this , jq Lite Parse HTML ( element ) ) ; } else if ( is Function ( element ) ) { jq Lite Ready ( element ) ; } else { jq Lite Add Nodes ( this , element ) ; } } 
function ( ) { var post Digest Queue = new Ng Map ( ) ; var post Digest Elements = [ ] ; this . $get = [ ' $ $Animate Runner ' , ' $root Scope ' , function ( $ $Animate Runner , $root Scope ) { return { enabled : noop , on : noop , off : noop , pin : noop , push : function ( element , event , options , dom Operation ) { if ( dom Operation ) { dom Operation ( ) ; } options = options | | { } ; if ( options . from ) { element . css ( options . from ) ; } if ( options . to ) { element . css ( options . to ) ; } if ( options . add Class | | options . remove Class ) { add Remove Classes Post Digest ( element , options . add Class , options . remove Class ) ; } var runner = new $ $Animate Runner ( ) ; 
function Browser ( window , document , $log , $sniffer , $ $task Tracker Factory ) { var self = this , location = window . location , history = window . history , set Timeout = window . set Timeout , clear Timeout = window . clear Timeout , pending Defer Ids = { } , task Tracker = $ $task Tracker Factory ( $log ) ; self . is Mock = false ; * @name $browser #url * * @description * GETTER : * Without any argument , this method just returns current value of `location .href ` (with a * trailing ` # ` stripped of if the hash is empty ) . * * SETTER : * With at least one argument , this method sets url to new value . * If html 5 history api supported , `push State ` / `replace State ` is used , otherwise * `location .href ` / `location .replace ` is used . * Returns its own instance to allow chaining . * * NOTE : this api is intended for use only by the ` $location ` service . Please use the * { @link ng . $location $location service } to change url . * * @param {string } url New url (when used as setter ) * @param {boolean = } replace Should new url replace current history record ? * @param {object = } state State object to use with `push State ` / `replace State ` * / self . url = function ( url , replace , state ) { * @name $browser #state * * @description * This method is a getter . * * Return history .state or null if history .state is undefined . * * @returns {object } state * / self . state = function ( ) { return cached State ; } ; var url Change Listeners = [ ] , url Change Init = false ; function cache State And Fire Url Change ( ) { pending Location = null ; fire State Or Url Change ( ) ; } * @name $browser #on Url Change * * @description * Register callback function that will be called , when url changes . * * It 's only called when the url is changed from outside of Angular JS : * - user types different url into address bar * - user clicks on history (forward /back ) button * - user clicks on a link * * It 's not called when url is changed by $browser .url ( ) method * * The listener gets called with new url as parameter . * * NOTE : this api is intended for use only by the $location service . Please use the * { @link ng . $location $location service } to monitor url changes in Angular JS apps . * * @param {function (string ) } listener Listener function to be called when url changes . * @return {function (string ) } Returns the registered listener fn - handy if the fn is anonymous . * / self . on Url Change = function ( callback ) { * @private * Remove popstate and hashchange handler from window . * * NOTE : this api is intended for use only by $root Scope . * / self . $ $application Destroyed = function ( ) { jq Lite ( window ) . off ( 'hashchange popstate ' , cache State And Fire Url Change ) ; } ; self . $ $check Url Change = fire State Or Url Change ; * @name $browser #base Href * * @description * Returns current <base href > * (always relative - without domain ) * * @returns {string } The current base href * / self . base Href = function ( ) { var href = base Element . attr ( 'href ' ) ; return href ? href . replace ( / ^ (https ? : ) ? \ / \ / [ ^ / ] * / , ' ' ) : ' ' ; } ; self . defer = function ( fn , delay , task Type ) { var timeout Id ; delay = delay | | 0 ; task Type = task Type | | task Tracker . DEFAULT _TASK _TYPE ; task Tracker . inc Task Count ( task Type ) ; timeout Id = set Timeout ( function ( ) { delete pending Defer Ids [ timeout Id ] ; task Tracker . complete Task ( fn , task Type ) ; } , delay ) ; pending Defer Ids [ timeout Id ] = task Type ; return timeout Id ; } ; self . defer . cancel = function ( defer Id ) { if ( pending Defer Ids . has Own Property ( defer Id ) ) { var task Type = pending Defer Ids [ defer Id ] ; delete pending Defer Ids [ defer Id ] ; clear Timeout ( defer Id ) ; task Tracker . complete Task ( noop , task Type ) ; return true ; } return false ; } ; } 
function ( key ) { if ( capacity < Number . MAX _VALUE ) { var lru Entry = lru Hash [ key ] ; if ( ! lru Entry ) return ; if ( lru Entry = = = fresh End ) fresh End = lru Entry . p ; if ( lru Entry = = = stale End ) stale End = lru Entry . n ; link ( lru Entry . n , lru Entry . p ) ; delete lru Hash [ key ] ; } if ( ! ( key in data ) ) return ; delete data [ key ] ; size - - ; } 
function refresh ( entry ) { if ( entry ! = = fresh End ) { if ( ! stale End ) { stale End = entry ; } else if ( stale End = = = entry ) { stale End = entry . n ; } link ( entry . n , entry . p ) ; link ( entry , fresh End ) ; fresh End = entry ; fresh End . n = null ; } } 
function link ( next Entry , prev Entry ) { if ( next Entry ! = = prev Entry ) { if ( next Entry ) next Entry . p = prev Entry ; 
function ( key , value , write Attr , attr Name ) { 
function group Scan ( node , attr Start , attr End ) { var nodes = [ ] ; var depth = 0 ; if ( attr Start & & node . has Attribute & & node . has Attribute ( attr Start ) ) { do { if ( ! node ) { throw $compile Min Err ( 'uterdir ' , 'Unterminated attribute , found \ ' { 0 } \ ' but no matching \ ' { 1 } \ ' found . ' , attr Start , attr End ) ; } if ( node . node Type = = = NODE _TYPE _ELEMENT ) { if ( node . has Attribute ( attr Start ) ) depth + + ; if ( node . has Attribute ( attr End ) ) depth - - ; } nodes . push ( node ) ; node = node . next Sibling ; } while ( depth > 0 ) ; } else { nodes . push ( node ) ; } return jq Lite ( nodes ) ; } 
function merge Template Attributes ( dst , src ) { var src Attr = src . $attr , dst Attr = dst . $attr ; 
function replace With ( $root Element , elements To Remove , new Node ) { var first Element To Remove = elements To Remove [ 0 ] , remove Count = elements To Remove . length , parent = first Element To Remove . parent Node , i , ii ; if ( $root Element ) { for ( i = 0 , ii = $root Element . length ; i < ii ; i + + ) { if ( $root Element [ i ] = = = first Element To Remove ) { $root Element [ i + + ] = new Node ; for ( var j = i , j 2 = j + remove Count - 1 , jj = $root Element . length ; j < jj ; j + + , j 2 + + ) { if ( j 2 < jj ) { $root Element [ j ] = $root Element [ j 2 ] ; } else { delete $root Element [ j ] ; } } $root Element . length - = remove Count - 1 ; 
function resolve Promise ( response , status , headers , status Text , xhr Status ) { 
function constant Watch Delegate ( scope , listener , object Equality , constant Interp ) { var unwatch = scope . $watch ( function constant Interpolate Watch ( scope ) { unwatch ( ) ; return constant Interp ( scope ) ; } , listener , object Equality ) ; return unwatch ; } 
function encode Path ( path ) { var segments = path . split ( ' / ' ) , i = segments . length ; while ( i - - ) { 
function Location Html 5Url ( app Base , app Base No File , base Prefix ) { this . $ $html 5 = true ; base Prefix = base Prefix | | ' ' ; parse Absolute Url ( app Base , this ) ; this . $ $parse = function ( url ) { var path Url = strip Base Url ( app Base No File , url ) ; if ( ! is String ( path Url ) ) { throw $location Min Err ( 'ipthprfx ' , 'Invalid url " { 0 } " , missing path prefix " { 1 } " . ' , url , app Base No File ) ; } parse App Url ( path Url , this , true ) ; if ( ! this . $ $path ) { this . $ $path = ' / ' ; } this . $ $compose ( ) ; } ; this . $ $normalize Url = function ( url ) { return app Base No File + url . substr ( 1 ) ; 
function urls Equal ( a , b ) { return a = = = b | | url Resolve ( a ) . href = = = url Resolve ( b ) . href ; } 
function $Log Provider ( ) { var debug = true , self = this ; this . debug Enabled = function ( flag ) { if ( is Defined ( flag ) ) { debug = flag ; return this ; } else { return debug ; } } ; this . $get = [ ' $window ' , function ( $window ) { * @ngdoc method * @name $log #log * * @description * Write a log message * / log : console Log ( 'log ' ) , info : console Log ( 'info ' ) , warn : console Log ( 'warn ' ) , error : console Log ( 'error ' ) , debug : ( function ( ) { var fn = console Log ( 'debug ' ) ; return function ( ) { if ( debug ) { fn . apply ( self , arguments ) ; } } ; } ) ( ) } ; function format Error ( arg ) { if ( is Error ( arg ) ) { if ( arg . stack & & format Stack Trace ) { arg = ( arg . message & & arg . stack . index Of ( arg . message ) = = = - 1 ) ? 'Error : ' + arg . message + ' \n ' + arg . stack : arg . stack ; } else if ( arg . source URL ) { arg = arg . message + ' \n ' + arg . source URL + ' : ' + arg . line ; } } return arg ; } function console Log ( type ) { var console = $window . console | | { } , log Fn = console [ type ] | | console . log | | noop ; return function ( ) { var args = [ ] ; for Each ( arguments , function ( arg ) { args . push ( format Error ( arg ) ) ; } ) ; 
function is Pure ( node , parent Is Pure ) { switch ( node . type ) { 
function $Parse Provider ( ) { var cache = create Map ( ) ; var literals = { 'true ' : true , 'false ' : false , 'null ' : null , 'undefined ' : undefined } ; var ident Start , ident Continue ; this . add Literal = function ( literal Name , literal Value ) { literals [ literal Name ] = literal Value ; } ; this . set Identifier Fns = function ( identifier Start , identifier Continue ) { ident Start = identifier Start ; ident Continue = identifier Continue ; return this ; } ; this . $get = [ ' $filter ' , function ( $filter ) { var no Unsafe Eval = csp ( ) . no Unsafe Eval ; var $parse Options = { csp : no Unsafe Eval , literals : copy ( literals ) , is Identifier Start : is Function ( ident Start ) & & ident Start , is Identifier Continue : is Function ( ident Continue ) & & ident Continue } ; $parse . $ $get Ast = $ $get Ast ; return $parse ; function $parse ( exp , interceptor Fn ) { var parsed Expression , cache Key ; switch ( typeof exp ) { case 'string ' : exp = exp . trim ( ) ; cache Key = exp ; parsed Expression = cache [ cache Key ] ; if ( ! parsed Expression ) { var lexer = new Lexer ( $parse Options ) ; var parser = new Parser ( lexer , $filter , $parse Options ) ; parsed Expression = parser . parse ( exp ) ; cache [ cache Key ] = add Watch Delegate ( parsed Expression ) ; } return add Interceptor ( parsed Expression , interceptor Fn ) ; case 'function ' : return add Interceptor ( exp , interceptor Fn ) ; default : return add Interceptor ( noop , interceptor Fn ) ; } } function $ $get Ast ( exp ) { var lexer = new Lexer ( $parse Options ) ; var parser = new Parser ( lexer , $filter , $parse Options ) ; return parser . get Ast ( exp ) . ast ; } function expression Input Dirty Check ( new Value , old Value Of Value , compare Object Identity ) { if ( new Value = = null | | old Value Of Value = = null ) { 
function $QProvider ( ) { var error On Unhandled Rejections = true ; this . $get = [ ' $root Scope ' , ' $exception Handler ' , function ( $root Scope , $exception Handler ) { return q Factory ( function ( callback ) { $root Scope . $eval Async ( callback ) ; } , $exception Handler , error On Unhandled Rejections ) ; } ] ; this . error On Unhandled Rejections = function ( value ) { if ( is Defined ( value ) ) { error On Unhandled Rejections = value ; return this ; } else { return error On Unhandled Rejections ; } } ; } 
function q Factory ( next Tick , exception Handler , error On Unhandled Rejections ) { var $q Min Err = min Err ( ' $q ' , Type Error ) ; var queue Size = 0 ; var check Queue = [ ] ; function defer ( ) { return new Deferred ( ) ; } function Deferred ( ) { var promise = this . promise = new Promise ( ) ; * @ngdoc method * @name $q #reject * @kind function * * @description * Creates a promise that is resolved as rejected with the specified `reason ` . This api should be * used to forward rejection in a chain of promises . If you are dealing with the last promise in * a promise chain , you don 't need to worry about it . * * When comparing deferreds /promises to the familiar behavior of try /catch /throw , think of * `reject ` as the `throw ` keyword in Java Script . This also means that if you "catch " an error via * a promise error callback and you want to forward the error to the promise derived from the * current promise , you have to "rethrow " the error by returning a rejection constructed via * `reject ` . * * ` ` `js * promise B = promise A .then (function (result ) { * / / success : do something and resolve promise B * / / with the old or a new result * return result ; * } , function (reason ) { * / / error : handle the error if possible and * / / resolve promise B with new Promise Or Value , * / / otherwise forward the rejection to promise B * if (can Handle (reason ) ) { * / / handle the error and recover * return new Promise Or Value ; * } * return $q .reject (reason ) ; * } ) ; * ` ` ` * * @param { * } reason Constant , message , exception or an object representing the rejection reason . * @returns {Promise } Returns a promise that was already resolved as rejected with the `reason ` . * / function reject ( reason ) { var result = new Promise ( ) ; reject Promise ( result , reason ) ; return result ; } function handle Callback ( value , resolver , callback ) { var callback Output = null ; try { if ( is Function ( callback ) ) callback Output = callback ( ) ; } catch ( e ) { return reject ( e ) ; } if ( is Promise Like ( callback Output ) ) { return callback Output . then ( function ( ) { return resolver ( value ) ; } , reject ) ; } else { return resolver ( value ) ; } } / * * * @ngdoc method * @name $q #when * @kind function * * @description * Wraps an object that might be a value or a ( 3rd party ) then -able promise into a $q promise . * This is useful when you are dealing with an object that might or might not be a promise , or if * the promise comes from a source that can 't be trusted . * * @param { * } value Value or a promise * @param {Function = } success Callback * @param {Function = } error Callback * @param {Function = } progress Callback * @returns {Promise } Returns a promise of the passed value or promise * / function when ( value , callback , errback , progress Back ) { var result = new Promise ( ) ; resolve Promise ( result , value ) ; return result . then ( callback , errback , progress Back ) ; } var resolve = when ; function all ( promises ) { var result = new Promise ( ) , counter = 0 , results = is Array ( promises ) ? [ ] : { } ; for Each ( promises , function ( promise , key ) { counter + + ; when ( promise ) . then ( function ( value ) { results [ key ] = value ; if ( ! ( - - counter ) ) resolve Promise ( result , results ) ; } , function ( reason ) { reject Promise ( result , reason ) ; } ) ; } ) ; if ( counter = = = 0 ) { resolve Promise ( result , results ) ; } return result ; } function race ( promises ) { var deferred = defer ( ) ; for Each ( promises , function ( promise ) { when ( promise ) . then ( deferred . resolve , deferred . reject ) ; } ) ; return deferred . promise ; } function $Q ( resolver ) { if ( ! is Function ( resolver ) ) { throw $q Min Err ( 'norslvr ' , 'Expected resolver Fn , got \ ' { 0 } \ ' ' , resolver ) ; } var promise = new Promise ( ) ; function resolve Fn ( value ) { resolve Promise ( promise , value ) ; } function reject Fn ( reason ) { reject Promise ( promise , reason ) ; } resolver ( resolve Fn , reject Fn ) ; return promise ; } 
function when ( value , callback , errback , progress Back ) { var result = new Promise ( ) ; resolve Promise ( result , value ) ; return result . then ( callback , errback , progress Back ) ; } 
function all ( promises ) { var result = new Promise ( ) , counter = 0 , results = is Array ( promises ) ? [ ] : { } ; for Each ( promises , function ( promise , key ) { counter + + ; when ( promise ) . then ( function ( value ) { results [ key ] = value ; if ( ! ( - - counter ) ) resolve Promise ( result , results ) ; } , function ( reason ) { reject Promise ( result , reason ) ; } ) ; } ) ; if ( counter = = = 0 ) { resolve Promise ( result , results ) ; } return result ; } 
function race ( promises ) { var deferred = defer ( ) ; for Each ( promises , function ( promise ) { when ( promise ) . then ( deferred . resolve , deferred . reject ) ; } ) ; return deferred . promise ; } 
function $Root Scope Provider ( ) { var TTL = 1 0 ; var $root Scope Min Err = min Err ( ' $root Scope ' ) ; var last Dirty Watch = null ; var apply Async Id = null ; this . digest Ttl = function ( value ) { if ( arguments . length ) { TTL = value ; } return TTL ; } ; function create Child Scope Class ( parent ) { function Child Scope ( ) { this . $ $watchers = this . $ $next Sibling = this . $ $child Head = this . $ $child Tail = null ; this . $ $listeners = { } ; this . $ $listener Count = { } ; this . $ $watchers Count = 0 ; this . $id = next Uid ( ) ; this . $ $Child Scope = null ; this . $ $suspended = false ; } Child Scope . prototype = parent ; return Child Scope ; } this . $get = [ ' $exception Handler ' , ' $parse ' , ' $browser ' , function ( $exception Handler , $parse , $browser ) { function destroy Child Scope ( $event ) { $event . current Scope . $ $destroyed = true ; } function clean Up Scope ( $scope ) { * @ngdoc type * @name $root Scope .Scope * * @description * A root scope can be retrieved using the { @link ng . $root Scope $root Scope } key from the * { @link auto . $injector $injector } . Child scopes are created using the * { @link ng . $root Scope .Scope # $new $new ( ) } method . (Most scopes are created automatically when * compiled HTML template is executed . ) See also the { @link guide /scope Scopes guide } for * an in -depth introduction and usage examples . * * * # # Inheritance * A scope can inherit from a parent scope , as in this example : * ` ` `js var parent = $root Scope ; var child = parent . $new ( ) ; parent .salutation = "Hello " ; expect (child .salutation ) .to Equal ( 'Hello ' ) ; child .salutation = "Welcome " ; expect (child .salutation ) .to Equal ( 'Welcome ' ) ; expect (parent .salutation ) .to Equal ( 'Hello ' ) ; * ` ` ` * * When interacting with `Scope ` in tests , additional helper methods are available on the * instances of `Scope ` type . See { @link ng Mock . $root Scope .Scope ng Mock Scope } for additional * details . * * * @param {Object . <string , function ( ) > = } providers Map of service factory which need to be * provided for the current scope . Defaults to { @link ng } . * @param {Object . <string , * > = } instance Cache Provides pre -instantiated services which should * append /override services provided by `providers ` . This is handy * when unit -testing and having the need to override a default * service . * @returns {Object } Newly created scope . * * / function Scope ( ) { this . $id = next Uid ( ) ; this . $ $phase = this . $parent = this . $ $watchers = this . $ $next Sibling = this . $ $prev Sibling = this . $ $child Head = this . $ $child Tail = null ; this . $root = this ; this . $ $destroyed = false ; this . $ $suspended = false ; this . $ $listeners = { } ; this . $ $listener Count = { } ; this . $ $watchers Count = 0 ; this . $ $isolate Bindings = null ; } Scope . prototype = { constructor : Scope , $new : function ( isolate , parent ) { var child ; parent = parent | | this ; if ( isolate ) { child = new Scope ( ) ; child . $root = this . $root ; } else { * @ngdoc method * @name $root Scope .Scope # $watch * @kind function * * @description * Registers a `listener ` callback to be executed whenever the `watch Expression ` changes . * * - The `watch Expression ` is called on every call to { @link ng . $root Scope .Scope # $digest * $digest ( ) } and should return the value that will be watched . ( `watch Expression ` should not change * its value when executed multiple times with the same input because it may be executed multiple * times by { @link ng . $root Scope .Scope # $digest $digest ( ) } . That is , `watch Expression ` should be * [idempotent ] (http : * - The `listener ` is called only when the value from the current `watch Expression ` and the * previous call to `watch Expression ` are not equal (with the exception of the initial run , * see below ) . Inequality is determined according to reference inequality , * [strict comparison ] (https : * via the ` ! = = ` Javascript operator , unless `object Equality = = true ` * (see next point ) * - When `object Equality = = true ` , inequality of the `watch Expression ` is determined * according to the { @link angular .equals } function . To save the value of the object for * later comparison , the { @link angular .copy } function is used . This therefore means that * watching complex objects will have adverse memory and performance implications . * - This should not be used to watch for changes in objects that are (or contain ) * [File ] (https : * - The watch `listener ` may change the model , which may trigger other `listener `s to fire . * This is achieved by rerunning the watchers until no changes are detected . The rerun * iteration limit is 1 0 to prevent an infinite loop deadlock . * * * If you want to be notified whenever { @link ng . $root Scope .Scope # $digest $digest } is called , * you can register a `watch Expression ` function with no `listener ` . (Be prepared for * multiple calls to your `watch Expression ` because it will execute multiple times in a * single { @link ng . $root Scope .Scope # $digest $digest } cycle if a change is detected . ) * * After a watcher is registered with the scope , the `listener ` fn is called asynchronously * (via { @link ng . $root Scope .Scope # $eval Async $eval Async } ) to initialize the * watcher . In rare cases , this is undesirable because the listener is called when the result * of `watch Expression ` didn 't change . To detect this scenario within the `listener ` fn , you * can compare the `new Val ` and `old Val ` . If these two values are identical ( ` = = = ` ) then the * listener was called due to initialization . * * * * @example * ` ` `js / / let 's assume that scope was dependency injected as the $root Scope var scope = $root Scope ; scope .name = 'misko ' ; scope .counter = 0 ; expect (scope .counter ) .to Equal ( 0 ) ; scope . $watch ( 'name ' , function (new Value , old Value ) { scope .counter = scope .counter + 1 ; } ) ; expect (scope .counter ) .to Equal ( 0 ) ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 1 ) ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 1 ) ; scope .name = 'adam ' ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 2 ) ; var food ; scope .food Counter = 0 ; expect (scope .food Counter ) .to Equal ( 0 ) ; scope . $watch ( function ( ) { return food ; } , function (new Value , old Value ) { if ( new Value ! = = old Value ) { scope .food Counter = scope .food Counter + 1 ; } } ) ; expect (scope .food Counter ) .to Equal ( 0 ) ; scope . $digest ( ) ; expect (scope .food Counter ) .to Equal ( 0 ) ; food = 'cheeseburger ' ; scope . $digest ( ) ; expect (scope .food Counter ) .to Equal ( 1 ) ; * ` ` ` * * * * @param { (function ( ) |string ) } watch Expression Expression that is evaluated on each * { @link ng . $root Scope .Scope # $digest $digest } cycle . A change in the return value triggers * a call to the `listener ` . * * - `string ` : Evaluated as { @link guide /expression expression } * - `function (scope ) ` : called with current `scope ` as a parameter . * @param {function (new Val , old Val , scope ) } listener Callback called whenever the value * of `watch Expression ` changes . * * - `new Val ` contains the current value of the `watch Expression ` * - `old Val ` contains the previous value of the `watch Expression ` * - `scope ` refers to the current scope * @param {boolean = } [object Equality =false ] Compare for object equality using { @link angular .equals } instead of * comparing for reference equality . * @returns {function ( ) } Returns a deregistration function for this listener . * / $watch : function ( watch Exp , listener , object Equality , pretty Print Expression ) { var get = $parse ( watch Exp ) ; var fn = is Function ( listener ) ? listener : noop ; if ( get . $ $watch Delegate ) { return get . $ $watch Delegate ( this , fn , object Equality , get , watch Exp ) ; } var scope = this , array = scope . $ $watchers , watcher = { fn : fn , last : init Watch Val , get : get , exp : pretty Print Expression | | watch Exp , eq : ! ! object Equality } ; last Dirty Watch = null ; if ( ! array ) { array = scope . $ $watchers = [ ] ; array . $ $digest Watch Index = - 1 ; } * @ngdoc method * @name $root Scope .Scope # $watch Group * @kind function * * @description * A variant of { @link ng . $root Scope .Scope # $watch $watch ( ) } where it watches an array of `watch Expressions ` . * If any one expression in the collection changes the `listener ` is executed . * * - The items in the `watch Expressions ` array are observed via the standard ` $watch ` operation . Their return * values are examined for changes on every call to ` $digest ` . * - The `listener ` is called whenever any expression in the `watch Expressions ` array changes . * * @param {Array . <string |Function (scope ) > } watch Expressions Array of expressions that will be individually * watched using { @link ng . $root Scope .Scope # $watch $watch ( ) } * * @param {function (new Values , old Values , scope ) } listener Callback called whenever the return value of any * expression in `watch Expressions ` changes * The `new Values ` array contains the current values of the `watch Expressions ` , with the indexes matching * those of `watch Expression ` * and the `old Values ` array contains the previous values of the `watch Expressions ` , with the indexes matching * those of `watch Expression ` * The `scope ` refers to the current scope . * @returns {function ( ) } Returns a de -registration function for all listeners . * / $watch Group : function ( watch Expressions , listener ) { var old Values = new Array ( watch Expressions . length ) ; var new Values = new Array ( watch Expressions . length ) ; var deregister Fns = [ ] ; var self = this ; var change Reaction Scheduled = false ; var first Run = true ; if ( ! watch Expressions . length ) { * @ngdoc method * @name $root Scope .Scope # $watch Collection * @kind function * * @description * Shallow watches the properties of an object and fires whenever any of the properties change * (for arrays , this implies watching the array items ; for object maps , this implies watching * the properties ) . If a change is detected , the `listener ` callback is fired . * * - The `obj ` collection is observed via standard $watch operation and is examined on every * call to $digest ( ) to see if any items have been added , removed , or moved . * - The `listener ` is called whenever anything within the `obj ` has changed . Examples include * adding , removing , and moving items belonging to an object or array . * * * @example * ` ` `js $scope .names = [ 'igor ' , 'matias ' , 'misko ' , 'james ' ] ; $scope .data Count = 4 ; $scope . $watch Collection ( 'names ' , function (new Names , old Names ) { $scope .data Count = new Names .length ; } ) ; expect ( $scope .data Count ) .to Equal ( 4 ) ; $scope . $digest ( ) ; expect ( $scope .data Count ) .to Equal ( 4 ) ; $scope .names .pop ( ) ; $scope . $digest ( ) ; expect ( $scope .data Count ) .to Equal ( 3 ) ; * ` ` ` * * * @param {string |function (scope ) } obj Evaluated as { @link guide /expression expression } . The * expression value should evaluate to an object or an array which is observed on each * { @link ng . $root Scope .Scope # $digest $digest } cycle . Any shallow change within the * collection will trigger a call to the `listener ` . * * @param {function (new Collection , old Collection , scope ) } listener a callback function called * when a change is detected . * - The `new Collection ` object is the newly modified data obtained from the `obj ` expression * - The `old Collection ` object is a copy of the former collection data . * Due to performance considerations , the `old Collection ` value is computed only if the * `listener ` function declares two or more arguments . * - The `scope ` argument refers to the current scope . * * @returns {function ( ) } Returns a de -registration function for this listener . When the * de -registration function is executed , the internal watch operation is terminated . * / $watch Collection : function ( obj , listener ) { * @ngdoc method * @name $root Scope .Scope # $digest * @kind function * * @description * Processes all of the { @link ng . $root Scope .Scope # $watch watchers } of the current scope and * its children . Because a { @link ng . $root Scope .Scope # $watch watcher } 's listener can change * the model , the ` $digest ( ) ` keeps calling the { @link ng . $root Scope .Scope # $watch watchers } * until no more listeners are firing . This means that it is possible to get into an infinite * loop . This function will throw ` 'Maximum iteration limit exceeded . ' ` if the number of * iterations exceeds 1 0 . * * Usually , you don 't call ` $digest ( ) ` directly in * { @link ng .directive :ng Controller controllers } or in * { @link ng . $compile Provider #directive directives } . * Instead , you should call { @link ng . $root Scope .Scope # $apply $apply ( ) } (typically from within * a { @link ng . $compile Provider #directive directive } ) , which will force a ` $digest ( ) ` . * * If you want to be notified whenever ` $digest ( ) ` is called , * you can register a `watch Expression ` function with * { @link ng . $root Scope .Scope # $watch $watch ( ) } with no `listener ` . * * In unit tests , you may need to call ` $digest ( ) ` to simulate the scope life cycle . * * @example * ` ` `js var scope = . . . ; scope .name = 'misko ' ; scope .counter = 0 ; expect (scope .counter ) .to Equal ( 0 ) ; scope . $watch ( 'name ' , function (new Value , old Value ) { scope .counter = scope .counter + 1 ; } ) ; expect (scope .counter ) .to Equal ( 0 ) ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 1 ) ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 1 ) ; scope .name = 'adam ' ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 2 ) ; * ` ` ` * * / $digest : function ( ) { var watch , value , last , fn , get , watchers , dirty , ttl = TTL , next , current , target = async Queue . length ? $root Scope : this , watch Log = [ ] , log Idx , async Task ; begin Phase ( ' $digest ' ) ; * @ngdoc method * @name $root Scope .Scope # $suspend * @kind function * * @description * Suspend watchers of this scope subtree so that they will not be invoked during digest . * * This can be used to optimize your application when you know that running those watchers * is redundant . * * * *Warning * * * * Suspending scopes from the digest cycle can have unwanted and difficult to debug results . * Only use this approach if you are confident that you know what you are doing and have * ample tests to ensure that bindings get updated as you expect . * * Some of the things to consider are : * * * Any external event on a directive /component will not trigger a digest while the hosting * scope is suspended - even if the event handler calls ` $apply ( ) ` or ` $root Scope . $digest ( ) ` . * * Transcluded content exists on a scope that inherits from outside a directive but exists * as a child of the directive 's containing scope . If the containing scope is suspended the * transcluded scope will also be suspended , even if the scope from which the transcluded * scope inherits is not suspended . * * Multiple directives trying to manage the suspended status of a scope can confuse each other : * * A call to ` $suspend ( ) ` on an already suspended scope is a no -op . * * A call to ` $resume ( ) ` on a non -suspended scope is a no -op . * * If two directives suspend a scope , then one of them resumes the scope , the scope will no * longer be suspended . This could result in the other directive believing a scope to be * suspended when it is not . * * If a parent scope is suspended then all its descendants will be also excluded from future * digests whether or not they have been suspended themselves . Note that this also applies to * isolate child scopes . * * Calling ` $digest ( ) ` directly on a descendant of a suspended scope will still run the watchers * for that scope and its descendants . When digesting we only check whether the current scope is * locally suspended , rather than checking whether it has a suspended ancestor . * * Calling ` $resume ( ) ` on a scope that has a suspended ancestor will not cause the scope to be * included in future digests until all its ancestors have been resumed . * * Resolved promises , e .g . from explicit ` $q ` deferreds and ` $http ` calls , trigger ` $apply ( ) ` * against the ` $root Scope ` and so will still trigger a global digest even if the promise was * initiated by a component that lives on a suspended scope . * / $suspend : function ( ) { this . $ $suspended = true ; } , / * * * @ngdoc method * @name $root Scope .Scope # $is Suspended * @kind function * * @description * Call this method to determine if this scope has been explicitly suspended . It will not * tell you whether an ancestor has been suspended . * To determine if this scope will be excluded from a digest triggered at the $root Scope , * for example , you must check all its ancestors : * * ` ` ` * function is Excluded From Digest (scope ) { * while (scope ) { * if (scope . $is Suspended ( ) ) return true ; * scope = scope . $parent ; * } * return false ; * ` ` ` * * Be aware that a scope may not be included in digests if it has a suspended ancestor , * even if ` $is Suspended ( ) ` returns false . * * @returns true if the current scope has been suspended . * / $is Suspended : function ( ) { return this . $ $suspended ; } , / * * * @ngdoc method * @name $root Scope .Scope # $resume * @kind function * * @description * Resume watchers of this scope subtree in case it was suspended . * * See { @link $root Scope .Scope # $suspend } for information about the dangers of using this approach . * / $resume : function ( ) { this . $ $suspended = false ; } , / * * * @ngdoc event * @name $root Scope .Scope # $destroy * @event Type broadcast on scope being destroyed * * @description * Broadcasted when a scope and its children are being destroyed . * * Note that , in Angular JS , there is also a ` $destroy ` j Query event , which can be used to * clean up DOM bindings before an element is removed from the DOM . * / / * * * @ngdoc method * @name $root Scope .Scope # $destroy * @kind function * * @description * Removes the current scope (and all of its children ) from the parent scope . Removal implies * that calls to { @link ng . $root Scope .Scope # $digest $digest ( ) } will no longer * propagate to the current scope and its children . Removal also implies that the current * scope is eligible for garbage collection . * * The ` $destroy ( ) ` is usually used by directives such as * { @link ng .directive :ng Repeat ng Repeat } for managing the * unrolling of the loop . * * Just before a scope is destroyed , a ` $destroy ` event is broadcasted on this scope . * Application code can register a ` $destroy ` event handler that will give it a chance to * perform any necessary cleanup . * * Note that , in Angular JS , there is also a ` $destroy ` j Query event , which can be used to * clean up DOM bindings before an element is removed from the DOM . * / $destroy : function ( ) { / / We can 't destroy a scope that has been already destroyed . if ( this . $ $destroyed ) return ; var parent = this . $parent ; this . $broadcast ( ' $destroy ' ) ; this . $ $destroyed = true ; if ( this = = = $root Scope ) { * @ngdoc method * @name $root Scope .Scope # $eval * @kind function * * @description * Executes the `expression ` on the current scope and returns the result . Any exceptions in * the expression are propagated (uncaught ) . This is useful when evaluating Angular JS * expressions . * * @example * ` ` `js var scope = ng . $root Scope .Scope ( ) ; scope .a = 1 ; scope .b = 2 ; expect (scope . $eval ( 'a +b ' ) ) .to Equal ( 3 ) ; expect (scope . $eval (function (scope ) { return scope .a + scope .b ; } ) ) .to Equal ( 3 ) ; * ` ` ` * * @param { (string |function ( ) ) = } expression An Angular JS expression to be executed . * * - `string ` : execute using the rules as defined in { @link guide /expression expression } . * - `function (scope ) ` : execute the function with the current `scope ` parameter . * * @param { (object ) = } locals Local variables object , useful for overriding values in scope . * @returns { * } The result of evaluating the expression . * / $eval : function ( expr , locals ) { return $parse ( expr ) ( this , locals ) ; } , $eval Async : function ( expr , locals ) { * @ngdoc method * @name $root Scope .Scope # $apply * @kind function * * @description * ` $apply ( ) ` is used to execute an expression in Angular JS from outside of the Angular JS * framework . (For example from browser DOM events , set Timeout , XHR or third party libraries ) . * Because we are calling into the Angular JS framework we need to perform proper scope life * cycle of { @link ng . $exception Handler exception handling } , * { @link ng . $root Scope .Scope # $digest executing watches } . * * * *Life cycle : Pseudo -Code of ` $apply ( ) ` * * * * ` ` `js function $apply (expr ) { try { return $eval (expr ) ; } catch (e ) { $exception Handler (e ) ; } finally { $root . $digest ( ) ; } } * ` ` ` * * * Scope 's ` $apply ( ) ` method transitions through the following stages : * * 1 . The { @link guide /expression expression } is executed using the * { @link ng . $root Scope .Scope # $eval $eval ( ) } method . * 2 . Any exceptions from the execution of the expression are forwarded to the * { @link ng . $exception Handler $exception Handler } service . * 3 . The { @link ng . $root Scope .Scope # $watch watch } listeners are fired immediately after the * expression was executed using the { @link ng . $root Scope .Scope # $digest $digest ( ) } method . * * * @param { (string |function ( ) ) = } exp An Angular JS expression to be executed . * * - `string ` : execute using the rules as defined in { @link guide /expression expression } . * - `function (scope ) ` : execute the function with current `scope ` parameter . * * @returns { * } The result of evaluating the expression . * / $apply : function ( expr ) { try { begin Phase ( ' $apply ' ) ; try { return this . $eval ( expr ) ; } finally { clear Phase ( ) ; } } catch ( e ) { $exception Handler ( e ) ; } finally { try { $root Scope . $digest ( ) ; } catch ( e ) { $exception Handler ( e ) ; / / eslint -disable -next -line no -unsafe -finally throw e ; } } } , / * * * @ngdoc method * @name $root Scope .Scope # $apply Async * @kind function * * @description * Schedule the invocation of $apply to occur at a later time . The actual time difference * varies across browsers , but is typically around ~ 1 0 milliseconds . * * This can be used to queue up multiple expressions which need to be evaluated in the same * digest . * * @param { (string |function ( ) ) = } exp An Angular JS expression to be executed . * * - `string ` : execute using the rules as defined in { @link guide /expression expression } . * - `function (scope ) ` : execute the function with current `scope ` parameter . * / $apply Async : function ( expr ) { var scope = this ; if ( expr ) { apply Async Queue . push ( $apply Async Expression ) ; } expr = $parse ( expr ) ; schedule Apply Async ( ) ; function $apply Async Expression ( ) { scope . $eval ( expr ) ; } } , / * * * @ngdoc method * @name $root Scope .Scope # $on * @kind function * * @description * Listens on events of a given type . See { @link ng . $root Scope .Scope # $emit $emit } for * discussion of event life cycle . * * The event listener function format is : `function (event , args . . . ) ` . The `event ` object * passed into the listener has the following attributes : * * - `target Scope ` - ` {Scope } ` : the scope on which the event was ` $emit ` -ed or * ` $broadcast ` -ed . * - `current Scope ` - ` {Scope } ` : the scope that is currently handling the event . Once the * event propagates through the scope hierarchy , this property is set to null . * - `name ` - ` {string } ` : name of the event . * - `stop Propagation ` - ` {function = } ` : calling `stop Propagation ` function will cancel * further event propagation (available only for events that were ` $emit ` -ed ) . * - `prevent Default ` - ` {function } ` : calling `prevent Default ` sets `default Prevented ` flag * to true . * - `default Prevented ` - ` {boolean } ` : true if `prevent Default ` was called . * * @param {string } name Event name to listen on . * @param {function (event , . . .args ) } listener Function to call when the event is emitted . * @returns {function ( ) } Returns a deregistration function for this listener . * / $on : function ( name , listener ) { var named Listeners = this . $ $listeners [ name ] ; if ( ! named Listeners ) { this . $ $listeners [ name ] = named Listeners = [ ] ; } named Listeners . push ( listener ) ; var current = this ; do { if ( ! current . $ $listener Count [ name ] ) { current . $ $listener Count [ name ] = 0 ; } current . $ $listener Count [ name ] + + ; } while ( ( current = current . $parent ) ) ; var self = this ; return function ( ) { var index Of Listener = named Listeners . index Of ( listener ) ; if ( index Of Listener ! = = - 1 ) { / / Use delete in the hope of the browser deallocating the memory for the array entry , / / while not shifting the array indexes of other listeners . / / See issue https : / /github .com /angular /angular .js /issues / 1 6 1 3 5 delete named Listeners [ index Of Listener ] ; decrement Listener Count ( self , 1 , name ) ; } } ; } , / * * * @ngdoc method * @name $root Scope .Scope # $emit * @kind function * * @description * Dispatches an event `name ` upwards through the scope hierarchy notifying the * registered { @link ng . $root Scope .Scope # $on } listeners . * * The event life cycle starts at the scope on which ` $emit ` was called . All * { @link ng . $root Scope .Scope # $on listeners } listening for `name ` event on this scope get * notified . Afterwards , the event traverses upwards toward the root scope and calls all * registered listeners along the way . The event will stop propagating if one of the listeners * cancels it . * * Any exception emitted from the { @link ng . $root Scope .Scope # $on listeners } will be passed * onto the { @link ng . $exception Handler $exception Handler } service . * * @param {string } name Event name to emit . * @param { . . . * } args Optional one or more arguments which will be passed onto the event listeners . * @return {Object } Event object (see { @link ng . $root Scope .Scope # $on } ) . * / $emit : function ( name , args ) { var empty = [ ] , named Listeners , scope = this , stop Propagation = false , event = { name : name , target Scope : scope , stop Propagation : function ( ) { stop Propagation = true ; } , prevent Default : function ( ) { event . default Prevented = true ; } , default Prevented : false } , listener Args = concat ( [ event ] , arguments , 1 ) , i , length ; do { named Listeners = scope . $ $listeners [ name ] | | empty ; event . current Scope = scope ; for ( i = 0 , length = named Listeners . length ; i < length ; i + + ) { / / if listeners were deregistered , defragment the array if ( ! named Listeners [ i ] ) { named Listeners . splice ( i , 1 ) ; i - - ; length - - ; continue ; } try { / /allow all listeners attached to the current scope to run named Listeners [ i ] . apply ( null , listener Args ) ; } catch ( e ) { $exception Handler ( e ) ; } } / /if any listener on the current scope stops propagation , prevent bubbling if ( stop Propagation ) { break ; } / /traverse upwards scope = scope . $parent ; } while ( scope ) ; event . current Scope = null ; return event ; } , / * * * @ngdoc method * @name $root Scope .Scope # $broadcast * @kind function * * @description * Dispatches an event `name ` downwards to all child scopes (and their children ) notifying the * registered { @link ng . $root Scope .Scope # $on } listeners . * * The event life cycle starts at the scope on which ` $broadcast ` was called . All * { @link ng . $root Scope .Scope # $on listeners } listening for `name ` event on this scope get * notified . Afterwards , the event propagates to all direct and indirect scopes of the current * scope and calls all registered listeners along the way . The event cannot be canceled . * * Any exception emitted from the { @link ng . $root Scope .Scope # $on listeners } will be passed * onto the { @link ng . $exception Handler $exception Handler } service . * * @param {string } name Event name to broadcast . * @param { . . . * } args Optional one or more arguments which will be passed onto the event listeners . * @return {Object } Event object , see { @link ng . $root Scope .Scope # $on } * / $broadcast : function ( name , args ) { var target = this , current = target , next = target , event = { name : name , target Scope : target , prevent Default : function ( ) { event . default Prevented = true ; } , default Prevented : false } ; if ( ! target . $ $listener Count [ name ] ) return event ; var listener Args = concat ( [ event ] , arguments , 1 ) , listeners , i , length ; / /down while you can , then up and next sibling or up and next sibling until back at root while ( ( current = next ) ) { event . current Scope = current ; listeners = current . $ $listeners [ name ] | | [ ] ; for ( i = 0 , length = listeners . length ; i < length ; i + + ) { / / if listeners were deregistered , defragment the array if ( ! listeners [ i ] ) { listeners . splice ( i , 1 ) ; i - - ; length - - ; continue ; } try { listeners [ i ] . apply ( null , listener Args ) ; } catch ( e ) { $exception Handler ( e ) ; } } / / Insanity Warning : scope depth -first traversal / / yes , this code is a bit crazy , but it works and we have tests to prove it ! / / this piece should be kept in sync with the traversal in $digest / / (though it differs due to having the extra check for $ $listener Count and / / does not check $ $suspended ) if ( ! ( next = ( ( current . $ $listener Count [ name ] & & current . $ $child Head ) | | ( current ! = = target & & current . $ $next Sibling ) ) ) ) { while ( current ! = = target & & ! ( next = current . $ $next Sibling ) ) { current = current . $parent ; } } } event . current Scope = null ; return event ; } } ; var $root Scope = new Scope ( ) ; / /The internal queues . Expose them on the $root Scope for debugging /testing purposes . var async Queue = $root Scope . $ $async Queue = [ ] ; var post Digest Queue = $root Scope . $ $post Digest Queue = [ ] ; var apply Async Queue = $root Scope . $ $apply Async Queue = [ ] ; var post Digest Queue Position = 0 ; return $root Scope ; function begin Phase ( phase ) { if ( $root Scope . $ $phase ) { throw $root Scope Min Err ( 'inprog ' , ' { 0 } already in progress ' , $root Scope . $ $phase ) ; } $root Scope . $ $phase = phase ; } function clear Phase ( ) { $root Scope . $ $phase = null ; } function increment Watchers Count ( current , count ) { do { current . $ $watchers Count + = count ; } while ( ( current = current . $parent ) ) ; } function decrement Listener Count ( current , count , name ) { do { current . $ $listener Count [ name ] - = count ; if ( current . $ $listener Count [ name ] = = = 0 ) { delete current . $ $listener Count [ name ] ; } } while ( ( current = current . $parent ) ) ; } / * * * function used as an initial value for watchers . * because it 's unique we can easily tell it apart from other values * / function init Watch Val ( ) { } function flush Apply Async ( ) { while ( apply Async Queue . length ) { try { apply Async Queue . shift ( ) ( ) ; } catch ( e ) { $exception Handler ( e ) ; } } apply Async Id = null ; } function schedule Apply Async ( ) { if ( apply Async Id = = = null ) { apply Async Id = $browser . defer ( function ( ) { $root Scope . $apply ( flush Apply Async ) ; } , null , ' $apply Async ' ) ; } } } ] ; } 
function ( isolate , parent ) { var child ; parent = parent | | this ; if ( isolate ) { child = new Scope ( ) ; child . $root = this . $root ; } else { 
function ( watch Expressions , listener ) { var old Values = new Array ( watch Expressions . length ) ; var new Values = new Array ( watch Expressions . length ) ; var deregister Fns = [ ] ; var self = this ; var change Reaction Scheduled = false ; var first Run = true ; if ( ! watch Expressions . length ) { 
function $ $Sanitize Uri Provider ( ) { var a Href Sanitization Whitelist = / ^ \s * (https ? |s ?ftp |mailto |tel |file ) : / , img Src Sanitization Whitelist = / ^ \s * ( (https ? |ftp |file |blob ) : |data :image \ / ) / ; this . a Href Sanitization Whitelist = function ( regexp ) { if ( is Defined ( regexp ) ) { a Href Sanitization Whitelist = regexp ; return this ; } return a Href Sanitization Whitelist ; } ; this . img Src Sanitization Whitelist = function ( regexp ) { if ( is Defined ( regexp ) ) { img Src Sanitization Whitelist = regexp ; return this ; } return img Src Sanitization Whitelist ; } ; this . $get = function ( ) { return function sanitize Uri ( uri , is Media Url ) { 
function get Trusted ( type , maybe Trusted ) { if ( maybe Trusted = = = null | | is Undefined ( maybe Trusted ) | | maybe Trusted = = = ' ' ) { return maybe Trusted ; } var constructor = ( by Type . has Own Property ( type ) ? by Type [ type ] : null ) ; 
function url Is Allowed Origin Factory ( whitelisted Origin Urls ) { var parsed Allowed Origin Urls = [ origin Url ] . concat ( whitelisted Origin Urls . map ( url Resolve ) ) ; return function url Is Allowed Origin ( request Url ) { var parsed Url = url Resolve ( request Url ) ; return parsed Allowed Origin Urls . some ( urls Are Same Origin . bind ( null , parsed Url ) ) ; } ; } 
function urls Are Same Origin ( url 1 , url 2 ) { url 1 = url Resolve ( url 1 ) ; url 2 = url Resolve ( url 2 ) ; return ( url 1 . protocol = = = url 2 . protocol & & url 1 . host = = = url 2 . host ) ; } 
function get Base Url ( ) { if ( window . document . base URI ) { return window . document . base URI ; } 
function filter Filter ( ) { return function ( array , expression , comparator , any Property Key ) { if ( ! is Array Like ( array ) ) { if ( array = = null ) { return array ; } else { throw min Err ( 'filter ' ) ( 'notarray ' , 'Expected array but received : { 0 } ' , array ) ; } } any Property Key = any Property Key | | ' $ ' ; var expression Type = get Type For Filter ( expression ) ; var predicate Fn ; var match Against Any Prop ; switch ( expression Type ) { case 'function ' : predicate Fn = expression ; break ; case 'boolean ' : case 'null ' : case 'number ' : case 'string ' : match Against Any Prop = true ; 
function format Number ( number , pattern , group Sep , decimal Sep , fraction Size ) { if ( ! ( is String ( number ) | | is Number ( number ) ) | | is Na N ( number ) ) return ' ' ; var is Infinity = ! is Finite ( number ) ; var is Zero = false ; var num Str = Math . abs ( number ) + ' ' , formatted Text = ' ' , parsed Number ; if ( is Infinity ) { formatted Text = ' \u 2 2 1e ' ; } else { parsed Number = parse ( num Str ) ; round Number ( parsed Number , fraction Size , pattern . min Frac , pattern . max Frac ) ; var digits = parsed Number . d ; var integer Len = parsed Number . i ; var exponent = parsed Number . e ; var decimals = [ ] ; is Zero = digits . reduce ( function ( is Zero , d ) { return is Zero & & ! d ; } , true ) ; 
function limit To Filter ( ) { return function ( input , limit , begin ) { if ( Math . abs ( Number ( limit ) ) = = = Infinity ) { limit = Number ( limit ) ; } else { limit = to Int ( limit ) ; } if ( is Number Na N ( limit ) ) return input ; if ( is Number ( input ) ) input = input . to String ( ) ; if ( ! is Array Like ( input ) ) return input ; begin = ( ! begin | | is Na N ( begin ) ) ? 0 : to Int ( begin ) ; begin = ( begin < 0 ) ? Math . max ( 0 , input . length + begin ) : begin ; if ( limit > = 0 ) { return slice Fn ( input , begin , begin + limit ) ; } else { if ( begin = = = 0 ) { return slice Fn ( input , limit , input . length ) ; } else { return slice Fn ( input , Math . max ( 0 , begin + limit ) , begin ) ; } } } ; } 
function ( control , new Name ) { var old Name = control . $name ; if ( this [ old Name ] = = = control ) { delete this [ old Name ] ; } this [ new Name ] = control ; control . $name = new Name ; } 
function ( control ) { if ( control . $name & & this [ control . $name ] = = = control ) { delete this [ control . $name ] ; } for Each ( this . $pending , function ( value , name ) { 
function ( ) { this . $ $animate . set Class ( this . $ $element , PRISTINE _CLASS , DIRTY _CLASS + ' ' + SUBMITTED _CLASS ) ; this . $dirty = false ; this . $pristine = true ; this . $submitted = false ; for Each ( this . $ $controls , function ( control ) { control . $set Pristine ( ) ; } ) ; } 
function ( is Ng Form ) { return [ ' $timeout ' , ' $parse ' , function ( $timeout , $parse ) { var form Directive = { name : 'form ' , restrict : is Ng Form ? 'EAC ' : 'E ' , require : [ 'form ' , ' ^ ^ ?form ' ] , 
function setup Validity ( instance ) { instance . $ $class Cache = { } ; instance . $ $class Cache [ INVALID _CLASS ] = ! ( instance . $ $class Cache [ VALID _CLASS ] = instance . $ $element . has Class ( VALID _CLASS ) ) ; } 
function update Element Value ( element , attr , value ) { 
function class Directive ( name , selector ) { name = 'ng Class ' + name ; var index Watch Expression ; return [ ' $parse ' , function ( $parse ) { return { restrict : 'AC ' , link : function ( scope , element , attr ) { var class Counts = element . data ( ' $class Counts ' ) ; var old Modulo = true ; var old Class String ; if ( ! class Counts ) { 
function ( ) { 
function ( ) { var formatters = this . $formatters , idx = formatters . length ; var view Value = this . $model Value ; while ( idx - - ) { view Value = formatters [ idx ] ( view Value ) ; } return view Value ; } 
function ( ) { Ng Model Options Controller . $inject = [ ' $attrs ' , ' $scope ' ] ; function Ng Model Options Controller ( $attrs , $scope ) { this . $ $attrs = $attrs ; this . $ $scope = $scope ; } Ng Model Options Controller . prototype = { $on Init : function ( ) { var parent Options = this . parent Ctrl ? this . parent Ctrl . $options : default Model Options ; var model Options Definition = this . $ $scope . $eval ( this . $ $attrs . ng Model Options ) ; this . $options = parent Options . create Child ( model Options Definition ) ; } } ; return { restrict : 'A ' , 
function defaults ( dst , src ) { for Each ( src , function ( value , key ) { if ( ! is Defined ( dst [ key ] ) ) { dst [ key ] = value ; } } ) ; } 
function add Option Element ( option , parent ) { var option Element = option Template . clone Node ( false ) ; parent . append Child ( option Element ) ; update Option Element ( option , option Element ) ; } 
function ( play Animation ) { if ( ! animation Completed ) { animation Paused = ! play Animation ; if ( timings . animation Duration ) { var value = block Keyframe Animations ( node , animation Paused ) ; if ( animation Paused ) { temporary Styles . push ( value ) ; } else { remove From Array ( temporary Styles , value ) ; } } } else if ( animation Paused & & play Animation ) { animation Paused = false ; close ( ) ; } } 
function ( element , bool ) { var arg Count = arguments . length ; if ( arg Count = = = 0 ) { 
function are Animations Allowed ( node , parent Node , event ) { var body Node = $document [ 0 ] . body ; var root Node = get Dom Node ( $root Element ) ; var body Node Detected = ( node = = = body Node ) | | node . node Name = = = 'HTML ' ; var root Node Detected = ( node = = = root Node ) ; var parent Animation Detected = false ; var element Disabled = disabled Elements Lookup . get ( node ) ; var animate Children ; var parent Host = jq Lite . data ( node , NG _ANIMATE _PIN _DATA ) ; if ( parent Host ) { parent Node = get Dom Node ( parent Host ) ; } while ( parent Node ) { if ( ! root Node Detected ) { 
function ( scope , $element , attrs , ctrl , $transclude ) { var previous Element , previous Scope ; scope . $watch Collection ( attrs . ng Animate Swap | | attrs [ 'for ' ] , function ( value ) { if ( previous Element ) { $animate . leave ( previous Element ) ; } if ( previous Scope ) { previous Scope . $destroy ( ) ; previous Scope = null ; } if ( value | | value = = = 0 ) { $transclude ( function ( clone , child Scope ) { previous Element = clone ; previous Scope = child Scope ; $animate . enter ( clone , null , $element ) ; } ) ; } } ) ; } 
function $Aria Provider ( ) { var config = { aria Hidden : true , aria Checked : true , aria Readonly : true , aria Disabled : true , aria Required : true , aria Invalid : true , aria Value : true , tabindex : true , bind Keydown : true , bind Role For Click : true } ; this . config = function ( new Config ) { config = angular . extend ( config , new Config ) ; } ; function watch Expr ( attr Name , aria Attr , node Black List , negate ) { return function ( scope , elem , attr ) { if ( attr . has Own Property ( ARIA _DISABLE _ATTR ) ) return ; var aria Camel Name = attr . $normalize ( aria Attr ) ; if ( config [ aria Camel Name ] & & ! is Node One Of ( elem , node Black List ) & & ! attr [ aria Camel Name ] ) { scope . $watch ( attr [ attr Name ] , function ( bool Val ) { * @ngdoc service * @name $aria * * @description * @priority 2 0 0 * * The $aria service contains helper methods for applying common * [ARIA ] (http : * * ng Aria injects common accessibility attributes that tell assistive technologies when HTML * elements are enabled , selected , hidden , and more . To see how this is performed with ng Aria , * let 's review a code snippet from ng Aria itself : * * ` ` `js * ng Aria Module .directive ( 'ng Disabled ' , [ ' $aria ' , function ( $aria ) { * return $aria . $ $watch Expr ( 'ng Disabled ' , 'aria -disabled ' , node Black List , false ) ; * } ] ) * ` ` ` * Shown above , the ng Aria module creates a directive with the same signature as the * traditional `ng -disabled ` directive . But this ng Aria version is dedicated to * solely managing accessibility attributes on custom elements . The internal ` $aria ` service is * used to watch the boolean attribute `ng Disabled ` . If it has not been explicitly set by the * developer , `aria -disabled ` is injected as an attribute with its value synchronized to the * value in `ng Disabled ` . * * Because ng Aria hooks into the `ng -disabled ` directive , developers do not have to do * anything to enable this feature . The `aria -disabled ` attribute is automatically managed * simply as a silent side -effect of using `ng -disabled ` with the ng Aria module . * * The full list of directives that interface with ng Aria : * * * *ng Model * * * * * *ng Checked * * * * * *ng Readonly * * * * * *ng Required * * * * * *ng Disabled * * * * * *ng Value * * * * * *ng Show * * * * * *ng Hide * * * * * *ng Click * * * * * *ng Dblclick * * * * * *ng Messages * * * * Read the { @link guide /accessibility ng Aria Developer Guide } for a thorough explanation of each * directive . * * * # # Dependencies * Requires the { @link ng Aria } module to be installed . * / this . $get = function ( ) { return { config : function ( key ) { return config [ key ] ; } , $ $watch Expr : watch Expr } ; } ; } 
function ( elem , attr ) { if ( attr . has Own Property ( ARIA _DISABLE _ATTR ) ) return ; var shape = get Shape ( attr , elem ) ; return { post : function ( scope , elem , attr , ng Model ) { var needs Tab Index = should Attach Attr ( 'tabindex ' , 'tabindex ' , elem , false ) ; function ng Aria Watch Model Value ( ) { return ng Model . $model Value ; } function get Radio Reaction ( new Val ) { 
function ( $scope , element , attrs ) { var src = attrs . ng Messages Include | | attrs . src ; $template Request ( src ) . then ( function ( html ) { if ( $scope . $ $destroyed ) return ; if ( is String ( html ) & & ! html . trim ( ) ) { 
function replace Element With Marker ( element , src ) { 
function locale _locales _ _get Set Global Locale ( key , values ) { var data ; if ( key ) { if ( typeof values = = = 'undefined ' ) { data = locale _locales _ _get Locale ( key ) ; } else { data = define Locale ( key , values ) ; } if ( data ) { 
function config From String ( config ) { var matched = asp Net Json Regex . exec ( config . _i ) ; if ( matched ! = = null ) { config . _d = new Date ( + matched [ 1 ] ) ; return ; } config From ISO ( config ) ; if ( config . _is Valid = = = false ) { delete config . _is Valid ; utils _hooks _ _hooks . create From Input Fallback ( config ) ; } } 
function get Set Week Year ( input ) { var year = week Of Year ( this , this . locale Data ( ) . _week . dow , this . locale Data ( ) . _week . doy ) . year ; return input = = null ? year : this . add ( ( input - year ) , 'y ' ) ; } 
function get Set Day Of Week ( input ) { var day = this . _is UTC ? this . _d . get UTCDay ( ) : this . _d . get Day ( ) ; if ( input ! = null ) { input = parse Weekday ( input , this . locale Data ( ) ) ; return this . add ( input - day , 'd ' ) ; } else { return day ; } } 
function duration _humanize _ _get Set Relative Time Threshold ( threshold , limit ) { if ( thresholds [ threshold ] = = = undefined ) { return false ; } if ( limit = = = undefined ) { return thresholds [ threshold ] ; } thresholds [ threshold ] = limit ; return true ; } 
function ( element , parent , options ) { options = options | | { } ; $md Util . disable Scroll Around . _count = Math . max ( 0 , $md Util . disable Scroll Around . _count | | 0 ) ; $md Util . disable Scroll Around . _count + + ; if ( $md Util . disable Scroll Around . _restore Scroll ) { return $md Util . disable Scroll Around . _restore Scroll ; } var body = $document [ 0 ] . body ; var restore Body = disable Body Scroll ( ) ; var restore Element = disable Element Scroll ( parent ) ; return $md Util . disable Scroll Around . _restore Scroll = function ( ) { if ( - - $md Util . disable Scroll Around . _count < = 0 ) { restore Body ( ) ; restore Element ( ) ; delete $md Util . disable Scroll Around . _restore Scroll ; } } ; function disable Element Scroll ( element ) { element = angular . element ( element | | body ) ; var scroll Mask ; if ( options . disable Scroll Mask ) { scroll Mask = element ; } else { scroll Mask = angular . element ( ' <div class = "md -scroll -mask " > ' + ' <div class = "md -scroll -mask -bar " > < /div > ' + ' < /div > ' ) ; element . append ( scroll Mask ) ; } scroll Mask . on ( 'wheel ' , prevent Default ) ; scroll Mask . on ( 'touchmove ' , prevent Default ) ; return function restore Element Scroll ( ) { scroll Mask . off ( 'wheel ' ) ; scroll Mask . off ( 'touchmove ' ) ; if ( ! options . disable Scroll Mask & & scroll Mask [ 0 ] . parent Node ) { scroll Mask [ 0 ] . parent Node . remove Child ( scroll Mask [ 0 ] ) ; } } ; function prevent Default ( e ) { e . prevent Default ( ) ; } } 
function Md Gesture ( $ $Md Gesture Handler , $ $r AF , $timeout ) { var user Agent = navigator . user Agent | | navigator . vendor | | window . opera ; var is Ios = user Agent . match ( / ipad |iphone |ipod / i ) ; var is Android = user Agent . match ( / android / i ) ; var touch Action Property = get Touch Action ( ) ; var has JQuery = ( typeof window . j Query ! = = 'undefined ' ) & & ( angular . element = = = window . j Query ) ; var self = { handler : add Handler , register : register , is Android : is Android , is Ios : is Ios , * Register an element to listen for a handler . * This allows an element to override the default options for a handler . * Additionally , some handlers like drag and hold only dispatch events if * the dom Event happens inside an element that 's registered to listen for these events . * * @see Gesture Handler for how overriding of default options works . * @example $md Gesture .register (my Element , 'drag ' , { min Distance : 2 0 , horizontal : false } ) * / function register ( element , handler Name , options ) { var handler = HANDLERS [ handler Name . replace ( / ^ \ $md . / , ' ' ) ] ; if ( ! handler ) { throw new Error ( 'Failed to register element with handler ' + handler Name + ' . ' + 'Available handlers : ' + Object . keys ( HANDLERS ) . join ( ' , ' ) ) ; } return handler . register Element ( element , options ) ; } / * * add a handler to $md Gesture . see below . * / function add Handler ( name , definition ) { var handler = new $ $Md Gesture Handler ( name ) ; angular . extend ( handler , definition ) ; HANDLERS [ name ] = handler ; return self ; } / * * * Register handlers . These listen to touch /start /move events , interpret them , * and dispatch gesture events depending on options & conditions . These are all * instances of Gesture Handler . * @see Gesture Handler * / return self / * * The press handler dispatches an event on touchdown /touchend . * It 's a simple abstraction of touch /mouse /pointer start and end . * / . handler ( 'press ' , { on Start : function ( ev , pointer ) { this . dispatch Event ( ev , ' $md .pressdown ' ) ; } , on End : function ( ev , pointer ) { this . dispatch Event ( ev , ' $md .pressup ' ) ; } } ) . handler ( 'hold ' , { options : { max Distance : 6 , delay : 5 0 0 } , on Cancel : function ( ) { $timeout . cancel ( this . state . timeout ) ; } , on Start : function ( ev , pointer ) { * The drag handler dispatches a drag event if the user holds and moves his finger greater than * <min Distance > px in the x or y direction , depending on options .horizontal . * The drag will be cancelled if the user moves his finger greater than <min Distance > * <cancel Multiplier > in * the perpendicular direction . Eg if the drag is horizontal and the user moves his finger <min Distance > * <cancel Multiplier > * pixels vertically , this handler won 't consider the move part of a drag . * / . handler ( 'drag ' , { options : { min Distance : 6 , horizontal : true , cancel Multiplier : 1 . 5 } , on Setup : function ( element , options ) { if ( touch Action Property ) { / / We check for horizontal to be false , because otherwise we would overwrite the default opts . this . old Touch Action = element [ 0 ] . style [ touch Action Property ] ; element [ 0 ] . style [ touch Action Property ] = options . horizontal ? 'pan -y ' : 'pan -x ' ; } } , on Cleanup : function ( element ) { if ( this . old Touch Action ) { element [ 0 ] . style [ touch Action Property ] = this . old Touch Action ; } } , on Start : function ( ev ) { / / For drag , require a parent to be registered with $md Gesture .register ( ) if ( ! this . state . registered Parent ) this . cancel ( ) ; } , on Move : function ( ev , pointer ) { var should Start Drag , should Cancel ; / / Don 't scroll while deciding if this touchmove qualifies as a drag event . * The swipe handler will dispatch a swipe event if , on the end of a touch , * the velocity and distance were high enough . * / . handler ( 'swipe ' , { options : { min Velocity : 0 . 6 5 , min Distance : 1 0 } , on End : function ( ev , pointer ) { var event Type ; if ( Math . abs ( pointer . velocity X ) > this . state . options . min Velocity & & Math . abs ( pointer . distance X ) > this . state . options . min Distance ) { event Type = pointer . direction X = = 'left ' ? ' $md .swipeleft ' : ' $md .swiperight ' ; this . dispatch Event ( ev , event Type ) ; } else if ( Math . abs ( pointer . velocity Y ) > this . state . options . min Velocity & & Math . abs ( pointer . distance Y ) > this . state . options . min Distance ) { event Type = pointer . direction Y = = 'up ' ? ' $md .swipeup ' : ' $md .swipedown ' ; this . dispatch Event ( ev , event Type ) ; } } } ) ; function get Touch Action ( ) { var test El = document . create Element ( 'div ' ) ; var vendor Prefixes = [ ' ' , 'webkit ' , 'Moz ' , 'MS ' , 'ms ' , 'o ' ] ; for ( var i = 0 ; i < vendor Prefixes . length ; i + + ) { var prefix = vendor Prefixes [ i ] ; var property = prefix ? prefix + 'Touch Action ' : 'touch Action ' ; if ( angular . is Defined ( test El . style [ property ] ) ) { return property ; } } } } 
function Md Interaction Service ( $timeout , $md Util ) { this . $timeout = $timeout ; this . $md Util = $md Util ; this . body Element = angular . element ( document . body ) ; this . is Buffering = false ; this . buffer Timeout = null ; this . last Interaction Type = null ; this . last Interaction Time = null ; 
function Interim Element Provider ( ) { Interim Element Factory . $inject = [ " $document " , " $q " , " $root Scope " , " $timeout " , " $root Element " , " $animate " , " $md Util " , " $md Compiler " , " $md Theming " , " $injector " , " $exception Handler " ] ; create Interim Element Provider . $get = Interim Element Factory ; return create Interim Element Provider ; function create Interim Element Provider ( interim Factory Name ) { factory . $inject = [ " $ $interim Element " , " $injector " ] ; var EXPOSED _METHODS = [ 'on Hide ' , 'on Show ' , 'on Remove ' ] ; var custom Methods = { } ; var provider Config = { presets : { } } ; var provider = { set Defaults : set Defaults , add Preset : add Preset , add Method : add Method , $get : factory } ; provider . add Preset ( 'build ' , { methods : [ 'controller ' , 'controller As ' , 'resolve ' , 'multiple ' , 'template ' , 'template Url ' , 'themable ' , 'transform Template ' , 'parent ' , 'content Element ' ] } ) ; return provider ; function set Defaults ( definition ) { provider Config . options Factory = definition . options ; provider Config . methods = ( definition . methods | | [ ] ) . concat ( EXPOSED _METHODS ) ; return provider ; } function add Method ( name , fn ) { custom Methods [ name ] = fn ; return provider ; } function add Preset ( name , definition ) { definition = definition | | { } ; definition . methods = definition . methods | | [ ] ; definition . options = definition . options | | function ( ) { return { } ; } ; if ( / ^cancel |hide |show $ / . test ( name ) ) { throw new Error ( "Preset ' " + name + " ' in " + interim Factory Name + " is reserved ! " ) ; } if ( definition . methods . index Of ( ' _options ' ) > - 1 ) { throw new Error ( "Method ' _options ' in " + interim Factory Name + " is reserved ! " ) ; } provider Config . presets [ name ] = { methods : definition . methods . concat ( EXPOSED _METHODS ) , options Factory : definition . options , arg Option : definition . arg Option } ; return provider ; } function add Preset Method ( preset Name , method Name , method ) { provider Config . presets [ preset Name ] [ method Name ] = method ; } function factory ( $ $interim Element , $injector ) { var default Methods ; var default Options ; var interim Element Service = $ $interim Element ( ) ; var public Service = { hide : interim Element Service . hide , cancel : interim Element Service . cancel , show : show Interim Element , * * / function show Interim Element ( opts ) { * Special method to hide and destroy an interim Element WITHOUT * any 'leave ` or hide animations ( an immediate force hide /remove ) * * NOTE : This calls the on Remove ( ) subclass method for each component . . . * which must have code to respond to `options . $destroy = = true ` * / function destroy Interim Element ( opts ) { return interim Element Service . destroy ( opts ) ; } / * * * Helper to call $injector .invoke with a local of the factory name for * this provider . * If an $md Dialog is providing options for a dialog and tries to inject * $md Dialog , a circular dependency error will happen . * We get around that by manually injecting $md Dialog as a local . * / function invoke Factory ( factory , default Val ) { var locals = { } ; locals [ interim Factory Name ] = public Service ; return $injector . invoke ( factory | | function ( ) { return default Val ; } , { } , locals ) ; } } } / * @ng Inject * / function Interim Element Factory ( $document , $q , $root Scope , $timeout , $root Element , $animate , $md Util , $md Compiler , $md Theming , $injector , $exception Handler ) { return function create Interim Element Service ( ) { var SHOW _CANCELLED = false ; / * * @ngdoc service * @name $ $interim Element . $service * * @description * A service used to control inserting and removing an element into the DOM . * * / var service ; var show Promises = [ ] ; / / Promises for the interim 's which are currently opening . var hide Promises = [ ] ; * @ngdoc method * @name $ $interim Element . $service #show * @kind function * * @description * Adds the ` $interim Element ` to the DOM and returns a special promise that will be resolved or rejected * with hide or cancel , respectively . To external cancel /hide , developers should use the * * @param { * } options is hash Map of settings * @returns a Promise * * / function show ( options ) { options = options | | { } ; var interim Element = new Interim Element ( options | | { } ) ; * @ngdoc method * @name $ $interim Element . $service #hide * @kind function * * @description * Removes the ` $interim Element ` from the DOM and resolves the promise returned from `show ` * * @param { * } resolve Param Data to resolve the promise with * @returns a Promise that will be resolved after the element has been removed . * * / function hide ( reason , options ) { options = options | | { } ; if ( options . close All ) { * @ngdoc method * @name $ $interim Element . $service #cancel * @kind function * * @description * Removes the ` $interim Element ` from the DOM and rejects the promise returned from `show ` * * @param { * } reason Data to reject the promise with * @returns Promise that will be resolved after the element has been removed . * * / function cancel ( reason , options ) { var interim = showing Interims . pop ( ) ; if ( ! interim ) { return $q . when ( reason ) ; } var cancel Action = interim . remove ( reason , true , options | | { } ) . catch ( function ( reason ) { return reason ; } ) . finally ( function ( ) { hide Promises . splice ( hide Promises . index Of ( cancel Action ) , 1 ) ; } ) ; hide Promises . push ( cancel Action ) ; * Creates a function to wait for at least one interim element to be available . * @param callback Fn Function to be used as callback * @returns {Function } * / function wait For Interim ( callback Fn ) { return function ( ) { var fn Arguments = arguments ; if ( ! showing Interims . length ) { * Special method to quick -remove the interim element without animations * Note : interim elements are in "interim containers " * / function destroy ( target El ) { var interim = ! target El ? showing Interims . shift ( ) : null ; var parent El = angular . element ( target El ) . length & & angular . element ( target El ) [ 0 ] . parent Node ; if ( parent El ) { * Internal Interim Element Object * Used internally to manage the DOM element and related data * / function Interim Element ( options ) { var self , element , show Action = $q . when ( true ) ; options = configure Scope And Transitions ( options ) ; return self = { options : options , deferred : $q . defer ( ) , show : create And Transition In , remove : transition Out And Remove } ; function create And Transition In ( ) { return $q ( function ( resolve , reject ) { * After the show process has finished /rejected : * - announce 'removing ' , * - perform the transition -out , and * - perform optional clean up scope . * / function transition Out And Remove ( response , is Cancelled , opts ) { * The `show ( ) ` returns a promise that will be resolved when the interim * element is hidden or cancelled . . . * / function resolve All ( response ) { self . deferred . resolve ( response ) ; } function reject All ( fault ) { self . deferred . reject ( fault ) ; } } function configure Scope And Transitions ( options ) { options = options | | { } ; if ( options . template ) { options . template = $md Util . process Template ( options . template ) ; } return angular . extend ( { preserve Scope : false , cancel Auto Hide : angular . noop , scope : options . scope | | $root Scope . $new ( options . isolate Scope ) , on Show : function transition In ( scope , element , options ) { return $animate . enter ( element , options . parent ) ; } , on Remove : function transition Out ( scope , element ) { * Compile an element with a template Url , controller , and locals * / function compile Element ( options ) { var compiled = ! options . skip Compile ? $md Compiler . compile ( options ) : null ; return compiled | | $q ( function ( resolve ) { resolve ( { locals : { } , link : function ( ) { return options . element ; } } ) ; } ) ; } function link Element ( compile Data , options ) { angular . extend ( compile Data . locals , options ) ; var element = compile Data . link ( options . scope ) ; * Search for parent at insertion time , if not specified * / function find Parent ( element , options ) { var parent = options . parent ; * If auto -hide is enabled , start timer and prepare cancel function * / function start Auto Hide ( ) { var auto Hide Timer , cancel Auto Hide = angular . noop ; if ( options . hide Delay ) { auto Hide Timer = $timeout ( service . hide , options . hide Delay ) ; cancel Auto Hide = function ( ) { $timeout . cancel ( auto Hide Timer ) ; } ; } * Show the element ( with transitions ) , notify complete and start * optional auto -Hide * / function show Element ( element , options , controller ) { 
function create Interim Element Provider ( interim Factory Name ) { factory . $inject = [ " $ $interim Element " , " $injector " ] ; var EXPOSED _METHODS = [ 'on Hide ' , 'on Show ' , 'on Remove ' ] ; var custom Methods = { } ; var provider Config = { presets : { } } ; var provider = { set Defaults : set Defaults , add Preset : add Preset , add Method : add Method , $get : factory } ; provider . add Preset ( 'build ' , { methods : [ 'controller ' , 'controller As ' , 'resolve ' , 'multiple ' , 'template ' , 'template Url ' , 'themable ' , 'transform Template ' , 'parent ' , 'content Element ' ] } ) ; return provider ; function set Defaults ( definition ) { provider Config . options Factory = definition . options ; provider Config . methods = ( definition . methods | | [ ] ) . concat ( EXPOSED _METHODS ) ; return provider ; } function add Method ( name , fn ) { custom Methods [ name ] = fn ; return provider ; } function add Preset ( name , definition ) { definition = definition | | { } ; definition . methods = definition . methods | | [ ] ; definition . options = definition . options | | function ( ) { return { } ; } ; if ( / ^cancel |hide |show $ / . test ( name ) ) { throw new Error ( "Preset ' " + name + " ' in " + interim Factory Name + " is reserved ! " ) ; } if ( definition . methods . index Of ( ' _options ' ) > - 1 ) { throw new Error ( "Method ' _options ' in " + interim Factory Name + " is reserved ! " ) ; } provider Config . presets [ name ] = { methods : definition . methods . concat ( EXPOSED _METHODS ) , options Factory : definition . options , arg Option : definition . arg Option } ; return provider ; } function add Preset Method ( preset Name , method Name , method ) { provider Config . presets [ preset Name ] [ method Name ] = method ; } function factory ( $ $interim Element , $injector ) { var default Methods ; var default Options ; var interim Element Service = $ $interim Element ( ) ; var public Service = { hide : interim Element Service . hide , cancel : interim Element Service . cancel , show : show Interim Element , * * / function show Interim Element ( opts ) { * Special method to hide and destroy an interim Element WITHOUT * any 'leave ` or hide animations ( an immediate force hide /remove ) * * NOTE : This calls the on Remove ( ) subclass method for each component . . . * which must have code to respond to `options . $destroy = = true ` * / function destroy Interim Element ( opts ) { return interim Element Service . destroy ( opts ) ; } function invoke Factory ( factory , default Val ) { var locals = { } ; locals [ interim Factory Name ] = public Service ; return $injector . invoke ( factory | | function ( ) { return default Val ; } , { } , locals ) ; } } } 
function Interim Element Factory ( $document , $q , $root Scope , $timeout , $root Element , $animate , $md Util , $md Compiler , $md Theming , $injector , $exception Handler ) { return function create Interim Element Service ( ) { var SHOW _CANCELLED = false ; var service ; var show Promises = [ ] ; * @ngdoc method * @name $ $interim Element . $service #show * @kind function * * @description * Adds the ` $interim Element ` to the DOM and returns a special promise that will be resolved or rejected * with hide or cancel , respectively . To external cancel /hide , developers should use the * * @param { * } options is hash Map of settings * @returns a Promise * * / function show ( options ) { options = options | | { } ; var interim Element = new Interim Element ( options | | { } ) ; * @ngdoc method * @name $ $interim Element . $service #hide * @kind function * * @description * Removes the ` $interim Element ` from the DOM and resolves the promise returned from `show ` * * @param { * } resolve Param Data to resolve the promise with * @returns a Promise that will be resolved after the element has been removed . * * / function hide ( reason , options ) { options = options | | { } ; if ( options . close All ) { * @ngdoc method * @name $ $interim Element . $service #cancel * @kind function * * @description * Removes the ` $interim Element ` from the DOM and rejects the promise returned from `show ` * * @param { * } reason Data to reject the promise with * @returns Promise that will be resolved after the element has been removed . * * / function cancel ( reason , options ) { var interim = showing Interims . pop ( ) ; if ( ! interim ) { return $q . when ( reason ) ; } var cancel Action = interim . remove ( reason , true , options | | { } ) . catch ( function ( reason ) { return reason ; } ) . finally ( function ( ) { hide Promises . splice ( hide Promises . index Of ( cancel Action ) , 1 ) ; } ) ; hide Promises . push ( cancel Action ) ; * Creates a function to wait for at least one interim element to be available . * @param callback Fn Function to be used as callback * @returns {Function } * / function wait For Interim ( callback Fn ) { return function ( ) { var fn Arguments = arguments ; if ( ! showing Interims . length ) { * Special method to quick -remove the interim element without animations * Note : interim elements are in "interim containers " * / function destroy ( target El ) { var interim = ! target El ? showing Interims . shift ( ) : null ; var parent El = angular . element ( target El ) . length & & angular . element ( target El ) [ 0 ] . parent Node ; if ( parent El ) { * Internal Interim Element Object * Used internally to manage the DOM element and related data * / function Interim Element ( options ) { var self , element , show Action = $q . when ( true ) ; options = configure Scope And Transitions ( options ) ; return self = { options : options , deferred : $q . defer ( ) , show : create And Transition In , remove : transition Out And Remove } ; function create And Transition In ( ) { return $q ( function ( resolve , reject ) { * After the show process has finished /rejected : * - announce 'removing ' , * - perform the transition -out , and * - perform optional clean up scope . * / function transition Out And Remove ( response , is Cancelled , opts ) { * The `show ( ) ` returns a promise that will be resolved when the interim * element is hidden or cancelled . . . * / function resolve All ( response ) { self . deferred . resolve ( response ) ; } function reject All ( fault ) { self . deferred . reject ( fault ) ; } } function configure Scope And Transitions ( options ) { options = options | | { } ; if ( options . template ) { options . template = $md Util . process Template ( options . template ) ; } return angular . extend ( { preserve Scope : false , cancel Auto Hide : angular . noop , scope : options . scope | | $root Scope . $new ( options . isolate Scope ) , on Show : function transition In ( scope , element , options ) { return $animate . enter ( element , options . parent ) ; } , on Remove : function transition Out ( scope , element ) { * Compile an element with a template Url , controller , and locals * / function compile Element ( options ) { var compiled = ! options . skip Compile ? $md Compiler . compile ( options ) : null ; return compiled | | $q ( function ( resolve ) { resolve ( { locals : { } , link : function ( ) { return options . element ; } } ) ; } ) ; } function link Element ( compile Data , options ) { angular . extend ( compile Data . locals , options ) ; var element = compile Data . link ( options . scope ) ; * Search for parent at insertion time , if not specified * / function find Parent ( element , options ) { var parent = options . parent ; * If auto -hide is enabled , start timer and prepare cancel function * / function start Auto Hide ( ) { var auto Hide Timer , cancel Auto Hide = angular . noop ; if ( options . hide Delay ) { auto Hide Timer = $timeout ( service . hide , options . hide Delay ) ; cancel Auto Hide = function ( ) { $timeout . cancel ( auto Hide Timer ) ; } ; } * Show the element ( with transitions ) , notify complete and start * optional auto -Hide * / function show Element ( element , options , controller ) { 
function show ( options ) { options = options | | { } ; var interim Element = new Interim Element ( options | | { } ) ; 
function Md Checkbox Directive ( input Directive , $md Aria , $md Constant , $md Theming , $md Util , $md Interaction ) { input Directive = input Directive [ 0 ] ; return { restrict : 'E ' , transclude : true , require : [ ' ^ ?md Input Container ' , ' ?ng Model ' , ' ? ^form ' ] , priority : $md Constant . BEFORE _NG _ARIA , template : ' <div class = "md -container " md -ink -ripple md -ink -ripple -checkbox > ' + ' <div class = "md -icon " > < /div > ' + ' < /div > ' + ' <div ng -transclude class = "md -label " > < /div > ' , compile : compile } ; 
function Md Colors Directive ( $md Colors , $md Util , $log , $parse ) { return { restrict : 'A ' , require : [ ' ^ ?md Theme ' ] , compile : function ( t Elem , t Attrs ) { var should Watch = should Colors Watch ( ) ; return function ( scope , element , attrs , ctrl ) { var md Theme Controller = ctrl [ 0 ] ; var last Colors = { } ; var parse Colors = function ( theme ) { if ( typeof theme ! = = 'string ' ) { theme = ' ' ; } if ( ! attrs . md Colors ) { attrs . md Colors = ' { } ' ; } var colors = $parse ( attrs . md Colors ) ( scope ) ; if ( md Theme Controller ) { Object . keys ( colors ) . for Each ( function ( prop ) { var color = colors [ prop ] ; if ( ! $md Colors . has Theme ( color ) ) { colors [ prop ] = ( theme | | md Theme Controller . $md Theme ) + ' - ' + color ; } } ) ; } clean Element ( colors ) ; return colors ; } ; var clean Element = function ( colors ) { if ( ! angular . equals ( colors , last Colors ) ) { var keys = Object . keys ( last Colors ) ; if ( last Colors . background & & ! keys . color ) { keys . push ( 'color ' ) ; } keys . for Each ( function ( key ) { element . css ( key , ' ' ) ; } ) ; } last Colors = colors ; } ; var unregister Changes = angular . noop ; if ( md Theme Controller ) { unregister Changes = md Theme Controller . register Changes ( function ( theme ) { $md Colors . apply Theme Colors ( element , parse Colors ( theme ) ) ; } ) ; } scope . $on ( ' $destroy ' , function ( ) { unregister Changes ( ) ; } ) ; try { if ( should Watch ) { scope . $watch ( parse Colors , angular . bind ( this , $md Colors . apply Theme Colors , element ) , true ) ; } else { $md Colors . apply Theme Colors ( element , parse Colors ( ) ) ; } } catch ( e ) { $log . error ( e . message ) ; } } ; function should Colors Watch ( ) { 
function Grid Tile Directive ( $md Media ) { return { restrict : 'E ' , require : ' ^md Grid List ' , template : ' <figure ng -transclude > < /figure > ' , transclude : true , scope : { } , 
function md Input Container Directive ( $md Theming , $parse ) { Container Ctrl . $inject = [ " $scope " , " $element " , " $attrs " , " $animate " ] ; var INPUT _TAGS = [ 'INPUT ' , 'TEXTAREA ' , 'SELECT ' , 'MD -SELECT ' ] ; var LEFT _SELECTORS = INPUT _TAGS . reduce ( function ( selectors , isel ) { return selectors . concat ( [ 'md -icon ~ ' + isel , ' .md -icon ~ ' + isel ] ) ; } , [ ] ) . join ( " , " ) ; var RIGHT _SELECTORS = INPUT _TAGS . reduce ( function ( selectors , isel ) { return selectors . concat ( [ isel + ' ~ md -icon ' , isel + ' ~ .md -icon ' ] ) ; } , [ ] ) . join ( " , " ) ; return { restrict : 'E ' , compile : compile , controller : Container Ctrl } ; function compile ( t Element ) { 
function Md Nav Bar ( $md Aria , $md Theming ) { return { restrict : 'E ' , transclude : true , controller : Md Nav Bar Controller , controller As : 'ctrl ' , bind To Controller : true , scope : { 'md Selected Nav Item ' : ' = ? ' , 'md No Ink Bar ' : ' = ? ' , 'nav Bar Aria Label ' : ' @ ? ' , } , template : ' <div class = "md -nav -bar " > ' + ' <nav role = "navigation " > ' + ' <ul class = " _md -nav -bar -list " ng -transclude role = "listbox " ' + 'tabindex = " 0 " ' + 'ng -focus = "ctrl .on Focus ( ) " ' + 'ng -keydown = "ctrl .on Keydown ( $event ) " ' + 'aria -label = " { {ctrl .nav Bar Aria Label } } " > ' + ' < /ul > ' + ' < /nav > ' + ' <md -nav -ink -bar ng -hide = "ctrl .md No Ink Bar " > < /md -nav -ink -bar > ' + ' < /div > ' , link : function ( scope , element , attrs , ctrl ) { $md Theming ( element ) ; if ( ! ctrl . nav Bar Aria Label ) { $md Aria . expect Async ( element , 'aria -label ' , angular . noop ) ; } } , } ; } 
function on Remove ( scope , element , opts ) { var animation Runner = null ; var destroy Listener = scope . $on ( ' $destroy ' , function ( ) { * For normal closes (eg clicks ) , animate the removal . * For forced closes (like $destroy events from navigation ) , * skip the animations * / function animate Removal ( ) { animation Runner = $animate Css ( element , { add Class : 'md -leave ' } ) ; return animation Runner . start ( ) ; } function clean Element ( ) { destroy Listener ( ) ; element . remove Class ( 'md -active ' ) . attr ( 'aria -hidden ' , 'true ' ) . css ( 'display ' , 'none ' ) ; element . parent ( ) . find ( 'md -select -value ' ) . remove Attr ( 'aria -hidden ' ) ; announce Closed ( opts ) ; if ( ! opts . $destroy & & opts . restore Focus ) { opts . target . focus ( ) ; } } } 
function position And Focus Menu ( ) { return $q ( function ( resolve ) { if ( opts . is Removed ) return $q . reject ( false ) ; var info = calculate Menu Positions ( scope , element , opts ) ; info . container . element . css ( animator . to Css ( info . container . styles ) ) ; info . drop Down . element . css ( animator . to Css ( info . drop Down . styles ) ) ; $ $r AF ( function ( ) { element . add Class ( 'md -active ' ) ; info . drop Down . element . css ( animator . to Css ( { transform : ' ' } ) ) ; resolve ( ) ; } ) ; } ) ; } 
function sanitize And Configure ( scope , options ) { var select El = element . find ( 'md -select -menu ' ) ; if ( ! options . target ) { throw new Error ( $md Util . supplant ( ERROR _TARGET _EXPECTED , [ options . target ] ) ) ; } angular . extend ( options , { is Removed : false , target : angular . element ( options . target ) , 
function update Is Open ( is Open ) { 
function Sidenav Controller ( $scope , $attrs , $md Component Registry , $q , $interpolate ) { var self = this ; 
function compile ( t Element , t Attrs ) { var wrapper = angular . element ( t Element [ 0 ] . get Elements By Class Name ( 'md -slider -wrapper ' ) ) ; var tab Index = t Attrs . tabindex | | 0 ; wrapper . attr ( 'tabindex ' , tab Index ) ; if ( t Attrs . disabled | | t Attrs . ng Disabled ) wrapper . attr ( 'tabindex ' , - 1 ) ; t Element . attr ( 'role ' , 'slider ' ) ; $md Aria . expect ( t Element , 'aria -label ' ) ; return post Link ; } 
function keydown Listener ( ev ) { if ( is Disabled ( ) ) return ; var change Amount ; if ( vertical ? ev . key Code = = = $md Constant . KEY _CODE . DOWN _ARROW : ev . key Code = = = $md Constant . KEY _CODE . LEFT _ARROW ) { change Amount = - step ; } else if ( vertical ? ev . key Code = = = $md Constant . KEY _CODE . UP _ARROW : ev . key Code = = = $md Constant . KEY _CODE . RIGHT _ARROW ) { change Amount = step ; } change Amount = invert ? - change Amount : change Amount ; if ( change Amount ) { if ( ev . meta Key | | ev . ctrl Key | | ev . alt Key ) { change Amount * = 4 ; } ev . prevent Default ( ) ; ev . stop Propagation ( ) ; scope . $eval Async ( function ( ) { set Model Value ( ng Model Ctrl . $view Value + change Amount ) ; } ) ; } } 
function refresh Position ( item ) { 
function Md Toast Controller ( $md Toast , $scope ) { 
function Virtual Repeat Model Array Like ( model ) { if ( ! angular . is Function ( model . get Item At Index ) | | ! angular . is Function ( model . get Length ) ) { throw Error ( 'When md -on -demand is enabled , the Object passed to md -virtual -repeat must implement ' + 'functions get Item At Index ( ) and get Length ( ) ' ) ; } this . model = model ; } 
function init ( ) { $md Util . init Optional Properties ( $scope , $attrs , { search Text : ' ' , selected Item : null , clear Button : false } ) ; $md Theming ( $element ) ; configure Watchers ( ) ; $md Util . next Tick ( function ( ) { gather Elements ( ) ; move Dropdown ( ) ; 
function position Dropdown ( ) { if ( ! elements ) { return $md Util . next Tick ( position Dropdown , false , $scope ) ; } var dropdown Height = ( $scope . dropdown Items | | MAX _ITEMS ) * ITEM _HEIGHT ; var hrect = elements . wrap . get Bounding Client Rect ( ) , vrect = elements . snap . get Bounding Client Rect ( ) , root = elements . root . get Bounding Client Rect ( ) , top = vrect . bottom - root . top , bot = root . bottom - vrect . top , left = hrect . left - root . left , width = hrect . width , offset = get Vertical Offset ( ) , position = $scope . dropdown Position , styles ; * Calculates the vertical offset for floating label examples to account for ng Messages * @returns {number } * / function get Vertical Offset ( ) { var offset = 0 ; var input Container = $element . find ( 'md -input -container ' ) ; if ( input Container . length ) { var input = input Container . find ( 'input ' ) ; offset = input Container . prop ( 'offset Height ' ) ; offset - = input . prop ( 'offset Top ' ) ; offset - = input . prop ( 'offset Height ' ) ; * Makes sure that the menu doesn 't go off of the screen on either side . * / function correct Horizontal Alignment ( ) { var dropdown = elements . scroll Container . get Bounding Client Rect ( ) , styles = { } ; if ( dropdown . right > root . right - MENU _PADDING ) { styles . left = ( hrect . right - dropdown . width ) + 'px ' ; } elements . $ . scroll Container . css ( styles ) ; } } 
function correct Horizontal Alignment ( ) { var dropdown = elements . scroll Container . get Bounding Client Rect ( ) , styles = { } ; if ( dropdown . right > root . right - MENU _PADDING ) { styles . left = ( hrect . right - dropdown . width ) + 'px ' ; } elements . $ . scroll Container . css ( styles ) ; } 
function gather Elements ( ) { var snap Wrap = gather Snap Wrap ( ) ; elements = { main : $element [ 0 ] , scroll Container : $element [ 0 ] . query Selector ( ' .md -virtual -repeat -container ' ) , scroller : $element [ 0 ] . query Selector ( ' .md -virtual -repeat -scroller ' ) , ul : $element . find ( 'ul ' ) [ 0 ] , input : $element . find ( 'input ' ) [ 0 ] , wrap : snap Wrap . wrap , snap : snap Wrap . snap , root : document . body } ; elements . li = elements . ul . get Elements By Tag Name ( 'li ' ) ; elements . $ = get Angular Elements ( elements ) ; input Model Ctrl = elements . $ . input . controller ( 'ng Model ' ) ; } 
function selected Item Change ( selected Item , previous Selected Item ) { update Model Validators ( ) ; if ( selected Item ) { get Display Value ( selected Item ) . then ( function ( val ) { $scope . search Text = val ; handle Selected Item Change ( selected Item , previous Selected Item ) ; } ) ; } else if ( previous Selected Item & & $scope . search Text ) { get Display Value ( previous Selected Item ) . then ( function ( display Value ) { 
function handle Search Text ( search Text , previous Search Text ) { ctrl . index = get Default Index ( ) ; 
function keydown ( event ) { switch ( event . key Code ) { case $md Constant . KEY _CODE . DOWN _ARROW : if ( ctrl . loading ) return ; event . stop Propagation ( ) ; event . prevent Default ( ) ; ctrl . index = Math . min ( ctrl . index + 1 , ctrl . matches . length - 1 ) ; update Scroll ( ) ; report Messages ( false , Report Type . Selected ) ; break ; case $md Constant . KEY _CODE . UP _ARROW : if ( ctrl . loading ) return ; event . stop Propagation ( ) ; event . prevent Default ( ) ; ctrl . index = ctrl . index < 0 ? ctrl . matches . length - 1 : Math . max ( 0 , ctrl . index - 1 ) ; update Scroll ( ) ; report Messages ( false , Report Type . Selected ) ; break ; case $md Constant . KEY _CODE . TAB : 
function get Display Value ( item ) { return $q . when ( get Item Text ( item ) | | item ) . then ( function ( item Text ) { if ( item Text & & ! angular . is String ( item Text ) ) { $log . warn ( 'md -autocomplete : Could not resolve display value to a string . ' + 'Please check the `md -item -text ` attribute . ' ) ; } return item Text ; } ) ; function get Item Text ( item ) { return ( item & & $scope . item Text ) ? $scope . item Text ( get Item As Name Val ( item ) ) : null ; } } 
function update Scroll ( ) { if ( ! elements . li [ 0 ] ) return ; var height = elements . li [ 0 ] . offset Height , top = height * ctrl . index , bot = top + height , hgt = elements . scroller . client Height , scroll Top = elements . scroller . scroll Top ; if ( top < scroll Top ) { scroll To ( top ) ; } else if ( bot > scroll Top + hgt ) { scroll To ( bot - hgt ) ; } } 
function select Item On Match ( ) { var search Text = $scope . search Text , matches = ctrl . matches , item = matches [ 0 ] ; if ( matches . length = = = 1 ) get Display Value ( item ) . then ( function ( display Value ) { var is Matching = search Text = = display Value ; if ( $scope . match Insensitive & & ! is Matching ) { is Matching = search Text . to Lower Case ( ) = = display Value . to Lower Case ( ) ; } if ( is Matching ) select ( 0 ) ; } ) ; } 
function Md Chips Ctrl ( $scope , $attrs , $md Constant , $log , $element , $timeout , $md Util , $exception Handler ) { this . $timeout = $timeout ; this . $md Constant = $md Constant ; this . $scope = $scope ; this . parent = $scope . $parent ; this . $md Util = $md Util ; this . $log = $log ; this . $exception Handler = $exception Handler ; this . $element = $element ; this . $attrs = $attrs ; this . ng Model Ctrl = null ; this . user Input Ng Model Ctrl = null ; this . autocomplete Ctrl = null ; this . user Input Element = null ; this . items = [ ] ; this . selected Chip = - 1 ; this . enable Chip Edit = $md Util . parse Attribute Boolean ( $attrs . md Enable Chip Edit ) ; this . add On Blur = $md Util . parse Attribute Boolean ( $attrs . md Add On Blur ) ; this . input Aria Label = 'Chips input . ' ; this . container Hint = 'Chips container . Use arrow keys to select chips . ' ; this . delete Hint = 'Press delete to remove this chip . ' ; this . delete Button Label = 'Remove ' ; this . chip Buffer = ' ' ; this . use Transform Chip = false ; this . use On Add = false ; this . use On Remove = false ; this . wrapper Id = ' ' ; this . content Ids = [ ] ; this . aria Tab Index = null ; this . chip Append Delay = DEFAULT _CHIP _APPEND _DELAY ; this . de Register = [ ] ; this . init ( ) ; } 
function setup Tabs Controller ( ) { ctrl . selected Index = ctrl . selected Index | | 0 ; compile Template ( ) ; configure Watchers ( ) ; bind Events ( ) ; $md Theming ( $element ) ; $md Util . next Tick ( function ( ) { 
function handle Stretch Tabs ( stretch Tabs ) { var elements = get Elements ( ) ; angular . element ( elements . wrapper ) . toggle Class ( 'md -stretch -tabs ' , should Stretch Tabs ( ) ) ; update Ink Bar Styles ( ) ; } 
function handle Offset Change ( left ) { var elements = get Elements ( ) ; var new Value = ( ( ctrl . should Center Tabs | | is Rtl ( ) ? ' ' : ' - ' ) + left + 'px ' ) ; 
function scroll ( event ) { if ( ! ctrl . should Paginate ) return ; event . prevent Default ( ) ; ctrl . offset Left = fix Offset ( ctrl . offset Left - event . wheel Delta ) ; } 
function should Paginate ( ) { if ( ctrl . no Pagination | | ! loaded ) return false ; var canvas Width = $element . prop ( 'client Width ' ) ; angular . for Each ( get Elements ( ) . tabs , function ( tab ) { canvas Width - = tab . offset Width ; } ) ; return canvas Width < 0 ; } 
function adjust Offset ( index ) { var elements = get Elements ( ) ; if ( ! angular . is Number ( index ) ) index = ctrl . focus Index ; if ( ! elements . tabs [ index ] ) return ; if ( ctrl . should Center Tabs ) return ; var tab = elements . tabs [ index ] , left = tab . offset Left , right = tab . offset Width + left , extra Offset = 3 2 ; 
function update Ink Bar Styles ( ) { var elements = get Elements ( ) ; if ( ! elements . tabs [ ctrl . selected Index ] ) { angular . element ( elements . ink Bar ) . css ( { left : 'auto ' , right : 'auto ' } ) ; return ; } if ( ! ctrl . tabs . length ) return queue . push ( ctrl . update Ink Bar Styles ) ; 
function Barcode 2D ( ) { this . width = 0 ; this . height = 0 ; this . background = ' #FFF ' ; this . modulecolor = ' # 0 0 0 ' ; this . type = 'PNG ' ; this . leftoffset = 0 ; this . topoffset = 0 ; this . unitwidth = 0 ; this . unitheight = 0 ; } 
function Barcode 1D ( ) { this . mode = MODE _BARWIDTH ; this . width = 0 ; this . height = 0 ; this . background = ' #FFF ' ; this . barcolor = ' # 0 0 0 ' ; this . type = 'PNG ' ; this . offset = 0 ; this . modulewidth = 1 ; } 
function generate Sequence ( seq , check ) { seq = seq . substr ( 0 , 1 2 ) + ' ' + check ; var first = seq . substr ( 0 , 1 ) , group 1 = seq . substr ( 1 , 6 ) , group 2 = seq . substr ( 7 ) ; var left = [ ] , right = [ ] , enc = ENCODE _GROUPS [ parse Int ( first ) ] , d Int ; for ( var i = 0 ; i < 6 ; i + + ) { d Int = parse Int ( group 1 [ i ] ) ; left = left . concat ( BARMAP [ enc [ i ] ] [ d Int ] ) ; } for ( var i = 0 ; i < 6 ; i + + ) { d Int = parse Int ( group 2 [ i ] ) right = right . concat ( BARMAP [ RIGHT ] [ d Int ] ) ; } return [ ] . concat ( START , left , MIDDLE , right , END ) ; } 
function from Upc A ( upcastr ) { var upca = upcastr . split ( ' ' ) ; if ( upca . length = = 1 2 ) { upca . pop ( ) ; } var first = upca . shift ( ) ; if ( upca . length ! = 1 0 | | first ! = 1 & & first ! = 0 ) { return ' ' ; } var upcamask = upca . join ( ' ' ) , match = null , upce = ' ' ; 
function generate Sequence ( pattern , parity , check ) { if ( pattern . length ! = = 6 ) { return null ; } check = parse Int ( check ) ; parity = parse Int ( parity ) ; var p = PAIRITYMAP [ check ] [ parity ] , seq = START ; for ( var i = 0 ; i < 6 ; i + + ) { seq = seq . concat ( BARMAP [ p [ i ] ] [ parse Int ( pattern [ i ] ) ] ) ; } return seq . concat ( END ) ; } 
function build Frame Tree ( frame ) { var tree = { name : frame . get Param Value ( "tabname " ) | | "mira .frame ( " + frame . id + " ) " , children : [ ] } ; frame . get Objects ( ) . for Each ( function ( obj ) { tree . children . push ( { name : obj . type + " ( " + obj . id + " ) " } ) ; } ) ; return tree ; } 
function update ( ) { var state Tree = build Tree JSON ( xebra State . get Patchers ( ) ) ; var nodes = d 3 . hierarchy ( state Tree , function ( d ) { return d . children ; } ) ; d 3Tree ( nodes ) ; var link = g . select All ( " .link " ) . data ( nodes . descendants ( ) . slice ( 1 ) ) . enter ( ) . append ( "path " ) . attr ( "class " , "link " ) . attr ( "d " , diagonal ) ; var node = g . select All ( " .node " ) . data ( nodes . descendants ( ) ) . enter ( ) . append ( "g " ) . attr ( "class " , function ( d ) { return "node " + ( d . children ? " node - -internal " : " node - -leaf " ) ; } ) . attr ( "transform " , function ( d ) { return "translate ( " + d . y + " , " + d . x + " ) " ; } ) ; node . append ( "circle " ) . attr ( "r " , 2 . 5 ) ; node . append ( "text " ) . attr ( "dy " , function ( d ) { return d . children ? - 1 0 : 0 } ) . attr ( "x " , function ( d ) { return d . children ? - 8 : 8 ; } ) . style ( "text -anchor " , "start " ) . text ( function ( d ) { return d . data . name ; } ) ; } 
function to Hebon ( s ) { var hebon = ' ' ; var last Hebon = ' ' ; var last Char = ' ' ; var i = 0 ; while ( i < s . length ) { var hr = get Hebon ( s , i ) ; if ( hr . c = = ' っ ' ) { 
function to Katakana ( s ) { var res = ' ' ; for ( var i = 0 ; i < s . length ; i + = 1 ) { var cd = s . char Code At ( i ) ; res + = ( min Hira < = cd & & cd < = max Hira ) ? String . from Char Code ( cd - min Hira + min Kata ) : s . char At ( i ) ; } return res ; } 
function to Hiragana ( s ) { var res = ' ' ; for ( var i = 0 ; i < s . length ; i + = 1 ) { var cd = s . char Code At ( i ) ; res + = ( min Kata < = cd & & cd < = max Kata ) ? String . from Char Code ( cd - min Kata + min Hira ) : s . char At ( i ) ; } return res ; } 
function swal _alert ( message , custom Options ) { var options = angular . extend ( { title : 'Alert ' , text : message , type : 'warning ' , show Cancel Button : false } , custom Options ) ; return $q . when ( swal ( options ) ) ; } 
function swal _open ( options ) { var resolve = angular . extend ( { } , options . resolve ) ; angular . for Each ( resolve , function ( value , key ) { resolve [ key ] = angular . is String ( value ) ? $injector . get ( value ) : $injector . invoke ( value , null , null , key ) ; } ) ; return $q . all ( { html : _get Html ( options ) , locals : $q . all ( resolve ) } ) . then ( function ( setup ) { var scope = options . scope , controller = options . controller , controller As Option = options . controller As , pre Confirm = options . pre Confirm ; delete options . html ; delete options . html Template ; delete options . resolve ; delete options . scope ; delete options . controller ; delete options . controller As ; delete options . pre Confirm ; var locals = setup . locals ; options . html = setup . html ; scope = scope ? scope . $new ( ) : $root Scope . $new ( ) ; if ( controller ) { var controller As ; if ( controller As Option & & angular . is String ( controller As Option ) ) { controller As = controller As Option ; } var controller Instance = $controller ( controller , angular . extend ( locals , { $scope : scope } ) , false , controller As ) ; if ( typeof pre Confirm = = = 'string ' ) { options . pre Confirm = function ( ) { return $timeout ( controller Instance [ pre Confirm ] . bind ( controller Instance ) ) ; } ; } } if ( typeof pre Confirm = = = 'function ' ) { options . pre Confirm = function ( ) { return $timeout ( pre Confirm ) ; } ; } var prom = $q . when ( swal ( options ) ) ; var html = document . get Elements By Class Name ( 'swal 2 -modal ' ) [ 0 ] ; 
function swal _base ( arg 1 , arg 2 , arg 3 ) { 
function message ( msg , this Arg ) { var sig = colors . red ( this Arg . name ) ; sig + = ' in plugin ' ; sig + = ' " ' + colors . cyan ( this Arg . plugin ) + ' " ' ; sig + = ' \n ' ; sig + = msg ; return sig ; } 
function set Defaults ( plugin , message , opts ) { if ( typeof plugin = = = 'object ' ) { return defaults ( plugin ) ; } opts = opts | | { } ; if ( message instanceof Error ) { opts . error = message ; } else if ( typeof message = = = 'object ' ) { opts = message ; } else { opts . message = message ; } opts . plugin = plugin ; return defaults ( opts ) ; } 
function to Str _ ( n , min Len ) { const str = n . to String ( 1 6 ) ; return str . length < 2 ? ' 0 ' + str : str ; } 
function Unshort ( options ) { if ( ! ( this instanceof Unshort ) ) return new Unshort ( options ) ; options = options | | { } ; this . _options = merge . all ( [ { timeout : 3 0 * 1 0 0 0 , retries : 1 , follow Redirect : false , 
function split Segments ( polygon ) { if ( typeof polygon ! = = "string " ) { throw new Error ( "Polygon should be a path string " ) ; } var start = null ; var position = null ; var result = [ ] ; var input = polygon ; function strip Whitespace ( ) { polygon = polygon . trim ( ) ; } function read Char Seq ( n ) { var c = polygon . char Code At ( n ) ; while ( c > = 4 8 & & c < = 5 7 ) { n + + ; c = polygon . char Code At ( n ) ; } return n ; } function read Number ( ) { strip Whitespace ( ) ; var start = 0 ; var end = 0 ; if ( polygon [ start ] = = = " , " ) { start + + ; end + + ; } if ( polygon [ start ] = = = " - " ) { end + + ; } end = read Char Seq ( end ) ; if ( polygon [ end ] = = = " . " ) { end + + ; end = read Char Seq ( end ) ; } var s = polygon . substring ( start , end ) ; if ( s ! = = " " ) { var num = to Float ( s ) ; polygon = polygon . substring ( end ) ; if ( polygon . length & & polygon [ 0 ] . to Lower Case ( ) = = = "e " ) { var f = 1 ; var exp End = 0 ; if ( polygon . length > 1 & & polygon [ 1 ] = = = " - " ) { f = - 1 ; exp End = read Char Seq ( 2 ) ; } else { exp End = read Char Seq ( 1 ) ; } var exp = to Float ( polygon . substring ( 1 , exp End ) ) ; if ( math Abs ( exp ) > 0 ) { num * = math Pow ( 1 0 , exp ) ; } polygon = polygon . substring ( exp End ) ; } return num ; } else { throw new Error ( "Expected number : " + polygon ) ; } } function read Numbers ( n , fn ) { strip Whitespace ( ) ; var index = 0 ; var c = polygon . char Code At ( 0 ) ; while ( ( c > = 4 8 & & c < = 5 7 ) | | c = = = 4 4 | | c = = = 4 5 ) { var numbers = [ ] ; for ( var i = 0 ; i < n ; i + + ) { numbers . push ( read Number ( ) ) ; } fn ( numbers , index ) ; strip Whitespace ( ) ; c = polygon . char Code At ( 0 ) ; index + + ; } } function read Coords ( n , fn ) { read Numbers ( n * 2 , function ( numbers , index ) { var coords = [ ] ; for ( var i = 0 ; i < n ; i + + ) { coords . push ( numbers . splice ( 0 , 2 ) ) ; } fn ( coords , index ) ; } ) ; } function push Type ( item Type , offset ) { return function ( c ) { if ( offset ) { c = c . map ( function ( c ) { return [ x ( c ) + x ( offset ) , y ( c ) + y ( offset ) ] ; } ) ; } c . unshift ( position ) ; result . push ( { type : item Type , coords : c , } ) ; position = c [ c . length - 1 ] ; } ; } function calculate Cubic Control Points ( coords ) { return [ coords [ 0 ] , [ x ( coords [ 0 ] ) + 2 . 0 / 3 . 0 * ( x ( coords [ 1 ] ) - x ( coords [ 0 ] ) ) , y ( coords [ 0 ] ) + 2 . 0 / 3 . 0 * ( y ( coords [ 1 ] ) - y ( coords [ 0 ] ) ) , ] , [ x ( coords [ 2 ] ) + 2 . 0 / 3 . 0 * ( x ( coords [ 1 ] ) - x ( coords [ 2 ] ) ) , y ( coords [ 2 ] ) + 2 . 0 / 3 . 0 * ( y ( coords [ 1 ] ) - y ( coords [ 2 ] ) ) , ] , coords [ 2 ] , ] ; } function calculate Bezier Control Point ( ) { var last Bezier = result [ result . length - 1 ] ; var control Point = null ; if ( ! last Bezier | | last Bezier . type ! = = bezier 3Type ) { control Point = position ; } else { 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _is Placeholder = _ _webpack _require _ _ ( 3 6 ) ; function _curry 2 ( fn ) { return function f 2 ( a , b ) { switch ( arguments . length ) { case 0 : return f 2 ; case 1 : return _is Placeholder ( a ) ? f 2 : _curry 1 ( function ( _b ) { return fn ( a , _b ) ; } ) ; default : return _is Placeholder ( a ) & & _is Placeholder ( b ) ? f 2 : _is Placeholder ( a ) ? _curry 1 ( function ( _a ) { return fn ( _a , b ) ; } ) : _is Placeholder ( b ) ? _curry 1 ( function ( _b ) { return fn ( a , _b ) ; } ) : fn ( a , b ) ; } } ; } module . exports = _curry 2 ; } 
function _curry 2 ( fn ) { return function f 2 ( a , b ) { switch ( arguments . length ) { case 0 : return f 2 ; case 1 : return _is Placeholder ( a ) ? f 2 : _curry 1 ( function ( _b ) { return fn ( a , _b ) ; } ) ; default : return _is Placeholder ( a ) & & _is Placeholder ( b ) ? f 2 : _is Placeholder ( a ) ? _curry 1 ( function ( _a ) { return fn ( _a , b ) ; } ) : _is Placeholder ( b ) ? _curry 1 ( function ( _b ) { return fn ( a , _b ) ; } ) : fn ( a , b ) ; } } ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _is Placeholder = _ _webpack _require _ _ ( 3 6 ) ; function _curry 1 ( fn ) { return function f 1 ( a ) { if ( arguments . length = = = 0 | | _is Placeholder ( a ) ) { return f 1 ; } else { return fn . apply ( this , arguments ) ; } } ; } module . exports = _curry 1 ; } 
function _curry 1 ( fn ) { return function f 1 ( a ) { if ( arguments . length = = = 0 | | _is Placeholder ( a ) ) { return f 1 ; } else { return fn . apply ( this , arguments ) ; } } ; } 
function _dispatchable ( method Names , xf , fn ) { return function ( ) { if ( arguments . length = = = 0 ) { return fn ( ) ; } var args = Array . prototype . slice . call ( arguments , 0 ) ; var obj = args . pop ( ) ; if ( ! _is Array ( obj ) ) { var idx = 0 ; while ( idx < method Names . length ) { if ( typeof obj [ method Names [ idx ] ] = = = 'function ' ) { return obj [ method Names [ idx ] ] . apply ( obj , args ) ; } idx + = 1 ; } if ( _is Transformer ( obj ) ) { var transducer = xf . apply ( null , args ) ; return transducer ( obj ) ; } } return fn . apply ( this , arguments ) ; } ; } 
function ( module , exports ) { module . exports = { init : function ( ) { return this . xf [ ' @ @transducer /init ' ] ( ) ; } , result : function ( result ) { return this . xf [ ' @ @transducer /result ' ] ( result ) ; } } ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _arity = _ _webpack _require _ _ ( 1 4 ) ; var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _curry N = _ _webpack _require _ _ ( 3 3 ) ; var curry N = _curry 2 ( function curry N ( length , fn ) { if ( length = = = 1 ) { return _curry 1 ( fn ) ; } return _arity ( length , _curry N ( length , [ ] , fn ) ) ; } ) ; module . exports = curry N ; } 
function ( module , exports ) { function _has ( prop , obj ) { return Object . prototype . has Own Property . call ( obj , prop ) ; } module . exports = _has ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _map = _ _webpack _require _ _ ( 3 7 ) ; var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var _xmap = _ _webpack _require _ _ ( 3 4 4 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var keys = _ _webpack _require _ _ ( 1 5 ) ; var map = _curry 2 ( _dispatchable ( [ 'fantasy -land /map ' , 'map ' ] , _xmap , function map ( fn , functor ) { switch ( Object . prototype . to String . call ( functor ) ) { case ' [object Function ] ' : return curry N ( functor . length , function ( ) { return fn . call ( this , functor . apply ( this , arguments ) ) ; } ) ; case ' [object Object ] ' : return _reduce ( function ( acc , key ) { acc [ key ] = fn ( functor [ key ] ) ; return acc ; } , { } , keys ( functor ) ) ; default : return _map ( fn , functor ) ; } } ) ) ; module . exports = map ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _equals = _ _webpack _require _ _ ( 3 1 9 ) ; var equals = _curry 2 ( function equals ( a , b ) { return _equals ( a , b , [ ] , [ ] ) ; } ) ; module . exports = equals ; } 
function ( module , exports ) { function _concat ( set 1 , set 2 ) { set 1 = set 1 | | [ ] ; set 2 = set 2 | | [ ] ; var idx ; var len 1 = set 1 . length ; var len 2 = set 2 . length ; var result = [ ] ; idx = 0 ; while ( idx < len 1 ) { result [ result . length ] = set 1 [ idx ] ; idx + = 1 ; } idx = 0 ; while ( idx < len 2 ) { result [ result . length ] = set 2 [ idx ] ; idx + = 1 ; } return result ; } module . exports = _concat ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _check For Method = _ _webpack _require _ _ ( 2 3 ) ; var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var slice = _curry 3 ( _check For Method ( 'slice ' , function slice ( from Index , to Index , list ) { return Array . prototype . slice . call ( list , from Index , to Index ) ; } ) ) ; module . exports = slice ; } 
function ( module , exports ) { function _arity ( n , fn ) { switch ( n ) { case 0 : return function ( ) { return fn . apply ( this , arguments ) ; } ; case 1 : return function ( a 0 ) { return fn . apply ( this , arguments ) ; } ; case 2 : return function ( a 0 , a 1 ) { return fn . apply ( this , arguments ) ; } ; case 3 : return function ( a 0 , a 1 , a 2 ) { return fn . apply ( this , arguments ) ; } ; case 4 : return function ( a 0 , a 1 , a 2 , a 3 ) { return fn . apply ( this , arguments ) ; } ; case 5 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 ) { return fn . apply ( this , arguments ) ; } ; case 6 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 , a 5 ) { return fn . apply ( this , arguments ) ; } ; case 7 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 ) { return fn . apply ( this , arguments ) ; } ; case 8 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 , a 7 ) { return fn . apply ( this , arguments ) ; } ; case 9 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 , a 7 , a 8 ) { return fn . apply ( this , arguments ) ; } ; case 1 0 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 , a 7 , a 8 , a 9 ) { return fn . apply ( this , arguments ) ; } ; default : throw new Error ( 'First argument to _arity must be a non -negative integer no greater than ten ' ) ; } } module . exports = _arity ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var _is Arguments = _ _webpack _require _ _ ( 2 0 8 ) ; * Returns a list containing the names of all the enumerable own properties of * the supplied object . * Note that the order of the output array is not guaranteed to be consistent * across different JS platforms . * * @func * @member Of R * @since v 0 . 1 . 0 * @category Object * @sig {k : v } - > [k ] * @param {Object } obj The object to extract properties from * @return {Array } An array of the object 's own properties . * @see R .keys In , R .values * @example * * R .keys ( {a : 1 , b : 2 , c : 3 } ) ; / / = > [ 'a ' , 'b ' , 'c ' ] * / var _keys = typeof Object . keys = = = 'function ' & & ! has Args Enum Bug ? function keys ( obj ) { return Object ( obj ) ! = = obj ? [ ] : Object . keys ( obj ) ; } : function keys ( obj ) { if ( Object ( obj ) ! = = obj ) { return [ ] ; } var prop , n Idx ; var ks = [ ] ; var check Args Length = has Args Enum Bug & & _is Arguments ( obj ) ; for ( prop in obj ) { if ( _has ( prop , obj ) & & ( ! check Args Length | | prop ! = = 'length ' ) ) { ks [ ks . length ] = prop ; } } if ( has Enum Bug ) { n Idx = non Enumerable Props . length - 1 ; while ( n Idx > = 0 ) { prop = non Enumerable Props [ n Idx ] ; if ( _has ( prop , obj ) & & ! contains ( ks , prop ) ) { ks [ ks . length ] = prop ; } n Idx - = 1 ; } } return ks ; } ; var keys = _curry 1 ( _keys ) ; module . exports = keys ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var reduce = _curry 3 ( _reduce ) ; module . exports = reduce ; } 
function ( module , exports ) { module . exports = Array . is Array | | function _is Array ( val ) { return val ! = null & & val . length > = 0 & & Object . prototype . to String . call ( val ) = = = ' [object Array ] ' ; } ; } 
function ( module , exports ) { function _reduced ( x ) { return x & & x [ ' @ @transducer /reduced ' ] ? x : { ' @ @transducer /value ' : x , ' @ @transducer /reduced ' : true } ; } module . exports = _reduced ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var always = _curry 1 ( function always ( val ) { return function ( ) { return val ; } ; } ) ; module . exports = always ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _index Of = _ _webpack _require _ _ ( 2 0 7 ) ; function _contains ( a , list ) { return _index Of ( list , a , 0 ) > = 0 ; } module . exports = _contains ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var max = _curry 2 ( function max ( a , b ) { return b > a ? b : a ; } ) ; module . exports = max ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var path = _curry 2 ( function path ( paths , obj ) { var val = obj ; var idx = 0 ; while ( idx < paths . length ) { if ( val = = null ) { return ; } val = val [ paths [ idx ] ] ; idx + = 1 ; } return val ; } ) ; module . exports = path ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _is Array = _ _webpack _require _ _ ( 1 7 ) ; function _check For Method ( methodname , fn ) { return function ( ) { var length = arguments . length ; if ( length = = = 0 ) { return fn ( ) ; } var obj = arguments [ length - 1 ] ; return _is Array ( obj ) | | typeof obj [ methodname ] ! = = 'function ' ? fn . apply ( this , arguments ) : obj [ methodname ] . apply ( obj , Array . prototype . slice . call ( arguments , 0 , length - 1 ) ) ; } ; } module . exports = _check For Method ; } 
function ( module , exports ) { function _is String ( x ) { return Object . prototype . to String . call ( x ) = = = ' [object String ] ' ; } module . exports = _is String ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _is Function = _ _webpack _require _ _ ( 3 5 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var to String = _ _webpack _require _ _ ( 2 8 ) ; var invoker = _curry 2 ( function invoker ( arity , method ) { return curry N ( arity + 1 , function ( ) { var target = arguments [ arity ] ; if ( target ! = null & & _is Function ( target [ method ] ) ) { return target [ method ] . apply ( target , Array . prototype . slice . call ( arguments , 0 , arity ) ) ; } throw new Type Error ( to String ( target ) + ' does not have a method named " ' + method + ' " ' ) ; } ) ; } ) ; module . exports = invoker ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _is String = _ _webpack _require _ _ ( 2 4 ) ; var nth = _curry 2 ( function nth ( offset , list ) { var idx = offset < 0 ? list . length + offset : offset ; return _is String ( list ) ? list . char At ( idx ) : list [ idx ] ; } ) ; module . exports = nth ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var map = _ _webpack _require _ _ ( 9 ) ; var prop = _ _webpack _require _ _ ( 6 0 ) ; var pluck = _curry 2 ( function pluck ( p , list ) { return map ( prop ( p ) , list ) ; } ) ; module . exports = pluck ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _to String = _ _webpack _require _ _ ( 3 3 1 ) ; var to String = _curry 1 ( function to String ( val ) { return _to String ( val , [ ] ) ; } ) ; module . exports = to String ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var add = _curry 2 ( function add ( a , b ) { return Number ( a ) + Number ( b ) ; } ) ; module . exports = add ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var assoc = _curry 3 ( function assoc ( prop , val , obj ) { var result = { } ; for ( var p in obj ) { result [ p ] = obj [ p ] ; } result [ prop ] = val ; return result ; } ) ; module . exports = assoc ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var flip = _curry 1 ( function flip ( fn ) { return curry N ( fn . length , function ( a , b ) { var args = Array . prototype . slice . call ( arguments , 0 ) ; args [ 0 ] = b ; args [ 1 ] = a ; return fn . apply ( this , args ) ; } ) ; } ) ; module . exports = flip ; } 
function ( module , exports ) { function _contains With ( pred , x , list ) { var idx = 0 ; var len = list . length ; while ( idx < len ) { if ( pred ( x , list [ idx ] ) ) { return true ; } idx + = 1 ; } return false ; } module . exports = _contains With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _is Array = _ _webpack _require _ _ ( 1 7 ) ; var _is String = _ _webpack _require _ _ ( 2 4 ) ; var _is Array Like = _curry 1 ( function is Array Like ( x ) { if ( _is Array ( x ) ) { return true ; } if ( ! x ) { return false ; } if ( typeof x ! = = 'object ' ) { return false ; } if ( _is String ( x ) ) { return false ; } if ( x . node Type = = = 1 ) { return ! ! x . length ; } if ( x . length = = = 0 ) { return true ; } if ( x . length > 0 ) { return x . has Own Property ( 0 ) & & x . has Own Property ( x . length - 1 ) ; } return false ; } ) ; module . exports = _is Array Like ; } 
function ( module , exports ) { function _is Function ( x ) { return Object . prototype . to String . call ( x ) = = = ' [object Function ] ' ; } module . exports = _is Function ; } 
function ( module , exports ) { function _is Placeholder ( a ) { return a ! = null & & typeof a = = = 'object ' & & a [ ' @ @functional /placeholder ' ] = = = true ; } module . exports = _is Placeholder ; } 
function ( module , exports ) { function _map ( fn , functor ) { var idx = 0 ; var len = functor . length ; var result = Array ( len ) ; while ( idx < len ) { result [ idx ] = fn ( functor [ idx ] ) ; idx + = 1 ; } return result ; } module . exports = _map ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var map = _ _webpack _require _ _ ( 9 ) ; var lens = _curry 2 ( function lens ( getter , setter ) { return function ( to Functor Fn ) { return function ( target ) { return map ( function ( focus ) { return setter ( focus , target ) ; } , to Functor Fn ( getter ( target ) ) ) ; } ; } ; } ) ; module . exports = lens ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var lift N = _ _webpack _require _ _ ( 2 1 9 ) ; var lift = _curry 1 ( function lift ( fn ) { return lift N ( fn . length , fn ) ; } ) ; module . exports = lift ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var _is Object = _ _webpack _require _ _ ( 5 7 ) ; var merge With Key = _ _webpack _require _ _ ( 5 9 ) ; var merge Deep With Key = _curry 3 ( function merge Deep With Key ( fn , l Obj , r Obj ) { return merge With Key ( function ( k , l Val , r Val ) { if ( _is Object ( l Val ) & & _is Object ( r Val ) ) { return merge Deep With Key ( fn , l Val , r Val ) ; } else { return fn ( k , l Val , r Val ) ; } } , l Obj , r Obj ) ; } ) ; module . exports = merge Deep With Key ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var n Ary = _curry 2 ( function n Ary ( n , fn ) { switch ( n ) { case 0 : return function ( ) { return fn . call ( this ) ; } ; case 1 : return function ( a 0 ) { return fn . call ( this , a 0 ) ; } ; case 2 : return function ( a 0 , a 1 ) { return fn . call ( this , a 0 , a 1 ) ; } ; case 3 : return function ( a 0 , a 1 , a 2 ) { return fn . call ( this , a 0 , a 1 , a 2 ) ; } ; case 4 : return function ( a 0 , a 1 , a 2 , a 3 ) { return fn . call ( this , a 0 , a 1 , a 2 , a 3 ) ; } ; case 5 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 ) { return fn . call ( this , a 0 , a 1 , a 2 , a 3 , a 4 ) ; } ; case 6 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 , a 5 ) { return fn . call ( this , a 0 , a 1 , a 2 , a 3 , a 4 , a 5 ) ; } ; case 7 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 ) { return fn . call ( this , a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 ) ; } ; case 8 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 , a 7 ) { return fn . call ( this , a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 , a 7 ) ; } ; case 9 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 , a 7 , a 8 ) { return fn . call ( this , a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 , a 7 , a 8 ) ; } ; case 1 0 : return function ( a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 , a 7 , a 8 , a 9 ) { return fn . call ( this , a 0 , a 1 , a 2 , a 3 , a 4 , a 5 , a 6 , a 7 , a 8 , a 9 ) ; } ; default : throw new Error ( 'First argument to n Ary must be a non -negative integer no greater than ten ' ) ; } } ) ; module . exports = n Ary ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry N = _ _webpack _require _ _ ( 3 3 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var _xreduce By = _ _webpack _require _ _ ( 3 4 5 ) ; var reduce By = _curry N ( 4 , [ ] , _dispatchable ( [ ] , _xreduce By , function reduce By ( value Fn , value Acc , key Fn , list ) { return _reduce ( function ( acc , elt ) { var key = key Fn ( elt ) ; acc [ key ] = value Fn ( _has ( key , acc ) ? acc [ key ] : value Acc , elt ) ; return acc ; } , { } , list ) ; } ) ) ; module . exports = reduce By ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _complement = _ _webpack _require _ _ ( 2 0 5 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var filter = _ _webpack _require _ _ ( 5 1 ) ; var reject = _curry 2 ( function reject ( pred , filterable ) { return filter ( _complement ( pred ) , filterable ) ; } ) ; module . exports = reject ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _is String = _ _webpack _require _ _ ( 2 4 ) ; var reverse = _curry 1 ( function reverse ( list ) { return _is String ( list ) ? list . split ( ' ' ) . reverse ( ) . join ( ' ' ) : Array . prototype . slice . call ( list , 0 ) . reverse ( ) ; } ) ; module . exports = reverse ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _concat = _ _webpack _require _ _ ( 1 2 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var map = _ _webpack _require _ _ ( 9 ) ; var ap = _curry 2 ( function ap ( apply F , apply X ) { return typeof apply X [ 'fantasy -land /ap ' ] = = = 'function ' ? apply X [ 'fantasy -land /ap ' ] ( apply F ) : typeof apply F . ap = = = 'function ' ? apply F . ap ( apply X ) : typeof apply F = = = 'function ' ? function ( x ) { return apply F ( x ) ( apply X ( x ) ) ; } : 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _make Flat = _ _webpack _require _ _ ( 2 1 0 ) ; var _xchain = _ _webpack _require _ _ ( 3 3 4 ) ; var map = _ _webpack _require _ _ ( 9 ) ; var chain = _curry 2 ( _dispatchable ( [ 'fantasy -land /chain ' , 'chain ' ] , _xchain , function chain ( fn , monad ) { if ( typeof monad = = = 'function ' ) { return function ( x ) { return fn ( monad ( x ) ) ( x ) ; } ; } return _make Flat ( false ) ( map ( fn , monad ) ) ; } ) ) ; module . exports = chain ; } 
function ( module , exports , _ _webpack _require _ _ ) { var pipe = _ _webpack _require _ _ ( 2 2 8 ) ; var reverse = _ _webpack _require _ _ ( 4 4 ) ; function compose ( ) { if ( arguments . length = = = 0 ) { throw new Error ( 'compose requires at least one argument ' ) ; } return pipe . apply ( this , reverse ( arguments ) ) ; } module . exports = compose ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _is Array = _ _webpack _require _ _ ( 1 7 ) ; var _is Function = _ _webpack _require _ _ ( 3 5 ) ; var _is String = _ _webpack _require _ _ ( 2 4 ) ; var to String = _ _webpack _require _ _ ( 2 8 ) ; var concat = _curry 2 ( function concat ( a , b ) { if ( _is Array ( a ) ) { if ( _is Array ( b ) ) { return a . concat ( b ) ; } throw new Type Error ( to String ( b ) + ' is not an array ' ) ; } if ( _is String ( a ) ) { if ( _is String ( b ) ) { return a + b ; } throw new Type Error ( to String ( b ) + ' is not a string ' ) ; } if ( a ! = null & & _is Function ( a [ 'fantasy -land /concat ' ] ) ) { return a [ 'fantasy -land /concat ' ] ( b ) ; } if ( a ! = null & & _is Function ( a . concat ) ) { return a . concat ( b ) ; } throw new Type Error ( to String ( a ) + ' does not have a method named "concat " or "fantasy -land /concat " ' ) ; } ) ; module . exports = concat ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var curry = _curry 1 ( function curry ( fn ) { return curry N ( fn . length , fn ) ; } ) ; module . exports = curry ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _filter = _ _webpack _require _ _ ( 5 4 ) ; var _is Object = _ _webpack _require _ _ ( 5 7 ) ; var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var _xfilter = _ _webpack _require _ _ ( 3 3 9 ) ; var keys = _ _webpack _require _ _ ( 1 5 ) ; var filter = _curry 2 ( _dispatchable ( [ 'filter ' ] , _xfilter , function ( pred , filterable ) { return _is Object ( filterable ) ? _reduce ( function ( acc , key ) { if ( pred ( filterable [ key ] ) ) { acc [ key ] = filterable [ key ] ; } return acc ; } , { } , keys ( filterable ) ) : 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _identity = _ _webpack _require _ _ ( 5 5 ) ; var identity = _curry 1 ( _identity ) ; module . exports = identity ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _object Assign = _ _webpack _require _ _ ( 3 2 4 ) ; module . exports = typeof Object . assign = = = 'function ' ? Object . assign : _object Assign ; } 
function ( module , exports ) { function _filter ( fn , list ) { var idx = 0 ; var len = list . length ; var result = [ ] ; while ( idx < len ) { if ( fn ( list [ idx ] ) ) { result [ result . length ] = list [ idx ] ; } idx + = 1 ; } return result ; } module . exports = _filter ; } 
function ( module , exports ) { module . exports = Number . is Integer | | function _is Integer ( n ) { return n < < 0 = = = n ; } ; } 
function ( module , exports ) { function _is Object ( x ) { return Object . prototype . to String . call ( x ) = = = ' [object Object ] ' ; } module . exports = _is Object ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var merge With Key = _curry 3 ( function merge With Key ( fn , l , r ) { var result = { } ; var k ; for ( k in l ) { if ( _has ( k , l ) ) { result [ k ] = _has ( k , r ) ? fn ( k , l [ k ] , r [ k ] ) : l [ k ] ; } } for ( k in r ) { if ( _has ( k , r ) & & ! _has ( k , result ) ) { result [ k ] = r [ k ] ; } } return result ; } ) ; module . exports = merge With Key ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var path = _ _webpack _require _ _ ( 2 2 ) ; var prop = _curry 2 ( function prop ( p , obj ) { return path ( [ p ] , obj ) ; } ) ; module . exports = prop ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _check For Method = _ _webpack _require _ _ ( 2 3 ) ; var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var slice = _ _webpack _require _ _ ( 1 3 ) ; var tail = _curry 1 ( _check For Method ( 'tail ' , slice ( 1 , Infinity ) ) ) ; module . exports = tail ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xtake = _ _webpack _require _ _ ( 3 4 6 ) ; var slice = _ _webpack _require _ _ ( 1 3 ) ; var take = _curry 2 ( _dispatchable ( [ 'take ' ] , _xtake , function take ( n , xs ) { return slice ( 0 , n < 0 ? Infinity : n , xs ) ; } ) ) ; module . exports = take ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var type = _curry 1 ( function type ( val ) { return val = = = null ? 'Null ' : val = = = undefined ? 'Undefined ' : Object . prototype . to String . call ( val ) . slice ( 8 , - 1 ) ; } ) ; module . exports = type ; } 
function ( module , exports , _ _webpack _require _ _ ) { var identity = _ _webpack _require _ _ ( 5 2 ) ; var uniq By = _ _webpack _require _ _ ( 2 3 7 ) ; var uniq = uniq By ( identity ) ; module . exports = uniq ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var adjust = _ _webpack _require _ _ ( 1 8 6 ) ; var always = _ _webpack _require _ _ ( 1 9 ) ; var update = _curry 3 ( function update ( idx , x , list ) { return adjust ( always ( x ) , idx , list ) ; } ) ; module . exports = update ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var empty Object = { } ; if ( false ) { Object . freeze ( empty Object ) ; } module . exports = empty Object ; } 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { * @param without Suffix boolean true = a length of time ; false = before /after a period of time . * / function format ( forms , number , without Suffix ) { if ( without Suffix ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { 
function ( module , exports , _ _webpack _require _ _ ) { var _concat = _ _webpack _require _ _ ( 1 2 ) ; var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var adjust = _curry 3 ( function adjust ( fn , idx , list ) { if ( idx > = list . length | | idx < - list . length ) { return list ; } var start = idx < 0 ? list . length : 0 ; var _idx = start + idx ; var _list = _concat ( list ) ; _list [ _idx ] = fn ( list [ _idx ] ) ; return _list ; } ) ; module . exports = adjust ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var and = _curry 2 ( function and ( a , b ) { return a & & b ; } ) ; module . exports = and ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xany = _ _webpack _require _ _ ( 2 1 1 ) ; var any = _curry 2 ( _dispatchable ( [ 'any ' ] , _xany , function any ( fn , list ) { var idx = 0 ; while ( idx < list . length ) { if ( fn ( list [ idx ] ) ) { return true ; } idx + = 1 ; } return false ; } ) ) ; module . exports = any ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var apply = _curry 2 ( function apply ( fn , args ) { return fn . apply ( this , args ) ; } ) ; module . exports = apply ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var _is Array = _ _webpack _require _ _ ( 1 7 ) ; var _is Integer = _ _webpack _require _ _ ( 5 6 ) ; var assoc = _ _webpack _require _ _ ( 3 0 ) ; var is Nil = _ _webpack _require _ _ ( 2 1 5 ) ; var assoc Path = _curry 3 ( function assoc Path ( path , val , obj ) { if ( path . length = = = 0 ) { return val ; } var idx = path [ 0 ] ; if ( path . length > 1 ) { var next Obj = ! is Nil ( obj ) & & _has ( idx , obj ) ? obj [ idx ] : _is Integer ( path [ 1 ] ) ? [ ] : { } ; val = assoc Path ( Array . prototype . slice . call ( path , 1 ) , val , next Obj ) ; } if ( _is Integer ( idx ) & & _is Array ( obj ) ) { var arr = [ ] . concat ( obj ) ; arr [ idx ] = val ; return arr ; } else { return assoc ( idx , val , obj ) ; } } ) ; module . exports = assoc Path ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _arity = _ _webpack _require _ _ ( 1 4 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var bind = _curry 2 ( function bind ( fn , this Obj ) { return _arity ( fn . length , function ( ) { return fn . apply ( this Obj , arguments ) ; } ) ; } ) ; module . exports = bind ; } 
function ( module , exports , _ _webpack _require _ _ ) { var chain = _ _webpack _require _ _ ( 4 7 ) ; var compose = _ _webpack _require _ _ ( 4 8 ) ; var map = _ _webpack _require _ _ ( 9 ) ; function compose K ( ) { if ( arguments . length = = = 0 ) { throw new Error ( 'compose K requires at least one argument ' ) ; } var init = Array . prototype . slice . call ( arguments ) ; var last = init . pop ( ) ; return compose ( compose . apply ( this , map ( chain , init ) ) , last ) ; } module . exports = compose K ; } 
function compose K ( ) { if ( arguments . length = = = 0 ) { throw new Error ( 'compose K requires at least one argument ' ) ; } var init = Array . prototype . slice . call ( arguments ) ; var last = init . pop ( ) ; return compose ( compose . apply ( this , map ( chain , init ) ) , last ) ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var curry = _ _webpack _require _ _ ( 5 0 ) ; var n Ary = _ _webpack _require _ _ ( 4 1 ) ; var construct N = _curry 2 ( function construct N ( n , Fn ) { if ( n > 1 0 ) { throw new Error ( 'Constructor with greater than ten arguments ' ) ; } if ( n = = = 0 ) { return function ( ) { return new Fn ( ) ; } ; } return curry ( n Ary ( n , function ( $ 0 , $ 1 , $ 2 , $ 3 , $ 4 , $ 5 , $ 6 , $ 7 , $ 8 , $ 9 ) { switch ( arguments . length ) { case 1 : return new Fn ( $ 0 ) ; case 2 : return new Fn ( $ 0 , $ 1 ) ; case 3 : return new Fn ( $ 0 , $ 1 , $ 2 ) ; case 4 : return new Fn ( $ 0 , $ 1 , $ 2 , $ 3 ) ; case 5 : return new Fn ( $ 0 , $ 1 , $ 2 , $ 3 , $ 4 ) ; case 6 : return new Fn ( $ 0 , $ 1 , $ 2 , $ 3 , $ 4 , $ 5 ) ; case 7 : return new Fn ( $ 0 , $ 1 , $ 2 , $ 3 , $ 4 , $ 5 , $ 6 ) ; case 8 : return new Fn ( $ 0 , $ 1 , $ 2 , $ 3 , $ 4 , $ 5 , $ 6 , $ 7 ) ; case 9 : return new Fn ( $ 0 , $ 1 , $ 2 , $ 3 , $ 4 , $ 5 , $ 6 , $ 7 , $ 8 ) ; case 1 0 : return new Fn ( $ 0 , $ 1 , $ 2 , $ 3 , $ 4 , $ 5 , $ 6 , $ 7 , $ 8 , $ 9 ) ; } } ) ) ; } ) ; module . exports = construct N ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _map = _ _webpack _require _ _ ( 3 7 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var max = _ _webpack _require _ _ ( 2 1 ) ; var pluck = _ _webpack _require _ _ ( 2 7 ) ; var reduce = _ _webpack _require _ _ ( 1 6 ) ; var converge = _curry 2 ( function converge ( after , fns ) { return curry N ( reduce ( max , 0 , pluck ( 'length ' , fns ) ) , function ( ) { var args = arguments ; var context = this ; return after . apply ( context , _map ( function ( fn ) { return fn . apply ( context , args ) ; } , fns ) ) ; } ) ; } ) ; module . exports = converge ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var default To = _curry 2 ( function default To ( d , v ) { return v = = null | | v ! = = v ? d : v ; } ) ; module . exports = default To ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _contains = _ _webpack _require _ _ ( 2 0 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var difference = _curry 2 ( function difference ( first , second ) { var out = [ ] ; var idx = 0 ; var first Len = first . length ; while ( idx < first Len ) { if ( ! _contains ( first [ idx ] , second ) & & ! _contains ( first [ idx ] , out ) ) { out [ out . length ] = first [ idx ] ; } idx + = 1 ; } return out ; } ) ; module . exports = difference ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _contains With = _ _webpack _require _ _ ( 3 2 ) ; var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var difference With = _curry 3 ( function difference With ( pred , first , second ) { var out = [ ] ; var idx = 0 ; var first Len = first . length ; while ( idx < first Len ) { if ( ! _contains With ( pred , first [ idx ] , second ) & & ! _contains With ( pred , first [ idx ] , out ) ) { out . push ( first [ idx ] ) ; } idx + = 1 ; } return out ; } ) ; module . exports = difference With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var dissoc = _curry 2 ( function dissoc ( prop , obj ) { var result = { } ; for ( var p in obj ) { result [ p ] = obj [ p ] ; } delete result [ prop ] ; return result ; } ) ; module . exports = dissoc ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xdrop = _ _webpack _require _ _ ( 3 3 5 ) ; var slice = _ _webpack _require _ _ ( 1 3 ) ; var drop = _curry 2 ( _dispatchable ( [ 'drop ' ] , _xdrop , function drop ( n , xs ) { return slice ( Math . max ( 0 , n ) , Infinity , xs ) ; } ) ) ; module . exports = drop ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xdrop Repeats With = _ _webpack _require _ _ ( 2 1 2 ) ; var last = _ _webpack _require _ _ ( 2 1 7 ) ; var drop Repeats With = _curry 2 ( _dispatchable ( [ ] , _xdrop Repeats With , function drop Repeats With ( pred , list ) { var result = [ ] ; var idx = 1 ; var len = list . length ; if ( len ! = = 0 ) { result [ 0 ] = list [ 0 ] ; while ( idx < len ) { if ( ! pred ( last ( result ) , list [ idx ] ) ) { result [ result . length ] = list [ idx ] ; } idx + = 1 ; } } return result ; } ) ) ; module . exports = drop Repeats With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _is Arguments = _ _webpack _require _ _ ( 2 0 8 ) ; var _is Array = _ _webpack _require _ _ ( 1 7 ) ; var _is Object = _ _webpack _require _ _ ( 5 7 ) ; var _is String = _ _webpack _require _ _ ( 2 4 ) ; var empty = _curry 1 ( function empty ( x ) { return x ! = null & & typeof x [ 'fantasy -land /empty ' ] = = = 'function ' ? x [ 'fantasy -land /empty ' ] ( ) : x ! = null & & x . constructor ! = null & & typeof x . constructor [ 'fantasy -land /empty ' ] = = = 'function ' ? x . constructor [ 'fantasy -land /empty ' ] ( ) : x ! = null & & typeof x . empty = = = 'function ' ? x . empty ( ) : x ! = null & & x . constructor ! = null & & typeof x . constructor . empty = = = 'function ' ? x . constructor . empty ( ) : _is Array ( x ) ? [ ] : _is String ( x ) ? ' ' : _is Object ( x ) ? { } : _is Arguments ( x ) ? function ( ) { return arguments ; } ( ) : 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var identical = _curry 2 ( function identical ( a , b ) { 
function _clone ( value , ref From , ref To , deep ) { var copy = function copy ( copied Value ) { var len = ref From . length ; var idx = 0 ; while ( idx < len ) { if ( value = = = ref From [ idx ] ) { return ref To [ idx ] ; } idx + = 1 ; } ref From [ idx + 1 ] = value ; ref To [ idx + 1 ] = copied Value ; for ( var key in value ) { copied Value [ key ] = deep ? _clone ( value [ key ] , ref From , ref To , true ) : value [ key ] ; } return copied Value ; } ; switch ( type ( value ) ) { case 'Object ' : return copy ( { } ) ; case 'Array ' : return copy ( [ ] ) ; case 'Date ' : return new Date ( value . value Of ( ) ) ; case 'Reg Exp ' : return _clone Reg Exp ( value ) ; default : return value ; } } 
function ( module , exports ) { function _clone Reg Exp ( pattern ) { return new Reg Exp ( pattern . source , ( pattern . global ? 'g ' : ' ' ) + ( pattern . ignore Case ? 'i ' : ' ' ) + ( pattern . multiline ? 'm ' : ' ' ) + ( pattern . sticky ? 'y ' : ' ' ) + ( pattern . unicode ? 'u ' : ' ' ) ) ; } module . exports = _clone Reg Exp ; } 
function ( module , exports ) { function _complement ( f ) { return function ( ) { return ! f . apply ( this , arguments ) ; } ; } module . exports = _complement ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _arity = _ _webpack _require _ _ ( 1 4 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; function _create Partial Applicator ( concat ) { return _curry 2 ( function ( fn , args ) { return _arity ( Math . max ( 0 , fn . length - args . length ) , function ( ) { return fn . apply ( this , concat ( args , arguments ) ) ; } ) ; } ) ; } module . exports = _create Partial Applicator ; } 
function ( module , exports , _ _webpack _require _ _ ) { var equals = _ _webpack _require _ _ ( 1 0 ) ; function _index Of ( list , a , idx ) { var inf , item ; 
function ( module , exports , _ _webpack _require _ _ ) { var _has = _ _webpack _require _ _ ( 8 ) ; var to String = Object . prototype . to String ; var _is Arguments = function ( ) { return to String . call ( arguments ) = = = ' [object Arguments ] ' ? function _is Arguments ( x ) { return to String . call ( x ) = = = ' [object Arguments ] ' ; } : function _is Arguments ( x ) { return _has ( 'callee ' , x ) ; } ; } ; module . exports = _is Arguments ; } 
function ( module , exports ) { function _is Number ( x ) { return Object . prototype . to String . call ( x ) = = = ' [object Number ] ' ; } module . exports = _is Number ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _is Array Like = _ _webpack _require _ _ ( 3 4 ) ; function _make Flat ( recursive ) { return function flatt ( list ) { var value , jlen , j ; var result = [ ] ; var idx = 0 ; var ilen = list . length ; while ( idx < ilen ) { if ( _is Array Like ( list [ idx ] ) ) { value = recursive ? flatt ( list [ idx ] ) : list [ idx ] ; j = 0 ; jlen = value . length ; while ( j < jlen ) { result [ result . length ] = value [ j ] ; j + = 1 ; } } else { result [ result . length ] = list [ idx ] ; } idx + = 1 ; } return result ; } ; } module . exports = _make Flat ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _reduced = _ _webpack _require _ _ ( 1 8 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XAny = function ( ) { function XAny ( f , xf ) { this . xf = xf ; this . f = f ; this . any = false ; } XAny . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XAny . prototype [ ' @ @transducer /result ' ] = function ( result ) { if ( ! this . any ) { result = this . xf [ ' @ @transducer /step ' ] ( result , false ) ; } return this . xf [ ' @ @transducer /result ' ] ( result ) ; } ; XAny . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { if ( this . f ( input ) ) { this . any = true ; result = _reduced ( this . xf [ ' @ @transducer /step ' ] ( result , true ) ) ; } return result ; } ; return XAny ; } ( ) ; var _xany = _curry 2 ( function _xany ( f , xf ) { return new XAny ( f , xf ) ; } ) ; module . exports = _xany ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XDrop Repeats With = function ( ) { function XDrop Repeats With ( pred , xf ) { this . xf = xf ; this . pred = pred ; this . last Value = undefined ; this . seen First Value = false ; } XDrop Repeats With . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XDrop Repeats With . prototype [ ' @ @transducer /result ' ] = _xf Base . result ; XDrop Repeats With . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { var same As Last = false ; if ( ! this . seen First Value ) { this . seen First Value = true ; } else if ( this . pred ( this . last Value , input ) ) { same As Last = true ; } this . last Value = input ; return same As Last ? result : this . xf [ ' @ @transducer /step ' ] ( result , input ) ; } ; return XDrop Repeats With ; } ( ) ; var _xdrop Repeats With = _curry 2 ( function _xdrop Repeats With ( pred , xf ) { return new XDrop Repeats With ( pred , xf ) ; } ) ; module . exports = _xdrop Repeats With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var is = _curry 2 ( function is ( Ctor , val ) { return val ! = null & & val . constructor = = = Ctor | | val instanceof Ctor ; } ) ; module . exports = is ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var is Nil = _curry 1 ( function is Nil ( x ) { return x = = null ; } ) ; module . exports = is Nil ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var converge = _ _webpack _require _ _ ( 1 9 4 ) ; var juxt = _curry 1 ( function juxt ( fns ) { return converge ( function ( ) { return Array . prototype . slice . call ( arguments , 0 ) ; } , fns ) ; } ) ; module . exports = juxt ; } 
function ( module , exports , _ _webpack _require _ _ ) { var nth = _ _webpack _require _ _ ( 2 6 ) ; var last = nth ( - 1 ) ; module . exports = last ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _is Number = _ _webpack _require _ _ ( 2 0 9 ) ; var length = _curry 1 ( function length ( list ) { return list ! = null & & _is Number ( list . length ) ? list . length : Na N ; } ) ; module . exports = length ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var ap = _ _webpack _require _ _ ( 4 6 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var map = _ _webpack _require _ _ ( 9 ) ; var lift N = _curry 2 ( function lift N ( arity , fn ) { var lifted = curry N ( arity , fn ) ; return curry N ( arity , function ( ) { return _reduce ( ap , map ( lifted , arguments [ 0 ] ) , Array . prototype . slice . call ( arguments , 1 ) ) ; } ) ; } ) ; module . exports = lift N ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var sum = _ _webpack _require _ _ ( 2 3 4 ) ; var mean = _curry 1 ( function mean ( list ) { return sum ( list ) / list . length ; } ) ; module . exports = mean ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _arity = _ _webpack _require _ _ ( 1 4 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var memoize With = _curry 2 ( function memoize With ( m Fn , fn ) { var cache = { } ; return _arity ( fn . length , function ( ) { var key = m Fn . apply ( this , arguments ) ; if ( ! _has ( key , cache ) ) { cache [ key ] = fn . apply ( this , arguments ) ; } return cache [ key ] ; } ) ; } ) ; module . exports = memoize With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var multiply = _curry 2 ( function multiply ( a , b ) { return a * b ; } ) ; module . exports = multiply ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var not = _curry 1 ( function not ( a ) { return ! a ; } ) ; module . exports = not ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var obj Of = _curry 2 ( function obj Of ( key , val ) { var obj = { } ; obj [ key ] = val ; return obj ; } ) ; module . exports = obj Of ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var or = _curry 2 ( function or ( a , b ) { return a | | b ; } ) ; module . exports = or ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; * Returns the result of "setting " the portion of the given data structure * focused by the given lens to the result of applying the given function to * the focused value . * * @func * @member Of R * @since v 0 . 1 6 . 0 * @category Object * @typedefn Lens s a = Functor f = > (a - > f a ) - > s - > f s * @sig Lens s a - > (a - > a ) - > s - > s * @param {Lens } lens * @param { * } v * @param { * } x * @return { * } * @see R .prop , R .lens Index , R .lens Prop * @example * * var head Lens = R .lens Index ( 0 ) ; * * R .over (head Lens , R .to Upper , [ 'foo ' , 'bar ' , 'baz ' ] ) ; * / var over = _curry 3 ( function over ( lens , f , x ) { 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var pick All = _curry 2 ( function pick All ( names , obj ) { var result = { } ; var idx = 0 ; var len = names . length ; while ( idx < len ) { var name = names [ idx ] ; result [ name ] = obj [ name ] ; idx + = 1 ; } return result ; } ) ; module . exports = pick All ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _arity = _ _webpack _require _ _ ( 1 4 ) ; var _pipe = _ _webpack _require _ _ ( 3 2 6 ) ; var reduce = _ _webpack _require _ _ ( 1 6 ) ; var tail = _ _webpack _require _ _ ( 6 1 ) ; function pipe ( ) { if ( arguments . length = = = 0 ) { throw new Error ( 'pipe requires at least one argument ' ) ; } return _arity ( arguments [ 0 ] . length , reduce ( _pipe , arguments [ 0 ] , tail ( arguments ) ) ) ; } module . exports = pipe ; } 
function pipe ( ) { if ( arguments . length = = = 0 ) { throw new Error ( 'pipe requires at least one argument ' ) ; } return _arity ( arguments [ 0 ] . length , reduce ( _pipe , arguments [ 0 ] , tail ( arguments ) ) ) ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _arity = _ _webpack _require _ _ ( 1 4 ) ; var _pipe P = _ _webpack _require _ _ ( 3 2 7 ) ; var reduce = _ _webpack _require _ _ ( 1 6 ) ; var tail = _ _webpack _require _ _ ( 6 1 ) ; function pipe P ( ) { if ( arguments . length = = = 0 ) { throw new Error ( 'pipe P requires at least one argument ' ) ; } return _arity ( arguments [ 0 ] . length , reduce ( _pipe P , arguments [ 0 ] , tail ( arguments ) ) ) ; } module . exports = pipe P ; } 
function pipe P ( ) { if ( arguments . length = = = 0 ) { throw new Error ( 'pipe P requires at least one argument ' ) ; } return _arity ( arguments [ 0 ] . length , reduce ( _pipe P , arguments [ 0 ] , tail ( arguments ) ) ) ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _concat = _ _webpack _require _ _ ( 1 2 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var prepend = _curry 2 ( function prepend ( el , list ) { return _concat ( [ el ] , list ) ; } ) ; module . exports = prepend ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var reduce Right = _curry 3 ( function reduce Right ( fn , acc , list ) { var idx = list . length - 1 ; while ( idx > = 0 ) { acc = fn ( list [ idx ] , acc ) ; idx - = 1 ; } return acc ; } ) ; module . exports = reduce Right ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var remove = _curry 3 ( function remove ( start , count , list ) { var result = Array . prototype . slice . call ( list , 0 ) ; result . splice ( start , count ) ; return result ; } ) ; module . exports = remove ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var ap = _ _webpack _require _ _ ( 4 6 ) ; var map = _ _webpack _require _ _ ( 9 ) ; var prepend = _ _webpack _require _ _ ( 2 3 0 ) ; var reduce Right = _ _webpack _require _ _ ( 2 3 1 ) ; var sequence = _curry 2 ( function sequence ( of , traversable ) { return typeof traversable . sequence = = = 'function ' ? traversable . sequence ( of ) : reduce Right ( function ( x , acc ) { return ap ( map ( prepend , x ) , acc ) ; } , of ( [ ] ) , traversable ) ; } ) ; module . exports = sequence ; } 
function ( module , exports , _ _webpack _require _ _ ) { var add = _ _webpack _require _ _ ( 2 9 ) ; var reduce = _ _webpack _require _ _ ( 1 6 ) ; var sum = reduce ( add , 0 ) ; module . exports = sum ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var drop = _ _webpack _require _ _ ( 1 9 9 ) ; var take Last = _curry 2 ( function take Last ( n , xs ) { return drop ( n > = 0 ? xs . length - n : 0 , xs ) ; } ) ; module . exports = take Last ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var times = _curry 2 ( function times ( fn , n ) { var len = Number ( n ) ; var idx = 0 ; var list ; if ( len < 0 | | is Na N ( len ) ) { throw new Range Error ( 'n must be a non -negative number ' ) ; } list = new Array ( len ) ; while ( idx < len ) { list [ idx ] = fn ( idx ) ; idx + = 1 ; } return list ; } ) ; module . exports = times ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _Set = _ _webpack _require _ _ ( 3 1 4 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var uniq By = _curry 2 ( function uniq By ( fn , list ) { var set = new _Set ( ) ; var result = [ ] ; var idx = 0 ; var applied Item , item ; while ( idx < list . length ) { item = list [ idx ] ; applied Item = fn ( item ) ; if ( set . add ( applied Item ) ) { result . push ( item ) ; } idx + = 1 ; } return result ; } ) ; module . exports = uniq By ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _contains With = _ _webpack _require _ _ ( 3 2 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var uniq With = _curry 2 ( function uniq With ( pred , list ) { var idx = 0 ; var len = list . length ; var result = [ ] ; var item ; while ( idx < len ) { item = list [ idx ] ; if ( ! _contains With ( pred , item , result ) ) { result [ result . length ] = item ; } idx + = 1 ; } return result ; } ) ; module . exports = uniq With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var use With = _curry 2 ( function use With ( fn , transformers ) { return curry N ( transformers . length , function ( ) { var args = [ ] ; var idx = 0 ; while ( idx < transformers . length ) { args . push ( transformers [ idx ] . call ( this , arguments [ idx ] ) ) ; idx + = 1 ; } return fn . apply ( this , args . concat ( Array . prototype . slice . call ( arguments , transformers . length ) ) ) ; } ) ; } ) ; module . exports = use With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var keys = _ _webpack _require _ _ ( 1 5 ) ; var values = _curry 1 ( function values ( obj ) { var props = keys ( obj ) ; var len = props . length ; var vals = [ ] ; var idx = 0 ; while ( idx < len ) { vals [ idx ] = obj [ props [ idx ] ] ; idx + = 1 ; } return vals ; } ) ; module . exports = values ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var where = _curry 2 ( function where ( spec , test Obj ) { for ( var prop in spec ) { if ( _has ( prop , spec ) & & ! spec [ prop ] ( test Obj [ prop ] ) ) { return false ; } } return true ; } ) ; module . exports = where ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; if ( true ) { module . exports = _ _webpack _require _ _ ( 4 6 4 ) ; } else { module . exports = require ( ' . /cjs /react .development .js ' ) ; } } 
function ( module , exports , _ _webpack _require _ _ ) { var always = _ _webpack _require _ _ ( 1 9 ) ; var F = always ( false ) ; module . exports = F ; } 
function ( module , exports , _ _webpack _require _ _ ) { var always = _ _webpack _require _ _ ( 1 9 ) ; var T = always ( true ) ; module . exports = T ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _concat = _ _webpack _require _ _ ( 1 2 ) ; var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var add Index = _curry 1 ( function add Index ( fn ) { return curry N ( fn . length , function ( ) { var idx = 0 ; var orig Fn = arguments [ 0 ] ; var list = arguments [ arguments . length - 1 ] ; var args = Array . prototype . slice . call ( arguments , 0 ) ; args [ 0 ] = function ( ) { var result = orig Fn . apply ( this , _concat ( arguments , [ idx , list ] ) ) ; idx + = 1 ; return result ; } ; return fn . apply ( this , args ) ; } ) ; } ) ; module . exports = add Index ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xall = _ _webpack _require _ _ ( 3 3 2 ) ; var all = _curry 2 ( _dispatchable ( [ 'all ' ] , _xall , function all ( fn , list ) { var idx = 0 ; while ( idx < list . length ) { if ( ! fn ( list [ idx ] ) ) { return false ; } idx + = 1 ; } return true ; } ) ) ; module . exports = all ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var max = _ _webpack _require _ _ ( 2 1 ) ; var pluck = _ _webpack _require _ _ ( 2 7 ) ; var reduce = _ _webpack _require _ _ ( 1 6 ) ; var any Pass = _curry 1 ( function any Pass ( preds ) { return curry N ( reduce ( max , 0 , pluck ( 'length ' , preds ) ) , function ( ) { var idx = 0 ; var len = preds . length ; while ( idx < len ) { if ( preds [ idx ] . apply ( this , arguments ) ) { return true ; } idx + = 1 ; } return false ; } ) ; } ) ; module . exports = any Pass ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _aperture = _ _webpack _require _ _ ( 3 1 5 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xaperture = _ _webpack _require _ _ ( 3 3 3 ) ; var aperture = _curry 2 ( _dispatchable ( [ ] , _xaperture , _aperture ) ) ; module . exports = aperture ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _concat = _ _webpack _require _ _ ( 1 2 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var append = _curry 2 ( function append ( el , list ) { return _concat ( list , [ el ] ) ; } ) ; module . exports = append ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var apply = _ _webpack _require _ _ ( 1 8 9 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var map = _ _webpack _require _ _ ( 9 ) ; var max = _ _webpack _require _ _ ( 2 1 ) ; var pluck = _ _webpack _require _ _ ( 2 7 ) ; var reduce = _ _webpack _require _ _ ( 1 6 ) ; var values = _ _webpack _require _ _ ( 2 4 0 ) ; var apply Spec = _curry 1 ( function apply Spec ( spec ) { spec = map ( function ( v ) { return typeof v = = 'function ' ? v : apply Spec ( v ) ; } , spec ) ; return curry N ( reduce ( max , 0 , pluck ( 'length ' , values ( spec ) ) ) , function ( ) { var args = arguments ; return map ( function ( f ) { return apply ( f , args ) ; } , spec ) ; } ) ; } ) ; module . exports = apply Spec ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var apply To = _curry 2 ( function apply To ( x , f ) { return f ( x ) ; } ) ; module . exports = apply To ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var n Ary = _ _webpack _require _ _ ( 4 1 ) ; var binary = _curry 1 ( function binary ( fn ) { return n Ary ( 2 , fn ) ; } ) ; module . exports = binary ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _is Function = _ _webpack _require _ _ ( 3 5 ) ; var and = _ _webpack _require _ _ ( 1 8 7 ) ; var lift = _ _webpack _require _ _ ( 3 9 ) ; var both = _curry 2 ( function both ( f , g ) { return _is Function ( f ) ? function _both ( ) { return f . apply ( this , arguments ) & & g . apply ( this , arguments ) ; } : lift ( and ) ( f , g ) ; } ) ; module . exports = both ; } 
function ( module , exports , _ _webpack _require _ _ ) { var curry = _ _webpack _require _ _ ( 5 0 ) ; var call = curry ( function call ( fn ) { return fn . apply ( this , Array . prototype . slice . call ( arguments , 1 ) ) ; } ) ; module . exports = call ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var clamp = _curry 3 ( function clamp ( min , max , value ) { if ( min > max ) { throw new Error ( 'min must not be greater than max in clamp (min , max , value ) ' ) ; } return value < min ? min : value > max ? max : value ; } ) ; module . exports = clamp ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _clone = _ _webpack _require _ _ ( 2 0 3 ) ; var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var clone = _curry 1 ( function clone ( value ) { return value ! = null & & typeof value . clone = = = 'function ' ? value . clone ( ) : _clone ( value , [ ] , [ ] , true ) ; } ) ; module . exports = clone ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var comparator = _curry 1 ( function comparator ( pred ) { return function ( a , b ) { return pred ( a , b ) ? - 1 : pred ( b , a ) ? 1 : 0 ; } ; } ) ; module . exports = comparator ; } 
function ( module , exports , _ _webpack _require _ _ ) { var lift = _ _webpack _require _ _ ( 3 9 ) ; var not = _ _webpack _require _ _ ( 2 2 3 ) ; var complement = lift ( not ) ; module . exports = complement ; } 
function ( module , exports , _ _webpack _require _ _ ) { var pipe P = _ _webpack _require _ _ ( 2 2 9 ) ; var reverse = _ _webpack _require _ _ ( 4 4 ) ; function compose P ( ) { if ( arguments . length = = = 0 ) { throw new Error ( 'compose P requires at least one argument ' ) ; } return pipe P . apply ( this , reverse ( arguments ) ) ; } module . exports = compose P ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _arity = _ _webpack _require _ _ ( 1 4 ) ; var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var map = _ _webpack _require _ _ ( 9 ) ; var max = _ _webpack _require _ _ ( 2 1 ) ; var reduce = _ _webpack _require _ _ ( 1 6 ) ; var cond = _curry 1 ( function cond ( pairs ) { var arity = reduce ( max , 0 , map ( function ( pair ) { return pair [ 0 ] . length ; } , pairs ) ) ; return _arity ( arity , function ( ) { var idx = 0 ; while ( idx < pairs . length ) { if ( pairs [ idx ] [ 0 ] . apply ( this , arguments ) ) { return pairs [ idx ] [ 1 ] . apply ( this , arguments ) ; } idx + = 1 ; } } ) ; } ) ; module . exports = cond ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var construct N = _ _webpack _require _ _ ( 1 9 3 ) ; var construct = _curry 1 ( function construct ( Fn ) { return construct N ( Fn . length , Fn ) ; } ) ; module . exports = construct ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _contains = _ _webpack _require _ _ ( 2 0 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var contains = _curry 2 ( _contains ) ; module . exports = contains ; } 
function ( module , exports , _ _webpack _require _ _ ) { var reduce By = _ _webpack _require _ _ ( 4 2 ) ; var count By = reduce By ( function ( acc , elem ) { return acc + 1 ; } , 0 ) ; module . exports = count By ; } 
function ( module , exports , _ _webpack _require _ _ ) { var add = _ _webpack _require _ _ ( 2 9 ) ; var dec = add ( - 1 ) ; module . exports = dec ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var descend = _curry 3 ( function descend ( fn , a , b ) { var aa = fn ( a ) ; var bb = fn ( b ) ; return aa > bb ? - 1 : aa < bb ? 1 : 0 ; } ) ; module . exports = descend ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _is Integer = _ _webpack _require _ _ ( 5 6 ) ; var assoc = _ _webpack _require _ _ ( 3 0 ) ; var dissoc = _ _webpack _require _ _ ( 1 9 8 ) ; var remove = _ _webpack _require _ _ ( 2 3 2 ) ; var update = _ _webpack _require _ _ ( 6 5 ) ; var dissoc Path = _curry 2 ( function dissoc Path ( path , obj ) { switch ( path . length ) { case 0 : return obj ; case 1 : return _is Integer ( path [ 0 ] ) ? remove ( path [ 0 ] , 1 , obj ) : dissoc ( path [ 0 ] , obj ) ; default : var head = path [ 0 ] ; var tail = Array . prototype . slice . call ( path , 1 ) ; if ( obj [ head ] = = null ) { return obj ; } else if ( _is Integer ( path [ 0 ] ) ) { return update ( head , dissoc Path ( tail , obj [ head ] ) , obj ) ; } else { return assoc ( head , dissoc Path ( tail , obj [ head ] ) , obj ) ; } } } ) ; module . exports = dissoc Path ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var divide = _curry 2 ( function divide ( a , b ) { return a / b ; } ) ; module . exports = divide ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _drop Last = _ _webpack _require _ _ ( 3 1 7 ) ; var _xdrop Last = _ _webpack _require _ _ ( 3 3 6 ) ; var drop Last = _curry 2 ( _dispatchable ( [ ] , _xdrop Last , _drop Last ) ) ; module . exports = drop Last ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _drop Last While = _ _webpack _require _ _ ( 3 1 8 ) ; var _xdrop Last While = _ _webpack _require _ _ ( 3 3 7 ) ; var drop Last While = _curry 2 ( _dispatchable ( [ ] , _xdrop Last While , _drop Last While ) ) ; module . exports = drop Last While ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xdrop Repeats With = _ _webpack _require _ _ ( 2 1 2 ) ; var drop Repeats With = _ _webpack _require _ _ ( 2 0 0 ) ; var equals = _ _webpack _require _ _ ( 1 0 ) ; var drop Repeats = _curry 1 ( _dispatchable ( [ ] , _xdrop Repeats With ( equals ) , drop Repeats With ( equals ) ) ) ; module . exports = drop Repeats ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xdrop While = _ _webpack _require _ _ ( 3 3 8 ) ; var slice = _ _webpack _require _ _ ( 1 3 ) ; var drop While = _curry 2 ( _dispatchable ( [ 'drop While ' ] , _xdrop While , function drop While ( pred , xs ) { var idx = 0 ; var len = xs . length ; while ( idx < len & & pred ( xs [ idx ] ) ) { idx + = 1 ; } return slice ( idx , Infinity , xs ) ; } ) ) ; module . exports = drop While ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _is Function = _ _webpack _require _ _ ( 3 5 ) ; var lift = _ _webpack _require _ _ ( 3 9 ) ; var or = _ _webpack _require _ _ ( 2 2 5 ) ; var either = _curry 2 ( function either ( f , g ) { return _is Function ( f ) ? function _either ( ) { return f . apply ( this , arguments ) | | g . apply ( this , arguments ) ; } : lift ( or ) ( f , g ) ; } ) ; module . exports = either ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var equals = _ _webpack _require _ _ ( 1 0 ) ; var take Last = _ _webpack _require _ _ ( 2 3 5 ) ; var ends With = _curry 2 ( function ( suffix , list ) { return equals ( take Last ( suffix . length , list ) , suffix ) ; } ) ; module . exports = ends With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var equals = _ _webpack _require _ _ ( 1 0 ) ; var eq By = _curry 3 ( function eq By ( f , x , y ) { return equals ( f ( x ) , f ( y ) ) ; } ) ; module . exports = eq By ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var equals = _ _webpack _require _ _ ( 1 0 ) ; var eq Props = _curry 3 ( function eq Props ( prop , obj 1 , obj 2 ) { return equals ( obj 1 [ prop ] , obj 2 [ prop ] ) ; } ) ; module . exports = eq Props ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var evolve = _curry 2 ( function evolve ( transformations , object ) { var result = { } ; var transformation , key , type ; for ( key in object ) { transformation = transformations [ key ] ; type = typeof transformation ; result [ key ] = type = = = 'function ' ? transformation ( object [ key ] ) : transformation & & type = = = 'object ' ? evolve ( transformation , object [ key ] ) : object [ key ] ; } return result ; } ) ; module . exports = evolve ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xfind = _ _webpack _require _ _ ( 3 4 0 ) ; var find = _curry 2 ( _dispatchable ( [ 'find ' ] , _xfind , function find ( fn , list ) { var idx = 0 ; var len = list . length ; while ( idx < len ) { if ( fn ( list [ idx ] ) ) { return list [ idx ] ; } idx + = 1 ; } } ) ) ; module . exports = find ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xfind Index = _ _webpack _require _ _ ( 3 4 1 ) ; var find Index = _curry 2 ( _dispatchable ( [ ] , _xfind Index , function find Index ( fn , list ) { var idx = 0 ; var len = list . length ; while ( idx < len ) { if ( fn ( list [ idx ] ) ) { return idx ; } idx + = 1 ; } return - 1 ; } ) ) ; module . exports = find Index ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xfind Last = _ _webpack _require _ _ ( 3 4 2 ) ; var find Last = _curry 2 ( _dispatchable ( [ ] , _xfind Last , function find Last ( fn , list ) { var idx = list . length - 1 ; while ( idx > = 0 ) { if ( fn ( list [ idx ] ) ) { return list [ idx ] ; } idx - = 1 ; } } ) ) ; module . exports = find Last ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xfind Last Index = _ _webpack _require _ _ ( 3 4 3 ) ; var find Last Index = _curry 2 ( _dispatchable ( [ ] , _xfind Last Index , function find Last Index ( fn , list ) { var idx = list . length - 1 ; while ( idx > = 0 ) { if ( fn ( list [ idx ] ) ) { return idx ; } idx - = 1 ; } return - 1 ; } ) ) ; module . exports = find Last Index ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _make Flat = _ _webpack _require _ _ ( 2 1 0 ) ; var flatten = _curry 1 ( _make Flat ( true ) ) ; module . exports = flatten ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _check For Method = _ _webpack _require _ _ ( 2 3 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var for Each = _curry 2 ( _check For Method ( 'for Each ' , function for Each ( fn , list ) { var len = list . length ; var idx = 0 ; while ( idx < len ) { fn ( list [ idx ] ) ; idx + = 1 ; } return list ; } ) ) ; module . exports = for Each ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var keys = _ _webpack _require _ _ ( 1 5 ) ; var for Each Obj Indexed = _curry 2 ( function for Each Obj Indexed ( fn , obj ) { var key List = keys ( obj ) ; var idx = 0 ; while ( idx < key List . length ) { var key = key List [ idx ] ; fn ( obj [ key ] , key , obj ) ; idx + = 1 ; } return obj ; } ) ; module . exports = for Each Obj Indexed ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var from Pairs = _curry 1 ( function from Pairs ( pairs ) { var result = { } ; var idx = 0 ; while ( idx < pairs . length ) { result [ pairs [ idx ] [ 0 ] ] = pairs [ idx ] [ 1 ] ; idx + = 1 ; } return result ; } ) ; module . exports = from Pairs ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _check For Method = _ _webpack _require _ _ ( 2 3 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var reduce By = _ _webpack _require _ _ ( 4 2 ) ; var group By = _curry 2 ( _check For Method ( 'group By ' , reduce By ( function ( acc , item ) { if ( acc = = null ) { acc = [ ] ; } acc . push ( item ) ; return acc ; } , null ) ) ) ; module . exports = group By ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var group With = _curry 2 ( function ( fn , list ) { var res = [ ] ; var idx = 0 ; var len = list . length ; while ( idx < len ) { var nextidx = idx + 1 ; while ( nextidx < len & & fn ( list [ nextidx - 1 ] , list [ nextidx ] ) ) { nextidx + = 1 ; } res . push ( list . slice ( idx , nextidx ) ) ; idx = nextidx ; } return res ; } ) ; module . exports = group With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var gt = _curry 2 ( function gt ( a , b ) { return a > b ; } ) ; module . exports = gt ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var gte = _curry 2 ( function gte ( a , b ) { return a > = b ; } ) ; module . exports = gte ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var has = _curry 2 ( _has ) ; module . exports = has ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var has In = _curry 2 ( function has In ( prop , obj ) { return prop in obj ; } ) ; module . exports = has In ; } 
function ( module , exports , _ _webpack _require _ _ ) { var nth = _ _webpack _require _ _ ( 2 6 ) ; var head = nth ( 0 ) ; module . exports = head ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var if Else = _curry 3 ( function if Else ( condition , on True , on False ) { return curry N ( Math . max ( condition . length , on True . length , on False . length ) , function _if Else ( ) { return condition . apply ( this , arguments ) ? on True . apply ( this , arguments ) : on False . apply ( this , arguments ) ; } ) ; } ) ; module . exports = if Else ; } 
function ( module , exports , _ _webpack _require _ _ ) { var add = _ _webpack _require _ _ ( 2 9 ) ; var inc = add ( 1 ) ; module . exports = inc ; } 
function ( module , exports , _ _webpack _require _ _ ) { module . exports = { } ; module . exports . F = _ _webpack _require _ _ ( 2 5 3 ) ; module . exports . T = _ _webpack _require _ _ ( 2 5 4 ) ; module . exports . _ _ = _ _webpack _require _ _ ( 2 5 5 ) ; module . exports . add = _ _webpack _require _ _ ( 2 9 ) ; module . exports . add Index = _ _webpack _require _ _ ( 2 5 6 ) ; module . exports . adjust = _ _webpack _require _ _ ( 1 8 6 ) ; module . exports . all = _ _webpack _require _ _ ( 2 5 7 ) ; module . exports . all Pass = _ _webpack _require _ _ ( 2 5 8 ) ; module . exports . always = _ _webpack _require _ _ ( 1 9 ) ; module . exports . and = _ _webpack _require _ _ ( 1 8 7 ) ; module . exports . any = _ _webpack _require _ _ ( 1 8 8 ) ; module . exports . any Pass = _ _webpack _require _ _ ( 2 5 9 ) ; module . exports . ap = _ _webpack _require _ _ ( 4 6 ) ; module . exports . aperture = _ _webpack _require _ _ ( 2 6 0 ) ; module . exports . append = _ _webpack _require _ _ ( 2 6 1 ) ; module . exports . apply = _ _webpack _require _ _ ( 1 8 9 ) ; module . exports . apply Spec = _ _webpack _require _ _ ( 2 6 2 ) ; module . exports . apply To = _ _webpack _require _ _ ( 2 6 3 ) ; module . exports . ascend = _ _webpack _require _ _ ( 2 6 4 ) ; module . exports . assoc = _ _webpack _require _ _ ( 3 0 ) ; module . exports . assoc Path = _ _webpack _require _ _ ( 1 9 0 ) ; module . exports . binary = _ _webpack _require _ _ ( 2 6 5 ) ; module . exports . bind = _ _webpack _require _ _ ( 1 9 1 ) ; module . exports . both = _ _webpack _require _ _ ( 2 6 6 ) ; module . exports . call = _ _webpack _require _ _ ( 2 6 7 ) ; module . exports . chain = _ _webpack _require _ _ ( 4 7 ) ; module . exports . clamp = _ _webpack _require _ _ ( 2 6 8 ) ; module . exports . clone = _ _webpack _require _ _ ( 2 6 9 ) ; module . exports . comparator = _ _webpack _require _ _ ( 2 7 0 ) ; module . exports . complement = _ _webpack _require _ _ ( 2 7 1 ) ; module . exports . compose = _ _webpack _require _ _ ( 4 8 ) ; module . exports . compose K = _ _webpack _require _ _ ( 1 9 2 ) ; module . exports . compose P = _ _webpack _require _ _ ( 2 7 2 ) ; module . exports . concat = _ _webpack _require _ _ ( 4 9 ) ; module . exports . cond = _ _webpack _require _ _ ( 2 7 3 ) ; module . exports . construct = _ _webpack _require _ _ ( 2 7 4 ) ; module . exports . construct N = _ _webpack _require _ _ ( 1 9 3 ) ; module . exports . contains = _ _webpack _require _ _ ( 2 7 5 ) ; module . exports . converge = _ _webpack _require _ _ ( 1 9 4 ) ; module . exports . count By = _ _webpack _require _ _ ( 2 7 6 ) ; module . exports . curry = _ _webpack _require _ _ ( 5 0 ) ; module . exports . curry N = _ _webpack _require _ _ ( 7 ) ; module . exports . dec = _ _webpack _require _ _ ( 2 7 7 ) ; module . exports . default To = _ _webpack _require _ _ ( 1 9 5 ) ; module . exports . descend = _ _webpack _require _ _ ( 2 7 8 ) ; module . exports . difference = _ _webpack _require _ _ ( 1 9 6 ) ; module . exports . difference With = _ _webpack _require _ _ ( 1 9 7 ) ; module . exports . dissoc = _ _webpack _require _ _ ( 1 9 8 ) ; module . exports . dissoc Path = _ _webpack _require _ _ ( 2 7 9 ) ; module . exports . divide = _ _webpack _require _ _ ( 2 8 0 ) ; module . exports . drop = _ _webpack _require _ _ ( 1 9 9 ) ; module . exports . drop Last = _ _webpack _require _ _ ( 2 8 1 ) ; module . exports . drop Last While = _ _webpack _require _ _ ( 2 8 2 ) ; module . exports . drop Repeats = _ _webpack _require _ _ ( 2 8 3 ) ; module . exports . drop Repeats With = _ _webpack _require _ _ ( 2 0 0 ) ; module . exports . drop While = _ _webpack _require _ _ ( 2 8 4 ) ; module . exports . either = _ _webpack _require _ _ ( 2 8 5 ) ; module . exports . empty = _ _webpack _require _ _ ( 2 0 1 ) ; module . exports . ends With = _ _webpack _require _ _ ( 2 8 6 ) ; module . exports . eq By = _ _webpack _require _ _ ( 2 8 7 ) ; module . exports . eq Props = _ _webpack _require _ _ ( 2 8 8 ) ; module . exports . equals = _ _webpack _require _ _ ( 1 0 ) ; module . exports . evolve = _ _webpack _require _ _ ( 2 8 9 ) ; module . exports . filter = _ _webpack _require _ _ ( 5 1 ) ; module . exports . find = _ _webpack _require _ _ ( 2 9 0 ) ; module . exports . find Index = _ _webpack _require _ _ ( 2 9 1 ) ; module . exports . find Last = _ _webpack _require _ _ ( 2 9 2 ) ; module . exports . find Last Index = _ _webpack _require _ _ ( 2 9 3 ) ; module . exports . flatten = _ _webpack _require _ _ ( 2 9 4 ) ; module . exports . flip = _ _webpack _require _ _ ( 3 1 ) ; module . exports . for Each = _ _webpack _require _ _ ( 2 9 5 ) ; module . exports . for Each Obj Indexed = _ _webpack _require _ _ ( 2 9 6 ) ; module . exports . from Pairs = _ _webpack _require _ _ ( 2 9 7 ) ; module . exports . group By = _ _webpack _require _ _ ( 2 9 8 ) ; module . exports . group With = _ _webpack _require _ _ ( 2 9 9 ) ; module . exports . gt = _ _webpack _require _ _ ( 3 0 0 ) ; module . exports . gte = _ _webpack _require _ _ ( 3 0 1 ) ; module . exports . has = _ _webpack _require _ _ ( 3 0 2 ) ; module . exports . has In = _ _webpack _require _ _ ( 3 0 3 ) ; module . exports . head = _ _webpack _require _ _ ( 3 0 4 ) ; module . exports . identical = _ _webpack _require _ _ ( 2 0 2 ) ; module . exports . identity = _ _webpack _require _ _ ( 5 2 ) ; module . exports . if Else = _ _webpack _require _ _ ( 3 0 5 ) ; module . exports . inc = _ _webpack _require _ _ ( 3 0 6 ) ; module . exports . index By = _ _webpack _require _ _ ( 3 0 8 ) ; module . exports . index Of = _ _webpack _require _ _ ( 3 0 9 ) ; module . exports . init = _ _webpack _require _ _ ( 3 1 0 ) ; module . exports . inner Join = _ _webpack _require _ _ ( 3 1 1 ) ; module . exports . insert = _ _webpack _require _ _ ( 3 1 2 ) ; module . exports . insert All = _ _webpack _require _ _ ( 3 1 3 ) ; module . exports . intersection = _ _webpack _require _ _ ( 3 4 9 ) ; module . exports . intersperse = _ _webpack _require _ _ ( 3 5 0 ) ; module . exports . into = _ _webpack _require _ _ ( 3 5 1 ) ; module . exports . invert = _ _webpack _require _ _ ( 3 5 2 ) ; module . exports . invert Obj = _ _webpack _require _ _ ( 3 5 3 ) ; module . exports . invoker = _ _webpack _require _ _ ( 2 5 ) ; module . exports . is = _ _webpack _require _ _ ( 2 1 4 ) ; module . exports . is Empty = _ _webpack _require _ _ ( 3 5 4 ) ; module . exports . is Nil = _ _webpack _require _ _ ( 2 1 5 ) ; module . exports . join = _ _webpack _require _ _ ( 3 5 5 ) ; module . exports . juxt = _ _webpack _require _ _ ( 2 1 6 ) ; module . exports . keys = _ _webpack _require _ _ ( 1 5 ) ; module . exports . keys In = _ _webpack _require _ _ ( 3 5 6 ) ; module . exports . last = _ _webpack _require _ _ ( 2 1 7 ) ; module . exports . last Index Of = _ _webpack _require _ _ ( 3 5 7 ) ; module . exports . length = _ _webpack _require _ _ ( 2 1 8 ) ; module . exports . lens = _ _webpack _require _ _ ( 3 8 ) ; module . exports . lens Index = _ _webpack _require _ _ ( 3 5 8 ) ; module . exports . lens Path = _ _webpack _require _ _ ( 3 5 9 ) ; module . exports . lens Prop = _ _webpack _require _ _ ( 3 6 0 ) ; module . exports . lift = _ _webpack _require _ _ ( 3 9 ) ; module . exports . lift N = _ _webpack _require _ _ ( 2 1 9 ) ; module . exports . lt = _ _webpack _require _ _ ( 3 6 1 ) ; module . exports . lte = _ _webpack _require _ _ ( 3 6 2 ) ; module . exports . map = _ _webpack _require _ _ ( 9 ) ; module . exports . map Accum = _ _webpack _require _ _ ( 3 6 3 ) ; module . exports . map Accum Right = _ _webpack _require _ _ ( 3 6 4 ) ; module . exports . map Obj Indexed = _ _webpack _require _ _ ( 3 6 5 ) ; module . exports . match = _ _webpack _require _ _ ( 3 6 6 ) ; module . exports . math Mod = _ _webpack _require _ _ ( 3 6 7 ) ; module . exports . max = _ _webpack _require _ _ ( 2 1 ) ; module . exports . max By = _ _webpack _require _ _ ( 3 6 8 ) ; module . exports . mean = _ _webpack _require _ _ ( 2 2 0 ) ; module . exports . median = _ _webpack _require _ _ ( 3 6 9 ) ; module . exports . memoize = _ _webpack _require _ _ ( 3 7 0 ) ; module . exports . memoize With = _ _webpack _require _ _ ( 2 2 1 ) ; module . exports . merge = _ _webpack _require _ _ ( 3 7 1 ) ; module . exports . merge All = _ _webpack _require _ _ ( 3 7 2 ) ; module . exports . merge Deep Left = _ _webpack _require _ _ ( 3 7 3 ) ; module . exports . merge Deep Right = _ _webpack _require _ _ ( 3 7 4 ) ; module . exports . merge Deep With = _ _webpack _require _ _ ( 3 7 5 ) ; module . exports . merge Deep With Key = _ _webpack _require _ _ ( 4 0 ) ; module . exports . merge With = _ _webpack _require _ _ ( 3 7 6 ) ; module . exports . merge With Key = _ _webpack _require _ _ ( 5 9 ) ; module . exports . min = _ _webpack _require _ _ ( 3 7 7 ) ; module . exports . min By = _ _webpack _require _ _ ( 3 7 8 ) ; module . exports . modulo = _ _webpack _require _ _ ( 3 7 9 ) ; module . exports . multiply = _ _webpack _require _ _ ( 2 2 2 ) ; module . exports . n Ary = _ _webpack _require _ _ ( 4 1 ) ; module . exports . negate = _ _webpack _require _ _ ( 3 8 0 ) ; module . exports . none = _ _webpack _require _ _ ( 3 8 1 ) ; module . exports . not = _ _webpack _require _ _ ( 2 2 3 ) ; module . exports . nth = _ _webpack _require _ _ ( 2 6 ) ; module . exports . nth Arg = _ _webpack _require _ _ ( 3 8 2 ) ; module . exports . o = _ _webpack _require _ _ ( 3 8 3 ) ; module . exports . obj Of = _ _webpack _require _ _ ( 2 2 4 ) ; module . exports . of = _ _webpack _require _ _ ( 3 8 4 ) ; module . exports . omit = _ _webpack _require _ _ ( 3 8 5 ) ; module . exports . once = _ _webpack _require _ _ ( 3 8 6 ) ; module . exports . or = _ _webpack _require _ _ ( 2 2 5 ) ; module . exports . over = _ _webpack _require _ _ ( 2 2 6 ) ; module . exports . pair = _ _webpack _require _ _ ( 3 8 7 ) ; module . exports . partial = _ _webpack _require _ _ ( 3 8 8 ) ; module . exports . partial Right = _ _webpack _require _ _ ( 3 8 9 ) ; module . exports . partition = _ _webpack _require _ _ ( 3 9 0 ) ; module . exports . path = _ _webpack _require _ _ ( 2 2 ) ; module . exports . path Eq = _ _webpack _require _ _ ( 3 9 1 ) ; module . exports . path Or = _ _webpack _require _ _ ( 3 9 2 ) ; module . exports . path Satisfies = _ _webpack _require _ _ ( 3 9 3 ) ; module . exports . pick = _ _webpack _require _ _ ( 3 9 4 ) ; module . exports . pick All = _ _webpack _require _ _ ( 2 2 7 ) ; module . exports . pick By = _ _webpack _require _ _ ( 3 9 5 ) ; module . exports . pipe = _ _webpack _require _ _ ( 2 2 8 ) ; module . exports . pipe K = _ _webpack _require _ _ ( 3 9 6 ) ; module . exports . pipe P = _ _webpack _require _ _ ( 2 2 9 ) ; module . exports . pluck = _ _webpack _require _ _ ( 2 7 ) ; module . exports . prepend = _ _webpack _require _ _ ( 2 3 0 ) ; module . exports . product = _ _webpack _require _ _ ( 3 9 7 ) ; module . exports . project = _ _webpack _require _ _ ( 3 9 8 ) ; module . exports . prop = _ _webpack _require _ _ ( 6 0 ) ; module . exports . prop Eq = _ _webpack _require _ _ ( 3 9 9 ) ; module . exports . prop Is = _ _webpack _require _ _ ( 4 0 0 ) ; module . exports . prop Or = _ _webpack _require _ _ ( 4 0 1 ) ; module . exports . prop Satisfies = _ _webpack _require _ _ ( 4 0 2 ) ; module . exports . props = _ _webpack _require _ _ ( 4 0 3 ) ; module . exports . range = _ _webpack _require _ _ ( 4 0 4 ) ; module . exports . reduce = _ _webpack _require _ _ ( 1 6 ) ; module . exports . reduce By = _ _webpack _require _ _ ( 4 2 ) ; module . exports . reduce Right = _ _webpack _require _ _ ( 2 3 1 ) ; module . exports . reduce While = _ _webpack _require _ _ ( 4 0 5 ) ; module . exports . reduced = _ _webpack _require _ _ ( 4 0 6 ) ; module . exports . reject = _ _webpack _require _ _ ( 4 3 ) ; module . exports . remove = _ _webpack _require _ _ ( 2 3 2 ) ; module . exports . repeat = _ _webpack _require _ _ ( 4 0 7 ) ; module . exports . replace = _ _webpack _require _ _ ( 4 0 8 ) ; module . exports . reverse = _ _webpack _require _ _ ( 4 4 ) ; module . exports . scan = _ _webpack _require _ _ ( 4 0 9 ) ; module . exports . sequence = _ _webpack _require _ _ ( 2 3 3 ) ; module . exports . set = _ _webpack _require _ _ ( 4 1 0 ) ; module . exports . slice = _ _webpack _require _ _ ( 1 3 ) ; module . exports . sort = _ _webpack _require _ _ ( 4 1 1 ) ; module . exports . sort By = _ _webpack _require _ _ ( 4 1 2 ) ; module . exports . sort With = _ _webpack _require _ _ ( 4 1 3 ) ; module . exports . split = _ _webpack _require _ _ ( 4 1 4 ) ; module . exports . split At = _ _webpack _require _ _ ( 4 1 5 ) ; module . exports . split Every = _ _webpack _require _ _ ( 4 1 6 ) ; module . exports . split When = _ _webpack _require _ _ ( 4 1 7 ) ; module . exports . starts With = _ _webpack _require _ _ ( 4 1 8 ) ; module . exports . subtract = _ _webpack _require _ _ ( 4 1 9 ) ; module . exports . sum = _ _webpack _require _ _ ( 2 3 4 ) ; module . exports . symmetric Difference = _ _webpack _require _ _ ( 4 2 0 ) ; module . exports . symmetric Difference With = _ _webpack _require _ _ ( 4 2 1 ) ; module . exports . tail = _ _webpack _require _ _ ( 6 1 ) ; module . exports . take = _ _webpack _require _ _ ( 6 2 ) ; module . exports . take Last = _ _webpack _require _ _ ( 2 3 5 ) ; module . exports . take Last While = _ _webpack _require _ _ ( 4 2 2 ) ; module . exports . take While = _ _webpack _require _ _ ( 4 2 3 ) ; module . exports . tap = _ _webpack _require _ _ ( 4 2 4 ) ; module . exports . test = _ _webpack _require _ _ ( 4 2 5 ) ; module . exports . times = _ _webpack _require _ _ ( 2 3 6 ) ; module . exports . to Lower = _ _webpack _require _ _ ( 4 2 6 ) ; module . exports . to Pairs = _ _webpack _require _ _ ( 4 2 7 ) ; module . exports . to Pairs In = _ _webpack _require _ _ ( 4 2 8 ) ; module . exports . to String = _ _webpack _require _ _ ( 2 8 ) ; module . exports . to Upper = _ _webpack _require _ _ ( 4 2 9 ) ; module . exports . transduce = _ _webpack _require _ _ ( 4 3 0 ) ; module . exports . transpose = _ _webpack _require _ _ ( 4 3 1 ) ; module . exports . traverse = _ _webpack _require _ _ ( 4 3 2 ) ; module . exports . trim = _ _webpack _require _ _ ( 4 3 3 ) ; module . exports . try Catch = _ _webpack _require _ _ ( 4 3 4 ) ; module . exports . type = _ _webpack _require _ _ ( 6 3 ) ; module . exports . unapply = _ _webpack _require _ _ ( 4 3 5 ) ; module . exports . unary = _ _webpack _require _ _ ( 4 3 6 ) ; module . exports . uncurry N = _ _webpack _require _ _ ( 4 3 7 ) ; module . exports . unfold = _ _webpack _require _ _ ( 4 3 8 ) ; module . exports . union = _ _webpack _require _ _ ( 4 3 9 ) ; module . exports . union With = _ _webpack _require _ _ ( 4 4 0 ) ; module . exports . uniq = _ _webpack _require _ _ ( 6 4 ) ; module . exports . uniq By = _ _webpack _require _ _ ( 2 3 7 ) ; module . exports . uniq With = _ _webpack _require _ _ ( 2 3 8 ) ; module . exports . unless = _ _webpack _require _ _ ( 4 4 1 ) ; module . exports . unnest = _ _webpack _require _ _ ( 4 4 2 ) ; module . exports . until = _ _webpack _require _ _ ( 4 4 3 ) ; module . exports . update = _ _webpack _require _ _ ( 6 5 ) ; module . exports . use With = _ _webpack _require _ _ ( 2 3 9 ) ; module . exports . values = _ _webpack _require _ _ ( 2 4 0 ) ; module . exports . values In = _ _webpack _require _ _ ( 4 4 4 ) ; module . exports . view = _ _webpack _require _ _ ( 4 4 5 ) ; module . exports . when = _ _webpack _require _ _ ( 4 4 6 ) ; module . exports . where = _ _webpack _require _ _ ( 2 4 1 ) ; module . exports . where Eq = _ _webpack _require _ _ ( 4 4 7 ) ; module . exports . without = _ _webpack _require _ _ ( 4 4 8 ) ; module . exports . xprod = _ _webpack _require _ _ ( 4 4 9 ) ; module . exports . zip = _ _webpack _require _ _ ( 4 5 0 ) ; module . exports . zip Obj = _ _webpack _require _ _ ( 4 5 1 ) ; module . exports . zip With = _ _webpack _require _ _ ( 4 5 2 ) ; } 
function ( module , exports , _ _webpack _require _ _ ) { var reduce By = _ _webpack _require _ _ ( 4 2 ) ; var index By = reduce By ( function ( acc , elem ) { return elem ; } , null ) ; module . exports = index By ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _index Of = _ _webpack _require _ _ ( 2 0 7 ) ; var _is Array = _ _webpack _require _ _ ( 1 7 ) ; var index Of = _curry 2 ( function index Of ( target , xs ) { return typeof xs . index Of = = = 'function ' & & ! _is Array ( xs ) ? xs . index Of ( target ) : _index Of ( xs , target , 0 ) ; } ) ; module . exports = index Of ; } 
function ( module , exports , _ _webpack _require _ _ ) { var slice = _ _webpack _require _ _ ( 1 3 ) ; var init = slice ( 0 , - 1 ) ; module . exports = init ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _contains With = _ _webpack _require _ _ ( 3 2 ) ; var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var _filter = _ _webpack _require _ _ ( 5 4 ) ; var inner Join = _curry 3 ( function inner Join ( pred , xs , ys ) { return _filter ( function ( x ) { return _contains With ( pred , x , ys ) ; } , xs ) ; } ) ; module . exports = inner Join ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var insert = _curry 3 ( function insert ( idx , elt , list ) { idx = idx < list . length & & idx > = 0 ? idx : list . length ; var result = Array . prototype . slice . call ( list , 0 ) ; result . splice ( idx , 0 , elt ) ; return result ; } ) ; module . exports = insert ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var insert All = _curry 3 ( function insert All ( idx , elts , list ) { idx = idx < list . length & & idx > = 0 ? idx : list . length ; return [ ] . concat ( Array . prototype . slice . call ( list , 0 , idx ) , elts , Array . prototype . slice . call ( list , idx ) ) ; } ) ; module . exports = insert All ; } 
function ( module , exports ) { function _aperture ( n , list ) { var idx = 0 ; var limit = list . length - ( n - 1 ) ; var acc = new Array ( limit > = 0 ? limit : 0 ) ; while ( idx < limit ) { acc [ idx ] = Array . prototype . slice . call ( list , idx , idx + n ) ; idx + = 1 ; } return acc ; } module . exports = _aperture ; } 
function ( module , exports ) { function _array From Iterator ( iter ) { var list = [ ] ; var next ; while ( ! ( next = iter . next ( ) ) . done ) { list . push ( next . value ) ; } return list ; } module . exports = _array From Iterator ; } 
function ( module , exports , _ _webpack _require _ _ ) { var take = _ _webpack _require _ _ ( 6 2 ) ; function drop Last ( n , xs ) { return take ( n < xs . length ? xs . length - n : 0 , xs ) ; } module . exports = drop Last ; } 
function ( module , exports , _ _webpack _require _ _ ) { var slice = _ _webpack _require _ _ ( 1 3 ) ; function drop Last While ( pred , xs ) { var idx = xs . length - 1 ; while ( idx > = 0 & & pred ( xs [ idx ] ) ) { idx - = 1 ; } return slice ( 0 , idx + 1 , xs ) ; } module . exports = drop Last While ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _array From Iterator = _ _webpack _require _ _ ( 3 1 6 ) ; var _contains With = _ _webpack _require _ _ ( 3 2 ) ; var _function Name = _ _webpack _require _ _ ( 3 2 2 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var identical = _ _webpack _require _ _ ( 2 0 2 ) ; var keys = _ _webpack _require _ _ ( 1 5 ) ; var type = _ _webpack _require _ _ ( 6 3 ) ; function _uniq Content Equals ( a Iterator , b Iterator , stack A , stack B ) { var a = _array From Iterator ( a Iterator ) ; var b = _array From Iterator ( b Iterator ) ; function eq ( _a , _b ) { return _equals ( _a , _b , stack A . slice ( ) , stack B . slice ( ) ) ; } 
function _uniq Content Equals ( a Iterator , b Iterator , stack A , stack B ) { var a = _array From Iterator ( a Iterator ) ; var b = _array From Iterator ( b Iterator ) ; function eq ( _a , _b ) { return _equals ( _a , _b , stack A . slice ( ) , stack B . slice ( ) ) ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _force Reduced = _ _webpack _require _ _ ( 3 2 1 ) ; var _is Array Like = _ _webpack _require _ _ ( 3 4 ) ; var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var preserving Reduced = function ( xf ) { return { ' @ @transducer /init ' : _xf Base . init , ' @ @transducer /result ' : function ( result ) { return xf [ ' @ @transducer /result ' ] ( result ) ; } , ' @ @transducer /step ' : function ( result , input ) { var ret = xf [ ' @ @transducer /step ' ] ( result , input ) ; return ret [ ' @ @transducer /reduced ' ] ? _force Reduced ( ret ) : ret ; } } ; } ; var _flat Cat = function _xcat ( xf ) { var rxf = preserving Reduced ( xf ) ; return { ' @ @transducer /init ' : _xf Base . init , ' @ @transducer /result ' : function ( result ) { return rxf [ ' @ @transducer /result ' ] ( result ) ; } , ' @ @transducer /step ' : function ( result , input ) { return ! _is Array Like ( input ) ? _reduce ( rxf , result , [ input ] ) : _reduce ( rxf , result , input ) ; } } ; } ; module . exports = _flat Cat ; } 
function ( module , exports ) { function _function Name ( f ) { 
function ( module , exports ) { function _is Reg Exp ( x ) { return Object . prototype . to String . call ( x ) = = = ' [object Reg Exp ] ' ; } module . exports = _is Reg Exp ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _has = _ _webpack _require _ _ ( 8 ) ; 
function ( module , exports ) { function _pipe ( f , g ) { return function ( ) { return g . call ( this , f . apply ( this , arguments ) ) ; } ; } module . exports = _pipe ; } 
function ( module , exports ) { function _pipe P ( f , g ) { return function ( ) { var ctx = this ; return f . apply ( ctx , arguments ) . then ( function ( x ) { return g . call ( ctx , x ) ; } ) ; } ; } module . exports = _pipe P ; } 
function ( module , exports ) { function _quote ( s ) { var escaped = s . replace ( / \ \ / g , ' \ \ \ \ ' ) . replace ( / [ \b ] / g , ' \ \b ' ) 
function ( module , exports , _ _webpack _require _ _ ) { var _assign = _ _webpack _require _ _ ( 5 3 ) ; var _identity = _ _webpack _require _ _ ( 5 5 ) ; var _is Array Like = _ _webpack _require _ _ ( 3 4 ) ; var _is Transformer = _ _webpack _require _ _ ( 5 8 ) ; var obj Of = _ _webpack _require _ _ ( 2 2 4 ) ; var _step Cat Array = { ' @ @transducer /init ' : Array , ' @ @transducer /step ' : function ( xs , x ) { xs . push ( x ) ; return xs ; } , ' @ @transducer /result ' : _identity } ; var _step Cat String = { ' @ @transducer /init ' : String , ' @ @transducer /step ' : function ( a , b ) { return a + b ; } , ' @ @transducer /result ' : _identity } ; var _step Cat Object = { ' @ @transducer /init ' : Object , ' @ @transducer /step ' : function ( result , input ) { return _assign ( result , _is Array Like ( input ) ? obj Of ( input [ 0 ] , input [ 1 ] ) : input ) ; } , ' @ @transducer /result ' : _identity } ; function _step Cat ( obj ) { if ( _is Transformer ( obj ) ) { return obj ; } if ( _is Array Like ( obj ) ) { return _step Cat Array ; } if ( typeof obj = = = 'string ' ) { return _step Cat String ; } if ( typeof obj = = = 'object ' ) { return _step Cat Object ; } throw new Error ( 'Cannot create transformer for ' + obj ) ; } module . exports = _step Cat ; } 
function ( module , exports ) { var pad = function pad ( n ) { return ( n < 1 0 ? ' 0 ' : ' ' ) + n ; } ; var _to ISOString = typeof Date . prototype . to ISOString = = = 'function ' ? function _to ISOString ( d ) { return d . to ISOString ( ) ; } : function _to ISOString ( d ) { return d . get UTCFull Year ( ) + ' - ' + pad ( d . get UTCMonth ( ) + 1 ) + ' - ' + pad ( d . get UTCDate ( ) ) + 'T ' + pad ( d . get UTCHours ( ) ) + ' : ' + pad ( d . get UTCMinutes ( ) ) + ' : ' + pad ( d . get UTCSeconds ( ) ) + ' . ' + ( d . get UTCMilliseconds ( ) / 1 0 0 0 ) . to Fixed ( 3 ) . slice ( 2 , 5 ) + 'Z ' ; } ; module . exports = _to ISOString ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _contains = _ _webpack _require _ _ ( 2 0 ) ; var _map = _ _webpack _require _ _ ( 3 7 ) ; var _quote = _ _webpack _require _ _ ( 3 2 8 ) ; var _to ISOString = _ _webpack _require _ _ ( 3 3 0 ) ; var keys = _ _webpack _require _ _ ( 1 5 ) ; var reject = _ _webpack _require _ _ ( 4 3 ) ; function _to String ( x , seen ) { var recur = function recur ( y ) { var xs = seen . concat ( [ x ] ) ; return _contains ( y , xs ) ? ' <Circular > ' : _to String ( y , xs ) ; } ; 
function ( obj , keys ) { return _map ( function ( k ) { return _quote ( k ) + ' : ' + recur ( obj [ k ] ) ; } , keys . slice ( ) . sort ( ) ) ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _reduced = _ _webpack _require _ _ ( 1 8 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XAll = function ( ) { function XAll ( f , xf ) { this . xf = xf ; this . f = f ; this . all = true ; } XAll . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XAll . prototype [ ' @ @transducer /result ' ] = function ( result ) { if ( this . all ) { result = this . xf [ ' @ @transducer /step ' ] ( result , true ) ; } return this . xf [ ' @ @transducer /result ' ] ( result ) ; } ; XAll . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { if ( ! this . f ( input ) ) { this . all = false ; result = _reduced ( this . xf [ ' @ @transducer /step ' ] ( result , false ) ) ; } return result ; } ; return XAll ; } ( ) ; var _xall = _curry 2 ( function _xall ( f , xf ) { return new XAll ( f , xf ) ; } ) ; module . exports = _xall ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _concat = _ _webpack _require _ _ ( 1 2 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XAperture = function ( ) { function XAperture ( n , xf ) { this . xf = xf ; this . pos = 0 ; this . full = false ; this . acc = new Array ( n ) ; } XAperture . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XAperture . prototype [ ' @ @transducer /result ' ] = function ( result ) { this . acc = null ; return this . xf [ ' @ @transducer /result ' ] ( result ) ; } ; XAperture . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { this . store ( input ) ; return this . full ? this . xf [ ' @ @transducer /step ' ] ( result , this . get Copy ( ) ) : result ; } ; XAperture . prototype . store = function ( input ) { this . acc [ this . pos ] = input ; this . pos + = 1 ; if ( this . pos = = = this . acc . length ) { this . pos = 0 ; this . full = true ; } } ; XAperture . prototype . get Copy = function ( ) { return _concat ( Array . prototype . slice . call ( this . acc , this . pos ) , Array . prototype . slice . call ( this . acc , 0 , this . pos ) ) ; } ; return XAperture ; } ( ) ; var _xaperture = _curry 2 ( function _xaperture ( n , xf ) { return new XAperture ( n , xf ) ; } ) ; module . exports = _xaperture ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _flat Cat = _ _webpack _require _ _ ( 3 2 0 ) ; var map = _ _webpack _require _ _ ( 9 ) ; var _xchain = _curry 2 ( function _xchain ( f , xf ) { return map ( f , _flat Cat ( xf ) ) ; } ) ; module . exports = _xchain ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XDrop = function ( ) { function XDrop ( n , xf ) { this . xf = xf ; this . n = n ; } XDrop . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XDrop . prototype [ ' @ @transducer /result ' ] = _xf Base . result ; XDrop . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { if ( this . n > 0 ) { this . n - = 1 ; return result ; } return this . xf [ ' @ @transducer /step ' ] ( result , input ) ; } ; return XDrop ; } ( ) ; var _xdrop = _curry 2 ( function _xdrop ( n , xf ) { return new XDrop ( n , xf ) ; } ) ; module . exports = _xdrop ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XDrop Last = function ( ) { function XDrop Last ( n , xf ) { this . xf = xf ; this . pos = 0 ; this . full = false ; this . acc = new Array ( n ) ; } XDrop Last . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XDrop Last . prototype [ ' @ @transducer /result ' ] = function ( result ) { this . acc = null ; return this . xf [ ' @ @transducer /result ' ] ( result ) ; } ; XDrop Last . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { if ( this . full ) { result = this . xf [ ' @ @transducer /step ' ] ( result , this . acc [ this . pos ] ) ; } this . store ( input ) ; return result ; } ; XDrop Last . prototype . store = function ( input ) { this . acc [ this . pos ] = input ; this . pos + = 1 ; if ( this . pos = = = this . acc . length ) { this . pos = 0 ; this . full = true ; } } ; return XDrop Last ; } ( ) ; var _xdrop Last = _curry 2 ( function _xdrop Last ( n , xf ) { return new XDrop Last ( n , xf ) ; } ) ; module . exports = _xdrop Last ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XDrop Last While = function ( ) { function XDrop Last While ( fn , xf ) { this . f = fn ; this . retained = [ ] ; this . xf = xf ; } XDrop Last While . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XDrop Last While . prototype [ ' @ @transducer /result ' ] = function ( result ) { this . retained = null ; return this . xf [ ' @ @transducer /result ' ] ( result ) ; } ; XDrop Last While . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { return this . f ( input ) ? this . retain ( result , input ) : this . flush ( result , input ) ; } ; XDrop Last While . prototype . flush = function ( result , input ) { result = _reduce ( this . xf [ ' @ @transducer /step ' ] , result , this . retained ) ; this . retained = [ ] ; return this . xf [ ' @ @transducer /step ' ] ( result , input ) ; } ; XDrop Last While . prototype . retain = function ( result , input ) { this . retained . push ( input ) ; return result ; } ; return XDrop Last While ; } ( ) ; var _xdrop Last While = _curry 2 ( function _xdrop Last While ( fn , xf ) { return new XDrop Last While ( fn , xf ) ; } ) ; module . exports = _xdrop Last While ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XDrop While = function ( ) { function XDrop While ( f , xf ) { this . xf = xf ; this . f = f ; } XDrop While . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XDrop While . prototype [ ' @ @transducer /result ' ] = _xf Base . result ; XDrop While . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { if ( this . f ) { if ( this . f ( input ) ) { return result ; } this . f = null ; } return this . xf [ ' @ @transducer /step ' ] ( result , input ) ; } ; return XDrop While ; } ( ) ; var _xdrop While = _curry 2 ( function _xdrop While ( f , xf ) { return new XDrop While ( f , xf ) ; } ) ; module . exports = _xdrop While ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XFilter = function ( ) { function XFilter ( f , xf ) { this . xf = xf ; this . f = f ; } XFilter . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XFilter . prototype [ ' @ @transducer /result ' ] = _xf Base . result ; XFilter . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { return this . f ( input ) ? this . xf [ ' @ @transducer /step ' ] ( result , input ) : result ; } ; return XFilter ; } ( ) ; var _xfilter = _curry 2 ( function _xfilter ( f , xf ) { return new XFilter ( f , xf ) ; } ) ; module . exports = _xfilter ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _reduced = _ _webpack _require _ _ ( 1 8 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XFind = function ( ) { function XFind ( f , xf ) { this . xf = xf ; this . f = f ; this . found = false ; } XFind . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XFind . prototype [ ' @ @transducer /result ' ] = function ( result ) { if ( ! this . found ) { result = this . xf [ ' @ @transducer /step ' ] ( result , void 0 ) ; } return this . xf [ ' @ @transducer /result ' ] ( result ) ; } ; XFind . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { if ( this . f ( input ) ) { this . found = true ; result = _reduced ( this . xf [ ' @ @transducer /step ' ] ( result , input ) ) ; } return result ; } ; return XFind ; } ( ) ; var _xfind = _curry 2 ( function _xfind ( f , xf ) { return new XFind ( f , xf ) ; } ) ; module . exports = _xfind ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _reduced = _ _webpack _require _ _ ( 1 8 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XFind Index = function ( ) { function XFind Index ( f , xf ) { this . xf = xf ; this . f = f ; this . idx = - 1 ; this . found = false ; } XFind Index . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XFind Index . prototype [ ' @ @transducer /result ' ] = function ( result ) { if ( ! this . found ) { result = this . xf [ ' @ @transducer /step ' ] ( result , - 1 ) ; } return this . xf [ ' @ @transducer /result ' ] ( result ) ; } ; XFind Index . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { this . idx + = 1 ; if ( this . f ( input ) ) { this . found = true ; result = _reduced ( this . xf [ ' @ @transducer /step ' ] ( result , this . idx ) ) ; } return result ; } ; return XFind Index ; } ( ) ; var _xfind Index = _curry 2 ( function _xfind Index ( f , xf ) { return new XFind Index ( f , xf ) ; } ) ; module . exports = _xfind Index ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XFind Last = function ( ) { function XFind Last ( f , xf ) { this . xf = xf ; this . f = f ; } XFind Last . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XFind Last . prototype [ ' @ @transducer /result ' ] = function ( result ) { return this . xf [ ' @ @transducer /result ' ] ( this . xf [ ' @ @transducer /step ' ] ( result , this . last ) ) ; } ; XFind Last . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { if ( this . f ( input ) ) { this . last = input ; } return result ; } ; return XFind Last ; } ( ) ; var _xfind Last = _curry 2 ( function _xfind Last ( f , xf ) { return new XFind Last ( f , xf ) ; } ) ; module . exports = _xfind Last ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XFind Last Index = function ( ) { function XFind Last Index ( f , xf ) { this . xf = xf ; this . f = f ; this . idx = - 1 ; this . last Idx = - 1 ; } XFind Last Index . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XFind Last Index . prototype [ ' @ @transducer /result ' ] = function ( result ) { return this . xf [ ' @ @transducer /result ' ] ( this . xf [ ' @ @transducer /step ' ] ( result , this . last Idx ) ) ; } ; XFind Last Index . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { this . idx + = 1 ; if ( this . f ( input ) ) { this . last Idx = this . idx ; } return result ; } ; return XFind Last Index ; } ( ) ; var _xfind Last Index = _curry 2 ( function _xfind Last Index ( f , xf ) { return new XFind Last Index ( f , xf ) ; } ) ; module . exports = _xfind Last Index ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XMap = function ( ) { function XMap ( f , xf ) { this . xf = xf ; this . f = f ; } XMap . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XMap . prototype [ ' @ @transducer /result ' ] = _xf Base . result ; XMap . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { return this . xf [ ' @ @transducer /step ' ] ( result , this . f ( input ) ) ; } ; return XMap ; } ( ) ; var _xmap = _curry 2 ( function _xmap ( f , xf ) { return new XMap ( f , xf ) ; } ) ; module . exports = _xmap ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry N = _ _webpack _require _ _ ( 3 3 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XReduce By = function ( ) { function XReduce By ( value Fn , value Acc , key Fn , xf ) { this . value Fn = value Fn ; this . value Acc = value Acc ; this . key Fn = key Fn ; this . xf = xf ; this . inputs = { } ; } XReduce By . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XReduce By . prototype [ ' @ @transducer /result ' ] = function ( result ) { var key ; for ( key in this . inputs ) { if ( _has ( key , this . inputs ) ) { result = this . xf [ ' @ @transducer /step ' ] ( result , this . inputs [ key ] ) ; if ( result [ ' @ @transducer /reduced ' ] ) { result = result [ ' @ @transducer /value ' ] ; break ; } } } this . inputs = null ; return this . xf [ ' @ @transducer /result ' ] ( result ) ; } ; XReduce By . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { var key = this . key Fn ( input ) ; this . inputs [ key ] = this . inputs [ key ] | | [ key , this . value Acc ] ; this . inputs [ key ] [ 1 ] = this . value Fn ( this . inputs [ key ] [ 1 ] , input ) ; return result ; } ; return XReduce By ; } ( ) ; var _xreduce By = _curry N ( 4 , [ ] , function _xreduce By ( value Fn , value Acc , key Fn , xf ) { return new XReduce By ( value Fn , value Acc , key Fn , xf ) ; } ) ; module . exports = _xreduce By ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _reduced = _ _webpack _require _ _ ( 1 8 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XTake = function ( ) { function XTake ( n , xf ) { this . xf = xf ; this . n = n ; this . i = 0 ; } XTake . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XTake . prototype [ ' @ @transducer /result ' ] = _xf Base . result ; XTake . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { this . i + = 1 ; var ret = this . n = = = 0 ? result : this . xf [ ' @ @transducer /step ' ] ( result , input ) ; return this . n > = 0 & & this . i > = this . n ? _reduced ( ret ) : ret ; } ; return XTake ; } ( ) ; var _xtake = _curry 2 ( function _xtake ( n , xf ) { return new XTake ( n , xf ) ; } ) ; module . exports = _xtake ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _reduced = _ _webpack _require _ _ ( 1 8 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XTake While = function ( ) { function XTake While ( f , xf ) { this . xf = xf ; this . f = f ; } XTake While . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XTake While . prototype [ ' @ @transducer /result ' ] = _xf Base . result ; XTake While . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { return this . f ( input ) ? this . xf [ ' @ @transducer /step ' ] ( result , input ) : _reduced ( result ) ; } ; return XTake While ; } ( ) ; var _xtake While = _curry 2 ( function _xtake While ( f , xf ) { return new XTake While ( f , xf ) ; } ) ; module . exports = _xtake While ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _xf Base = _ _webpack _require _ _ ( 6 ) ; var XTap = function ( ) { function XTap ( f , xf ) { this . xf = xf ; this . f = f ; } XTap . prototype [ ' @ @transducer /init ' ] = _xf Base . init ; XTap . prototype [ ' @ @transducer /result ' ] = _xf Base . result ; XTap . prototype [ ' @ @transducer /step ' ] = function ( result , input ) { this . f ( input ) ; return this . xf [ ' @ @transducer /step ' ] ( result , input ) ; } ; return XTap ; } ( ) ; var _xtap = _curry 2 ( function _xtap ( f , xf ) { return new XTap ( f , xf ) ; } ) ; module . exports = _xtap ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _contains = _ _webpack _require _ _ ( 2 0 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _filter = _ _webpack _require _ _ ( 5 4 ) ; var flip = _ _webpack _require _ _ ( 3 1 ) ; var uniq = _ _webpack _require _ _ ( 6 4 ) ; var intersection = _curry 2 ( function intersection ( list 1 , list 2 ) { var lookup List , filtered List ; if ( list 1 . length > list 2 . length ) { lookup List = list 1 ; filtered List = list 2 ; } else { lookup List = list 2 ; filtered List = list 1 ; } return uniq ( _filter ( flip ( _contains ) ( lookup List ) , filtered List ) ) ; } ) ; module . exports = intersection ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _check For Method = _ _webpack _require _ _ ( 2 3 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var intersperse = _curry 2 ( _check For Method ( 'intersperse ' , function intersperse ( separator , list ) { var out = [ ] ; var idx = 0 ; var length = list . length ; while ( idx < length ) { if ( idx = = = length - 1 ) { out . push ( list [ idx ] ) ; } else { out . push ( list [ idx ] , separator ) ; } idx + = 1 ; } return out ; } ) ) ; module . exports = intersperse ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _clone = _ _webpack _require _ _ ( 2 0 3 ) ; var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var _is Transformer = _ _webpack _require _ _ ( 5 8 ) ; var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var _step Cat = _ _webpack _require _ _ ( 3 2 9 ) ; var into = _curry 3 ( function into ( acc , xf , list ) { return _is Transformer ( acc ) ? _reduce ( xf ( acc ) , acc [ ' @ @transducer /init ' ] ( ) , list ) : _reduce ( xf ( _step Cat ( acc ) ) , _clone ( acc , [ ] , [ ] , false ) , list ) ; } ) ; module . exports = into ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var keys = _ _webpack _require _ _ ( 1 5 ) ; var invert = _curry 1 ( function invert ( obj ) { var props = keys ( obj ) ; var len = props . length ; var idx = 0 ; var out = { } ; while ( idx < len ) { var key = props [ idx ] ; var val = obj [ key ] ; var list = _has ( val , out ) ? out [ val ] : out [ val ] = [ ] ; list [ list . length ] = key ; idx + = 1 ; } return out ; } ) ; module . exports = invert ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var keys = _ _webpack _require _ _ ( 1 5 ) ; var invert Obj = _curry 1 ( function invert Obj ( obj ) { var props = keys ( obj ) ; var len = props . length ; var idx = 0 ; var out = { } ; while ( idx < len ) { var key = props [ idx ] ; out [ obj [ key ] ] = key ; idx + = 1 ; } return out ; } ) ; module . exports = invert Obj ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var empty = _ _webpack _require _ _ ( 2 0 1 ) ; var equals = _ _webpack _require _ _ ( 1 0 ) ; var is Empty = _curry 1 ( function is Empty ( x ) { return x ! = null & & equals ( x , empty ( x ) ) ; } ) ; module . exports = is Empty ; } 
function ( module , exports , _ _webpack _require _ _ ) { var invoker = _ _webpack _require _ _ ( 2 5 ) ; var join = invoker ( 1 , 'join ' ) ; module . exports = join ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var keys In = _curry 1 ( function keys In ( obj ) { var prop ; var ks = [ ] ; for ( prop in obj ) { ks [ ks . length ] = prop ; } return ks ; } ) ; module . exports = keys In ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _is Array = _ _webpack _require _ _ ( 1 7 ) ; var equals = _ _webpack _require _ _ ( 1 0 ) ; var last Index Of = _curry 2 ( function last Index Of ( target , xs ) { if ( typeof xs . last Index Of = = = 'function ' & & ! _is Array ( xs ) ) { return xs . last Index Of ( target ) ; } else { var idx = xs . length - 1 ; while ( idx > = 0 ) { if ( equals ( xs [ idx ] , target ) ) { return idx ; } idx - = 1 ; } return - 1 ; } } ) ; module . exports = last Index Of ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var lens = _ _webpack _require _ _ ( 3 8 ) ; var nth = _ _webpack _require _ _ ( 2 6 ) ; var update = _ _webpack _require _ _ ( 6 5 ) ; var lens Index = _curry 1 ( function lens Index ( n ) { return lens ( nth ( n ) , update ( n ) ) ; } ) ; module . exports = lens Index ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var assoc Path = _ _webpack _require _ _ ( 1 9 0 ) ; var lens = _ _webpack _require _ _ ( 3 8 ) ; var path = _ _webpack _require _ _ ( 2 2 ) ; var lens Path = _curry 1 ( function lens Path ( p ) { return lens ( path ( p ) , assoc Path ( p ) ) ; } ) ; module . exports = lens Path ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var assoc = _ _webpack _require _ _ ( 3 0 ) ; var lens = _ _webpack _require _ _ ( 3 8 ) ; var prop = _ _webpack _require _ _ ( 6 0 ) ; var lens Prop = _curry 1 ( function lens Prop ( k ) { return lens ( prop ( k ) , assoc ( k ) ) ; } ) ; module . exports = lens Prop ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var lt = _curry 2 ( function lt ( a , b ) { return a < b ; } ) ; module . exports = lt ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var lte = _curry 2 ( function lte ( a , b ) { return a < = b ; } ) ; module . exports = lte ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var map Accum = _curry 3 ( function map Accum ( fn , acc , list ) { var idx = 0 ; var len = list . length ; var result = [ ] ; var tuple = [ acc ] ; while ( idx < len ) { tuple = fn ( tuple [ 0 ] , list [ idx ] ) ; result [ idx ] = tuple [ 1 ] ; idx + = 1 ; } return [ tuple [ 0 ] , result ] ; } ) ; module . exports = map Accum ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var map Accum Right = _curry 3 ( function map Accum Right ( fn , acc , list ) { var idx = list . length - 1 ; var result = [ ] ; var tuple = [ acc ] ; while ( idx > = 0 ) { tuple = fn ( list [ idx ] , tuple [ 0 ] ) ; result [ idx ] = tuple [ 1 ] ; idx - = 1 ; } return [ result , tuple [ 0 ] ] ; } ) ; module . exports = map Accum Right ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var keys = _ _webpack _require _ _ ( 1 5 ) ; var map Obj Indexed = _curry 2 ( function map Obj Indexed ( fn , obj ) { return _reduce ( function ( acc , key ) { acc [ key ] = fn ( obj [ key ] , key , obj ) ; return acc ; } , { } , keys ( obj ) ) ; } ) ; module . exports = map Obj Indexed ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var match = _curry 2 ( function match ( rx , str ) { return str . match ( rx ) | | [ ] ; } ) ; module . exports = match ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _is Integer = _ _webpack _require _ _ ( 5 6 ) ; var math Mod = _curry 2 ( function math Mod ( m , p ) { if ( ! _is Integer ( m ) ) { return Na N ; } if ( ! _is Integer ( p ) | | p < 1 ) { return Na N ; } return ( m % p + p ) % p ; } ) ; module . exports = math Mod ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var max By = _curry 3 ( function max By ( f , a , b ) { return f ( b ) > f ( a ) ? b : a ; } ) ; module . exports = max By ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var mean = _ _webpack _require _ _ ( 2 2 0 ) ; var median = _curry 1 ( function median ( list ) { var len = list . length ; if ( len = = = 0 ) { return Na N ; } var width = 2 - len % 2 ; var idx = ( len - width ) / 2 ; return mean ( Array . prototype . slice . call ( list , 0 ) . sort ( function ( a , b ) { return a < b ? - 1 : a > b ? 1 : 0 ; } ) . slice ( idx , idx + width ) ) ; } ) ; module . exports = median ; } 
function ( module , exports , _ _webpack _require _ _ ) { var memoize With = _ _webpack _require _ _ ( 2 2 1 ) ; var to String = _ _webpack _require _ _ ( 2 8 ) ; var memoize = memoize With ( function ( ) { return to String ( arguments ) ; } ) ; module . exports = memoize ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _assign = _ _webpack _require _ _ ( 5 3 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var merge = _curry 2 ( function merge ( l , r ) { return _assign ( { } , l , r ) ; } ) ; module . exports = merge ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _assign = _ _webpack _require _ _ ( 5 3 ) ; var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var merge All = _curry 1 ( function merge All ( list ) { return _assign . apply ( null , [ { } ] . concat ( list ) ) ; } ) ; module . exports = merge All ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var merge Deep With Key = _ _webpack _require _ _ ( 4 0 ) ; var merge Deep Left = _curry 2 ( function merge Deep Left ( l Obj , r Obj ) { return merge Deep With Key ( function ( k , l Val , r Val ) { return l Val ; } , l Obj , r Obj ) ; } ) ; module . exports = merge Deep Left ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var merge Deep With Key = _ _webpack _require _ _ ( 4 0 ) ; var merge Deep Right = _curry 2 ( function merge Deep Right ( l Obj , r Obj ) { return merge Deep With Key ( function ( k , l Val , r Val ) { return r Val ; } , l Obj , r Obj ) ; } ) ; module . exports = merge Deep Right ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var merge Deep With Key = _ _webpack _require _ _ ( 4 0 ) ; var merge Deep With = _curry 3 ( function merge Deep With ( fn , l Obj , r Obj ) { return merge Deep With Key ( function ( k , l Val , r Val ) { return fn ( l Val , r Val ) ; } , l Obj , r Obj ) ; } ) ; module . exports = merge Deep With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var merge With Key = _ _webpack _require _ _ ( 5 9 ) ; var merge With = _curry 3 ( function merge With ( fn , l , r ) { return merge With Key ( function ( _ , _l , _r ) { return fn ( _l , _r ) ; } , l , r ) ; } ) ; module . exports = merge With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var min = _curry 2 ( function min ( a , b ) { return b < a ? b : a ; } ) ; module . exports = min ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var min By = _curry 3 ( function min By ( f , a , b ) { return f ( b ) < f ( a ) ? b : a ; } ) ; module . exports = min By ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var modulo = _curry 2 ( function modulo ( a , b ) { return a % b ; } ) ; module . exports = modulo ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var negate = _curry 1 ( function negate ( n ) { return - n ; } ) ; module . exports = negate ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _complement = _ _webpack _require _ _ ( 2 0 5 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xany = _ _webpack _require _ _ ( 2 1 1 ) ; var any = _ _webpack _require _ _ ( 1 8 8 ) ; var none = _curry 2 ( _complement ( _dispatchable ( [ 'any ' ] , _xany , any ) ) ) ; module . exports = none ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var nth = _ _webpack _require _ _ ( 2 6 ) ; var nth Arg = _curry 1 ( function nth Arg ( n ) { var arity = n < 0 ? 1 : n + 1 ; return curry N ( arity , function ( ) { return nth ( n , arguments ) ; } ) ; } ) ; module . exports = nth Arg ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var o = _curry 3 ( function o ( f , g , x ) { return f ( g ( x ) ) ; } ) ; module . exports = o ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _of = _ _webpack _require _ _ ( 3 2 5 ) ; var of = _curry 1 ( _of ) ; module . exports = of ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var omit = _curry 2 ( function omit ( names , obj ) { var result = { } ; var index = { } ; var idx = 0 ; var len = names . length ; while ( idx < len ) { index [ names [ idx ] ] = 1 ; idx + = 1 ; } for ( var prop in obj ) { if ( ! index . has Own Property ( prop ) ) { result [ prop ] = obj [ prop ] ; } } return result ; } ) ; module . exports = omit ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _arity = _ _webpack _require _ _ ( 1 4 ) ; var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var once = _curry 1 ( function once ( fn ) { var called = false ; var result ; return _arity ( fn . length , function ( ) { if ( called ) { return result ; } called = true ; result = fn . apply ( this , arguments ) ; return result ; } ) ; } ) ; module . exports = once ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var pair = _curry 2 ( function pair ( fst , snd ) { return [ fst , snd ] ; } ) ; module . exports = pair ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _concat = _ _webpack _require _ _ ( 1 2 ) ; var _create Partial Applicator = _ _webpack _require _ _ ( 2 0 6 ) ; var partial = _create Partial Applicator ( _concat ) ; module . exports = partial ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _concat = _ _webpack _require _ _ ( 1 2 ) ; var _create Partial Applicator = _ _webpack _require _ _ ( 2 0 6 ) ; var flip = _ _webpack _require _ _ ( 3 1 ) ; var partial Right = _create Partial Applicator ( flip ( _concat ) ) ; module . exports = partial Right ; } 
function ( module , exports , _ _webpack _require _ _ ) { var filter = _ _webpack _require _ _ ( 5 1 ) ; var juxt = _ _webpack _require _ _ ( 2 1 6 ) ; var reject = _ _webpack _require _ _ ( 4 3 ) ; var partition = juxt ( [ filter , reject ] ) ; module . exports = partition ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var equals = _ _webpack _require _ _ ( 1 0 ) ; var path = _ _webpack _require _ _ ( 2 2 ) ; var path Eq = _curry 3 ( function path Eq ( _path , val , obj ) { return equals ( path ( _path , obj ) , val ) ; } ) ; module . exports = path Eq ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var default To = _ _webpack _require _ _ ( 1 9 5 ) ; var path = _ _webpack _require _ _ ( 2 2 ) ; var path Or = _curry 3 ( function path Or ( d , p , obj ) { return default To ( d , path ( p , obj ) ) ; } ) ; module . exports = path Or ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var path = _ _webpack _require _ _ ( 2 2 ) ; var path Satisfies = _curry 3 ( function path Satisfies ( pred , prop Path , obj ) { return prop Path . length > 0 & & pred ( path ( prop Path , obj ) ) ; } ) ; module . exports = path Satisfies ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var pick = _curry 2 ( function pick ( names , obj ) { var result = { } ; var idx = 0 ; while ( idx < names . length ) { if ( names [ idx ] in obj ) { result [ names [ idx ] ] = obj [ names [ idx ] ] ; } idx + = 1 ; } return result ; } ) ; module . exports = pick ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var pick By = _curry 2 ( function pick By ( test , obj ) { var result = { } ; for ( var prop in obj ) { if ( test ( obj [ prop ] , prop , obj ) ) { result [ prop ] = obj [ prop ] ; } } return result ; } ) ; module . exports = pick By ; } 
function ( module , exports , _ _webpack _require _ _ ) { var compose K = _ _webpack _require _ _ ( 1 9 2 ) ; var reverse = _ _webpack _require _ _ ( 4 4 ) ; function pipe K ( ) { if ( arguments . length = = = 0 ) { throw new Error ( 'pipe K requires at least one argument ' ) ; } return compose K . apply ( this , reverse ( arguments ) ) ; } module . exports = pipe K ; } 
function ( module , exports , _ _webpack _require _ _ ) { var multiply = _ _webpack _require _ _ ( 2 2 2 ) ; var reduce = _ _webpack _require _ _ ( 1 6 ) ; var product = reduce ( multiply , 1 ) ; module . exports = product ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _map = _ _webpack _require _ _ ( 3 7 ) ; var identity = _ _webpack _require _ _ ( 5 2 ) ; var pick All = _ _webpack _require _ _ ( 2 2 7 ) ; var use With = _ _webpack _require _ _ ( 2 3 9 ) ; var project = use With ( _map , [ pick All , identity ] ) ; 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var equals = _ _webpack _require _ _ ( 1 0 ) ; var prop Eq = _curry 3 ( function prop Eq ( name , val , obj ) { return equals ( val , obj [ name ] ) ; } ) ; module . exports = prop Eq ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var is = _ _webpack _require _ _ ( 2 1 4 ) ; var prop Is = _curry 3 ( function prop Is ( type , name , obj ) { return is ( type , obj [ name ] ) ; } ) ; module . exports = prop Is ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var prop Or = _curry 3 ( function prop Or ( val , p , obj ) { return obj ! = null & & _has ( p , obj ) ? obj [ p ] : val ; } ) ; module . exports = prop Or ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var prop Satisfies = _curry 3 ( function prop Satisfies ( pred , name , obj ) { return pred ( obj [ name ] ) ; } ) ; module . exports = prop Satisfies ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var props = _curry 2 ( function props ( ps , obj ) { var len = ps . length ; var out = [ ] ; var idx = 0 ; while ( idx < len ) { out [ idx ] = obj [ ps [ idx ] ] ; idx + = 1 ; } return out ; } ) ; module . exports = props ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _is Number = _ _webpack _require _ _ ( 2 0 9 ) ; var range = _curry 2 ( function range ( from , to ) { if ( ! ( _is Number ( from ) & & _is Number ( to ) ) ) { throw new Type Error ( 'Both arguments to range must be numbers ' ) ; } var result = [ ] ; var n = from ; while ( n < to ) { result . push ( n ) ; n + = 1 ; } return result ; } ) ; module . exports = range ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry N = _ _webpack _require _ _ ( 3 3 ) ; var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var _reduced = _ _webpack _require _ _ ( 1 8 ) ; var reduce While = _curry N ( 4 , [ ] , function _reduce While ( pred , fn , a , list ) { return _reduce ( function ( acc , x ) { return pred ( acc , x ) ? fn ( acc , x ) : _reduced ( acc ) ; } , a , list ) ; } ) ; module . exports = reduce While ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _reduced = _ _webpack _require _ _ ( 1 8 ) ; var reduced = _curry 1 ( _reduced ) ; module . exports = reduced ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var always = _ _webpack _require _ _ ( 1 9 ) ; var times = _ _webpack _require _ _ ( 2 3 6 ) ; var repeat = _curry 2 ( function repeat ( value , n ) { return times ( always ( value ) , n ) ; } ) ; module . exports = repeat ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var replace = _curry 3 ( function replace ( regex , replacement , str ) { return str . replace ( regex , replacement ) ; } ) ; module . exports = replace ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var scan = _curry 3 ( function scan ( fn , acc , list ) { var idx = 0 ; var len = list . length ; var result = [ acc ] ; while ( idx < len ) { acc = fn ( acc , list [ idx ] ) ; result [ idx + 1 ] = acc ; idx + = 1 ; } return result ; } ) ; module . exports = scan ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var always = _ _webpack _require _ _ ( 1 9 ) ; var over = _ _webpack _require _ _ ( 2 2 6 ) ; var set = _curry 3 ( function set ( lens , v , x ) { return over ( lens , always ( v ) , x ) ; } ) ; module . exports = set ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var sort = _curry 2 ( function sort ( comparator , list ) { return Array . prototype . slice . call ( list , 0 ) . sort ( comparator ) ; } ) ; module . exports = sort ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var sort By = _curry 2 ( function sort By ( fn , list ) { return Array . prototype . slice . call ( list , 0 ) . sort ( function ( a , b ) { var aa = fn ( a ) ; var bb = fn ( b ) ; return aa < bb ? - 1 : aa > bb ? 1 : 0 ; } ) ; } ) ; module . exports = sort By ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var sort With = _curry 2 ( function sort With ( fns , list ) { return Array . prototype . slice . call ( list , 0 ) . sort ( function ( a , b ) { var result = 0 ; var i = 0 ; while ( result = = = 0 & & i < fns . length ) { result = fns [ i ] ( a , b ) ; i + = 1 ; } return result ; } ) ; } ) ; module . exports = sort With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var invoker = _ _webpack _require _ _ ( 2 5 ) ; var split = invoker ( 1 , 'split ' ) ; module . exports = split ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var length = _ _webpack _require _ _ ( 2 1 8 ) ; var slice = _ _webpack _require _ _ ( 1 3 ) ; var split At = _curry 2 ( function split At ( index , array ) { return [ slice ( 0 , index , array ) , slice ( index , length ( array ) , array ) ] ; } ) ; module . exports = split At ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var slice = _ _webpack _require _ _ ( 1 3 ) ; var split Every = _curry 2 ( function split Every ( n , list ) { if ( n < = 0 ) { throw new Error ( 'First argument to split Every must be a positive integer ' ) ; } var result = [ ] ; var idx = 0 ; while ( idx < list . length ) { result . push ( slice ( idx , idx + = n , list ) ) ; } return result ; } ) ; module . exports = split Every ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var split When = _curry 2 ( function split When ( pred , list ) { var idx = 0 ; var len = list . length ; var prefix = [ ] ; while ( idx < len & & ! pred ( list [ idx ] ) ) { prefix . push ( list [ idx ] ) ; idx + = 1 ; } return [ prefix , Array . prototype . slice . call ( list , idx ) ] ; } ) ; module . exports = split When ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var equals = _ _webpack _require _ _ ( 1 0 ) ; var take = _ _webpack _require _ _ ( 6 2 ) ; var starts With = _curry 2 ( function ( prefix , list ) { return equals ( take ( prefix . length , list ) , prefix ) ; } ) ; module . exports = starts With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var subtract = _curry 2 ( function subtract ( a , b ) { return Number ( a ) - Number ( b ) ; } ) ; module . exports = subtract ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var concat = _ _webpack _require _ _ ( 4 9 ) ; var difference = _ _webpack _require _ _ ( 1 9 6 ) ; var symmetric Difference = _curry 2 ( function symmetric Difference ( list 1 , list 2 ) { return concat ( difference ( list 1 , list 2 ) , difference ( list 2 , list 1 ) ) ; } ) ; module . exports = symmetric Difference ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var concat = _ _webpack _require _ _ ( 4 9 ) ; var difference With = _ _webpack _require _ _ ( 1 9 7 ) ; var symmetric Difference With = _curry 3 ( function symmetric Difference With ( pred , list 1 , list 2 ) { return concat ( difference With ( pred , list 1 , list 2 ) , difference With ( pred , list 2 , list 1 ) ) ; } ) ; module . exports = symmetric Difference With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var slice = _ _webpack _require _ _ ( 1 3 ) ; var take Last While = _curry 2 ( function take Last While ( fn , xs ) { var idx = xs . length - 1 ; while ( idx > = 0 & & fn ( xs [ idx ] ) ) { idx - = 1 ; } return slice ( idx + 1 , Infinity , xs ) ; } ) ; module . exports = take Last While ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xtake While = _ _webpack _require _ _ ( 3 4 7 ) ; var slice = _ _webpack _require _ _ ( 1 3 ) ; var take While = _curry 2 ( _dispatchable ( [ 'take While ' ] , _xtake While , function take While ( fn , xs ) { var idx = 0 ; var len = xs . length ; while ( idx < len & & fn ( xs [ idx ] ) ) { idx + = 1 ; } return slice ( 0 , idx , xs ) ; } ) ) ; module . exports = take While ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _dispatchable = _ _webpack _require _ _ ( 5 ) ; var _xtap = _ _webpack _require _ _ ( 3 4 8 ) ; var tap = _curry 2 ( _dispatchable ( [ ] , _xtap , function tap ( fn , x ) { fn ( x ) ; return x ; } ) ) ; module . exports = tap ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _clone Reg Exp = _ _webpack _require _ _ ( 2 0 4 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var _is Reg Exp = _ _webpack _require _ _ ( 3 2 3 ) ; var to String = _ _webpack _require _ _ ( 2 8 ) ; var test = _curry 2 ( function test ( pattern , str ) { if ( ! _is Reg Exp ( pattern ) ) { throw new Type Error ( ' ‘test ’ requires a value of type Reg Exp as its first argument ; received ' + t S ring (pat t ern ) ) ; } return _clone Reg Exp ( pattern ) . test ( str ) ; } ) ; module . exports = test ; } 
function ( module , exports , _ _webpack _require _ _ ) { var invoker = _ _webpack _require _ _ ( 2 5 ) ; var to Lower = invoker ( 0 , 'to Lower Case ' ) ; module . exports = to Lower ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var _has = _ _webpack _require _ _ ( 8 ) ; var to Pairs = _curry 1 ( function to Pairs ( obj ) { var pairs = [ ] ; for ( var prop in obj ) { if ( _has ( prop , obj ) ) { pairs [ pairs . length ] = [ prop , obj [ prop ] ] ; } } return pairs ; } ) ; module . exports = to Pairs ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var to Pairs In = _curry 1 ( function to Pairs In ( obj ) { var pairs = [ ] ; for ( var prop in obj ) { pairs [ pairs . length ] = [ prop , obj [ prop ] ] ; } return pairs ; } ) ; module . exports = to Pairs In ; } 
function ( module , exports , _ _webpack _require _ _ ) { var invoker = _ _webpack _require _ _ ( 2 5 ) ; var to Upper = invoker ( 0 , 'to Upper Case ' ) ; module . exports = to Upper ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _reduce = _ _webpack _require _ _ ( 1 1 ) ; var _xwrap = _ _webpack _require _ _ ( 2 1 3 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var transduce = curry N ( 4 , function transduce ( xf , fn , acc , list ) { return _reduce ( xf ( typeof fn = = = 'function ' ? _xwrap ( fn ) : fn ) , acc , list ) ; } ) ; module . exports = transduce ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var transpose = _curry 1 ( function transpose ( outerlist ) { var i = 0 ; var result = [ ] ; while ( i < outerlist . length ) { var innerlist = outerlist [ i ] ; var j = 0 ; while ( j < innerlist . length ) { if ( typeof result [ j ] = = = 'undefined ' ) { result [ j ] = [ ] ; } result [ j ] . push ( innerlist [ j ] ) ; j + = 1 ; } i + = 1 ; } return result ; } ) ; module . exports = transpose ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var map = _ _webpack _require _ _ ( 9 ) ; var sequence = _ _webpack _require _ _ ( 2 3 3 ) ; var traverse = _curry 3 ( function traverse ( of , f , traversable ) { return typeof traversable [ 'fantasy -land /traverse ' ] = = = 'function ' ? traversable [ 'fantasy -land /traverse ' ] ( f , of ) : sequence ( of , map ( f , traversable ) ) ; } ) ; module . exports = traverse ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var ws = ' \x 0 9 \x 0A \x 0B \x 0C \x 0D \x 2 0 \x A 0 \u 1 6 8 0 \u 1 8 0E \u 2 0 0 0 \u 2 0 0 1 \u 2 0 0 2 \u 2 0 0 3 ' + ' \u 2 0 0 4 \u 2 0 0 5 \u 2 0 0 6 \u 2 0 0 7 \u 2 0 0 8 \u 2 0 0 9 \u 2 0 0A \u 2 0 2F \u 2 0 5F \u 3 0 0 0 \u 2 0 2 8 ' + ' \u 2 0 2 9 \u FEFF ' ; var zero Width = ' \u 2 0 0b ' ; var has Proto Trim = typeof String . prototype . trim = = = 'function ' ; var _trim = ! has Proto Trim | | ws . trim ( ) | | ! zero Width . trim ( ) ? function trim ( str ) { var begin Rx = new Reg Exp ( ' ^ [ ' + ws + ' ] [ ' + ws + ' ] * ' ) ; var end Rx = new Reg Exp ( ' [ ' + ws + ' ] [ ' + ws + ' ] * $ ' ) ; return str . replace ( begin Rx , ' ' ) . replace ( end Rx , ' ' ) ; } : function trim ( str ) { return str . trim ( ) ; } ; var trim = _curry 1 ( _trim ) ; module . exports = trim ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _arity = _ _webpack _require _ _ ( 1 4 ) ; var _concat = _ _webpack _require _ _ ( 1 2 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var try Catch = _curry 2 ( function _try Catch ( tryer , catcher ) { return _arity ( tryer . length , function ( ) { try { return tryer . apply ( this , arguments ) ; } catch ( e ) { return catcher . apply ( this , _concat ( [ e ] , arguments ) ) ; } } ) ; } ) ; module . exports = try Catch ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var unapply = _curry 1 ( function unapply ( fn ) { return function ( ) { return fn ( Array . prototype . slice . call ( arguments , 0 ) ) ; } ; } ) ; module . exports = unapply ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var n Ary = _ _webpack _require _ _ ( 4 1 ) ; var unary = _curry 1 ( function unary ( fn ) { return n Ary ( 1 , fn ) ; } ) ; module . exports = unary ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var curry N = _ _webpack _require _ _ ( 7 ) ; var uncurry N = _curry 2 ( function uncurry N ( depth , fn ) { return curry N ( depth , function ( ) { var current Depth = 1 ; var value = fn ; var idx = 0 ; var end Idx ; while ( current Depth < = depth & & typeof value = = = 'function ' ) { end Idx = current Depth = = = depth ? arguments . length : idx + value . length ; value = value . apply ( this , Array . prototype . slice . call ( arguments , idx , end Idx ) ) ; current Depth + = 1 ; idx = end Idx ; } return value ; } ) ; } ) ; module . exports = uncurry N ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var unfold = _curry 2 ( function unfold ( fn , seed ) { var pair = fn ( seed ) ; var result = [ ] ; while ( pair & & pair . length ) { result [ result . length ] = pair [ 0 ] ; pair = fn ( pair [ 1 ] ) ; } return result ; } ) ; module . exports = unfold ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _concat = _ _webpack _require _ _ ( 1 2 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var compose = _ _webpack _require _ _ ( 4 8 ) ; var uniq = _ _webpack _require _ _ ( 6 4 ) ; var union = _curry 2 ( compose ( uniq , _concat ) ) ; module . exports = union ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _concat = _ _webpack _require _ _ ( 1 2 ) ; var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var uniq With = _ _webpack _require _ _ ( 2 3 8 ) ; var union With = _curry 3 ( function union With ( pred , list 1 , list 2 ) { return uniq With ( pred , _concat ( list 1 , list 2 ) ) ; } ) ; module . exports = union With ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var unless = _curry 3 ( function unless ( pred , when False Fn , x ) { return pred ( x ) ? x : when False Fn ( x ) ; } ) ; module . exports = unless ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _identity = _ _webpack _require _ _ ( 5 5 ) ; var chain = _ _webpack _require _ _ ( 4 7 ) ; var unnest = chain ( _identity ) ; module . exports = unnest ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var until = _curry 3 ( function until ( pred , fn , init ) { var val = init ; while ( ! pred ( val ) ) { val = fn ( val ) ; } return val ; } ) ; module . exports = until ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 1 = _ _webpack _require _ _ ( 3 ) ; var values In = _curry 1 ( function values In ( obj ) { var prop ; var vs = [ ] ; for ( prop in obj ) { vs [ vs . length ] = obj [ prop ] ; } return vs ; } ) ; module . exports = values In ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; * Returns a "view " of the given data structure , determined by the given lens . * The lens 's focus determines which portion of the data structure is visible . * * @func * @member Of R * @since v 0 . 1 6 . 0 * @category Object * @typedefn Lens s a = Functor f = > (a - > f a ) - > s - > f s * @sig Lens s a - > s - > a * @param {Lens } lens * @param { * } x * @return { * } * @see R .prop , R .lens Index , R .lens Prop * @example * * var x Lens = R .lens Prop ( 'x ' ) ; * * R .view (x Lens , {x : 1 , y : 2 } ) ; * R .view (x Lens , {x : 4 , y : 2 } ) ; * / var view = _curry 2 ( function view ( lens , x ) { 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var when = _curry 3 ( function when ( pred , when True Fn , x ) { return pred ( x ) ? when True Fn ( x ) : x ; } ) ; module . exports = when ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var equals = _ _webpack _require _ _ ( 1 0 ) ; var map = _ _webpack _require _ _ ( 9 ) ; var where = _ _webpack _require _ _ ( 2 4 1 ) ; var where Eq = _curry 2 ( function where Eq ( spec , test Obj ) { return where ( map ( equals , spec ) , test Obj ) ; } ) ; module . exports = where Eq ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _contains = _ _webpack _require _ _ ( 2 0 ) ; var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var flip = _ _webpack _require _ _ ( 3 1 ) ; var reject = _ _webpack _require _ _ ( 4 3 ) ; var without = _curry 2 ( function ( xs , list ) { return reject ( flip ( _contains ) ( xs ) , list ) ; } ) ; module . exports = without ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var xprod = _curry 2 ( function xprod ( a , b ) { 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var zip = _curry 2 ( function zip ( a , b ) { var rv = [ ] ; var idx = 0 ; var len = Math . min ( a . length , b . length ) ; while ( idx < len ) { rv [ idx ] = [ a [ idx ] , b [ idx ] ] ; idx + = 1 ; } return rv ; } ) ; module . exports = zip ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 2 = _ _webpack _require _ _ ( 1 ) ; var zip Obj = _curry 2 ( function zip Obj ( keys , values ) { var idx = 0 ; var len = Math . min ( keys . length , values . length ) ; var out = { } ; while ( idx < len ) { out [ keys [ idx ] ] = values [ idx ] ; idx + = 1 ; } return out ; } ) ; module . exports = zip Obj ; } 
function ( module , exports , _ _webpack _require _ _ ) { var _curry 3 = _ _webpack _require _ _ ( 4 ) ; var zip With = _curry 3 ( function zip With ( fn , a , b ) { var rv = [ ] ; var idx = 0 ; var len = Math . min ( a . length , b . length ) ; while ( idx < len ) { rv [ idx ] = fn ( a [ idx ] , b [ idx ] ) ; idx + = 1 ; } return rv ; } ) ; module . exports = zip With ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; function check DCE ( ) { if ( typeof _ _REACT _DEVTOOLS _GLOBAL _HOOK _ _ = = = 'undefined ' | | typeof _ _REACT _DEVTOOLS _GLOBAL _HOOK _ _ . check DCE ! = = 'function ' ) { return ; } if ( false ) { 
function ( module , exports , _ _webpack _require _ _ ) { if ( typeof Promise = = = 'undefined ' ) { 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _create Class = function ( ) { function define Properties ( target , props ) { for ( var i = 0 ; i < props . length ; i + + ) { var descriptor = props [ i ] ; descriptor . enumerable = descriptor . enumerable | | false ; descriptor . configurable = true ; if ( "value " in descriptor ) descriptor . writable = true ; Object . define Property ( target , descriptor . key , descriptor ) ; } } return function ( Constructor , proto Props , static Props ) { if ( proto Props ) define Properties ( Constructor . prototype , proto Props ) ; if ( static Props ) define Properties ( Constructor , static Props ) ; return Constructor ; } ; } ( ) ; var _react = _ _webpack _require _ _ ( 2 4 3 ) ; var _react 2 = _interop Require Default ( _react ) ; var _react Dom = _ _webpack _require _ _ ( 4 5 5 ) ; var _react Dom 2 = _interop Require Default ( _react Dom ) ; var _react Calendar Multiday = _ _webpack _require _ _ ( 4 5 3 ) ; var _react Calendar Multiday 2 = _interop Require Default ( _react Calendar Multiday ) ; _ _webpack _require _ _ ( 4 5 9 ) ; var _moment = _ _webpack _require _ _ ( 2 ) ; var _moment 2 = _interop Require Default ( _moment ) ; var _ramda = _ _webpack _require _ _ ( 3 0 7 ) ; function _interop Require Default ( obj ) { return obj & & obj . _ _es Module ? obj : { default : obj } ; } function _class Call Check ( instance , Constructor ) { if ( ! ( instance instanceof Constructor ) ) { throw new Type Error ( "Cannot call a class as a function " ) ; } } function _possible Constructor Return ( self , call ) { if ( ! self ) { throw new Reference Error ( "this hasn 't been initialised - super ( ) hasn 't been called " ) ; } return call & & ( typeof call = = = "object " | | typeof call = = = "function " ) ? call : self ; } function _inherits ( sub Class , super Class ) { if ( typeof super Class ! = = "function " & & super Class ! = = null ) { throw new Type Error ( "Super expression must either be null or a function , not " + typeof super Class ) ; } sub Class . prototype = Object . create ( super Class & & super Class . prototype , { constructor : { value : sub Class , enumerable : false , writable : true , configurable : true } } ) ; if ( super Class ) Object . set Prototype Of ? Object . set Prototype Of ( sub Class , super Class ) : sub Class . _ _proto _ _ = super Class ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var Promise = _ _webpack _require _ _ ( 2 4 2 ) ; var DEFAULT _WHITELIST = [ Reference Error , Type Error , Range Error ] ; var enabled = false ; exports . disable = disable ; function disable ( ) { enabled = false ; Promise . _ 1 0 = null ; Promise . _ 9 7 = null ; } exports . enable = enable ; function enable ( options ) { options = options | | { } ; if ( enabled ) disable ( ) ; enabled = true ; var id = 0 ; var display Id = 0 ; var rejections = { } ; Promise . _ 1 0 = function ( promise ) { if ( promise . _ 8 1 = = = 2 & & 
function ( layer ) { return { type : 'rectangle ' , north East : { lat : layer . get Bounds ( ) . _north East . lat , lng : layer . get Bounds ( ) . _north East . lng , } , south West : { lat : layer . get Bounds ( ) . _south West . lat , lng : layer . get Bounds ( ) . _south West . lng , } } ; } 
function ( filter ) { this . _start Lat Lng = filter . north East ; var shape = new L . Rectangle ( new L . Lat Lng Bounds ( this . _start Lat Lng , filter . south West ) , this . options . shape Options ) ; return { type : 'rectangle ' , 'layer ' : shape } ; } 
function ( t ) { 
function ( t , e ) { 
function delaunay Refine ( points , triangulation ) { var stack = [ ] var num Points = points . length var stars = triangulation . stars for ( var a = 0 ; a < num Points ; + + a ) { var star = stars [ a ] for ( var j = 1 ; j < star . length ; j + = 2 ) { var b = star [ j ] 
function Partial Hull ( a , b , idx , lower Ids , upper Ids ) { this . a = a this . b = b this . idx = idx this . lower Ids = lower Ids this . upper Ids = upper Ids } 
function Event ( a , b , type , idx ) { this . a = a this . b = b this . type = type this . idx = idx } 
function compare Event ( a , b ) { var d = ( a . a [ 0 ] - b . a [ 0 ] ) | | ( a . a [ 1 ] - b . a [ 1 ] ) | | ( a . type - b . type ) if ( d ) { return d } if ( a . type ! = = EVENT _POINT ) { d = orient ( a . a , a . b , b . b ) if ( d ) { return d } } return a . idx - b . idx } 
function ( filter ) { 
function ( filter , options ) { 
function ( layer ) { var center = layer . get Lat Lng ( ) ; var radius = layer . get Radius ( ) ; return { type : 'circle ' , center : center , radius : radius } ; } 
function ( filter ) { 
function show Validation ( feedback ) { feedback . errors . for Each ( function ( error ) { console . log ( 'ERROR : ' + error ) ; } ) ; feedback . warnings . for Each ( function ( warning ) { console . log ( 'WARNING : ' + warning ) ; } ) ; console . log ( "Validator finished with " + feedback . warnings . length + " warnings and " + feedback . errors . length + " errors . " ) ; process . exit ( feedback . errors . length > 0 ? 2 : 0 ) ; } 
function ( code Lines , h , line No ) { while ( ( code Lines . height ( ) - h ) < = 0 ) { if ( line No = = opts . selected Line ) code Lines . append ( " <div class = 'lineno lineselect ' > " + line No + " < /div > " ) ; else code Lines . append ( " <div class = 'lineno ' > " + line No + " < /div > " ) ; line No + + ; } return line No ; } 
function ( input , prefix ) { _ . for Own ( input , function ( value , key ) { if ( ( / [ ^ \w - ] / ) . test ( key ) ) { console . warn ( key + ' : the key format is not valid ' ) ; } if ( _ . is Plain Object ( value ) ) { return recursion ( value , prefix ? [ prefix , key ] . join ( ' _ ' ) : key ) ; } result [ ( prefix ? [ null , prefix , key ] : [ null , key ] ) . join ( ' _ ' ) ] = _ . is Finite ( value ) ? value : _ . truncate ( _ . to String ( value ) , { length : 3 2 7 6 5 } ) ; 
function Location Hashbang Url ( app Base , hash Prefix ) { var app Base No File = strip File ( app Base ) ; parse Absolute Url ( app Base , this , app Base ) ; this . $ $parse = function ( url ) { var without Base Url = begins With ( app Base , url ) | | begins With ( app Base No File , url ) ; var without Hash Url = without Base Url . char At ( 0 ) = = ' # ' ? begins With ( hash Prefix , without Base Url ) : ( this . $ $html 5 ) ? without Base Url : ' ' ; if ( ! is String ( without Hash Url ) ) { throw $location Min Err ( 'ihshprfx ' , 'Invalid url " { 0 } " , missing hash prefix " { 1 } " . ' , url , hash Prefix ) ; } parse App Url ( without Hash Url , this , app Base ) ; this . $ $path = remove Windows Drive Name ( this . $ $path , without Hash Url , app Base ) ; this . $ $compose ( ) ; function remove Windows Drive Name ( path , url , base ) { var windows File Path Exp = / ^ \ / [A -Z ] : ( \ / . * ) / ; var first Path Segment Match ; * Compose hashbang url and update `abs Url ` property * @private * / this . $ $compose = function ( ) { var search = to Key Value ( this . $ $search ) , hash = this . $ $hash ? ' # ' + encode Uri Segment ( this . $ $hash ) : ' ' ; this . $ $url = encode Path ( this . $ $path ) + ( search ? ' ? ' + search : ' ' ) + hash ; this . $ $abs Url = app Base + ( this . $ $url ? hash Prefix + this . $ $url : ' ' ) ; } ; this . $ $rewrite = function ( url ) { if ( strip Hash ( app Base ) = = strip Hash ( url ) ) { return url ; } } ; } 
function ( search , param Value ) { switch ( arguments . length ) { case 0 : return this . $ $search ; case 1 : if ( is String ( search ) ) { this . $ $search = parse Key Value ( search ) ; } else if ( is Object ( search ) ) { 
function $Location Provider ( ) { var hash Prefix = ' ' , html 5Mode = false ; this . hash Prefix = function ( prefix ) { if ( is Defined ( prefix ) ) { hash Prefix = prefix ; return this ; } else { return hash Prefix ; } } ; this . html 5Mode = function ( mode ) { if ( is Defined ( mode ) ) { html 5Mode = mode ; return this ; } else { return html 5Mode ; } } ; this . $get = [ ' $root Scope ' , ' $browser ' , ' $sniffer ' , ' $root Element ' , function ( $root Scope , $browser , $sniffer , $root Element ) { var $location , Location Mode , base Href = $browser . base Href ( ) , 
function csp Safe Getter Fn ( key 0 , key 1 , key 2 , key 3 , key 4 , full Exp ) { ensure Safe Member Name ( key 0 , full Exp ) ; ensure Safe Member Name ( key 1 , full Exp ) ; ensure Safe Member Name ( key 2 , full Exp ) ; ensure Safe Member Name ( key 3 , full Exp ) ; ensure Safe Member Name ( key 4 , full Exp ) ; return function csp Safe Getter ( scope , locals ) { var path Val = ( locals & & locals . has Own Property ( key 0 ) ) ? locals : scope ; if ( path Val = = null ) return path Val ; path Val = path Val [ key 0 ] ; if ( ! key 1 ) return path Val ; if ( path Val = = null ) return undefined ; path Val = path Val [ key 1 ] ; if ( ! key 2 ) return path Val ; if ( path Val = = null ) return undefined ; path Val = path Val [ key 2 ] ; if ( ! key 3 ) return path Val ; if ( path Val = = null ) return undefined ; path Val = path Val [ key 3 ] ; if ( ! key 4 ) return path Val ; if ( path Val = = null ) return undefined ; path Val = path Val [ key 4 ] ; return path Val ; } ; } 
function $Parse Provider ( ) { var cache = { } ; var $parse Options = { csp : false } ; this . $get = [ ' $filter ' , ' $sniffer ' , function ( $filter , $sniffer ) { $parse Options . csp = $sniffer . csp ; return function ( exp , interceptor Fn ) { var parsed Expression , one Time , cache Key = ( exp = trim ( exp ) ) ; switch ( typeof exp ) { case 'string ' : if ( cache . has Own Property ( cache Key ) ) { parsed Expression = cache [ cache Key ] ; } else { if ( exp . char At ( 0 ) = = = ' : ' & & exp . char At ( 1 ) = = = ' : ' ) { one Time = true ; exp = exp . substring ( 2 ) ; } var lexer = new Lexer ( $parse Options ) ; var parser = new Parser ( lexer , $filter , $parse Options ) ; parsed Expression = parser . parse ( exp ) ; if ( parsed Expression . constant ) parsed Expression . $ $watch Delegate = constant Watch ; else if ( one Time ) parsed Expression . $ $watch Delegate = one Time Watch ; if ( cache Key ! = = 'has Own Property ' ) { 
function get First Anchor ( list ) { var result = null ; for Each ( list , function ( element ) { if ( ! result & & node Name _ ( element ) = = = 'a ' ) result = element ; } ) ; return result ; } 
function apply Directives To Node ( directives , compile Node , template Attrs , transclude Fn , jq Collection , original Replace Directive , pre Link Fns , post Link Fns , previous Compile Context ) { previous Compile Context = previous Compile Context | | { } ; var terminal Priority = - Number . MAX _VALUE , new Scope Directive , controller Directives = previous Compile Context . controller Directives , new Isolate Scope Directive = previous Compile Context . new Isolate Scope Directive , template Directive = previous Compile Context . template Directive , non Tlb Transclude Directive = previous Compile Context . non Tlb Transclude Directive , has Transclude Directive = false , has Template = false , has Element Transclude Directive = previous Compile Context . has Element Transclude Directive , $compile Node = template Attrs . $ $element = jq Lite ( compile Node ) , directive , directive Name , $template , replace Directive = original Replace Directive , child Transclude Fn = transclude Fn , link Fn , directive Value ; 
function shallow Copy ( src , dst ) { var i = 0 ; if ( is Array ( src ) ) { dst = dst | | [ ] ; for ( ; i < src . length ; i + + ) { dst [ i ] = src [ i ] ; } } else if ( is Object ( src ) ) { dst = dst | | { } ; var keys = Object . keys ( src ) ; for ( var l = keys . length ; i < l ; i + + ) { var key = keys [ i ] ; if ( ! ( key . char At ( 0 ) = = = ' $ ' & & key . char At ( 1 ) = = = ' $ ' ) ) { dst [ key ] = src [ key ] ; } } } return dst | | src ; } 
function bootstrap ( element , modules , config ) { if ( ! is Object ( config ) ) config = { } ; var default Config = { strict Di : false } ; config = extend ( default Config , config ) ; var do Bootstrap = function ( ) { element = jq Lite ( element ) ; if ( element . injector ( ) ) { var tag = ( element [ 0 ] = = = document ) ? 'document ' : starting Tag ( element ) ; throw ng Min Err ( 'btstrpd ' , "App Already Bootstrapped with this Element ' { 0 } ' " , tag ) ; } modules = modules | | [ ] ; modules . unshift ( [ ' $provide ' , function ( $provide ) { $provide . value ( ' $root Element ' , element ) ; } ] ) ; modules . unshift ( 'ng ' ) ; var injector = create Injector ( modules , config . strict Di ) ; injector . invoke ( [ ' $root Scope ' , ' $root Element ' , ' $compile ' , ' $injector ' , function ( scope , element , compile , injector ) { scope . $apply ( function ( ) { element . data ( ' $injector ' , injector ) ; compile ( element ) ( scope ) ; } ) ; } ] ) ; return injector ; } ; var NG _DEFER _BOOTSTRAP = / ^NG _DEFER _BOOTSTRAP ! / ; if ( window & & ! NG _DEFER _BOOTSTRAP . test ( window . name ) ) { return do Bootstrap ( ) ; } window . name = window . name . replace ( NG _DEFER _BOOTSTRAP , ' ' ) ; angular . resume Bootstrap = function ( extra Modules ) { for Each ( extra Modules , function ( module ) { modules . push ( module ) ; } ) ; do Bootstrap ( ) ; } ; } 
function push ( ) { var name , value , browser Cookies , updated ; 
function make Swipe Directive ( directive Name , direction ) { ng Mobile . directive ( directive Name , [ ' $parse ' , function ( $parse ) { 
function limit To Filter ( ) { return function ( input , limit ) { if ( ! is Array ( input ) & & ! is String ( input ) ) return input ; if ( Math . abs ( Number ( limit ) ) = = = Infinity ) { limit = Number ( limit ) ; } else { limit = int ( limit ) ; } if ( is String ( input ) ) { 
function $Sniffer Provider ( ) { this . $get = [ ' $window ' , ' $document ' , function ( $window , $document ) { var event Support = { } , android = int ( ( / android ( \d + ) / . exec ( lowercase ( ( $window . navigator | | { } ) . user Agent ) ) | | [ ] ) [ 1 ] ) , boxee = / Boxee / i . test ( ( $window . navigator | | { } ) . user Agent ) , document = $document [ 0 ] | | { } , document Mode = document . document Mode , vendor Prefix , vendor Regex = / ^ (Moz |webkit |O |ms ) ( ? = [A -Z ] ) / , body Style = document . body & & document . body . style , transitions = false , animations = false , match ; if ( body Style ) { for ( var prop in body Style ) { if ( match = vendor Regex . exec ( prop ) ) { vendor Prefix = match [ 0 ] ; vendor Prefix = vendor Prefix . substr ( 0 , 1 ) . to Upper Case ( ) + vendor Prefix . substr ( 1 ) ; break ; } } if ( ! vendor Prefix ) { vendor Prefix = ( 'Webkit Opacity ' in body Style ) & & 'webkit ' ; } transitions = ! ! ( ( 'transition ' in body Style ) | | ( vendor Prefix + 'Transition ' in body Style ) ) ; animations = ! ! ( ( 'animation ' in body Style ) | | ( vendor Prefix + 'Animation ' in body Style ) ) ; if ( android & & ( ! transitions | | ! animations ) ) { transitions = is String ( document . body . style . webkit Transition ) ; animations = is String ( document . body . style . webkit Animation ) ; } } return { 
function ( ) { var pending = [ ] , value , deferred ; deferred = { resolve : function ( val ) { if ( pending ) { var callbacks = pending ; pending = undefined ; value = ref ( val ) ; if ( callbacks . length ) { next Tick ( function ( ) { var callback ; for ( var i = 0 , ii = callbacks . length ; i < ii ; i + + ) { callback = callbacks [ i ] ; value . then ( callback [ 0 ] , callback [ 1 ] , callback [ 2 ] ) ; } } ) ; } } } , reject : function ( reason ) { deferred . resolve ( create Internal Rejected Promise ( reason ) ) ; } , notify : function ( progress ) { if ( pending ) { var callbacks = pending ; if ( pending . length ) { next Tick ( function ( ) { var callback ; for ( var i = 0 , ii = callbacks . length ; i < ii ; i + + ) { callback = callbacks [ i ] ; callback [ 2 ] ( progress ) ; } } ) ; } } } , promise : { then : function ( callback , errback , progressback ) { var result = defer ( ) ; var wrapped Callback = function ( value ) { try { result . resolve ( ( is Function ( callback ) ? callback : default Callback ) ( value ) ) ; } catch ( e ) { result . reject ( e ) ; exception Handler ( e ) ; } } ; var wrapped Errback = function ( reason ) { try { result . resolve ( ( is Function ( errback ) ? errback : default Errback ) ( reason ) ) ; } catch ( e ) { result . reject ( e ) ; exception Handler ( e ) ; } } ; var wrapped Progressback = function ( progress ) { try { result . notify ( ( is Function ( progressback ) ? progressback : default Callback ) ( progress ) ) ; } catch ( e ) { exception Handler ( e ) ; } } ; if ( pending ) { pending . push ( [ wrapped Callback , wrapped Errback , wrapped Progressback ] ) ; } else { value . then ( wrapped Callback , wrapped Errback , wrapped Progressback ) ; } return result . promise ; } , "catch " : function ( callback ) { return this . then ( null , callback ) ; } , "finally " : function ( callback ) { function make Promise ( value , resolved ) { var result = defer ( ) ; if ( resolved ) { result . resolve ( value ) ; } else { result . reject ( value ) ; } return result . promise ; } function handle Callback ( value , is Resolved ) { var callback Output = null ; try { callback Output = ( callback | | default Callback ) ( ) ; } catch ( e ) { return make Promise ( e , false ) ; } if ( is Promise Like ( callback Output ) ) { return callback Output . then ( function ( ) { return make Promise ( value , is Resolved ) ; } , function ( error ) { return make Promise ( error , false ) ; } ) ; } else { return make Promise ( value , is Resolved ) ; } } return this . then ( function ( value ) { return handle Callback ( value , true ) ; } , function ( error ) { return handle Callback ( error , false ) ; } ) ; } } } ; return deferred ; } 
function validate ( ctrl , validator Name , validity , value ) { ctrl . $set Validity ( validator Name , validity ) ; return validity ? value : undefined ; } 
function add Native Html 5Validators ( ctrl , validator Name , bad Flags , ignore Flags , validity ) { if ( is Object ( validity ) ) { ctrl . $ $has Native Validators = true ; var validator = function ( value ) { 
function ( ) { return { restrict : 'A ' , require : [ 'ng Model ' , ' ^ ?form ' , ' ^ ?ng Model Options ' ] , controller : Ng Model Controller , link : { pre : function ( scope , element , attr , ctrls ) { 
function ( ) { return { restrict : 'A ' , require : 'ng Model ' , link : function ( scope , element , attr , ctrl ) { 
function $Root Scope Provider ( ) { var TTL = 1 0 ; var $root Scope Min Err = min Err ( ' $root Scope ' ) ; var last Dirty Watch = null ; this . digest Ttl = function ( value ) { if ( arguments . length ) { TTL = value ; } return TTL ; } ; this . $get = [ ' $injector ' , ' $exception Handler ' , ' $parse ' , ' $browser ' , function ( $injector , $exception Handler , $parse , $browser ) { function Scope ( ) { this . $id = next Uid ( ) ; this . $ $phase = this . $parent = this . $ $watchers = this . $ $next Sibling = this . $ $prev Sibling = this . $ $child Head = this . $ $child Tail = null ; this [ 'this ' ] = this . $root = this ; this . $ $destroyed = false ; this . $ $async Queue = [ ] ; this . $ $post Digest Queue = [ ] ; this . $ $listeners = { } ; this . $ $listener Count = { } ; this . $ $isolate Bindings = { } ; } Scope . prototype = { constructor : Scope , $new : function ( isolate ) { var Child Scope , child ; if ( isolate ) { child = new Scope ( ) ; child . $root = this . $root ; * @ngdoc method * @name $root Scope .Scope # $watch * @kind function * * @description * Registers a `listener ` callback to be executed whenever the `watch Expression ` changes . * * - The `watch Expression ` is called on every call to { @link ng . $root Scope .Scope # $digest * $digest ( ) } and should return the value that will be watched . (Since * { @link ng . $root Scope .Scope # $digest $digest ( ) } reruns when it detects changes the * `watch Expression ` can execute multiple times per * { @link ng . $root Scope .Scope # $digest $digest ( ) } and should be idempotent . ) * - The `listener ` is called only when the value from the current `watch Expression ` and the * previous call to `watch Expression ` are not equal (with the exception of the initial run , * see below ) . Inequality is determined according to reference inequality , * [strict comparison ] (https : * via the ` ! = = ` Javascript operator , unless `object Equality = = true ` * (see next point ) * - When `object Equality = = true ` , inequality of the `watch Expression ` is determined * according to the { @link angular .equals } function . To save the value of the object for * later comparison , the { @link angular .copy } function is used . This therefore means that * watching complex objects will have adverse memory and performance implications . * - The watch `listener ` may change the model , which may trigger other `listener `s to fire . * This is achieved by rerunning the watchers until no changes are detected . The rerun * iteration limit is 1 0 to prevent an infinite loop deadlock . * * * If you want to be notified whenever { @link ng . $root Scope .Scope # $digest $digest } is called , * you can register a `watch Expression ` function with no `listener ` . (Since `watch Expression ` * can execute multiple times per { @link ng . $root Scope .Scope # $digest $digest } cycle when a * change is detected , be prepared for multiple calls to your listener . ) * * After a watcher is registered with the scope , the `listener ` fn is called asynchronously * (via { @link ng . $root Scope .Scope # $eval Async $eval Async } ) to initialize the * watcher . In rare cases , this is undesirable because the listener is called when the result * of `watch Expression ` didn 't change . To detect this scenario within the `listener ` fn , you * can compare the `new Val ` and `old Val ` . If these two values are identical ( ` = = = ` ) then the * listener was called due to initialization . * * * * # Example * ` ` `js / / let 's assume that scope was dependency injected as the $root Scope var scope = $root Scope ; scope .name = 'misko ' ; scope .counter = 0 ; expect (scope .counter ) .to Equal ( 0 ) ; scope . $watch ( 'name ' , function (new Value , old Value ) { scope .counter = scope .counter + 1 ; } ) ; expect (scope .counter ) .to Equal ( 0 ) ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 1 ) ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 1 ) ; scope .name = 'adam ' ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 2 ) ; var food ; scope .food Counter = 0 ; expect (scope .food Counter ) .to Equal ( 0 ) ; scope . $watch ( function ( ) { return food ; } , function (new Value , old Value ) { if ( new Value ! = = old Value ) { scope .food Counter = scope .food Counter + 1 ; } } ) ; expect (scope .food Counter ) .to Equal ( 0 ) ; scope . $digest ( ) ; expect (scope .food Counter ) .to Equal ( 0 ) ; food = 'cheeseburger ' ; scope . $digest ( ) ; expect (scope .food Counter ) .to Equal ( 1 ) ; * ` ` ` * * * * @param { (function ( ) |string ) } watch Expression Expression that is evaluated on each * { @link ng . $root Scope .Scope # $digest $digest } cycle . A change in the return value triggers * a call to the `listener ` . * * - `string ` : Evaluated as { @link guide /expression expression } * - `function (scope ) ` : called with current `scope ` as a parameter . * @param {function (new Val , old Val , scope ) } listener Callback called whenever the value * of `watch Expression ` changes . * * - `new Val ` contains the current value of the `watch Expression ` * - `old Val ` contains the previous value of the `watch Expression ` * - `scope ` refers to the current scope * @param {boolean = } object Equality Compare for object equality using { @link angular .equals } instead of * comparing for reference equality . * @param {function ( ) = } deregister Notifier Function to call when the deregistration function * get called . * @returns {function ( ) } Returns a deregistration function for this listener . * / $watch : function ( watch Exp , listener , object Equality , deregister Notifier ) { var get = compile To Fn ( watch Exp , 'watch ' ) ; if ( get . $ $watch Delegate ) { return get . $ $watch Delegate ( this , listener , object Equality , deregister Notifier , get ) ; } var scope = this , array = scope . $ $watchers , watcher = { fn : listener , last : init Watch Val , get : get , exp : watch Exp , eq : ! ! object Equality } ; last Dirty Watch = null ; if ( ! is Function ( listener ) ) { watcher . fn = noop ; } if ( ! array ) { array = scope . $ $watchers = [ ] ; } * @ngdoc method * @name $root Scope .Scope # $watch Group * @kind function * * @description * A variant of { @link ng . $root Scope .Scope # $watch $watch ( ) } where it watches an array of `watch Expressions ` . * If any one expression in the collection changes the `listener ` is executed . * * - The items in the `watch Expressions ` array are observed via standard $watch operation and are examined on every * call to $digest ( ) to see if any items changes . * - The `listener ` is called whenever any expression in the `watch Expressions ` array changes . * * @param {Array . <string |Function (scope ) > } watch Expressions Array of expressions that will be individually * watched using { @link ng . $root Scope .Scope # $watch $watch ( ) } * * @param {function (new Values , old Values , scope ) } listener Callback called whenever the return value of any * expression in `watch Expressions ` changes * The `new Values ` array contains the current values of the `watch Expressions ` , with the indexes matching * those of `watch Expression ` * and the `old Values ` array contains the previous values of the `watch Expressions ` , with the indexes matching * those of `watch Expression ` * The `scope ` refers to the current scope . * @returns {function ( ) } Returns a de -registration function for all listeners . * / $watch Group : function ( watch Expressions , listener ) { var old Values = new Array ( watch Expressions . length ) ; var new Values = new Array ( watch Expressions . length ) ; var deregister Fns = [ ] ; var change Count = 0 ; var self = this ; var master Unwatch ; if ( watch Expressions . length = = = 1 ) { * @ngdoc method * @name $root Scope .Scope # $watch Collection * @kind function * * @description * Shallow watches the properties of an object and fires whenever any of the properties change * (for arrays , this implies watching the array items ; for object maps , this implies watching * the properties ) . If a change is detected , the `listener ` callback is fired . * * - The `obj ` collection is observed via standard $watch operation and is examined on every * call to $digest ( ) to see if any items have been added , removed , or moved . * - The `listener ` is called whenever anything within the `obj ` has changed . Examples include * adding , removing , and moving items belonging to an object or array . * * * # Example * ` ` `js $scope .names = [ 'igor ' , 'matias ' , 'misko ' , 'james ' ] ; $scope .data Count = 4 ; $scope . $watch Collection ( 'names ' , function (new Names , old Names ) { $scope .data Count = new Names .length ; } ) ; expect ( $scope .data Count ) .to Equal ( 4 ) ; $scope . $digest ( ) ; expect ( $scope .data Count ) .to Equal ( 4 ) ; $scope .names .pop ( ) ; $scope . $digest ( ) ; expect ( $scope .data Count ) .to Equal ( 3 ) ; * ` ` ` * * * @param {string |function (scope ) } obj Evaluated as { @link guide /expression expression } . The * expression value should evaluate to an object or an array which is observed on each * { @link ng . $root Scope .Scope # $digest $digest } cycle . Any shallow change within the * collection will trigger a call to the `listener ` . * * @param {function (new Collection , old Collection , scope ) } listener a callback function called * when a change is detected . * - The `new Collection ` object is the newly modified data obtained from the `obj ` expression * - The `old Collection ` object is a copy of the former collection data . * Due to performance considerations , the `old Collection ` value is computed only if the * `listener ` function declares two or more arguments . * - The `scope ` argument refers to the current scope . * * @returns {function ( ) } Returns a de -registration function for this listener . When the * de -registration function is executed , the internal watch operation is terminated . * / $watch Collection : function ( obj , listener ) { var self = this ; * @ngdoc method * @name $root Scope .Scope # $digest * @kind function * * @description * Processes all of the { @link ng . $root Scope .Scope # $watch watchers } of the current scope and * its children . Because a { @link ng . $root Scope .Scope # $watch watcher } 's listener can change * the model , the ` $digest ( ) ` keeps calling the { @link ng . $root Scope .Scope # $watch watchers } * until no more listeners are firing . This means that it is possible to get into an infinite * loop . This function will throw ` 'Maximum iteration limit exceeded . ' ` if the number of * iterations exceeds 1 0 . * * Usually , you don 't call ` $digest ( ) ` directly in * { @link ng .directive :ng Controller controllers } or in * { @link ng . $compile Provider #directive directives } . * Instead , you should call { @link ng . $root Scope .Scope # $apply $apply ( ) } (typically from within * a { @link ng . $compile Provider #directive directive } ) , which will force a ` $digest ( ) ` . * * If you want to be notified whenever ` $digest ( ) ` is called , * you can register a `watch Expression ` function with * { @link ng . $root Scope .Scope # $watch $watch ( ) } with no `listener ` . * * In unit tests , you may need to call ` $digest ( ) ` to simulate the scope life cycle . * * # Example * ` ` `js var scope = . . . ; scope .name = 'misko ' ; scope .counter = 0 ; expect (scope .counter ) .to Equal ( 0 ) ; scope . $watch ( 'name ' , function (new Value , old Value ) { scope .counter = scope .counter + 1 ; } ) ; expect (scope .counter ) .to Equal ( 0 ) ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 1 ) ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 1 ) ; scope .name = 'adam ' ; scope . $digest ( ) ; expect (scope .counter ) .to Equal ( 2 ) ; * ` ` ` * * / $digest : function ( ) { var watch , value , last , watchers , async Queue = this . $ $async Queue , post Digest Queue = this . $ $post Digest Queue , length , dirty , ttl = TTL , next , current , target = this , watch Log = [ ] , log Idx , log Msg , async Task ; begin Phase ( ' $digest ' ) ; last Dirty Watch = null ; do { * @ngdoc event * @name $root Scope .Scope # $destroy * @event Type broadcast on scope being destroyed * * @description * Broadcasted when a scope and its children are being destroyed . * * Note that , in Angular JS , there is also a ` $destroy ` j Query event , which can be used to * clean up DOM bindings before an element is removed from the DOM . * / $destroy : function ( ) { * @ngdoc method * @name $root Scope .Scope # $eval * @kind function * * @description * Executes the `expression ` on the current scope and returns the result . Any exceptions in * the expression are propagated (uncaught ) . This is useful when evaluating Angular * expressions . * * # Example * ` ` `js var scope = ng . $root Scope .Scope ( ) ; scope .a = 1 ; scope .b = 2 ; expect (scope . $eval ( 'a +b ' ) ) .to Equal ( 3 ) ; expect (scope . $eval (function (scope ) { return scope .a + scope .b ; } ) ) .to Equal ( 3 ) ; * ` ` ` * * @param { (string |function ( ) ) = } expression An angular expression to be executed . * * - `string ` : execute using the rules as defined in { @link guide /expression expression } . * - `function (scope ) ` : execute the function with the current `scope ` parameter . * * @param { (object ) = } locals Local variables object , useful for overriding values in scope . * @returns { * } The result of evaluating the expression . * / $eval : function ( expr , locals ) { return $parse ( expr ) ( this , locals ) ; } , $eval Async : function ( expr ) { * @ngdoc method * @name $root Scope .Scope # $apply * @kind function * * @description * ` $apply ( ) ` is used to execute an expression in angular from outside of the angular * framework . (For example from browser DOM events , set Timeout , XHR or third party libraries ) . * Because we are calling into the angular framework we need to perform proper scope life * cycle of { @link ng . $exception Handler exception handling } , * { @link ng . $root Scope .Scope # $digest executing watches } . * * # # Life cycle * * # Pseudo -Code of ` $apply ( ) ` * ` ` `js function $apply (expr ) { try { return $eval (expr ) ; } catch (e ) { $exception Handler (e ) ; } finally { $root . $digest ( ) ; } } * ` ` ` * * * Scope 's ` $apply ( ) ` method transitions through the following stages : * * 1 . The { @link guide /expression expression } is executed using the * { @link ng . $root Scope .Scope # $eval $eval ( ) } method . * 2 . Any exceptions from the execution of the expression are forwarded to the * { @link ng . $exception Handler $exception Handler } service . * 3 . The { @link ng . $root Scope .Scope # $watch watch } listeners are fired immediately after the * expression was executed using the { @link ng . $root Scope .Scope # $digest $digest ( ) } method . * * * @param { (string |function ( ) ) = } exp An angular expression to be executed . * * - `string ` : execute using the rules as defined in { @link guide /expression expression } . * - `function (scope ) ` : execute the function with current `scope ` parameter . * * @returns { * } The result of evaluating the expression . * / $apply : function ( expr ) { try { begin Phase ( ' $apply ' ) ; return this . $eval ( expr ) ; } catch ( e ) { $exception Handler ( e ) ; } finally { clear Phase ( ) ; try { $root Scope . $digest ( ) ; } catch ( e ) { $exception Handler ( e ) ; throw e ; } } } , / * * * @ngdoc method * @name $root Scope .Scope # $on * @kind function * * @description * Listens on events of a given type . See { @link ng . $root Scope .Scope # $emit $emit } for * discussion of event life cycle . * * The event listener function format is : `function (event , args . . . ) ` . The `event ` object * passed into the listener has the following attributes : * * - `target Scope ` - ` {Scope } ` : the scope on which the event was ` $emit ` -ed or * ` $broadcast ` -ed . * - `current Scope ` - ` {Scope } ` : the scope that is currently handling the event . Once the * event propagates through the scope hierarchy , this property is set to null . * - `name ` - ` {string } ` : name of the event . * - `stop Propagation ` - ` {function = } ` : calling `stop Propagation ` function will cancel * further event propagation (available only for events that were ` $emit ` -ed ) . * - `prevent Default ` - ` {function } ` : calling `prevent Default ` sets `default Prevented ` flag * to true . * - `default Prevented ` - ` {boolean } ` : true if `prevent Default ` was called . * * @param {string } name Event name to listen on . * @param {function (event , . . .args ) } listener Function to call when the event is emitted . * @returns {function ( ) } Returns a deregistration function for this listener . * / $on : function ( name , listener ) { var named Listeners = this . $ $listeners [ name ] ; if ( ! named Listeners ) { this . $ $listeners [ name ] = named Listeners = [ ] ; } named Listeners . push ( listener ) ; var current = this ; do { if ( ! current . $ $listener Count [ name ] ) { current . $ $listener Count [ name ] = 0 ; } current . $ $listener Count [ name ] + + ; } while ( ( current = current . $parent ) ) ; var self = this ; return function ( ) { named Listeners [ index Of ( named Listeners , listener ) ] = null ; decrement Listener Count ( self , 1 , name ) ; } ; } , / * * * @ngdoc method * @name $root Scope .Scope # $emit * @kind function * * @description * Dispatches an event `name ` upwards through the scope hierarchy notifying the * registered { @link ng . $root Scope .Scope # $on } listeners . * * The event life cycle starts at the scope on which ` $emit ` was called . All * { @link ng . $root Scope .Scope # $on listeners } listening for `name ` event on this scope get * notified . Afterwards , the event traverses upwards toward the root scope and calls all * registered listeners along the way . The event will stop propagating if one of the listeners * cancels it . * * Any exception emitted from the { @link ng . $root Scope .Scope # $on listeners } will be passed * onto the { @link ng . $exception Handler $exception Handler } service . * * @param {string } name Event name to emit . * @param { . . . * } args Optional one or more arguments which will be passed onto the event listeners . * @return {Object } Event object (see { @link ng . $root Scope .Scope # $on } ) . * / $emit : function ( name , args ) { var empty = [ ] , named Listeners , scope = this , stop Propagation = false , event = { name : name , target Scope : scope , stop Propagation : function ( ) { stop Propagation = true ; } , prevent Default : function ( ) { event . default Prevented = true ; } , default Prevented : false } , listener Args = concat ( [ event ] , arguments , 1 ) , i , length ; do { named Listeners = scope . $ $listeners [ name ] | | empty ; event . current Scope = scope ; for ( i = 0 , length = named Listeners . length ; i < length ; i + + ) { / / if listeners were deregistered , defragment the array if ( ! named Listeners [ i ] ) { named Listeners . splice ( i , 1 ) ; i - - ; length - - ; continue ; } try { / /allow all listeners attached to the current scope to run named Listeners [ i ] . apply ( null , listener Args ) ; } catch ( e ) { $exception Handler ( e ) ; } } / /if any listener on the current scope stops propagation , prevent bubbling if ( stop Propagation ) { event . current Scope = null ; return event ; } / /traverse upwards scope = scope . $parent ; } while ( scope ) ; event . current Scope = null ; return event ; } , / * * * @ngdoc method * @name $root Scope .Scope # $broadcast * @kind function * * @description * Dispatches an event `name ` downwards to all child scopes (and their children ) notifying the * registered { @link ng . $root Scope .Scope # $on } listeners . * * The event life cycle starts at the scope on which ` $broadcast ` was called . All * { @link ng . $root Scope .Scope # $on listeners } listening for `name ` event on this scope get * notified . Afterwards , the event propagates to all direct and indirect scopes of the current * scope and calls all registered listeners along the way . The event cannot be canceled . * * Any exception emitted from the { @link ng . $root Scope .Scope # $on listeners } will be passed * onto the { @link ng . $exception Handler $exception Handler } service . * * @param {string } name Event name to broadcast . * @param { . . . * } args Optional one or more arguments which will be passed onto the event listeners . * @return {Object } Event object , see { @link ng . $root Scope .Scope # $on } * / $broadcast : function ( name , args ) { var target = this , current = target , next = target , event = { name : name , target Scope : target , prevent Default : function ( ) { event . default Prevented = true ; } , default Prevented : false } , listener Args = concat ( [ event ] , arguments , 1 ) , listeners , i , length ; / /down while you can , then up and next sibling or up and next sibling until back at root while ( ( current = next ) ) { event . current Scope = current ; listeners = current . $ $listeners [ name ] | | [ ] ; for ( i = 0 , length = listeners . length ; i < length ; i + + ) { / / if listeners were deregistered , defragment the array if ( ! listeners [ i ] ) { listeners . splice ( i , 1 ) ; i - - ; length - - ; continue ; } try { listeners [ i ] . apply ( null , listener Args ) ; } catch ( e ) { $exception Handler ( e ) ; } } / / Insanity Warning : scope depth -first traversal / / yes , this code is a bit crazy , but it works and we have tests to prove it ! / / this piece should be kept in sync with the traversal in $digest / / (though it differs due to having the extra check for $ $listener Count ) if ( ! ( next = ( ( current . $ $listener Count [ name ] & & current . $ $child Head ) | | ( current ! = = target & & current . $ $next Sibling ) ) ) ) { while ( current ! = = target & & ! ( next = current . $ $next Sibling ) ) { current = current . $parent ; } } } event . current Scope = null ; return event ; } } ; var $root Scope = new Scope ( ) ; return $root Scope ; function begin Phase ( phase ) { if ( $root Scope . $ $phase ) { throw $root Scope Min Err ( 'inprog ' , ' { 0 } already in progress ' , $root Scope . $ $phase ) ; } $root Scope . $ $phase = phase ; } function clear Phase ( ) { $root Scope . $ $phase = null ; } function compile To Fn ( exp , name ) { var fn = $parse ( exp ) ; assert Arg Fn ( fn , name ) ; return fn ; } function decrement Listener Count ( current , count , name ) { do { current . $ $listener Count [ name ] - = count ; if ( current . $ $listener Count [ name ] = = = 0 ) { delete current . $ $listener Count [ name ] ; } } while ( ( current = current . $parent ) ) ; } / * * * function used as an initial value for watchers . * because it 's unique we can easily tell it apart from other values * / function init Watch Val ( ) { } } ] ; } 
function ( isolate ) { var Child Scope , child ; if ( isolate ) { child = new Scope ( ) ; child . $root = this . $root ; 
function ( watch Expressions , listener ) { var old Values = new Array ( watch Expressions . length ) ; var new Values = new Array ( watch Expressions . length ) ; var deregister Fns = [ ] ; var change Count = 0 ; var self = this ; var master Unwatch ; if ( watch Expressions . length = = = 1 ) { 
function ( ) { 
function ( name , listener ) { var named Listeners = this . $ $listeners [ name ] ; if ( ! named Listeners ) { this . $ $listeners [ name ] = named Listeners = [ ] ; } named Listeners . push ( listener ) ; var current = this ; do { if ( ! current . $ $listener Count [ name ] ) { current . $ $listener Count [ name ] = 0 ; } current . $ $listener Count [ name ] + + ; } while ( ( current = current . $parent ) ) ; var self = this ; return function ( ) { named Listeners [ index Of ( named Listeners , listener ) ] = null ; decrement Listener Count ( self , 1 , name ) ; } ; } 
function ( event ) { scope . $apply ( function ( ) { controller . $commit View Value ( ) ; } ) ; event . prevent Default ? event . prevent Default ( ) : event . return Value = false ; 
function ( docular _webapp _target ) { var ABS _SCRIPTS = _ _dirname ; var ABS _LIB = path . resolve ( ABS _SCRIPTS + ' / . . ' ) ; var ABS _DEFAULT _GENERATED _WEBAPP = ABS _LIB + ' /generated / ' ; return docular _webapp _target ? path . resolve ( process . cwd ( ) + ' / ' + docular _webapp _target ) : path . relative ( process . cwd ( ) , ABS _DEFAULT _GENERATED _WEBAPP ) ; } 
function Integration Context ( variable , options ) { this . variable = variable . clone ( ) ; this . options = options ; this . _constant Expr = { } ; this . sub Integral = { } ; this . rules = options . rules ; this . debug Indent = 0 ; } 
function preprocess Integrand ( expr , context ) { expr = remove Parenthesis ( expr ) ; expr = reduce Functions ( expr ) ; expr = remove Division ( expr ) ; return expr ; function remove Parenthesis ( node ) { if ( node . type = = = "Parenthesis Node " ) { return remove Parenthesis ( node . content ) ; } else { return node . map ( remove Parenthesis ) ; } } function reduce Functions ( expr ) { return helper ( expr ) ; function helper ( expr ) { if ( ! context . is Constant ( expr ) & & expr . type = = = "Function Node " ) { var func Name = typeof expr . fn = = = "string " ? expr . fn : expr . fn . name ; switch ( func Name ) { case "add " : return new Operator Node ( ' + ' , 'add ' , expr . args ) ; case "subtract " : return new Operator Node ( ' - ' , 'subtract ' , expr . args ) ; case "multiply " : return new Operator Node ( ' * ' , 'multiply ' , expr . args ) ; case "divide " : return new Operator Node ( ' / ' , 'divide ' , expr . args ) ; case "sqrt " : return new Operator Node ( ' ^ ' , 'pow ' , [ expr . args [ 0 ] . map ( helper ) , new Operator Node ( ' / ' , 'divide ' , [ new Constant Node ( 1 ) , new Constant Node ( 2 ) ] ) ] ) ; case "nth Root " : return new Operator Node ( ' ^ ' , 'pow ' , [ expr . args [ 0 ] . map ( helper ) , new Operator Node ( ' / ' , 'divide ' , [ new Constant Node ( 1 ) , expr . args [ 1 ] . map ( helper ) ] ) ] ) ; case "exp " : return new Operator Node ( ' ^ ' , 'pow ' , [ new Symbol Node ( 'e ' ) , expr . args [ 0 ] ] ) ; case "pow " : return new Operator Node ( ' ^ ' , 'pow ' , expr . args ) ; case "log " : if ( expr . args . length = = = 2 ) { return new Operator Node ( ' / ' , 'divide ' , [ new Function Node ( 'log ' , [ expr . args [ 0 ] . map ( helper ) ] ) , new Function Node ( 'log ' , [ expr . args [ 1 ] . map ( helper ) ] ) ] ) ; } else { break ; } default : break ; } } return expr . map ( helper ) ; } } function remove Division ( expr ) { return expr . transform ( function ( node ) { if ( ! context . is Constant ( node ) & & node . type = = = 'Operator Node ' & & node . op = = = ' / ' ) { return new Operator Node ( ' * ' , 'multiply ' , [ node . args [ 0 ] , new Operator Node ( ' ^ ' , 'pow ' , [ node . args [ 1 ] , new Constant Node ( - 1 ) ] ) ] ) ; } else { return node ; } } ) ; } } 
function get Numeric Value ( expr ) { var simplified = simplify Constant ( expr ) ; return to Number ( simplified ) ; function to Number ( expr ) { if ( expr . type = = = 'Operator Node ' & & expr . op = = = ' - ' & & expr . args . length = = = 1 ) { 
function ( expr , context , sub Integral ) { var simplified = simplify . simplify Core ( expr , context ) ; if ( ! simplified . equals ( expr ) ) { return sub Integral ( simplified , context , "simplified expression " ) ; } } 
function ( expr , context , sub Integral ) { if ( expr . type = = = 'Parenthesis Node ' ) { var int = sub Integral ( expr . content , context , "parentheses removal " ) ; return int ? new Parenthesis Node ( int ) : null ; } } 
function ( expr , context ) { if ( context . is Constant ( expr ) ) { return new Operator Node ( ' * ' , 'multiply ' , [ expr . clone ( ) , context . variable . clone ( ) ] ) ; } } 
function ( expr , context , sub Integral ) { if ( expr . type = = = "Operator Node " & & ( expr . op = = = ' + ' | | expr . op = = = ' - ' ) ) { var child Ints = expr . args . map ( function ( expr ) { return sub Integral ( expr , context , "sum rule " ) ; } ) ; if ( child Ints . every ( function ( n ) { return n ; } ) ) { return new Operator Node ( expr . op , expr . fn , child Ints ) ; } } } 
function ( expr , context , sub Integral ) { if ( expr . type = = = "Operator Node " & & expr . op = = = " * " ) { var factors = get Factors ( expr ) ; if ( factors . length > expr . args . length ) { return sub Integral ( new Operator Node ( ' * ' , 'multiply ' , factors ) , context , "product flattening " ) ; } } function get Factors ( expr ) { if ( expr . type = = = "Operator Node " & & expr . op = = = " * " ) { return expr . args . reduce ( function ( factors , expr ) { return factors . concat ( get Factors ( expr ) ) ; } , [ ] ) ; } else if ( expr . type = = = "Parenthesis Node " ) { return get Factors ( expr . content ) } else { return [ expr ] ; } } } 
function ( expr , context ) { if ( expr . type = = = "Symbol Node " & & expr . name = = = context . variable . name ) { return new Operator Node ( ' * ' , 'multiply ' , [ new Operator Node ( ' / ' , 'divide ' , [ new Constant Node ( 1 ) , new Constant Node ( 2 ) ] ) , new Operator Node ( ' ^ ' , 'pow ' , [ expr . clone ( ) , new Constant Node ( 2 ) ] ) ] ) ; } } 
function ( expr , context , sub Integral ) { if ( expr . type = = = "Operator Node " & & expr . op = = = ' * ' ) { var constant Factors = [ ] ; var non Constant Factors = [ ] ; expr . args . for Each ( function ( expr ) { if ( context . is Constant ( expr ) ) { constant Factors . push ( expr ) ; } else { non Constant Factors . push ( expr ) ; } } ) ; if ( constant Factors . length ! = = 0 ) { var constant Node = factors To Node ( constant Factors ) ; var non Constant Node = factors To Node ( non Constant Factors ) ; var non Constant Integral = sub Integral ( non Constant Node , context , "multiplication by constant " ) ; if ( non Constant Integral ) { return new Operator Node ( ' * ' , 'multiply ' , [ constant Node , non Constant Integral ] ) ; } } function factors To Node ( factors ) { if ( factors . length = = = 1 ) { return factors [ 0 ] ; } else { return new Operator Node ( ' * ' , 'multiply ' , factors ) ; } } } } 
function ( expr , context ) { if ( expr . type = = = "Operator Node " & & expr . op = = = ' ^ ' & & expr . args [ 0 ] . equals ( context . variable ) & & context . is Constant ( expr . args [ 1 ] ) ) { 
function ( expr , context ) { if ( expr . type = = = 'Operator Node ' & & expr . op = = = ' ^ ' ) { if ( context . is Constant ( expr . args [ 0 ] ) & & expr . args [ 1 ] . equals ( context . variable ) ) { return new Operator Node ( ' / ' , 'divide ' , [ expr , new Function Node ( 'log ' , [ expr . args [ 0 ] ] ) ] ) ; } } } 
function ( expr , context , sub Integral ) { if ( expr . type = = = "Operator Node " & & expr . op = = = ' * ' ) { var args As Power = expr . args . map ( get Expr In Power Form ) ; 
function ( expr , context , sub Integral ) { if ( expr . type = = = 'Operator Node ' & & expr . op = = = ' ^ ' ) { var base = expr . args [ 0 ] ; var exponent = expr . args [ 1 ] ; if ( base . type = = = 'Operator Node ' & & base . op = = = ' * ' ) { return sub Integral ( new Operator Node ( ' * ' , 'multiply ' , base . args . map ( function ( base Child ) { return new Operator Node ( ' ^ ' , 'pow ' , [ base Child , exponent ] ) ; } ) ) , context , "distributing power " ) ; } } } 
function ( expr , context , sub Integral ) { if ( expr . type = = = 'Operator Node ' & & expr . op = = = ' ^ ' ) { if ( expr . args [ 0 ] . type = = = 'Operator Node ' & & expr . args [ 0 ] . op = = = ' ^ ' ) { return sub Integral ( new Operator Node ( ' ^ ' , 'pow ' , [ expr . args [ 0 ] . args [ 0 ] , new Operator Node ( ' * ' , 'multiply ' , [ expr . args [ 0 ] . args [ 1 ] , expr . args [ 1 ] ] ) ] ) , context , 'removing double exponential ' ) ; } } } 
function ( expr , context , sub Integral ) { if ( expr . type = = = "Operator Node " & & expr . op = = = ' * ' ) { var was Change = false ; var is Total Positive = true ; var processed Args = [ ] ; expr . args . for Each ( function ( expr ) { if ( expr . type = = = "Operator Node " & & expr . args . length = = = 1 & & ( expr . op = = = ' + ' | | expr . op = = = ' - ' ) ) { was Change = true ; is Total Positive = is Total Positive ^ ( expr . op = = = ' - ' ) ; processed Args . push ( expr . args [ 0 ] ) ; } else { processed Args . push ( expr ) ; } } ) ; if ( was Change ) { var int = sub Integral ( new Operator Node ( ' * ' , 'multiply ' , processed Args ) , context , "removing unary + / - from factors " ) ; if ( int ) { return is Total Positive ? int : new Operator Node ( ' - ' , 'unary Minus ' , [ int ] ) ; } } } } 
function ( expr , context , sub Integral ) { if ( expr . type = = = "Operator Node " & & expr . op = = = ' * ' ) { var sum Node = null ; var other Factors = null ; for ( var i = 0 ; i < expr . args . length ; i + + ) { if ( expr . args [ i ] . type = = = "Operator Node " & & ( expr . args [ i ] . op = = = ' + ' | | expr . args [ i ] . op = = = ' - ' ) ) { sum Node = expr . args [ i ] ; other Factors = expr . args . filter ( function ( expr , index ) { return index ! = = i ; } ) ; break ; } } if ( sum Node ! = = null ) { var new Terms = sum Node . args . map ( function ( term ) { return new Operator Node ( ' * ' , 'multiply ' , other Factors . concat ( [ term ] ) ) ; } ) ; return sub Integral ( new Operator Node ( sum Node . op , sum Node . fn , new Terms ) , context , "product distribution " ) ; } } } 
function ( expr , context , sub Integral ) { var create Integral Wrapper = null ; var unique Parent = get Parent Of Unique Variable ( expr ) ; if ( unique Parent ! = = null & & unique Parent . type = = = "Operator Node " ) { if ( unique Parent . op = = = ' + ' | | unique Parent . op = = = ' - ' ) { if ( unique Parent . args . length = = = 1 ) { 
function ( expr , context , sub Integral ) { var Max Exponent Expanded = 1 0 ; if ( expr . type = = = 'Operator Node ' & & expr . op = = = ' ^ ' ) { var multiplied Out = try Multiply Out ( expr ) ; if ( multiplied Out ) { var int = sub Integral ( multiplied Out , context , "reducing power " ) ; if ( int ) { return int ; } } } else if ( expr . type = = = 'Operator Node ' & & expr . op = = = ' * ' ) { for ( var i = 0 ; i < expr . args . length ; i + + ) { var multiplied Out Child = try Multiply Out ( expr . args [ i ] ) ; if ( multiplied Out Child ) { var int = sub Integral ( new Operator Node ( ' * ' , 'multiply ' , multiplied Out Child . args . concat ( expr . args . slice ( 0 , i ) , expr . args . slice ( i + 1 ) ) ) , context , "reducing power " ) ; if ( int ) { return int ; } } } } 
function ( expr , context , sub Integral ) { if ( expr . type = = = 'Function Node ' & & expr . name = = = 'log ' & & expr . args . length = = = 1 ) { if ( expr . args . length = = = 1 & & expr . args [ 0 ] . equals ( context . variable ) ) { return new Operator Node ( ' - ' , 'subtract ' , [ new Operator Node ( ' * ' , 'multiply ' , [ context . variable , new Function Node ( 'log ' , [ context . variable ] ) ] ) , context . variable ] ) ; } } } 
function ( expr , context , sub Integral ) { if ( expr . type = = = 'Function Node ' & & expr . args [ 0 ] . equals ( context . variable ) ) { switch ( expr . name ) { case "sin " : return new Operator Node ( ' - ' , 'unary Minus ' , [ new Function Node ( "cos " , [ context . variable ] ) ] ) ; case "cos " : return new Function Node ( "sin " , [ context . variable ] ) ; case "tan " : 
function _integral ( expr , context , last Rule Comment ) { var expr String = expr . to String ( { parenthesis : 'all ' , handler : function ( node , options ) { if ( node . type = = = 'Parenthesis Node ' ) { return ' ( ' + node . content . to String ( options ) + ' ) ' ; } } } ) ; var debug Comment = last Rule Comment ? last Rule Comment + " : " : " " ; debug Comment + = "find integral of " + expr String + " d " + context . variable . name ; context . print Debug ( debug Comment ) ; context . debug Indent + + ; 
function Joy Stick ( device ) { var self = this ; Mouse . apply ( this , arguments ) ; this . on ( 'data ' , function ( ev ) { if ( ev . type = = Input Event . EVENT _TYPES . EV _INIT ) { self . emit ( 'init ' , ev ) ; } } ) ; } 
function Rotary ( device ) { var self = this ; Input Event . apply ( this , arguments ) ; this . on ( 'data ' , function ( ev ) { 
function Input Event ( device , options ) { var self = this ; Event Emitter . call ( this ) ; if ( device instanceof Input Event ) { device = device . device ; } this . device = device ; this . options = options | | { flags : 'r ' , encoding : null } ; this . options . fd = fs . open Sync ( this . device , this . options . flags ) ; this . fd = fs . create Read Stream ( null , this . options ) ; this . fd . on ( 'data ' , function ( data ) { self . emit ( 'raw ' , data ) ; self . process ( data ) ; } ) ; this . fd . on ( 'error ' , function ( err ) { self . emit ( 'error ' , err ) ; } ) ; } 
function Keyboard ( device ) { var self = this ; Input Event . apply ( this , arguments ) ; this . on ( 'data ' , function ( ev ) { 
function Mouse ( device ) { var self = this ; Keyboard . apply ( this , arguments ) ; this . on ( 'data ' , function ( ev , data ) { if ( Input Event . EVENT _TYPES . EV _REL = = ev . type ) { 
function ( ) { this . _ _lux . cleanup . for Each ( ( method ) = > method . call ( this ) ) ; this . _ _lux . cleanup = undefined ; delete this . _ _lux . cleanup ; } 
function default Process ( template , content ) { return template . replace ( options . parse Pattern , function ( match , inner ) { var processed = process Placeholder ( inner , content ) ; if ( processed = = = undefined ) { processed = ( ! options . remove Undefined ? match : " " ) ; } return processed ; } ) ; } 
function check File ( src ) { if ( ! grunt . file . exists ( src ) ) { grunt . log . error ( "Source file \ " " + src + " \ " not fount . " ) ; return false ; } return true ; } 
function parse Inline Values ( string ) { var match ; var values = { } ; while ( match = attributes Regex . exec ( string ) ) { values [ match [ 1 ] ] = match [ 2 ] ; } return values ; } 
function parse Signature ( signature ) { var match ; var result ; 
function resolve Name ( name , values ) { name = String ( name ) . replace ( / \ [ ( [ ^ \ ] ] + ) \ ] / g , function ( match , inner ) { return " . " + resolve Name ( inner , values ) ; } ) ; return mout . object . get ( values , name ) ; } 
function apply Indent ( indent , content ) { if ( ! indent | | indent . length < 1 ) { return content ; } return content . split ( " \n " ) . map ( function ( line ) { 
function get Array Values ( string , values ) { string = string . split ( " " ) . join ( " " ) ; if ( array Regex . test ( string ) ) return string . match ( array Regex ) [ 1 ] . split ( " , " ) ; else { var array = process Placeholder ( string , values ) ; if ( ! mout . lang . is Array ( array ) ) array = [ ] ; return array ; } } 
function validate If ( inline Values , values ) { if ( " _if " in inline Values ) { var value = inline Values [ " _if " ] ; delete inline Values [ " _if " ] ; var params = { } ; var condition = value . replace ( if Regex , function ( match , varname ) { if ( ! varname ) return match ; var resolved = resolve Name ( varname , values ) ; 
function validate Render ( inline Values ) { if ( " _render " in inline Values ) { var skip Value = inline Values [ " _render " ] ; if ( skip Value in options ) { return ! options [ skip Value ] ; } } return false ; } 
function validate For Each ( inline Values , values , array ) { if ( " _foreach " in inline Values ) { 
function validate Bake ( inline Values ) { if ( " _bake " in inline Values ) { var signature = inline Values [ " _bake " ] ; delete inline Values [ " _bake " ] ; var set = signature . split ( " > " , 2 ) ; return { src : mout . string . trim ( set [ 0 ] ) , dest : mout . string . trim ( set [ 1 ] ) } ; } return null ; } 
function validate Process ( inline Values ) { if ( " _process " in inline Values ) { var value = inline Values [ " _process " ] ; delete inline Values [ " _process " ] ; return String ( value ) . to Lower Case ( ) = = = 'true ' ; } return true ; } 
function extract Section ( content ) { var depth = 0 ; 
function parse ( file Content , file Path , dest File , values ) { var section = extract Section ( file Content ) ; if ( section ) { file Content = process Content ( section . before , values ) ; if ( section . inner ) { file Content + = replace String ( section . inner , " " , " " , file Path , section . attributes , file Path , dest File , values ) ; } else if ( section . include Path ) { file Content + = replace File ( section . linebreak , section . indent , section . include Path , section . attributes , file Path , dest File , values ) ; } file Content + = parse ( section . after , file Path , dest File , values ) ; } else { return process Content ( file Content , values ) ; } return file Content ; } 
function process Content ( content , values ) { return mout . lang . is Function ( options . process ) ? options . process ( content , values ) : content ; } 
function bake File ( src , dest , content ) { var src Content = grunt . file . read ( src ) ; var dest Content = parse ( src Content , src , dest , content ) ; grunt . file . write ( dest , dest Content ) ; grunt . log . ok ( "File \ " " + dest + " \ " created . " ) ; } 
function ( client Id , client Secret ) { this . _client Id = client Id this . _client Secret = client Secret this . _auth = new google Auth . OAuth 2 ( client Id , client Secret , ' ' ) ; } 
function compare ( a , b , index ) { return ( ( a . char Code At ( index ) | | 0 ) - ( b . char Code At ( index ) | | 0 ) | | compare ( a , b , index + 1 ) ) } 
function javascript ( node ) { if ( ! is ( node , 'script ' ) ) { return false } if ( has ( node , 'type ' ) ) { return check ( node . properties . type ) } return ! has ( node , 'language ' ) | | check ( node . properties . language , 'text / ' ) } 
function check ( value , prefix ) { var val if ( typeof value ! = = 'string ' ) { return false } val = trim ( value . split ( ' ; ' , 1 ) [ 0 ] ) . to Lower Case ( ) return val = = = ' ' | | mime . index Of ( ( prefix | | ' ' ) + val ) ! = = - 1 } 
function collapsable ( node ) { return ( is ( 'text ' , node ) | | element ( node , list ) | | embedded ( node ) | | body OK ( node ) | | ( element ( node , 'meta ' ) & & has ( node , 'item Prop ' ) ) ) } 
function Module ( app , options = DEFAULT _OPTIONS ) { const session Name = options . session Name | | options . session _name | | DEFAULT _OPTIONS . session Name ; const utility Name = options . utility Name | | options . utility _name | | DEFAULT _OPTIONS . utility Name ; const locals Name = options . locals Name | | options . locals _name | | DEFAULT _OPTIONS . locals Name ; const view Name = options . view Name | | options . view _name | | DEFAULT _OPTIONS . view Name ; const before Single Render = options . before Single Render | | options . before Single Render | | DEFAULT _OPTIONS . before Single Render ; const after All Render = options . after All Render | | options . after All Render | | DEFAULT _OPTIONS . after All Render ; function render ( req , res , next ) { if ( ! req . session [ session Name ] . length ) { next ( ) ; } else { const result HTML = [ ] ; async . each ( req . session [ session Name ] , function ( item , next ) { before Single Render ( item , function ( error , item ) { if ( error ) return next ( error ) ; app . render ( view Name , item , function ( error , html ) { if ( error ) return next ( error ) ; result HTML . push ( html ) ; next ( null ) ; } ) } ) } , function ( error ) { if ( error ) return next ( error ) ; req . session [ session Name ] . length = 0 ; after All Render ( result HTML , function ( error , html ) { if ( error ) return next ( error ) ; res . locals [ locals Name ] = html ; next ( ) ; } ) } ) } } function Flash Middleware ( req , res , next ) { if ( ! is Object ( req . session ) ) throw new Error ( 'express -session is required . (npm i express -session ) ' ) ; if ( ! req . session [ session Name ] | | ! is Array ( req . session [ session Name ] ) ) req . session [ session Name ] = [ ] ; req [ utility Name ] = function ( ) { const argc = arguments . length ; let notification ; let redirect = REDIRECT ; * When there is no redirect , notifications must be rendered now and since * rendering is async (and this method is sync ) , a *promise * like function is returned . * The function can be called with a callback that will be called after all notifcations * are rendered , otherwise , rendering will be done during the next request . * / return function Manual Render ( callback ) { render ( req , res , callback ) ; } } } render ( req , res , next ) ; } return Flash Middleware ; } 
function render ( req , res , next ) { if ( ! req . session [ session Name ] . length ) { next ( ) ; } else { const result HTML = [ ] ; async . each ( req . session [ session Name ] , function ( item , next ) { before Single Render ( item , function ( error , item ) { if ( error ) return next ( error ) ; app . render ( view Name , item , function ( error , html ) { if ( error ) return next ( error ) ; result HTML . push ( html ) ; next ( null ) ; } ) } ) } , function ( error ) { if ( error ) return next ( error ) ; req . session [ session Name ] . length = 0 ; after All Render ( result HTML , function ( error , html ) { if ( error ) return next ( error ) ; res . locals [ locals Name ] = html ; next ( ) ; } ) } ) } } 
function Flash Middleware ( req , res , next ) { if ( ! is Object ( req . session ) ) throw new Error ( 'express -session is required . (npm i express -session ) ' ) ; if ( ! req . session [ session Name ] | | ! is Array ( req . session [ session Name ] ) ) req . session [ session Name ] = [ ] ; req [ utility Name ] = function ( ) { const argc = arguments . length ; let notification ; let redirect = REDIRECT ; * When there is no redirect , notifications must be rendered now and since * rendering is async (and this method is sync ) , a *promise * like function is returned . * The function can be called with a callback that will be called after all notifcations * are rendered , otherwise , rendering will be done during the next request . * / return function Manual Render ( callback ) { render ( req , res , callback ) ; } } } render ( req , res , next ) ; } 
function ( s ) { let md 5blks = [ ] , i ; for ( i = 0 ; i < 6 4 ; i + = 4 ) { md 5blks [ i > > 2 ] = s . char Code At ( i ) + ( s . char Code At ( i + 1 ) < < 8 ) + ( s . char Code At ( i + 2 ) < < 1 6 ) + ( s . char Code At ( i + 3 ) < < 2 4 ) ; } return md 5blks ; } 
function get Framework Path ( { framework , base Dir } ) { const pkg Path = path . join ( base Dir , 'package .json ' ) ; assert ( fs . exists Sync ( pkg Path ) , ` $ { pkg Path } ` ) ; const module Dir = path . join ( base Dir , 'node _modules ' ) ; const pkg = utility . read JSONSync ( pkg Path ) ; 
function get Framework Or Egg Path ( cwd , egg Names ) { egg Names = egg Names | | [ 'egg ' ] ; const module Dir = path . join ( cwd , 'node _modules ' ) ; if ( ! fs . exists Sync ( module Dir ) ) { return ' ' ; } 
function auto Inject Services ( object , args ) { if ( args . length = = = 0 ) return ; let code = object . constructor . to String ( ) ; code = code . match ( 'constructor \ \ ( [ \ \ $a -z A -Z 0 - 9 \ \ , \ \s ] + \ \ ) ' ) [ 0 ] ; code = code . substring ( code . index Of ( ' ( ' ) + 1 , code . index Of ( ' ) ' ) ) ; code = code . split ( ' , ' ) ; for ( let i = 0 ; i < code . length ; i + + ) { Object . define Property ( object , code [ i ] , { value : args [ i ] } ) } } 
function Settable Observable ( fn , context , initial Value ) { this . last Set Value = new Simple Observable ( initial Value ) ; function observe ( ) { return fn . call ( context , this . last Set Value . get ( ) ) ; } this . handler = this . handler . bind ( this ) ; 
function Setter Observable ( getter , setter ) { this . setter = setter ; this . observation = new Observation ( getter ) ; this . handler = this . handler . bind ( this ) ; 
function Async Observable ( fn , context , initial Value ) { this . resolve = this . resolve . bind ( this ) ; this . last Set Value = new Simple Observable ( initial Value ) ; this . handler = this . handler . bind ( this ) ; function observe ( ) { this . resolve Called = false ; 
function load ( dot Graph , append To ) { var dot AST = parse Dot ( dot Graph ) ; if ( dot AST . length > 1 & & append To ! = = undefined ) { throw new Error ( 'Dot file contains multiple graphs . Cannot use `save To ` in this case ' ) ; } if ( ! append To ) { append To = require ( 'ngraph .graph ' ) ( ) ; } 
function update Nodes ( parent , old , vnodes , recycling , hooks , next Sibling , ns ) { if ( old = = = vnodes | | old = = null & & vnodes = = null ) return else if ( old = = null ) create Nodes ( parent , vnodes , 0 , vnodes . length , hooks , next Sibling , ns ) else if ( vnodes = = null ) remove Nodes ( old , 0 , old . length , vnodes ) else { if ( old . length = = = vnodes . length ) { var is Unkeyed = false for ( var i = 0 ; i < vnodes . length ; i + + ) { if ( vnodes [ i ] ! = null & & old [ i ] ! = null ) { is Unkeyed = vnodes [ i ] . key = = null & & old [ i ] . key = = null break } } if ( is Unkeyed ) { for ( var i = 0 ; i < old . length ; i + + ) { if ( old [ i ] = = = vnodes [ i ] ) continue else if ( old [ i ] = = null & & vnodes [ i ] ! = null ) create Node ( parent , vnodes [ i ] , hooks , ns , get Next Sibling ( old , i + 1 , next Sibling ) ) else if ( vnodes [ i ] = = null ) remove Nodes ( old , i , i + 1 , vnodes ) else update Node ( parent , old [ i ] , vnodes [ i ] , hooks , get Next Sibling ( old , i + 1 , next Sibling ) , recycling , ns ) } return } } recycling = recycling | | is Recyclable ( old , vnodes ) if ( recycling ) { var pool = old . pool old = old . concat ( old . pool ) } var old Start = 0 , start = 0 , old End = old . length - 1 , end = vnodes . length - 1 , map while ( old End > = old Start & & end > = start ) { var o = old [ old Start ] , v = vnodes [ start ] if ( o = = = v & & ! recycling ) old Start + + , start + + else if ( o = = null ) old Start + + else if ( v = = null ) start + + else if ( o . key = = = v . key ) { var should Recycle = ( pool ! = null & & old Start > = old . length - pool . length ) | | ( ( pool = = null ) & & recycling ) old Start + + , start + + update Node ( parent , o , v , hooks , get Next Sibling ( old , old Start , next Sibling ) , should Recycle , ns ) if ( recycling & & o . tag = = = v . tag ) insert Node ( parent , to Fragment ( o ) , next Sibling ) } else { var o = old [ old End ] if ( o = = = v & & ! recycling ) old End - - , start + + else if ( o = = null ) old End - - else if ( v = = null ) start + + else if ( o . key = = = v . key ) { var should Recycle = ( pool ! = null & & old End > = old . length - pool . length ) | | ( ( pool = = null ) & & recycling ) update Node ( parent , o , v , hooks , get Next Sibling ( old , old End + 1 , next Sibling ) , should Recycle , ns ) if ( recycling | | start < end ) insert Node ( parent , to Fragment ( o ) , get Next Sibling ( old , old Start , next Sibling ) ) old End - - , start + + } else break } } while ( old End > = old Start & & end > = start ) { var o = old [ old End ] , v = vnodes [ end ] if ( o = = = v & & ! recycling ) old End - - , end - - else if ( o = = null ) old End - - else if ( v = = null ) end - - else if ( o . key = = = v . key ) { var should Recycle = ( pool ! = null & & old End > = old . length - pool . length ) | | ( ( pool = = null ) & & recycling ) update Node ( parent , o , v , hooks , get Next Sibling ( old , old End + 1 , next Sibling ) , should Recycle , ns ) if ( recycling & & o . tag = = = v . tag ) insert Node ( parent , to Fragment ( o ) , next Sibling ) if ( o . dom ! = null ) next Sibling = o . dom old End - - , end - - } else { if ( ! map ) map = get Key Map ( old , old End ) if ( v ! = null ) { var old Index = map [ v . key ] if ( old Index ! = null ) { var movable = old [ old Index ] var should Recycle = ( pool ! = null & & old Index > = old . length - pool . length ) | | ( ( pool = = null ) & & recycling ) update Node ( parent , movable , v , hooks , get Next Sibling ( old , old End + 1 , next Sibling ) , recycling , ns ) insert Node ( parent , to Fragment ( movable ) , next Sibling ) old [ old Index ] . skip = true if ( movable . dom ! = null ) next Sibling = movable . dom } else { var dom = create Node ( parent , v , hooks , ns , next Sibling ) next Sibling = dom } } end - - } if ( end < start ) break } create Nodes ( parent , vnodes , start , end + 1 , hooks , next Sibling , ns ) remove Nodes ( old , old Start , old End + 1 , vnodes ) } } 
function remove Nodes ( vnodes , start , end , context ) { for ( var i = start ; i < end ; i + + ) { var vnode = vnodes [ i ] if ( vnode ! = null ) { if ( vnode . skip ) vnode . skip = false else remove Node ( vnode , context ) } } } 
function set Attrs ( vnode , attrs 2 , ns ) { for ( var key 2 in attrs 2 ) { set Attr ( vnode , key 2 , null , attrs 2 [ key 2 ] , ns ) } } 
function update Style ( element , old , style ) { if ( old = = = style ) element . style . css Text = " " , old = null if ( style = = null ) element . style . css Text = " " else if ( typeof style = = = "string " ) element . style . css Text = style else { if ( typeof old = = = "string " ) element . style . css Text = " " for ( var key 2 in style ) { element . style [ key 2 ] = style [ key 2 ] } if ( old ! = null & & typeof old ! = = "string " ) { for ( var key 2 in old ) { if ( ! ( key 2 in style ) ) element . style [ key 2 ] = " " } } } } 
function update Event ( vnode , key 2 , value ) { var element = vnode . dom var callback = typeof onevent ! = = "function " ? value : function ( e ) { var result = value . call ( element , e ) onevent . call ( element , e ) return result } if ( key 2 in element ) element [ key 2 ] = typeof value = = = "function " ? callback : null else { var event Name = key 2 . slice ( 2 ) if ( vnode . events = = = undefined ) vnode . events = { } if ( vnode . events [ key 2 ] = = = callback ) return if ( vnode . events [ key 2 ] ! = null ) element . remove Event Listener ( event Name , vnode . events [ key 2 ] , false ) if ( typeof value = = = "function " ) { vnode . events [ key 2 ] = callback element . add Event Listener ( event Name , vnode . events [ key 2 ] , false ) } } } 
function init Lifecycle ( source , vnode , hooks ) { if ( typeof source . oninit = = = "function " ) source . oninit . call ( vnode . state , vnode ) if ( typeof source . oncreate = = = "function " ) hooks . push ( source . oncreate . bind ( vnode . state , vnode ) ) } 
function ( message ) { message . tab Id = chrome . devtools . inspected Window . tab Id chrome . extension . send Message ( message ) } 
function ( ) { var send Tracer Init = function ( ) { send Object To Inspected Page ( { content : { type : "MEIOSIS _TRACER _INIT " } } ) } var trigger Stream Value = function ( index , value ) { send Object To Inspected Page ( { content : { type : "MEIOSIS _TRIGGER _STREAM _VALUE " , index : index , value : value } } ) } tracer = window . meiosis Tracer ( { selector : " #meiosis -tracer " , send Tracer Init : send Tracer Init , trigger Stream Value : trigger Stream Value , direction : "auto " } ) } 
function recurse ( streams ) { if ( streams . length < 2 ) return streams [ 0 ] . pipe ( streams [ 1 ] ) recurse ( streams . slice ( 1 ) ) } 
function Temporary Credentials ( params ) { AWS . Credentials . call ( this ) ; this . load Master Credentials ( ) ; this . expired = true ; this . params = params | | { } ; if ( this . params . Role Arn ) { this . params . Role Session Name = this . params . Role Session Name | | 'temporary -credentials ' ; } this . service = new AWS . STS ( { params : this . params } ) ; } 
function refresh ( callback ) { var self = this ; if ( ! callback ) callback = function ( err ) { if ( err ) throw err ; } ; self . service . config . credentials = self . master Credentials ; var operation = self . params . Role Arn ? self . service . assume Role : self . service . get Session Token ; operation . call ( self . service , function ( err , data ) { if ( ! err ) { self . service . credentials From ( data , self ) ; } callback ( err ) ; } ) ; } 
function add Positions ( base , relative ) { return { line : base . line + relative . line - 1 , 
function SAMLCredentials ( params ) { AWS . Credentials . call ( this ) ; this . expired = true ; this . params = params ; this . service = new AWS . STS ( { params : this . params } ) ; } 
function refresh ( callback ) { var self = this ; if ( ! callback ) callback = function ( err ) { if ( err ) throw err ; } ; self . metadata Service . load Credentials ( function ( err , creds ) { if ( ! err ) { self . expired = false ; self . metadata = creds ; self . access Key Id = creds . Access Key Id ; self . secret Access Key = creds . Secret Access Key ; self . session Token = creds . Token ; self . expire Time = new Date ( creds . Expiration ) ; } callback ( err ) ; } ) ; } 
function Service ( config ) { if ( ! this . load Service Class ) { throw AWS . util . error ( new Error ( ) , 'Service must be constructed with `new \ ' operator ' ) ; } var Service Class = this . load Service Class ( config | | { } ) ; if ( Service Class ) return new Service Class ( config ) ; this . initialize ( config ) ; } 
function get Signer Class ( ) { var version ; if ( this . config . signature Version ) { version = this . config . signature Version ; } else { version = this . api . signature Version ; } return AWS . Signers . Request Signer . get Version ( version ) ; } 
function define Methods ( svc ) { AWS . util . each ( svc . prototype . api . operations , function iterator ( method ) { if ( svc . prototype [ method ] ) return ; svc . prototype [ method ] = function ( params , callback ) { return this . make Request ( method , params , callback ) ; } ; } ) ; } 
function define Service ( service Identifier , versions , features ) { if ( ! Array . is Array ( versions ) ) { features = versions ; versions = [ ] ; } var svc = inherit ( AWS . Service , features | | { } ) ; if ( typeof service Identifier = = = 'string ' ) { AWS . Service . add Versions ( svc , versions ) ; var identifier = svc . service Identifier | | service Identifier ; svc . service Identifier = identifier ; } else { 
function abort ( ) { this . remove All Listeners ( 'validate Response ' ) ; this . remove All Listeners ( 'extract Error ' ) ; this . on ( 'validate Response ' , function add Aborted Error ( resp ) { resp . error = AWS . util . error ( new Error ( 'Request aborted by user ' ) , { code : 'Request Aborted Error ' , retryable : false } ) ; } ) ; if ( this . http Request . stream ) { 
function each Item ( callback ) { function wrapped Callback ( err , data ) { if ( err ) return callback ( err , null ) ; if ( data = = = null ) return callback ( null , null ) ; var config = this . request . service . pagination Config ( this . request . operation ) ; var result Key = config . result Key ; if ( Array . is Array ( result Key ) ) result Key = result Key [ 0 ] ; var results = AWS . util . jamespath . query ( result Key , data ) ; AWS . util . array Each ( results , function ( result ) { AWS . util . array Each ( result , function ( item ) { callback ( null , item ) ; } ) ; } ) ; } this . each Page ( wrapped Callback ) ; } 
function create Read Stream ( ) { var streams = AWS . util . node Require ( 'stream ' ) ; var req = this ; var stream = null ; var legacy Streams = false ; if ( AWS . Http Client . streams Api Version = = = 2 ) { stream = new streams . Readable ( ) ; stream . _read = function ( ) { } ; } else { stream = new streams . Stream ( ) ; stream . readable = true ; } stream . sent = false ; stream . on ( 'new Listener ' , function ( event ) { if ( ! stream . sent & & ( event = = = 'data ' | | event = = = 'readable ' ) ) { if ( event = = = 'data ' ) legacy Streams = true ; stream . sent = true ; process . next Tick ( function ( ) { req . send ( function ( ) { } ) ; } ) ; } } ) ; this . on ( 'http Headers ' , function stream Headers ( status Code , headers , resp ) { if ( status Code < 3 0 0 ) { this . http Request . _streaming = true ; req . remove Listener ( 'http Data ' , AWS . Event Listeners . Core . HTTP _DATA ) ; req . remove Listener ( 'http Error ' , AWS . Event Listeners . Core . HTTP _ERROR ) ; req . on ( 'http Error ' , function stream Http Error ( error , resp ) { resp . error = error ; resp . error . retryable = false ; } ) ; var http Stream = resp . http Response . stream ; if ( legacy Streams ) { http Stream . on ( 'data ' , function ( arg ) { stream . emit ( 'data ' , arg ) ; } ) ; http Stream . on ( 'end ' , function ( ) { stream . emit ( 'end ' ) ; } ) ; } else { http Stream . on ( 'readable ' , function ( ) { var chunk ; do { chunk = http Stream . read ( ) ; if ( chunk ! = = null ) stream . push ( chunk ) ; } while ( chunk ! = = null ) ; stream . read ( 0 ) ; } ) ; http Stream . on ( 'end ' , function ( ) { stream . push ( null ) ; } ) ; } http Stream . on ( 'error ' , function ( err ) { stream . emit ( 'error ' , err ) ; } ) ; } } ) ; this . on ( 'error ' , function ( err ) { stream . emit ( 'error ' , err ) ; } ) ; return stream ; } 
function constructor ( service , state ) { this . service = service ; this . state = state ; if ( typeof this . state = = = 'object ' ) { AWS . util . each . call ( this , this . state , function ( key , value ) { this . state = key ; this . expected Value = value ; } ) ; } this . load Waiter Config ( this . state ) ; if ( ! this . expected Value ) { this . expected Value = this . config . success Value ; } } 
function check Success ( resp ) { if ( ! this . config . success Path ) { return resp . http Response . status Code < 3 0 0 ; } var r = AWS . util . jamespath . find ( this . config . success Path , resp . data ) ; if ( this . config . failure Value & & this . config . failure Value . index Of ( r ) > = 0 ) { return null ; 
function check Error ( resp ) { var value = this . config . success Value ; if ( typeof value = = = 'number ' ) { return resp . http Response . status Code = = = value ; } else { return resp . error & & resp . error . code = = = value ; } } 
function Web Identity Credentials ( params ) { AWS . Credentials . call ( this ) ; this . expired = true ; this . params = params ; this . params . Role Session Name = this . params . Role Session Name | | 'web -identity ' ; this . service = new AWS . STS ( { params : this . params } ) ; this . data = null ; } 
function Shared Ini File Credentials ( options ) { AWS . Credentials . call ( this ) ; options = options | | { } ; this . filename = options . filename ; this . profile = options . profile | | process . env . AWS _PROFILE | | 'default ' ; this . get ( function ( ) { } ) ; } 
function refresh ( callback ) { if ( ! callback ) callback = function ( err ) { if ( err ) throw err ; } ; try { if ( ! this . filename ) this . load Default Filename ( ) ; var creds = AWS . util . ini . parse ( AWS . util . read File Sync ( this . filename ) ) ; if ( typeof creds [ this . profile ] = = = 'object ' ) { this . access Key Id = creds [ this . profile ] [ 'aws _access _key _id ' ] ; this . secret Access Key = creds [ this . profile ] [ 'aws _secret _access _key ' ] ; this . session Token = creds [ this . profile ] [ 'aws _session _token ' ] ; } if ( ! this . access Key Id | | ! this . secret Access Key ) { throw new Error ( 'Credentials not set in ' + this . filename + ' using profile ' + this . profile ) ; } this . expired = false ; callback ( ) ; } catch ( err ) { callback ( err ) ; } } 
function Cognito Identity Credentials ( params ) { AWS . Credentials . call ( this ) ; this . expired = true ; this . web Identity Credentials = new AWS . Web Identity Credentials ( params ) ; this . cognito = new AWS . Cognito Identity ( { params : params } ) ; this . sts = new AWS . STS ( ) ; this . params = params ; this . data = null ; this . identity Id = null ; this . load Cached Id ( ) ; } 
function get Id ( callback ) { var self = this ; if ( typeof self . params . Identity Id = = = 'string ' ) return callback ( ) ; self . cognito . get Id ( function ( err , data ) { if ( ! err & & data . Identity Id ) { self . params . Identity Id = data . Identity Id ; } callback ( err , data ) ; } ) ; } 
function Barrels ( source Folder ) { if ( ! ( this instanceof Barrels ) ) return new Barrels ( source Folder ) ; 
function ( collection , key , ip ) { if ( ! collection ) { collection = { } ; } if ( ! collection [ key ] ) { collection [ key ] = [ ] ; } collection [ key ] . push ( ip ) ; } 
function forward ( obj , target , only Accessors ) { only Accessors = only Accessors | | false ; for ( var k in target ) { ( function ( k ) { if ( typeof ( target [ k ] ) = = 'function ' ) { if ( ! only Accessors ) { obj [ k ] = target [ k ] . bind ( target ) ; } } else { Object . define Property ( obj , k , { get : function ( ) { return target [ k ] ; } , set : function ( x ) { target [ k ] = x ; } } ) ; } } ) ( k ) ; } } 
function get Data Context ( ctx Or Canvas ) { if ( ctx Or Canvas instanceof HTMLCanvas Element ) { return get Data Context ( ctx Or Canvas . get Context ( ' 2d ' ) ) ; } var ctx = ctx Or Canvas ; if ( stub Get Data Context ) { return stub Get Data Context ( ctx ) ; } else { for ( var i = 0 ; i < get Data Context . cache . length ; i + + ) { var pair = get Data Context . cache [ i ] ; if ( pair [ 0 ] = = ctx ) return pair [ 1 ] ; } var dtx = new Data Context ( ctx ) ; get Data Context . cache . push ( [ ctx , dtx ] ) ; return dtx ; } } 
function Recording Context ( ctx ) { forward ( this , ctx , true ) ; var calls = [ ] ; this . calls = calls ; for ( var k in ctx ) { ( function ( k ) { if ( typeof ( ctx [ k ] ) ! = 'function ' ) return ; this [ k ] = function ( ) { 
function transformed Calls ( calls , args ) { var image = args [ 0 ] , sx = 0 , sy = 0 , s Width = image . width , s Height = image . height , dx , dy , d Width = image . width , d Height = image . height ; if ( args . length = = 3 ) { 
function ( original Call ) { var call = original Call . slice ( ) , 
function find Recorder ( div , selector ) { if ( ! div ) { if ( ! Recording Context . recorders ) { throw 'You must call Recording Context .record All ( ) before using other Recording Context static methods ' ; } else if ( Recording Context . recorders . length = = 0 ) { throw 'Called a Recording Context method , but no canvases are being recorded . ' ; } else if ( Recording Context . recorders . length > 1 ) { throw 'Called a Recording Context method while multiple canvases were being recorded . Specify one using a div and selector . ' ; } else { return Recording Context . recorders [ 0 ] [ 1 ] ; } } else { return Recording Context . recorder For Selector ( div , selector ) ; } } 
function Click Tracking Context ( ctx , px , py ) { forward ( this , ctx ) ; var stack = [ ] ; this . hits = [ ] ; this . hit = null ; var that = this ; function record Hit ( ) { that . hits . unshift ( Array . prototype . slice . call ( stack ) ) ; that . hit = that . hits [ 0 ] ; } this . push Object = function ( o ) { stack . unshift ( o ) ; } ; this . pop Object = function ( ) { stack . shift ( ) ; } ; this . reset = function ( ) { this . hits = [ ] ; this . hit = null ; } ; 
function sort ( vector ) { 
function quartiles ( data ) { var q Values = new Array ( 2 ) , vector ; vector = new Array ( data . length ) ; for ( var i = 0 ; i < data . length ; i + + ) { vector [ i ] = data [ i ] [ 1 ] ; } q Values [ 0 ] = quantile ( vector , 0 . 2 5 ) ; q Values [ 1 ] = quantile ( vector , 0 . 7 5 ) ; return q Values ; } 
function quantile ( vector , percent ) { var num Values = vector . length , id , value ; 
function filter ( FLG ) { return function filter ( data ) { var q Values , iqr , bounds = new Array ( 4 ) , idx , d , outliers = [ ] ; 
function transform ( ) { var kde = new KDE ( ) ; return function transform ( data ) { kde . estimator ( data , 'silverman ' ) ; return kde . eval ( data ) ; } ; } 
function get Buffer ( W ) { var buffer = new Array ( W ) ; for ( var i = 0 ; i < W ; i + + ) { buffer [ i ] = 0 ; } return buffer ; } 
function on Data ( W ) { var buffer = get Buffer ( W ) , full = false , old Val , sos = 0 , mean = 0 , N = 0 , delta = 0 , old _delta = 0 , new _delta = 0 ; return function on Data ( new Val ) { 
function kde _estimator _silverman ( vector ) { var sigma , N = vector . length , A ; 
function string Escape ( str ) { let string Array = str . to String ( ) . split ( ' ' ) ; for ( let j = 0 ; j < string Array . length ; j + + ) { for ( let i = 0 ; i < escape Array . length ; i + + ) { if ( string Array [ j ] = = = escape Array [ i ] ) { string Array [ j ] = ' \ \ ' + escape Array [ i ] ; } } } return string Array . join ( ' ' ) ; } 
function from Ms ( ms , format = 'mm :ss ' ) { if ( typeof ms ! = = 'number ' | | Number . is Na N ( ms ) ) { throw new Error ( 'Na N error ' ) } let abs Ms = Math . abs ( ms ) let negative = ( ms < 0 ) let hours = Math . floor ( abs Ms / HOUR ) let minutes = Math . floor ( abs Ms % HOUR / MINUTE ) let seconds = Math . floor ( abs Ms % MINUTE / SECOND ) let miliseconds = Math . floor ( abs Ms % SECOND ) return format Time ( { negative , hours , minutes , seconds , miliseconds } , format ) } 
function format Time ( time , format ) { let show Ms let show Sc let show Hr switch ( format . to Lower Case ( ) ) { case 'hh :mm :ss .sss ' : show Ms = true show Sc = true show Hr = true break case 'hh :mm :ss ' : show Ms = ! ( ! time . miliseconds ) show Sc = true show Hr = true break case 'hh :mm ' : show Ms = ! ( ! time . miliseconds ) show Sc = show Ms | | ! ( ! time . seconds ) show Hr = true break case 'mm :ss ' : show Ms = ! ( ! time . miliseconds ) show Sc = true show Hr = ! ( ! time . hours ) break case 'mm :ss .sss ' : show Ms = true show Sc = true show Hr = ! ( ! time . hours ) break default : throw new Error ( TIME _FORMAT _ERRMSG ) } let hh = zero Fill ( 2 , time . hours ) let mm = zero Fill ( 2 , time . minutes ) let ss = zero Fill ( 2 , time . seconds ) let sss = zero Fill ( 3 , time . miliseconds ) return ( time . negative ? ' - ' : ' ' ) + ( show Hr ? ( show Ms ? ` $ { hh } $ { mm } $ { ss } $ { sss } ` : show Sc ? ` $ { hh } $ { mm } $ { ss } ` : ` $ { hh } $ { mm } ` ) : ( show Ms ? ` $ { mm } $ { ss } $ { sss } ` : ` $ { mm } $ { ss } ` ) ) } 
function to Mac Address ( internal Representation ) { const parts = [ ] ; 
function get Attrs ( ) { if ( attr Res ! = = null ) { return attr Res ; } ; var xmlns Alias ; var ns Attr Name ; var attr List = is Namespace & & has Surmise NS ? [ ] : null ; var i = attr Start Pos + 1 ; 
function Hexdump ( data , options ) { var self = this ; self . hexdump = [ ] ; self . hex = false ; self . options = { container : options . container | | ' ' , width : options . width | | 1 6 , byte Grouping : options . byte Grouping | | 0 , ascii : options . ascii , line Number : options . line Number , endian : options . endian | | 'big ' , html : options . html , base : options . base | | 'hexadecimal ' , non Printable : options . non Printable | | ' . ' , style : { line Number Left : options . style . line Number Left | | ' ' , line Number Right : options . style . line Number Right | | ' : ' , string Left : options . style . string Left | | ' | ' , string Right : options . style . string Right | | ' | ' , hex Left : options . style . hex Left | | ' ' , hex Right : options . style . hex Right | | ' ' , hex Null : options . style . hex Null | | ' . ' , string Null : options . style . string Null | | ' ' } } ; if ( self . options . base = = 'hex ' ) { self . hex = true ; } else if ( self . options . base = = 'hexadecimal ' ) { self . hex = true ; } ; 
function get ( cz Config ) { const scopes = [ ] ; if ( typeof cz Config . scopes = = = 'undefined ' ) { return defaults ; } for ( const scope of cz Config . scopes ) { scopes . push ( scope . name ) ; } if ( typeof cz Config . scope Overrides = = = 'undefined ' ) { return scopes ; } for ( const type of Object . keys ( cz Config . scope Overrides ) ) { for ( const scope of cz Config . scope Overrides [ type ] ) { scopes . push ( scope . name ) ; } } return scopes . filter ( function ( value , index , scope ) { return scope . index Of ( value ) = = = index ; } ) ; } 
function get ( path Or Cz Config , default Config ) { const config = Object . assign ( clone Deep ( defaults ) , clone Deep ( default Config ) | | { } ) ; let cz Config = path Or Cz Config | | { } ; if ( typeof path Or Cz Config = = = 'string ' ) { cz Config = Cz Config . get ( path Or Cz Config ) ; } 
function get ( path ) { let cz Config ; try { fs . access Sync ( path , fs . R _OK ) ; cz Config = require ( path ) ; } catch ( err ) { cz Config = { } ; } return cz Config ; } 
function get ( cz Config ) { const types = [ ] ; if ( typeof cz Config . types = = = 'undefined ' ) { return defaults ; } for ( const type of cz Config . types ) { types . push ( type . value ) ; } return types ; } 
function Colog ( ) { if ( ( this instanceof Colog ) = = = false ) { return new Colog ( ) ; } var self = this ; var base = ' \x 1B [ %dm ' ; var reset = 0 ; var color Light Value Change = 6 0 ; var last Command = 'log ' ; var last Line Length = 0 ; var color = { 'black ' : [ 3 0 , 3 9 ] , 'red ' : [ 3 1 , 3 9 ] , 'green ' : [ 3 2 , 3 9 ] , 'yellow ' : [ 3 3 , 3 9 ] , 'blue ' : [ 3 4 , 3 9 ] , 'magenta ' : [ 3 5 , 3 9 ] , 'cyan ' : [ 3 6 , 3 9 ] , 'white ' : [ 3 7 , 3 9 ] } ; var background = { 'black ' : [ 4 0 , 4 9 ] , 'red ' : [ 4 1 , 4 9 ] , 'green ' : [ 4 2 , 4 9 ] , 'yellow ' : [ 4 3 , 4 9 ] , 'blue ' : [ 4 4 , 4 9 ] , 'magenta ' : [ 4 5 , 4 9 ] , 'cyan ' : [ 4 6 , 4 9 ] , 'white ' : [ 4 7 , 4 9 ] } ; var effect = { 'b ' : [ 1 , 2 2 ] , 'u ' : [ 4 , 2 4 ] , 'i ' : [ 7 , 2 7 ] , 's ' : [ 9 , 2 9 ] , 'bold ' : [ 1 , 2 2 ] , 'underline ' : [ 4 , 2 4 ] , 'inverse ' : [ 7 , 2 7 ] , 'strike ' : [ 9 , 2 9 ] } ; var progress = [ 0 , 1 0 0 ] ; var defaults = { progress : { zero : ' ░ ' , one : ' ▓ ' , length : 4 0 , sufix : ' ~ %d % % ( %s / %s ) ' , effects : [ 'color Yellow ' ] , description : ' ' } } ; var be Silent = false ; var console Width = 1 0 0 ; if ( process . stdout . is TTY ) { console Width = process . stdout . get Window Size ( ) [ 0 ] ; process . stdout . on ( 'resize ' , function ( ) { console Width = process . stdout . get Window Size ( ) [ 0 ] ; } ) ; } function use ( code , light Color ) { return util . format ( base , ( light Color = = = true ) ? code + color Light Value Change : code ) ; } function text ( message , effect , light Color ) { return [ use ( effect [ 0 ] , light Color ) , String ( message ) , use ( effect [ 1 ] , light Color ) ] . join ( ' ' ) ; } function clear Line ( ) { if ( process . stdout . clear Line ) { process . stdout . clear Line ( ) ; process . stdout . cursor To ( 0 ) ; } else { var str = ' \r ' , i = 0 ; for ( i = 0 ; i < last Line Length ; i + + ) { str + = ' ' ; } process . stdout . write ( str ) ; } last Line Length = 0 ; return self ; } this . silent = function ( is Silent ) { be Silent = ( is Silent ) ? true : false ; } this . get Width = function ( ) { return console Width ; } ; this . configure Progress = function ( zero , one , length , effects ) { length = Math . abs ( parse Int ( length , 1 0 ) ) ; defaults . progress . zero = ( zero ! = = undefined ) ? zero : defaults . progress . zero ; defaults . progress . one = ( one ! = = undefined ) ? one : defaults . progress . one ; defaults . progress . length = ( length > 0 ) ? length : defaults . progress . length ; defaults . progress . effects = ( effects instanceof Array ) ? effects : defaults . progress . effects ; return this ; } ; this . set Progress Description = function ( text ) { text = String ( text ) ; defaults . progress . description = text ; return this ; } ; this . progress = function ( min Or Change , max , effects , return String ) { if ( be Silent ) { return this ; } if ( last Command = = = 'progress ' ) { clear Line ( ) ; } var i = 0 , prc = 0 , full Bars To Draw = 0 , empty Bars To Draw = 0 , total Bars = defaults . progress . length ; * Return "reset all effects " code * @returns { * } * / this . reset = function ( ) { return use ( reset ) ; } ; this . b = function ( message ) { return text ( message , effect . bold ) ; } ; this . u = function ( message ) { return text ( message , effect . underline ) ; } ; this . s = function ( message ) { return text ( message , effect . strike ) ; } ; this . i = function ( message ) { return text ( message , effect . inverse ) ; } ; this . bold = function ( message ) { return this . b ( message ) ; } ; this . underline = function ( message ) { return this . u ( message ) ; } ; this . strike = function ( message ) { return this . s ( message ) ; } ; this . inverse = function ( message ) { return this . i ( message ) ; } ; this . color = function ( message , name , light ) { if ( color [ name ] = = = undefined ) { var colors = [ ] , c ; for ( c in color ) { if ( color . has Own Property ( c ) ) { colors . push ( c ) ; } } throw new Error ( 'Undefined color . Use : ' + colors . join ( ' , ' ) ) ; } return text ( message , color [ name ] , light ) ; } ; this . black = function ( message , light ) { return text ( message , color . black , light ) ; } ; this . red = function ( message , light ) { return text ( message , color . red , light ) ; } ; this . green = function ( message , light ) { return text ( message , color . green , light ) ; } ; this . yellow = function ( message , light ) { return text ( message , color . yellow , light ) ; } ; this . blue = function ( message , light ) { return text ( message , color . blue , light ) ; } ; this . magenta = function ( message , light ) { return text ( message , color . magenta , light ) ; } ; this . cyan = function ( message , light ) { return text ( message , color . cyan , light ) ; } ; this . white = function ( message , light ) { return text ( message , color . white , light ) ; } ; this . color Black = function ( message , light ) { return this . black ( message , light ) ; } ; this . color Red = function ( message , light ) { return this . red ( message , light ) ; } ; this . color Green = function ( message , light ) { return this . green ( message , light ) ; } ; this . color Yellow = function ( message , light ) { return this . yellow ( message , light ) ; } ; this . color Blue = function ( message , light ) { return this . blue ( message , light ) ; } ; this . color Magenta = function ( message , light ) { return this . magenta ( message , light ) ; } ; this . color Cyan = function ( message , light ) { return this . cyan ( message , light ) ; } ; this . color White = function ( message , light ) { return this . white ( message , light ) ; } ; this . background = function ( message , name , light ) { if ( background [ name ] = = = undefined ) { var backgrounds = [ ] , b ; for ( b in background ) { if ( background . has Own Property ( b ) ) { backgrounds . push ( b ) ; } } throw new Error ( 'Undefined color . Use : ' + backgrounds . join ( ' , ' ) ) ; } return text ( message , background [ name ] , light ) ; } ; this . bg Black = function ( message , light ) { return text ( message , background . black , light ) ; } ; this . bg Red = function ( message , light ) { return text ( message , background . red , light ) ; } ; this . bg Green = function ( message , light ) { return text ( message , background . green , light ) ; } ; this . bg Yellow = function ( message , light ) { return text ( message , background . yellow , light ) ; } ; this . bg Blue = function ( message , light ) { return text ( message , background . blue , light ) ; } ; this . bg Magenta = function ( message , light ) { return text ( message , background . magenta , light ) ; } ; this . bg Cyan = function ( message , light ) { return text ( message , background . cyan , light ) ; } ; this . bg White = function ( message , light ) { return text ( message , background . white , light ) ; } ; this . background Black = function ( message , light ) { return this . bg Black ( message , light ) ; } ; this . background Red = function ( message , light ) { return this . bg Red ( message , light ) ; } ; this . background Green = function ( message , light ) { return this . bg Green ( message , light ) ; } ; this . background Yellow = function ( message , light ) { return this . bg Yellow ( message , light ) ; } ; this . background Blue = function ( message , light ) { return this . bg Blue ( message , light ) ; } ; this . background Magenta = function ( message , light ) { return this . bg Magenta ( message , light ) ; } ; this . background Cyan = function ( message , light ) { return this . bg Cyan ( message , light ) ; } ; this . background White = function ( message , light ) { return this . bg White ( message , light ) ; } ; this . log = function ( message ) { if ( be Silent ) { return this ; } if ( last Command = = = 'progress ' | | last Command = = = 'write ' ) { this . write ( ' \n ' ) ; } last Command = 'log ' ; console . log ( message ) ; message + = ' ' ; last Line Length = message . length ; return this ; } ; this . write = function ( message ) { if ( be Silent ) { return this ; } last Command = 'write ' ; process . stdout . write ( message ) ; message = String ( message ) ; if ( last Command = = = 'write ' ) { last Line Length + = message . length ; } else { last Line Length = message . length ; } return this ; } ; this . info = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'white ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . success = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'green ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . warning = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'yellow ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . error = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'red ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . question = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'cyan ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . answer = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'magenta ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . header Info = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'black ' , 'bg White ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . header Success = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'white ' , 'bg Green ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . header Warning = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'black ' , 'bg Yellow ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . header Error = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'white ' , 'bg Red ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . header Question = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'white ' , 'bg Cyan ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . header Answer = function ( message , return String ) { var str = this . apply ( message , [ 'bold ' , 'white ' , 'bg Magenta ' ] ) ; return return String = = = true ? str : this . log ( str ) ; } ; this . apply = function ( message , effects ) { if ( ( effects instanceof Array ) = = = false ) { throw new Error ( 'Effects must be an array ' ) ; } if ( ! effects . length ) { return message ; } var i = 0 , limit = effects . length ; for ( i = 0 ; i < limit ; i + + ) { if ( this . has Own Property ( effects [ i ] ) & & typeof this [ effects [ i ] ] = = = 'function ' ) { message = this [ effects [ i ] ] ( message ) ; } else { var all Effects = [ ] , e = ' ' ; for ( e in this ) { if ( this . has Own Property ( e ) & & ( ( e . index Of ( 'color ' ) = = = 0 & & e ! = = 'color ' ) | | ( e . index Of ( 'background ' ) = = = 0 & & e ! = = 'background ' ) | | effect [ e ] ! = = undefined ) ) { all Effects . push ( e ) ; } } throw new Error ( util . format ( 'Invalid effect " %s " , you can use " %s " ' , effects [ i ] , all Effects . join ( ' " , " ' ) ) ) ; } } return message ; } ; this . dump = function ( variable , effects ) { if ( be Silent ) { return this ; } if ( ! ( effects instanceof Array ) ) { effects = [ ] ; } effects = this . apply ( ' \n ' , effects ) ; effects = effects . split ( ' \n ' ) ; this . write ( effects [ 0 ] ) ; this . write ( util . inspect ( ( typeof variable = = = 'function ' ) ? variable . to String ( ) : variable ) ) ; this . write ( effects [ 1 ] + ' \n ' ) ; return this ; } ; this . get All Effects = function ( ) { var all Effects = [ ] , e = ' ' ; for ( e in this ) { if ( this . has Own Property ( e ) & & ( ( e . index Of ( 'color ' ) = = = 0 & & e ! = = 'color ' ) | | ( ( e . index Of ( 'background ' ) = = = 0 | | e . index Of ( 'bg ' ) = = = 0 ) & & e ! = = 'background ' ) | | effect [ e ] ! = = undefined | | color [ e ] ! = = undefined ) ) { all Effects . push ( e ) ; } } return all Effects ; } ; this . format = function ( ) { if ( be Silent ) { return this ; } this . log ( this . get Format . apply ( this . get Format , arguments ) ) ; return this ; } ; this . get Format = function ( ) { var message = arguments . length > 0 ? arguments [ 0 ] : ' ' ; message = util . format . apply ( util . format , arguments ) ; var all = self . get All Effects ( ) , i = 0 , limit = all . length , apply Callback = function ( match , content ) { return self . apply ( content , [ all [ i ] ] ) ; } ; for ( i = 0 ; i < limit ; i + + ) { message = message . replace ( new Reg Exp ( util . format ( ' < %s > ( [ \ \s \ \S ] * ? ) < \ / %s > ' , all [ i ] , all [ i ] ) , 'g ' ) , apply Callback ) ; } return message ; } ; this . strip Format = function ( ) { var message = arguments . length > 0 ? arguments [ 0 ] : ' ' ; message = util . format . apply ( util . format , arguments ) ; var all = this . get All Effects ( ) , i = 0 , limit = all . length , apply Callback = function ( match , content ) { return content ; } ; for ( i = 0 ; i < limit ; i + + ) { message = message . replace ( new Reg Exp ( util . format ( ' < %s > ( [ \ \s \ \S ] * ? ) < \ / %s > ' , all [ i ] , all [ i ] ) , 'g ' ) , apply Callback ) ; } return message ; } ; this . nl = function ( ) { this . write ( ' \n ' ) ; return this ; } ; this . new Line = this . nl ; this . status = function ( text , status , text Effects , status Effects , return String ) { if ( be Silent ) { return this ; } if ( text instanceof Object ) { text = text . to String ( ) ; } if ( status instanceof Object ) { status = status . to String ( ) ; } var text Len = this . strip Format ( text ) . length , status Len = this . strip Format ( status ) . length , empty Length = console Width - ( text Len + status Len ) , empty String = ' ' , i = 0 , str = ' ' ; text = this . get Format ( text ) ; status = this . get Format ( status ) ; if ( text Effects instanceof Array ) { text = this . apply ( text , text Effects ) ; } if ( status Effects instanceof Array ) { status = this . apply ( status , status Effects ) ; } if ( empty Length < 2 ) { empty Length = 2 ; } empty Length - = 1 ; for ( i = 0 ; i < empty Length ; i + + ) { empty String = empty String + ' ' ; } str = text + empty String + status ; if ( return String = = = true ) { return str ; } this . log ( str ) ; return this ; } ; } 
function use ( code , light Color ) { return util . format ( base , ( light Color = = = true ) ? code + color Light Value Change : code ) ; } 
function text ( message , effect , light Color ) { return [ use ( effect [ 0 ] , light Color ) , String ( message ) , use ( effect [ 1 ] , light Color ) ] . join ( ' ' ) ; } 
function clear Line ( ) { if ( process . stdout . clear Line ) { process . stdout . clear Line ( ) ; process . stdout . cursor To ( 0 ) ; } else { var str = ' \r ' , i = 0 ; for ( i = 0 ; i < last Line Length ; i + + ) { str + = ' ' ; } process . stdout . write ( str ) ; } last Line Length = 0 ; return self ; } 
function ( ) { L . Dom Util . empty ( this . _container ) ; var legends = this . options . legends ; if ( ! legends ) return ; legends . for Each ( function ( legend ) { if ( ! legend . elements ) return ; var elements = legend . elements ; var class Name = 'legend -block ' ; if ( this . options . detect Stretched ) { if ( elements . length = = = 3 & & elements [ 0 ] . label ! = = ' ' & & elements [ 1 ] . label = = = ' ' & & elements [ 2 ] . label ! = = ' ' ) { legend . type = 'stretched ' ; } } if ( legend . type = = = 'stretched ' ) { class Name + = ' legend -stretched ' ; } var block = L . Dom Util . create ( 'div ' , class Name , this . _container ) ; if ( this . options . collapse Simple & & elements . length = = 1 & & ! elements [ 0 ] . label ) { this . _add Element ( elements [ 0 ] . image Data , legend . name , block ) ; return ; } if ( legend . name ) { var header = L . Dom Util . create ( 'h 4 ' , null , block ) ; L . Dom Util . create ( 'div ' , 'caret ' , header ) ; L . Dom Util . create ( 'span ' , null , header ) . inner HTML = legend . name ; L . Dom Event . on ( header , 'click ' , function ( ) { if ( L . Dom Util . has Class ( header , 'closed ' ) ) { L . Dom Util . remove Class ( header , 'closed ' ) ; } else { L . Dom Util . add Class ( header , 'closed ' ) ; } } , this ) ; } var element Container = L . Dom Util . create ( 'div ' , 'legend -elements ' , block ) ; elements . for Each ( function ( element ) { this . _add Element ( element . image Data , element . label , element Container ) ; } , this ) ; } , this ) ; } 
function update Location ( method ) { return function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } return { type : _constants . CALL _HISTORY _METHOD , payload : { method : method , args : args } } ; } ; } 
function get Header ( data ) { var header = { } header . umid = data . slice ( 0 , 3 ) header . mt _version = data . slice ( 3 , 5 ) header . rics = data . slice ( 5 , 9 ) header . key _id = data . slice ( 9 , 1 4 ) return header } 
function shoelace ( edges ) { var area = 0 ; var _iterator Normal Completion = true ; var _did Iterator Error = false ; var _iterator Error = undefined ; try { for ( var _iterator = edges [ Symbol . iterator ] ( ) , _step ; ! ( _iterator Normal Completion = ( _step = _iterator . next ( ) ) . done ) ; _iterator Normal Completion = true ) { var _step $value = _sliced To Array ( _step . value , 2 ) ; var u = _step $value [ 0 ] ; var v = _step $value [ 1 ] ; area + = vcross 2 ( u , v ) ; } } catch ( err ) { _did Iterator Error = true ; _iterator Error = err ; } finally { try { if ( ! _iterator Normal Completion & & _iterator [ "return " ] ) { _iterator [ "return " ] ( ) ; } } finally { if ( _did Iterator Error ) { throw _iterator Error ; } } } return Math . abs ( area ) / 2 ; } 
function topleft ( compare ) { return function ( a , b ) { var d ; d = compare ( a [ 0 ] , b [ 0 ] ) ; if ( d ! = = 0 ) { return d ; } return compare ( b [ 1 ] , a [ 1 ] ) ; } ; } 
function DCELMesh ( vertices , edges , faces ) { this . vertices = vertices ; this . edges = edges ; this . faces = faces ; } 
function cosval ( a , b , c ) { return cossign ( a , b , c ) / dist ( a , b ) / dist ( b , c ) ; } 
function sinval ( a , b , c ) { return sinsign ( a , b , c ) / dist ( a , b ) / dist ( b , c ) ; } 
function monotonic ( compare , d ) { return function ( a , b ) { return compare ( a [ d ] , b [ d ] ) ; } ; } 
function det 3 ( A 0 0 , A 0 1 , A 0 2 , A 1 0 , A 1 1 , A 1 2 , A 2 0 , A 2 1 , A 2 2 ) { return A 0 0 * A 1 1 * A 2 2 + A 0 1 * A 1 2 * A 2 0 + A 0 2 * A 1 0 * A 2 1 - A 2 0 * A 1 1 * A 0 2 - A 2 1 * A 1 2 * A 0 0 - A 2 2 * A 1 0 * A 0 1 ; } 
function scalar 2 ( a , b ) { var c ; c = vsub 2 ( a , b ) ; return vdot 2 ( c , c ) ; } 
function cossign ( x , y , z ) { return ( y [ 0 ] - x [ 0 ] ) * ( y [ 0 ] - z [ 0 ] ) + ( y [ 1 ] - x [ 1 ] ) * ( y [ 1 ] - z [ 1 ] ) ; } 
function sinsign ( a , b , c ) { return ( b [ 0 ] - a [ 0 ] ) * ( c [ 1 ] - a [ 1 ] ) - ( b [ 1 ] - a [ 1 ] ) * ( c [ 0 ] - a [ 0 ] ) ; } 
function rayshoot ( d , m , A , b , z , r ) { var i = 0 ; var j = m ; var w = undefined ; while ( true ) { if ( i > = j ) return j ; var h = A [ i ] ; w = ( b [ i ] - vdot ( d , h , z ) ) / vdot ( d , h , r ) ; if ( w > = 0 ) break ; + + i ; } var k = i ; while ( true ) { + + i ; if ( i > = j ) return k ; var h = A [ i ] ; var l = ( b [ i ] - vdot ( d , h , z ) ) / vdot ( d , h , r ) ; if ( l < 0 | | l > = w ) continue ; k = i ; w = l ; } } 
function vdot ( d , u , v ) { var s = 0 ; for ( var i = 0 ; i < d ; + + i ) { s + = u [ i ] * v [ i ] ; } return s ; } 
function get Plugins ( ) { var plugins = [ ] ; 
function generate Statsd Routes ( stats ) { var result = { } ; Object . keys ( stats ) . for Each ( function ( name ) { var routes = stats [ name ] ; if ( ! ( routes instanceof Array ) ) { routes = [ routes ] ; } routes . for Each ( function ( route ) { result [ route . path ] = { name : name , methods : route . method ? route . method : route . methods } ; } ) ; } ) ; return result ; } 
function time Output ( difference , time Value , plural Time Name ) { let result = ' ' ; if ( Math . round ( difference / time Value ) = = = 1 ) { result = ` $ { plural Time Name . substring ( 0 , plural Time Name . length - 1 ) } ` ; } else { result = ` $ { Math . round ( difference / time Value ) } $ { plural Time Name } ` ; } return result ; } 
function Rest Client ( base Url ) { if ( typeof base Url ! = = 'string ' ) { if ( typeof document ! = = 'undefined ' ) { base Url = document . get Element By Id ( 'base Url Holder ' ) . get Attribute ( 'data ' ) + ' /api / ' ; } else { base Url = ' /api / ' ; } } this . organizations = new Organizations Client ( base Url ) ; this . projects = new Projects Client ( base Url ) ; this . user = new User Client ( base Url ) ; this . users = new Users Client ( base Url ) ; this . get Status = ( ) = > { return this . user . get ( [ 'status ' ] ) ; } ; } 
function register ( ports , log ) { 
function storage Push To Set ( [ key , value ] ) { log ( 'storage Push To Set ' , key , value ) ; const item = get Local Storage Item ( key ) ; const list = Array . is Array ( item ) ? item : [ ] ; if ( list . index Of ( value ) = = = - 1 ) { list . push ( value ) ; } set Local Storage Item ( key , list ) ; } 
function get Local Storage Item ( key ) { try { return JSON . parse ( window . local Storage . get Item ( key ) ) ; } catch ( e ) { return null ; } } 
function set Local Storage Item ( key , value ) { window . local Storage . set Item ( key , JSON . stringify ( value ) ) ; } 
function task Graph Runner ( opts ) { let graph = opts . graph ; let task = opts . task ; let force = opts . force | | false ; let safe = true ; let queue = new Set ( graph . keys ( ) ) ; let running = new Set ( ) ; function get Next Chunk ( ) { let chunk = [ ] ; let current = new Map ( ) ; if ( ! queue . size ) { return chunk ; } for ( let key of queue ) { let deps = graph . get ( key ) | | [ ] ; let curr = deps . filter ( dep = > queue . has ( dep ) ) ; current . set ( key , curr ) ; if ( ! curr . length ) { chunk . push ( key ) ; } } if ( chunk . length = = = 0 ) { if ( ! force ) { throw new Error ( 'Cycle detected in graph ' ) ; } let items = Array . from ( queue ) ; let sorted = items . sort ( ( a , b ) = > { let a Curr = current . get ( a ) | | [ ] ; let b Curr = current . get ( b ) | | [ ] ; let deps = a Curr . length - b Curr . length ; if ( deps ! = = 0 ) return deps ; let a Children = items . filter ( item = > array Includes ( current . get ( item ) | | [ ] , a ) ) ; let b Children = items . filter ( item = > array Includes ( current . get ( item ) | | [ ] , b ) ) ; return b Children . length - a Children . length ; } ) ; let first = sorted [ 0 ] ; chunk . push ( first ) ; safe = false ; } chunk = chunk . filter ( key = > { let deps = graph . get ( key ) | | [ ] ; return ! deps . find ( dep = > running . has ( dep ) ) ; } ) ; for ( let key of chunk ) { queue . delete ( key ) ; } return chunk ; } let values = new Map ( ) ; function next ( ) { let chunk = get Next Chunk ( ) ; let promises = [ ] ; for ( let key of chunk ) { running . add ( key ) ; promises . push ( Promise . resolve ( task ( key ) ) . then ( result = > { running . delete ( key ) ; values . set ( key , result ) ; if ( queue . size ) { return next ( ) ; } } ) ) ; } return Promise . all ( promises ) ; } return new Promise ( ( resolve , reject ) = > { return next ( ) . then ( resolve , reject ) ; } ) . then ( ( ) = > { return { safe , values } ; } ) ; } 
function ( options ) { var self = this ; options = options | | { } ; events . Event Emitter . call ( this ) ; this . _counter = 0 ; this . _last Send = 0 ; this . _packets = new Array ( ) ; this . _sending = false ; this . _opened = false ; this . _serial Port = new Serial Port ( options . port , { baudrate : 1 1 5 2 0 0 } ) ; this . _emitter = new events . Event Emitter ( ) ; this . _emitter . on ( "send Data " , function ( ) { if ( self . _packets . length > 0 ) { var packet = self . _packets . shift ( ) ; 
function run ( options ) { if ( options . results ) { return map ( options ) ; } return fetch ( options ) . then ( map . bind ( null , options ) ) ; } 
function fetch ( options ) { var time , promise , resolve , reject ; time = new Date ( ) ; promise = new Promise ( function ( r 1 , r 2 ) { resolve = r 1 ; reject = r 2 ; } ) ; try { options = normalise ( options ) ; if ( options . result Ids ) { wpt . get Results ( options , options . result Ids ) . then ( after ) ; } else { wpt . run Tests ( options ) . then ( wpt . get Results . bind ( null , options ) ) . then ( after ) ; } } catch ( error ) { reject ( error ) ; } return promise ; function after ( results ) { results = { data : results , options : options , times : { begin : time , end : new Date ( ) } } ; if ( options . dump ) { dump ( options , results ) ; } resolve ( results ) ; } } 
function map ( options , results ) { var promise , resolve , reject ; promise = new Promise ( function ( r 1 , r 2 ) { resolve = r 1 ; reject = r 2 ; } ) ; try { 
function set Hide Props ( target , prop Key , value ) { Object . define Property ( target , prop Key , { value , configurable : true , enumerable : false } ) } 
function List ( init = [ ] , Type , options = { } ) { class Call Check ( this , List ) const arr = observable . array ( [ ] , options ) Observable Array . apply ( this , [ [ ] , arr . $mobx . enhancer ] ) add Hide Props ( this , ' _Type ' , Type ) this . assign ( init ) } 
function on Message ( msg , rinfo ) { 
function ( o ) { function Created Object ( ) { } Created Object . prototype = o ; var tmp = new Created Object ( ) ; tmp . _ _proto _ _ = o ; return tmp ; } 
function to Ring Class ( claz ) { if ( claz . _ _class Id _ _ ) return ; var proto = ! Object . get Own Property Names ? claz . prototype : ( function ( ) { var keys = { } ; ( function crawl ( p ) { if ( p = = = Object . prototype ) return ; _ . extend ( keys , _ . chain ( Object . get Own Property Names ( p ) ) . map ( function ( el ) { return [ el , true ] ; } ) . from Pairs ( ) . value ( ) ) ; crawl ( Object . get Prototype Of ( p ) ) ; } ) ( claz . prototype ) ; return _ . from Pairs ( _ . map ( _ . keys ( keys ) , function ( k ) { return [ k , claz . prototype [ k ] ] ; } ) ) ; } ) ( ) ; proto = _ . chain ( proto ) . map ( function ( v , k ) { return [ k , v ] ; } ) . filter ( function ( el ) { return el [ 0 ] ! = = "constructor " & & el [ 0 ] ! = = " _ _proto _ _ " ; } ) . from Pairs ( ) . value ( ) ; var id = class Counter + + ; _ . extend ( claz , { _ _mro _ _ : [ claz , ring . Object ] , _ _properties _ _ : _ . extend ( { } , proto , { _ _ring Constructor _ _ : function ( ) { this . $super . apply ( this , arguments ) ; var tmp = this . $super ; this . $super = null ; try { claz . apply ( this , arguments ) ; } finally { this . $super = tmp ; } } } ) , _ _class Id _ _ : id , _ _parents _ _ : [ ring . Object ] , _ _class Index _ _ : { " 1 " : ring . Object } , _ _ring Converted Object _ _ : true } ) ; claz . _ _class Index _ _ [ id ] = claz ; } 
function mixed Renderer ( model , props Or Class Name , props , . . . children ) { if ( model & & typeof model = = = 'object ' ) { if ( typeof props Or Class Name = = = 'string ' ) { props Or Class Name = { class Name : props Or Class Name } props = props | | { } props = { . . . props , . . . props Or Class Name } } else { children = [ props ] . concat ( children ) props = props Or Class Name } return r . apply ( this , [ model , props , . . . children ] ) } return h . apply ( this , arguments ) } 
function url Sync ( url Key Or Target , property , descriptor ) { if ( invoked With Args ( arguments ) ) { let options = property return ( target , property , descriptor ) = > urlsync ( url Key Or Target | | property , { . . . key Map , . . . options } , target , property , descriptor ) } return urlsync ( property , key Map , url Key Or Target , property , descriptor ) } 
function ZWave Device Connection ( ip Address Family , ip Address , psk Identity , psk Password ) { 
function ( this Object , command Class , request Command , data , response Command , response Matching Id ) { if ( typeof response Matching Id = = = "undefined " ) { 
function ( this Object , command Class , command , data ) { if ( typeof data = = = "undefined " ) { 
function ( this Object , data , rinfo ) { if ( typeof data = = = "undefined " ) { 
function Message Waiting For Ack ( callback , timeout Timestamp , timeout Object , response Callback Object ) { this . callback = callback ; this . timeout Timestamp = timeout Timestamp ; this . timeout Object = timeout Object ; this . response Callback Object = response Callback Object ; 
function ZWave Command Callback ( command Class , command , match Identifier , callback , timeout In Milliseconds , timeout Object , is Wrapped In Zip Frame ) { this . command Class = command Class ; this . command = command ; this . match Identifier = match Identifier ; this . callback = callback ; this . timeout In Milliseconds = timeout In Milliseconds ; this . timeout Timestamp = add Time ( process . hrtime ( ) , timeout In Milliseconds ) ; 
function ( config , webpack ) { config . entry . PICIDAE _ENTRY = [ config . entry . PICIDAE _ENTRY , require . resolve ( ' . . / ' ) ] console . log ( config . entry ) config . resolve = config . resolve | | { } config . resolve . alias = Object . assign ( { } , alias , config . resolve . alias ) return config } 
function ( ) { if ( ! _pagination Data . links . next = = = null | | ! _pagination Data . links . previous ) { return { } ; } 
function ensure Name Form ( name , i ) { var pos = i | | 0 ; 
function ( type , i ) { return maybe ( utils . find ( maybe ( this . get Name Form ( i ) ) . parts , { type : type } ) ) . value ; } 
function ( full Text , i ) { this . changed = true ; var name Form = ensure Name Form ( this , i ) ; if ( ! ! full Text ) { name Form . full Text = full Text ; } else { delete name Form . full Text ; } 
function ( name , type , i ) { this . changed = true ; var name Form = ensure Name Form ( this , i ) ; if ( ! utils . is Array ( name Form . parts ) ) { name Form . parts = [ ] ; } var part = utils . find ( name Form . parts , { type : type } ) ; if ( ! ! name ) { if ( ! part ) { part = { type : type } ; name Form . parts . push ( part ) ; } part . value = name ; } else if ( ! ! part ) { name Form . parts . splice ( name Form . parts . index Of ( part ) , 1 ) ; } 
function pedigree Convenience Function Generator ( number Label ) { return { get Persons : function ( ) { return maybe ( this . get Data ( ) ) . persons ; } , exists : function ( num ) { return ! ! maybe ( maybe ( utils . find ( maybe ( this . get Data ( ) ) . persons , match Person Num ( number Label , num ) ) ) . data ) . id ; } , get Person : function ( num ) { return utils . find ( maybe ( this . get Data ( ) ) . persons , match Person Num ( number Label , num ) ) ; } } ; } 
function get Root ( response ) { var obj = response . get Data ( ) ; if ( obj ) { if ( obj . persons ) { return obj . persons ; } else if ( obj . child And Parents Relationships ) { return obj . child And Parents Relationships ; } else if ( obj . relationships ) { return obj . relationships ; } } return { } ; } 
function ( client ) { this . settings = client . settings ; this . client = client ; this . access Token Inactive Timer = null ; this . access Token Creation Timer = null ; } 
function ( object ) { var parts = [ ] ; for ( var param in object ) { if ( object . has Own Property ( param ) ) { parts . push ( encode URIComponent ( param ) + ' = ' + encode URIComponent ( object [ param ] ) ) ; } } return parts . join ( ' & ' ) ; } 
function ( query String ) { var pairs = query String . split ( ' & ' ) ; var params = { } ; pairs . for Each ( function ( pair ) { pair = pair . split ( ' = ' ) ; params [ pair [ 0 ] ] = decode URIComponent ( pair [ 1 ] | | ' ' ) ; } ) ; return params ; } 
function template Matches ( template , obj ) { for ( var key in template ) { if ( template . has Own Property ( key ) & & obj [ key ] ! = = template [ key ] ) { return false ; } } return true ; } 
function require Used ( files ) { if ( files ) { var file Pattern ; for ( var i = files . length ; i > 0 ; i - - ) { file Pattern = files [ i ] & & files [ i ] . pattern ; if ( typeof file Pattern = = = 'string ' & & ( file Pattern . index Of ( ' \ \karma -requirejs \ \ ' ) ! = = - 1 | | file Pattern . index Of ( ' /karma -requirejs / ' ) ! = = - 1 ) ) { return true ; } if ( typeof file Pattern = = = 'string ' & & ( file Pattern . index Of ( ' \ \karma -cajon \ \ ' ) ! = = - 1 | | file Pattern . index Of ( ' /karma -cajon / ' ) ! = = - 1 ) ) { return true ; } } } return false ; } 
function create Parser ( _options , _extra Plugins ) { 
function apply Plugin ( extra Plugin ) { if ( Array . is Array ( extra Plugin ) ) { const plugin = extra Plugin [ 0 ] const config = extra Plugin [ 1 ] return parser . use ( plugin , config | | { } ) } parser . use ( extra Plugin ) } 
function lift Feedback Loop ( loops , mappings ) { return function ( outer State , scheduler ) { var embeded Loops = loops . map ( function ( loop ) { return loop ( outer State . pipe ( map _ 1 . map ( mappings . map State ) ) , scheduler ) . pipe ( map _ 1 . map ( mappings . map Event ) ) ; } ) ; return rx . merge . apply ( rx , embeded Loops ) ; } ; } 
function system ( initial State , reduce , feedback ) { return rx . defer ( function ( ) { var state = new rx . Replay Subject ( 1 ) ; var scheduler = rx . queue Scheduler ; var events = feedback . map ( function ( x ) { return x ( state , scheduler ) ; } ) ; var merged Event = rx . merge . apply ( rx , events ) . pipe ( observe On _ 1 . observe On ( scheduler ) ) ; var events With Effects = merged Event . pipe ( scan _ 1 . scan ( reduce , initial State ) , tap _ 1 . tap ( function ( x ) { state . next ( x ) ; } ) , subscribe On _ 1 . subscribe On ( scheduler ) , start With _ 1 . start With ( initial State ) , observe On _ 1 . observe On ( scheduler ) ) ; var hack On Subscribed = rx . defer ( function ( ) { state . next ( initial State ) ; return rx . empty ( ) ; } ) ; return rx . merge . apply ( rx , [ events With Effects , hack On Subscribed ] ) . pipe ( catch Error _ 1 . catch Error ( function ( e ) { dispatch Error ( e ) ; return rx . throw Error ( e ) ; } ) ) ; } ) ; } 
function materialized Retry Strategy ( strategy ) { return function ( source ) { switch ( strategy . kind ) { case "ignore Error Just Complete " : return source . pipe ( catch Error _ 1 . catch Error ( function ( e ) { dispatch Error ( e ) ; return rx . empty ( ) ; } ) ) ; case "ignore Error And Return " : return source . pipe ( catch Error _ 1 . catch Error ( function ( e ) { dispatch Error ( e ) ; return rx . of ( strategy . value ) ; } ) ) ; case "exponential Backoff " : return rx . defer ( function ( ) { var counter = 1 ; return source . pipe ( tap _ 1 . tap ( function ( ) { counter = 1 ; } , function ( ) { if ( counter * 2 < = strategy . max Backoff Factor ) { counter * = 2 ; } } ) , retry When _ 1 . retry When ( function ( e ) { return e . pipe ( switch Map _ 1 . switch Map ( function ( x ) { dispatch Error ( x ) ; return rx . of ( 0 ) . pipe ( delay _ 1 . delay ( strategy . initial Timeout * counter * 1 0 0 0 ) ) ; } ) ) ; } ) ) ; } ) ; case "catch Error " : return source . pipe ( catch Error _ 1 . catch Error ( function ( e ) { dispatch Error ( e ) ; return rx . of ( strategy . handle ( e ) ) ; } ) ) ; default : return js _extensions _ 1 . unhandled Case ( strategy ) ; } } ; } 
function react ( request , effects , retry Strategy ) { return react With Latest ( function ( state ) { var request Instance = request ( state ) ; return request Instance ! = null ? [ { id : request Instance , request : request Instance } ] : [ ] ; } , function ( request , _ , scheduler ) { return effects ( request , scheduler ) ; } , retry Strategy ) ; } 
function react Set ( requests , effects , retry Strategy ) { return react With Latest ( function ( state ) { var request Instances = requests ( state ) ; var identifiable Requests = [ ] ; request Instances . for Each ( function ( request ) { identifiable Requests . push ( { id : request , request : request } ) ; } ) ; return identifiable Requests ; } , function ( request , _ , scheduler ) { return effects ( request , scheduler ) ; } , retry Strategy ) ; } 
function URL ( url , base URL ) { if ( url ! = undefined ) { let _url = URL . parse Url ( url ) ; if ( _url ! = = false ) return _url ; if ( base URL ) { _url = URL . parse Url ( base URL ) ; if ( _url = = = false ) return ; url = String ( url ) ; if ( url . slice ( 0 , 2 ) = = ' / / ' ) { return URL . parse Url ( _url . protocol + url ) ; } let _path ; if ( url . slice ( 0 , 1 ) = = ' / ' ) { _path = url ; } else { _path = _url . pathname . split ( ' / ' ) ; _path [ _path . length - 1 ] = url ; _path = _path . join ( ' / ' ) ; } return URL . parse Url ( _url . origin + _path ) ; } throw new Syntax Error ( "Failed to construct 'URL ' : Invalid URL " ) ; } } 
function get Element Services ( app , name ) { let forecasts = app . get ( 'forecasts ' ) if ( name ) { forecasts = forecasts . filter ( forecast = > forecast . name = = = name ) } / / Iterate over configured forecast models let services = [ ] for ( let forecast of forecasts ) { for ( let element of forecast . elements ) { let service = app . get Service ( forecast . name + ' / ' + element . name ) if ( service ) { services . push ( service ) } } } return services } 
function fatal Error ( stderr ) { return { errors : [ { message : [ { path : ' ' , code : 0 , line : 0 , start : 0 , descr : stderr } ] } ] } ; } 
function timeline Mouse Down ( e ) { previous XPosition = e . client X ; previous YPosition = e . client Y ; var chart Axes = existing Chart Ref . get Axes ( ) ; var timeline Axes = plot . get Axes ( ) ; var left Bound Val = chart Axes . xaxis . min ; var right Bound Val = chart Axes . xaxis . max ; var event Val = timeline Axes . xaxis . c 2p ( e . client X - plot . offset ( ) . left ) ; if ( ( event Val < left Bound Val | | event Val > right Bound Val ) & & update Existing Chart ) { 
function ( next ) { var options = { type : ctx . type , count : ctx . count , now : ctx . now , now ISOString : ctx . now ISOString , params : { pk : Model . get Id Name ( ) , id : ctx . params . id , relation : ctx . params . relation , custom : ctx . params . custom } } ; if ( ctx . type = = = 'model ' ) { options . params . where = ctx . params . where ; options . params . range = ctx . params . range ; } new _query Builder 2 . default ( options ) . on Complete ( next ) . build ( ) ; } 
function ( query , next ) { switch ( ctx . type ) { case 'model ' : Model . find ( query , next ) ; break ; case 'relation ' : Model . find One ( query , function ( err , instance ) { if ( err ) return next ( err ) ; var builder = new _query Builder 2 . default ( { type : ctx . type , count : ctx . count , now : ctx . now , now ISOString : ctx . now ISOString , params : { range : ctx . params . range , where : ctx . params . where , custom : ctx . params . custom } } ) ; builder . on Complete ( function ( _err , _query ) { if ( _err ) return next ( _err ) ; instance [ ctx . relation | | ctx . params . relation ] ( _query , next ) ; } ) ; builder . build ( ) ; } ) ; break ; case 'nested ' : Model . find One ( query , function ( err , instance ) { return next ( err , instance [ ctx . nested ] ) ; } ) ; break ; default : next ( null , [ ] ) ; } } 
function compute Row Position ( plot , cursor , index , count ) { var width = plot . width ( ) ; var height = plot . height ( ) ; var text Align = 'left ' ; var font Size In Px = Number ( cursor . font Size . substring ( 0 , cursor . font Size . length - 2 ) ) ; var y = cursor . y ; var x = cursor . x ; if ( x > ( width / 2 ) ) { x - = constants . label Padding ; text Align = 'right ' ; } else { x + = constants . label Padding ; } if ( y > ( height / 2 ) ) { y - = constants . label Padding * ( count - index ) + font Size In Px * ( count - 1 - index ) ; } else { y + = constants . label Padding * ( index + 1 ) + font Size In Px * ( index + 1 ) ; } return { x : x , y : y , text Align : text Align } ; } 
function find Item ( options ) { if ( ! options . itemid ) { return { error : 'Must provide the itemid of the saved search ' , options : options } ; } var filters = [ new nlobj Search Filter ( 'itemid ' , null , 'equalto ' , options . itemid ) ] ; var columns = [ new nlobj Search Column ( 'itemid ' ) ] ; return nlapi Search Record ( 'item ' , null , filters , columns ) ; } 
function ( source File Name , code ) { 
function ( options , code ) { var rst = JSON . parse ( JSON . stringify ( options ) ) ; 
function chart Mouse Down ( e ) { if ( ( e . button & & e . button = = = 1 ) | | ( e . which & & e . which = = = 2 ) ) { e . prevent Default ( ) ; var offsets = plot . offset ( ) ; plot . get Placeholder ( ) . append ( ' <div id = "plot -highlight -div " > < /div > ' ) . bind ( 'mousemove ' , middle Mouse Move ) ; $ ( ' #plot -highlight -div ' ) . bind ( 'mouseup ' , chart Mouse Up ) ; that . highlight Container . highlighting = true ; that . highlight Container . start = e . client X ; return ; } that . previous XPosition = e . client X ; that . previous YPosition = e . client Y ; if ( e . shift Key ) { that . pan Type = 'vertical ' ; plot . get Placeholder ( ) . bind ( 'mousemove ' , vert Pan Chart ) ; } else { that . pan Type = 'horizontal ' ; plot . get Placeholder ( ) . bind ( 'mousemove ' , hor Pan Chart ) ; } } 
function get ( self , steam Obj , key ) { steam Obj = steam Obj | | { } ; if ( steam Obj [ key ] ! = = undefined ) { return steam Obj [ key ] ; } else if ( self [ key ] ! = = undefined ) { return self [ key ] ; } else if ( Steam [ key ] ! = = undefined ) { return Steam [ key ] ; } else { throw new Error ( "Missing required field : " + key ) ; } } 
function request ( self , options , callback ) { var _http = get ( self , options , 'secure ' ) ? https : http ; if ( Steam . dev Mode ) console . log ( options ) ; var req = _http . request ( options , function ( res ) { var data , data Str = ' ' ; res . on ( 'data ' , function ( chunk ) { data Str + = chunk ; } ) ; res . on ( 'end ' , function ( ) { var status Code = res . status Code ; if ( status Code ! = = 2 0 0 ) { if ( status Code = = = 4 0 1 ) { return callback ( new Error ( 'Invalid API Key ' ) ) ; } else { return callback ( new Error ( "HTTP " + status Code + " " + http . STATUS _CODES [ status Code ] ) ) ; } } 
function get Params ( self , steam Obj , required Params , optional Params ) { 
function add Interface Method ( interface Name , func Name , f N ) { 
function build Steam Wrapper Method ( interface Name , func Name , default Version , http Method , required Params , optional Params ) { 
function retrieve Steam APIMethods ( key , callback ) { var _steam = new Steam ( ) ; _steam . get Supported APIList ( { key : key } , function ( err , data ) { if ( err ) return callback ( err ) ; var api List = data . apilist ; if ( api List = = = undefined ) return callback ( new Error ( 'No data returned ' ) ) ; api List = api List . interfaces ; 
function filter Element ( fl Json ) { var return Json = { "photo " : { } } ; return Json . photo . title = fl Json . photo . title ; return Json . photo . description = fl Json . photo . description ; return Json . photo . farm = fl Json . photo . farm ; return Json . photo . id = fl Json . photo . id ; return Json . photo . media = fl Json . photo . media ; return Json . photo . secret = fl Json . photo . secret ; return Json . photo . server = fl Json . photo . server ; return Json . photo . urls = fl Json . photo . urls ; return return Json ; } 
function push Flickr Json ( flickr Json ) { if ( ! enabled Cache ) return ; var is Match = false ; var filter Json = filter Element ( flickr Json ) ; for ( var i = 0 ; i < cache Json . length ; i + + ) { if ( cache Json [ i ] . fl . photo . id = = flickr Json . photo . id ) { cache Json [ i ] . fl = filter Json ; is Match = true ; } } if ( ! is Match ) cache Json . push ( { "fl " : filter Json , "expires " : 0 } ) ; } 
function get Flickr Cache Json ( photo Id ) { if ( ! enabled Cache ) return null ; var d = new Date ( ) ; for ( var i = 0 ; i < cache Json . length ; i + + ) { if ( cache Json [ i ] . fl . photo . id = = photo Id ) { if ( cache Json [ i ] . expires > d . get Time ( ) ) { return cache Json [ i ] . fl ; } break ; } } return null ; } 
function get Image Size ( flickr Json , photo _id , photo _size ) { var size Info = { "width " : 0 , "height " : 0 } ; var size Table = { "s " : "Square " , "q " : "Large Square " , "t " : "Thumbnail " , "m " : "Small " , "n " : "Small 3 2 0 " , " - " : "Medium " , "z " : "Medium 6 4 0 " , "c " : "Medium 8 0 0 " , "b " : "Large " , "o " : "Original " } if ( flickr Json & & flickr Json . sizes . size ) { for ( var i = 0 ; i < flickr Json . sizes . size . length ; i + + ) { if ( flickr Json . sizes . size [ i ] . label = = size Table [ photo _size ] ) { size Info . width = flickr Json . sizes . size [ i ] . width ; size Info . height = flickr Json . sizes . size [ i ] . height ; } } } return size Info ; } 
function push Image Size And Express _flickr Json ( image Size , photo _id ) { if ( ! enabled Cache ) return null ; var d = new Date ( ) ; var expires Time = d . get Time ( ) + cache Period ; for ( var i = 0 ; i < cache Json . length ; i + + ) { if ( cache Json [ i ] . fl . photo . id = = photo _id ) { cache Json [ i ] . fl . photo . img Size = image Size ; cache Json [ i ] . expires = expires Time ; } } } 
function ( tag Args ) { if ( ! APIKey ) { throw new Error ( 'flickr _api _key configuration is required ' ) ; } var tag = tag Util . convert Attr ( tag Args ) ; return new Promise ( function ( resolve , reject ) { var fl Json = get Flickr Cache Json ( tag . id ) ; if ( ! fl Json ) { 
function ( tag Args , return Img Attr ) { if ( ! APIKey ) { throw new Error ( 'flickr _api _key configuration is required ' ) ; } var tag = tag Util . convert Attr ( tag Args ) ; return new Promise ( function ( resolve , reject ) { var fl Json = get Flickr Cache Json ( tag . id ) ; if ( ! fl Json | | ! fl Json . photo . img Size ) { 
function has Class ( el , class Name ) { var test ; if ( el . class List ) { test = el . class List . contains ( class Name ) ; } else { var class Name = new Reg Exp ( ' ( ^ | ) ' + class Name + ' ( | $ ) ' , 'gi ' ) ; test = new Reg Exp ( class Name ) . test ( el . class Name ) ; } return test ; } 
function Leipzig Event ( name , data ) { var leipzig Event = undefined ; if ( window . Custom Event ) { leipzig Event = new Custom Event ( name , { detail : data , bubbles : true , cancelable : true } ) ; } else { 
function trigger Event ( el , name , data ) { var e = new Leipzig Event ( name , data ) ; el . dispatch Event ( e ) ; } 
function Leipzig ( selector ) { var config = arguments . length < = 1 | | arguments [ 1 ] = = = undefined ? { } : arguments [ 1 ] ; if ( ! ( this instanceof Leipzig ) ) { return new Leipzig ( selector , config ) ; } if ( typeof selector ! = = 'undefined ' ) { if ( typeof selector = = = 'string ' | | selector instanceof Node List | | selector instanceof Element ) { config . selector = selector ; } else if ( typeof selector = = = 'object ' ) { 
function process Gloss ( gloss , callback ) { if ( ! ( gloss instanceof Element ) ) { var err = new Error ( 'Invalid gloss element ' ) ; if ( typeof callback = = = 'function ' ) { callback ( err ) ; } else { throw err ; } } var lines = Array . prototype . slice . call ( gloss . children ) ; var lines To Align = [ ] ; var first Raw Line = null ; var first Raw Line Num = 0 ; trigger Event ( gloss , events . before Gloss ) ; if ( first Line Orig ) { var first Line = lines [ 0 ] ; add Class ( first Line , classes . original ) ; } if ( last Line Free ) { var last Line = lines [ lines . length - 1 ] ; add Class ( last Line , classes . free Translation ) ; } 
function block Out ( block ) { var width = 8 , len = block . length , stp = len / width , x , y , z ; for ( x = 0 ; x < len ; x + = stp ) { z = [ ] ; for ( y = 0 ; y < width ; y + + ) { z . push ( block [ x + y ] ) ; } console . log ( [ x , z . join ( ) ] . join ( " " ) ) ; } } 
function xor ( ) { var args = [ ] . slice . call ( arguments ) , bits = args . shift ( ) . slice ( ) ; args . for Each ( function ( arg , y ) { arg . for Each ( function ( bit , x ) { bits [ x ] ^ = bit ; } ) ; } ) ; return bits ; } 
function add ( ) { var args = [ ] . slice . call ( arguments ) , bits = args . shift ( ) . slice ( ) ; args . for Each ( function ( arg , y ) { var carry = 0 , len = arg . length , x , z ; for ( x = len - 1 ; x > - 1 ; x - - ) { z = bits [ x ] + arg [ x ] + carry ; switch ( z ) { case 3 : bits [ x ] = one Bit ; carry = 1 ; break ; case 2 : bits [ x ] = zero Bit ; carry = 1 ; break ; case 1 : bits [ x ] = one Bit ; carry = 0 ; break ; case 0 : bits [ x ] = zero Bit ; carry = 0 ; break ; default : throw new Error ( [ "add " , y , x , bits [ x ] , arg [ x ] , carry , z ] . join ( " " ) ) ; break ; } } } ) ; return bits ; } 
function sha 2 5 6 ( message , debugging ) { var debug Output = [ ] , noop = function ( ) { } , out = debugging ? function ( ) { debug Output . push ( [ ] . slice . call ( arguments ) . join ( " " ) ) ; } : noop ; try { var h 0 = hex 2bin ( 0x 6a 0 9e 6 6 7 ) , h 1 = hex 2bin ( 0xbb 6 7ae 8 5 ) , h 2 = hex 2bin ( 0x 3c 6ef 3 7 2 ) , h 3 = hex 2bin ( 0xa 5 4ff 5 3a ) , h 4 = hex 2bin ( 0x 5 1 0e 5 2 7f ) , h 5 = hex 2bin ( 0x 9b 0 5 6 8 8c ) , h 6 = hex 2bin ( 0x 1f 8 3d 9ab ) , h 7 = hex 2bin ( 0x 5be 0cd 1 9 ) ; Initialize array of round constants : (first 3 2 bits of the fractional parts of the cube roots of the first 6 4 primes 2 . . 3 1 1 ) : k [ 0 . . 6 3 ] : = 0x 4 2 8a 2f 9 8 , 0x 7 1 3 7 4 4 9 1 , 0xb 5c 0fbcf , 0xe 9b 5dba 5 , 0x 3 9 5 6c 2 5b , 0x 5 9f 1 1 1f 1 , 0x 9 2 3f 8 2a 4 , 0xab 1c 5ed 5 , 0xd 8 0 7aa 9 8 , 0x 1 2 8 3 5b 0 1 , 0x 2 4 3 1 8 5be , 0x 5 5 0c 7dc 3 , 0x 7 2be 5d 7 4 , 0x 8 0deb 1fe , 0x 9bdc 0 6a 7 , 0xc 1 9bf 1 7 4 , 0xe 4 9b 6 9c 1 , 0xefbe 4 7 8 6 , 0x 0fc 1 9dc 6 , 0x 2 4 0ca 1cc , 0x 2de 9 2c 6f , 0x 4a 7 4 8 4aa , 0x 5cb 0a 9dc , 0x 7 6f 9 8 8da , 0x 9 8 3e 5 1 5 2 , 0xa 8 3 1c 6 6d , 0xb 0 0 3 2 7c 8 , 0xbf 5 9 7fc 7 , 0xc 6e 0 0bf 3 , 0xd 5a 7 9 1 4 7 , 0x 0 6ca 6 3 5 1 , 0x 1 4 2 9 2 9 6 7 , 0x 2 7b 7 0a 8 5 , 0x 2e 1b 2 1 3 8 , 0x 4d 2c 6dfc , 0x 5 3 3 8 0d 1 3 , 0x 6 5 0a 7 3 5 4 , 0x 7 6 6a 0abb , 0x 8 1c 2c 9 2e , 0x 9 2 7 2 2c 8 5 , 0xa 2bfe 8a 1 , 0xa 8 1a 6 6 4b , 0xc 2 4b 8b 7 0 , 0xc 7 6c 5 1a 3 , 0xd 1 9 2e 8 1 9 , 0xd 6 9 9 0 6 2 4 , 0xf 4 0e 3 5 8 5 , 0x 1 0 6aa 0 7 0 , 0x 1 9a 4c 1 1 6 , 0x 1e 3 7 6c 0 8 , 0x 2 7 4 8 7 7 4c , 0x 3 4b 0bcb 5 , 0x 3 9 1c 0cb 3 , 0x 4ed 8aa 4a , 0x 5b 9cca 4f , 0x 6 8 2e 6ff 3 , 0x 7 4 8f 8 2ee , 0x 7 8a 5 6 3 6f , 0x 8 4c 8 7 8 1 4 , 0x 8cc 7 0 2 0 8 , 0x 9 0befffa , 0xa 4 5 0 6ceb , 0xbef 9a 3f 7 , 0xc 6 7 1 7 8f 2 * / var k = array Hex 2bin ( [ 0x 4 2 8a 2f 9 8 , 0x 7 1 3 7 4 4 9 1 , 0xb 5c 0fbcf , 0xe 9b 5dba 5 , 0x 3 9 5 6c 2 5b , 0x 5 9f 1 1 1f 1 , 0x 9 2 3f 8 2a 4 , 0xab 1c 5ed 5 , 0xd 8 0 7aa 9 8 , 0x 1 2 8 3 5b 0 1 , 0x 2 4 3 1 8 5be , 0x 5 5 0c 7dc 3 , 0x 7 2be 5d 7 4 , 0x 8 0deb 1fe , 0x 9bdc 0 6a 7 , 0xc 1 9bf 1 7 4 , 0xe 4 9b 6 9c 1 , 0xefbe 4 7 8 6 , 0x 0fc 1 9dc 6 , 0x 2 4 0ca 1cc , 0x 2de 9 2c 6f , 0x 4a 7 4 8 4aa , 0x 5cb 0a 9dc , 0x 7 6f 9 8 8da , 0x 9 8 3e 5 1 5 2 , 0xa 8 3 1c 6 6d , 0xb 0 0 3 2 7c 8 , 0xbf 5 9 7fc 7 , 0xc 6e 0 0bf 3 , 0xd 5a 7 9 1 4 7 , 0x 0 6ca 6 3 5 1 , 0x 1 4 2 9 2 9 6 7 , 0x 2 7b 7 0a 8 5 , 0x 2e 1b 2 1 3 8 , 0x 4d 2c 6dfc , 0x 5 3 3 8 0d 1 3 , 0x 6 5 0a 7 3 5 4 , 0x 7 6 6a 0abb , 0x 8 1c 2c 9 2e , 0x 9 2 7 2 2c 8 5 , 0xa 2bfe 8a 1 , 0xa 8 1a 6 6 4b , 0xc 2 4b 8b 7 0 , 0xc 7 6c 5 1a 3 , 0xd 1 9 2e 8 1 9 , 0xd 6 9 9 0 6 2 4 , 0xf 4 0e 3 5 8 5 , 0x 1 0 6aa 0 7 0 , 0x 1 9a 4c 1 1 6 , 0x 1e 3 7 6c 0 8 , 0x 2 7 4 8 7 7 4c , 0x 3 4b 0bcb 5 , 0x 3 9 1c 0cb 3 , 0x 4ed 8aa 4a , 0x 5b 9cca 4f , 0x 6 8 2e 6ff 3 , 0x 7 4 8f 8 2ee , 0x 7 8a 5 6 3 6f , 0x 8 4c 8 7 8 1 4 , 0x 8cc 7 0 2 0 8 , 0x 9 0befffa , 0xa 4 5 0 6ceb , 0xbef 9a 3f 7 , 0xc 6 7 1 7 8f 2 ] ) ; var digest = " " , ar Msg = message . split ( ' ' ) , ar Msg Len = ar Msg . length , original Bits = [ ] , original Bits Length = 0 , err = null , i , s 0 , s 1 , S 0 , S 1 , ch , maj , temp 1 , temp 2 , a , b , c , d , e , f , g , h , l , m , n , o , p , u , v , w , x , y , z , z 1 , z 2 , z 3 ; append a single ' 1 ' bit * / u = original Bits . slice ( ) ; u . push ( one Bit ) ; append K ' 0 ' bits , where K is the minimum number > = 0 such that L + 1 + K + 6 4 is a multiple of 5 1 2 * / v = u . length ; append L as a 6 4 -bit big -endian integer , making the total post -processed length a multiple of 5 1 2 bits * / Process the message in successive 5 1 2 -bit chunks : * / for ( x = 0 ; x < v ; x + = 5 1 2 ) { break message into 5 1 2 -bit chunks for each chunk create a 6 4 -entry message schedule array w [ 0 . . 6 3 ] of 3 2 -bit words (The initial values in w [ 0 . . 6 3 ] don 't matter , so many implementations zero them here ) * / w = [ ] ; / * copy chunk into first 1 6 words w [ 0 . . 1 5 ] of the message schedule array * / for ( y = 0 ; y < 1 6 ; y + + ) { w [ y ] = [ ] ; for ( z = 0 ; z < 3 2 ; z + + ) { w [ y ] . push ( u [ x + y * 3 2 + z ] ) ; } / /out ( "w [ " + y + " ] " , w [y ] , bin 2hex (w [y ] ) ) ; } / * Extend the first 1 6 words into the remaining 4 8 words w [ 1 6 . . 6 3 ] of the message schedule array : for i from 1 6 to 6 3 * / for ( i = 1 6 ; i < 6 4 ; i + + ) { / * s 0 : = (w [i - 1 5 ] rightrotate 7 ) xor (w [i - 1 5 ] rightrotate 1 8 ) xor (w [i - 1 5 ] rightshift 3 ) * / y = w [ i - 1 5 ] ; / /out (i , "y " ,y ) ; z = rightrotate ( y , 7 ) ; / /out ( "z " , z ) ; z 1 = rightrotate ( y , 1 8 ) ; / /out ( "z 1 " , z 1 ) ; z 2 = rightshift ( y , 3 ) ; / /out ( "z 2 " , z 2 ) ; s 0 = xor ( z , z 1 , z 2 ) ; / /out ( "s 0 " , s 0 ) ; / * s 1 : = (w [i - 2 ] rightrotate 1 7 ) xor (w [i - 2 ] rightrotate 1 9 ) xor (w [i - 2 ] rightshift 1 0 ) * / y = w [ i - 2 ] ; / /out (i , "y " ,y ) ; z = rightrotate ( y , 1 7 ) ; / /out ( "z " , z ) ; z 1 = rightrotate ( y , 1 9 ) ; / /out ( "z 1 " , z 1 ) ; z 2 = rightshift ( y , 1 0 ) ; / /out ( "z 2 " , z 2 ) ; s 1 = xor ( z , z 1 , z 2 ) ; / /out ( "s 1 " , s 1 ) ; / * w [i ] : = w [i - 1 6 ] + s 0 + w [i - 7 ] + s 1 * / y = w [ i - 1 6 ] ; / /out ( "y " , y ) ; z = w [ i - 7 ] ; / /out ( "z " , z ) ; w [ i ] = add ( y , s 0 , z , s 1 ) ; / /out ( "w [ " +i + " ] " , w [i ] ) ; } / * Initialize working variables to current hash value : a : = h 0 b : = h 1 c : = h 2 d : = h 3 e : = h 4 f : = h 5 g : = h 6 h : = h 7 * / a = h 0 ; b = h 1 ; c = h 2 ; d = h 3 ; e = h 4 ; f = h 5 ; g = h 6 ; h = h 7 ; / * Compression function main loop : for i from 0 to 6 3 * / for ( i = 0 ; i < 6 4 ; i + + ) { / * S 1 : = (e rightrotate 6 ) xor (e rightrotate 1 1 ) xor (e rightrotate 2 5 ) * / l = rightrotate ( e , 6 ) ; m = rightrotate ( e , 1 1 ) ; n = rightrotate ( e , 2 5 ) ; S 1 = xor ( l , m , n ) ; / /out ( "S 1 " , S 1 ) ; / * ch : = (e and f ) xor ( (not e ) and g ) * / l = and ( e , f ) ; m = not ( e ) ; n = and ( m , g ) ; ch = xor ( l , n ) ; / /out ( "ch " , ch ) ; / * temp 1 : = h + S 1 + ch + k [i ] + w [i ] * / temp 1 = add ( h , S 1 , ch , k [ i ] , w [ i ] ) ; / /out ( "temp 1 " , temp 1 ) ; / * S 0 : = (a rightrotate 2 ) xor (a rightrotate 1 3 ) xor (a rightrotate 2 2 ) * / l = rightrotate ( a , 2 ) ; m = rightrotate ( a , 1 3 ) ; n = rightrotate ( a , 2 2 ) ; S 0 = xor ( l , m , n ) ; / /out ( "S 0 " , S 0 ) ; / * maj : = (a and b ) xor (a and c ) xor (b and c ) * / l = and ( a , b ) ; m = and ( a , c ) ; n = and ( b , c ) ; maj = xor ( l , m , n ) ; / /out ( "maj " , maj ) ; / * temp 2 : = S 0 + maj * / temp 2 = add ( S 0 , maj ) ; / /out ( "temp 2 " , temp 2 ) ; / * h : = g g : = f f : = e e : = d + temp 1 d : = c c : = b b : = a a : = temp 1 + temp 2 * / h = g ; g = f ; f = e ; e = add ( d , temp 1 ) ; / /out ( "e " , e ) ; d = c ; c = b ; b = a ; a = add ( temp 1 , temp 2 ) ; / /out ( "a " , a ) ; / /out ( "t = " +i , array Bin 2hex ( [a ,b ,c ,d ,e ,f ,g ,h ] ) .join ( ' ' ) ) ; } / * Add the compressed chunk to the current hash value : h 0 : = h 0 + a h 1 : = h 1 + b h 2 : = h 2 + c h 3 : = h 3 + d h 4 : = h 4 + e h 5 : = h 5 + f h 6 : = h 6 + g h 7 : = h 7 + h * / / /out ( "h 0 " , bin 2hex (h 0 ) , " + " , bin 2hex (a ) , " = " , bin 2hex (add (h 0 , a ) ) ) ; h 0 = add ( h 0 , a ) ; / /out ( "h 1 " , bin 2hex (h 1 ) , " + " , bin 2hex (b ) , " = " , bin 2hex (add (h 1 , b ) ) ) ; h 1 = add ( h 1 , b ) ; / /out ( "h 2 " , bin 2hex (h 2 ) , " + " , bin 2hex (c ) , " = " , bin 2hex (add (h 2 , c ) ) ) ; h 2 = add ( h 2 , c ) ; / /out ( "h 3 " , bin 2hex (h 3 ) , " + " , bin 2hex (d ) , " = " , bin 2hex (add (h 3 , d ) ) ) ; h 3 = add ( h 3 , d ) ; / /out ( "h 4 " , bin 2hex (h 4 ) , " + " , bin 2hex (e ) , " = " , bin 2hex (add (h 4 , e ) ) ) ; h 4 = add ( h 4 , e ) ; / /out ( "h 5 " , bin 2hex (h 5 ) , " + " , bin 2hex (f ) , " = " , bin 2hex (add (h 5 , f ) ) ) ; h 5 = add ( h 5 , f ) ; / /out ( "h 6 " , bin 2hex (h 6 ) , " + " , bin 2hex (g ) , " = " , bin 2hex (add (h 6 , g ) ) ) ; h 6 = add ( h 6 , g ) ; / /out ( "h 7 " , bin 2hex (h 7 ) , " + " , bin 2hex (h ) , " = " , bin 2hex (add (h 7 , h ) ) ) ; h 7 = add ( h 7 , h ) ; } / * Produce the final hash value (big -endian ) : digest : = hash : = h 0 append h 1 append h 2 append h 3 append h 4 append h 5 append h 6 append h 7 * / digest = array Bin 2hex ( [ h 0 , h 1 , h 2 , h 3 , h 4 , h 5 , h 6 , h 7 ] ) ; } catch ( e ) { err = e ; console . error ( "ERROR " , e ) ; } finally { return debugging ? [ digest . join ( " " ) , debug Output , err ] : digest . join ( ' ' ) ; } } 
function ( selector , config = { } ) { if ( ! ( this instanceof Leipzig ) ) { return new Leipzig ( selector , config ) ; } if ( typeof selector ! = = 'undefined ' ) { if ( typeof selector = = = 'string ' | | selector instanceof Node List | | selector instanceof Element ) { config . selector = selector ; } else if ( typeof selector = = = 'object ' ) { 
function Url Helper ( params ) { this . url = "http : / /store .steampowered .com /search / ? " ; if ( ! ! params . tags ) { for ( i = 0 ; i < params . tags . length ; i + + ) params . tags [ i ] = parameters . tags . get ( params . tags [ i ] ) . value this . url + = "tags = " + params . tags . join ( " , " ) + " & " ; } if ( ! ! params . os ) { for ( i = 0 ; i < params . os . length ; i + + ) params . os [ i ] = parameters . os . get ( params . os [ i ] ) . value this . url + = "os = " + params . os . join ( " , " ) + " & " ; } if ( ! ! params . player Amount ) for ( i = 0 ; i < params . player Amount . length ; i + + ) params . player Amount [ i ] = parameters . player Amount . get ( params . player Amount [ i ] ) . value this . url + = "category 3 = " + params . player Amount . join ( " , " ) + " & " ; if ( params . games Only ) this . url + = "category 1 = 9 9 8 & " ; } 
function navigate ( ) { if ( location . hash ) { var new State = JSON . parse ( location . hash . substr ( 1 ) ) ; if ( JSON . stringify ( new State ) ! = = JSON . stringify ( force Directed Graph . state ) ) { force Directed Graph . state = new State ; } } } 
function serialize State ( ) { var data = model . data , scale = model . scale , translate = model . translate ; model . state = { nodes : data . nodes . map ( function ( node ) { return { type : node . type , property : node . property , fixed : node . fixed , 
function when ( properties , callback ) { 
function track ( property ) { if ( ! ( property in tracked Properties ) ) { tracked Properties [ property ] = true ; values [ property ] = model [ property ] ; Object . define Property ( model , property , { get : function ( ) { return values [ property ] ; } , set : function ( value ) { values [ property ] = value ; get Listeners ( property ) . for Each ( function ( callback ) { callback ( value ) ; } ) ; } } ) ; } } 
function find All ( collection , callbacks ) { localforage . get Item ( collection . sync . localforage Key , function ( err , data ) { if ( data & & data . length ) { var done = function ( ) { if ( callbacks . success ) { callbacks . success ( data . filter ( function ( model ) { 
function _ _require ( uid , parent Uid ) { if ( ! _ _module Is Cached [ uid ] ) { require it , they will only see an empty Object for now * / 
function get Pkg Resource ( resources , ret , full Pack Hit ) { var pkg List = { } ; var list = [ ] ; var handled = { } ; var id List = resources . map ( function ( resource ) { return resource . id ; } ) ; var resource Map = { } ; resources . for Each ( function ( resource ) { resource Map [ resource . id ] = resource ; } ) ; function full Pack Pass ( resource ) { if ( ! full Pack Hit ) { return true ; } var pkg = ret . map . pkg [ ret . map . res [ resource . id ] . pkg ] ; var un Hit = pkg . has . filter ( function ( id ) { return id List . index Of ( id ) = = - 1 ; } ) ; return un Hit . length = = = 0 ; } function add Pkg ( id , pkg , src Id ) { if ( pkg List [ id ] ) return ; var head = false ; pkg . has . for Each ( function ( in Pkg ) { handled [ in Pkg ] = true ; if ( resource Map [ in Pkg ] ) { head = head | | ( resource Map [ in Pkg ] . head | | false ) ; } } ) ; pkg List [ id ] = true ; list . push ( { type : 'pkg ' , id : id , src Id : src Id , head : head } ) ; } resources . for Each ( function ( resource ) { var id = resource . id ; if ( handled [ id ] ) { return false ; } 
function random Date ( start , end ) { return new Date ( start . get Time ( ) + Math . random ( ) * ( end . get Time ( ) - start . get Time ( ) ) ) ; } 
function random Price ( old Price , volatility ) { const rnd = random Number ( ) ; let change Percent = 2 * volatility * rnd ; if ( change Percent > volatility ) { change Percent - = ( 2 * volatility ) ; } const change Amount = old Price * change Percent ; const new Price = old Price + change Amount ; return new Price ; } 
function random Incident ( types , start , end ) { const x 1 = random Date ( start , end ) ; const x 2 = new Date ( x 1 ) ; x 2 . set Date ( x 1 . get Date ( ) + ( Math . floor ( Math . random ( ) * 4 5 ) ) ) ; Incidents . insert ( { x 1 : x 1 . get Time ( ) , x 2 : x 2 . get Time ( ) , y 1 : ( Math . floor ( Math . random ( ) * 9 9 ) ) , type : types [ ( Math . floor ( Math . random ( ) * 2 ) ) ] , } ) ; } 
function get Datetime Unit ( min , max ) { const diff = max . diff ( min , 'days ' ) ; let unit = 'month ' ; if ( diff < = 1 4 ) { unit = 'day ' ; } else if ( diff > 1 4 & & diff < = 1 8 3 ) { unit = 'week ' ; } return unit ; } 
function get Rendered Template ( template , data , variable Regex ) { return template . replace ( variable Regex , ( match , captured ) = > { const replacement = value For Property ( data , captured . trim ( ) ) ; 
function get Processed Path ( file , data ) { return file . replace ( / _ _ ( [A -Za -z 0 - 9 - ] + _ ? [A -Za -z 0 - 9 - ] + ) + _ _ / g , ( match ) = > { const data Key = match . substring ( 2 , match . length - 2 ) ; const data Val = data [ data Key ] ; if ( data Val ) { return data Val ; } return match ; } ) ; } 
function scaffold ( { source = ' ' , destination = 'destination ' , only Files = false , exclude = [ ] , variable Regex = / \ { \ { \s ? ( [A -Za -z 0 - 9 - ] + _ ? [A -Za -z 0 - 9 - ] + ) + \s ? \ } \ } / g , } = { } , data = { } , ) { const cwd = process . cwd ( ) ; const this Source = path Is Absolute ( source ) ? source : path . join ( cwd , source ) ; const this Destination = path Is Absolute ( destination ) ? destination : path . join ( cwd , destination ) ; const this Only Files = only Files ; const this Exclude = exclude ; const this Variable Regex = variable Regex ; try { const list Of Files = fs . readdir Sync ( this Source ) ; const destination Exists = fs . exists Sync ( this Destination ) ; if ( ! destination Exists ) { fs . mkdir Sync ( this Destination ) ; } list Of Files . for Each ( ( file ) = > { const this File = path . join ( this Source , file ) ; const stat = fs . stat Sync ( this File ) ; const destination Filename = get Processed Path ( file , data ) ; const destination Path = path . join ( this Destination , destination Filename ) ; if ( stat & & stat . is Directory ( ) & & ! this Only Files & & ! this Exclude . includes ( file ) ) { scaffold ( { source : this File , destination : destination Path , only Files : this Only Files , exclude : this Exclude , variable Regex : this Variable Regex , } , data ) ; } else if ( ! stat . is Directory ( ) ) { const template = fs . read File Sync ( this File , 'utf - 8 ' ) ; const filled Template = get Rendered Template ( template , data , this Variable Regex ) ; fs . write File Sync ( destination Path , filled Template ) ; } } ) ; } catch ( e ) { throw new Error ( e ) ; } } 
function ( lookup ) { var matches = tmpl Reg Exp . exec ( lookup ) ; if ( matches ) { return { src : matches & & matches [ 0 ] , prop : matches & & matches [ 1 ] | | matches [ 2 ] , } ; } else { return false ; } } 
function ( data , lookup , options ) { var property ; 
function ( data , arr , options ) { return arr . map ( function ( lookup ) { return expander . process ( data , lookup , options ) ; } ) ; } 
function ( data , obj , options ) { var result = { } ; Object . keys ( obj ) . for Each ( function ( key ) { result [ key ] = expander . process ( data , obj [ key ] , options ) ; } ) ; return result ; } 
function _execute ( $vm ) { var _ _ $args _ _ = _ _ $util _ _ . slice ( arguments ) var _ _ $expr _ _ = _ _ $args _ _ [ 1 ] var _ _ $fn _ _ = _ _ $compiled Exprs _ _ _ [ _ _ $expr _ _ ] try { if ( ! _ _ $fn _ _ ) { _ _ $fn _ _ = _ _ $compiled Exprs _ _ _ [ _ _ $expr _ _ ] = _ _ $compile _ _ ( _ _ $expr _ _ ) } return [ null , _ _ $util _ _ . immutable ( _ _ $fn _ _ ( _ _ $util _ _ . extend ( { } , $vm . $methods , $vm . $data ) ) ) ] } catch ( e ) { _ _ $args _ _ [ 1 ] = ' . ' + _ _ $args _ _ [ 2 ] + ' = ' + ( / ^ \ { / . test ( _ _ $args _ _ [ 1 ] ) ? _ _ $args _ _ [ 1 ] : ' { ' + _ _ $args _ _ [ 1 ] + ' } ' ) 
function style _html ( html _source , options ) { for (var i = 0 ; i <this .indent _level ; i + + ) { content + = this .indent _string ; } space = false ; * / this . line _char _count = 0 ; continue ; } } content + = input _char ; this . line _char _count + + ; space = true ; } while ( content . index Of ( delimiter ) = = - 1 ) ; return content ; } this . get _token = function ( ) { 
function _set ( obj , keypath , value ) { var parts = _key Path Normalize ( keypath ) . split ( ' . ' ) var last = parts . pop ( ) var dest = obj var has Error var error Info util . some ( parts , function ( key ) { var t = util . type ( dest ) if ( t ! = 'object ' & & t ! = 'array ' ) { has Error = true error Info = [ key , dest ] return true } dest = dest [ key ] } ) 
function ( v ) { if ( ! this . _key ) return if ( util . type ( v ) = = 'array ' ) { var that = this this . _v = v var last Vms = that . _vms | | [ ] var last Vm Map = that . _vm Map | | { } var parent Vm = that . $vm var removed Vms = [ ] var changed Vms = [ ] var inserted Vms = [ ] var vms = that . _vms = new Array ( that . _v . length ) var vm Map = that . _vm Map = { } var last Insert Index = - 1 var continued Change Offset = 0 var last Change Index = - 1 var is Continued Insert = true var is Continued Change = true var cursor = 0 util . for Each ( that . _v , function ( data , index ) { var is Obj = util . is Obj ( data ) var key if ( that . _is Index Key ) { key = index } else if ( ! is Obj | | that . _is Self Str Key ) { key = data + ' ' } else { key = keypath . get ( data , that . _key ) } var vm = last Vm Map [ key ] if ( vm ) { vm = vm . vm } var p = { key : key , vm : vm } if ( vm Map [ key ] ) { * If `list Id ` and compile result exit , use it * / if ( ! that . _compile Cache & & that . _list Id & & list Compile Results [ that . _list Id ] ) { that . _compile Cache = list Compile Results [ that . _list Id ] } * cache compile result * / if ( that . _list Id & & ! list Compile Results [ that . _list Id ] ) { list Compile Results [ that . _list Id ] = that . _compile Cache } if ( is Continued Insert ) { if ( last Insert Index < 0 ) { last Insert Index = index } else { if ( last Insert Index + 1 ! = index ) { * remove * / util . for Each ( last Vms , function ( item ) { if ( ! vm Map [ item . key ] ) { removed Vms . push ( item ) } } ) var changed Count = changed Vms . length var inserted Count = inserted Vms . length var removed Count = removed Vms . length var only Removed if ( ! inserted Count ) { if ( ! changed Count & & ! removed Count ) { return } else if ( removed Count & & ( ! changed Count | | ( - 1 * continued Change Offset = = removed Count & & is Continued Change ) ) ) { only Removed = true } } else { if ( is Continued Insert & & ( ! changed Count | | is Continued Change ) ) { only Removed = true 
function ( text ) { if ( ! text | | ! text . replace ) return text return text . replace ( / ( & [ #a -z A -Z 0 - 9 ] + ; ) / g , function ( m , s ) { return _convert Entity ( s ) } ) } 
function compute ( ) { 
function ( ) { var container Props = pluck Table Props ( this . props ) ; container Props . css Prefix = "row " ; container Props . wrapper = pluck Td Props ( mixin ( { } , Row . default Props . wrapper , this . props . wrapper | | { } ) ) ; return container Props ; } 
function submit Request ( params ) { debug ( 'sending API request to proxy <iframe > %o ' , params ) ; 
function get File Value ( v ) { if ( is File ( v ) ) { return v ; } if ( typeof v = = = 'object ' & & is File ( v . file Contents ) ) { return v . file Contents ; } return null ; } 
function patch File Objects ( form Data ) { 
function install ( ) { debug ( 'install ( ) ' ) ; if ( iframe ) { uninstall ( ) ; } buffered = [ ] ; 
function uninstall ( ) { debug ( 'uninstall ( ) ' ) ; event . unbind ( window , 'message ' , onmessage ) ; document . body . remove Child ( iframe ) ; loaded = false ; iframe = null ; } 
function onload ( ) { debug ( 'proxy <iframe > "load " event ' ) ; loaded = true ; 
function onmessage ( e ) { debug ( 'onmessage ' ) ; 
function onprogress ( data ) { debug ( 'got "progress " event : %o ' , data ) ; const xhr = requests [ data . callback Id ] ; if ( xhr ) { const prog = new Progress Event ( 'progress ' , data ) ; const target = data . upload ? xhr . upload : xhr ; target . dispatch Event ( prog ) ; } } 
function resolve ( xhr , body , headers ) { const e = new Progress Event ( 'load ' ) ; e . data = e . body = e . response = body ; e . headers = headers ; xhr . dispatch Event ( e ) ; } 
function reject ( xhr , err , headers ) { const e = new Progress Event ( 'error ' ) ; e . error = e . err = err ; e . headers = headers ; xhr . dispatch Event ( e ) ; } 
function Real ( options ) { options = options | | { } var optimise Opt = options . optimise | | { } var precompile = optimise Opt . precompile var compile Cache = optimise Opt . compile Cache var vm = this var NS = conf . namespace var _ready = options . ready var _created = options . created var _destroy = options . destroy var _binding if ( compile Cache ) { _binding = compile Cache . has Binding } else { _binding = util . has Own ( options , 'binding ' ) ? options . binding : true if ( precompile ) { precompile . has Binding = _binding } } var _message if ( ! optimise Opt . no Message ) { _message = this . _message = new Message ( ) } this . $id = _cid + + this . $name = options . name | | ' ' this . $parent = options . parent | | null this . $binding = ! ! _binding this . $should Update = options . should Update this . $directives = [ ] this . $components = [ ] this . $watchers = [ ] this . _ $before Destroy = function ( ) { _safely Call ( conf [ CATCH _KEY ] , _destroy , vm ) } var el = options . el var has Replace Option = util . has Own ( options , 'replace ' ) ? options . replace : false if ( util . type ( el ) = = 'string ' ) { var sel = el if ( support Query Selector ) { el = document . query Selector ( sel ) } else if ( / ^ \ . / . test ( sel ) ) { el = _get Elements By Class Name ( sel . replace ( / ^ \ . / , ' ' ) ) el & & ( el = el [ 0 ] ) } else if ( / ^ # / . test ( sel ) ) { el = document . get Element By Id ( sel . replace ( / ^ # / , ' ' ) ) } else { el = null } if ( ! el ) return consoler . error ( 'Can \ 't resolve element by " ' + sel + ' " ' ) } / * * * Container element must be a element or has template option * / var is HTMLElement = is . Element ( el ) var children if ( is HTMLElement & & options . template ) { / * * * If el is passed and has template option * if without "replace " , it will render template to inner HTML , * otherwise template rendering to inner HTML and replace the component element with * root element of template . * / if ( util . has Attribute ( el , NS + 'notemplate ' ) | | options . notemplate ) { / / skip render template , using with SSR } else if ( has Replace Option ) { var child = _fragment Wrap ( options . template ) / / for get first Element of the template as root element of the component children = _fragment Children ( child ) if ( ! children . length ) throw new Error ( 'Component with \ 'replace \ ' must has a child element of template . ' , options . template ) var next El = children [ 0 ] var parent = el . parent Node if ( parent ) { parent . replace Child ( next El , el ) } _clone Attributes ( el , next El ) el = next El } else { / / el is given then set template as inner HTML for the component if ( is . Fragment ( el ) ) { consoler . warn ( 'Container element should \ 'nt a fragment node when "template " is given . Template : \n ' , options . template ) } else { el . inner HTML = options . template } } } else if ( ! el & & options . template ) { if ( has Replace Option ) { var frag = _fragment Wrap ( options . template ) 
function instance Scoped Directive ( tar , dec , dname ) { 
function _safely Call ( is Catch , fn , ctx ) { if ( ! fn ) return if ( is Catch ) { try { fn . call ( ctx ) } catch ( e ) { consoler . error Trace ( e ) } } else { fn . call ( ctx ) } } 
function _update ( ) { if ( d . $destroyed ) return consoler . warn ( 'Directive " ' + name + ' " already destroyed . ' ) var has Diff = false 
function mixin ( a ) { var k , key , o ; var len = arguments . length ; for ( k = 1 ; k < len ; k + = 1 ) { o = arguments [ k ] ; for ( key in o ) { var v = o [ key ] ; if ( o . has Own Property ( key ) ) { if ( v = = = undefined | | v = = = null ) { delete a [ key ] ; } else { a [ key ] = o [ key ] ; } } } } return a ; } 
function load Middleware Filters ( filters ) { var result = [ ] , index , num = filters . length , filter , module Path , middleware ; function starts With ( string , search String , position ) { position = position | | 0 ; return string . index Of ( search String , position ) = = = position ; } for ( index = 0 ; index < num ; index + + ) { filter = filters [ index ] ; 
function load Resources ( resources , provider Index ) { var result = [ ] , index , num = resources . length , resource , prefilters , postfilters ; for ( index = 0 ; index < num ; index + + ) { resource = resources [ index ] ; prefilters = [ ] ; postfilters = [ ] ; 
function load Providers ( providers ) { var result = [ ] , index , num = providers . length , provider , prefilters , postfilters , resources ; for ( index = 0 ; index < num ; index + + ) { provider = providers [ index ] ; prefilters = [ ] ; postfilters = [ ] ; resources = [ ] ; 
function load ( config ) { var configuration = { prefilters : [ ] , providers : [ ] , postfilters : [ ] } ; 
function Clyde ( options ) { 
function Currencies ( currencies ) { if ( ! currencies ) { throw new Error ( 'Missing currencies object ' ) ; } this . keys = parse Int ( currencies . keys | | 0 ) ; this . metal = parse Float ( currencies . metal | | 0 ) ; if ( is Na N ( this . keys ) | | is Na N ( this . metal ) ) { throw new Error ( 'Not a valid currencies object ' ) ; } this . metal = to Refined ( to Scrap ( this . metal ) ) ; } 
function parse Path ( url ) { url = ( url | | " " ) . trim ( ) var output = { protocols : protocols ( url ) , protocol : null , port : null , resource : " " , user : " " , pathname : " " , hash : " " , search : " " , href : url , query : Object . create ( null ) } , protocol Index = url . index Of ( " : / / " ) , resource Index = - 1 , splits = null , parts = null ; if ( url . starts With ( " . " ) ) { if ( url . starts With ( " . / " ) ) { url = url . substring ( 2 ) ; } output . pathname = url ; output . protocol = "file " ; } const first Char = url . char At ( 1 ) if ( ! output . protocol ) { output . protocol = output . protocols [ 0 ] if ( ! output . protocol ) { if ( is Ssh ( url ) ) { output . protocol = "ssh " } else if ( first Char = = = " / " | | first Char = = = " ~ " ) { url = url . substring ( 2 ) output . protocol = "file " } else { output . protocol = "file " } } } if ( protocol Index ! = = - 1 ) { url = url . substring ( protocol Index + 3 ) ; } parts = url . split ( " / " ) ; if ( output . protocol ! = = "file " ) { output . resource = parts . shift ( ) ; } else { output . resource = " " ; } 
function get Options ( ) { 
function get Window For Element ( element ) { var doc = element . owner Document | | element ; return doc . default View | | doc . parent Window | | window ; } 
function create Input Instance ( manager ) { var Type ; var input Class = manager . options . input Class ; if ( input Class ) { Type = input Class ; } else if ( SUPPORT _POINTER _EVENTS ) { Type = Pointer Event Input ; } else if ( SUPPORT _ONLY _TOUCH ) { Type = Touch Input ; } else if ( ! SUPPORT _TOUCH ) { Type = Mouse Input ; } else { Type = Touch Mouse Input ; } return new Type ( manager , input Handler ) ; } 
function input Handler ( manager , event Type , input ) { var pointers Len = input . pointers . length ; var changed Pointers Len = input . changed Pointers . length ; var is First = event Type & INPUT _START & & pointers Len - changed Pointers Len = = = 0 ; var is Final = event Type & ( INPUT _END | INPUT _CANCEL ) & & pointers Len - changed Pointers Len = = = 0 ; input . is First = ! ! is First ; input . is Final = ! ! is Final ; if ( is First ) { manager . session = { } ; } 
function compute Input Data ( manager , input ) { var session = manager . session ; var pointers = input . pointers ; var pointers Length = pointers . length ; 
function TMEhandler ( manager , input Event , input Data ) { var is Touch = input Data . pointer Type = = INPUT _TYPE _TOUCH , is Mouse = input Data . pointer Type = = INPUT _TYPE _MOUSE ; if ( is Mouse & & input Data . source Capabilities & & input Data . source Capabilities . fires Touch Events ) { return ; } 
function ( input ) { var src Event = input . src Event ; var direction = input . offset Direction ; 
function ( t Id , partial Tree ) { if ( t Id = = = void 0 ) { t Id = ' ' ; } if ( partial Tree = = = void 0 ) { partial Tree = tree ; } if ( ! t Id ) { return undefined ; } var found ; partial Tree . some ( function ( tree Item ) { if ( tree Item [ id ] = = = t Id ) { found = tree Item ; return true ; } found = tree Item [ children ] ? find ( t Id , tree Item [ children ] ) : undefined ; return found ? true : false ; } ) ; return found ; } 
function ( t Id , partial Tree ) { if ( t Id = = = void 0 ) { t Id = ' ' ; } if ( partial Tree = = = void 0 ) { partial Tree = tree ; } if ( ! t Id ) { return false ; } var found = false ; partial Tree . some ( function ( tree Item , i ) { if ( tree Item [ id ] = = = t Id ) { partial Tree . splice ( i , 1 ) ; found = true ; return true ; } found = tree Item [ children ] ? delete Tree Item ( t Id , tree Item [ children ] ) : false ; if ( found & & tree Item [ children ] . length = = = 0 ) { delete tree Item [ children ] ; delete tree Item [ opts . is Open ] ; } return found ; } ) ; return found ; } 
function ( updated Tree Item , partial Tree ) { if ( partial Tree = = = void 0 ) { partial Tree = tree ; } var found = false ; partial Tree . some ( function ( tree Item , i ) { if ( tree Item [ id ] = = = updated Tree Item [ id ] ) { partial Tree [ i ] = updated Tree Item ; found = true ; return true ; } found = tree Item [ children ] ? update Tree Item ( updated Tree Item , tree Item [ children ] ) : false ; return found ; } ) ; return found ; } 
function ( el ) { return el . id ? el . id : el . parent Element ? find Id ( el . parent Element ) : null ; } 
function list Local Dataset Client Data ( dataset Client , cb ) { sync Storage . read Dataset Client With Records ( dataset Client . get Id ( ) , function ( err , dataset Clients With Records ) { if ( err ) { return cb ( err ) ; } 
function list Applied Change Since Last Sync ( dataset Id , last Sync End Time , client Info , cb ) { sync Storage . list Updates ( dataset Id , { type : SYNC _UPDATE _TYPES . APPLIED , cuid : client Info . cuid , timestamp : { $gt : last Sync End Time } } , null , cb ) ; } 
function list Pending Changes For Client ( dataset Id , client Info , cb ) { pending Queue . search ( { dataset Id : dataset Id , cuid : client Info . cuid } , cb ) ; } 
function list Changes Not In Local Dataset ( dataset Id , last Sync Time , client Info , cb ) { async . parallel ( { applied Updates Since Last Sync : async . apply ( list Applied Change Since Last Sync , dataset Id , last Sync Time , client Info ) , pending Changes For Client : async . apply ( list Pending Changes For Client , dataset Id , client Info ) } , function ( err , results ) { if ( err ) { return cb ( err ) ; } return cb ( null , results . applied Updates Since Last Sync , results . pending Changes For Client ) ; } ) ; } 
function remove Applied Updates ( client Records , local Dataset Client , applied Updates ) { _ . each ( applied Updates , function ( update , record Uid ) { if ( client Records [ record Uid ] ) { delete client Records [ record Uid ] ; } if ( local Dataset Client [ record Uid ] ) { delete local Dataset Client [ record Uid ] ; } 
function remove Pending Changes ( client Records , local Dataset Client , pending Changes ) { _ . each ( pending Changes , function ( pending Change , uid ) { if ( client Records [ uid ] ) { delete client Records [ uid ] ; } if ( local Dataset Client [ uid ] ) { delete local Dataset Client [ uid ] ; } } ) ; } 
function compute Delta ( dataset Id , client Records , server Records ) { var creates = { } ; var updates = { } ; var deletes = { } ; _ . each ( server Records , function ( server Record , server Record Uid ) { var server Rec Hash = server Record . hash ; 
function sync Records ( dataset Id , params , cb ) { debug ( ' [ %s ] process sync Records request ' , dataset Id ) ; var query Params = params . query _params | | { } ; var meta Data = params . meta _data | | { } ; 
function process Touch Event ( env , e ) { var listener , touches = [ ] ; e = JSON . parse ( e ) ; if ( e . touch Source Device ! = = 'Capacitive Keyboard ' | | ! e . touch Points | | ! e . touch Points . length ) { return ; } if ( ! _listeners [ env . webview Id ] ) { return ; } e . touch Points . for Each ( function ( point ) { touches . push ( { keyboard X : point . screen Position . x + _shift . x , keyboard Y : point . screen Position . y + _shift . y , state : point . state , identifier : point . id } ) ; } ) ; listener = _listeners [ env . webview Id ] ; listener ( { type : _type , touches : touches , time Stamp : e . time Stamp } ) ; } 
function ( metric , records ) { var return Value = { message : 'no stats available ' , name : metric . display Name } ; if ( records & & records . length > 0 ) { return Value = _ . chain ( records ) . map ( function ( record Str ) { return JSON . parse ( record Str ) ; } ) . group By ( function ( record ) { return record . tags [ metric . group By Tag ] ; } ) . reduce ( function ( reduced , group Records , group Key ) { group Records = _ . sort By ( group Records , 'ts ' ) ; var processed Data = _ . reduce ( group Records , function ( memo , group Record ) { var value = group Record . fields [ metric . value Field ] ; memo . current = value ; memo . number Of Records + + ; memo . total + = value ; memo . max = Math . max ( value , memo . max ) ; memo . min = Math . min ( value , memo . min ) ; memo . from = Math . min ( group Record . ts , memo . from ) ; memo . end = Math . max ( group Record . ts , memo . end ) ; return memo ; } , { max : 0 , min : MAX _NUMBER , current : 0 , number Of Records : 0 , total : 0 , from : MAX _NUMBER , end : 0 } ) ; reduced [ group Key ] = { current : metric . data Formatter ( processed Data . current ) , max : metric . data Formatter ( processed Data . max ) , min : metric . data Formatter ( processed Data . min ) , average : metric . data Formatter ( processed Data . total / processed Data . number Of Records ) , number Of Records : processed Data . number Of Records , from : new Date ( processed Data . from ) . to ISOString ( ) , end : new Date ( processed Data . end ) . to ISOString ( ) } ; return reduced ; } , { } ) . value ( ) ; } return return Value ; } 
function init ( dataset _id , options , cb ) { debug ( ' [ %s ] init sync with options %j ' , dataset _id , options ) ; datasets . init ( dataset _id , options ) ; 
function start ( cb ) { if ( arguments . length < 1 ) throw new Error ( 'start requires 1 argument ' ) ; sync Started = true ; if ( mongo Db Client = = = null | | redis Client = = = null ) { throw new Error ( 'Mongo DB Client & Redis Client are not connected . Ensure you have called sync .connect ( ) before calling sync .init ( ) ' ) ; } metrics Client = metrics Module . init ( sync Config , redis Client ) ; async . series ( [ function create Queues ( callback ) { ack Queue = new Mongodb Queue ( 'fhsync _ack _queue ' , metrics Client , sync Lock , { mongodb : mongo Db Client , queue Messages TTL : sync Config . queue Messages TTL } ) ; pending Queue = new Mongodb Queue ( 'fhsync _pending _queue ' , metrics Client , sync Lock , { mongodb : mongo Db Client , queue Messages TTL : sync Config . queue Messages TTL , visibility : sync Config . pending Worker Retry Interval In Seconds } ) ; sync Queue = new Mongodb Queue ( 'fhsync _queue ' , metrics Client , sync Lock , { mongodb : mongo Db Client , queue Messages TTL : sync Config . queue Messages TTL } ) ; async . parallel ( [ async . apply ( ack Queue . create . bind ( ack Queue ) ) , async . apply ( pending Queue . create . bind ( pending Queue ) ) , async . apply ( sync Queue . create . bind ( sync Queue ) ) ] , callback ) ; } , function init Apis ( callback ) { api Sync = sync Api Module ( interceptors , ack Queue , pending Queue , sync Storage , sync Config ) ; api Sync Records = sync Records Api Module ( sync Storage , pending Queue , sync Config ) ; return callback ( ) ; } , function create Workers ( callback ) { var sync Processor Impl = sync Processor ( sync Storage , data Handlers , metrics Client , hash Provider ) ; var sync Worker Opts = { name : 'sync _worker ' , interval : sync Config . sync Worker Interval , backoff : sync Config . sync Worker Backoff , collect Stats Interval : sync Config . collect Stats Interval } ; for ( var i = 0 ; i < sync Config . sync Worker Concurrency ; i + + ) { var sync Worker = new Worker ( sync Queue , sync Processor Impl , metrics Client , sync Worker Opts ) ; sync Workers . push ( sync Worker ) ; } var ack Processor Impl = ack Processor ( sync Storage ) ; var ack Worker Opts = { name : 'ack _worker ' , interval : sync Config . ack Worker Interval , backoff : sync Config . ack Worker Backoff , collect Stats Interval : sync Config . collect Stats Interval } ; for ( var j = 0 ; j < sync Config . ack Worker Concurrency ; j + + ) { var ack Worker = new Worker ( ack Queue , ack Processor Impl , metrics Client , ack Worker Opts ) ; ack Workers . push ( ack Worker ) ; } var pending Processor Impl = pending Processor ( sync Storage , data Handlers , hash Provider , metrics Client , sync Config . pending Worker Retry Limit ) ; var pending Worker Opts = { name : 'pending _worker ' , interval : sync Config . pending Worker Interval , backoff : sync Config . pending Worker Backoff , collect Stats Interval : sync Config . collect Stats Interval } ; for ( var k = 0 ; k < sync Config . pending Worker Concurrency ; k + + ) { var pending Worker = new Worker ( pending Queue , pending Processor Impl , metrics Client , pending Worker Opts ) ; pending Workers . push ( pending Worker ) ; } start All Workers ( sync Workers ) ; start All Workers ( ack Workers ) ; start All Workers ( pending Workers ) ; return callback ( ) ; } , function start Sync Scheduler ( callback ) { var Sync Scheduler = sync Scheduler Module ( sync Lock , sync Storage , metrics Client ) . Sync Scheduler ; sync Scheduler = new Sync Scheduler ( sync Queue , { time Between Checks : sync Config . scheduler Interval , time Before Crash Assumed : sync Config . scheduler Lock Max Time , sync Scheduler Lock Name : sync Config . scheduler Lock Name } ) ; sync Scheduler . start ( ) ; return callback ( ) ; } , function start Dataset Client Cleaner ( callback ) { var dataset Client Cleaner Builder = dataset Client Cleaner Module ( sync Storage , sync Lock ) ; dataset Client Cleaner = dataset Client Cleaner Builder ( { retention Period : sync Config . dataset Client Cleaner Retention Period , check Frequency : sync Config . dataset Client Cleaner Check Frequency } ) ; dataset Client Cleaner . start ( true , callback ) ; } ] , function ( err ) { if ( err ) { 
function stop ( dataset _id , cb ) { if ( ! sync Started ) { return cb ( ) ; } debug ( ' [ %s ] stop sync for dataset ' , dataset _id ) ; sync Storage . update Many Dataset Clients ( { dataset Id : dataset _id } , { stopped : true } , cb ) ; } 
function stop All ( cb ) { 
function remove Collision ( dataset Id , params , cb ) { debug ( ' [ %s ] remove Collision ' ) ; data Handlers . remove Collision ( dataset Id , params . hash , params . meta _data , cb ) ; } 
function do List Dataset Clients ( filter , cb ) { debug ( 'do List Dataset Clients ' ) ; var col = mongo Client . collection ( DATASETCLIENTS _COLLECTION ) ; col . find ( filter ) . to Array ( function ( err , dataset Clients ) { if ( err ) { debug Error ( 'Failed to list dataset Clients due to error %s ' , err ) ; } return cb ( err , dataset Clients ) ; } ) ; } 
function do Remove Dataset Clients ( dataset Clients To Remove , cb ) { var remove Ids = _ . pluck ( dataset Clients To Remove , 'id ' ) ; var dataset Ids = _ . uniq ( _ . pluck ( dataset Clients To Remove , 'dataset Id ' ) ) ; debug ( 'do Remove Dataset Clients : removed dataset Clients = %d , datasets = %d ' , remove Ids . length , dataset Ids . length ) ; async . series ( [ function delete Dataset Client And Refs ( callback ) { async . map ( remove Ids , do Remove Dataset Client With Records , function ( err , delete Result ) { if ( err ) { debug ( 'Failed to delete dataset Clients due to error %s ' , err ) ; } return callback ( err , delete Result ) ; } ) ; } , function remove Unused Records ( callback ) { async . map ( dataset Ids , remove Records For Dataset , function ( err , deleted Count ) { if ( err ) { debug ( 'Error occured when delete records for dataset due to error %s ' , err ) ; } return callback ( err , deleted Count ) ; } ) ; } ] , function ( err , results ) { if ( err ) { return cb ( err ) ; } else { return cb ( null , results [ 0 ] ) ; } } ) ; } 
function do Remove Dataset Client With Records ( dataset Client Id , cb ) { debug ( 'do Remove Dataset Client With Records dataset Client Id = %s ' , dataset Client Id ) ; async . waterfall ( [ async . apply ( do Read Dataset Client , dataset Client Id ) , function remove Refs ( dataset Client Json , next ) { var dataset Id = dataset Client Json . dataset Id ; var records Collection = mongo Client . collection ( get Dataset Records Collection Name ( dataset Id ) ) ; records Collection . update Many ( { 'refs ' : dataset Client Id } , { ' $pull ' : { 'refs ' : dataset Client Id } } , function ( err ) { return next ( err , dataset Client Json ) ; } ) ; } , function delete Dataset Client ( dataset Client Json , next ) { var col = mongo Client . collection ( DATASETCLIENTS _COLLECTION ) ; col . find One And Delete ( { 'id ' : dataset Client Id } , next ) ; } ] , function ( err , result ) { if ( err ) { debug ( 'Failed to do Remove Dataset Client With Records due to error %s ' , err ) ; return cb ( err ) ; } else { return cb ( null , result & & result . value ) ; } } ) ; } 
function upsert Or Delete Dataset Records ( dataset Id , dataset Client Id , records , cb ) { var dataset Records Col = mongo Client . collection ( get Dataset Records Collection Name ( dataset Id ) ) ; debug ( 'upsert Or Delete Dataset Records diff records = %j ' , records ) ; async . map Limit ( records , RECORDS _UPDATE _CONCURRENCY , function ( record , callback ) { var op = record . op ; var fields = { uid : record . uid , hash : record . hash , data : record . data } ; var update = { ' $set ' : fields } ; if ( op = = = 'update ' ) { 
function list Dataset Client Records ( dataset Client Json , projection , cb ) { debug ( 'list Dataset Client Records dataset Client Json = %j ' , dataset Client Json ) ; var dataset Id = dataset Client Json . dataset Id ; var dataset Records Col = mongo Client . collection ( get Dataset Records Collection Name ( dataset Id ) ) ; var cursor = dataset Records Col . find ( { 'refs ' : dataset Client Json . id } ) ; if ( projection ) { cursor = cursor . project ( projection ) ; } else { cursor = cursor . project ( { 'refs ' : 0 } ) ; } return cursor . to Array ( function ( err , records ) { if ( err ) { debug ( ' [ %s ] Failed to list dataset Client records due to error %s : : dataset Client Json = %j ' , err , dataset Client Json ) ; } return cb ( err , records ) ; } ) ; } 
function do Read Dataset Client With Records ( dataset Client Id , callback ) { debug ( 'do Read Dataset Client With Records dataset Client Id = ' , dataset Client Id ) ; async . waterfall ( [ async . apply ( do Read Dataset Client , dataset Client Id ) , function list Records ( dataset Client Json , next ) { if ( dataset Client Json ) { list Dataset Client Records ( dataset Client Json , null , function ( err , local Records ) { return next ( err , dataset Client Json , local Records ) ; } ) ; } else { return next ( ) ; } } ] , function ( err , dataset Client Json , local Records ) { if ( err ) { debug Error ( 'Failed to do Read Dataset Client With Records due to error %s : : dataset Client Id = %s ' , err , dataset Client Id ) ; return callback ( err ) ; } if ( dataset Client Json ) { dataset Client Json . records = local Records ; } return callback ( null , dataset Client Json ) ; } ) ; } 
function do Read Dataset Client ( dataset Client Id , cb ) { debug ( 'do Read Dataset Client dataset Client Id = %s ' , dataset Client Id ) ; var col = mongo Client . collection ( DATASETCLIENTS _COLLECTION ) ; col . find One ( { id : dataset Client Id } , function ( err , dataset Client ) { if ( err ) { debug Error ( 'Failed to read dataset Client due to error %s : : dataset Client Id = %s ' , err , dataset Client Id ) ; } return cb ( err , dataset Client ) ; } ) ; } 
function do Update Dataset Client ( dataset Client Id , fields , upsert , cb ) { debug ( 'do Update Dataset Client dataset Client Id = %s : : fields = %j ' , dataset Client Id , fields ) ; var col = mongo Client . collection ( DATASETCLIENTS _COLLECTION ) ; delete fields . _id ; col . find One And Update ( { id : dataset Client Id } , { ' $set ' : fields } , { upsert : upsert , return Original : false } , function ( err , result ) { if ( err ) { debug Error ( 'Failed to update dataset Clients due to error %s : : dataset Client Id = %s : : fields = %j ' , err , dataset Client Id , fields ) ; return cb ( err ) ; } if ( result . value = = = null ) { return cb ( new Error ( 'Dataset Client not found for id ' + dataset Client Id ) ) ; } 
function create Index For Collection ( collection Name , index Field , index Opts ) { var collection = mongo Client . collection ( collection Name ) ; collection . create Index ( index Field , index Opts , function ( err ) { if ( err ) { debug Error ( 'Failed to create index for collection . collection = %s : : index = %j : : error = %j ' , collection Name , index Field , err ) ; } else { debug ( 'Index created for collection . Collection = %s : : index = %j ' , collection Name , index Field ) ; } } ) ; } 
function ensure Indexes For Dataset ( dataset Id ) { create Index For Collection ( get Dataset Records Collection Name ( dataset Id ) , { 'uid ' : 1 } , { } ) ; create Index For Collection ( get Dataset Records Collection Name ( dataset Id ) , { 'refs ' : 1 } , { } ) ; create Index For Collection ( require ( ' . /sync -updates ' ) . get Dataset Updates Collection Name ( dataset Id ) , { 'cuid ' : 1 , 'hash ' : 1 } , { } ) ; } 
function diff Records ( local Records , new Records ) { var records Diff = { } ; _ . each ( new Records , function ( record , uid ) { if ( local Records [ uid ] ) { if ( local Records [ uid ] . hash ! = = record . hash ) { record . op = "update " ; records Diff [ uid ] = record ; } } else { record . op = "update " ; records Diff [ uid ] = record ; } } ) ; _ . each ( local Records , function ( record , uid ) { if ( ! new Records [ uid ] ) { record . op = "delete " ; records Diff [ uid ] = record ; } } ) ; return records Diff ; } 
function do Update Dataset Client With Records ( dataset Client Id , fields , records , callback ) { debug ( 'do Update Dataset Client With Records dataset Client Id = %s : : records .length = %d ' , dataset Client Id , records . length ) ; async . waterfall ( [ function read Dataset Client ( next ) { do Read Dataset Client ( dataset Client Id , function ( err , dataset Client Json ) { if ( ! dataset Client Json ) { return next ( new Error ( 'can not find dataset Client with id ' + dataset Client Id ) ) ; } else { return next ( err , dataset Client Json ) ; } } ) ; } , function create Index ( dataset Client Json , next ) { ensure Indexes For Dataset ( dataset Client Json . dataset Id ) ; return next ( null , dataset Client Json ) ; } , function list Records ( dataset Client Json , next ) { 
function diff ( dataset Client Json , local Records , next ) { var records Diff = diff Records ( sync Util . convert To Object ( local Records ) , sync Util . convert To Object ( records ) ) ; return next ( null , dataset Client Json , records Diff ) ; } 
function ( filter , callback ) { metrics . time Async Func ( metrics . KEYS . MONGODB _OPERATION _TIME , do List Dataset Clients ) ( filter , callback ) ; } 
function ( dataset Clients To Remove , callback ) { if ( ! dataset Clients To Remove . length ) { return callback ( ) ; } return metrics . time Async Func ( metrics . KEYS . MONGODB _OPERATION _TIME , do Remove Dataset Clients ) ( dataset Clients To Remove , callback ) ; } 
function ( dataset Client Id , fields To Update , callback ) { return metrics . time Async Func ( metrics . KEYS . MONGODB _OPERATION _TIME , do Update Dataset Client ) ( dataset Client Id , fields To Update , false , callback ) ; } 
function ( dataset Client Id , fields , callback ) { fields . id = dataset Client Id ; return metrics . time Async Func ( metrics . KEYS . MONGODB _OPERATION _TIME , do Update Dataset Client ) ( dataset Client Id , fields , true , callback ) ; } 
function ( dataset Client Id , fields , records , callback ) { return metrics . time Async Func ( metrics . KEYS . MONGODB _OPERATION _TIME , do Update Dataset Client With Records ) ( dataset Client Id , fields , records , callback ) ; } 
function ( dataset Client Id , callback ) { return metrics . time Async Func ( metrics . KEYS . MONGODB _OPERATION _TIME , do Read Dataset Client With Records Use Cache ) ( dataset Client Id , callback ) ; } 
function do Find And Delete Update ( dataset Id , acknowledgement , callback ) { debug ( ' [ %s ] do Find And Delete Update acknowledgement = %j ' , dataset Id , acknowledgement ) ; var updates Collection = mongo Client . collection ( get Dataset Updates Collection Name ( dataset Id ) ) ; updates Collection . find One And Delete ( { cuid : acknowledgement . cuid , hash : acknowledgement . hash } , function ( err , result ) { if ( err ) { debug Error ( ' [ %s ] Failed to do Find And Delete Update due to error %s : : acknowledgement = %j ' , dataset Id , err , acknowledgement ) ; return callback ( err ) ; } return callback ( null , result . value ) ; } ) ; } 
function do Save Update ( dataset Id , acknowledgement Fields , callback ) { debug ( ' [ %s ] do Save Update acknowledgement Fields = %j ' , dataset Id , acknowledgement Fields ) ; var updates Collection = mongo Client . collection ( get Dataset Updates Collection Name ( dataset Id ) ) ; updates Collection . find One And Update ( { cuid : acknowledgement Fields . cuid , hash : acknowledgement Fields . hash } , { ' $set ' : acknowledgement Fields } , { upsert : true , return Original : false } , function ( err , update Result ) { if ( err ) { debug Error ( ' [ %s ] Failed to do Save Update due to error %s : : acknowledgement Fields = %j ' , dataset Id , err , acknowledgement Fields ) ; return callback ( err ) ; } return callback ( null , update Result . value ) ; } ) ; } 
function do List Updates ( dataset Id , criteria , options , callback ) { debug ( ' [ %s ] do List Updates criteria = %j ' , dataset Id , criteria ) ; var updates Collection = mongo Client . collection ( get Dataset Updates Collection Name ( dataset Id ) ) ; var doc Limit = options & & options . limit ; var cursor = updates Collection . find ( criteria ) ; if ( doc Limit & & doc Limit > 0 ) { cursor = cursor . limit ( doc Limit ) ; } cursor . to Array ( function ( err , updates ) { if ( err ) { debug Error ( ' [ %s ] Failed to do List Updates due to error %s : : criteria = %j ' + criteria , dataset Id , err , criteria ) ; return callback ( err ) ; } return callback ( null , updates ) ; } ) ; } 
function ( dataset Id , acknowledgement , callback ) { return metrics . time Async Func ( metrics . KEYS . MONGODB _OPERATION _TIME , do Find And Delete Update ) ( dataset Id , acknowledgement , callback ) ; } 
function ( dataset Id , acknowledgement Fields , callback ) { return metrics . time Async Func ( metrics . KEYS . MONGODB _OPERATION _TIME , do Save Update ) ( dataset Id , acknowledgement Fields , callback ) ; } 
function ( dataset Id , criteria , options , callback ) { return metrics . time Async Func ( metrics . KEYS . MONGODB _OPERATION _TIME , do List Updates ) ( dataset Id , criteria , options , callback ) ; } 
function Dataset Client ( dataset Id , opts ) { opts = opts | | { } ; this . dataset Id = dataset Id ; this . query Params = opts . query Params | | { } ; this . meta Data = opts . meta Data | | { } ; this . id = generate Dataset Client Id ( this ) ; this . config = opts . config | | datasets . get Dataset Config ( dataset Id ) ; this . collision Count = opts . collision Count | | 0 ; this . stopped = opts . stopped ; this . sync Scheduled = opts . sync Scheduled ; this . sync Completed = opts . sync Completed ; this . sync Loop Start = opts . sync Loop Start ; this . sync Loop End = opts . sync Loop End ; this . last Accessed = opts . last Accessed ; } 
function connect ( mongo DBConnection Url , mongo DBConnection Option , redis Url , cb ) { if ( arguments . length < 4 ) throw new Error ( 'connect requires 4 arguments ' ) ; async . series ( [ function connect To Mongo DB ( callback ) { Mongo Client . connect ( mongo DBConnection Url , mongo DBConnection Option | | { } , callback ) ; } , function connect To Redis ( callback ) { var redis Opts = { url : redis Url } ; var client = redis . create Client ( redis Opts ) ; 
function invoke ( dataset _id , params , callback ) { debug ( 'invoke ' ) ; if ( arguments . length < 3 ) throw new Error ( 'invoke requires 3 arguments ' ) ; 
function str To UTF 8Arr ( s DOMStr ) { var a Bytes , n Chr , n Str Len = s DOMStr . length , n Arr Len = 0 , n Map Idx , n Idx , n Chr Idx ; for ( n Map Idx = 0 ; n Map Idx < n Str Len ; n Map Idx + + ) { n Chr = s DOMStr . char Code At ( n Map Idx ) ; n Arr Len + = n Chr < 0x 8 0 ? 1 : n Chr < 0x 8 0 0 ? 2 : n Chr < 0x 1 0 0 0 0 ? 3 : n Chr < 0x 2 0 0 0 0 0 ? 4 : n Chr < 0x 4 0 0 0 0 0 0 ? 5 : 6 ; } a Bytes = new Uint 8Array ( n Arr Len ) ; for ( n Idx = 0 , n Chr Idx = 0 ; n Idx < n Arr Len ; n Chr Idx + + ) { n Chr = s DOMStr . char Code At ( n Chr Idx ) ; if ( n Chr < 1 2 8 ) { a Bytes [ n Idx + + ] = n Chr ; } else if ( n Chr < 0x 8 0 0 ) { a Bytes [ n Idx + + ] = 1 9 2 + ( n Chr > > > 6 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr & 6 3 ) ; } else if ( n Chr < 0x 1 0 0 0 0 ) { a Bytes [ n Idx + + ] = 2 2 4 + ( n Chr > > > 1 2 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr > > > 6 & 6 3 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr & 6 3 ) ; } else if ( n Chr < 0x 2 0 0 0 0 0 ) { a Bytes [ n Idx + + ] = 2 4 0 + ( n Chr > > > 1 8 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr > > > 1 2 & 6 3 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr > > > 6 & 6 3 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr & 6 3 ) ; } else if ( n Chr < 0x 4 0 0 0 0 0 0 ) { a Bytes [ n Idx + + ] = 2 4 8 + ( n Chr > > > 2 4 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr > > > 1 8 & 6 3 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr > > > 1 2 & 6 3 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr > > > 6 & 6 3 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr & 6 3 ) ; } else { a Bytes [ n Idx + + ] = 2 5 2 + ( n Chr / 1 0 7 3 7 4 1 8 2 4 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr > > > 2 4 & 6 3 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr > > > 1 8 & 6 3 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr > > > 1 2 & 6 3 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr > > > 6 & 6 3 ) ; a Bytes [ n Idx + + ] = 1 2 8 + ( n Chr & 6 3 ) ; } } return a Bytes ; } 
function convert To Object ( item Arr ) { var obj = { } ; _ . each ( item Arr , function ( item ) { obj [ item . uid ] = item ; } ) ; return obj ; } 
function Sync Scheduler ( sync Queue Impl , options ) { if ( ! sync Queue Impl ) { throw new Error ( 'sync Queue Impl is required ' ) ; } this . sync Queue = sync Queue Impl ; options = options | | { } ; this . sync Scheduler Lock Name = options . sync Scheduler Lock Name | | 'locks :sync :Sync Scheduler ' ; this . time Between Checks = options . time Between Checks | | 5 0 0 ; this . time Before Crash Assumed = options . time Before Crash Assumed | | 2 0 0 0 0 ; this . stopped = false ; } 
function update Dataset Clients ( wcb ) { var dataset Client Ids = _ . pluck ( dataset Clients To Sync , 'id ' ) ; sync Storage . update Many Dataset Clients ( { id : { $in : dataset Client Ids } } , { sync Scheduled : Date . now ( ) } , wcb ) ; } 
function insert Docs To Db ( dburl , collection Name , docs , cb ) { Mongo Client . connect ( dburl , function ( err , db ) { if ( err ) { return cb ( err ) ; } var col = db . collection ( collection Name ) ; col . insert Many ( docs , function ( err , result ) { if ( err ) { return cb ( err ) ; } return cb ( null , result ) ; } ) ; } ) ; } 
function set ( key , value , cb ) { if ( ! sync Config . use Cache | | ! redis Client ) { return cb & & cb ( ) ; } return redis Client . set ( key , value , cb ) ; } 
function get ( key , cb ) { if ( ! sync Config . use Cache | | ! redis Client ) { return cb & & cb ( ) ; } return redis Client . get ( key , cb ) ; } 
function del ( key , cb ) { if ( ! sync Config . use Cache | | ! redis Client ) { return cb & & cb ( ) ; } return redis Client . del ( key , cb ) ; } 
function validate Id Message Settings ( args ) { if ( args . settings ) { args . settings = JSON . parse ( decode URIComponent ( args . settings ) ) ; } else { args . settings = { } ; } if ( args . message ) { args . message = decode URIComponent ( args . message ) ; args . message = args . message = args . message . replace ( / ^ " | " $ / g , " " ) . replace ( / \ \ " / g , ' " ' ) . replace ( / \ \ \ \ / g , ' \ \ ' ) ; } else { return 1 ; } return 0 ; } 
function sync With Backend ( payload , tries , callback ) { var dataset Client Id = payload . id ; var dataset Id = payload . dataset Id ; var start Time = payload . start Time ; if ( ! dataset Client Id | | ! dataset Id ) { record Process Time ( start Time , false ) ; debug Error ( "no dataset Id value found in sync request payload %j " , payload ) ; return callback ( ) ; } if ( tries > 1 ) { 
function do Create ( dataset Id , pending Change , callback ) { var record = pending Change . post ; var meta Data = pending Change . meta _data ; debug ( ' [ %s ] CREATE Start data = %j ' , dataset Id , record ) ; data Handlers . do Create ( dataset Id , record , meta Data , function ( err , data ) { if ( err ) { debug Error ( ' [ %s ] CREATE Failed - : err = %s ' , dataset Id , err ) ; } else { debug ( ' [ %s ] CREATE Success - uid = %s ' , dataset Id , data . uid ) ; pending Change . old Uid = pending Change . uid ; pending Change . uid = data . uid ; } return save Update ( dataset Id , pending Change , err ? SYNC _UPDATE _TYPES . FAILED : SYNC _UPDATE _TYPES . APPLIED , err ? util . inspect ( err ) : null , callback ) ; } ) ; } 
function do Delete ( dataset Id , pending Change , callback ) { debug ( ' [ %s ] DELETE Start ' , dataset Id ) ; var meta Data = pending Change . meta _data ; var uid = pending Change . uid ; data Handlers . do Read ( dataset Id , uid , meta Data , function ( err , data ) { if ( err ) { debug Error ( 'READ for DELETE Failed - uid = %s : err = %s ' , dataset Id , uid , err ) ; return save Update ( dataset Id , pending Change , SYNC _UPDATE _TYPES . FAILED , util . inspect ( err ) , callback ) ; } debug ( ' [ %s ] READ for DELETE Success ' , dataset Id ) ; debug ( ' [ %s ] READ for DELETE Data : \n %j ' , dataset Id , data ) ; var pre Hash = hash Provider . record Hash ( dataset Id , pending Change . pre ) ; var data Hash = hash Provider . record Hash ( dataset Id , data ) ; debug ( ' [ %s ] DELETE Hash Check %s (client : : data Store ) = %s : : %s ' , dataset Id , uid , pre Hash . data Hash ) ; if ( ! data Hash ) { 
function apply Pending Change ( pending Change , tries , callback ) { var dataset Id = pending Change . dataset Id ; if ( ! dataset Id | | ! pending Change . action | | ! pending Change . uid | | ! pending Change . cuid | | ! pending Change . hash ) { debug Error ( " [ %s ] invalid pending Change request dropped : : item = %j " , dataset Id , pending Change ) ; return callback ( ) ; } debug ( ' [ %s ] process Pending : : item = %j ' , dataset Id , pending Change ) ; if ( tries > retry Limit ) { 
function Mongodb Queue ( name , metrics , lock , opts ) { if ( ! name ) { throw new Error ( 'name is required to create a mongodb queue ' ) ; } if ( ! opts | | ! opts . mongodb ) { throw new Error ( 'mongodb is not specified to create mongodb queue ' ) ; } this . queue Name = name ; this . metrics = metrics ; this . lock = lock ; this . lock Name = opts . lock Name | | ( 'lock :sync : ' + this . queue Name ) ; this . lock Timeout = opts . lock Timeout | | 1 0 0 0 0 ; this . mongodb = opts . mongodb ; this . queue Options = { visibility : opts . visibility | | 3 0 , ttl : opts . queue Messages TTL | | 2 4 * 6 0 * 6 0 } ; this . queue ; } 
function list Indexes ( callback ) { debug ( ' [ %s ] list existing indexes ' , self . queue Name ) ; collection . index Information ( { full : true } , function ( err , index Info ) { if ( err ) { debug ( ' [ %s ] error getting index Info . skipping ttl index check : %s ' , self . queue Name , err ) ; return callback ( null , null ) ; } return callback ( null , index Info ) ; } ) ; } 
function ( dataset Id , params , callback ) { var interceptor = request Interceptors [ dataset Id ] | | defaults . request Interceptor ; return interceptor ( dataset Id , params , callback ) ; } 
function ( dataset Id , query Params , callback ) { var interceptor = response Interceptors [ dataset Id ] | | defaults . response Interceptor ; return interceptor ( dataset Id , query Params , callback ) ; } 
function add To Queue ( items , extra Params , target Queue , cb ) { if ( ! items | | items . length = = = 0 ) { return cb ( ) ; } var items To Push = _ . map ( items , function ( item ) { return _ . extend ( { } , item , extra Params ) ; } ) ; debug ( "adding %d items to queue %s " , items To Push . length , target Queue . get Name ( ) ) ; target Queue . add Many ( items To Push , cb ) ; } 
function format Updates ( processed Updates ) { var updates = { hashes : { } } ; _ . each ( processed Updates , function ( update ) { var type = update . type ; var hash = update . hash ; updates . hashes [ hash ] = update ; updates [ type ] = updates [ type ] | | { } ; updates [ type ] [ hash ] = update ; } ) ; return updates ; } 
function remove Updates In Request ( updates In Db , updates In Request ) { var updates Not In Request = _ . filter ( updates In Db , function ( db Update ) { var found In Request = _ . find Where ( updates In Request , { hash : db Update . hash } ) ; return ! found In Request ; } ) ; return updates Not In Request ; } 
function sync ( dataset Id , params , cb ) { debug ( ' [ %s ] process sync request for the dataset ' , dataset Id ) ; var query Params = params . query _params | | { } ; var meta Data = params . meta _data | | { } ; var dataset Client = new Dataset Client ( dataset Id , { query Params : query Params , meta Data : meta Data } ) ; debug ( ' [ %s ] processing sync API request : : query _params = %j : : meta _data = %j ' , dataset Id , query Params , meta Data ) ; async . series ( { request Interceptor : async . apply ( interceptors . request Interceptor , dataset Id , params ) , read Dataset Client : function check Datasetclient Stopped ( callback ) { sync Storage . read Dataset Client ( dataset Client . get Id ( ) , function ( err , dataset Client Json ) { if ( err ) { return callback ( err ) ; } if ( dataset Client Json & & dataset Client Json . stopped = = = true ) { return callback ( new Error ( 'sync stopped for dataset ' + dataset Id ) ) ; } else { return callback ( null , dataset Client Json ) ; } } ) ; } } , function ( err , results ) { if ( err ) { debug Error ( ' [ %s ] sync request returns error = %s %j ' , dataset Id , err , params ) ; return cb ( err ) ; } return process Sync API ( dataset Id , params , results . read Dataset Client , cb ) ; } ) ; } 
function ( data , reason ) { switch ( reason ) { case "cancel " : if ( on Cancel & & typeof ( on Cancel ) = = = "function " ) { on Cancel ( ) ; } break ; case "done " : if ( on Done & & typeof ( on Done ) = = = "function " ) { on Done ( data ) ; } break ; } } 
function ( result ) { var error ; if ( ! result . _success ) { error = new Contact Error ( result . code ) ; } if ( on Invoke & & typeof ( on Invoke ) = = = "function " ) { on Invoke ( error ) ; } } 
function Dataset Clients Cleaner ( opts ) { this . retention Period = opts . retention Period | | ' 2 4h ' ; this . check Frequency = opts . check Frequency | | ' 1h ' ; this . cleaner Lock Name = opts . cleaner Lock Name | | 'locks :sync :Dataset Cleaner ' ; this . lock Timeout = parse Duration ( this . check Frequency ) / 2 ; this . job ; } 
function process Acknowledgement ( acknowledgement , callback ) { var dataset Id = acknowledgement . dataset Id ; if ( ! dataset Id | | ! acknowledgement . cuid | | ! acknowledgement . hash ) { debug Error ( "acknowledgement missing info %j " , acknowledgement ) ; return callback ( ) ; } debug ( 'process Acknowledge : : processing acknowledge %j ' , acknowledgement ) ; sync Storage . find And Delete Update ( dataset Id , acknowledgement , function ( err ) { if ( err ) { debug Error ( 'END process Acknowledge - err = %s ' , err ) ; return callback ( err ) ; } else { debug ( 'acknowledgement processed successfully . hash = %s ' , acknowledgement . hash ) ; return callback ( ) ; } } ) ; } 
function ( success , fail , args , env ) { var result = new Plugin Result ( args , env ) , userargs , wv , i ; 
function ( error ) { if ( error ) { result . callback Error ( error , false ) ; } else { result . callback Ok ( undefined , false ) ; } } 
function add Event Listeners ( ) { window . add Event Listener ( 'resize ' , this . event Listener ) ; this . scroll Parents . for Each ( parent = > { parent . add Event Listener ( 'scroll ' , this . event Listener ) ; } ) ; } 
function remove Event Listeners ( ) { window . remove Event Listener ( 'resize ' , this . event Listener ) ; this . scroll Parents . for Each ( parent = > { parent . remove Event Listener ( 'scroll ' , this . event Listener ) ; } ) ; } 
function ( element ) { for ( var i = 0 , len = this . length ; i < len ; i + + ) { if ( element = = = this [ i ] ) { return true ; } } return false ; } 
function ( elements ) { if ( ! _ . is Array ( elements ) ) { elements = [ elements ] ; } elements . for Each ( function ( e ) { this . push ( e ) ; } . bind ( this ) ) ; return this ; } 
function ( list ) { var result = false ; list . for Each ( function ( e ) { result | = this . remove Element ( e ) ; } . bind ( this ) ) ; return result ; } 
function ( predicate ) { var lists = new Array List ; var arrays = _ . partition ( this , predicate ) ; arrays . for Each ( function ( arr ) { var list = new Array List ; lists . push ( list . add ( arr ) ) ; } ) ; return lists ; } 
function ( is Sorted , iterator ) { var list = new Array List ; return list . add ( _ . uniq ( this , is Sorted , iterator ) ) ; } 
function ( iterator , context ) { var list = new Array List ; return list . add ( _ . map ( this , iterator , context ) ) ; } 
function ( predicate , context ) { var list = new Array List ; return list . add ( _ . filter ( this , predicate , context ) ) ; } 
function ( iterator , context ) { var list = new Array List ; return list . add ( _ . sort By ( this , iterator , context ) ) ; } 
function this To Args ( that , args ) { args = Array . prototype . slice . call ( args , 0 ) ; args . unshift ( that ) ; return args ; } 
function Koa Nunjucks ( o Ctx , s Path , o Opts ) { 
function parse ( report ) { var rows = [ ' ' , 'Binary Images : ' ] ; var sys = report [ 'system ' ] | | { } ; var exe _path = sys [ 'CFBundle Executable Path ' ] ; var images = report [ 'binary _images ' ] | | [ ] ; _ . each ( images , function ( image ) { 
function get _cpu _arch ( major , minor ) { if ( major = = = CPU _TYPE _ARM 6 4 ) { return 'arm 6 4 ' ; } if ( major = = = CPU _TYPE _X 8 6 ) { return 'i 3 8 6 ' ; } if ( major = = = CPU _TYPE _X 8 6 _ 6 4 ) { return 'x 8 6 _ 6 4 ' ; } if ( major = = = CPU _TYPE _ARM ) { return CPU _ARM _TYPES [ minor ] | | 'arm ' ; } return ` $ { major } $ { minor } ` } 
function get _registers ( cpu ) { cpu = cpu . to Lower Case ( ) ; if ( cpu . starts With ( 'arm ' ) ) { return REGISTERS . ARM ; } if ( ~ [ 'x 8 6 ' , 'i 3 8 6 ' , 'i 4 8 6 ' , 'i 6 8 6 ' ] . index Of ( cpu ) ) { return REGISTERS . X 8 6 ; } if ( cpu = = = 'x 8 6 _ 6 4 ' ) { return REGISTERS . X 8 6 _ 6 4 ; } return [ ] ; } 
function parse ( report ) { var sys = report [ 'system ' ] | | { } ; var info = report [ 'report ' ] | | { } ; function _i ( x ) { return info [ x ] | | ' ' ; } function _s ( x ) { return sys [ x ] | | ' ' ; } var error = report [ 'crash ' ] [ 'error ' ] ; var thread = Utils . get _crash _thread ( report ) ; return [ Utils . header ( 'Incident Identifier : ' , _i ( 'id ' ) , 4 ) , Utils . header ( 'Crash Reporter Key : ' , _s ( 'device _app _hash ' ) , 4 ) , Utils . header ( 'Hardware Model : ' , _s ( 'machine ' ) , 4 ) , Utils . header ( 'Process : ' , ` $ { _s ( 'process _name ' ) } $ { _s ( 'process _id ' ) } ` ) , Utils . header ( 'Path : ' , _s ( 'CFBundle Executable Path ' ) ) , Utils . header ( 'Identifier : ' , _s ( 'CFBundle Identifier ' ) ) , Utils . header ( 'Version : ' , ` $ { _s ( 'CFBundle Short Version String ' ) } $ { _s ( 'CFBundle Version ' ) } ` ) , Utils . header ( 'Code Type : ' , get _cpu _arch ( report ) ) , Utils . header ( 'Parent Process : ' , ` $ { _s ( 'parent _process _name ' ) } $ { _s ( 'parent _process _id ' ) } ` ) , Utils . header ( ' ' , ' ' ) , Utils . header ( 'Date /Time : ' , get _time ( report ) ) , Utils . header ( 'OS Version : ' , ` $ { _s ( 'system _name ' ) } $ { _s ( 'system _version ' ) } $ { _s ( 'os _version ' ) } ` ) , Utils . header ( 'Report Version : ' , 1 0 4 ) , Utils . header ( ' ' , ' ' ) ] . concat ( Errors . parse _errors ( error , thread ) ) ; } 
function parse ( report , crash , threads ) { crash = crash | | report [ 'crash ' ] | | { } ; threads = threads | | crash [ 'threads ' ] | | [ ] ; var rows = [ ] ; var idx = 0 ; _ . each ( threads , function ( thread ) { if ( idx + + ! = = 0 ) { rows . push ( ' ' ) ; } var index = thread [ 'index ' ] ; var name = thread [ 'name ' ] ; var queue = thread [ 'dispatch _queue ' ] ; if ( name ) { rows . push ( ` $ { index } $ { name } ` ) ; } else if ( queue ) { rows . push ( ` $ { index } $ { queue } ` ) ; } if ( thread [ 'crashed ' ] ) { rows . push ( ` $ { index } ` ) ; } else { rows . push ( ` $ { index } ` ) ; } var backtrace = thread [ 'backtrace ' ] ; var trace _log = Backtrace . parse _backtrace ( backtrace ) ; rows = rows . concat ( trace _log ) ; } ) ; return rows ; } 
function convert ( report ) { return [ ] . concat ( Parsers . parse ( 'headers ' , report ) , Parsers . parse ( 'reason ' , report ) , Parsers . parse ( 'threads ' , report ) , Parsers . parse ( 'cpu ' , report ) , Parsers . parse ( 'images ' , report ) , Parsers . parse ( 'extras ' , report ) ) . join ( ' \n ' ) } 
function get _crash _thread ( report ) { var crash = report [ 'crash ' ] | | { } ; var threads = crash [ 'threads ' ] | | [ ] ; var thread = threads . find ( function ( thread ) { return ! ! thread [ 'crashed ' ] ; } ) ; return thread | | crash [ 'crashed _thread ' ] ; } 
function pad ( input , char , count , direction ) { var ipt = ' ' + ( input ) ; var rem = count - ipt . length ; if ( rem < 1 ) { return ipt ; } var padding = char . repeat ( count - ipt . length ) ; return direction = = = 'left ' ? padding + ipt : ipt + padding ; } 
function parse ( report , thread ) { var rows = [ ' ' ] ; var crashed = thread | | Utils . get _crash _thread ( report ) ; if ( ! crashed ) { return rows ; } var index = crashed [ 'index ' ] ; var sys = report [ 'system ' ] | | { } ; var type = sys [ 'binary _cpu _type ' ] ; var sub = sys [ 'binary _cpu _subtype ' ] ; var arch ; if ( ! type & & ! sub ) { arch = sys [ 'cpu _arch ' ] ; } else { arch = CPU . get _cpu _arch ( type , sub ) ; } var cpu = CPU . get _cpu _type ( arch ) ; rows . push ( ` $ { index } $ { cpu } ` ) ; var registers = ( crashed [ 'registers ' ] | | { } ) [ 'basic ' ] | | { } ; var reg _order = CPU . get _registers ( cpu ) ; var line = ' ' ; for ( var i = 0 , j = reg _order . length ; i < j ; i + + ) { if ( i % 4 = = = 0 & & i ! = = 0 ) { rows . push ( line ) ; line = ' ' ; } var register = reg _order [ i ] ; var register _addr = registers [ register ] | | 0 ; var register _name = Utils . pad _left ( register , ' ' , 6 ) ; var register _loc = Utils . pad _hex ( register _addr , ' 0 ' , 8 ) ; var register _pad = Utils . pad _right ( register _loc , ' ' , 9 ) ; line + = ` $ { register _name } $ { register _pad } ` ; } if ( line ) { rows . push ( line ) ; } return rows ; } 
function parse ( report ) { var system = report [ 'system ' ] | | { } ; var crash = report [ 'crash ' ] | | { } ; return [ ' ' , 'Extra Information : ' ] . concat ( parse _nsexception ( crash ) , parse _crash _thread ( report ) , parse _last _exception ( report ) , parse _diagnosis ( crash ) , parse _recrash ( report ) ) ; } 
function parse _errors ( error , thread ) { var signal = error [ 'signal ' ] ; var mach = error [ 'mach ' ] ; var exc _name = mach [ 'exception _name ' ] | | ' 0 ' ; var code _name = mach [ 'code _name ' ] | | ' 0x 0 0 0 0 0 0 0 0 ' ; var sig _name = signal [ 'name ' ] | | signal [ 'signal ' ] | | ' 0 ' ; var addr _name = Utils . pad _hex ( error [ 'address ' ] | | 0 , ' 0 ' , 8 ) ; var index = 0 ; if ( thread ) { index = thread [ 'index ' ] ; } return [ Utils . header ( 'Exception Type : ' , ` $ { exc _name } $ { sig _name } ` ) , Utils . header ( 'Exception Codes : ' , ` $ { code _name } $ { addr _name } ` ) , Utils . header ( 'Crashed Thread : ' , index ) ] ; } 
function subscribe To Title ( get Title , set Title ) { var title Element = document . query Selector ( 'title ' ) ; var doc El = document . document Element ; function title Modified ( ) { var title = document . title ; var old Title = get Title ( ) ; if ( old Title ! = = title ) { set Title ( title ) ; } } function subscribe As Observer ( ) { var observer = new Mutation Observer ( function ( ) { title Modified ( ) ; } ) ; observer . observe ( title Element , { child List : true } ) ; return function ( ) { return observer . disconnect ( ) ; } ; } function subscribe IE ( ) { 
function ( defined Log Levels ) { log Levels = this . _merge ( defined Log Levels ) ; 
function ( class Name ) { 
function parse ( report ) { var rows = [ ' ' ] ; var crash = report [ 'crash ' ] | | { } ; var error = crash [ 'error ' ] ; var type = error [ 'type ' ] ; var reason = error [ 'reason ' ] ; var user _exception = error [ 'user _reported ' ] ; var ns _exception = error [ 'nsexception ' ] ; if ( ns _exception ) { rows . push ( format ( ns _exception ) ) ; rows . push ( ' ' ) ; return rows ; } if ( zombie _exception ( report ) ) { var last _exception = Utils . get _last _exception ( report ) ; if ( last _exception ) { rows . push ( format ( last _exception , reason ) ) ; rows . push ( 'NOTE : This exception has been deallocated ! ' + 'Stack trace is crash from attempting to access this zombie exception . ' ) ; rows . push ( ' ' ) ; } return rows ; } if ( user _exception ) { rows . push ( format ( user _exception , reason ) ) ; var line = user _exception [ 'line _of _code ' ] ; var back = user _exception [ 'backtrace ' ] | | [ ] ; if ( line | | back ) { rows . push ( 'Custom Backtrace : ' ) ; } if ( line ) { rows . push ( ` $ { line } ` ) ; } return rows . concat ( back ) ; } if ( type = = 'cpp _exception ' ) { return rows . concat ( format ( error [ 'cppexception ' ] , reason ) ) ; } if ( type = = 'deadlock ' ) { rows . push ( 'Application main thread deadlocked ' ) ; rows . push ( ' ' ) ; } return rows ; } 
function parse _backtrace ( backtrace ) { if ( ! backtrace ) { return [ ] ; } var num = 0 ; var rows = [ ] ; var contents = backtrace [ 'contents ' ] | | [ ] ; _ . each ( contents , function ( trace ) { 
function order _stack ( stack ) { 
function ( name , src , onload , requester , errorback ) { 
function rgb To Hex ( rgb ) { function component To Hex ( c ) { var hex = c . to String ( 1 6 ) . to Upper Case ( ) ; return hex . length = = = 1 ? " 0 " + hex : hex ; } var color = rgb . map ( function ( component ) { return component To Hex ( parse Int ( component * 2 5 5 ) ) ; } ) ; color . unshift ( " 0X " ) ; color = color . join ( " " ) ; return parse Int ( color ) ; } 
function Slack Bot ( slack _params , ws _params ) { this . cached = typeof slack _params . cached ! = = 'undefined ' ? slack _params . cached : true this . token = slack _params . token | | null this . name = slack _params . name | | null this . reconnect _url = null ws _params = ws _params | | { } this . ws _protocols = ws _params . protocols | | null this . ws _options = ws _params . options | | null } 
function wrap Standard Array Mutators ( array , subscribable , signal ) { var fn Names = [ 'pop ' , 'push ' , 'reverse ' , 'shift ' , 'sort ' , 'splice ' , 'unshift ' ] ; fn Names . for Each ( function ( fn Name ) { var orig Mutator = array [ fn Name ] ; array [ fn Name ] = function ( ) { var result = orig Mutator . apply ( this , arguments ) ; if ( signal . pause ! = = true ) { subscribable . notify Subscribers ( this ) ; } return result ; } ; } ) ; } 
function add Knockout Array Mutators ( ko , array , subscribable , signal ) { var fn Names = [ 'remove ' , 'remove All ' , 'destroy ' , 'destroy All ' , 'replace ' ] ; fn Names . for Each ( function ( fn Name ) { 
function get Subscribable For Array ( ko , array ) { var subscribable = array . _subscribable ; var signal = { } ; if ( ! subscribable ) { subscribable = array . _subscribable = new ko . subscribable ( ) ; wrap Standard Array Mutators ( array , subscribable , signal ) ; add Knockout Array Mutators ( ko , array , subscribable , signal ) ; } return subscribable ; } 
function start Watchingarray ( ko , observable , array ) { var subscribable = get Subscribable For Array ( ko , array ) ; return subscribable . subscribe ( observable ) ; } 
function notify When Present Or Future Array Values Mutate ( ko , observable ) { var watching Array Subscription = null ; ko . computed ( function ( ) { 
function get Runner ( grunt ) { var path = require ( 'path ' ) ; var tsd = require ( 'tsd ' ) ; function get API ( options ) { grunt . log . writeln ( ' - > config : ' + options . config ) ; var api = tsd . get API ( options . config , grunt . option ( 'verbose ' ) ) ; if ( options . cache Dir ) { grunt . log . writeln ( 'cache Dir : ' + options . cache Dir ) ; api . context . paths . cache Dir = path . resolve ( options . cache Dir ) ; } return api ; } function reinstall ( options ) { var api = get API ( options ) ; return api . read Config ( options . config , true ) . then ( function ( ) { var opts = tsd . Options . from JSON ( options . opts ) ; opts . overwrite Files = true ; opts . resolve Dependencies = true ; opts . save To Config = true ; if ( options . latest ) { var query = new tsd . Query ( ) ; api . context . config . get Installed ( ) . for Each ( function ( inst ) { var def = tsd . Def . get From ( inst . path ) ; query . add Name Pattern ( def . project + ' / ' + def . name ) ; } ) ; query . version Matcher = new tsd . Version Matcher ( 'latest ' ) ; return api . select ( query , opts ) . then ( function ( selection ) { return api . install ( selection , opts ) ; } ) ; } return api . reinstall ( opts ) ; } ) ; } return { get API : get API , commands : { reinstall : reinstall } } ; } 
async function Composite Below ( ctx , target , major Name , side Name , config ) { config = config | | { } ; const major = this . items [ major Name ] ; const side = this . items [ side Name ] ; if ( ! major ) { this . remove ( side Name ) ; this . remove ( major Name ) ; this . introduce ( target , side ) ; return ; } / / Add new cmaps for ( const unicode in side . cmap ) { if ( major . cmap [ unicode ] ) continue ; major . cmap [ unicode ] = side . cmap [ unicode ] ; } / / Add new cmap UVS assignments if ( side . cmap _uvs ) { if ( ! major . cmap _uvs ) major . cmap _uvs = { } ; for ( const key in side . cmap _uvs ) { if ( major . cmap _uvs [ key ] ) continue ; major . cmap _uvs [ key ] = side . cmap _uvs [ key ] ; } } / / Add new glyphs for ( const gid in side . glyf ) { major . glyf [ gid ] = side . glyf [ gid ] ; if ( major . TSI _ 2 3 & & major . TSI _ 2 3 . glyphs & & side . TSI _ 2 3 & & side . TSI _ 2 3 . glyphs ) { major . TSI _ 2 3 . glyphs [ gid ] = side . TSI _ 2 3 . glyphs [ gid ] ; } if ( major . TSI _ 0 1 & & major . TSI _ 0 1 . glyphs & & side . TSI _ 0 1 & & side . TSI _ 0 1 . glyphs ) { major . TSI _ 0 1 . glyphs [ gid ] = side . TSI _ 0 1 . glyphs [ gid ] ; } } if ( config . merge OTL ) { merge OTLTables ( major . GSUB , side . GSUB , false ) ; merge OTLTables ( major . GPOS , side . GPOS , false ) ; major . GDEF = merge GDEF ( side . GDEF | | { } , major . GDEF | | { } ) ; } / / Change name this . remove ( side Name ) ; this . remove ( major Name ) ; this . introduce ( target , major ) ; } 
function filter Feature ( table , options ) { if ( ! table ) return ; options = options | | { } ; const visible Languages = new Set ( ) ; const visible Features = new Set ( ) ; const visible Lookups = new Set ( ) ; for ( let lid in table . languages ) { const lang = table . languages [ lid ] ; if ( ! lang ) continue ; if ( options . is Valid Lang & & ! options . is Valid Lang ( lid , lang ) ) continue ; visible Languages . add ( lid ) ; if ( lang . required Feature & & table . features [ lang . required Feature ] ) { if ( ! ( options . is Valid Feature & & ! options . is Valid Feature ( lang . required Feature , table . features [ lang . required Feature ] ) ) ) { visible Features . add ( lang . required Feature ) ; } } if ( ! lang . features ) lang . features = [ ] ; for ( let f of lang . features ) { if ( ! table . features [ f ] ) continue ; if ( options . is Valid Feature & & ! options . is Valid Feature ( f , table . features [ f ] ) ) continue ; visible Features . add ( f ) ; } } table . languages = kvfilter ( table . languages , k = > visible Languages . has ( k ) ) ; table . features = kvfilter ( table . features , k = > visible Features . has ( k ) ) ; for ( let fid in table . features ) { if ( ! table . features [ fid ] ) continue ; for ( let lutid of table . features [ fid ] ) { if ( ! table . lookups [ lutid ] ) continue ; visible Lookups . add ( lutid ) ; } } do { const n A = visible Lookups . size ; for ( let lid in table . lookups ) { const lut = table . lookups [ lid ] ; if ( ! lut | | ! visible Lookups . has ( lid ) ) continue ; switch ( lut . type ) { case "gsub _chaining " : case "gpos _chaining " : for ( let rule of lut . subtables ) { for ( let application of rule . apply ) { visible Lookups . add ( application . lookup ) ; } } break ; default : break ; } } const n K = visible Lookups . size ; if ( n K > = n A ) break ; } while ( true ) ; table . lookups = kvfilter ( table . lookups , k = > visible Lookups . has ( k ) ) ; } 
function get Value ( options ) { return new Promise ( ( resolve , reject ) = > { let url = api URL ; 
function delete Backup ( config ) { return new Promise ( ( resolve , reject ) = > { const backup Path = path . join ( process . cwd ( ) , ( config . backup ! = = undefined ) ? config . backup : " .backup " ) ; fs . remove ( backup Path , ( error ) = > { ( error = = = null ) ? resolve ( config ) : reject ( error ) ; } ) ; } ) ; } 
function inline ( config , files ) { return new Promise ( ( resolve , reject ) = > { let files Changed = 0 ; let i = 0 ; ( function proceed ( result ) { if ( result ) { files Changed + + ; } if ( i = = = files . length ) { resolve ( "Modified " + files Changed + " files " ) ; } else { Inline Import . transform ( files [ i + + ] , config . options ) . then ( proceed ) . catch ( reject ) ; } } ( ) ) ; } ) ; } 
function get Files ( config ) { return new Promise ( ( resolve , reject ) = > { const src = config . src ; let files = [ ] ; let i = 0 ; ( function proceed ( error , more Files ) { if ( error ! = = null ) { reject ( error ) ; } else { files = files . concat ( more Files ) ; if ( i = = = src . length ) { if ( files . length = = = 0 ) { reject ( "No input files found " ) ; } else { resolve ( [ config , files ] ) ; } } else { glob ( src [ i + + ] , proceed ) ; } } } ( null , [ ] ) ) ; } ) ; } 
function validate Config ( config ) { return new Promise ( ( resolve , reject ) = > { if ( config . src ! = = undefined ) { if ( ! Array . is Array ( config . src ) ) { config . src = [ config . src ] ; } resolve ( config ) ; } else { reject ( "No source path specified " ) ; } } ) ; } 
function read Config ( ) { 
function Markdown ( config ) { RED . nodes . create Node ( this , config ) ; var self = this ; this . on ( 'input ' , function ( msg ) { msg . payload = marked ( msg . payload ) ; self . send ( msg ) ; } ) ; } 
function read File ( file , encoding ) { return new Promise ( ( resolve , reject ) = > { fs . read File ( file , encoding , ( error , data ) = > error ? reject ( error ) : resolve ( data ) ) ; } ) ; } 
function parse Imports ( data , file , extensions ) { const imports = [ ] ; let result = import Reg Exp . exec ( data ) ; let encoding ; while ( result ! = = null ) { encoding = extensions [ path . extname ( result [ 2 ] ) ] ; 
function read Imports ( imports , data ) { return ( imports . length = = = 0 ) ? Promise . resolve ( [ imports , data ] ) : new Promise ( ( resolve , reject ) = > { let i = 0 ; ( function proceed ( error , import Data ) { if ( import Data ) { imports [ i + + ] . data = import Data ; } if ( error ) { reject ( error ) ; } else if ( i = = = imports . length ) { resolve ( [ imports , data ] ) ; } else { fs . read File ( imports [ i ] . path , imports [ i ] . encoding , proceed ) ; } } ( ) ) ; } ) ; } 
function inline Imports ( imports , data , declaration ) { let modified = imports . length > 0 ; let i , item ; 
function write File ( modified , data , file ) { return ! modified ? Promise . resolve ( false ) : new Promise ( ( resolve , reject ) = > { fs . write File ( file , data , ( error ) = > { error ? reject ( error ) : resolve ( true ) ; } ) ; } ) ; } 
function ( N , data , CART _OR _SPH , DIRECT _OR _PINV ) { var Ndirs = data . length , Nsh = ( N + 1 ) * ( N + 1 ) ; var inv Y _N ; var mag = [ , ] ; if ( Nsh > Ndirs ) { console . log ( "The SHT degree is too high for the number of data points " ) } 
function ( coeffs , azi Elev ) { var azi Elev R = azi Elev ; var N = Math . sqrt ( coeffs . length ) - 1 ; 
function ( array 2D ) { for ( var q = 0 ; q < array 2D . length ; q + + ) console . log ( array 2D [ q ] ) ; } 
function ( xyz , OMIT _MAG ) { var azi , elev , r ; var azi Elev R = new Array ( xyz . length ) ; for ( var i = 0 ; i < xyz . length ; i + + ) { azi = Math . atan 2 ( xyz [ i ] [ 1 ] , xyz [ i ] [ 0 ] ) ; elev = Math . atan 2 ( xyz [ i ] [ 2 ] , Math . sqrt ( xyz [ i ] [ 0 ] * xyz [ i ] [ 0 ] + xyz [ i ] [ 1 ] * xyz [ i ] [ 1 ] ) ) ; if ( OMIT _MAG = = 1 ) { azi Elev R [ i ] = [ azi , elev ] ; } else { r = Math . sqrt ( xyz [ i ] [ 0 ] * xyz [ i ] [ 0 ] + xyz [ i ] [ 1 ] * xyz [ i ] [ 1 ] + xyz [ i ] [ 2 ] * xyz [ i ] [ 2 ] ) ; azi Elev R [ i ] = [ azi , elev , r ] ; } } return azi Elev R ; } 
function ( azi Elev R ) { var x , y , z ; var xyz = new Array ( azi Elev R . length ) ; for ( var i = 0 ; i < azi Elev R . length ; i + + ) { x = Math . cos ( azi Elev R [ i ] [ 0 ] ) * Math . cos ( azi Elev R [ i ] [ 1 ] ) ; y = Math . sin ( azi Elev R [ i ] [ 0 ] ) * Math . cos ( azi Elev R [ i ] [ 1 ] ) ; z = Math . sin ( azi Elev R [ i ] [ 1 ] ) ; if ( azi Elev R [ 0 ] . length = = 2 ) xyz [ i ] = [ x , y , z ] ; else if ( azi Elev R [ 0 ] . length = = 3 ) xyz [ i ] = [ azi Elev R [ i ] [ 2 ] * x , azi Elev R [ i ] [ 2 ] * y , azi Elev R [ i ] [ 2 ] * z ] ; } return xyz ; } 
function ( N , data ) { var azi = new Array ( data . length ) ; var elev = new Array ( data . length ) ; for ( var i = 0 ; i < data . length ; i + + ) { azi [ i ] = data [ i ] [ 0 ] ; elev [ i ] = data [ i ] [ 1 ] ; } var factorials = new Array ( 2 * N + 1 ) ; var Ndirs = azi . length ; var Nsh = ( N + 1 ) * ( N + 1 ) ; var leg _n _minus 1 = 0 ; var leg _n _minus 2 = 0 ; var leg _n ; var sinel = numeric . sin ( elev ) ; var index _n = 0 ; var Y _N = new Array ( Nsh ) ; var Nn 0 , Nnm ; var cosmazi , sinmazi ; 
function ( n , x , Pnm _minus 1 , Pnm _minus 2 ) { var Pnm = new Array ( n + 1 ) ; switch ( n ) { case 1 : var x 2 = numeric . mul ( x , x ) ; var P 1 0 = x ; var P 1 1 = numeric . sqrt ( numeric . sub ( 1 , x 2 ) ) ; Pnm [ 0 ] = P 1 0 ; Pnm [ 1 ] = P 1 1 ; break ; case 2 : var x 2 = numeric . mul ( x , x ) ; var P 2 0 = numeric . mul ( 3 , x 2 ) ; P 2 0 = numeric . sub ( P 2 0 , 1 ) ; P 2 0 = numeric . div ( P 2 0 , 2 ) ; var P 2 1 = numeric . sub ( 1 , x 2 ) ; P 2 1 = numeric . sqrt ( P 2 1 ) ; P 2 1 = numeric . mul ( 3 , P 2 1 ) ; P 2 1 = numeric . mul ( P 2 1 , x ) ; var P 2 2 = numeric . sub ( 1 , x 2 ) ; P 2 2 = numeric . mul ( 3 , P 2 2 ) ; Pnm [ 0 ] = P 2 0 ; Pnm [ 1 ] = P 2 1 ; Pnm [ 2 ] = P 2 2 ; break ; default : var x 2 = numeric . mul ( x , x ) ; var one _min _x 2 = numeric . sub ( 1 , x 2 ) ; 
function ( A ) { var z = numeric . svd ( A ) , foo = z . S [ 0 ] ; var U = z . U , S = z . S , V = z . V ; var m = A . length , n = A [ 0 ] . length , tol = Math . max ( m , n ) * numeric . epsilon * foo , M = S . length ; var Sinv = new Array ( M ) ; for ( var i = M - 1 ; i ! = = - 1 ; i - - ) { if ( S [ i ] > tol ) Sinv [ i ] = 1 / S [ i ] ; else Sinv [ i ] = 0 ; } return numeric . dot ( numeric . dot ( V , numeric . diag ( Sinv ) ) , numeric . transpose ( U ) ) } 
function ( A ) { var AT = numeric . transpose ( A ) ; return numeric . dot ( numeric . inv ( numeric . dot ( AT , A ) ) , AT ) ; } 
function ( Rxyz , L ) { var Nsh = ( L + 1 ) * ( L + 1 ) ; 
function U ( l , m , n , R _ 1 , R _lm 1 ) { return P ( 0 , l , m , n , R _ 1 , R _lm 1 ) ; } 
function P ( i , l , a , b , R _ 1 , R _lm 1 ) { var ri 1 , rim 1 , ri 0 , ret ; ri 1 = R _ 1 [ i + 1 ] [ 1 + 1 ] ; rim 1 = R _ 1 [ i + 1 ] [ - 1 + 1 ] ; ri 0 = R _ 1 [ i + 1 ] [ 0 + 1 ] ; if ( b = = - l ) { ret = ri 1 * R _lm 1 [ a + l - 1 ] [ 0 ] + rim 1 * R _lm 1 [ a + l - 1 ] [ 2 * l - 2 ] ; } else { if ( b = = l ) ret = ri 1 * R _lm 1 [ a + l - 1 ] [ 2 * l - 2 ] - rim 1 * R _lm 1 [ a + l - 1 ] [ 0 ] ; else ret = ri 0 * R _lm 1 [ a + l - 1 ] [ b + l - 1 ] ; } return ret ; } 
function ( yaw , pitch , roll ) { var Rx , Ry , Rz ; if ( roll = = 0 ) Rx = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] ; else Rx = [ [ 1 , 0 , 0 ] , [ 0 , Math . cos ( roll ) , Math . sin ( roll ) ] , [ 0 , - Math . sin ( roll ) , Math . cos ( roll ) ] ] ; if ( pitch = = 0 ) Ry = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] ; else Ry = [ [ Math . cos ( pitch ) , 0 , - Math . sin ( pitch ) ] , [ 0 , 1 , 0 ] , [ Math . sin ( pitch ) , 0 , Math . cos ( pitch ) ] ] ; if ( yaw = = 0 ) Rz = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] ; else Rz = [ [ Math . cos ( yaw ) , Math . sin ( yaw ) , 0 ] , [ - Math . sin ( yaw ) , Math . cos ( yaw ) , 0 ] , [ 0 , 0 , 1 ] ] ; var R = numeric . dot MMsmall ( Ry , Rz ) ; R = numeric . dot MMsmall ( Rx , R ) ; return R ; } 
function heapify ( compare , x ) { var n = x . length ; for ( var k = n / 2 | 0 ; k ; ) { ( 0 , _core . siftdown ) ( compare , x , 0 , n , - - k ) ; } return new _core . Heap ( compare , x ) ; } 
function siftdown ( compare , a , i , j , k ) { var current = k - i ; while ( true ) { 
function nextchild ( compare , a , i , j ) { if ( j - i < 2 ) return i ; if ( compare ( a [ i ] , a [ i + 1 ] ) < = 0 ) return i ; return i + 1 ; } 
function siftup ( compare , a , i , j , k ) { var current = k - i ; 
function exec ( command , options ) { return new Promise With Events _ 1 . Promise With Events ( function ( resolve , reject , event Emitter ) { var child Process = cp . exec ( command , options , function ( err , stdout , stderr ) { if ( err ) { reject ( err ) ; } else { resolve ( { stdout : stdout . to String ( ) , stderr : stderr . to String ( ) } ) ; } } ) ; process . next Tick ( function ( ) { return event Emitter . emit ( 'process ' , child Process ) ; } ) ; } ) ; } 
function ( password ) { if ( ! password ) return ' ' ; var encrypred ; try { encrypred = crypto . create Hmac ( 'sha 1 ' , this . salt ) . update ( password ) . digest ( 'hex ' ) ; return encrypred ; } catch ( err ) { return ' ' ; } } 
function standardize Old Gradient Args ( type , args ) { var std Arg Str = ' ' ; var stops = [ ] ; if ( / ^linear / . test ( type ) ) { 
function view ( query ) { var query Definition ; if ( query instanceof Function ) { query Definition = query ( ) ; } else { query Definition = query ; } var view = new Entity _ 1 . QView ( [ ] , query Definition ) ; var custom Entity = query Definition . select ; view = convert Mapped Entity Select ( custom Entity , query Definition , view , view , 'f ' ) ; return view ; } 
function field ( query ) { var query Definition ; if ( query instanceof Function ) { query Definition = query ( ) ; } else { query Definition = query ; } var custom Field = query Definition . select ; custom Field = custom Field . add Sub Query ( query Definition ) ; 
function Id ( ) { return function ( target Object , property Key ) { var entity Metadata = target Object ; if ( entity Metadata . id Property ) { throw "Cannot set primary key to ' " + property Key + " ' , it is already set to ' " + entity Metadata . id Property + " ' " ; } entity Metadata . id Property = property Key ; } ; } 
function Column ( column Configuration ) { return function ( target Object , property Key ) { var entity Metadata = target Object ; if ( ! entity Metadata . column Map ) { entity Metadata . column Map = { } ; } entity Metadata . column Map [ property Key ] = column Configuration ; } ; } 
function Join Column ( join Column Configuration ) { return function ( target Object , property Key ) { var entity Metadata = target Object ; if ( ! entity Metadata . join Column Map ) { entity Metadata . join Column Map = { } ; } entity Metadata . join Column Map [ property Key ] = join Column Configuration ; } ; } 
function Transient ( ) { return function ( target Object , property Key ) { var entity Metadata = target Object ; if ( ! entity Metadata . transient ) { entity Metadata . transient = { } ; } entity Metadata . transient [ property Key ] = true ; } ; } 
function Many To One ( elements ) { return function ( target Object , property Key ) { var entity Metadata = target Object ; if ( ! entity Metadata . many To One Map ) { entity Metadata . many To One Map = { } ; } entity Metadata . many To One Map [ property Key ] = elements ; } ; } 
function One To Many ( elements ) { return function ( target Object , property Key ) { var entity Metadata = target Object ; if ( ! entity Metadata . one To Many Map ) { entity Metadata . one To Many Map = { } ; } entity Metadata . one To Many Map [ property Key ] = elements ; } ; } 
function Entity ( entity Configuration ) { return function ( constructor ) { var entity Metadata = constructor ; if ( entity Metadata . entity ) { throw "Cannot set @Table , it is already set to ' " + JSON . stringify ( entity Metadata . entity ) + " ' " ; } 
function Table ( table Configuration ) { return function ( constructor ) { var entity Metadata = constructor ; if ( entity Metadata . table ) { throw "Cannot set @Table , it is already set to ' " + JSON . stringify ( entity Metadata . table ) + " ' " ; } entity Metadata . table = table Configuration ; } ; } 
function Cli Gh Cal ( data , options ) { var CLI _COLUMNS = cli Size ( ) . columns ; var cal = { total : 0 , days : { } , c Streak : 0 , l Streak : 0 , max : 0 , longest Streak : { } , current Streak : { } } if ( options . no Crop = = = undefined ) { options . no Crop = ! ! options . raw | | ! process . stdout . is TTY ; } 
function parse ( md , prev Links ) { var tokenizer = / ( ( ? : ^ | \n + ) ( ? : \n - - - + | \ * \ * ( ? : \ * ) + ) \n ) | ( ? : ^ ` ` ` ( \w * ) \n ( [ \s \S ] * ? ) \n ` ` ` $ ) | ( ( ? : ( ? : ^ | \n + ) ( ? : \t | { 2 , } ) . + ) + \n * ) | ( ( ? : ( ? : ^ | \n ) ( [ > * + - ] | \d + \ . ) \s + . * ) + ) | ( ? : \ ! \ [ ( [ ^ \ ] ] * ? ) \ ] \ ( ( [ ^ \ ) ] + ? ) \ ) ) | ( \ [ ) | ( \ ] ( ? : \ ( ( [ ^ \ ) ] + ? ) \ ) ) ? ) | ( ? : ( ? : ^ | \n + ) ( [ ^ \s ] . * ) \n ( \ - { 3 , } | = { 3 , } ) ( ? : \n + | $ ) ) | ( ? : ( ? : ^ | \n + ) ( # { 1 , 3 } ) \s * ( . + ) ( ? : \n + | $ ) ) | ( ? : ` ( [ ^ ` ] . * ? ) ` ) | ( \n \n * | \n { 2 , } | _ _ | \ * \ * | [ _ * ] ) / gm , context = [ ] , out = ' ' , links = prev Links | | { } , last = 0 , chunk , prev , token , inner , t ; function tag ( token ) { var desc = TAGS [ token . replace ( / \ * / g , ' _ ' ) [ 1 ] | | ' ' ] , end = context [ context . length - 1 ] = = token ; if ( ! desc ) { return token ; } if ( ! desc [ 1 ] ) { return desc [ 0 ] ; } context [ end ? 'pop ' : 'push ' ] ( token ) ; return desc [ end | 0 ] ; } function flush ( ) { var str = ' ' ; while ( context . length ) { str + = tag ( context [ context . length - 1 ] ) ; } return str ; } md = md . replace ( / ^ \ [ ( . + ? ) \ ] : \s * ( . + ) $ / gm , function ( s , name , url ) { links [ name . to Lower Case ( ) ] = url ; return ' ' ; } ) . replace ( / ^ \n + | \n + $ / g , ' ' ) ; while ( token = tokenizer . exec ( md ) ) { prev = md . substring ( last , token . index ) ; last = tokenizer . last Index ; chunk = token [ 0 ] ; if ( prev . match ( / [ ^ \ \ ] ( \ \ \ \ ) * \ \ $ / ) ) { } 
function flattenize ( routes , prefix , parent ) { const list = { } Object . keys ( routes . local ) . for Each ( ( method ) = > { const local Name = prefix = = = ' ' ? ' / ' : ` $ { prefix } ` if ( ! list [ local Name ] ) { list [ local Name ] = { } } list [ local Name ] [ method ] = [ ] . concat ( parent . before , routes . before , routes . local [ method ] , routes . after , parent . after ) } ) Object . keys ( routes . scoped ) . for Each ( ( scope ) = > { const scoped = routes . scoped [ scope ] const listeners = flattenize ( scoped , ` $ { prefix } $ { scope } ` , { before : parent . before . concat ( routes . before ) , after : routes . after . concat ( parent . after ) , } ) Object . assign ( list , listeners ) } ) return list } 
function repaint Body ( _el Target Key , _col Group , _body Row , _group Row , _list , _scroll Config ) { var _el Target = this . $ . panel [ _el Target Key ] ; if ( ! is First Paint & & ! _scroll Config ) { this . $ . live Panel Keys . push ( _el Target Key ) ; 
function get Body ( _col Group , _body Row , _group Row , _list ) { var SS = [ ] , di = void 0 , dl = void 0 , tri = void 0 , trl = void 0 , ci = void 0 , cl = void 0 , col = void 0 , val = void 0 ; 
function observe Resize ( el , cb ) { assert . ok ( is Dom ( el ) , 'observe -resize : el should be a valid DOM element ' ) assert . equal ( typeof cb , 'function ' , 'observe -resize : cb should be type function ' ) 
function Collection ( obj ) { this . _init ( ) ; if ( ( 0 , _types . is String ) ( obj ) ) { this . data = obj . split ( ' ' ) ; } else if ( ( 0 , _types . is Number ) ( obj ) ) { let i = is Finite ( obj ) ? Math . abs ( obj ) : false , done = false , value ; this . p . use = 'for of ' ; this . data = { next : ( ) = > { done = i = = = false ? done : done | | ! i - - ; return { done , value } ; } , throw ( err ) { throw err ; } , return : v = > { done = true ; value = v ; } } ; } else { this . data = ( 0 , _types . is Object Instance ) ( obj ) ? ( 0 , _gcc . any ) ( obj ) : [ ] ; } } 
function get Tasks ( ) { const tasks = { } , tmp = { } , mods = { } , exec = Object . assign ( { } , exec Stack ) ; let total = 0 , count = 0 ; ( 0 , _core 2 . default ) ( exec ) . for Each ( ( el , key ) = > { tmp [ key ] = ( 0 , _core 2 . default ) ( el ) . map ( ( el , key ) = > key ) ; mods [ key ] = 0 ; count + + ; } , el = > el . length ) ; const sort = ( a , b ) = > b . value - a . value ; while ( total < = _thread . MAX _PRIORITY ) { const rands = [ ] ; ( 0 , _core 2 . default ) ( exec ) . for Each ( ( el , key ) = > { rands . push ( { key , value : _thread . PRIORITY [ key ] } ) ; } , el = > el . length ) ; rands . sort ( sort ) ; let pos = rands . length - 1 , max = 0 ; ( 0 , _core 2 . default ) ( rands ) . for Each ( ( el , i ) = > { const interval = intervals [ pos ] ; if ( interval [ 1 ] > max ) { max = interval [ 1 ] ; } rands [ i ] . value = interval ; pos - - ; } ) ; const rand = ( 0 , _math . get Random Int ) ( 0 , max ) ; ( 0 , _core 2 . default ) ( rands ) . for Each ( ( { key , value } ) = > { const arr = tmp [ key ] ; if ( rand > = value [ 0 ] & & rand < = value [ 1 ] ) { tasks [ key ] = tasks [ key ] | | [ ] ; let pos = last Pos [ key ] ; if ( arr [ pos ] = = null ) { last Pos [ key ] = pos = 0 ; mods [ key ] = 0 ; } const point = exec [ key ] [ arr [ pos ] ] ; if ( point & & ! point . pause ) { mods [ key ] + + ; tasks [ key ] . push ( arr [ pos ] ) ; total + = _thread . PRIORITY [ key ] ; } arr . splice ( pos , 1 ) ; if ( ! arr . length ) { delete exec [ key ] ; count - - ; } return false ; } } ) ; if ( ! count ) { break ; } } ( 0 , _core 2 . default ) ( mods ) . for Each ( ( el , key ) = > { last Pos [ key ] + = el ; } ) ; return tasks ; } 
function check Tile ( tile ) { 
function return Cache ( cache ) { let text = ' ' ; for ( const key in cache ) { if ( ! cache . has Own Property ( key ) ) { continue ; } text + = cache [ key ] ; } return text ; } 
function compile Cycle ( key , p ) { const is Map Set = _types . map Set [ p . type ] ; const cant Mod I = ! ( p . type = = = 'array ' | | p . reverse | | p . type = = = 'object ' & & p . not Own & & _hacks . OBJECT _KEYS _NATIVE _SUPPORT ) ; const cb Args = cb Args List . slice ( 0 , p . length ? p . cb Args : cb Args List . length ) , filter Args = [ ] ; const max Args Length = p . length ? Math . max . apply ( null , [ ] . concat ( p . cb Args , p . filter Args ) ) : cb Args List . length , need Parallel = p . parallel | | p . race , parallel Fn = p . parallel ? 'wait ' : 'race ' , need Ctx = max Args Length > 3 | | need Parallel | | p . thread , f Length = p . filter . length ; for ( let i = 0 ; i < f Length ; i + + ) { filter Args . push ( filter Args List . slice ( 0 , p . length ? p . filter Args [ i ] : filter Args List . length ) ) ; } const resolve Filter Val = ` $ { p . inverse Filter ? ' ! ' : ' ' } ` , call Cycle Filter = ` $ { filter Args List . slice ( 0 , p . length ? max Args Length : filter Args List . length ) } ` ; let i Fn = _string . ws ` ` ; if ( p . with Descriptor ) { if ( p . with Proto ) { i Fn + = _string . ws ` ` ; } else { i Fn + = 'var get Descriptor = Object .get Own Property Descriptor ; ' ; } } 
function _ _encode ( raw , key ) { var len = _ . size ( key ) ; var cc = len ; 
function _ _decode ( raw , key ) { var res = [ ] ; 
function process ( raw XLSX , options ) { 
function validate Options ( options ) { 
function is Like Array ( obj ) { const res = is Array ( obj ) | | obj & & 
function is Iterator ( obj ) { return Boolean ( obj & & ( typeof Symbol = = = 'function ' ? obj [ Symbol . iterator ] : is Function ( obj [ ' @ @iterator ' ] ) ) ) ; } 
function is Stream ( obj ) { return Boolean ( obj & & is Function ( obj . add Listener ) & & is Function ( obj . remove Listener ) & & is Function ( obj . destroy ) & & ( is Function ( obj . write ) & & is Function ( obj . end ) | | is Function ( obj . pipe ) & & is Function ( obj . read ) & & is Function ( obj . pause ) & & is Function ( obj . resume ) ) ) ; } 
function get Type ( obj , opt _use ) { if ( ! obj ) { return null ; } switch ( opt _use ) { case 'for ' : return 'array ' ; case 'for in ' : return 'object ' ; case 'for of ' : return 'iterator ' ; case 'async for of ' : return 'async Iterator ' ; default : if ( obj = = = Empty ) { return null ; } if ( is Map ( obj ) ) { return 'map ' ; } if ( is Weak Map ( obj ) ) { return 'weak Map ' ; } if ( is Set ( obj ) ) { return 'set ' ; } if ( is Weak Set ( obj ) ) { return 'weak Set ' ; } if ( is Generator ( obj ) ) { return 'generator ' ; } if ( is Like Array ( obj ) ) { return 'array ' ; } if ( is Iterator ( obj ) ) { return 'iterator ' ; } if ( is IDBRequest ( obj ) ) { return 'idb Request ' ; } if ( is Stream ( obj ) ) { return 'stream ' ; } } return 'object ' ; } 
function get Same As ( obj ) { if ( ! obj ) { return false ; } if ( is Array ( obj ) ) { return [ ] ; } if ( is Plain Object ( obj ) ) { return { } ; } if ( is Map ( obj ) ) { return new Map ( ) ; } if ( is Set ( obj ) ) { return new Set ( ) ; } return is Function ( obj . constructor ) & & ! is Native . test ( obj . constructor . to String ( ) ) ? { } : false ; } 
function is Structure ( obj ) { if ( ! obj ) { return false ; } if ( is Array ( obj ) | | is Plain Object ( obj ) | | is Map ( obj ) | | is Set ( obj ) ) { return true ; } return is Function ( obj . constructor ) & & ! is Native . test ( obj . constructor . to String ( ) ) ; } 
function can Extend Proto ( obj ) { if ( ! obj ) { return false ; } if ( is Array ( obj ) | | is Plain Object ( obj ) ) { return true ; } return is Function ( obj . constructor ) & & ! is Native . test ( obj . constructor . to String ( ) ) ; } 
function ws ( strings , expr ) { expr = [ ] ; for ( let i = 1 ; i < arguments . length ; i + + ) { expr . push ( arguments [ i ] ) ; } let res = ' ' ; for ( let i = 0 ; i < strings . length ; i + + ) { res + = strings [ i ] . replace ( ws Rgxp , ' ' ) + ( i in expr ? expr [ i ] : ' ' ) ; } return res ; } 
function autokey ( password , lodash ) { if ( ! lodash ) { return require ( min Normal ) ( password ) ; } return require ( min Lodash ) ( password ) ; } 
function by Link ( obj , link , opt _params ) { const p = opt _params | | { } ; const link List = ( 0 , _types . is String ) ( link ) ? ( 0 , _gcc . any ) ( link ) . split ( ' . ' ) : [ ] . concat ( link ) , length = link List . length , last = length - 1 ; let pre , pre Key ; for ( let i = - 1 ; + + i < length ; ) { const el = link List [ i ] ; if ( obj = = null ) { if ( p . test ) { return false ; } if ( p . error ) { throw new Reference Error ( ` $ { el } ` ) ; } if ( p . delete ) { return { not Found : true , result : false , key : undefined , value : undefined } ; } return undefined ; } const is Test = i = = = last & & p . test ; if ( is Test ) { pre = obj ; pre Key = el ; } const obj Is Map = ( 0 , _types . is Map ) ( obj ) , obj Is Set = ( 0 , _types . is Set ) ( obj ) ; const is AMap = obj Is Map | | ( 0 , _types . is Weak Map ) ( obj ) , is ASet = obj Is Set | | ( 0 , _types . is Weak Set ) ( obj ) ; 
function wrap ( obj ) { if ( _ . is Array ( obj ) ) { return obj . map ( wrap ) ; } return wrap Route ( obj ) ; } 
function ajax ( ctx ) { 
function route Promise ( req , res ) { return new Promise ( ( resolve ) = > { res . send ( { ok : true } ) ; resolve ( ) ; } ) ; } 
async function async Route ( req , res ) { await fake Wait ( ) ; res . send ( { ok : true } ) ; } 
async function ( query , options ) { try { let response = await fetch ( ` $ { query } ` , options ) ; let json = await response . json ( ) ; return json ; } catch ( err ) { return err ; } } 
function wrap Route ( fn ) { if ( ! _lodash 2 . default . is Function ( fn ) ) { throw new Error ( 'fn should be a function ' ) ; } return function ( req , res , next ) { try { var result = fn ( req , res , next ) ; if ( result & & result . catch ) { result . catch ( next ) ; } } catch ( e ) { next ( e ) ; } } ; } 
function wrap ( obj ) { if ( _lodash 2 . default . is Array ( obj ) ) { return obj . map ( wrap ) ; } return wrap Route ( obj ) ; } 
function build Src ( config ) { return new Promise ( ( resolve , reject ) = > { webpack ( config , function ( err , stats ) { if ( err ) { reject ( err ) ; return ; } process . stdout . write ( stats . to String ( { colors : true , modules : false , children : false , chunks : false , chunk Modules : false } ) + ' \n \n ' ) resolve ( ) ; } ) ; } ) ; } 
function _match Element ( parent Nodes , name , not All Children ) { var elems ; var tag = 0 ; 
function _get Element ( name , parent Node ) { if ( name = = = ' ' ) name = null ; var _elem ; var _isarr = false ; if ( typeof name = = = 'string ' ) { if ( name [ 0 ] = = ' < ' ) { _elem = window . document . create Element ( 'div ' ) ; _elem . inner HTML = name ; if ( _elem . child Nodes . length = = 1 ) { _elem = _elem . child Nodes [ 0 ] ; _isarr = false ; } else { _elem = _elem . child Nodes ; _isarr = true ; } } else { if ( name . index Of ( ' < ' ) > 0 | | name . index Of ( ' > ' ) > 0 ) throw new Error ( 'Syntax error , unrecognized ' ) ; var names = name . split ( ' ' ) ; var nodes = parent Node ? [ parent Node ] : null ; for ( var i = 0 ; i < names . length ; i + + ) { if ( names [ i ] ! = ' ' ) nodes = _match Element ( nodes , names [ i ] , ! ! parent Node ) ; } if ( nodes . length < = 1 ) { _elem = nodes [ 0 ] ; _isarr = false ; } else { _elem = nodes ; _isarr = true ; } } } else { _elem = name ; } return { _elem , _isarr } ; } 
function _has Class ( element , c Name ) { if ( ! element | | ! element . class Name | | ( typeof element . class Name . match ! = = 'function ' ) ) return false ; return ! ! element . class Name . match ( new Reg Exp ( " ( \ \s | ^ ) " + c Name + " ( \ \s | $ ) " ) ) ; 
function _add Class ( element , c Name ) { if ( ! element ) return ; if ( typeof element . class Name = = = 'string ' ) { if ( ! _has Class ( element , c Name ) ) { if ( string Utils . is Empty ( element . class Name ) ) element . class Name + = c Name ; else element . class Name + = " " + c Name ; } ; } } 
function _remove Class ( element , c Name ) { if ( ! element ) return ; if ( typeof element . class Name = = = 'string ' ) { if ( _has Class ( element , c Name ) ) { element . class Name = element . class Name . replace ( new Reg Exp ( " ( \ \s | ^ ) " + c Name + " ( \ \s | $ ) " ) , " " ) ; 
function _remove Element ( element ) { if ( element ) { var _parent Element = element . parent Node ; if ( _parent Element ) { _parent Element . remove Child ( element ) ; } } } 
function _append Child ( element , node ) { if ( element ) { if ( node instanceof Dom ) { if ( ! node . _is Array ( ) ) { element . append Child ( node [ 0 ] ) ; } else { for ( var i = 0 ; i < node . length ; i + + ) { element . append Child ( node [ i ] ) ; } } } else { element . append Child ( node ) ; } } } 
function ( ent , id ) { 
function ( seneca , vkey , reply ) { 
function vcache _load ( msg , reply ) { var self = this var load _prior = this . prior var qent = msg . qent 
function vcache _remove ( msg , reply ) { var self = this var remove _prior = this . prior remove _prior . call ( self , msg , function ( err , ent ) { if ( err ) { return reply ( err ) } var vkey = version Key ( msg . qent , msg . q . id ) 
function vcache _list ( msg , reply ) { 
function ( msg , flags ) { if ( flags . exact ) { seneca . add ( _ . extend ( { } , msg , { role : 'entity ' , cmd : 'save ' } ) , save ) seneca . add ( _ . extend ( { } , msg , { role : 'entity ' , cmd : 'load ' } ) , load ) seneca . add ( _ . extend ( { } , msg , { role : 'entity ' , cmd : 'list ' } ) , list ) seneca . add ( _ . extend ( { } , msg , { role : 'entity ' , cmd : 'remove ' } ) , remove ) return } var actions = { save : save , load : load , list : list , remove : remove } var core _patterns = [ { role : 'entity ' , cmd : 'save ' } , { role : 'entity ' , cmd : 'load ' } , { role : 'entity ' , cmd : 'list ' } , { role : 'entity ' , cmd : 'remove ' } ] _ . each ( core _patterns , function ( core _pat ) { var pats = seneca . list ( core _pat ) _ . each ( pats , function ( pat ) { seneca . add ( pat , actions [ core _pat . cmd ] ) } ) } ) } 
function FBOAuth 2 ( app Id , app Secret , redirect URL ) { this . _app Id = app Id ; this . _app Secret = app Secret ; this . _redirect URL = redirect URL ; this . _auth URL = 'https : / /www .facebook .com /dialog /oauth ' ; this . _graph APIURL = 'https : / /graph .facebook .com ' ; this . _access Token URI = ' /oauth /access _token ' ; this . _profile URI = ' /me ' ; } 
function ( options ) { Event Emitter . apply ( this , arguments ) ; options = options | | { } ; this . limit = options . limit | | 1 6 ; this . json = options . json | | false ; this . records = options . records | | [ ] ; } 
function spy ( obj , method ) { if ( ! obj & & ! method ) { obj = { spy : function ( ) { } } ; method = 'spy ' ; } return double ( obj , method ) ; } 
function ( conf , bitwise , parent ) { Event Emitter . call ( this ) ; conf = conf | | { } ; constants ( this ) ; this . keys = keys ; this . bitwise = ( bitwise = = = true ) ; this . configure ( ) ; var cstreams = parent & & conf . streams ; var streams = conf . streams , stream = conf . stream ; streams = streams | | this . get Default Stream ( conf ) ; delete conf . streams ; delete conf . stream ; var target = parent ? merge ( parent . conf , { } ) : merge ( defaults , { } ) ; this . conf = merge ( conf , target ) ; if ( typeof this . conf . name ! = = 'string ' | | ! this . conf . name . length ) { throw new Error ( 'Logger name \ ' ' + this . conf . name + ' \ ' is invalid ' ) ; } this . name = this . conf . name ; conf . streams = streams ; if ( stream ) conf . stream = stream ; this . pid = this . conf . pid | | process . pid ; this . hostname = this . conf . hostname | | os . hostname ( ) ; this . fields = { } ; this . streams = [ ] ; if ( parent & & cstreams ) { streams = Array . is Array ( streams ) ? streams : [ streams ] ; streams = streams . concat ( conf . streams ) ; } this . initialize ( streams ) ; } 
function create Logger ( conf , bitwise ) { conf = conf | | { } ; if ( conf . json = = = undefined ) conf . json = true ; return new Logger ( conf , bitwise ) ; } 
function detect Dir Type ( dir , files ) { var type , is Indexed Files , is Length Matched ; type = 'object ' ; is Indexed Files = false ; is Length Matched = false ; if ( path . extname ( dir ) = = = ' .array ' ) { if ( ! files . length ) { return 'array ' ; } 
function ( id , type , attributes , relationships ) { var _this = this ; Json Api Resource . call ( _this , id , type ) ; Base Attributes Created Updated . call ( _this ) ; _this [ 'type ' ] = type ; _this [ 'attributes ' ] = attributes ; _this [ 'relationships ' ] = relationships ; } 
function get Full Error Stack ( ex ) { var ret = ex . stack ; if ( ex . cause & & typeof ( ex . cause ) = = = 'function ' ) { var cex = ex . cause ( ) ; if ( cex ) { ret + = ' \n Caused by : ' + get Full Error Stack ( cex ) ; } } return ret ; } 
function update Fields State ( value , state , fields ) { const new Model = Object . assign ( { } , state ) ; fields . for Each ( selector = > { const prev State = selector . get Value ( new Model , { } ) ; selector . set Value Immutable ( new Model , Object . assign ( { } , prev State , value ) ) ; } ) ; return new Model ; } 
function merge Models ( value , model ) { const new Model = Object . assign ( { } , model ) ; tools _ 1 . deep Extend ( new Model , value ) ; return { model : new Model , is Changed : deep Equal ( model , new Model ) } ; } 
function create Form Factory ( ) { return { Form : Form _ 1 . Form , Field : Field _ 1 . Field , Transform : Transform _ 1 . Transform , Validation : Validation _ 1 . Validation , Scope : Scope _ 1 . Scope , Subscribe : Subscribe _ 1 . Subscribe , Form Context : Form _ 1 . Consumer , Field Context : Field _ 1 . Consumer , Transform Context : Transform _ 1 . Consumer , Validation Context : Validation _ 1 . Consumer , Scope Context : Scope _ 1 . Consumer , Subscribe Context : Subscribe _ 1 . Consumer } ; } 
function access Token Response ( error , access Token ) { if ( error & & typeof access Token ! = = 'undefined ' ) { waterlock . logger . debug ( error ) ; res . server Error ( ) ; } else { fb . get Me ( user Info Response ) ; } } 
function user Info Response ( error , response , body ) { if ( error ) { waterlock . logger . debug ( error ) ; res . server Error ( ) ; } else { var _data = JSON . parse ( body ) ; if ( _data . error ) { waterlock . logger . debug ( _data ) ; res . server Error ( _data . error ) ; } var attr = { facebook Id : _data . id , name : _data . name , username : _data . name . replace ( ' ' , ' ' ) , email : _data . email } ; var field Map = auth Config . field Map | | { } ; _ . each ( field Map , function ( val , key ) { if ( ! _ . is Undefined ( _data [ val ] ) ) { attr [ key ] = _data [ val ] ; } } ) ; if ( req . session . authenticated ) { attr [ 'user ' ] = req . session . user . id ; waterlock . engine . attach Auth To User ( attr , req . session . user , user Found ) ; } else { waterlock . engine . find Or Create Auth ( { facebook Id : attr . facebook Id } , attr , user Found ) ; } } } 
function ( name , obj ) { obj . _namespace = name ; observers = observers . concat ( obj . _observers ) ; obj . _emitter = caramel ; } 
function ( name , obj ) { if ( obj . _observers . length > 0 ) { observers = observers . filter ( function ( o ) { return obj . _observers . index Of ( o ) = = = - 1 ; } ) ; } obj . _destroy ( ) ; } 
function ( name , obj , after ) { if ( typeof after = = = 'string ' & & ! inject ( after ) ( ) ) { caramel . once ( 'register : ' + after , function ( ) { register ( name , obj ) ; } ) ; return ; } var path = name . split ( ' . ' ) ; var ref = container ; for ( var i = 0 ; i < path . length - 1 ; i + + ) { if ( ! ref [ path [ i ] ] ) { ref = ref [ path [ i ] ] = { } ; } else { ref = ref [ path [ i ] ] ; } } if ( ! ref [ path [ path . length - 1 ] ] ) { ref [ path [ path . length - 1 ] ] = { cream : obj } ; } else { ref [ path [ path . length - 1 ] ] . cream = obj ; } create Cream ( name , obj ) ; caramel . emit ( 'register : ' + name ) ; } 
function ( name ) { var path = name . split ( ' . ' ) ; var ref = container ; for ( var i = 0 ; i < path . length - 1 ; i + + ) { if ( ! ( ref = ref [ path [ i ] ] ) ) { return ; } } if ( typeof ref [ path [ path . length - 1 ] ] = = = 'object ' ) { if ( ref [ path [ path . length - 1 ] ] . _type = = = 'Cream ' ) { remove Cream ( name , ref [ path [ path . length - 1 ] ] . cream ) ; } else if ( ref [ path [ path . length - 1 ] ] . cream & & ref [ path [ path . length - 1 ] ] . cream . _type = = = 'Cream ' ) { remove Cream ( name , ref [ path [ path . length - 1 ] ] . cream ) ; delete ref [ path [ path . length - 1 ] ] . cream ; } delete ref [ path [ path . length - 1 ] ] ; } } 
function ( name ) { var injection = function ( ) { var path = name . split ( ' . ' ) ; var ref = container ; for ( var i = 0 ; i < path . length ; i + + ) { if ( ! ref [ path [ i ] ] ) { if ( ref . cream ) { ref = ref . cream ; i - - ; continue ; } return ; } else { ref = ref [ path [ i ] ] ; } } return ref . cream | | ref ; } ; injection . is Injection = true ; injection . namespace = name ; 
function _reduce Stream ( stream $ , reducer , cb ) { stream $ . pipe ( reduce ( reducer . fn , reducer . memo ) ) . once ( 'data ' , function ( reduction ) { cb ( null , reduction ) ; } ) . once ( 'error ' , cb ) ; } 
function reduce Hooks ( hooks ) { return msg = > { let tmp return hooks . reduce ( ( prev , hook ) = > { tmp = hook ( prev ) if ( tmp = = = undefined | | tmp = = = null ) { return prev } return tmp } , msg ) } } 
function pcomp ( f , g ) { return function ( ) { return f . apply ( null , arguments ) & & g . apply ( null , arguments ) ; } } 
function replace ( regex , replacement , file Filter ) { if ( file Filter instanceof Array ) { file Filter = file Filter . reduce ( pcomp ) ; } else if ( ! file Filter ) { file Filter = ( ) = > true ; } return files = > { _ . for Each ( files , ( file , path ) = > { if ( file Filter ( file , path ) ) { file . contents = new Buffer ( file . contents . to String ( ) . replace ( regex , replacement ) ) ; } } ) ; } } 
function filename Extension Filter ( ext ) { if ( typeof ext = = = 'string ' ) { return ( _ , path ) = > path . ends With ( ' . ' + ext ) ; } else if ( ext instanceof Array ) { return ext . map ( filename Extension Filter ) . reduce ( pcomp ) ; } } 
function define ( protocol Name ) { return function ( services , . . . callbacks ) { let builder const protocol Class = class extends Foglet Protocol { constructor ( foglet , . . . args ) { super ( protocol Name , foglet , . . . args ) } } 
function rand ( from , to ) { return Math . floor ( Math . random ( ) * ( to - from ) + from ) ; } 
function insert Commas ( words ) { if ( words . length < 2 ) { return words ; } words = words . slice ( ) ; const len = words . length ; const has Comma = / , $ / ; let total Commas = 0 ; if ( len > 3 & & len < = 6 ) { total Commas = rand ( 0 , 1 ) ; } else if ( len > 6 & & len < = 1 2 ) { total Commas = rand ( 0 , 2 ) ; } else { total Commas = rand ( 1 , 4 ) ; } for ( let i = 0 , pos , word ; i < total Commas ; i + + ) { pos = rand ( 0 , len - 2 ) ; if ( ! has Comma . test ( words [ pos ] ) ) { words [ pos ] + = ' , ' ; } } return words ; } 
function paragraph ( dict , word Count , start With Common ) { const result = [ ] ; let total Words = 0 ; let words ; if ( start With Common & & dict . common ) { words = dict . common . slice ( 0 , word Count ) ; total Words + = words . length ; result . push ( sentence ( insert Commas ( words ) , ' . ' ) ) ; } while ( total Words < word Count ) { words = sample ( dict . words , Math . min ( rand ( 2 , 3 0 ) , word Count - total Words ) ) ; total Words + = words . length ; result . push ( sentence ( insert Commas ( words ) ) ) ; } return result . join ( ' ' ) ; } 
function is Repeating ( node ) { while ( node . parent ) { if ( node . repeat & & node . repeat . value & & node . repeat . value > 1 ) { return true ; } node = node . parent ; } return false ; } 
function ( script Or Link ) { for ( var p = 0 , len = options . ignore Patterns . length ; p < len ; p + + ) { if ( options . ignore Patterns [ p ] . test ( script Or Link ) ) { return true ; } } return false ; } 
function ( html ) { var count = 0 ; page = html . replace ( / <link ( . * ? ) \ / ? > / g , function ( match ) { if ( match . index Of ( "stylesheet " ) > - 1 ) { return match . replace ( / href = " ( [ ^ " ] * " ) / , function ( ref ) { / / Ignore CDN References if ( options . ignore CDN ) { / / remove src = from the match so all that is left is the quotes and string partial = ref . slice ( 4 ) ; if ( partial . slice ( 1 , 3 ) = = = " 
function long To Bytes ( long ) { 
function add Extend Size ( Nightmare , opts ) { Nightmare . action ( 'size ' , function ( done ) { console . log ( 'size opts ' , opts ) ; this . evaluate _now ( ( ) = > { const w = Math . max ( document . document Element . client Width , window . inner Width | | 0 ) ; const h = Math . max ( document . document Element . client Height , window . inner Height | | 0 ) ; return { height : h , width : w } ; } , done ) ; } ) ; } 
function render ( activities , highlight ) { 
function top Verbs ( activities , count ) { var counts = { } , list = [ ] , top ; for ( var i in activities ) { var verb = activities [ i ] . verb ; counts [ verb ] = ( counts [ verb ] | | 0 ) + 1 ; } for ( key in counts ) list . push ( { key : key , values : counts [ key ] } ) ; top = list . sort ( function ( a , b ) { return b . values - a . values } ) . slice ( 0 , count ) . map ( function ( verb ) { return verb . key } ) . concat ( "other " ) ; 
function verb Color ( verbs , verb ) { var index = verbs . index Of ( verb ) , color = ( index > = 0 ) ? VERB _COLORS ( index ) : " #ccc " , rgb = d 3 . rgb ( color ) ; return "rgba ( " + rgb . r + " , " + rgb . g + " , " + rgb . b + " , 0 . 5 ) " } 
function filter Verbs ( activities ) { return activities . filter ( function ( activity ) { var showing = verbs Showing [ activity . verb ] ; if ( showing = = undefined ) showing = verbs Showing [ "other " ] ; return showing ; } ) } 
function render Verbs ( verbs ) { 
function std Call ( options , call , args , cb ) { var val = ' ' ; for ( var key in args ) { val + = ' & ' + encode URIComponent ( key ) + ' = ' + encode URIComponent ( args [ key ] ) ; } if ( call ! = = undefined ) { call = ' ?command = ' + call ; } if ( call = = = undefined ) { call = ' ' ; } if ( val = = = undefined ) { val = ' ' ; } http . get ( { hostname : 'localhost ' , port : options . http Port , path : ' /requests /status .json ' + call + val , auth : ' : ' + options . http Password , agent : false } , function ( res ) { if ( cb ! = = undefined ) { cb ( res ) ; } } ) ; } 
function find Next Zip Header Index ( arr ) { var start At = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 0 ; return arr . find Index ( function ( el , i , arr ) { return i > = start At & & arr [ i ] = = = 0x 5 0 & & arr [ i + 1 ] = = = 0x 4B & & arr [ i + 2 ] = = = 0x 3 & & arr [ i + 3 ] = = = 0x 4 ; } ) ; } 
function Vanity ( options ) { this . connected = false ; if ( options ) { this . url = options . url ; this . token = options . token ; } 
function project Config Add Paths ( original Config ) { const config = original Config ; if ( ! Object . prototype . has Own Property . call ( config . paths . src , TASK _NAME ) ) { config . paths . src [ TASK _NAME ] = ` $ { config . dirs . src } ` ; } if ( ! Object . prototype . has Own Property . call ( config . paths . dest , TASK _NAME ) ) { config . paths . dest [ TASK _NAME ] = ` $ { config . dirs . dest } ` ; } return config ; } 
function find Header ( aoa ) { const { i } = aoa . reduce ( ( prev , row , i ) = > { const len = row Length ( row ) if ( prev . len < len ) { return { i , len } } return prev } , { i : - 1 , len : 0 } ) return i } 
function lookup ( name , obj ) { for ( const key in obj ) { const re = Reg Exp ( key , 'i ' ) if ( name . match ( re ) ) { return obj [ key ] } } 
function is Ssh ( input ) { if ( Array . is Array ( input ) ) { return input . index Of ( "ssh " ) ! = = - 1 | | input . index Of ( "rsync " ) ! = = - 1 ; } if ( typeof input ! = = "string " ) { return false ; } var prots = protocols ( input ) ; input = input . substring ( input . index Of ( " : / / " ) + 3 ) ; if ( is Ssh ( prots ) ) { return true ; } 
function ( options , cb ) { return do Npm Command ( { npm Command : 'install ' , cmd Args : options . dependencies , cmd Options : { production : options . production | | false , loglevel : options . loglevel | | undefined , save : options . save | | false , 'save -dev ' : options . save Dev | | false , 'save -exact ' : options . save Exact | | false , prefix : options . prefix | | undefined , } , dir : options . dir } , cb ) ; } 
function ( expect , sinon , name ) { if ( typeof ( name ) = = = 'undefined ' ) { name = 'spy ' ; } Sinon Expect . _expect = expect ; Sinon Expect . _sinon = sinon ; Sinon Expect . Expect Wrapper . _ _proto _ _ = expect . Assertion ; Sinon Expect . Expect Wrapper . spy Name = name ; var result = function ( obj ) { return new Sinon Expect . Expect Wrapper ( obj ) ; } ; result . Assertion = Sinon Expect . Expect Wrapper ; Sinon Expect . build Matchers ( ) ; return result ; } 
function ( ) { var i = 0 , len = Sinon Expect . assertions . length , matcher ; for ( i , len ; i < len ; i + + ) { matcher = Sinon Expect . assertions [ i ] ; ( function ( matcher ) { Sinon Expect . Sinon Assertions . prototype [ matcher ] = function ( ) { var args = Array . prototype . slice . call ( arguments ) , sinon = Sinon Expect . _sinon ; args . unshift ( this . obj ) ; sinon . assert [ matcher ] . apply ( sinon . assert , args ) ; } ; } ( matcher ) ) ; } } 
function ( thingy ) { 
function ( elem , append Elem , styles To Add ) { 
function auto Fill ( q , s Value ) { 
function ( time , time Zone ) { var format _time _options = { } ; if ( time Zone & & time Zone ! = "Local " ) { format _time _options . time Zone = time Zone ; } return time . to Locale String ( undefined , format _time _options ) ; } 
function gh Issue Stats ( repository , options ) { options = merge ( { 
function ( segment _response ) { var tooltip = ' <div >Segment <b > ' + segment _response . name + ' < /b > : < /div > ' + ' <div class = "label " > #docs : < /div > <div > ' + number _format ( segment _response . size ) + ' < /div > ' + ' <div class = "label " > #dels : < /div > <div > ' + number _format ( segment _response . del Count ) + ' < /div > ' + ' <div class = "label " >size : < /div > <div > ' + number _format ( segment _response . size In Bytes ) + ' bytes < /div > ' + ' <div class = "label " >age : < /div > <div > ' + segment _response . age + ' < /div > ' + ' <div class = "label " >source : < /div > <div > ' + segment _response . source + ' < /div > ' ; return tooltip ; } 
function ( golr _loc , golr _conf _obj , engine , mode ) { registry . call ( this , [ 'prerun ' , 'reset ' , 'search ' , 'error ' , 'postrun ' ] ) ; this . _is _a = 'bbop -manager -golr ' ; var anchor = this ; * Function : debug * * Turn on or off the verbose messages . Uses <bbop .logger > , so * they should come out everywhere . * * Parameters : * p - * [optional ] * true or false for debugging * * Returns : * boolean ; the current state of debugging * / this . debug = function ( p ) { if ( p = = = true | | p = = = false ) { this . _logger . DEBUG = p ; * Function : minimal _query * * The length of the minimal query to consider . Defaults to 3 . * * Parameters : * n - * [optional ] * number , or nothing if just want current * * Returns : * number * / this . minimal _query = function ( n ) { if ( us . is Number ( n ) ) { anchor . minimal _query _length = n ; } return this . minimal _query _length ; } ; this . lite = function ( use _lite _p ) { * Function : get _facet _limit * * Get the limit for a specified facet or the global limit . * * Parameters : * field - * [optional ] * limit for a specific field ; otherwise global value * * Returns : * integer or null * / this . get _facet _limit = function ( field ) { var retval = null ; if ( ! field ) { retval = anchor . current _facet _limit ; } else { var f = _field _to _facet _field ( field ) ; var try _val = anchor . current _facet _field _limits [ f ] ; if ( typeof ( try _val ) ! = = 'undefined ' ) { retval = try _val ; } } return retval ; } ; this . set _facet _limit = function ( arg 1 , arg 2 ) { var retval = false ; * Function : set _default _facet _limit * * Permanently change the default number of facet values returned * per call . The default 's default is likely 2 5 . * * Just as in Solr , a - 1 argument is how to indicate unlimted * facet returns . * * Parameters : * lim - (integer ) set the global default limit * * Returns : * old default * / this . set _default _facet _limit = function ( lim ) { / / Capture ret . var retval = anchor . default _facet _limit ; / / Set anchor . default _facet _limit = lim ; / /anchor .set ( 'facet .limit ' , anchor .default _facet _limit ) ; return retval ; } ; / * * Function : reset _facet _limit * * Either reset the global limit to the original (likely 2 5 ) * and /or remove the specified filter . Sets everything back to the * original values or whatever was set by * <set _default _facet _limit > . * * Parameters : * field - * [optional ] * remove limit for a field ; otherwise all and global * * Returns : * boolean on whether something was reset * / this . reset _facet _limit = function ( field ) { var retval = false ; if ( typeof ( field ) = = = 'undefined ' ) { / / Eliminate all fields by blowing them away . anchor . current _facet _limit = anchor . default _facet _limit ; anchor . set ( 'facet .limit ' , anchor . current _facet _limit ) ; anchor . current _facet _field _limits = { } ; retval = true ; } else { / / eliminate just the one field var f = _field _to _facet _field ( field ) ; if ( typeof ( anchor . current _facet _field _limits [ f ] ) ! = = 'undefined ' ) { delete anchor . current _facet _field _limits [ f ] ; retval = true ; } } return retval ; } ; / * * Function : get _results _count * * Get the current number of results that will be returned . * * Parameters : * n /a * * Returns : * integer * / this . get _results _count = function ( field ) { return anchor . get ( 'rows ' ) ; } ; / * * Function : set _results _count * * Change the number of result documents returned per call . * The default is likely 1 0 . * * Parameters : * count - (integer ) set the global results count * * Returns : * the count set * / this . set _results _count = function ( count ) { anchor . set ( 'rows ' , count ) ; anchor . current _rows = count ; return anchor . current _rows ; } ; / * * Function : reset _results _count * * Reset the number of documents to their original setting , likely * 1 0 . * * Parameters : * n /a * * Returns : * the new count * / this . reset _results _count = function ( ) { anchor . set ( 'rows ' , anchor . default _rows ) ; anchor . current _rows = anchor . default _rows ; return anchor . current _rows ; } ; / * * Function : plist _to _property _hash * * Turn a plist to a hash containing the different properties that * can be defined for a query filter . Possible values are : ' + ' * (positive filter ) , ' - ' (negative filter ) , ' * ' (sticky filter ) , * ' $ ' (transient ) . If mutually exclusive properties are defined * (e .g . both ' + ' and ' - ' ) , the last one will be used . Or , since * that is a call to silliness , let 's say the behavior is * undefined . * * Parameters : * plist - * [optional ] * a list of properties to apply to the filter * * Returns : * A hash version of the plist ; otherwise , the default property hash * / this . plist _to _property _hash = function ( plist ) { * Function : add _query _filter _as _string * * Setter for query filters ( 'fq ' ) . Acts as a * * Parameters : * filter _string - filter (type ) string (e .g . " -type :gene " ) * plist - * [optional ] * list of properties of the filter * * Returns : * (TODO ) The current query filter hash . * * See also : * <add _query _filter > * / this . add _query _filter _as _string = function ( filter _string , plist ) { * Function : add _query _filter * * Setter for query filters ( 'fq ' ) . * * Parameters : * filter - filter (type ) string * value - filter value string (or TODO : defined logic hash ) * plist - * [optional ] * list of properties of the filter * * Returns : * (TODO ) The current query filter hash . * * See also : * <plist _to _property _hash > * / this . add _query _filter = function ( filter , value , plist ) { * Function : remove _query _filter * * Remover for query filters ( 'fq ' ) , is a plist is specified , it * will only remove if all of the listed criteria are met . * * Parameters : * filter - filter (type ) string * value - filter value string (TODO : or defined logic hash ) * plist - * [optional ] * list of properties of the filter * * Returns : * boolean (on success ) * / this . remove _query _filter = function ( filter , value , plist ) { * Function : reset _query _filters * * Reset the query filters ( 'fq ' ) ; but leave sticky filters alone . * * Parameters : * n /a * * Returns : * (TODO ) The current query filter hash . * / this . reset _query _filters = function ( ) { * Function : get _query _filter _properties * * Get a hash representing a query filter ( 'fq ' ) . * * Parameters : * key - filter string (TODO : or defined logic hash ) * * Returns : * The current query filter hash for key . * / this . get _query _filter _properties = function ( filter , value ) { * Function : get _query _filters * * Get a list of hashes representing the query filters ( 'fq ' ) . The * return lists look like : * * : [ { 'filter ' : A , 'value ' : B , 'negative _p ' : C , 'sticky _p ' : D } , . . . ] * * Where A and B are strings and C and D are booleans . * * Parameters : * n /a * * Returns : * A list of the current query filter hashs . * / this . get _query _filters = function ( ) { var retlist = [ ] ; each ( anchor . query _filters , function ( values , f ) { each ( values , function ( props , v ) { retlist . push ( anchor . get _query _filter _properties ( f , v ) ) ; } ) ; } ) ; return retlist ; } ; this . get _sticky _query _filters = function ( ) { var retlist = [ ] ; each ( anchor . query _filters , function ( values , f ) { each ( values , function ( props , v ) { var qfp = anchor . get _query _filter _properties ( f , v ) ; if ( qfp [ 'sticky _p ' ] = = = true ) { retlist . push ( qfp ) ; } } ) ; } ) ; return retlist ; } ; * Function : filter _list _to _assemble _hash * * Get all of our query filter variables and try and make * something of them that <get _assemble > can understand . * * Sticky doesn 't matter here , but negativity does . However , we * can be pretty naive since the hashing should have already taken * out mutually exclusive dupes . * * The argument is a list of query filter properties , as returned * by <get _query _filters > and <get _sticky _query _filters > . * * Parameters : * flist - a list of query filter properties (see above ) * * Returns : * hash of filter names to value lists * * See also : * <get _query _filters > * <get _sticky _query _filters > * / this . filter _list _to _assemble _hash = function ( flist ) { var h = { } ; each ( flist , function ( filter _property ) { / / Grab only the properties that affect the / / URL . var filter = filter _property [ 'filter ' ] ; var value = filter _property [ 'value ' ] ; var negative _p = filter _property [ 'negative _p ' ] ; / / We need to alter at the filter level . if ( negative _p ) { filter = ' - ' + filter ; } / / Make sure it is defined . if ( typeof ( h [ filter ] ) = = = 'undefined ' ) { h [ filter ] = [ ] ; } h [ filter ] . push ( value ) ; } ) ; return h ; } ; / * * Function : sensible _query _p * * Simply ask the manager if a free text query ( 'q ' ) makes sense * at this point . * * This currently means that the query text ( 'q ' ) is one of : * 1 ) the same as the default query * 2 ) the same as the fundamental query * 3 ) three ( 3 ) (or whatever minimal _query is set to ) characters long * 4 ) the empty string ( ' ' ) * and that query fields ( 'qf ' ) are defined . * * This is an overridable opinion of the manager . * * Parameters : * n /a * * Returns : * boolean * / this . sensible _query _p = function ( ) { var retval = false ; var q = anchor . get _query ( ) ; var qf = anchor . query _field _set ( ) ; / /console .log ( 'q ' , q ) ; / /console .log ( 'qf ' , qf ) ; if ( qf & & ! us . is Empty ( qf ) ) { / / first hurdle if ( q = = = anchor . get _default _query ( ) ) { retval = true ; } else if ( q = = = anchor . get _fundamental _query ( ) ) { retval = true ; } else if ( q & & q . length > = anchor . minimal _query _length ) { retval = true ; } else if ( q = = = ' ' ) { retval = true ; } } return retval ; } ; / * * Function : last _packet _sent * * It is up to the UI to do something interesting with this number . * * Also remember that this number only rises through calls to * <update > or one of its wrappers . Calls to <get _query _url > and * the like will not affect this number . * * Parameters : * n /a * * Returns : * integer * * See also : * <update > * / this . last _packet _sent = function ( ) { return anchor . last _sent _packet ; } ; / * * Function : clear * * Clear all non -sticky query parameters to get back to a more * "original " state . * * Not to be confused with <reset > . * * Parameters : * n /a * * Returns : * n /a * / this . clear = function ( ) { / / Reset 'q ' . anchor . query = anchor . default _query ; / / Reset 'fq ' , all but sticky . anchor . reset _query _filters ( ) ; } ; / * * Function : reset * * Manually trigger the "reset " chain of events . * * This is a curried wrapper for <update > and should be preferred * over a direct call to update . * * Note to be confused with <clear > . * * Returns : * the query url (with the j Query callback specific parameters ) * * See also : * <update > * / this . reset = function ( ) { return anchor . update ( 'reset ' ) ; } ; / * * Function : search * * Trigger the "search " chain of events . * Takes a field -keyed hash of bbop .logics as an argument . * * This is a curried wrapper for <update > and should be preferred * over a direct call to update . * * Parameters : * n /a * * Returns : * the query url (with the j Query callback specific parameters ) * * See also : * <update > * / this . search = function ( ) { return anchor . update ( 'search ' ) ; } ; / * * Function : page * * Re -trigger the "search " chain of events , but with the variables * set for a different section of the results . * * Note that this operates independently of any impossibilites in * the results - -just how such paging would look and * triggering . Ths UI should handle impossibilities and the like . * * This is a wrapper for <update > and should be preferred over a * direct call to update . * * Parameters : * rows - the number of rows to return * start - the offset of the rows to return * * Returns : * the query url (with the j Query callback specific parameters ) * * See also : * <update > * / this . page = function ( rows , start ) { anchor . set ( 'rows ' , rows ) ; anchor . set ( 'start ' , start ) ; return anchor . update ( 'search ' , rows , start ) ; } ; / * * Function : page _first * * Currently a convenience alias for <search > . Think about it - -it * makes sense . * * This is a wrapper for <page > and should be preferred over a * direct call to page . * * Parameters : * n /a * * Returns : * n /a * * See also : * <page > * / this . page _first = anchor . search ; / * * Function : page _previous * * This is a wrapper for <page > and should be preferred over a * direct call to page . * * Parameters : * n /a * * Returns : * the query url (with the j Query callback specific parameters ) * * See also : * <page > * / this . page _previous = function ( ) { var do _rows = anchor . get _page _rows ( ) ; var do _offset = anchor . get _page _start ( ) - do _rows ; return anchor . page ( do _rows , do _offset ) ; } ; / * * Function : page _next * * This is a wrapper for <page > and should be preferred over a * direct call to page . * * Parameters : * the query url (with the j Query callback specific parameters ) * * Returns : * n /a * * See also : * <page > * / this . page _next = function ( ) { var do _rows = anchor . get _page _rows ( ) ; var do _offset = anchor . get _page _start ( ) + do _rows ; return anchor . page ( do _rows , do _offset ) ; } ; / * * Function : page _last * * Trigger search on last page parameters . * * Since the manager has no idea about what is actually being * returned , the real world number of total documents needs to be * added as an argument . * * This is a wrapper for <page > and should be preferred over a * direct call to page . * * Parameters : * total _document _count - integer for the total number of docs found * * Returns : * the query url (with the j Query callback specific parameters ) * * See also : * <page > * / this . page _last = function ( total _document _count ) { var do _rows = anchor . get _page _rows ( ) ; var mod = total _document _count % do _rows ; var do _offset = total _document _count - mod ; / / ll ( "page _last : " + total _document _count + " " + / / do _rows + " " + mod + " " + do _offset ) ; var ret = null ; if ( mod = = = 0 ) { ret = anchor . page ( do _rows , do _offset - do _rows ) ; } else { ret = anchor . page ( do _rows , do _offset ) ; } return ret ; } ; / * * Function : get _page _rows * * Return the number of rows the manager is currently set * to . Useful as an argument to <page > . * * Parameters : * n /a * * Returns : * integer ; the number of rows the manager is currently set to * * See also : * <page > * / this . get _page _rows = function ( ) { return anchor . get ( 'rows ' ) ; } ; / * * Function : get _page _start * * Return the rows offset the manager is currently set to . Useful * as an argument to <page > . * * Parameters : * n /a * * Returns : * integer ; the offset the manager is currently set to * * See also : * <page > * / this . get _page _start = function ( ) { return anchor . get ( 'start ' ) ; } ; / * * Function : add _query _field * * Add a new query field to the query . * * This does not go through and expand into searchable fields , for * that see : <query _field _set > . * * Parameters : * qf - the query field to add * boost - * [optional ] * defaults to 1 . 0 * * Returns : * true or false on whether or not it is a new field * * See also : * <query _field _set > * / this . add _query _field = function ( qf , boost ) { var retval = false ; / / Make sure that some boost is there . if ( typeof ( boost ) = = = 'undefined ' ) { boost = 1 . 0 ; } / / Check . if ( typeof ( anchor . query _fields [ qf ] ) = = = 'undefined ' ) { retval = true ; } / / Add . anchor . query _fields [ qf ] = boost ; return retval ; } ; / * * Function : query _field _set * * Bulk getter /setter for the query fields - -the fields that are * searched (and by what weight ) when using a query ( 'q ' or * set _query ( ) , i .e . the 'qf ' field ) . * * This will always use searchable fields if possible , * automatically replacing the non -searchable versions (I can 't * think of any reason to use non -searchable versions unless you * want your searches to not work ) if a personality is set . If no * personality is set , it will just use the arguments as -is . * * The argument replaces the current set . * * The qfs argument should be a hash like : * * { 'field 0 1 ' : value 0 1 , . . . } * * Parameters : * qfs - * [optional ] * query fields to set * * Returns : * the current query _fields array (e .g . [ "field 0 1 ^value 0 1 " , . . . ] ) * / this . query _field _set = function ( qfs ) { * Function : facets * * Bulk getter /setter for facets (technically 'facet .field ' ) . * * Parameters : * key - * [optional ] * facet to add to the facet list * * Parameters : * list - * [optional ] * list to replace the current list with * * Returns : * the current facets hash . * / this . facets = function ( list _or _key ) { if ( list _or _key ) { if ( bbop . what _is ( list _or _key ) ! = = 'array ' ) { * Function : set _default _query * * Setter for the default query for the query variable ( 'q ' ) . * * Call <reset _query > if you want to affect query immediately . * * Parameters : * new _default _query - new default query string (or TODO : <bbop .logic > ) * * Returns : * the current setting of default query for ( 'q ' ) * / this . set _default _query = function ( new _default _query ) { anchor . default _query = new _default _query ; return anchor . default _query ; } ; * Function : reset _default _query * * Reset the default query back to " * : * " . * * Call <reset _query > if you want to affect query immediately . * * Parameters : * n /a * * Returns : * the current setting of default query ( 'q ' ) * / this . reset _default _query = function ( ) { anchor . default _query = anchor . fundamental _query ; return anchor . default _query ; } ; this . set _query = function ( new _query ) { anchor . query = new _query ; return anchor . query ; } ; this . set _comfy _query = function ( new _query ) { var comfy _query = new _query ; * Function : set _id * * A limited setter , removing whatever else is on query . This is * for when you want to lock into one (unique ) document by id * (essentially 'q =id : "foo " ' ) . All other query operations behave * as they should around it . * * Parameters : * new _id - string id * * Returns : * the current setting of query ( 'q ' ) * * Also see : * <set _ids > * / this . set _id = function ( new _id ) { anchor . query = 'id : ' + bbop . ensure ( new _id , ' " ' ) ; return anchor . query ; } ; * Function : set _ids * * Like <set _id > , a limited setter . It removes whatever else is on * query and replaces it with something like : * * : gm .set _ids ( [ 'GO : 1 ' , 'GO : 2 ' ] ) * * This is for when you want to lock into a set of documents by id . All * other query operations behave as they should around it . * * Parameters : * id _list - a list of ids to search for * * Returns : * the current setting of query ( 'q ' ) * * Also see : * <set _ids > * / this . set _ids = function ( id _list ) { anchor . query = _lock _map ( 'id ' , id _list ) ; return anchor . query ; } ; this . set _targets = function ( id _list , field _list ) { var fixed _list = [ ] ; each ( field _list , function ( field ) { fixed _list . push ( _lock _map ( field , id _list ) ) ; } ) ; var sum = fixed _list . join ( ' OR ' ) ; anchor . query = sum ; return anchor . query ; } ; this . get _query = function ( ) { return anchor . query ; } ; this . get _default _query = function ( ) { return anchor . default _query ; } ; this . get _fundamental _query = function ( ) { return anchor . fundamental _query ; } ; this . get _query = function ( ) { return anchor . query ; } ; this . reset _query = function ( ) { anchor . query = anchor . default _query ; ll ( 'reset query to default : ' + anchor . query ) ; return anchor . query ; } ; this . set _extra = function ( new _extra ) { anchor . query _extra = new _extra ; return anchor . query _extra ; } ; this . get _extra = anchor . set _extra ; this . remove _extra = function ( ) { anchor . query _extra = " " ; return anchor . query _extra ; } ; this . set = function ( key , new _val ) { anchor . query _variants [ key ] = new _val ; } ; this . get = function ( key ) { return anchor . query _variants [ key ] ; } ; this . unset = function ( key ) { var retval = false ; if ( typeof ( anchor . query _variants [ key ] ) ! = = 'undefined ' ) { retval = true ; delete anchor . query _variants [ key ] ; } return retval ; } ; this . include _highlighting = function ( hilite _p , html _elt _str ) { var retval = false ; if ( typeof ( hilite _p ) ! = = 'undefined ' & & ( hilite _p = = = true | | hilite _p = = = false ) ) { if ( hilite _p = = = true ) { * Function : set _personality * * While we are always contacting the same Solr instance , we * sometimes want to have different weights , facets , etc . This * function allows us to use the pre -set ones defined in the * constructor configuration argument . * * Currently , this only sets the 'facet .field ' internal variable . * * Parameters : * personality _id - string * * Returns : * Will return false if personality doesn 't exist * / this . set _personality = function ( personality _id ) { var retval = false ; / / This sets the facet .field internal variable . var cclass = anchor . _golr _conf . get _class ( personality _id ) ; if ( cclass ) { / / Remember what our personality is . / / WARNING : this line must go before the query _field _set / / line below , or else we won 't get the "smart " search . this . _current _class = cclass ; * Function : get _personality * * Returns the current personality , null if none . * * Parameters : * n /a * * Returns : * Returns the current personality as a string , null if none is set * / this . get _personality = function ( ) { var retval = null ; if ( typeof ( anchor . _current _class ) ! = = 'undefined ' & & bbop . what _is ( anchor . _current _class ) = = = 'golr -conf .conf _class ' ) { retval = anchor . _current _class . id ( ) ; } return retval ; } ; this . get _query _url = function ( ) { * Function : push _excursion * * Save the current state of the manager - -data and sticky filter * information - -onto an internal stack . Batch information is not * stored . * * Useful for gettinginto a state , doing something else , then * returning to the original state . * * Parameters : * n /a * * Returns : * the number of items on the excursion stack * * Also see : * <get _query _url > * <pop _excursion > * / this . push _excursion = function ( ) { var now = { * Function : pop _excursion * * Return to a previously pushed state . Batch items are not * recovered . * * Parameters : * n /a * * Returns : * boolean on whether a state was recovered * * Also see : * <get _query _url > * <gpush _excursion > * / this . pop _excursion = function ( ) { var retval = false ; var then = anchor . _excursions . pop ( ) ; if ( then ) { retval = true ; * Function : get _download _url * * Get the current invariant state of the manager returned as a * URL string . * * This differs from <get _query _url > in that the generated string * is intended for text -processing uses rather than computerized * searching uses . The idea where is to create a TSV file for * downloading and consumption . * * Instead of downloading all of the results , a limited listed set * can be downloaded using entity _list , which identifies documents by id . * * The optional argument hash looks like : * rows - the number of rows to return ; defaults to : 1 0 0 0 * encapsulator - how to enclose whitespace fields ; defaults to : " " * separator - separator between fields ; defaults to : " % 0 9 " (tab ) * header - whether or not to show headers ; defaults to : "false " * mv _separator - separator for multi -valued fields ; defaults to : " | " * entity _list - list of specific download items in results ; default null * * With the entity list , keep in mind that null and an empty list * are handled in pretty much the same way - -they are an indication * that we are going after nothing specific , and so all results * are game . * * Parameters : * field _list - a list of fields to return * in _arg _hash - * [optional ] * additional optional arguments * * Returns : * URL string * * Also see : * <get _query _url > * / this . get _download _url = function ( field _list , in _arg _hash ) { * Function : get _filter _query _string * * Get the current state of the manager , as defined by the current * gross filter set - -query , sticky filters , and standard filters - - * returned as a URL query string (sans the ' ? ' ) . * * This differs from <get _query _url > and <get _state _url > in that * the generated string is intended for applications that may want * just enough information to recover filter state when the * personality , and other types of information , are already * known . It is intended to be part of a light RESTy bookmarking * mechanism in larger application . * * Parameters : * n /a * * Returns : * query string for current filters (sans the ' ? ' ) * * Also see : * <get _query _url > * <get _state _url > * / this . get _filter _query _string = function ( ) { * Function : get _state _url * * Get the current invariant state of the manager , plus the * current personality as a parameter , returned as a URL string . * * This differs from <get _query _url > in that the generated string * is intended for applications that may want a little more * information and hinting over just what the current search * is . This method essentially parameterizes some of the "hidden * state " of the manager . * * Parameters : * n /a * * Returns : * URL string * * Also see : * <get _query _url > * / this . get _state _url = function ( ) { * Function : load _url * * Makes a a best attempt to recover the state of a manager from * the clues left in a data url . This can also (and probably * should ) be thought of as a "load bookmark " * function . Theoretically , you should even be able to use * "bookmarks " from alien installations . * * Note that while this recovers enough to get the same data , * certain "session " / "preference " type things that are not encoded * in the url (e .g . filter stickiness , the contents of batch * queues , non -default base queries , etc . ) will not be replayed * and must be recovered or guessed on an app by app basis . . * * Warning : this currently only replays a small subset of possible * parameters . Currently : personality , q , fq , ? ? ? . In the future , * this should no all non -session information . * * Warning : Because there is more to bookmarks than just the major * stuff , variants not supplied in the bookmark will be removed . * * This returns true if the parameter portions of the new and * bookmark urls match . However , this is often not the case - -think * shifting personalities , etc . * * Parameters : * url - A URL string generated by a manager 's get _query _url (or similar ) * * Returns : * boolean * / this . load _url = function ( url ) { / / / / Some Regexps that would be nice to just compile once . / / var regexp _url _space = / \ % 2 0 /g ; / / ' % 2 0 ' = = = ' ' / / var regexp _url _quote = / \ % 2 2 /g ; / / ' % 2 2 ' = = = ' " ' / / var regexp _url _left _paren = / \ % 2 8 /g ; / / ' % 2 8 ' = = = ' ( ' / / var regexp _url _right _paren = / \ % 2 9 /g ; / / ' % 2 9 ' = = = ' ) ' / / We are assuming that we are consuming our own URLs from / / get _query _url ( ) , so we start by attempting to decode it / / (TODO : need a tab watch here ) ? var decoded _url = decode URI ( url ) ; / / Break down url . var in _params = bbop . url _parameters ( decoded _url ) ; / / First , look for the personality setting and invoke it if / / it 's there - -it will dominate unless we take care of it first . / / Also note the all the keys that we see (for later erasure / / of excess ) . var seen _params = { } ; each ( in _params , function ( ip ) { var key = ip [ 0 ] ; var val = ip [ 1 ] ; if ( key = = = 'personality ' & & val & & val ! = = ' ' ) { anchor . set _personality ( val ) ; } seen _params [ key ] = true ; } ) ; / / Now cycle through the the parameters again and invoke the / / appropriate functions to bring them in line . var sticky _cache = { } ; each ( in _params , function ( ip ) { var key = ip [ 0 ] ; var val = ip [ 1 ] ; if ( typeof ( val ) ! = = 'undefined ' & & val ! = = ' ' ) { if ( key = = = 'personality ' ) { / / Already did it , skip . } else if ( key = = = 'q ' ) { anchor . set _query ( val ) ; } else if ( key = = = 'fq ' | | key = = = 'sfq ' ) { / / Split the fq (or sfq ) parameter . var fnv = bbop . first _split ( ' : ' , val ) ; var fname = fnv [ 0 ] ; var fval = fnv [ 1 ] ; / /ll ( 'HERE : fname : ' + fname ) ; / /ll ( 'HERE : fval : ' + fval ) ; if ( fname & & fval ) { var plist = [ ] ; / / Remove leading sign on a filter and / / add it to the plist . var lead _char = fname . char At ( 0 ) ; if ( lead _char = = = ' - ' | | lead _char = = = ' + ' ) { plist . push ( lead _char ) ; fname = fname . substr ( 1 , fname . length - 1 ) ; } / / / / TODO : / / / / If the fval looks like it has not been / / / / decoded (like from a URL -safe / / / / bookmark ) , go ahead and do so . / / fval = fval .replace (regexp _url _space , ' ' ) ; / / fval = fval .replace (regexp _url _quote , ' " ' ) ; / / fval = fval .replace (regexp _url _left _paren , ' ( ' ) ; / / fval = fval .replace (regexp _url _right _paren , ' ) ' ) ; / / Do not allow quotes in - -they will be / / added by the assembler . fval = bbop . dequote ( fval ) ; / / Make it sticky it it came in on "sfq " . / / Note if this is the sticky form . var skey = fname + ' ^ ' + fval ; if ( key = = = 'sfq ' ) { sticky _cache [ skey ] = true ; plist . push ( ' * ' ) ; } / / Add the query filter properly , but / / only if we have not already added the / / sticky form (prevent clobbering ) . if ( ! bbop . is _defined ( sticky _cache [ skey ] ) | | key = = = 'sfq ' ) { anchor . add _query _filter ( fname , fval , plist ) ; } } } else if ( key = = = 'qf ' ) { / / qf is handles a little strangely . . . var foo = bbop . first _split ( ' ^ ' , val ) ; / /ll ( 'qf : key : ' + key + ' , val : ' + val + ' , foo : ' + foo ) ; anchor . add _query _field ( foo [ 0 ] , foo [ 1 ] ) ; } else if ( key = = = 'facet .field ' ) { anchor . facets ( val ) ; } else if ( key = = = 'start ' | | key = = = 'rows ' ) { / / Numbers need to be handled carefully . if ( bbop . what _is ( val ) = = = 'string ' ) { val = parse Float ( val ) ; } anchor . set ( key , val ) ; } else { / / This one catches all of the non -special / / parameters and resets them using .set ( ) . anchor . set ( key , val ) ; / / if ( key = = = 'fq ' ) { / / throw new Error ( "OI " ) ; / / } } } } ) ; / / Now go through and remove all of the query variant / / parameters that were not seen in the bookmark . each ( anchor . query _variants , function ( val , key ) { if ( typeof ( seen _params [ key ] ) = = = 'undefined ' ) { anchor . unset ( key ) ; } } ) ; / / Produce our own url from what we 've done . If the parameters * Function : add _to _batch * * "Save " the current manager state to run later in serial batch * mode . * * The actual job of running these batches is left to the * implementation of the sub -managers ; probably in "run _batch " . * * Parameters : * n /a * * Returns : * state url * / this . add _to _batch = function ( ) { var qurl = anchor . get _query _url ( ) ; anchor . _batch _urls . push ( qurl ) ; return qurl ; } ; this . batch _urls = function ( ) { return anchor . _batch _urls ; } ; this . next _batch _url = function ( ) { return anchor . _batch _urls . shift ( ) | | null ; } ; this . reset _batch = function ( ) { var num = anchor . _batch _urls . length ; anchor . _batch _urls = [ ] ; return num ; } ; } 
function _full _delete ( hash , key 1 , key 2 ) { if ( key 1 & & key 2 & & hash & & hash [ key 1 ] & & hash [ key 1 ] [ key 2 ] ) { delete hash [ key 1 ] [ key 2 ] ; } if ( us . is Empty ( hash [ key 1 ] ) ) { delete hash [ key 1 ] ; } } 
function Socket Transport ( URL , options ) { if ( ! URL ) { throw new Error ( 'A Web Socket URL must be passed to the Socket Transport constructor ! ' ) ; } if ( ! ( this instanceof Socket Transport ) ) { return new Socket Transport ( URL , options ) ; } this . _URL = URL ; this . _options = options | | { } ; this . _socket = null ; this . _state = 'unconnected ' ; this . _active = false ; this . _reconnect Timeout = null ; Event Emitter 2 . call ( this ) ; var self = this ; var listeners = { open : function ( ) { self . _handle Open ( ) ; } , error : function ( error ) { self . _handle Error ( error ) ; } , close : function ( close Event ) { self . _handle Disconnect ( ) ; } , message : function ( message Event ) { self . emit ( 'message ' , message Event . data ) ; } } ; this . _standard Listeners = listeners ; } 
function Commander ( client , options ) { if ( ! ( this instanceof Commander ) ) { return new Commander ( client , options ) ; } Event Emitter 2 . call ( this ) ; this . set Max Listeners ( 0 ) ; options = options | | { } ; options . retry Strategy = options . retry Strategy | | default Retry ; this . _client = client ; this . _options = options ; } 
function add List Element Font Size ( element ) { var h Data Weight = - 9 0 0 7 1 9 9 2 5 4 7 4 0 9 9 2 ; var l Data Weight = 9 0 0 7 1 9 9 2 5 4 7 4 0 9 9 2 ; $ . each ( element . find ( "li " ) , function ( ) { c Data Weight = get Data Weight ( this ) ; if ( c Data Weight = = undefined ) { log Warning ( "No \ "data -weight \ " attribut defined on <li > element " ) ; } else { h Data Weight = c Data Weight > h Data Weight ? c Data Weight : h Data Weight ; l Data Weight = c Data Weight < l Data Weight ? c Data Weight : l Data Weight ; } } ) ; $ . each ( element . find ( "li " ) , function ( ) { var data Weight = get Data Weight ( this ) ; var percent = Math . abs ( ( data Weight - l Data Weight ) / ( l Data Weight - h Data Weight ) ) ; $ ( this ) . css ( 'font -size ' , ( 1 + ( percent * settings [ 'multiplier ' ] ) ) + "em " ) ; } ) ; } 
function ( value ) { if ( value ! = = Number ( value ) ) { var units = 'BKMGTPEZY ' ; var match = value . match ( / ^ ( \d + ( [ , \ . ] \d + ) ? ) ( \w ) \w ? $ / ) ; var value = parse Float ( match [ 1 ] ) * Math . pow ( 1 0 2 4 , units . index Of ( match [ 3 ] . to Upper Case ( ) ) ) ; } return value ; } 
function toggles ( documents _form , show _json , show _file , show _doc , doc _text , show _wizard ) { var json _only = $ ( ' #json -only ' ) ; var the _document = $ ( ' #document ' , documents _form ) ; if ( show _doc ) { 
function add Wizard Fields ( active _core , wizard ) { var core _basepath = active _core . attr ( 'data -basepath ' ) ; var select _options = " " ; 
function ( data ) { var field _select = $ ( " #wiz -field -select " , wizard ) ; field _select . empty ( ) ; $ . each ( data . fields , function ( i , item ) { 
function process Add ( cmd ) { doc = cmd . solr Doc ; 
function mappr ( ) { for ( var _len 2 = arguments . length , mappers = Array ( _len 2 ) , _key 2 = 0 ; _key 2 < _len 2 ; _key 2 + + ) { mappers [ _key 2 ] = arguments [ _key 2 ] ; } return _utils . flow . apply ( undefined , _to Consumable Array ( mappers . map ( apply Mapper ) ) ) ; } 
function zk _error ( xhr , text _status , error _thrown ) { var zk = null ; try { eval ( 'zk = ' + xhr . response Text + ' ; ' ) ; } catch ( e ) { } var message = ' <p class = "txt " >Loading of " <code > ' + xhr . url + ' < /code > " ' + 'failed (HTTP -Status <code > ' + xhr . status + ' < /code > ) < /p > ' + " \n " ; if ( zk . error ) { message + = ' <p class = "msg " > " ' + zk . error . esc ( ) + ' " < /p > ' + " \n " ; } this . closest ( ' #cloud ' ) . html ( ' <div class = "block " id = "error " > ' + message + ' < /div > ' ) ; } 
function ( direction , cloud _element ) { var start = $ ( ' #cloud Graph Paging Start ' ) . val ( ) ; var rows = $ ( ' #cloud Graph Paging Rows ' ) . val ( ) ; var start At = start ? parse Int ( start ) : 0 ; var num Rows = rows ? parse Int ( rows ) : 2 0 ; var new Start = Math . max ( start At + ( rows * direction ) , 0 ) ; $ ( ' #cloud Graph Paging Start ' ) . val ( new Start ) ; var graph _element = $ ( ' #graph -content ' , cloud _element ) ; $ ( ' #canvas ' , graph _element ) . empty ( ) ; init _graph ( graph _element ) ; } 
function dataimport _fetch _config ( ) { $ . ajax ( { url : handler _url + ' ?command =show -config &indent =true ' , data Type : 'xml ' , context : $ ( ' #dataimport _config ' , config _element ) , before Send : function ( xhr , settings ) { error _element . empty ( ) . hide ( ) ; } , success : function ( config , text _status , xhr ) { dataimport _element . remove Class ( 'error ' ) ; config _element . add Class ( 'hidden ' ) ; var entities = [ ' <option value = " " > < /option > ' ] ; $ ( 'document > entity ' , config ) . each ( function ( i , element ) { entities . push ( ' <option > ' + $ ( element ) . attr ( 'name ' ) . esc ( ) + ' < /option > ' ) ; } ) ; $ ( ' #entity ' , form _element ) . html ( entities . join ( " \n " ) ) ; $ ( ' .editable textarea ' , this ) . val ( xhr . response Text . replace ( / \n + $ / , ' ' ) ) ; } , error : function ( xhr , text _status , error _thrown ) { if ( 'parsererror ' = = = error _thrown ) { dataimport _element . add Class ( 'error ' ) ; error _element . text ( 'Dataimport XML -Configuration is not valid ' ) . show ( ) ; config _element . remove Class ( 'hidden ' ) ; } } , complete : function ( xhr , text _status ) { var code = $ ( ' <pre class = "syntax language -xml " > <code > ' + xhr . response Text . esc ( ) + ' < /code > < /pre > ' ) ; $ ( ' .formatted ' , this ) . html ( code ) ; if ( 'success ' = = = text _status ) { hljs . highlight Block ( code . get ( 0 ) ) ; } } } ) ; } 
function ( loaded Frame , element ) { var response , response Str = loaded Frame . content Window . document . body . inner HTML ; try { 
function ( element ) { 
function file Upload ( ) { var form = $form [ 0 ] ; if ( $ ( ' :input [name =submit ] , :input [id =submit ] ' , form ) . length ) { 
function do Submit ( ) { 
function log ( ) { if ( $ . fn . ajax Submit . debug ) { var msg = ' [jquery .form ] ' + Array . prototype . join . call ( arguments , ' ' ) ; if ( window . console & & window . console . log ) { window . console . log ( msg ) ; } else if ( window . opera & & window . opera . post Error ) { window . opera . post Error ( msg ) ; } } } 
function ( status ) { var hc _button = $ ( ' .healthcheck -status ' ) if ( status = = 'enable ' ) { hc _button . parents ( 'dd ' ) . remove Class ( 'ico - 0 ' ) . add Class ( 'ico - 1 ' ) ; hc _button . add Class ( 'enabled ' ) . html ( 'disable ping ' ) ; } else { hc _button . parents ( 'dd ' ) . remove Class ( 'ico - 1 ' ) . add Class ( 'ico - 0 ' ) ; hc _button . remove Class ( 'enabled ' ) . html ( 'enable ping ' ) ; } } 
function App Client ( URL , options ) { if ( ! ( this instanceof App Client ) ) { return new App Client ( URL , options ) ; } options = options | | { } ; 
function write Tobuffer ( value , buffer ) { write ( buffer , value , OFFSET , LITTLE _ENDIAN , MANTISSA _LENGTH , NUMBER _OF _BYTES ) ; } 
function buf 2hex ( buffer , options = { prefix : true } ) { var hex = Array . prototype . map . call ( new Uint 8Array ( buffer ) , x = > ( ' 0 0 ' + x . to String ( 1 6 ) ) . slice ( - 2 ) ) . join ( ' ' ) ; return options . prefix = = = true ? ` $ { hex } ` : hex ; } 
function num 2hex ( value , options ) { if ( value = = = undefined ) throw new Error ( 'Value is undefined ' ) ; var buffer = Buffer . alloc ( NUMBER _OF _BYTES ) ; write Tobuffer ( value , buffer ) ; return buf 2hex ( buffer , options ) ; } 
function hex 2num ( value ) { if ( value = = = undefined ) throw new Error ( 'Value is undefined ' ) ; var buffer = hex 2buf ( value ) ; return read From Buffer ( buffer ) ; } 
function ( ) { var f = $ . jstree . _focused ( ) ; if ( f & & f ! = = this ) { f . get _container ( ) . remove Class ( "jstree -focused " ) ; } if ( f ! = = this ) { this . get _container ( ) . add Class ( "jstree -focused " ) ; focused _instance = this . get _index ( ) ; } this . _ _callback ( ) ; } 
function ( obj , callback , skip _animation ) { obj = this . _get _node ( obj ) ; if ( ! obj . length ) { return false ; } if ( ! obj . has Class ( "jstree -closed " ) ) { if ( callback ) { callback . call ( ) ; } return false ; } var s = skip _animation | | is _ie 6 ? 0 : this . _get _settings ( ) . core . animation , t = this ; if ( ! this . _is _loaded ( obj ) ) { obj . children ( "a " ) . add Class ( "jstree -loading " ) ; this . load _node ( obj , function ( ) { t . open _node ( obj , callback , skip _animation ) ; } , callback ) ; } else { if ( s ) { obj . children ( "ul " ) . css ( "display " , "none " ) ; } obj . remove Class ( "jstree -closed " ) . add Class ( "jstree -open " ) . children ( "a " ) . remove Class ( "jstree -loading " ) ; if ( s ) { obj . children ( "ul " ) . stop ( true ) . slide Down ( s , function ( ) { this . style . display = " " ; } ) ; } this . _ _callback ( { "obj " : obj } ) ; if ( callback ) { callback . call ( ) ; } } } 
function ( obj , position , js , callback , is _loaded ) { obj = this . _get _node ( obj ) ; position = typeof position = = = "undefined " ? "last " : position ; var d = $ ( " <li > " ) , s = this . _get _settings ( ) . core , tmp ; if ( obj ! = = - 1 & & ! obj . length ) { return false ; } if ( ! is _loaded & & ! this . _is _loaded ( obj ) ) { this . load _node ( obj , function ( ) { this . create _node ( obj , position , js , callback , true ) ; } ) ; return false ; } this . _ _rollback ( ) ; if ( typeof js = = = "string " ) { js = { "data " : js } ; } if ( ! js ) { js = { } ; } if ( js . attr ) { d . attr ( js . attr ) ; } if ( js . state ) { d . add Class ( "jstree - " + js . state ) ; } if ( ! js . data ) { js . data = s . strings . new _node ; } if ( ! $ . is Array ( js . data ) ) { tmp = js . data ; js . data = [ ] ; js . data . push ( tmp ) ; } $ . each ( js . data , function ( i , m ) { tmp = $ ( " <a > " ) ; if ( $ . is Function ( m ) ) { m = m . call ( this , js ) ; } if ( typeof m = = "string " ) { tmp . attr ( 'href ' , ' # ' ) [ s . html _titles ? "html " : "text " ] ( m ) ; } else { if ( ! m . attr ) { m . attr = { } ; } if ( ! m . attr . href ) { m . attr . href = ' # ' ; } tmp . attr ( m . attr ) [ s . html _titles ? "html " : "text " ] ( m . title ) ; if ( m . language ) { tmp . add Class ( m . language ) ; } } tmp . prepend ( " <ins class = 'jstree -icon ' > & # 1 6 0 ; < /ins > " ) ; if ( m . icon ) { if ( m . icon . index Of ( " / " ) = = = - 1 ) { tmp . children ( "ins " ) . add Class ( m . icon ) ; } else { tmp . children ( "ins " ) . css ( "background " , "url ( ' " + m . icon + " ' ) center center no -repeat " ) ; } } d . append ( tmp ) ; } ) ; d . prepend ( " <ins class = 'jstree -icon ' > & # 1 6 0 ; < /ins > " ) ; if ( obj = = = - 1 ) { obj = this . get _container ( ) ; if ( position = = = "before " ) { position = "first " ; } if ( position = = = "after " ) { position = "last " ; } } switch ( position ) { case "before " : obj . before ( d ) ; tmp = this . _get _parent ( obj ) ; break ; case "after " : obj . after ( d ) ; tmp = this . _get _parent ( obj ) ; break ; case "inside " : case "first " : if ( ! obj . children ( "ul " ) . length ) { obj . append ( " <ul > " ) ; } obj . children ( "ul " ) . prepend ( d ) ; tmp = obj ; break ; case "last " : if ( ! obj . children ( "ul " ) . length ) { obj . append ( " <ul > " ) ; } obj . children ( "ul " ) . append ( d ) ; tmp = obj ; break ; default : if ( ! obj . children ( "ul " ) . length ) { obj . append ( " <ul > " ) ; } if ( ! position ) { position = 0 ; } tmp = obj . children ( "ul " ) . children ( "li " ) . eq ( position ) ; if ( tmp . length ) { tmp . before ( d ) ; } else { obj . children ( "ul " ) . append ( d ) ; } tmp = obj ; break ; } if ( tmp = = = - 1 | | tmp . get ( 0 ) = = = this . get _container ( ) . get ( 0 ) ) { tmp = - 1 ; } this . clean _node ( tmp ) ; this . _ _callback ( { "obj " : d , "parent " : tmp } ) ; if ( callback ) { callback . call ( this , d ) ; } return d ; } 
function ( obj ) { obj = this . _get _node ( obj ) ; if ( ! obj . length ) { return false ; } this . _ _rollback ( ) ; var p = this . _get _parent ( obj ) , prev = this . _get _prev ( obj ) ; obj = obj . remove ( ) ; if ( p ! = = - 1 & & p . find ( " > ul > li " ) . length = = = 0 ) { p . remove Class ( "jstree -open jstree -closed " ) . add Class ( "jstree -leaf " ) ; } this . clean _node ( p ) ; this . _ _callback ( { "obj " : obj , "prev " : prev } ) ; return obj ; } 
function ( ) { var json = { } ; $ . each ( this , function ( k , v ) { if ( ! _is Function ( v ) ) { json [ k ] = v ; } } ) ; return json ; } 
function ( ) { var display = " " ; $ . each ( this , function ( k , v ) { if ( ! _is Function ( v ) ) { display + = " <strong > " + k + " < /strong > " + v + " <br / > " ; } } ) ; return display ; } 
function ( attributes _only ) { var keys = [ ] ; for ( var property in this ) { if ( ! _is Function ( this [ property ] ) | | ! attributes _only ) { keys . push ( property ) ; } } return keys ; } 
function ( include _functions ) { var s = [ ] ; $ . each ( this , function ( k , v ) { if ( ! _is Function ( v ) | | include _functions ) { s . push ( ' " ' + k + ' " : ' + v . to String ( ) ) ; } } ) ; return "Sammy .Object : { " + s . join ( ' , ' ) + " } " ; } 
function ( ) { var proxy = this , app = this . app ; $ ( window ) . bind ( 'hashchange . ' + this . app . event Namespace ( ) , function ( e , non _native ) { 
function ( ) { $ ( window ) . unbind ( 'hashchange . ' + this . app . event Namespace ( ) ) ; Sammy . Hash Location Proxy . _bindings - - ; if ( Sammy . Hash Location Proxy . _bindings < = 0 ) { window . clear Interval ( Sammy . Hash Location Proxy . _interval ) ; } } 
function ( ) { 
function ( new _proxy ) { var original _proxy = this . _location _proxy ; this . _location _proxy = new _proxy ; if ( this . is Running ( ) ) { if ( original _proxy ) { 
function ( verb , path , callback ) { var app = this , param _names = [ ] , add _route , path _match ; 
function ( route _array ) { var app = this ; $ . each ( route _array , function ( i , route _args ) { app . route . apply ( app , route _args ) ; } ) ; return this ; } 
function ( name , data , callback ) { var app = this ; 
function ( options , callback ) { if ( _is Function ( options ) ) { callback = options ; options = { } ; } this . befores . push ( [ options , callback ] ) ; return this ; } 
function ( start _url ) { if ( this . is Running ( ) ) { return false ; } var app = this ; this .bind ( 'submit ' , function (e ) { var returned = app . _check Form Submission ( $ (e .target ) .closest ( 'form ' ) ) ; return (returned = = = false ) ? e .prevent Default ( ) : false ; } ) ; * / 
function ( ) { if ( ! this . is Running ( ) ) { return false ; } var app = this ; this . trigger ( 'unload ' ) ; 
function ( callback ) { var app = this ; 
function ( verb , path ) { var app = this , routed = false ; this . trigger ( 'lookup -route ' , { verb : verb , path : path } ) ; if ( typeof this . routes [ verb ] ! = 'undefined ' ) { $ . each ( this . routes [ verb ] , function ( i , route ) { if ( app . routable Path ( path ) . match ( route . path ) ) { routed = route ; return false ; } } ) ; } return routed ; } 
function ( verb , path , params , target ) { var app = this , route = this . lookup Route ( verb , path ) , context , wrapped _route , arounds , around , befores , before , callback _args , path _params , final _returned ; this . log ( 'run Route ' , [ verb , path ] . join ( ' ' ) ) ; this . trigger ( 'run -route ' , { verb : verb , path : path , params : params } ) ; if ( typeof params = = 'undefined ' ) { params = { } ; } $ . extend ( params , this . _parse Query String ( path ) ) ; if ( route ) { this . trigger ( 'route -found ' , { route : route } ) ; 
function ( context , match _options , positive ) { 
function ( verb , path ) { var ret = this . error ( [ ' 4 0 4 Not Found ' , verb , path ] . join ( ' ' ) ) ; return ( verb = = = 'get ' ) ? ret : true ; } 
function ( message , original _error ) { if ( ! original _error ) { original _error = new Error ( ) ; } original _error . message = [ message , original _error . message ] . join ( ' ' ) ; this . trigger ( 'error ' , { message : original _error . message , error : original _error } ) ; if ( this . raise _errors ) { throw ( original _error ) ; } else { this . log ( original _error . message , original _error ) ; } } 
function ( callback ) { if ( ! _is Function ( callback ) ) { 
function ( content ) { this . waiting = false ; if ( typeof content ! = = 'undefined ' ) { this . previous _content = this . content ; this . content = content ; } if ( this . callbacks . length > 0 ) { this . then ( this . callbacks . shift ( ) ) ; } } 
function ( location , options , callback ) { var context = this ; return this . then ( function ( ) { var should _cache , cached , is _json , location _array ; if ( _is Function ( options ) ) { callback = options ; options = { } ; } else { options = $ . extend ( { } , options ) ; } if ( callback ) { this . then ( callback ) ; } if ( typeof location = = = 'string ' ) { 
function ( location , data , callback ) { if ( _is Function ( location ) & & ! data ) { return this . then ( location ) ; } else { if ( ! data & & this . content ) { data = this . content ; } return this . load ( location ) . interpolate ( data , location ) . then ( callback ) ; } } 
function ( ) { var context = this , args = _make Array ( arguments ) , fun = args . shift ( ) ; if ( _is Array ( args [ 0 ] ) ) { args = args [ 0 ] ; } return this . then ( function ( content ) { args . push ( function ( response ) { context . next ( response ) ; } ) ; context . wait ( ) ; fun . apply ( fun , args ) ; return false ; } ) ; } 
function ( array , callback , now ) { var context = this ; var coll = function ( ) { if ( _is Function ( array ) ) { callback = array ; array = this . content ; } var contents = [ ] , doms = false ; $ . each ( array , function ( i , item ) { var returned = callback . apply ( context , [ i , item ] ) ; if ( returned . jquery & & returned . length = = 1 ) { returned = returned [ 0 ] ; doms = true ; } contents . push ( returned ) ; return returned ; } ) ; return doms ? contents : contents . join ( ' ' ) ; } ; return now ? coll ( ) : this . then ( coll ) ; } 
function ( location , name , data , callback ) { if ( _is Array ( name ) ) { callback = data ; data = name ; name = null ; } return this . load ( location ) . then ( function ( content ) { var rctx = this ; if ( ! data ) { data = _is Array ( this . previous _content ) ? this . previous _content : [ ] ; } if ( callback ) { $ . each ( data , function ( i , value ) { var idata = { } , engine = this . next _engine | | location ; name ? ( idata [ name ] = value ) : ( idata = value ) ; callback ( value , rctx . event _context . interpolate ( content , idata , engine ) ) ; } ) ; } else { return this . collect ( data , function ( i , value ) { var idata = { } , engine = this . next _engine | | location ; name ? ( idata [ name ] = value ) : ( idata = value ) ; return this . event _context . interpolate ( content , idata , engine ) ; } , true ) ; } } ) ; } 
function ( name , data ) { return this . then ( function ( content ) { if ( typeof data = = 'undefined ' ) { data = { content : content } ; } this . event _context . trigger ( name , data ) ; } ) ; } 
function ( engine ) { var context = this , engine _match ; 
function ( location , name , data , callback ) { return new Sammy . Render Context ( this ) . render Each ( location , name , data , callback ) ; } 
function ( ) { var to , args = _make Array ( arguments ) , current _location = this . app . get Location ( ) ; if ( args . length > 1 ) { args . unshift ( ' / ' ) ; to = this . join . apply ( this , args ) ; } else { to = args [ 0 ] ; } this . trigger ( 'redirect ' , { to : to } ) ; this . app . last _location = [ this . verb , this . path ] ; this . app . set Location ( to ) ; if ( current _location = = to ) { this . app . trigger ( 'location -changed ' ) ; } } 
function ( name , data ) { if ( typeof data = = 'undefined ' ) { data = { } ; } if ( ! data . context ) { data . context = this ; } return this . app . trigger ( name , data ) ; } 
function ( partial Path , locals ) { var normalized Partial Path = normalize Template Path ( partial Path , path . dirname ( normalized Template Path ) ) ; return exports . compile ( normalized Partial Path ) ( locals ) ; } 
function ( type , content , text After , state ) { if ( this . json Mode ) { return / ^ [ \ [ , { ] $ / . test ( content ) | | / ^ } / . test ( text After ) ; } else { if ( content = = " ; " & & state . lexical & & state . lexical . type = = " ) " ) return false ; return / ^ [ ; { } ] $ / . test ( content ) & & ! / ^ ; / . test ( text After ) ; } } 
function scan For Bracket ( cm , where , dir , style , config ) { var max Scan Len = ( config & & config . max Scan Line Length ) | | 1 0 0 0 0 ; var max Scan Lines = ( config & & config . max Scan Lines ) | | 1 0 0 0 ; var stack = [ ] ; var re = config & & config . bracket Regex ? config . bracket Regex : / [ ( ) { } [ \ ] ] / ; var line End = dir > 0 ? Math . min ( where . line + max Scan Lines , cm . last Line ( ) + 1 ) : Math . max ( cm . first Line ( ) - 1 , where . line - max Scan Lines ) ; for ( var line No = where . line ; line No ! = line End ; line No + = dir ) { var line = cm . get Line ( line No ) ; if ( ! line ) continue ; var pos = dir > 0 ? 0 : line . length - 1 , end = dir > 0 ? line . length : - 1 ; if ( line . length > max Scan Len ) continue ; if ( line No = = where . line ) pos = where . ch - ( dir < 0 ? 1 : 0 ) ; for ( ; pos ! = end ; pos + = dir ) { var ch = line . char At ( pos ) ; if ( re . test ( ch ) & & ( style = = = undefined | | cm . get Token Type At ( Pos ( line No , pos + 1 ) ) = = style ) ) { var match = matching [ ch ] ; if ( ( match . char At ( 1 ) = = " > " ) = = ( dir > 0 ) ) stack . push ( ch ) ; else if ( ! stack . length ) return { pos : Pos ( line No , pos ) , ch : ch } ; else stack . pop ( ) ; } } } return line No - dir = = ( dir > 0 ? cm . last Line ( ) : cm . first Line ( ) ) ? false : null ; } 
function entering String ( cm , pos , ch ) { var line = cm . get Line ( pos . line ) ; var token = cm . get Token At ( pos ) ; if ( / \bstring 2 ? \b / . test ( token . type ) ) return false ; var stream = new Code Mirror . String Stream ( line . slice ( 0 , pos . ch ) + ch + line . slice ( pos . ch ) , 4 ) ; stream . pos = stream . start = token . start ; for ( ; ; ) { var type 1 = cm . get Mode ( ) . token ( stream , token . state ) ; if ( stream . pos > = pos . ch + 1 ) return / \bstring 2 ? \b / . test ( type 1 ) ; stream . start = stream . pos ; } } 
function Yr ( a , b ) { this . je = [ ] ; this . Lf = a ; this . Af = b | | null ; this . Bd = this . Wc = ! 1 ; this . dc = void 0 ; this . Ye = this . Zf = this . ue = ! 1 ; this . me = 0 ; this . Va = null ; this . ve = 0 ; } 
function push ( type , packet ) { let msg = { 'type ' : type ! = null ? 'results ' : 'other ' , 'value ' : type , 'data ' : packet . data ( ) } ; 
function resolve ( paths ) { paths = Array . is Array ( paths ) ? paths : [ paths ] ; var full Path = path . resolve . apply ( this , paths ) . replace ( / \ \ / g , ' / ' ) ; return { full Path : full Path , dir Name : path . dirname ( full Path ) , file Name : path . basename ( full Path ) , ext Name : path . extname ( full Path ) . replace ( ' . ' , ' ' ) } ; } 
function exists Or Create ( file Path , opts , cb ) { if ( arguments . length = = = 2 ) { cb = arguments [ 1 ] ; opts = { } ; } opts . encoding = opts . encoding | | 'utf 8 ' ; opts . data = opts . data | | opts . content | | ' ' ; opts . mode = opts . mode | | ' 0 7 7 7 ' ; opts . replace = opts . replace ? true : false ; var fp = resolve ( file Path ) ; var is File = opts . has Own Property ( 'is File ' ) ? opts . is File : ! ! fp . ext Name ; fs . exists ( fp . full Path , function ( exists ) { if ( exists & & ! opts . replace ) cb ( null , exists ) ; else { 
function exists Or Create Sync ( file Path , opts ) { opts = opts | | { } ; opts . encoding = opts . encoding | | 'utf 8 ' ; opts . data = opts . data | | opts . content | | ' ' ; opts . mode = opts . mode | | ' 0 7 7 7 ' ; var fp = resolve ( file Path ) ; var is File = opts . has Own Property ( 'is File ' ) ? opts . is File : ! ! fp . ext Name ; var exists = fs . exists Sync ( fp . full Path ) ; if ( ! exists | | opts . replace ) { mkdir ( ( is File ? fp . dir Name : fp . full Path ) ) ; if ( is File | | opts . replace ) fs . write File Sync ( fp . full Path , opts . data , opts . encoding ) ; } function mkdir ( full Path ) { if ( fs . exists Sync ( full Path ) ) return ; else { var parent Path = full Path . split ( ' / ' ) ; parent Path . pop ( ) ; mkdir ( parent Path . join ( ' / ' ) ) ; fs . mkdir Sync ( full Path , opts . mode ) ; } } return exists ; } 
function unwatch ( file Path ) { file Path = path . resolve ( file Path ) ; if ( _file Watchers [ file Path ] ) _file Watchers [ file Path ] . close ( ) ; delete _file Watchers [ file Path ] ; } 
function unwatch All ( ) { for ( var file Path in _file Watchers ) { if ( _file Watchers [ file Path ] ) _file Watchers [ file Path ] . close ( ) ; delete _file Watchers [ file Path ] ; } for ( var dir Path in _dir Watchers ) { if ( _dir Watchers [ dir Path ] ) _dir Watchers [ dir Path ] . close ( ) ; delete _dir Watchers [ dir Path ] ; } } 
function require Async ( file Path , opts , cb ) { if ( arguments . length = = = 2 ) { cb = arguments [ 1 ] ; opts = { } ; } file Path = path . resolve ( file Path ) ; opts . encoding = opts . encoding | | 'utf 8 ' ; 
function check Exists Name ( file Path , is Dir , callback , count ) { 
function write File ( file Path , data , callback , count ) { 
function read File ( file Path , opts , callback , count ) { 
function read File Line ( filepath , opts , data Cb , complete Cb ) { if ( typeof arguments [ 0 ] ! = = 'string ' ) { complete Cb = arguments [ 2 ] ; data Cb = arguments [ 1 ] ; opts = arguments [ 0 ] ; filepath = opts . file | | opts . filename | | opts . filepath ; } filepath = resolve ( filepath ) . full Path ; opts = opts | | { } ; var chunk Size = opts . chunk Size | | 1 ; var has Header = opts . header | | opts . headers | | opts . has Header ; var head Line ; var instream = fs . create Read Stream ( filepath , opts ) ; var outstream = new Stream ( ) ; var rl = readline . create Interface ( instream , outstream ) ; var on Lines = data Cb | | opts . on Line | | opts . on Lines | | opts . on Data ; var on Close = complete Cb | | opts . on Close | | opts . on Complete ; var done = data Cb | | complete Cb ; instream . on ( 'error ' , function ( err ) { rl . closed = true ; rl . close ( ) ; if ( done ) done ( err ) ; else throw err ; } ) ; opts . separator = opts . separator | | opts . delimiter ; var line Parser = opts . line Parser | | function ( line ) { if ( ! opts . separator ) return line ; return line . split ( opts . separator ) ; } ; var next Chunk = chunk Size ; var chunk Data = [ ] ; var line Error ; var index = - 1 ; 
function file Line Reader ( filepath , opts ) { if ( typeof arguments [ 0 ] ! = = 'string ' ) { opts = arguments [ 0 ] ; filepath = opts . file | | opts . filename | | opts . filepath ; } filepath = resolve ( filepath ) . full Path ; opts = opts | | { } ; var chunk Size = opts . chunk Size | | 1 ; var has Header = opts . header | | opts . headers | | opts . has Header ; var head Line ; var instream = fs . create Read Stream ( filepath , opts ) ; var outstream = new Stream ( ) ; var rl = readline . create Interface ( instream , outstream ) ; var on Data ; var done ; instream . on ( 'error ' , function ( err ) { rl . closed = true ; rl . close ( ) ; if ( done ) done ( err ) ; else throw err ; } ) ; opts . separator = opts . separator | | opts . delimiter ; var line Parser = opts . line Parser | | function ( line ) { if ( ! opts . separator ) return line ; return line . split ( opts . separator ) ; } ; var lines = [ ] ; var line Error ; var index = - 1 ; var limit = 1 ; function get Lines ( num Of Lines , cb ) { if ( arguments . length = = = 0 ) cb = arguments [ 0 ] ; if ( typeof cb ! = = 'function ' ) throw new Error ( 'Wrong arguments ' ) ; done = cb ; index = index = = = - 1 ? - 1 : 0 ; limit = num Of Lines | | 1 ; var result ; if ( lines . length = = = 0 ) index = - 1 ; 
function rmdir Recursive ( dir , clbk ) { dir = resolve ( dir ) . full Path ; if ( clbk = = = null | | typeof clbk = = = 'undefined ' ) clbk = function ( err ) { } ; fs . readdir ( dir , function ( err , files ) { if ( err ) return clbk ( err ) ; if ( ! files ) return clbk ( new Error ( 'fs Ext .rmdir Recursive : removing folders failed , folder not exists ' ) ) ; ( function rm File ( err ) { if ( err ) return clbk ( err ) ; var filename = files . shift ( ) ; if ( filename = = = null | | typeof filename = = = 'undefined ' ) return fs . rmdir ( dir , clbk ) ; var file = dir + ' / ' + filename ; fs . lstat ( file , function ( err , stat ) { if ( err ) return clbk ( err ) ; if ( stat . is Directory ( ) ) rmdir Recursive ( file , rm File ) ; else fs . unlink ( file , rm File ) ; } ) ; } ) ( ) ; } ) ; } 
function walk ( dir , opts , done , root Dir , level ) { 
function get File Info ( file Id , file Path , cb , repeated ) { 
function get Path Ancestors ( filename ) { var tree = filename . split ( ' / ' ) ; tree . pop ( ) ; 
function get Name ( file Id , is File ) { var splitted = file Id . split ( ' / ' ) ; 
function get Ext ( filename ) { var splitted = filename . split ( ' . ' ) ; if ( splitted . length = = = 1 ) return ' ' ; 
function get File Item ( file Id , stat , file Path ) { return { id : file Id , full Path : file Path , name : get Name ( file Id , ! stat . is Directory ( ) ) , ancestors : get Path Ancestors ( file Id ) , is Dir : stat . is Directory ( ) , is File : ! stat . is Directory ( ) , ext : ! stat . is Directory ( ) ? get Ext ( file Id ) : null , modified DT : stat . mtime , 
function watch Recursive ( dir , opts , on Change , cb , repeated ) { 
function get Dir Children ( parent Id , items ) { var children = { } ; for ( var id in items ) { if ( items [ id ] . ancestors [ items [ id ] . ancestors . length - 1 ] = = = parent Id ) children [ id ] = items [ id ] ; } return children ; } 
function compare Dir Files ( parent Id , old _children , descendants ) { var changes = [ ] , not _found = object . extend ( { } , old _children ) ; for ( var id in descendants ) { if ( descendants [ id ] . ancestors [ descendants [ id ] . ancestors . length - 1 ] = = = parent Id ) { 
function Fast Dom ( ) { var self = this ; self . reads = [ ] ; self . writes = [ ] ; self . raf = request Animation Frame $ 1 . bind ( window ) ; 
function ( fn , ctx ) { var task = ! ctx ? fn : fn . bind ( ctx ) ; this . reads . push ( task ) ; schedule Flush ( this ) ; return task ; } 
function ( fn , ctx ) { var task = ! ctx ? fn : fn . bind ( ctx ) ; this . writes . push ( task ) ; schedule Flush ( this ) ; return task ; } 
function ( props ) { if ( typeof props ! = 'object ' ) { throw new Error ( 'expected object ' ) ; } var child = Object . create ( this ) ; mixin ( child , props ) ; child . fastdom = this ; 
function schedule Flush ( fastdom ) { if ( ! fastdom . scheduled ) { fastdom . scheduled = true ; fastdom . raf ( flush . bind ( null , fastdom ) ) ; } } 
function flush ( fastdom ) { var reads = fastdom . reads . splice ( 0 , fastdom . reads . length ) , writes = fastdom . writes . splice ( 0 , fastdom . writes . length ) , error ; try { run Tasks ( reads ) ; run Tasks ( writes ) ; } catch ( e ) { error = e ; } fastdom . scheduled = false ; 
function do Call Endpoint ( call Spec , next , on Receive , on Error , store ) { const { method , path , url Params , body , token , base Url } = call Spec return api Fetch ( compile Url ( path , url Params ) , { . . . fetch Options ( method , body , token ) , base Url } ) . then ( response = > 
function create ( props ) { var knob = Object . create ( this ) ; 
function draw ( ) { 
function process Pointer Position ( e ) { var x Offset = e . client X , y Offset = e . client Y ; var radius = this . rect . width / 2 ; this . last Value = this . value ; if ( ! this . uses Rotation ) { if ( this . last Position ! = = - 1 ) { 
function set Context Value ( set Chain Context , chain Id , name , value ) { if ( value instanceof Function ) { throw new Function As Value Exception ( ) ; } set Chain Context ( chain Id , name , value ) ; } 
function recurse ( node ) { 
function ( url , prev , done ) { if ( url . index Of ( 'bootstrap / ' ) = = = 0 ) { var component = url . substr ( 'bootstrap / ' . length + 1 ) ; var file = cms Dir + ' /src /scss /bootstrap / _ ' + component + ' .scss ' ; try { var stats = fs . lstat Sync ( file ) ; if ( stats . is File ( ) ) { return { file : file } ; } } catch ( ex ) { 
function format Date ( date , format ) { format = format + ' ' ; var result = ' ' ; var i _format = 0 ; var c = ' ' ; var token = ' ' ; var y = date . get Year ( ) + ' ' ; var M = date . get Month ( ) + 1 ; var d = date . get Date ( ) ; var E = date . get Day ( ) ; var H = date . get Hours ( ) ; var m = date . get Minutes ( ) ; var s = date . get Seconds ( ) ; var yyyy , yy , MMM , MM , dd , hh , h , mm , ss , ampm , HH , H , KK , K , kk , k ; 
function get Date From Format ( val , format ) { val = val + ' ' ; format = format + ' ' ; var i _val = 0 ; var i _format = 0 ; var c = ' ' ; var token = ' ' ; var token 2 = ' ' ; var x , y ; var now = new Date ( 0 ) ; var year = now . get Year ( ) ; var month = now . get Month ( ) + 1 ; var date = 1 ; var hh = now . get Hours ( ) ; var mm = now . get Minutes ( ) ; var ss = now . get Seconds ( ) ; var ampm = ' ' ; while ( i _format < format . length ) { 
function _is Integer ( val ) { var digits = ' 1 2 3 4 5 6 7 8 9 0 ' ; for ( var i = 0 ; i < val . length ; i + + ) { if ( digits . index Of ( val . char At ( i ) ) = = = - 1 ) { return false ; } } return true ; } 
function stream To Buffer ( stream , cb ) { 
function Bucks ( params ) { this . _tasks = [ ] ; this . _taskcount = 0 ; this . _results = [ ] ; this . callback = none ; this . failure = none ; this . _alive = true ; this . _interrupt = false ; this . _ _id = uid ( ) ; Bucks . living [ this . _ _id ] = this ; this . initialize ( params ) ; } 
function _normalize Task ( task ) { var _task = task ; if ( task . length < 3 ) { _task = function _task ( err , res , next ) { 
function _normalize Success ( on Success ) { var _on Success = on Success ; if ( on Success . length < 2 ) { _on Success = function ( res , next ) { var result = on Success ( res ) ; next ( null , result ) ; } ; } else if ( on Success . length = = = 2 ) { _on Success = on Success ; } else { throw new Error ( 'args length invalid ' ) ; } return _on Success ; } 
function _normalize Error ( on Error ) { var _on Error = on Error ; if ( on Error . length < 2 | | 3 < on Error . length ) { throw new Error ( on Error . name + ' : args length invalid . should be : on Error (err , next ) ' ) ; } return _on Error ; } 
function add ( task ) { if ( ! this . _alive ) { throw new Error ( 'this bucks object already destroyed . ' ) ; } var _task = this . _normalize Task ( task ) ; this . _tasks . push ( _task ) ; return this ; } 
function then ( on Success ) { var _on Success = this . _normalize Success ( on Success ) ; return this . add ( function on Success Task ( err , res , next ) { if ( err ) { 
function error ( on Error ) { var _on Error = this . _normalize Error ( on Error ) ; return this . add ( function on Error Task ( err , res , next ) { if ( err ) { 
function _iterator ( err , res ) { if ( this . _interrupt ) { return this ; } if ( ! this . _alive ) { throw new Error ( 'this bucks object already destroyed . ' ) ; } 
function parallel ( tasks ) { if ( ! is Array ( tasks ) ) { throw new Error ( 'tasks is not array . ' ) ; } if ( is Array Empty ( tasks ) ) { return this . add ( function pass Empty ( err , res , next ) { next ( null , new Parallel Handler ( 0 ) . result Obj ) ; } ) ; } 
function waterfall ( tasks ) { if ( ! is Array ( tasks ) ) { throw new Error ( 'tasks is not array . ' ) ; } if ( is Array Empty ( tasks ) ) { return this . add ( function pass Empty ( err , res , next ) { next ( null , [ ] ) ; } ) ; } 
function delay ( ms ) { return this . add ( function ( err , res , next ) { set Timeout ( function ( ) { next ( err , res ) ; } , ms | | 0 ) ; } ) ; } 
function destroy ( err ) { if ( ! this . _alive ) { return this ; } var ress = this . _results ; var callback = this . callback ; var failure = this . failure ; var dispose = this . dispose ; this . _tasks = null ; this . _taskcount = 0 ; this . _results = null ; this . callback = none ; this . failure = none ; this . dispose = none ; 
function end ( callback , errback ) { if ( callback & & callback . length < 1 ) { 
function success One ( idx , err , res ) { this . _errors [ idx ] = err ; this . _results [ idx ] = res ; this . _waiting - - ; if ( this . _waiting < = 0 ) { this . _on Finish . call ( null , this . result Obj ) ; } } 
function ( e ) { var delta = e . loaded - progress Before ; bar . value + = delta ; progress Before = e . loaded ; } 
function cached ( opt ) { if ( typeof opt = = 'undefined ' | | opt = = = null ) opt = { } ; if ( typeof opt = = 'string ' ) opt = { type : opt } ; if ( typeof opt . id ! = 'string ' ) opt . id = _random _string ( 8 ) ; opt = Object . assign ( { } , get Settings ( ) , opt ) ; for ( var i in opt ) check Setting ( i , opt [ i ] ) ; return function ( func , key , descriptor ) { if ( key ) func = func [ key ] ; 
function ( . . . rest ) { const _key = _hash ( rest , opt . id ) ; return cache Obj . get ( opt , _key ) . then ( res = > { if ( typeof res = = 'undefined ' | | res = = = null ) { res = _update . bind ( this ) ( opt , func , rest ) ; } return res ; } ) ; } 
function get Chain ( storage , name ) { if ( storage [ GET _CHAIN _METHOD ] ) { return storage [ GET _CHAIN _METHOD ] ( name ) ; } var chain = Object . assign ( { } , storage [ name ] ) ; chain [ ' $chain Id ' ] = ( 0 , _Util . generate UUID ) ( ) ; return Object . assign ( { } , chain ) ; } 
function get Chain Data By Id ( storage , chain Id ) { if ( storage [ GET _CHAIN _METHOD ] ) { return storage [ GET _CHAIN _METHOD ] ( chain Id ) ; } return storage [ chain Id ] ; } 
function get Chain Context ( storage , chain Id , field ) { if ( storage [ GET _CHAIN _CONTEXT _METHOD ] ) { return storage [ GET _CHAIN _CONTEXT _METHOD ] ( chain Id , field ) ; } if ( storage [ chain Id ] ) { return storage [ chain Id ] [ field ] ; } } 
function create ( props ) { var multi Button = Object . create ( this ) ; _canvas Widget 2 . default . create . call ( multi Button ) ; Object . assign ( multi Button , Multi Button . defaults , props ) ; if ( props . value ) { multi Button . _ _value = props . value ; } else { multi Button . _ _value = [ ] ; for ( var i = 0 ; i < multi Button . count ; i + + ) { multi Button . _ _value [ i ] = 0 ; } multi Button . value = [ ] ; } multi Button . active = { } ; multi Button . _ _prev Value = [ ] ; multi Button . init ( ) ; return multi Button ; } 
function draw ( ) { this . ctx . fill Style = this . _ _value = = = 1 ? this . fill : this . background ; this . ctx . stroke Style = this . stroke ; this . ctx . line Width = this . line Width ; var button Width = this . rect . width / this . columns , button Height = this . rect . height / this . rows ; for ( var row = 0 ; row < this . rows ; row + + ) { var y = row * button Height ; for ( var column = 0 ; column < this . columns ; column + + ) { var x = column * button Width , _button Num = row * this . columns + column ; this . ctx . fill Style = this . _ _value [ _button Num ] = = = 1 ? this . fill : this . background ; this . ctx . fill Rect ( x , y , button Width , button Height ) ; this . ctx . stroke Rect ( x , y , button Width , button Height ) ; } } } 
function mk Sprite ( src Files , dest Image , options , callback ) { options . src = src Files , grunt . verbose . writeln ( 'Options passed to Spritesmth : ' , JSON . stringify ( options ) ) ; spritesmith ( options , function ( err , result ) { 
function is Host Object $ 1 ( value ) { 
function is Plain Object ( value ) { if ( ! is Object Like $ 1 ( value ) | | object To String $ 1 . call ( value ) ! = object Tag | | is Host Object $ 1 ( value ) ) { return false ; } var proto = get Prototype ( value ) ; if ( proto = = = null ) { return true ; } var Ctor = has Own Property $ 1 . call ( proto , 'constructor ' ) & & proto . constructor ; return ( typeof Ctor = = 'function ' & & Ctor instanceof Ctor & & func To String $ 1 . call ( Ctor ) = = object Ctor String ) ; } 
function is Host Object $ 2 ( value ) { 
function Hash $ 1 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( + + index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function hash Get $ 1 ( key ) { var data = this . _ _data _ _ ; if ( native Create $ 1 ) { var result = data [ key ] ; return result = = = HASH _UNDEFINED $ 1 ? undefined : result ; } return has Own Property $ 2 . call ( data , key ) ? data [ key ] : undefined ; } 
function hash Has $ 1 ( key ) { var data = this . _ _data _ _ ; return native Create $ 1 ? data [ key ] ! = = undefined : has Own Property $ 2 . call ( data , key ) ; } 
function hash Set $ 1 ( key , value ) { var data = this . _ _data _ _ ; data [ key ] = ( native Create $ 1 & & value = = = undefined ) ? HASH _UNDEFINED $ 1 : value ; return this ; } 
function List Cache $ 1 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( + + index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function list Cache Delete $ 1 ( key ) { var data = this . _ _data _ _ , index = assoc Index Of $ 1 ( data , key ) ; if ( index < 0 ) { return false ; } var last Index = data . length - 1 ; if ( index = = last Index ) { data . pop ( ) ; } else { splice $ 1 . call ( data , index , 1 ) ; } return true ; } 
function list Cache Get $ 1 ( key ) { var data = this . _ _data _ _ , index = assoc Index Of $ 1 ( data , key ) ; return index < 0 ? undefined : data [ index ] [ 1 ] ; } 
function list Cache Set $ 1 ( key , value ) { var data = this . _ _data _ _ , index = assoc Index Of $ 1 ( data , key ) ; if ( index < 0 ) { data . push ( [ key , value ] ) ; } else { data [ index ] [ 1 ] = value ; } return this ; } 
function Map Cache $ 1 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( + + index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function assoc Index Of $ 1 ( array , key ) { var length = array . length ; while ( length - - ) { if ( eq $ 1 ( array [ length ] [ 0 ] , key ) ) { return length ; } } return - 1 ; } 
function base Is Native $ 1 ( value ) { if ( ! is Object $ 1 ( value ) | | is Masked $ 1 ( value ) ) { return false ; } var pattern = ( is Function $ 1 ( value ) | | is Host Object $ 2 ( value ) ) ? re Is Native $ 1 : re Is Host Ctor $ 1 ; return pattern . test ( to Source $ 1 ( value ) ) ; } 
function base To String $ 1 ( value ) { 
function get Map Data $ 1 ( map , key ) { var data = map . _ _data _ _ ; return is Keyable $ 1 ( key ) ? data [ typeof key = = 'string ' ? 'string ' : 'hash ' ] : data . map ; } 
function get Native $ 1 ( object , key ) { var value = get Value $ 1 ( object , key ) ; return base Is Native $ 1 ( value ) ? value : undefined ; } 
function has Path ( object , path , has Func ) { path = is Key $ 1 ( path , object ) ? [ path ] : cast Path $ 1 ( path ) ; var result , index = - 1 , length = path . length ; while ( + + index < length ) { var key = to Key $ 1 ( path [ index ] ) ; if ( ! ( result = object ! = null & & has Func ( object , key ) ) ) { break ; } object = object [ key ] ; } if ( result ) { return result ; } var length = object ? object . length : 0 ; return ! ! length & & is Length ( length ) & & is Index ( key , length ) & & ( is Array $ 1 ( object ) | | is Arguments ( object ) ) ; } 
function is Key $ 1 ( value , object ) { if ( is Array $ 1 ( value ) ) { return false ; } var type = typeof value ; if ( type = = 'number ' | | type = = 'symbol ' | | type = = 'boolean ' | | value = = null | | is Symbol $ 1 ( value ) ) { return true ; } return re Is Plain Prop $ 1 . test ( value ) | | ! re Is Deep Prop $ 1 . test ( value ) | | ( object ! = null & & value in Object ( object ) ) ; } 
function to Key $ 1 ( value ) { if ( typeof value = = 'string ' | | is Symbol $ 1 ( value ) ) { return value ; } var result = ( value + ' ' ) ; return ( result = = ' 0 ' & & ( 1 / value ) = = - INFINITY $ 1 ) ? ' - 0 ' : result ; } 
function to Source $ 1 ( func ) { if ( func ! = null ) { try { return func To String $ 2 . call ( func ) ; } catch ( e ) { } try { return ( func + ' ' ) ; } catch ( e ) { } } return ' ' ; } 
function memoize $ 1 ( func , resolver ) { if ( typeof func ! = 'function ' | | ( resolver & & typeof resolver ! = 'function ' ) ) { throw new Type Error ( FUNC _ERROR _TEXT $ 1 ) ; } var memoized = function ( ) { var args = arguments , key = resolver ? resolver . apply ( this , args ) : args [ 0 ] , cache = memoized . cache ; if ( cache . has ( key ) ) { return cache . get ( key ) ; } var result = func . apply ( this , args ) ; memoized . cache = cache . set ( key , result ) ; return result ; } ; memoized . cache = new ( memoize $ 1 . Cache | | Map Cache $ 1 ) ; return memoized ; } 
function is Arguments ( value ) { 
function is Function $ 1 ( value ) { 
function is Host Object $ 3 ( value ) { 
function Hash $ 2 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( + + index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function hash Get $ 2 ( key ) { var data = this . _ _data _ _ ; if ( native Create $ 2 ) { var result = data [ key ] ; return result = = = HASH _UNDEFINED $ 2 ? undefined : result ; } return has Own Property $ 3 . call ( data , key ) ? data [ key ] : undefined ; } 
function hash Has $ 2 ( key ) { var data = this . _ _data _ _ ; return native Create $ 2 ? data [ key ] ! = = undefined : has Own Property $ 3 . call ( data , key ) ; } 
function hash Set $ 2 ( key , value ) { var data = this . _ _data _ _ ; data [ key ] = ( native Create $ 2 & & value = = = undefined ) ? HASH _UNDEFINED $ 2 : value ; return this ; } 
function List Cache $ 2 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( + + index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function list Cache Delete $ 2 ( key ) { var data = this . _ _data _ _ , index = assoc Index Of $ 2 ( data , key ) ; if ( index < 0 ) { return false ; } var last Index = data . length - 1 ; if ( index = = last Index ) { data . pop ( ) ; } else { splice $ 2 . call ( data , index , 1 ) ; } return true ; } 
function list Cache Get $ 2 ( key ) { var data = this . _ _data _ _ , index = assoc Index Of $ 2 ( data , key ) ; return index < 0 ? undefined : data [ index ] [ 1 ] ; } 
function list Cache Set $ 2 ( key , value ) { var data = this . _ _data _ _ , index = assoc Index Of $ 2 ( data , key ) ; if ( index < 0 ) { data . push ( [ key , value ] ) ; } else { data [ index ] [ 1 ] = value ; } return this ; } 
function Map Cache $ 2 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( + + index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function assign Value ( object , key , value ) { var obj Value = object [ key ] ; if ( ! ( has Own Property $ 3 . call ( object , key ) & & eq $ 2 ( obj Value , value ) ) | | ( value = = = undefined & & ! ( key in object ) ) ) { object [ key ] = value ; } } 
function assoc Index Of $ 2 ( array , key ) { var length = array . length ; while ( length - - ) { if ( eq $ 2 ( array [ length ] [ 0 ] , key ) ) { return length ; } } return - 1 ; } 
function base Is Native $ 2 ( value ) { if ( ! is Object $ 2 ( value ) | | is Masked $ 2 ( value ) ) { return false ; } var pattern = ( is Function $ 2 ( value ) | | is Host Object $ 3 ( value ) ) ? re Is Native $ 2 : re Is Host Ctor $ 2 ; return pattern . test ( to Source $ 2 ( value ) ) ; } 
function base Set ( object , path , value , customizer ) { if ( ! is Object $ 2 ( object ) ) { return object ; } path = is Key $ 2 ( path , object ) ? [ path ] : cast Path $ 2 ( path ) ; var index = - 1 , length = path . length , last Index = length - 1 , nested = object ; while ( nested ! = null & & + + index < length ) { var key = to Key $ 2 ( path [ index ] ) , new Value = value ; if ( index ! = last Index ) { var obj Value = nested [ key ] ; new Value = customizer ? customizer ( obj Value , key , nested ) : undefined ; if ( new Value = = = undefined ) { new Value = is Object $ 2 ( obj Value ) ? obj Value : ( is Index $ 1 ( path [ index + 1 ] ) ? [ ] : { } ) ; } } assign Value ( nested , key , new Value ) ; nested = nested [ key ] ; } return object ; } 
function base To String $ 2 ( value ) { 
function get Map Data $ 2 ( map , key ) { var data = map . _ _data _ _ ; return is Keyable $ 2 ( key ) ? data [ typeof key = = 'string ' ? 'string ' : 'hash ' ] : data . map ; } 
function get Native $ 2 ( object , key ) { var value = get Value $ 2 ( object , key ) ; return base Is Native $ 2 ( value ) ? value : undefined ; } 
function is Key $ 2 ( value , object ) { if ( is Array $ 2 ( value ) ) { return false ; } var type = typeof value ; if ( type = = 'number ' | | type = = 'symbol ' | | type = = 'boolean ' | | value = = null | | is Symbol $ 2 ( value ) ) { return true ; } return re Is Plain Prop $ 2 . test ( value ) | | ! re Is Deep Prop $ 2 . test ( value ) | | ( object ! = null & & value in Object ( object ) ) ; } 
function is Keyable $ 2 ( value ) { var type = typeof value ; return ( type = = 'string ' | | type = = 'number ' | | type = = 'symbol ' | | type = = 'boolean ' ) ? ( value ! = = ' _ _proto _ _ ' ) : ( value = = = null ) ; } 
function to Key $ 2 ( value ) { if ( typeof value = = 'string ' | | is Symbol $ 2 ( value ) ) { return value ; } var result = ( value + ' ' ) ; return ( result = = ' 0 ' & & ( 1 / value ) = = - INFINITY $ 2 ) ? ' - 0 ' : result ; } 
function to Source $ 2 ( func ) { if ( func ! = null ) { try { return func To String $ 3 . call ( func ) ; } catch ( e ) { } try { return ( func + ' ' ) ; } catch ( e ) { } } return ' ' ; } 
function memoize $ 2 ( func , resolver ) { if ( typeof func ! = 'function ' | | ( resolver & & typeof resolver ! = 'function ' ) ) { throw new Type Error ( FUNC _ERROR _TEXT $ 2 ) ; } var memoized = function ( ) { var args = arguments , key = resolver ? resolver . apply ( this , args ) : args [ 0 ] , cache = memoized . cache ; if ( cache . has ( key ) ) { return cache . get ( key ) ; } var result = func . apply ( this , args ) ; memoized . cache = cache . set ( key , result ) ; return result ; } ; memoized . cache = new ( memoize $ 2 . Cache | | Map Cache $ 2 ) ; return memoized ; } 
function is Function $ 2 ( value ) { 
function arr Copy ( arr , offset ) { offset = offset | | 0 ; var len = Math . max ( 0 , arr . length - offset ) ; var new Arr = new Array ( len ) ; for ( var ii = 0 ; ii < len ; ii + + ) { new Arr [ ii ] = arr [ ii + offset ] ; } return new Arr ; } 
function is ( value A , value B ) { if ( value A = = = value B | | ( value A ! = = value A & & value B ! = = value B ) ) { return true ; } if ( ! value A | | ! value B ) { return false ; } if ( typeof value A . value Of = = = 'function ' & & typeof value B . value Of = = = 'function ' ) { value A = value A . value Of ( ) ; value B = value B . value Of ( ) ; if ( value A = = = value B | | ( value A ! = = value A & & value B ! = = value B ) ) { return true ; } if ( ! value A | | ! value B ) { return false ; } } if ( typeof value A . equals = = = 'function ' & & typeof value B . equals = = = 'function ' & & value A . equals ( value B ) ) { return true ; } return false ; } 
function hash String ( string ) { 
function mixin ( ctor , methods ) { var key Copier = function ( key ) { ctor . prototype [ key ] = methods [ key ] ; } ; Object . keys ( methods ) . for Each ( key Copier ) ; Object . get Own Property Symbols & & Object . get Own Property Symbols ( methods ) . for Each ( key Copier ) ; return ctor ; } 
function ( ) { assert Not Infinite ( this . size ) ; var array = new Array ( this . size | | 0 ) ; this . value Seq ( ) . _ _iterate ( function ( v , i ) { array [ i ] = v ; } ) ; return array ; } 
function is String ( value ) { return typeof value = = 'string ' | | ( ! is Array $ 3 ( value ) & & is Object Like $ 4 ( value ) & & object To String $ 4 . call ( value ) = = string Tag ) ; } 
function is Function $ 3 ( value ) { if ( ! is Object $ 3 ( value ) ) { return false ; } 
function array Includes ( array , value ) { var length = array ? array . length : 0 ; return ! ! length & & base Index Of ( array , value , 0 ) > - 1 ; } 
function base Index Of ( array , value , from Index ) { if ( value ! = = value ) { return base Find Index ( array , base Is Na N , from Index ) ; } var index = from Index - 1 , length = array . length ; while ( + + index < length ) { if ( array [ index ] = = = value ) { return index ; } } return - 1 ; } 
function count Holders ( array , placeholder ) { var length = array . length , result = 0 ; while ( length - - ) { if ( array [ length ] = = = placeholder ) { result + + ; } } return result ; } 
function is Host Object $ 4 ( value ) { 
function base Is Native $ 3 ( value ) { if ( ! is Object $ 4 ( value ) | | is Masked $ 3 ( value ) ) { return false ; } var pattern = ( is Function $ 4 ( value ) | | is Host Object $ 4 ( value ) ) ? re Is Native $ 3 : re Is Host Ctor $ 3 ; return pattern . test ( to Source $ 3 ( value ) ) ; } 
function create Recurry ( func , bitmask , wrap Func , placeholder , this Arg , partials , holders , arg Pos , ary , arity ) { var is Curry = bitmask & CURRY _FLAG , new Holders = is Curry ? holders : undefined , new Holders Right = is Curry ? undefined : holders , new Partials = is Curry ? partials : undefined , new Partials Right = is Curry ? undefined : partials ; bitmask | = ( is Curry ? PARTIAL _FLAG : PARTIAL _RIGHT _FLAG ) ; bitmask & = ~ ( is Curry ? PARTIAL _RIGHT _FLAG : PARTIAL _FLAG ) ; if ( ! ( bitmask & CURRY _BOUND _FLAG ) ) { bitmask & = ~ ( BIND _FLAG | BIND _KEY _FLAG ) ; } var result = wrap Func ( func , bitmask , this Arg , new Partials , new Holders , new Partials Right , new Holders Right , arg Pos , ary , arity ) ; result . placeholder = placeholder ; return set Wrap To String ( result , func , bitmask ) ; } 
function get Native $ 3 ( object , key ) { var value = get Value $ 3 ( object , key ) ; return base Is Native $ 3 ( value ) ? value : undefined ; } 
function insert Wrap Details ( source , details ) { var length = details . length , last Index = length - 1 ; details [ last Index ] = ( length > 1 ? ' & ' : ' ' ) + details [ last Index ] ; details = details . join ( length > 2 ? ' , ' : ' ' ) ; return source . replace ( re Wrap Comment , ' { \n / * [wrapped with ' + details + ' ] * / \n ' ) ; } 
function to Source $ 3 ( func ) { if ( func ! = null ) { try { return func To String $ 4 . call ( func ) ; } catch ( e ) { } try { return ( func + ' ' ) ; } catch ( e ) { } } return ' ' ; } 
function is Function $ 4 ( value ) { 
function to Finite ( value ) { if ( ! value ) { return value = = = 0 ? value : 0 ; } value = to Number ( value ) ; if ( value = = = INFINITY $ 3 | | value = = = - INFINITY $ 3 ) { var sign = ( value < 0 ? - 1 : 1 ) ; return sign * MAX _INTEGER ; } return value = = = value ? value : 0 ; } 
function to Number ( value ) { if ( typeof value = = 'number ' ) { return value ; } if ( is Symbol $ 3 ( value ) ) { return NAN ; } if ( is Object $ 4 ( value ) ) { var other = typeof value . value Of = = 'function ' ? value . value Of ( ) : value ; value = is Object $ 4 ( other ) ? ( other + ' ' ) : other ; } if ( typeof value ! = 'string ' ) { return value = = = 0 ? value : + value ; } value = value . replace ( re Trim , ' ' ) ; var is Binary = re Is Binary . test ( value ) ; return ( is Binary | | re Is Octal . test ( value ) ) ? free Parse Int ( value . slice ( 2 ) , is Binary ? 2 : 8 ) : ( re Is Bad Hex . test ( value ) ? NAN : + value ) ; } 
function array Like Keys ( value , inherited ) { 
function assign In Defaults ( obj Value , src Value , key , object ) { if ( obj Value = = = undefined | | ( eq $ 3 ( obj Value , object Proto $ 7 [ key ] ) & & ! has Own Property $ 6 . call ( object , key ) ) ) { return src Value ; } return obj Value ; } 
function assign Value $ 1 ( object , key , value ) { var obj Value = object [ key ] ; if ( ! ( has Own Property $ 6 . call ( object , key ) & & eq $ 3 ( obj Value , value ) ) | | ( value = = = undefined & & ! ( key in object ) ) ) { object [ key ] = value ; } } 
function base Keys In ( object ) { if ( ! is Object $ 5 ( object ) ) { return native Keys In ( object ) ; } var is Proto = is Prototype ( object ) , result = [ ] ; for ( var key in object ) { if ( ! ( key = = 'constructor ' & & ( is Proto | | ! has Own Property $ 6 . call ( object , key ) ) ) ) { result . push ( key ) ; } } return result ; } 
function base Rest ( func , start ) { start = native Max $ 1 ( start = = = undefined ? ( func . length - 1 ) : start , 0 ) ; return function ( ) { var args = arguments , index = - 1 , length = native Max $ 1 ( args . length - start , 0 ) , array = Array ( length ) ; while ( + + index < length ) { array [ index ] = args [ start + index ] ; } index = - 1 ; var other Args = Array ( start + 1 ) ; while ( + + index < start ) { other Args [ index ] = args [ index ] ; } other Args [ start ] = array ; return apply $ 1 ( func , this , other Args ) ; } ; } 
function is Index $ 3 ( value , length ) { length = length = = null ? MAX _SAFE _INTEGER $ 3 : length ; return ! ! length & & ( typeof value = = 'number ' | | re Is Uint $ 3 . test ( value ) ) & & ( value > - 1 & & value % 1 = = 0 & & value < length ) ; } 
function is Iteratee Call ( value , index , object ) { if ( ! is Object $ 5 ( object ) ) { return false ; } var type = typeof index ; if ( type = = 'number ' ? ( is Array Like $ 1 ( object ) & & is Index $ 3 ( index , object . length ) ) : ( type = = 'string ' & & index in object ) ) { return eq $ 3 ( object [ index ] , value ) ; } return false ; } 
function is Prototype ( value ) { var Ctor = value & & value . constructor , proto = ( typeof Ctor = = 'function ' & & Ctor . prototype ) | | object Proto $ 7 ; return value = = = proto ; } 
function is Arguments $ 1 ( value ) { 
function is Function $ 5 ( value ) { 
function get Raw Tag $ 1 ( value ) { var is Own = has Own Property $ 7 . call ( value , sym To String Tag $ 1 ) , tag = value [ sym To String Tag $ 1 ] ; try { value [ sym To String Tag $ 1 ] = undefined ; } catch ( e ) { } var result = native Object To String $ 1 . call ( value ) ; { if ( is Own ) { value [ sym To String Tag $ 1 ] = tag ; } else { delete value [ sym To String Tag $ 1 ] ; } } return result ; } 
function base Get Tag $ 1 ( value ) { if ( value = = null ) { return value = = = undefined ? undefined Tag $ 1 : null Tag $ 1 ; } return ( sym To String Tag $ 2 & & sym To String Tag $ 2 in Object ( value ) ) ? _get Raw Tag ( value ) : _object To String ( value ) ; } 
function is Key $ 3 ( value , object ) { if ( is Array _ 1 ( value ) ) { return false ; } var type = typeof value ; if ( type = = 'number ' | | type = = 'symbol ' | | type = = 'boolean ' | | value = = null | | is Symbol _ 1 ( value ) ) { return true ; } return re Is Plain Prop $ 3 . test ( value ) | | ! re Is Deep Prop $ 3 . test ( value ) | | ( object ! = null & & value in Object ( object ) ) ; } 
function is Function $ 6 ( value ) { if ( ! is Object _ 1 ( value ) ) { return false ; } 
function to Source $ 4 ( func ) { if ( func ! = null ) { try { return func To String $ 5 . call ( func ) ; } catch ( e ) { } try { return ( func + ' ' ) ; } catch ( e ) { } } return ' ' ; } 
function base Is Native $ 4 ( value ) { if ( ! is Object _ 1 ( value ) | | _is Masked ( value ) ) { return false ; } var pattern = is Function _ 1 ( value ) ? re Is Native $ 4 : re Is Host Ctor $ 4 ; return pattern . test ( _to Source ( value ) ) ; } 
function get Native $ 4 ( object , key ) { var value = _get Value ( object , key ) ; return _base Is Native ( value ) ? value : undefined ; } 
function hash Delete $ 3 ( key ) { var result = this . has ( key ) & & delete this . _ _data _ _ [ key ] ; this . size - = result ? 1 : 0 ; return result ; } 
function hash Get $ 3 ( key ) { var data = this . _ _data _ _ ; if ( _native Create ) { var result = data [ key ] ; return result = = = HASH _UNDEFINED $ 3 ? undefined : result ; } return has Own Property $ 9 . call ( data , key ) ? data [ key ] : undefined ; } 
function hash Has $ 3 ( key ) { var data = this . _ _data _ _ ; return _native Create ? ( data [ key ] ! = = undefined ) : has Own Property $a . call ( data , key ) ; } 
function hash Set $ 3 ( key , value ) { var data = this . _ _data _ _ ; this . size + = this . has ( key ) ? 0 : 1 ; data [ key ] = ( _native Create & & value = = = undefined ) ? HASH _UNDEFINED $ 4 : value ; return this ; } 
function Hash $ 3 ( entries ) { var index = - 1 , length = entries = = null ? 0 : entries . length ; this . clear ( ) ; while ( + + index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function assoc Index Of $ 3 ( array , key ) { var length = array . length ; while ( length - - ) { if ( eq _ 1 ( array [ length ] [ 0 ] , key ) ) { return length ; } } return - 1 ; } 
function list Cache Delete $ 3 ( key ) { var data = this . _ _data _ _ , index = _assoc Index Of ( data , key ) ; if ( index < 0 ) { return false ; } var last Index = data . length - 1 ; if ( index = = last Index ) { data . pop ( ) ; } else { splice $ 3 . call ( data , index , 1 ) ; } - - this . size ; return true ; } 
function list Cache Get $ 3 ( key ) { var data = this . _ _data _ _ , index = _assoc Index Of ( data , key ) ; return index < 0 ? undefined : data [ index ] [ 1 ] ; } 
function list Cache Set $ 3 ( key , value ) { var data = this . _ _data _ _ , index = _assoc Index Of ( data , key ) ; if ( index < 0 ) { + + this . size ; data . push ( [ key , value ] ) ; } else { data [ index ] [ 1 ] = value ; } return this ; } 
function List Cache $ 3 ( entries ) { var index = - 1 , length = entries = = null ? 0 : entries . length ; this . clear ( ) ; while ( + + index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function is Keyable $ 3 ( value ) { var type = typeof value ; return ( type = = 'string ' | | type = = 'number ' | | type = = 'symbol ' | | type = = 'boolean ' ) ? ( value ! = = ' _ _proto _ _ ' ) : ( value = = = null ) ; } 
function get Map Data $ 3 ( map , key ) { var data = map . _ _data _ _ ; return _is Keyable ( key ) ? data [ typeof key = = 'string ' ? 'string ' : 'hash ' ] : data . map ; } 
function map Cache Set $ 3 ( key , value ) { var data = _get Map Data ( this , key ) , size = data . size ; data . set ( key , value ) ; this . size + = data . size = = size ? 0 : 1 ; return this ; } 
function Map Cache $ 3 ( entries ) { var index = - 1 , length = entries = = null ? 0 : entries . length ; this . clear ( ) ; while ( + + index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function base To String $ 3 ( value ) { 
function cast Path $ 3 ( value , object ) { if ( is Array _ 1 ( value ) ) { return value ; } return _is Key ( value , object ) ? [ value ] : _string To Path ( to String _ 1 ( value ) ) ; } 
function to Key $ 3 ( value ) { if ( typeof value = = 'string ' | | is Symbol _ 1 ( value ) ) { return value ; } var result = ( value + ' ' ) ; return ( result = = ' 0 ' & & ( 1 / value ) = = - INFINITY $ 5 ) ? ' - 0 ' : result ; } 
function get $ 2 ( object , path , default Value ) { var result = object = = null ? undefined : _base Get ( object , path ) ; return result = = = undefined ? default Value : result ; } 
function drop DB ( ) { nano . db . destroy ( name DB , function ( err ) { if ( err & & err . status Code ! = 4 0 4 ) { logger _ 1 . logger . log ( 'error ' , ` $ { name DB } \n ` ) ; throw err ; } nano . db . create ( name DB , function ( err ) { if ( err ) { logger _ 1 . logger . log ( 'error ' , ` $ { name DB } \n ` ) ; throw err ; } logger _ 1 . logger . log ( 'success ' , ` $ { name DB } \n ` ) ; if ( program . test ) { 
function dump Load Option ( ) { let p = new Promise ( ( resolve , reject ) = > { let file = jsonfile . read File Sync ( program . dumpload ) ; let file Content = [ ] ; if ( file . has Own Property ( "rows " ) & & file . rows instanceof Object & & file ) { if ( ! Array . is Array ( file . rows ) ) file Content . push ( file . rows ) ; else file Content = file . rows ; } else if ( Array . is Array ( file ) ) file Content = file ; else logger _ 1 . logger . log ( 'warn ' , ` ` ) ; if ( file Content . length > 0 ) { logger _ 1 . logger . log ( 'info ' , ` $ { program . dumpload } ` ) ; store Job ( file Content ) . on ( 'store Done ' , ( ) = > { logger _ 1 . logger . log ( 'success ' , ` $ { program . dumpload } $ { name DB } \n ` ) ; resolve ( ) ; } ) . on ( 'store Error ' , ( err ) = > { logger _ 1 . logger . log ( 'error ' , ` $ { program . dumpload } \n $ { err } ` ) ; reject ( ) ; } ) ; } else { logger _ 1 . logger . log ( 'warn ' , ` ` ) ; reject ( ) ; } } ) ; return p ; } 
function indexation Option ( ) { return new Promise ( ( resolve , reject ) = > { logger _ 1 . logger . log ( 'info ' , ` ` ) ; indexation ( config Content . previous Cache Dir ) . on ( 'index Done ' , ( ) = > { logger _ 1 . logger . log ( 'success ' , ` \n ` ) ; resolve ( ) ; } ) . on ( 'index Error ' , ( err ) = > { logger _ 1 . logger . log ( 'error ' , ` $ { err } ` ) ; reject ( err ) ; } ) ; } ) ; } 
function dump Option ( ) { return new Promise ( ( resolve , reject ) = > { dumping Database ( ) . on ( 'dump Done ' , ( ) = > { resolve ( ) ; } ) . on ( 'dump Failed ' , ( err ) = > { reject ( err ) ; } ) ; } ) ; } 
function dumping Database ( test Dump = false ) { let dump Emitter = new Event Emitter ( ) ; let wstream ; if ( test Dump ) { wstream = fs . create Write Stream ( ` $ { name DB } ` ) ; } else { wstream = fs . create Write Stream ( ` $ { name DB } ` ) ; } let chunk Res = ' ' ; let chunk Error = ' ' ; let curl ; if ( proxy Bool ) { curl = child _process _ 1 . spawn ( 'curl ' , [ ' - -noproxy ' , ` $ { address DB } ` , ` ` , ` ` , ` $ { account DB } $ { password DB } $ { address DB } $ { port DB } $ { name DB } ` ] ) ; } else { curl = child _process _ 1 . spawn ( 'curl ' , [ ` ` , ` ` , ` $ { account DB } $ { password DB } $ { address DB } $ { port DB } $ { name DB } ` ] ) ; } curl . stdout . on ( 'data ' , ( data ) = > { chunk Res + = data . to String ( 'utf 8 ' ) ; } ) ; curl . stderr . on ( 'data ' , ( data ) = > { chunk Error + = data . to String ( 'utf 8 ' ) ; } ) ; curl . on ( 'close ' , ( code ) = > { let split = chunk Error . replace ( / ( \r \n \t | \n | \r \t ) / gm , " " ) . split ( " " ) ; if ( chunk Error . length > 0 & & chunk Res . length = = = 0 ) { logger _ 1 . logger . log ( 'error ' , ` $ { name DB } \n $ { chunk Error } ` ) ; } else { try { wstream . write ( chunk Res ) ; if ( test Dump ) logger _ 1 . logger . log ( 'success ' , ` $ { name DB } $ { name DB } ` ) ; else logger _ 1 . logger . log ( 'success ' , ` $ { name DB } $ { name DB } ` ) ; dump Emitter . emit ( 'dump Done ' ) ; } catch ( err ) { logger _ 1 . logger . log ( 'error ' , ` $ { name DB } \n $ { err } ` ) ; dump Emitter . emit ( 'dump Failed ' , err ) ; } } } ) ; return dump Emitter ; } 
function constraints Call ( constraints , connect Type ) { let emitter Call = new Event Emitter ( ) ; 
function indexation ( cache Array ) { let emitter Index = new Event Emitter ( ) ; let path Result = glob Caches ( cache Array ) ; 
function glob Caches ( paths Array ) { let deep Index = [ ] ; let merged Index ; 
function directory Search ( directory Path ) { let uuidregex V 4 = / [ 0 - 9a -f ] { 8 } - [ 0 - 9a -f ] { 4 } - [ 1 - 5 ] [ 0 - 9a -f ] { 3 } - [ 8 9ab ] [ 0 - 9a -f ] { 3 } - [ 0 - 9a -f ] { 1 2 } / ig ; let uuid Array = directory Path . match ( uuidregex V 4 ) ; let uuid Dir = null ; logger _ 1 . logger . log ( 'debug ' , ` \n $ { JSON . stringify ( uuid Array ) } ` ) ; if ( uuid Array ! = null ) { uuid Dir = uuid Array . pop ( ) ; 
function extract Doc ( path , uuid ) { let file ; if ( typeof ( path ) ! = = 'string ' ) { logger _ 1 . logger . log ( 'warn ' , ` \n $ { path } ` ) ; } try { file = jsonfile . read File Sync ( path ) ; } catch ( err ) { logger _ 1 . logger . log ( 'warn ' , ` $ { path } \n $ { err } ` ) ; return null ; } return file ; } 
function constraints To Query ( constraints , either = false ) { let const Emitter = new Event Emitter ; let query = { "selector " : { } } ; let str Constr = JSON . stringify ( constraints ) ; let sel = query . selector ; if ( str Constr = = = JSON . stringify ( { } ) | | str Constr = = = JSON . stringify ( [ ] ) ) { let error = 'Empty constraints json or array given ' ; logger _ 1 . logger . log ( 'warn ' , error ) ; const Emitter . emit ( 'error On Constraints ' ) ; return const Emitter ; } 
function store Job ( job ) { let store Emitter = new Event Emitter ( ) ; db Mod . add To DB ( job , name DB , account DB , password DB , address DB , port DB , proxy Bool ) . then ( ( ) = > { if ( Array . is Array ( job ) ) { logger _ 1 . logger . log ( 'success ' , ` $ { job . length } $ { name DB } ` ) ; } else logger _ 1 . logger . log ( 'success ' , ` $ { name DB } ` ) ; store Emitter . emit ( 'store Done ' ) ; } ) . catch ( ( err ) = > { store Emitter . emit ( 'store Error ' , err ) ; } ) ; return store Emitter ; } 
function ( save Path , consolidate , use Dot Notation , file Prefix , consolidate All ) { this . save Path = save Path | | ' ' ; this . consolidate = consolidate = = = jasmine . undefined ? true : consolidate ; this . consolidate All = consolidate All = = = jasmine . undefined ? false : consolidate All ; this . use Dot Notation = use Dot Notation = = = jasmine . undefined ? true : use Dot Notation ; this . file Prefix = file Prefix | | ( this . consolidate All ? 'junitresults ' : 'TEST - ' ) ; } 
function delete Cache For Constructor ( constr ) { for ( var i in inheritance Chain ) { if ( inheritance Chain . has Own Property ( i ) ) { if ( inheritance Chain [ i ] . index Of ( constr . _ _get _protolib _id _ _ ) > - 1 ) { cached [ i ] = undefined ; delete cached [ i ] ; inheritance Chain [ i ] = undefined ; delete inheritance Chain [ i ] ; } } } return self ; } 
function attach Library To Self ( ) { for ( var i in libs ) if ( libs . has Own Property ( i ) & & ! self [ i ] ) self [ i ] = libs [ i ] ; return self ; } 
function apply Library To Prototypes ( ) { if ( ! attached ) { Object . define Property ( Object . prototype , handle , { configurable : true , enumerable : false , 
function ( v ) { if ( this [ handle ] ! = = v ) { Object . define Property ( this , handle , { configurable : true , enumerable : true , writable : true , value : v } ) ; } } 
function ( ) { var cc Id , proto = get Proto ( this ) , c Id = proto . constructor . _ _get _protolib _id _ _ , lib = { } , i = 0 , last = null , m ; current This = this ; do { cc Id = proto . constructor . _ _get _protolib _id _ _ ; if ( cached [ cc Id ] & & i = = = 0 ) { return cached [ cc Id ] ; } else if ( cached [ cc Id ] ) { for ( m in cached [ cc Id ] ) if ( cached [ cc Id ] . has Own Property ( m ) ) lib [ m ] = cached [ cc Id ] [ m ] ; if ( ! inheritance Chain [ c Id ] ) inheritance Chain [ c Id ] = [ ] ; inheritance Chain [ c Id ] = inheritance Chain [ cc Id ] . concat ( inheritance Chain [ c Id ] ) ; cached [ c Id ] = lib ; return lib ; } else { if ( ! libp [ cc Id ] ) libp [ cc Id ] = { } ; for ( m in libp [ cc Id ] ) if ( libp [ cc Id ] . has Own Property ( m ) ) lib [ m ] = libp [ cc Id ] [ m ] ; if ( ! inheritance Chain [ cc Id ] ) inheritance Chain [ cc Id ] = [ ] ; inheritance Chain [ c Id ] . unshift ( cc Id ) ; cached [ c Id ] = lib ; last = cc Id ; } + + i ; } while ( proto = get Proto ( proto ) ) ; 
function remove Library From Prototypes ( ) { Object . define Property ( Object . prototype , handle , { value : undefined } ) ; delete Object . prototype [ handle ] ; attached = false ; return self ; } 
function get This Value And Invoke ( callback ) { return callback ( current This ! = = undefined & & current This ! = = null ? ( typeof current This = = = 'object ' ? current This : current This . value Of ( ) ) : current This ) ; } 
function create ( props ) { var button = Object . create ( this ) ; _canvas Widget 2 . default . create . call ( button ) ; Object . assign ( button , Button . defaults , props ) ; if ( props . value ) button . _ _value = props . value ; button . init ( ) ; return button ; } 
function draw ( ) { this . ctx . fill Style = this . _ _value = = = 1 ? this . fill : this . background ; this . ctx . stroke Style = this . stroke ; this . ctx . line Width = this . line Width ; this . ctx . fill Rect ( 0 , 0 , this . rect . width , this . rect . height ) ; this . ctx . stroke Rect ( 0 , 0 , this . rect . width , this . rect . height ) ; } 
function add To DB ( data , name DB , account Name , password DB , address DB , port DB , proxy Bool ) { return _ _awaiter ( this , void 0 , void 0 , function * ( ) { let doc List = Array . is Array ( data ) ? data : [ data ] ; let array Data = doc List . length > 5 0 0 ? array Split ( doc List , 5 0 0 ) : doc List ; for ( let elem of array Data ) { let add Obj = new add Data ( elem , name DB , account Name , password DB , address DB , port DB , proxy Bool ) ; yield add Obj . three _curl ( ) ; } ; } ) ; } 
function bind Property ( o , parent , prop ) { Object . define Property ( o , prop , { get : function ( ) { try { return parent [ prop ] ; } catch ( e ) { } } , set : function ( val ) { try { parent [ prop ] = val ; } catch ( e ) { } } , configurable : true } ) ; } 
function iterate Properties ( _sub , _super ) { var props = Object . get Own Property Names ( _super ) , proto ; _sub . _ _proto _ _ = _super ; 
function get Keys ( o ) { switch ( typeof o ) { case 'object ' : return o ? Object . keys ( o ) : [ ] ; case 'string ' : var keys = [ ] ; for ( var i = 0 ; i < o . length ; i + + ) keys . push ( i . to String ( ) ) ; return keys ; default : return [ ] ; } } 
function camelize ( ) { var ret = [ ] ; libs . object . every ( arguments , function ( s ) { if ( s ) { if ( typeof s = = = 'function ' ) s = fix Firefox Function String ( s . to String ( ) ) ; s = s . to String ( ) . replace ( / [ ^a -z 0 - 9 $ ] / gi , ' _ ' ) . replace ( / \ $ ( \w ) / g , ' $ _ $ 1 ' ) . split ( / [ \s _ ] + / g ) ; libs . object . each ( s , 1 , s . length , function ( i , k ) { this [ k ] = libs . string . uc First ( i ) ; } ) ; s = libs . string . lc First ( s . join ( ' ' ) ) ; } ret . push ( s ) ; } ) ; return ret . length = = = 1 ? ret [ 0 ] : ret ; } 
function decamelize ( ) { var ret = [ ] ; libs . object . every ( arguments , function ( s ) { if ( s ) { if ( typeof s = = = 'function ' ) s = fix Firefox Function String ( s . to String ( ) ) ; s = s . to String ( ) . replace ( / ( [A -Z $ ] ) / g , function ( $ ) { return ' ' + ( typeof $ = = = 'string ' ? $ . to Lower Case ( ) : ' ' ) ; } ) . replace ( / function \ ( \ ) / g , 'function ( ) ' ) ; } ret . push ( typeof s = = = 'string ' ? s . trim ( ) : s ) ; } ) ; return ret . length = = = 1 ? ret [ 0 ] : ret ; } 
function difference From String ( s , other ) { if ( typeof other ! = = 'string ' | | typeof s ! = = 'string ' ) return s ; var sarr = s . split ( ' ' ) , oarr = other . split ( ' ' ) ; return libs . array . difference ( sarr , oarr ) . join ( ' ' ) ; } 
function intersect String ( s , other ) { if ( typeof other ! = = 'string ' | | typeof s ! = = 'string ' ) return s ; var sarr = s . split ( ' ' ) , oarr = other . split ( ' ' ) ; return libs . array . intersect ( sarr , oarr ) . join ( ' ' ) ; } 
function repeat ( s , times ) { times = parse Int ( times , 1 0 ) ; times = is Na N ( times ) | | ! is Finite ( times ) | | times < = 0 ? 1 : times ; var os = s ; for ( var i = 1 ; i < times ; i + + ) s + = os ; return s ; } 
function rtrim ( s , what ) { what = typeof what = = = 'string ' ? what : ' \ \s + ' ; return s . replace ( new Reg Exp ( what + ' $ ' ) , ' ' ) ; } 
function ltrim ( s , what ) { what = typeof what = = = 'string ' ? what : ' \ \s + ' ; return s . replace ( new Reg Exp ( ' ^ ' + what ) , ' ' ) ; } 
function title Case ( s ) { var arr = [ ] ; libs . object . each ( s . split ( ' ' ) , function ( t ) { arr . push ( libs . string . uc First ( t ) ) ; } ) ; return arr . join ( ' ' ) ; } 
function splice ( s , index , count , add ) { return s . slice ( 0 , index ) + ( add | | ' ' ) + s . slice ( index + count ) ; } 
function ellipses _ ( s , length , place , ellipses ) { if ( is Na N ( parse Int ( length , 1 0 ) ) ) length = s . length ; if ( length < 0 | | ! is Finite ( length ) ) length = 0 ; ellipses = typeof ellipses = = = 'string ' ? ellipses : ' . . . ' ; if ( s . length < = length ) return s ; if ( length < = ellipses . length ) { return ellipses . substring ( 0 , length ) ; } else if ( ! place | | place ! = = 'front ' ) { return s . substr ( 0 , length - ellipses . length ) + ellipses ; } else { return ellipses + s . substr ( 0 , length - ellipses . length ) ; } } 
function shuffle ( s , splitter ) { var a = s . split ( typeof splitter = = = 'string ' ? splitter : ' ' ) , n = a . length , replace Splits = n - 1 ; for ( var i = n - 1 ; i > 0 ; i - - ) { var j = Math . floor ( Math . random ( ) * ( i + 1 ) ) , tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; } for ( var k = 0 ; k < replace Splits ; k + + ) a . splice ( libs . number . random Int In Range ( 0 , a . length ) , 0 , splitter ) ; return a . join ( ' ' ) ; } 
function reverse ( s ) { if ( s . length < 6 4 ) { var str = ' ' ; for ( var i = s . length ; i > = 0 ; i - - ) str + = s . char At ( i ) ; return str ; } else { return s . split ( ' ' ) . reverse ( ) . join ( ' ' ) ; } } 
function without Trailing Slash ( s ) { if ( ! IS _BROWSER & & HAS _OS & & require ( 'os ' ) . platform = = = 'win 3 2 ' ) return s . replace ( / \ \ + $ / , ' ' ) ; return s . replace ( / \ / + $ / , ' ' ) ; } 
function with Trailing Slash ( s ) { if ( ! IS _BROWSER & & HAS _OS & & require ( 'os ' ) . platform = = = 'win 3 2 ' ) return libs . string . without Trailing Slash ( s ) + ' \ \ ' ; return libs . string . without Trailing Slash ( s ) + ' / ' ; } 
function pad ( s , length , delim , pre ) { var i , this Length = s . length ; if ( ! delim ) delim = ' ' ; if ( length = = = 0 ) return ' ' ; else if ( is Na N ( parse Int ( length , 1 0 ) ) ) return s ; length = parse Int ( length , 1 0 ) ; if ( length < this Length ) return ! pre ? s . slice ( 0 , length ) : s . slice ( - length ) ; if ( pre ) { for ( i = 0 ; i < length - this Length ; i + + ) s = delim + s ; } else { for ( i = 0 ; i < length - this Length ; i + + ) s + = delim ; } return s ; } 
function word Wrap To Length ( s , width , padleft , padright , omit First ) { if ( padright = = = undefined & & padleft ) padright = padleft ; padleft = ! is Na N ( parse Int ( padleft , 1 0 ) ) ? parse Int ( padleft , 1 0 ) : 0 ; padright = ! is Na N ( parse Int ( padright , 1 0 ) ) ? parse Int ( padright , 1 0 ) : 0 ; var padding Left = ' ' ; for ( var n = 0 ; n < padleft ; n + + ) padding Left + = ' ' ; var cols = ! is Na N ( parse Int ( width , 1 0 ) ) ? length : 1 2 0 , arr = s . split ( ' ' ) , item = null , len = ! omit First ? cols - padright - padleft : cols - padright , str = ! omit First ? padding Left : ' ' , olen = cols - padright - padleft ; while ( ( item = arr . shift ( ) ) ! = = undefined ) { if ( item . length < len ) { str + = item + ' ' ; len - = item . length + 1 ; } else if ( item . length > olen ) { str + = item . substring ( 0 , len - 1 ) + ' - \n ' + padding Left ; arr . unshift ( item . substring ( len , item . length - 1 ) ) ; len = cols - padright - padleft ; } else { str + = ' \n ' + padding Left + item + ' ' ; len = cols - padright - 1 - padleft - item . length ; } } return str ; } 
function advance Days ( d , days In The Future , adjust For Weekend ) { if ( ! ( d instanceof Date ) ) return d ; days In The Future = days In The Future & & libs . generic . is Numeric ( days In The Future ) ? days In The Future : 1 ; d . set Time ( d . get Time ( ) + ( days In The Future * 8 6 4 0 0 0 0 0 ) ) ; if ( adjust For Weekend & & ( d . get Day ( ) = = = 0 | | d . get Day ( ) = = = 6 ) ) { while ( d . get Day ( ) = = = 0 | | d . get Day ( ) = = = 6 ) d . set Time ( d . get Time ( ) + 8 6 4 0 0 0 0 0 ) ; } return d ; } 
function advance Months ( d , months In The Future , adjust For Weekend ) { if ( ! ( d instanceof Date ) ) return d ; months In The Future = months In The Future & & libs . generic . is Numeric ( months In The Future ) ? months In The Future : 1 ; d . set Time ( d . get Time ( ) + ( months In The Future * 2 6 2 9 7 4 6 0 0 0 ) ) ; if ( adjust For Weekend & & ( d . get Day ( ) = = = 0 | | d . get Day ( ) = = = 6 ) ) { while ( d . get Day ( ) = = = 0 | | d . get Day ( ) = = = 6 ) d . set Time ( d . get Time ( ) + 8 6 4 0 0 0 0 0 ) ; } return d ; } 
function advance Years ( d , years In The Future , adjust For Weekend ) { if ( ! ( d instanceof Date ) ) return d ; years In The Future = years In The Future & & libs . generic . is Numeric ( years In The Future ) ? years In The Future : 1 ; d . set Time ( d . get Time ( ) + ( years In The Future * 3 1 5 3 6 0 0 0 0 0 0 ) ) ; if ( adjust For Weekend & & ( d . get Day ( ) = = = 0 | | d . get Day ( ) = = = 6 ) ) { while ( d . get Day ( ) = = = 0 | | d . get Day ( ) = = = 6 ) d . set Time ( d . get Time ( ) + 8 6 4 0 0 0 0 0 ) ; } return d ; } 
function yyyymmdd ( d , delim ) { if ( ! ( d instanceof Date ) ) return d ; delim = typeof delim ! = = 'string ' ? ' - ' : delim ; var dd = d . get Date ( ) , mm = d . get Month ( ) + 1 , yyyy = d . get Full Year ( ) ; if ( dd < 1 0 ) dd = ' 0 ' + dd ; if ( mm < 1 0 ) mm = ' 0 ' + mm ; return yyyy + delim + mm + delim + dd ; } 
function clock Time ( d , omit MS ) { if ( ! ( d instanceof Date ) ) return d ; return libs . number . clock Time ( d . get Time ( ) , ! ! omit MS ) ; } 
function ( n , placeholder ) { if ( n = = = undefined | | n = = = null | | ! libs . object . is Numeric ( n ) ) return n ; placeholder = typeof placeholder = = = 'string ' ? placeholder : ' . ' ; var rest , idx , int , ns = n . to String ( ) , neg = n < 0 ; idx = ns . index Of ( ' . ' ) ; int = parse Int ( Math . abs ( n ) , 1 0 ) . to String ( ) ; if ( idx > - 1 ) rest = ' . ' + ns . substring ( idx + 1 , ns . length ) ; return ( neg ? ' - ' : ' ' ) + libs . string . reverse ( libs . string . reverse ( int ) . replace ( / ( \d { 3 } ) ( ? ! $ ) / g , ' $ 1 , ' ) ) + ( rest | | ' ' ) ; } 
function ( n , symbol ) { if ( n = = = undefined | | n = = = null | | ! libs . object . is Numeric ( n ) ) return n ; n = libs . object . get Numeric ( n ) . to Fixed ( 2 ) ; symbol = typeof symbol = = = 'string ' ? symbol : ' $ ' ; return n . replace ( / ^ ( - ) ? ( \d + ) \ . ( \d + ) $ / , function ( $ 0 , $ 1 , $ 2 , $ 3 ) { $ 1 = $ 2 = = = ' 0 ' & & $ 3 = = = ' 0 0 ' ? null : $ 1 ; return ( $ 1 | | ' ' ) + symbol + libs . number . with Placeholders ( $ 2 ) + ' . ' + $ 3 ; } ) ; } 
function ( min , max ) { min = parse Int ( min , 1 0 ) ; max = parse Int ( max , 1 0 ) ; if ( is Na N ( min ) & & ! is Finite ( min ) ) min = 0 ; if ( is Na N ( max ) & & ! is Finite ( max ) ) max = Number . MAX _VALUE ; return Math . floor ( Math . random ( ) * ( max - min + 1 ) ) + min ; } 
function ( min , max ) { min = parse Float ( min ) ; max = parse Float ( max ) ; if ( is Na N ( min ) & & ! is Finite ( min ) ) min = 0 ; if ( is Na N ( max ) & & ! is Finite ( max ) ) max = Number . MAX _VALUE ; return Math . random ( ) * ( max - min ) + min ; } 
function factorial ( n ) { if ( typeof n ! = = 'number ' | | n < 0 ) return Na N ; if ( n > 1 7 0 ) return Infinity ; if ( n = = = 0 | | n = = = 1 ) return 1 ; return n * factorial ( n - 1 ) ; } 
function is Int ( ) { return libs . object . every ( arguments , function ( n ) { return typeof n = = = 'number ' & & n % 1 = = = 0 & & n . to String ( ) . index Of ( ' . ' ) = = = - 1 ; } ) ; } 
function choose ( n , k ) { if ( typeof n ! = = 'number ' | | typeof k ! = = 'number ' ) return Na N ; if ( k = = = 0 ) return 1 ; return ( n * choose ( n - 1 , k - 1 ) ) / k ; } 
function pad ( n , length ) { return libs . string . pad ( n . to String ( ) , length , ' 0 ' , true ) ; } 
function days From ( n , date ) { if ( typeof date = = = 'number ' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . set Date ( date . get Date ( ) + n ) ; return date ; } 
function seconds From ( n , date ) { if ( typeof date = = = 'number ' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . set Seconds ( date . get Seconds ( ) + n ) ; return date ; } 
function years From ( n , date ) { if ( typeof date = = = 'number ' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . set Full Year ( date . get Full Year ( ) + n ) ; return date ; } 
function months From ( n , date ) { if ( typeof date = = = 'number ' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . set Month ( date . get Month ( ) + n ) ; return date ; } 
function hours From ( n , date ) { if ( typeof date = = = 'number ' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . set Hours ( date . get Hours ( ) + n ) ; return date ; } 
function minutes From ( n , date ) { if ( typeof date = = = 'number ' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . set Minutes ( date . get Minutes ( ) + n ) ; return date ; } 
function clock Time ( t , omit MS ) { var ms , secs , mins , hrs ; ms = t % 1 0 0 0 ; t = ( t - ms ) / 1 0 0 0 ; secs = t % 6 0 ; t = ( t - secs ) / 6 0 ; mins = t % 6 0 ; hrs = ( t - mins ) / 6 0 ; return libs . number . pad ( hrs . to String ( ) , 2 ) + ' : ' + libs . number . pad ( mins . to String ( ) , 2 ) + ' : ' + libs . number . pad ( secs . to String ( ) , 2 ) + ( ( omit MS = = = true ) ? ' ' : ' . ' + libs . number . pad ( ms . to String ( ) , 3 ) ) ; } 
function inherits ( constructor , super Constructor ) { if ( constructor = = = undefined | | constructor = = = null ) throw new Type Error ( 'The constructor to "inherits " must not be ' + 'null or undefined ' ) ; if ( super Constructor = = = undefined | | super Constructor = = = null ) throw new Type Error ( 'The super constructor to "inherits " must not ' + 'be null or undefined ' ) ; if ( super Constructor . prototype = = = undefined ) throw new Type Error ( 'The super constructor to "inherits " must ' + 'have a prototype ' ) ; constructor . super _ = super Constructor ; Object . set Prototype Of ( constructor . prototype , super Constructor . prototype ) ; 
function union ( a ) { var args = libs . object . only ( libs . object . to Array ( arguments ) , 'array ' ) ; var union = [ ] ; args . unshift ( a ) ; libs . object . each ( args , function ( array ) { libs . object . each ( array , function ( item ) { if ( union . index Of ( item ) = = = - 1 ) union . push ( item ) ; } ) ; } ) ; return union ; } 
function difference ( ) { var arrays = libs . object . only ( libs . object . to Array ( arguments ) , 'array ' ) , diff = [ ] , all Items = [ ] , i ; for ( i = 0 ; i < arrays . length ; i + + ) all Items = all Items . concat ( arrays [ i ] ) ; for ( i = 0 ; i < all Items . length ; i + + ) { var in Array = - 1 , unique = false ; for ( var n = 0 ; n < arrays . length ; n + + ) { if ( in Array = = = - 1 & & arrays [ n ] . index Of ( all Items [ i ] ) > - 1 ) { in Array = n ; unique = true ; } else if ( in Array ! = = - 1 & & arrays [ n ] . index Of ( all Items [ i ] ) > - 1 ) { in Array = n ; unique = false ; } } if ( in Array ! = = - 1 & & unique ) diff . push ( all Items [ i ] ) ; } return diff ; } 
function intersect ( ) { var arrays = libs . object . only ( libs . object . to Array ( arguments ) , 'array ' ) ; if ( arrays . length = = = 0 ) return [ ] ; if ( arrays . length = = = 1 ) return libs . object . copy ( arrays [ 0 ] ) ; var intersection = arrays [ 0 ] , intermediate = [ ] ; for ( var i = 1 ; i < arrays . length ; i + + ) { var arr = libs . object . copy ( arrays [ i ] ) ; 
function without ( ) { var args = libs . object . to Array ( arguments ) , a = args . shift ( ) , res = [ ] ; if ( ! ( a instanceof Array ) ) return a ; libs . object . each ( a , function ( v ) { if ( args . index Of ( v ) = = = - 1 ) res . push ( v ) ; } ) ; return res ; } 
function rotate ( a , direction , amount ) { if ( ! ( a instanceof Array ) ) return a ; if ( direction & & libs . object . is Numeric ( direction ) & & ! amount ) { amount = direction ; direction = undefined ; } if ( ! amount | | ( amount & & ! libs . object . is Numeric ( amount ) ) ) amount = 1 ; for ( var i = 0 ; i < amount ; i + + ) { if ( direction ! = = 'right ' ) a . push ( a . shift ( ) ) ; else a . unshift ( a . pop ( ) ) ; } return a ; } 
function rotate Left ( a , amount ) { if ( ! ( a instanceof Array ) ) return a ; return libs . array . rotate ( a , 'left ' , amount ) ; } 
function make Unique ( a ) { if ( ! ( a instanceof Array ) ) return a ; var visited = [ ] ; for ( var i = 0 ; i < a . length ; i + + ) { if ( visited . index Of ( a [ i ] ) = = = - 1 ) { visited . push ( a [ i ] ) ; } else { a . splice ( i , 1 ) ; i - - ; 
function unique ( a ) { if ( ! ( a instanceof Array ) ) return a ; var visited = [ ] , unique = [ ] ; libs . object . each ( a , function ( item ) { if ( visited . index Of ( item ) = = = - 1 ) { unique . push ( item ) ; visited . push ( item ) ; } } ) ; return unique ; } 
function ascending ( a ) { if ( ! ( a instanceof Array ) ) return a ; return a . sort ( function ( a , b ) { if ( a ! = = undefined & & a ! = = null ) a = a . to String ( ) ; if ( b ! = = undefined & & b ! = = null ) b = b . to String ( ) ; return a < b ? - 1 : a > b ? 1 : 0 ; } ) ; } 
function descending ( a ) { if ( ! ( a instanceof Array ) ) return a ; return a . sort ( function ( a , b ) { if ( a ! = = undefined & & a ! = = null ) a = a . to String ( ) ; if ( b ! = = undefined & & b ! = = null ) b = b . to String ( ) ; return a > b ? - 1 : a < b ? 1 : 0 ; } ) ; } 
function histogram ( ) { var histogram = { } ; libs . object . every ( arguments , function ( o ) { if ( typeof o = = = 'boolean ' ) { if ( ! histogram [ o ] ) histogram [ o ] = 1 ; else histogram [ o ] + + ; } else if ( typeof o = = = 'function ' ) { if ( ! histogram [ 'function ' ] ) histogram [ 'function ' ] = 1 ; else histogram [ o ] + + ; } else { libs . object . every ( o , function ( val ) { switch ( true ) { case typeof val = = = 'function ' : case typeof val = = = 'undefined ' : val = typeof val ; break ; case typeof val = = = 'object ' & & val = = = null : val = 'null ' ; break ; case typeof val = = = 'object ' & & val instanceof Array : val = 'array ' ; break ; case typeof val = = = 'object ' : val = 'object ' ; break ; default : val = val . to String ( ) ; } if ( typeof histogram [ val ] ! = = 'number ' ) histogram [ val ] = 0 ; histogram [ val ] + + ; } ) ; } } ) ; return histogram ; } 
function copy ( item ) { var copy ; if ( ! item ) return item ; switch ( typeof item ) { case 'string ' : case 'number ' : case 'function ' : case 'boolean ' : return item ; default : if ( item instanceof Array ) { return item . slice ( 0 ) ; } else { copy = { } ; } } libs . object . every ( item , function ( o , k ) { copy [ k ] = o ; } ) ; return copy ; } 
function occurrences Of ( obj , what ) { if ( arguments . length < 2 ) return 0 ; if ( typeof obj = = = 'boolean ' ) { return 0 ; } if ( typeof obj = = = 'number ' ) { return occurrences Of ( obj . to String ( ) , what ) ; } else if ( typeof obj = = = 'function ' ) { return occurrences Of ( fix Firefox Function String ( obj . to String ( ) ) , what ) ; } var count = 0 ; if ( typeof obj = = = 'string ' ) { if ( typeof what = = = 'string ' | | typeof what = = = 'number ' ) { var regexp = new Reg Exp ( what . to String ( ) , 'g ' ) , m ; while ( m = regexp . exec ( obj ) ) count + + ; 
function keys ( o ) { if ( o = = = undefined | | o = = = null ) return [ ] ; var keys = get Keys ( o ) , idx ; if ( libs . object . is Arguments ( o ) ) { idx = keys . index Of ( 'length ' ) ; if ( idx > - 1 ) keys . splice ( idx , 1 ) ; } return keys ; } 
function size ( o ) { switch ( true ) { case typeof o = = = 'function ' : return 1 ; case typeof o = = = 'number ' : return o . to String ( ) . length ; case o instanceof Array : case typeof o = = = 'string ' : return o . length ; case libs . object . is Arguments ( o ) & & typeof o . length ! = = 'undefined ' : return o . length ; case o & & typeof o = = = 'object ' : return Object . keys ( o ) . length ; default : return 0 ; } } 
function is Numeric ( ) { return libs . object . every ( arguments , function ( item ) { return ! is Na N ( parse Float ( item ) ) & & is Finite ( item ) ; } ) ; } 
function get Numeric ( ) { var vals = [ ] ; libs . object . every ( arguments , function ( o ) { vals . push ( libs . object . is Numeric ( o ) ? parse Float ( o ) : Na N ) ; } ) ; return vals . length = = = 1 ? vals [ 0 ] : vals ; } 
function is Empty ( ) { return libs . object . every ( arguments , function ( item ) { return libs . object . size ( item ) = = = 0 & & item ! = = false & & item ! = = ' ' & & item ! = = true ; } ) ; } 
function is Arguments ( ) { return libs . object . every ( arguments , function ( item ) { return Object . prototype . to String . call ( item ) = = = ' [object Arguments ] ' ; } ) ; } 
function to Int ( ) { var vals = [ ] ; libs . object . every ( arguments , function ( o ) { var radix = / ^ 0x / . test ( o ) ? 1 6 : 1 0 ; 
function random ( o ) { if ( typeof o = = = 'object ' ) { return o instanceof Array ? o [ Math . floor ( Math . random ( ) * o . length ) ] : o [ Object . keys ( o ) [ Math . floor ( Math . random ( ) * Object . keys ( o ) . length ) ] ] ; } else if ( typeof o = = = 'string ' | | typeof o = = = 'number ' ) { var val = o , negative = false ; if ( o . length = = = 0 ) return ' ' ; if ( typeof o = = = 'number ' & & o < 0 ) { negative = true ; val = Math . abs ( val ) ; } val = val . to String ( ) [ Math . floor ( Math . random ( ) * val . to String ( ) . length ) ] ; if ( typeof o = = = 'number ' ) val = parse Int ( val , 1 0 ) ; return negative ? - val : val ; } return o ; } 
function each ( o , range A , range B , f ) { 
function any ( o , f ) { f = f instanceof Function ? f : undefined ; if ( f instanceof Function ) { var self = o , keys , property , value ; if ( typeof self = = = 'number ' | | typeof self = = = 'function ' | | typeof self = = = 'boolean ' ) self = o . to String ( ) ; 
function to Array ( o ) { if ( o instanceof Array ) return libs . object . copy ( o ) ; var arr = [ ] ; libs . object . each ( o , function ( val ) { arr . push ( val ) ; } ) ; return arr ; } 
function first ( o , n ) { var got N = ( n = = = 0 ? true : ! ! n ) , v ; n = parse Int ( n , 1 0 ) ; n = is Na N ( n ) | | ! is Finite ( n ) ? 1 : n ; if ( typeof o = = = 'boolean ' ) { return o ; } else if ( typeof o ! = = 'object ' ) { if ( n ! = = 0 ) v = o . to String ( ) . slice ( 0 , n ) ; else return undefined ; } else if ( o instanceof Array ) { if ( n = = = 1 & & ! got N ) return o [ 0 ] ; if ( n = = = 0 & & ! got N ) return undefined ; return n ! = = 0 ? o . slice ( 0 , n ) : [ ] ; } else { v = { } ; libs . object . each ( o , 0 , n - 1 , function ( item , key ) { v [ key ] = item ; } ) ; var keys = get Keys ( v ) ; if ( n = = = 1 & & ! got N & & keys . length = = = 0 ) return undefined ; return keys . length = = = 1 & & ! got N ? v [ keys [ 0 ] ] : v ; } return v . length = = = 1 & & ! got N ? v [ 0 ] : v ; } 
function last ( o , n ) { if ( typeof o = = = 'boolean ' ) return o ; var got N = ( ! ! n | | n = = = 0 ) ; n = parse Int ( n , 1 0 ) ; n = is Na N ( n ) | | ! is Finite ( n ) ? 1 : n ; var v = null , keys , len = libs . object . size ( o ) , idx ; if ( typeof o = = = 'boolean ' ) { return o ; } else if ( libs . object . is Arguments ( o ) ) { keys = get Keys ( o ) ; idx = keys . index Of ( 'length ' ) ; if ( idx > - 1 ) keys . splice ( idx , 1 ) ; v = [ ] ; len = keys . length ; 
function get Callback ( o ) { var last = libs . object . last ( o ) ; return last instanceof Function ? last : NULL _FUNCTION ; } 
function find Child At Path ( o , path , delimiter , original , invoked , done ) { done = libs . object . get Callback ( arguments ) ; var self = o ; original = ( ! ( original instanceof Function ) & & original ) ? original : self ; invoked = invoked | | false ; if ( typeof o = = = 'object ' & & typeof path = = = 'string ' ) { delimiter = typeof delimiter = = = 'string ' ? delimiter : ' . ' ; path = path . split ( delimiter ) ; var p = path . shift ( ) ; if ( p ) { return libs . object . each ( o , function ( o , k , i , exit ) { if ( path . length = = = 0 & & k = = = p ) { done . call ( original , o , self , k ) ; invoked = true ; exit ( o ) ; } else { var obj = libs . object . find Child At Path ( o , path . join ( delimiter ) , delimiter , original , invoked , done ) ; if ( obj ! = = null ) exit ( obj ) ; } } ) ; } } if ( ! invoked & & original = = = self & & done instanceof Function ) done . call ( original , null , self , null ) ; return null ; } 
function clone ( o , replacer ) { if ( typeof o = = = 'string ' | | typeof o = = = 'number ' ) return o ; try { return JSON . parse ( JSON . stringify ( o , replacer ) ) ; } catch ( e ) { throw new Error ( 'Unable to clone object : ' + e . message ) ; } } 
function only ( o , types ) { types = libs . object . to Array ( arguments ) ; types . shift ( ) ; 
function where Keys ( o , predicate ) { if ( ! ( predicate instanceof Function ) ) { var temp = predicate ; predicate = function ( k ) { return k = = temp ; } ; 
function invert ( o ) { if ( o = = = null | | o = = = undefined ) return o ; if ( typeof o = = = 'string ' ) return libs . string . reverse ( o ) ; if ( typeof o = = = 'number ' ) return 1 / o ; if ( typeof o = = = 'boolean ' ) return ! o ; if ( typeof o = = = 'function ' ) { return function ( ) { return libs . object . invert ( o . apply ( o , arguments ) ) ; } ; } var obj = { } ; libs . object . each ( o , function ( item , key ) { if ( typeof item = = = 'string ' | | typeof item = = = 'number ' ) { if ( ! obj [ item ] ) { obj [ item ] = key ; } else { var tmp = obj [ item ] ; obj [ item ] = [ ] ; obj [ item ] . push ( tmp , key ) ; } } } ) ; return obj ; } 
function max ( o , func ) { if ( ! o | | typeof o ! = = 'object ' ) return o ; if ( libs . object . size ( o ) = = = 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; var max , max Value ; if ( ! func ) { max = libs . object . first ( o ) ; libs . object . each ( o , 1 , function ( item ) { if ( item > = max ) max = item ; } ) ; } else { max = libs . object . first ( o ) ; max Value = func . call ( max , max ) ; libs . object . each ( o , 1 , function ( item ) { var value = func . call ( item , item ) ; if ( value > = max Value ) { max = item ; max Value = value ; } } ) ; } return max ; } 
function key Of Max ( o , func ) { if ( ! o | | typeof o ! = = 'object ' ) return o ; if ( libs . object . size ( o ) = = = 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; var max , max Value , max Key ; if ( ! func ) { max = libs . object . first ( o ) ; max Key = libs . object . keys ( o ) [ 0 ] ; libs . object . each ( o , 1 , function ( item , key ) { if ( item > = max ) { max = item ; max Key = key ; } } ) ; } else { max = libs . object . first ( o ) ; max Key = libs . object . keys ( o ) [ 0 ] ; max Value = func . call ( max , max ) ; libs . object . each ( o , 1 , function ( item , key ) { var value = func . call ( item , item ) ; if ( value > = max Value ) { if ( value > = max Value ) { max = item ; max Value = value ; max Key = key ; } } } ) ; } return max Key ; } 
function min ( o , func ) { if ( ! o | | typeof o ! = = 'object ' ) return o ; if ( libs . object . size ( o ) = = = 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; if ( typeof o ! = = 'object ' ) return o ; var min , min Value ; if ( ! func ) { min = libs . object . first ( o ) ; libs . object . each ( o , 1 , function ( item ) { if ( item < = min ) min = item ; } ) ; } else { min = libs . object . first ( o ) ; min Value = func . call ( min , min ) ; libs . object . each ( o , 1 , function ( item ) { var value = func . call ( item , item ) ; if ( value < = min Value ) { min = item ; min Value = value ; } } ) ; } return min ; } 
function key Of Min ( o , func ) { if ( ! o | | typeof o ! = = 'object ' ) return o ; if ( libs . object . size ( o ) = = = 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; if ( typeof o ! = = 'object ' ) return o ; var min , min Value , min Key ; if ( ! func ) { min = libs . object . first ( o ) ; min Key = libs . object . keys ( o ) [ 0 ] ; libs . object . each ( o , 1 , function ( item , key ) { if ( item < = min ) { min = item ; min Key = key ; } } ) ; } else { min = libs . object . first ( o ) ; min Value = func . call ( min , min ) ; min Key = libs . object . keys ( o ) [ 0 ] ; libs . object . each ( o , 1 , function ( item , key ) { var value = func . call ( item , item ) ; if ( value < = min Value ) { min = item ; min Value = value ; min Key = key ; } } ) ; } return min Key ; } 
function _implements ( ) { var args = libs . object . to Array ( arguments ) , a = args . shift ( ) ; if ( ! a ) return false ; return libs . object . every ( args , function ( m ) { if ( ! ( a [ m ] instanceof Function ) ) return false ; } ) ; } 
function implements Own ( o , method ) { var args = libs . object . to Array ( arguments ) , a = args . shift ( ) ; if ( ! a ) return false ; return libs . object . every ( args , function ( m ) { if ( ! ( a [ m ] instanceof Function ) | | ! o . has Own Property ( method ) ) return false ; } ) ; } 
function create ( props ) { var joystick = Object . create ( this ) ; 
function draw ( ) { 
function create ( ) { var should Use Touch = _utilities 2 . default . get Mode ( ) = = = 'touch ' ; _widget 2 . default . create . call ( this ) ; Object . assign ( this , DOMWidget . defaults ) ; * The DOM element used by the DOMWidget * @memberof DOMWidget * @instance * / this . element = this . create Element ( ) ; } else { throw new Error ( 'widget inheriting from DOMWidget does not implement create Element method ; this is required . ' ) ; } } 
function place ( ) { var container Width = this . container . get Width ( ) , container Height = this . container . get Height ( ) , width = this . width < = 1 ? container Width * this . width : this . width , height = this . height < = 1 ? container Height * this . height : this . height , x = this . x < 1 ? container Width * this . x : this . x , y = this . y < 1 ? container Height * this . y : this . y ; if ( ! this . attached ) { this . attached = true ; } if ( this . is Square ) { if ( height > width ) { height = width ; } else { width = height ; } } this . element . width = width ; this . element . style . width = width + 'px ' ; this . element . height = height ; this . element . style . height = height + 'px ' ; this . element . style . left = x ; this . element . style . top = y ; this . rect = this . element . get Bounding Client Rect ( ) ; } 
function normalize Attributes ( attributes ) { let main Attributes = [ ] let max Value for ( let key in attributes ) { if ( valid Attributes . index Of ( key ) = = = - 1 ) { continue } if ( ! max Value | | attributes [ key ] > max Value ) { max Value = attributes [ key ] main Attributes = [ key ] } else if ( attributes [ key ] = = = max Value ) { main Attributes . push ( key ) } } let secondary Attributes = Object . keys ( attributes ) . filter ( a = > main Attributes . index Of ( a ) = = = - 1 & & valid Attributes . index Of ( a ) ! = = - 1 ) return [ main Attributes , secondary Attributes ] } 
function equal Array Elements ( needle , haystack ) { let missing Needle = needle . filter ( n = > haystack . index Of ( n ) = = = - 1 ) if ( missing Needle . length ! = = 0 ) { return false } let missing Haystack = haystack . filter ( h = > needle . index Of ( h ) = = = - 1 ) return missing Haystack . length = = = 0 } 
function get Async Fnc Wrapper ( async Fnc Wrapper ) { if ( ! async Fnc Wrapper ) return set Immediate ; else if ( async Fnc Wrapper = = = true ) return function ( cb ) { cb ( ) ; } ; else if ( ! ( async Fnc Wrapper = = = set Immediate | | async Fnc Wrapper = = = set Timeout | | typeof async Fnc Wrapper = = = 'function ' ) ) { throw new Error ( 'Wrong argument "async Fnc Wrapper " , it have to be function , set Immediate , set Timeout , ' + 'or true when use default function , or undefined to use set Immediate ' ) ; } return async Fnc Wrapper ; } 
function Series ( async Fnc Wrapper ) { async Fnc Wrapper = get Async Fnc Wrapper ( async Fnc Wrapper ) ; this . add = function ( ) { var fnc , args ; if ( arguments . length = = = 1 ) { fnc = arguments [ 0 ] ; } else if ( arguments . length > 1 ) { fnc = arguments [ arguments . length - 1 ] ; args = [ ] ; for ( var i = 0 ; i < arguments . length - 1 ; i + + ) { args . push ( arguments [ i ] ) ; } } if ( typeof fnc ! = = 'function ' ) throw new Error ( 'Async Series : Last argument have to be function (arg 1 , arg 2 , . . . , next ) . ' ) ; this . _fnc Queue = this . _fnc Queue | | [ ] ; this . _fnc Queue . push ( { args : args , fnc : fnc } ) ; this . execute = function ( final Fnc ) { var fnc Queue = this . _fnc Queue ; fnc Queue . current = 0 ; fnc Queue . scheduled = 0 ; function run ( itm ) { async Fnc Wrapper ( function ( ) { fnc Queue . scheduled = fnc Queue . current ; if ( itm . args ) { itm . args . push ( next ) ; itm . fnc . apply ( itm , itm . args ) ; } else itm . fnc ( next ) ; } ) ; } function next ( ) { if ( ! fnc Queue | | fnc Queue . scheduled ! = = fnc Queue . current ) throw new Error ( 'Async Series : cannot execute next ( ) more than once per function ' ) ; 
function Parallel ( async Fnc Wrapper ) { async Fnc Wrapper = get Async Fnc Wrapper ( async Fnc Wrapper ) ; this . add = function ( ) { var fnc , args ; if ( arguments . length = = = 1 ) { fnc = arguments [ 0 ] ; } else if ( arguments . length > 1 ) { fnc = arguments [ arguments . length - 1 ] ; args = [ ] ; for ( var i = 0 ; i < arguments . length - 1 ; i + + ) { args . push ( arguments [ i ] ) ; } } if ( typeof fnc ! = = 'function ' ) throw new Error ( 'Async Parallel : Last argument have to be function (arg 1 , arg 2 , . . . , next ) . ' ) ; this . _fnc Queue = this . _fnc Queue | | [ ] ; this . _fnc Queue . push ( { args : args , fnc : fnc } ) ; this . execute = function ( final Fnc ) { var fnc Queue = this . _fnc Queue ; fnc Queue . finished = 0 ; function run ( itm ) { async Fnc Wrapper ( function ( ) { if ( itm . args ) { itm . args . push ( next ) ; itm . fnc . apply ( itm , itm . args ) ; } else itm . fnc ( next ) ; } ) ; } function next ( ) { if ( arguments . length > 0 ) throw new Error ( 'Async Parallel : next ( ) callback do not accept any arguments , ' + 'because of parallel behaviour , it cannot stop executing on error argument in callback ' ) ; else if ( ! fnc Queue ) 
function create ( props ) { var menu = Object . create ( this ) ; _dom Widget 2 . default . create . call ( menu ) ; Object . assign ( menu , Menu . defaults , props ) ; menu . create Options ( ) ; menu . element . add Event Listener ( 'change ' , function ( e ) { menu . _ _value = e . target . value ; menu . output ( ) ; if ( menu . onvaluechange ! = = null ) { menu . onvaluechange ( menu . value ) ; } } ) ; return menu ; } 
function create Options ( ) { this . element . inner HTML = ' ' ; var _iterator Normal Completion = true ; var _did Iterator Error = false ; var _iterator Error = undefined ; try { for ( var _iterator = this . options [ Symbol . iterator ] ( ) , _step ; ! ( _iterator Normal Completion = ( _step = _iterator . next ( ) ) . done ) ; _iterator Normal Completion = true ) { var option = _step . value ; var option El = document . create Element ( 'option ' ) ; option El . set Attribute ( 'value ' , option ) ; option El . inner Text = option ; this . element . append Child ( option El ) ; } } catch ( err ) { _did Iterator Error = true ; _iterator Error = err ; } finally { try { if ( ! _iterator Normal Completion & & _iterator . return ) { _iterator . return ( ) ; } } finally { if ( _did Iterator Error ) { throw _iterator Error ; } } } } 
function create ( props ) { var multi Slider = Object . create ( this ) ; 
function draw ( ) { 
function process Pointer Position ( e ) { var prev Value = this . value , slider Num = void 0 ; if ( this . style = = = 'horizontal ' ) { slider Num = Math . floor ( e . client Y / this . rect . height / ( 1 / this . count ) ) ; this . _ _value [ slider Num ] = ( e . client X - this . rect . left ) / this . rect . width ; } else { slider Num = Math . floor ( e . client X / this . rect . width / ( 1 / this . count ) ) ; this . _ _value [ slider Num ] = 1 - ( e . client Y - this . rect . top ) / this . rect . height ; } for ( var i = 0 ; i < this . count ; i + + ) { if ( this . _ _value [ i ] > 1 ) this . _ _value [ i ] = 1 ; if ( this . _ _value [ i ] < 0 ) this . _ _value [ i ] = 0 ; } var should Draw = this . output ( ) ; if ( should Draw ) this . draw ( ) ; } 
function match All ( regex , string ) { let match let matches = [ ] while ( ( match = regex . exec ( string ) ) ! = = null ) { delete match [ 'index ' ] delete match [ 'input ' ] matches . push ( match ) } return matches } 
function ( f Path , fn Add , fn Remove , depth ) { fs . stat ( f Path , function on Stat ( err , stats ) { if ( err ) { return fn Add & & fn Add ( err ) ; } if ( stats . is Directory ( ) & & depth > 0 ) { 
function flush Buffer ( ) { if ( file Buffer . length > 0 & & original _fn Add ) { var temp Buffer = file Buffer ; file Buffer = [ ] ; original _fn Add ( null , temp Buffer ) ; } flush Timer = null ; } 
function flush Buffer ( ) { if ( file Buffer . length > 0 & & original _fn Remove ) { var temp Buffer = file Buffer ; file Buffer = [ ] ; original _fn Remove ( null , temp Buffer ) ; } flush Timer = null ; } 
function before Each ( test , context , done ) { context . dir = tmp . dir Sync ( ) . name ; process . chdir ( context . dir ) ; done & & done ( ) ; } 
function promise Should Fail ( promise , done , handler ) { promise . then ( result = > done ( new Error ( 'Promise expected to fail ' ) ) ) . catch ( error = > { handler ( error ) done ( ) } ) . catch ( error = > done ( error ) ) } 
function promise Should Succeed ( promise , done , handler ) { promise . then ( result = > { handler ( result ) done ( ) } ) . catch ( error = > done ( error ) ) } 
function copy Asset To Context ( src , dest , context ) { var source Asset = path . join ( test Dir , src ) ; var target Asset = path . join ( context . dir , dest ) ; if ( ! fs . exists Sync ( source Asset ) ) { 
function deep Set ( parent , key , value , mode ) { 
function update ( obj , expression ) { if ( is Object ( expression ) ) for ( var key in expression ) { if ( is Object ( expression [ key ] ) ) { if ( key = = = ' $set ' ) obj = update ( obj , expression [ key ] ) ; else if ( key = = = ' $inc ' ) for ( var prop in expression [ key ] ) { if ( typeof expression [ key ] [ prop ] = = = 'number ' ) { var orig = deep Get ( obj , prop ) ; if ( orig = = = undefined ) obj = deep Set ( obj , prop , expression [ key ] [ prop ] ) ; else if ( typeof orig = = = 'number ' ) obj = deep Set ( obj , prop , orig + expression [ key ] [ prop ] ) ; } } else if ( key = = = ' $max ' | | key = = = ' $min ' ) for ( var prop in expression [ key ] ) { if ( typeof expression [ key ] [ prop ] = = = 'number ' ) { var orig = deep Get ( obj , prop ) ; if ( key = = = ' $max ' & & orig < expression [ key ] [ prop ] ) obj = deep Set ( obj , prop , expression [ key ] [ prop ] ) ; else if ( key = = = ' $min ' & & orig > expression [ key ] [ prop ] ) obj = deep Set ( obj , prop , expression [ key ] [ prop ] ) ; } } else if ( key = = = ' $pull ' | | key = = = ' $pull All ' ) for ( var prop in expression [ key ] ) { var orig = deep Get ( obj , prop ) , value = expression [ key ] [ prop ] ; if ( Array . is Array ( orig ) ) { if ( ! Array . is Array ( value ) ) value = [ value ] ; for ( var i = 0 ; i < value . length ; i + + ) { var index = orig . index Of ( value [ i ] ) ; if ( index ! = = - 1 ) orig . splice ( index , 1 ) ; } obj = deep Set ( obj , prop , orig ) ; } } else if ( key = = = ' $push ' ) for ( var prop in expression [ key ] ) { var orig = deep Get ( obj , prop ) , value = expression [ key ] [ prop ] ; if ( value . $each ) value = value . $each ; if ( Array . is Array ( orig ) ) { if ( ! Array . is Array ( value ) ) value = [ value ] ; for ( var i = 0 ; i < value . length ; i + + ) { orig . push ( value [ i ] ) ; } obj = deep Set ( obj , prop , orig ) ; } } else if ( key [ 0 ] = = = ' $ ' ) continue ; 
function ( f Path , strict , fn ) { if ( typeof ( strict ) = = = 'function ' ) { fn = strict ; strict = false ; } var dir = path . dirname ( f Path ) ; var base = path . basename ( f Path ) ; if ( typeof watched = = = 'undefined ' ) { return fn & & fn ( ' [check File ] watched array not properly defined . ' ) ; } else { fs . stat ( f Path , function on Stat ( err , stats ) { 
function create ( props ) { var should Use Touch = _utilities 2 . default . get Mode ( ) = = = 'touch ' ; _dom Widget 2 . default . create . call ( this ) ; Object . assign ( this , Canvas Widget . defaults ) ; this . ctx = this . element . get Context ( ' 2d ' ) ; this . apply Handlers ( should Use Touch ) ; } 
function create Element ( ) { var element = document . create Element ( 'canvas ' ) ; element . set Attribute ( 'touch -action ' , 'none ' ) ; element . style . position = 'absolute ' ; element . style . display = 'block ' ; return element ; } 
function convert Official Array ( attributes ) { let map = { } attributes . map ( attribute = > { let key = official Attribute Map [ attribute . attribute ] map [ key ] = attribute . modifier } ) return map } 
function convert Official Map ( attributes ) { let map = { } for ( let attribute in attributes ) { let key = official Attribute Map [ attribute ] map [ key ] = attributes [ attribute ] } return map } 
function ( ) { return _ . map ( ko . unwrap ( that . relations ) , function ( relation ) { return ko . unwrap ( relation . related Post . id ) ; } ) ; } 
function ( post Ids ) { if ( ! post Ids ) return ; var updated Relations = [ ] ; 
function ( element , value Accessor , all Bindings , view Model , binding Context ) { var $element = $ ( element ) ; var observable = value Accessor ( ) ; if ( ko . unwrap ( observable ) ) { $element . datepicker ( 'update ' , observable . date Picker ( ) . format ( 'DD .MM .YYYY ' ) ) ; 
function jajax ( o , done , fail , _u ) { let xhr = jajax . create XHR ( FALSE ) ; if ( ! xhr ) { fail & & fail ( NULL , 'xhr ' , ` ` ) ; return xhr ; } if ( type ( o ) = = 'String ' ) { if ( done & & type ( done ) = = 'Object ' ) { done . url = o ; o = done ; done = fail ; fail = _u ; } else { o = { url : o } ; } } o = extend ( { url : ' ' , 
function type ( obj ) { 
function each ( o , f ) { if ( ! o ) return o ; if ( is Array ( o ) | | is Array Like ( o ) ) { for ( let i = 0 , l = o [ LENGTH ] > > > 0 ; i < l ; i + + ) if ( hop . call ( o , i ) ) { let s = o [ i ] ; if ( f . call ( s , i , s , o ) = = = FALSE ) return i ; } } else { for ( let i in o ) if ( hop . call ( o , i ) ) { let s = o [ i ] ; if ( f . call ( s , i , s , o ) = = = FALSE ) return i ; } } return o ; } 
function extend ( o ) { const cpy = ( i , s ) = > { o [ i ] = s ; } ; each ( arguments , ( i , a ) = > { i & & each ( a , cpy ) ; } ) ; return o ; } 
async function disposable ( ) { const name = "tmp " + Math . floor ( Math . random ( ) * 1 0 0 0 0 ) ; await connection . db Create ( name ) . run ( ) ; const r = Object . create ( connection ) ; r . dispose = async function ( ) { await this . db Drop ( name ) . run ( ) ; } ; r . _pool Master . _options . db = name ; return r ; } 
function run Request Queue ( socket ) { var queue = socket . request Queue ; if ( ! queue ) return ; for ( var i in queue ) { 
function JWR ( response Ctx ) { this . body = response Ctx . body | | { } ; this . headers = response Ctx . headers | | { } ; this . status Code = response Ctx . status Code | | 2 0 0 ; if ( this . status Code < 2 0 0 | | this . status Code > = 4 0 0 ) { this . error = this . body | | this . status Code ; } } 
function Sails Socket ( opts ) { var self = this ; opts = opts | | { } ; 
function create ( props ) { var slider = Object . create ( this ) ; 
function draw ( ) { 
function process Pointer Position ( e ) { var prev Value = this . value ; if ( this . style = = = 'horizontal ' ) { this . _ _value = ( e . client X - this . rect . left ) / this . rect . width ; } else { this . _ _value = 1 - ( e . client Y - this . rect . top ) / this . rect . height ; } 
function setter ( obj , prop , value ) { var prop Dashed = prop . replace ( / _ / g , ' - ' ) ; var prop Underscored = prop . replace ( / \ - / g , ' _ ' ) ; obj [ prop ] = value ; obj [ prop Dashed ] = value ; obj [ prop Underscored ] = value ; return true ; } 
function replacer ( start String , end String ) { var start String Escaped = start String . escape ( ) ; var end String Escaped = end String . escape ( ) ; var match Regexp = new Reg Exp ( start String Escaped + ' ( [ ^ ' + start String [ 0 ] . escape ( ) + end String [ 0 ] . escape ( ) + ' ] + ) ' + end String Escaped , 'g ' ) ; return function ( template , model ) { var brackets = template . match ( match Regexp ) | | [ ] , value ; for ( var i = 0 ; i < brackets . length ; i + + ) { brackets [ i ] = brackets [ i ] . replace ( start String , ' ' ) . replace ( end String , ' ' ) ; value = object . get Value ( model , brackets [ i ] . trim ( ) ) | | ' ' ; template = template . replace ( new Reg Exp ( start String Escaped + brackets [ i ] + end String Escaped , 'g ' ) , value ) ; } return template ; } ; } 
function from Mongo ( item ) { if ( Array . is Array ( item ) & & item . length ) { item = item [ 0 ] ; } item . id = item . _id ; delete item . _id ; return item ; } 
function get Collection ( cb ) { if ( collection ) { set Immediate ( function ( ) { cb ( null , collection ) ; } ) ; return ; } Mongo Client . connect ( url , function ( err , db ) { if ( err ) { return cb ( err ) ; } collection = db . collection ( collection Name ) ; cb ( null , collection ) ; } ) ; } 
function list ( qs , limit , token , cb ) { token = token ? parse Int ( token , 1 0 ) : 0 ; if ( is Na N ( token ) ) { return cb ( new Error ( 'invalid token ' ) ) ; } get Collection ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } collection . find ( { } ) . skip ( token ) . limit ( limit ) . to Array ( function ( err , results ) { if ( err ) { return cb ( err ) ; } var has More = results . length = = = limit ? token + results . length : false ; cb ( null , results . map ( from Mongo ) , has More ) ; 
function read ( id , cb ) { if ( ! / ^ [a -f A -F 0 - 9 ] { 2 4 } $ / . test ( id ) ) { return cb ( { code : 4 0 4 , message : 'Not valid Object Id . Must be 2 4 hex string or 1 2 hex binary sequence . ' } ) } ; get Collection ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } collection . find One ( { _id : new Object ID ( id ) } , function ( err , result ) { if ( err ) { return cb ( err ) ; } if ( ! result ) { return cb ( { code : 4 0 4 , message : 'Not found ' } ) ; } cb ( null , from Mongo ( result ) ) ; } ) ; } ) ; } 
function update ( id , data , cb ) { get Collection ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } collection . update ( { _id : new Object ID ( id ) } , { ' $set ' : to Mongo ( data ) } , { w : 1 } , function ( err ) { if ( err ) { return cb ( err ) ; } return read ( id , cb ) ; } ) ; } ) ; } 
function _delete ( id , cb ) { get Collection ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } collection . remove ( { _id : new Object ID ( id ) } , cb ) ; } ) ; } 
function push Constraints ( constraints , param = config ) { let emitter Constraints = new Event Emitter ( ) ; port Socket = param . port Socket ; address Warehouse = param . warehouse Address ; url Socket = ` $ { address Warehouse } $ { port Socket } ` ; handshake ( param ) . then ( ( ) = > { let socket = io . connect ( url Socket ) ; let msg = message Builder ( constraints , 'push Constraints ' ) ; socket . on ( 'connect ' , function ( ) { socket . emit ( 'push Constraints ' , msg ) ; } ) . on ( 'results Constraints ' , ( message Results ) = > { if ( message Results . value = = = 'found ' ) { logger _ 1 . logger . log ( 'info ' , ` ` ) ; logger _ 1 . logger . log ( 'debug ' , ` \n $ { JSON . stringify ( message Results ) } ` ) ; let work Path = message Results . data [ 0 ] . work Dir ; f Stdout _f Sterr _Check ( work Path ) . on ( 'check OK ' , ( name Out , name Err ) = > { logger _ 1 . logger . log ( 'success ' , ` $ { message Results . data . length } ` ) ; emitter Constraints . emit ( 'found Docs ' , name Out , name Err , work Path ) ; } ) . on ( 'check Not OK ' , ( ) = > { emitter Constraints . emit ( 'not Found Docs ' ) ; } ) ; } ; if ( message Results . value = = = 'not Found ' ) { logger _ 1 . logger . log ( 'info ' , ` ` ) ; logger _ 1 . logger . log ( 'debug ' , ` \n $ { JSON . stringify ( message Results ) } ` ) ; emitter Constraints . emit ( 'not Found Docs ' , message Results ) ; } if ( message Results . value = = = 'error Constraints ' ) emitter Constraints . emit ( 'error Docs ' , message Results ) ; } ) ; } ) . catch ( ( ) = > { emitter Constraints . emit ( 'cant Connect ' ) ; } ) ; return emitter Constraints ; } 
function store Job ( job Completed ) { 
function message Builder ( data , event , store = false , index = false ) { let message = { 'type ' : store ? 'store ' : index ? 'indexation ' : 'request ' , 'value ' : event , 'data ' : data } ; logger _ 1 . logger . log ( 'debug ' , ` \n $ { JSON . stringify ( message ) } ` ) ; return message ; } 
function f Stdout _f Sterr _Check ( work Dir ) { let emitter Check = new Event Emitter ( ) ; let split Work Dir = work Dir . split ( ' / ' ) ; let name Out = path . basename ( work Dir ) + " .out " ; let name Err = path . basename ( work Dir ) + " .err " ; let path Out = work Dir + " / " + name Out ; let path Err = work Dir + " / " + name Err ; path Exists ( path Out ) . then ( exists Out = > { if ( exists Out ) { path Exists ( path Err ) . then ( exists Err = > { if ( exists Err ) { emitter Check . emit ( 'check OK ' , name Out , name Err ) ; } else emitter Check . emit ( 'check Not OK ' ) ; } ) . catch ( err = > { emitter Check . emit ( 'check Not OK ' ) ; } ) ; } else emitter Check . emit ( 'check Not OK ' ) ; } ) . catch ( err = > { emitter Check . emit ( 'check Not OK ' ) ; } ) ; return emitter Check ; } 
function handshake ( param ) { return new Promise ( ( resolve , reject ) = > { if ( types . is Client Config ( param ) ) { logger _ 1 . logger . log ( 'info ' , ` ` ) ; logger _ 1 . logger . log ( 'debug ' , ` \n $ { JSON . stringify ( param ) } ` ) ; let socket = io . connect ( ` $ { param . warehouse Address } $ { param . port Socket } ` ) ; socket . on ( 'connect ' , function ( ) { logger _ 1 . logger . log ( 'info ' , ` \n ` ) ; resolve ( ) ; } ) . on ( 'connect _error ' , function ( ) { logger _ 1 . logger . log ( 'debug ' , ` \n ` ) ; reject ( ) ; socket . disconnect ( ) ; } ) ; } else { logger _ 1 . logger . log ( 'error ' , ` \n $ { JSON . stringify ( config ) } ` ) ; reject ( ) ; } } ) ; } 
function pivot Table ( dataset ) { var column _names = [ ] ; var xvalues = [ ] ; var values = { } ; var rows = { } ; for ( rn in dataset . data ) { 
function VMessage ( reason , position , origin ) { var parts var range var location if ( typeof position = = = 'string ' ) { origin = position position = null } parts = parse Origin ( origin ) range = stringify ( position ) | | ' 1 : 1 ' location = { start : { line : null , column : null } , end : { line : null , column : null } } 
function async Process File Error Wrapper ( e ) { if ( typeof e ! = = 'object ' ) e = new Error ( ' ' + e ) ; e . file = relative Path ; e . tree Dir = src Dir ; throw e ; } 
function mkdir Sync Recursive ( directory ) { var path = directory . replace ( / \ / $ / , ' ' ) . split ( ' / ' ) ; for ( var i = 1 ; i < = path . length ; i + + ) { var segment = path . slice ( 0 , i ) . join ( ' / ' ) ; segment . length > 0 & & ! fs . exists Sync ( segment ) ? fs . mkdir Sync ( segment ) : null ; } } 
function init ( user _id , secret , storage , callback ) { API _USER _ID = user _id ; API _SECRET = secret ; TOKEN _STORAGE = storage ; if ( ! callback ) { callback = function ( ) { } } if ( ! fs . exists Sync ( TOKEN _STORAGE ) ) { mkdir Sync Recursive ( TOKEN _STORAGE ) ; } if ( TOKEN _STORAGE . substr ( - 1 ) ! = = ' / ' ) { TOKEN _STORAGE + = ' / ' ; } var hash Name = md 5 ( API _USER _ID + ' : : ' + API _SECRET ) ; if ( fs . exists Sync ( TOKEN _STORAGE + hash Name ) ) { TOKEN = fs . read File Sync ( TOKEN _STORAGE + hash Name , { encoding : 'utf 8 ' } ) ; } if ( ! TOKEN . length ) { get Token ( callback ) ; return ; } callback ( TOKEN ) } 
function get Email Template ( callback , id ) { if ( id = = = undefined ) { return callback ( return Error ( 'Empty email template id ' ) ) ; } send Request ( 'template / ' + id , 'GET ' , { } , true , callback ) ; } 
function update Email Variables ( callback , id , email , variables ) { if ( ( id = = = undefined ) | | ( email = = = undefined ) | | ( variables = = = undefined ) | | ( ! variables . length ) ) { return callback ( return Error ( "Empty email , variables or book id " ) ) ; } var data = { email : email , variables : variables } ; send Request ( 'addressbooks / ' + id + ' /emails /variable ' , 'POST ' , data , true , callback ) ; } 
function sms Add Phones ( callback , addressbook _id , phones ) { if ( ( addressbook _id = = = undefined ) | | ( phones = = = undefined ) | | ( ! phones . length ) ) { return callback ( return Error ( "Empty phones or book id " ) ) ; } var data = { address Book Id : addressbook _id , phones : JSON . stringify ( phones ) } ; send Request ( 'sms /numbers ' , 'POST ' , data , true , callback ) ; } 
function sms Add Phones With Variables ( callback , addressbook _id , phones ) { if ( ( addressbook _id = = = undefined ) | | ( phones = = = undefined ) | | ( ! Object . keys ( phones ) . length ) ) { return callback ( return Error ( "Empty phones or book id " ) ) ; } var data = { address Book Id : addressbook _id , phones : JSON . stringify ( phones ) } ; send Request ( 'sms /numbers /variables ' , 'POST ' , data , true , callback ) ; } 
function sms Get Phone Info ( callback , addressbook _id , phone ) { if ( ( addressbook _id = = = undefined ) | | ( phone = = = undefined ) ) { return callback ( return Error ( "Empty phone or book id " ) ) ; } send Request ( 'sms /numbers /info / ' + addressbook _id + ' / ' + phone , 'GET ' , { } , true , callback ) ; } 
function sms Update Phones Variables ( callback , addressbook _id , phones , variables ) { if ( addressbook _id = = = undefined ) { return callback ( return Error ( "Empty book id " ) ) ; } if ( ( phones = = = undefined ) | | ( ! phones . length ) ) { return callback ( return Error ( "Empty phones " ) ) ; } if ( ( variables = = = undefined ) | | ( ! Object . keys ( variables ) . length ) ) { return callback ( return Error ( "Empty variables " ) ) ; } var data = { 'address Book Id ' : addressbook _id , 'phones ' : JSON . stringify ( phones ) , 'variables ' : JSON . stringify ( variables ) } send Request ( 'sms /numbers ' , 'PUT ' , data , true , callback ) ; } 
function sms Add Phones To Blacklist ( callback , phones , comment ) { if ( ( phones = = = undefined ) | | ( ! phones . length ) ) { return callback ( return Error ( "Empty phones " ) ) ; } var data = { 'phones ' : JSON . stringify ( phones ) , 'description ' : comment } send Request ( 'sms /black _list ' , 'POST ' , data , true , callback ) ; } 
function sms Delete Phones From Blacklist ( callback , phones ) { if ( ( phones = = = undefined ) | | ( ! phones . length ) ) { return callback ( return Error ( "Empty phones " ) ) ; } var data = { 'phones ' : JSON . stringify ( phones ) , } send Request ( 'sms /black _list ' , 'DELETE ' , data , true , callback ) ; } 
function sms Add Campaign ( callback , sender _name , addressbook _id , body , date , transliterate ) { if ( sender _name = = = undefined ) { return callback ( return Error ( "Empty sender name " ) ) ; } if ( addressbook _id = = = undefined ) { return callback ( return Error ( "Empty book id " ) ) ; } if ( body = = = undefined ) { return callback ( return Error ( "Empty sms text " ) ) ; } var data = { 'sender ' : sender _name , 'address Book Id ' : addressbook _id , 'body ' : body , 'date ' : date , 'transliterate ' : transliterate } send Request ( 'sms /campaigns ' , 'POST ' , data , true , callback ) ; } 
function sms Send ( callback , sender _name , phones , body , date , transliterate ) { if ( sender _name = = = undefined ) { return callback ( return Error ( "Empty sender name " ) ) ; } if ( ( phones = = = undefined ) | | ( ! phones . length ) ) { return callback ( return Error ( "Empty phones " ) ) ; } if ( body = = = undefined ) { return callback ( return Error ( "Empty sms text " ) ) ; } var data = { 'sender ' : sender _name , 'phones ' : JSON . stringify ( phones ) , 'body ' : body , 'date ' : date , 'transliterate ' : transliterate } send Request ( 'sms /send ' , 'POST ' , data , true , callback ) ; } 
function sms Get List Campaigns ( callback , date _from , date _to ) { var data = { 'date From ' : date _from , 'date To ' : date _to } send Request ( 'sms /campaigns /list ' , 'GET ' , data , true , callback ) ; } 
function sms Get Campaign Info ( callback , campaign _id ) { if ( campaign _id = = = undefined ) { return callback ( return Error ( "Empty sms campaign id " ) ) ; } send Request ( 'sms /campaigns /info / ' + campaign _id , 'GET ' , { } , true , callback ) ; } 
function sms Cancel Campaign ( callback , campaign _id ) { if ( campaign _id = = = undefined ) { return callback ( return Error ( "Empty sms campaign id " ) ) ; } send Request ( 'sms /campaigns /cancel / ' + campaign _id , 'PUT ' , { } , true , callback ) ; } 
function sms Get Campaign Cost ( callback , sender _name , body , addressbook _id , phones ) { if ( sender _name = = = undefined ) { return callback ( return Error ( "Empty sender name " ) ) ; } if ( body = = = undefined ) { return callback ( return Error ( "Empty sms text " ) ) ; } if ( ( addressbook _id = = = undefined ) | | ( phones = = = undefined ) | | ( ! phones . length ) ) { return callback ( return Error ( "Empty book id or phones " ) ) ; } var data = { 'sender ' : sender _name , 'body ' : body , 'address Book Id ' : addressbook _id } if ( phones . length ) { data [ 'phones ' ] = JSON . stringify ( phones ) ; } send Request ( 'sms /campaigns /cost ' , 'GET ' , data , true , callback ) ; } 
function sms Delete Campaign ( callback , campaign _id ) { if ( campaign _id = = = undefined ) { return callback ( return Error ( "Empty sms campaign id " ) ) ; } var data = { 'id ' : campaign _id } send Request ( 'sms /campaigns ' , 'DELETE ' , data , true , callback ) ; } 
function for Each ( arr , callback , scope ) { var i , len = arr . length ; for ( i = 0 ; i < len ; i + = 1 ) { callback . call ( scope , arr [ i ] , i ) ; } } 
function emit ( instance , name ) { var args = [ ] . slice . call ( arguments , 2 ) ; if ( events . index Of ( name ) > - 1 ) { if ( instance . handlers [ name ] & & instance . handlers [ name ] instanceof Array ) { for Each ( instance . handlers [ name ] , function ( handle ) { window . set Timeout ( function ( ) { handle . callback . apply ( handle . context , args ) ; } , 0 ) ; } ) ; } } else { throw new Error ( name + ' event cannot be found on Tree View . ' ) ; } } 
function render ( self ) { var container = is DOMElement ( self . node ) ? self . node : document . get Element By Id ( self . node ) ; var leaves = [ ] , click ; var render Leaf = function ( item ) { var leaf = document . create Element ( 'div ' ) ; var content = document . create Element ( 'div ' ) ; var text = document . create Element ( 'div ' ) ; var expando = document . create Element ( 'div ' ) ; leaf . set Attribute ( 'class ' , 'tree -leaf ' ) ; content . set Attribute ( 'class ' , 'tree -leaf -content ' ) ; content . set Attribute ( 'data -item ' , JSON . stringify ( item ) ) ; text . set Attribute ( 'class ' , 'tree -leaf -text ' ) ; text . text Content = item . name ; expando . set Attribute ( 'class ' , 'tree -expando ' + ( item . expanded ? 'expanded ' : ' ' ) ) ; expando . text Content = item . expanded ? ' - ' : ' + ' ; content . append Child ( expando ) ; content . append Child ( text ) ; leaf . append Child ( content ) ; if ( item . children & & item . children . length > 0 ) { var children = document . create Element ( 'div ' ) ; children . set Attribute ( 'class ' , 'tree -child -leaves ' ) ; for Each ( item . children , function ( child ) { var child Leaf = render Leaf ( child ) ; children . append Child ( child Leaf ) ; } ) ; if ( ! item . expanded ) { children . class List . add ( 'hidden ' ) ; } leaf . append Child ( children ) ; } else { expando . class List . add ( 'hidden ' ) ; } return leaf ; } ; for Each ( self . data , function ( item ) { leaves . push ( render Leaf . call ( self , item ) ) ; } ) ; container . inner HTML = leaves . map ( function ( leaf ) { return leaf . outer HTML ; } ) . join ( ' ' ) ; click = function ( e ) { var parent = ( e . target | | e . current Target ) . parent Node ; var data = JSON . parse ( parent . get Attribute ( 'data -item ' ) ) ; var leaves = parent . parent Node . query Selector ( ' .tree -child -leaves ' ) ; if ( leaves ) { if ( leaves . class List . contains ( 'hidden ' ) ) { self . expand ( parent , leaves ) ; } else { self . collapse ( parent , leaves ) ; } } else { emit ( self , 'select ' , { target : e , data : data } ) ; } } ; for Each ( container . query Selector All ( ' .tree -leaf -text ' ) , function ( node ) { node . onclick = click ; } ) ; for Each ( container . query Selector All ( ' .tree -expando ' ) , function ( node ) { node . onclick = click ; } ) ; } 
function validate Package Name ( package _name ) { 
function validate Project Name ( project _name ) { var msg = 'Error validating project name . ' ; 
function ( options ) { Transport . call ( this , options ) ; options = options | | { } ; this . json = options . json | | false ; this . colorize = options . colorize | | false ; this . pretty Print = options . pretty Print | | false ; this . timestamp = typeof options . timestamp ! = = 'undefined ' ? options . timestamp : false ; this . show Level = options . show Level = = = undefined ? true : options . show Level ; this . label = options . label | | null ; this . logstash = options . logstash | | false ; this . depth = options . depth | | null ; this . align = options . align | | false ; this . stderr Levels = set Stderr Levels ( options . stderr Levels , options . debug Stdout ) ; this . warn Levels = set Warn Levels ( options . warn Levels ) ; this . info Levels = set Info Levels ( options . info Levels ) ; this . eol = options . eol | | os . EOL ; this . console = options . console | | console ; if ( this . json ) { this . stringify = options . stringify | | function ( obj ) { return JSON . stringify ( obj , null , 2 ) ; } ; } 
function set Stderr Levels ( levels , debug Stdout ) { var default Msg = 'Cannot have non -string elements in stderr Levels Array ' ; if ( debug Stdout ) { if ( levels ) { 
function ( file ) { var contents = fs . read File Sync ( file , 'utf - 8 ' ) ; if ( contents ) { 
function Config ( file ) { this . _file = file ; this . _doc = _this . parse ( file ) ; this . _root = this . _doc . getroot ( ) ; } 
function Evaluation ( evaluator , stream Handler ) { _evaluation Counter + + ; this . counter = _evaluation Counter ; this . _evaluator = evaluator ; this . _stream Handler = stream Handler ; } 
function capture Stream ( name , callback ) { var stream = process [ name ] ; var original Write = stream . write ; stream . write = function ( str ) { callback ( name , str ) ; } ; return { restore : function ( ) { stream . write = original Write ; } } ; } 
function create Socket ( type , ip , port , message Handler ) { var uri = util . format ( 'tcp : / / %s : %d ' , ip , port ) ; var socket = zmq . create Socket ( type ) ; socket . bind ( uri , function ( e ) { } ) ; if ( message Handler ) { socket . on ( 'message ' , message Handler ) ; } return socket ; } 
function message Handler ( ) { var message = messages . read ( arguments , _session . signer ) ; if ( ! message ) { return ; } var handler = _session . handlers [ message . header . msg _type ] ; if ( handler ) { handler ( message ) ; } } 
function run Session ( evaluator , config ) { _session . signer = signers . create ( config . signature _scheme , config . key ) ; _session . io = create Socket ( 'pub ' , config . ip , config . iopub _port ) ; _session . shell = create Socket ( 'xrep ' , config . ip , config . shell _port , message Handler ) ; _session . control = create Socket ( 'xrep ' , config . ip , config . control _port , message Handler ) ; _session . evaluator = evaluator ; _session . handlers = handlers . create ( _session ) ; create Socket ( 'rep ' , config . ip , config . hb _port , heartbeat Handler ) ; } 
function inspect Command ( shell , args , data , evaluation Id ) { if ( args . names ) { args . names . for Each ( function ( n ) { console . log ( n + ' : ' ) ; console . dir ( shell . state [ n ] ) ; console . log ( ) ; } ) ; } } 
function add Message ( message ) { var text = message . content ? message . content . code . trim ( ) : ' ' ; if ( ! text ) { return ; } message . content . code = text ; _messages . push ( message ) ; 
function process Message ( message ) { var complete = false ; function output Handler ( name , str ) { if ( ! complete ) { var stream Message = messages . stream ( message , name , str ) ; messages . write ( stream Message , _session . io , _session . signer ) ; } } var current Evaluation = evaluation . create ( _session . evaluator , output Handler ) ; var result = current Evaluation . execute ( message . content . code ) ; result . then ( function ( value ) { 
function text Command ( shell , args , data , evaluation Id ) { return data Command ( shell , args , data , evaluation Id , function ( value ) { return value ; } ) ; } 
function json Command ( shell , args , data , evaluation Id ) { return data Command ( shell , args , data , evaluation Id , function ( value ) { return JSON . parse ( value ) ; } ) ; } 
function create Globals ( shell ) { var globals = { Buffer : Buffer , console : console , clear Immediate : clear Immediate , clear Interval : clear Interval , clear Timeout : clear Timeout , set Immediate : set Immediate , set Interval : set Interval , set Timeout : set Timeout , _ : ijsrt } ; globals . global = globals ; return globals ; } 
function create Promise ( result , error ) { 
function Shell ( config ) { this . config = config ; this . commands = { } ; this . runtime = ijsrt ; this . state = vm . create Context ( create Globals ( this ) ) ; this . code = ' ' ; require ( ' . . / . . /node _modules /tern /plugin /node .js ' ) ; var tern Options = { defs : [ require ( ' . . / . . /node _modules /tern /defs /ecma 5 .json ' ) ] , plugins : { node : { } } } ; this . tern Server = new tern . Server ( tern Options ) ; } 
function create Shell ( config , callback ) { var shell = new Shell ( config ) ; modules . initialize ( shell ) ; extensions . initialize ( shell ) ; require ( ' . /commands ' ) . initialize ( shell ) ; require ( ' . /display Commands ' ) . initialize ( shell ) ; require ( ' . /data Commands ' ) . initialize ( shell ) ; process . next Tick ( function ( ) { callback ( shell ) ; } ) ; } 
function module Command ( shell , args , data , evaluation Id ) { var deferred = shell . runtime . q . defer ( ) ; installer . install ( args . name , shell . config . user Path , false , function ( error ) { if ( error ) { deferred . reject ( shell . create Error ( 'Could not install module ' ) ) ; } else { shell . installed Modules [ args . name ] = true ; deferred . resolve ( ) ; } } ) ; return deferred . promise ; } 
function modules Command ( shell , args , data , evaluation Id ) { var names = [ ] ; for ( var n in shell . installed Modules ) { names . push ( n ) ; } console . log ( names . join ( ' \n ' ) ) ; } 
function custom Require ( shell , name ) { var module = shell . required Modules [ name ] ; if ( module ) { return module ; } if ( _known Modules [ name ] ) { module = require ( name ) ; } else if ( shell . installed Modules [ name ] ) { 
function initialize ( shell ) { shell . required Modules = { } ; shell . installed Modules = { } ; shell . state . require = function ( name ) { return custom Require ( shell , name ) ; } ; shell . register Command ( 'module ' , module Command ) ; shell . register Command ( 'modules ' , modules Command ) ; } 
function create Message ( identities , header , parent Header , metadata , content ) { return { identities : identities , header : header , parent Header : parent Header , metadata : metadata , content : content } ; } 
function new Message ( type , parent Message , content , metadata ) { var header = { msg _type : type , msg _id : uuid . v 4 ( ) , session : parent Message . header . session , username : parent Message . header . username } ; metadata = metadata | | { } ; content = content | | { } ; return create Message ( parent Message . identities , header , parent Message . header , metadata , content ) ; } 
function create Kernel Info Response Message ( parent Message ) { var content = { language : 'javascript ' , language _version : [ 1 , 0 ] , protocol _version : [ 4 , 1 ] } ; return new Message ( _message Names . kernel Info Response , parent Message , content ) ; } 
function create Execute Error Response Message ( parent Message , execution Count , error , traceback ) { var content = { status : 'error ' , execution _count : execution Count , ename : error . constructor . name , evalue : error . to String ( ) , traceback : traceback } ; return new Message ( _message Names . execute Response , parent Message , content ) ; } 
function create Execute Success Response Message ( parent Message , execution Count , metadata ) { var content = { status : 'ok ' , execution _count : execution Count , payload : [ ] , user _variables : { } , user _expressions : { } } ; return new Message ( _message Names . execute Response , parent Message , content , metadata ) ; } 
function create Complete Info Response Message ( parent Message , matched Text , matches , metadata ) { var content = { status : 'ok ' , matched _text : matched Text , matches : matches } ; return new Message ( _message Names . complete Response , parent Message , content , metadata ) ; } 
function create Data Message ( parent Message , representations ) { var content = { data : representations } ; return new Message ( _message Names . display Data , parent Message , content ) ; } 
function create Stream Message ( parent Message , stream Name , data ) { var content = { name : stream Name , data : data } ; return new Message ( _message Names . stream , parent Message , content ) ; } 
function create Status Message ( parent Message , busy ) { var content = { execution _state : busy ? 'busy ' : 'idle ' } ; return new Message ( _message Names . status , parent Message , content ) ; } 
function read Message ( socket Data , signer ) { var identities = socket Data [ 0 ] ; var signature = socket Data [ 2 ] . to String ( ) ; var header = socket Data [ 3 ] ; var parent Header = socket Data [ 4 ] ; var metadata = socket Data [ 5 ] ; var content = socket Data [ 6 ] ; if ( ! signer . validate ( signature , [ header , parent Header , metadata , content ] ) ) { return null ; } return create Message ( identities , JSON . parse ( header ) , JSON . parse ( parent Header ) , JSON . parse ( metadata ) , JSON . parse ( content ) ) ; } 
function write Message ( message , socket , signer ) { var header = JSON . stringify ( message . header ) ; var parent Header = JSON . stringify ( message . parent Header ) ; var metadata = JSON . stringify ( message . metadata ) ; var content = JSON . stringify ( message . content ) ; var signature = signer . sign ( [ header , parent Header , metadata , content ] ) ; var socket Data = [ message . identities , ' <IDS |MSG > ' , signature , header , parent Header , metadata , content ] ; socket . send ( socket Data ) ; } 
function html Command ( shell , args , data , evaluation Id ) { return shell . runtime . data . html ( data ) ; } 
function script Command ( shell , args , data , evaluation Id ) { return shell . runtime . data . script ( data ) ; } 
function kernel Info Handler ( message ) { var info Message = messages . kernel Info Response ( message ) ; messages . write ( info Message , _session . shell , _session . signer ) ; } 
function create Handlers ( session ) { _session = session ; _queue = queue . create ( session ) ; var handlers = { } ; handlers [ messages . names . kernel Info Request ] = kernel Info Handler ; handlers [ messages . names . shutdown Request ] = shutdown Handler ; handlers [ messages . names . execute Request ] = execute Handler ; handlers [ messages . names . complete Request ] = complete Handler ; return handlers ; } 
function setup Outline ( ) { var markup = ' <select id = "toc Drop Down " style = "float : right " > <option >Outline < /option > < /select > ' ; IPython . toolbar . element . append ( markup ) ; var toc Drop Down = $ ( ' #toc Drop Down ' ) ; toc Drop Down . change ( function ( e ) { var index = toc Drop Down . val ( ) ; if ( index . length = = = ' ' ) { return false ; } var scroll Top = IPython . notebook . get _cell ( 0 ) . element . position ( ) . top - IPython . notebook . get _cell ( parse Int ( index ) ) . element . position ( ) . top ; IPython . notebook . element . animate ( { scroll Top : - scroll Top } , 2 5 0 , 'ease In Out Cubic ' ) ; toc Drop Down . blur ( ) ; toc Drop Down . find ( 'option ' ) . get ( 0 ) . selected = true ; return false ; } ) ; function create Option ( title , value , level ) { var prefix = level > 1 ? new Array ( level + 1 ) . join ( ' &nbsp ; &nbsp ; ' ) : ' ' ; var text = prefix + IPython . utils . escape _html ( title ) ; return ' <option value = " ' + value + ' " > ' + text + ' < /option > ' ; } function update Outline ( ) { var content = [ ] ; content . push ( create Option ( 'Table of Contents ' , ' ' , 0 ) ) ; var cells = IPython . notebook . get _cells ( ) ; cells . for Each ( function ( c , i ) { if ( ( c . cell _type = = 'heading ' ) & & ( c . level < = 3 ) ) { var cell = $ ( c . element ) ; var header = cell . find ( 'h ' + c . level ) ; 
function main ( ) { var parser = nomnom ( ) ; parser . script ( 'ijs ' ) . nocolors ( ) . printer ( function ( s , code ) { console . log ( s ) ; if ( code ) { process . exit ( code ) ; } } ) . option ( 'version ' , { abbr : 'v ' , flag : true , help : 'print version and exit ' , callback : function ( ) { console . log ( ' 0 . 1 . 0 ' ) ; process . exit ( 0 ) ; } } ) . option ( 'user Path ' , { abbr : 'u ' , full : 'user Path ' , metavar : 'path ' , type : 'string ' , required : true , help : 'path that will contain installed node modules ' , callback : function ( user Path ) { if ( ! fs . exists Sync ( user Path ) | | ! fs . stat Sync ( user Path ) . is Directory ( ) ) { return 'expected an existing directory for the user Path option ' ; } return null ; } } ) . option ( 'connection File ' , { position : 0 , required : true , help : 'path to file containing kernel connection information ' } ) ; var options = parser . parse ( process . argv . slice ( 2 ) ) ; if ( options ) { var shell Config = { user Path : options . user Path } ; var connection Config = JSON . parse ( fs . read File Sync ( options . connection File , { encoding : 'utf 8 ' } ) ) ; Shell . create ( shell Config , function ( shell ) { Session . run ( shell , connection Config ) ; } ) ; } } 
function compute Signature ( values , signature Scheme , signature Key ) { var hmac = crypto . create Hmac ( signature Scheme , signature Key ) ; values . for Each ( function ( v ) { hmac . update ( v ) ; } ) ; return hmac . digest ( 'hex ' ) ; } 
function create Signer ( signature Scheme , signature Key ) { if ( signature Key ) { 
function create Error ( ) { var e = new Error ( util . format . apply ( null , arguments ) ) ; e . trace = false ; return e ; } 
function extension Command ( shell , args , data , evaluation Id ) { var deferred = shell . runtime . q . defer ( ) ; var name = args . name ; var module Name = 'ijs .ext . ' + name ; var module Path = args . path | | module Name ; installer . install ( module Path , shell . config . user Path , true , function ( error ) { if ( error ) { deferred . reject ( shell . create Error ( 'Unable to install extension module " %s " ' , module Name ) ) ; } else { var extension Path = path . join ( shell . config . user Path , 'node _modules ' , module Name ) ; var extension = require ( extension Path ) ; try { extension . initialize ( shell , function ( error , result ) { if ( error ) { deferred . reject ( shell . create Error ( 'Error initializing extension ' ) ) ; } else { shell . loaded Extensions [ name ] = true ; deferred . resolve ( result ) ; } } ) ; } catch ( e ) { deferred . reject ( shell . create Error ( 'Error initializing extension ' ) ) ; } } } ) return deferred . promise ; } 
function extensions Command ( shell , args , data , evaluation Id ) { var names = [ ] ; for ( var n in shell . loaded Extensions ) { names . push ( n ) ; } console . log ( names . join ( ' \n ' ) ) ; } 
function initialize ( shell ) { shell . loaded Extensions = { } ; shell . register Command ( 'extension ' , extension Command ) ; shell . register Command ( 'extensions ' , extensions Command ) ; } 
function create Display Data ( value ) { var display Data = { } ; if ( ( value = = = null ) | | ( value = = = undefined ) ) { return display Data ; } var use Fallbacks = true ; if ( typeof value . to HTML = = 'function ' ) { display Data [ 'text /html ' ] = value . to HTML ( ) ; use Fallbacks = false ; } if ( typeof value . to Script = = 'function ' ) { display Data [ 'application /javascript ' ] = value . to Script ( ) ; use Fallbacks = false ; } if ( typeof value . to Image = = 'function ' ) { var buffer = value . to Image ( ) ; if ( buffer ) { var data = buffer . to String ( 'base 6 4 ' ) ; var mime = buffer . mime | | 'image /png ' ; display Data [ mime ] = data ; use Fallbacks = false ; } } if ( typeof value . to Text = = 'function ' ) { var text = value . to Text ( ) ; if ( text ) { display Data [ 'text /plain ' ] = text ; use Fallbacks = false ; } } if ( use Fallbacks ) { if ( ( value . constructor = = Object ) | | ( value . constructor = = Array ) ) { display Data [ 'application /json ' ] = JSON . stringify ( value ) ; } else if ( value . constructor = = Buffer ) { var mime = value . mime | | 'application /octet -stream ' ; display Data [ mime ] = value . to String ( 'base 6 4 ' ) ; } else { display Data [ 'text /plain ' ] = value . to String ( ) ; } } return display Data ; } 
function ( dest ) { if ( grunt . util . _ . ends With ( dest , ' / ' ) | | grunt . util . _ . ends With ( dest , ' \ \ ' ) ) { return 'directory ' ; } else { return 'file ' ; } } 
function find File ( name , dir ) { dir = dir | | process . cwd ( ) ; var filename = path . normalize ( path . join ( dir , name ) ) ; if ( find File Results [ filename ] ! = = undefined ) { return find File Results [ filename ] ; } var parent = path . resolve ( dir , " . . / " ) ; if ( shjs . test ( " -e " , filename ) ) { find File Results [ filename ] = filename ; return filename ; } if ( dir = = = parent ) { find File Results [ filename ] = null ; return null ; } return find File ( name , parent ) ; } 
function ( view , offset , length ) { var trm Offset = lib . locate Seq ( [ 0 , 0 ] , view , offset , length ) ; if ( trm Offset = = = - 1 ) { return - 1 ; } if ( ( trm Offset - offset ) % 2 ! = = 0 ) { + + trm Offset ; } return trm Offset ; } 
function ( view , offset , length ) { return String . from Char Code . apply ( null , new Uint 8Array ( view . buffer , offset , length ) ) ; } 
function ( view , offset , length ) { 
function ( view , offset , length ) { var trm Offset = lib . locate Str Trm . iso ( view , offset , length ) ; if ( trm Offset ! = = - 1 ) { length = trm Offset - offset ; } return lib . read Str . iso ( view , offset , length ) ; } 
function ( view , offset , length ) { var trm Offset = lib . locate Str Trm . ucs ( view , offset , length ) ; if ( trm Offset ! = = - 1 ) { length = trm Offset - offset ; } return lib . read Str . ucs ( view , offset , length ) ; } 
function Mailto ( form , options ) { this . form = null ; this . prevent Default = true ; this . formatter = Mailto . default Formatter ; this . on Submit = function ( m ) { } ; this . init Form Object ( form ) ; this . init Options ( options ) ; this . init Form Handler ( ) ; } 
function get Mailto Url ( to , fields ) { this . form . action . match ( / mailto : ( [ ^ \ ? & ] + ) / ) ; to = to | | Reg Exp . $ 1 | | ' ' ; fields = fields | | { subject : this . form . get Attribute ( 'data -subject ' ) | | ' ' , body : this . get Body ( ) } ; if ( ! to & & ! fields . to ) { throw new Error ( 'Could not find any person to send an email to . ' ) ; } return 'mailto : ' + to + ' ? ' + Object . keys ( fields ) . reduce ( function ( a , b , i ) { return a + ( i > 0 ? ' & ' : ' ' ) + encode URIComponent ( b ) + ' = ' + encode URIComponent ( fields [ b ] ) . replace ( / % 0A ( ? ! % ) / g , ' % 0D % 0A ' ) + 
function get Form Data ( ) { var form = this . form ; var selector = [ 'input ' , 'select ' , 'textarea ' ] . join ( ' , ' ) ; return [ ] . slice . call ( form . query Selector All ( selector ) ) . filter ( Mailto . form Data Filter ) . map ( Mailto . form Data Mapper ( form ) ) ; } 
function get Data ( ) { var data = { } ; this . get Form Data ( ) . for Each ( function ( d ) { if ( Array . is Array ( data [ d . name ] ) ) { data [ d . name ] . push ( d . value ) ; } else if ( data [ d . name ] ! = = undefined ) { data [ d . name ] = [ data [ d . name ] , d . value ] ; } else { data [ d . name ] = d . value ; } } ) ; return data ; } 
function get Serialised Data ( ) { var data = this . get Form Data ( ) ; return data . length = = = 0 ? ' ' : ' ? ' + data . map ( function ( f ) { return encode URIComponent ( f . name ) + ' = ' + encode URIComponent ( f . value ) ; } ) . join ( ' & ' ) ; } 
function parse Date ( day String , month String , year String ) { const initial Date = { day : parse And Constrain ( 1 , 3 1 , day String ) , month : parse And Constrain ( 1 , 1 2 , month String ) , year : parse And Constrain ( 1 , 2 5 0 0 , year String ) , } ; const date Is Valid = flow ( to Milliseconds , milliseconds To Breakdown Date , parsed = > JSON . stringify ( initial Date ) = = = JSON . stringify ( parsed ) ) ( initial Date ) ; if ( ! date Is Valid ) { 
function register XDiv ( ) { 
function x Controller ( callback ) { 'use strict ' ; var execute = function execute ( ) { callback . call ( document . current Script . parent Element , document . current Script . parent Element ) ; } ; 
function process Condition ( condition , error Message ) { if ( ! condition ) { var complete Error Message = ' ' ; var re = / at ( [ ^ \s ] + ) \s \ ( / g ; var stack Trace = new Error ( ) . stack ; var stack Functions = [ ] ; var func Name = re . exec ( stack Trace ) ; while ( func Name & & func Name [ 1 ] ) { stack Functions . push ( func Name [ 1 ] ) ; func Name = re . exec ( stack Trace ) ; } 
function assert ( condition , error Message ) { var error = process Condition ( condition , error Message ) ; if ( typeof error = = = 'string ' ) { throw new Error ( error ) ; } } 
function get Parent Field ( el ) { if ( ! el | | ! el . parent Node ) { return el ; } return el . class List . contains ( 'fl -fb -Field ' ) ? el : get Parent Field ( el . parent Node ) ; } 
function Credulous ( options ) { var i ; if ( ! this ) { return new Credulous ( options ) ; } options = validate Options ( options ) ; this . labels = options . labels ; this . data Length = options . data Length ; 
function set Up Data Store ( data Store , labels , data Length ) { var i ; for ( i = 0 ; i < data Length ; i + + ) { data Store [ i ] = { words : { } , labels : { } } ; labels . for Each ( function ( label ) { data Store [ i ] . labels [ label ] = 0 ; } ) ; } } 
function arg Max ( array ) { var max Index = 0 , i ; for ( i = 0 ; i < array . length ; i + + ) { if ( array [ i ] > array [ max Index ] ) { max Index = i ; } } return max Index ; } 
function process Data Items ( items ) { var processed Items = [ ] ; 
function add Label ( label , self ) { if ( ! ( label in self . labels ) ) { self . labels [ label ] = 1 ; } else { self . labels [ label ] + + ; } } 
function File Queue ( limit , new Queue ) { if ( typeof limit = = = 'boolean ' ) { new Queue = limit ; limit = null ; } if ( ! limit ) { limit = 2 0 0 ; 
function from Json ( winston Conf , callback ) { if ( _is Empty ( winston Conf ) ) { callback ( new Error ( 'Empty winston configuration ' ) , winston ) ; return ; } config Logger ( winston Conf ) ; callback ( null , winston ) ; } 
function from File ( filename , callback ) { var config File = filename | | ' . . /config /winston -config .json ' ; fs . exists ( config File , function ( exists ) { if ( exists ) { var winston Conf = require ( config File ) . logging ; from Json ( winston Conf , callback ) ; } else { callback ( new Error ( 'No config file found (at least provide a config /winston -config .json ) with winston configuration ' ) , winston ) ; } } ) ; } 
function from File Sync ( filename ) { var config File = filename | | ' . . /config /winston -config .json ' ; var exists = fs . exists Sync ( config File ) ; if ( exists ) { var winston Conf = require ( config File ) . logging ; if ( _is Empty ( winston Conf ) ) { console . log ( 'Empty winston configuration ' ) ; } else { config Logger ( winston Conf ) ; } } else { console . log ( 'No config file found (at least provide a config /winston -config .json ) with winston configuration ' ) ; } return winston ; } 
function ( id ) { let user = { } let gender = Math . random ( ) > 0 . 5 user . id = ' ' + id user . gender = gender ? 'MALE ' : 'FEMALE ' user . first _name = gender ? random Array Value ( MALE _FIRST _NAMES ) : random Array Value ( FEMALE _FIRST _NAMES ) user . last _name = random Array Value ( LAST _NAMES ) user . email = user . first _name + user . last _name + ' @ ' + random Array Value ( DOMAINS ) user . created At = random Created At Date ( ) user . updated At = random Updated At Date ( user . created At ) 
function Debug ( . . . rest ) { if ( new . target ) { this . debug = ( id , stats , . . . rest ) = > { debug ( id ) ( . . . rest ) ; } ; return ; } return new Debug ( . . . rest ) ; } 
function log ( ctx , start , len , err , event ) { 
function send Message ( id , level , fallback To Log , . . . rest ) { const level Method = level . to Lower Case ( ) ; const options = build Message Options ( id ) ; const tags To Disable = get ( config Registry , 'tags .disable ' , [ ] ) ; const namespace Tags = get ( config Registry , ` $ { id } ` , [ ] ) ; const contains Disabled Tag = tags To Disable . some ( ( element ) = > { return namespace Tags . index Of ( element ) > - 1 ; } ) ; if ( options . disable . index Of ( level ) > - 1 | | contains Disabled Tag ) { 
function calc Stats ( ) { return { max Id Length : Math . max ( . . . Object . keys ( loggers ) . map ( ( l ) = > l . length ) ) } ; } 
function apply Plugins ( plugins = [ ] , id , level , stats , . . . rest ) { if ( ! Array . is Array ( plugins ) | | ! plugins . every ( ( p ) = > typeof p = = = 'function ' ) ) { throw new Error ( 'Plugins MUST be an array of functions ' ) ; } const args = Object . freeze ( rest . map ( ( arg ) = > Object . freeze ( arg ) ) ) ; 
function create Logger ( id ) { let log = ( level , fallback To Log , . . . rest ) = > send Message ( id , level , fallback To Log , . . . rest ) ; return { get id ( ) { return id ; } , silly ( . . . rest ) { log ( LEVELS . SILLY , true , . . . rest ) ; } , debug ( . . . rest ) { log ( LEVELS . DEBUG , true , . . . rest ) ; } , info ( . . . rest ) { log ( LEVELS . INFO , true , . . . rest ) ; } , warn ( . . . rest ) { log ( LEVELS . WARN , true , . . . rest ) ; } , error ( . . . rest ) { log ( LEVELS . ERROR , true , . . . rest ) ; } , 
function get Logger ( id , { disable = [ ] , wrappers = [ ] , tags = [ ] } = { } ) { let config = { disable : normalize Array ( disable ) . map ( v = > v + ' ' ) , wrappers : normalize Array ( wrappers ) , tags : normalize Array ( tags ) } ; set ( config Registry , ` $ { id } ` , deepmerge ( get ( config Registry , ` $ { id } ` , { } ) , config , deep Merge Options ) ) ; return loggers [ id ] | | ( loggers [ id ] = create Logger ( id ) ) ; } 
function configure ( { use Global = true , disable = [ ] , namespaces = { } , tags = { } , verbose = false } = { } , override = false ) { const config = Object . create ( null ) ; config . use Global = ! ! use Global ; config . disable = normalize Array ( disable ) . map ( v = > v + ' ' ) ; config . namespaces = namespaces ; config . tags = { disable : normalize Array ( get ( tags , 'disable ' , [ ] ) ) } ; config . verbose = verbose ; config Registry = override ? config : deepmerge ( config Registry , config , deep Merge Options ) ; } 
function add Wrapper ( wrapper , { pass Initial Arguments = false , plugins = [ ] } = { } ) { const opts = { pass Initial Arguments , plugins : normalize Array ( plugins ) } ; if ( typeof wrapper = = = 'object ' & & ! Array . is Array ( wrapper ) & & ( typeof wrapper . log = = = 'function ' | | Object . keys ( LEVELS ) . some ( ( lvl ) = > typeof wrapper [ lvl . to Lower Case ( ) ] = = = 'function ' ) ) ) { 
function add Plugin ( use Level , fn ) { let plugin Fn = fn ; if ( typeof fn = = = 'undefined ' & & typeof use Level = = = 'function ' ) { plugin Fn = use Level ; } if ( typeof plugin Fn ! = = 'function ' ) { throw new Error ( 'Plugin must be a function ! ' ) ; } if ( typeof use Level = = = 'string ' ) { plugin Fn = ( id , level , stats , . . . rest ) = > { if ( level = = = use Level . to Upper Case ( ) ) { return fn ( id , level , stats , . . . rest ) ; } return [ id , level , stats , . . . rest ] ; } ; } plugins Registry . push ( plugin Fn ) ; } 
function ( ) { var self = this return { version : ' 1 . 0 . 0 ' , 
function ( ) { var self = this var endpoints = new Array ( ) var flatten = function ( eps , top Level , parent Path ) { for ( var _path in eps ) { if ( self . _include Undocumented | | ! eps [ _path ] . no Document ) { var abs Path = path . join ( parent Path , _path ) endpoints . push ( { path : abs Path , top Level : top Level , endpoint : eps [ _path ] } ) if ( eps [ _path ] . endpoints ) { flatten ( eps [ _path ] . endpoints , false , abs Path ) } } } } flatten ( self . _service . endpoints , true , ' / ' ) var methods = _o ( ' . . /Endpoint ' ) . prototype . ALL _METHODS for ( var i = 0 ; i < endpoints . length ; i + + ) { var operations = methods . map ( function ( m ) { if ( endpoints [ i ] . endpoint [ m ] & & ( self . _include Undocumented | | ! endpoints [ i ] . endpoint [ m ] . no Document ) & & ( m ! = "options " | | self . _service . generate Options Methods In Docs ) ) { return self . _generate Operation Descriptor ( m , endpoints [ i ] . endpoint [ m ] , endpoints [ i ] . path ) } return undefined } ) . filter ( function ( e ) { return e ? true : false ; } ) if ( operations . length = = 0 ) { continue } endpoints [ i ] = { path : endpoints [ i ] . path , description : endpoints [ i ] . endpoint . description , top Level : endpoints [ i ] . top Level , parameters : self . _generate Parameter Descriptors ( endpoints [ i ] . endpoint . parameters , undefined , endpoints [ i ] . path ) , allow Unauthenticated : endpoints [ i ] . endpoint . allow Unauthenticated , operations : operations } } endpoints = _ . sort By ( endpoints , [ 'path ' ] ) return endpoints } 
function ( method , operation , path _ ) { var self = this var all Parameters = operation . get All Parameters ( ) var inherited Parameters = _ . keys ( all Parameters ) . reduce ( function ( obj , e ) { if ( ! ( e in operation . parameters ) ) { obj [ e ] = all Parameters [ e ] } return obj } , { } ) var parameter Descriptors = self . _generate Parameter Descriptors ( operation . parameters , inherited Parameters , path _ ) 
function ( parameters , inherited Parameters , path _ ) { var _parameters = { 'path ' : [ ] , 'query ' : [ ] , 'body ' : [ ] , 'header ' : [ ] } self = this var descriptor = function ( parameter , inherited ) { return { name : parameter . name , description : parameter . description , location : parameter . location , schema : self . _remove No Document Properties ( parameter . schema ) , example : parameter . example , required : parameter . required , default : parameter . default , inherited : inherited , } } if ( ! _ . is Undefined ( inherited Parameters ) ) { for ( var parameter in inherited Parameters ) { if ( this . _include Undocumented | | ! inherited Parameters [ parameter ] . no Document ) { _parameters [ inherited Parameters [ parameter ] . location ] . push ( descriptor ( inherited Parameters [ parameter ] , true ) ) } } } for ( var parameter in parameters ) { if ( this . _include Undocumented | | ! parameters [ parameter ] . no Document ) { _parameters [ parameters [ parameter ] . location ] . push ( descriptor ( parameters [ parameter ] , false ) ) } } var existing Path Params = _ . map ( _parameters . path , function ( val ) { return val . name } ) _parameters . path = _ . concat ( _parameters . path , this . _get Path Parameters ( path _ , existing Path Params ) ) for ( var location in _parameters ) { if ( _parameters [ location ] . length = = 0 ) { delete _parameters [ location ] } } return _parameters } 
function ( responses ) { assert ( _ . is Object ( responses ) ) self = this var descriptor = function ( response ) { return { name : response . status Code . to String ( ) , status Code : response . status Code , description : response . description , schema : self . _remove No Document Properties ( response . schema ) , example : response . example , headers : response . headers . length = = = 0 ? null : _ . join ( _ . map ( response . headers , function ( header ) { return _ . trim ( header . to String ( ) ) } ) , ' \n ' ) } } return _ . sort By ( _ . map ( responses , descriptor ) , function ( r ) { return r . name } ) } 
function ( ) { var self = this 
function ( ) { var help = handlebars . Utils . escape Expression ( this . _service . get Usage ( ) ) handlebars . register Partial ( 'Service Help ' , ` $ { help } ` ) handlebars . register Partial ( 'schema Elements ' , ` ` ) } 
function ( objects , options ) { var self = this objects . for Each ( function ( object ) { self . cache [ object . _id ] = object } ) return objects } 
function ( options ) { var self = this var result = [ ] if ( options . _id ) { var id = Array . is Array ( options . _id ) ? options . _id : [ options . _id ] id . for Each ( function ( id ) { if ( self . cache [ id ] ) { result . push ( self . cache [ id ] ) } } ) } else { result = Object . keys ( this . cache ) . map ( function ( k ) { return self . cache [ k ] } ) . sort ( function ( count 1 , count 2 ) { return count 1 . _id - count 2 . _id } ) if ( options . skip | | options . limit ) { var skip = options . skip | | 0 var limit = options . limit | | 0 return result . slice ( skip , skip + limit ) } } return result } 
function ( objects , options ) { var id Set = new Set ( objects . map ( function ( object ) { return object . _id } ) ) if ( id Set . length < objects . length ) { throw new this . get Service ( ) . errors . Bad Request ( 'Duplicate IDs ' ) } this . cache = objects return objects } 
function ( object , options ) { var created = typeof this . cache [ object . _id ] = = = 'undefined ' this . cache [ object . _id ] = object return { created : created , val : object } } 
function ( update , options ) { var count = 0 for ( var id in this . cache ) { count + = 1 if ( update . $inc ) { this . cache [ id ] . count + = update . $inc } else { this . cache [ id ] . count - = update . $dec } } return count } 
function ( options ) { var objects = [ ] for ( var id in this . cache ) { objects . push ( this . cache [ id ] ) } this . cache = { } return objects } 
function ( update , options ) { var count = 0 for ( var id in this . cache ) { this . cache [ id ] . count + = update . n count + = 1 } 
function ( object , options ) { return this . collection . find One And Replace ( { _id : object . _id } , object , { return Original : false } ) . value } 
async function my New Package ( config = { } ) { const { should Run = true , text , } = config if ( ! should Run ) return LOG ( 'my -new -package called with %s ' , text ) return text } 
function add Handler ( cls , replacer , reviver ) { if ( typeof cls ! = = "function " ) { throw new Type Error ( " 'cls ' must be class /function " ) ; } if ( typeof replacer ! = = "function " ) { throw new Type Error ( " 'replacer ' must be function " ) ; } if ( typeof reviver ! = = "function " ) { throw new Type Error ( " 'reviver ' must be function " ) ; } _ _handlers [ cls . name ] = { cls : cls , replacer : replacer , reviver : reviver } ; } 
function ( object , options ) { var col = this . service . db . get Collection ( path . basename ( this . path ) ) return col . insert Object ( obj ) } 
function ( options ) { 
function ( ) { this . object = null this . owner Field = ' _ _owner _ _ ' this . permission Definitions = { 
function ( ) { _o ( ' . /Acl ' ) . prototype . _init . call ( this ) 
function ( user , object ) { 
function ( user , filter Single Value , filter Arrays , acl ) { return sanitize ( this . object , user , filter Single Value , filter Arrays , acl ) } 
function sanitize ( value , user , filter Single Value , filter Arrays , acl ) { var result = do Sanitize ( value , user , filter Arrays , acl ) if ( typeof ( value ) = = = 'object ' & & result = = = undefined ) { if ( ! filter Single Value ) { throw new Error ( "User unauthorized to see value " ) 
function do Sanitize ( value , user , filter Arrays , acl ) { if ( ! value ) { return value } var result = value if ( value . constructor = = = Array ) { result = do Sanitize Array ( value , user , filter Arrays , acl ) } else if ( typeof ( value ) = = = 'object ' ) { result = do Sanitize Object ( value , user , filter Arrays , acl ) } return result } 
function do Sanitize Array ( arr , user , filter Arrays , acl ) { var result = [ ] var processed Elem arr . for Each ( function ( elem ) { if ( typeof ( elem ) = = = 'object ' ) { processed Elem = do Sanitize ( elem , user , filter Arrays , acl ) 
function do Sanitize Object ( obj , user , filter Arrays , acl ) { var result = obj var final Acl = undefined var obj Acl Datum = obj . _ _acl _ _ if ( obj Acl Datum ) { obj Acl = o ( acl Datum , null , module . exports ) 
function add Extras ( callback ) { var n = 0 ; async . each Series ( data . _people Info | | [ ] , function ( person Info , callback ) { var set = { $set : { } } ; var extras = { } ; 
function if Status Ok ( response , fulfill , reject ) { var response Code = response . code ; if ( is Client Error ( response Code ) ) { reject ( { name : "Client Error Exception " , message : response . body } ) ; } else if ( is Server Error ( response Code ) ) { reject ( { name : "Server Error Exception " , message : response . error } ) ; } else if ( is Other Error Response ( response Code ) ) { reject ( { name : "Other Communication Exception " , message : response . error } ) ; } else { fulfill ( response . body ) } } 
function ( ) { this . permission Definitions = { 
function ( user , permission , env ) { if ( permission = = = 'get ' ) { return this . has Permission ( user , 'find ' , env ) } if ( permission = = = 'patch ' ) { return this . has Permission ( user , 'update ' , env ) } if ( permission = = = 'post ' ) { 
function directories Under ( root Dir ) { return directory Contents ( root Dir , stats = > stats . is Directory ( ) , ( path , stats ) = > path ) } 
function files Under ( root Dir ) { return directory Contents ( root Dir , stats = > ( stats . is File ( ) & & stats . size ! = = 0 ) , ( path , stats ) = > [ path , stats . size ] ) } 
async function directory Contents ( root Dir , filter , transform ) { const items = await readdir Async ( root Dir ) debug ( ` $ { items } ` ) const stated Items = await Promise . all ( items . map ( async item = > { const item Path = path . join ( root Dir , item ) const stats = await lstat Async ( item Path ) return filter ( stats ) ? transform ( item Path , stats ) : null } ) ) const dirs = stated Items . filter ( d = > ! ! d ) return dirs } 
function ( ) { this . description = undefined this . example = undefined this . no Document = false this . allow Unauthenticated = false this . id Parameter Name = undefined this . parameters = { } this . options = undefined this . responses = { } this . endpoint = null } 
function ( schema ) { var _schema = schema . type = = = 'array ' ? schema . items : schema if ( ! _ . is Nil ( _schema . properties ) & & _schema . properties [ this . id Parameter Name ] ) { _schema = _ . clone ( _schema ) if ( _schema . required ) { _schema . required = _ . difference ( _schema . required , [ this . id Parameter Name ] ) if ( _ . is Empty ( _schema . required ) ) { delete _schema . required } } if ( _schema . additional Properties ) { delete _schema . additional Properties } if ( schema . type = = = 'array ' ) { schema = _ . clone ( schema ) schema . items = _schema } else { schema = _schema } } return schema } 
function ( ) { this . id Parameter Name = ' _id ' * @property {string } [db Name ] - - The database name . Note , this is only needed if * the { @link carbond .Service } instance connects * to multiple databases * / this . db Name = undefined * @property {string } collection Name - - The database collection name * / this . collection Name = undefined this . query Schema = undefined this . update Schema = undefined this . update Object Schema = undefined } 
function ( ) { var self = this 
function ( options , context ) { var self = this var query = undefined if ( ! _ . is Nil ( options . query ) ) { query = _ . clone ( options . query ) 
function ( config , req , res , context ) { var options = Collection . prototype . pre Find Object Operation . apply ( this , arguments ) options . driver Options = config . driver Options if ( ! _ . is Nil ( options . projection ) ) { options . driver Options . fields = options . projection delete options . projection } return options } 
function ( objects , options , context ) { var result = undefined var rename Result = undefined var tmp Collection Name = uuid ( ) + ' - ' + this . collection var tmp Collection = this . db . get Collection ( tmp Collection Name ) try { result = tmp Collection . insert Many ( objects , options . driver Options ) rename Result = tmp Collection . rename ( this . collection Name , { drop Target : true } ) } finally { if ( _ . is Nil ( rename Result ) ) { tmp Collection . drop ( ) } } return result . ops } 
function ( config , req , res , context ) { var options = Collection . prototype . pre Save Object Operation . call ( this , config , req , res ) options . driver Options = _ . clone ( config . driver Options ) options . driver Options . return Original = false if ( config . supports Upsert ) { options . driver Options . upsert = true } return options } 
function ( object , options , context ) { var result = this . collection . find One And Replace ( { _id : object . _id } , object , options . driver Options ) return { val : result . value , created : options . driver Options . upsert & & ! result . last Error Object . updated Existing } } 
function ( config , req , res , context ) { var options = Collection . prototype . pre Update Operation . apply ( this , arguments ) options . driver Options = config . driver Options return options } 
function ( update , options , context ) { var driver Options = { } if ( options . upsert ) { driver Options = _ . assign In ( driver Options , options . driver Options , { upsert : true } ) } var result = undefined try { var result = this . collection . update Many ( options . query , update , driver Options ) } catch ( e ) { 
function ( id , update , options , context ) { var driver Options = { } if ( options . upsert ) { driver Options = _ . assign In ( driver Options , options . driver Options , { upsert : true } ) } 
function ( id , options , context ) { try { this . collection . delete Object ( id , options . driver Options ) return 1 } catch ( e ) { if ( e instanceof leafnode . errors . Leafnode Object Set Operation Error ) { return e . deleted Count } throw e } } 
function ( ) { Limiter . prototype . _init . call ( this ) if ( ! ( this . selector instanceof Limiter Selector ) ) { throw new Type Error ( ' "selector " must be an instance of `Limiter Selector ` ' ) } if ( ! ( this . policy instanceof Limiter Policy ) ) { throw new Type Error ( ' "policy " must be an instance of `Limiter Policy ` ' ) } } 
function ( service , node ) { Limiter . prototype . initialize . call ( this , service , node ) 
function ( req , res , next ) { var selector = this . selector . key ( req ) if ( this . policy . allow ( req , res , selector ) ) { next ( ) } else { this . send Unavailable ( res , next ) } } 
function ( ) { * @property {xxx } _all Parameters - - xxx * / this . _all Parameters = undefined * @property {string } name - - The operation name (i .e . , HTTP method ) * @readonly * / this . name = undefined this . endpoint = undefined * @property {string } [description ] - - A brief description of what this operation * does . This will be displayed in any * generated documentation . * / this . description = undefined this . parameters = { } this . responses = { } this . validate Output = true this . limiter = undefined } 
function ( ) { if ( this . _all Parameters ) { return this . _all Parameters } 
function ( endpoint , all ) { if ( ! _ . is Nil ( endpoint ) ) { all = _ . assign In ( _ . clone ( all Endpoint Parameters ( endpoint . parent , endpoint . parameters ) ) , all | | { } ) } return all } 
function ( ) { for ( var status Code in this . responses ) { var Operation Response = _o ( ' . /Operation Response ' ) if ( ! ( this . responses [ status Code ] instanceof Operation Response ) ) { if ( _ . is Plain Object ( this . responses [ status Code ] ) ) { this . responses [ status Code ] = o ( this . responses [ status Code ] , Operation Response ) } else { throw new Error ( 'Malformed response spec . ' + JSON . stringify ( this . responses [ status Code ] ) ) } } } } 
function ( req ) { var parsed = url . parse ( req . original Url ) 
function get Src Info ( stack ) { const file Line No Arr = [ ] ; const end = Math . min ( callsite Stack Depth , stack . length - 1 ) ; for ( let i = 1 ; i < = end ; + + i ) { const call = stack [ i ] ; 
function configure App ( app , config ) { app . set ( 'query parser ' , 'simple ' ) ; app . set ( 'x -powered -by ' , false ) ; if ( thorin . env = = = 'production ' ) { app . set ( 'env ' , 'production ' ) ; } app . set ( 'views ' , undefined ) ; app . set ( 'view cache ' , false ) ; if ( config . trust Proxy ) { app . set ( 'trust proxy ' , true ) ; } } 
function get Authorization Data ( config , req ) { let data = null , types = Object . keys ( config ) ; for ( let i = 0 ; i < types . length ; i + + ) { let auth Type = types [ i ] , auth Name = config [ auth Type ] ; if ( auth Type = = = 'header ' ) { try { let tmp = req . headers [ auth Name ] | | req . headers [ auth Name . to Lower Case ( ) ] | | null ; if ( typeof tmp ! = = 'string ' | | ! tmp ) throw 1 ; if ( tmp . index Of ( 'Bearer ' ) = = = 0 ) { tmp = tmp . substr ( 7 ) ; } tmp = tmp . trim ( ) ; if ( tmp = = = ' ' ) throw 1 ; data = tmp ; break ; } catch ( e ) { } } if ( auth Type = = = 'cookie ' ) { try { let tmp = cookie . parse ( req . headers [ 'cookie ' ] ) ; if ( typeof tmp [ auth Name ] ! = = 'string ' ) throw 1 ; tmp = tmp [ auth Name ] . trim ( ) ; if ( tmp = = = ' ' ) throw 1 ; data = tmp ; break ; } catch ( e ) { } } } return data ; } 
function register Favicon ( app , config ) { if ( typeof config . static ! = = 'string ' | | ! config . static ) return ; let stat ; 
function register Middleware ( app , config ) { if ( config . authorization & & typeof config . authorization . basic = = = 'object ' & & config . authorization . basic ) { register Basic Auth ( app , config . authorization . basic ) ; } 
function handle Request Not Found ( req , res , next ) { if ( typeof req . unique Id = = = 'undefined ' ) { if ( unique Request Id > = MAX _REQUEST _ID ) { unique Request Id = 0 ; } req . unique Id = + + unique Request Id ; } req . start At = Date . now ( ) ; let msg = 'The requested resource was not found ' ; if ( this [ config ] . action Path ! = = req . url ) { msg + = ` $ { req . method } $ { req . url } ` ; } else if ( req . _action Type ) { msg + = ' : ' + req . _action Type ; } return next ( thorin . error ( 'TRANSPORT .NOT _FOUND ' , msg , 4 0 4 ) ) ; } 
function handle Request Error ( err , req , res , next ) { 
function register Basic Auth ( app , auth Config ) { if ( typeof auth Config . user ! = = 'string ' | | typeof auth Config . password ! = = 'string ' ) return ; app . use ( ( req , res , next ) = > { let credentials = basic Auth ( req ) ; if ( ! credentials | | credentials . name ! = = auth Config . user | | credentials . pass ! = = auth Config . password ) { res . set Header ( 'WWW -Authenticate ' , ` $ { config . realm | | 'app ' } ` ) ; return next ( thorin . error ( 'UNAUTHORIZED ' , 'Authorization failed ' , 4 0 1 ) ) ; } next ( ) ; } ) ; } 
function register Cors ( app , cors Config , cors Ignore ) { if ( cors Config = = = false ) return ; let domains = [ ] ; if ( typeof cors Config = = = 'string ' ) { domains = cors Config . split ( ' ' ) ; } else if ( cors Config instanceof Array ) { domains = cors Config ; } app . use ( ( req , res , next ) = > { let origin = req . headers [ 'origin ' ] | | req . headers [ 'referer ' ] | | null , should Add Headers = false , raw Origin = origin ; if ( typeof raw Origin = = = 'string ' ) { let qs Idx = raw Origin . index Of ( ' ? ' ) ; if ( qs Idx ! = = - 1 ) { raw Origin = raw Origin . substr ( 0 , qs Idx ) ; } } if ( cors Config = = = true ) { should Add Headers = true ; } else if ( domains . length > 0 & & typeof origin = = = 'string ' ) { origin = get Raw Origin ( origin ) ; for ( let i = 0 ; i < domains . length ; i + + ) { let domain = domains [ i ] , is Match = match Cors Origin ( domain , origin , raw Origin ) ; if ( is Match ) { should Add Headers = true ; break ; } } } if ( ! should Add Headers ) return next ( ) ; 
function parse Request Input ( source , target ) { let keys = Object . keys ( source ) ; if ( keys . length = = = 1 ) { 
function handle Incoming Request ( action Type , alias , req , res , next ) { if ( typeof req . unique Id = = = 'undefined ' ) { req . unique Id = + + unique Request Id ; req . start At = Date . now ( ) ; } if ( ! req . action ) { req . action = action Type ; } if ( typeof this [ actions ] [ action Type ] = = = 'undefined ' ) { let msg = 'The requested resource was not found ' ; if ( this [ config ] . action Path ! = = req . url ) { msg + = ` $ { req . method } $ { req . url } ` ; } return handle Request Error . call ( this , thorin . error ( 'TRANSPORT .NOT _FOUND ' , msg , 4 0 4 ) , req , res , next ) ; } req . _has Debug = this [ actions ] [ action Type ] . has Debug ; req . expose Type = ( this [ actions ] [ action Type ] . default Handle = = = true ) ; 
function handle Intent Redirect ( req , res , intent Obj , redirect Url , redirect Code ) { try { res . redirect ( redirect Code , redirect Url ) ; } catch ( e ) { logger ( 'warn ' , "Failed to perform redirect on action " + req . action , e ) ; } if ( req . _has Debug ! = = false ) { let log Msg = ' [ENDED ' + req . unique Id + " ] - " , took = Date . now ( ) - req . start At ; log Msg + = req . action + ' ' ; log Msg + = " ( " + req . method . to Upper Case ( ) + ' ' + req . original Url . substr ( 0 , 6 4 ) + ' ) ' ; log Msg + = ' = ' + redirect Code + ' = > ' + redirect Url + ' ' ; log Msg + = ' ( ' + took + 'ms ) ' ; logger ( 'trace ' , log Msg ) ; } } 
function handle Intent Success ( req , res , next , data , intent Obj ) { let took = Date . now ( ) - req . start At , status = 2 0 0 , is Done = false ; try { if ( typeof res . status Code ! = = 'number ' ) { res . status ( status ) ; } if ( res . headers Sent ) { is Done = true ; } } catch ( e ) { } if ( is Done ) { try { res . end ( ) ; } catch ( e ) { } } else { 
function handle Intent Error ( req , res , next , data , intent Obj ) { if ( intent Obj . has Raw Result ( ) ) { data . raw Data = intent Obj . result ( ) ; } req . intent = intent Obj ; return handle Request Error . call ( this , data , req , res , next ) ; } 
function register Action Path ( verb , url , action Name ) { var app = this [ server ] ; var req Handler = handle Incoming Request . bind ( this , action Name , url ) ; app [ verb ] ( url , req Handler ) ; 
function set Cors ( req , res , verb ) { let dom = this [ config ] . cors ; if ( dom = = = true ) { dom = req . headers [ 'origin ' ] | | ' * ' ; } else if ( dom instanceof Array ) { if ( ! req . headers [ 'origin ' ] ) { dom = false ; } else { let found = false ; for ( let i = 0 , len = dom . length ; i < len ; i + + ) { if ( dom [ i ] . index Of ( req . headers [ 'origin ' ] ) = = = - 1 ) continue ; found = true ; dom = dom [ i ] ; break ; } if ( ! found ) return ; } } 
function handle Request ( req , res , next ) { set Cors . call ( this , req , res , verb ) ; req . unique Id = + + unique Request Id ; req . start At = Date . now ( ) ; if ( typeof req . body ! = = 'object ' | | ! req . body | | typeof req . body . type ! = = 'string ' | | req . body . type = = = ' ' ) { return next ( thorin . error ( 'TRANSPORT .INVALID _TYPE ' , 'Invalid or missing action type ' , 4 0 4 ) ) ; } let action Type = req . body . type , was Found = true ; if ( ! this [ actions ] [ action Type ] | | ! this [ actions ] [ action Type ] . default Handle ) { was Found = false ; } else { req . action = action Type ; } if ( ! was Found ) { for ( let i = 0 , len = this [ action Patterns ] . length ; i < len ; i + + ) { let item = this [ action Patterns ] [ i ] ; if ( item . match . test ( action Type ) ) { was Found = true ; req . action = action Type ; action Type = item . action ; break ; } } } if ( ! was Found ) { req . _action Type = action Type ; return handle Request Not Found . call ( this , req , res , next ) ; } let payload = ( typeof req . body . payload = = = 'object ' & & req . body . payload ? req . body . payload : { } ) ; if ( typeof req . body . filter = = = 'object ' & & req . body . filter ) { req . filter = req . body . filter ; } if ( typeof req . body . meta = = = 'object ' & & req . body . meta ) { req . meta = req . body . meta ; } req . url = req . action ; req . body = payload ; req . query = { } ; req . params = { } ; handle Incoming Request . call ( this , action Type , null , req , res , next ) ; } 
function Apos Groups ( options ) { var self = this ; apos Schemas . add Field Type ( { name : 'a 2Permissions ' , displayer : function ( snippet , name , $field , $el , field , callback ) { _ . each ( apos . data . apos Groups . permissions , function ( permission ) { $el . find By Name ( permission . value ) . val ( _ . contains ( snippet . permissions | | [ ] , permission . value ) ? ' 1 ' : ' 0 ' ) ; } ) ; return callback ( ) ; } , converter : function ( data , name , $field , $el , field , callback ) { _ . each ( apos . data . apos Groups . permissions , function ( permission ) { data [ permission . value ] = $el . find By Name ( permission . value ) . val ( ) ; } ) ; return callback ( ) ; } } ) ; apos Schemas . add Field Type ( { name : 'a 2People ' , displayer : function ( snippet , name , $field , $el , field , callback ) { var source = apos Pages . get Type ( 'people ' ) . _action + ' /autocomplete ' ; $ . json Call ( source , { values : _ . map ( snippet . people | | [ ] , function ( person ) { return person . _id ; } ) } , function ( results ) { var label Map = { } ; _ . each ( results , function ( result ) { label Map [ result . value ] = result . label ; } ) ; $el . find ( ' [data -name = "people " ] ' ) . selective ( { sortable : options . people Sortable , extras : field . extras , source : source , data : _ . map ( snippet . _people | | [ ] , function ( person ) { var label = label Map [ person . _id ] ; var data = { label : label , value : person . _id } ; if ( person . group Extras & & person . group Extras [ snippet . _id ] ) { $ . extend ( true , data , person . group Extras [ snippet . _id ] ) ; } return data ; } ) } ) ; return callback ( ) ; } ) ; } , converter : function ( data , name , $field , $el , field , callback ) { data . _people Info = $el . find ( ' [data -name = "people " ] ' ) . selective ( 'get ' , { incomplete : true } ) ; return callback ( ) ; } } ) ; Apos Snippets . call ( self , options ) ; self . adding To Manager = function ( $el , $snippet , snippet ) { $snippet . find ( ' [data -published ] ' ) . val ( snippet . published ? 'Yes ' : 'No ' ) ; } ; } 
function ( ) { this . self And Below = false * @property {object } permission Definitions - - mapping of permissions to * defaults * / this . permission Definitions = { 
function ( p ) { var is Roll Left = roll = = null | | roll . get Depth ( ) > = 1 if ( roll ) { roll . up ( ) } if ( is Roll Left ) { next ( ) } else { callback ( null , null , result Status ) / /could not be found / /fail ( ) } } 
async function supercopy ( options , callback ) { try { preprocess ( options ) const file Info = await collect File Info ( options ) let statements = generate Script Statements ( file Info , options ) statements = annotate Copy Statements ( statements ) await options . client . run ( statements ) callback ( null ) } catch ( err ) { callback ( err ) } } 
function figure Out Who User Is ( req ) { 
function freeze Properties ( object , prototype ) { if ( ! _ . is Object Like ( object ) ) { throw new Type Error ( 'freeze Properties requires a valid object to be passed ' ) } var next = _ . is Nil ( prototype ) ? object : prototype if ( _ . is Array ( next . _frozen Properties ) ) { next . _frozen Properties . for Each ( function ( prop Name ) { var prop = object [ prop Name ] Object . define Property ( object , prop Name , { configurable : false , enumerable : true , value : prop , writable : false } ) } ) } if ( ! _ . is Nil ( Object . get Prototype Of ( next ) ) ) { freeze Properties ( object , Object . get Prototype Of ( next ) ) } } 
function ( ) { this . server Cert Path = null , this . server Key Path = null , this . server Key Passphrase = null , this . trusted Certs Paths = null , * @property {string ? } [crl ] - - A certificate revocation list in PEM format * / this . crl = null , this . ciphers = null , this . ecdh Curve = null , this . dhparam = null , this . handshake Timeout = null , this . honor Cipher Order = true , this . request Cert = false , this . reject Unauthorized = false , this . check Server Identity = null , this . NPNProtocols = null , this . SNICallback = null , this . session Timeout = null , this . ticket Keys = null , this . session Id Context = null , this . secure Protocol = 'TLSv 1 _method ' , * @property {xxx } secure Options - - xxx * @todo this doesn 't appear to be used anywhere . get rid of it ? * @ignore * / this . secure Options = null } 
function ( ) { var result = { } _ . extend ( result , this ) result . cert = fs . read File Sync ( this . server Cert Path ) result . key = fs . read File Sync ( this . server Key Path ) if ( this . trusted Certs Paths ) { result . ca = this . _load Certificates ( this . trusted Certs Paths ) } if ( this . server Key Passphrase ) { result . passphrase = this . server Key Passphrase delete this . server Key Passphrase } return result } 
function ( spec ) { var self = this if ( Array . is Array ( spec ) ) { return spec . reduce ( function ( result , element ) { return result . concat ( self . _load Certificates ( element ) ) } , [ ] ) } else if ( fs . stat Sync ( spec ) . is Directory ( ) ) { 
function ( ) { let parameters = this . parameters for ( let parameter Name in parameters ) { let parameter = parameters [ parameter Name ] if ( ! ( parameter instanceof Operation Parameter ) ) { parameter = o ( _ . assign ( { name : parameter Name } , parameter ) , Operation Parameter ) parameters [ parameter Name ] = parameter 
function ( ) { this . name = undefined this . location = undefined * @property {string } [description ] - - A brief description of this parameter * This will be displayed in any generated * documentation . * / this . description = undefined this . schema = undefined this . required = false this . default = undefined 
function ( ) { if ( ! _ . is String ( this . name ) ) { throw new Type Error ( ` $ { this . name } ` ) } if ( ! _ . is String ( this . location ) | | ! _ . includes ( VALID _LOCATIONS , this . location ) ) { throw new Type Error ( ` $ { this . location } ` + ` $ { VALID _LOCATIONS } ` ) } } 
function ( req ) { if ( ! this . name ) { throw new Error ( "Incomplete parameter definition . No name specified for parameter definition " + this ) } var result = undefined if ( this . location = = = "query " ) { result = req . query [ this . name ] } else if ( this . location = = = "path " ) { result = req . params [ this . name ] } else if ( this . location = = = "header " ) { result = req . header [ this . name ] } else if ( this . location = = = "body " ) { result = req . body } else if ( this . location = = = "form Data " ) { result = req . body & & req . body [ this . name ] } else { throw new Error ( "Unrecognized location value specified for parameter ' " + this . name + " ' : " + this . location ) } 
function ( ) { * @property {string } path - - The URI path that routes to this endpoint . This * is built during service initialization and will * overwrite any value specified on instantiation . * @readonly * / this . path = ' ' * @property {carbond .Endpoint } parent - - The parent endpoint for this * endpoint in the endpoint tree * @readonly * / this . parent = null this . service = null * @property {string } [description ] - - A brief description of what this endpoint * does . This will be displayed in any * generated documentation . * / this . description = undefined this . parameters = { } * @property {carbond .security .Acl } acl - - The access control list for this endpoint * @todo implement /document * @ignore * / this . acl = null * @property {xxx } data Acl - - xxx * @todo implement /document * @ignore * / this . data Acl = null this . sanitizes Output = false this . sanitize Mode = 'strict ' * @property {Array . <string > ? } allow Unauthenticated * @description Skip authentication for the HTTP methods listed on this * endpoint * / this . allow Unauthenticated = null * @property {boolean } [validate Output =true ] * @description Controls whether or not response bodies are validated using * the response { @link carbond .Operation Response .schema } corresponding * to the current response code * / this . validate Output = true this . endpoints = { } this . no Document = false this . limiter = undefined } 
function ( method ) { var self = this var Operation = _o ( ' . /Operation ' ) var operation = this [ method ] if ( typeof ( operation ) = = = 'function ' ) { var op Fn = operation 
function ( method , user , req ) { var acl = this . _cached Full Endpoint Acl if ( acl = = = undefined ) { acl = this . _compute Full Endpoint Acl ( ) this . _cached Full Endpoint Acl = acl } if ( ! acl ) { 
function ( ) { var result = [ ] var self = this this . ALL _METHODS . for Each ( function ( method ) { if ( self [ method ] ) { result . push ( method ) } } ) return result } 
function ( ) { var endpoint = this var acl = endpoint . acl | | null var parent Acl while ( endpoint = endpoint . parent ) { parent Acl = endpoint . acl if ( parent Acl & & parent Acl . self And Below ) { acl = this . _acl And Below ( parent Acl , acl ) } } return acl } 
function ( parent Acl , child Acl ) { var self = this return o ( { _type : parent Acl . constructor , has Permission : function ( user , permission , env ) { var self And Below Fn = self . _self And Below Fn ( parent Acl ) return ( ! self And Below Fn | | self And Below Fn ( user , permission , env ) ) & & ( ! child Acl | | child Acl . has Permission ( user , permission , env ) ) } } ) } 
function ( parent Acl ) { var self And Below = parent Acl . self And Below if ( self And Below ) { if ( typeof ( self And Below ) = = = 'boolean ' ) { return function ( user , permission , env ) { return parent Acl . has Permission ( user , permission , env ) } } else if ( typeof ( self And Below ) = = = 'function ' ) { return self And Below } else if ( self And Below in parent Acl . permission Definitions ) { return function ( user , permission , env ) { return parent Acl . has Permission ( user , self And Below , env ) } } else { throw Error ( "Unexpected value for self And Below : " + JSON . stringify ( parent Acl ) ) } } return null } 
function ( type , options ) { var self = this ; self . type = type ; if ( ! Random Generator . Type [ type ] ) { throw new Error ( "Unknown random generator type : " + type ) ; } if ( type = = = Random Generator . Type . ALEA ) { if ( ! options . seeds ) { throw new Error ( "No seeds were provided for Alea PRNG " ) ; } self . alea = Alea . apply ( null , options . seeds ) ; } } 
function check Type ( obj , field , exp Type , must Have , min , max ) { let value = typeof ( obj ) = = = 'object ' ? obj [ field ] : obj ; if ( value = = = undefined ) { return get Default ( obj , field , must Have ) ; } 
function handle Success ( ) { clear Outdated Errors ( ) ; destroy Error Overlay ( ) ; var is Hot Update = ! is First Compilation ; is First Compilation = false ; has Compile Errors = false ; 
function handle Warnings ( warnings ) { clear Outdated Errors ( ) ; destroy Error Overlay ( ) ; var is Hot Update = ! is First Compilation ; is First Compilation = false ; has Compile Errors = false ; function print Warnings ( ) { 
function try Apply Updates ( on Hot Update Success ) { if ( ! module . hot ) { 
function log Message ( message , data ) { if ( ! message ) return render ( message , data , function ( err , res ) { if ( err ) { console . error ( ' \n Error when rendering template complete message : ' + err . message . trim ( ) ) } else { console . log ( ` \n ` ) console . log ( ' ' ) console . log ( ` $ { chalk . gray ( ' - - - - - - - - - - - - - - - - - - ' ) } ` ) console . log ( ' ' + res . split ( / \r ? \n / g ) . map ( function ( line ) { return ` $ { chalk . blue ( line ) } ` } ) . join ( ' \n ' ) ) console . log ( ` $ { chalk . gray ( ' - - - - - - - - - - - - - - - - - - ' ) } ` ) console . log ( ' ' ) console . log ( ` $ { chalk . blue . underline ( 'fe -h ' ) } ` ) } } ) } 
function intercept Write Stream ( write Stream ) { return new Promise ( ( resolve , reject ) = > { let response = " " ; let write Bkp = write Stream . write ; let send Bkp = write Stream . send ; 
function ( filepath , options , content ) { if ( ! inited ) { this . config ( ) } if ( arguments . length = = = 2 & & ( typeof options = = = "string " ) ) { content = options ; options = { } ; } content = content | | get File String ( filepath ) ; options = options | | { } ; if ( ! content ) return " " ; return compile ( content , filepath , options ) ; } 
function compile ( content , file Path , opt ) { var file Url , 
function get File String ( filepath ) { if ( / ( ? : \ / | \ \ ) $ / . test ( filepath ) | | ! fs . exists Sync ( filepath ) ) { console . log ( " \x 1B [ 3 1mfile is not exist ： " + f lepath + " x 1B [ 0m " ) ; return null ; } else { return fs . read File Sync ( filepath ) . to String ( ) } } 
function deep Copy ( obj ) { var result = { } ; var type = to String . call ( obj ) ; if ( ! obj | | ( type = = = " [object Reg Exp ] " ) | | typeof obj ! = = "object " ) return obj ; if ( type = = = " [object Array ] " ) return slice . call ( obj ) ; for ( var k in obj ) { result [ k ] = deep Copy ( obj [ k ] ) } return result ; } 
function get Random Music ( queue , msg ) { fs . read File ( ' . /data /autoplaylist .txt ' , 'utf 8 ' , function ( err , data ) { if ( err ) throw err ; con ( 'OK : autoplaylist .txt ' ) ; var random = data . split ( ' \n ' ) ; var num = get Random Int ( random . length ) ; con ( random [ num ] ) var url = random [ num ] ; msg . author . username = "AUTOPLAYLIST " ; play ( msg , queue , url ) } ) ; } 
function format Message ( message ) { var lines = message . split ( ' \n ' ) ; 
function resolve Bot ( bot ) { let is Waterfall = ( "function " = = typeof bot ) | | Array . is Array ( bot ) ; if ( is Waterfall ) { let dialog = bot ; let connector = new Test Connector ( ) ; bot = new builder . Universal Bot ( connector ) ; bot . dialog ( ' / ' , dialog ) ; } else if ( bot instanceof builder . Universal Bot ) { if ( ! bot . connector ( ) ) { bot . connector ( 'console ' , new Test Connector ( ) ) ; } } else { throw new Error ( ` $ { JSON . stringify ( bot ) } ` ) ; } return bot ; } 
function mixin ( target , Mixin Constructor , . . . args ) { let source = new Mixin Constructor ( . . . args ) let names = Object . get Own Property Names ( Mixin Constructor . prototype ) for ( let name of names ) { let val = source [ name ] if ( _ . is Function ( val ) & & name ! = = 'constructor ' ) { target [ name ] = val . bind ( source ) } } } 
function nest Lists ( blocks , mode = 'html ' ) { const tree = [ ] let current List for ( let i = 0 ; i < blocks . length ; i + + ) { const block = blocks [ i ] if ( ! is List Block ( block ) ) { tree . push ( block ) current List = null continue } 
function sort Marks By Occurences ( span , i , spans ) { if ( ! span . marks | | span . marks . length = = = 0 ) { return span . marks | | [ ] } const mark Occurences = span . marks . reduce ( ( occurences , mark ) = > { occurences [ mark ] = occurences [ mark ] ? occurences [ mark ] + 1 : 1 for ( let sibling Index = i + 1 ; sibling Index < spans . length ; sibling Index + + ) { const sibling = spans [ sibling Index ] if ( sibling . marks & & Array . is Array ( sibling . marks ) & & sibling . marks . index Of ( mark ) ! = = - 1 ) { occurences [ mark ] + + } else { break } } return occurences } , { } ) const sort By Occurence = sort Marks . bind ( null , mark Occurences ) 
function Block Serializer ( props ) { const { node , serializers , options , is Inline , children } = props const block Type = node . _type const serializer = serializers . types [ block Type ] if ( ! serializer ) { throw new Error ( ` $ { block Type } \ ` \ ` ` ) } return h ( serializer , { node , options , is Inline } , children ) } 
function Span Serializer ( props ) { const { mark , children } = props . node const is Plain = typeof mark = = = 'string ' const mark Type = is Plain ? mark : mark . _type const serializer = props . serializers . marks [ mark Type ] if ( ! serializer ) { 
function List Serializer ( props ) { const tag = props . type = = = 'bullet ' ? 'ul ' : 'ol ' return h ( tag , null , props . children ) } 
function List Item Serializer ( props ) { const children = ! props . node . style | | props . node . style = = = 'normal ' ? 
function Block Type Serializer ( props ) { const style = props . node . style | | 'normal ' if ( / ^h \d / . test ( style ) ) { return h ( style , null , props . children ) } return style = = = 'blockquote ' ? h ( 'blockquote ' , null , props . children ) : h ( 'p ' , null , props . children ) } 
function serialize Span ( span , serializers , index , options ) { if ( span = = = ' \n ' & & serializers . hard Break ) { return h ( serializers . hard Break , { key : ` $ { index } ` } ) } if ( typeof span = = = 'string ' ) { return serializers . text ? h ( serializers . text , { key : ` $ { index } ` } , span ) : span } let children if ( span . children ) { children = { children : span . children . map ( ( child , i ) = > options . serialize Node ( child , i , span . children , true ) ) } } const serialized Node = object Assign ( { } , span , children ) return h ( serializers . span , { key : span . _key | | ` $ { index } ` , node : serialized Node , serializers } ) } 
function checksum ( str ) { let hash = 0 const strlen = str . length if ( strlen = = = 0 ) { return hash } for ( let i = 0 ; i < strlen ; i + + ) { hash = ( hash < < 5 ) - hash + str . char Code At ( i ) hash & = hash 
function Strategy ( options , verify ) { options = options | | { } ; options . authorization URL = options . authorization URL | | 'https : / /bitbucket .org /site /oauth 2 /authorize ' ; options . token URL = options . token URL | | 'https : / /bitbucket .org /site /oauth 2 /access _token ' ; options . custom Headers = options . custom Headers | | { } ; if ( ! options . custom Headers [ 'User -Agent ' ] ) { options . custom Headers [ 'User -Agent ' ] = options . user Agent | | 'passport -bitbucket ' ; 
function ( ) { var el = this . el ; this . last Position = el . get Attribute ( 'position ' ) ; this . last Rotation = el . get Attribute ( 'rotation ' ) ; this . last Scale = el . get Attribute ( 'scale ' ) ; this . lerping Position = false ; this . lerping Rotation = false ; this . lerping Scale = false ; this . time Of Last Update = 0 ; } 
function ( time , delta Time ) { var progress ; var now = this . now ( ) ; var obj 3d = this . el . object 3D ; this . check For Component Changed ( ) ; 
function ( from , to ) { this . lerping Position = true ; this . start Lerp Time Position = this . now ( ) ; this . start Position = new THREE . Vector 3 ( from . x , from . y , from . z ) ; this . target Position = new THREE . Vector 3 ( to . x , to . y , to . z ) ; } 
function ( from , to ) { this . lerping Rotation = true ; this . start Lerp Time Rotation = this . now ( ) ; this . start Rotation = new THREE . Quaternion ( ) ; this . start Rotation . set From Euler ( new THREE . Euler ( deg To Rad ( from . x ) , deg To Rad ( from . y ) , deg To Rad ( from . z ) , 'YXZ ' ) ) ; this . target Rotation = new THREE . Quaternion ( ) ; this . target Rotation . set From Euler ( new THREE . Euler ( deg To Rad ( to . x ) , deg To Rad ( to . y ) , deg To Rad ( to . z ) , 'YXZ ' ) ) ; } 
function ( from , to ) { this . lerping Scale = true ; this . start Lerp Time Scale = this . now ( ) ; this . start Scale = new THREE . Vector 3 ( from . x , from . y , from . z ) ; this . target Scale = new THREE . Vector 3 ( to . x , to . y , to . z ) ; } 
function ( json , variables , member Mode , callback ) { if ( typeof member Mode = = 'function ' ) { callback = member Mode ; var member _mode = member Mode | | false ; } else { var member _mode = member Mode | | false ; } var str = JSON . stringify ( json ) ; var output = str . replace ( / { { \w + } } / g , function ( found ) { found = ( member _mode ) ? found . match ( / [ \w \ . ] + / ) [ 0 ] : found ; 
function ( datamodel , variables ) { traverse ( datamodel ) . for Each ( function ( path ) { 
function ( element ) { this . el = element ; this . core = window . lg Data [ this . el . get Attribute ( 'lg -uid ' ) ] ; 
function buffer Contents ( file , enc , cb ) { 
function two ( context , next ) { set Timeout ( function ( ) { context . two = 'Hello ' ; console . log ( 'Hello from two ' , context ) ; return next ( ) ; } , 1 0 0 0 ) ; } 
function next ( ) { var middleware = chain . shift ( ) ; if ( middleware & & typeof middleware = = = 'function ' ) { middleware . call ( this , context , next ) ; } return this ; } 
function one ( context , next ) { set Timeout ( function ( ) { context . one = 'Hello ' ; console . log ( 'Hello from one ' , context ) ; return next ( ) ; } , 1 0 0 0 ) ; console . log ( 'Hi from one ' , context ) ; } 
function two ( context , next ) { context . two = 'Hello ' ; console . log ( 'Hello from two ' , context ) ; console . log ( 'Hi from two ' , context ) ; return next ( ) ; } 
function three ( context , next ) { console . log ( 'Hi from three ' , context ) ; set Timeout ( function ( ) { context . three = 'Hello ' ; console . log ( 'Hello from three ' , context ) ; } , 1 0 0 0 ) ; } 
function two ( context , next ) { set Timeout ( function ( ) { context . two = 'Hello ' ; console . log ( 'Hello from two ' , context ) ; chain ( { nested : 'Hello ' } , [ one , three ] ) ; return next ( ) ; } , 1 0 0 0 ) ; } 
function Express View ( view ) { this . render = ( options , callback ) = > { const variables = { . . . options . _locals , . . . options } ; callback ( null , view ( variables ) ) ; } ; this . path = view . id ; } 
function try Match Sequence ( key ) { seq . keys . push ( key . name ) ; 
function mat 3from 4 ( out , mat 4x 4 ) { out [ 0 ] [ 0 ] = mat 4x 4 [ 0 ] out [ 0 ] [ 1 ] = mat 4x 4 [ 1 ] out [ 0 ] [ 2 ] = mat 4x 4 [ 2 ] out [ 1 ] [ 0 ] = mat 4x 4 [ 4 ] out [ 1 ] [ 1 ] = mat 4x 4 [ 5 ] out [ 1 ] [ 2 ] = mat 4x 4 [ 6 ] out [ 2 ] [ 0 ] = mat 4x 4 [ 8 ] out [ 2 ] [ 1 ] = mat 4x 4 [ 9 ] out [ 2 ] [ 2 ] = mat 4x 4 [ 1 0 ] } 
function Motion Detector ( n ) { RED . nodes . create Node ( this , n ) ; this . cam = RED . nodes . get Node ( n . cam ) ; this . name = n . name ; this . topic = n . topic ; this . device = n . device ; this . resolution = n . resolution ; this . rotate = n . rotate ; var node = this ; node . on ( 'close ' , function ( done ) { node . status ( { } ) ; done ( ) ; } ) ; event Emitter . on ( 'event ' , function ( data , data 2 ) { var tmp = data . split ( ' ; ' ) ; node . send ( { payload : { event : tmp [ 0 ] , date : tmp [ 1 ] , event Number : tmp [ 2 ] , frame Number : tmp [ 3 ] , camera : tmp [ 4 ] , changed Pixels : tmp [ 5 ] , noise : tmp [ 6 ] , width : tmp [ 7 ] , height : tmp [ 8 ] , x Motion : tmp [ 9 ] , y Motion : tmp [ 1 0 ] , text : tmp [ 1 1 ] , filename : tmp [ 1 2 ] , filetype : tmp [ 1 3 ] } } ) ; } ) ; } 
function filter ( fn , ctx ) { assert . equal ( typeof fn , 'function ' ) return function ( val ) { val = Array . is Array ( val ) ? val : [ val ] return Promise . resolve ( val . filter ( fn , ctx ) ) } } 
function ( raw Value ) { const value = stringify Input ( raw Value ) ; if ( ! value . match ( FORMAT ) ) { throw new Error ( 'Invalid data format ; expecting : \ ' ' + FORMAT + ' \ ' , found : \ ' ' + value + ' \ ' ' ) ; } return mod 9 7 ( value ) ; } 
async function send Message ( app , context , title , message , { update = ' ' , update After Days = 7 , owner , repo } = { } ) { if ( ! app | | ! context | | ! title | | ! message ) { throw new Error ( 'Required parameter missing ' ) ; } if ( ! owner | | ! repo ) { ( { owner , repo } = context . repo ( ) ) ; } const app Gh = await app . auth ( ) ; const { name : app Name , html _url : app Url } = ( await app Gh . apps . get ( { } ) ) . data ; const { data : issues } = await context . github . issues . get For Repo ( { owner , repo , state : 'open ' , creator : ` $ { app Name } ` , per _page : 1 0 0 } ) ; message = message . replace ( / {app Name } / , app Name ) . replace ( / {app Url } / , app Url ) ; const message Hash = crypto . create Hash ( 'sha 2 5 6 ' ) . update ( message ) . digest ( 'hex ' ) ; const message Hash Rx = new Reg Exp ( ` $ { message Hash } ` ) ; for ( const issue of issues ) { if ( ! message Hash Rx . test ( issue . body ) ) { continue ; } let comment Id = null ; if ( update & & ! issue . locked & & Date . now ( ) - Date . parse ( issue . updated _at ) > = update After Days * 2 4 * 6 0 * 6 0 * 1 0 0 0 ) { update = update . replace ( / {app Name } / , app Name ) . replace ( / {app Url } / , app Url ) ; const { data : comment Data } = await context . github . issues . create Comment ( { owner , repo , number : issue . number , body : update } ) ; comment Id = comment Data . id ; } return new Message ( owner , repo , issue . number , comment Id , false ) ; } title = title . replace ( / {app Name } / , app Name ) . replace ( / {app Url } / , app Url ) ; const { data : issue Data } = await context . github . issues . create ( { owner , repo , title , body : ` $ { message } \n $ { message Hash } ` } ) ; return new Message ( owner , repo , issue Data . number , null , true ) ; } 
function package States Serialize ( ) { if ( atom . packages . serialize ! = null ) { return atom . packages . serialize ( ) } atom . packages . get Active Packages ( ) . for Each ( ( pack ) = > { var state if ( pack . serialize ! = null ) state = pack . serialize ( ) if ( state ) { atom . packages . set Package State ( pack . name , state ) } } ) return atom . packages . package States } 
function atom Serialize ( ) { var options = { is Unloading : true } if ( atom . serialize ! = null ) return atom . serialize ( options ) 
function rdf To Jsonld ( triples , config ) { var use Rdf Type = config . use Rdf Type ; var use Native Types = config . use Native Types ; var graphs = get Graphs ( triples ) ; var default Graph = { } ; var graph Map = { ' @default ' : default Graph } ; Object . keys ( graphs ) . for Each ( function ( name ) { var triples = graphs [ name ] ; if ( name = = = ' ' ) { name = ' @default ' ; } else if ( ! default Graph [ name ] ) { default Graph [ name ] = { ' @id ' : name } ; } graph Map [ name ] = graph Map [ name ] | | { } ; var node Map = graph Map [ name ] ; triples . for Each ( function ( triple ) { if ( ! node Map [ triple . subject ] ) { node Map [ triple . subject ] = { ' @id ' : triple . subject } ; } var node = node Map [ triple . subject ] ; var object = triple . object ; if ( object . id ) { if ( ! node Map [ object . id ] ) { node Map [ object . id ] = { ' @id ' : object . id } ; } } if ( triple . predicate = = = RDF _ _TYPE & & ! use Rdf Type & & object . id ) { if ( ! node [ ' @type ' ] ) { node [ ' @type ' ] = [ object . id ] ; } return 'continue ' ; } var value = rdf Object To Jsonld Object ( object , use Native Types ) ; if ( ! node [ triple . predicate ] ) { node [ triple . predicate ] = [ ] ; } var already Exists = node [ triple . predicate ] . some ( function ( existing Value ) { var are Equivalent = equivalent Objects ( value , existing Value ) ; return are Equivalent ; } ) ; if ( ! already Exists ) { node [ triple . predicate ] . push ( value ) ; } if ( object . id ) { if ( ! node . usages ) { node . usages = [ ] ; } node . usages . push ( { node : node , property : triple . predicate , value : value } ) ; } } ) ; } ) ; Object . keys ( graph Map ) . for Each ( function ( name ) { var graph = graph Map [ name ] ; var nil = graph [ RDF _ _NIL ] ; if ( ! nil ) { return 'continue ' ; } nil . usages . for Each ( function ( usage ) { var node = usage . node ; var property = usage . property ; var head = usage . value ; var list = [ ] ; var list Nodes = [ ] ; while ( property = = = RDF _ _REST & & is Well Formed List Node ( node ) ) { list . push ( node [ RDF _ _FIRST ] [ 0 ] ) ; list Nodes . push ( node [ ' @id ' ] ) ; var node Usage = node . usages [ 0 ] ; node = node Usage . node ; property = node Usage . property ; head = node Usage . value ; if ( ! / ^ _ : / . test ( node [ ' @id ' ] ) ) { break ; } } if ( property = = = RDF _ _FIRST ) { if ( node [ ' @id ' ] = = = RDF _ _NIL ) { return 'continue ' ; } var head Id = head [ ' @id ' ] ; head = graph [ head Id ] ; head = head [ RDF _ _REST ] [ 0 ] ; list . pop ( ) ; list Nodes . pop ( ) ; } delete head [ ' @id ' ] ; list . reverse ( ) ; head [ ' @list ' ] = list ; list Nodes . for Each ( function ( node Id ) { delete graph [ node Id ] ; } ) ; } ) ; } ) ; var result = [ ] ; Object . keys ( default Graph ) . sort ( ) . for Each ( function ( subject ) { var node = default Graph [ subject ] ; if ( graph Map [ subject ] ) { node [ ' @graph ' ] = [ ] ; Object . keys ( graph Map [ subject ] ) . sort ( ) . for Each ( function ( s ) { var n = graph Map [ s ] ; delete n . usages ; if ( Object . keys ( n ) . length = = = 1 & & n [ ' @id ' ] ) { return 'continue ' ; } node [ ' @graph ' ] . push ( n ) ; } ) ; } delete node . usages ; if ( Object . keys ( node ) . length = = = 1 & & node [ ' @id ' ] ) { return 'continue ' ; } result . push ( node ) ; } ) ; return result ; } 
function split Unique ( string ) { string = string & & string . trim ( ) ; if ( string ) { return unique ( string . split ( / \s + / ) ) ; } else { return undefined ; } } 
function walk Nodes ( $nodes , current Item ) { $nodes . each ( function ( i , node ) { var $node = $ ( node ) ; var props = split Unique ( $node . attr ( 'itemprop ' ) ) ; if ( props & & current Item ) { var value = null ; if ( $node . is ( ' [itemscope ] ' ) ) { value = parse Item ( node , current Item ) ; } else { value = parse Property Value ( node ) ; walk Nodes ( $node . children ( ) , current Item ) ; } current Item . add Properties ( props , value ) ; } else if ( $node . is ( ' [itemscope ] ' ) & & ! $node . is ( ' [itemprop ] ' ) ) { var new Item = parse Item ( node , current Item ) ; if ( new Item ! = = Item . ERROR ) { items . push ( new Item ) ; } } else { walk Nodes ( $node . children ( ) , current Item ) ; } } ) ; } 
function parse Item ( node , current Item ) { 
function resolve Url Attribute ( $node , attr ) { var url = $node . attr ( attr ) ; if ( url = = = undefined ) return ' ' ; if ( is Absolute Url ( url ) ) { return url ; } else { return url Util . resolve ( base , url ) ; } } 
function parse Property Value ( node ) { var $node = $ ( node ) ; if ( $node . is ( 'meta ' ) ) { return resolve Attribute ( $node , 'content ' ) ; } else if ( $node . is ( 'audio ,embed ,iframe ,img ,source ,track ,video ' ) ) { return resolve Url Attribute ( $node , 'src ' ) ; } else if ( $node . is ( 'a ,area ,link ' ) ) { return resolve Url Attribute ( $node , 'href ' ) ; } else if ( $node . is ( 'object ' ) ) { return resolve Url Attribute ( $node , 'data ' ) ; } else if ( $node . is ( 'data ,meter ' ) ) { return resolve Attribute ( $node , 'value ' ) ; } else if ( $node . is ( 'time ' ) ) { return resolve Attribute ( $node , 'datetime ' ) ; } else { var text = $node . text ( ) ; return text | | ' ' ; } } 
function process Patterns ( patterns , fn ) { 
function send Message ( args ) { last = new Date ( ) ; fs . write ( tmpfile , JSON . stringify ( args ) + ' \n ' , 'a ' ) ; 
function ( url ) { grunt . verbose . write ( 'Running Phantom JS . . . ' ) . or . write ( ' . . . ' ) ; grunt . log . error ( ) ; grunt . warn ( 'Phantom JS unable to load " ' + url + ' " URI . ' , 9 0 ) ; } 
function Flowa ( flow , name ) { this . name = typeof name = = 'undefined ' ? null : name ; this . _root = flow ; this . _tasks = { } ; this . _runners = { serial : serial , parallel : parallel } ; this . _root Name = Symbol ( ' _ _root _ _ ' ) ; this . _tasks Runners Types = { } ; this . _tasks Depths = { } ; this . _tasks Parents = { } ; this . _default Runner Type = 'serial ' ; this . _init ( ) ; } 
function F ( type , term ) { let original = term ; if ( term & & ! term . _ _meta ) { term = type . wrap ? type . wrap ( term ) : term ; term . _ _meta = { } ; term . _ _name = function ( name ) { term . _ _meta . name = name ; return term ; } ; term . _ _desc = function ( desc ) { term . _ _meta . desc = desc ; return term ; } ; if ( term . _ _meta ) { term . _ _meta . term = original ; term . _ _meta . name = "anon " ; term . _ _meta . desc = "no description " ; } ; } ; F . check ( type , term ) ; return term ; } 
function make ( options ) { var shopify Theme ; var previous = shopify Theme Instances . filter ( ( instance ) = > { return options . shop _name = = = instance . _shop Name & & options . api _key = = = instance . _api Key ; } ) ; if ( previous . length ) return previous [ 0 ] ; shopify Theme = new Shopify Theme ( options ) ; shopify Theme Instances . push ( shopify Theme ) ; return shopify Theme ; } 
function end ( error ) { _this . _queue Running = false ; if ( error ) { _this . _task Queue = [ ] ; return ; } 
function Background ( width = 0 , height = 0 , radius = [ 0 , 0 , 0 , 0 ] ) { THREE . Mesh . call ( this , new Background Geometry ( width , height , radius ) , new THREE . Mesh Standard Material ( { side : THREE . Double Side } ) , undefined ) this . name = 'Background ' 
function Border Line ( line Width = [ 0 . 0 1 , 0 . 0 1 , 0 . 0 1 , 0 . 0 1 ] , width = 0 , height = 0 , radius = [ 0 , 0 , 0 , 0 ] ) { THREE . Mesh . call ( this , new Border Geometry ( line Width , width , height , radius ) , new THREE . Mesh Standard Material ( { side : THREE . Double Side } ) , undefined ) this . name = 'Border Line ' 
function ( json , delimiter ) { var result = [ ] ; var recurse = function ( cur , prop ) { for ( var key in cur ) { if ( cur . has Own Property ( key ) ) { var item = cur [ key ] ; result . push ( { match : prop ? prop + delimiter + key : key , replacement : item , expression : false } ) ; 
function ld ( date , long = true , options = null ) { return Localizer . Singleton . format Date ( date , long , options ) } 
function ldt ( date , long = true , options = null ) { return Localizer . Singleton . format Date Time ( date , long , options ) } 
function ( replacer , e ) { var message = e ; if ( e instanceof Error ) { message = e . message ; } replacer . emit ( 'error ' , e ) ; } 
function ( context ) { return function ( plugin ) { var pattern = context . pattern ; if ( plugin . match ( pattern , opts ) = = = true ) { plugin . transform ( pattern , opts , function ( items ) { if ( items instanceof Error ) { throw items ; } else { 
function ( opts ) { 
function get Style ( element , property ) { if ( window . get Computed Style ) { return get Style Property ( element , property ) . original ; } else if ( element . current Style ) { return element . current Style [ property ] ; } return null ; } 
function has Changed ( new Data , old Data ) { var changed = false for ( var i = 0 ; i < scope . length ; i + + ) { var k = scope [ i ] , new Val = _ . get ( new Data , k ) , old Val = _ . get ( old Data , k ) if ( ! _ . is Equal ( new Val , old Val ) ) { changed = true break } } return changed } 
function build Options ( data ) { var slg = slug ( _ . get ( data , slug Field ) , slug Options ) , key = doc + ' | ' 
function build Slug ( data , update , done ) { var opt = build Options ( data ) 
function ( needles , haystack ) { var i , needle Arr = needles . split ( / \s + / g ) , needle , needle Regexp Arr = [ ] , regexp , ret Val = true , has Upper Case , regexp Flags ; 
function ( values , callback , items ) { var values To Add = values . splice ( 0 , 1 0 0 ) ; items = items | | [ ] ; items = items . concat ( self . add ( values To Add ) ) ; if ( values . length > 0 ) { set Timeout ( function ( ) { add Async ( values , callback , items ) ; } , 1 0 ) ; } else { self . update ( ) ; callback ( items ) ; } } 
function ( init Values , element , not Create ) { if ( element = = = undefined ) { if ( not Create ) { item . values ( init Values , not Create ) ; } else { item . values ( init Values ) ; } } else { item . elm = element ; var values = templater . get ( item , init Values ) ; item . values ( values ) ; } } 
function ( nodes ) { var result = Object . prototype . to String . call ( nodes ) ; if ( typeof nodes = = = 'object ' & & / ^ \ [object (HTMLCollection |Node List |Object ) \ ] $ / . test ( result ) & & ( nodes . length = = 0 | | ( typeof nodes [ 0 ] = = = "object " & & nodes [ 0 ] . node Type > 0 ) ) ) { return true ; } return false ; } 
function validate ( host ) { const host Scheme = joi . array ( ) . items ( joi . string ( ) . min ( 1 ) ) . min ( 1 ) . single ( ) joi . assert ( host , host Scheme , 'The parameter `host ` is invalid . Its ' ) } 
function get Routes ( server , host ) { return server . table ( host ) . map ( ( { path , method , settings : { vhost } } ) = > ( { path , method , . . . ( vhost ? { vhost } : { } ) } ) ) } 
function decorator ( server , . . . rest ) { validate ( . . . rest ) const route List = get Routes ( server , . . . rest ) const sorted = _ . sort By ( route List , serialize ) return _ . sorted Uniq By ( sorted , serialize ) } 
function index ( origin ) { var new Comers = [ ] ; for ( var _i = 1 ; _i < arguments . length ; _i + + ) { new Comers [ _i - 1 ] = arguments [ _i ] ; } var extensions = null ; var base = origin ; if ( is Plain Object ( origin ) & & origin . extensions & & Object . keys ( origin ) . length = = = 1 ) { base = { } ; extensions = origin . extensions ; } return new Comers . reduce ( function ( result , new Comer ) { return merge Recursively ( result , new Comer , extensions ) ; } , base ) ; } 
function check Url ( url , method , routes ) { method = method . to Lower Case ( ) ; for ( var i = 0 ; i < routes . length ; i + + ) { var route = routes [ i ] ; if ( ( match Path ( route . url , url ) ) & & ( method = = route . method ) ) return route ; } return false ; } 
function eat Braces ( stream , root ) { if ( stream . eat ( LBRACE ) ) { let stack = 1 , token ; while ( ! stream . eof ( ) ) { if ( stream . eat ( RBRACE ) ) { stack - - ; if ( ! stack ) { break ; } } else if ( stream . eat ( LBRACE ) ) { stack + + ; } else if ( eat Url ( stream ) | | eat String ( stream ) ) { continue ; } else if ( token = comment ( stream ) ) { root . add Comment ( token ) ; continue ; } else { stream . next ( ) ; } } return true ; } return false ; } 
function get Commit Sha ( ) { try { return exec Sync ( "git rev -parse HEAD " ) . to String ( ) ; } catch ( ignore ) { console . warn ( "Failed to get commit sha via git command " ) ; } try { return exec Sync ( "cat .git /ORIG _HEAD " ) . to String ( ) ; } catch ( ignore ) { console . warn ( "Failed to get commit sha by reading from ORIG _HEAD " ) ; } return null ; } 
function underscore ( base Query ) { return _ . map Keys ( base Query , function ( v , k ) { return table Column Renamer . underscore ( k ) } ) } 
function filter Query Params ( base Clause , request ) { _ . for Each ( request . query , function ( v , k ) { add Where Clause ( base Clause , k , v ) } ) return base Clause } 
function add Where Clause ( base Clause , k , v ) { if ( v . starts With ( ' > ' ) ) { base Clause . where ( k , ' > = ' , v . substring ( 1 ) ) ; return } if ( v . starts With ( ' < ' ) ) { base Clause . where ( k , ' < = ' , v . substring ( 1 ) ) ; return } if ( v . starts With ( ' ~ ' ) ) { base Clause . where ( k , 'LIKE ' , v . substring ( 1 ) ) ; return } if ( k . ends With ( 'Id ' ) ) { base Clause . where ( k . substring ( 0 , k . length - 2 ) + ' _id ' , ' = ' , v ) ; return } base Clause . where ( k , ' = ' , v ) ; return } 
function find By Id Query Params ( request , config ) { return typeof config . base Query = = = 'undefined ' ? { 'id ' : request . params . id } : _ . merge ( { 'id ' : request . params . id } , underscore ( config . base Query ( request ) ) ) } 
function empty ( entity , schema , Empty ) { if ( typeof entity = = = 'undefined ' | | entity = = = null ) { return } _ . for Each ( schema , function ( v , k ) { if ( v = = = Empty ) { delete entity [ k ] } } ) } 
function init Model ( config ) { if ( typeof config . bookshelf Model . prototype . schema = = = 'undefined ' ) { config . bookshelf Model . prototype . schema = { } } add Constraints For Foreign Keys ( config . bookshelf Model , config . base Query ) config . bookshelf Model . prototype . format = table Column Renamer . rename On Format config . bookshelf Model . prototype . parse = table Column Renamer . rename On Parse init Json Date Format ( config . bookshelf Model ) } 
function add Constraints For Foreign Keys ( bookshelf Model , base Query ) { if ( typeof base Query = = = 'undefined ' ) { return } _ . for Each ( base Query ( { params : { } , payload : { } } ) , function ( v , k ) { const value = bookshelf Model . prototype . schema [ k ] if ( typeof value = = = 'undefined ' ) { bookshelf Model . prototype . schema [ k ] = Joi . any ( ) . required ( ) } else if ( value . is Joi ) { bookshelf Model . prototype . schema [ k ] = bookshelf Model . prototype . schema [ k ] . required ( ) } } ) } 
function init Json Date Format ( bookshelf Model ) { const schema = bookshelf Model . prototype . schema const original Function = bookshelf Model . prototype . to JSON 
function format Number ( payload , schema ) { _ . for Each ( schema , function ( v , k ) { if ( v ! = = null & & v . _type = = = 'number ' ) { if ( typeof payload [ k ] = = = 'undefined ' | | payload [ k ] = = = null ) { payload [ k ] = 0 } } } ) } 
function format Date ( payload , schema ) { _ . for Each ( schema , function ( v , k ) { if ( v ! = = null & & v . _type = = = 'date ' ) { if ( payload [ k ] ! = = null ) { payload [ k ] = new Date ( payload [ k ] ) } } } ) } 
function set Foreign Keys ( request , base Query ) { if ( typeof base Query = = = 'undefined ' ) { return } _ . for Each ( base Query ( request ) , function ( v , k ) { request . payload [ k ] = request . params [ k ] } ) } 
function transform Constraint Violation Messages ( input ) { return { validation Errors : _ . chain ( input . details ) . map Keys ( function ( v , k ) { 
function lazy Cons Force ( ) { var val = this . tail Fn ( ) ; this . tail Value = Array . is Array ( val ) ? from Array ( val ) : val ; delete this . tail ; delete this . force ; return this ; } 
function from Array Iter ( arr , n ) { if ( n < arr . length ) { return cons ( arr [ n ] , function ( ) { return from Array Iter ( arr , n + 1 ) ; } ) ; } else { return nil ; } } 
function append ( ) { var acc = nil ; for ( var i = 0 ; i < arguments . length ; i + + ) { acc = acc . append ( arguments [ i ] ) ; } return acc ; } 
function list Fold ( list , z , f , n ) { if ( n < list . length ) { return f ( list [ n ] , function ( ) { return list Fold ( list , z , f , n + 1 ) ; } ) ; } else { return z ; } } 
function plugin ( opts ) { var obj = { } ; try { var content = fs . read File Sync ( ' . /package .json ' , { encoding : 'utf 8 ' } ) ; obj = JSON . parse ( content ) ; } catch ( e ) { 
function is Empty Tag ( node ) { if ( node . constructor = = = Element & & ! node . has Child Nodes ( ) ) return true return Boolean ( EMPTY _TAG _SET [ node . tag Name ] ) } 
function Log Watcher ( dirpath , maxfiles , ignore Initial ) { _class Call Check ( this , Log Watcher ) ; var _this = _possible Constructor Return ( this , ( Log Watcher . _ _proto _ _ | | Object . get Prototype Of ( Log Watcher ) ) . call ( this ) ) ; _this . _dirpath = dirpath | | DEFAULT _SAVE _DIR ; _this . _filter = is Commander Log ; _this . _maxfiles = maxfiles | | 3 ; _this . _log Detail Map = { } ; _this . _ops = [ ] ; _this . _op = null ; _this . _start Time = new Date ( ) ; _this . _timer = null ; _this . _die = false ; _this . _ignore Initial = ignore Initial | | false ; _this . stopped = false ; _this . _loop ( ) ; _this . emit ( 'Started ' ) ; return _this ; } 
function is Commander Log ( fpath ) { var base = _path 2 . default . basename ( fpath ) ; return base . index Of ( 'Journal . ' ) = = = 0 & & _path 2 . default . extname ( fpath ) = = = ' .log ' ; } 
function load Image ( image ) { $scope . $apply Async ( function ( ) { if ( $scope . reversed ) $scope . flip Context ( ) ; $scope . signature Ready = true ; ctx Background . clear Rect ( 0 , 0 , canvas . width , canvas . height ) ; ctx Background . draw Image ( image , 0 , 0 , canvas Background . width , canvas Background . height ) ; } ) ; } 
function ( ) { if ( this . read ) { this .event (name , event Function Factory (value , context ) , context ) ; } * / } 
function ( function Body , arg Names , arg Values , context ) { 
function ( expected , actual , options Or Msg ) { var options = options Or Msg instanceof Object ? options Or Msg : { message : options Or Msg } , msg = options . message , compat Html = bender . tools & & bender . tools . compat Html ; if ( ! options . skip Compat Html ) { var sort Attributes = ( 'sort Attributes ' in options ) ? options . sort Attributes : true , fix ZWS = ( 'fix ZWS ' in options ) ? options . fix ZWS : true , fix Nbsp = ( 'fix Nbsp ' in options ) ? options . fix Nbsp : true ; if ( ! compat Html ) { throw new Error ( 'Missing bender .tools .compat Html ' ) ; } expected = compat Html ( expected , options . no Inter WS , sort Attributes , fix ZWS , options . fix Styles , fix Nbsp , options . no Temp Elements , options . custom Filters ) ; actual = compat Html ( actual , options . no Inter WS , sort Attributes , fix ZWS , options . fix Styles , fix Nbsp , options . no Temp Elements , options . custom Filters ) ; } bender . assert . are Same ( html _beautify ( expected , this . _config ) , html _beautify ( actual , this . _config ) , msg ) ; } 
function ( expected , actual , msg ) { bender . assert . are Same ( js _beautify ( expected , this . _config ) , js _beautify ( actual , this . _config ) , msg ) ; } 
function ( expected , actual , msg ) { var assert = bender . assert ; assert . is Type Of ( 'object ' , expected , 'Expected is not an object ' ) ; assert . is Type Of ( 'object ' , actual , 'Actual is not an object ' ) ; 
function check If Should Stick ( ) { if ( media Query & & ! match Media ( ' ( ' + media Query + ' ) ' ) . matches ) return ; var scroll Top = ( window . page YOffset | | doc . scroll Top ) - ( doc . client Top | | 0 ) ; var should Stick = scroll Top > = sticky Line ; 
function get Sanitized Selector ( selector ) { return selector . replace ( / - ( [a -z ] ) / g , function ( g ) { return g [ 1 ] . to Upper Case ( ) ; } ) . replace ( / \ [ | ] / g , " " ) ; } 
function find Cluster By Addin Id ( id ) { var i , j ; var clusters ; for ( j = 1 ; j < arguments . length ; j + + ) { clusters = arguments [ j ] ; for ( i = 0 ; i < clusters . length ; i + + ) { if ( clusters [ i ] . contains Addin ( id ) ) { return clusters [ i ] ; } } } return null ; } 
function build Services Internal ( ) { if ( _ . is Function ( subdivision . build Services ) ) { subdivision . vent . trigger ( 'before :build Services ' ) ; return subdivision . build Services ( ) . then ( function ( ) { subdivision . vent . trigger ( 'after :build Services ' ) ; } ) ; } else { return Promise . resolve ( ) ; } } 
function ( axis ) { if ( _ . is String ( axis ) ) { if ( _ . is Empty ( axis ) | | _ . index Of ( axis , _delimiter ) > = 0 ) { return false ; } return true ; } return false ; } 
function ( ) { if ( arguments . length = = = 0 ) { return ' ' ; } if ( arguments [ 0 ] instanceof Array ) { return subdivision . registry . join Path . apply ( this , _ . flatten ( arguments [ 0 ] ) ) ; } var args = Array . prototype . slice . call ( arguments , 0 ) ; var result = [ ] ; _ . for Each ( args , function ( value ) { var axes = subdivision . registry . break Path ( value ) ; var i ; for ( i = 0 ; i < axes . length ; i + + ) { result . push ( axes [ i ] ) ; } } ) ; if ( result . length = = = 0 ) { return ' ' ; } else { return result . join ( _delimiter ) ; } } 
function ( path ) { if ( ! _ . is String ( path ) ) { throw new Error ( 'path must be a string ' + JSON . stringify ( path ) ) ; } if ( path = = = ' ' ) { return [ ] ; } var split Path = path . split ( _delimiter ) ; _ . for Each ( split Path , function ( axis ) { if ( ! subdivision . registry . verify Axis ( axis ) ) { throw new Error ( 'Invalid axis ' + axis ) ; } } ) ; return split Path ; } 
function ( path ) { var node = this . $get Node ( path , false ) ; if ( node ! = = null ) { return _ . keys ( node . nodes ) ; } else { return null ; } } 
function Computed ( read Fn , write Fn , context ) { this . read Fn = read Fn ; this . write Fn = write Fn ; this . context = context ; } 
function ( obj ) { if ( obj = = null | | typeof obj ! = 'object ' | | Object . is Frozen ( obj ) | | obj . _keep Hot ) return ; Object . freeze ( obj ) ; 
function ( parent Class , constructor ) { 
function f ( prex ) { return { restrict : 'A ' , link : function link ( scope , elez , attrs , crtl ) { crtl . select ( attrs . tab Href ) ; } } ; } 
function Binary Search Tree Iterator ( tree , type ) { type = type | | 'v ' ; if ( type ! = = 'k ' & & type ! = = 'v ' & & type ! = = 'e ' ) { throw new Error ( 'Incorrect binary search tree iterator type " ' + type + ' " ! ' ) ; } this . _type = type ; this . _tree = tree ; this . _last = null ; this . _done = false ; } 
function ( xhr , options , promise ) { var instance = this , url = options . url , method = options . method | | GET , headers = options . headers ? options . headers . itsa _deep Clone ( ) : { } , 
function ( xhr , promise , headers , method ) { 
function ( xhr , promise ) { 
function ( data ) { var param Array = [ ] , key , value ; for ( key in data ) { value = data [ key ] ; key = ENCODE _URI _COMPONENT ( key ) ; param Array . push ( ( value = = = null ) ? key : ( key + " = " + ENCODE _URI _COMPONENT ( value ) ) ) ; } return param Array . join ( " & " ) ; } 
function ( query String ) { var args = query String . split ( " & " ) , data = { } ; args . for Each ( function ( arg ) { var item = arg . split ( " = " ) ; ( item . length = = = 2 ) & & ( data [ item [ 0 ] ] = item [ 1 ] ) ; } ) ; return data ; } 
function ( ) { var instance = this ; instance . _running Requests . for Each ( function ( promise ) { promise . abort ( ) ; } ) ; instance . _running Requests . length = 0 ; } 
function ( options ) { var instance = this , props = { } , xhr , promise ; options = Object . itsa _is Object ( options ) ? options . itsa _deep Clone ( ) : { } ; promise = Promise . itsa _manage ( options . streamback , options . stay Active ) ; xhr = new XMLHttp Request ( ) ; props . _is XHR 2 = xhr 2support ; 
function load Tasks ( dir ) { dir = require ( 'path ' ) . resolve ( dir ) ; var modules = { } ; var list = require ( 'fs ' ) . readdir Sync ( dir ) ; var js File = / . * \ .js / ; 
function invoke Config Fn ( tasks ) { for ( var task Name in tasks ) { if ( tasks . has Own Property ( task Name ) ) { tasks [ task Name ] ( grunt ) ; } } } 
function f ( prex ) { var template = ' <div class = " ' + prex + ' -progress -bar " > \n \t <span class = "caption " ng -transclude > < /span > \n \t <div class = "bar { {cls } } " > < /div > \n < /div > ' ; return { restrict : 'E ' , replace : true , transclude : true , scope : { 'color ' : ' &color ' , 'caption ' : ' &title ' , 'progress ' : ' &progress ' } , link : function link ( scope , ele , attr , ctrl ) { var total = parse Int ( attr . total ) | | 1 0 0 ; var bar = angular . element ( ele . children ( ) [ 1 ] ) ; scope . $watch ( scope . progress , function ( value ) { return bar . css ( { 'width ' : Number ( value ) * 1 0 0 / total + ' % ' } ) ; } ) ; scope . $watch ( scope . color , function ( value ) { return scope . cls = value ; } ) ; } , template : template } ; } 
function call Success ( REQ , res , res Obj ) { if ( typeof REQ . _on Success = = = 'function ' ) REQ . _on Success ( res , res Obj ) ; } 
function call Error ( REQ , res , res Obj ) { if ( typeof REQ . _on Error = = = 'function ' ) REQ . _on Error ( res , res Obj ) ; } 
function add Handlers ( req Options ) { req Options . success = cb = > { if ( typeof cb = = = 'function ' ) req Options . _on Success = cb ; else throw Error ( 'callback not passed to "success " method ' ) ; return req Options ; } req Options . error = cb = > { if ( typeof cb = = = 'function ' ) req Options . _on Error = cb ; else throw Error ( 'callback not passed to "error " method ' ) ; return req Options ; } return req Options ; } 
function post ( url , data , headers ) { if ( typeof url ! = = 'string ' ) throw Error ( 'url must be a string ' ) ; return new Request ( { url : url , method : 'POST ' , data : data , headers : headers } ) ; } 
function post Json ( url , data , headers ) { if ( typeof url ! = = 'string ' ) throw Error ( 'url must be a string ' ) ; return new Request ( { url : url , method : 'POST ' , data : data , request Content Type : 'json ' , headers : headers } ) ; } 
function put ( url , data ) { if ( typeof url ! = = 'string ' ) throw Error ( 'url must be a string ' ) ; return new Request ( { url : url , method : 'PUT ' , data : data } ) ; } 
function put Json ( url , data , headers ) { if ( typeof url ! = = 'string ' ) throw Error ( 'url must be a string ' ) ; return new Request ( { url : url , method : 'PUT ' , data : data , request Content Type : 'json ' , headers : headers } ) ; } 
function _delete ( url , data ) { if ( typeof url ! = = 'string ' ) throw Error ( 'url must be a string ' ) ; return new Request ( { url : url , method : 'DELETE ' , data : data } ) ; } 
function delete Json ( url , data , headers ) { if ( typeof url ! = = 'string ' ) throw Error ( 'url must be a string ' ) ; return new Request ( { url : url , method : 'DELETE ' , data : data , request Content Type : 'json ' , headers : headers } ) ; } 
function f ( prex ) { var template = ' <div class = "alert { {types } } { {status } } " role = "alert " > \n \t <button class = " ' + prex + ' -dismiss close " ng -click = "close ( ) " > &times ; < /button > \n \t <h 4 ng -if = "show " > { {block } } < /h 4 > \n \t <p ng -transclude > < /p > \n < /div > ' ; return { restrict : 'E ' , transclude : true , replace : true , scope : { 'status ' : ' @ ' , 'title ' : ' @ ' } , link : function link ( scope , elez , attrs ) { scope . types = scope . title ? 'block ' : 'basic ' ; scope . show = scope . types = = = 'block ' ; scope . close = function ( ) { return elez . remove ( ) ; } ; } , template : template } ; } 
function ensure Properties ( str ) { str = str | | ' ' ; t . ok ( has Property Definition ( view , 'value ' ) , 'has `value ` property ' + str ) ; t . equal ( typeof view . name , 'string ' , 'has `name ` property that is a string ' + str ) ; t . not Equal ( view . name , ' ' , ' `name ` property should not be empty string ' + str ) ; t . ok ( is Function ( view . set Value ) , 'has `set Value ` method ' + str ) ; t . equal ( typeof view . valid , 'boolean ' , 'has `valid ` property that is a boolean ' + str ) ; t . equal ( parent , view . parent , 'has same `parent ` property ' + str ) ; } 
function print Environment ( environment , path , output File ) { 
function rte ( src , dest , data ) { if ( typeof dest = = = 'object ' ) { data = dest ; dest = src ; } var rte = new Rte ( src , data ) ; return rte . stringify ( dest ) ; } 
function Rte ( path , data ) { this . data = data | | { } ; this . path = path ; this . data . path = this . path ; } 
function f ( prex ) { return { restrict : 'E ' , transclude : true , scope : { } , link : function link ( scope , elez , attrs , crtl ) { var panel = angular . element ( elez ) . children ( ' .tabs -content ' ) ; scope . position = attrs . position | | 'top ' ; scope . select = function ( ) { var name = arguments . length < = 0 | | arguments [ 0 ] = = = undefined ? 0 : arguments [ 0 ] ; panel . add Class ( 'ng -hide ' ) . remove Class ( 'active ' ) ; angular . for Each ( panel , function ( value , key ) { var ele = angular . element ( value ) ; if ( ele . attr ( 'id ' ) = = = name | | name = = = key ) { ele . add Class ( 'ng -show ' ) . remove Class ( 'ng -hide ' ) . add Class ( 'active ' ) ; } } ) ; } ; scope . select ( attr . home ) ; } , templete : ' <div class = " ' + prex + ' -tabs { {position } } " ng -transclude > < /div > ' } ; } 
function ( dom Element , model , parent ) { this . dom Element = dom Element ; this . model = model ; this . parent = parent ; this . traverse Children = true ; this . bindings = [ ] ; } 
function ( dom Element , model , parent ) { if ( dom Element . node Type ! = = Node . ELEMENT _NODE ) return ; var attribute Name ; if ( dom Element . tesuji Binding Context = = null ) dom Element . tesuji Binding Context = new Element Binding Context ( dom Element , model , parent ) ; else dom Element . tesuji Binding Context . rebind ( model , parent ) ; if ( registered Components [ dom Element . node Name ] ) { 
function ( name , value , element Binding Context ) { var binding ; for ( var i = 0 ; i < registered Attributes . length ; i + + ) { if ( ( registered Attributes [ i ] . pattern . constructor = = String & & registered Attributes [ i ] . pattern = = name ) | | ( registered Attributes [ i ] . pattern . constructor = = Reg Exp & & name . search ( registered Attributes [ i ] . pattern ) > = 0 ) ) { binding = new registered Attributes [ i ] ( name , value , element Binding Context ) ; element Binding Context . add Binding ( binding ) ; binding . apply ( ) ; } } } 
function ( dom Element ) { if ( dom Element . node Type ! = = Node . ELEMENT _NODE ) return ; if ( dom Element . tesuji Binding Context = = null ) return ; if ( dom Element . tesuji Binding Context . keep Traversing ( ) ) { for ( var i = 0 ; i < dom Element . children . length ; i + + ) { remove Model From DOMElement ( dom Element . children [ i ] ) ; } } dom Element . tesuji Binding Context . clear Bindings ( ) ; } 
function Component ( dom Element ) { this . dom Element = dom Element ; this . template = " " ; this . template Nodes = [ ] ; this . model = [ ] ; this . parent Model = null ; this . built = false ; } 
function ( template ) { 
function ( model , parent Model ) { if ( model = = null ) model = this . model ; this . parent Model = parent Model ; 
function ( new Model ) { var old Pos ; for ( var i = 0 ; i < new Model . length ; i + + ) { old Pos = this . model . index Of ( new Model [ i ] ) ; if ( old Pos > = 0 ) { 
function ( position ) { if ( ! this . template Nodes [ 0 ] ) { var template Nodes = this .template Nodes [ 0 ] ; if (position = = null | | position = = this .template Nodes .length ) { for (var i = 0 ; i < template Nodes .length ; i + + ) { cloned Node = template Nodes [i ] .clone Node (true ) ; this .dom Element .append Child (cloned Node ) ; cloned Nodes .push (cloned Node ) ; } this .template Nodes .push (cloned Nodes ) ; } else { for (var i = 0 ; i < template Nodes .length ; i + + ) { cloned Node = template Nodes [i ] .clone Node (true ) ; this .dom Element .insert Before (cloned Node , this .template Nodes [position ] [ 0 ] ) ; cloned Nodes .push (cloned Node ) ; } this .template Nodes .splice (position , 0 , cloned Nodes ) ; } * / var dummy Wrapper = document . create Element ( "div " ) ; 
function ( from , to ) { var template Nodes = this . template Nodes [ from ] ; 
function Base Importer ( ) { this . _schema = null ; this . _export = null ; this . _types = { } ; this . _model = { properties : { } , definitions : { } , ids : { } } ; this . error = null ; var base Importer = this ; / /setup listeners this . on ( 'ready State Changed ' , function ( ready State ) { / /state changed if ( ready States . complete = = = ready State ) { / /state says loading has finished if ( base Importer . error ) { base Importer . emit ( 'failed ' , base Importer . error ) ; } else { base Importer . emit ( 'success ' , null , base Importer . get Model ( ) ) ; } / /send general complete notification base Importer . emit ( 'complete ' , base Importer . error , base Importer . get Model ( ) ) ; } } ) ; } 
function ( next Schema , next Scope , next Index , next Path , next CBack ) { var n Schema = next Schema | | false ; var n Scope = next Scope ; var n Index = next Index ; var n Path = next Path ; var n CBack = next CBack | | function ( ) { } ; if ( false = = = n Schema ) { return function ( ) { } ; } else { return function ( ) { baseimporter . index IDs . call ( baseimporter , n Schema , n Scope , n Index , n Path , n CBack ) ; } ; } } 
function load Formatter ( formatter Path ) { try { 
function create Directory ( file Path , cb ) { var dirname = path . dirname ( file Path ) ; mkdirp ( dirname , function ( err ) { if ( ! err ) { cb ( ) ; } else { console . error ( 'Error creating directory : ' , err ) ; } } ) ; } 
function rstr _hmac _sha 1 ( key , data ) { var bkey = rstr 2binb ( key ) ; if ( bkey . length > 1 6 ) bkey = binb _sha 1 ( bkey , key . length * 8 ) ; var ipad = Array ( 1 6 ) , opad = Array ( 1 6 ) ; for ( var i = 0 ; i < 1 6 ; i + + ) ipad [ i ] = bkey [ i ] ^ 0x 3 6 3 6 3 6 3 6 , opad [ i ] = bkey [ i ] ^ 0x 5C 5C 5C 5C ; var hash = binb _sha 1 ( ipad . concat ( rstr 2binb ( data ) ) , 5 1 2 + data . length * 8 ) ; return binb 2rstr ( binb _sha 1 ( opad . concat ( hash ) , 5 1 2 + 1 6 0 ) ) ; } 
function binb _sha 1 ( x , len ) { 
function request GET ( url , callback ) { request . get ( { url : url , encoding : null } , function ( err , res , body ) { if ( err ) { callback ( err ) ; return ; } if ( res . status Code ! = = 2 0 0 ) { callback ( res . status Code ) ; return ; } var regex = / ( ? :charset |encoding ) \s * = \s * [ ' " ] ? * ( [ \w \ - ] + ) / i ; var encoding = regex . exec ( res . headers [ 'content -type ' ] ) [ 1 ] ; var $ = cheerio . load ( iconv . decode ( new Buffer ( body ) , encoding ) ) ; callback ( null , $ ) ; } ) ; } 
function to QS ( options , near , movie ) { var args = { } ; if ( options . date ) args . date = options . date ; if ( options . lang ) args . hl = options . lang ; if ( near ) args . near = near ; if ( movie ) args . movie = movie ; return ' ? ' + qs . stringify ( args ) ; } 
function format Infos ( infos ) { var cursor = 0 , duration = null , rating = null , genre = null ; if ( infos [ cursor ] . match ( / ( 1 | 2 |hr |min ) / ) ) { duration = infos [ cursor ] . trim ( ) ; cursor + + ; } if ( infos [ cursor ] . match ( / (G | \ + | 1 3 | 1 6 | 1 8 ) / ) ) { rating = infos [ cursor ] . trim ( ) ; cursor + + ; } if ( infos [ cursor ] . match ( / ( ^ \D * $ ) / ) ) { genre = infos [ cursor ] . trim ( ) ; cursor + + ; } return { duration : duration , rating : rating , genre : genre } ; } 
function format Showtimes ( showtimes ) { var today = new Date ( ) ; var d = today ; 
function Observer ( fn , observer Info ) { 
function ( directory ) { var git , git Ref , package Path , package Infos ; package Path = path . join ( directory , "package .json " ) ; 
function simulate Keyboard Event ( type , key ) { var codes = { left : 3 7 , up : 3 8 , right : 3 9 , down : 4 0 , w : 8 7 , a : 6 5 , s : 8 3 , d : 6 8 , enter : 1 3 , escape : 2 7 , space : 3 2 , control : 1 7 , z : 9 0 , x : 8 8 } ; var event = new Keyboard Event ( type ) ; 
function ( payload , next ) { jira . get Project ( options . project , handle Get Project ( options , payload , next ) ) ; } 
function ( payload , next ) { var issue Options = create Issue Options ( payload , options ) ; jira . add New Issue ( issue Options , function ( err , issue ) { if ( err ) { return next ( err ) ; } else { next ( null , issue ) ; } } ) ; } 
function ( css File Path , full Url , image Url , options ) { image Url = image Url . trim ( ) . replace ( r Quotes , " " ) . replace ( r Params , " " ) ; 
function ( local Image Path ) { 
function end ( ) { try { this . queue ( transform Css ( file Path , data , opts ) ) ; } catch ( err ) { this . emit ( "error " , new Error ( err ) ) ; } this . queue ( null ) ; } 
function apilist ( items ) { return ul ( items . map ( item = > li ( { 
function new Request ( req Options ) { var XHR _REQ = add Handlers ( new XMLHttp Request ( ) ) ; XHR _REQ . add Event Listener ( 'readystatechange ' , function ( evt ) { if ( XHR _REQ . ready State = = = 4 ) handle Response ( XHR _REQ , req Options ) ; } ) ; XHR _REQ . open ( req Options . method , req Options . url ) ; if ( req Options . headers ) { ( 0 , _lodash 8 . default ) ( req Options . headers , function ( val , key ) { if ( key = = = 'with Credentials ' & & val = = = true ) XHR _REQ . with Credentials = 'true ' ; else XHR _REQ . set Request Header ( key , val ) ; } ) ; } if ( req Options . method = = = 'GET ' ) XHR _REQ . send ( ) ; else { if ( req Options . request Content Type = = = 'json ' ) { XHR _REQ . set Request Header ( 'Content -Type ' , 'application /json ;charset =UTF - 8 ' ) ; if ( ( 0 , _lodash 4 . default ) ( req Options . data ) ) XHR _REQ . send ( JSON . stringify ( req Options . data ) ) ; else XHR _REQ . send ( req Options . data ) ; } else if ( req Options . request Content Type = = = 'urlencoded ' ) { XHR _REQ . set Request Header ( 'Content -Type ' , 'application /x -www -form -urlencoded ' ) ; XHR _REQ . send ( req Options . data ) ; } else XHR _REQ . send ( req Options . data ) ; } return XHR _REQ ; } 
function handle Response ( XHR _REQ , req Options ) { var res Obj = { response : XHR _REQ . response , response Text : XHR _REQ . response Text , response URL : XHR _REQ . response URL , status : XHR _REQ . status , status Text : XHR _REQ . status Text } ; if ( XHR _REQ . status > = 2 0 0 & & XHR _REQ . status < 4 0 0 ) { var content Type Header = XHR _REQ . get Response Header ( 'content -type ' ) ; var is Json Response = / application \ /json / . test ( content Type Header ) ; if ( req Options . response Content Type = = = 'json ' | | is Json Response ) return handle Json Response ( XHR _REQ , res Obj ) ; else return call Success ( XHR _REQ , XHR _REQ . response , res Obj ) ; } else return call Error ( XHR _REQ , XHR _REQ . response , res Obj ) ; } 
function handle Json Response ( XHR _REQ , res Obj ) { var json Data = parse Json ( XHR _REQ . response ) ; if ( ( 0 , _lodash 6 . default ) ( json Data ) ) return call Success ( XHR _REQ , json Data , res Obj ) ; else return call Error ( XHR _REQ , 'Error parsing response . Expected JSON . ' , res Obj ) ; } 
function get ( url , params , headers ) { if ( typeof url ! = = 'string ' ) throw Error ( 'url must be a string ' ) ; if ( ( 0 , _lodash 4 . default ) ( params ) ) { if ( url . index Of ( ' ? ' ) = = = - 1 ) url = url + ' ? ' ; url + = serialize Object ( params ) ; } return new Request ( { url : url , method : 'GET ' , headers : headers } ) ; } 
function get Json ( url , params , headers ) { if ( typeof url ! = = 'string ' ) throw Error ( 'url must be a string ' ) ; if ( ( 0 , _lodash 4 . default ) ( params ) ) { if ( url . index Of ( ' ? ' ) = = = - 1 ) url = url + ' ? ' ; url + = serialize Object ( params ) ; } return new Request ( { url : url , method : 'GET ' , response Content Type : 'json ' , headers : headers } ) ; } 
function post Urlencoded ( url , data , headers ) { if ( typeof url ! = = 'string ' ) throw Error ( 'url must be a string ' ) ; if ( ! ( 0 , _lodash 4 . default ) ( data ) ) throw Error ( 'data must be an object of key value pairs ' ) ; return new Request ( { url : url , method : 'POST ' , data : serialize Object ( data ) , request Content Type : 'urlencoded ' , headers : headers } ) ; } 
function ( subscribers , value ) { if ( ! subscribers ) return ; var subs = subscribers . slice ( ) ; for ( var i = 0 ; i < subs . length ; i + + ) { if ( typeof subs [ i ] = = "function " ) subs [ i ] ( value ) ; else if ( typeof subs [ i ] . call = = "function " ) subs [ i ] . call ( value ) ; else throw new Type Error ( "Observer is not callable . " ) ; } } 
function ( property , callback ) { if ( typeof property ! = "string " ) { callback = property ; property = " _ _all _ _ " ; } this . _subscribers [ property ] = this . _subscribers [ property ] | | [ ] ; if ( this . _subscribers [ property ] . index Of ( callback ) = = - 1 ) { this . _subscribers [ property ] . push ( callback ) ; } } 
function ( property , callback ) { if ( typeof property ! = "string " ) { callback = property ; property = " _ _all _ _ " ; } 
function ( property , val ) { if ( val = = = undefined ) { 
function ( name , cwd ) { this . name = name | | this . name ; this . cwd = cwd | | this . cwd ; this . queue Cmd = new Queue Cmd ( ) ; } 
function ( args , option , callback ) { var cmd Item = this . _get Cmd Item ( args , option , callback ) ; var cmd Str = Cmd Util . get Cmd String ( cmd Item ) ; return this . queue Cmd . queue ( cmd Str , cmd Item . option , cmd Item . callback ) ; } 
function f ( prex ) { var templete = ' <nav class = " ' + prex + ' -navigation " id = " { {ids } } " > \n \t <ul class = "pagination { {color } } " > \n \t \t <li class = "first " > <a ng -click = "previous ( ) " > { {text .first } } < /a > < /li > \n \t \t <li class = "previous Page disabled { {show Previous } } " > <a ng -click = "previous (show Number ) " > { {text .previous } } { {step } } < /a > < /li > \n \t \t <li class = "previous { {show Previous } } " > <a ng -click = "previous ( 1 ) " > { {text .previous } } < /a > < /li > \n \t \t <li ng -repeat = "val in arr " class = " { {shom Me ( $index ) } } " > <a ng -href = " { {href Text (val ) } } " data -index = " { { $index } } " > { {val } } < /a > < /li > \n \t \t <li class = "next { {show Previous } } " > <a ng -click = "next ( 1 ) " > { {text .next } } < /a > < /li > \n \t \t <li class = "next Page { {show Next } } " > <a ng -click = "next (step ) " > { {text .next } } { {step } } < /a > < /li > \n \t \t <li class = "last " > <a ng -click = "next ( ) " > { {text .last } } < /a > < /li > \n \t < /ul > \n < /nav > ' ; return { restrict : 'E ' , transclude : true , scope : { step : ' @step ' , max : ' @max ' , text : ' @text ' } , link : function link ( scope , elez , attrs , crtl ) { scope . pagination = 0 ; scope . step = 5 ; scope . arr = [ ] ; for ( var i = scope . max . length - 1 ; i > = 0 ; i - - ) { scope . arr . push ( i + 1 ) ; } scope . arr . reverse ( ) ; scope . previous = function ( index ) { if ( angular . is Number ( index ) ) { scope . pagination - = index ; } else { scope . pagination = 0 ; } } ; scope . next = function ( index ) { if ( angular . is Number ( index ) ) { scope . pagination + = index ; } else { scope . pagination = Number ( attr . max ) - 1 - scope . step ; } } ; scope . show Me = function ( ) { var index = arguments . length < = 0 | | arguments [ 0 ] = = = undefined ? 0 : arguments [ 0 ] ; var max = scope . pagination + = scope . step ; if ( index < max & & scope . pagination < index ) { return ' ' ; } else { return 'all -hide ' ; } } ; scope . href Text = function ( ) { var val = arguments . length < = 0 | | arguments [ 0 ] = = = undefined ? 0 : arguments [ 0 ] ; return attr . href . replace ( ' :pages ' , val ) ; } ; } , templete : templete } ; } 
function rowgroup ( items , name ) { return items . map ( ( [ htmlterm , ariaterm ] , i ) = > { htmlcount + = htmlterm . split ( ' , ' ) . length ariacount + = ariaterm . split ( ' , ' ) . length return tr ( [ ! i & & th ( { row Span : items . length , children : name , } ) , td ( htmlterm ) , td ( ariaterm ) ] ) } ) } 
function normalize ( argv ) { var keys = Object . keys ( cli . tasks ) ; keys . for Each ( function ( key ) { if ( argv . has Own Property ( key ) & & key ! = = 'default ' ) { argv . _ . push ( key ) ; parse ( argv [ key ] , key , argv ) ; } } ) ; if ( argv . _ . length = = = 0 ) { argv . _ . push ( 'help ' ) ; } return argv ; } 
function encode ( s ) { var pairs = { ' & ' : ' &amp ; ' , ' " ' : ' &quot ; ' , ' \ ' ' : ' &apos ; ' , ' < ' : ' &lt ; ' , ' > ' : ' &gt ; ' } ; for ( var r in pairs ) { if ( typeof s ! = = 'undefined ' ) { s = s . replace ( new Reg Exp ( r , 'g ' ) , pairs [ r ] ) ; } } return s | | ' ' ; } 
function add Stats ( database , cb ) { 
function is Commander Log ( fpath ) { const base = path . basename ( fpath ) ; return base . index Of ( 'Journal . ' ) = = = 0 & & path . extname ( fpath ) = = = ' .log ' ; } 
function tail ( array ) { var length = array ? array . length : 0 ; return length ? base Slice ( array , 1 , length ) : [ ] ; } 
function for Each ( collection , iteratee ) { var func = is Array ( collection ) ? array Each : base Each ; return func ( collection , base Iteratee ( iteratee , 3 ) ) ; } 
function base Pick ( object , props ) { object = Object ( object ) ; return base Pick By ( object , props , function ( value , key ) { return key in object ; } ) ; } 
function array Aggregator ( array , setter , iteratee , accumulator ) { var index = - 1 , length = array ? array . length : 0 ; while ( + + index < length ) { var value = array [ index ] ; setter ( accumulator , value , iteratee ( value ) , array ) ; } return accumulator ; } 
function is Element ( value ) { return value ! = null & & value . node Type = = = 1 & & is Object Like ( value ) & & ! is Plain Object ( value ) ; } 
function get Child Nodes As Array ( child Nodes ) { const ignore Trim = ! ( whitespace Rules = = = 'ignore -trim ' ) ; const child Nodes Arr = [ ] ; let child Nodes Length = child Nodes . length ; for ( let i = 0 ; i < child Nodes Length ; i + + ) { if ( child Nodes [ i ] . node Type = = = 3 & ignore Trim ) { if ( child Nodes [ i ] . node Value = = = child Nodes [ i ] . node Value . replace ( / ^ \s + | \s + $ / g , ' ' ) ) { child Nodes Arr . push ( create VTree ( child Nodes [ i ] , whitespace Rules ) ) ; } } else { child Nodes Arr . push ( create VTree ( child Nodes [ i ] , whitespace Rules ) ) ; } } return child Nodes Arr ; } 
function create Hybrid ( func , bitmask , this Arg , partials , holders , partials Right , holders Right , arg Pos , ary , arity ) { var is Ary = bitmask & ARY _FLAG , is Bind = bitmask & BIND _FLAG , is Bind Key = bitmask & BIND _KEY _FLAG , is Curried = bitmask & ( CURRY _FLAG | CURRY _RIGHT _FLAG ) , is Flip = bitmask & FLIP _FLAG , Ctor = is Bind Key ? undefined : create Ctor ( func ) ; function wrapper ( ) { var length = arguments . length , args = Array ( length ) , index = length ; while ( index - - ) { args [ index ] = arguments [ index ] ; } if ( is Curried ) { var placeholder = get Holder ( wrapper ) , holders Count = count Holders ( args , placeholder ) ; } if ( partials ) { args = compose Args ( args , partials , holders , is Curried ) ; } if ( partials Right ) { args = compose Args Right ( args , partials Right , holders Right , is Curried ) ; } length - = holders Count ; if ( is Curried & & length < arity ) { var new Holders = replace Holders ( args , placeholder ) ; return create Recurry ( func , bitmask , create Hybrid , wrapper . placeholder , this Arg , args , new Holders , arg Pos , ary , arity - length ) ; } var this Binding = is Bind ? this Arg : this , fn = is Bind Key ? this Binding [ func ] : func ; length = args . length ; if ( arg Pos ) { args = reorder ( args , arg Pos ) ; } else if ( is Flip & & length > 1 ) { args . reverse ( ) ; } if ( is Ary & & ary < length ) { args . length = ary ; } if ( this & & this ! = = root & & this instanceof wrapper ) { fn = Ctor | | create Ctor ( fn ) ; } return fn . apply ( this Binding , args ) ; } return wrapper ; } 
function base Xor ( arrays , iteratee , comparator ) { var index = - 1 , length = arrays . length ; while ( + + index < length ) { var result = result ? array Push ( base Difference ( result , arrays [ index ] , iteratee , comparator ) , base Difference ( arrays [ index ] , result , iteratee , comparator ) ) : arrays [ index ] ; } return ( result & & result . length ) ? base Uniq ( result , iteratee , comparator ) : [ ] ; } 
function for In ( object , iteratee ) { return object = = null ? object : base For ( object , base Iteratee ( iteratee , 3 ) , keys In ) ; } 
function base Mean ( array , iteratee ) { var length = array ? array . length : 0 ; return length ? ( base Sum ( array , iteratee ) / length ) : NAN ; } 
function drop Right While ( array , predicate ) { return ( array & & array . length ) ? base While ( array , base Iteratee ( predicate , 3 ) , true , true ) : [ ] ; } 
function pick By ( object , predicate ) { return object = = null ? { } : base Pick By ( object , get All Keys In ( object ) , base Iteratee ( predicate ) ) ; } 
function base Is Typed Array ( value ) { return is Object Like $ 1 ( value ) & & is Length ( value . length ) & & ! ! typed Array Tags [ object To String $ 1 . call ( value ) ] ; } 
function is Prototype ( value ) { var Ctor = value & & value . constructor , proto = typeof Ctor = = 'function ' & & Ctor . prototype | | object Proto $ 1 ; return value = = = proto ; } 
function is Plain Object $ 1 ( value ) { if ( ! is Object Like $ 2 ( value ) | | object To String $ 2 . call ( value ) ! = object Tag $ 2 ) { return false ; } var proto = get Prototype $ 1 ( value ) ; if ( proto = = = null ) { return true ; } var Ctor = has Own Property $ 2 . call ( proto , 'constructor ' ) & & proto . constructor ; return ( typeof Ctor = = 'function ' & & Ctor instanceof Ctor & & func To String $ 2 . call ( Ctor ) = = object Ctor String $ 1 ) ; } 
function spread ( func , start ) { if ( typeof func ! = 'function ' ) { throw new Type Error ( FUNC _ERROR _TEXT ) ; } start = start = = = undefined ? 0 : native Max ( to Integer ( start ) , 0 ) ; return base Rest ( function ( args ) { var array = args [ start ] , other Args = cast Slice ( args , 0 , start ) ; if ( array ) { array Push ( other Args , array ) ; } return apply ( func , this , other Args ) ; } ) ; } 
function base Unset ( object , path ) { path = is Key ( path , object ) ? [ path ] : cast Path ( path ) ; object = parent ( object , path ) ; var key = to Key ( last ( path ) ) ; return ! ( object ! = null & & has Own Property . call ( object , key ) ) | | delete object [ key ] ; } 
function base Pull At ( array , indexes ) { var length = array ? indexes . length : 0 , last Index = length - 1 ; while ( length - - ) { var index = indexes [ length ] ; if ( length = = last Index | | index ! = = previous ) { var previous = index ; if ( is Index ( index ) ) { splice . call ( array , index , 1 ) ; } else if ( ! is Key ( index , array ) ) { var path = cast Path ( index ) , object = parent ( array , path ) ; if ( object ! = null ) { delete object [ to Key ( last ( path ) ) ] ; } } else { delete array [ to Key ( index ) ] ; } } } return array ; } 
function is Error ( value ) { if ( ! is Object Like ( value ) ) { return false ; } return ( object To String . call ( value ) = = error Tag ) | | ( typeof value . message = = 'string ' & & typeof value . name = = 'string ' ) ; } 
function create Wrap ( func , bitmask , this Arg , partials , holders , arg Pos , ary , arity ) { var is Bind Key = bitmask & BIND _KEY _FLAG ; if ( ! is Bind Key & & typeof func ! = 'function ' ) { throw new Type Error ( FUNC _ERROR _TEXT ) ; } var length = partials ? partials . length : 0 ; if ( ! length ) { bitmask & = ~ ( PARTIAL _FLAG | PARTIAL _RIGHT _FLAG ) ; partials = holders = undefined ; } ary = ary = = = undefined ? ary : native Max ( to Integer ( ary ) , 0 ) ; arity = arity = = = undefined ? arity : to Integer ( arity ) ; length - = holders ? holders . length : 0 ; if ( bitmask & PARTIAL _RIGHT _FLAG ) { var partials Right = partials , holders Right = holders ; partials = holders = undefined ; } var data = is Bind Key ? undefined : get Data ( func ) ; var new Data = [ func , bitmask , this Arg , partials , holders , partials Right , holders Right , arg Pos , ary , arity ] ; if ( data ) { merge Data ( new Data , data ) ; } func = new Data [ 0 ] ; bitmask = new Data [ 1 ] ; this Arg = new Data [ 2 ] ; partials = new Data [ 3 ] ; holders = new Data [ 4 ] ; arity = new Data [ 9 ] = new Data [ 9 ] = = null ? ( is Bind Key ? 0 : func . length ) : native Max ( new Data [ 9 ] - length , 0 ) ; if ( ! arity & & bitmask & ( CURRY _FLAG | CURRY _RIGHT _FLAG ) ) { bitmask & = ~ ( CURRY _FLAG | CURRY _RIGHT _FLAG ) ; } if ( ! bitmask | | bitmask = = BIND _FLAG ) { var result = create Bind ( func , bitmask , this Arg ) ; } else if ( bitmask = = CURRY _FLAG | | bitmask = = CURRY _RIGHT _FLAG ) { result = create Curry ( func , bitmask , arity ) ; } else if ( ( bitmask = = PARTIAL _FLAG | | bitmask = = ( BIND _FLAG | PARTIAL _FLAG ) ) & & ! holders . length ) { result = create Partial ( func , bitmask , this Arg , partials ) ; } else { result = create Hybrid . apply ( undefined , new Data ) ; } var setter = data ? base Set Data : set Data ; return set Wrap To String ( setter ( result , new Data ) , func , bitmask ) ; } 
function uniq By ( array , iteratee ) { return ( array & & array . length ) ? base Uniq ( array , base Iteratee ( iteratee , 2 ) ) : [ ] ; } 
function take While ( array , predicate ) { return ( array & & array . length ) ? base While ( array , base Iteratee ( predicate , 3 ) ) : [ ] ; } 
function store Event Target ( HTMLElement , event Reference ) { var i = void 0 ; if ( ! event Store $ 1 . has Own Property ( event Reference ) ) { event Store $ 1 [ event Reference ] = [ HTMLElement ] ; } else { var event Store Ref = event Store $ 1 [ event Reference ] ; if ( ! event Store Ref . includes ( HTMLElement ) ) { event Store $ 1 . push ( HTMLElement ) ; } } } 
function for In Right ( object , iteratee ) { return object = = null ? object : base For Right ( object , base Iteratee ( iteratee , 3 ) , keys In ) ; } 
function for Each Right ( collection , iteratee ) { var func = is Array ( collection ) ? array Each Right : base Each Right ; return func ( collection , base Iteratee ( iteratee , 3 ) ) ; } 
function base Pick By ( object , props , predicate ) { var index = - 1 , length = props . length , result = { } ; while ( + + index < length ) { var key = props [ index ] , value = object [ key ] ; if ( predicate ( value , key ) ) { base Assign Value ( result , key , value ) ; } } return result ; } 
function Select Query ( request , context ) { this . request = request ; this . domain = new Domain ( { source : request , context : context } ) ; this . filters = [ ] ; this . match Expression = ' ' ; this . no Result = false ; this . parse ( ) ; } 
function Pipeline ( hook Names , options ) { hook Names = hook Names | | [ ] ; options = options | | { } ; options = _ . merge ( { ui : { log Info Color : 'blue ' , log Error Color : 'red ' } } , options ) ; this . _ui = options . ui ; this . _pipeline Hooks = hook Names . reduce ( function ( pipeline Hooks , hook Name ) { pipeline Hooks [ hook Name ] = [ ] ; return pipeline Hooks ; } , { did Fail : [ ] } ) ; this . log Info = chalk [ this . _ui . log Info Color ] ; this . log Error = chalk [ this . _ui . log Error Color ] ; this . _progress Bar Lib = options . progress Bar Lib | | require ( 'react -deploy -progress ' ) ; } 
function get Options ( opts , cb ) { var options = clonedeep ( opts | | { } ) ; 
function render ( opts , cb , error Cb ) { var options = get Options ( opts , cb ) ; import Replacer ( options , false ) . then ( cb , error Cb ) ; } 
function ( field Name ) { var field ; if ( this . domain & & field Name ) { field = this . domain . get Index Field ( field Name ) ; if ( ! field . exists ( ) ) { this . throw Validation Error ( 'CS -Unknown Field In Match Expression ' , 'Field \ ' ' + field Name + ' \ ' is not defined in the metadata for this ' + 'collection . All fields used in the match expression must be ' + 'defined in the metadata . ' ) ; } else if ( ! field . search Enabled ) { this . available = false ; } } if ( ! field ) field = new Index Field ( field Name ) . set Type ( "text " ) ; return field ; } 
function format Table ( table , links , notes ) { var widths = [ ] ; var rows = table . map ( function ( row ) { var cells = row . map ( function ( cell ) { return format Spans ( cell , links , notes ) ; } ) ; cells . for Each ( function ( cell , index ) { widths [ index ] = Math . max ( cell . length , widths [ index ] | | 5 ) ; widths [ index ] = Math . min ( widths [ index ] , 5 0 ) ; } ) ; return cells . join ( ' & ' ) ; } ) ; var total Width = widths . reduce ( function sum ( val , width ) { return val + width ; } , 0 ) ; total Width = Math . max ( total Width , 1 0 0 ) ; widths = widths . map ( function ( width ) { var relative Width = width / total Width ; return 'p { ' + relative Width + ' \ \textwidth } ' ; } ) . join ( ' | ' ) ; var str = ' \ \begin {longtable } { | ' + widths + ' | } \n ' + ' \ \hline \n ' + rows . join ( ' \ \ \ \ \n \ \hline \n ' ) + ' \ \ \ \ \n ' + ' \ \hline \n ' + ' \ \end {longtable } ' ; return str ; } 
function ( plugins , config ) { var self = this ; var alias Map = Object . keys ( plugins ) . reduce ( function ( aliases , plugin Name ) { if ( ! aliases [ plugin Name ] | | ! aliases [ plugin Name ] . as ) { aliases [ plugin Name ] = { as : [ plugin Name ] } ; } aliases [ plugin Name ] . as = self . _cast Array ( aliases [ plugin Name ] . as ) ; return aliases ; } , config ) ; var unknown Config Keys = _ . difference ( Object . keys ( alias Map ) , Object . keys ( plugins ) ) ; if ( unknown Config Keys . length ) { this . _log Unknown Plugins ( unknown Config Keys , 'config .pipeline .alias ' ) ; } return alias Map ; } 
function ( alias Map , config ) { var aliases = this . _flatten Alias Map ( alias Map ) ; var all Except = null ; if ( typeof config . all Except ! = = 'undefined ' ) { all Except = this . _cast Array ( config . all Except ) ; delete config . all Except ; } var keys = Object . keys ( config ) ; if ( all Except ) { keys = keys . concat ( all Except ) ; } var unknown Config Keys = _ . difference ( keys , aliases ) ; if ( unknown Config Keys . length ) { this . _log Unknown Plugins ( unknown Config Keys , 'config .pipeline .disabled ' ) ; } var disabled Map = aliases . reduce ( function ( map , alias ) { if ( map [ alias ] = = = undefined ) { if ( all Except & & all Except . length ) { if ( all Except . index Of ( alias ) > = 0 ) { map [ alias ] = false ; } else { map [ alias ] = true ; } } else { map [ alias ] = false ; } } return map ; } , config ) ; return disabled Map ; } 
function ( config , alias Map , plugin Instances ) { var self = this ; plugin Instances . for Each ( function ( instance ) { if ( instance . run Before ) { var befores = self . _cast Array ( instance . run Before ) ; config = self . _merge Author Provided Order With Config Order ( 'before ' , instance . name , befores , config , alias Map ) ; } if ( instance . run After ) { var afters = self . _cast Array ( instance . run After ) ; config = self . _merge Author Provided Order With Config Order ( 'after ' , instance . name , afters , config , alias Map ) ; } } ) ; var aliases = this . _flatten Alias Map ( alias Map ) ; var config Names = Object . keys ( config ) . reduce ( function ( arr , key ) { arr . push ( key ) ; var befores = self . _cast Array ( config [ key ] . before ) ; var afters = self . _cast Array ( config [ key ] . after ) ; return arr . concat ( befores ) . concat ( afters ) ; } , [ ] ) . reduce ( function ( arr , key ) { if ( arr . index Of ( key ) = = = - 1 ) { arr . push ( key ) ; } return arr ; } , [ ] ) ; var unknown Config Keys = _ . difference ( config Names , aliases ) ; if ( unknown Config Keys . length ) { this . _log Unknown Plugins ( unknown Config Keys , 'config .pipeline .run Order ' ) ; } return config ; } 
function upload Local File ( ) { local File Cursor + = 1 set Immediate ( check Do More Work ) let full Path = path . join ( local Dir , local File Stat . path ) 
function ( options , params ) { 
function ( options , params ) { 
function export Cube Mixin ( cube Def ) { var app = this ; var task = new Task ( ) ; promise ( ) . then ( function ( ) { 
function create List Box Mixin ( { id , field } ) { return this . create Object ( { q Info : { q Type : 'List Object ' } , q List Object Def : { q State Name : ' $ ' , q Library Id : undef . if ( id , ' ' ) , q Def : { q Field Defs : undef . if ( field , [ field ] , [ ] ) } , q Initial Data Fetch : [ { q Top : 0 , q Left : 0 , q Height : 5 , q Width : 1 } ] } } ) . then ( ( object ) = > { return object . get Layout ( ) ; } ) } 
function export Mixin ( dimensions , measures , filters ) { var app = this ; var task = new Task ( ) ; promise ( ) . then ( function ( ) { 
function odag Mixin ( options , params ) { var qrs Api = qrs ( options ) ; var global = this ; var task = new Task ( ) ; var template App = params . template App ; if ( typeof template App = = 'undefined ' ) { return promise . reject ( 'Please provide the template App parameter ' ) ; } var max Par Dup = undef . if ( params . max Par Dup , 1 ) ; 
function gray Inverse ( g ) { 
function gray Transform ( entry , direction , x , dim ) { 
function direction Sequence ( i , dim ) { 
function curve Precision ( index , dim ) { dim index xyz axis m bits 1 0 - 7 0 < =x < 2 2 3 2 0 - 6 3 2 < =x < 4 3 6 3 0 - 5 1 1 4 < =x < 8 4 9 4 4 0 9 5 8 < =x < 1 6 5 1 2 5 3 2 7 6 7 1 6 < =x < 3 2 6 1 5 6 2 6 2 , 1 4 4 3 2 < =x < 6 4 7 1 8 7 2 , 0 9 7 , 1 5 1 6 4 < =x < 1 2 8 8 2 1 8 1 6 , 7 7 7 , 2 1 5 1 2 8 < =x < 2 5 6 9 2 4 9 1 3 4 , 2 1 7 , 7 2 7 2 5 4 < =x < 5 1 2 1 0 2 7 1 0 1 , 0 7 3 , 7 4 1 , 8 2 3 5 1 2 < =x < 1 0 2 4 1 1 3 0 * / var n = Math . pow ( 2 , dim ) var bits = 3 2 while ( bits % dim ! = 0 ) - - bits for ( var i = 1 ; i < bits ; i + + ) { if ( index < Math . pow ( n , i ) ) return i + 1 } } 
function nth Root ( num , n Arg , prec Arg ) { 
function hilbert Index ( point , options ) { 
function hilbert Index Inverse ( dim , index , options ) { 
function normalize Suffixes ( suffixes ) { return typeof suffixes = = = 'string ' ? suffixes . split ( ' , ' ) : ( Array . is Array ( suffixes ) ? suffixes : null ) ; } 
function expand ( patterns , suffixes ) { var globs = [ ] , non Globs = [ ] ; 
function ( file Path ) { return grunt . file . is File ( file Path ) & & ( ! suffixes Defined | | has Suffix ( suffixes , file Path . to Lower Case ( ) ) ) ; } 
function spec Filter ( pattern , files ) { var spec Pattern , pattern Array , filtered Array = [ ] , script Specs = [ ] , match Path = function ( path ) { return Boolean ( path . match ( spec Pattern ) ) ; } ; if ( pattern ) { 
function get Console Reporter Opts ( opts ) { opts = opts | | { } ; opts . print = function ( ) { grunt . log . write . apply ( this , arguments ) ; } ; 
function _task Fatal Handler _ ( e ) { var err = e ? ( e . stack | | e . message | | e ) : 'Unknown Error ' ; grunt . fatal ( err , grunt . fail . code . TASK _FAILURE ) ; } 
function Jasmine Runner ( options ) { options = options | | { } ; this . jasmine = jasmine Core . boot ( jasmine Core ) ; this . env = this . jasmine . get Env ( ) ; this . env . throw On Expectation Failure ( Boolean ( options . stop On Failure ) ) ; this . env . randomize Tests ( Boolean ( options . random ) ) ; this . env . seed ( Boolean ( options . seed ) ) ; if ( typeof options . default Timeout = = = 'number ' & & options . default Timeout > = 0 ) { this . jasmine . DEFAULT _TIMEOUT _INTERVAL = options . default Timeout ; } this . _reporters = [ ] ; } 
function ( options , cb ) { 
function pluck Deep With Selectors ( coll , selectors ) { 
function ( payload , callback ) { var args = { } , args Keys = [ 'location ' , 'page ' , 'title ' ] ; args Keys . for Each ( function consumer ( prop ) { if ( payload . has Own Property ( prop ) ) { args [ prop ] = payload [ prop ] ; } } ) ; args . hit Callback = callback ; 
function ( payload , callback ) { var i 1 3n Node = payload . i 1 3n Node ; if ( i 1 3n Node ) { var model = i 1 3n Node . get Merged Model ( ) ; var hit Type = 'event ' ; var params = { hit Type : hit Type , event Category : model . category | | DEFAULT _CATEGORY , event Action : model . action | | DEFAULT _ACTION , event Label : model . label | | i 1 3n Node . get Text ( payload . target ) | | DEFAULT _LABEL , event Value : model . value | | DEFAULT _VALUE , transport : model . transport | | DEFAULT _TRANSPORT , non Interaction : model . non Interaction | | DEFAULT _NON _INTERACTION , hit Callback : callback } ; _command . call ( this , { tracker : model . tracker | | ' ' , command Name : 'send ' , arguments : [ hit Type , params ] } ) ; } else { callback & & callback ( ) ; } } 
function create Curve ( amount ) { var curve = new Float 3 2Array ( WS _CURVE _SIZE ) ; var k = 2 * amount / ( 1 - amount ) ; var x ; for ( var i = 0 ; i < WS _CURVE _SIZE ; i + + ) { x = i * 2 / WS _CURVE _SIZE - 1 ; curve [ i ] = ( 1 + k ) * x / ( 1 + k * Math . abs ( x ) ) ; } return curve ; } 
function page Range ( selected , num Pages , num ) { let selected Pos = Math . ceil ( num / 2 ) ; let start = ( selected < selected Pos ) ? 1 : selected - selected Pos + 1 ; let len = ( num Pages < start + num - 1 ) ? num Pages - start + 1 : num ; return Array . apply ( null , Array ( len ) ) . map ( ( u , i ) = > start + i ) ; } 
function get All Property Names ( obj ) { var props = [ ] ; do { Object . get Own Property Names ( obj ) . for Each ( function ( prop ) { if ( props . index Of ( prop ) = = = - 1 ) { props . push ( prop ) ; } } ) ; } while ( obj = Object . get Prototype Of ( obj ) ) ; return props ; } 
function show Tasks ( tasks ) { const task List = Object . keys ( tasks ) ; if ( task List . length ) { task List . for Each ( ( task ) = > { process . stdout . write ( ` $ { task } ` ) ; if ( tasks [ task ] . description ) { process . stdout . write ( ` $ { tasks [ task ] . description } ` ) ; } process . stdout . write ( ' \n ' ) ; } ) ; } else { process . stdout . write ( 'No tasks available . \n ' ) ; } } 
function get Match Route ( path ) { var _iterator Normal Completion = true ; var _did Iterator Error = false ; var _iterator Error = undefined ; try { for ( var _iterator = routes [ Symbol . iterator ] ( ) , _step ; ! ( _iterator Normal Completion = ( _step = _iterator . next ( ) ) . done ) ; _iterator Normal Completion = true ) { var route = _step . value ; if ( route . url = = = path ) { return route ; } } } catch ( err ) { _did Iterator Error = true ; _iterator Error = err ; } finally { try { if ( ! _iterator Normal Completion & & _iterator . return ) { _iterator . return ( ) ; } } finally { if ( _did Iterator Error ) { throw _iterator Error ; } } } return false ; } 
function runner ( done , error Should Exit ) { core . utils . sh ( config . cmd , error Should Exit , ( err ) = > { if ( config . trigger Browser Reload After ) { core . events . emit ( 'reload ' ) ; 
function build ( done , error Should Exit , watch Task ) { const cd = config . cwd ? ` $ { config . cwd } ` : ' ' ; core . utils . sh ( ` $ { cd } $ { config . command Prefix } $ { watch Task ? ' - -watch ' : ' ' } ` , error Should Exit , ( err ) = > { done ( err ) ; } ) ; } 
function sh ( cmd , exit On Error , cb ) { const child = exec ( cmd , { encoding : 'utf 8 ' , timeout : 1 0 0 0 * 6 0 * 2 , 
function read Yaml File ( file , cb ) { fs . read File ( file , 'utf 8 ' , ( err , data ) = > { if ( err ) throw err ; cb ( yaml . safe Load ( data ) ) ; } ) ; } 
function write Yaml File ( file , data , cb ) { fs . write File ( file , yaml . safe Dump ( data ) , ( ) = > { if ( cb ) cb ( ) ; } ) ; } 
function build Script ( file , dest ) { var bundler = browserify ( { entries : [ file ] , cache : { } , package Cache : { } } , watchify . args ) , src File = file . substring ( file . last Index Of ( ' / ' ) + 1 ) ; if ( environment ! = = 'production ' ) { bundler = watchify ( bundler ) ; bundler . on ( 'update ' , function ( ) { rebundle ( ) ; } ) ; } function rebundle ( ) { gutil . log ( 'Running rebundle ' ) ; return bundler . bundle ( ) . on ( 'error ' , gutil . log . bind ( gutil , 'Browserify Error ' ) ) . pipe ( source ( src File ) ) . pipe ( buffer ( ) ) . pipe ( production Only ( uglify ) ) . pipe ( gulp . dest ( dest ) ) . pipe ( development Only ( browser Sync . reload , { stream : true } ) ) ; } return rebundle ( ) ; } 
function middleware ( file , options ) { var matcher = new Reg Exp ( " \ \ . ( ? : " + middleware . extensions . join ( " | " ) + " ) $ " ) if ( ! matcher . test ( file ) ) return through ( ) ; var input = ' ' ; var write = function ( buffer ) { input + = buffer ; } var end = function ( ) { this . queue ( create Module ( input , options ) ) ; this . queue ( null ) ; } return through ( write , end ) ; } 
function create Module ( body , options ) { body = middleware . sanitize ( body ) if ( String ( options . parameterize ) ! = = 'false ' ) { body = middleware . parameterise ( body ) } if ( options . module = = = "es 6 " | | options . module = = = "es 2 0 1 5 " ) { var module = 'export default ' + body + ' ; \n ' ; } else { var module = 'module .exports = ' + body + ' ; \n ' ; } return module } 
function ( schema , definition ) { return _ . reduce ( schema , function ( memo , field ) { / / console .log ( 'definition normalize ' ) ;console .log (definition ) ; / / Marshal mysql DESCRIBE to waterline collection semantics var attr Name = field . COLUMN _NAME . to Lower Case ( ) ; Object . keys ( definition ) . for Each ( function ( key ) { if ( attr Name = = = key . to Lower Case ( ) ) attr Name = key ; } ) ; var type = field . DATA _TYPE ; / / Remove (n ) column -size indicators type = type . replace ( / \ ( [ 0 - 9 ] + \ ) $ / , ' ' ) ; memo [ attr Name ] = { type : type / / defaults To : ' ' , / /auto Increment : field .Extra = = = 'auto _increment ' } ; if ( field . primary Key ) { memo [ attr Name ] . primary Key = field . primary Key ; } if ( field . unique ) { memo [ attr Name ] . unique = field . unique ; } if ( field . indexed ) { memo [ attr Name ] . indexed = field . indexed ; } return memo ; } , { } ) ; } 
function ( collection Name , values , key ) { return sql . build ( collection Name , values , sql . prepare Value , ' , ' , key ) ; } 
function ( collection Name , where , key , parent Key ) { return sql . build ( collection Name , where , sql . predicate , ' AND ' , undefined , parent Key ) ; } 
function ( collection Name , criterion , key , parent Key ) { var query Part = ' ' ; if ( parent Key ) { return sql . prepare Criterion ( collection Name , criterion , key , parent Key ) ; } / / OR if ( key . to Lower Case ( ) = = = 'or ' ) { query Part = sql . build ( collection Name , criterion , sql . where , ' OR ' ) ; return ' ( ' + query Part + ' ) ' ; } / / AND else if ( key . to Lower Case ( ) = = = 'and ' ) { query Part = sql . build ( collection Name , criterion , sql . where , ' AND ' ) ; return ' ( ' + query Part + ' ) ' ; } / / IN else if ( _ . is Array ( criterion ) ) { query Part = sql . prepare Attribute ( collection Name , null , key ) + " IN ( " + sql . values ( collection Name , criterion , key ) + " ) " ; return query Part ; } / / LIKE else if ( key . to Lower Case ( ) = = = 'like ' ) { return sql . build ( collection Name , criterion , function ( collection Name , value , attr Name ) { var attr Str = sql . prepare Attribute ( collection Name , value , attr Name ) ; attr Str = attr Str . replace ( / ' / g , ' " ' ) ; / / TODO : Handle regexp criterias if ( _ . is Reg Exp ( value ) ) { throw new Error ( 'Reg Exp LIKE criterias not supported by the My SQLAdapter yet . Please contribute @ http : / /github .com /balderdashy /sails -mysql ' ) ; } var value Str = sql . prepare Value ( collection Name , value , attr Name ) ; / / Handle escaped percent ( % ) signs [encoded as % % % ] value Str = value Str . replace ( / % % % / g , ' \ \ % ' ) ; var condition = ( attr Str + " LIKE " + value Str ) ; / /condition = condition .replace ( / ' /g , ' " ' ) ; return condition ; } , ' AND ' ) ; } / / NOT else if ( key . to Lower Case ( ) = = = 'not ' ) { throw new Error ( 'NOT not supported yet ! ' ) ; } / / Basic criteria item else { return sql . prepare Criterion ( collection Name , criterion , key ) ; } } 
function ( collection Name , collection , fn , separator , key Override , parent Key ) { separator = separator | | ' , ' ; var $sql = ' ' ; _ . each ( collection , function ( value , key ) { $sql + = fn ( collection Name , value , key Override | | key , parent Key ) ; / / (always append separator ) $sql + = separator ; } ) ; / / (then remove final one ) return _ . str . rtrim ( $sql , separator ) ; } 
function sql Type Cast ( type , attr Name ) { type = type & & type . to Lower Case ( ) ; switch ( type ) { case 'string ' : return 'VARCHAR 2 ( 2 5 5 ) ' ; case 'text ' : case 'array ' : case 'json ' : return 'VARCHAR 2 ( 2 5 5 ) ' ; case 'boolean ' : return 'NUMBER ( 1 ) CHECK ( " ' + attr Name + ' " IN ( 0 , 1 ) ) ' ; case 'int ' : case 'integer ' : return 'NUMBER ' ; case 'float ' : case 'double ' : return 'FLOAT ' ; case 'date ' : return 'DATE ' ; case 'datetime ' : return 'TIMESTAMP ' ; case 'binary ' : return 'BLOB ' ; default : console . error ( "Unregistered type given : " + type ) ; return "TEXT " ; } } 
function valid Sub Attr Criteria ( c ) { return _ . is Object ( c ) & & ( ! _ . is Undefined ( c . not ) | | ! _ . is Undefined ( c . greater Than ) | | ! _ . is Undefined ( c . less Than ) | | ! _ . is Undefined ( c . greater Than Or Equal ) | | ! _ . is Undefined ( c . less Than Or Equal ) | | ! _ . is Undefined ( c [ ' < ' ] ) | | ! _ . is Undefined ( c [ ' < = ' ] ) | | ! _ . is Undefined ( c [ ' ! ' ] ) | | ! _ . is Undefined ( c [ ' > ' ] ) | | ! _ . is Undefined ( c [ ' > = ' ] ) | | ! _ . is Undefined ( c . starts With ) | | ! _ . is Undefined ( c . ends With ) | | ! _ . is Undefined ( c . contains ) | | ! _ . is Undefined ( c . like ) ) ; } 
function process Icon Template ( src File , dest File , data , cb ) { fs . read File ( src File , 'utf 8 ' , ( err , src File Contents ) = > { if ( err ) throw err ; const result = template ( src File Contents , { 
function icons ( done ) { const stream = gulp . src ( config . src ) . pipe ( iconfont ( { font Name : config . icon Name , append Uniconde : true , formats : config . formats , timestamp : config . use Timestamp ? get Timestamp ( ) : 0 , autohint : config . autohint , normalize : config . normalize , } ) ) ; 
function is Safe Method ( method , safe Methods ) { method = method . to Upper Case ( ) ; return ( safe Methods | | SAFE _METHODS ) . some ( function ( safe Method ) { return method . to Upper Case ( ) = = = safe Method ; } ) ; } 
function inject Data ( token Value , options , key ) { var data ; if ( ~ options . content Type . index Of ( 'application /json ' ) ) { data = options . data ? JSON . parse ( options . data ) : { } ; data [ key ] = token Value ; options . data = JSON . stringify ( data ) ; } else { options . data + = options . data ? ' & ' : ' ' ; options . data + = key + ' = ' + token Value ; } } 
function inject Query ( token Value , options , param ) { options . url + = ~ options . url . index Of ( ' ? ' ) ? ' & ' : ' ? ' ; options . url + = param + ' = ' + token Value ; } 
function homedir ( username ) { return username ? path . resolve ( path . dirname ( home ) , username ) : home ; } 
function ( connection , collections , cb ) { if ( LOG _DEBUG ) { console . log ( "BEGIN register Connection " ) ; } 
function ( conn , cb ) { if ( LOG _DEBUG ) { console . log ( "BEGIN tear Down " ) ; } if ( typeof conn = = 'function ' ) { cb = conn ; conn = null ; } if ( ! conn ) { connections = { } ; return cb ( ) ; } if ( ! connections [ conn ] ) return cb ( ) ; delete connections [ conn ] ; cb ( ) ; } 
function ( connection Name , table , query , data , cb ) { var connection Object = connections [ connection Name ] ; if ( LOG _DEBUG ) { console . log ( "BEGIN query " ) ; } if ( _ . is Function ( data ) ) { cb = data ; data = null ; } 
function ( connection Name , table , cb ) { if ( LOG _DEBUG ) { console . log ( "BEGIN describe " ) ; } var connection Object = connections [ connection Name ] ; var collection = connection Object . collections [ table ] ; if ( ! collection ) { return cb ( util . format ( 'Unknown collection ` %s ` in connection ` %s ` ' , collection Name , connection Name ) ) ; } var queries = [ ] ; queries [ 0 ] = "SELECT COLUMN _NAME , DATA _TYPE , NULLABLE FROM USER _TAB _COLUMNS WHERE TABLE _NAME = ' " + table + " ' " ; queries [ 1 ] = "SELECT index _name ,COLUMN _NAME FROM user _ind _columns WHERE table _name = ' " + table + " ' " ; queries [ 2 ] = "SELECT cols .table _name , cols .column _name , cols .position , cons .status , cons .owner " + "FROM all _constraints cons , all _cons _columns cols WHERE cols .table _name = ' " + table + " ' AND cons .constraint _type = 'P ' AND cons .constraint _name = cols .constraint _name AND cons .owner = cols .owner " + "ORDER BY cols .table _name , cols .position " ; 
function drop Table ( item , next ) { 
function ( connection Name , table , attr Name , attr Def , cb ) { var connection Object = connections [ connection Name ] ; if ( LOG _DEBUG ) { console . log ( "BEGIN add Attribute " ) ; } 
function ( collection Name , criteria , _cb ) { return adapter . find ( connection Name , collection Name , criteria , _cb , pool ) ; } 
function ( connection Name , table , options , cb ) { if ( LOG _DEBUG ) { console . log ( 'BEGIN find ' ) ; } 
function ( connection Name , table , data , cb ) { if ( LOG _DEBUG ) { console . log ( "BEGIN create " ) ; } var connection Object = connections [ connection Name ] ; var collection = connection Object . collections [ table ] ; var schema Name = collection . meta & & collection . meta . schema Name ? utils . escape Name ( collection . meta . schema Name ) + ' . ' : ' ' ; var table Name = schema Name + utils . escape Name ( table ) ; 
function ( connection Name , table , options , cb ) { if ( LOG _DEBUG ) { console . log ( "BEGIN count " ) ; } 
function ( connection Name , table , options , data , cb ) { if ( LOG _DEBUG ) { console . log ( "BEGIN update " ) ; } 
function ( connection Name , table , options , cb ) { if ( LOG _DEBUG ) { console . log ( "BEGIN destroy " ) ; } var connection Object = connections [ connection Name ] ; var collection = connection Object . collections [ table ] ; var _schema = connection Object . schema ; 
function _get PK ( connection Name , collection Name ) { var collection Definition ; try { collection Definition = connections [ connection Name ] . collections [ collection Name ] . definition ; var pk ; pk = _ . find ( Object . keys ( collection Definition ) , function _find PK ( key ) { var attr Def = collection Definition [ key ] ; if ( attr Def & & attr Def . primary Key ) return key ; else return false ; } ) ; if ( ! pk ) pk = 'id ' ; return pk ; } catch ( e ) { throw new Error ( 'Unable to determine primary key for collection ` ' + collection Name + ' ` because ' + 'an error was encountered acquiring the collection definition : \n ' + require ( 'util ' ) . inspect ( e , false , null ) ) ; } } 
function pl Build ( done , error Should Exit ) { core . events . emit ( 'pattern -lab :precompile ' ) ; 
function get Twig Namespace Config ( working Dir ) { working Dir = working Dir | | process . cwd ( ) ; 
function is Release Finished ( ) : boolean { const current Branch = exec ( 'git rev -parse - -abbrev -ref HEAD ' , { silent : true } ) . stdout . trim ( ) return process . env . CIRCLECI & & process . env . CIRCLE _BRANCH ! = current Branch } 
function print Error ( message ) { arrayify ( message ) . for Each ( function ( msg ) { console . error ( ansi . format ( msg , 'red ' ) ) } ) } 
function print Output ( message ) { process . stdout . on ( 'error ' , err = > { if ( err . code = = = 'EPIPE ' ) { } } ) arrayify ( message ) . for Each ( function ( msg ) { console . log ( ansi . format ( msg ) ) } ) } 
function halt ( err , options ) { options = Object . assign ( { exit Code : 1 } , options ) if ( err ) { if ( err . code = = = 'EPIPE ' ) { process . exit ( 0 ) } else { const t = require ( 'typical ' ) print Error ( t . is String ( err ) ? err : options . stack ? err . stack : err . message , options ) } } process . exit ( options . exit Code ) } 
function get Cli ( definitions , usage Sections , argv ) { const command Line Args = require ( 'command -line -args ' ) const command Line Usage = require ( 'command -line -usage ' ) const usage = usage Sections ? command Line Usage ( usage Sections ) : ' ' const options = command Line Args ( definitions , argv ) return { options , usage } } 
function Composite Error ( message , inner Errors ) { this . message = message ; this . name = 'Composite Error ' ; this . inner Errors = normalize Inner Errors ( inner Errors ) ; Error . capture Stack Trace ( this , this . constructor ) ; this . original Stack Descriptor = Object . get Own Property Descriptor ( this , 'stack ' ) ; 
function get Bmp Bin ( ) : string { const cwd = new Working Directory ( ) . resolve ( ) if ( fs . exists Sync ( cwd + ' / .yangpao .toml ' ) ) { return which ( 'yangpao ' ) } if ( fs . exists Sync ( cwd + ' / .bmp .yml ' ) ) { return which ( 'bmp ' ) } } 
function handle Request ( req , res ) { var self = this ; var config = self . app . config ; 
function is Required ( _ref ) { var validate = _ref . validate , required = _ref . required ; return required | | validate & & validate . some ( function ( item ) { return item . trigger ! = = "submit " & & item . required ; } ) ; } 
function slice Data ( data , page , length ) { return data . slice ( ( page - 1 ) * length , page * length ) ; } 
function get Match Data ( value , match Case , data , strict ) { var output = [ ] ; value = match Case ? value : ( ' ' + value ) . to Lower Case ( ) ; for ( var i = 0 ; i < data . length ; i + + ) { var item = data [ i ] ; var label = match Case ? item . label : ( ' ' + item . label ) . to Lower Case ( ) ; if ( ! strict & & ~ label . index Of ( value ) ) { output . push ( ( 0 , _util . extend ) ( { } , item ) ) ; } else if ( strict & & label = = = value ) { output . push ( ( 0 , _util . extend ) ( { } , item ) ) ; } } return output ; } 
function kill Posix ( ) { get Descendent Process Info ( this . pid , ( err , descendent ) = > { if ( err ) { return } descendent . for Each ( ( { PID : pid } ) = > { try { process . kill ( pid ) } catch ( _err ) { 
function o ( obj ) { obj . source = { text : text ( ) , line : line ( ) , column : column ( ) } return obj ; } 
function Tree Walker ( ast , recv ) { var self = this ; this . ast = ast ; this . recv = recv ; this . stack = [ { traverse : ast , parent : undefined , name : undefined } , { fun : function ( ) { if ( self . has Prop ( self . recv , 'finished ' ) & & Function = = = self . recv . finished . constructor ) { return self . recv . finished ( ) ; } } } ] ; this . current = undefined ; } 
function _shell Escape ( params , options = { } ) { let escaped = [ _ _shell Escape ( params , options ) ] let flattened = _ . flatten Deep ( escaped ) return flattened . join ( ' ' ) } 
function _ _shell Escape ( params , options ) { if ( params instanceof Escaped ) { return params . value } else if ( Array . is Array ( params ) ) { return params . map ( param = > _ _shell Escape ( param , options ) ) } else if ( params = = null ) { return [ ] } else { return options . verbatim ? String ( params ) : shell Escape ( String ( params ) ) } } 
function shell ( strings , . . . params ) { let result = ' ' for ( let [ string , param ] of _ . zip ( strings , params ) ) { result + = string + _shell Escape ( param ) } return result } 
function ( ) { self . log ( "enumerate " ) ; var result = [ ] , keys , i , name , desc ; stm . record Read ( self ) ; keys = handler . get Property Names ( ) ; for ( i = 0 ; i < keys . length ; i + = 1 ) { name = keys [ i ] ; desc = handler . get Property Descriptor ( name ) ; if ( undefined ! = = desc & & desc . enumerable ) { result . push ( name ) ; } } return result ; } 
function ( obj , meta ) { var val , parent Id ; if ( undefined = = = obj | | util . is Primitive ( obj ) ) { return { proxied : obj , raw : obj } ; } val = this . proxied To TVar . get ( obj ) ; if ( undefined = = = val ) { val = this . obj To TVar . get ( obj ) ; if ( undefined = = = val ) { this . t Var Count + = 1 ; val = new TVar ( this . t Var Count , obj , this ) ; this . proxied To TVar . set ( val . proxied , val ) ; this . obj To TVar . set ( obj , val ) ; this . id To TVar [ val . id ] = val ; this . record Creation ( val , meta ) ; return val ; } else { 
function Contract Factory ( config ) { _class Call Check ( this , Contract Factory ) ; this . _config = config ; this . _web 3 = config . web 3 ; this . _account = config . account ; this . _gas = config . gas ; } 
function Contract ( config ) { _class Call Check ( this , Contract ) ; this . _config = config ; this . _web 3 = config . web 3 ; this . _bytecode = config . contract . bytecode ; this . _interface = JSON . parse ( config . contract . interface ) ; this . _contract = this . _web 3 . eth . contract ( this . _interface ) ; this . _account = config . account ; this . _gas = config . gas ; this . _logger = DUMMY _LOGGER ; } 
function Contract Instance ( config ) { _class Call Check ( this , Contract Instance ) ; this . _config = config ; this . _contract = config . contract ; this . _web 3 = this . _contract . _web 3 ; this . _address = config . address ; this . _inst = this . contract . _contract . at ( this . _address ) ; this . _logger = { } ; for ( var log Method in DUMMY _LOGGER ) { this . _logger [ log Method ] = function ( log Method , self ) { return function ( ) { self . contract . logger [ log Method ] . apply ( self . contract . logger , [ ' [ ' + self . address + ' ] : ' ] . concat ( Array . from ( arguments ) ) ) ; } ; } ( log Method , this ) ; } } 
function Transaction ( config ) { _class Call Check ( this , Transaction ) ; this . _web 3 = config . parent . _web 3 ; this . _logger = config . parent . _logger ; this . _hash = config . hash ; } 
function get Valid Regex ( pattern ) { var escaped = ( 0 , _escape Regexp 2 . default ) ( pattern ) ; var _iterator Normal Completion = true ; var _did Iterator Error = false ; var _iterator Error = undefined ; try { for ( var _iterator = filters [ Symbol . iterator ] ( ) , _step ; ! ( _iterator Normal Completion = ( _step = _iterator . next ( ) ) . done ) ; _iterator Normal Completion = true ) { var data = _step . value ; var rxp = new Reg Exp ( " \ \ \ \ \ \ [ " + data [ 0 ] + " \ \ \ \ : [A -Za -z ] { 0 , } ? \ \ \ \ ] " , "g " ) ; if ( rxp . exec ( escaped ) ) { escaped = escaped . replace ( rxp , data [ 1 ] ) ; } } } catch ( err ) { _did Iterator Error = true ; _iterator Error = err ; } finally { try { if ( ! _iterator Normal Completion & & _iterator . return ) { _iterator . return ( ) ; } } finally { if ( _did Iterator Error ) { throw _iterator Error ; } } } return new Reg Exp ( " ^ " + escaped + " $ " , "g " ) ; } 
function get Named Props ( pattern ) { var regex = / \ [ ( \w + ) : ( \w + ) ? ] / g ; var props = [ ] ; var i = 0 ; pattern . replace ( regex , function ( ) { props . push ( ( arguments . length < = 2 ? undefined : arguments [ 2 ] ) | | i + + ) ; return " " ; } ) ; return props ; } 
function spawn Command With Kill ( . . . args ) { const child = spawn Command ( . . . args ) child . kill = kill . bind ( child ) return child } 
function apply Format ( method , args , string ) { 
function access Object ( obj , string ) { var m , pos = 0 ; while ( ( m = string . substring ( pos ) . match ( access Exp ) ) ) { 
function Format Error ( func , msg , value ) { this . name = 'Format Error ' ; this . message = new Formatter ( ) ( msg , value ) ; if ( Error . capture Stack Trace ) { Error . capture Stack Trace ( this , func ) ; } } 
function choose Data Source ( data Source ) { if ( data Source = = = 'json ' ) { return function ( file ) { return JSON . parse ( file . contents . to String ( ) ) ; } ; } else if ( data Source = = = 'vinyl ' ) { return function ( file ) { file [ body Attribute ] = file . contents . to String ( ) ; return file ; } ; } else if ( data Source = = = 'data ' ) { return function ( file ) { var data = file . data ; data [ body Attribute ] = file . contents . to String ( ) ; return data ; } ; } else if ( typeof data Source = = = 'function ' ) { return data Source ; } else { throw plugin Error ( 'Unknown data Source ' ) ; } } 
function templates From Stream ( template Stream ) { var first Template = null ; template Stream . on ( 'data ' , function ( file ) { var relpath = file . relative ; var deferred ; if ( registry . has Own Property ( relpath ) ) { deferred = registry [ relpath ] ; } else { deferred = registry [ relpath ] = new Deferred ( ) ; } try { if ( ! file . is Buffer ( ) ) { throw plugin Error ( 'Template source must be buffer ' ) ; } var template = compile ( { data : file . contents . to String ( ) , name : file . path , path : file . path } ) ; deferred . resolve ( template ) ; if ( first Template = = = null ) { first Template = template ; } else { first Template = false ; the Only Template . reject ( plugin Error ( 'Multiple templates given , must select one ' ) ) ; } } catch ( err ) { deferred . reject ( err ) ; } } ) . on ( 'end ' , function ( ) { if ( first Template ) the Only Template . resolve ( first Template ) ; else the Only Template . reject ( plugin Error ( 'No templates in template stream ' ) ) ; no More Templates ( ) ; } ) . on ( 'error ' , function ( err ) { template Stream Error = err ; no More Templates ( ) ; } ) ; } 
function no More Templates ( ) { registry Complete = true ; 
function template From File ( path ) { 
function process File ( file , cb ) { var data = data Source ( file ) ; return pick Template ( forced Template Name | | get Template Name ( data ) | | default Template Name ) . then ( function ( template ) { file . path = replace Ext ( file . path , ' .html ' ) ; data . _file = file ; data . _target = { path : file . path , relative : replace Ext ( file . relative , ' .html ' ) , } ; 
function pick Template ( template Name ) { if ( template Name = = = THE _ONLY _TEMPLATE ) return the Only Template . promise ; if ( registry . has Own Property ( template Name ) ) return registry [ template Name ] . promise ; if ( registry Complete ) throw no Such Template ( template Name ) ; return ( registry [ template Name ] = new Deferred ( ) ) . promise ; } 
function get Template Name ( data ) { for ( var i = 0 ; i < template Attribute . length ; + + i ) { if ( ! data ) return null ; data = data [ template Attribute [ i ] ] ; } return data ; } 
function escapeshellarg ( arg ) { 
function table Data Sort ( key , data , direction ) { var data Copy = data . map ( function ( i ) { return Object . assign ( { } , i ) ; } ) ; data Copy . sort ( function ( a , b ) { var sort Result ; var a Tmp = a [ key ] ; var b Tmp = b [ key ] ; if ( typeof a Tmp = = = 'number ' & & typeof b Tmp = = = 'number ' ) { sort Result = sort ( a Tmp , b Tmp ) ; } else { sort Result = sort ( ( a Tmp + ' ' ) . to Lower Case ( ) , ( b Tmp + ' ' ) . to Lower Case ( ) ) ; } return sort Result * direction ; } ) ; return data Copy ; } 
function mod ( x , by ) { return ( x > 0 ) ? x % by : ( by - ( Math . abs ( x ) % by ) ) % by } 
function change Group ( num ) { if ( num = = = cur Group ) return console . log ( 'switching groups to ' , num ) groups [ cur Group ] . for Each ( function ( window ) { X . Unmap Window ( { window : window } ) } ) cur Group = num groups [ cur Group ] . for Each ( function ( window ) { X . Map Window ( { window : window } ) } ) size Windows ( ) } 
function label ( ) { var self = this ; return this . execute ( function ( ) { var id = this . get Attribute ( 'id ' ) ; var label = document . query Selector ( 'label [for = " ' + id + ' " ] ' ) | | closest Label ( this ) ; return label ? label . text Content . trim ( ) : null ; } ) . then ( function ( text ) { if ( text = = = null ) { throw new Error ( self . to String ( ) + ' does not have a label ' ) ; } return text ; } ) ; } 
function ( _this , count , as UTC ) { if ( _this instanceof Date ) { var date = $ _NAME ( _this , count , as UTC ) return _this . set Time ( + date ) } throw new Type Error ( 'Method Date .prototype .add ' + ( as UTC ? 'UTC ' : ' ' ) + 'Months called on incompatible receiver ' + _this ) } 
function deep Set ( obj , path ) { var value = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : null ; var define = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : ! 1 ; if ( ! ( 0 , _object . is Object ) ( obj ) ) throw new Type Error ( 'Deepget is only supported for objects ' ) ; var parts = interpolate Path ( path ) ; 
function deep Get ( obj , path ) { var get _parent = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : ! 1 ; if ( ! ( 0 , _object . is Object ) ( obj ) ) throw new Type Error ( 'Deepget is only supported for objects ' ) ; var parts = interpolate Path ( path ) ; 
function update _stats ( data ) { var timenow = parse Int ( new Date ( ) . get Time ( ) / 1 0 0 0 ) ; for ( var v in data ) { switch ( config . output _format ) { case 'console ' : console . log ( [ [ os . hostname ( ) , v ] . join ( ' . ' ) , data [ v ] , timenow ] . join ( ' ' ) ) ; break ; case 'graphite ' : console . log ( [ [ os . hostname ( ) , v ] . join ( ' . ' ) , data [ v ] , timenow ] . join ( ' ' ) ) ; break ; case 'rrd -simple ' : var off = timenow % 6 0 ; timenow = ( off < = 3 0 ) ? timenow - off : timenow + ( 6 0 - off ) ; var data = [ [ timenow , v ] . join ( ' . ' ) , data [ v ] ] . join ( ' ' ) ; var http = require ( 'http ' ) ; var opts = { host : config . rrdsimple . host , port : config . rrdsimple . port , path : config . rrdsimple . path , method : 'POST ' , headers : { 'Content -Type ' : 'application /x -www -form -urlencoded ' , 'Content -Length ' : data . length } } console . log ( ' [ ' + new Date ( ) . to ISOString ( ) + ' ] ' + [ timenow , v ] . join ( ' . ' ) + ' - > ' + opts [ 'host ' ] ) ; var req = http . request ( opts , function ( res ) { 
function ( ) { var args = Array . prototype . slice . apply ( arguments ) ; var message = args [ 0 ] ; var rpc Callback Handler = function ( ) { } ; 
function to Percentage ( val ) { var precision = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 0 ; var min = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : 0 ; var max = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : 1 ; if ( ! is Number ( val ) | | is Numerical Na N ( val ) ) { throw new Type Error ( 'Value should be numeric ' ) ; } if ( ! is Number ( min ) | | is Numerical Na N ( min ) ) { throw new Type Error ( 'Value should be numeric ' ) ; } if ( ! is Number ( max ) | | is Numerical Na N ( max ) ) { throw new Type Error ( 'Value should be numeric ' ) ; } return round ( ( val - min ) / ( max - min ) * 1 0 0 , precision ) ; } 
function round ( val ) { var precision = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 0 ; if ( ! is Number ( val ) | | is Numerical Na N ( val ) ) { throw new Type Error ( 'Value should be numeric ' ) ; } if ( precision = = = ! 1 | | precision < 1 ) { return Math . round ( val ) ; } var exp = Math . pow ( 1 0 , Math . round ( precision ) ) ; return Math . round ( val * exp ) / exp ; } 
function random Between ( ) { var min = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : 0 ; var max = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 1 0 ; if ( ! is Number ( min ) | | is Numerical Na N ( min ) ) { throw new Type Error ( 'Min should be numeric ' ) ; } if ( ! is Number ( max ) | | is Numerical Na N ( max ) ) { throw new Type Error ( 'Max should be numeric ' ) ; } return Math . random ( ) * max + min ; } 
function expensive Operation ( input ) { return new Promise ( ( resolve , reject ) = > { set Timeout ( ( ) = > { const output = 'result ' cache . write ( input , output ) resolve ( output ) } , 3 0 0 0 ) } ) } 
function Flow ( limit ) { this . limit = limit ; Object . define Property ( this , "future Stack _ " , { enumerable : false , writable : true , value : [ ] } ) ; Object . define Property ( this , "running Num _ " , { enumerable : false , writable : true , value : 0 } ) ; } 
function Future ( f , args ) { var self = this ; function run ( ) { args [ args . length ] = function cb ( ) { switch ( arguments . length ) { case 0 : self . result = null ; break ; case 1 : if ( arguments [ 0 ] instanceof Error ) { self . err = arguments [ 0 ] ; } else { self . result = arguments [ 0 ] ; } break ; default : self . err = arguments [ 0 ] ; if ( arguments . length = = = 2 ) { self . result = arguments [ 1 ] ; } else { self . result = Array . prototype . slice . call ( arguments , 1 ) ; } break ; } if ( self . flow _ ) self . flow _ . future Finished ( ) ; var caller = self . caller ; if ( caller ) caller . run ( ) ; } ; args . length + + ; f . apply ( undefined , args ) ; } this . run = run ; var flow = Fiber . current . flow ; if ( flow ) { Object . define Property ( this , "flow _ " , { enumerable : false , writable : true , value : flow } ) ; flow . register Future ( this ) ; } else { run ( ) ; } } 
function hashish ( ) { var id = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : Math . floor ( Math . random ( ) * 1 0 0 ) ; var n = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : 2 ; var base = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : 3 6 ; return _create Hash ( id , _create Salts ( n , base ) , base ) ; } 
function escape ( html , encode ) { if ( encode ) { if ( escape . escape Test . test ( html ) ) { return html . replace ( escape . escape Replace , function ( ch ) { return escape . replacements [ ch ] ; } ) ; } } else { if ( escape . escape Test No Encode . test ( html ) ) { return html . replace ( escape . escape Replace No Encode , function ( ch ) { return escape . replacements [ ch ] ; } ) ; } } return html ; } 
function rtrim ( str , c , invert ) { if ( str . length = = = 0 ) { return ' ' ; } 
function index Of Match ( string , regex , index ) { const str = index ! = = null ? string . substring ( index ) : string ; const matches = str . match ( regex ) ; return matches ? str . index Of ( matches [ 0 ] ) + index : - 1 ; } 
function last Index Of Match ( string , regex , index ) { const str = index ! = = null ? string . substring ( 0 , index ) : string ; const matches = str . match ( regex ) ; return matches ? str . last Index Of ( matches [ matches . length - 1 ] ) : - 1 ; } 
function split Lines ( string , index ) { const str = index ? string . substring ( index ) : string ; return str . split ( / \r \n | \r | \n / ) ; } 
function inline Handler ( string , selection Range , symbol ) { let new String = string ; const new Selection Range = [ . . . selection Range ] ; 
function block Handler ( string , selection Range , symbol ) { const start = selection Range [ 0 ] ; const end = selection Range [ 1 ] ; const boundary Regex = / [ 0 - 9 ~ * ` _ - ] | \b | \n | $ / gm ; let value ; let line Start = start Of Line ( string , start ) ; let line End = end Of Line ( string , end ) ; 
function list Handler ( string , selection Range , type ) { const start = start Of Line ( string , selection Range [ 0 ] ) ; const end = end Of Line ( string , selection Range [ 1 ] ) ; const lines = split Lines ( string . substring ( start , end ) ) ; const boundary Regex = / [ ~ * ` _ [ ! ] | [a -z A -Z ] | \r | \n | $ / gm ; const new Lines = [ ] ; lines . for Each ( ( line , i ) = > { const symbol = type = = = 'ul ' ? ' - ' : ` $ { i + 1 } ` ; let new Line ; 
function indent Handler ( string , selection Range , type ) { const start = start Of Line ( string , selection Range [ 0 ] ) ; const end = end Of Line ( string , selection Range [ 1 ] ) ; const lines = split Lines ( string . substring ( start , end ) ) ; const new Lines = [ ] ; lines . for Each ( line = > { const four Spaces = ' ' ; let new Line ; if ( type = = = 'out ' ) { new Line = line . index Of ( four Spaces , 0 ) = = = 0 ? line . substring ( four Spaces . length , line . length ) : line . substring ( line . search ( / [ ~ * ` _ [ ! # > - ] | [a -z A -Z 0 - 9 ] | \r | \n | $ / gm ) , line . length ) ; return new Lines . push ( new Line ) ; } new Line = four Spaces + line . substring ( 0 , line . length ) ; return new Lines . push ( new Line ) ; } ) ; const joined = new Lines . join ( ' \r \n ' ) ; const value = string . substring ( 0 , start ) + new Lines . join ( ' \r \n ' ) + string . substring ( end , string . length ) ; return { value , range : [ start , start + joined . replace ( / \n / gm , ' ' ) . length ] } ; } 
function insert Handler ( string , selection Range , snippet ) { const start = selection Range [ 0 ] ; const end = selection Range [ 1 ] ; const value = string . substring ( 0 , start ) + snippet + string . substring ( end , string . length ) ; return { value , range : [ start , start + snippet . length ] } ; } 
function markymark ( container = document . get Elements By Tag Name ( 'marky -mark ' ) ) { if ( container instanceof HTMLElement ) { return initializer ( container ) ; } if ( ! ( container instanceof Array ) & & ! ( container instanceof HTMLCollection ) & & ! ( container instanceof Node List ) ) { throw new Type Error ( 'argument should be an HTMLElement , Array , HTMLCollection ' ) ; } return Array . from ( container ) . map ( initializer ) ; } 
function get PDF ( mu , s 2 ) { var A = 1 / ( Math . sqrt ( s 2 * 2 * Math . PI ) ) , B = - 1 / ( 2 * s 2 ) ; return function pdf ( x ) { var C = x - mu ; return A * Math . exp ( B * C * C ) ; } ; } 
function get CDF ( mu , s 2 ) { var A = 1 / 2 , B = Math . sqrt ( s 2 * 2 ) ; return function cdf ( x ) { var C = x - mu ; return A * ( 1 + erf ( C / B ) ) ; } ; } 
function get Quantile Function ( mu , s 2 ) { var A = mu , B = Math . sqrt ( s 2 * 2 ) ; return function quantile ( x ) { var C = 2 * x - 1 ; return A + B * erfinv ( C ) ; } ; } 
function cdf ( x , sigma ) { if ( x < 0 ) { return 0 ; } var s 2 = pow ( sigma , 2 ) ; return - expm 1 ( - pow ( x , 2 ) / ( 2 * s 2 ) ) ; } 
function to Javascript ( data , merge Into ) { var result = merge Into | | { } var keys = Object . keys ( data ) for ( var i = 0 ; i < keys . length ; i + + ) { var p = keys [ i ] result [ p ] = to Js Value ( data [ p ] ) } return result } 
function to DDB ( data , merge Into ) { var result = merge Into | | { } var keys = Object . keys ( data ) for ( var i = 0 ; i < keys . length ; i + + ) { var p = keys [ i ] result [ p ] = to DDBValue ( data [ p ] ) } return result } 
function clone ( obj ) { var cloned = { } ; for ( var i in obj ) { if ( obj . has Own Property ( i ) ) { cloned [ i ] = obj [ i ] ; } } return cloned ; } 
function deep Clone ( obj ) { if ( obj = = null | | typeof obj ! = = 'object ' ) { return obj ; } var cloned = obj . constructor ( ) ; for ( var key in obj ) { if ( obj . has Own Property ( key ) ) { cloned [ key ] = deep Clone ( obj [ key ] ) ; } } return cloned ; } 
function deep Merge ( one , another ) { if ( another = = null | | typeof another ! = = 'object ' ) { return another ; } if ( one = = null & & typeof another = = = 'object ' ) { if ( Array . is Array ( another ) ) { one = [ ] ; } else { one = { } ; } } var cloned = deep Clone ( another ) ; for ( var key in cloned ) { if ( cloned . has Own Property ( key ) ) { one [ key ] = deep Merge ( one [ key ] , another [ key ] ) ; } } return one ; } 
function ( object ) { if ( is Decorated ( object ) ) { return object ; } if ( Array . is Array ( object ) ) { return new JSONArray ( object ) ; } return new JSONObject ( object ) ; } 
function contents To Display ( req , res , scs Id , sc Id = 0 , cb ) { var zl Site Content In = app . models . zl Site Content In ; var Role = app . models . Role ; var comp Mod = require ( ' . /helpers /component -from -model ' ) ( app ) ; 
function vhost ( hostname , subsite , handle ) { if ( ! hostname ) { throw new Type Error ( 'argument hostname is required ' ) } if ( ! handle ) { throw new Type Error ( 'argument handle is required ' ) } if ( typeof handle ! = = 'function ' ) { throw new Type Error ( 'argument handle must be a function ' ) } 
function vhostof ( req , regexp , subsite ) { var host = req . headers . host var hostname = hostnameof ( req ) if ( ! hostname ) { return } var match = regexp . exec ( hostname ) if ( ! match ) { return } if ( subsite & & 'IS _ROUTE ' ! = subsite & & ! _ . starts With ( req . path , subsite + ' / ' , 1 ) & & ( req . get ( 'X -Base -Url -Path ' ) ! = subsite ) ) { return } var obj = Object . create ( null ) obj . host = host obj . hostname = hostname obj . length = match . length - 1 for ( var i = 1 ; i < match . length ; i + + ) { obj [ i - 1 ] = match [ i ] } return obj } 
function get Packages ( app , cb = null ) { let stdout = ' ' ; const ls = spawn ( 'npm ' , [ 'ls ' , ' - -json ' , ' - -prod ' , ' - -depth = 0 ' , ' - -long ' ] ) ; ls . stdout . on ( 'data ' , data = > { stdout + = data ; } ) ; ls . stderr . on ( 'data ' , data = > { app . error ( ` $ { data } ` ) ; } ) ; ls . on ( 'close ' , ( code ) = > { if ( 0 ! = = code ) app . error ( 'child process exited with code %s ' , code ) ; app . debug ( 'loading installed zealder packages ' ) ; var p = JSON . parse ( stdout ) ; if ( p . dependencies ) { 
function set Packages State ( app , dependencies , cb ) { var zeal Packs = { } ; let promises = [ ] ; _ . for Each ( dependencies , function ( val , key ) { build Packages List ( app , zeal Packs , val , key , promises ) ; } ) ; Promise . all ( promises ) . then ( ( ) = > { app . emit ( 'zealder packages loaded ' ) ; 
function load Models ( app , datasource , src , cb = null ) { const ds = app . data Sources [ datasource ] ; let promises = [ ] , models Names = [ ] ; let files = fs . readdir Sync ( src ) ; if ( files ) { files . for Each ( file = > { * NOTE : UNCOMMENT TO UPDATE DB ON PRODUCTION ALTHOUGH THAT SHOULD BE * AVOIDED BECAUSE IT RECREATE TABLE STRUCTURE AND REMOVES INDEXES , while * TRYING TO REBUILD STRUCTURE /INDEX IT CAN LEAVE SOME OUT ON LARGE DB AND * CREATE OPTIMIZATION NIGHTMARE * / 
function make Entity ( req , res , all , top , data , path = ' ' , promises ) { var Role = app . models . Role ; const { zl Site } = res . locals ; const zs Base Url Path = ( zl Site . zs Base Url Path ) ? ` $ { zl Site . zs Base Url Path } ` : ' / ' _ . for Each ( _ . filter ( all , [ 'scs Parent ' , top ] ) , function ( val ) { val = val . to JSON ( ) ; if ( _ . find ( all , [ 'scs Parent ' , val . scs Id ] ) ) { data = make Entity ( req , res , all , val . scs Id , data , path + val . scs Slug + ' / ' , promises ) ; } let load This Entity = ( ) = > { data [ val . scs Id ] = val ; 
function parse ( attribute ) { if ( _ . is String ( attribute ) ) { if ( attribute . char At ( 0 ) = = = " $ " ) { 
function minify ( page , app Name Map , app Content Map ) { let css Content = ' ' ; let xml Content = fs . read File Sync ( page . wxml , 'utf 8 ' ) ; if ( utils . is File ( page . wxss ) ) { css Content = fs . read File Sync ( page . wxss , 'utf 8 ' ) ; } if ( css Content ) { css Content = new Clean CSS ( { keep Breaks : true } ) . minify ( css Content ) . styles ; css Content = css Content . replace ( / : : ? (after |before |first \ -child |last \ -child ) / g , ' : $ 1 ' ) ; } 
function get User App Roles ( app , usr Id , uro For , uro For Id , cb ) { var zl User Role = app . models . zl User Role ; let filter = { where : { usr Id : usr Id , uro For : uro For , uro For Id : uro For Id } } ; zl User Role . find One ( filter , ( err , data ) = > { if ( data & & data . uro Roles ) { let all Roles = build All Roles ( [ ] , data . uro Roles ) ; cb ( all Roles ) ; } else if ( 'Network ' ! = = uro For ) { 
function build All Roles ( all , roles ) { all . push ( . . . roles ) ; _ . for Each ( roles , function ( role ) { 
function replace String ( from , str , prefix , ignores ) { 
function make Screen Cap ( zs Id , url , req ) { const zl Site = app . models . zl Site ; 
function build List Item ( list , item ) { if ( list & & list . length & & item . _ _k ! = = undefined ) { for ( let t of list ) { if ( t . _ _k ! = = undefined & & t . _ _k = = = item . _ _k ) { return Object . assign ( { } , t , item ) ; } } } return item ; } 
function curry ( fn ) { return function resolver ( ) { for ( var _len = arguments . length , resolver Args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { resolver Args [ _key ] = arguments [ _key ] ; } return function ( ) { for ( var _len 2 = arguments . length , args = Array ( _len 2 ) , _key 2 = 0 ; _key 2 < _len 2 ; _key 2 + + ) { args [ _key 2 ] = arguments [ _key 2 ] ; } var next Args = resolver Args . concat ( args . length ? args : null ) ; var next = next Args . length > = fn . length ? fn : resolver ; return next . apply ( undefined , to Consumable Array ( next Args ) ) ; } ; } ( ) ; } 
function reset Local Or Reset UTC ( increment , date , utc ) { var _increment Handlers ; var increment Handlers = ( _increment Handlers = { } , define Property ( _increment Handlers , SECOND , function ( date ) { return new Date ( date [ 'set ' + utc + 'Seconds ' ] ( date [ 'get ' + utc + 'Seconds ' ] ( ) , 0 ) ) ; } ) , define Property ( _increment Handlers , MINUTE , function ( date ) { return new Date ( date [ 'set ' + utc + 'Minutes ' ] ( date [ 'get ' + utc + 'Minutes ' ] ( ) , 0 , 0 ) ) ; } ) , define Property ( _increment Handlers , HOUR , function ( date ) { return new Date ( date [ 'set ' + utc + 'Hours ' ] ( date [ 'get ' + utc + 'Hours ' ] ( ) , 0 , 0 , 0 ) ) ; } ) , define Property ( _increment Handlers , DATE , function ( date ) { date [ 'set ' + utc + 'Date ' ] ( date [ 'get ' + utc + 'Date ' ] ( ) ) ; date [ 'set ' + utc + 'Hours ' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , define Property ( _increment Handlers , WEEK , function ( date ) { date [ 'set ' + utc + 'Date ' ] ( date [ 'get ' + utc + 'Date ' ] ( ) - date [ 'get ' + utc + 'Day ' ] ( ) ) ; date [ 'set ' + utc + 'Hours ' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , define Property ( _increment Handlers , MONTH , function ( date ) { date [ 'set ' + utc + 'Month ' ] ( date [ 'get ' + utc + 'Month ' ] ( ) , 1 ) ; date [ 'set ' + utc + 'Hours ' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , define Property ( _increment Handlers , YEAR , function ( date ) { date [ 'set ' + utc + 'Full Year ' ] ( date [ 'get ' + utc + 'Full Year ' ] ( ) , 0 , 1 ) ; date [ 'set ' + utc + 'Hours ' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , _increment Handlers ) ; return increment Handlers [ increment ] ( date ) ; } 
function set Local Or Set UTC ( increment , value , date ) { var _increment Handlers ; var utc = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : ' ' ; var increment Handlers = ( _increment Handlers = { } , define Property ( _increment Handlers , MILLISECOND , function ( date ) { return new Date ( date [ 'set ' + utc + 'Milliseconds ' ] ( value ) ) ; } ) , define Property ( _increment Handlers , SECOND , function ( date ) { return new Date ( date [ 'set ' + utc + 'Seconds ' ] ( value ) ) ; } ) , define Property ( _increment Handlers , MINUTE , function ( date ) { return new Date ( date [ 'set ' + utc + 'Minutes ' ] ( value ) ) ; } ) , define Property ( _increment Handlers , HOUR , function ( date ) { return new Date ( date [ 'set ' + utc + 'Hours ' ] ( value ) ) ; } ) , define Property ( _increment Handlers , DATE , function ( date ) { return new Date ( date [ 'set ' + utc + 'Date ' ] ( value ) ) ; } ) , define Property ( _increment Handlers , DAY , function ( date ) { return new Date ( date [ 'set ' + utc + 'Date ' ] ( date [ 'get ' + utc + 'Date ' ] ( ) - date [ 'get ' + utc + 'Day ' ] ( ) + ( value - 1 ) ) ) ; } ) , define Property ( _increment Handlers , WEEK , function ( date ) { var current Day = date [ 'get ' + utc + 'Day ' ] ( ) ; var current Milliseconds = date [ 'get ' + utc + 'Milliseconds ' ] ( ) ; date [ 'set ' + utc + 'Full Year ' ] ( date [ 'get ' + utc + 'Full Year ' ] ( ) , 0 , value * 7 ) ; var n = current Day - date [ 'get ' + utc + 'Day ' ] ( ) ; date [ 'set ' + utc + 'Date ' ] ( date [ 'get ' + utc + 'Date ' ] ( ) + n ) ; return new Date ( date [ 'set ' + utc + 'Milliseconds ' ] ( current Milliseconds ) ) ; } ) , define Property ( _increment Handlers , MONTH , function ( date ) { var new Month = value - 1 ; var new Year = date [ 'get ' + utc + 'Full Year ' ] ( ) ; var new Date = date [ 'get ' + utc + 'Date ' ] ( ) ; var shift Month = new Date ( date [ 'set ' + utc + 'Full Year ' ] ( new Year , new Month + 1 , 0 ) ) ; if ( new Date > shift Month [ 'get ' + utc + 'Date ' ] ( ) ) { return shift Month ; } else { return new Date ( date [ 'set ' + utc + 'Full Year ' ] ( new Year , new Month , new Date ) ) ; } } ) , define Property ( _increment Handlers , YEAR , function ( date ) { var new Year = value ; var new Month = date [ 'get ' + utc + 'Month ' ] ( ) ; var new Date = date [ 'get ' + utc + 'Date ' ] ( ) ; var shift Month = new Date ( date [ 'set ' + utc + 'Full Year ' ] ( new Year , new Month + 1 , 0 ) ) ; if ( new Date > shift Month [ 'get ' + utc + 'Date ' ] ( ) ) { return shift Month ; } else { return new Date ( date [ 'set ' + utc + 'Full Year ' ] ( new Year , new Month , new Date ) ) ; } } ) , _increment Handlers ) ; return increment Handlers [ increment ] ( date ) ; } 
function get Local Or Get UTC ( increment , date ) { var _increment Handlers ; var utc = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : ' ' ; var increment Handlers = ( _increment Handlers = { } , define Property ( _increment Handlers , TIMEZONE _OFFSET , function ( date ) { return utc ? 0 : date . get Timezone Offset ( ) / 6 0 * - 1 ; } ) , define Property ( _increment Handlers , MILLISECOND , function ( date ) { return date [ 'get ' + utc + 'Milliseconds ' ] ( ) ; } ) , define Property ( _increment Handlers , SECOND , function ( date ) { return date [ 'get ' + utc + 'Seconds ' ] ( ) ; } ) , define Property ( _increment Handlers , MINUTE , function ( date ) { return date [ 'get ' + utc + 'Minutes ' ] ( ) ; } ) , define Property ( _increment Handlers , HOUR , function ( date ) { return date [ 'get ' + utc + 'Hours ' ] ( ) ; } ) , define Property ( _increment Handlers , DATE , function ( date ) { return date [ 'get ' + utc + 'Date ' ] ( ) ; } ) , define Property ( _increment Handlers , DAY , function ( date ) { return date [ 'get ' + utc + 'Day ' ] ( ) + 1 ; } ) , define Property ( _increment Handlers , WEEK , function ( date ) { return Math . floor ( ( ( date - new Date ( date [ 'get ' + utc + 'Full Year ' ] ( ) , 0 , 1 ) ) / 1 0 0 0 / 6 0 / 6 0 / 2 4 + 1 ) / 7 ) ; } ) , define Property ( _increment Handlers , MONTH , function ( date ) { return date [ 'get ' + utc + 'Month ' ] ( ) + 1 ; } ) , define Property ( _increment Handlers , YEAR , function ( date ) { return date [ 'get ' + utc + 'Full Year ' ] ( ) ; } ) , _increment Handlers ) ; return increment Handlers [ increment ] ( date ) ; } 
function diff It ( increment , date 1 , date 2 ) { var _increment Handlers ; var increment Handlers = ( _increment Handlers = { } , define Property ( _increment Handlers , MILLISECOND , function ( date 1 , date 2 ) { return diff ( date 1 , date 2 ) ; } ) , define Property ( _increment Handlers , SECOND , function ( date 1 , date 2 ) { return diff ( date 1 , date 2 ) / 1 0 0 0 ; } ) , define Property ( _increment Handlers , MINUTE , function ( date 1 , date 2 ) { return this [ SECOND ] ( date 1 , date 2 ) / 6 0 ; } ) , define Property ( _increment Handlers , HOUR , function ( date 1 , date 2 ) { return this [ MINUTE ] ( date 1 , date 2 ) / 6 0 ; } ) , define Property ( _increment Handlers , DATE , function ( date 1 , date 2 ) { return this [ HOUR ] ( date 1 , date 2 ) / 2 4 ; } ) , define Property ( _increment Handlers , WEEK , function ( date 1 , date 2 ) { return this [ DATE ] ( date 1 , date 2 ) / 7 ; } ) , define Property ( _increment Handlers , MONTH , function ( date 1 , date 2 ) { return this [ DATE ] ( date 1 , date 2 ) / 3 0 . 4 4 ; 
function hinter ( fspec , opt _options ) { return gulp . src ( fspec ) . pipe ( ignorer . exclude ( excludes ) ) . pipe ( jshint ( opt _options ) ) . pipe ( jshint . reporter ( stylish ) ) ; } 
function get Inherit Theme ( theme , tree = { } ) { if ( ! app . locals . themes [ theme ] ) { 
function cache ( app ) { if ( app . locals . config . cache Db & & 'redis ' = = = app . locals . config . cache Db . connector ) { 
function ( ) { if ( 3 = = arguments . length ) { 
function ( ) { if ( 4 = = arguments . length ) { 
function ( ) { if ( 4 = = arguments . length ) { 
function ( ) { if ( 3 = = arguments . length ) { 
function bypass ( req , conditions = { files : 1 , api : 1 } ) { if ( conditions . files ) { 
function auth Ctx ( req , res ) { let ctx = { access Token : null , remoting Context : { req : req , res : res } } 
function mail Common ( type , data , req , res ) { const { zl Site } = res . locals ; if ( 'form -notice ' = = = type ) { if ( data . text ) { data . text + = ` \n $ { req . cookies . referer } \n \n ` + ` ` + ` \n \n ` + ` $ { req . ip } \n $ { req . get ( 'Referrer ' ) } \n \n ` + ` $ { process . env . ZEAL _NETWORK _NAME } ` + ` ` } } 
function recaptcha Verify ( req , res , action = 'form _submit ' , cb , token = ' ' , threshold = 0 . 3 ) { const { zl Site } = res . locals ; if ( zl Site . user ) { 
function start Watching ( watch _folder , dest _folder ) { var watch = require ( 'watch ' ) ; watch . watch Tree ( watch _folder , function ( f , curr , prev ) { if ( typeof f = = "object " & & prev = = = null & & curr = = = null ) { 
function copy File From ( file , to _dir ) { var sys = require ( "sys " ) ; var fs = require ( 'fs ' ) ; var file _name = filename From Path ( file ) ; if ( file _name = = " .DS _Store " ) { return ; } sys . pump ( fs . create Read Stream ( file ) , fs . create Write Stream ( to _dir ) , function ( ) { console . log ( "Copied file : " + file ) ; console . log ( "To new destination : " + to _dir + " \n " ) ; } ) ; } 
function real Destination Path ( file , from _dir , to _dir ) { var length = from _dir . length ; var from _dir _path = file . substring ( length , file . length ) ; return to _dir + from _dir _path ; } 
function remove File At Path ( file , to _dir ) { var fs = require ( 'fs ' ) ; var file _name = filename From Path ( file ) ; var file _at _dest _dir = to _dir + file _name ; fs . unlink ( file _at _dest _dir ) ; console . log ( "Removed file at directory : " + file _at _dest _dir ) ; } 
function Class ( ctor ) { if ( is ( 'Object ' , ctor ) ) { 
function base ( args , ctor ) { var plain = false ; 
function clas ( ) { 
function size It ( grid Size , size Ele , size Screen = 'xs ' ) { 
function _get Outer Size ( grid Size , size Screen ) { if ( 'lg ' = = = size Screen ) { if ( grid Size & & grid Size . lg ) { return grid Size . lg ; } else if ( grid Size & & grid Size . md ) { return grid Size . md ; } else if ( grid Size & & grid Size . sm ) { return grid Size . sm ; } else if ( grid Size & & grid Size . xs ) { return grid Size . xs ; } } else if ( 'md ' = = = size Screen ) { if ( grid Size & & grid Size . md ) { return grid Size . md ; } else if ( grid Size & & grid Size . sm ) { return grid Size . sm ; } else if ( grid Size & & grid Size . xs ) { return grid Size . xs ; } } else if ( 'sm ' = = = size Screen ) { if ( grid Size & & grid Size . sm ) { return grid Size . sm ; } else if ( grid Size & & grid Size . xs ) { return grid Size . xs ; } } else if ( 'xs ' = = = size Screen ) { if ( grid Size & & grid Size . xs ) { return grid Size . xs ; } } 
function Recursive Concat ( options ) { this . concat = null ; this . current Count Directories = 0 ; this . current Count Files = 0 ; this . current Folder = null ; this . new File Generated = null ; this . new Final File = " " ; this . options = options ; this . walk Counter = 0 ; this . stream = new Transform ( { object Mode : true } ) ; this . stream . _transform = function ( chunk , encoding , callback ) { var full Path = null , file = { } , relative = chunk . relative ; file . base = chunk . base ; file . contents = chunk . contents ; file . extname = Path . extname ( relative ) ; file . basename = Path . basename ( relative , file . extname ) ; file . dirname = Path . dirname ( relative ) ; file . new Dirname = utils . fix Dir Name ( file . dirname ) ; full Path = file . new Dirname + file . basename + file . extname ; file . path = Path . join ( chunk . base , full Path ) ; if ( ! file . relative ) { file . relative = relative ; } callback ( null , self . walk ( file ) ) ; } ; var self = this ; return this . stream ; } 
function get Theme App ( ) { let map State To Props = ( state ) = > { return { pages : state . pages , zl Site : state . zl Site , theme Data : state . theme Data , loaded Components , get Component , page : state . pages [ state . current Page ] } ; } 
function get Theme Page ( component , scs Id ) { let map State To Props = ( state ) = > { let page = state . pages [ scs Id ] ; let zs Default Content = state . zl Site . zs Default Content ; let gtags = state . zl Site . gtags ; const { is Fetching , last Updated , contents } = state . pages [ scs Id ] | | { is Fetching : true , contents : [ ] } let content List ; if ( Array . is Array ( contents ) & & contents . length > 0 ) { content List = [ ] ; contents . for Each ( function ( sc Id ) { content List . push ( state . site Contents [ sc Id ] ) ; } ) ; } return { page , content List , zs Default Content , is Fetching , last Updated , get Component , gtags } ; } 
function create Color ( color , alpha ) { return alpha > = 1 ? color : Color ( color ) . alpha ( alpha ) . hsl ( ) . string ( ) ; } 
function get Color ( name , props ) { const t = get Theme Or Default ( 'colors ' , props ) ; if ( props & & props . inverted ) { const inverted Name = ` $ { name } ` ; if ( inverted Name in t ) { const alpha Name = ` $ { inverted Name } ` ; return create Color ( t [ inverted Name ] , t [ alpha Name ] | | 1 ) ; } } if ( name in t ) { const alpha Name = ` $ { name } ` ; return create Color ( t [ name ] , t [ alpha Name ] | | 1 ) ; } return ' # 0 0 0 0 0 0 ' ; } 
function protect _roles ( app , config , prefix ) { for ( var path in config ) { init _debug ( "Protecting path : " + prefix + path ) ; var allow = true ; if ( config [ path ] . action = = = "deny " ) allow = false ; init _debug ( "Allow : " + allow ) ; for ( var method in config [ path ] ) { init _debug ( "Protecting method : " + method ) ; if ( method ! = "action " ) { var config _array = config [ path ] [ method ] ; app [ method ] ( prefix + path , ( function ( allow , conf ) { return function ( req , resp , next ) { running _debug ( "config roles : " + conf ) ; running _debug ( "req roles : " + req . user . roles . to String ( ) ) ; var active _roles = _ . intersection ( conf , req . user . roles ) ; running _debug ( "active roles : " + active _roles ) ; if ( active _roles . length > 0 ) { running _debug ( "active roles > 0 " ) ; if ( allow ) { running _debug ( "path allowed " ) ; req . user . authorized _roles = _ . union ( req . user . authorized _roles , active _roles ) ; } else { running _debug ( "path not allowed " ) ; req . user . authorized _roles = _ . difference ( req . user . authorized _roles , active _roles ) ; } } next ( ) ; } ; } ) ( allow , config _array ) ) ; } } } } 
function check _role _authorization ( req , res , next ) { if ( ! req . has Own Property ( "user " ) | | ! req . user . has Own Property ( 'authorized _roles ' ) | | ! ( req . user . authorized _roles instanceof Array ) | | req . user . authorized _roles . length = = = 0 ) { running _debug ( "Unhautorized : Invalid role or path not configured " ) ; var err = new Error ( "Unhautorized : Invalid role or path not configured " ) ; err . status = 4 0 1 ; return next ( err ) ; } running _debug ( "Authorized roles : " + req . user . authorized _roles ) ; return next ( ) ; } 
function In Sicht ( ) { var options = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : { } ; _class Call Check ( this , In Sicht ) ; this . options = Object . assign ( { } , defaults , options ) ; this . init ( ) ; } 
function webpack Dev ( app ) { var { config } = app . locals ; 
function user From Token ( req , cb ) { const { access Token } = req ; app . models . zl User . find By Id ( access Token . user Id , ( err , usr ) = > { if ( ! err & & usr ) { cb ( null , usr ) ; } else cb ( err ) ; } ) ; } 
function render ( raw Code , id Pre ) { var code Arr = { } ; 
function load Pages ( req , res , next ) { const { zl Site } = res . locals ; 
function ( key , value , keep ) { 
function ( key , storage Type ) { 
function ( key , storage Type ) { var is Storage Type = typeof storage Type = = = 'undefined ' ? false : true ; if ( is Storage Type ) { web Storage = $window [ storage Type ] ; web Storage . remove Item ( key ) ; } else { web Storage = $window . session Storage ; web Storage . remove Item ( key ) ; web Storage = $window . local Storage ; web Storage . remove Item ( key ) ; } return true ; } 
function ( storage Type ) { var is Storage Type = typeof storage Type = = = 'undefined ' ? false : true ; var key , keys = [ ] ; if ( is Storage Type ) { web Storage = $window [ storage Type ] ; for ( key in web Storage ) { keys . push ( key ) ; } } else { web Storage = $window . local Storage ; for ( key in web Storage ) { keys . push ( key ) ; } web Storage = $window . session Storage ; for ( key in web Storage ) { if ( keys . index Of ( key ) = = - 1 ) keys . push ( key ) ; } } return keys ; } 
function ( storage Type ) { var is Storage Type = typeof storage Type = = = 'undefined ' ? false : true , key ; if ( is Storage Type ) { web Storage = $window [ storage Type ] ; for ( key in web Storage ) remove From Storage ( key , storage Type ) ; } else { web Storage = $window . session Storage ; for ( key in web Storage ) remove From Storage ( key , 'session Storage ' ) ; web Storage = $window . local Storage ; for ( key in web Storage ) remove From Storage ( key , 'local Storage ' ) ; } return true ; } 
function Trip Case ( options ) { if ( ! options | | ! options . email | | ! options . password ) throw 'Missing required options ' ; this . email = options . email ; this . password = options . password ; this . session = null ; return this ; } 
function ready Bundle Conf ( app , wp Config , mod Incl , comp Dict , sass Path , app Bundled , wp Entry , type , key , pack , packages Ver ) { app . debug ( 'preparing bundle for %s ' , key ) ; make available to a framework /lib such as bootstrap * / sass Path . push ( ` $ { pack . path } $ { pack . zealder Config . sass Path } ` ) ; } if ( ! app Bundled & & pack . zealder Config . client Render File & & pack . zealder Config . server Render File & & 'theme ' = = type ) { 
function ready Bundle ( app , zl Site , theme , resolve = ( ) = > { } , cb ) { var { apps , themes , cache , get Inherit Theme , default Theme , config } = app . locals ; var content Path , bundl Theme ; if ( zl Site ) { 
function load Assets ( req , res , next ) { var { zl Site , socket Query , app Styles } = res . locals ; const { config , re CAPTCHAkey } = req . app . locals ; 
function trmv ( A , x , is Lower ) { var dot = blas 1 . dot ; var n = A . shape [ 1 ] ; var i = 0 ; if ( is Lower ) { for ( i = n - 1 ; i > = 0 ; i - - ) { x . set ( i , dot ( A . pick ( i , null ) . hi ( i + 1 ) , x . hi ( i + 1 ) ) ) ; } } else { for ( i = 0 ; i < n ; i + + ) { x . set ( i , dot ( A . pick ( i , null ) . lo ( i ) , x . lo ( i ) ) ) ; } } return true ; } 
function ( ) { this . TYPE = { TAG : 'tag ' , USER : 'user ' } this . url Rules = { tag : { rule : / ( (https ? ) : \ / \ / ) ? (www \ . ) ?instagram .com \ /explore \ /tags \ / ( [ \w _ ] + ) / mi } , user : { rule : / ( (https ? ) : \ / \ / ) ? (www \ . ) ?instagram \ .com \ / ( [ \w . _ ] + ) \ / ? / mi } } } 
function fetch Data ( url , type , conf , cb ) { let for Url ; switch ( type ) { case 'categories ' : for Url = ` $ { url } ` ; break ; case 'post ' : 
function get Local Or Get UTC ( increment , date , utc = ' ' ) { const increment Handlers = { [ TIMEZONE _OFFSET ] ( date ) { return utc ? 0 : date . get Timezone Offset ( ) / 6 0 * - 1 ; } , [ MILLISECOND ] ( date ) { return date [ ` $ { utc } ` ] ( ) ; } , [ SECOND ] ( date ) { return date [ ` $ { utc } ` ] ( ) ; } , [ MINUTE ] ( date ) { return date [ ` $ { utc } ` ] ( ) ; } , [ HOUR ] ( date ) { return date [ ` $ { utc } ` ] ( ) ; } , [ DATE ] ( date ) { return date [ ` $ { utc } ` ] ( ) ; } , [ DAY ] ( date ) { return date [ ` $ { utc } ` ] ( ) + 1 ; } , [ WEEK ] ( date ) { return Math . floor ( ( ( date - new Date ( date [ ` $ { utc } ` ] ( ) , 0 , 1 ) ) / 1 0 0 0 / 6 0 / 6 0 / 2 4 + 1 ) / 7 , ) ; } , [ MONTH ] ( date ) { return date [ ` $ { utc } ` ] ( ) + 1 ; } , [ YEAR ] ( date ) { return date [ ` $ { utc } ` ] ( ) ; } , } ; return increment Handlers [ increment ] ( date ) ; } 
function site Apps Admin ( req , res , cb ) { var { theme Data } = res . locals ; const { apps , get Inherit Theme , themes } = req . app . locals ; if ( ! theme Data . managing Site ) cb ( ) ; else { 
function sanitize ( str ) { const symbol Map = { ' \ ' ' : ' \ \textquotesingle { } ' , ' " ' : ' \ \textquotedbl { } ' , ' ` ' : ' \ \textasciigrave { } ' , ' ^ ' : ' \ \textasciicircum { } ' , ' ~ ' : ' \ \textasciitilde { } ' , ' < ' : ' \ \textless { } ' , ' > ' : ' \ \textgreater { } ' , ' | ' : ' \ \textbar { } ' , ' \ \ ' : ' \ \textbackslash { } ' , ' { ' : ' \ \ { ' , ' } ' : ' \ \ } ' , ' $ ' : ' \ \ $ ' , ' & ' : ' \ \ & ' , ' # ' : ' \ \ # ' , ' _ ' : ' \ \ _ ' , ' % ' : ' \ \ % ' } return Array . from ( str ) . map ( char = > symbol Map [ char ] | | char ) . join ( ' ' ) } 
function execute ( target , prop , . . . args ) { return _ . is Function ( target [ prop ] ) ? target [ prop ] ( . . . args ) : target [ prop ] ; } 
function token To Cookie ( req , res , next ) { if ( req . signed Cookies . authorization ! = = req . access Token . id ) { let opt = _cookie Opt ( req , res ) ; res . cookie ( 'authorization ' , req . access Token . id , opt ) ; } next ( ) ; } 
function token Query Remove ( req , res , next ) { if ( req . query & & req . query . access _token & & ! req . app . locals . bypass ( req ) ) { 
function load Usr Info ( token , app , zl Site , next ) { app . models . zl User . find By Id ( token . user Id , ( err , usr ) = > { if ( err ) next ( err ) ; else if ( usr ) { zl Site . user = _ . clone Deep ( usr ) ; if ( ! zl Site . user . usr Photo & & zl Site . user . email ) { 
function add Time Or Subtract Time ( increment , n , date ) { const increment Handlers = { [ MILLISECOND ] ( date ) { return new Date ( date . set UTCMilliseconds ( date . get UTCMilliseconds ( ) + n ) ) ; } , [ SECOND ] ( date ) { return new Date ( date . set UTCSeconds ( date . get UTCSeconds ( ) + n ) ) ; } , [ MINUTE ] ( date ) { return new Date ( date . set UTCMinutes ( date . get UTCMinutes ( ) + n ) ) ; } , [ HOUR ] ( date ) { return new Date ( date . set UTCHours ( date . get UTCHours ( ) + n ) ) ; } , [ DATE ] ( date ) { return new Date ( date . set UTCDate ( date . get UTCDate ( ) + n ) ) ; } , [ WEEK ] ( date ) { return new Date ( date . set UTCDate ( date . get UTCDate ( ) + n * 7 ) ) ; } , [ MONTH ] ( date ) { let new Month = date . get UTCMonth ( ) + n ; let new Year = date . get UTCFull Year ( ) ; let new Date = date . get UTCDate ( ) ; if ( new Date > new Date ( date . set UTCFull Year ( new Year , new Month + 1 , 0 ) ) . get UTCDate ( ) ) { return new Date ( date . set UTCFull Year ( new Year , new Month + 1 , 0 ) ) ; } return new Date ( date . set UTCFull Year ( new Year , new Month , new Date ) ) ; } , [ YEAR ] ( date ) { let new Year = date . get UTCFull Year ( ) + n ; let new Month = date . get UTCMonth ( ) ; let new Date = date . get UTCDate ( ) ; if ( new Date > new Date ( date . set UTCFull Year ( new Year , new Month + 1 , 0 ) ) . get UTCDate ( ) ) { return new Date ( date . set UTCFull Year ( new Year , new Month + 1 , 0 ) ) ; } return new Date ( date . set UTCFull Year ( new Year , new Month , new Date ) ) ; } , } ; return increment Handlers [ increment ] ( date ) ; } 
function meta Data ( req , res , next ) { var zl Site = res . locals . zl Site ; 
function trsv ( A , x , is Lower ) { var dot = blas 1 . dot ; var n = A . shape [ 1 ] ; var i = 0 ; if ( is Lower ) { x . set ( 0 , x . get ( 0 ) / A . get ( 0 , 0 ) ) ; for ( i = 1 ; i < n ; i + + ) { x . set ( i , ( x . get ( i ) - dot ( A . pick ( i , null ) . hi ( i ) , x . hi ( i ) ) ) / A . get ( i , i ) ) ; } } else { x . set ( n - 1 , x . get ( n - 1 ) / A . get ( n - 1 , n - 1 ) ) ; for ( i = n - 2 ; i > = 0 ; i - - ) { x . set ( i , ( x . get ( i ) - dot ( A . pick ( i , null ) . lo ( i + 1 ) , x . lo ( i + 1 ) ) ) / A . get ( i , i ) ) ; } } return true ; } 
function ( sc Content ) { if ( _ . is Empty ( sc Content [ 'data ' ] ) ) { return ; } let columns = [ ] ; if ( sc Content [ 'columns ' ] ) { 
function ( model Data , sc Content ) { if ( sc Content [ 'tree Data ' ] ) { 
function ( res , sc Content , embed In ) { this . app = app ; this . res = res ; const self = this ; let fields = [ ] ; if ( sc Content [ 'fields ' ] ) { 
function ( res , sc Content , post , cb ) { let model = this . _model Info ( sc Content [ 'for Model ' ] ) ; 
function ( for Model ) { let model = { model : app . models [ for Model ] , prop : app . models [ for Model ] . definition . properties , settings : app . models [ for Model ] . settings , meta : app . models [ for Model ] . settings . zl Meta , ns : ' ' } ; if ( model . meta & & model . meta [ 'Namespace ' ] ) { model . ns = model . meta [ 'Namespace ' ] ; } return model ; } 
function ( mod Meth , filter , cb = ( err , val , cb ) = > cb ( ) ) { this . promises . push ( new Promise ( ( resolve , reject ) = > { mod Meth ( . . . filter , ( err , val ) = > { cb ( err , val , resolve ) ; } ) ; } ) ) ; } 
function _embed Getter ( self , fields , embed Getter , key ) { let all Opts = [ ] ; self . res . locals . emiter . emit ( 'get -options ' , embed Getter , all Opts ) ; if ( all Opts ) { all Opts . for Each ( function ( obj ) { obj . embed In = key ; } ) ; fields . push ( . . . all Opts ) ; } } 
function get Auth Sites ( req , res , next ) { const zl User Role = req . app . models . zl User Role ; const zl Site = req . app . models . zl Site ; let { theme Data , socket Query , emiter } = res . locals ; theme Data [ 'auth Sites ' ] = { } , theme Data [ 'managing Site ' ] = null ; socket Query [ 'auth Sites ' ] = [ ] ; let filter = { where : { "usr Id " : req . access Token . user Id , "uro For " : 'Site ' } } zl User Role . find ( filter , ( err , data ) = > { if ( err ) req . app . error ( err ) ; if ( data ) { let promises = [ ] ; _ . for Each ( data , function ( val ) { val = val . to JSON ( ) ; promises . push ( new Promise ( ( resolve , reject ) = > { 
function should Fetch Contents ( state , scs Id ) { const page = state . pages [ scs Id ] ; if ( page . contents . length = = = 0 ) { return true } else if ( page . is Fetching ) { return false } else { return page . did Invalidate } } 
function build ( app ) { console . log ( 'Building Zealder bundles . . . ' ) ; let promises = [ ] ; 
function bundle Server ( app , promises ) { var { themes , config } = app . locals ; 
function server Render ( req , res , next ) { var app = req . app ; var { themes , default Theme } = app . locals ; var { zl Site } = res . locals ; if ( ! zl Site | | ! themes [ zl Site . zs Theme ] ) return next ( ) ; 
function ( active , suppress Event ) { if ( this . active ! = active ) { this . active = active ; if ( suppress Event ! = = true ) { this . fire Event ( active ? 'activate ' : 'deactivate ' , this ) ; } } } 
function is Initialize Method ( node ) { var expression = node . expression ; return expression . type = = = 'Assignment Expression ' & & expression . left . type = = = 'Member Expression ' & & expression . left . object . name = = = 'my ' & & expression . left . property . name = = = 'initialize ' ; } 
function ( dataview ) { this . dataview = dataview ; dataview . mon ( dataview , { beforecontainerclick : this . cancel Click , scope : this , render : { fn : this . on Render , scope : this , single : true } } ) ; } 
function hmac Sign ( input , algorithm , secret ) { return crypto . create Hmac ( algorithm , secret ) . update ( input ) . digest ( 'base 6 4 ' ) } 
function rsa Sign ( input , algorithm , private Secret ) { try { 
function sign ( input , algorithm , secret ) { const alg = algorithm Map [ algorithm ] if ( ! alg ) { throw new Error ( error Map [ ' 0 0 2 ' ] . message ) } const type = type Map [ algorithm ] let signature switch ( type ) { case 'hmac ' : signature = hmac Sign ( input , alg , secret ) break case 'sign ' : signature = rsa Sign ( input , alg , secret ) break default : signature = hmac Sign ( input , alg , secret ) break } return signature } 
function hmac Verify ( input , algorithm , secret , signature ) { try { const verify = signature = = = hmac Sign ( input , algorithm , secret ) if ( ! verify ) { error Map [ ' 0 0 6 ' ] . message = 'Unvalid secret for hmac verify , signature verification failed ' error Map [ ' 0 0 6 ' ] . error = new Error ( error Map [ ' 0 0 6 ' ] . message ) } return verify } catch ( e ) { error Map [ ' 0 0 6 ' ] . message = 'Exception error in hamc verify , signature verification failed ' error Map [ ' 0 0 6 ' ] . error = e return false } } 
function rsa Verify ( input , algorithm , public Secret , signature ) { try { 
function verify ( input , algorithm , secret , signature ) { const alg = algorithm Map [ algorithm ] if ( ! alg ) { error Map [ ' 0 0 6 ' ] . message = 'Algorithm not recognized , signature verification failed ' error Map [ ' 0 0 6 ' ] . message = new Error ( error Map [ ' 0 0 6 ' ] . message ) return false } const type = type Map [ algorithm ] switch ( type ) { case 'hmac ' : return hmac Verify ( input , alg , secret , signature ) case 'sign ' : return rsa Verify ( input , alg , secret , signature ) default : return hmac Verify ( input , alg , secret , signature ) } } 
function ( data ) { if ( data . blocks ) delete data . blocks if ( ! controllers Count & & request . page ) { callback ( null , { code : 4 0 4 } ) return ; } data . request = request me . server . tpl ( me . tpls [ data . tpl ] . tpl , data , function ( code ) { callback ( code ) ; } , request . locale ) } 
function ( data ) { for ( var i = 1 ; i < = me . tpls [ data . tpl ] . blocks ; i + + ) { data [ 'BLOCK _ ' + i ] = [ ] } 
function register Collection ( identifier , collection , model ) { this . registered Models And Collections [ identifier ] = { collection Class : collection , model Class : model } ; } 
function find Registered Identifier ( model Or Collection ) { var found Key ; for ( var key in this . registered Models And Collections ) { var registered Model Or Collection = this . registered Models And Collections [ key ] ; if ( model Or Collection . constructor = = = registered Model Or Collection ) { found Key = key ; break ; } else { if ( _ . has ( registered Model Or Collection , 'collection Class ' ) & & model Or Collection . constructor = = = registered Model Or Collection . collection Class ) { found Key = key ; break ; } } } return found Key ; } 
function get Type ( v ) { var result = ' ' ; if ( v = = null ) { result = v + ' ' ; } else { result = typeof v ; if ( result = = 'object ' | | result = = 'function ' ) { result = illa . class By Type [ illa . class By Type . to String . call ( v ) ] | | 'object ' ; } } return result ; } 
function bind Unsafe ( fn , obj ) { var args = [ ] ; for ( var _i = 2 ; _i < arguments . length ; _i + + ) { args [ _i - 2 ] = arguments [ _i ] ; } return illa . bind . call ( this , arguments ) ; } 
function uuid ( ) { var base = 'xxxxxxxx -xxxx - 4xxx -yxxx -xxxxxxxxxxxx ' ; var result = base . replace ( / [xy ] / g , function ( char ) { var random = crypto Random 1 6 ( ) ; var result = char = = 'x ' ? random : ( random & 0x 3 | 0x 8 ) ; return result . to String ( 1 6 ) ; } ) ; return result ; } 
function add Props ( obj ) { var rest = [ ] ; for ( var _i = 1 ; _i < arguments . length ; _i + + ) { rest [ _i - 1 ] = arguments [ _i ] ; } for ( var i = 0 , n = rest . length ; i < n ; i + = 2 ) { if ( illa . is String ( rest [ i ] ) ) { obj [ rest [ i ] ] = rest [ i + 1 ] ; } } return obj ; } 
function ( ) { var me = this ; me . add Events ( 'click ' ) ; 
function ( ) { var me = this , attr ; me . call Parent ( arguments ) ; me . el . on ( { click : me . on Click , mousedown : me . on Mouse Down , mouseover : me . on Mouse Over , mouseout : me . on Mouse Out , scope : me } ) ; if ( me . tooltip ) { if ( Ext . quick Tips Active & & Ext . is Object ( me . tooltip ) ) { Ext . tip . Quick Tip Manager . register ( Ext . apply ( { target : me . id } , me . tooltip ) ) ; } else { attr = me . tooltip Type = = 'qtip ' ? 'data -qtip ' : 'title ' ; me . el . dom . set Attribute ( attr , me . tooltip ) ; } } } 
function ( type ) { var me = this , old Type = me . type ; me . type = type ; if ( me . rendered ) { if ( old Type ) { me . tool El . remove Cls ( me . base Cls + ' - ' + old Type ) ; } me . tool El . add Cls ( me . base Cls + ' - ' + type ) ; } else { me . render Data . type = type ; } return me ; } 
function ( ) { if ( Ext . quick Tips Active & & Ext . is Object ( this . tooltip ) ) { Ext . tip . Quick Tip Manager . unregister ( this . id ) ; } this . call Parent ( ) ; } 
function ( ) { var me = this , locked = me . lockable . locked Grid . header Ct . get Columns State ( ) , normal = me . lockable . normal Grid . header Ct . get Columns State ( ) ; return locked . concat ( normal ) ; } 
function next Line ( ) { var at ; if ( line > = lines . length ) { return false ; } character = 1 ; s = lines [ line ] ; line + = 1 ; at = s . search ( / \t / ) ; if ( at > = 0 ) { warning At ( "Mixed spaces and tabs . " , line , at + 1 ) ; } s = s . replace ( / \t / g , tab ) ; at = s . search ( cx ) ; if ( at > = 0 ) { warning At ( "Unsafe character . " , line , at ) ; } if ( option . maxlen & & option . maxlen < s . length ) { warning At ( "Line too long . " , line , s . length ) ; } return true ; } 
function it ( type , value ) { var i , t ; if ( type = = = ' (color ) ' | | type = = = ' (range ) ' ) { t = { type : type } ; } else if ( type = = = ' (punctuator ) ' | | ( type = = = ' (identifier ) ' & & is _own ( syntax , value ) ) ) { t = syntax [ value ] | | syntax [ ' (error ) ' ] ; } else { t = syntax [ type ] ; } t = Object . create ( t ) ; if ( type = = = ' (string ) ' | | type = = = ' (range ) ' ) { if ( jx . test ( value ) ) { warning At ( "Script URL . " , line , from ) ; } } if ( type = = = ' (identifier ) ' ) { t . identifier = true ; if ( value = = = ' _ _iterator _ _ ' | | value = = = ' _ _proto _ _ ' ) { error At ( "Reserved name ' {a } ' . " , line , from , value ) ; } else if ( option . nomen & & ( value . char At ( 0 ) = = = ' _ ' | | value . char At ( value . length - 1 ) = = = ' _ ' ) ) { warning At ( "Unexpected {a } in ' {b } ' . " , line , from , "dangling ' _ ' " , value ) ; } } t . value = value ; t . line = line ; t . character = character ; t . from = from ; i = t . id ; if ( i ! = = ' (endline ) ' ) { prereg = i & & ( ( ' ( , = : [ ! & | ? { } ; ' . index Of ( i . char At ( i . length - 1 ) ) > = 0 ) | | i = = = 'return ' ) ; } return t ; } 
function ( ) { var b , c , captures , d , depth , high , i , l , low , q , t ; function match ( x ) { var r = x . exec ( s ) , r 1 ; if ( r ) { l = r [ 0 ] . length ; r 1 = r [ 1 ] ; c = r 1 . char At ( 0 ) ; s = s . substr ( l ) ; from = character + l - r 1 . length ; character + = l ; return r 1 ; } } function string ( x ) { var c , j , r = ' ' ; if ( jsonmode & & x ! = = ' " ' ) { warning At ( "Strings must use doublequote . " , line , character ) ; } if ( xquote = = = x | | ( xmode = = = 'scriptstring ' & & ! xquote ) ) { return it ( ' (punctuator ) ' , x ) ; } function esc ( n ) { var i = parse Int ( s . substr ( j + 1 , n ) , 1 6 ) ; j + = n ; if ( i > = 3 2 & & i < = 1 2 6 & & i ! = = 3 4 & & i ! = = 9 2 & & i ! = = 3 9 ) { warning At ( "Unnecessary escapement . " , line , character ) ; } character + = n ; c = String . from Char Code ( i ) ; } j = 0 ; for ( ; ; ) { while ( j > = s . length ) { j = 0 ; if ( xmode ! = = 'html ' | | ! next Line ( ) ) { error At ( "Unclosed string . " , line , from ) ; } } c = s . char At ( j ) ; if ( c = = = x ) { character + = 1 ; s = s . substr ( j + 1 ) ; return it ( ' (string ) ' , r , x ) ; } if ( c < ' ' ) { if ( c = = = ' \n ' | | c = = = ' \r ' ) { break ; } warning At ( "Control character in string : {a } . " , line , character + j , s . slice ( 0 , j ) ) ; } else if ( c = = = xquote ) { warning At ( "Bad HTML string " , line , character + j ) ; } else if ( c = = = ' < ' ) { if ( option . safe & & xmode = = = 'html ' ) { warning At ( "ADsafe string violation . " , line , character + j ) ; } else if ( s . char At ( j + 1 ) = = = ' / ' & & ( xmode | | option . safe ) ) { warning At ( "Expected ' < \ \ / ' and instead saw ' < / ' . " , line , character ) ; } else if ( s . char At ( j + 1 ) = = = ' ! ' & & ( xmode | | option . safe ) ) { warning At ( "Unexpected ' < ! ' in a string . " , line , character ) ; } } else if ( c = = = ' \ \ ' ) { if ( xmode = = = 'html ' ) { if ( option . safe ) { warning At ( "ADsafe string violation . " , line , character + j ) ; } } else if ( xmode = = = 'styleproperty ' ) { j + = 1 ; character + = 1 ; c = s . char At ( j ) ; if ( c ! = = x ) { warning At ( "Escapement in style string . " , line , character + j ) ; } } else { j + = 1 ; character + = 1 ; c = s . char At ( j ) ; switch ( c ) { case xquote : warning At ( "Bad HTML string " , line , character + j ) ; break ; case ' \ \ ' : case ' " ' : case ' / ' : break ; case ' \ ' ' : if ( jsonmode ) { warning At ( "Avoid \ \ ' . " , line , character ) ; } break ; case 'b ' : c = ' \b ' ; break ; case 'f ' : c = ' \f ' ; break ; case 'n ' : c = ' \n ' ; break ; case 'r ' : c = ' \r ' ; break ; case 't ' : c = ' \t ' ; break ; case 'u ' : esc ( 4 ) ; break ; case 'v ' : if ( jsonmode ) { warning At ( "Avoid \ \v . " , line , character ) ; } c = ' \v ' ; break ; case 'x ' : if ( jsonmode ) { warning At ( "Avoid \ \x - . " , line , character ) ; } esc ( 2 ) ; break ; default : warning At ( "Bad escapement . " , line , character ) ; } } } r + = c ; character + = 1 ; j + = 1 ; } } for ( ; ; ) { if ( ! s ) { return it ( next Line ( ) ? ' (endline ) ' : ' (end ) ' , ' ' ) ; } while ( xmode = = = 'outer ' ) { i = s . search ( ox ) ; if ( i = = = 0 ) { break ; } else if ( i > 0 ) { character + = 1 ; s = s . slice ( i ) ; break ; } else { if ( ! next Line ( ) ) { return it ( ' (end ) ' , ' ' ) ; } } } t = match ( rx [ xmode ] | | tx ) ; if ( ! t ) { t = ' ' ; c = ' ' ; while ( s & & s < ' ! ' ) { s = s . substr ( 1 ) ; } if ( s ) { if ( xmode = = = 'html ' ) { return it ( ' (error ) ' , s . char At ( 0 ) ) ; } else { error At ( "Unexpected ' {a } ' . " , line , character , s . substr ( 0 , 1 ) ) ; } } } else { / / identifier if ( c . is Alpha ( ) | | c = = = ' _ ' | | c = = = ' $ ' ) { return it ( ' (identifier ) ' , t ) ; } / / number if ( c . is Digit ( ) ) { if ( xmode ! = = 'style ' & & ! is Finite ( Number ( t ) ) ) { warning At ( "Bad number ' {a } ' . " , line , character , t ) ; } if ( xmode ! = = 'style ' & & xmode ! = = 'styleproperty ' & & s . substr ( 0 , 1 ) . is Alpha ( ) ) { warning At ( "Missing space after ' {a } ' . " , line , character , t ) ; } if ( c = = = ' 0 ' ) { d = t . substr ( 1 , 1 ) ; if ( d . is Digit ( ) ) { if ( token . id ! = = ' . ' & & xmode ! = = 'styleproperty ' ) { warning At ( "Don 't use extra leading zeros ' {a } ' . " , line , character , t ) ; } } else if ( jsonmode & & ( d = = = 'x ' | | d = = = 'X ' ) ) { warning At ( "Avoid 0x - . ' {a } ' . " , line , character , t ) ; } } if ( t . substr ( t . length - 1 ) = = = ' . ' ) { warning At ( "A trailing decimal point can be confused with a dot ' {a } ' . " , line , character , t ) ; } return it ( ' (number ) ' , t ) ; } switch ( t ) { / / string case ' " ' : case " ' " : return string ( t ) ; / / / / comment case ' 
function advance ( id , t ) { switch ( token . id ) { case ' (number ) ' : if ( nexttoken . id = = = ' . ' ) { warning ( "A dot following a number can be confused with a decimal point . " , token ) ; } break ; case ' - ' : if ( nexttoken . id = = = ' - ' | | nexttoken . id = = = ' - - ' ) { warning ( "Confusing minusses . " ) ; } break ; case ' + ' : if ( nexttoken . id = = = ' + ' | | nexttoken . id = = = ' + + ' ) { warning ( "Confusing plusses . " ) ; } break ; } if ( token . type = = = ' (string ) ' | | token . identifier ) { anonname = token . value ; } if ( id & & nexttoken . id ! = = id ) { if ( t ) { if ( nexttoken . id = = = ' (end ) ' ) { warning ( "Unmatched ' {a } ' . " , t , t . id ) ; } else { warning ( "Expected ' {a } ' to match ' {b } ' from line {c } and instead saw ' {d } ' . " , nexttoken , id , t . id , t . line , nexttoken . value ) ; } } else if ( nexttoken . type ! = = ' (identifier ) ' | | nexttoken . value ! = = id ) { warning ( "Expected ' {a } ' and instead saw ' {b } ' . " , nexttoken , id , nexttoken . value ) ; } } prevtoken = token ; token = nexttoken ; for ( ; ; ) { nexttoken = lookahead . shift ( ) | | lex . token ( ) ; if ( nexttoken . id = = = ' (end ) ' | | nexttoken . id = = = ' (error ) ' ) { return ; } if ( nexttoken . type = = = 'special ' ) { do Option ( ) ; } else { if ( nexttoken . id ! = = ' (endline ) ' ) { break ; } } } } 
function expression ( rbp , initial ) { var left ; if ( nexttoken . id = = = ' (end ) ' ) { error ( "Unexpected early end of program . " , token ) ; } advance ( ) ; if ( option . safe & & typeof predefined [ token . value ] = = = 'boolean ' & & ( nexttoken . id ! = = ' ( ' & & nexttoken . id ! = = ' . ' ) ) { warning ( 'ADsafe violation . ' , token ) ; } if ( initial ) { anonname = 'anonymous ' ; funct [ ' (verb ) ' ] = token . value ; } if ( initial = = = true & & token . fud ) { left = token . fud ( ) ; } else { if ( token . nud ) { left = token . nud ( ) ; } else { if ( nexttoken . type = = = ' (number ) ' & & token . id = = = ' . ' ) { warning ( "A leading decimal point can be confused with a dot : ' . {a } ' . " , token , nexttoken . value ) ; advance ( ) ; return token ; } else { error ( "Expected an identifier and instead saw ' {a } ' . " , token , token . id ) ; } } while ( rbp < nexttoken . lbp ) { advance ( ) ; if ( token . led ) { left = token . led ( left ) ; } else { error ( "Expected an operator and instead saw ' {a } ' . " , token , token . id ) ; } } } return left ; } 
function adjacent ( left , right ) { left = left | | token ; right = right | | nexttoken ; if ( option . white | | xmode = = = 'styleproperty ' | | xmode = = = 'style ' ) { if ( left . character ! = = right . from & & left . line = = = right . line ) { warning ( "Unexpected space after ' {a } ' . " , right , left . value ) ; } } } 
function optionalidentifier ( fnparam ) { if ( nexttoken . identifier ) { advance ( ) ; if ( option . safe & & banned [ token . value ] ) { warning ( "ADsafe violation : ' {a } ' . " , token , token . value ) ; } else if ( token . reserved & & ! option . es 5 ) { 
function block ( ordinary , stmt ) { var a , b = inblock , old _indent = indent , m = strict _mode , s = scope , t ; inblock = ordinary ; scope = Object . create ( scope ) ; nonadjacent ( token , nexttoken ) ; t = nexttoken ; if ( nexttoken . id = = = ' { ' ) { advance ( ' { ' ) ; if ( nexttoken . id ! = = ' } ' | | token . line ! = = nexttoken . line ) { indent + = option . indent ; while ( ! ordinary & & nexttoken . from > indent ) { indent + = option . indent ; } if ( ! ordinary & & ! use _strict ( ) & & ! m & & option . strict & & funct [ ' (context ) ' ] [ ' (global ) ' ] ) { warning ( "Missing \ "use strict \ " statement . " ) ; } a = statements ( ) ; strict _mode = m ; indent - = option . indent ; indentation ( ) ; } advance ( ' } ' , t ) ; indent = old _indent ; } else if ( ! ordinary ) { error ( "Expected ' {a } ' and instead saw ' {b } ' . " , nexttoken , ' { ' , nexttoken . value ) ; } else { if ( ! stmt | | option . curly ) warning ( "Expected ' {a } ' and instead saw ' {b } ' . " , nexttoken , ' { ' , nexttoken . value ) ; noreach = true ; a = [ statement ( ) ] ; noreach = false ; } funct [ ' (verb ) ' ] = null ; scope = s ; inblock = b ; if ( ordinary & & option . noempty & & ( ! a | | a . length = = = 0 ) ) { warning ( "Empty block . " ) ; } return a ; } 
function do Begin ( n ) { if ( n ! = = 'html ' & & ! option . fragment ) { if ( n = = = 'div ' & & option . adsafe ) { error ( "ADSAFE : Use the fragment option . " ) ; } else { error ( "Expected ' {a } ' and instead saw ' {b } ' . " , token , 'html ' , n ) ; } } if ( option . adsafe ) { if ( n = = = 'html ' ) { error ( "Currently , ADsafe does not operate on whole HTML documents . It operates on <div > fragments and .js files . " , token ) ; } if ( option . fragment ) { if ( n ! = = 'div ' ) { error ( "ADsafe violation : Wrap the widget in a div . " , token ) ; } } else { error ( "Use the fragment option . " , token ) ; } } option . browser = true ; assume ( ) ; } 
function json Value ( ) { function json Object ( ) { var o = { } , t = nexttoken ; advance ( ' { ' ) ; if ( nexttoken . id ! = = ' } ' ) { for ( ; ; ) { if ( nexttoken . id = = = ' (end ) ' ) { error ( "Missing ' } ' to match ' { ' from line {a } . " , nexttoken , t . line ) ; } else if ( nexttoken . id = = = ' } ' ) { warning ( "Unexpected comma . " , token ) ; break ; } else if ( nexttoken . id = = = ' , ' ) { error ( "Unexpected comma . " , nexttoken ) ; } else if ( nexttoken . id ! = = ' (string ) ' ) { warning ( "Expected a string and instead saw {a } . " , nexttoken , nexttoken . value ) ; } if ( o [ nexttoken . value ] = = = true ) { warning ( "Duplicate key ' {a } ' . " , nexttoken , nexttoken . value ) ; } else if ( nexttoken . value = = = ' _ _proto _ _ ' ) { warning ( "Stupid key ' {a } ' . " , nexttoken , nexttoken . value ) ; } else { o [ nexttoken . value ] = true ; } advance ( ) ; advance ( ' : ' ) ; json Value ( ) ; if ( nexttoken . id ! = = ' , ' ) { break ; } advance ( ' , ' ) ; } } advance ( ' } ' ) ; } function json Array ( ) { var t = nexttoken ; advance ( ' [ ' ) ; if ( nexttoken . id ! = = ' ] ' ) { for ( ; ; ) { if ( nexttoken . id = = = ' (end ) ' ) { error ( "Missing ' ] ' to match ' [ ' from line {a } . " , nexttoken , t . line ) ; } else if ( nexttoken . id = = = ' ] ' ) { warning ( "Unexpected comma . " , token ) ; break ; } else if ( nexttoken . id = = = ' , ' ) { error ( "Unexpected comma . " , nexttoken ) ; } json Value ( ) ; if ( nexttoken . id ! = = ' , ' ) { break ; } advance ( ' , ' ) ; } } advance ( ' ] ' ) ; } switch ( nexttoken . id ) { case ' { ' : json Object ( ) ; break ; case ' [ ' : json Array ( ) ; break ; case 'true ' : case 'false ' : case 'null ' : case ' (number ) ' : case ' (string ) ' : advance ( ) ; break ; case ' - ' : advance ( ' - ' ) ; if ( token . character ! = = nexttoken . from ) { warning ( "Unexpected space after ' - ' . " , token ) ; } adjacent ( token , nexttoken ) ; advance ( ' (number ) ' ) ; break ; default : error ( "Expected a JSON value . " , nexttoken ) ; } } 
function ( s , o ) { var a , i , k ; JSHINT . errors = [ ] ; predefined = Object . create ( standard ) ; if ( o ) { a = o . predef ; if ( a ) { if ( Array . is Array ( a ) ) { for ( i = 0 ; i < a . length ; i + = 1 ) { predefined [ a [ i ] ] = true ; } } else if ( typeof a = = = 'object ' ) { k = Object . keys ( a ) ; for ( i = 0 ; i < k . length ; i + = 1 ) { predefined [ k [ i ] ] = ! ! a [ k ] ; } } } if ( o . adsafe ) { o . safe = true ; } if ( o . safe ) { o . browser = o . css = o . debug = o . devel = o . evil = o . forin = o . on = o . rhino = o . windows = o . sub = o . widget = false ; o . eqeqeq = o . nomen = o . safe = o . undef = true ; predefined . Date = predefined [ 'eval ' ] = predefined . Function = predefined . Object = null ; predefined . ADSAFE = predefined . lib = false ; } option = o ; } else { option = { } ; } option . indent = option . indent | | 4 ; option . maxerr = option . maxerr | | 5 0 ; adsafe _id = ' ' ; adsafe _may = false ; adsafe _went = false ; approved = { } ; if ( option . approved ) { for ( i = 0 ; i < option . approved . length ; i + = 1 ) { approved [ option . approved [ i ] ] = option . approved [ i ] ; } } else { approved . test = 'test ' ; } tab = ' ' ; for ( i = 0 ; i < option . indent ; i + = 1 ) { tab + = ' ' ; } indent = 1 ; global = Object . create ( predefined ) ; scope = global ; funct = { ' (global ) ' : true , ' (name ) ' : ' (global ) ' , ' (scope ) ' : scope , ' (breakage ) ' : 0 , ' (loopage ) ' : 0 } ; functions = [ funct ] ; ids = { } ; urls = [ ] ; src = false ; xmode = false ; stack = null ; member = { } ; members Only = null ; implied = { } ; inblock = false ; lookahead = [ ] ; jsonmode = false ; warnings = 0 ; lex . init ( s ) ; prereg = true ; strict _mode = false ; prevtoken = token = nexttoken = syntax [ ' (begin ) ' ] ; assume ( ) ; try { advance ( ) ; if ( nexttoken . value . char At ( 0 ) = = = ' < ' ) { html ( ) ; if ( option . adsafe & & ! adsafe _went ) { warning ( "ADsafe violation : Missing ADSAFE .go . " , this ) ; } } else { switch ( nexttoken . id ) { case ' { ' : case ' [ ' : option . laxbreak = true ; jsonmode = true ; json Value ( ) ; break ; case ' @ ' : case ' * ' : case ' # ' : case ' . ' : case ' : ' : xmode = 'style ' ; advance ( ) ; if ( token . id ! = = ' @ ' | | ! nexttoken . identifier | | nexttoken . value ! = = 'charset ' | | token . line ! = = 1 | | token . from ! = = 1 ) { error ( "A css file should begin with @charset 'UTF - 8 ' ; " ) ; } advance ( ) ; if ( nexttoken . type ! = = ' (string ) ' & & nexttoken . value ! = = 'UTF - 8 ' ) { error ( "A css file should begin with @charset 'UTF - 8 ' ; " ) ; } advance ( ) ; advance ( ' ; ' ) ; styles ( ) ; break ; default : if ( option . adsafe & & option . fragment ) { error ( "Expected ' {a } ' and instead saw ' {b } ' . " , nexttoken , ' <div > ' , nexttoken . value ) ; } if ( nexttoken . value = = = 'use strict ' ) { warning ( "Use the function form of \ "use strict \ " . " ) ; use _strict ( ) ; } statements ( 'lib ' ) ; } } advance ( ' (end ) ' ) ; } catch ( e ) { if ( e ) { JSHINT . errors . push ( { reason : e . message , line : e . line | | nexttoken . line , character : e . character | | nexttoken . from } , null ) ; } } return JSHINT . errors . length = = = 0 ; } 
function Node ( t , init ) { var token = t . token ; if ( token ) { 
function Statements ( t , x , n ) { try { while ( ! t . done & & t . peek ( true ) ! = = RIGHT _CURLY ) n . push ( Statement ( t , x ) ) ; } catch ( e ) { if ( t . done ) t . unexpected EOF = true ; throw e ; } } 
function Statement ( t , x ) { var i , label , n , n 2 , p , c , ss , tt = t . get ( true ) , tt 2 , x 2 , x 3 ; 
function Let Block ( t , x , is Statement ) { var n , n 2 ; * If this is really an expression in let statement guise , then we * need to wrap the LET _BLOCK node in a SEMICOLON node so that we pop * the return value of the expression . * / n 2 = new Node ( t , { type : SEMICOLON , expression : n } ) ; is Statement = false ; } if ( is Statement ) n . block = Block ( t , x ) ; else n . expression = Assign Expression ( t , x ) ; return n ; } 
function Tokenizer ( s , f , l ) { this . cursor = 0 ; this . source = String ( s ) ; this . tokens = [ ] ; this . token Index = 0 ; this . lookahead = 0 ; this . scan Newlines = false ; this . unexpected EOF = false ; this . filename = f | | " " ; this . lineno = l | | 1 ; } 
function ( ) { var input = this . source ; for ( ; ; ) { var ch = input [ this . cursor + + ] ; var next = input [ this . cursor ] ; if ( ch = = = ' \n ' & & ! this . scan Newlines ) { this . lineno + + ; } else if ( ch = = = ' / ' & & next = = = ' * ' ) { this . cursor + + ; for ( ; ; ) { ch = input [ this . cursor + + ] ; if ( ch = = = undefined ) throw this . new Syntax Error ( "Unterminated comment " ) ; if ( ch = = = ' * ' ) { next = input [ this . cursor ] ; if ( next = = = ' / ' ) { this . cursor + + ; break ; } } else if ( ch = = = ' \n ' ) { this . lineno + + ; } } } else if ( ch = = = ' / ' & & next = = = ' / ' ) { this . cursor + + ; for ( ; ; ) { ch = input [ this . cursor + + ] ; if ( ch = = = undefined ) return ; if ( ch = = = ' \n ' ) { this . lineno + + ; break ; } } } else if ( ch ! = = ' ' & & ch ! = = ' \t ' ) { this . cursor - - ; return ; } } } 
function ( records ) { var ghost = this . create Ghost ( records ) , store = ghost . store ; store . remove All ( ) ; store . add ( records ) ; return ghost . get El ( ) ; } 
function init ( ) { document . add Event Listener ( 'visibilitychange ' , visibility Change . bind ( this ) ) ; window . onpopstate = pop State . bind ( this ) ; window . onbeforeunload = before Unload . bind ( this ) ; 
function visibility Change ( ev ) { 
function activate ( that , el ) { 
function Charged ( options ) { if ( ! ( this instanceof Charged ) ) { return new Charged ( options ) ; } this . options = options ; this . subdomain = options . subdomain | | options . product | | options . name ; this . api Key = options . key | | options . api Key ; this . site Key = options . site Key ; this . default Family = options . family | | options . default Family ; this . smart Validation = options . smart Validation ; this . debug = options . debug ; this . retry = options . retry | | 1 ; this . cache = options . cache | | false ; this . cache TTL = options . cache TTL | | 2 0 * 1 0 0 0 ; this . cache Threshold = options . cache Threshold | | 1 0 0 ; this . _cache = { customers : { } , subscriptions : { } , components : { } , metadata : { } , usage : { } } ; this . cache Schemas = options . cache Schemas ; this . _schema Cache = { components : { } , products : { } } ; if ( ! this . subdomain | | ! this . api Key ) { throw new Error ( 'Options `subdomain ` and `api Key ` are required for Charged . ' ) ; } } 
function formatter ( name , callback ) { return function ( err , result ) { if ( err ) return callback ( err ) ; if ( ! result ) result = { } ; 
function parse ( str , del , eq ) { if ( ! str ) return { } ; var out = { } , s = str . split ( del | | ' & ' ) , l = s . length , i = 0 , $ ; for ( ; i < l ; i + + ) { $ = s [ i ] . split ( eq | | ' = ' ) ; if ( $ [ 0 ] ) { $ [ 0 ] = unescape ( $ [ 0 ] ) ; $ [ 1 ] = $ [ 1 ] ? unescape ( $ [ 1 ] ) : ' ' ; parse . set ( out , $ [ 0 ] , $ [ 1 ] ) ; } } return out ; } 
function ( key , done ) { var val = null ; if ( cache . has Own Property ( key ) ) { val = cache [ key ] ; } return done ( null , val ) ; } 
function ( additional Rules , opts ) { if ( check ( additional Rules ) . is ( 'undefined ' ) ) { return true ; } if ( check ( additional Rules ) . is . not ( 'object ' ) ) { logger . warn ( 'Provide an mapping of custom rules ' ) ; return false ; } _ . each ( additional Rules , function ( rule , rule Name ) { if ( check ( rule ) . is . not ( 'function ' ) | | check ( rule Name ) . is . not ( 'string ' ) ) { logger . warn ( 'Invalid custom rule provided ' ) ; return ; } rules [ rule Name ] = rule ; opts [ rule Name ] = opts [ rule Name ] | | true ; } ) ; return true ; } 
function ( opts , file , encoding , callback ) { var file Path = new File Path ( file . path ) ; results [ file Path . value ] = results [ file Path . value ] | | [ ] ; _ . each ( rules , function ( rule , name ) { var response ; if ( ! opts [ name ] ) { return ; } response = rule ( file Path , opts [ name ] ) ; if ( check ( response ) . is ( 'string ' ) ) { results [ file Path . value ] . push ( response ) ; } } ) ; callback ( null , file ) ; } 
function ( data ) { return _ . reduce ( data , function ( results , errors , file Path ) { if ( check ( errors ) . is . not ( 'empty ' ) ) { results [ file Path ] = errors ; } return results ; } , { } ) ; } 
function unpromisify ( fn ) { return function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } var callback = function callback ( ) { } ; if ( typeof _lodash 2 [ 'default ' ] . last ( args ) = = = 'function ' ) { callback = _lodash 2 [ 'default ' ] . last ( args ) ; args = _lodash 2 [ 'default ' ] . take ( args , args . length - 1 ) ; } return _bluebird 2 [ 'default ' ] [ 'try ' ] ( function ( ) { return fn . apply ( undefined , _to Consumable Array ( args ) ) ; } ) . nodeify ( callback ) ; } ; } 
function _return Map ( callback , file , created ) { if ( typeof file = = = 'string ' ) { var map = foldermap . map Sync ( file ) ; Object . define Property ( map , ' _created ' , { value : created } ) ; } else { var map = { } ; for ( var i in file ) { map [ i ] = foldermap . map Sync ( file [ i ] ) ; Object . define Property ( map [ i ] , ' _created ' , { value : created } ) ; } } callback ( null , map ) ; } 
function ready Cb ( cb ) { 
function compute ( value , m ) { if ( ! m ) return { } var res = { } var keys = Object . keys ( m ) for ( var i = 0 ; i < keys . length ; + + i ) { var k = keys [ i ] var v = m [ k ] if ( v > value ) { res [ k ] = v } } 
function _filter ( f ) { var fpath = path . format ( path . parse ( path . normalize ( path . dirname ( f ) ) ) ) ; if ( fpath = = = fpath Parsed ) return true ; return false ; } 
function filter Trackeds ( tracked , code ) { return _ . omit ( tracked , Object . keys ( tracked ) . filter ( function ( fname ) { return tracked [ fname ] . code ! = = code ; } ) ) ; } 
function file Status ( prev , stat , filename , dir , fn ) { var fullname = path . join ( dir , filename ) / / is a deleted file ? / / is a file added ? if ( prev = = = undefined | | prev = = = null ) { fn & & fn ( null , { stats : { mtime : stat . mtime , size : stat . size } , code : 1 } ) ; return ; } var mtime Change = stat . mtime . value Of ( ) ! = prev . stats . mtime . value Of ( ) ; var size Change = stat . size ! = prev . stats . size ; / / has changes ? if ( ! mtime Change & & ! size Change ) { return fn & & fn ( null , { stats : { mtime : stat . mtime , size : stat . size } , code : 0 } ) ; } / / the file has change fn & & fn ( null , { stats : { mtime : stat . mtime , size : stat . size } , code : 2 } ) ; } 
function get Files ( dir , pattern , fn ) { if ( "function " = = = typeof pattern ) { fn = pattern ; pattern = undefined ; } pattern = pattern | | / . * / ig ; fs . readdir ( dir , function ( err , files ) { if ( err ) return fn & & fn ( err ) ; async . map ( files , function ( f , cb ) { fs . stat ( path . join ( dir , f ) , function ( err , stats ) { if ( err ) return cb & & cb ( err ) ; cb & & cb ( null , { filename : f , stats : stats } ) } ) } , function ( err , stats ) { if ( err ) return fn & & fn ( err ) ; var fstats = stats . filter ( function ( f ) { return f . stats . is File ( ) & & pattern . test ( f . filename ) ; } ) ; fn & & fn ( null , fstats ) ; } ) ; } ) ; } 
function ( key , value ) { 
function ( key , value ) { var me = this , map = me . map , old ; 
function ( key ) { var me = this , value ; if ( me . contains Key ( key ) ) { value = me . map [ key ] ; delete me . map [ key ] ; - - me . length ; if ( me . has Listeners . remove ) { me . fire Event ( 'remove ' , me , key , value ) ; } return true ; } return false ; } 
function ( is Key ) { var arr = [ ] , key , map = this . map ; for ( key in map ) { if ( map . has Own Property ( key ) ) { arr . push ( is Key ? key : map [ key ] ) ; } } return arr ; } 
function ( fn , scope ) { 
function ( ) { var hash = new this . self ( this . initial Config ) , map = this . map , key ; hash . suspend Events ( ) ; for ( key in map ) { if ( map . has Own Property ( key ) ) { hash . add ( key , map [ key ] ) ; } } hash . resume Events ( ) ; return hash ; } 
function ( ast List , context , callback ) { var retval = new Array ( ast List . length ) ; async Each ( ast List , function ( ast , i , done ) { run ( ast , context , function ( err , val ) { if ( err ) { callback ( err ) ; } else { retval [ i ] = val ; done ( ) ; } } ) ; } , callback , null , retval ) ; } 
function ( ast List , context , callback ) { var retval = new Array ( 2 ) ; var i = 0 ; var get Op Args 2 _callback = function ( err , val ) { if ( err ) { callback ( err ) ; } else { retval [ i ] = val ; i + + ; if ( i > = 2 ) callback ( null , retval ) ; } } ; run ( ast List [ 1 ] , context , get Op Args 2 _callback ) ; run ( ast List [ 2 ] , context , get Op Args 2 _callback ) ; } 
function ( ed , url ) { var t = this ; 
function peek Token No Line Terminator ( ) { var t = peek Token ( ) ; var start = last Token . location . end . offset ; var end = t . location . start . offset ; for ( var i = start ; i < end ; i + + ) { var code = input . char Code At ( i ) ; if ( is Line Terminator ( code ) ) return null ; 
function compute Several Snapshot Versions ( latest Version Id ) { if ( latest Version Id < Base ) return [ ] ; var k = Math . log ( latest Version Id / Base ) / Log Rate ; k = Math . floor ( k ) ; var arr = [ ] ; 
function Immutable Core Model View ( args ) { 
function ( ) { 
function get Model View ( model View Name ) { 
function make Immutable ( model View ) { 
function make Immutable Asynchronous ( model View ) { 
function make Immutable Synchronous ( model View ) { 
function set Model View Id ( model View Constructor ) { 
function set Model View Instance Id ( model View Instance ) { 
function parse ( serialized Store ) { var self = this , keys = _ . keys ( serialized Store ) ; _ . each ( keys , function ( key ) { var serialized Data = serialized Store [ key ] , identifier = serialized Data . data Store Model Identifier , Model ; if ( ! _ . has ( self . registered Models And Collections , identifier ) ) { throw new Error ( 'Could not deserialize Data Store because ' + 'a required model was not registered before ! ' ) ; } else { var meta Information = self . registered Models And Collections [ identifier ] , json Representation = serialized Data . data ; if ( _ . has ( meta Information , 'collection Class ' ) ) { var Collection = meta Information . collection Class , deserialized Collection = new Collection ( ) ; Model = meta Information . model Class ; self . set ( key , deserialized Collection ) ; for ( var i in json Representation ) { var model Json = json Representation [ i ] ; deserialized Collection . add ( new Model ( model Json ) ) ; } } else { Model = meta Information ; self . set ( key , new Model ( json Representation ) ) ; } } } ) ; } 
function find Outer Char ( str , char ) { var square = 0 , curly = 0 , round = 0 , angle = 0 ; for ( var i = 0 ; i < str . length ; + + i ) { var c = str . char At ( i ) ; if ( c = = = char & & square = = = 0 & & curly = = = 0 & & round = = = 0 & & angle = = = 0 ) { return i ; } if ( c = = = ' [ ' ) + + square ; else if ( c = = = ' ] ' ) - - square ; else if ( c = = = ' { ' ) + + curly ; else if ( c = = = ' } ' ) - - curly ; else if ( c = = = ' ( ' ) + + round ; else if ( c = = = ' ) ' ) - - round ; else if ( c = = = ' < ' ) + + angle ; else if ( c = = = ' > ' ) - - angle ; if ( c = = = char & & square = = = 0 & & curly = = = 0 & & round = = = 0 & & angle = = = 0 ) { return i ; } } if ( square ! = = 0 ) _ . errout ( 'mismatched [ ] brackets : ' + str ) ; if ( curly ! = = 0 ) _ . errout ( 'mismatched { } brackets : ' + str ) ; if ( round ! = = 0 ) _ . errout ( 'mismatched ( ) brackets : ' + str ) ; return - 1 ; } 
function compute Param Types ( rel , binding Types , implicits , compute Type Wrapper ) { _ . assert Length ( arguments , 4 ) _ . assert Array ( implicits ) rel . params . for Each ( function ( p ) { if ( p . type = = = 'macro ' | | p . type = = = 'partial -application ' ) { return } compute Type Wrapper ( p , binding Types , implicits ) } ) } 
function CI ( pull _request , branch , build _number , builder ) { this . pull _request = pull _request ; this . branch = branch ; this . build _number = build _number ; this . builder = builder ; this . Get Version = Get Version ; this . Get Pull Request = Get Pull Request ; this . Publish Git Tag = Publish Git Tag ; this . Merge Downstream = Merge Downstream ; } 
function ( sb ) { var me = this ; me . status Bar = sb ; sb . on ( { single : true , scope : me , render : me . on Statusbar Render , beforedestroy : me . destroy } ) ; sb . on ( { click : { element : 'el ' , fn : me . on Status Click , scope : me , buffer : 2 0 0 } } ) ; } 
function ( f , is Valid ) { var me = this , msg ; if ( ! me . monitor ) { return false ; } msg = f . get Errors ( ) [ 0 ] ; if ( msg ) { me . errors . add ( f . id , { field : f , msg : msg } ) ; } else { me . errors . remove At Key ( f . id ) ; } this . update Error List ( ) ; if ( me . errors . get Count ( ) > 0 ) { if ( me . status Bar . get Text ( ) ! = = me . show Text ) { me . status Bar . set Status ( { text : me . show Text , icon Cls : me . error Icon Cls } ) ; } } else { me . status Bar . clear Status ( ) . set Icon ( me . valid Icon Cls ) ; } } 
function ( ) { var me = this , msg , msg El = me . get Msg El ( ) ; if ( me . errors . get Count ( ) > 0 ) { msg = [ ' <ul > ' ] ; this . errors . each ( function ( err ) { msg . push ( ' <li id = "x -err - ' , err . field . id , ' " > <a href = " # " > ' , err . msg , ' < /a > < /li > ' ) ; } ) ; msg . push ( ' < /ul > ' ) ; msg El . update ( msg . join ( ' ' ) ) ; } else { msg El . update ( ' ' ) ; } 
function ( ) { var me = this , msg El = me . msg El , t ; if ( ! msg El ) { msg El = me . msg El = Ext . Dom Helper . append ( Ext . get Body ( ) , { cls : me . error List Cls } , true ) ; msg El . hide ( ) ; msg El . on ( 'click ' , function ( e ) { t = e . get Target ( 'li ' , 1 0 , true ) ; if ( t ) { Ext . get Cmp ( t . id . split ( 'x -err - ' ) [ 1 ] ) . focus ( ) ; me . hide Errors ( ) ; } } , null , { stop Event : true } ) ; 
function ( ) { var me = this ; me . update Error List ( ) ; me . get Msg El ( ) . align To ( me . status Bar . get El ( ) , me . list Align ) . slide In ( 'b ' , { duration : 3 0 0 , easing : 'ease Out ' } ) ; me . status Bar . set Text ( me . hide Text ) ; me . form Panel . body . on ( 'click ' , me . hide Errors , me , { single : true } ) ; 
function ( ) { var el = this . get Msg El ( ) ; if ( el . is Visible ( ) ) { el . slide Out ( 'b ' , { duration : 3 0 0 , easing : 'ease In ' } ) ; this . status Bar . set Text ( this . show Text ) ; } this . form Panel . body . un ( 'click ' , this . hide Errors , this ) ; } 
function ( env ) { console . log ( 'Stubbatti server version %s . ' , Stubbatti . version ) ; 
function ( table , to Obj ) { ! table & & ( table = ' ' ) ; var result = table ; var tablename = table . name | | table ; tablename = tablename . trim ( ) ; if ( tablename . length = = 0 ) { return false ; } while ( tablename . substr ( 0 , 1 ) = = ' _ ' ) { tablename = tablename . substr ( 1 ) ; } result . name = tablename ; return to Obj ? result : tablename ; } 
function ( sql ) { if ( ! sql | | typeof sql ! = 'string ' ) { return ' ' ; } var tmp = sql . to Lower Case ( ) ; if ( tmp . index Of ( "select " ) ! = 0 & & tmp . index Of ( "update " ) ! = 0 & & tmp . index Of ( "insert " ) ! = 0 & & tmp . index Of ( "delete " ) ! = 0 & & tmp . index Of ( "limit " ) ! = 0 & & tmp . index Of ( "where " ) ! = 0 ) { sql = "WHERE " + sql ; } return sql ; } 
function ( type ) { 
function ( value ) { var rs ; if ( typeof value = = "object " ) { rs = "JSON " ; } else if ( / ^ - ? \d + ( ? : \ . \d * ) ? ( ? :e [ + \ - ] ? \d + ) ? $ / i . test ( value ) ) { rs = data Type ( "Number " ) ; } else if ( ! is Na N ( Date . parse ( value ) ) ) { rs = data Type ( "Date " ) ; } else { rs = data Type ( typeof value ) ; } return rs ; } 
function ( data ) { var schema = { } ; if ( ! data | | typeof data ! = 'object ' ) { data = { } ; } else if ( util . is Array ( data ) ) { return get Value Schema ( data [ 0 ] ) ; } for ( var key in data ) { schema [ key ] = value Type ( data [ key ] ) ; } return schema ; } 
function ( value , type ) { if ( typeof type ! = "string " ) { return check Value ( value ) ; } var rs = value ; if ( value = = = null ) { return null ; } switch ( type ) { case "String " : if ( ! value ) { rs = " " ; } else { rs = value . to String ( ) ; } break ; case "Number " : rs = is Na N ( parse Float ( value ) ) ? null : parse Float ( value ) ; break ; case "Date " : rs = is Na N ( new Date ( value ) ) ? null : new Date ( value ) ; break ; case "Boolean " : if ( typeof value = = 'string ' ) { value = value . to Lower Case ( ) ; } switch ( value ) { case true : case "true " : case "t " : case 1 : case " 1 " : rs = true ; break ; case false : case "false " : case "f " : case 0 : case " 0 " : rs = false ; break ; default : rs = null ; break ; } break ; case "JSON " : rs = typeof value = = 'object ' ? value : { } ; break ; case "Binary " : break ; } return rs ; } 
function ( data ) { var type = typeof ( data ) , rs = { } ; if ( type ! = 'object ' ) { key = ' _ ' + type ; rs [ key ] = data ; } else { rs = data ; } return rs ; } 
function ( value ) { var rs ; if ( / ^ - ? \d + ( ? : \ . \d * ) ? ( ? :e [ + \ - ] ? \d + ) ? $ / i . test ( value ) ) { rs = parse Float ( value ) ; } else if ( ! is Na N ( Date . parse ( value ) ) ) { rs = new Date ( value ) ; } else { rs = value ; } return rs ; } 
function ( value , type ) { var rs ; value = value . trim ( ) ; if ( value . index Of ( " ' " ) = = 0 | | value . index Of ( ' " ' ) = = 0 ) { rs = value . substr ( 1 , value . length - 2 ) ; if ( type ) { rs = data Transfer ( rs , type ) ; } } else { if ( type ) { rs = data Transfer ( value , type ) ; } if ( typeof ( value ) = = 'object ' ) { rs = value ; } else if ( value = = 'true ' ) { rs = true ; } else if ( value = = 'false ' ) { rs = false ; } else { rs = parse Float ( value ) ; } } return rs ; } 
function index ( req , res , next ) { 
function ( table , config ) { config = Ext . apply ( { } , config ) ; table = this . table = Ext . get ( table ) ; var config Fields = config . fields | | [ ] , config Columns = config . columns | | [ ] , fields = [ ] , cols = [ ] , headers = table . query ( "thead th " ) , i = 0 , len = headers . length , data = table . dom , width , height , store , col , text , name ; for ( ; i < len ; + + i ) { col = headers [ i ] ; text = col . inner HTML ; name = 'tcol - ' + i ; fields . push ( Ext . apply If ( config Fields [ i ] | | { } , { name : name , mapping : 'td :nth ( ' + ( i + 1 ) + ' ) / @inner HTML ' } ) ) ; cols . push ( Ext . apply If ( config Columns [ i ] | | { } , { text : text , data Index : name , width : col . offset Width , tooltip : col . title , sortable : true } ) ) ; } if ( config . width ) { width = config . width ; } else { width = table . get Width ( ) + 1 ; } if ( config . height ) { height = config . height ; } Ext . apply If ( config , { store : { data : data , fields : fields , proxy : { type : 'memory ' , reader : { record : 'tbody tr ' , type : 'xml ' } } } , columns : cols , width : width , height : height } ) ; this . call Parent ( [ config ] ) ; if ( config . remove ! = = false ) { 
function weight ( word ) { return HAMMING _TABLE [ ( word > > 0x 0 0 ) & 0x F ] + HAMMING _TABLE [ ( word > > 0x 0 4 ) & 0x F ] + HAMMING _TABLE [ ( word > > 0x 0 8 ) & 0x F ] + HAMMING _TABLE [ ( word > > 0x 0C ) & 0x F ] + HAMMING _TABLE [ ( word > > 0x 1 0 ) & 0x F ] + HAMMING _TABLE [ ( word > > 0x 1 4 ) & 0x F ] + HAMMING _TABLE [ ( word > > 0x 1 8 ) & 0x F ] + HAMMING _TABLE [ ( word > > 0x 1C ) & 0x F ] ; } 
function highest ( word ) { word | = word > > 1 ; word | = word > > 2 ; word | = word > > 4 ; word | = word > > 8 ; word | = word > > 1 6 ; 
function on Selection ( ev ) { 
function multiply Duration ( start Duration , multiplier ) { if ( ! is Finite ( multiplier ) | | multiplier < = 0 ) { throw new Error ( 'Invalid Multiplier ' ) ; } var new Duration = { } , has Time = false , duration = ' ' ; if ( start Duration . get Seconds ( ) ) { new Duration . seconds = Math . round ( start Duration . get Seconds ( ) * multiplier ) ; } if ( start Duration . get Minutes ( ) ) { new Duration . minutes = Math . round ( start Duration . get Minutes ( ) * multiplier ) ; } if ( start Duration . get Hours ( ) ) { new Duration . hours = Math . round ( start Duration . get Hours ( ) * multiplier ) ; } if ( start Duration . get Days ( ) ) { new Duration . days = Math . round ( start Duration . get Days ( ) * multiplier ) ; } if ( start Duration . get Months ( ) ) { new Duration . months = Math . round ( start Duration . get Months ( ) * multiplier ) ; } if ( start Duration . get Years ( ) ) { new Duration . years = Math . round ( start Duration . get Years ( ) * multiplier ) ; } if ( new Duration . seconds ) { has Time = true ; duration = new Duration . seconds + 'S ' + duration ; } if ( new Duration . minutes ) { has Time = true ; duration = new Duration . minutes + 'M ' + duration ; } if ( new Duration . hours ) { has Time = true ; duration = new Duration . hours + 'H ' + duration ; } if ( has Time ) { duration = 'T ' + duration ; } if ( new Duration . days ) { duration = new Duration . days + 'D ' + duration ; } if ( new Duration . months ) { duration = new Duration . months + 'M ' + duration ; } if ( new Duration . years ) { duration = new Duration . years + 'Y ' + duration ; } if ( ! duration ) { throw new Error ( 'Invalid Duration Multiplier ' ) ; } return new Duration ( 'P ' + duration ) ; } 
function add Duration ( start Date , duration ) { var end = get Obj From Date ( start Date , false ) , end String = ' ' ; 
function get Duration ( start Date , end Date ) { if ( ! ( start Date instanceof Simple & & end Date instanceof Simple ) ) { throw new Error ( 'Start and end dates must be simple dates ' ) ; } var start = get Obj From Date ( start Date , true ) , end = get Obj From Date ( end Date , true ) , has Time = false , duration = ' ' ; zip Dates ( start , end ) ; if ( end . seconds ! = undefined ) { while ( end . seconds - start . seconds < 0 ) { end . minutes - = 1 ; end . seconds + = 6 0 ; } if ( end . seconds - start . seconds > 0 ) { has Time = true ; duration = ( ' 0 0 ' + ( end . seconds - start . seconds ) ) . substr ( - 2 , 2 ) + 'S ' + duration ; } } if ( end . minutes ! = undefined ) { while ( end . minutes - start . minutes < 0 ) { end . hours - = 1 ; end . minutes + = 6 0 ; } if ( end . minutes - start . minutes > 0 ) { has Time = true ; duration = ( ' 0 0 ' + ( end . minutes - start . minutes ) ) . substr ( - 2 , 2 ) + 'M ' + duration ; } } if ( end . hours ! = undefined ) { while ( end . hours - start . hours < 0 ) { end . day - = 1 ; end . hours + = 2 4 ; } if ( end . hours - start . hours > 0 ) { has Time = true ; duration = ( ' 0 0 ' + ( end . hours - start . hours ) ) . substr ( - 2 , 2 ) + 'H ' + duration ; } } if ( has Time ) { duration = 'T ' + duration ; } if ( end . day ! = undefined ) { while ( end . day - start . day < 0 ) { end . day + = Global Util . days In Month ( end . month , end . year ) ; end . month - = 1 ; if ( end . month < 1 ) { end . year - = 1 ; end . month + = 1 2 ; } } if ( end . day - start . day > 0 ) { duration = ( ' 0 0 ' + ( end . day - start . day ) ) . substr ( - 2 , 2 ) + 'D ' + duration ; } } if ( end . month ! = undefined ) { while ( end . month - start . month < 0 ) { end . year - = 1 ; end . month + = 1 2 ; } if ( end . month - start . month > 0 ) { duration = ( ' 0 0 ' + ( end . month - start . month ) ) . substr ( - 2 , 2 ) + 'M ' + duration ; } } if ( end . year - start . year > 0 ) { duration = ( ' 0 0 0 0 ' + ( end . year - start . year ) ) . substr ( - 4 , 4 ) + 'Y ' + duration ; } if ( end . year - start . year < 0 | | duration = = ' ' ) { throw new Error ( 'Start Date must be less than End Date ' ) ; } return new Duration ( 'P ' + duration ) ; } 
function zip Dates ( start , end ) { if ( start . month ! = undefined & & end . month = = undefined ) { end . month = 1 ; } if ( start . month = = undefined & & end . month ! = undefined ) { start . month = 1 ; } if ( start . day ! = undefined & & end . day = = undefined ) { end . day = 1 ; } if ( start . day = = undefined & & end . day ! = undefined ) { start . day = 1 ; } if ( start . hours ! = undefined & & end . hours = = undefined ) { end . hours = 0 ; } if ( start . hours = = undefined & & end . hours ! = undefined ) { start . hours = 0 ; } if ( start . minutes ! = undefined & & end . minutes = = undefined ) { end . minutes = 0 ; } if ( start . minutes = = undefined & & end . minutes ! = undefined ) { start . minutes = 0 ; } if ( start . seconds ! = undefined & & end . seconds = = undefined ) { end . seconds = 0 ; } if ( start . seconds = = undefined & & end . seconds ! = undefined ) { start . seconds = 0 ; } } 
function zip Duration ( date , duration ) { var to Set = { } ; if ( duration . get Seconds ( ) ) { to Set = { seconds : true , minutes : true , hours : true , days : true , months : true } ; } else if ( duration . get Minutes ( ) ) { to Set = { minutes : true , hours : true , days : true , months : true } ; } else if ( duration . get Hours ( ) ) { to Set = { hours : true , days : true , months : true } ; } else if ( duration . get Days ( ) ) { to Set = { days : true , months : true } ; } else if ( duration . get Months ( ) ) { to Set = { months : true } ; } else { return ; } if ( to Set . seconds & & date . seconds = = undefined ) { date . seconds = 0 ; } if ( to Set . minutes & & date . minutes = = undefined ) { date . minutes = 0 ; } if ( to Set . hours & & date . hours = = undefined ) { date . hours = 0 ; } if ( to Set . days & & date . day = = undefined ) { date . day = 1 ; } if ( to Set . months & & date . month = = undefined ) { date . month = 1 ; } } 
function get Obj From Date ( date , adjust Timezone ) { var obj = { year : date . get Year ( ) , month : date . get Month ( ) , day : date . get Day ( ) , hours : date . get Hours ( ) , minutes : date . get Minutes ( ) , seconds : date . get Seconds ( ) } if ( adjust Timezone ) { if ( obj . minutes ! = undefined & & date . get TZMinutes ( ) ! = undefined ) { obj . minutes + = date . get TZMinutes ( ) ; } if ( obj . hours ! = undefined & & date . get TZHours ( ) ! = undefined ) { obj . hours + = date . get TZHours ( ) ; } } return obj ; } 
function Range ( str ) { var range = str ; 
function ( p ) { return me . server . get Model ( 'admin .models .access ' ) . get Page Rates ( null , null , null , p , rates ) } 
function ( ) { Ext . data . flash . Binary Xhr . flash Plugin Active = true ; Ext . data . flash . Binary Xhr . flash Plugin = document . get Element By Id ( "ext -flash -polyfill " ) ; Ext . global Events . fire Event ( "flashready " ) ; 
function ( javascript Id , state , data ) { var connection ; 
function ( ) { var headers = [ ] ; Ext . Object . each ( this . response Headers , function ( name , value ) { headers . push ( name + ' : ' + value ) ; } ) ; return headers . join ( ' \x 0d \x 0a ' ) ; } 
function ( method , url , async , user , password ) { var me = this ; me . method = method ; me . url = url ; me . async = async ! = = false ; me . user = user ; me . password = password ; 
function ( body ) { var me = this ; me . body = body ; if ( ! Ext . data . flash . Binary Xhr . flash Plugin Active ) { Ext . global Events . add Listener ( "flashready " , me . on Flash Ready , me ) ; } else { this . on Flash Ready ( ) ; } } 
function ( ) { var me = this , req , status ; me . javascript Id = Ext . data . flash . Binary Xhr . register Connection ( me ) ; 
function ( state ) { var me = this ; if ( me . ready State ! = state ) { me . ready State = state ; me . onreadystatechange ( ) ; } } 
function ( data ) { var me = this ; 
function Resources Agent ( resources Data , language , namespace ) { if ( ! resources Data | | ( resources Data & & typeof resources Data ! = = "object " ) ) { throw new Error ( "Expected Resource Data . " ) ; } if ( ! language ) { throw new Error ( "Expected argument language . " ) ; } if ( ! namespace ) { throw new Error ( "Expected argument namespace . " ) ; } if ( ! resources Data [ language ] ) { throw new Error ( "Resource Language ' " + language + " ' is not available " ) ; } if ( ! resources Data [ language ] [ namespace ] ) { throw new Error ( "Resource Namespace ' " + namespace + " ' is not available " ) ; } 
function consume _sl _comment ( proc _stack ) { let comment = " / / " ; proc _stack . t Skip ( 2 ) ; let done = false ; while ( ! proc _stack . t At End ( ) & & ! done ) { let peek = proc _stack . t Peek ( ) ; if ( peek = = " \r " | | peek = = " \n " ) { done = true ; } else { comment + = proc _stack . t Accept ( ) ; } } return comment ; } 
function consume _ml _comment ( proc _stack ) { let comment = " / * " ; proc _stack . t Skip ( 2 ) ; while ( ! proc _stack . t Matches ( " * / " ) ) { comment + = proc _stack . t Accept ( ) ; } proc _stack . t Skip ( 2 ) ; comment + = " * / " ; return comment ; } 
function consume _string ( proc _stack ) { let delim = proc _stack . t Accept ( ) ; let str = delim ; let escaping = 0 ; let done = false ; while ( ! done ) { let c = proc _stack . t Accept ( ) ; if ( c = = " \ \ " ) { escaping ^ = 1 ; } else { if ( c = = delim & & ! escaping ) { done = true ; } else if ( c = = " \r " | | c = = " \n " ) { if ( ! escaping ) { throw new Syntax Error ( ` ` ) ; } if ( c = = " \r " & & proc _stack . t Peek ( ) = = " \n " ) { proc _stack . t Skip ( ) ; } } escaping = 0 ; } str + = c ; } return str ; } 
function consume _template ( proc _stack ) { let template = " ` " ; proc _stack . t Skip ( 1 ) ; let escaping = 0 ; let done = false ; while ( ! done ) { let c = proc _stack . t Accept ( ) ; if ( c = = " \ \ " ) { escaping ^ = 1 ; } else { if ( c = = " ` " & & ! escaping ) { done = true ; } escaping = 0 ; } template + = c ; } return template ; } 
function consume _directive ( proc _stack ) { let pos = proc _stack . _t Get NPos ( ) ; proc _stack . t Skip ( 5 ) ; let directive _name = proc _stack . t Accept Until ( " ( " ) ; proc _stack . t Skip ( ) ; let args = [ ] ; do { proc _stack . t Skip While ( WHITESPACE ) ; let peek = proc _stack . t Peek ( ) ; if ( peek = = " ) " ) { break ; } let arg _val _parts = [ ] ; do { proc _stack . t Skip While ( WHITESPACE ) ; let matched = false ; for ( let trig of CONSUMERS _DIRECTIVE _ARG _TRIGGERS ) { if ( proc _stack . t Matches ( trig ) ) { let consumed = CONSUMERS _DIRECTIVE _ARG [ trig ] ( proc _stack ) ; if ( consumed instanceof Directive Expr ) { arg _val _parts . push ( consumed ) ; } else { arg _val _parts . push ( Function ( ` $ { consumed } ` ) ( ) ) ; } matched = true ; break ; } } if ( ! matched ) { throw new Syntax Error ( ` ` ) ; } proc _stack . t Skip While ( WHITESPACE ) ; } while ( proc _stack . t Skip If ( " + " ) ) ; args . push ( arg _val _parts ) ; } while ( proc _stack . t Skip If ( " , " ) ) ; if ( ! proc _stack . t Skip If ( " ) " ) ) { throw new Syntax Error ( ` ` ) ; } proc _stack . t Skip If ( " ; " ) ; return new Directive Expr ( proc _stack , pos , directive _name , args ) ; } 
function Http Log ( ) { var args = arguer . apply ( _constructor Format , arguments ) ; if ( args instanceof Error ) return http Log ( args ) ; if ( args . response instanceof Http . Incoming Message & & args . response . status Code ) return http Log ( args . response . status Code , Http . STATUS _CODES [ args . response . status Code ] ) ; if ( args . error instanceof Http Log ) return args . error ; var log ; if ( args . error ) { log = args . error ; } else if ( args . message ! = = undefined | | ( args . status ! = = undefined & & args . data ! = = null ) | | args . data ) { log = new Error ( args . message ) ; } else { return Http Log . none ; } log . _ _proto _ _ = Http Log . prototype ; if ( args . status ! = = undefined ) log . status = args . status ; log . data = args . data | | { } ; return log ; } 
function get Stack ( log ) { log . _ _getting Stack = true ; var stack = log . stack ; log . _ _getting Stack = false ; return stack ; } 
function ( animate ) { var me = this ; me . set Visible ( ! me . is Visible ( ) , me . anim ( animate ) ) ; return me ; } 
function ( ) { var me = this ; if ( me . is Style ( DISPLAY , NONE ) ) { me . set Style ( VISIBILITY , HIDDEN ) ; me . set Style ( DISPLAY , get Display ( me ) ) ; 
function skip Whitespace Nodes ( e , next ) { while ( e & & ( e . node Type = = = 8 | | ( e . node Type = = = 3 & & / ^ [ \t \n \r ] * $ / . test ( e . node Value ) ) ) ) { e = next ( e ) ; } return e ; } 
function is End Of List Item ( ) { var node = ed . selection . get Node ( ) ; var valid Elements = 'h 1 ,h 2 ,h 3 ,h 4 ,h 5 ,h 6 ,p ,div ' ; var is Last Paragraph Of Li = ed . dom . is ( node , valid Elements ) & & node . parent Node . tag Name = = = 'LI ' & & node . parent Node . last Child = = = node ; return ed . selection . is Collapsed ( ) & & is Last Paragraph Of Li & & is Cursor At End Of Container ( ) ; } 
function create New Li ( ed , e ) { if ( is Enter Without Shift ( e ) & & is End Of List Item ( ) ) { var node = ed . selection . get Node ( ) ; var li = ed . dom . create ( "li " ) ; var parent Li = ed . dom . get Parent ( node , 'li ' ) ; ed . dom . insert After ( li , parent Li ) ; 
function set Cursor Position To Original Li ( li ) { var list = ed . dom . get Parent ( li , 'ol ,ul ' ) ; if ( list ! = null ) { var last Li = list . last Child ; 
function ( config ) { config = config | | { } ; var me = this , pos = config . position | | 'left ' ; pos = pos . char At ( 0 ) . to Upper Case ( ) + pos . substring ( 1 ) ; 
function ( err ) { if ( err ) { if ( cb . length = = = 1 ) { console . log ( 'cb has no error handling , throwing : ' + cb ) throw err } if (cb .length = = = 1 ) { cb (api .get View (view Id , historical Key ) ) }else { * / try { var view = api . get View ( view Id ) } catch ( e ) { console . log ( 'ERROR during api .get View ' ) console . log ( e . stack ) return } try { cb ( undefined , view ) 
function ( ed , cm , n ) { var le , p ; le = this . _get Parent Layer ( n ) ; p = ed . dom . get Parent ( n , 'DIV ,P ,IMG ' ) ; if ( ! p ) { cm . set Disabled ( 'absolute ' , 1 ) ; cm . set Disabled ( 'moveforward ' , 1 ) ; cm . set Disabled ( 'movebackward ' , 1 ) ; } else { cm . set Disabled ( 'absolute ' , 0 ) ; cm . set Disabled ( 'moveforward ' , ! le ) ; cm . set Disabled ( 'movebackward ' , ! le ) ; cm . set Active ( 'absolute ' , le & & le . style . position . to Lower Case ( ) = = "absolute " ) ; } } 
function ( ed , e , s ) { var dom = ed . dom ; tinymce . each ( dom . select ( 'div ,p ' , e ) , function ( e ) { if ( / ^ (absolute |relative |fixed ) $ / i . test ( e . style . position ) ) { if ( s ) dom . add Class ( e , 'mce Item Visual Aid ' ) ; else dom . remove Class ( e , 'mce Item Visual Aid ' ) ; dom . add Class ( e , 'mce Item Layer ' ) ; } } ) ; } 
function Static ( app , root , opts ) { app . properties [ SERVER . Capabilities ] [ STATIC . CAPABILITY ] = { } ; app . properties [ SERVER . Capabilities ] [ STATIC . CAPABILITY ] [ SERVER . Version ] = package Version ; opts = opts | | { } ; 
function listener ( bot ) { return function ( buffer ) { var line = buffer . to String ( ) ; var truncated Line = line . slice ( 0 , line . length - 1 ) ; if ( current _actions & & ! is Na N ( parse Int ( truncated Line ) ) & & parse Int ( truncated Line ) < current _actions . length ) { var action = current _actions [ parse Int ( truncated Line ) ] ; current _actions = null ; if ( typeof action = = = "string " ) { bot ( platform , { session Id : session Id } , { type : 'action ' , message : action , action : action } , oncomplete ) ; } else if ( action . url ) { request ( action . url , function ( error , response , body ) { var article = unfluff ( body ) ; console . log ( bot _name + ' > Processed Body For ' + article . title ) ; console . log ( ' \n ' + article . text + ' \n ' ) ; oncomplete ( null , null , null , function ( ) { } ) ; } ) ; } else { bot ( platform , { session Id : session Id } , { type : 'action ' , message : ' ' + action . payload , action : action . payload } , oncomplete ) ; } } else { current _actions = null ; bot ( platform , { session Id : session Id } , { type : 'message ' , message : truncated Line } , oncomplete ) ; } } ; } 
function ( obj , event , callback ) { 
function ( obj , event , callback ) { 
function ( obj , event , args ) { 
function ( obj , event , callback ) { 
function ( uuid ) { if ( ! uuid . match ( UUID . rvalid ) ) { 
function ( c ) { 
function ( list , func ) { list = list | | [ ] ; func = func | | function ( ) { return false ; } ; for ( var i = 0 , l = list . length ; i < l ; i + + ) { if ( func ( list [ i ] ) ) { return i ; } } return - 1 ; } 
function ( ) { return underscore . reduce ( arguments , function ( first , second ) { return underscore . union ( underscore . difference ( first , second ) , underscore . difference ( second , first ) ) ; } ) ; } 
function ( object , path , value , overwrite ) { overwrite = overwrite | | false ; value = value | | null ; 
function ( obj ) { if ( ! obj ) { obj = promise ; } else { for ( var key in promise ) { obj [ key ] = promise [ key ] ; } } return obj ; } 
function ( config ) { var me = this , comp ; if ( arguments . length = = = 2 ) { 
function ( store , initial ) { var me = this ; me . mixins . bindable . bind Store . apply ( me , arguments ) ; store = me . store ; if ( store & & store . is Loading ( ) ) { me . on Before Load ( ) ; } } 
function callback ( key , err , result ) { delete waiting [ key ] ; results [ key ] = result ; context . log ( err ) ; check Done ( ) ; } 
function get Server Only Files ( ) { var files = fs . readdir Sync ( path . join ( _ _dirname ) ) ; _ . each ( files , function ( file , i ) { files [ i ] = path . join ( _ _dirname , file ) ; } ) ; return files ; } 
function prepare Browserify ( app , options ) { if ( ! _ . has ( options , 'main File ' ) | | ! _ . has ( options , 'url ' ) ) { throw new Error ( 'Missing "main File " and "url " property . ' ) ; } var main File = options . main File , url = options . url , exclude = options . exclude | | [ ] , browserify Options ; exclude = exclude . concat ( get Server Only Files ( ) ) ; browserify Options = { ignore : exclude } ; _ . extend ( browserify Options , _ . omit ( options , [ 'main File ' , 'exclude ' ] ) ) ; _ . defaults ( browserify Options , { debug : false , gzip : true , minify : true } ) ; app . get ( url , browserify ( main File , browserify Options ) ) ; } 
function start ( Router , APIAdapter , start Options ) { debug ( 'Starting server ' ) ; if ( ! _ . has ( start Options , 'app ' ) ) { throw new Error ( 'Missing "app " property in "start Options " ! Please ' + 'pass a valid express app instance when starting the barefoot ' + 'router on the server . ' ) ; } if ( ! _ . has ( start Options , 'main Java Script File ' ) ) { throw new Error ( 'Missing "main Java Script File " property in ' + ' "start Options " ! Please describe how browserify should serve your ' + ' applications code . ' ) ; } var app = start Options . app , api Adapter ; if ( _ . has ( start Options , 'setup Middlewares ' ) ) { start Options . setup Middlewares ( app ) ; } if ( _ . has ( start Options , 'setup Api Adapter ' ) ) { api Adapter = new APIAdapter ( start Options ) ; start Options . setup Api Adapter ( api Adapter ) ; if ( ! _ . is Undefined ( api Adapter , 'sync ' ) ) { Backbone . sync = function ( ) { return api Adapter . sync . apply ( api Adapter , arguments ) ; } ; } start Options . api Adapter = api Adapter ; } prepare Browserify ( app , start Options . main Java Script File ) ; 
function ( events ) { var me = this , i , event , state Events By Name ; if ( me . stateful & & me . get State Id ( ) ) { if ( typeof events = = 'string ' ) { events = Array . prototype . slice . call ( arguments , 0 ) ; } state Events By Name = me . state Events By Name | | ( me . state Events By Name = { } ) ; for ( i = events . length ; i - - ; ) { event = events [ i ] ; if ( ! state Events By Name [ event ] ) { state Events By Name [ event ] = 1 ; me . on ( event , me . on State Change , me ) ; } } } } 
function ( ) { var me = this , delay = me . save Delay , statics , runner ; if ( ! me . stateful ) { return ; } if ( delay ) { if ( ! me . state Task ) { statics = Ext . state . Stateful ; runner = statics . runner | | ( statics . runner = new Ext . util . Task Runner ( ) ) ; me . state Task = runner . new Task ( { run : me . save State , scope : me , interval : delay , repeat : 1 } ) ; } me . state Task . start ( ) ; } else { me . save State ( ) ; } } 
function ( ) { var me = this , id = me . stateful & & me . get State Id ( ) , has Listeners = me . has Listeners , state ; if ( id ) { state = Ext . state . Manager . get ( id ) ; if ( state ) { state = Ext . apply ( { } , state ) ; if ( ! has Listeners . beforestaterestore | | me . fire Event ( 'beforestaterestore ' , me , state ) ! = = false ) { me . apply State ( state ) ; if ( has Listeners . staterestore ) { me . fire Event ( 'staterestore ' , me , state ) ; } } } } } 
function ( prop Name , state , state Name ) { var me = this , value = me [ prop Name ] , config = me . initial Config ; if ( me . has Own Property ( prop Name ) ) { if ( ! config | | config [ prop Name ] ! = = value ) { if ( state ) { state [ state Name | | prop Name ] = value ; } return true ; } } return false ; } 
function ( prop Names , state ) { var me = this , i , n ; if ( typeof prop Names = = 'string ' ) { me . save Prop To State ( prop Names , state ) ; } else { for ( i = 0 , n = prop Names . length ; i < n ; + + i ) { me . save Prop To State ( prop Names [ i ] , state ) ; } } return state ; } 
function ( ) { var me = this , task = me . state Task ; if ( task ) { task . destroy ( ) ; me . state Task = null ; } me . clear Listeners ( ) ; } 
function ( element , style Name ) { var view = element . owner Document . default View , style = ( view ? view . get Computed Style ( element , null ) : element . current Style ) | | element . style ; return style [ style Name ] ; } 
function ( ) { var me = this , doc = document , to Run = me . to Run | | me . tests , n = to Run . length , div = n & & Ext . is Ready & & doc . create Element ( 'div ' ) , not Run = [ ] , browser Key = get Browser Key ( ) , test , vector , value ; if ( div ) { div . inner HTML = [ ' <div style = "height : 3 0px ;width : 5 0px ; " > ' , ' <div style = "height : 2 0px ;width : 2 0px ; " > < /div > ' , ' < /div > ' , ' <div style = "width : 2 0 0px ; height : 2 0 0px ; position : relative ; padding : 5px ; " > ' , ' <div style = "position : absolute ; top : 0 ; left : 0 ; width : 1 0 0 % ; height : 1 0 0 % ; " > < /div > ' , ' < /div > ' , ' <div style = "position : absolute ; left : 1 0 % ; top : 1 0 % ; " > < /div > ' , ' <div style = "float :left ; background -color :transparent ; " > < /div > ' ] . join ( ' ' ) ; doc . body . append Child ( div ) ; } vector = supports Vectors [ browser Key ] ; while ( n - - ) { test = to Run [ n ] ; value = vector & & vector [ n ] ; if ( value ! = = undefined ) { me [ test . identity ] = value ; } else if ( div | | test . early ) { me [ test . identity ] = test . fn . call ( me , doc , div ) ; } else { not Run . push ( test ) ; } } if ( div ) { doc . body . remove Child ( div ) ; } me . to Run = not Run ; } 
function ( ) { var tests = this . tests , vector = [ ] , i = 0 , ln = tests . length , test ; for ( ; i < ln ; i + + ) { test = tests [ i ] ; vector . push ( this [ test . identity ] ? 1 : 0 ) ; } return vector ; } 
function ( ) { var me = this ; if ( ! me . active ) { me . active = new Date ( ) ; me . start Time = me . get Time ( ) ; me . on Start ( ) ; me . fire Event ( 'start ' , me ) ; } } 
function ( ) { var me = this ; if ( me . active ) { me . active = null ; me . on Stop ( ) ; me . fire Event ( 'stop ' , me ) ; } } 
function enter ( node , parent ) { if ( ! node . body ) return ; for ( var i = 0 ; i < node . body . length ; i + + ) { 
function parse Comment ( comment , append ) { 
function parse Example Line ( left , right , result ) { if ( ! left | | ! right ) return false ; 
function split Lines ( comment ) { if ( ! comment | | ! ( comment = comment [ 1 ] ) ) return ' ' ; var result = comment . split ( ' \n ' ) , line ; for ( var i in result ) { 
function match Identifier Name ( name ) { var noid = identifier ( ) . replace ( ' [ ' , ' [ ^ ' ) ; noid = ' ( ^ | $ | ' + noid + ' ) ' ; return noid + name + noid ; } 
function ( v , meta , record , row Idx , col Idx , store , view ) { var me = this , prefix = Ext . base CSSPrefix , scope = me . orig Scope | | me , items = me . items , len = items . length , i = 0 , item , ret , disabled , tooltip ; 
function ( index , silent ) { var me = this ; if ( ! index ) { index = 0 ; } else if ( ! Ext . is Number ( index ) ) { index = Ext . Array . index Of ( me . items , index ) ; } me . items [ index ] . disabled = false ; me . up ( 'tablepanel ' ) . el . select ( ' . ' + Ext . base CSSPrefix + 'action -col - ' + index ) . remove Cls ( me . disabled Cls ) ; if ( ! silent ) { me . fire Event ( 'enable ' , me ) ; } } 
function ( index , silent ) { var me = this ; if ( ! index ) { index = 0 ; } else if ( ! Ext . is Number ( index ) ) { index = Ext . Array . index Of ( me . items , index ) ; } me . items [ index ] . disabled = true ; me . up ( 'tablepanel ' ) . el . select ( ' . ' + Ext . base CSSPrefix + 'action -col - ' + index ) . add Cls ( me . disabled Cls ) ; if ( ! silent ) { me . fire Event ( 'disable ' , me ) ; } } 
function ( ) { var me = this , type = me . input Type , input Id = me . get Input Id ( ) , data ; data = Ext . apply ( { id : input Id , cmp Id : me . id , name : me . name | | input Id , disabled : me . disabled , read Only : me . read Only , value : me . get Raw Value ( ) , type : type , field Cls : me . field Cls , field Style : me . get Field Style ( ) , tab Idx : me . tab Index , input Cls : me . input Cls , type Cls : Ext . base CSSPrefix + 'form - ' + ( type = = = 'password ' ? 'text ' : type ) } , me . sub Tpl Data ) ; me . get Insertion Render Data ( data , me . sub Tpl Insertions ) ; return data ; } 
function ( style ) { var me = this , input El = me . input El ; if ( input El ) { input El . apply Styles ( style ) ; } me . field Style = style ; } 
function ( ) { var me = this , data = null , val ; if ( ! me . disabled & & me . submit Value & & ! me . is File Upload ( ) ) { val = me . get Submit Value ( ) ; if ( val ! = = null ) { data = { } ; data [ me . get Name ( ) ] = val ; } } return data ; } 
function ( ) { var me = this , v = ( me . input El ? me . input El . get Value ( ) : Ext . value ( me . raw Value , ' ' ) ) ; me . raw Value = v ; return v ; } 
function ( ) { var me = this , val = me . raw To Value ( me . process Raw Value ( me . get Raw Value ( ) ) ) ; me . value = val ; return val ; } 
function ( value ) { var me = this ; me . set Raw Value ( me . value To Raw ( value ) ) ; return me . mixins . field . set Value . call ( me , value ) ; } 
function ( ) { var me = this , input El = me . input El ; me . call Parent ( ) ; if ( input El ) { input El . dom . disabled = true ; if ( me . has Active Error ( ) ) { 
function ( ) { var me = this , input El = me . input El ; me . call Parent ( ) ; if ( input El ) { input El . dom . disabled = false ; if ( me . needs Validate On Enable ) { delete me . needs Validate On Enable ; 
function ( read Only ) { var me = this , input El = me . input El ; read Only = ! ! read Only ; me [ read Only ? 'add Cls ' : 'remove Cls ' ] ( me . read Only Cls ) ; me . read Only = read Only ; if ( input El ) { input El . dom . read Only = read Only ; } else if ( me . rendering ) { me . set Read Only On Box Ready = true ; } me . fire Event ( 'writeablechange ' , me , read Only ) ; } 
function ( ) { var me = this , input El = me . input El , on Change Task , on Change Event , events = me . check Change Events , e , e Len = events . length , event ; 
function ( ) { var me = this , disabled = me . disabled , validate = me . force Validation | | ! disabled ; return validate ? me . validate Value ( me . process Raw Value ( me . get Raw Value ( ) ) ) : disabled ; } 
function ( value ) { var me = this , errors = me . get Errors ( value ) , is Valid = Ext . is Empty ( errors ) ; if ( ! me . prevent Mark ) { if ( is Valid ) { me . clear Invalid ( ) ; } else { me . mark Invalid ( errors ) ; } } return is Valid ; } 
function ( errors ) { 
function ( active ) { var me = this , msg Target = me . msg Target , prop ; if ( me . rendered ) { if ( msg Target = = 'title ' | | msg Target = = 'qtip ' ) { if ( me . rendered ) { prop = msg Target = = 'qtip ' ? 'data -errorqtip ' : 'title ' ; } me . get Action El ( ) . dom . set Attribute ( prop , active | | ' ' ) ; } else { me . update Layout ( ) ; } } } 
function ( file Path , opts ) { if ( file Path . is Directory ) { return true ; } if ( ! check ( opts ) . has ( 'ignore ' ) | | check ( opts . ignore ) . is . not ( 'array ' ) ) { return false ; } return opts . ignore . some ( function ( directory ) { return _ . is String ( directory ) & & directory = = = file Path . relative | | _ . is Reg Exp ( directory ) & & directory . test ( file Path . relative ) ; } ) ; } 
function ( sorters , direction , where , do Sort ) { var me = this , sorter , new Sorters ; if ( Ext . is Array ( sorters ) ) { do Sort = where ; where = direction ; new Sorters = sorters ; } else if ( Ext . is Object ( sorters ) ) { do Sort = where ; where = direction ; new Sorters = [ sorters ] ; } else if ( Ext . is String ( sorters ) ) { sorter = me . sorters . get ( sorters ) ; if ( ! sorter ) { sorter = { property : sorters , direction : direction } ; new Sorters = [ sorter ] ; } else if ( direction = = = undefined ) { sorter . toggle ( ) ; } else { sorter . set Direction ( direction ) ; } } if ( new Sorters & & new Sorters . length ) { new Sorters = me . decode Sorters ( new Sorters ) ; if ( Ext . is String ( where ) ) { if ( where = = = 'prepend ' ) { me . sorters . insert ( 0 , new Sorters ) ; } else { me . sorters . add All ( new Sorters ) ; } } else { me . sorters . clear ( ) ; me . sorters . add All ( new Sorters ) ; } } if ( do Sort ! = = false ) { me . fire Event ( 'beforesort ' , me , new Sorters ) ; me . on Before Sort ( new Sorters ) ; sorters = me . sorters . items ; if ( sorters . length ) { 
function ( ) { var sorters = this . sorters . items , len = sorters . length , i = 0 , sorter ; for ( ; i < len ; + + i ) { sorter = sorters [ i ] ; if ( ! sorter . is Grouper ) { return sorter ; } } return null ; } 
function ( err ) { err = err | | { } ; if ( Ext . is String ( err ) ) { err = { msg : err } ; } var method = this . raise . caller , msg ; if ( method ) { if ( method . $name ) { err . source Method = method . $name ; } if ( method . $owner ) { err . source Class = method . $owner . $class Name ; } } if ( Ext . Error . handle ( err ) ! = = true ) { msg = Ext . Error . prototype . to String . call ( err ) ; Ext . log ( { msg : msg , level : 'error ' , dump : err , stack : true } ) ; throw new Ext . Error ( err ) ; } } 
function ( ) { var me = this , class Name = me . source Class ? me . source Class : ' ' , method Name = me . source Method ? ' . ' + me . source Method + ' ( ) : ' : ' ' , msg = me . msg | | ' (No description provided ) ' ; return class Name + method Name + msg ; } 
function boolean F ( bindings ) { var value = value Expr ( bindings ) value = ! ! value 
function save Edit ( type Code , id , op , e , sync Id , timestamp ) { _ . assert Number ( timestamp ) _ . assert Int ( op ) if (e .id < 0 ) e .id = translate Temporary (e .id , sync Id ) }else if (op = = = edit Codes .select Sub Object ) { if (e .id < 0 ) e .id = translate Temporary (e .id , sync Id ) }else if (op = = = edit Codes .select Object Key ) { if (e .key < 0 ) e .key = translate Temporary (e .key , sync Id ) } * / if ( current Id ! = = id & & id ! = = - 1 ) { ap . select Top Object ( { id : id } ) 
function get Preview Css ( ed , fmt ) { var name , preview Elm , dom = ed . dom , preview Css = ' ' , parent Font Size , preview Styles Name ; preview Styles = ed . settings . preview _styles ; / / No preview forced if ( preview Styles = = = false ) return ' ' ; / / Default preview if ( ! preview Styles ) preview Styles = 'font -family font -size font -weight text -decoration text -transform color background -color ' ; / / Removes any variables since these can 't be previewed function remove Vars ( val ) { return val . replace ( / % ( \w + ) / g , ' ' ) ; } ; / / Create block /inline element to use for preview name = fmt . block | | fmt . inline | | 'span ' ; preview Elm = dom . create ( name ) ; / / Add format styles to preview element each ( fmt . styles , function ( value , name ) { value = remove Vars ( value ) ; if ( value ) dom . set Style ( preview Elm , name , value ) ; } ) ; / / Add attributes to preview element each ( fmt . attributes , function ( value , name ) { value = remove Vars ( value ) ; if ( value ) dom . set Attrib ( preview Elm , name , value ) ; } ) ; / / Add classes to preview element each ( fmt . classes , function ( value ) { value = remove Vars ( value ) ; if ( ! dom . has Class ( preview Elm , value ) ) dom . add Class ( preview Elm , value ) ; } ) ; / / Add the preview Elm outside the visual area dom . set Styles ( preview Elm , { position : 'absolute ' , left : - 0x FFFF } ) ; ed . get Body ( ) . append Child ( preview Elm ) ; / / Get parent container font size so we can compute px values out of em / % for older IE :s parent Font Size = dom . get Style ( ed . get Body ( ) , 'font Size ' , true ) ; parent Font Size = / px $ / . test ( parent Font Size ) ? parse Int ( parent Font Size , 1 0 ) : 0 ; each ( preview Styles . split ( ' ' ) , function ( name ) { var value = dom . get Style ( preview Elm , name , true ) ; / / If background is transparent then check if the body has a background color we can use if ( name = = 'background -color ' & & / transparent |rgba \s * \ ( [ ^ ) ] + , \s * 0 \ ) / . test ( value ) ) { value = dom . get Style ( ed . get Body ( ) , name , true ) ; / / Ignore white since it 's the default color , not the nicest fix if ( dom . to Hex ( value ) . to Lower Case ( ) = = ' #ffffff ' ) { return ; } } / / Old IE won 't calculate the font size so we need to do that manually if ( name = = 'font -size ' ) { if ( / em | % $ / . test ( value ) ) { if ( parent Font Size = = = 0 ) { return ; } / / Convert font size from em / % to px value = parse Float ( value , 1 0 ) / ( / % $ / . test ( value ) ? 1 0 0 : 1 ) ; value = ( value * parent Font Size ) + 'px ' ; } } preview Css + = name + ' : ' + value + ' ; ' ; } ) ; dom . remove ( preview Elm ) ; return preview Css ; } 
function ( s , tb , o , p ) { var t = this , ed = t . editor , lo = s . theme _advanced _toolbar _location , sl = s . theme _advanced _statusbar _location , n , ic , etb , c ; if ( s . readonly ) { n = DOM . add ( tb , 'tr ' ) ; n = ic = DOM . add ( n , 'td ' , { 'class ' : 'mce Iframe Container ' } ) ; return ic ; } / / Create toolbar container at top if ( lo = = 'top ' ) t . _add Toolbars ( tb , o ) ; / / Create external toolbar if ( lo = = 'external ' ) { n = c = DOM . create ( 'div ' , { style : 'position :relative ' } ) ; n = DOM . add ( n , 'div ' , { id : ed . id + ' _external ' , 'class ' : 'mce External Toolbar ' } ) ; DOM . add ( n , 'a ' , { id : ed . id + ' _external _close ' , href : 'javascript : ; ' , 'class ' : 'mce External Close ' } ) ; n = DOM . add ( n , 'table ' , { id : ed . id + ' _tblext ' , cell Spacing : 0 , cell Padding : 0 } ) ; etb = DOM . add ( n , 'tbody ' ) ; if ( p . first Child . class Name = = 'mce Old Box Model ' ) p . first Child . append Child ( c ) ; else p . insert Before ( c , p . first Child ) ; t . _add Toolbars ( etb , o ) ; ed . on Mouse Up . add ( function ( ) { var e = DOM . get ( ed . id + ' _external ' ) ; DOM . show ( e ) ; DOM . hide ( last Ext ID ) ; var f = Event . add ( ed . id + ' _external _close ' , 'click ' , function ( ) { DOM . hide ( ed . id + ' _external ' ) ; Event . remove ( ed . id + ' _external _close ' , 'click ' , f ) ; return false ; } ) ; DOM . show ( e ) ; DOM . set Style ( e , 'top ' , 0 - DOM . get Rect ( ed . id + ' _tblext ' ) . h - 1 ) ; / / Fixes IE rendering bug DOM . hide ( e ) ; DOM . show ( e ) ; e . style . filter = ' ' ; last Ext ID = ed . id + ' _external ' ; e = null ; } ) ; } if ( sl = = 'top ' ) t . _add Status Bar ( tb , o ) ; / / Create iframe container if ( ! s . theme _advanced _toolbar _container ) { n = DOM . add ( tb , 'tr ' ) ; n = ic = DOM . add ( n , 'td ' , { 'class ' : 'mce Iframe Container ' } ) ; } / / Create toolbar container at bottom if ( lo = = 'bottom ' ) t . _add Toolbars ( tb , o ) ; if ( sl = = 'bottom ' ) t . _add Status Bar ( tb , o ) ; return ic ; } 
function HTTPError ( ) { var args = Array . prototype . slice . call ( arguments ) ; if ( ! ( this instanceof HTTPError ) ) { var self = new HTTPError ( ) ; return FUNCTION ( self ) . apply ( self , args ) ; } var headers , msg , code ; ARRAY ( args ) . for Each ( function HTTPError _foreach ( arg ) { if ( typeof arg = = = 'object ' ) { headers = arg ; } if ( typeof arg = = = 'string ' ) { msg = arg ; } if ( typeof arg = = = 'number ' ) { code = arg ; } } ) ; code = code | | 5 0 0 ; msg = msg | | ( ' ' + code + ' ' + require ( 'http ' ) . STATUS _CODES [ code ] ) ; headers = headers | | { } ; Error . call ( this ) ; Error . capture Stack Trace ( this , this ) ; this . code = code ; this . message = msg ; this . headers = headers ; } 
function ( ) { var me = this , strategies = me . label Strategies , label Align = me . owner . label Align ; return strategies [ label Align ] | | strategies . base ; } 
function ( ) { var me = this , owner = me . owner , strategies = me . error Strategies , msg Target = owner . msg Target ; return ! owner . prevent Mark & & Ext . is String ( msg Target ) ? ( strategies [ msg Target ] | | strategies . element Id ) : strategies . none ; } 
function ( ) { var tip = this . tip ; if ( ! tip ) { tip = this . tip = Ext . create ( 'Ext .tip .Quick Tip ' , { ui : 'form -invalid ' } ) ; tip . tag Config = Ext . apply ( { } , { attribute : 'errorqtip ' } , tip . tag Config ) ; } } 
function ( ) { var doc = me . get Doc ( ) ; if ( doc . body | | doc . ready State = = = 'complete ' ) { Ext . Task Manager . stop ( task ) ; me . set Design Mode ( true ) ; Ext . defer ( me . init Editor , 1 0 , me ) ; } } 
function ( source Edit Mode ) { var me = this , iframe = me . iframe El , textarea = me . textarea El , hidden Cls = Ext . base CSSPrefix + 'hidden ' , btn = me . get Toolbar ( ) . get Component ( 'sourceedit ' ) ; if ( ! Ext . is Boolean ( source Edit Mode ) ) { source Edit Mode = ! me . source Edit Mode ; } me . source Edit Mode = source Edit Mode ; if ( btn . pressed ! = = source Edit Mode ) { btn . toggle ( source Edit Mode ) ; } if ( source Edit Mode ) { me . disable Items ( true ) ; me . sync Value ( ) ; iframe . add Cls ( hidden Cls ) ; textarea . remove Cls ( hidden Cls ) ; textarea . dom . remove Attribute ( 'tab Index ' ) ; textarea . focus ( ) ; me . input El = textarea ; } else { if ( me . initialized ) { me . disable Items ( me . read Only ) ; } me . push Value ( ) ; iframe . remove Cls ( hidden Cls ) ; textarea . add Cls ( hidden Cls ) ; textarea . dom . set Attribute ( 'tab Index ' , - 1 ) ; me . defer Focus ( ) ; me . input El = iframe ; } me . fire Event ( 'editmodechange ' , me , source Edit Mode ) ; me . update Layout ( ) ; } 
function ( ) { var me = this , i , l , btns , doc , name , queried Name , font Select , toolbar Submenus ; if ( me . read Only ) { return ; } if ( ! me . activated ) { me . on First Focus ( ) ; return ; } btns = me . get Toolbar ( ) . items . map ; doc = me . get Doc ( ) ; if ( me . enable Font & & ! Ext . is Safari 2 ) { 
function ( cmd , value ) { Ext . defer ( function ( ) { var me = this ; if ( ! this . is Destroyed ) { me . win . focus ( ) ; me . exec Cmd ( cmd , value ) ; me . update Toolbar ( ) ; } } , 1 0 , this ) ; } 
function ( cmd , value ) { var me = this , doc = me . get Doc ( ) ; doc . exec Command ( cmd , false , ( value = = undefined ? null : value ) ) ; me . sync Value ( ) ; } 
function ( text ) { var me = this , range ; if ( me . activated ) { me . win . focus ( ) ; if ( Ext . is IE ) { range = me . get Doc ( ) . selection . create Range ( ) ; if ( range ) { range . paste HTML ( text ) ; me . sync Value ( ) ; me . defer Focus ( ) ; } } else { me . exec Cmd ( 'Insert HTML ' , text ) ; me . defer Focus ( ) ; } } } 
function get Level Str ( opts ) { var lvl Str = _ . invert ( LEVELS ) [ opts . level ] , use Colours = opts . colourise | | true ; if ( use Colours ) { switch ( opts . level ) { case LEVELS . DBG : lvl Str = colours . magenta ( lvl Str ) ; break ; case LEVELS . INF : lvl Str = colours . green ( lvl Str ) ; break ; case LEVELS . WRN : lvl Str = colours . yellow ( lvl Str ) ; break ; case LEVELS . ERR : lvl Str = colours . red ( lvl Str ) ; break ; } } return lvl Str ; } 
function ( input ) { this . reset ( ) ; 
function ( type ) { var ctl = { type : type } ; var idx = this . form . controls . length ; var id = this . form . signature + ' : ' + idx ; ctl . id = 'c - ' + utils . sha 2 5 6 ( id ) . substring ( 0 , 8 ) ; this . form . controls . push ( ctl ) ; return ctl ; } 
function ( ctl ) { var len = ctl . items & & ctl . items . length ; return utils . sha 2 5 6 ( ctl . id + ' : ' + len ) . substring ( 0 , 8 ) ; } 
function ( attrs ) { for ( var k in attrs ) if ( attrs . has Own Property ( k ) ) this . out . push ( ' ' + k + ' = " ' + attrs [ k ] + ' " ' ) ; } 
function ( walk ) { var _super = Block Compiler . prototype . emit Paragraph . bind ( this ) ; if ( this . try Group ( 'checkbox ' , walk ) ) return ; if ( this . try Group ( 'radio ' , walk ) ) return ; if ( this . try Sortable Group ( walk ) ) return ; if ( this . try Associative Group ( walk ) ) return ; return _super ( walk ) ; } 
function ( type , walk ) { if ( ! this . at Group Marker ( type , walk ) ) return false ; 
function ( type , walk ) { var ctl = this . create Ctl ( type + 'Group ' ) ; ctl . items = [ ] ; 
function ( walk ) { if ( ! walk . at ( ' ^ ' ) ) return false ; 
function ( walk ) { var ctl = this . create Ctl ( 'sortable Group ' ) ; ctl . items = [ ] ; 
function ( walk ) { if ( ! walk . at ( ' @ ' ) ) return false ; 
function ( walk ) { var i , item ; var ctl = this . create Ctl ( 'associative Group ' ) ; ctl . items = [ ] ; 
function ( walk ) { if ( this . emit Text ( walk ) ) return ; if ( this . try Input Text ( walk ) ) return ; if ( this . try Input Regex ( walk ) ) return ; if ( this . try Input Text With Default ( walk ) ) return ; if ( this . try Select Menu ( walk ) ) return ; var _super = Inline Compiler . prototype . emit Normal . bind ( this ) ; return _super ( walk ) ; } 
function ( walk ) { if ( ! walk . at ( ' { { ' ) ) return false ; var end Idx = walk . index Of ( ' } } ' ) ; if ( end Idx = = = null ) return false ; 
function ( walk ) { if ( ! walk . at ( ' { { ' ) ) return false ; var end Idx = walk . index Of ( ' ] } ' ) ; if ( end Idx = = = null ) return false ; var str = walk . substring ( walk . position + 2 , end Idx ) ; var data = str . split ( ' } [ ' ) ; if ( data . length ! = 2 ) return false ; var size = data [ 0 ] . length ; var value = data [ 0 ] . trim ( ) ; var default Value = data [ 1 ] . trim ( ) ; if ( ! default Value ) return false ; var ctl = this . form Compiler . create Ctl ( 'input Text ' ) ; ctl . value = value ; ctl . default Value = default Value ; this . out . push ( ' <input ' ) ; this . emit Attrs ( { id : ctl . id , name : ctl . id , class : ctl . type , type : 'text ' , size : size , value : default Value } ) ; this . out . push ( ' / > ' ) ; walk . start From ( end Idx ) . skip ( 2 ) ; } 
function ( walk ) { if ( ! walk . at ( ' { / ' ) ) return false ; var end Idx = walk . index Of ( ' } ' ) ; if ( end Idx = = = null ) return false ; var source = walk . substring ( walk . position , end Idx + 1 ) ; 
function ( walk ) { if ( ! walk . at ( ' ( { ' ) ) return false ; var end Idx = walk . index Of ( ' } ) ' ) ; if ( end Idx = = = null ) return false ; 
function ( ) { 
function ( ) { var values = this . get Value ( ) , key ; for ( key in values ) { if ( values [ key ] ! = = undefined ) { return true ; } } return false ; } 
function ( record ) { var val = record . get ( this . data Index ) , values = this . get Value ( ) , is Number = Ext . is Number ; if ( is Number ( values . eq ) & & val ! = values . eq ) { return false ; } if ( is Number ( values . lt ) & & val > = values . lt ) { return false ; } if ( is Number ( values . gt ) & & val < = values . gt ) { return false ; } return true ; } 
function ( ) { var right = this . status Align = = = 'right ' ; this . call Parent ( arguments ) ; this . curr Icon Cls = this . icon Cls | | this . default Icon Cls ; this . status El = Ext . create ( 'Ext .toolbar .Text Item ' , { cls : 'x -status -text ' + ( this . curr Icon Cls | | ' ' ) , text : this . text | | this . default Text | | ' ' } ) ; if ( right ) { this . cls + = ' x -status -right ' ; this . add ( ' - > ' ) ; this . add ( this . status El ) ; } else { this . insert ( 0 , this . status El ) ; this . insert ( 1 , ' - > ' ) ; } } 
function ( o ) { var me = this ; o = o | | { } ; Ext . suspend Layouts ( ) ; if ( Ext . is String ( o ) ) { o = { text : o } ; } if ( o . text ! = = undefined ) { me . set Text ( o . text ) ; } if ( o . icon Cls ! = = undefined ) { me . set Icon ( o . icon Cls ) ; } if ( o . clear ) { var c = o . clear , wait = me . auto Clear , defaults = { use Defaults : true , anim : true } ; if ( Ext . is Object ( c ) ) { c = Ext . apply If ( c , defaults ) ; if ( c . wait ) { wait = c . wait ; } } else if ( Ext . is Number ( c ) ) { wait = c ; c = defaults ; } else if ( Ext . is Boolean ( c ) ) { c = defaults ; } c . thread Id = this . active Thread Id ; Ext . defer ( me . clear Status , wait , me , [ c ] ) ; } Ext . resume Layouts ( true ) ; return me ; } 
function ( o ) { o = o | | { } ; var me = this , status El = me . status El ; if ( o . thread Id & & o . thread Id ! = = me . active Thread Id ) { 
function ( text ) { var me = this ; me . active Thread Id + + ; me . text = text | | ' ' ; if ( me . rendered ) { me . status El . set Text ( me . text ) ; } return me ; } 
function ( cls ) { var me = this ; me . active Thread Id + + ; cls = cls | | ' ' ; if ( me . rendered ) { if ( me . curr Icon Cls ) { me . status El . remove Cls ( me . curr Icon Cls ) ; me . curr Icon Cls = null ; } if ( cls . length > 0 ) { me . status El . add Cls ( cls ) ; me . curr Icon Cls = cls ; } } else { me . curr Icon Cls = cls ; } return me ; } 
function ( o ) { if ( Ext . is String ( o ) ) { o = { text : o } ; } o = Ext . apply If ( o | | { } , { text : this . busy Text , icon Cls : this . busy Icon Cls } ) ; return this . set Status ( o ) ; } 
function trailer ( file , fn ) { return through ( { object Mode : true } , function ( a , e , cb ) { this . push ( a ) cb ( ) } , function ( cb ) { var self = this fn ( function ( err , val ) { if ( err ) { return cb ( err ) } if ( val ) { if ( typeof val = = = 'string ' ) { val = new Buffer ( string ) } var f = new File ( { path : file , contents : val } ) self . push ( f ) } cb ( ) } ) } ) } 
function is Color ( value , mode ) { if ( ! is String ( value ) ) { return false ; } if ( arguments . length = = = 1 | | mode = = = 'full ' ) { return re . test ( value ) ; } if ( mode = = = 'shorthand ' ) { return re . shorthand . test ( value ) ; } if ( mode = = = 'either ' ) { return re . either . test ( value ) ; } throw new Type Error ( 'invalid input argument . Unrecognized /unsupported validation mode . Value : ` ' + mode + ' ` . ' ) ; } 
function ( ) { var fw , ix = 0 ; / / Find front most window and focus that each ( this . windows , function ( w ) { if ( w . z Index > ix ) { fw = w ; ix = w . z Index ; } } ) ; return fw ; } 
function ( w ) { var t = this ; if ( typeof ( w ) = = 'string ' ) return w ; each ( t . windows , function ( wo ) { var ifr = DOM . get ( wo . id + ' _ifr ' ) ; if ( ifr & & w = = ifr . content Window ) { w = wo . id ; return false ; } } ) ; return w ; } 
function ( ) { var me = this , mon = me . monitor ; if ( mon ) { mon . unbind ( ) ; me . monitor = null ; } me . clear Listeners ( ) ; me . check Validity Task . cancel ( ) ; me . check Dirty Task . cancel ( ) ; } 
function ( ) { return ! ! this . get Fields ( ) . find By ( function ( field ) { var prevent Mark = field . prevent Mark , is Valid ; field . prevent Mark = true ; is Valid = field . is Valid ( ) ; field . prevent Mark = prevent Mark ; return ! is Valid ; } ) ; } 
function ( ) { var me = this , invalid ; Ext . suspend Layouts ( ) ; invalid = me . get Fields ( ) . filter By ( function ( field ) { return ! field . validate ( ) ; } ) ; Ext . resume Layouts ( true ) ; return invalid . length < 1 ; } 
function ( ) { var me = this , valid = ! me . has Invalid Field ( ) ; if ( valid ! = = me . was Valid ) { me . on Validity Change ( valid ) ; me . fire Event ( 'validitychange ' , me , valid ) ; me . was Valid = valid ; } } 
function ( action , options ) { if ( Ext . is String ( action ) ) { action = Ext . Class Manager . instantiate By Alias ( 'formaction . ' + action , Ext . apply ( { } , options , { form : this } ) ) ; } if ( this . fire Event ( 'beforeaction ' , this , action ) ! = = false ) { this . before Action ( action ) ; Ext . defer ( action . run , 1 0 0 , action ) ; } return this ; } 
function ( options ) { options = options | | { } ; var me = this , action ; if ( options . standard Submit | | me . standard Submit ) { action = 'standardsubmit ' ; } else { action = me . api ? 'directsubmit ' : 'submit ' ; } return me . do Action ( action , options ) ; } 
function ( id ) { return this . get Fields ( ) . find By ( function ( f ) { return f . id = = = id | | f . get Name ( ) = = = id ; } ) ; } 
function ( errors ) { var me = this , e , e Len , error , value , key ; function mark ( field Id , msg ) { var field = me . find Field ( field Id ) ; if ( field ) { field . mark Invalid ( msg ) ; } } if ( Ext . is Array ( errors ) ) { e Len = errors . length ; for ( e = 0 ; e < e Len ; e + + ) { error = errors [ e ] ; mark ( error . id , error . msg ) ; } } else if ( errors instanceof Ext . data . Errors ) { e Len = errors . items . length ; for ( e = 0 ; e < e Len ; e + + ) { error = errors . items [ e ] ; mark ( error . field , error . message ) ; } } else { for ( key in errors ) { if ( errors . has Own Property ( key ) ) { value = errors [ key ] ; mark ( key , value , errors ) ; } } } return this ; } 
function ( values ) { var me = this , v , v Len , val , field ; function set Val ( field Id , val ) { var field = me . find Field ( field Id ) ; if ( field ) { field . set Value ( val ) ; if ( me . track Reset On Load ) { field . reset Original Value ( ) ; } } } 
function ( as String , dirty Only , include Empty Text , use Data Values ) { var values = { } , fields = this . get Fields ( ) . items , f , f Len = fields . length , is Array = Ext . is Array , field , data , val , bucket , name ; for ( f = 0 ; f < f Len ; f + + ) { field = fields [ f ] ; if ( ! dirty Only | | field . is Dirty ( ) ) { data = field [ use Data Values ? 'get Model Data ' : 'get Submit Data ' ] ( include Empty Text ) ; if ( Ext . is Object ( data ) ) { for ( name in data ) { if ( data . has Own Property ( name ) ) { val = data [ name ] ; if ( include Empty Text & & val = = = ' ' ) { val = field . empty Text | | ' ' ; } if ( values . has Own Property ( name ) ) { bucket = values [ name ] ; if ( ! is Array ( bucket ) ) { bucket = values [ name ] = [ bucket ] ; } if ( is Array ( val ) ) { values [ name ] = bucket . concat ( val ) ; } else { bucket . push ( val ) ; } } else { values [ name ] = val ; } } } } } } if ( as String ) { values = Ext . Object . to Query String ( values ) ; } return values ; } 
function ( ) { Ext . suspend Layouts ( ) ; var me = this , fields = me . get Fields ( ) . items , f , f Len = fields . length ; for ( f = 0 ; f < f Len ; f + + ) { fields [ f ] . clear Invalid ( ) ; } Ext . resume Layouts ( true ) ; return me ; } 
function ( reset Record ) { Ext . suspend Layouts ( ) ; var me = this , fields = me . get Fields ( ) . items , f , f Len = fields . length ; for ( f = 0 ; f < f Len ; f + + ) { fields [ f ] . reset ( ) ; } Ext . resume Layouts ( true ) ; if ( reset Record = = = true ) { delete me . _record ; } return me ; } 
function ( obj ) { var fields = this . get Fields ( ) . items , f , f Len = fields . length ; for ( f = 0 ; f < f Len ; f + + ) { Ext . apply ( fields [ f ] , obj ) ; } return this ; } 
function ( ) { var me = this , model = ( this . model | | this . get Controller Name ( ) . replace ( ' .controller . ' , ' .model . ' ) ) Core . Ajax . request ( { url : 'models .access :check Access 2Model / / ' + model + ' / ' , succ : function ( r ) { me . access Rights = r me . set Access Controls ( r , me . main Win ) } } ) } 
function ( rights ) { var me = this , o if ( rights & & me . main Win ) { if ( ! rights . add ) { o = me . main Win . down ( " [action =add ] " ) if ( o ) o . owner Ct . remove ( o ) o = me . main Win . down ( " [action =formapply ] " ) if ( o ) o . owner Ct . remove ( o ) o = me . main Win . down ( " [action =formsave ] " ) if ( o ) o . owner Ct . remove ( o ) } if ( ! rights . del ) { o = me . main Win . down ( " [action =remove ] " ) if ( o ) o . owner Ct . remove ( o ) } } } 
function ( status , msg ) { var delay = 3 ; 
function ( title , msg ) { switch ( title ) { case true : title = this . STATUS _OK ; break ; case false : title = this . STATUS _ERROR ; break ; } return [ ' <div class = "app -msg " > ' , ' <div class = "x -box -tl " > <div class = "x -box -tr " > <div class = "x -box -tc " > < /div > < /div > < /div > ' , ' <div class = "x -box -ml " > <div class = "x -box -mr " > <div class = "x -box -mc " > <h 3 class = "x -icon -text icon -status - ' + title + ' " > ' , title , ' < /h 3 > ' , msg , ' < /div > < /div > < /div > ' , ' <div class = "x -box -bl " > <div class = "x -box -br " > <div class = "x -box -bc " > < /div > < /div > < /div > ' , ' < /div > ' ] . join ( ' ' ) ; } 
function ( status ) { var icon Cls = ' ' ; switch ( status ) { case true : case this . STATUS _OK : icon Cls = this . ICON _OK ; break ; case this . STATUS _NOTICE : icon Cls = this . ICON _NOTICE ; break ; case false : case this . STATUS _ERROR : icon Cls = this . ICON _ERROR ; break ; case this . STATUS _HELP : icon Cls = this . ICON _HELP ; break ; } return icon Cls ; } 
function get Info Sync ( dir ) { var fullname = path . join ( dir , ' .epm /CONFIG ' ) ; if ( ! fs . exists Sync ( fullname ) ) { return { name : 'unknown ' , engine : 'unknown ' , path : dir } ; } var info = JSON . parse ( fs . read File Sync ( fullname , 'utf - 8 ' ) ) ; return { name : info . name | | 'unknown ' , engine : info . engine | | 'unknown ' , path : dir } ; } 
function get Directories ( dir , cb ) { fs . readdir ( dir , function ( err , objects ) { if ( err ) { return cb & & cb ( err ) ; } var dirs = objects . filter ( function ( item ) { return fs . stat Sync ( path . join ( dir , item ) ) . is Directory ( ) ; } ) ; cb & & cb ( null , dirs ) } ) } 
function get Directories Sync ( dir ) { return fs . readdir Sync ( dir ) . filter ( function ( item ) { return fs . stat Sync ( path . join ( dir , item ) ) . is Directory ( ) ; } ) ; } 
function is Repo Sync ( dir ) { var dirs if ( dir instanceof Array ) { dirs = dir } else { dirs = get Directories Sync ( dir ) } var res = dirs . filter ( function ( name ) { return name . match ( / \ .epm / ig ) } ) ; return res . length > 0 ; } 
function handle Resolution ( resolution ) { var pieces = resolution . split ( / [ :x ] + / ) , width = pieces [ 0 ] , height = pieces [ 1 ] ; 
function hook ( filter , fn , args ) { var tasty = this ; tasty . hooks . set ( filter , function ( result ) { return tasty . utils . thenable ( fn . apply ( tasty , args ) ) . then ( function ( ) { return result ; } ) ; } ) ; } 
function ready ( period , filter ) { var tasty = this ; tasty . hooks . set ( filter , function delay ( result ) { return tasty . utils . delay ( period , result ) ; } , 'ready :delay ' + period ) ; } 
function ready ( period , filter ) { var tasty = this ; tasty . hooks . set ( filter , function ( result ) { return tasty . utils . thenable ( / / eslint -disable -next -line no -undef document . ready State = = = 'interactive ' | | / / eslint -disable -next -line no -undef document . ready State = = = 'complete ' ? result : function ( resolve ) { / / eslint -disable -next -line no -undef tasty . dom . on ( document , 'DOMContent Loaded ' , resolve ) ; / / eslint -disable -next -line no -undef tasty . dom . on ( document , 'readystatechage ' , function ( ) { / / eslint -disable -next -line no -undef ( document . ready State = = = 'interactive ' | | / / eslint -disable -next -line no -undef document . ready State = = = 'complete ' ) & & resolve ( ) ; } ) ; } ) . then ( function ( ) { return period ? tasty . utils . delay ( period , result ) : result ; } ) ; } , period ? 'ready :document ' + period : 'ready :document ' ) ; } 
function ready ( fn , filter ) { var tasty = this ; tasty . hooks . set ( filter , function ( result ) { return tasty . utils . thenable ( fn . call ( tasty ) ) . then ( function ( ) { return result ; } ) ; } , 'ready :exec ' ) ; } 
function ready ( fn , period , filter ) { var tasty = this ; tasty . hooks . set ( filter , function ( result ) { return tasty . utils . thenable ( function ( resolve ) { var interval = set Interval ( function ( ) { if ( fn . call ( tasty ) ) { clear Interval ( interval ) ; resolve ( result ) ; } } , period ) ; } ) ; } , 'ready :until ' + period ) ; } 
function ready ( period , filter ) { var tasty = this ; tasty . hooks . set ( filter , function ( result ) { return tasty . utils . thenable ( / / eslint -disable -next -line no -undef document . ready State = = = 'complete ' ? result : function ( resolve ) { / / eslint -disable -next -line no -undef tasty . dom . on ( window , 'load ' , resolve ) ; } ) . then ( function ( ) { return period ? tasty . utils . delay ( period , result ) : result ; } ) ; } , period ? 'ready :window ' + period : 'ready :window ' ) ; } 
function Status Error ( status , message ) { if ( ! message ) { message = http . STATUS _CODES [ status ] | | http . STATUS _CODES [ ' 5 0 0 ' ] ; } this . message = message ; this . status = status ; this . name = "Status Error " ; Error . capture Stack Trace ( this , Status Error ) ; } 
function ( parent , records , suppress Event ) { var me = this , insert Index = me . index Of ( parent ) + 1 , to Add = [ ] ; 
function ( parent , records , to Add ) { var me = this , ln = records ? records . length : 0 , i , record ; 
function ( parent , records , suppress Event , callback , scope ) { var me = this , collapse Index = me . index Of ( parent ) + 1 , node , last Node Index Plus , sibling , found ; if ( ! me . recursive & & parent ! = = me . node ) { return ; } 
function inline And Compile ( filenames , options , reporter , callback , errback ) { var dep Target = options & & options . dep Target ; var referrer Name = options & & options . referrer ; var base Path ; if ( referrer Name ) { 
function on Host Render ( ) { var e = this . is XType ( 'panel ' ) ? this . body : this . el ; if ( this . data Tip . render To Target ) { this . data Tip . render ( e ) ; } this . data Tip . set Target ( e ) ; } 
function Simple ( ) { 
function ( ) { var me = this , ret = { min Width : 2 0 , width : Ext . theme Name = = = 'neptune ' ? 7 0 : 6 0 , items : [ ] , enable Overflow : true } ; Ext . each ( this . quick Start , function ( item ) { ret . items . push ( { tooltip : { text : item . name , align : 'bl -tl ' } , 
function init ( tag , attrs , params ) { * HTML Element wrapper constructor . * * @todo * Templates must have single root . * * @param tag {String |Object } Tag or element to be wrapped or created * @param [attrs ] {String |Object } Attributes of element , supplied string is used as element class * @param [params ] {String |Object } Parameters of element wrapper , string is used as `element .text Content ` * * @method constructor * / switch ( typeof ( tag | | undefined ) ) { case 'string ' : if ( tag . char At ( 0 ) = = = ' < ' ) { var t = document . create Element ( 'template ' ) ; t . inner HTML = tag ; this . el = document . adopt Node ( t . content ) . first Element Child ; break ; } if ( tag in exports . controls ) { this . control = exports . controls [ tag ] ; if ( this . control . template ) { this . el = document . import Node ( this . control . template . content , true ) . first Element Child ; } else { this . el = document . create Element ( tag ) ; } this . el . ose = this ; break ; } this . el = document . create Element ( tag ) ; break ; case 'object ' : if ( typeof tag . tag Name = = = 'string ' ) { if ( tag . tag Name = = = 'TEMPLATE ' ) { this . el = document . adopt Node ( tag . content ) . first Element Child ; break ; } this . el = tag ; break ; } 
function listen Removed ( el , cb ) { * Element wrappers that has `wrap . _removed = function ( ) { . . . } ` method defined must be removed by calling `wrap .remove ( ) ` * / while ( el ) { if ( el . ose & & el . ose . _removed ) { if ( ' _on _removed ' in el . ose ) { el . ose . _on _removed . push ( cb ) ; return ; } el . ose . _on _removed = [ cb ] ; return ; } el = el . parent Node ; } set Timeout ( function ( ) { if ( ! el . parent Node ) { throw O . log . error ( 'Can \ 't listen to "removed " event on orphaned child ' ) ; } listen Removed ( el , cb ) ; } ) ; } 
function apply Each Optimization ( rel ) { var original Rel = rel rel = JSON . parse ( JSON . stringify ( rel ) ) 
function get Loader Uri ( loader Id ) { var json = get Res ( loader Id ) ; if ( json . pkg ) { json = get Pkg ( json . pkg ) ; } return json . uri ; } 
function get Route ( id ) { if ( id . index Of ( ' : ' ) > - 1 ) { var arr = id . split ( ' : ' ) ; var prefix = arr [ 0 ] ; if ( prefix . index Of ( ' / ' ) > - 1 ) { return prefix ; } else { return config . base Name + ' / ' + prefix ; } } else { 
function get Map ( id ) { var route = get Route ( id ) ; var cache = json Cache [ route ] ; if ( ! cache ) { var file Path = path . join ( root , route , 'map .json ' ) ; try { cache = json Cache [ route ] = JSON . parse ( fs . read File Sync ( file Path ) ) ; } catch ( e ) { throw e ; } } return cache ; } 
function get Res ( id ) { var file Json = get Map ( id ) ; var all Res = file Json . res ; if ( ! all Res . has Own Property ( id ) ) { if ( error Ids . index Of ( id ) = = - 1 ) { error Ids . unshift ( id ) ; } } return all Res [ id ] | | { } ; } 
function get Pkg ( pkg Id ) { var file Json = get Map ( pkg Id ) ; var all Pkg = file Json . pkg ; return all Pkg [ pkg Id ] | | { } } 
function get Async ( id ) { var res = get Res ( id ) ; if ( res . extras & & res . extras . async ) { return res . extras . async ; } return [ ] ; } 
function get Uri ( id ) { var res = get Res ( id ) ; if ( res . pkg ) { return get Pkg ( res . pkg ) . uri ; } else { return res . uri ; } } 
function push Js Data ( ) { var css Arr = [ ] ; for ( var i in uris ) { var data = uris [ i ] ; var type = data . type ; if ( type = = = 'js ' ) { if ( data . uri ! = = loader Uri ) { json Data . js . push ( data . uri ) ; } else { json Data . loader = data . uri ; } } else if ( type = = = 'css ' ) { css Arr . push ( data ) ; } } uris = css Arr ; } 
function push Css Data ( ) { for ( var i in uris ) { var data = uris [ i ] ; var type = data . type ; if ( type = = = 'css ' ) { json Data . css . push ( data . uri ) ; } } } 
function make Sync Op Generic Get Changes Between ( handle , ws , rel , recurse , param Funcs ) { 
function make State Validator ( type ) { if ( type . type = = = 'set ' | | type . type = = = 'list ' ) { return function ( s ) { _ . assert Array ( s ) return s } } else if ( type . type = = = 'map ' ) { return function ( m ) { if ( m = = = undefined ) return { } _ . assert Object ( m ) return m } } else if ( type . type = = = 'primitive ' ) { return function ( v ) { _ . assert Primitive ( v ) return v } } else if ( type . type = = = 'object ' ) { return function ( id ) { _ . assert Not ( _ . is Array ( id ) ) return id } } else if ( type . type = = = 'view ' ) { return function ( id ) { _ . assert Not ( _ . is Array ( id ) ) if ( id ! = = undefined ) _ . assert String ( id ) return id } } else if ( type . type = = = 'nil ' ) { return function ( n ) { return n } } else { _ . errout ( 'TODO : ' + JSON . stringify ( type ) ) } } 
function Queue ( cache , ttl ) { this . cache = cache | | memory ( ) ; this . fn _cache = Fn Cache ( ) ; this . queue = Queue Entry ( this . fn _cache , this . cache ) ; this . ttl = ttl ; this . semaphore = Semaphore ( ) ; } 
function ( key , task , done , ttl ) { const queue = this . queue ; const semaphore = this . semaphore ; if ( ! ttl ) ttl = this . ttl ; const run Task = ( res ) = > new Promise ( ( resolve ) = > task ( ( . . . args ) = > resolve ( Response . set Data ( res , args ) ) ) ) ; const start Then Run Task = ( lock _key ) = > queue . start ( key , Response . factory ( ttl ) ) . then ( run Task ) . then ( queue . dequeue . bind ( null , key ) ) . then ( ( ) = > semaphore . release ( key , lock _key ) ) . catch ( ( err ) = > { semaphore . release ( key , lock _key ) ; throw err ; } ) ; const start If Not Waiting = ( ) = > Promise . all ( [ queue . is Waiting ( key ) , semaphore . lock ( key ) ] ) . then ( ( [ is _waiting , lock _key ] ) = > ( ! is _waiting & & lock _key ) ? start Then Run Task ( lock _key ) : null ) return queue . add ( key , done ) . then ( start If Not Waiting ) ; } 
function json _sender ( data , req , res , next ) { debug . assert ( data ) . is ( 'object ' ) ; debug . assert ( req ) . is ( 'object ' ) ; debug . assert ( res ) . is ( 'object ' ) ; debug . assert ( next ) . is ( 'function ' ) ; var content ; if ( req . headers [ 'x -pretty -print ' ] | | req . headers [ 'x -pretty -json ' ] ) { content = JSON . stringify ( data , null , 2 ) ; } else { content = JSON . stringify ( data ) ; } if ( content ) { 
function init ( view , entry ) { * Socket constructor * * @param view {Object } View * @param entry {Object } Entry * * @method constructor * / this . view = view ; view . socket = this ; if ( entry ) { return entry . track ( this ) ; } return O . data . track Entry ( view . demand . ident , this ) ; } 
function Iterator ( options , fn ) { if ( typeof options = = = 'function ' ) { fn = options ; options = { } ; } if ( typeof fn ! = = 'function ' ) { throw new Type Error ( 'Iterator expects `fn ` to be a function . ' ) ; } this . options = options | | { } ; this . fn = fn ; } 
function ( text , mode ) { this . $modified = true ; this . $breakpoints = [ ] ; this . $front Markers = { } ; this . $back Markers = { } ; this . $marker Id = 1 ; this . $row Cache = [ ] ; this . $wrap Data = [ ] ; this . $fold Data = [ ] ; this . $undo Select = true ; this . $fold Data . to String = function ( ) { var str = " " ; this . for Each ( function ( fold Line ) { str + = " \n " + fold Line . to String ( ) ; } ) ; return str ; } if ( text instanceof Document ) { this . set Document ( text ) ; } else { this . set Document ( new Document ( text ) ) ; } this . selection = new Selection ( this ) ; this . set Mode ( mode ) ; } 
function ( rules , flag ) { flag = flag ? "g " + flag : "g " ; this . rules = rules ; this . reg Exps = { } ; this . match Mappings = { } ; for ( var key in this . rules ) { var rule = this . rules [ key ] ; var state = rule ; var rule Reg Exps = [ ] ; var match Total = 0 ; var mapping = this . match Mappings [ key ] = { } ; for ( var i = 0 ; i < state . length ; i + + ) { if ( state [ i ] . regex instanceof Reg Exp ) state [ i ] . regex = state [ i ] . regex . to String ( ) . slice ( 1 , - 1 ) ; 
function ( platform , commands ) { this . platform = platform ; this . commands = { } ; this . commmand Key Binding = { } ; this . add Commands ( commands ) ; this . set Default Handler ( "exec " , function ( e ) { return e . command . exec ( e . editor , e . args | | { } ) ; } ) ; } 
function ( container , theme ) { var _self = this ; this . container = container ; 
function dom Gen ( tag Name ) { return ( opts , . . . args ) = > { if ( ! seem Like Plain Object ( opts ) ) { args . unshift ( opts ) opts = undefined } return $ ( ' < ' + tag Name + ' / > ' , opts ) . append ( . . . [ ] . concat ( . . . args ) ) } } 
function ( v ) { var ots = Object . prototype . to String ; var s = typeof v ; if ( s = = 'object ' ) { if ( v ) { if ( ( ots . call ( v ) . index Of ( 'HTML ' ) ! = = - 1 & & ots . call ( v ) . index Of ( 'Element ' ) ! = - 1 ) ) { return 'element ' } if ( v instanceof Array | | ( ! ( v instanceof Object ) & & ( ots . call ( v ) = = ' [object Array ] ' ) | | typeof v . length = = 'number ' & & typeof v . splice ! = 'undefined ' & & typeof v . property Is Enumerable ! = 'undefined ' & & ! v . property Is Enumerable ( 'splice ' ) ) ) { return 'array ' } if ( ! ( v instanceof Object ) & & ( ots . call ( v ) = = ' [object Function ] ' | | typeof v . call ! = 'undefined ' & & typeof v . property Is Enumerable ! = 'undefined ' & & ! v . property Is Enumerable ( 'call ' ) ) ) { return 'function ' } } return 'null ' ; } else if ( s = = 'function ' & & typeof v . call = = 'undefined ' ) { return 'object ' } return s ; } 
function ( ) { 
function ( identifier ) { if ( ! Bella . contains ( this . lines , identifier ) ) { this . lines . push ( identifier ) ; this . Event . on Add Online User ( identifier ) ; return true ; } return false ; } 
function ( ob ) { var identifier = ob . identifier | | ' ' ; var client Id = ob . client Id ; var socket Id = ob . socket Id ; var junction Id = ob . junction Id ; var user = ob . user | | { } ; if ( ! ! identifier & & ! ! client Id & & ! ! socket Id & & ! ! junction Id ) { var lis = this . junctions ; var r = false ; if ( lis . length > 0 ) { for ( var i = 0 ; i < lis . length ; i + + ) { var c = lis [ i ] ; if ( c . identifier = = identifier & & c . client Id = = client Id & & c . socket Id = = socket Id ) { r = true ; break ; } } } if ( ! r ) { var junc = { identifier : identifier , client Id : client Id , socket Id : socket Id , junction Id : junction Id , user : user , } if ( ! last Added Junction | | last Added Junction ! = junc ) { last Added Junction = junc ; this . junctions . push ( junc ) ; this . Event . on Add Junction ( junc , user ) ; } } } } 
function ( user , overwrite ) { var uid = user . identifier , ow = overwrite | | false ; if ( ! ! uid ) { if ( ! this . users [ uid ] | | ! ! ow ) { this . users [ uid ] = user ; } } } 
function ( value ) { value = value | | ' ' ; return this . set Style ( { left : value , right : value , top : value , bottom : value , 'z -index ' : ' ' , position : STATIC } ) ; } 
function ( ) { var me = this , offset Parent = me . dom . offset Parent , x = me . get Style ( 'left ' ) ; if ( ! x | | x = = = 'auto ' ) { x = 0 ; } else if ( me . px Re . test ( x ) ) { x = parse Float ( x ) ; } else { x = me . get X ( ) ; if ( offset Parent ) { x - = Element . get X ( offset Parent ) ; } } return x ; } 
function ( ) { var me = this , offset Parent = me . dom . offset Parent , style = me . get Style ( [ 'left ' , 'top ' ] ) , x = style . left , y = style . top ; if ( ! x | | x = = = 'auto ' ) { x = 0 ; } else if ( me . px Re . test ( x ) ) { x = parse Float ( x ) ; } else { x = me . get X ( ) ; if ( offset Parent ) { x - = Element . get X ( offset Parent ) ; } } if ( ! y | | y = = = 'auto ' ) { y = 0 ; } else if ( me . px Re . test ( y ) ) { y = parse Float ( y ) ; } else { y = me . get Y ( ) ; if ( offset Parent ) { y - = Element . get Y ( offset Parent ) ; } } return [ x , y ] ; } 
function ( ) { var me = this , offset Parent = me . dom . offset Parent , y = me . get Style ( 'top ' ) ; if ( ! y | | y = = = 'auto ' ) { y = 0 ; } else if ( me . px Re . test ( y ) ) { y = parse Float ( y ) ; } else { y = me . get Y ( ) ; if ( offset Parent ) { y - = Element . get Y ( offset Parent ) ; } } return y ; } 
function ( get Region ) { var me = this , dom = me . dom , is Doc = dom . node Name = = BODY , w = is Doc ? Ext . Element . get View Width ( ) : dom . offset Width , h = is Doc ? Ext . Element . get View Height ( ) : dom . offset Height , xy = me . get XY ( ) , t = xy [ 1 ] , r = xy [ 0 ] + w , b = xy [ 1 ] + h , l = xy [ 0 ] ; if ( get Region ) { return new Ext . util . Region ( t , r , b , l ) ; } else { return { left : l , top : t , width : w , height : h , right : r , bottom : b } ; } } 
function ( auto Px ) { var styles = this . get Style ( [ 'left ' , 'top ' , 'position ' , 'z -index ' ] ) , dom = this . dom ; if ( auto Px ) { if ( styles . left = = = 'auto ' ) { styles . left = dom . offset Left + 'px ' ; } if ( styles . top = = = 'auto ' ) { styles . top = dom . offset Top + 'px ' ; } } return styles ; } 
function ( pos , z Index , x , y ) { var me = this ; if ( ! pos & & me . is Style ( POSITION , STATIC ) ) { me . set Style ( POSITION , RELATIVE ) ; } else if ( pos ) { me . set Style ( POSITION , pos ) ; } if ( z Index ) { me . set Style ( ZINDEX , z Index ) ; } if ( x | | y ) { me . set XY ( [ x | | false , y | | false ] ) ; } } 
function ( x , y , width , height , animate ) { return this . set Box ( { x : x , y : y , width : width , height : height } , animate ) ; } 
function ( left , top ) { var me = this , style = me . dom . style ; style . left = me . add Units ( left ) ; style . top = me . add Units ( top ) ; return me ; } 
function ( rec ) { var me = this , node = me . get Node ( rec , true ) , el = me . el , adjustment Y = 0 , adjustment X = 0 , el Region = el . get Region ( ) , node Region ; 
function ( ) { var me = this , docked Items = [ ] . concat ( me . docked Items | | [ ] ) , active Tab = me . active Tab | | ( me . active Tab = 0 ) , tab Position = me . tab Position ; * @property {Ext .tab .Bar } tab Bar Internal reference to the docked Tab Bar * / me . tab Bar = new Ext . tab . Bar ( Ext . apply ( { dock : me . tab Position , orientation : ( tab Position = = 'top ' | | tab Position = = 'bottom ' ) ? 'horizontal ' : 'vertical ' , plain : me . plain , card Layout : me . layout , tab Panel : me } , me . tab Bar ) ) ; docked Items . push ( me . tab Bar ) ; me . docked Items = docked Items ; me . add Events ( 'beforetabchange ' , 'tabchange ' ) ; me . call Parent ( arguments ) ; 
function ( card ) { var me = this , previous ; card = me . get Component ( card ) ; if ( card ) { previous = me . get Active Tab ( ) ; if ( previous ! = = card & & me . fire Event ( 'beforetabchange ' , me , card , previous ) = = = false ) { return false ; } 
function ( ) { var me = this , 
function ( e ) { 
function ( e ) { if ( closed [ e . sync Id ] ) { return } 
function data Listener ( data ) { if ( client Destroyed ) return try { 
function ( sync Id , block Cb , make Cb , reify Cb , cb ) { _ . assert Length ( arguments , 5 ) 
function create Setup ( widget Configuration ) { before Each ( ( ) = > { ax Mocks . widget . configure ( widget Configuration ) ; } ) ; before Each ( ax Mocks . widget . load ) ; before Each ( ( ) = > { ax Mocks . widget . render ( ) ; widget Scope = ax Mocks . widget . $scope ; test Event Bus = ax Mocks . event Bus ; ax Mocks . trigger Startup Events ( { did Change Locale : { default : { locale : 'default ' , language Tag : 'en _US ' } } } ) ; } ) ; } 
function replace ( resource , data ) { test Event Bus . publish ( ` $ { resource } ` , { resource , data } ) ; test Event Bus . flush ( ) ; } 
function update ( resource , patches ) { test Event Bus . publish ( ` $ { resource } ` , { resource , patches } ) ; test Event Bus . flush ( ) ; } 
function ( ed , url ) { var t = this , old Size = 0 ; if ( ed . get Param ( 'fullscreen _is _enabled ' ) ) return ; function resize ( ) { var delta Size , d = ed . get Doc ( ) , body = d . body , de = d . document Element , DOM = tinymce . DOM , resize Height = t . autoresize _min _height , my Height ; 
function resize ( ) { var delta Size , d = ed . get Doc ( ) , body = d . body , de = d . document Element , DOM = tinymce . DOM , resize Height = t . autoresize _min _height , my Height ; 
function Loader Type ( options , fn ) { if ( ! ( this instanceof Loader Type ) ) { return new Loader Type ( options ) ; } Loader Stack . call ( this ) ; this . iterator = new Iterator ( options , fn ) ; } 
function ( old Key , new Key ) { var me = this , map = me . map , index Map = me . index Map , index = me . index Of Key ( old Key ) , item ; if ( index > - 1 ) { item = map [ old Key ] ; delete map [ old Key ] ; delete index Map [ old Key ] ; map [ new Key ] = item ; index Map [ new Key ] = index ; me . keys [ index ] = new Key ; me . generation + + ; } } 
function ( objs ) { var me = this , key ; if ( arguments . length > 1 | | Ext . is Array ( objs ) ) { me . insert ( me . length , arguments . length > 1 ? arguments : objs ) ; } else { for ( key in objs ) { if ( objs . has Own Property ( key ) ) { if ( me . allow Functions | | typeof objs [ key ] ! = 'function ' ) { me . add ( key , objs [ key ] ) ; } } } } } 
function ( fn , scope ) { var items = Ext . Array . push ( [ ] , this . items ) , 
function ( ) { if ( Ext . is Defined ( Ext . global . console ) ) { Ext . global . console . warn ( 'Ext .util .Mixed Collection : find has been deprecated . Use find By instead . ' ) ; } return this . find By . apply ( this , arguments ) ; } 
function ( index , key , obj ) { if ( Ext . is Iterable ( key ) ) { return this . do Insert ( index , key , obj ) ; } return ( obj ? this . do Insert ( index , [ key ] , [ obj ] ) : this . do Insert ( index , [ key ] ) ) [ 0 ] ; } 
function ( index , keys , objects ) { var me = this , item Key , remove Index , i , len = keys . length , fire Add = me . has Listeners . add , sync Indices ; 
function ( o ) { var me = this , remove Key , index ; 
function ( items ) { var me = this , i ; if ( items | | me . has Listeners . remove ) { 
function ( index ) { var me = this , o , key ; if ( index < me . length & & index > = 0 ) { me . length - - ; o = me . items [ index ] ; Ext . Array . erase ( me . items , index , 1 ) ; key = me . keys [ index ] ; if ( typeof key ! = 'undefined ' ) { delete me . map [ key ] ; } Ext . Array . erase ( me . keys , index , 1 ) ; if ( me . has Listeners . remove ) { me . fire Event ( 'remove ' , o , key ) ; } me . generation + + ; return o ; } return false ; } 
function ( o ) { var me = this , key ; if ( o ! = null ) { 
function ( ) { var me = this ; me . length = 0 ; me . items = [ ] ; me . keys = [ ] ; me . map = { } ; me . index Map = { } ; me . generation + + ; me . index Generation = me . generation ; if ( me . has Listeners . clear ) { me . fire Event ( 'clear ' ) ; } } 
function ( property , root , start , end ) { var values = this . extract Values ( property , root ) , length = values . length , sum = 0 , i ; start = start | | 0 ; end = ( end | | end = = = 0 ) ? end : length - 1 ; for ( i = start ; i < = end ; i + + ) { sum + = values [ i ] ; } return sum ; } 
function ( property , root , allow Null ) { var values = this . extract Values ( property , root ) , length = values . length , hits = { } , unique = [ ] , value , str Value , i ; for ( i = 0 ; i < length ; i + + ) { value = values [ i ] ; str Value = String ( value ) ; if ( ( allow Null | | ! Ext . is Empty ( value ) ) & & ! hits [ str Value ] ) { hits [ str Value ] = true ; unique . push ( value ) ; } } return unique ; } 
function ( property , value , any Match , case Sensitive ) { var filters = [ ] ; 
function ( fn , scope ) { var me = this , new MC = new me . self ( me . initial Config ) , keys = me . keys , items = me . items , length = items . length , i ; new MC . get Key = me . get Key ; for ( i = 0 ; i < length ; i + + ) { if ( fn . call ( scope | | me , items [ i ] , keys [ i ] ) ) { new MC . add ( keys [ i ] , items [ i ] ) ; } } return new MC ; } 
function ( property , value , start , any Match , case Sensitive ) { if ( Ext . is Empty ( value , false ) ) { return - 1 ; } value = this . create Value Matcher ( value , any Match , case Sensitive ) ; return this . find Index By ( function ( o ) { return o & & value . test ( o [ property ] ) ; } , null , start ) ; } 
function ( value , any Match , case Sensitive , exact Match ) { if ( ! value . exec ) { 
function ( ) { var me = this , copy = new this . self ( me . initial Config ) ; copy . add ( me . keys , me . items ) ; return copy ; } 
function process Eq ( r , expr , cb ) { 
function is Simple ( p ) { return p . type = = = 'param ' | | p . type = = = 'value ' | | ( p . type = = = 'view ' & & p . view = = = 'property ' & & is Simple ( p . params [ 1 ] ) ) } 
function ( message , socket , smartrouter ) { smartrouter . publish ( message . ids . addressee , 'message ' , message , socket ) ; 
function ( data , force _absolute ) { var self = this , editor = self . editor , base Uri = editor . document Base URI , sources , attrs , img , i ; data . params . src = self . convert Url ( data . params . src , force _absolute ) ; attrs = data . video . attrs ; if ( attrs ) attrs . src = self . convert Url ( attrs . src , force _absolute ) ; if ( attrs ) attrs . poster = self . convert Url ( attrs . poster , force _absolute ) ; sources = to Array ( data . video . sources ) ; if ( sources ) { for ( i = 0 ; i < sources . length ; i + + ) sources [ i ] . src = self . convert Url ( sources [ i ] . src , force _absolute ) ; } img = self . editor . dom . create ( 'img ' , { id : data . id , style : data . style , align : data . align , hspace : data . hspace , vspace : data . vspace , src : self . editor . theme . url + ' /img /trans .gif ' , 'class ' : 'mce Item Media mce Item ' + self . get Type ( data . type ) . name , 'data -mce -json ' : JSON . serialize ( data , " ' " ) } ) ; img . width = data . width = normalize Size ( data . width | | ( data . type = = 'audio ' ? " 3 0 0 " : " 3 2 0 " ) ) ; img . height = data . height = normalize Size ( data . height | | ( data . type = = 'audio ' ? " 3 2 " : " 2 4 0 " ) ) ; return img ; } 
function ( data , force _absolute ) { return this . editor . serializer . serialize ( this . data To Img ( data , force _absolute ) , { forced _root _block : ' ' , force _absolute : force _absolute } ) ; } 
function ( html ) { var fragment , img , data ; data = { type : 'flash ' , video : { sources : [ ] } , params : { } } ; fragment = this . editor . parser . parse ( html ) ; img = fragment . get All ( 'img ' ) [ 0 ] ; if ( img ) { data = JSON . parse ( img . attr ( 'data -mce -json ' ) ) ; data . type = this . get Type ( img . attr ( 'class ' ) ) . name . to Lower Case ( ) ; / / Add some extra properties to the data object tinymce . each ( root Attributes , function ( name ) { var value = img . attr ( name ) ; if ( value ) data [ name ] = value ; } ) ; } return data ; } 
function ( value ) { var i , values , type Item ; / / Find type by checking the classes values = tinymce . explode ( value , ' ' ) ; for ( i = 0 ; i < values . length ; i + + ) { type Item = this . lookup [ values [ i ] ] ; if ( type Item ) return type Item ; } } 
function ( node , args ) { var self = this , editor = self . editor , video , object , embed , iframe , name , value , data , source , sources , params , param , type Item , i , item , mp 4Source , replacement , poster Src , style , audio ; / / Adds the flash player function add Player ( video _src , poster _src ) { var base Uri , flash Vars , flash Vars Output , params , flash Player ; flash Player = editor . get Param ( 'flash _video _player _url ' , self . convert Url ( self . url + ' /moxieplayer .swf ' ) ) ; if ( flash Player ) { base Uri = editor . document Base URI ; data . params . src = flash Player ; / / Convert the movie url to absolute urls if ( editor . get Param ( 'flash _video _player _absvideourl ' , true ) ) { video _src = base Uri . to Absolute ( video _src | | ' ' , true ) ; poster _src = base Uri . to Absolute ( poster _src | | ' ' , true ) ; } / / Generate flash vars flash Vars Output = ' ' ; flash Vars = editor . get Param ( 'flash _video _player _flashvars ' , { url : ' $url ' , poster : ' $poster ' } ) ; tinymce . each ( flash Vars , function ( value , name ) { / / Replace $url and $poster variables in flashvars value value = value . replace ( / \ $url / , video _src | | ' ' ) ; value = value . replace ( / \ $poster / , poster _src | | ' ' ) ; if ( value . length > 0 ) flash Vars Output + = ( flash Vars Output ? ' & ' : ' ' ) + name + ' = ' + escape ( value ) ; } ) ; if ( flash Vars Output . length ) data . params . flashvars = flash Vars Output ; params = editor . get Param ( 'flash _video _player _params ' , { allowfullscreen : true , allowscriptaccess : true } ) ; tinymce . each ( params , function ( value , name ) { data . params [ name ] = " " + value ; } ) ; } } ; data = node . attr ( 'data -mce -json ' ) ; if ( ! data ) return ; data = JSON . parse ( data ) ; type Item = this . get Type ( node . attr ( 'class ' ) ) ; style = node . attr ( 'data -mce -style ' ) ; if ( ! style ) { style = node . attr ( 'style ' ) ; if ( style ) style = editor . dom . serialize Style ( editor . dom . parse Style ( style , 'img ' ) ) ; } / / Use node width /height to override the data width /height when the placeholder is resized data . width = node . attr ( 'width ' ) | | data . width ; data . height = node . attr ( 'height ' ) | | data . height ; / / Handle iframe if ( type Item . name = = = 'Iframe ' ) { replacement = new Node ( 'iframe ' , 1 ) ; tinymce . each ( root Attributes , function ( name ) { var value = node . attr ( name ) ; if ( name = = 'class ' & & value ) value = value . replace ( / mce Item . + ? / g , ' ' ) ; if ( value & & value . length > 0 ) replacement . attr ( name , value ) ; } ) ; for ( name in data . params ) replacement . attr ( name , data . params [ name ] ) ; replacement . attr ( { style : style , src : data . params . src } ) ; node . replace ( replacement ) ; return ; } / / Handle scripts if ( this . editor . settings . media _use _script ) { replacement = new Node ( 'script ' , 1 ) . attr ( 'type ' , 'text /javascript ' ) ; value = new Node ( ' #text ' , 3 ) ; value . value = 'write ' + type Item . name + ' ( ' + JSON . serialize ( tinymce . extend ( data . params , { width : node . attr ( 'width ' ) , height : node . attr ( 'height ' ) } ) ) + ' ) ; ' ; replacement . append ( value ) ; node . replace ( replacement ) ; return ; } / / Add HTML 5 video element if ( type Item . name = = = 'Video ' & & data . video . sources [ 0 ] ) { / / Create new object element video = new Node ( 'video ' , 1 ) . attr ( tinymce . extend ( { id : node . attr ( 'id ' ) , width : normalize Size ( node . attr ( 'width ' ) ) , height : normalize Size ( node . attr ( 'height ' ) ) , style : style } , data . video . attrs ) ) ; / / Get poster source and use that for flash fallback if ( data . video . attrs ) poster Src = data . video . attrs . poster ; sources = data . video . sources = to Array ( data . video . sources ) ; for ( i = 0 ; i < sources . length ; i + + ) { if ( / \ .mp 4 $ / . test ( sources [ i ] . src ) ) mp 4Source = sources [ i ] . src ; } if ( ! sources [ 0 ] . type ) { video . attr ( 'src ' , sources [ 0 ] . src ) ; sources . splice ( 0 , 1 ) ; } for ( i = 0 ; i < sources . length ; i + + ) { source = new Node ( 'source ' , 1 ) . attr ( sources [ i ] ) ; source . short Ended = true ; video . append ( source ) ; } / / Create flash fallback for video if we have a mp 4 source if ( mp 4Source ) { add Player ( mp 4Source , poster Src ) ; type Item = self . get Type ( 'flash ' ) ; } else data . params . src = ' ' ; } / / Add HTML 5 audio element if ( type Item . name = = = 'Audio ' & & data . video . sources [ 0 ] ) { / / Create new object element audio = new Node ( 'audio ' , 1 ) . attr ( tinymce . extend ( { id : node . attr ( 'id ' ) , width : normalize Size ( node . attr ( 'width ' ) ) , height : normalize Size ( node . attr ( 'height ' ) ) , style : style } , data . video . attrs ) ) ; / / Get poster source and use that for flash fallback if ( data . video . attrs ) poster Src = data . video . attrs . poster ; sources = data . video . sources = to Array ( data . video . sources ) ; if ( ! sources [ 0 ] . type ) { audio . attr ( 'src ' , sources [ 0 ] . src ) ; sources . splice ( 0 , 1 ) ; } for ( i = 0 ; i < sources . length ; i + + ) { source = new Node ( 'source ' , 1 ) . attr ( sources [ i ] ) ; source . short Ended = true ; audio . append ( source ) ; } data . params . src = ' ' ; } if ( type Item . name = = = 'Embedded Audio ' ) { embed = new Node ( 'embed ' , 1 ) ; embed . short Ended = true ; embed . attr ( { id : node . attr ( 'id ' ) , width : normalize Size ( node . attr ( 'width ' ) ) , height : normalize Size ( node . attr ( 'height ' ) ) , style : style , type : node . attr ( 'type ' ) } ) ; for ( name in data . params ) embed . attr ( name , data . params [ name ] ) ; tinymce . each ( root Attributes , function ( name ) { if ( data [ name ] & & name ! = 'type ' ) embed . attr ( name , data [ name ] ) ; } ) ; data . params . src = ' ' ; } / / Do we have a params src then we can generate object if ( data . params . src ) { / / Is flv movie add player for it if ( / \ .flv $ / i . test ( data . params . src ) ) add Player ( data . params . src , ' ' ) ; if ( args & & args . force _absolute ) data . params . src = editor . document Base URI . to Absolute ( data . params . src ) ; / / Create new object element object = new Node ( 'object ' , 1 ) . attr ( { id : node . attr ( 'id ' ) , width : normalize Size ( node . attr ( 'width ' ) ) , height : normalize Size ( node . attr ( 'height ' ) ) , style : style } ) ; tinymce . each ( root Attributes , function ( name ) { var value = data [ name ] ; if ( name = = 'class ' & & value ) value = value . replace ( / mce Item . + ? / g , ' ' ) ; if ( value & & name ! = 'type ' ) object . attr ( name , value ) ; } ) ; / / Add params for ( name in data . params ) { param = new Node ( 'param ' , 1 ) ; param . short Ended = true ; value = data . params [ name ] ; / / Windows media needs to use url instead of src for the media URL if ( name = = = 'src ' & & type Item . name = = = 'Windows Media ' ) name = 'url ' ; param . attr ( { name : name , value : value } ) ; object . append ( param ) ; } / / Setup add type and classid if strict is disabled if ( this . editor . get Param ( 'media _strict ' , true ) ) { object . attr ( { data : data . params . src , type : type Item . mimes [ 0 ] } ) ; } else { object . attr ( { classid : "clsid : " + type Item . clsids [ 0 ] , codebase : type Item . codebase } ) ; embed = new Node ( 'embed ' , 1 ) ; embed . short Ended = true ; embed . attr ( { id : node . attr ( 'id ' ) , width : normalize Size ( node . attr ( 'width ' ) ) , height : normalize Size ( node . attr ( 'height ' ) ) , style : style , type : type Item . mimes [ 0 ] } ) ; for ( name in data . params ) embed . attr ( name , data . params [ name ] ) ; tinymce . each ( root Attributes , function ( name ) { if ( data [ name ] & & name ! = 'type ' ) embed . attr ( name , data [ name ] ) ; } ) ; object . append ( embed ) ; } / / Insert raw HTML if ( data . object _html ) { value = new Node ( ' #text ' , 3 ) ; value . raw = true ; value . value = data . object _html ; object . append ( value ) ; } / / Append object to video element if it exists if ( video ) video . append ( object ) ; } if ( video ) { / / Insert raw HTML if ( data . video _html ) { value = new Node ( ' #text ' , 3 ) ; value . raw = true ; value . value = data . video _html ; video . append ( value ) ; } } if ( audio ) { / / Insert raw HTML if ( data . video _html ) { value = new Node ( ' #text ' , 3 ) ; value . raw = true ; value . value = data . video _html ; audio . append ( value ) ; } } var n = video | | audio | | object | | embed ; if ( n ) node . replace ( n ) ; else node . remove ( ) ; } 
function add Player ( video _src , poster _src ) { var base Uri , flash Vars , flash Vars Output , params , flash Player ; flash Player = editor . get Param ( 'flash _video _player _url ' , self . convert Url ( self . url + ' /moxieplayer .swf ' ) ) ; if ( flash Player ) { base Uri = editor . document Base URI ; data . params . src = flash Player ; / / Convert the movie url to absolute urls if ( editor . get Param ( 'flash _video _player _absvideourl ' , true ) ) { video _src = base Uri . to Absolute ( video _src | | ' ' , true ) ; poster _src = base Uri . to Absolute ( poster _src | | ' ' , true ) ; } / / Generate flash vars flash Vars Output = ' ' ; flash Vars = editor . get Param ( 'flash _video _player _flashvars ' , { url : ' $url ' , poster : ' $poster ' } ) ; tinymce . each ( flash Vars , function ( value , name ) { / / Replace $url and $poster variables in flashvars value value = value . replace ( / \ $url / , video _src | | ' ' ) ; value = value . replace ( / \ $poster / , poster _src | | ' ' ) ; if ( value . length > 0 ) flash Vars Output + = ( flash Vars Output ? ' & ' : ' ' ) + name + ' = ' + escape ( value ) ; } ) ; if ( flash Vars Output . length ) data . params . flashvars = flash Vars Output ; params = editor . get Param ( 'flash _video _player _params ' , { allowfullscreen : true , allowscriptaccess : true } ) ; tinymce . each ( params , function ( value , name ) { data . params [ name ] = " " + value ; } ) ; } } 
function ( node ) { var object , embed , video , iframe , img , name , id , width , height , style , i , html , param , params , source , sources , data , type , lookup = this . lookup , matches , attrs , url Converter = this . editor . settings . url _converter , url Converter Scope = this . editor . settings . url _converter _scope , hspace , vspace , align , bgcolor ; function get Inner HTML ( node ) { return new tinymce . html . Serializer ( { inner : true , validate : false } ) . serialize ( node ) ; } ; function lookup Attribute ( o , attr ) { return lookup [ ( o . attr ( attr ) | | ' ' ) . to Lower Case ( ) ] ; } function lookup Extension ( src ) { var ext = src . replace ( / ^ . * \ . ( [ ^ . ] + ) $ / , ' $ 1 ' ) ; return lookup [ ext . to Lower Case ( ) | | ' ' ] ; } / / If node isn 't in document if ( ! node . parent ) return ; / / Handle media scripts if ( node . name = = = 'script ' ) { if ( node . first Child ) matches = script Reg Exp . exec ( node . first Child . value ) ; if ( ! matches ) return ; type = matches [ 1 ] ; data = { video : { } , params : JSON . parse ( matches [ 2 ] ) } ; width = data . params . width ; height = data . params . height ; } / / Setup data objects data = data | | { video : { } , params : { } } ; / / Setup new image object img = new Node ( 'img ' , 1 ) ; img . attr ( { src : this . editor . theme . url + ' /img /trans .gif ' } ) ; / / Video element name = node . name ; if ( name = = = 'video ' | | name = = 'audio ' ) { video = node ; object = node . get All ( 'object ' ) [ 0 ] ; embed = node . get All ( 'embed ' ) [ 0 ] ; width = video . attr ( 'width ' ) ; height = video . attr ( 'height ' ) ; id = video . attr ( 'id ' ) ; data . video = { attrs : { } , sources : [ ] } ; / / Get all video attributes attrs = data . video . attrs ; for ( name in video . attributes . map ) attrs [ name ] = video . attributes . map [ name ] ; source = node . attr ( 'src ' ) ; if ( source ) data . video . sources . push ( { src : url Converter . call ( url Converter Scope , source , 'src ' , node . name ) } ) ; / / Get all sources sources = video . get All ( "source " ) ; for ( i = 0 ; i < sources . length ; i + + ) { source = sources [ i ] . remove ( ) ; data . video . sources . push ( { src : url Converter . call ( url Converter Scope , source . attr ( 'src ' ) , 'src ' , 'source ' ) , type : source . attr ( 'type ' ) , media : source . attr ( 'media ' ) } ) ; } / / Convert the poster URL if ( attrs . poster ) attrs . poster = url Converter . call ( url Converter Scope , attrs . poster , 'poster ' , node . name ) ; } / / Object element if ( node . name = = = 'object ' ) { object = node ; embed = node . get All ( 'embed ' ) [ 0 ] ; } / / Embed element if ( node . name = = = 'embed ' ) embed = node ; / / Iframe element if ( node . name = = = 'iframe ' ) { iframe = node ; type = 'Iframe ' ; } if ( object ) { / / Get width /height width = width | | object . attr ( 'width ' ) ; height = height | | object . attr ( 'height ' ) ; style = style | | object . attr ( 'style ' ) ; id = id | | object . attr ( 'id ' ) ; hspace = hspace | | object . attr ( 'hspace ' ) ; vspace = vspace | | object . attr ( 'vspace ' ) ; align = align | | object . attr ( 'align ' ) ; bgcolor = bgcolor | | object . attr ( 'bgcolor ' ) ; data . name = object . attr ( 'name ' ) ; / / Get all object params params = object . get All ( "param " ) ; for ( i = 0 ; i < params . length ; i + + ) { param = params [ i ] ; name = param . remove ( ) . attr ( 'name ' ) ; if ( ! excluded Attrs [ name ] ) data . params [ name ] = param . attr ( 'value ' ) ; } data . params . src = data . params . src | | object . attr ( 'data ' ) ; } if ( embed ) { / / Get width /height width = width | | embed . attr ( 'width ' ) ; height = height | | embed . attr ( 'height ' ) ; style = style | | embed . attr ( 'style ' ) ; id = id | | embed . attr ( 'id ' ) ; hspace = hspace | | embed . attr ( 'hspace ' ) ; vspace = vspace | | embed . attr ( 'vspace ' ) ; align = align | | embed . attr ( 'align ' ) ; bgcolor = bgcolor | | embed . attr ( 'bgcolor ' ) ; / / Get all embed attributes for ( name in embed . attributes . map ) { if ( ! excluded Attrs [ name ] & & ! data . params [ name ] ) data . params [ name ] = embed . attributes . map [ name ] ; } } if ( iframe ) { / / Get width /height width = normalize Size ( iframe . attr ( 'width ' ) ) ; height = normalize Size ( iframe . attr ( 'height ' ) ) ; style = style | | iframe . attr ( 'style ' ) ; id = iframe . attr ( 'id ' ) ; hspace = iframe . attr ( 'hspace ' ) ; vspace = iframe . attr ( 'vspace ' ) ; align = iframe . attr ( 'align ' ) ; bgcolor = iframe . attr ( 'bgcolor ' ) ; tinymce . each ( root Attributes , function ( name ) { img . attr ( name , iframe . attr ( name ) ) ; } ) ; / / Get all iframe attributes for ( name in iframe . attributes . map ) { if ( ! excluded Attrs [ name ] & & ! data . params [ name ] ) data . params [ name ] = iframe . attributes . map [ name ] ; } } / / Use src not movie if ( data . params . movie ) { data . params . src = data . params . src | | data . params . movie ; delete data . params . movie ; } / / Convert the URL to relative /absolute depending on configuration if ( data . params . src ) data . params . src = url Converter . call ( url Converter Scope , data . params . src , 'src ' , 'object ' ) ; if ( video ) { if ( node . name = = = 'video ' ) type = lookup . video . name ; else if ( node . name = = = 'audio ' ) type = lookup . audio . name ; } if ( object & & ! type ) type = ( lookup Attribute ( object , 'clsid ' ) | | lookup Attribute ( object , 'classid ' ) | | lookup Attribute ( object , 'type ' ) | | { } ) . name ; if ( embed & & ! type ) type = ( lookup Attribute ( embed , 'type ' ) | | lookup Extension ( data . params . src ) | | { } ) . name ; / / for embedded audio we preserve the original specified type if ( embed & & type = = 'Embedded Audio ' ) { data . params . type = embed . attr ( 'type ' ) ; } / / Replace the video /object /embed element with a placeholder image containing the data node . replace ( img ) ; / / Remove embed if ( embed ) embed . remove ( ) ; / / Serialize the inner HTML of the object element if ( object ) { html = get Inner HTML ( object . remove ( ) ) ; if ( html ) data . object _html = html ; } / / Serialize the inner HTML of the video element if ( video ) { html = get Inner HTML ( video . remove ( ) ) ; if ( html ) data . video _html = html ; } data . hspace = hspace ; data . vspace = vspace ; data . align = align ; data . bgcolor = bgcolor ; / / Set width /height of placeholder img . attr ( { id : id , 'class ' : 'mce Item Media mce Item ' + ( type | | 'Flash ' ) , style : style , width : width | | ( node . name = = 'audio ' ? " 3 0 0 " : " 3 2 0 " ) , height : height | | ( node . name = = 'audio ' ? " 3 2 " : " 2 4 0 " ) , hspace : hspace , vspace : vspace , align : align , bgcolor : bgcolor , "data -mce -json " : JSON . serialize ( data , " ' " ) } ) ; } 
function ( binding ) { var me = this , key Code = binding . key , i , len ; if ( me . processing ) { me . bindings = bindings . slice ( 0 ) ; } if ( Ext . is Array ( binding ) ) { for ( i = 0 , len = binding . length ; i < len ; i + + ) { me . add Binding ( binding [ i ] ) ; } return ; } me . bindings . push ( Ext . apply ( { key Code : me . process Keys ( key Code ) } , binding ) ) ; } 
function ( binding ) { var me = this , bindings = me . bindings , len = bindings . length , i , item , keys ; if ( me . processing ) { me . bindings = bindings . slice ( 0 ) ; } keys = me . process Keys ( binding . key ) ; for ( i = 0 ; i < len ; + + i ) { item = bindings [ i ] ; if ( item . fn = = = binding . fn & & item . scope = = = binding . scope ) { if ( binding . alt = = item . alt & & binding . crtl = = item . crtl & & binding . shift = = item . shift ) { if ( Ext . Array . equals ( item . key Code , keys ) ) { Ext . Array . erase ( me . bindings , i , 1 ) ; return ; } } } } } 
function ( binding , event ) { if ( this . check Modifiers ( binding , event ) ) { var key = event . get Key ( ) , handler = binding . fn | | binding . handler , scope = binding . scope | | this , key Code = binding . key Code , default Event Action = binding . default Event Action , i , len , keydown Event = new Ext . Event Object Impl ( event ) ; for ( i = 0 , len = key Code . length ; i < len ; + + i ) { if ( key = = = key Code [ i ] ) { if ( handler . call ( scope , key , event ) ! = = true & & default Event Action ) { keydown Event [ default Event Action ] ( ) ; } break ; } } } } 
function ( binding , e ) { var keys = [ 'shift ' , 'ctrl ' , 'alt ' ] , i = 0 , len = keys . length , val , key ; for ( ; i < len ; + + i ) { key = keys [ i ] ; val = binding [ key ] ; if ( ! ( val = = = undefined | | ( val = = = e [ key + 'Key ' ] ) ) ) { return false ; } } return true ; } 
function ( key , fn , scope ) { var key Code , shift , ctrl , alt ; if ( Ext . is Object ( key ) & & ! Ext . is Array ( key ) ) { key Code = key . key ; shift = key . shift ; ctrl = key . ctrl ; alt = key . alt ; } else { key Code = key ; } this . add Binding ( { key : key Code , shift : shift , ctrl : ctrl , alt : alt , fn : fn , scope : scope } ) ; } 
function ( ) { var me = this ; if ( ! me . enabled ) { me . target . on ( me . event Name , me . handle Target Event , me ) ; me . enabled = true ; } } 
function ( ) { var me = this ; if ( me . enabled ) { me . target . remove Listener ( me . event Name , me . handle Target Event , me ) ; me . enabled = false ; } } 
function ( remove Target ) { var me = this , target = me . target ; me . bindings = [ ] ; me . disable ( ) ; if ( remove Target = = = true ) { if ( target . is Component ) { target . destroy ( ) ; } else { target . remove ( ) ; } } delete me . target ; } 
function ( ) { var wrap = arguments [ 0 ] , items = this . get Layout Items ( ) , index = Ext . Array . index Of ( items , this . active Item ) ; return items [ index + 1 ] | | ( wrap ? items [ 0 ] : false ) ; } 
function ( ) { var el = Ext . get Body ( ) . create Child ( { tag : 'div ' , style : 'position :absolute ;overflow :auto ;height : 1 0 0px ;width : 1 0 0px ; ' , children : [ { tag : 'div ' , style : 'height : 3 0px ;width : 1 5 0px ; ' } ] } ) , dom = el . dom , flag = 2 ; if ( dom . scroll Left = = = 5 0 ) { flag = 1 ; } else { dom . scroll Left = - 1 ; if ( dom . scroll Left ) { flag = 0 ; } } el . remove ( ) ; return flag ; } 
function ( xtype ) { var me = this ; if ( Ext . is Array ( xtype ) ) { Ext . Array . for Each ( xtype , me . add XType To Whitelist , me ) ; return ; } if ( ! Ext . Array . contains ( me . whitelist , xtype ) ) { me . whitelist . push ( xtype ) ; } } 
function ( xtype ) { var me = this ; if ( Ext . is Array ( xtype ) ) { Ext . Array . for Each ( xtype , me . remove XType From Whitelist , me ) ; return ; } Ext . Array . remove ( me . whitelist , xtype ) ; } 
function ( ) { var me = this , items = me . flush Queue . clear ( ) , length = items . length , i ; if ( length ) { + + me . flush Count ; for ( i = 0 ; i < length ; + + i ) { items [ i ] . flush ( ) ; } } } 
function ( parent , el ) { var id = el . id , children = parent . children , items = this . items ; if ( children ) { Ext . Array . remove ( children , items [ id ] ) ; } delete items [ id ] ; } 
function ( ) { var me = this , layouts = me . layout Queue . clear ( ) , length = layouts . length , i ; + + me . cycle Count ; 
function ( layout ) { var me = this , owner Context = me . get Cmp ( layout . owner ) ; layout . pending = false ; if ( owner Context . state . blocks ) { return ; } 
function ( item , width , height ) { var items = item , len = 1 , context Item , i ; 
function Strategy ( options , validate ) { options = options | | { } ; options . provider URL = options . provider URL | | 'https : / /api .screenname .aol .com /auth /openid /xrds ' ; 
function parse ( argv , options ) { options = Object . assign ( { } , constants _ 1 . PARSER _DEFAULTS , options ) ; var _result = { _ : [ ] , _ _ : [ ] } ; var _configs , _aliases , _indexed , _max Index ; function handle Error ( message ) { var args = [ ] ; for ( var _i = 1 ; _i < arguments . length ; _i + + ) { args [ _i - 1 ] = arguments [ _i ] ; } var template = message ; message = util _ 1 . format . apply ( void 0 , [ message ] . concat ( args ) ) ; var err = new Error ( message ) ; if ( ! options . on Parser Error ) throw err ; options . on Parser Error ( err , template , args ) ; } function get Config ( key ) { 
function ( model , set On Store ) { var me = this ; me . model = Ext . Model Manager . get Model ( model ) ; me . set Reader ( this . reader ) ; me . set Writer ( this . writer ) ; if ( set On Store & & me . store ) { me . store . set Model ( me . model ) ; } } 
function ( reader ) { var me = this , needs Copy = true , current = me . reader ; if ( reader = = = undefined | | typeof reader = = 'string ' ) { reader = { type : reader } ; needs Copy = false ; } if ( reader . is Reader ) { reader . set Model ( me . model ) ; } else { if ( needs Copy ) { reader = Ext . apply ( { } , reader ) ; } Ext . apply If ( reader , { proxy : me , model : me . model , type : me . default Reader Type } ) ; reader = Ext . create By Alias ( 'reader . ' + reader . type , reader ) ; } if ( reader ! = = current & & reader . on Meta Change ) { reader . on Meta Change = Ext . Function . create Sequence ( reader . on Meta Change , this . on Meta Change , this ) ; } me . reader = reader ; return me . reader ; } 
function ( writer ) { var me = this , needs Copy = true ; if ( writer = = = undefined | | typeof writer = = 'string ' ) { writer = { type : writer } ; needs Copy = false ; } if ( ! writer . is Writer ) { if ( needs Copy ) { writer = Ext . apply ( { } , writer ) ; } Ext . apply If ( writer , { model : me . model , type : me . default Writer Type } ) ; writer = Ext . create By Alias ( 'writer . ' + writer . type , writer ) ; } me . writer = writer ; return me . writer ; } 
function evict ( new Id ) { _ .errout (JSON .stringify (edits ) ) } _ .assert Equal (edits [ 1 ] .edit .id , evicted Id ) * / if ( ob . is New ( evicted Id ) ) { ob . write ( evicted Id , edits ) } else { ob . append ( evicted Id , edits ) } delete cache [ evicted Id ] _ .assert Int (order [i ] ) _ .assert (order [i ] ! = = evicted Id ) } * / } 
function get Oldest Filename ( callback ) { get Log Files ( function ( err , files ) { if ( err ) { callback ( err , null ) ; } else if ( ! files | | files . length = = = 0 ) { return callback ( null , Date . now ( ) . to String ( ) . concat ( FILE _EXT ) ) ; } else { var file = _ . min ( files , function ( f ) { 
function get Most Recent Filename ( callback ) { get Log Files ( function ( err , files ) { if ( err ) { callback ( err , null ) ; } else if ( ! files | | files . length = = = 0 ) { return callback ( null , Date . now ( ) . to String ( ) . concat ( FILE _EXT ) ) ; } else { var file = _ . max ( files , function ( f ) { var n = ( f & & typeof f . name = = = 'string ' ) ? f . name : f ; 
function get Required Filename ( name , callback ) { var filepath = path . join ( LOG _DIR , name ) ; function get Stats ( ) { fs . stat ( filepath , function ( err , stats ) { if ( err ) { callback ( err , null ) ; } else if ( stats & & stats . size > = MAX _FILE _SIZE ) { create File ( ) ; } else { callback ( null , name ) ; } } ) ; } function create File ( ) { fs . write File ( filepath , ' [ ] ' , function ( err ) { if ( err ) { callback ( err , null ) ; } else { callback ( null , name ) ; } } ) ; } fs . exists ( filepath , function ( exists ) { if ( exists ) { get Stats ( ) ; } else { create File ( ) ; } } ) ; } 
function get Write Function ( log ) { return function write Log File ( name , qcb ) { var dir = path . join ( LOG _DIR , name ) ; function read File ( cb ) { fs . read File ( dir , cb ) ; } function update Logs ( logs , cb ) { logs . push ( log . to JSON ( ) ) ; cb ( null , logs ) ; } function write File ( str , cb ) { fs . write File ( dir , str , cb ) ; } async . waterfall ( [ read File , safejson . parse , update Logs , safejson . stringify , write File ] , qcb ) ; } ; } 
function get Logs Object ( name , callback ) { fs . read File ( path . join ( LOG _DIR , name ) , function ( err , data ) { if ( err ) { return callback ( err , null ) ; } safejson . parse ( data , function ( err , log Array ) { if ( err ) { return callback ( err , null ) ; } callback ( null , { logs : log Array } ) ; } ) ; } ) ; } 
function delete File ( name , callback ) { fs . unlink ( path . join ( LOG _DIR , name ) , callback ) ; } 
function ( ) { this . port = DEFAULT _STUBBATTI _PORT ; this . app = express ( ) ; this . console = global . console ; var stubbatti = this ; this . app [ KILL _METHOD ] ( KILL _PATH , function ( req , res ) { res . set ( 'Connection ' , 'close ' ) ; res . end ( ) ; stubbatti . stop ( ) ; } ) ; } 
function bravojs _init ( bravojs , window ) { try { bravojs . window = window ; if ( ! bravojs . has Own Property ( "error Reporter " ) ) { bravojs . error Reporter = function bravojs _default Drror Reporter ( e ) { if ( typeof alert ! = "undefined " ) alert ( " * Bravo JS : " + e + " \n " + e . stack ) ; throw ( e ) ; } } bravojs . reset = function bravojs _reset ( main Module Dir , plugins ) { if ( ! main Module Dir ) { if ( typeof bravojs . main Module Dir ! = "undefined " ) main Module Dir = bravojs . main Module Dir ; else main Module Dir = bravojs . dirname ( bravojs . URL _to Id ( window . location . href + " .js " , true ) ) ; } bravojs . require Memo = { } ; bravojs . pending Module Declarations = { } ; bravojs . main Module Dir = main Module Dir ; bravojs . plugins = plugins | | [ ] ; bravojs . contexts = { } ; bravojs . active Contexts = [ ] ; delete bravojs . Module . prototype . main ; delete bravojs . script Tag Memo ; delete bravojs . script Tag Memo IE ; bravojs . make Context ( " _ " ) ; bravojs . module = window . module = new bravojs . Module ( ' ' , [ ] ) ; bravojs . require = window . require = bravojs . require Factory ( bravojs . main Module Dir , [ ] , bravojs . module ) ; bravojs . module . declare = function main _module _declare ( dependencies , module Factory ) { if ( typeof dependencies = = = "function " ) { module Factory = dependencies ; dependencies = [ ] ; } bravojs . initialize Main Module ( dependencies , module Factory , ' ' ) ; } } function bravojs _print ( ) { var output = " " ; var i ; var stdout ; for ( i = 0 ; i < arguments . length ; i + + ) output + = arguments [ i ] + ( i = = = arguments . length - 1 ? " " : " " ) ; output . replace ( / \t / , " " ) ; if ( typeof window . document ! = "undefined " & & ( stdout = window . document . get Element By Id ( 'stdout ' ) ) ) { output + = " \n " ; if ( typeof stdout . value ! = = "undefined " ) { stdout . value + = output ; if ( stdout . focus ) stdout . focus ( ) ; if ( stdout . tag Name = = = "TEXTAREA " ) stdout . scroll Top = stdout . scroll Height ; } else { if ( typeof stdout . inner Text ! = = "undefined " ) { stdout . inner Text = stdout . inner Text . slice ( 0 , - 1 ) + output + " " ; } else stdout . text Content + = output ; } } else if ( typeof console = = = "object " & & console . print ) { console . print ( output ) ; } else if ( typeof console = = = "object " & & console . log ) { console . log ( output ) ; } * Treats paths with trailing slashes as though they end with INDEX instead . * Not rigorous . * / bravojs . realpath = function bravojs _realpath ( path , index ) { if ( typeof index = = = "undefined " ) index = "INDEX " ; if ( typeof path ! = = "string " ) path = path . to String ( ) ; var old Path = path . split ( ' / ' ) ; var new Path = [ ] ; var i ; if ( path . char At ( path . length - 1 ) = = = ' / ' & & index ) old Path . push ( index ) ; for ( i = 0 ; i < old Path . length ; i + + ) { if ( old Path [ i ] = = ' . ' | | ! old Path [ i ] . length ) continue ; if ( old Path [ i ] = = ' . . ' ) { if ( ! new Path . length ) throw new Error ( "Invalid module path : " + path ) ; new Path . pop ( ) ; continue ; } new Path . push ( old Path [ i ] ) ; } new Path . unshift ( ' ' ) ; return new Path . join ( ' / ' ) ; } bravojs . basename = function bravojs _basename ( path ) { if ( typeof path ! = = "string " ) path = path . to String ( ) ; var s = path . split ( ' / ' ) . slice ( - 1 ) . join ( ' / ' ) ; if ( ! s ) return path ; return s ; } bravojs . dirname = function bravojs _dirname ( path ) { if ( typeof path ! = = "string " ) path = path . to String ( ) ; if ( path . char At ( path . length - 1 ) = = = ' / ' ) return path . slice ( 0 , - 1 ) ; var s = path . split ( ' / ' ) . slice ( 0 , - 1 ) . join ( ' / ' ) ; if ( ! s ) return " . " ; return s ; } bravojs . make Module Id = function make Module Id ( relative Module Dir , module Identifier ) { return bravojs . context For Id ( relative Module Dir , true ) . resolve Id ( module Identifier , relative Module Dir ) ; } bravojs . URL _to Id = function URL _to Id ( module URL , relax Validation ) { var i ; i = module URL . index Of ( " : / / " ) ; if ( i = = - 1 ) throw new Error ( "Invalid module URL : " + module URL ) ; id = module URL . slice ( i + 2 ) ; id = bravojs . realpath ( id ) ; if ( ( i = id . index Of ( ' ? ' ) ) ! = - 1 ) id = id . slice ( 0 , i ) ; if ( ( i = id . index Of ( ' # ' ) ) ! = - 1 ) id = id . slice ( 0 , i ) ; if ( ! relax Validation & & ( id . slice ( - 3 ) ! = " .js " ) ) throw new Error ( "Invalid module URL : " + module URL ) ; id = id . slice ( 0 , - 3 ) ; return id ; } bravojs . normalize Dependency Array = function bravojs _normalize Dependency Array ( dependencies , relative Module Dir ) { var normalized Dependencies = [ ] ; var i , label ; function add Normal ( module Identifier ) { var id = module Identifier ; if ( typeof id ! = "string " | | id . char At ( 0 ) ! = " / " ) id = bravojs . context For Id ( relative Module Dir , true ) . resolve Id ( id , relative Module Dir ) ; if ( id = = = null ) return ; if ( bravojs . require Memo [ id ] | | bravojs . pending Module Declarations [ id ] ) return ; normalized Dependencies . push ( id ) ; } for ( i = 0 ; i < dependencies . length ; i + + ) { if ( dependencies [ i ] ) { switch ( typeof dependencies [ i ] ) { case "object " : for ( label in dependencies [ i ] ) { if ( dependencies [ i ] . has Own Property ( label ) ) add Normal ( dependencies [ i ] [ label ] ) ; } break ; case "string " : add Normal ( dependencies [ i ] ) ; break ; default : throw new Error ( "Invalid dependency array value at position " + ( i + 1 ) ) ; } } } return normalized Dependencies ; } bravojs . context For Id = function bravojs _context For Id ( id , only Create If Delimited ) { return bravojs . contexts [ " _ " ] ; } bravojs . make Context = function bravojs _make Context ( id ) { return bravojs . contexts [ id ] = new bravojs . Context ( id ) ; } bravojs . Context = function bravojs _Context ( id ) { this . id = id ; } bravojs . Context . prototype . resolve Id = function bravojs _Context _resolve Id ( module Identifier , relative Module Dir ) { var id ; if ( module Identifier = = = ' ' ) return ' ' ; if ( typeof module Identifier ! = = "string " ) throw new Error ( "Invalid module identifier : " + module Identifier ) ; if ( module Identifier . char At ( 0 ) = = = ' / ' ) { id = module Identifier ; } else if ( ( module Identifier . index Of ( " . / " ) = = 0 ) | | ( module Identifier . index Of ( " . . / " ) = = 0 ) ) { id = relative Module Dir + " / " + module Identifier ; } else { id = bravojs . main Module Dir + " / " + module Identifier ; } return bravojs . realpath ( id ) ; } bravojs . provide Module = function bravojs _provide Module ( dependencies , module Factory , id , callback ) { if ( module Factory ) bravojs . require . memoize ( id , dependencies , module Factory ) ; if ( dependencies ) { bravojs . module . provide ( bravojs . normalize Dependency Array ( dependencies , id ? bravojs . dirname ( id ) : bravojs . main Module Dir ) , callback ) ; } else { if ( callback ) callback ( ) ; } } bravojs . initialize Module = function bravojs _initialize Module ( id ) { var module Dir = id ? bravojs . dirname ( id ) : bravojs . main Module Dir ; var module Factory = bravojs . pending Module Declarations [ id ] . module Factory ; var dependencies = bravojs . pending Module Declarations [ id ] . dependencies ; var require , exports , module ; delete bravojs . pending Module Declarations [ id ] ; exports = bravojs . require Memo [ id ] = { } ; module = new bravojs . Module ( id , dependencies ) ; if ( typeof module . augment = = "function " ) module . augment ( ) ; require = bravojs . require Factory ( module Dir , dependencies , module ) ; module Factory ( require , exports , module ) ; } bravojs . require Module = function bravojs _require Module ( parent Module Dir , module Identifier ) { bravojs . active Contexts = [ ] ; var id = bravojs . make Module Id ( parent Module Dir , module Identifier ) ; var exports = bravojs . call Plugins ( "require Module " , [ id ] ) ; if ( typeof exports ! = "undefined " ) { if ( exports = = = true ) return bravojs . require Memo [ id ] ; return bravojs . require Memo [ id ] = exports ; } if ( id = = = false ) return null ; if ( ! bravojs . require Memo [ id ] & & bravojs . pending Module Declarations [ id ] ) bravojs . initialize Module ( id ) ; if ( id = = = null | | ! bravojs . require Memo [ id ] ) throw new Error ( "Module " + id + " is not available . " ) ; return bravojs . require Memo [ id ] ; } bravojs . require Factory = function bravojs _require Factory ( module Dir , dependencies , module ) { var deps , i , label ; function get Context Sensitive Module Dir ( ) { var context Id ; if ( bravojs . active Contexts . length > 0 ) context Id = bravojs . active Contexts [ bravojs . active Contexts . length - 1 ] . id ; if ( typeof context Id = = "undefined " | | ! context Id ) context Id = module Dir ; else if ( context Id = = " _ " ) context Id = bravojs . main Module Dir ; return context Id ; } function add Labeled Dep ( module Identifier ) { deps [ label ] = function bravojs _labeled _dependency ( ) { return bravojs . require Module ( get Context Sensitive Module Dir ( ) , module Identifier ) ; } } if ( dependencies ) { for ( i = 0 ; i < dependencies . length ; i + + ) { if ( typeof dependencies [ i ] ! = = "object " ) continue ; for ( label in dependencies [ i ] ) { if ( dependencies [ i ] . has Own Property ( label ) ) { if ( ! deps ) deps = { } ; add Labeled Dep ( dependencies [ i ] [ label ] ) ; } } } } var new Require = function require ( module Identifier ) { if ( deps & & deps [ module Identifier ] ) return deps [ module Identifier ] ( ) ; return bravojs . require Module ( get Context Sensitive Module Dir ( ) , module Identifier ) ; } ; var ret = bravojs . call Plugins ( "new Require " , [ { module : module , deps : deps , get Context Sensitive Module Dir : get Context Sensitive Module Dir } ] ) ; if ( typeof ret ! = "undefined " ) new Require = ret ; new Require . paths = [ bravojs . main Module Dir ] ; if ( typeof bravojs . platform ! = "undefined " ) new Require . platform = bravojs . platform ; new Require . id = function require _id ( module Identifier , unsanitized ) { var context Id = get Context Sensitive Module Dir ( ) , context = bravojs . context For Id ( context Id , true ) ; id = context . resolve Id ( module Identifier , context Id ) ; if ( unsanitized ) return id ; return bravojs . call Plugins ( "sanitize Id " , [ id ] ) | | id ; } new Require . uri = function require _uri ( module Identifier Path ) { var basename = bravojs . basename ( module Identifier Path ) , parts = basename . split ( " . " ) ; var uri = window . location . protocol + " / " + new Require . id ( module Identifier Path , true ) ; if ( parts . length > 1 ) uri + = " . " + parts . slice ( 1 ) . join ( " . " ) ; return uri ; } new Require . canonicalize = function require _canonicalize ( module Identifier ) { var id = bravojs . make Module Id ( get Context Sensitive Module Dir ( ) , module Identifier ) ; if ( id = = = ' ' ) throw new Error ( "Cannot canonically name the resource bearing this main module " ) ; return window . location . protocol + " / " + id + " .js " ; } new Require . memoize = function require _memoize ( id , dependencies , module Factory ) { bravojs . pending Module Declarations [ id ] = { module Factory : module Factory , dependencies : dependencies } ; } new Require . is Memoized = function require _is Memoized ( id ) { return ( bravojs . pending Module Declarations [ id ] | | bravojs . require Memo [ id ] ) ? true : false ; } new Require . get Memoized = function require _get Memoized ( id ) { return bravojs . pending Module Declarations [ id ] | | bravojs . require Memo [ id ] ; } bravojs . call Plugins ( "augment New Require " , [ new Require , { module : module , get Context Sensitive Module Dir : get Context Sensitive Module Dir } ] ) ; return new Require ; } bravojs . Module = function bravojs _Module ( id , dependencies ) { this . _id = id ; this . id = bravojs . call Plugins ( "sanitize Id " , [ id ] ) | | id ; this [ "protected " ] = void 0 ; this . dependencies = dependencies ; this . print = bravojs . print ; var i , label ; this . deps = { } ; for ( i = 0 ; i < dependencies . length ; i + + ) { if ( typeof dependencies [ i ] = = = "string " ) continue ; if ( typeof dependencies [ i ] ! = = "object " ) throw new Error ( "Invalid " + typeof dependencies [ i ] + " element in dependency array at position " + i ) ; for ( label in dependencies [ i ] ) { if ( dependencies [ i ] . has Own Property ( label ) ) { this . deps [ label ] = function bravojs _lambda _module _deps ( ) { bravojs . require Module ( bravojs . dirname ( id ) , dependencies [ i ] [ label ] ) ; } ; } } } } bravojs . Module . prototype . declare = function bravojs _Module _declare ( dependencies , module Factory ) { var stm ; if ( typeof dependencies = = = "function " ) { module Factory = dependencies ; dependencies = [ ] ; } stm = bravojs . script Tag Memo ; if ( stm & & stm . id = = = ' ' ) { delete bravojs . script Tag Memo ; bravojs . provide Module ( dependencies , module Factory , stm . id , stm . callback ) ; return ; } if ( stm ) throw new Error ( "Bug " ) ; if ( document . add Event Listener ) { bravojs . script Tag Memo = { dependencies : dependencies , module Factory : module Factory } ; return ; } stm = bravojs . script Tag Memo IE ; delete bravojs . script Tag Memo IE ; if ( stm & & stm . id ) { bravojs . provide Module ( dependencies , module Factory , stm . id , stm . callback ) ; return ; } var scripts = document . get Elements By Tag Name ( "SCRIPT " ) ; var i ; for ( i = 0 ; i < scripts . length ; i + + ) { if ( scripts [ i ] . ready State = = = "interactive " ) { bravojs . provide Module ( dependencies , module Factory , bravojs . URL _to Id ( scripts [ i ] . src ) , stm . callback ) ; return ; } } throw new Error ( "Could not determine module 's canonical name from script -tag loader " ) ; } bravojs . Module . prototype . provide = function bravojs _Module _provide ( dependencies , callback ) { var self = arguments . callee ; if ( ( typeof dependencies ! = = "object " ) | | ( dependencies . length ! = = 0 & & ! dependencies . length ) ) throw new Error ( "Invalid dependency array : " + dependencies . to String ( ) ) ; dependencies = bravojs . normalize Dependency Array ( dependencies , ( this . _id ) ? this . _id : bravojs . main Module Dir ) ; if ( dependencies . length = = = 0 ) { if ( callback ) callback ( ) ; return ; } bravojs . active Contexts . push ( bravojs . context For Id ( dependencies [ 0 ] , true ) ) ; bravojs . module . load ( dependencies [ 0 ] , function bravojs _lambda _provide Next Dep ( ) { self ( dependencies . slice ( 1 ) , callback ) } ) ; bravojs . active Contexts . pop ( ) ; } bravojs . Module . prototype . load = function bravojs _Module _load ( module Identifier , callback ) { if ( window . module . has Own Property ( "declare " ) ) delete window . module . declare ; var script = document . create Element ( 'SCRIPT ' ) ; script . set Attribute ( "type " , "text /javascript " ) ; script . set Attribute ( "src " , bravojs . require . canonicalize ( module Identifier ) + " ? 1 " ) ; if ( document . add Event Listener ) { script . onload = function bravojs _lambda _script _onload ( ) { var stm = bravojs . script Tag Memo ; if ( typeof stm = = = "undefined " ) throw new Error ( "Module ' " + module Identifier + " ' did not invoke module .declare ! " ) ; delete bravojs . script Tag Memo ; if ( typeof module Identifier = = "object " ) { module Identifier = bravojs . make Module Id ( bravojs . main Module Dir , module Identifier ) ; } bravojs . active Contexts . push ( bravojs . context For Id ( module Identifier , true ) ) ; bravojs . provide Module ( stm . dependencies , stm . module Factory , bravojs . require . id ( module Identifier , true ) , function ( ) { callback ( module Identifier ) ; } ) ; bravojs . active Contexts . pop ( ) ; } script . onerror = function bravojs _lambda _script _onerror ( ) { var id = bravojs . require . id ( module Identifier , true ) ; bravojs . pending Module Declarations [ id ] = null ; callback ( ) ; } } else { bravojs . script Tag Memo IE = { module Identifier : module Identifier , callback : callback } ; script . onreadystatechange = function bravojs _lambda _script _onreadystatechange ( ) { if ( this . ready State ! = "loaded " ) return ; var id = bravojs . require . id ( module Identifier , true ) ; if ( ! bravojs . pending Module Declarations [ id ] & & ! bravojs . require Memo [ id ] & & id = = = bravojs . script Tag Memo IE . module Identifier ) { bravojs . pending Module Declarations [ id ] = null ; callback ( ) ; } } } document . get Elements By Tag Name ( "HEAD " ) [ 0 ] . append Child ( script ) ; } bravojs . Module . prototype . eventually = function ( cb ) { cb ( ) ; } ; bravojs . es 5 _shim _then = function bravojs _es 5 _shim _then ( callback ) { if ( ! Array . prototype . index Of ) { var script = document . create Element ( 'SCRIPT ' ) ; script . set Attribute ( "type " , "text /javascript " ) ; script . set Attribute ( "src " , bravojs . dirname ( bravojs . url ) + " /global -es 5 .js ? 1 " ) ; if ( document . add Event Listener ) script . onload = callback ; else { script . onreadystatechange = function ( ) { if ( this . ready State = = = "loaded " ) callback ( ) ; } } document . get Elements By Tag Name ( "HEAD " ) [ 0 ] . append Child ( script ) ; } else { callback ( ) ; } } bravojs . reload Module = function ( id , callback ) { delete bravojs . pending Module Declarations [ id ] ; delete bravojs . require Memo [ id ] ; bravojs . module . provide ( [ id ] , callback ) ; } bravojs . initialize Main Module = function bravojs _initialize Main Module ( dependencies , module Factory , module Identifier ) { if ( bravojs . module . has Own Property ( "declare " ) ) delete bravojs . module . declare ; if ( bravojs . module . constructor . prototype . main ) throw new Error ( "Main module has already been initialized ! " ) ; bravojs . es 5 _shim _then ( ( function ( ) { bravojs . provide Module ( dependencies , module Factory , module Identifier , function bravojs _lambda _require Main ( ) { bravojs . module . constructor . prototype . main = bravojs . require ( module Identifier ) ; } ) } ) ) ; } bravojs . run External Main Module = function bravojs _run External Program ( dependencies , module Identifier , callback ) { if ( arguments . length = = = 1 | | typeof module Identifier = = = "function " ) { callback = module Identifier ; module Identifier = dependencies ; dependencies = [ ] ; } delete bravojs . module . declare ; if ( module Identifier . char At ( 0 ) = = = ' / ' ) bravojs . main Module Dir = bravojs . dirname ( module Identifier ) ; else bravojs . main Module Dir = bravojs . dirname ( bravojs . URL _to Id ( window . location . href + " .js " ) , true ) + " / " + bravojs . dirname ( module Identifier ) ; module Identifier = bravojs . basename ( module Identifier ) ; bravojs . es 5 _shim _then ( function ( ) { bravojs . module . provide ( dependencies . concat ( [ module Identifier ] ) , function bravojs _run Main Module ( ) { bravojs . initialize Main Module ( dependencies , ' ' , module Identifier ) ; if ( callback ) callback ( ) ; } ) } ) ; } bravojs . reset ( ) ; if ( typeof bravojs . url = = = "undefined " ) { ( function bravojs _set URL ( ) { var i ; var check Basename = false ; var script ; script = document . get Element By Id ( "Bravo JS " ) ; if ( ! script ) { check Basename = true ; script = document . get Elements By Tag Name ( "SCRIPT " ) [ 0 ] ; } bravojs . url = script . src ; i = bravojs . url . index Of ( " ? " ) ; if ( i ! = = - 1 ) bravojs . url = bravojs . url . slice ( 0 , i ) ; i = bravojs . url . index Of ( " # " ) ; if ( i ! = = - 1 ) bravojs . url = bravojs . url . slice ( 0 , i ) ; if ( check Basename & & bravojs . basename ( bravojs . url ) ! = = "bravo .js " ) throw new Error ( "Could not determine Bravo JS URL . Bravo JS must be the first script , or have id = 'Bravo JS ' " ) ; } ) ( ) ; } var print = bravojs . print ; if ( ! window . onerror ) { window . onerror = function window _onerror ( message , url , line ) { var scripts , i ; print ( " \n * Error : " + message + " \n " + " in : " + url + " \n " + " line : " + line ) ; } } } catch ( e ) { bravojs . error Reporter ( e ) ; } } 
function bravojs _print ( ) { var output = " " ; var i ; var stdout ; for ( i = 0 ; i < arguments . length ; i + + ) output + = arguments [ i ] + ( i = = = arguments . length - 1 ? " " : " " ) ; output . replace ( / \t / , " " ) ; if ( typeof window . document ! = "undefined " & & ( stdout = window . document . get Element By Id ( 'stdout ' ) ) ) { output + = " \n " ; if ( typeof stdout . value ! = = "undefined " ) { stdout . value + = output ; if ( stdout . focus ) stdout . focus ( ) ; if ( stdout . tag Name = = = "TEXTAREA " ) stdout . scroll Top = stdout . scroll Height ; } else { if ( typeof stdout . inner Text ! = = "undefined " ) { stdout . inner Text = stdout . inner Text . slice ( 0 , - 1 ) + output + " " ; } else stdout . text Content + = output ; } } else if ( typeof console = = = "object " & & console . print ) { console . print ( output ) ; } else if ( typeof console = = = "object " & & console . log ) { console . log ( output ) ; } 
function str 2blks _MD 5 ( str ) { nblk = ( ( str . length + 8 ) > > 6 ) + 1 ; blks = new Array ( nblk * 1 6 ) ; for ( i = 0 ; i < nblk * 1 6 ; i + + ) blks [ i ] = 0 ; for ( i = 0 ; i < str . length ; i + + ) blks [ i > > 2 ] | = str . char Code At ( i ) < < ( ( i % 4 ) * 8 ) ; blks [ i > > 2 ] | = 0x 8 0 < < ( ( i % 4 ) * 8 ) ; blks [ nblk * 1 6 - 2 ] = str . length * 8 ; return blks ; } 
function cmn ( q , a , b , x , s , t ) { return add ( rol ( add ( add ( a , q ) , add ( x , t ) ) , s ) , b ) ; } 
function bound ( ) { if ( this instanceof bound ) { 
function Setting ( setting Spec , settings ) { this . _settings = settings ; Object . keys ( setting Spec ) . for Each ( function ( key ) { this [ key ] = setting Spec [ key ] ; } , this ) ; this . type = types . get Type ( this . type ) ; if ( this . type = = null ) { throw new Error ( 'In ' + this . name + ' : can \ 't find type for : ' + JSON . stringify ( setting Spec . type ) ) ; } if ( ! this . name ) { throw new Error ( 'Setting .name = = undefined . Ignoring . ' , this ) ; } if ( ! this . default Value = = = undefined ) { throw new Error ( 'Setting .default Value = = undefined ' , this ) ; } if ( this . on Change ) { this . on ( 'change ' , this . on Change . bind ( this ) ) } this . set ( this . default Value ) ; } 
function ( setting Spec ) { var setting = new Setting ( setting Spec , this ) ; this . _settings [ setting . name ] = setting ; this . _setting Names . push ( setting . name ) ; this . _setting Names . sort ( ) ; } 
function ( ) { var reply = [ ] ; this . get Setting Names ( ) . for Each ( function ( setting ) { reply . push ( { 'key ' : setting , 'value ' : this . get Setting ( setting ) . get ( ) } ) ; } , this ) ; return reply ; } 
function ( data ) { 
function ( ) { return this . get Setting Names ( ) . map ( function ( key ) { return this . _settings [ key ] . type . stringify ( this . get ( key ) ) ; } . bind ( this ) ) ; } 
function ( statuses ) { var combined = Status . VALID ; for ( var i = 0 ; i < statuses . length ; i + + ) { if ( statuses [ i ] . value Of ( ) > combined . value Of ( ) ) { combined = statuses [ i ] ; } } return combined ; } 
function Conversion ( value , status , message , predictions ) { this . value = value ; this . status = status | | Status . VALID ; this . message = message ; this . predictions = predictions | | [ ] ; } 
function reconstitute Type ( name , type Spec ) { if ( name . substr ( - 2 ) = = = ' [ ] ' ) { 
function add Command ( command ) { if ( ! command . name ) { throw new Error ( 'All registered commands must have a name ' ) ; } if ( command . params = = null ) { command . params = [ ] ; } if ( ! Array . is Array ( command . params ) ) { throw new Error ( 'command .params must be an array in ' + command . name ) ; } 
function default Args Provider ( request , callback ) { var args = request . args , params = request . command . params ; for ( var i = 0 ; i < params . length ; i + + ) { var param = params [ i ] ; 
function exec ( command , env , sender , args , typed ) { if ( typeof command = = = 'string ' ) { command = commands [ command ] ; } if ( ! command ) { * Executes the command and ensures request .done is called on the request in * case it 's not marked to be done already or async . * / function execute ( ) { command . exec ( env , request . args , request ) ; / / If the request isn 't asnync and isn 't done , then make it done . if ( ! request . is Async & & ! request . is Done ) { request . done ( ) ; } } if ( request . get Status ( ) = = Status . INVALID ) { console . error ( "Canon .exec : Invalid parameter (s ) passed to " + command . name ) ; return false ; } / / If the request isn 't complete yet , try to complete it . else if ( request . get Status ( ) = = Status . INCOMPLETE ) { 
function execute ( ) { command . exec ( env , request . args , request ) ; 
function Request ( options ) { options = options | | { } ; 
function ( editor ) { this . editor = editor ; event . add Listener ( editor . container , "mousedown " , function ( e ) { editor . focus ( ) ; return event . prevent Default ( e ) ; } ) ; event . add Listener ( editor . container , "selectstart " , function ( e ) { return event . prevent Default ( e ) ; } ) ; var mouse Target = editor . renderer . get Mouse Event Target ( ) ; event . add Listener ( mouse Target , "mousedown " , this . on Mouse Down . bind ( this ) ) ; event . add Multi Mouse Down Listener ( mouse Target , 0 , 2 , 5 0 0 , this . on Mouse Double Click . bind ( this ) ) ; event . add Multi Mouse Down Listener ( mouse Target , 0 , 3 , 6 0 0 , this . on Mouse Triple Click . bind ( this ) ) ; event . add Multi Mouse Down Listener ( mouse Target , 0 , 4 , 6 0 0 , this . on Mouse Quad Click . bind ( this ) ) ; event . add Mouse Wheel Listener ( mouse Target , this . on Mouse Wheel . bind ( this ) ) ; } 
function change On Path ( local , op , edit , sync Id , edit Id ) { _ . assert Int ( op ) We need : - an index of every existing inner object by id * / console .log (index + ' ' + edit Names [e .op ] + ' ' + JSON .stringify (e ) ) } ) * / _ .errout ( 'invalid input Object : ' + local .input Object + ' \t ' + edit Id + ' ! = = ' + local .get Editing Id ( ) ) } * / if ( local . object Api Cache ) { ch = local . object Api Cache [ local . input Object ] } if ( ! ch ) { console . log ( 'WARNING : not found ' + local . input Object + ' , only got : ' + JSON . stringify ( Object . keys ( local . object Api Cache | | { } ) ) + ' in ' + local . object Id + ' - - - ' + edit Id ) console . log ( JSON . stringify ( local . edits , null , 2 ) ) throw new Error ( 'here ' ) return } _ . assert Object ( ch ) } var property = ch . type Schema . properties By Code [ local . input Property ] if ( property = = = undefined ) { var candidates = ' ' + JSON . stringify ( _ . map ( Object . keys ( ch . type Schema . properties By Code ) , function ( p ) { return ch . type Schema . properties By Code [ p ] . name + ' : ' + ch . type Schema . properties By Code [ p ] . code } ) ) if ( Top Object Handle . prototype . error On Warn ) { _ . errout ( 'WARNING : logic error or removed property , ' + ch . type Schema . name + ' cannot find property with code : ' + local . input Property + candidates ) } else { console . log ( 'WARNING : logic error or removed property , ' + ch . type Schema . name + ' cannot find property with code : ' + local . input Property + candidates ) } return } 
function same State ( a , b ) { return a . object = = = b . object & & a . property = = = b . property } 
function thing ( type , value ) { if ( arguments . length < 2 ) { if ( instance ( type , Thing ) ) { return type ; } value = type ; type = typeof value = = = 'string ' | | typeof value = = = 'number ' | | instance ( value , Reg Exp ) ? 'text ' : 'unknown ' ; } return instance ( value , Promise ) ? value . then ( thing . bind ( null , type ) ) : new Thing ( type , value ) ; } 
function ( view Name , params , cb ) { _ . assert Length ( arguments , 3 ) _ . assert Defined ( params ) var s = schema [ view Name ] ; if ( s = = = undefined ) _ . errout ( 'unknown view : ' + view Name ) var view Code = s . code ; 
function ( view Code , snapshot Id , previous Id , params Str , cb ) { _ . assert Length ( arguments , 5 ) var s = schema . _by Code [ view Code ] ; var parsed Params = do Parse Params ( params Str , s ) var snap Req = { type Code : view Code , params : pu . params Str ( parsed Params , s . view Schema . params ) , latest Version Id : snapshot Id , previous Version Id : previous Id } ; cc . get Snapshot ( snap Req , function ( err , response ) { if ( err ) { cb ( err ) } else { 
function consume _doctype _or _comment ( proc _stack ) { let html = " < ! " ; proc _stack . t Skip ( 2 ) ; html + = proc _stack . t Accept Until ( " > " ) + proc _stack . t Accept ( ) ; return html ; } 
function consume _char _data _with _entity _directives ( proc _stack , decode _entities , break _on _a , break _on _b ) { let parts = [ ] ; let cur _literal = " " ; while ( ! proc _stack . t Matches ( break _on _a ) & & ( ! break _on _b | | ! proc _stack . t Matches ( break _on _b ) ) ) { let matched = false ; if ( proc _stack . t Matches ( " &zc - " ) ) { if ( decode _entities ) { cur _literal = html Entities . decode ( cur _literal ) ; } parts . push ( cur _literal ) ; cur _literal = " " ; parts . push ( consume _directive _entity ( proc _stack ) ) ; matched = true ; break ; } else { cur _literal + = proc _stack . t Accept ( ) ; } } if ( decode _entities ) { cur _literal = html Entities . decode ( cur _literal ) ; } parts . push ( cur _literal ) ; return parts ; } 
function consume _directive _tag ( proc _stack , tag _name ) { let pos = proc _stack . _t Get NPos ( ) - tag _name . length ; let directive _name = tag _name . slice ( 3 ) ; let raw _args = { } ; proc _stack . t Skip While ( WHITESPACE ) ; while ( ! proc _stack . t Skip If ( " > " ) ) { let arg _name = proc _stack . t Accept Until ( " = " ) ; proc _stack . t Skip ( ) ; if ( ! proc _stack . t Skip If ( " \ " " ) ) { throw new Syntax Error ( ` ` ) ; } raw _args [ arg _name ] = consume _char _data _with _entity _directives ( proc _stack , true , " \ " " ) ; proc _stack . t Skip ( ) ; proc _stack . t Skip While ( WHITESPACE ) ; } let closing _tag = ` $ { directive _name } ` ; 
function consume _opening _or _closing _tag ( proc _stack ) { proc _stack . t Skip ( ) ; let is _closing = proc _stack . t Skip If ( " / " ) ; let tag _name = proc _stack . t Accept Until Set ( TAG _NAME _DELIMITER ) . to Locale Lower Case ( ) ; if ( ! / ^ [a -z 0 - 9 ] + ( - [a -z 0 - 9 ] + ) * ( : [a -z 0 - 9 ] + ( - [a -z 0 - 9 ] + ) * ) ? $ / . test ( tag _name ) ) { throw new Syntax Error ( ` $ { tag _name } ` ) ; } if ( ! is _closing & & / ^zc - / . test ( tag _name ) ) { return consume _directive _tag ( proc _stack , tag _name ) ; } let parts = [ ] ; 
function consume _directive _entity ( proc _stack ) { let pos = proc _stack . _t Get NPos ( ) ; proc _stack . t Skip ( 4 ) ; let directive _name = proc _stack . t Accept Until ( " ( " ) ; proc _stack . t Skip ( ) ; let raw _args = { } ; do { proc _stack . t Skip While ( WHITESPACE ) ; if ( proc _stack . t Peek ( ) = = " ) " ) { break ; } let arg _name = proc _stack . t Accept Until ( " = " ) ; proc _stack . t Skip ( ) ; raw _args [ arg _name ] = consume _char _data _with _entity _directives ( proc _stack , true , " , " , " ) " ) ; } while ( proc _stack . t Skip If ( " , " ) ) ; if ( ! proc _stack . t Skip If ( " ) " ) ) { throw new Syntax Error ( ` ` ) ; } proc _stack . t Skip If ( " ; " ) ; return new Directive Expr ( proc _stack , pos , directive _name , raw _args ) ; } 
function ( method , path , cb ) { http . request ( { hostname : DEFAULT _HOST , port : DEFAULT _PORT , path : path , method : method } , function ( res ) { res . pipe ( concat ( { encoding : 'string ' } , function ( data ) { cb ( data , res . headers , res . status Code ) ; } ) ) ; } ) . end ( ) ; } 
function init ( ) { SXE . init Element Dialog ( 'del ' ) ; if ( SXE . current Action = = "update " ) { set Form Value ( 'datetime ' , tiny MCEPopup . editor . dom . get Attrib ( SXE . update Element , 'datetime ' ) ) ; set Form Value ( 'cite ' , tiny MCEPopup . editor . dom . get Attrib ( SXE . update Element , 'cite ' ) ) ; SXE . show Remove Button ( ) ; } } 
function ( operation , callback , scope ) { var me = this , records = operation . records , ids = me . get Ids ( ) , id Length = ids . length , new Ids = [ ] , removed Hash = { } , i = records . length , id ; operation . set Started ( ) ; for ( ; i - - ; ) { Ext . apply ( removed Hash , me . remove Record ( records [ i ] ) ) ; } for ( i = 0 ; i < id Length ; i + + ) { id = ids [ i ] ; if ( ! removed Hash [ id ] ) { new Ids . push ( id ) ; } } me . set Ids ( new Ids ) ; operation . set Completed ( ) ; operation . set Successful ( ) ; if ( typeof callback = = 'function ' ) { callback . call ( scope | | me , operation ) ; } } 
function ( ) { var me = this , obj = me . get Storage Object ( ) , ids = me . get Ids ( ) , len = ids . length , i ; 
function set Up ( ) { function refit ( ) { if ( ! resize To Fit ( iframe ) ) { 
function resize To Fit ( iframe ) { if ( ! iframe ) { 
function set Pixel Dimensions ( iframe , width , height ) { if ( width ) { iframe . style . width = ` $ { width } ` ; } if ( height ) { iframe . style . height = ` $ { height } ` ; } } 
function ( z , id ) { if ( id = = = undefined ) { return } var type Code = z . object State . get Object Type ( id ) 
function ( version ) { var parts , release Start Index ; if ( version instanceof Version ) { return version ; } this . version = this . short Version = String ( version ) . to Lower Case ( ) . replace ( / _ / g , ' . ' ) . replace ( / [ \ - + ] / g , ' ' ) ; release Start Index = this . version . search ( / ( [ ^ \d \ . ] ) / ) ; if ( release Start Index ! = = - 1 ) { this . release = this . version . substr ( release Start Index , version . length ) ; this . short Version = this . version . substr ( 0 , release Start Index ) ; } this . short Version = this . short Version . replace ( / [ ^ \d ] / g , ' ' ) ; parts = this . version . split ( ' . ' ) ; this . major = parse Int ( parts . shift ( ) | | 0 , 1 0 ) ; this . minor = parse Int ( parts . shift ( ) | | 0 , 1 0 ) ; this . patch = parse Int ( parts . shift ( ) | | 0 , 1 0 ) ; this . build = parse Int ( parts . shift ( ) | | 0 , 1 0 ) ; return this ; } 
function ( current , target ) { var current Value , target Value , i ; current = new Version ( current ) . to Array ( ) ; target = new Version ( target ) . to Array ( ) ; for ( i = 0 ; i < Math . max ( current . length , target . length ) ; i + + ) { current Value = this . get Component Value ( current [ i ] ) ; target Value = this . get Component Value ( target [ i ] ) ; if ( current Value < target Value ) { return - 1 ; } else if ( current Value > target Value ) { return 1 ; } } return 0 ; } 
function ( package Name , version ) { Ext . versions [ package Name ] = new Version ( version ) ; Ext . last Registered Version = Ext . versions [ package Name ] ; return this ; } 
function ( package Name , since , closure , scope ) { if ( Version . compare ( Ext . get Version ( package Name ) , since ) < 1 ) { closure . call ( scope ) ; } } 
function set From Object ( object ) { Object . keys ( object ) . for Each ( ( name ) = > { options [ name ] = object [ name ] ; } ) ; } 
function add Options ( flags ) { Object . keys ( options ) . for Each ( function ( name ) { var dashed Name = to Dash Case ( name ) ; if ( ( name in parse Options ) & & ( name in transform Options ) ) { flags . option ( ' - - ' + dashed Name + ' [true |false |parse ] ' , descriptions [ name ] ) ; flags . on ( dashed Name , ( value ) = > set Option ( dashed Name , value ) ) ; } 
function add Feature Option ( name , kind ) { if ( kind = = = EXPERIMENTAL ) experimental Options [ name ] = true ; Object . define Property ( parse Options , name , { get : function ( ) { return ! ! options [ name ] ; } , enumerable : true , configurable : true } ) ; Object . define Property ( transform Options , name , { get : function ( ) { var v = options [ name ] ; if ( v = = = 'parse ' ) return false ; return v ; } , enumerable : true , configurable : true } ) ; var default Value = options [ name ] | | kind = = = ON _BY _DEFAULT ; options [ name ] = default Value ; default Values [ name ] = default Value ; } 
function ( ) { this . add Events ( 'change ' , 'validitychange ' , 'dirtychange ' ) ; this . init Value ( ) ; 
function ( value 1 , value 2 ) { return String ( Ext . value ( value 1 , ' ' ) ) = = = String ( Ext . value ( value 2 , ' ' ) ) ; } 
function ( ) { var me = this , data = null ; if ( ! me . disabled & & me . submit Value & & ! me . is File Upload ( ) ) { data = { } ; data [ me . get Name ( ) ] = ' ' + me . get Value ( ) ; } return data ; } 
function ( ) { if ( ! this . suspend Check Change ) { var me = this , new Val = me . get Value ( ) , old Val = me . last Value ; if ( ! me . is Equal ( new Val , old Val ) & & ! me . is Destroyed ) { me . last Value = new Val ; me . fire Event ( 'change ' , me , new Val , old Val ) ; me . on Change ( new Val , old Val ) ; } } } 
function ( ) { var me = this , is Dirty = me . is Dirty ( ) ; if ( is Dirty ! = = me . was Dirty ) { me . fire Event ( 'dirtychange ' , me , is Dirty ) ; me . on Dirty Change ( is Dirty ) ; me . was Dirty = is Dirty ; } } 
function ( ) { var me = this , is Valid = me . is Valid ( ) ; if ( is Valid ! = = me . was Valid ) { me . was Valid = is Valid ; me . fire Event ( 'validitychange ' , me , is Valid ) ; } return is Valid ; } 
function munge ( str , options ) { var a Munged = [ ] ; var a Chars , i ; 
function Exclude ( config , options ) { this . _config = config ; this . paths = [ ] ; for ( var index in this . _config ) { var key = this . _config [ index ] ; var keys = key . split ( ' . ' ) ; this . paths . push ( keys ) ; } } 
function ( ) { var header Fragment = this . _parse Header ( ) , data = { } , nodes , elm , matches , editor = this . editor ; function get Attr ( elm , name ) { var value = elm . attr ( name ) ; return value | | ' ' ; } ; / / Default some values data . fontface = editor . get Param ( "fullpage _default _fontface " , " " ) ; data . fontsize = editor . get Param ( "fullpage _default _fontsize " , " " ) ; / / Parse XML PI elm = header Fragment . first Child ; if ( elm . type = = 7 ) { data . xml _pi = true ; matches = / encoding = " ( [ ^ " ] + ) " / . exec ( elm . value ) ; if ( matches ) data . docencoding = matches [ 1 ] ; } / / Parse doctype elm = header Fragment . get All ( ' #doctype ' ) [ 0 ] ; if ( elm ) data . doctype = ' < !DOCTYPE ' + elm . value + " > " ; / / Parse title element elm = header Fragment . get All ( 'title ' ) [ 0 ] ; if ( elm & & elm . first Child ) { data . metatitle = elm . first Child . value ; } / / Parse meta elements each ( header Fragment . get All ( 'meta ' ) , function ( meta ) { var name = meta . attr ( 'name ' ) , http Equiv = meta . attr ( 'http -equiv ' ) , matches ; if ( name ) data [ 'meta ' + name . to Lower Case ( ) ] = meta . attr ( 'content ' ) ; else if ( http Equiv = = "Content -Type " ) { matches = / charset \s * = \s * ( . * ) \s * / gi . exec ( meta . attr ( 'content ' ) ) ; if ( matches ) data . docencoding = matches [ 1 ] ; } } ) ; / / Parse html attribs elm = header Fragment . get All ( 'html ' ) [ 0 ] ; if ( elm ) data . langcode = get Attr ( elm , 'lang ' ) | | get Attr ( elm , 'xml :lang ' ) ; / / Parse stylesheet elm = header Fragment . get All ( 'link ' ) [ 0 ] ; if ( elm & & elm . attr ( 'rel ' ) = = 'stylesheet ' ) data . stylesheet = elm . attr ( 'href ' ) ; / / Parse body parts elm = header Fragment . get All ( 'body ' ) [ 0 ] ; if ( elm ) { data . langdir = get Attr ( elm , 'dir ' ) ; data . style = get Attr ( elm , 'style ' ) ; data . visited _color = get Attr ( elm , 'vlink ' ) ; data . link _color = get Attr ( elm , 'link ' ) ; data . active _color = get Attr ( elm , 'alink ' ) ; } return data ; } 
function ( ) { var me = this , menu Trigger = me . menu Trigger , names = me . layout . names ; 
function ( width , height ) { var me = this ; me . target . set Size ( width , height ) ; me . fire Event ( 'resize ' , me , width , height , null ) ; } 
function getter ( bindings ) { var set = compute Set ( bindings ) var result Set = [ ] for ( var i = 0 ; i < set . length ; + + i ) { var v = set [ i ] var fv = filtered Lookup Index [ v ] if ( fv = = = undefined ) { bindings [ compute For Name ] = v fv = filtered Lookup Index [ v ] = compute For ( bindings ) } 
function ( xhr ) { var me = this , ret = { } , method = 'do ' + Ext . String . capitalize ( xhr . method . to Lower Case ( ) ) , 
function ( character , current Group ) { 
function ( name ) { 
function ( input , format , strict ) { var p = util Date . parse Functions ; if ( p [ format ] = = null ) { util Date . create Parser ( format ) ; } return p [ format ] . call ( util Date , input , Ext . is Defined ( strict ) ? strict : util Date . use Strict ) ; } 
function ( character ) { var f = util Date . format Codes [ character ] ; if ( f ) { f = typeof f = = 'function ' ? f ( ) : f ; util Date . format Codes [ character ] = f ; 
function ( date , format ) { var format Functions = util Date . format Functions ; if ( ! Ext . is Date ( date ) ) { return ' ' ; } if ( format Functions [ format ] = = null ) { util Date . create Format ( format ) ; } return format Functions [ format ] . call ( date ) + ' ' ; } 
function ( date , colon ) { var offset = date . get Timezone Offset ( ) ; return ( offset > 0 ? " - " : " + " ) + Ext . String . left Pad ( Math . floor ( Math . abs ( offset ) / 6 0 ) , 2 , " 0 " ) + ( colon ? " : " : " " ) + Ext . String . left Pad ( Math . abs ( offset % 6 0 ) , 2 , " 0 " ) ; } 
function ( date ) { var num = 0 , d = Ext . Date . clone ( date ) , m = date . get Month ( ) , i ; for ( i = 0 , d . set Date ( 1 ) , d . set Month ( 0 ) ; i < m ; d . set Month ( + + i ) ) { num + = util Date . get Days In Month ( d ) ; } return num + date . get Date ( ) - 1 ; } 
function ( ) { var native Date = window . Date , p , statics = [ 'use Strict ' , 'format Code To Regex ' , 'parse Functions ' , 'parse Regexes ' , 'format Functions ' , 'y 2k Year ' , 'MILLI ' , 'SECOND ' , 'MINUTE ' , 'HOUR ' , 'DAY ' , 'MONTH ' , 'YEAR ' , 'defaults ' , 'day Names ' , 'month Names ' , 'month Numbers ' , 'get Short Month Name ' , 'get Short Day Name ' , 'get Month Number ' , 'format Codes ' , 'is Valid ' , 'parse Date ' , 'get Format Code ' , 'create Format ' , 'create Parser ' , 'parse Codes ' ] , proto = [ 'date Format ' , 'format ' , 'get Timezone ' , 'get GMTOffset ' , 'get Day Of Year ' , 'get Week Of Year ' , 'is Leap Year ' , 'get First Day Of Month ' , 'get Last Day Of Month ' , 'get Days In Month ' , 'get Suffix ' , 'clone ' , 'is DST ' , 'clear Time ' , 'add ' , 'between ' ] , s Len = statics . length , p Len = proto . length , stat , prot , s ; 
function delegate Events On Subviews ( ) { this . delegate Events ( ) ; if ( ! _ . is Undefined ( this . subviews ) ) { _ . each ( this . subviews , function ( subview ) { subview . delegate Events On Subviews ( ) ; } ) ; } } 
function close ( ) { this . undelegate Events ( ) ; if ( ! _ . is Undefined ( this . subviews ) ) { _ . each ( this . subviews , function ( subview ) { subview . close ( ) ; } ) ; } this . $el . empty ( ) ; this . unbind ( ) ; } 
function ( grid ) { var me = this ; grid . on ( { columnresize : me . resize Container , columnhide : me . resize Container , columnshow : me . resize Container , beforedestroy : me . unsetup , reconfigure : me . resetup , scope : me } ) ; grid . add Events ( 'filterupdated ' ) ; Ext . apply ( grid , { filter Bar : me , get Filter Bar : function ( ) { return this . filter Bar ; } } ) ; me . setup ( grid ) ; } 
function ( grid ) { var me = this ; me . grid = grid ; me . visible = ! me . render Hidden ; me . auto Stores = Ext . create ( 'Ext .util .Mixed Collection ' ) ; me . auto Stores Loaded = false ; me . columns = Ext . create ( 'Ext .util .Mixed Collection ' ) ; me . containers = Ext . create ( 'Ext .util .Mixed Collection ' ) ; me . fields = Ext . create ( 'Ext .util .Mixed Collection ' ) ; me . action Column = me . grid . down ( 'actioncolumn ' ) | | me . grid . down ( 'actioncolumnpro ' ) ; me . extra Column = null ; me . clear All El = null ; me . show Hide El = null ; me . task = Ext . create ( 'Ext .util .Delayed Task ' ) ; me . filter Array = [ ] ; me . override Proxy ( ) ; me . parse Filters Config ( ) ; / / sets me .columns and me .auto Stores me . parse Initial Filters ( ) ; / / sets me .filter Array with the store previous filters if any (adds operator and type if missing ) me . render Extra Column ( ) ; / / sets me .extra Column if applicable / / renders the filter 's bar if ( grid . rendered ) { me . render Filter Bar ( grid ) ; } else { grid . on ( 'afterrender ' , me . render Filter Bar , me , { single : true } ) ; } } 
function ( grid ) { var me = this ; if ( me . auto Stores . get Count ( ) ) { me . grid . store . un ( 'load ' , me . fill Auto Stores , me ) ; } me . auto Stores . each ( function ( item ) { Ext . destroy ( item ) ; } ) ; me . auto Stores . clear ( ) ; me . auto Stores = null ; me . columns . each ( function ( column ) { if ( column . rendered ) { if ( column . get El ( ) . has Cls ( me . column Filtered Cls ) ) { column . get El ( ) . remove Cls ( me . column Filtered Cls ) ; } } } , me ) ; me . columns . clear ( ) ; me . columns = null ; me . fields . each ( function ( item ) { Ext . destroy ( item ) ; } ) ; me . fields . clear ( ) ; me . fields = null ; me . containers . each ( function ( item ) { Ext . destroy ( item ) ; } ) ; me . containers . clear ( ) ; me . containers = null ; if ( me . clear All El ) { Ext . destroy ( me . clear All El ) ; me . clear All El = null ; } if ( me . show Hide El ) { Ext . destroy ( me . show Hide El ) ; me . show Hide El = null ; } if ( me . extra Column ) { me . grid . header Ct . items . remove ( me . extra Column ) ; Ext . destroy ( me . extra Column ) ; me . extra Column = null ; } me . task = null ; me . filter Array = null ; } 
function ( ) { var me = this ; / / override encode Filters to append type and operator in remote filtering Ext . apply ( me . grid . store . proxy , { encode Filters : function ( filters ) { var min = [ ] , length = filters . length , i = 0 ; for ( ; i < length ; i + + ) { min [ i ] = { property : filters [ i ] . property , value : filters [ i ] . value } ; if ( filters [ i ] . type ) { min [ i ] . type = filters [ i ] . type ; } if ( filters [ i ] . operator ) { min [ i ] . operator = filters [ i ] . operator ; } } return this . apply Encoding ( min ) ; } } ) ; } 
function ( ) { var me = this ; var columns = this . grid . header Ct . get Grid Columns ( ) ; me . columns . clear ( ) ; me . auto Stores . clear ( ) ; Ext . each ( columns , function ( column ) { if ( column . filter ) { if ( column . filter = = = true | | column . filter = = = 'auto ' ) { / / automatic types configuration (store based ) var type = 'auto ' / /me .grid .store .model .prototype .fields .get (column .data Index ) .type .type ; if ( type = = 'auto ' ) type = 'string ' ; column . filter = type ; } if ( Ext . is String ( column . filter ) ) { column . filter = { type : column . filter / / only set type to then use templates } ; } if ( column . filter . type ) { column . filter = Ext . apply If ( column . filter , me [ column . filter . type + 'Tpl ' ] ) ; / / also use templates but with user configuration } if ( column . filter . xtype = = 'combo ' & & ! column . filter . store ) { column . auto Store = true ; column . filter . store = Ext . create ( 'Ext .data .Array Store ' , { fields : [ { name : 'text ' } , { name : 'id ' } ] } ) ; me . auto Stores . add ( column . data Index , column . filter . store ) ; column . filter = Ext . apply ( column . filter , { display Field : 'text ' , value Field : 'id ' } ) ; } if ( ! column . filter . type ) { switch ( column . filter . xtype ) { case 'combo ' : column . filter . type = ( column . filter . multi Select ? 'list ' : 'combo ' ) ; break ; case 'datefield ' : column . filter . type = 'date ' ; break ; case 'numberfield ' : column . filter . type = ( column . filter . allow Decimals ? 'float ' : 'int ' ) ; break ; default : column . filter . type = 'string ' } } if ( ! column . filter . operator ) { column . filter . operator = me [ column . filter . type + 'Tpl ' ] . operator ; } me . columns . add ( column . data Index , column ) ; } } , me ) ; if ( me . auto Stores . get Count ( ) ) { if ( me . grid . store . get Count ( ) > 0 ) { me . fill Auto Stores ( me . grid . store ) ; } if ( me . grid . store . remote Filter ) { var auto Stores = [ ] ; me . auto Stores . each Key ( function ( key , item ) { auto Stores . push ( key ) ; } ) ; me . grid . store . proxy . extra Params = me . grid . store . proxy . extra Params | | { } ; me . grid . store . proxy . extra Params [ me . auto Stores Remote Property ] = auto Stores ; } me . grid . store . on ( 'load ' , me . fill Auto Stores , me ) ; } } 
function ( store ) { var me = this ; if ( ! me . auto Update Auto Stores & & me . auto Stores Loaded ) return ; me . auto Stores . each Key ( function ( key , item ) { var field = me . fields . get ( key ) ; if ( field ) { field . suspend Events ( ) ; var field Value = field . get Value ( ) ; } if ( ! store . remote Filter ) { / / values from local store var data = store . collect ( key , true , false ) . sort ( ) ; var records = [ ] ; Ext . each ( data , function ( txt ) { if ( Ext . is Empty ( txt ) ) { Ext . Array . insert ( records , 0 , [ { text : me . auto Stores Null Text , id : me . auto Stores Null Value } ] ) ; } else { records . push ( { text : txt , id : txt } ) ; } } ) ; item . load Data ( records ) ; } else { / / values from server if ( store . proxy . reader . raw Data [ me . auto Stores Remote Property ] ) { var data = store . proxy . reader . raw Data [ me . auto Stores Remote Property ] ; if ( data [ key ] ) { var records = [ ] ; Ext . each ( data [ key ] . sort ( ) , function ( txt ) { if ( Ext . is Empty ( txt ) ) { Ext . Array . insert ( records , 0 , [ { text : me . auto Stores Null Text , id : me . auto Stores Null Value } ] ) ; } else { records . push ( { text : txt , id : txt } ) ; } } ) ; item . load Data ( records ) ; } } } if ( field ) { field . set Value ( field Value ) ; field . resume Events ( ) ; } } , me ) ; me . auto Stores Loaded = true ; if ( me . grid . store . remote Filter & & ! me . auto Update Auto Stores ) { delete me . grid . store . proxy . extra Params [ me . auto Stores Remote Property ] ; } } 
function ( ) { var me = this ; me . filter Array = [ ] ; me . grid . store . filters . each ( function ( filter ) { / / try to parse initial filters , for now filter Fn is unsuported if ( filter . property & & ! Ext . is Empty ( filter . value ) & & me . columns . get ( filter . property ) ) { if ( ! filter . type ) filter . type = me . columns . get ( filter . property ) . filter . type ; if ( ! filter . operator ) filter . operator = me . columns . get ( filter . property ) . filter . operator ; me . filter Array . push ( filter ) ; } } , me ) ; } 
function ( ) { var me = this ; if ( me . columns . get Count ( ) & & ! me . action Column & & ( me . show Clear All Button | | me . show Show Hide Button ) ) { var extra Column Css Class = Ext . base CSSPrefix + 'filter -bar -extra -column -hack ' ; if ( ! document . get Element By Id ( extra Column Css Class ) ) { var style = document . create Element ( 'style ' ) ; var css = 'tr . ' + Ext . base CSSPrefix + 'grid -row td . ' + extra Column Css Class + ' { background -color : #ffffff !important ; border -color : #ffffff !important ; } ' ; style . set Attribute ( 'type ' , 'text /css ' ) ; style . set Attribute ( 'id ' , extra Column Css Class ) ; document . body . append Child ( style ) ; if ( style . style Sheet ) { / / IE style . style Sheet . css Text = css ; } else { / / others var css Node = document . create Text Node ( css ) ; style . append Child ( css Node ) ; } } me . extra Column = Ext . create ( 'Ext .grid .column .Column ' , { draggable : false , hideable : false , menu Disabled : true , sortable : false , resizable : false , fixed : true , width : 2 8 , min Width : 2 8 , max Width : 2 8 , header : ' &nbsp ; ' , td Cls : extra Column Css Class } ) ; me . grid . header Ct . add ( me . extra Column ) ; } } 
function ( grid ) { var me = this ; me . containers . clear ( ) ; me . fields . clear ( ) ; me . columns . each Key ( function ( key , column ) { var list Config = column . filter . list Config | | { } ; list Config = Ext . apply ( list Config , { style : 'border -top -width : 1px ' } ) ; var plugins = [ ] ; if ( me . show Clear Button ) { plugins . push ( { ptype : 'clearbutton ' } ) ; } if ( me . enable Operators & & ( column . filter . type = = 'date ' | | column . filter . type = = 'int ' | | column . filter . type = = 'float ' ) ) { plugins . push ( { ptype : 'operatorbutton ' , listeners : { operatorchanged : function ( txt ) { if ( Ext . is Empty ( txt . get Value ( ) ) ) return ; me . apply Instant Filters ( txt ) ; } } } ) ; } var field = Ext . widget ( column . filter . xtype , Ext . apply ( column . filter , { data Index : key , flex : 1 , margin : 0 , field Style : 'border -left -width : 0px ; border -bottom -width : 0px ; ' , list Config : list Config , prevent Mark : true , msg Target : 'none ' , check Change Buffer : 5 0 , enable Key Events : true , listeners : { change : me . apply Delayed Filters , select : me . apply Instant Filters , keypress : function ( txt , e ) { if ( e . get Char Code ( ) = = 1 3 ) { e . stop Event ( ) ; me . apply Instant Filters ( txt ) ; } return false ; } , scope : me } , plugins : plugins } ) ) ; me . fields . add ( column . data Index , field ) ; var container = Ext . create ( 'Ext .container .Container ' , { data Index : key , layout : 'hbox ' , body Style : 'background -color : "transparent " ; ' , width : column . get Width ( ) , items : [ field ] , listeners : { scope : me , element : 'el ' , mousedown : function ( e ) { e . stop Propagation ( ) ; } , click : function ( e ) { e . stop Propagation ( ) ; } , dblclick : function ( e ) { e . stop Propagation ( ) ; } , keydown : function ( e ) { e . stop Propagation ( ) ; } , keypress : function ( e ) { e . stop Propagation ( ) ; } , keyup : function ( e ) { e . stop Propagation ( ) ; } } } ) ; me . containers . add ( column . data Index , container ) ; container . render ( Ext . get ( column . id ) ) ; } , me ) ; var excluded Cols = [ ] ; if ( me . action Column ) excluded Cols . push ( me . action Column . id ) ; if ( me . extra Column ) excluded Cols . push ( me . extra Column . id ) ; Ext . each ( me . grid . header Ct . get Grid Columns ( ) , function ( column ) { if ( ! Ext . Array . contains ( excluded Cols , column . id ) ) { column . set Padding = Ext . Function . create Interceptor ( column . set Padding , function ( h ) { if ( column . has Cls ( Ext . base CSSPrefix + 'column -header -checkbox ' ) ) { / /checkbox column this . title El . set Style ( { padding Top : ' 4px ' } ) ; } return false ; } ) ; } } ) ; me . set Visible ( me . visible ) ; me . render Buttons ( ) ; me . show Initial Filters ( ) ; } 
function ( ) { var me = this ; if ( me . show Show Hide Button & & me . columns . get Count ( ) ) { var column = me . action Column | | me . extra Column ; var button El = column . el . first ( ) . first ( ) ; me . show Hide El = Ext . get ( Ext . core . Dom Helper . append ( button El , { tag : 'div ' , style : 'position : absolute ; width : 1 6px ; height : 1 6px ; top : 3px ; cursor : pointer ; left : ' + parse Int ( ( column . el . get Width ( ) - 1 6 ) / 2 ) + 'px ' , cls : me . show Hide Button Icon Cls , 'data -qtip ' : ( me . render Hidden ? me . show Hide Button Tooltip Do : me . show Hide Button Tooltip Undo ) } ) ) ; me . show Hide El . on ( 'click ' , function ( ) { me . set Visible ( ! me . is Visible ( ) ) ; me . show Hide El . set ( { 'data -qtip ' : ( ! me . is Visible ( ) ? me . show Hide Button Tooltip Do : me . show Hide Button Tooltip Undo ) } ) ; } ) ; } if ( me . show Clear All Button & & me . columns . get Count ( ) ) { var column = me . action Column | | me . extra Column ; var button El = column . el . first ( ) . first ( ) ; me . clear All El = Ext . get ( Ext . core . Dom Helper . append ( button El , { tag : 'div ' , style : 'position : absolute ; width : 1 6px ; height : 1 6px ; top : 2 5px ; cursor : pointer ; left : ' + parse Int ( ( column . el . get Width ( ) - 1 6 ) / 2 ) + 'px ' , cls : me . clear All Button Icon Cls , 'data -qtip ' : me . clear All Button Tooltip } ) ) ; me . clear All El . hide ( ) ; me . clear All El . on ( 'click ' , function ( ) { me . clear Filters ( ) ; } ) ; } } 
function ( ) { var me = this ; Ext . each ( me . filter Array , function ( filter ) { var column = me . columns . get ( filter . property ) ; var field = me . fields . get ( filter . property ) ; if ( ! column . get El ( ) . has Cls ( me . column Filtered Cls ) ) { column . get El ( ) . add Cls ( me . column Filtered Cls ) ; } field . suspend Events ( ) ; field . set Value ( filter . value ) ; field . resume Events ( ) ; } ) ; if ( me . filter Array . length & & me . show Clear All Button ) { me . clear All El . show ( { duration : 1 0 0 0 } ) ; } } 
function ( header Ct , col ) { var me = this ; var data Index = col . data Index ; if ( ! data Index ) return ; var item = me . containers . get ( data Index ) ; if ( item & & item . rendered ) { var item Width = item . get Width ( ) ; var col Width = me . columns . get ( data Index ) . get Width ( ) ; if ( item Width ! = col Width ) { item . set Width ( me . columns . get ( data Index ) . get Width ( ) ) ; item . do Layout ( ) ; } } } 
function ( field ) { if ( ! field . is Valid ( ) ) return ; var me = this , grid = me . grid , column = me . columns . get ( field . data Index ) , new Val = ( grid . store . remote Filter ? field . get Submit Value ( ) : field . get Value ( ) ) ; if ( Ext . is Array ( new Val ) & & new Val . length = = 0 ) { new Val = ' ' ; } var my Index = - 1 ; Ext . each ( me . filter Array , function ( item 2 , index , all Items ) { if ( item 2 . property = = = column . data Index ) { my Index = index ; } } ) ; if ( my Index ! = - 1 ) { me . filter Array . splice ( my Index , 1 ) ; } if ( ! Ext . is Empty ( new Val ) ) { if ( ! grid . store . remote Filter ) { var operator = field . operator | | column . filter . operator , filter Fn ; switch ( operator ) { case 'eq ' : filter Fn = function ( item ) { if ( column . filter . type = = 'date ' ) { return Ext . Date . clear Time ( item . get ( column . data Index ) , true ) . get Time ( ) = = Ext . Date . clear Time ( new Val , true ) . get Time ( ) ; } else { return ( Ext . is Empty ( item . get ( column . data Index ) ) ? me . auto Stores Null Value : item . get ( column . data Index ) ) = = ( Ext . is Empty ( new Val ) ? me . auto Stores Null Value : new Val ) ; } } ; break ; case 'gte ' : filter Fn = function ( item ) { if ( column . filter . type = = 'date ' ) { return Ext . Date . clear Time ( item . get ( column . data Index ) , true ) . get Time ( ) > = Ext . Date . clear Time ( new Val , true ) . get Time ( ) ; } else { return ( Ext . is Empty ( item . get ( column . data Index ) ) ? me . auto Stores Null Value : item . get ( column . data Index ) ) > = ( Ext . is Empty ( new Val ) ? me . auto Stores Null Value : new Val ) ; } } ; break ; case 'lte ' : filter Fn = function ( item ) { if ( column . filter . type = = 'date ' ) { return Ext . Date . clear Time ( item . get ( column . data Index ) , true ) . get Time ( ) < = Ext . Date . clear Time ( new Val , true ) . get Time ( ) ; } else { return ( Ext . is Empty ( item . get ( column . data Index ) ) ? me . auto Stores Null Value : item . get ( column . data Index ) ) < = ( Ext . is Empty ( new Val ) ? me . auto Stores Null Value : new Val ) ; } } ; break ; case 'ne ' : filter Fn = function ( item ) { if ( column . filter . type = = 'date ' ) { return Ext . Date . clear Time ( item . get ( column . data Index ) , true ) . get Time ( ) ! = Ext . Date . clear Time ( new Val , true ) . get Time ( ) ; } else { return ( Ext . is Empty ( item . get ( column . data Index ) ) ? me . auto Stores Null Value : item . get ( column . data Index ) ) ! = ( Ext . is Empty ( new Val ) ? me . auto Stores Null Value : new Val ) ; } } ; break ; case 'like ' : filter Fn = function ( item ) { var re = new Reg Exp ( new Val , 'i ' ) ; return re . test ( item . get ( column . data Index ) ) ; } ; break ; case 'in ' : filter Fn = function ( item ) { var re = new Reg Exp ( ' ^ ' + new Val . join ( ' | ' ) + ' $ ' , 'i ' ) ; return re . test ( ( Ext . is Empty ( item . get ( column . data Index ) ) ? me . auto Stores Null Value : item . get ( column . data Index ) ) ) ; } ; break ; } me . filter Array . push ( Ext . create ( 'Ext .util .Filter ' , { property : column . data Index , filter Fn : filter Fn , me : me } ) ) ; } else { me . filter Array . push ( Ext . create ( 'Ext .util .Filter ' , { property : column . data Index , value : new Val , type : column . filter . type , operator : ( field . operator | | column . filter . operator ) } ) ) ; } if ( ! column . get El ( ) . has Cls ( me . column Filtered Cls ) ) { column . get El ( ) . add Cls ( me . column Filtered Cls ) ; } } else { if ( column . get El ( ) . has Cls ( me . column Filtered Cls ) ) { column . get El ( ) . remove Cls ( me . column Filtered Cls ) ; } } grid . store . current Page = 1 ; if ( me . filter Array . length > 0 ) { if ( ! grid . store . remote Filter ) grid . store . clear Filter ( ) ; grid . store . filters . clear ( ) ; grid . store . filter ( me . filter Array ) ; if ( me . clear All El ) { me . clear All El . show ( { duration : 1 0 0 0 } ) ; } } else { grid . store . clear Filter ( ) ; if ( me . clear All El ) { me . clear All El . hide ( { duration : 1 0 0 0 } ) ; } } if ( ! grid . store . remote Filter & & me . auto Update Auto Stores ) { me . fill Auto Stores ( ) ; } me . fire Event ( 'filterupdated ' , me . filter Array ) ; } 
function ( field ) { if ( ! field . is Valid ( ) ) return ; var me = this ; me . task . delay ( me . update Buffer , me . apply Filters , me , [ field ] ) ; } 
function ( ) { var me = this , field = undefined ; Ext . each ( me . grid . header Ct . get Grid Columns ( ) , function ( col ) { if ( col . filter ) { field = me . fields . get ( col . data Index ) ; return false ; } } ) ; return field ; } 
function read Sync ( ) { const TLS _CERT = process . env . TLS _CERT ; const TLS _KEY = process . env . TLS _KEY ; const TLS _CA = process . env . TLS _CA ; const tls _cert = read Opt ( " - -tls -cert " ) ; const tls _key = read Opt ( " - -tls -key " ) ; const tls _ca = read Opt ( " - -tls -ca " ) ; const result = { secure Options : constants . SSL _OP _NO _TLSv 1 } ; if ( tls _cert ) { if ( tls _key ) { result . cert = fs . read File Sync ( tls _cert ) ; result . key = fs . read File Sync ( tls _key ) ; if ( tls _ca ) { result . ca = fs . read File Sync ( tls _ca ) ; } } else { result . pfx = fs . read File Sync ( tls _cert ) ; } } else if ( TLS _CERT ) { if ( TLS _KEY ) { result . cert = fs . read File Sync ( TLS _CERT ) ; result . key = fs . read File Sync ( TLS _KEY ) ; if ( TLS _CA ) { result . ca = fs . read File Sync ( TLS _CA ) ; } } else { result . pfx = fs . read File Sync ( TLS _CERT ) ; } } return result ; } 
function read ( ) { const TLS _CERT = process . env . TLS _CERT ; const TLS _KEY = process . env . TLS _KEY ; const TLS _CA = process . env . TLS _CA ; const tls _cert = read Opt ( " - -tls -cert " ) ; const tls _key = read Opt ( " - -tls -key " ) ; const tls _ca = read Opt ( " - -tls -ca " ) ; const result = { } ; if ( tls _cert ) { if ( tls _key ) { result . cert = read File ( tls _cert ) ; result . key = read File ( tls _key ) ; if ( tls _ca ) { result . ca = read File ( tls _ca ) ; } } else { result . pfx = read File ( tls _cert ) ; } } else if ( TLS _CERT ) { if ( TLS _KEY ) { result . cert = read File ( TLS _CERT ) ; result . key = read File ( TLS _KEY ) ; if ( TLS _CA ) { result . ca = read File ( TLS _CA ) ; } } else { result . pfx = read File ( TLS _CERT ) ; } } return Promise . all ( keys ( result ) . map ( key = > result [ key ] . then ( data = > { return result [ key ] = data ; } ) ) ) . then ( ( ) = > result ) ; } 
function read Opt ( option ) { const prefix = ` $ { option } ` ; for ( let i = 0 , len = process . argv . length , arg ; i < len ; i + + ) { arg = process . argv [ i ] ; if ( arg = = = option ) { return process . argv [ i + 1 ] ; } else if ( arg . index Of ( prefix ) = = = 0 ) { return arg . substr ( prefix . length ) ; } } } 
function check Params ( type Code , params , err Cb ) { _ . assert Function ( err Cb ) var view Schema = schema . _by Code [ type Code ] var failed = false var e = new Error ( 'parameters include an invalid object id ' ) e .code = 'Invalid Param Id ' err Cb (e ) return false }else * / if ( object State . is Deleted ( params [ i ] ) ) { var e = new Error ( 'parameters include a object id for a deleted object ' ) e . code = 'Invalid Param Id ' err Cb ( e ) return false } } } return true } 
function ( type Code , params , historical Key , cb ) { var c = object State . get Current Edit Id ( ) var real Versions = [ c - 1 ] 
function LLog ( opts ) { var options = opts | | { } , level = default Level , stdout ; if ( typeof opts = = = 'object ' & & opts ! = null ) { level = opts . level | | level ; stdout = opts . stdout ; } else { if ( typeof opts ! = = 'undefined ' ) { level = opts ; } if ( arguments . length > 1 ) { stdout = arguments [ 1 ] ; } } this . level = handle Level ( level ) | | level ; if ( stdout ) { this . stdout = stdout ; } else if ( typeof process ! = = 'undefined ' & & process . stdout & & typeof LLOG _SKIP _USING _PROCESS = = = 'undefined ' ) { 
function sendfile ( req , res ) { 
function ( target ) { var me = this , anims = [ ] , timeline = me . timeline , ln = timeline . length , anim , easing , damper , attrs , i ; if ( me . fire Event ( 'beforeanimate ' , me ) ! = = false ) { for ( i = 0 ; i < ln ; i + + ) { anim = timeline [ i ] ; attrs = anim . attrs ; easing = attrs . easing | | me . easing ; damper = attrs . damper | | me . damper ; delete attrs . easing ; delete attrs . damper ; anim = new Ext . fx . Anim ( { target : target , easing : easing , damper : damper , duration : anim . duration , paused : true , to : attrs } ) ; anims . push ( anim ) ; } me . animations = anims ; me . target = anim . target ; for ( i = 0 ; i < ln - 1 ; i + + ) { anim = anims [ i ] ; anim . next Anim = anims [ i + 1 ] ; anim . on ( 'afteranimate ' , function ( ) { this . next Anim . paused = false ; } ) ; anim . on ( 'afteranimate ' , function ( ) { this . fire Event ( 'keyframe ' , this , + + this . keyframe Step ) ; } , me ) ; } anims [ ln - 1 ] . on ( 'afteranimate ' , function ( ) { this . last Frame ( ) ; } , me ) ; } } 
function Set ( iter , options ) { if ( ! ( this instanceof Set ) ) return new Set ( iter , options ) ; this . _o = { } ; this . length = 0 ; 
function ( el , html , return Element ) { var new Node ; el = Ext . get Dom ( el ) ; html = this . markup ( html ) ; 
function ( ) { var me = this , chart = me . chart , store = chart . get Chart Store ( ) , data = store . data . items , count = me . get Record Count ( ) , i , ln , record , min , max , x Field = me . x Field , x Value ; if ( count > 0 ) { min = Infinity ; max = - min ; for ( i = 0 , ln = data . length ; i < ln ; i + + ) { record = data [ i ] ; x Value = record . get ( x Field ) ; if ( x Value > max ) { max = x Value ; } if ( x Value < min ) { min = x Value ; } } 
function ( ) { var me = this , chart = me . chart , store = chart . get Chart Store ( ) , data = store . data . items , count = me . get Record Count ( ) , i , ln , record , stacked = me . stacked , min , max , positive Total , negative Total ; function each YValue Stacked ( y Value , i ) { if ( ! me . is Excluded ( i ) ) { if ( y Value < 0 ) { negative Total + = y Value ; } else { positive Total + = y Value ; } } } function each YValue ( y Value , i ) { if ( ! me . is Excluded ( i ) ) { if ( y Value > max ) { max = y Value ; } if ( y Value < min ) { min = y Value ; } } } if ( count > 0 ) { min = Infinity ; max = - min ; for ( i = 0 , ln = data . length ; i < ln ; i + + ) { record = data [ i ] ; if ( stacked ) { positive Total = 0 ; negative Total = 0 ; me . each YValue ( record , each YValue Stacked ) ; if ( positive Total > max ) { max = positive Total ; } if ( negative Total < min ) { min = negative Total ; } } else { me . each YValue ( record , each YValue ) ; } } 
function ( cls ) { var me = this , result = me . call Parent ( arguments ) , classes = [ me . base Cls + ' -body - ' + cls , me . base Cls + ' -body - ' + me . ui + ' - ' + cls ] , array , i ; if ( me . body Cls ) { array = me . body Cls . split ( ' ' ) ; for ( i = 0 ; i < classes . length ; i + + ) { if ( ! Ext . Array . contains ( array , classes [ i ] ) ) { array . push ( classes [ i ] ) ; } } me . body Cls = array . join ( ' ' ) ; } else { me . body Cls = classes . join ( ' ' ) ; } return result ; } 
function ( ) { var me = this , array , cls ; me . call Parent ( arguments ) ; cls = me . base Cls + ' -body - ' + me . ui ; if ( me . rendered ) { if ( me . body Cls ) { me . body . add Cls ( me . body Cls ) ; } else { me . body . add Cls ( cls ) ; } } else { if ( me . body Cls ) { array = me . body Cls . split ( ' ' ) ; if ( ! Ext . Array . contains ( array , cls ) ) { array . push ( cls ) ; } me . body Cls = array . join ( ' ' ) ; } else { me . body Cls = cls ; } } if ( me . title Cmp & & me . title Cmp . rendered ) { me . title Cmp . add Cls ( me . base Cls + ' -text -container - ' + me . ui ) ; } } 
function ( ) { var me = this , array , cls ; me . call Parent ( arguments ) ; cls = me . base Cls + ' -body - ' + me . ui ; if ( me . rendered ) { if ( me . body Cls ) { me . body . remove Cls ( me . body Cls ) ; } else { me . body . remove Cls ( cls ) ; } } else { if ( me . body Cls ) { array = me . body Cls . split ( ' ' ) ; Ext . Array . remove ( array , cls ) ; me . body Cls = array . join ( ' ' ) ; } else { me . body Cls = cls ; } } if ( me . title Cmp & & me . title Cmp . rendered ) { me . title Cmp . remove Cls ( me . base Cls + ' -text -container - ' + me . ui ) ; } } 
function ( title ) { var me = this , title Cmp = me . title Cmp ; me . title = title ; if ( title Cmp . rendered ) { title Cmp . text El . update ( me . title | | ' & # 1 6 0 ; ' ) ; title Cmp . update Layout ( ) ; } else { me . title Cmp . on ( { render : function ( ) { me . set Title ( title ) ; } , single : true } ) ; } } 
function ( cls ) { var me = this , is Empty = ! cls | | ! cls . length , icon Cmp = me . icon Cmp ; me . icon Cls = cls ; if ( ! me . icon Cmp & & ! is Empty ) { me . init Icon Cmp ( ) ; me . insert ( 0 , me . icon Cmp ) ; } else if ( icon Cmp ) { if ( is Empty ) { me . icon Cmp . destroy ( ) ; delete me . icon Cmp ; } else { icon Cmp . remove Cls ( icon Cmp . icon Cls ) ; icon Cmp . add Cls ( cls ) ; icon Cmp . icon Cls = cls ; } } } 
function ( icon ) { var me = this , is Empty = ! icon | | ! icon . length , icon Cmp = me . icon Cmp ; me . icon = icon ; if ( ! me . icon Cmp & & ! is Empty ) { me . init Icon Cmp ( ) ; me . insert ( 0 , me . icon Cmp ) ; } else if ( icon Cmp ) { if ( is Empty ) { me . icon Cmp . destroy ( ) ; delete me . icon Cmp ; } else { icon Cmp . set Src ( me . icon ) ; } } } 
function ( glyph ) { var me = this , icon Cmp = me . icon Cmp ; if ( ! me . icon Cmp ) { me . init Icon Cmp ( ) ; me . insert ( 0 , me . icon Cmp ) ; } else if ( icon Cmp ) { if ( glyph ) { me . icon Cmp . set Glyph ( glyph ) ; } else { me . icon Cmp . destroy ( ) ; delete me . icon Cmp ; } } } 
function class Call ( func , object , static Object , super Class ) { if ( super Class ) { return parse Expression ` $ { func } $ { object } $ { static Object } $ { super Class } ` ; } return parse Expression ` $ { func } $ { object } $ { static Object } ` ; } 
function ( ) { var me = this ; if ( me . load On Show & & ! me . loaded & & ! me . store . loading ) { me . store . load ( ) ; } me . call Parent ( ) ; } 
function ( item , checked ) { var value = [ ] ; this . items . each ( function ( item ) { if ( item . checked ) { value . push ( item . value ) ; } } ) ; this . selected = value ; this . fire Event ( 'checkchange ' , item , checked ) ; } 
function is Type ( type , val ) { return ( type = = Any ) | | ( type = = Object & & is . object ( val ) ) | | ( type = = Function & & is . function ( val ) ) | | ( type = = String & & is . string ( val ) ) | | ( type = = Error & & is . error ( val ) ) | | ( type = = Number & & is . number ( val ) ) | | ( type = = Array & & is . array ( val ) ) | | ( type = = Boolean & & is . boolean ( val ) ) | | ( type = = Reg Exp & & is . reg Exp ( val ) ) | | ( type = = Date & & is . date ( val ) ) | | ( type = = null & & is . null Or Undefined ( val ) ) | | ( val instanceof type ) } 
function find Morph ( args , morphs ) { for ( var i = 0 ; i < morphs . length ; i + + ) { var sig = morphs [ i ] . sig if ( args . length = = sig . length ) { var matched = true for ( var j = 0 ; j < sig . length ; j + + ) { if ( ! is Type ( sig [ j ] , args [ j ] ) ) { matched = false break } } if ( matched ) { return morphs [ i ] } } } throw new Error ( 'No matching function signature ' ) } 
function subscribe ( callback ) { 
function save ( ) { 
function convert Json To Edits ( db Schema , type , json , top Temporary Id ) { 
function ( ed ) { var t = this , show Menu , contextmenu Never Use Native , real Ctrl Key , hide Menu ; t . editor = ed ; contextmenu Never Use Native = ed . settings . contextmenu _never _use _native ; t . on Context Menu = new tinymce . util . Dispatcher ( this ) ; hide Menu = function ( e ) { hide ( ed , e ) ; } ; show Menu = ed . on Context Menu . add ( function ( ed , e ) { / / Block Tiny MCE menu on ctrl Key and work around Safari issue if ( ( real Ctrl Key ! = = 0 ? real Ctrl Key : e . ctrl Key ) & & ! contextmenu Never Use Native ) return ; Event . cancel ( e ) ; / / Select the image if it 's clicked . Web Kit would other wise expand the selection if ( e . target . node Name = = 'IMG ' ) ed . selection . select ( e . target ) ; t . _get Menu ( ed ) . show Menu ( e . client X | | e . page X , e . client Y | | e . page Y ) ; Event . add ( ed . get Doc ( ) , 'click ' , hide Menu ) ; ed . node Changed ( ) ; } ) ; ed . on Remove . add ( function ( ) { if ( t . _menu ) t . _menu . remove All ( ) ; } ) ; function hide ( ed , e ) { real Ctrl Key = 0 ; / / Since the contextmenu event moves / / the selection we need to store it away if ( e & & e . button = = 2 ) { real Ctrl Key = e . ctrl Key ; return ; } if ( t . _menu ) { t . _menu . remove All ( ) ; t . _menu . destroy ( ) ; Event . remove ( ed . get Doc ( ) , 'click ' , hide Menu ) ; t . _menu = null ; } } ; ed . on Mouse Down . add ( hide ) ; ed . on Key Down . add ( hide ) ; ed . on Key Down . add ( function ( ed , e ) { if ( e . shift Key & & ! e . ctrl Key & & ! e . alt Key & & e . key Code = = = 1 2 1 ) { Event . cancel ( e ) ; show Menu ( ed , e ) ; } } ) ; } 
function generate Assign State Out Of Finally ( enclosing Finally , destination ) { var finally State = enclosing Finally . finally State ; 
function directory _path ( ) { pending + + readdir ( entry , ( err , children ) = > { if ( err ) return done ( err ) 
function file _path ( ) { pending + + for ( var i = globs . length ; i - - ; ) { const glob = globs [ i ] const glob _full = glob . glob const glob _base = glob . base const glob _negated = glob . negated const glob _pattern = glob . pattern if ( entry = = = glob _full | | mm . is Match ( entry , glob _pattern , ALLOW ) ) { return done ( null , file ) } } 
function get ( key ) { debug ( 'getting ` %s ` ' , key ) ; var value ; if ( this . cookies & & _ . has ( this . cookies , key ) ) { value = this . cookies [ key ] ; } return value ; } 
function set ( key , value ) { debug ( 'setting ` %s ` to ` %j ` ' , key , value ) ; if ( _ . is Undefined ( this . cookies ) ) { this . cookies = { } ; } this . cookies [ key ] = value ; } 
function process Arguments ( argv ) { 
function extend ( a , b , no Clone ) { 
function clone ( o ) { var c = { } ; var h = Object . keys ( o ) ; for ( var i = 0 , co = h . length ; i < co ; i + + ) { c [ h [ i ] ] = o [ h [ i ] ] ; } return c ; } 
function fix Path ( string ) { if ( string . length < 1 ) { return string ; } if ( string . char At ( string . length - 1 ) ! = = path . sep ) { string + = path . sep ; } return string ; } 
function stringify ( string , params , no Error ) { var arr = string . split ( ' : ' ) ; var param ; for ( var i = 0 , c = arr . length ; i < c ; i + + ) { param = arr [ i ] ; if ( i % 2 ) { if ( ! ( typeof params [ param ] = = = 'string ' | | typeof params [ param ] = = = 'number ' ) ) { if ( ! no Error ) { throw new Error ( 'Variable ' + param + ' not defined ' ) ; } } else { arr [ i ] = params [ param ] ; } } } return arr . join ( ' ' ) ; } 
function clean Callback ( error Callback , callback ) { var self = this | | { } ; if ( ! callback ) { return function ( err ) { 
function iterate Elements ( array ) { var index = 0 ; var rv = { } ; rv [ Symbol . iterator ] = { next ( ) { if ( index < array . length ) return { value : array [ index + + ] , done : false } ; return { done : true } ; } } } 
function could Chain ( r , many Indexes ) { many Indexes = many Indexes | | 0 var sub Param = could Chain (r .params [ 1 ] .expr , 2 ) if (sub Param .name = = = r .params [ 1 ] .implicits [ 0 ] ) { } }else if (r .type = = = 'view ' ) { var all Params = [ ] var has = { } r .params .for Each (function (p ) { var pm = could Chain (p , 2 ) if ( !pm ) all Params = undefined if (all Params & & !has [pm .name ] ) { all Params .push (pm ) has [pm .name ] = true } } ) if (all Params & & all Params .length = = = 1 ) { return all Params [ 0 ] } } * / } 
function Ping Pong ( interval Ms , retry Limit , ping , on Timeout ) { if ( typeof interval Ms ! = = 'number ' | | interval Ms < 0 ) throw new Error ( 'interval Ms must be an integer > = 0 but was : ' + interval Ms ) ; if ( typeof retry Limit ! = = 'number ' | | retry Limit < 0 ) throw new Error ( 'retry Limit must be an integer > = 0 but was : ' + retry Limit ) ; 
function clear ( timer ) { log ( 'stop ' ) ; timer . state . interval Timer = clear Interval ( timer . state . interval Timer ) ; timer . state . retry Counter . clear ( ) ; return timer ; } 
function pong ( timer ) { if ( ! timer . state . received Pong ) { log ( ' < pong ' ) ; timer . state . received Pong = true ; timer . state . retry Counter . reset ( ) ; timer . state . rounds Count + + ; } return timer ; } 
function _start ( timer ) { log ( 'start %j ' , timer . conf ) ; timer . state . interval Timer = set Interval ( _on Interval , timer . conf . interval Ms , timer ) ; return _ping ( timer ) ; } 
function compute 2 ( a , b ) { if ( ! a | | ! b ) return [ ] if ( a . length > b . length ) { var t = b b = a a = t } if ( a . length = = = 0 ) return [ ] if ( a . length = = = 1 ) { if ( b . index Of ( a [ 0 ] ) = = = - 1 ) { return [ ] } else { return a } } var ma = { } for ( var j = 0 ; j < a . length ; + + j ) { ma [ a [ j ] ] = true } var result = [ ] for ( var j = 0 ; j < b . length ; + + j ) { var v = b [ j ] if ( ma [ v ] ) { result . push ( v ) } } 
function xgettext ( template , options ) { options = options | | { } ; var identifiers = options . identifiers | | Catalog . DEFAULT _IDENTIFIERS ; var default Domain = options . default Domain | | 'messages ' ; var comment Identifiers = options . comment Identifiers | | [ 'gettext -comment ' ] ; var filename = options . filename ; 
function ( fo , clear ) { this . filters = fo ; if ( this . filters & & this . filter Fields ) { 
function Gedcom XDate ( str ) { if ( str = = ' ' ) { throw new Error ( 'Invalid Date ' ) ; } if ( str . char At ( 0 ) = = 'R ' ) { return new Recurring ( str ) ; } else if ( / \ / / . test ( str ) ) { return new Range ( str ) ; } else if ( str . char At ( 0 ) = = 'A ' ) { return new Approximate ( str ) ; } else { return new Simple ( str ) ; } } 
function ( e ) { var me = this , over Tab = me . _over Tab , tab Info , tab ; if ( e . get Target ( ' . ' + Ext . base CSSPrefix + 'box -scroller ' ) ) { return ; } tab Info = me . get Tab Info From Point ( e . get XY ( ) ) ; tab = tab Info . tab ; if ( tab ! = = over Tab ) { if ( over Tab & & over Tab . rendered ) { over Tab . on Mouse Leave ( e ) ; me . _over Tab = null ; } if ( tab ) { tab . on Mouse Enter ( e ) ; me . _over Tab = tab ; if ( ! tab . disabled ) { me . el . set Style ( 'cursor ' , 'pointer ' ) ; } } else { me . el . set Style ( 'cursor ' , 'default ' ) ; } } } 
function ( to Close ) { var me = this ; if ( to Close . active & & me . items . get Count ( ) > 1 ) { return ( me . previous Tab & & me . previous Tab ! = = to Close & & ! me . previous Tab . disabled ) ? me . previous Tab : ( to Close . next ( 'tab [disabled =false ] ' ) | | to Close . prev ( 'tab [disabled =false ] ' ) ) ; } } 
function update Localization ( ) { const medium = $scope . resources . medium ; if ( ! medium | | ! show Media ) { return ; } if ( medium . i 1 8n Name ) { medium . name = ax I 1 8n . localize ( medium . i 1 8n Name ) ; } if ( medium . i 1 8n Description ) { medium . description = ax I 1 8n . localize ( medium . i 1 8n Description ) ; } } 
function update Model ( ) { const medium = $scope . resources . medium ; if ( ! medium | | ! show Media ) { return ; } if ( ! ( medium . mime Type in MEDIA _TYPE _BY _MIME _TYPE ) ) { log . warn ( 'Unsupported mime Type : [ 0 ] ' , medium . mime Type ) ; } const model = $scope . model ; 
function parse Url ( url ) { 
function is Same Origin ( url ) { const frame Loc = parse Url ( url ) ; const loc = window . location ; 
function ( auto Render , config ) { if ( ! tip ) { if ( ! Ext . is Ready ) { Ext . on Ready ( function ( ) { Ext . tip . Quick Tip Manager . init ( auto Render , config ) ; } ) ; return ; } var tip Config = Ext . apply ( { disabled : disabled , id : 'ext -quicktips -tip ' } , config ) , class Name = tip Config . class Name , xtype = tip Config . xtype ; if ( class Name ) { delete tip Config . class Name ; } else if ( xtype ) { class Name = 'widget . ' + xtype ; delete tip Config . xtype ; } if ( auto Render ! = = false ) { tip Config . render To = document . body ; 
function ( ) { var me = this , args = arguments ; if ( me . has Own Property ( 'child Els ' ) ) { me . child Els . push . apply ( me . child Els , args ) ; } else { me . child Els = me . get Child Els ( ) . concat ( Array . prototype . slice . call ( args ) ) ; } me . prune ( me . child Els , false ) ; } 
function ( el , id ) { var me = this , child Els = me . get Child Els ( ) , base Id , child Name , i , selector , value ; base Id = ( id | | me . id ) + ' - ' ; for ( i = child Els . length ; i - - ; ) { child Name = child Els [ i ] ; if ( typeof child Name = = 'string ' ) { 
function ( test Fn ) { var me = this , old = me . get Child Els ( ) , keepers = ( me . child Els = [ ] ) , n , i , cel ; for ( i = 0 , n = old . length ; i < n ; + + i ) { cel = old [ i ] ; if ( ! test Fn ( cel ) ) { keepers . push ( cel ) ; } } } 
function multi Field Sort ( array , sort By ) { array . sort ( ( a , b ) = > { for ( let field of sort By ) { let reverse = field [ 0 ] = = = ' - ' ; if ( reverse ) { field = field . slice ( 1 ) ; } let value A = get Path ( a , field ) ; let value B = get Path ( b , field ) ; if ( reverse ) { if ( value A > value B ) return - 1 ; else if ( value A < value B ) return 1 ; } else { if ( value A > value B ) return 1 ; else if ( value A < value B ) return - 1 ; } } return 0 ; } ) ; return array ; } 
function ( bookmark ) { var t = this , ed = t . editor , nl , i , h , d = ed . get Doc ( ) , b = ed . get Body ( ) , nv , s = ed . selection , bo , div , bm ; t . state = ! t . state ; ed . control Manager . set Active ( 'visualchars ' , t . state ) ; if ( bookmark ) bm = s . get Bookmark ( ) ; if ( t . state ) { nl = [ ] ; tinymce . walk ( b , function ( n ) { if ( n . node Type = = 3 & & n . node Value & & n . node Value . index Of ( ' \u 0 0a 0 ' ) ! = - 1 ) nl . push ( n ) ; } , 'child Nodes ' ) ; for ( i = 0 ; i < nl . length ; i + + ) { nv = nl [ i ] . node Value ; nv = nv . replace ( / ( \u 0 0a 0 ) / g , ' <span data -mce -bogus = " 1 " class = "mce Item Hidden mce Item Nbsp " > $ 1 < /span > ' ) ; div = ed . dom . create ( 'div ' , null , nv ) ; while ( node = div . last Child ) ed . dom . insert After ( node , nl [ i ] ) ; ed . dom . remove ( nl [ i ] ) ; } } else { nl = ed . dom . select ( 'span .mce Item Nbsp ' , b ) ; for ( i = nl . length - 1 ; i > = 0 ; i - - ) ed . dom . remove ( nl [ i ] , 1 ) ; } s . move To Bookmark ( bm ) ; } 
function GET ( . . . args ) { let options = { } ; if ( args [ args . length - 1 ] = = = 'http ' ) { options = { hostname : args [ 0 ] , port : 8 0 , path : args [ 1 ] ? args [ 1 ] : ' / ' , method : 'GET ' , headers : args [ 2 ] ? args [ 2 ] : { } } ; return new Promise ( ( resolve , reject ) = > { let chunk = [ ] ; const req = http . request ( options , ( res ) = > { res . on ( 'data ' , ( data ) = > { chunk . push ( data ) ; } ) ; res . on ( 'end ' , ( ) = > { let data = Buffer . concat ( chunk ) ; resolve ( JSON . parse ( data . to String ( ) ) ) ; } ) ; } ) ; req . end ( ) ; req . on ( 'error ' , ( error ) = > { reject ( error ) ; } ) ; } ) ; } else if ( args [ args . length - 1 ] = = = 'https ' ) { options = { hostname : args [ 0 ] , port : 4 4 3 , path : args [ 1 ] ? args [ 1 ] : ' / ' , method : 'GET ' , headers : args [ 2 ] ? args [ 2 ] : { } } ; return new Promise ( ( resolve , reject ) = > { let chunk = [ ] ; const req = https . request ( options , ( res ) = > { res . on ( 'data ' , ( data ) = > { chunk . push ( data ) ; } ) ; res . on ( 'end ' , ( ) = > { let data = Buffer . concat ( chunk ) ; resolve ( JSON . parse ( data . to String ( ) ) ) ; } ) ; } ) ; req . end ( ) ; req . on ( 'error ' , ( error ) = > { reject ( error ) ; } ) ; } ) ; } } 
function ( ) { var me = this ; var menu = new Ext . menu . Menu ( { items : [ { text : D . t ( 'Remove shortcut ' ) , handler : function ( ) { me . remove Shortcut ( menu ) } } ] } ) ; return { xtype : 'dataview ' , over Item Cls : 'x -view -over ' , track Over : true , item Selector : me . shortcut Item Selector , store : me . shortcuts , style : { position : 'absolute ' } , x : 0 , y : 0 , tpl : new Ext . XTemplate ( me . shortcut Tpl ) , listeners : { itemcontextmenu : function ( view , record , el , index , e , e Opts ) { menu . view = view menu . rec = record menu . show At ( e . get XY ( ) ) ; e . stop Event ( ) } } } ; } 
function ( e , x ) { var me = this , menu = me . context Menu ; e . stop Event ( ) ; if ( ! menu . rendered ) { menu . on ( 'beforeshow ' , me . on Desktop Menu Before Show , me ) ; } menu . show At ( e . get XY ( ) ) ; menu . do Constrain ( ) ; } 
function ( menu ) { var items = menu . items . items , win = menu . the Win ; items [ 0 ] . set Disabled ( win . maximized ! = = true & & win . hidden ! = = true ) ; 
function ( ) { var x = 0 , y = 0 , zmgr = this . get Desktop ZIndex Manager ( ) ; zmgr . each Bottom Up ( function ( win ) { if ( win . is Window & & win . is Visible ( ) & & ! win . maximized ) { win . set Position ( x , y ) ; x + = 2 0 ; y + = 2 0 ; } } ) ; } 
function protect _split ( separator , str ) { var sep = ' # # # # # # ' ; var string = false ; var nb _brackets = 0 ; var new _str = " " ; for ( var i = 0 ; i < str . length ; i + + ) { if ( ! string & & / [ ' " ` ] / . test ( str [ i ] ) ) string = str [ i ] ; else if ( string & & str [ i ] = = string ) string = false ; else if ( ! string & & str [ i ] = = ' ( ' ) nb _brackets + + ; else if ( ! string & & str [ i ] = = ' ) ' ) nb _brackets - - ; if ( str [ i ] = = separator & & ( nb _brackets > 0 | | string ) ) new _str + = sep ; else new _str + = str [ i ] ; } str = new _str ; str = str . split ( separator ) ; str = str . map ( function ( item ) { return trim ( item . replace ( new Reg Exp ( sep , 'g ' ) , separator ) ) ; } ) ; return str ; } 
function protect ( str ) { var result = ' # ' ; var length = str . length ; for ( var i = 0 ; i < length ; i + + ) result + = str [ i ] + " # " ; return result ; } 
function unprotect ( str ) { var result = ' ' ; var length = str . length ; for ( var i = 1 ; i < length ; i = i + 2 ) result + = str [ i ] ; return result ; } 
function ( ) { if ( / \w / . test ( this . current Char ) ) return this . read Word ( ) ; if ( / [ " ' ` ] / . test ( this . current Char ) ) return this . read String ( ) ; if ( / [ ( ) ] / . test ( this . current Char ) ) return this . read Group Symbol ( ) ; if ( / [ ! = < > ] / . test ( this . current Char ) ) return this . read Operator ( ) ; if ( this . current Char = = = " " ) return { type : 'eot ' , value : ' ' } ; else { this . read Next Char ( ) ; return { type : 'empty ' , value : ' ' } ; } } 
function ( ) { var left Node = this . parse Condition Expression ( ) ; while ( this . current Token . type = = 'logic ' ) { var logic = this . current Token . value ; this . read Next Token ( ) ; var right Node = this . parse Condition Expression ( ) ; 
function ( ) { var left Node = this . parse Base Expression ( ) ; if ( this . current Token . type = = 'operator ' ) { var operator = this . current Token . value ; this . read Next Token ( ) ; 
function ( ) { var ast Node = " " ; 
function cond 2sql ( cond , not _first ) { var result = ' ' ; 
function partially Diff Text ( a , b ) { if ( b . length > = a . length ) { for ( var i = 0 ; i < a . length ; + + i ) { if ( a [ i ] ! = = b [ i ] ) break } var fi = i if ( fi = = = a . length ) { return { type : 'add ' , index : fi , value : b . substr ( fi ) } } else { var ea = a . substr ( fi ) var eb = b . substr ( fi ) for ( var i = 0 ; i < ea . length ; + + i ) { if ( ea [ ea . length - i - 1 ] ! = = eb [ eb . length - i - 1 ] ) { break } } var tail Length = i if ( b . length - tail Length - fi > b . length - a . length ) { 
function diff Text ( a , b ) { var changes = [ ] var text = a while ( text ! = = b ) { var c = partially Diff Text ( text , b ) if ( c . type = = = 'add ' ) { text = text . substr ( 0 , c . index ) + c . value + text . substr ( c . index ) } else { text = text . substr ( 0 , c . index ) + text . substr ( c . index + c . many ) } changes . push ( c ) } return changes } 
function ( store , initial ) { var me = this ; me . mixins . bindable . bind Store . apply ( me , arguments ) ; if ( me . store & & ! initial ) { me . refresh ( ) ; } } 
function ( suppress Event ) { var me = this , selections = me . store . get Range ( ) , i = 0 , len = selections . length , start = me . get Selection ( ) . length ; me . bulk Change = true ; for ( ; i < len ; i + + ) { me . do Select ( selections [ i ] , true , suppress Event ) ; } delete me . bulk Change ; 
function ( record , e , keep Existing ) { var me = this , is Selected = me . is Selected ( record ) ; switch ( me . selection Mode ) { case 'MULTI ' : if ( e . shift Key & & me . selection Start ) { me . select Range ( me . selection Start , record , e . ctrl Key ) ; } else if ( e . ctrl Key & & is Selected ) { me . do Deselect ( record , false ) ; } else if ( e . ctrl Key ) { me . do Select ( record , true , false ) ; } else if ( is Selected & & ! e . shift Key & & ! e . ctrl Key & & me . selected . get Count ( ) > 1 ) { me . do Select ( record , keep Existing , false ) ; } else if ( ! is Selected ) { me . do Select ( record , false ) ; } break ; case 'SIMPLE ' : if ( is Selected ) { me . do Deselect ( record ) ; } else { me . do Select ( record , true ) ; } break ; case 'SINGLE ' : 
function ( e , record ) { var me = this , rec Idx , from Idx , is Selected = me . is Selected ( record ) , from = ( me . selection Start & & me . is Selected ( me . last Focused ) ) ? me . selection Start : ( me . selection Start = me . last Focused ) , key = e . get Char Code ( ) , is Space = key = = = e . SPACE , direction = key = = = e . UP | | key = = = e . PAGE _UP ? 'up ' : ( key = = = e . DOWN | | key = = = e . DOWN ? 'down ' : null ) ; switch ( me . selection Mode ) { case 'MULTI ' : if ( is Space ) { 
function ( start Row , end Row , keep Existing ) { var me = this , store = me . store , i , to Select = [ ] ; if ( me . is Locked ( ) ) { return ; } if ( ! keep Existing ) { me . deselect All ( true ) ; } if ( ! Ext . is Number ( start Row ) ) { start Row = store . index Of ( start Row ) ; } if ( ! Ext . is Number ( end Row ) ) { end Row = store . index Of ( end Row ) ; } 
function ( start Row , end Row ) { var me = this , store = me . store , i , tmp , record ; if ( me . is Locked ( ) ) { return ; } if ( ! Ext . is Number ( start Row ) ) { start Row = store . index Of ( start Row ) ; } if ( ! Ext . is Number ( end Row ) ) { end Row = store . index Of ( end Row ) ; } 
function ( fire Event ) { var me = this ; if ( fire Event & & ! me . bulk Change ) { me . fire Event ( 'selectionchange ' , me , me . get Selection ( ) ) ; } } 
function ( record ) { record = Ext . is Number ( record ) ? this . store . get At ( record ) : record ; return this . selected . contains ( record ) ; } 
function ( store , records , indexes , is Move ) { var me = this ; 
function deploy Rules ( { client , rules , secret } ) { const last Request = rules Requests . get ( client . project Id ) ; return Promise . resolve ( last Request ) . then ( old Rules Hash = > { const new Rule Hash = hash ( rules ) ; if ( old Rules Hash = = = new Rule Hash ) { return old Rules Hash ; } const request = client . rules ( { rules , secret } ) ; rules Requests . set ( client . project Id , request . then ( ( ) = > new Rule Hash , ( ) = > old Rules Hash ) ) ; return request ; } ) ; } 
function lock ( client , sequence ) { const last Sequence = sequences . get ( client . project Id ) ; return Promise . resolve ( last Sequence ) . then ( ( ) = > { const result = sequence ( ) ; sequences . set ( client . project Id , result . then ( noop , noop ) ) ; return result ; } ) ; } 
function $id ( c ) { if ( is Window ( c ) ) return document . document Element ; if ( / string |object / . test ( typeof c ) ) { return typeof c = = 'string ' ? document . get Element By Id ( c ) : c . node Type ? c : ' ' } } 
function get Elements By Class Name ( node , classname ) { if ( node . get Elements By Class Name ) { 
function get Sibling Elements ( node , select ) { if ( is Window ( node ) ) node = document . document Element ; var targets = [ ] var temp = [ ] if ( ! select ) return if ( typeof select = = 'string ' ) { temp = select . split ( ' ' ) } if ( is Array ( select ) ) { temp = select } temp . for Each ( function ( item ) { var char 0 = item . char At ( 0 ) if ( char 0 = = ' # ' ) { targets = targets . concat ( document . get Element By Id ( item . substring ( 1 ) ) ) } else if ( char 0 = = ' . ' ) { targets = targets . concat ( to Array ( get Elements By Class Name ( node , item . substring ( 1 ) ) ) ) } else { targets = targets . concat ( to Array ( node . get Elements By Tag Name ( item ) ) ) } } ) if ( targets . length ) return targets } 
function ( o Target , s Event Type , fn Handler ) { if ( o Target . listeners & & o Target . listeners [ s Event Type ] ) { var listeners = o Target . listeners [ s Event Type ] ; for ( var i = listeners . length - 1 ; i > = 0 & & fn Handler ; i - - ) { if ( listeners [ i ] = = fn Handler ) { listeners . splice ( i , 1 ) ; } } if ( ( ! listeners . length | | ! fn Handler ) & & listeners [ " _handler " ] ) { o Target . remove Event Listener ? o Target . remove Event Listener ( s Event Type , listeners [ " _handler " ] , false ) : o Target . detach Event ( 'on ' + s Event Type , listeners [ " _handler " ] ) ; delete o Target . listeners [ s Event Type ] ; } } } 
function ( o Target , s Event Type , fn Handler ) { o Target . listeners = o Target . listeners | | { } ; var listeners = o Target . listeners [ s Event Type ] = o Target . listeners [ s Event Type ] | | [ ] ; listeners . push ( fn Handler ) ; if ( ! listeners [ " _handler " ] ) { listeners [ " _handler " ] = function ( e ) { var e = e | | window . event ; for ( var i = 0 , fn ; fn = listeners [ i + + ] ; ) { fn . call ( o Target , e ) } } o Target . add Event Listener ? o Target . add Event Listener ( s Event Type , listeners [ " _handler " ] , false ) : o Target . attach Event ( 'on ' + s Event Type , listeners [ " _handler " ] ) ; } } 
function ( ) { var render Data = this . call Parent ( ) ; if ( this . owner . get Hierarchy State ( ) . rtl ) { render Data . inner Ct Cls = ( render Data . inner Ct Cls | | ' ' ) + ' ' + Ext . base CSSPrefix + 'rtl ' ; } return render Data ; } 
function ( o ) { var me = this ; o . un ( { scope : me , mousedown : me . on Mouse Down , mouseup : me . on Mouse Up , mouseover : me . on Mouse Over , mouseout : me . on Mouse Out , click : me . on Click } ) ; return me . call Parent ( arguments ) ; } 
function ( ) { var i = 0 , sprite , bb , items = this . items , len = this . length , infinity = Infinity , min X = infinity , max Height = - infinity , min Y = infinity , max Width = - infinity , max Width BBox , max Height BBox ; for ( ; i < len ; i + + ) { sprite = items [ i ] ; if ( sprite . el & & ! sprite . bbox Excluded ) { bb = sprite . get BBox ( ) ; min X = Math . min ( min X , bb . x ) ; min Y = Math . min ( min Y , bb . y ) ; max Height = Math . max ( max Height , bb . height + bb . y ) ; max Width = Math . max ( max Width , bb . width + bb . x ) ; } } return { x : min X , y : min Y , height : max Height - min Y , width : max Width - min X } ; } 
function ( attrs , redraw ) { var i = 0 , items = this . items , len = this . length ; for ( ; i < len ; i + + ) { items [ i ] . set Attributes ( attrs , redraw ) ; } return this ; } 
function ( redraw ) { var i = 0 , items = this . items , len = this . length ; for ( ; i < len ; i + + ) { items [ i ] . hide ( redraw ) ; } return this ; } 
function ( redraw ) { var i = 0 , items = this . items , len = this . length ; for ( ; i < len ; i + + ) { items [ i ] . show ( redraw ) ; } return this ; } 
function ( ) { var me = this , i = 0 , items = me . items , surface = me . get Surface ( ) , len = me . length ; if ( surface ) { for ( ; i < len ; i + + ) { surface . render Item ( items [ i ] ) ; } } return me ; } 
function ( obj ) { var i = 0 , items = this . items , len = this . length , item , el ; for ( ; i < len ; i + + ) { item = items [ i ] ; el = item . el ; if ( el ) { el . set Style ( obj ) ; } } } 
function ( obj ) { var i = 0 , items = this . items , surface = this . get Surface ( ) , len = this . length ; if ( surface ) { for ( ; i < len ; i + + ) { surface . add Cls ( items [ i ] , obj ) ; } } } 
function ( obj ) { var i = 0 , items = this . items , surface = this . get Surface ( ) , len = this . length ; if ( surface ) { for ( ; i < len ; i + + ) { surface . remove Cls ( items [ i ] , obj ) ; } } } 
function ( ) { var me = this , surface = me . get Surface ( ) , destroy Sprites = me . auto Destroy , item ; if ( surface ) { while ( me . get Count ( ) > 0 ) { item = me . first ( ) ; me . remove ( item ) ; surface . remove ( item , destroy Sprites ) ; } } me . clear Listeners ( ) ; } 
function ( ) { var me = this ; me . source = me . source | | { } ; me . add Cls ( me . grid Cls ) ; me . plugins = me . plugins | | [ ] ; * @event beforepropertychange * Fires before a property value changes . Handlers can return false to cancel the property change * (this will internally call { @link Ext .data .Model #reject } on the property 's record ) . * @param {Object } source The source data object for the grid (corresponds to the same object passed in * as the { @link #source } config property ) . * @param {String } record Id The record 's id in the data store * @param {Object } value The current edited property value * @param {Object } old Value The original property value prior to editing * / 'beforepropertychange ' , 'propertychange ' ) ; me . call Parent ( ) ; 
function ( config ) { var me = this , o , key , value ; me . copy Legacy Object ( config , me . custom Renderers , 'renderer ' ) ; me . copy Legacy Object ( config , me . custom Editors , 'editor ' ) ; me . copy Legacy Object ( config , me . property Names , 'display Name ' ) ; 
function ( pos , direction , e , prevent Wrap , verifier Fn , scope ) { if ( direction = = 'left ' ) { direction = 'up ' ; } else if ( direction = = 'right ' ) { direction = 'down ' ; } pos = Ext . view . Table . prototype . walk Cells . call ( this , pos , direction , e , prevent Wrap , verifier Fn , scope ) ; if ( pos & & ! pos . column ) { pos . column = 1 ; } return pos ; } 
function ( source , source Config ) { var me = this ; me . source = source ; if ( source Config ! = = undefined ) { me . source Config = Ext . apply ( { } , source Config ) ; me . configure ( me . source Config ) ; } me . prop Store . set Source ( source ) ; } 
function init ( ) { tiny MCEPopup . resize To Inner Size ( ) ; var inst = tiny MCEPopup . editor ; var dom = inst . dom ; var elm = inst . selection . get Node ( ) ; var f = document . forms [ 0 ] ; var onclick = dom . get Attrib ( elm , 'onclick ' ) ; set Form Value ( 'title ' , dom . get Attrib ( elm , 'title ' ) ) ; set Form Value ( 'id ' , dom . get Attrib ( elm , 'id ' ) ) ; set Form Value ( 'style ' , dom . get Attrib ( elm , "style " ) ) ; set Form Value ( 'dir ' , dom . get Attrib ( elm , 'dir ' ) ) ; set Form Value ( 'lang ' , dom . get Attrib ( elm , 'lang ' ) ) ; set Form Value ( 'tabindex ' , dom . get Attrib ( elm , 'tabindex ' , typeof ( elm . tabindex ) ! = "undefined " ? elm . tabindex : " " ) ) ; set Form Value ( 'accesskey ' , dom . get Attrib ( elm , 'accesskey ' , typeof ( elm . accesskey ) ! = "undefined " ? elm . accesskey : " " ) ) ; set Form Value ( 'onfocus ' , dom . get Attrib ( elm , 'onfocus ' ) ) ; set Form Value ( 'onblur ' , dom . get Attrib ( elm , 'onblur ' ) ) ; set Form Value ( 'onclick ' , onclick ) ; set Form Value ( 'ondblclick ' , dom . get Attrib ( elm , 'ondblclick ' ) ) ; set Form Value ( 'onmousedown ' , dom . get Attrib ( elm , 'onmousedown ' ) ) ; set Form Value ( 'onmouseup ' , dom . get Attrib ( elm , 'onmouseup ' ) ) ; set Form Value ( 'onmouseover ' , dom . get Attrib ( elm , 'onmouseover ' ) ) ; set Form Value ( 'onmousemove ' , dom . get Attrib ( elm , 'onmousemove ' ) ) ; set Form Value ( 'onmouseout ' , dom . get Attrib ( elm , 'onmouseout ' ) ) ; set Form Value ( 'onkeypress ' , dom . get Attrib ( elm , 'onkeypress ' ) ) ; set Form Value ( 'onkeydown ' , dom . get Attrib ( elm , 'onkeydown ' ) ) ; set Form Value ( 'onkeyup ' , dom . get Attrib ( elm , 'onkeyup ' ) ) ; class Name = dom . get Attrib ( elm , 'class ' ) ; add Classes To List ( 'classlist ' , 'advlink _styles ' ) ; select By Value ( f , 'classlist ' , class Name , true ) ; Tiny MCE _Editable Selects . init ( ) ; } 
function ( columns ) { var i , len = columns . length , column ; for ( i = 0 ; i < len ; i + + ) { column = columns [ i ] ; if ( ! column . processed & & column . locked ) { return true ; } } } 
function ( header Ct , header , cols To Move , from Idx , to Idx ) { var me = this ; 
function ( ) { var me = this ; return me . lhs Marker | | ( me . lhs Marker = Ext . Dom Helper . append ( me . el , { cls : me . resize Marker Cls } , true ) ) ; } 
function Hot Path ( options ) { if ( ! this ) return new Hot Path ( options ) ; options = options | | { } ; this . maximum = bytes ( options . maximum | | Hot Path . maximum ) ; 
function ( base Uri ) { this . option = { common : helper . get Common Options ( base Uri ) , current : null } ; this . expect = { common : { } , current : null } ; } 
function ( text Field ) { this . is Text Area = ( this . text Field . input El . dom . type . to Lower Case ( ) = = 'textarea ' ) ; this . create Clear Button El ( ) ; this . add Listeners ( ) ; this . reposition Clear Button ( ) ; this . update Clear Button Visibility ( ) ; this . add Esc Listener ( ) ; } 
function ( ) { var animate With Class = this . animate Clear Button & & this . animate With Css 3 ; this . clear Button El = this . text Field . body El . create Child ( { tag : 'div ' , cls : this . clear Button Cls } ) ; if ( this . animate Clear Button ) { this . animate With Css 3 = this . supports Css Transition ( this . clear Button El ) ; } if ( this . animate With Css 3 ) { this . clear Button El . add Cls ( this . clear Button Cls + ' -off ' ) ; } else { this . clear Button El . set Style ( 'visibility ' , 'hidden ' ) ; } } 
function ( el ) { var styles = [ 'transition Property ' , 'Webkit Transition Property ' , 'Moz Transition Property ' , 'OTransition Property ' , 'ms Transition Property ' , 'Khtml Transition Property ' ] ; var style = el . dom . style ; for ( var i = 0 , length = styles . length ; i < length ; + + i ) { if ( style [ styles [ i ] ] ! = = 'undefined ' ) { 
function ( ) { if ( ! this . clear On Escape ) { return ; } 
function ( ) { 
function ( event , html Element , object ) { if ( ! this . is Left Button ( event ) ) { return ; } 
function ( ) { var clear Button El = this . clear Button El ; if ( ! clear Button El ) { return ; } var right = 0 ; if ( this . field Has Scroll Bar ( ) ) { right + = Ext . get Scroll Bar Width ( ) ; } if ( this . text Field . trigger Wrap ) { right + = this . text Field . get Trigger Width ( ) ; } clear Button El . align To ( this . text Field . body El , 'tr -tr ' , [ - 1 * ( right + 3 ) , 5 ] ) ; } 
function ( text Field ) { var positions = text Field . input El . get Box ( true , true ) ; var top = positions . y ; var right = positions . x ; if ( this . field Has Scroll Bar ( ) ) { right + = Ext . get Scroll Bar Width ( ) ; } if ( this . text Field . trigger Wrap ) { right + = this . text Field . get Trigger Width ( ) ; 
function ( ) { if ( ! this . is Text Area ) { return false ; } var input El = this . text Field . input El ; var overflow Y = input El . get Style ( 'overflow -y ' ) ; if ( overflow Y = = 'hidden ' | | overflow Y = = 'visible ' ) { return false ; } if ( overflow Y = = 'scroll ' ) { return true ; } 
function ( ) { if ( this . animate Clear Button & & this . animate With Css 3 ) { return this . clear Button El . has Cls ( this . clear Button Cls + ' -on ' ) ; } 
function ( ) { if ( this . hide Clear Button When Empty & & Ext . is Empty ( this . text Field . get Value ( ) ) ) { return false ; } var clear Button El = this . clear Button El ; 
function ( ) { var old Visible = this . is Button Currently Visible ( ) ; var new Visible = this . should Button Be Visible ( ) ; var clear Button El = this . clear Button El ; if ( old Visible ! = new Visible ) { if ( this . animate Clear Button & & this . animate With Css 3 ) { this . clear Button El . remove Cls ( this . clear Button Cls + ( old Visible ? ' -on ' : ' -off ' ) ) ; clear Button El . add Cls ( this . clear Button Cls + ( new Visible ? ' -on ' : ' -off ' ) ) ; } else { clear Button El . stop Animation ( ) ; clear Button El . set Visible ( new Visible , this . animate Clear Button ) ; } 
function compute ( param Values ) { 
function quit ( message , line , chr ) { var percentage = Math . floor ( ( line / lines . length ) * 1 0 0 ) ; throw { name : 'JSHint Error ' , line : line , character : chr , message : message + " ( " + percentage + " % scanned ) . " , raw : message } ; } 
function next Line ( ) { var at , tw ; 
function ( ) { var b , c , captures , d , depth , high , i , l , low , q , t , is Literal , is In Range , n ; function match ( x ) { var r = x . exec ( s ) , r 1 ; if ( r ) { l = r [ 0 ] . length ; r 1 = r [ 1 ] ; c = r 1 . char At ( 0 ) ; s = s . substr ( l ) ; from = character + l - r 1 . length ; character + = l ; return r 1 ; } } function string ( x ) { var c , j , r = ' ' , allow New Line = false ; if ( jsonmode & & x ! = = ' " ' ) { warning At ( "Strings must use doublequote . " , line , character ) ; } function esc ( n ) { var i = parse Int ( s . substr ( j + 1 , n ) , 1 6 ) ; j + = n ; if ( i > = 3 2 & & i < = 1 2 6 & & i ! = = 3 4 & & i ! = = 9 2 & & i ! = = 3 9 ) { warning At ( "Unnecessary escapement . " , line , character ) ; } character + = n ; c = String . from Char Code ( i ) ; } j = 0 ; unclosed String : for ( ; ; ) { while ( j > = s . length ) { j = 0 ; var cl = line , cf = from ; if ( ! next Line ( ) ) { error At ( "Unclosed string . " , cl , cf ) ; break unclosed String ; } if ( allow New Line ) { allow New Line = false ; } else { warning At ( "Unclosed string . " , cl , cf ) ; } } c = s . char At ( j ) ; if ( c = = = x ) { character + = 1 ; s = s . substr ( j + 1 ) ; return it ( ' (string ) ' , r , x ) ; } if ( c < ' ' ) { if ( c = = = ' \n ' | | c = = = ' \r ' ) { break ; } warning At ( "Control character in string : {a } . " , line , character + j , s . slice ( 0 , j ) ) ; } else if ( c = = = ' \ \ ' ) { j + = 1 ; character + = 1 ; c = s . char At ( j ) ; n = s . char At ( j + 1 ) ; switch ( c ) { case ' \ \ ' : case ' " ' : case ' / ' : break ; case ' \ ' ' : if ( jsonmode ) { warning At ( "Avoid \ \ ' . " , line , character ) ; } break ; case 'b ' : c = ' \b ' ; break ; case 'f ' : c = ' \f ' ; break ; case 'n ' : c = ' \n ' ; break ; case 'r ' : c = ' \r ' ; break ; case 't ' : c = ' \t ' ; break ; case ' 0 ' : c = ' \ 0 ' ; / / Octal literals fail in strict mode / / check if the number is between 0 0 and 0 7 / / where 'n ' is the token next to 'c ' if ( n > = 0 & & n < = 7 & & directive [ "use strict " ] ) { warning At ( "Octal literals are not allowed in strict mode . " , line , character ) ; } break ; case 'u ' : esc ( 4 ) ; break ; case 'v ' : if ( jsonmode ) { warning At ( "Avoid \ \v . " , line , character ) ; } c = ' \v ' ; break ; case 'x ' : if ( jsonmode ) { warning At ( "Avoid \ \x - . " , line , character ) ; } esc ( 2 ) ; break ; case ' ' : / / last character is escape character / / always allow new line if escaped , but show / / warning if option is not set allow New Line = true ; if ( option . multistr ) { if ( jsonmode ) { warning At ( "Avoid EOL escapement . " , line , character ) ; } c = ' ' ; character - = 1 ; break ; } warning At ( "Bad escapement of EOL . Use option multistr if needed . " , line , character ) ; break ; default : warning At ( "Bad escapement . " , line , character ) ; } } r + = c ; character + = 1 ; j + = 1 ; } } for ( ; ; ) { if ( ! s ) { return it ( next Line ( ) ? ' (endline ) ' : ' (end ) ' , ' ' ) ; } t = match ( tx ) ; if ( ! t ) { t = ' ' ; c = ' ' ; while ( s & & s < ' ! ' ) { s = s . substr ( 1 ) ; } if ( s ) { error At ( "Unexpected ' {a } ' . " , line , character , s . substr ( 0 , 1 ) ) ; s = ' ' ; } } else { / / identifier if ( c . is Alpha ( ) | | c = = = ' _ ' | | c = = = ' $ ' ) { return it ( ' (identifier ) ' , t ) ; } / / number if ( c . is Digit ( ) ) { if ( ! is Finite ( Number ( t ) ) ) { warning At ( "Bad number ' {a } ' . " , line , character , t ) ; } if ( s . substr ( 0 , 1 ) . is Alpha ( ) ) { warning At ( "Missing space after ' {a } ' . " , line , character , t ) ; } if ( c = = = ' 0 ' ) { d = t . substr ( 1 , 1 ) ; if ( d . is Digit ( ) ) { if ( token . id ! = = ' . ' ) { warning At ( "Don 't use extra leading zeros ' {a } ' . " , line , character , t ) ; } } else if ( jsonmode & & ( d = = = 'x ' | | d = = = 'X ' ) ) { warning At ( "Avoid 0x - . ' {a } ' . " , line , character , t ) ; } } if ( t . substr ( t . length - 1 ) = = = ' . ' ) { warning At ( "A trailing decimal point can be confused with a dot ' {a } ' . " , line , character , t ) ; } return it ( ' (number ) ' , t ) ; } switch ( t ) { / / string case ' " ' : case " ' " : return string ( t ) ; / / / / comment case ' 
function expression ( rbp , initial ) { var left , is Array = false , is Object = false ; if ( nexttoken . id = = = ' (end ) ' ) error ( "Unexpected early end of program . " , token ) ; advance ( ) ; if ( initial ) { anonname = 'anonymous ' ; funct [ ' (verb ) ' ] = token . value ; } if ( initial = = = true & & token . fud ) { left = token . fud ( ) ; } else { if ( token . nud ) { left = token . nud ( ) ; } else { if ( nexttoken . type = = = ' (number ) ' & & token . id = = = ' . ' ) { warning ( "A leading decimal point can be confused with a dot : ' . {a } ' . " , token , nexttoken . value ) ; advance ( ) ; return token ; } else { error ( "Expected an identifier and instead saw ' {a } ' . " , token , token . id ) ; } } while ( rbp < nexttoken . lbp ) { is Array = token . value = = = 'Array ' ; is Object = token . value = = = 'Object ' ; advance ( ) ; if ( is Array & & token . id = = = ' ( ' & & nexttoken . id = = = ' ) ' ) warning ( "Use the array literal notation [ ] . " , token ) ; if ( is Object & & token . id = = = ' ( ' & & nexttoken . id = = = ' ) ' ) warning ( "Use the object literal notation { } . " , token ) ; if ( token . led ) { left = token . led ( left ) ; } else { error ( "Expected an operator and instead saw ' {a } ' . " , token , token . id ) ; } } } return left ; } 
function adjacent ( left , right ) { left = left | | token ; right = right | | nexttoken ; if ( option . white ) { if ( left . character ! = = right . from & & left . line = = = right . line ) { left . from + = ( left . character - left . from ) ; warning ( "Unexpected space after ' {a } ' . " , left , left . value ) ; } } } 
function optionalidentifier ( fnparam ) { if ( nexttoken . identifier ) { advance ( ) ; if ( token . reserved & & ! option . es 5 ) { 
function directives ( ) { var i , p , pn ; for ( ; ; ) { if ( nexttoken . id = = = " (string ) " ) { p = peek ( 0 ) ; if ( p . id = = = " (endline ) " ) { i = 1 ; do { pn = peek ( i ) ; i = i + 1 ; } while ( pn . id = = = " (endline ) " ) ; if ( pn . id ! = = " ; " ) { if ( pn . id ! = = " (string ) " & & pn . id ! = = " (number ) " & & pn . id ! = = " (regexp ) " & & pn . identifier ! = = true & & pn . id ! = = " } " ) { break ; } warning ( "Missing semicolon . " , nexttoken ) ; } else { p = pn ; } } else if ( p . id = = = " } " ) { 
function block ( ordinary , stmt , isfunc ) { var a , b = inblock , old _indent = indent , m , s = scope , t , line , d ; inblock = ordinary ; if ( ! ordinary | | ! option . funcscope ) scope = Object . create ( scope ) ; nonadjacent ( token , nexttoken ) ; t = nexttoken ; if ( nexttoken . id = = = ' { ' ) { advance ( ' { ' ) ; line = token . line ; if ( nexttoken . id ! = = ' } ' ) { indent + = option . indent ; while ( ! ordinary & & nexttoken . from > indent ) { indent + = option . indent ; } if ( isfunc ) { m = { } ; for ( d in directive ) { if ( is _own ( directive , d ) ) { m [ d ] = directive [ d ] ; } } directives ( ) ; if ( option . strict & & funct [ ' (context ) ' ] [ ' (global ) ' ] ) { if ( ! m [ "use strict " ] & & ! directive [ "use strict " ] ) { warning ( "Missing \ "use strict \ " statement . " ) ; } } } a = statements ( line ) ; if ( isfunc ) { directive = m ; } indent - = option . indent ; if ( line ! = = nexttoken . line ) { indentation ( ) ; } } else if ( line ! = = nexttoken . line ) { indentation ( ) ; } advance ( ' } ' , t ) ; indent = old _indent ; } else if ( ! ordinary ) { error ( "Expected ' {a } ' and instead saw ' {b } ' . " , nexttoken , ' { ' , nexttoken . value ) ; } else { if ( ! stmt | | option . curly ) warning ( "Expected ' {a } ' and instead saw ' {b } ' . " , nexttoken , ' { ' , nexttoken . value ) ; noreach = true ; indent + = option . indent ; 
function save Property ( name , token ) { if ( props [ name ] & & is _own ( props , name ) ) warning ( "Duplicate member ' {a } ' . " , nexttoken , i ) ; else props [ name ] = { } ; props [ name ] . basic = true ; props [ name ] . basic Token = token ; } 
function ( s , o , g ) { var a , i , k ; JSHINT . errors = [ ] ; JSHINT . undefs = [ ] ; predefined = Object . create ( standard ) ; combine ( predefined , g | | { } ) ; if ( o ) { a = o . predef ; if ( a ) { if ( Array . is Array ( a ) ) { for ( i = 0 ; i < a . length ; i + = 1 ) { predefined [ a [ i ] ] = true ; } } else if ( typeof a = = = 'object ' ) { k = Object . keys ( a ) ; for ( i = 0 ; i < k . length ; i + = 1 ) { predefined [ k [ i ] ] = ! ! a [ k [ i ] ] ; } } } option = o ; } else { option = { } ; } option . indent = option . indent | | 4 ; option . maxerr = option . maxerr | | 5 0 ; tab = ' ' ; for ( i = 0 ; i < option . indent ; i + = 1 ) { tab + = ' ' ; } indent = 1 ; global = Object . create ( predefined ) ; scope = global ; funct = { ' (global ) ' : true , ' (name ) ' : ' (global ) ' , ' (scope ) ' : scope , ' (breakage ) ' : 0 , ' (loopage ) ' : 0 } ; functions = [ funct ] ; urls = [ ] ; stack = null ; member = { } ; members Only = null ; implied = { } ; inblock = false ; lookahead = [ ] ; jsonmode = false ; warnings = 0 ; lex . init ( s ) ; prereg = true ; directive = { } ; prevtoken = token = nexttoken = syntax [ ' (begin ) ' ] ; 
function Pragma ( n ) { if ( n . type = = = SEMICOLON ) { var e = n . expression ; if ( e . type = = = STRING & & e . value = = = "use strict " ) { n . pragma = "strict " ; return true ; } } return false ; } 
function Synthetic Node ( init ) { this . children = [ ] ; for ( var prop in init ) this [ prop ] = init [ prop ] ; this . synthetic = true ; } 
function register Export ( exports , decl ) { function register ( name , exp ) { if ( exports . has ( name ) ) throw new Syntax Error ( "multiple exports of " + name ) ; exports . set ( name , exp ) ; } switch ( decl . type ) { case MODULE : case FUNCTION : register ( decl . name , new Export ( decl , true ) ) ; break ; case VAR : for ( var i = 0 ; i < decl . children . length ; i + + ) register ( decl . children [ i ] . name , new Export ( decl . children [ i ] , true ) ) ; break ; case LET : case CONST : throw new Error ( "NYI : " + definitions . tokens [ decl . type ] ) ; case EXPORT : for ( var i = 0 ; i < decl . path List . length ; i + + ) { var path = decl . path List [ i ] ; switch ( path . type ) { case OBJECT _INIT : for ( var j = 0 ; j < path . children . length ; j + + ) { 
function Module ( node ) { var exports = node . body . exports ; var mod Defns = node . body . mod Defns ; var exported Modules = new Dict ( ) ; exports . for Each ( function ( name , exp ) { var node = exp . node ; if ( node . type = = = MODULE ) { exported Modules . set ( name , node ) ; } else if ( ! exp . is Definition & & node . type = = = IDENTIFIER & & mod Defns . has ( node . value ) ) { var mod = mod Defns . get ( node . value ) ; exported Modules . set ( name , mod ) ; } } ) ; this . node = node ; this . exports = exports ; this . exported Modules = exported Modules ; } 
function is Pragma Token ( tt ) { switch ( tt ) { case IDENTIFIER : case STRING : case NUMBER : case NULL : case TRUE : case FALSE : return true ; } return false ; } 
function parse ( s , f , l ) { var t = new Tokenizer ( s , f , l , options . allow HTMLComments ) ; var p = new Parser ( t ) ; return p . Script ( false , false , true ) ; } 
function parse Function ( s , require Name , form , f , l ) { var t = new Tokenizer ( s , f , l ) ; var p = new Parser ( t ) ; p . x = new Static Context ( null , null , false , false , false ) ; return p . Function Definition ( require Name , form ) ; } 
function parse Stdin ( s , ln , prefix , is Command ) { 
function parse Multiline ( ln , prefix ) { var s = " " ; for ( ; ; ) { if ( prefix ) putstr ( prefix ) ; var more = readline ( ) ; if ( more = = = null ) return null ; 
function is Valid Identifier Char ( ch , first ) { 
function Tokenizer ( s , f , l , allow HTMLComments ) { this . cursor = 0 ; this . source = String ( s ) ; this . tokens = [ ] ; this . token Index = 0 ; this . lookahead = 0 ; this . scan Newlines = false ; this . filename = f | | " " ; this . lineno = l | | 1 ; this . allow HTMLComments = allow HTMLComments ; this . block Comments = null ; } 
function ( ) { var input = this . source ; this . block Comments = [ ] ; for ( ; ; ) { var ch = input [ this . cursor + + ] ; var next = input [ this . cursor ] ; 
function ( ch , keyword Is Name ) { var token = this . token ; var id = ch ; while ( ( ch = this . get Valid Identifier Char ( false ) ) ! = = null ) { id + = ch ; } token . type = IDENTIFIER ; token . value = id ; if ( keyword Is Name ) return ; var kw ; if ( this . parser . mozilla Mode ) { kw = definitions . mozilla Keywords [ id ] ; if ( kw ) { token . type = kw ; return ; } } if ( this . parser . x . strict Mode ) { kw = definitions . strict Keywords [ id ] ; if ( kw ) { token . type = kw ; return ; } } kw = definitions . keywords [ id ] ; if ( kw ) token . type = kw ; } 
function ( first ) { var input = this . source ; if ( this . cursor > = input . length ) return null ; var ch = input [ this . cursor ] ; 
function mixin Handler ( redirect , catchall ) { function target For ( name ) { return has Own ( redirect , name ) ? redirect [ name ] : catchall ; } function get Mux Property Descriptor ( name ) { var desc = get Property Descriptor ( target For ( name ) , name ) ; if ( desc ) desc . configurable = true ; return desc ; } function get Mux Property Names ( ) { var names 1 = Object . get Own Property Names ( redirect ) . filter ( function ( name ) { return name in redirect [ name ] ; } ) ; var names 2 = get Property Names ( catchall ) . filter ( function ( name ) { return ! has Own ( redirect , name ) ; } ) ; return names 1 . concat ( names 2 ) ; } function enumerate Mux ( ) { var result = Object . get Own Property Names ( redirect ) . filter ( function ( name ) { return name in redirect [ name ] ; } ) ; for ( name in catchall ) { if ( ! has Own ( redirect , name ) ) result . push ( name ) ; } ; return result ; } function has Mux ( name ) { return name in target For ( name ) ; } return { get Own Property Descriptor : get Mux Property Descriptor , get Property Descriptor : get Mux Property Descriptor , get Own Property Names : get Mux Property Names , define Property : function ( name , desc ) { Object . define Property ( target For ( name ) , name , desc ) ; } , "delete " : function ( name ) { var target = target For ( name ) ; return delete target [ name ] ; } , 
function make Pow ( left , prev ) { if ( left . is Empty ( ) ) { return prev ; } const elem = left . first ( ) ; return make Pow ( left . remove ( elem ) , prev . union ( prev . map ( e = > e . add ( elem ) ) ) ) ; } 
function ( s ) { s = tinymce . trim ( s ) ; function rep ( re , str ) { s = s . replace ( re , str ) ; } ; / / example : <strong > to [b ] rep ( / <a . * ?href = \ " ( . * ? ) \ " . * ? > ( . * ? ) < \ /a > / gi , " [url = $ 1 ] $ 2 [ /url ] " ) ; rep ( / <font . * ?color = \ " ( . * ? ) \ " . * ?class = \ "code Style \ " . * ? > ( . * ? ) < \ /font > / gi , " [code ] [color = $ 1 ] $ 2 [ /color ] [ /code ] " ) ; rep ( / <font . * ?color = \ " ( . * ? ) \ " . * ?class = \ "quote Style \ " . * ? > ( . * ? ) < \ /font > / gi , " [quote ] [color = $ 1 ] $ 2 [ /color ] [ /quote ] " ) ; rep ( / <font . * ?class = \ "code Style \ " . * ?color = \ " ( . * ? ) \ " . * ? > ( . * ? ) < \ /font > / gi , " [code ] [color = $ 1 ] $ 2 [ /color ] [ /code ] " ) ; rep ( / <font . * ?class = \ "quote Style \ " . * ?color = \ " ( . * ? ) \ " . * ? > ( . * ? ) < \ /font > / gi , " [quote ] [color = $ 1 ] $ 2 [ /color ] [ /quote ] " ) ; rep ( / <span style = \ "color : ? ( . * ? ) ; \ " > ( . * ? ) < \ /span > / gi , " [color = $ 1 ] $ 2 [ /color ] " ) ; rep ( / <font . * ?color = \ " ( . * ? ) \ " . * ? > ( . * ? ) < \ /font > / gi , " [color = $ 1 ] $ 2 [ /color ] " ) ; rep ( / <span style = \ "font -size : ( . * ? ) ; \ " > ( . * ? ) < \ /span > / gi , " [size = $ 1 ] $ 2 [ /size ] " ) ; rep ( / <font > ( . * ? ) < \ /font > / gi , " $ 1 " ) ; rep ( / <img . * ?src = \ " ( . * ? ) \ " . * ? \ / > / gi , " [img ] $ 1 [ /img ] " ) ; rep ( / <span class = \ "code Style \ " > ( . * ? ) < \ /span > / gi , " [code ] $ 1 [ /code ] " ) ; rep ( / <span class = \ "quote Style \ " > ( . * ? ) < \ /span > / gi , " [quote ] $ 1 [ /quote ] " ) ; rep ( / <strong class = \ "code Style \ " > ( . * ? ) < \ /strong > / gi , " [code ] [b ] $ 1 [ /b ] [ /code ] " ) ; rep ( / <strong class = \ "quote Style \ " > ( . * ? ) < \ /strong > / gi , " [quote ] [b ] $ 1 [ /b ] [ /quote ] " ) ; rep ( / <em class = \ "code Style \ " > ( . * ? ) < \ /em > / gi , " [code ] [i ] $ 1 [ /i ] [ /code ] " ) ; rep ( / <em class = \ "quote Style \ " > ( . * ? ) < \ /em > / gi , " [quote ] [i ] $ 1 [ /i ] [ /quote ] " ) ; rep ( / <u class = \ "code Style \ " > ( . * ? ) < \ /u > / gi , " [code ] [u ] $ 1 [ /u ] [ /code ] " ) ; rep ( / <u class = \ "quote Style \ " > ( . * ? ) < \ /u > / gi , " [quote ] [u ] $ 1 [ /u ] [ /quote ] " ) ; rep ( / < \ / (strong |b ) > / gi , " [ /b ] " ) ; rep ( / < (strong |b ) > / gi , " [b ] " ) ; rep ( / < \ / (em |i ) > / gi , " [ /i ] " ) ; rep ( / < (em |i ) > / gi , " [i ] " ) ; rep ( / < \ /u > / gi , " [ /u ] " ) ; rep ( / <span style = \ "text -decoration : ?underline ; \ " > ( . * ? ) < \ /span > / gi , " [u ] $ 1 [ /u ] " ) ; rep ( / <u > / gi , " [u ] " ) ; rep ( / <blockquote [ ^ > ] * > / gi , " [quote ] " ) ; rep ( / < \ /blockquote > / gi , " [ /quote ] " ) ; rep ( / <br \ / > / gi , " \n " ) ; rep ( / <br \ / > / gi , " \n " ) ; rep ( / <br > / gi , " \n " ) ; rep ( / <p > / gi , " " ) ; rep ( / < \ /p > / gi , " \n " ) ; rep ( / &nbsp ; | \u 0 0a 0 / gi , " " ) ; rep ( / &quot ; / gi , " \ " " ) ; rep ( / &lt ; / gi , " < " ) ; rep ( / &gt ; / gi , " > " ) ; rep ( / &amp ; / gi , " & " ) ; return s ; } 
function ( s ) { s = tinymce . trim ( s ) ; function rep ( re , str ) { s = s . replace ( re , str ) ; } ; / / example : [b ] to <strong > rep ( / \n / gi , " <br / > " ) ; rep ( / \ [b \ ] / gi , " <strong > " ) ; rep ( / \ [ \ /b \ ] / gi , " < /strong > " ) ; rep ( / \ [i \ ] / gi , " <em > " ) ; rep ( / \ [ \ /i \ ] / gi , " < /em > " ) ; rep ( / \ [u \ ] / gi , " <u > " ) ; rep ( / \ [ \ /u \ ] / gi , " < /u > " ) ; rep ( / \ [url = ( [ ^ \ ] ] + ) \ ] ( . * ? ) \ [ \ /url \ ] / gi , " <a href = \ " $ 1 \ " > $ 2 < /a > " ) ; rep ( / \ [url \ ] ( . * ? ) \ [ \ /url \ ] / gi , " <a href = \ " $ 1 \ " > $ 1 < /a > " ) ; rep ( / \ [img \ ] ( . * ? ) \ [ \ /img \ ] / gi , " <img src = \ " $ 1 \ " / > " ) ; rep ( / \ [color = ( . * ? ) \ ] ( . * ? ) \ [ \ /color \ ] / gi , " <font color = \ " $ 1 \ " > $ 2 < /font > " ) ; rep ( / \ [code \ ] ( . * ? ) \ [ \ /code \ ] / gi , " <span class = \ "code Style \ " > $ 1 < /span > &nbsp ; " ) ; rep ( / \ [quote . * ? \ ] ( . * ? ) \ [ \ /quote \ ] / gi , " <span class = \ "quote Style \ " > $ 1 < /span > &nbsp ; " ) ; return s ; } 
function ( child Context , axis ) { var collapse Target = child Context . collapse Target , set Size Method = 'set ' + axis . size Prop Cap , size Prop = axis . size Prop , child Margin Size = child Context . get Margin Info ( ) [ size Prop ] , region , is Begin , flex , pos , size ; if ( collapse Target ) { 
function ( owner Context , axis ) { var size = axis . end - axis . begin , center = owner Context . center Region ; if ( center ) { center [ 'set ' + axis . size Prop Cap ] ( size - center . get Margin Info ( ) [ axis . size Prop ] ) ; center . layout Pos [ axis . pos Prop ] = axis . begin ; } return Ext . is Number ( size ) ? 1 : 0 ; } 
function ( child Items ) { var length = child Items . length , index , child Context ; for ( index = 0 ; index < length ; + + index ) { child Context = child Items [ index ] ; child Context . set Prop ( 'x ' , child Context . layout Pos . x + child Context . margin Info . left ) ; child Context . set Prop ( 'y ' , child Context . layout Pos . y + child Context . margin Info . top ) ; } } 
function ( item , index , hidden ) { var region = item . region , splitter = { xtype : 'bordersplitter ' , collapse Target : item , id : item . id + ' -splitter ' , hidden : hidden , can Resize : item . splitter Resize ! = = false } , at = index + ( ( region = = 'south ' | | region = = 'east ' ) ? 0 : 1 ) ; 
function ( item , index ) { var me = this , placeholder For = item . placeholder For , region = item . region , split , hidden ; me . call Parent ( arguments ) ; if ( region ) { Ext . apply ( item , me . region Flags [ region ] ) ; if ( region = = 'center ' ) { 
function array ( x , dtype ) { var ctor , dt ; if ( is Number ( x ) ) { if ( ! is Non Negative Integer ( x ) ) { throw new Type Error ( 'invalid input argument . Array length must be a nonnegative integer . Value : ` ' + x + ' ` . ' ) ; } if ( arguments . length = = = 1 ) { return new CTOR ( x ) ; } ctor = ctors ( dtype ) ; if ( ctor = = = null ) { throw new Error ( 'invalid input argument . Unrecognized /unsupported data type . Value : ` ' + dtype + ' ` . ' ) ; } return new ctor ( x ) ; } if ( ! is Array Like ( x ) ) { throw new Type Error ( 'invalid input argument . Input data must be either a typed or generic array . Value : ` ' + x + ' ` . ' ) ; } if ( arguments . length > 1 ) { dt = dtype ; } else { dt = 'float 6 4 ' ; } return cast ( x , dt ) ; } 
function map Type ( rel , ch ) { var input Type = rel . params [ 0 ] . schema Type 
function Duration ( str ) { 
function ( ) { var result = { } , fields = this . fields , key , field ; for ( key in fields ) { if ( fields . has Own Property ( key ) ) { field = fields [ key ] ; if ( field . is Valid ( ) & & field . get Value ( ) ! = = null ) { result [ key ] = field . get Value ( ) ; } } } return result ; } 
function ( data ) { var me = this , fields = me . fields , key , field ; for ( key in fields ) { if ( fields . has Own Property ( key ) ) { 
function add Connection ( c ) { + + connection Count if ( ! connections ) { 
function send Ready ( e ) { 
function ( e ) { s . get Snapshots ( e , function ( err , version List ) { if ( err ) { _ . errout ( 'TODO : ' + err ) } var res = { snapshot Version Ids : serialize Snapshot Version List ( version List ) , is Historical : e . is Historical } res . request Id = e . request Id ; conn . w . got Snapshots ( res ) ; conn . w . flush ( ) ; } ) ; } 
function rect Connect ( ) { if ( arguments . length = = = 3 ) { return _rect Connect Rect To Point . apply ( undefined , arguments ) ; } return _rect Connect Rect To Rect . apply ( undefined , arguments ) ; } 
function add Subview ( subview ) { debug ( 'add subview ` %s ` ' , this . to String ( ) ) ; if ( _ . is Undefined ( this . subviews ) ) { this . subviews = [ ] ; } subview . parent View = this ; this . subviews . push ( subview ) ; } 
function remove Subview ( subview ) { debug ( 'remove subview ` %s ` ' , this . to String ( ) ) ; subview . close ( ) ; if ( this . subviews ) { this . subviews = _ . without ( this . subviews , subview ) ; } subview . parent View = undefined ; } 
function render Subviews ( ) { debug ( 'render subviews ` %s ` ' , this . to String ( ) ) ; var self = this , $ = self . $ ; return Q . when ( _ . each ( self . subviews , function ( subview ) { subview . $ = $ ; subview . $el = subview . select DOMElement ( $ ) ; subview . render . call ( subview ) ; subview . delegate Events ( ) ; } ) ) ; } 
function render ( ) { debug ( 'render ` %s ` ' , this . to String ( ) ) ; var self = this ; function invoke Before Render ( ) { debug ( 'invoke before render ` %s ` ' , self . to String ( ) ) ; var defer Before Render = Q . defer ( ) , resolve = defer Before Render . resolve , reject = defer Before Render . reject ; if ( ! _ . is Undefined ( self . before Render ) ) { self . before Render ( resolve , reject ) ; } else { resolve ( ) ; } return defer Before Render . promise ; } function invoke Render ( ) { debug ( 'invoke render ` %s ` ' , self . to String ( ) ) ; if ( ! _ . is Undefined ( self . render View ) ) { self . render View ( ) ; } } function invoke After Render ( ) { debug ( 'invoke after render ` %s ` ' , self . to String ( ) ) ; var defer After Render = Q . defer ( ) , resolve = defer After Render . resolve , reject = defer After Render . reject ; if ( ! _ . is Undefined ( self . after Render ) ) { self . after Render ( resolve , reject ) ; } else { resolve ( ) ; } return defer After Render . promise ; } return invoke Before Render ( ) . then ( invoke Render ) . then ( invoke After Render ) . then ( self . render Subviews . bind ( self ) ) ; } 
function select DOMElement ( $ ) { debug ( 'select dom element ` %s ` ' , this . to String ( ) ) ; var dom Element ; if ( ! this . el ) { var attrs = _ . extend ( { } , _ . result ( this , 'attributes ' ) ) ; if ( this . id ) { attrs . id = _ . result ( this , 'id ' ) ; } if ( this . class Name ) { attrs [ 'class ' ] = _ . result ( this , 'class Name ' ) ; } var selector = ' < ' + _ . result ( this , 'tag Name ' ) + ' > ' ; dom Element = $ ( selector ) . attr ( attrs ) ; } else { dom Element = $ ( _ . result ( this , 'el ' ) ) ; } return dom Element ; } 
function ensure Default ( val , def ) { if ( ( util _ 1 . is Null Or Undefined ( val ) | | val = = = ' ' ) & & ! chek _ 1 . is Undefined ( def ) ) return def ; return val ; } 
function is Like Number ( val ) { return constants _ 1 . LIKE _HEX _NUMBER . test ( val ) | | constants _ 1 . LIKE _NUMBER . test ( val ) ; } 
function ( val ) { val = ensure Default ( val , constants _ 1 . DEFAULT _TYPE _VALUES . boolean ) ; return Boolean ( / ^false $ / i . test ( val ) ? false : val ) ; } 
function ( val ) { val = ensure Default ( val , constants _ 1 . DEFAULT _TYPE _VALUES . array ) ; if ( ! Array . is Array ( val ) ) val = [ val ] ; return val ; } 
function to Camelcase ( val , strict ) { if ( strict = = = void 0 ) { strict = true ; } if ( ! strict | | ! / \S + \ . [ ^ \ . ] \S + / . test ( val ) ) return chek _ 1 . camelcase ( val ) ; return val ; } 
function expand Args ( val , match , safe ) { if ( Array . is Array ( val ) ) return val . slice ( 0 ) ; 
function expand Options ( val , allow Values ) { val = val | | [ ] ; var trail = [ ] ; return val . reduce ( function ( a , c ) { if ( ! constants _ 1 . FLAG _SHORT . test ( c ) | | constants _ 1 . FLAG _COUNT . test ( c ) ) return a . concat ( c ) ; var split = c . slice ( 1 ) . split ( ' ' ) . map ( function ( n ) { return " - " + n ; } ) ; if ( allow Values ) return a . concat ( split ) ; trail = trail . concat ( split ) ; 
function is Negate Flag ( val , negate ) { negate = escape ( negate | | constants _ 1 . NEGATE _CHAR ) ; return ( new Reg Exp ( ' ^ - - ' + negate ) ) . test ( val ) ; } 
function is Arg Variadic ( val , variadic ) { variadic = variadic | | constants _ 1 . VARIADIC _CHAR ; return is Arg ( val ) & & ( val . ends With ( variadic + ' ] ' ) | | val . ends With ( variadic + ' > ' ) ) ; } 
function is Arg Variadic Required ( val , variadic ) { variadic = variadic | | constants _ 1 . VARIADIC _CHAR ; return is Arg Required ( val ) & & val . ends With ( variadic + ' > ' ) ; } 
function strip Flag ( val , negate ) { negate = escape ( negate | | constants _ 1 . NEGATE _CHAR ) ; return ( val | | ' ' ) . replace ( new Reg Exp ( ' ^ - - ? ( ' + negate + ' ) ? ' ) , ' ' ) ; } 
function strip Negate ( val , negate ) { negate = escape ( negate | | constants _ 1 . NEGATE _CHAR ) ; var exp = new Reg Exp ( ' ^ ' + negate ) ; return val . replace ( exp , ' ' ) ; } 
function strip Variadic ( val , variadic ) { variadic = escape ( variadic | | constants _ 1 . VARIADIC _CHAR ) ; var exp = new Reg Exp ( variadic + ' $ ' ) ; return val . replace ( exp , ' ' ) ; } 
function strip Tokens ( val , negate , variadic ) { variadic = escape ( variadic | | constants _ 1 . VARIADIC _CHAR ) ; negate = escape ( negate | | constants _ 1 . NEGATE _CHAR ) ; var arg Exp = new Reg Exp ( [ ' < ' , ' > ' , ' \ \ [ ' , ' \ \ ] ' ] . join ( ' | ' ) , 'g ' ) ; var no Exp = new Reg Exp ( ' ^ ' + negate ) ; var vari Exp = new Reg Exp ( variadic + ' $ ' ) ; return expand Args ( val ) . map ( function ( v ) { v = v . replace ( constants _ 1 . FLAG _EXP , ' ' ) . replace ( no Exp , ' ' ) . replace ( arg Exp , ' ' ) . replace ( vari Exp , ' ' ) ; return v ; } ) . join ( ' ' ) ; } 
function ( item ) { if ( ! item ) { return ; } var me = this , sprite = item . sprite , opts = Ext . merge ( { } , me . highlight Cfg , me . highlight ) , surface = me . chart . surface , animate = me . chart . animate , p , from , to , pi ; if ( ! me . highlight | | ! sprite | | sprite . _highlighted ) { return ; } if ( sprite . _anim ) { sprite . _anim . paused = true ; } sprite . _highlighted = true ; if ( ! sprite . _defaults ) { sprite . _defaults = Ext . apply ( { } , sprite . attr ) ; from = { } ; to = { } ; 
function ( ) { if ( ! this . highlight | | ! this . items ) { return ; } var me = this , items = me . items , len = items . length , opts = Ext . merge ( { } , me . highlight Cfg , me . highlight ) , animate = me . chart . animate , i = 0 , obj , p , sprite ; for ( ; i < len ; i + + ) { if ( ! items [ i ] ) { continue ; } sprite = items [ i ] . sprite ; if ( sprite & & sprite . _highlighted ) { if ( sprite . _anim ) { sprite . _anim . paused = true ; } obj = { } ; for ( p in opts ) { if ( Ext . is Object ( sprite . _defaults [ p ] ) ) { obj [ p ] = Ext . apply ( { } , sprite . _defaults [ p ] ) ; } else { obj [ p ] = sprite . _defaults [ p ] ; } } if ( animate ) { 
function ( component , selector ) { if ( ! selector ) { return true ; } var selectors = selector . split ( ' , ' ) , length = selectors . length , i = 0 , query ; for ( ; i < length ; i + + ) { selector = Ext . String . trim ( selectors [ i ] ) ; query = this . cache [ selector ] | | ( this . cache [ selector ] = this . parse ( selector ) ) ; if ( query . is ( component ) ) { return true ; } } return false ; } 
async function get Vinyl File ( file Path , options ) { if ( ! is String ( file Path ) ) { if ( ! options . lookup . has ( file Path . path ) ) options . lookup . set ( file Path . path , file Path ) ; return file Path ; } if ( options . lookup . has ( file Path ) ) return options . lookup . get ( file Path ) ; return create Vinyl File ( file Path , options ) ; } 
async function create Vinyl File ( file Path , options ) { options . lookup . set ( file Path , vinyl File . read ( file Path , options ) ) ; if ( options . debug Vcjd ) debug ( ` $ { file Path } ` ) ; return await options . lookup . get ( file Path ) ; } 
function get Vinyl Files ( files , options ) { return Promise . all ( files . map ( file = > get Vinyl File ( file , options ) ) ) ; } 
async function resolve Module ( module Id , options , root = options . base ) { if ( options . lookup . has ( module Id ) ) return options . lookup . get ( module Id ) ; const absolute Path = await options . resolver ( module Id , root ) ; if ( options . mapper . has Own Property ( absolute Path ) ) return options . mapper [ absolute Path ] ; if ( options . lookup . has ( absolute Path ) ) return options . lookup . get ( absolute Path ) ; return absolute Path ; } 
function get Requires ( file , options ) { return [ . . . file Requires ( file , options ) ] . map ( async ( module Id ) = > { if ( options . internal Only & & ( module Id . char At ( 0 ) ! = = ' . ' ) & & ( module Id . char At ( 0 ) ! = = ' / ' ) ) { if ( options . mapper [ module Id ] ! = = true ) return undefined ; } if ( options . mapper . has Own Property ( module Id ) & & ! ( options . internal Only & & ( options . mapper [ module Id ] = = = true ) ) ) { if ( options . mapper [ module Id ] ) return resolve Module ( options . mapper [ module Id ] , options ) ; return undefined ; } return resolve Module ( module Id , options , path . dirname ( file . path ) ) ; } ) ; } 
function filter Duplicate Files ( ) { const lookup = new Map ( ) ; return value = > { if ( lookup . has ( value ) ) return false ; return lookup . set ( value , true ) ; } } 
async function get Files ( paths , options ) { const files = ( await get Vinyl Files ( paths , options ) ) . map ( file = > [ file , . . . get Requires ( file , options ) ] ) ; return ( await promise Flatten ( files ) ) . filter ( file = > file ) . filter ( filter Duplicate Files ( ) ) ; } 
async function get All Files ( file , options ) { let files = await get Files ( [ file ] , options ) ; while ( has Unloaded ( files ) ) files = await get Files ( files , options ) ; return files ; } 
function src File Pusher ( options ) { return through . obj ( function ( file , encoding , done ) { get All Files ( file , options ) . then ( files = > { files . for Each ( file = > this . push ( file ) ) ; done ( ) ; } , err = > { } ) ; } ) } 
function create Resolver ( options ) { return ( module Id , base ) = > new Promise ( ( resolve , reject ) = > { const resolver = new Resolver ( options . resolver ? options . resolver : { } ) ; resolver . resolve ( module Id , base , ( err , absolute Path ) = > { if ( err ) { if ( options . debug Vcjd ) debug ( ` $ { module Id } \n \t $ { base } ` ) ; return reject ( err ) ; } if ( options . debug Vcjd ) debug ( ` $ { module Id } \n \t $ { base } \n \t $ { base } ` ) ; return resolve ( absolute Path ) ; } ) ; } ) } 
function parse Options ( options = { } , vinyl Cjs Deps ) { const _options = Object . assign ( { gulp : vinyl Cjs Deps . gulp | | require ( 'gulp ' ) , base : options . cwd | | process . cwd ( ) , cwd : options . base | | process . cwd ( ) , internal Only : false , debug Vcjd : false } , options ) ; _options . mapper = Object . assign ( { } , options . mapper | | { } ) ; _options . lookup = new Map ( options . lookup | | [ ] ) ; _options . resolver = create Resolver ( options ) ; return _options ; } 
function ( ed , cm , n ) { var dom = ed . dom , dir ; n = dom . get Parent ( n , dom . is Block ) ; if ( ! n ) { cm . set Disabled ( 'ltr ' , 1 ) ; cm . set Disabled ( 'rtl ' , 1 ) ; return ; } dir = dom . get Attrib ( n , 'dir ' ) ; cm . set Active ( 'ltr ' , dir = = "ltr " ) ; cm . set Disabled ( 'ltr ' , 0 ) ; cm . set Active ( 'rtl ' , dir = = "rtl " ) ; cm . set Disabled ( 'rtl ' , 0 ) ; } 
function new Entry ( that ) { return O . log . todo ( ) ; O . find Shard ( that . demand . ident , function ( err , shard ) { if ( err ) return that . end Update ( err ) ; shard . embryo ( that . demand . ident . id , that . demand . ident . kind , that . demand . dval , function ( err , entry ) { if ( err ) return that . end Update ( err ) ; that . set Entry ( entry ) ; that . fields . start Edit ( true ) ; return ; } ) ; return ; } ) ; } 
function ( ) { var me = this , prev = me . store . current Page - 1 ; if ( prev > 0 ) { if ( me . fire Event ( 'beforechange ' , me , prev ) ! = = false ) { me . store . previous Page ( ) ; } } } 
function ( ) { var me = this , total = me . get Page Data ( ) . page Count , next = me . store . current Page + 1 ; if ( next < = total ) { if ( me . fire Event ( 'beforechange ' , me , next ) ! = = false ) { me . store . next Page ( ) ; } } } 
function ( ) { var me = this , last = me . get Page Data ( ) . page Count ; if ( me . fire Event ( 'beforechange ' , me , last ) ! = = false ) { me . store . load Page ( last ) ; } } 
function ( ) { var me = this , current = me . store . current Page ; if ( me . fire Event ( 'beforechange ' , me , current ) ! = = false ) { me . store . load Page ( current ) ; } } 
function ( members ) { var member , name ; for ( name in members ) { if ( members . has Own Property ( name ) ) { member = members [ name ] ; if ( typeof member = = 'function ' & & ! member . $is Class & & member ! = = Ext . empty Fn & & member ! = = Ext . identity Fn ) { member . $owner = this ; member . $name = name ; 
function ( from Class , members ) { 
function ( members ) { var me = this , enumerables = Ext . enumerables , target = me . prototype , clone Function = Ext . Function . clone , name , index , member , statics , names , previous ; if ( arguments . length = = = 2 ) { name = members ; members = { } ; members [ name ] = arguments [ 1 ] ; enumerables = null ; } do { names = [ ] ; 
function ( args ) { var method ; 
function ( args ) { var method ; 
function ( name , mixin Class ) { var me = this , mixin = mixin Class . prototype , prototype = me . prototype , key , statics , i , ln , static Name , mixin Value , hook Key , hook Function ; if ( typeof mixin . on Class Mixed In ! = 'undefined ' ) { mixin . on Class Mixed In . call ( mixin Class , me ) ; } if ( ! prototype . has Own Property ( 'mixins ' ) ) { if ( 'mixins ' in prototype ) { prototype . mixins = Ext . Object . chain ( prototype . mixins ) ; } else { prototype . mixins = { } ; } } for ( key in mixin ) { mixin Value = mixin [ key ] ; if ( key = = = 'mixins ' ) { Ext . merge ( prototype . mixins , mixin Value ) ; } else if ( key = = = 'xhooks ' ) { for ( hook Key in mixin Value ) { hook Function = mixin Value [ hook Key ] ; 
function ( args ) { 
function ( config ) { var instance Config = config , config Name Cache = Ext . Class . config Name Cache , default Config = new this . config Class ( ) , default Config List = this . init Config List , has Config = this . config Map , name Map , i , ln , name , initialized Name ; this . init Config = Ext . empty Fn ; this . initial Config = instance Config | | { } ; this . config = config = ( instance Config ) ? Ext . merge ( default Config , config ) : default Config ; if ( instance Config ) { default Config List = default Config List . slice ( ) ; for ( name in instance Config ) { if ( has Config [ name ] ) { if ( instance Config [ name ] ! = = null ) { default Config List . push ( name ) ; this [ config Name Cache [ name ] . initialized ] = false ; } } } } for ( i = 0 , ln = default Config List . length ; i < ln ; i + + ) { name = default Config List [ i ] ; name Map = config Name Cache [ name ] ; initialized Name = name Map . initialized ; if ( ! this [ initialized Name ] ) { this [ initialized Name ] = true ; this [ name Map . set ] . call ( this , config [ name ] ) ; } } return this ; } 
function get Options ( opts ) { opts = opts | | { } ; 
function get Plugins ( opts ) { var batter Root Dir = _ _dirname . replace ( delim + 'lib ' , ' ' ) ; var batter Tasks = { root Dir : batter Root Dir } ; var current Project = { root Dir : opts . root Dir } ; var plugins = opts . plugins | | [ ] ; 
function whip ( gulp , taste , opts ) { opts = get Options ( opts ) ; opts . taste = taste ; var tasks = _ . extend ( { } , opts . tasksets ) ; 
function parse _arguments ( argv ) { var parsed = { } ; var current = false ; var name = false ; var unrecognized = false ; var have _action = false ; var is _global = false ; var name _format , option ; var i , j ; for ( i = 3 , len = argv . length ; i < len ; i + + ) { 
function ( stdout ) { var files = { } , i = 0 , j = 0 , n = 0 , c , f Name , sz , formats = [ [ 0 , 0 ] ] stdout = stdout . split ( ' \n ' ) while ( stdout [ i ] ! = = null & & stdout [ i ] . substr ( 0 , 7 ) ! = ' - - - - - - - ' ) { i + + ; } while ( stdout [ i ] & & j < stdout [ i ] . length ) { c = stdout [ i ] . char At ( j ) if ( c ! = ' - ' ) { n + + formats [ n ] = [ j + 1 , 0 ] } else { formats [ n ] [ 1 ] + + } j + + ; } i + + n = path Name . split ( ' / ' ) . length - 1 while ( stdout [ i ] & & stdout [ i ] . substr ( 0 , 7 ) ! = ' - - - - - - - ' ) { f Name = stdout [ i ] . substr ( formats [ 4 ] [ 0 ] ) . trim ( ) . split ( ' / ' ) if ( f Name [ n ] & & ! files [ f Name [ n ] ] ) { c = stdout [ i ] . substr ( formats [ 1 ] [ 0 ] , formats [ 1 ] [ 1 ] ) . trim ( ) sz = parse Int ( stdout [ i ] . substr ( formats [ 2 ] [ 0 ] , formats [ 2 ] [ 1 ] ) . trim ( ) ) if ( c . char At ( 0 ) ! = 'D ' & & n = = ( f Name . length - 1 ) ) { 
function get ( url , on Success , on Failure ) { http ( Method . GET , url , { } , on Success , on Failure ) ; } 
function post ( url , data , on Success , on Failure ) { http ( Method . POST , url , data , on Success , on Failure ) ; } 
function http ( method , url , data , on Success , on Failure ) { var qs = [ ] , xhr ; if ( Util . ENV . Node . JS ) { xhr = require ( ' . /xhr ' ) . create ( ) ; } else if ( 'undefined ' ! = typeof XDomain Request ) { xhr = new XDomain Request ( ) ; xdrs . push ( xhr ) ; } else xhr = new XMLHttp Request ( ) ; xhr . onload = function ( ) { try { var resp = JSON . parse ( xhr . response Text ) ; if ( 'reason ' in resp ) throw new Error ( resp [ 'reason ' ] ) ; if ( 'status ' in xhr & & 2 0 0 ! = xhr . status ) throw new Error ( xhr . status Text ) ; on Success ( resp ) ; } catch ( error ) { on Failure ( error , xhr . status ) ; } } ; xhr . onprogress = function ( ) { 
function Console Logger ( ) { this . _l = Util . ILogger . Level . Error ; this . _c = 'undefined ' ! = typeof console ? console : undefined ; } 
function Array Stream ( arr , options ) { var self = this ; this . _reading = false ; this . _closing = false ; this . _index = 0 ; options = options | | { } ; this . _duplex = options . duplex | | false ; this . set ( arr ) ; Duplex . call ( this , { object Mode : true , high Water Mark : options . high Water Mark | | Math . pow ( 2 , 1 0 ) } ) ; } 
function ( dir , htm , callback ) { var recur = function ( str ) { return s = str . replace ( / \ { \ {include [ \s ] { 1 , } [ \ ' \ " ] ( [ \w \ . \ / ] { 1 , } ) [ \ ' \ " ] \ } \ } / gi , function ( p 1 , path ) { if ( fs . exists Sync ( dir + path ) ) { return recur ( fs . read File Sync ( dir + path , 'utf 8 ' ) ) ; } return " " ; } ) } callback ( recur ( htm ) ) } 
function ( module , method ) { var all = { urlparams : [ ] } for ( var i = 2 ; i < u . length ; i + + ) all . urlparams . push ( decode URIComponent ( u [ i ] ) ) ; req . cookies = { } req . headers . cookie & & req . headers . cookie . split ( ' ; ' ) . for Each ( function ( cookie ) { var parts = cookie . split ( ' = ' ) , key = parts [ 0 ] . trim ( ) , val = decode URIComponent ( ( parts [ 1 ] | | ' ' ) . trim ( ) ) ; all [ key ] = val ; req . cookies [ key ] = val } ) ; if ( url . query ! = null ) for ( var i in url . query ) all [ i ] = url . query [ i ] if ( post ! = null ) for ( var i in post ) all [ i ] = post [ i ] all . response = res all . request = req all . _query = url . query if ( me . config . LOCALE & & ! all . locale ) { all . locale = req . url . substr ( 1 , 2 ) if ( ! me . config . LOCALE [ all . locale ] ) delete all . locale } 
function open Uid ( data Dir , cb ) { var fn = data Dir + ' /minnow _data /server .uid ' exists ( fn , function ( exists ) { if ( exists ) { fs . read File ( fn , 'utf 8 ' , function ( err , uid ) { if ( err ) throw err ; cb ( uid ) } ) } else { var uid = seedrandom . uid ( ) fs . write File Sync ( fn , uid , 'utf 8 ' ) ; cb ( uid ) } } ) } 
function maintain Edit Sequence ( up , add Edit Cb ) { if ( current Sync Id ! = = up . sync Id ) { 
function ( ed , cm , n ) { var ed = this . editor ; if ( ed . get Param ( 'save _enablewhendirty ' ) ) { cm . set Disabled ( 'save ' , ! ed . is Dirty ( ) ) ; cm . set Disabled ( 'cancel ' , ! ed . is Dirty ( ) ) ; } } 
function ( ) { var ed = this . editor , form Obj , os , i , element Id ; form Obj = tinymce . DOM . get ( ed . id ) . form | | tinymce . DOM . get Parent ( ed . id , 'form ' ) ; if ( ed . get Param ( "save _enablewhendirty " ) & & ! ed . is Dirty ( ) ) return ; tiny MCE . trigger Save ( ) ; / / Use callback instead if ( os = ed . get Param ( "save _onsavecallback " ) ) { if ( ed . exec Callback ( 'save _onsavecallback ' , ed ) ) { ed . start Content = tinymce . trim ( ed . get Content ( { format : 'raw ' } ) ) ; ed . node Changed ( ) ; } return ; } if ( form Obj ) { ed . is Not Dirty = true ; if ( form Obj . onsubmit = = null | | form Obj . onsubmit ( ) ! = false ) form Obj . submit ( ) ; ed . node Changed ( ) ; } else ed . window Manager . alert ( "Error : No form element found . " ) ; } 
function ( config ) { var me = this , surface , sprites , tip Surface ; if ( config . tips ) { me . tip Timeout = null ; me . tip Config = Ext . apply ( { } , config . tips , { renderer : Ext . empty Fn , constrain Position : true , auto Hide : true } ) ; me . tooltip = new Ext . tip . Tool Tip ( me . tip Config ) ; me . chart . surface . on ( 'mousemove ' , me . tooltip . on Mouse Move , me . tooltip ) ; me . chart . surface . on ( 'mouseleave ' , function ( ) { me . hide Tip ( ) ; } ) ; if ( me . tip Config . surface ) { 
function start ( ) { var Barefoot = require ( ' . . / ' ) ( ) , self = this , original Render = this . render , original Navigate = this . navigate ; 
function render ( view ) { if ( ! _ . is Undefined ( this . current View ) ) { this . current View . close ( ) ; } this . current View = view ; view . render ( ) ; } 
function ( request ) { var me = this , requests = me . requests , key ; if ( request ) { if ( ! request . id ) { request = requests [ request ] ; } me . handle Abort ( request ) ; } else { for ( key in requests ) { if ( requests . has Own Property ( key ) ) { me . abort ( requests [ key ] ) ; } } } } 
function ( result , request ) { var success = true ; if ( request . timeout ) { clear Timeout ( request . timeout ) ; } delete this [ request . callback Name ] ; delete this . requests [ request . id ] ; this . cleanup Error Handling ( request ) ; Ext . fly ( request . script ) . remove ( ) ; if ( request . error Type ) { success = false ; Ext . callback ( request . failure , request . scope , [ request . error Type ] ) ; } else { Ext . callback ( request . success , request . scope , [ result ] ) ; } Ext . callback ( request . callback , request . scope , [ success , result , request . error Type ] ) ; Ext . Event Manager . idle Event . fire ( ) ; } 
function ( url , params , options ) { var script = document . create Element ( 'script ' ) ; script . set Attribute ( "src " , Ext . url Append ( url , Ext . Object . to Query String ( params ) ) ) ; script . set Attribute ( "async " , true ) ; script . set Attribute ( "type " , "text /javascript " ) ; return script ; } 
function ( response ) { var data , error ; try { data = Ext . decode ( response . response Text ) ; return this . read Records ( data ) ; } catch ( ex ) { error = new Ext . data . Result Set ( { total : 0 , count : 0 , records : [ ] , success : false , message : ex . message } ) ; this . fire Event ( 'exception ' , this , response , error ) ; Ext . Logger . warn ( 'Unable to parse the JSON returned by the server ' ) ; return error ; } } 
function ( ) { var me = this , meta Prop = me . meta Property ; me . call Parent ( arguments ) ; if ( me . root ) { me . get Root = me . create Accessor ( me . root ) ; } else { me . get Root = Ext . identity Fn ; } if ( meta Prop ) { me . get Meta = me . create Accessor ( meta Prop ) ; } } 
function Table Grid ( table , dom , selection ) { var grid , start Pos , end Pos , selected Cell ; build Grid ( ) ; selected Cell = dom . get Parent ( selection . get Start ( ) , 'th ,td ' ) ; if ( selected Cell ) { start Pos = get Pos ( selected Cell ) ; end Pos = find End Pos ( ) ; selected Cell = get Cell ( start Pos . x , start Pos . y ) ; } function clone Node ( node , children ) { node = node . clone Node ( children ) ; node . remove Attribute ( 'id ' ) ; return node ; } function build Grid ( ) { var start Y = 0 ; grid = [ ] ; each ( [ 'thead ' , 'tbody ' , 'tfoot ' ] , function ( part ) { var rows = dom . select ( ' > ' + part + ' tr ' , table ) ; each ( rows , function ( tr , y ) { y + = start Y ; each ( dom . select ( ' > td , > th ' , tr ) , function ( td , x ) { var x 2 , y 2 , rowspan , colspan ; 
function create Table Grid ( node ) { var selection = ed . selection , tbl Elm = ed . dom . get Parent ( node | | selection . get Node ( ) , 'table ' ) ; if ( tbl Elm ) return new Table Grid ( tbl Elm , ed . dom , selection ) ; } 
function fix Table Cell Selection ( ed ) { if ( ! tinymce . is Web Kit ) return ; var rng = ed . selection . get Rng ( ) ; var n = ed . selection . get Node ( ) ; var current Cell = ed . dom . get Parent ( rng . start Container , 'TD ,TH ' ) ; if ( ! table Cell Selected ( ed , rng , n , current Cell ) ) return ; if ( ! current Cell ) { current Cell = n ; } 
function fix Table Caret Pos ( ) { var last ; 
function CLIProgress ( text , settings ) { var progress = this ; progress . settings = { text : ' { {current } } / { {max } } [ { {bar } } ] { {percent } } % ' , current : 0 , max : 1 0 0 , stream : process . stderr , render : function ( line ) { progress . settings . stream . cursor To ( 0 ) ; progress . settings . stream . clear Line ( 1 ) ; progress . settings . stream . write ( line ) ; } , clear : function ( ) { progress . settings . stream . clear Line ( 0 ) ; progress . settings . stream . cursor To ( 0 ) ; } , width : window Size . width , complete Char : ' = ' , incomplete Char : ' ' , percent : function ( ) { var p Text = Math . round ( progress . settings . current / progress . settings . max * 1 0 0 ) . to String ( ) ; var str Len = string Length ( p Text ) ; if ( str Len > 3 ) return p Text ; * Return the output that will be sent to the output stream * return {string } The raw console -suitable output * / progress . format = function ( ) { var text = mustache . render ( progress . settings . text , progress . settings ) ; * Holder for the throttle timeout handle * This will be the set Timeout ( ) response if we are throttling * @var {Object } * / progress . throttle Handle ; progress . update = function ( val ) { progress . set ( val ) ; if ( progress . settings . throttle & & progress . settings . throttle Sync ) { * The timestamp in milliseconds of the last update event * This is used when employing the synchronous throttling method * @var {date } * / progress . last Update ; progress . update Now = function ( ) { progress . last Update = Date . now ( ) ; progress . settings . render ( progress . format ( ) ) ; clear Timeout ( progress . throttle Handle ) ; progress . throttle Handle = null ; } ; progress . remove = function ( ) { clear Timeout ( progress . throttle Handle ) ; * Set one or more options or tokens * NOTE : Unlike .set ( ) this function DOES NOT refresh the progress bar * @params {Object |number } Either set a number of properties or the 'current ' value if passed a number * @return {Object } This object instance * @see set ( ) * / progress . set = function ( val ) { if ( ! val ) return ; if ( typeof val = = 'number ' ) { progress . settings . current = val ; } else { for ( var k in val ) { progress . settings [ k ] = val [ k ] ; } if ( val . text ) { 
async function request ( url , options ) { if ( ! options ) { if ( is Plain Object ( url ) ) { options = url url = null } else { options = { url } } } if ( ! is Plain Object ( options ) ) { throw new Parameter Exception ( 'Options must be an object ! ' ) } if ( is String ( url ) ) { options . url = url } if ( ! is String ( options . url ) ) { throw new Parameter Exception ( 'URL is required ! ' ) } let { interceptors , . . . req } = options interceptors = intercept ( interceptors ) req = await parse Req ( req ) req = await iterate Interceptors ( req , interceptors . request ) const res = await fetch ( req . url , req ) let body = await get Body ( res ) body = await iterate Interceptors ( body , interceptors . response ) if ( res . status > = 2 0 0 & & res . status < 4 0 0 ) { return body } throw body } 
function Context ( tasty , client ) { const config = tasty . config , flaws = client . flaws , server = tasty . server , id = client . id ; const tool = new Tool ( id , server , config ) ; const noop = function noop ( ) { } ; const now = function now ( ) { if ( arguments . length ) { enqueue . apply ( null , Array . prototype . map . call ( arguments , ( item ) = > { if ( ! instance ( item , Function ) ) { throw new Type Error ( 'pass functions to now ( ) ' ) ; } return item ; } ) ) ; } else { const queue = now . queue ; now . queue = [ ] ; return queue . reduce ( ( chain , item ) = > chain . then ( item ) , Promise . resolve ( ) ) ; } } ; now . noop = noop ; now . queue = [ ] ; const enqueue = function ( ) { config . slow & & now . queue . push ( ( ) = > new Promise ( ( resolve ) = > set Timeout ( resolve , config . slow ) ) ) ; now . queue . push . apply ( now . queue , arguments ) ; } / / NOTE support for get /set /pop /push /during /until . const wrap = ( handle ) = > { const wrapped = function ( ) { return new Promise ( ( resolve ) = > enqueue ( ( ) = > { const result = handle . apply ( id , arguments ) ; if ( ! instance ( result , Promise ) ) { throw new Error ( ` $ { handle . name } ` ) ; } return result . then ( resolve , ( error ) = > { resolve ( error ) ; throw error ; } ) ; } ) ) ; } ; wrapped . handle = handle ; return wrapped ; } ; const inject = function inject ( from , to , wrapped ) { Object . keys ( from ) . for Each ( ( name ) = > { to [ name ] = wrapped ? util . rename ( wrap ( from [ name ] ) , name ) : from [ name ] ; } ) ; } ; const api = function api ( scope ) { if ( ! scope ) { throw new Type Error ( 'api , scope is required ' ) ; } / / TODO filter . inject ( tool , scope , true ) ; inject ( thing , scope , false ) ; scope . noop = noop ; scope . now = now ; config . addon & & config . addon . split ( ' , ' ) . sort ( ( a , b ) = > a . locale Compare ( b ) ) . for Each ( ( name ) = > { const module = require ( util . resolve ( name ) ) ; scope [ name ] = module ; / / NOTE support for assterion /expectation libraries . if ( module . assert ) { scope . assert = module . assert ; } if ( module . expect ) { scope . expect = module . expect ; } / / TODO support should ( ) ; / / WORKAROUND for chai plugins . / ^chai - / . test ( name ) & & scope . chai & & scope . chai . use ( module ) ; } ) ; return scope ; } ; inject ( tool , now , false ) ; const globals = { console : server . logger , tasty : { api : api , config : config , flaws : flaws , now : now , thing : thing , tool : tool , wrap : wrap } } ; config . globals & & api ( globals ) ; return { globals : globals } ; } 
function now ( ) { if ( arguments . length ) { enqueue . apply ( null , Array . prototype . map . call ( arguments , ( item ) = > { if ( ! instance ( item , Function ) ) { throw new Type Error ( 'pass functions to now ( ) ' ) ; } return item ; } ) ) ; } else { const queue = now . queue ; now . queue = [ ] ; return queue . reduce ( ( chain , item ) = > chain . then ( item ) , Promise . resolve ( ) ) ; } } 
function api ( scope ) { if ( ! scope ) { throw new Type Error ( 'api , scope is required ' ) ; } / / TODO filter . inject ( tool , scope , true ) ; inject ( thing , scope , false ) ; scope . noop = noop ; scope . now = now ; config . addon & & config . addon . split ( ' , ' ) . sort ( ( a , b ) = > a . locale Compare ( b ) ) . for Each ( ( name ) = > { const module = require ( util . resolve ( name ) ) ; scope [ name ] = module ; / / NOTE support for assterion /expectation libraries . if ( module . assert ) { scope . assert = module . assert ; } if ( module . expect ) { scope . expect = module . expect ; } / / TODO support should ( ) ; / / WORKAROUND for chai plugins . / ^chai - / . test ( name ) & & scope . chai & & scope . chai . use ( module ) ; } ) ; return scope ; } 
function ( ) { * @event processcolumns * Fires when the configured (or * *reconfigured * * ) column set is split into two depending on the { @link Ext .grid .column .Column #locked locked } flag . * @param {Ext .grid .column .Column [ ] } locked Columns The locked columns . * @param {Ext .grid .column .Column [ ] } normal Columns The normal columns . * / 'processcolumns ' , 'lockcolumn ' , 'unlockcolumn ' ) ; me . add State Events ( [ 'lockcolumn ' , 'unlockcolumn ' ] ) ; columns = me . process Columns ( me . columns ) ; * @event filterchange * @inheritdoc Ext .data .Store #filterchange * / 'filterchange ' ] ) ; me . layout = { type : 'hbox ' , align : 'stretch ' } ; } 
function ( column ) { var result = column . width | | 0 , subcols , len , i ; 
function ( ) { var me = this , locked View = me . locked Grid . get View ( ) , locked View El = locked View . el . dom , spacer Height = ( me . normal Grid . header Ct . too Narrow ? Ext . get Scrollbar Size ( ) . height : 0 ) ; 
function ( ) { var me = this ; me . locked Grid . header Ct . get Menu Items = me . get Menu Items ( me . locked Grid . header Ct . get Menu Items , true ) ; me . normal Grid . header Ct . get Menu Items = me . get Menu Items ( me . normal Grid . header Ct . get Menu Items , false ) ; me . locked Grid . header Ct . show Menu By = Ext . Function . create Interceptor ( me . locked Grid . header Ct . show Menu By , me . show Menu By ) ; me . normal Grid . header Ct . show Menu By = Ext . Function . create Interceptor ( me . normal Grid . header Ct . show Menu By , me . show Menu By ) ; } 
function ( active Hd , to Idx ) { var me = this , normal Grid = me . normal Grid , locked Grid = me . locked Grid , normal HCt = normal Grid . header Ct , locked HCt = locked Grid . header Ct , refresh Flags , owner Ct ; active Hd = active Hd | | normal HCt . get Menu ( ) . active Header ; owner Ct = active Hd . owner Ct ; 
function ( store , columns ) { var me = this , old Store = me . store , locked Grid = me . locked Grid , normal Grid = me . normal Grid ; Ext . suspend Layouts ( ) ; if ( columns ) { locked Grid . header Ct . remove All ( ) ; normal Grid . header Ct . remove All ( ) ; columns = me . process Columns ( columns ) ; 
function write Long ( buffer , offset , value ) { var first = value , second = value > = 0 ? Math . floor ( value / 2 1 4 7 4 8 3 6 4 8 ) : Math . ceil ( value / 2 1 4 7 4 8 3 6 4 8 ) ; var sign = first > 0 ? 1 : - 1 ; first = ( sign * first ) % 2 1 4 7 4 8 3 6 4 8 ; first = sign * first ; 
function default Transformer ( . . . args ) { try { let [ record , . . . rest ] = args try { record = typeof record = = = 'string ' ? JSON . parse ( record ) : record } catch ( err ) { return { type : 'bunyan ' , record : { err : new Error ( 'Could not parse message . ' ) } } } return { type : 'bunyan ' , record } } catch ( err ) { return { type : 'bunyan ' , record : { err : new Error ( 'Internal error occurred . ' ) } } } } 
function print _rr ( obj Ref , str Obj Ref ) { converts str Obj Ref to an Array of the parts of the object i ,e [ "window " , "document " , "child Nodes " , " [ " , " 0 " , " ] " ] * / this . parse Str Obj Ref = function ( ) { this .populate Header = function ( ) { var str Ref = " " ; for (var x = 0 ;x <this .arr Str Obj Ref .length ;x + + ) { if ( (this .arr Str Obj Ref [x ] .match ( / \ [ /g ) ) | | (this .arr Str Obj Ref [x ] .match ( / \ ] /g ) ) ) { this .header .append Child (document .create Text Node (this .arr Str Obj Ref [x ] ) ) ; if (this .arr Str Obj Ref [x ] = = " [ " ) { str Ref + = " [ " ; } } else { var a = document .create Element ( 'a ' ) ; a .href = "javascript :void ( 0 ) ; " ; this .apply Styles (style Obj .a , a ) ; a .append Child (document .create Text Node (this .arr Str Obj Ref [x ] ) ) ; if (this .arr Str Obj Ref [x - 1 ] & & this .arr Str Obj Ref [x - 1 ] = = " ] " & & x ! = (this .arr Str Obj Ref .length - 1 ) ) { this .header .append Child (document .create Text Node ( " . " ) ) ; str Ref + = " . " ; } str Ref + = this .arr Str Obj Ref [x ] ; if (this .arr Str Obj Ref [x + 1 ] = = " ] " ) { str Ref + = " ] " ; } a .onclick = click Me (this , str Ref ) ; this .header .append Child (a ) ; if (this .arr Str Obj Ref [x + 1 ] & & this .arr Str Obj Ref [x + 1 ] ! = " ] " & & this .arr Str Obj Ref [x + 1 ] ! = " [ " ) { this .header .append Child (document .create Text Node ( " . " ) ) ; str Ref + = " . " ; } } } try { if (this .header .last Child .value = = " . " ) { this .header .remove Child (this .header .last Child ) ; } } catch (e ) { } } ; * / if ( (this .arr Str Obj Ref [x ] .match ( / \ [ /g ) ) ) { if (this .arr Str Obj Ref [x ] = = " [ " ) { str Ref + = " [ " ; } } else { this .apply Styles (style Obj .a , a ) ; if (this .arr Str Obj Ref [x - 1 ] & & this .arr Str Obj Ref [x - 1 ] = = " ] " & & x ! = (this .arr Str Obj Ref .length - 1 ) ) { } str Ref + = this .arr Str Obj Ref [x ] ; if (this .arr Str Obj Ref [x ] = = " ] " ) { if (this .arr Str Obj Ref [x + 1 ] & & this .arr Str Obj Ref [x + 1 ] ! = " ] " & & this .arr Str Obj Ref [x + 1 ] ! = " [ " ) { this .header .append Child (document .create Text Node ( " . " ) ) ; str Ref + = " . " ; } } if (this .arr Str Obj Ref [x ] ! = " ] " ) { a .onclick = click Me (this , str Ref ) ; a .href = "javascript :void ( 0 ) ; " ; } this .header .append Child (a ) ; if (this .arr Str Obj Ref [x + 1 ] & & this .arr Str Obj Ref [x + 1 ] ! = " ] " & & this .arr Str Obj Ref [x + 1 ] ! = " [ " ) { this .header .append Child (document .create Text Node ( " . " ) ) ; str Ref + = " . " ; } } * / This is the main function to populate the dom * / this . populate Body = function ( ) { if (properties [prop ] .name .match ( / [ ^a -z A -Z _ \ - ] /g ) ) { a .onclick = click Me (print _r , print _r .str Obj Ref + " [ ' " + properties [prop ] .name + " ' ] " ) ; } else { a .onclick = click Me (print _r , print _r .str Obj Ref + " . " + properties [prop ] .name ) ; } * / } else { try { var test = eval ( print _r . str Obj Ref + " . " + properties [ prop ] . name ) ; a . onclick = click Me ( print _r , print _r . str Obj Ref + " [ " + properties [ prop ] . name + " ] " ) ; } catch ( e ) { try { var test = eval ( print _r . str Obj Ref + " [ " + properties [ prop ] . name + " ] " ) ; a . onclick = click Me ( print _r , print _r . str Obj Ref + " [ " + properties [ prop ] . name + " ] " ) ; } catch ( e ) { a . onclick = click Me ( print _r , print _r . str Obj Ref + " [ ' " + properties [ prop ] . name + " ' ] " ) ; } } } } z . append Child ( a ) ; tdname . append Child ( z ) ; Since I could not get a css file to work consistently accross browsers in the Bookmarklet edition , I went with this approach so I would not have so many dom .style . * * * * * = " 5 0px " ; lines . And also to make it easy to customize * / this . apply Styles = function ( style Object , dom Object ) { for ( prop in style Object ) { try { dom Object . style [ prop ] = style Object [ prop ] ; } catch ( e ) { } } } ; 
function get String ( ref ) { try { if ( ref ) { try { return ref ; } catch ( e ) { return ref . to String ( ) ; } } else { try { return ref . to String ( ) ; } catch ( e ) { return "undefined " ; } } } catch ( e ) { 
function write Table ( properties , tbodyprops , name , print _r ) { if (properties [prop ] .name .match ( / [ ^a -z A -Z _ \ - ] /g ) ) { a .onclick = click Me (print _r , print _r .str Obj Ref + " [ ' " + properties [prop ] .name + " ' ] " ) ; } else { a .onclick = click Me (print _r , print _r .str Obj Ref + " . " + properties [prop ] .name ) ; } * / } else { try { var test = eval ( print _r . str Obj Ref + " . " + properties [ prop ] . name ) ; a . onclick = click Me ( print _r , print _r . str Obj Ref + " [ " + properties [ prop ] . name + " ] " ) ; } catch ( e ) { try { var test = eval ( print _r . str Obj Ref + " [ " + properties [ prop ] . name + " ] " ) ; a . onclick = click Me ( print _r , print _r . str Obj Ref + " [ " + properties [ prop ] . name + " ] " ) ; } catch ( e ) { a . onclick = click Me ( print _r , print _r . str Obj Ref + " [ ' " + properties [ prop ] . name + " ' ] " ) ; } } } } z . append Child ( a ) ; tdname . append Child ( z ) ; 
function click Me ( print _r , str ) { return ( function ( ) { print _r . obj Ref = eval ( str ) ; print _r . str Obj Ref = str ; print _r . refresh ( ) ; } ) ; } 
function arr Sort ( a , b ) { var acomp = a [ 'name ' ] . to String ( 1 0 ) ; var bcomp = b [ 'name ' ] . to String ( 1 0 ) ; if ( ! is Na N ( Number ( acomp ) ) ) { acomp = Number ( acomp ) ; } if ( ! is Na N ( Number ( bcomp ) ) ) { bcomp = Number ( bcomp ) ; } if ( acomp < bcomp ) { return - 1 ; } if ( acomp > bcomp ) { return 1 ; } return 0 ; } 
function run ( that , config ) { 
function ( filter , index , list ) { 
function ( ed , url ) { / / Register the command so that it can be invoked by using tiny MCE .active Editor .exec Command ( 'mce Example ' ) ; ed . add Command ( 'mce Example ' , function ( ) { ed . window Manager . open ( { file : url + ' /dialog .htm ' , width : 3 2 0 + parse Int ( ed . get Lang ( 'example .delta _width ' , 0 ) ) , height : 1 2 0 + parse Int ( ed . get Lang ( 'example .delta _height ' , 0 ) ) , inline : 1 } , { plugin _url : url , / / Plugin absolute URL some _custom _arg : 'custom arg ' / / Custom argument } ) ; } ) ; / / Register example button ed . add Button ( 'example ' , { title : 'example .desc ' , cmd : 'mce Example ' , image : url + ' /img /example .gif ' } ) ; / / Add a node change handler , selects the button in the UI when a image is selected ed . on Node Change . add ( function ( ed , cm , n ) { cm . set Active ( 'example ' , n . node Name = = 'IMG ' ) ; } ) ; } 
function get Current Expected Types ( type ) { var current Type ; var expected Type ; if ( type . name ) { current Type = type . name ; } else if ( type . expression ) { current Type = type . expression . name ; } expected Type = current Type & & prefer Type [ current Type ] ; return { current Type : current Type , expected Type : expected Type } ; } 
function validate Type ( jsdoc Node , type ) { if ( ! type | | ! can Type Be Validated ( type . type ) ) { return ; } var types To Check = [ ] ; var elements = [ ] ; switch ( type . type ) { case 'Type Application ' : 
function require Js Doc ( node , is Virtual , params To Check ) { var lines = source Code . lines ; var index = node . loc . start . line ; lines = lines . slice ( 0 , index ) ; var matches = lines . filter ( function ( line ) { return line . match ( / \ / \ * \ * / gi ) ; } ) ; var last Index = lines . last Index Of ( matches [ matches . length - 1 ] ) ; var jsdoc Comment = find JSDoc Comment ( source Code . ast . comments , last Index ) ; if ( ! jsdoc Comment ) { report ( node ) ; return ; } check JSDoc ( node , jsdoc Comment , is Virtual , params To Check ) ; } 
function Selection Type ( type Spec ) { if ( ! Array . is Array ( type Spec . data ) & & typeof type Spec . data ! = = 'function ' ) { throw new Error ( 'instances of Selection Type need type Spec .data to be an array or function that returns an array : ' + JSON . stringify ( type Spec ) ) ; } Object . keys ( type Spec ) . for Each ( function ( key ) { this [ key ] = type Spec [ key ] ; } , this ) ; } 
function Deferred Type ( type Spec ) { if ( typeof type Spec . defer ! = = 'function ' ) { throw new Error ( 'Instances of Deferred Type need type Spec .defer to be a function that returns a type ' ) ; } Object . keys ( type Spec ) . for Each ( function ( key ) { this [ key ] = type Spec [ key ] ; } , this ) ; } 
function Array Type ( type Spec ) { if ( type Spec instanceof Type ) { this . subtype = type Spec ; } else if ( typeof type Spec = = = 'string ' ) { this . subtype = types . get Type ( type Spec ) ; if ( this . subtype = = null ) { throw new Error ( 'Unknown array subtype : ' + type Spec ) ; } } else { throw new Error ( 'Can \ ' handle array subtype ' ) ; } } 
function ( ) { var conversion = this . parse ( ' ' ) ; if ( last Setting ) { var current = last Setting . get ( ) ; if ( conversion . predictions . length = = = 0 ) { conversion . predictions . push ( current ) ; } else { 
function Hint ( status , message , start , end , predictions ) { this . status = status ; this . message = message ; if ( typeof start = = = 'number ' ) { this . start = start ; this . end = end ; this . predictions = predictions ; } else { var arg = start ; this . start = arg . start ; this . end = arg . end ; this . predictions = arg . predictions ; } } 
function Conversion Hint ( conversion , arg ) { this . status = conversion . status ; this . message = conversion . message ; if ( arg ) { this . start = arg . start ; this . end = arg . end ; } else { this . start = 0 ; this . end = 0 ; } this . predictions = conversion . predictions ; } 
function Argument ( emitter , text , start , end , prefix , suffix ) { this . emitter = emitter ; this . set Text ( text ) ; this . start = start ; this . end = end ; this . prefix = prefix ; this . suffix = suffix ; } 
function ( following ) { if ( following . emitter ! = this . emitter ) { throw new Error ( 'Can \ 't merge Arguments from different Event Emitters ' ) ; } return new Argument ( this . emitter , this . text + this . suffix + following . prefix + following . text , this . start , following . end , this . prefix , following . suffix ) ; } 
function ( text ) { if ( text = = null ) { throw new Error ( 'Illegal text for Argument : ' + text ) ; } var ev = { argument : this , old Text : this . text , text : text } ; this . text = text ; this . emitter . _dispatch Event ( 'argument Change ' , ev ) ; } 
function Assignment ( param , requisition ) { this . param = param ; this . requisition = requisition ; this . set Value ( param . default Value ) ; } 
function ( ) { 
function ( position ) { if ( ! this . arg ) { return false ; } 
function ( command , arg ) { var docs = [ ] ; docs . push ( ' <strong > <tt > &gt ; ' ) ; docs . push ( command . name ) ; if ( command . params & & command . params . length > 0 ) { command . params . for Each ( function ( param ) { if ( param . default Value = = = undefined ) { docs . push ( ' [ ' + param . name + ' ] ' ) ; } else { docs . push ( ' <em > [ ' + param . name + ' ] < /em > ' ) ; } } , this ) ; } docs . push ( ' < /tt > < /strong > <br / > ' ) ; docs . push ( command . description ? command . description : ' (No description ) ' ) ; docs . push ( ' <br / > ' ) ; if ( command . params & & command . params . length > 0 ) { docs . push ( ' <ul > ' ) ; command . params . for Each ( function ( param ) { docs . push ( ' <li > ' ) ; docs . push ( ' <strong > <tt > ' + param . name + ' < /tt > < /strong > : ' ) ; docs . push ( param . description ? param . description : ' (No description ) ' ) ; if ( param . default Value = = = undefined ) { docs . push ( ' <em > [Required ] < /em > ' ) ; } else if ( param . default Value = = = null ) { docs . push ( ' <em > [Optional ] < /em > ' ) ; } else { docs . push ( ' <em > [Default : ' + param . default Value + ' ] < /em > ' ) ; } docs . push ( ' < /li > ' ) ; } , this ) ; docs . push ( ' < /ul > ' ) ; } return new Hint ( Status . VALID , docs . join ( ' ' ) , arg ) ; } 
function ( assignment ) { 
function ( name Or Number ) { var name = ( typeof name Or Number = = = 'string ' ) ? name Or Number : Object . keys ( this . _assignments ) [ name Or Number ] ; return this . _assignments [ name ] ; } 
function ( ) { 
function ( ) { var args = { } ; this . get Assignments ( ) . for Each ( function ( assignment ) { args [ assignment . param . name ] = assignment . value ; } , this ) ; return args ; } 
function ( include Command ) { var args = [ ] ; if ( include Command = = = true ) { args . push ( this . command Assignment ) ; } Object . keys ( this . _assignments ) . for Each ( function ( name ) { args . push ( this . get Assignment ( name ) ) ; } , this ) ; return args ; } 
function ( ) { var line = [ ] ; line . push ( this . command Assignment . value . name ) ; Object . keys ( this . _assignments ) . for Each ( function ( name ) { var assignment = this . _assignments [ name ] ; var type = assignment . param . type ; 
function Cli Requisition ( env , options ) { Requisition . call ( this , env ) ; if ( options & & options . flags ) { this . flags = options . flags ; } } 
function Cli View ( cli , env ) { cli . cli View = this ; this . cli = cli ; this . doc = document ; this . win = dom . get Parent Window ( this . doc ) ; this . env = env ; 
function ( ) { var input = this . element ; this . element . spellcheck = false ; this . output = this . doc . get Element By Id ( 'cockpit Output ' ) ; this . popup Output = ( this . output = = null ) ; if ( ! this . output ) { this . output = this . doc . create Element ( 'div ' ) ; this . output . id = 'cockpit Output ' ; this . output . class Name = 'cpt Output ' ; input . parent Node . insert Before ( this . output , input . next Sibling ) ; var set Max Output Height = function ( ) { this . output . style . max Height = this . output Height . get ( ) + 'px ' ; } . bind ( this ) ; this . output Height . add Event Listener ( 'change ' , set Max Output Height ) ; set Max Output Height ( ) ; } this . completer = this . doc . create Element ( 'div ' ) ; this . completer . class Name = 'cpt Completion VALID ' ; this . completer . style . color = dom . computed Style ( input , "color " ) ; this . completer . style . font Size = dom . computed Style ( input , "font Size " ) ; this . completer . style . font Family = dom . computed Style ( input , "font Family " ) ; this . completer . style . font Weight = dom . computed Style ( input , "font Weight " ) ; this . completer . style . font Style = dom . computed Style ( input , "font Style " ) ; input . parent Node . insert Before ( this . completer , input . next Sibling ) ; 
function ( ) { 
function ( ) { var rect = this . element . get Client Rects ( ) [ 0 ] ; this . completer . style . top = rect . top + 'px ' ; var height = rect . bottom - rect . top ; this . completer . style . height = height + 'px ' ; this . completer . style . line Height = height + 'px ' ; this . completer . style . left = rect . left + 'px ' ; var width = rect . right - rect . left ; this . completer . style . width = width + 'px ' ; if ( this . hint Direction . get ( ) = = = 'below ' ) { this . hinter . style . top = rect . bottom + 'px ' ; this . hinter . style . bottom = 'auto ' ; } else { this . hinter . style . top = 'auto ' ; this . hinter . style . bottom = ( this . doc . document Element . client Height - rect . top ) + 'px ' ; } this . hinter . style . left = ( rect . left + 3 0 ) + 'px ' ; this . hinter . style . max Width = ( width - 1 1 0 ) + 'px ' ; if ( this . popup Output ) { if ( this . output Direction . get ( ) = = = 'below ' ) { this . output . style . top = rect . bottom + 'px ' ; this . output . style . bottom = 'auto ' ; } else { this . output . style . top = 'auto ' ; this . output . style . bottom = ( this . doc . document Element . client Height - rect . top ) + 'px ' ; } this . output . style . left = rect . left + 'px ' ; this . output . style . width = ( width - 8 0 ) + 'px ' ; } } 
function ( ev , hash Id , key Code ) { var stop Event ; if ( key Code = = = keys . TAB | | key Code = = = keys . UP | | key Code = = = keys . DOWN ) { stop Event = true ; } else if ( hash Id ! = 0 | | key Code ! = 0 ) { stop Event = canon . exec Key Command ( this . env , 'cli ' , hash Id , key Code ) ; } stop Event & & event . stop Event ( ev ) ; } 
function ( ev ) { var handled ; 
function ( ) { this . is Updating = true ; var input = { typed : this . element . value , cursor : { start : dom . get Selection Start ( this . element ) , end : dom . get Selection End ( this . element . selection End ) } } ; this . cli . update ( input ) ; var display = this . cli . get Assignment At ( input . cursor . start ) . get Hint ( ) ; 
function ( scores ) { var completion = ' ' ; 
function ( ev ) { if ( this . is Updating ) { return ; } var prefix = this . element . value . substring ( 0 , ev . argument . start ) ; var suffix = this . element . value . substring ( ev . argument . end ) ; var insert = typeof ev . text = = = 'string ' ? ev . text : ev . text . name ; this . element . value = prefix + insert + suffix ; 
function image Url ( path ) { var data Url ; try { data Url = require ( 'text !cockpit /ui / ' + path ) ; } catch ( e ) { } if ( data Url ) { return data Url ; } var filename = module . id . split ( ' / ' ) . pop ( ) + ' .js ' ; var image Path ; if ( module . uri . substr ( - filename . length ) ! = = filename ) { console . error ( 'Can \ 't work out path from module .uri /module .id ' ) ; return path ; } if ( module . uri ) { var end = module . uri . length - filename . length - 1 ; return module . uri . substr ( 0 , end ) + " / " + path ; } return filename + path ; } 
function Request View ( request , cli View ) { this . request = request ; this . cli View = cli View ; this . image Url = image Url ; 
function ( ev ) { this . cli View . cli . update ( { typed : this . request . typed , cursor : { start : 0 , end : 0 } } ) ; this . cli View . cli . exec ( ) ; } 
function ( member , clone , ref ) { ref . parent Node . insert Before ( clone , ref ) ; data [ param Name ] = member ; self . process Node ( clone , data ) ; delete data [ param Name ] ; } 
function ( scope , member ) { self . scope . push ( scope ) ; try { if ( node . node Name = = = 'LOOP ' ) { for ( var i = 0 ; i < node . child Nodes . length ; i + + ) { var clone = node . child Nodes [ i ] . clone Node ( true ) ; process Single ( member , clone , node ) ; } } else { var clone = node . clone Node ( true ) ; clone . remove Attribute ( 'foreach ' ) ; process Single ( member , clone , node ) ; } } finally { self . scope . pop ( ) ; } } 
function string ( state ) { return [ { token : "string " , regex : ' " . * ? " ' } , { token : "string " , 
function ( data , hash Id , key ) { 
function ( urlparam , parent , callback , auth ) { if ( ! parent . server . models All ) parent . server . models All = { } var config = parent . server . config var fn = urlparam . split ( ' . ' ) fn [ 0 ] = config . ADMIN _MODULES _DIR fn = fn . join ( " / " ) 
function ( mdl ) { callback ( mdl ) if ( ! config . DEBUG ) return ; 
function ( model , req ) { if ( ! model ) return { } var fields = { } , query Field Set if ( req ) { if ( req . field Set ) { query Field Set = { } try { query Field Set = JSON . parse ( req . field Set ) } catch ( e ) { query Field Set = null } } else if ( req . urlparams & & req . urlparams [ 1 ] ) { query Field Set = { } var x = req . urlparams [ 1 ] . split ( ' , ' ) for ( var i = 0 ; i < x . length ; i + + ) query Field Set [ x [ i ] ] = 1 } } for ( var i in model . fields ) if ( model . fields [ i ] & & model . fields [ i ] . visable ) { if ( ! query Field Set | | query Field Set [ model . fields [ i ] . name ] ) fields [ model . fields [ i ] . name ] = 1 } return fields ; } 
function create Backbone Router With Pre Initialize ( ) { var Monkey Router = function ( options ) { if ( ! _ . is Undefined ( this . pre Initialize ) ) { this . pre Initialize ( options ) ; } return Backbone . Router . call ( this , options ) ; } ; _ . extend ( Monkey Router , Backbone . Router ) ; _ . extend ( Monkey Router . prototype , Backbone . Router . prototype ) ; return Monkey Router ; } 
function apply Mixin ( backbone Router , mixin ) { var Router = backbone Router . extend ( { } ) ; _ . extend ( Router . prototype , mixin ) ; return Router ; } 
function ( grid ) { var me = this ; if ( grid . rendered ) { me . grid = grid ; grid . get View ( ) . on ( { render : function ( v ) { me . view = v ; Ext . ux . dd . Cell Field Drop Zone . superclass . constructor . call ( me , me . view . el ) ; } , single : true } ) ; } else { grid . on ( 'render ' , me . init , me , { single : true } ) ; } } 
function ( target , dd , e , drag Data ) { delete this . drop OK ; if ( ! target ) { return ; } 
function ( target , dd , e , drag Data ) { if ( this . drop OK ) { var value = drag Data . field . get Value ( ) ; target . record . set ( target . field Name , value ) ; this . on Cell Drop ( target . field Name , value ) ; return true ; } } 
function type Func ( bindings ) { var v = param Func ( bindings ) if ( v ! = = undefined ) { var type Code = s . object State . get Object Type ( v ) return s . schema . _by Code [ type Code ] . name } } 
function ( css Text , id ) { var ss , head = doc . get Elements By Tag Name ( "head " ) [ 0 ] , style El = doc . create Element ( "style " ) ; style El . set Attribute ( "type " , "text /css " ) ; if ( id ) { style El . set Attribute ( "id " , id ) ; } if ( Ext . is IE ) { head . append Child ( style El ) ; ss = style El . style Sheet ; ss . css Text = css Text ; } else { try { style El . append Child ( doc . create Text Node ( css Text ) ) ; } catch ( e ) { style El . css Text = css Text ; } head . append Child ( style El ) ; ss = style El . style Sheet ? style El . style Sheet : ( style El . sheet | | doc . style Sheets [ doc . style Sheets . length - 1 ] ) ; } CSS . cache Style Sheet ( ss ) ; return ss ; } 
function ( id ) { var existing = doc . get Element By Id ( id ) ; if ( existing ) { existing . parent Node . remove Child ( existing ) ; } } 
function ( id , url ) { var ss ; CSS . remove Style Sheet ( id ) ; ss = doc . create Element ( "link " ) ; ss . set Attribute ( "rel " , "stylesheet " ) ; ss . set Attribute ( "type " , "text /css " ) ; ss . set Attribute ( "id " , id ) ; ss . set Attribute ( "href " , url ) ; doc . get Elements By Tag Name ( "head " ) [ 0 ] . append Child ( ss ) ; } 
function ( refresh Cache ) { var result = { } , selector ; if ( rules = = = null | | refresh Cache ) { CSS . refresh Cache ( ) ; } for ( selector in rules ) { result [ selector ] = rules [ selector ] . css Rule ; } return result ; } 
function ( selector , refresh Cache , raw Cache ) { var i , result ; if ( ! rules | | refresh Cache ) { CSS . refresh Cache ( ) ; } if ( ! Ext . is Array ( selector ) ) { result = rules [ selector . to Lower Case ( ) ] if ( result & & ! raw Cache ) { result = result . css Rule ; } return result | | null ; } for ( i = 0 ; i < selector . length ; i + + ) { if ( rules [ selector [ i ] ] ) { return raw Cache ? rules [ selector [ i ] . to Lower Case ( ) ] : rules [ selector [ i ] . to Lower Case ( ) ] . css Rule ; } } return null ; } 
function ( style Sheet , selector , css Text ) { var result , rule Set = style Sheet . css Rules | | style Sheet . rules , index = rule Set . length ; if ( style Sheet . insert Rule ) { style Sheet . insert Rule ( selector + ' { ' + css Text + ' } ' , index ) ; } else { style Sheet . add Rule ( selector , css Text | | ' ' ) ; } CSS . cache Rule ( result = rule Set [ index ] , style Sheet ) ; return result ; } 
function clone Object ( obj ) { if ( obj = = = null | | typeof obj ! = = 'object ' ) { return obj ; } var temp = obj . constructor ( ) ; 
function ( node , callback , scope , args ) { var me = this , reader , data Root , data , callback Args ; 
function ( root , prevent Load ) { var me = this , model = me . model , id Property = model . prototype . id Property root = root | | { } ; if ( ! root . is Model ) { root = Ext . apply ( { } , root ) ; 
function ( node 1 , node 2 ) { return node 1 [ node 1 . persistence Property ] . index - node 2 [ node 2 . persistence Property ] . index ; } 
function ( operation ) { var me = this , successful = operation . was Successful ( ) , records = operation . get Records ( ) , node = operation . node ; me . loading = false ; node . set ( 'loading ' , false ) ; if ( successful ) { if ( ! me . clear On Load ) { records = me . clean Records ( node , records ) ; } records = me . fill Node ( node , records ) ; } * @event load * Fires whenever the store reads data from a remote data source . * @param {Ext .data .Tree Store } this * @param {Ext .data .Node Interface } node The node that was loaded . * @param {Ext .data .Model [ ] } records An array of records . * @param {Boolean } successful True if the operation was successful . * / 
function init ( tag , attrs , params ) { * View constructor * * @copy Params ose -html 5 .lib .wrap /constructor * * @method constructor * / O . inherited ( this ) ( tag | | 'ul ' , attrs , params ) ; this . updating = 0 ; this . hook ( ) ; this . text ( 'Loading . . . ' ) ; } 
function ( event , opts , fn , anyway ) { 
function ( req , res , run Method ) { var form = new formidable . Incoming Form ( ) , files = { } , fields = { } , size = 0 for ( var i in form Config ) { form [ i ] = form Config [ i ] } form . on ( 'file ' , function ( field , file ) { size + = file . size if ( size > max Upload Size ) { return false ; } if ( files [ field ] ) { if ( ! util . is Array ( files [ field ] ) ) files [ field ] = [ files [ field ] ] files [ field ] . push ( file ) } else { files [ field ] = file ; } } ) form . on ( 'field ' , function ( field , value ) { if ( fields [ field ] ) { if ( ! util . is Array ( fields [ field ] ) ) fields [ field ] = [ fields [ field ] ] fields [ field ] . push ( value ) } else { fields [ field ] = value ; } } ) form . on ( 'end ' , function ( ) { fields . files = files run Method ( req , res , fields ) ; } ) ; form . parse ( req ) ; } 
function ( serv , conf ) { if ( conf . auth ) { var basic Auth = require ( 'http -auth ' ) ; var basic = basic Auth . basic ( { realm : "Closed Area . " } , function ( username , password , callback ) { 
function process Argv ( app , argv , options ) { var opts = utils . extend ( { } , options ) ; if ( opts . expand = = = false | | argv . expand = = = 'false ' ) { return argv ; } argv = utils . expand Args ( argv , opts ) ; return sort Args ( app , argv , opts ) ; } 
function sort Args ( app , argv , options ) { options = options | | [ ] ; var first = options . first | | [ ] ; var last = options . last | | [ ] ; var cli Keys = [ ] ; if ( app . cli & & app . cli . keys ) { cli Keys = app . cli . keys ; } var keys = utils . union ( first , cli Keys , Object . keys ( argv ) ) ; keys = utils . diff ( keys , last ) ; keys = utils . union ( keys , last ) ; var len = keys . length ; var idx = - 1 ; var res = { } ; while ( + + idx < len ) { var key = keys [ idx ] ; if ( argv . has Own Property ( key ) ) { res [ key ] = argv [ key ] ; } } return res ; } 
function ( line Num ) { var Changeset = require ( 'ep _etherpad -lite /static /js /Changeset ' ) ; var Changeset Utils = require ( 'ep _etherpad -lite /static /js /Changeset Utils ' ) ; var _ = require ( 'ep _etherpad -lite /static /js /underscore ' ) ; var aline = Cristo . rep . alines [ line Num ] ; if ( aline ) { var entry = Cristo . rep . lines . at Index ( line Num ) ; var text = entry . text ; var op Iter = Changeset . op Iterator ( aline ) ; var ci = - 1 ; var bci = - 1 ; var attributes = [ ] ; while ( op Iter . has Next ( ) ) { var op = op Iter . next ( ) ; bci = ci + 1 ; ci + = op . chars ; Changeset . each Attrib Number ( op . attribs , function ( n ) { if ( bci > text . length ) { return ; } attributes . push ( { name : Cristo . rep . apool . get Attrib Key ( n ) , value : Cristo . rep . apool . get Attrib Value ( n ) , offset : bci , limit : ci - bci + 1 , char Start : text [ bci ] , char End : text [ Math . min ( ci , text . length - 1 ) ] , remove : function ( with Char , limit ) { limit = Math . min ( this . offset + ( limit > 0 ? limit : this . limit ) , entry . width ) ; var builder = Changeset . builder ( Cristo . rep . lines . total Width ( ) ) ; if ( with Char ) { Changeset Utils . build Keep To Start Of Range ( Cristo . rep , builder , [ line Num , this . offset ] ) ; Changeset Utils . build Remove Range ( Cristo . rep , builder , [ line Num , this . offset ] , [ line Num , limit ] ) ; } else { var attribs = _replace Attrib ( this ) ; 
function ( line Num , attribute Name ) { var _ = require ( 'ep _etherpad -lite /static /js /underscore ' ) ; if ( ! _ . is Array ( attribute Name ) ) { attribute Name = [ attribute Name ] ; } var all Attribs = this . get All Attributes On Line ( line Num ) ; return _ . filter ( all Attribs , function ( a ) { return _ . contains ( attribute Name , a . name ) ; } ) ; } 
function ( ) { var me = this , min = me . normalize Date ( me . min Value | | me . abs Min ) , max = me . normalize Date ( me . max Value | | me . abs Max ) ; me . range Filter . set Filter Fn ( function ( record ) { var date = record . get ( 'date ' ) ; return date > = min & & date < = max ; } ) ; me . store . filter ( ) ; } 
function ( ) { var me = this , picker = new Ext . tree . Panel ( { shrink Wrap Dock : 2 , store : me . store , floating : true , display Field : me . display Field , columns : me . columns , min Height : me . min Picker Height , max Height : me . max Picker Height , manage Height : false , shadow : false , listeners : { scope : me , itemclick : me . on Item Click } , view Config : { listeners : { scope : me , render : me . on View Render } } } ) , view = picker . get View ( ) ; if ( Ext . is IE 9 & & Ext . is Strict ) { 
function ( ) { var style = this . picker . get View ( ) . get El ( ) . dom . style ; 
function ( ) { var me = this , picker ; if ( me . is Expanded ) { picker = me . get Picker ( ) ; if ( me . match Field Width ) { 
function ( e , el ) { var key = e . get Key ( ) ; if ( key = = = e . ENTER | | ( key = = = e . TAB & & this . select On Tab ) ) { this . select Item ( this . picker . get Selection Model ( ) . get Selection ( ) [ 0 ] ) ; } } 
function ( record ) { var me = this ; me . set Value ( record . get Id ( ) ) ; me . picker . hide ( ) ; me . input El . focus ( ) ; me . fire Event ( 'select ' , me , record ) } 
function ( ) { var me = this , picker = me . picker , store = picker . store , value = me . value , node ; if ( value ) { node = store . get Node By Id ( value ) ; } if ( ! node ) { node = store . get Root Node ( ) ; } picker . select Path ( node . get Path ( ) ) ; Ext . defer ( function ( ) { picker . get View ( ) . focus ( ) ; } , 1 ) ; } 
function ( value ) { var me = this , record ; me . value = value ; if ( me . store . loading ) { 
function ( key ) { var pos = key . index Of ( ' [ ' ) ; if ( pos = = = - 1 ) return { type : 'string ' , val : key } ; return { type : 'array ' , val : key . substr ( 0 , pos ) } ; } 
function ( direction ) { var me = this ; me . direction = direction ? direction . to Upper Case ( ) : direction ; me . update Sort Function ( ) ; } 
function ( ) { var me = this ; me . direction = Ext . String . toggle ( me . direction , "ASC " , "DESC " ) ; me . update Sort Function ( ) ; } 
function ( fn ) { var me = this ; fn = fn | | me . sorter Fn | | me . default Sorter Fn ; me . sort = me . create Sort Function ( fn ) ; } 
function ( text ) { var me = this , out = me . body ; text = text . replace ( me . apos Re , " \ \ ' " ) . replace ( me . new Line Re , ' \ \n ' ) ; if ( me . use Index ) { out . push ( 'out [out .length ] = \ ' ' , text , ' \ ' \n ' ) ; } else { out . push ( 'out .push ( \ ' ' , text , ' \ ' ) \n ' ) ; } } 
function Recurring ( str ) { var parts = str . split ( ' / ' ) ; if ( str . char At ( 0 ) ! = 'R ' | | parts . length ! = 3 ) { throw new Error ( 'Invalid Recurring Date ' ) ; } 
function conditional Require ( options ) { 
function read Data ( full Path , data , type , path ) { var vow = VOW . make ( ) ; 
function recast ( args ) { var encoding = args . encoding | | undefined ; 
function compose Function ( flist ) { if ( flist . length = = = 0 ) return function identity ( data ) { return VOW . kept ( data ) ; } ; else if ( flist . length = = = 1 ) return flist [ 0 ] ; else if ( flist . length = = = 2 ) return function ( data ) { return flist [ 0 ] ( data ) . when ( flist [ 1 ] ) ; } ; else if ( flist . length = = = 3 ) return function ( data ) { return flist [ 0 ] ( data ) . when ( flist [ 1 ] ) . when ( flist [ 2 ] ) ; } ; else if ( flist . length = = = 4 ) return function ( data ) { return flist [ 0 ] ( data ) . when ( flist [ 1 ] ) . when ( flist [ 2 ] ) . when ( flist [ 3 ] ) ; } ; return function ( ) { return VOW . broken ( "Can 't have more than four passes ! ! ! . Shouldn 't happen ! ! ! " ) ; } ; 
function Room ( host , gapi ) { var hangout = gapi . hangout var id = hangout . get Hangout Id ( ) var people = reducible ( function ( next , state ) { var invoke = invoker ( next , state , cleanup ) hangout . on Participants Added . add ( on Add ) hangout . on Participants Removed . add ( on Remove ) hangout . get Participants ( ) . for Each ( add ) var timer = set Timeout ( function loop ( ) { hangout . get Participants ( ) . for Each ( add ) timer = set Timeout ( loop , 1 0 0 0 ) } , 1 0 0 0 ) function on Add ( event ) { event . added Participants . for Each ( add ) } function on Remove ( event ) { event . removed Participants . for Each ( remove ) } function add ( par ) { invoke ( { id : par . person . id , image Uri : par . person . image . url , name : par . person . display Name , online : true , ts : now ( ) } ) } function remove ( par ) { invoke ( { id : par . person . id , online : false } ) } function cleanup ( callback ) { clear Timeout ( timer ) hangout . on Participants Added . remove ( on Add ) hangout . on Participants Removed . remove ( on Remove ) callback ( null ) } } ) return { id : id , host : host , people : people } } 
function pre Initialize ( options ) { debug ( 'pre initialize ' ) ; this . app = options . app ; this . layout Template = options . layout Template ; this . start Express App = options . start Express App ; this . api Adapter = options . api Adapter ; this . setup Request Context = options . setup Request Context ; } 
function route ( route Uri ) { debug ( 'route ` %s ` ' , route Uri ) ; var self = this , Barefoot = require ( ' . . / ' ) ( ) ; 
function render ( view ) { debug ( 'render ' ) ; var self = this , $ ; function init DOM ( ) { debug ( 'init DOM ' ) ; $ = cheerio . load ( self . layout Template ) ; } function render Main View ( ) { debug ( 'render main view ' ) ; var promise ; if ( ! _ . is Undefined ( self . main View ) ) { var cloned Main View = _ . clone ( self . main View ( ) ) ; cloned Main View . $ = $ ; cloned Main View . $el = cloned Main View . select DOMElement ( $ ) ; promise = cloned Main View . render ( ) ; } return promise ; } function render View ( ) { debug ( 'render view ' ) ; view . $ = $ ; view . $el = view . select DOMElement ( $ ) ; return view . render ( ) ; } function serialize Data Store ( ) { debug ( 'serialize data store ' ) ; if ( ! _ . is Undefined ( self . data Store ) & & _ . keys ( self . data Store . registered Models And Collections ) . length > 0 ) { var serializied Data Store = JSON . stringify ( self . data Store . to JSON ( ) ) , java Script Element = ' <script >function deserialize Data Store ( ) { ' + 'return ' + serializied Data Store + ' ; } < /script > ' ; $ ( 'body ' ) . append ( java Script Element ) ; } } function write HTTPResponse ( ) { debug ( 'write http response ' ) ; self . res . send ( $ . html ( ) ) ; } function write HTTPError ( err ) { winston . log ( 'error ' , 'Uncatched HTTP Error ' , { source : to String ( ) , err : err . to String ( ) | | err , stack : err . stack | | undefined } ) ; debug ( 'write http error ' ) ; self . res . send ( 5 0 0 ) ; } Q . fcall ( init DOM ) . then ( render Main View ) . then ( render View ) . then ( serialize Data Store ) . done ( write HTTPResponse , write HTTPError ) ; } 
function iopa Static Send ( context , path , opts ) { opts = opts | | { } ; return new Promise ( function iopa Static Load ( resolve , reject ) { var root = opts . root ? normalize ( path Resolve ( opts . root ) ) : ' ' ; var index = opts . index ; var maxage = opts . maxage | | 0 ; var hidden = opts . hidden | | false ; var sync = opts . sync | | false ; opts = null ; 
function bind Removed ( that , content ) { content . on ( 'removed ' , function ( ev ) { if ( content = = = that . content ) { delete that . content ; } if ( ! that . content & & that . header ) { that . header . empty ( ) ; } } ) ; } 
function ( ed , url ) { var self = this , settings = ed . settings ; self . editor = ed ; / / Parses the specified time string into a milisecond number 1 0m , 1 0s etc . function parse Time ( time ) { var multipels = { s : 1 0 0 0 , m : 6 0 0 0 0 } ; time = / ^ ( \d + ) ( [ms ] ? ) $ / . exec ( ' ' + time ) ; return ( time [ 2 ] ? multipels [ time [ 2 ] ] : 1 ) * parse Int ( time ) ; } ; / / Default config tinymce . each ( { ask _before _unload : TRUE , interval : ' 3 0s ' , retention : ' 2 0m ' , minlength : 5 0 } , function ( value , key ) { key = PLUGIN _NAME + ' _ ' + key ; if ( settings [ key ] = = = undefined ) settings [ key ] = value ; } ) ; / / Parse times settings . autosave _interval = parse Time ( settings . autosave _interval ) ; settings . autosave _retention = parse Time ( settings . autosave _retention ) ; / / Register restore button ed . add Button ( RESTORE _DRAFT , { title : PLUGIN _NAME + " .restore _content " , onclick : function ( ) { if ( ed . get Content ( { draft : true } ) . replace ( / \s | &nbsp ; | < \ / ?p [ ^ > ] * > | <br [ ^ > ] * > / gi , " " ) . length > 0 ) { / / Show confirm dialog if the editor isn 't empty ed . window Manager . confirm ( PLUGIN _NAME + " .warning _message " , function ( ok ) { if ( ok ) self . restore Draft ( ) ; } ) ; } else self . restore Draft ( ) ; } } ) ; / / Enable /disable restoredraft button depending on if there is a draft stored or not ed . on Node Change . add ( function ( ) { var control Manager = ed . control Manager ; if ( control Manager . get ( RESTORE _DRAFT ) ) control Manager . set Disabled ( RESTORE _DRAFT , ! self . has Draft ( ) ) ; } ) ; ed . on Init . add ( function ( ) { / / Check if the user added the restore button , then setup auto storage logic if ( ed . control Manager . get ( RESTORE _DRAFT ) ) { / / Setup storage engine self . setup Storage ( ed ) ; / / Auto save contents each interval time set Interval ( function ( ) { if ( ! ed . removed ) { self . store Draft ( ) ; ed . node Changed ( ) ; } } , settings . autosave _interval ) ; } } ) ; self . on Store Draft = new Dispatcher ( self ) ; self . on Restore Draft = new Dispatcher ( self ) ; self . on Remove Draft = new Dispatcher ( self ) ; / / Add ask before unload dialog only add one unload handler if ( ! unload Handler Added ) { window . onbeforeunload = tinymce . plugins . Auto Save . _before Unload Handler ; unload Handler Added = TRUE ; } } 
function ( ed ) { var self = this , test Key = PLUGIN _NAME + ' _test ' , test Val = "OK " ; self . key = PLUGIN _NAME + ed . id ; / / Loop though each storage engine type until we find one that works tinymce . each ( [ function ( ) { / / Try HTML 5 Local Storage if ( local Storage ) { local Storage . set Item ( test Key , test Val ) ; if ( local Storage . get Item ( test Key ) = = = test Val ) { local Storage . remove Item ( test Key ) ; return local Storage ; } } } , function ( ) { / / Try HTML 5 Session Storage if ( session Storage ) { session Storage . set Item ( test Key , test Val ) ; if ( session Storage . get Item ( test Key ) = = = test Val ) { session Storage . remove Item ( test Key ) ; return session Storage ; } } } , function ( ) { / / Try IE user Data if ( tinymce . is IE ) { ed . get Element ( ) . style . behavior = "url ( ' #default #user Data ' ) " ; / / Fake local Storage on old IE return { auto Expires : TRUE , set Item : function ( key , value ) { var user Data Element = ed . get Element ( ) ; user Data Element . set Attribute ( key , value ) ; user Data Element . expires = self . get Exp Date ( ) ; try { user Data Element . save ( "Tiny MCE " ) ; } catch ( e ) { / / Ignore , saving might fail if "Userdata Persistence " is disabled in IE } } , get Item : function ( key ) { var user Data Element = ed . get Element ( ) ; try { user Data Element . load ( "Tiny MCE " ) ; return user Data Element . get Attribute ( key ) ; } catch ( e ) { / / Ignore , loading might fail if "Userdata Persistence " is disabled in IE return null ; } } , remove Item : function ( key ) { ed . get Element ( ) . remove Attribute ( key ) ; } } ; } } , ] , function ( setup ) { / / Try executing each function to find a suitable storage engine try { self . storage = setup ( ) ; if ( self . storage ) return false ; } catch ( e ) { / / Ignore } } ) ; } 
function ( ) { var self = this , storage = self . storage , editor = self . editor , expires , content ; / / Is the contents dirty if ( storage ) { / / If there is no existing key and the contents hasn 't been changed since / / it 's original value then there is no point in saving a draft if ( ! storage . get Item ( self . key ) & & ! editor . is Dirty ( ) ) return ; / / Store contents if the contents if longer than the minlength of characters content = editor . get Content ( { draft : true } ) ; if ( content . length > editor . settings . autosave _minlength ) { expires = self . get Exp Date ( ) ; / / Store expiration date if needed IE user Data has auto expire built in if ( ! self . storage . auto Expires ) self . storage . set Item ( self . key + " _expires " , expires ) ; self . storage . set Item ( self . key , content ) ; self . on Store Draft . dispatch ( self , { expires : expires , content : content } ) ; } } } 
function ( ) { var self = this , storage = self . storage , content ; if ( storage ) { content = storage . get Item ( self . key ) ; if ( content ) { self . editor . set Content ( content ) ; self . on Restore Draft . dispatch ( self , { content : content } ) ; } } } 
function ( ) { var self = this , storage = self . storage , exp Date , exists ; if ( storage ) { / / Does the item exist at all exists = ! ! storage . get Item ( self . key ) ; if ( exists ) { / / Storage needs autoexpire if ( ! self . storage . auto Expires ) { exp Date = new Date ( storage . get Item ( self . key + " _expires " ) ) ; / / Contents hasn 't expired if ( new Date ( ) . get Time ( ) < exp Date . get Time ( ) ) return TRUE ; / / Remove it if it has self . remove Draft ( ) ; } else return TRUE ; } } return false ; } 
function ( ) { var self = this , storage = self . storage , key = self . key , content ; if ( storage ) { / / Get current contents and remove the existing draft content = storage . get Item ( key ) ; storage . remove Item ( key ) ; storage . remove Item ( key + " _expires " ) ; / / Dispatch remove event if we had any contents if ( content ) { self . on Remove Draft . dispatch ( self , { content : content } ) ; } } } 
function ( e ) { var msg ; tinymce . each ( tiny MCE . editors , function ( ed ) { / / Store a draft for each editor instance if ( ed . plugins . autosave ) ed . plugins . autosave . store Draft ( ) ; / / Never ask in fullscreen mode if ( ed . get Param ( "fullscreen _is _enabled " ) ) return ; / / Setup a return message if the editor is dirty if ( ! msg & & ed . is Dirty ( ) & & ed . get Param ( "autosave _ask _before _unload " ) ) msg = ed . get Lang ( "autosave .unload _msg " ) ; } ) ; return msg ; } 
function request ( url ) { return new Promise ( function ( resolve , reject ) { _request ( url , function ( error , response , body ) { if ( error ) return reject ( error ) ; resolve ( { response , body } ) } ) ; } ) ; } 
function ( ) { if ( typeof objective . promised = = = 'undefined ' ) { debug ( 'Got no promise from objective function ' ) ; return pipeline . emit ( 'objective .not .promised ' , { config : config , fn : objective Fn , result : running , deferral : deferral , root : root } , function ( err ) { if ( typeof err ! = = 'undefined ' & & err ! = = null ) { clear Require ( ) ; objective . current Child = null ; return deferral . reject ( err ) ; } clear Require ( ) ; objective . current Child = null ; deferral . resolve ( ) ; } ) ; } return objective . promised ; } 
function ( grid , state ) { var filters = { } ; this . filters . each ( function ( filter ) { if ( filter . active ) { filters [ filter . data Index ] = filter . get Value ( ) ; } } ) ; return ( state . filters = filters ) ; } 
function ( store ) { var me = this ; 
function ( ) { var me = this , header Ct = me . view . header Ct ; if ( header Ct ) { header Ct . items . each ( function ( header ) { var filter = me . get Filter ( header . data Index ) ; header [ filter & & filter . active ? 'add Cls ' : 'remove Cls ' ] ( me . filter Cls ) ; } ) ; } } 
function ( ) { var f = [ ] , len , i ; this . filters . each ( function ( filter ) { if ( filter . active ) { f . push ( filter ) ; } } ) ; len = f . length ; return function ( record ) { for ( i = 0 ; i < len ; i + + ) { if ( ! f [ i ] . validate Record ( record ) ) { return false ; } } return true ; } ; } 
function ( config ) { var me = this , columns = me . get Grid Panel ( ) . columns , i , columns Length , column , filters Length , filter ; for ( i = 0 , columns Length = columns . length ; i < columns Length ; i + + ) { column = columns [ i ] ; if ( column . data Index = = = config . data Index ) { column . filter = config ; } } if ( me . view . header Ct . menu ) { me . create Filters ( ) ; } else { 
function ( filters ) { if ( filters ) { var me = this , i , filters Length ; for ( i = 0 , filters Length = filters . length ; i < filters Length ; i + + ) { me . add Filter ( filters [ i ] ) ; } } } 
function ( ) { var items = this . get Filter Items ( ) , filters = [ ] , n , nlen , item , d , i , len ; for ( n = 0 , nlen = items . length ; n < nlen ; n + + ) { item = items [ n ] ; if ( item . active ) { d = [ ] . concat ( item . serialize ( ) ) ; for ( i = 0 , len = d . length ; i < len ; i + + ) { filters . push ( { field : item . data Index , data : d [ i ] } ) ; } } } return filters ; } 
function ( filters ) { var p = { } , i , f , root , data Prefix , key , tmp , len = filters . length ; if ( ! this . encode ) { for ( i = 0 ; i < len ; i + + ) { f = filters [ i ] ; root = [ this . param Prefix , ' [ ' , i , ' ] ' ] . join ( ' ' ) ; p [ root + ' [field ] ' ] = f . field ; data Prefix = root + ' [data ] ' ; for ( key in f . data ) { p [ [ data Prefix , ' [ ' , key , ' ] ' ] . join ( ' ' ) ] = f . data [ key ] ; } } } else { tmp = [ ] ; for ( i = 0 ; i < len ; i + + ) { f = filters [ i ] ; tmp . push ( Ext . apply ( { } , { field : f . field } , f . data ) ) ; } 
function ( p ) { 
function ( record , column Header ) { var me = this , grid = me . editing Plugin . grid , store = grid . store , view = grid . get View ( ) , context = me . context = Ext . apply ( me . editing Plugin . context , { view : view , store : store } ) ; if ( ! me . rendered ) { me . render ( view . el ) ; } 
function Approximate ( ) { if ( arguments . length > 0 ) { if ( arguments [ 0 ] . length < 1 | | arguments [ 0 ] . char At ( 0 ) ! = 'A ' ) { throw new Error ( 'Invalid Approximate Date ' ) ; } try { Simple . call ( this , arguments [ 0 ] . substr ( 1 ) ) ; } catch ( e ) { throw new Error ( e . message + ' in Approximate Date ' ) ; } } else { Simple . call ( this ) ; } } 
function ( as String , dirty Only , include Empty Text , use Data Values ) { return this . get Form ( ) . get Values ( as String , dirty Only , include Empty Text , use Data Values ) ; } 
function ( interval ) { this . stop Polling ( ) ; var task = new Ext . util . Task Runner ( interval ) ; task . start ( { interval : 0 , run : this . check Change , scope : this } ) ; this . poll Task = task ; } 
function ( ) { var fields = this . form . get Fields ( ) . items , f , f Len = fields . length ; for ( f = 0 ; f < f Len ; f + + ) { fields [ f ] . check Change ( ) ; } } 
function ( form , url , params , options ) { form = Ext . get Dom ( form ) ; options = options | | { } ; var id = Ext . id ( ) , frame = document . create Element ( 'iframe ' ) , hiddens = [ ] , encoding = 'multipart /form -data ' , buf = { target : form . target , method : form . method , encoding : form . encoding , enctype : form . enctype , action : form . action } , add Field = function ( name , value ) { hidden Item = document . create Element ( 'input ' ) ; Ext . fly ( hidden Item ) . set ( { type : 'hidden ' , value : value , name : name } ) ; form . append Child ( hidden Item ) ; hiddens . push ( hidden Item ) ; } , hidden Item , obj , value , name , v Len , v , h Len , h ; Ext . fly ( frame ) . set ( { id : id , name : id , cls : Ext . base CSSPrefix + 'hide -display ' , src : Ext . SSL _SECURE _URL } ) ; document . body . append Child ( frame ) ; 
function ( options ) { var form = this . get Form ( options ) ; if ( form ) { return ( options . is Upload | | ( / multipart \ /form -data / i ) . test ( form . get Attribute ( 'enctype ' ) ) ) ; } return false ; } 
function ( options , url ) { var form = this . get Form ( options ) ; if ( form ) { url = url | | form . action ; } return url ; } 
function ( options , params ) { var form = this . get Form ( options ) , serialized Form ; if ( form & & ! this . is Form Upload ( options ) ) { serialized Form = Ext . Element . serialize Form ( form ) ; params = params ? ( params + ' & ' + serialized Form ) : serialized Form ; } return params ; } 
function ( ) { var xdr ; if ( Ext . ie Version > = 8 ) { xdr = new XDomain Request ( ) ; } else { Ext . Error . raise ( { msg : 'Your browser does not support CORS ' } ) ; } return xdr ; } 
function ( request ) { if ( ! request ) { request = this . get Latest ( ) ; } if ( ! ( request & & request . xhr ) ) { return false ; } 
function ( request ) { var me = this , xhr ; if ( ! request ) { request = me . get Latest ( ) ; } if ( request & & me . is Loading ( request ) ) { xhr = request . xhr ; try { xhr . onreadystatechange = null ; } catch ( e ) { 
function ( ) { var requests = this . requests , id ; for ( id in requests ) { if ( requests . has Own Property ( id ) ) { this . abort ( requests [ id ] ) ; } } } 
function ( request , xdr Result ) { var me = this ; 
function ( request , xdr Result ) { var me = this , options = request . options , result , success , response ; try { result = me . parse Status ( request . xhr . status ) ; } catch ( e ) { 
function ( status ) { 
function ( request ) { return { request : request , request Id : request . id , status : request . aborted ? - 1 : 0 , status Text : request . aborted ? 'transaction aborted ' : 'communication failure ' , aborted : request . aborted , timedout : request . timedout } ; } 
function ( ) { var script Tag = document . create Element ( 'script ' ) ; script Tag . type = 'text /vbscript ' ; script Tag . text = [ 'Function get IEByte Array (byte Array , out ) ' , 'Dim len , i ' , 'len = Len B (byte Array ) ' , 'For i = 1 to len ' , 'out .push (Asc B (Mid B (byte Array , i , 1 ) ) ) ' , 'Next ' , 'End Function ' ] . join ( ' \n ' ) ; Ext . get Head ( ) . dom . append Child ( script Tag ) ; this . self . vb Script Injected = true ; } 
function Sync Api ( schema , sh , logger ) { _ . assert Object ( schema ) ; _ . assert Function ( logger ) this . log = logger ; this . temporary Id Counter = - 1 ; this . sh = sh ; 
function days In Month ( month , year ) { switch ( month ) { case 1 : case 3 : case 5 : case 7 : case 8 : case 1 0 : case 1 2 : return 3 1 ; case 4 : case 6 : case 9 : case 1 1 : return 3 0 ; case 2 : var leapyear ; if ( year % 4 ! = 0 ) { leapyear = false ; } else if ( year % 1 0 0 ! = 0 ) { leapyear = true ; } else if ( year % 4 0 0 ! = 0 ) { leapyear = false ; } else { leapyear = true ; } if ( leapyear ) { return 2 9 ; } else { return 2 8 ; } default : throw new Error ( 'Unknown Month ' ) ; } } 
function set Defaults ( ) { 
function get Timestamp ( ) { 
function get Sequence ( ) { var mod = + + seq % 1 6 
function assert Range ( name , val , max ) { assert . equal ( typeof val , 'number ' , name + ' must be a number ' ) assert ( ! is Na N ( val ) , 'number ' , name + ' must be a number ' ) if ( val > max ) throw new Range Error ( name + ' must be lower than ' + max + ' , but is ' + val ) else if ( val < 0 ) throw new Range Error ( name + ' must be greater than or equal to zero , but is ' + val ) else if ( val % 1 ) throw new Range Error ( name + ' must be an integer ' ) } 
function proceed To Fetch ( loader , load , p ) { proceed To Translate ( loader , load , p 
function proceed To Translate ( loader , load , p ) { p 
function async Start Load Partway Through ( step State ) { return function ( resolve , reject ) { var loader = step State . loader ; var name = step State . module Name ; var step = step State . step ; if ( loader . modules [ name ] ) throw new Type Error ( ' " ' + name + ' " already exists in the module table ' ) ; 
function create Link Set ( loader , starting Load ) { var link Set = { loader : loader , loads : [ ] , loading Count : 0 } ; link Set . done = new Promise ( function ( resolve , reject ) { link Set . resolve = resolve ; link Set . reject = reject ; } ) ; add Load To Link Set ( link Set , starting Load ) ; return link Set ; } 
function update Link Set On Load ( link Set , load ) { console . assert ( load . status = = 'loaded ' | | load . status = = 'linked ' , 'loaded or linked ' ) ; 
function finish Load ( loader , load ) { 
function link ( link Set ) { var loader = link Set . loader ; 
function link Declarative Module ( load , loads , loader ) { 
function ensure Evaluated ( module , seen , loader ) { if ( module . evaluated | | ! module . dependencies ) return ; seen . push ( module ) ; var deps = module . dependencies ; for ( var i = 0 ; i < deps . length ; i + + ) { var dep = deps [ i ] ; if ( index Of . call ( seen , dep ) = = - 1 ) ensure Evaluated ( dep , seen , loader ) ; } if ( module . evaluated ) return ; module . evaluated = true ; module . execute . call ( _ _global ) ; module . module = Module ( module . exports ) ; delete module . execute ; } 
function Loader ( options ) { if ( typeof options ! = 'object ' ) throw new Type Error ( 'Options must be an object ' ) ; if ( options . normalize ) this . normalize = options . normalize ; if ( options . locate ) this . locate = options . locate ; if ( options . fetch ) this . fetch = options . fetch ; if ( options . translate ) this . translate = options . translate ; if ( options . instantiate ) this . instantiate = options . instantiate ; this . _loader = { loader Obj : this , loads : [ ] , modules : { } } ; define Property ( this , 'global ' , { get : function ( ) { return global ; } } ) ; define Property ( this , 'realm ' , { get : function ( ) { throw new Type Error ( 'Realms not implemented in polyfill ' ) ; } } ) ; } 
function Module ( obj ) { if ( typeof obj ! = 'object ' ) throw new Type Error ( 'Expected object ' ) ; var self = { _ _es Module : true } ; for ( var key in obj ) { ( function ( key ) { define Property ( self , key , { configurable : false , enumerable : true , get : function ( ) { return obj [ key ] ; } } ) ; } ) ( key ) ; } if ( Object . prevent Extensions ) Object . prevent Extensions ( self ) ; return self ; } 
function ( ) { var me = this , view = me . view ; view . on ( { scope : me , groupclick : me . on Group Click } ) ; if ( me . enable Grouping Menu ) { me . inject Grouping Menu ( ) ; } me . prune Grouped Header ( ) ; me . last Group Field = me . get Group Field ( ) ; me . block ( ) ; me . on Group Change ( ) ; me . unblock ( ) ; } 
function ( menu Item , e ) { var me = this , menu = menu Item . parent Menu , hdr = menu . active Header , view = me . view , store = view . store ; delete me . last Group Index ; me . block ( ) ; me . enable ( ) ; store . group ( hdr . data Index ) ; me . prune Grouped Header ( ) ; me . unblock ( ) ; me . refresh If ( ) ; } 
function ( ) { var me = this , header = me . get Grouped Header ( ) ; if ( me . hide Grouped Header & & header ) { Ext . suspend Layouts ( ) ; if ( me . pruned Header & & me . pruned Header ! = = header ) { me . pruned Header . show ( ) ; } me . pruned Header = header ; header . hide ( ) ; Ext . resume Layouts ( true ) ; } } 
function ( data Index ) { var view = this . view , header = view . header Ct . down ( 'gridcolumn [data Index = ' + data Index + ' ] ' ) , menu = view . header Ct . get Menu ( ) ; return header ? menu . down ( 'menuitem [header Id = ' + header . id + ' ] ' ) : null ; } 
function ( view , row Element , group Name , e ) { var me = this , group Cache = me . group Cache , group Is Collapsed = ! me . is Expanded ( group Name ) , g ; if ( me . collapsible ) { 
function ( record ) { var grouper = this . view . store . groupers . first ( ) ; if ( grouper ) { return this . group Cache [ grouper . get Group String ( record ) ] ; } } 
function process ( o , force _rich ) { var dom = ed . dom , rng ; / / Execute pre process handlers t . on Pre Process . dispatch ( t , o ) ; / / Create DOM structure o . node = dom . create ( 'div ' , 0 , o . content ) ; / / If pasting inside the same element and the contents is only one block / / remove the block and keep the text since Firefox will copy parts of pre and h 1 -h 6 as a pre element if ( tinymce . is Gecko ) { rng = ed . selection . get Rng ( true ) ; if ( rng . start Container = = rng . end Container & & rng . start Container . node Type = = 3 ) { / / Is only one block node and it doesn 't contain word stuff if ( o . node . child Nodes . length = = = 1 & & / ^ (p |h [ 1 - 6 ] |pre ) $ / i . test ( o . node . first Child . node Name ) & & o . content . index Of ( ' _ _MCE _ITEM _ _ ' ) = = = - 1 ) dom . remove ( o . node . first Child , true ) ; } } / / Execute post process handlers t . on Post Process . dispatch ( t , o ) ; / / Serialize content o . content = ed . serializer . serialize ( o . node , { get Inner : 1 , forced _root _block : ' ' } ) ; / / Plain text option active ? if ( ( ! force _rich ) & & ( ed . paste As Plain Text ) ) { t . _insert Plain Text ( o . content ) ; if ( ! get Param ( ed , "paste _text _sticky " ) ) { ed . paste As Plain Text = false ; ed . control Manager . set Active ( "pastetext " , false ) ; } } else { t . _insert ( o . content ) ; } } 
function grab Content ( e ) { var n , or , rng , old Rng , sel = ed . selection , dom = ed . dom , body = ed . get Body ( ) , pos Y , text Content ; / / Check if browser supports direct plaintext access if ( e . clipboard Data | | dom . doc . data Transfer ) { text Content = ( e . clipboard Data | | dom . doc . data Transfer ) . get Data ( 'Text ' ) ; if ( ed . paste As Plain Text ) { e . prevent Default ( ) ; process ( { content : dom . encode ( text Content ) . replace ( / \r ? \n / g , ' <br / > ' ) } ) ; return ; } } if ( dom . get ( ' _mce Paste ' ) ) return ; / / Create container to paste into n = dom . add ( body , 'div ' , { id : ' _mce Paste ' , 'class ' : 'mce Paste ' , 'data -mce -bogus ' : ' 1 ' } , ' \u FEFF \u FEFF ' ) ; / / If content Editable mode we need to find out the position of the closest element if ( body ! = ed . get Doc ( ) . body ) pos Y = dom . get Pos ( ed . selection . get Start ( ) , body ) . y ; else pos Y = body . scroll Top + dom . get View Port ( ed . get Win ( ) ) . y ; / / Styles needs to be applied after the element is added to the document since Web Kit will otherwise remove all styles / / If also needs to be in view on IE or the paste would fail dom . set Styles ( n , { position : 'absolute ' , left : tinymce . is Gecko ? - 4 0 : 0 , / / Need to move it out of site on Gecko since it will othewise display a ghost resize rect for the div top : pos Y - 2 5 , width : 1 , height : 1 , overflow : 'hidden ' } ) ; if ( tinymce . is IE ) { / / Store away the old range old Rng = sel . get Rng ( ) ; / / Select the container rng = dom . doc . body . create Text Range ( ) ; rng . move To Element Text ( n ) ; rng . exec Command ( 'Paste ' ) ; / / Remove container dom . remove ( n ) ; / / Check if the contents was changed , if it wasn 't then clipboard extraction failed probably due / / to IE security settings so we pass the junk though better than nothing right if ( n . inner HTML = = = ' \u FEFF \u FEFF ' ) { ed . exec Command ( 'mce Paste Word ' ) ; e . prevent Default ( ) ; return ; } / / Restore the old range and clear the contents before pasting sel . set Rng ( old Rng ) ; sel . set Content ( ' ' ) ; / / For some odd reason we need to detach the the mce Insert Content call from the paste event / / It 's like IE has a reference to the parent element that you paste in and the selection gets messed up / / when it tries to restore the selection set Timeout ( function ( ) { / / Process contents process ( { content : n . inner HTML } ) ; } , 0 ) ; / / Block the real paste event return tinymce . dom . Event . cancel ( e ) ; } else { function block ( e ) { e . prevent Default ( ) ; } ; / / Block mousedown and click to prevent selection change dom . bind ( ed . get Doc ( ) , 'mousedown ' , block ) ; dom . bind ( ed . get Doc ( ) , 'keydown ' , block ) ; or = ed . selection . get Rng ( ) ; / / Move select contents inside DIV n = n . first Child ; rng = ed . get Doc ( ) . create Range ( ) ; rng . set Start ( n , 0 ) ; rng . set End ( n , 2 ) ; sel . set Rng ( rng ) ; / / Wait a while and grab the pasted contents window . set Timeout ( function ( ) { var h = ' ' , nl ; / / Paste divs duplicated in paste divs seems to happen when you paste plain text so lets first look for that broken behavior in Web Kit if ( ! dom . select ( 'div .mce Paste > div .mce Paste ' ) . length ) { nl = dom . select ( 'div .mce Paste ' ) ; / / Web Kit will split the div into multiple ones so this will loop through then all and join them to get the whole HTML string each ( nl , function ( n ) { var child = n . first Child ; / / Web Kit inserts a DIV container with lots of odd styles if ( child & & child . node Name = = 'DIV ' & & child . style . margin Top & & child . style . background Color ) { dom . remove ( child , 1 ) ; } / / Remove apply style spans each ( dom . select ( 'span .Apple -style -span ' , n ) , function ( n ) { dom . remove ( n , 1 ) ; } ) ; / / Remove bogus br elements each ( dom . select ( 'br [data -mce -bogus ] ' , n ) , function ( n ) { dom . remove ( n ) ; } ) ; / / Web Kit will make a copy of the DIV for each line of plain text pasted and insert them into the DIV if ( n . parent Node . class Name ! = 'mce Paste ' ) h + = n . inner HTML ; } ) ; } else { / / Found Web Kit weirdness so force the content into paragraphs this seems to happen when you paste plain text from Nodepad etc / / So this logic will replace double enter with paragraphs and single enter with br so it kind of looks the same h = ' <p > ' + dom . encode ( text Content ) . replace ( / \r ? \n \r ? \n / g , ' < /p > <p > ' ) . replace ( / \r ? \n / g , ' <br / > ' ) + ' < /p > ' ; } / / Remove the nodes each ( dom . select ( 'div .mce Paste ' ) , function ( n ) { dom . remove ( n ) ; } ) ; / / Restore the old selection if ( or ) sel . set Rng ( or ) ; process ( { content : h } ) ; / / Unblock events ones we got the contents dom . unbind ( ed . get Doc ( ) , 'mousedown ' , block ) ; dom . unbind ( ed . get Doc ( ) , 'keydown ' , block ) ; } , 0 ) ; } } 
function process ( items ) { each ( items , function ( v ) { / / Remove or replace if ( v . constructor = = Reg Exp ) h = h . replace ( v , ' ' ) ; else h = h . replace ( v [ 0 ] , v [ 1 ] ) ; } ) ; } 
function ( pl , o ) { var t = this , ed = t . editor , dom = ed . dom , style Props ; if ( ed . settings . paste _enable _default _filters = = false ) { return ; } if ( o . word Content ) { / / Remove named anchors or TOC links each ( dom . select ( 'a ' , o . node ) , function ( a ) { if ( ! a . href | | a . href . index Of ( ' # _Toc ' ) ! = - 1 ) dom . remove ( a , 1 ) ; } ) ; if ( get Param ( ed , "paste _convert _middot _lists " ) ) { t . _convert Lists ( pl , o ) ; } / / Process styles style Props = get Param ( ed , "paste _retain _style _properties " ) ; / / retained properties / / Process only if a string was specified and not equal to "all " or " * " if ( ( tinymce . is ( style Props , "string " ) ) & & ( style Props ! = = "all " ) & & ( style Props ! = = " * " ) ) { style Props = tinymce . explode ( style Props . replace ( / ^none $ / i , " " ) ) ; / / Retains some style properties each ( dom . select ( ' * ' , o . node ) , function ( el ) { var new Style = { } , npc = 0 , i , sp , sv ; / / Store a subset of the existing styles if ( style Props ) { for ( i = 0 ; i < style Props . length ; i + + ) { sp = style Props [ i ] ; sv = dom . get Style ( el , sp ) ; if ( sv ) { new Style [ sp ] = sv ; npc + + ; } } } / / Remove all of the existing styles dom . set Attrib ( el , 'style ' , ' ' ) ; if ( style Props & & npc > 0 ) dom . set Styles ( el , new Style ) ; / / Add back the stored subset of styles else / / Remove empty span tags that do not have class attributes if ( el . node Name = = 'SPAN ' & & ! el . class Name ) dom . remove ( el , true ) ; } ) ; } } / / Remove all style information or only specifically on Web Kit to avoid the style bug on that browser if ( get Param ( ed , "paste _remove _styles " ) | | ( get Param ( ed , "paste _remove _styles _if _webkit " ) & & tinymce . is Web Kit ) ) { each ( dom . select ( ' * [style ] ' , o . node ) , function ( el ) { el . remove Attribute ( 'style ' ) ; el . remove Attribute ( 'data -mce -style ' ) ; } ) ; } else { if ( tinymce . is Web Kit ) { / / We need to compress the styles on Web Kit since if you paste <img border = " 0 " / > it will become <img border = " 0 " style = " . . . lots of junk . . . " / > / / Removing the mce _style that contains the real value will force the Serializer engine to compress the styles each ( dom . select ( ' * ' , o . node ) , function ( el ) { el . remove Attribute ( 'data -mce -style ' ) ; } ) ; } } } 
function ( pl , o ) { var dom = pl . editor . dom , list Elm , li , last Margin = - 1 , margin , levels = [ ] , last Type , html ; / / Convert middot lists into real semantic lists each ( dom . select ( 'p ' , o . node ) , function ( p ) { var sib , val = ' ' , type , html , idx , parents ; / / Get text node value at beginning of paragraph for ( sib = p . first Child ; sib & & sib . node Type = = 3 ; sib = sib . next Sibling ) val + = sib . node Value ; val = p . inner HTML . replace ( / < \ / ? \w + [ ^ > ] * > / gi , ' ' ) . replace ( / &nbsp ; / g , ' \u 0 0a 0 ' ) ; / / Detect unordered lists look for bullets if ( / ^ ( _ _MCE _ITEM _ _ ) + [ \u 2 0 2 2 \u 0 0b 7 \u 0 0a 7 \u 0 0d 8o \u 2 5CF ] \s * \u 0 0a 0 * / . test ( val ) ) type = 'ul ' ; / / Detect ordered lists 1 . , a . or ixv . if ( / ^ _ _MCE _ITEM _ _ \s * \w + \ . \s * \u 0 0a 0 + / . test ( val ) ) type = 'ol ' ; / / Check if node value matches the list pattern : o &nbsp ; &nbsp ; if ( type ) { margin = parse Float ( p . style . margin Left | | 0 ) ; if ( margin > last Margin ) levels . push ( margin ) ; if ( ! list Elm | | type ! = last Type ) { list Elm = dom . create ( type ) ; dom . insert After ( list Elm , p ) ; } else { / / Nested list element if ( margin > last Margin ) { list Elm = li . append Child ( dom . create ( type ) ) ; } else if ( margin < last Margin ) { / / Find parent level based on margin value idx = tinymce . in Array ( levels , margin ) ; parents = dom . get Parents ( list Elm . parent Node , type ) ; list Elm = parents [ parents . length - 1 - idx ] | | list Elm ; } } / / Remove middot or number spans if they exists each ( dom . select ( 'span ' , p ) , function ( span ) { var html = span . inner HTML . replace ( / < \ / ? \w + [ ^ > ] * > / gi , ' ' ) ; / / Remove span with the middot or the number if ( type = = 'ul ' & & / ^ _ _MCE _ITEM _ _ [ \u 2 0 2 2 \u 0 0b 7 \u 0 0a 7 \u 0 0d 8o \u 2 5CF ] / . test ( html ) ) dom . remove ( span ) ; else if ( / ^ _ _MCE _ITEM _ _ [ \s \S ] * \w + \ . ( &nbsp ; | \u 0 0a 0 ) * \s * / . test ( html ) ) dom . remove ( span ) ; } ) ; html = p . inner HTML ; / / Remove middot /list items if ( type = = 'ul ' ) html = p . inner HTML . replace ( / _ _MCE _ITEM _ _ / g , ' ' ) . replace ( / ^ [ \u 2 0 2 2 \u 0 0b 7 \u 0 0a 7 \u 0 0d 8o \u 2 5CF ] \s * ( &nbsp ; | \u 0 0a 0 ) + \s * / , ' ' ) ; else html = p . inner HTML . replace ( / _ _MCE _ITEM _ _ / g , ' ' ) . replace ( / ^ \s * \w + \ . ( &nbsp ; | \u 0 0a 0 ) + \s * / , ' ' ) ; / / Create li and add paragraph data into the new li li = list Elm . append Child ( dom . create ( 'li ' , 0 , html ) ) ; dom . remove ( p ) ; last Margin = margin ; last Type = type ; } else list Elm = last Margin = 0 ; / / End list element } ) ; / / Remove any left over makers html = o . node . inner HTML ; if ( html . index Of ( ' _ _MCE _ITEM _ _ ' ) ! = - 1 ) o . node . inner HTML = html . replace ( / _ _MCE _ITEM _ _ / g , ' ' ) ; } 
function ( h , skip _undo ) { var ed = this . editor , r = ed . selection . get Rng ( ) ; / / First delete the contents seems to work better on Web Kit when the selection spans multiple list items or multiple table cells . if ( ! ed . selection . is Collapsed ( ) & & r . start Container ! = r . end Container ) ed . get Doc ( ) . exec Command ( 'Delete ' , false , null ) ; ed . exec Command ( 'mce Insert Content ' , false , h , { skip _undo : skip _undo } ) ; } 
function ( content ) { var ed = this . editor , linebr = get Param ( ed , "paste _text _linebreaktype " ) , rl = get Param ( ed , "paste _text _replacements " ) , is = tinymce . is ; function process ( items ) { each ( items , function ( v ) { if ( v . constructor = = Reg Exp ) content = content . replace ( v , " " ) ; else content = content . replace ( v [ 0 ] , v [ 1 ] ) ; } ) ; } ; if ( ( typeof ( content ) = = = "string " ) & & ( content . length > 0 ) ) { / / If HTML content with line -breaking tags , then remove all cr /lf chars because only tags will break a line if ( / < ( ? :p |br |h [ 1 - 6 ] |ul |ol |dl |table |t [rdh ] |div |blockquote |fieldset |pre |address |center ) [ ^ > ] * > / i . test ( content ) ) { process ( [ / [ \n \r ] + / g ] ) ; } else { / / Otherwise just get rid of carriage returns (only need linefeeds ) process ( [ / \r + / g ] ) ; } process ( [ [ / < \ / ( ? :p |h [ 1 - 6 ] |ul |ol |dl |table |div |blockquote |fieldset |pre |address |center ) > / gi , " \n \n " ] , / / Block tags get a blank line after them [ / <br [ ^ > ] * > | < \ /tr > / gi , " \n " ] , / / Single linebreak for <br / > tags and table rows [ / < \ /t [dh ] > \s * <t [dh ] [ ^ > ] * > / gi , " \t " ] , / / Table cells get tabs betweem them / < [a -z ! \ / ? ] [ ^ > ] * > / gi , / / Delete all remaining tags [ / &nbsp ; / gi , " " ] , / / Convert non -break spaces to regular spaces (remember , *plain text * ) [ / ( ? : ( ? ! \n ) \s ) * ( \n + ) ( ? : ( ? ! \n ) \s ) * / gi , " $ 1 " ] / / Cool little Reg Exp deletes whitespace around linebreak chars . ] ) ; var max Linebreaks = Number ( get Param ( ed , "paste _max _consecutive _linebreaks " ) ) ; if ( max Linebreaks > - 1 ) { var max Linebreaks Regex = new Reg Exp ( " \n { " + ( max Linebreaks + 1 ) + " , } " , "g " ) ; var linebreak Replacement = " " ; while ( linebreak Replacement . length < max Linebreaks ) { linebreak Replacement + = " \n " ; } process ( [ [ max Linebreaks Regex , linebreak Replacement ] / / Limit max consecutive linebreaks ] ) ; } content = ed . dom . decode ( tinymce . html . Entities . encode Raw ( content ) ) ; / / Perform default or custom replacements if ( is ( rl , "array " ) ) { process ( rl ) ; } else if ( is ( rl , "string " ) ) { process ( new Reg Exp ( rl , "gi " ) ) ; } / / Treat paragraphs as specified in the config if ( linebr = = "none " ) { / / Convert all line breaks to space process ( [ [ / \n + / g , " " ] ] ) ; } else if ( linebr = = "br " ) { / / Convert all line breaks to <br / > process ( [ [ / \n / g , " <br / > " ] ] ) ; } else if ( linebr = = "p " ) { / / Convert all line breaks to <p > . . . < /p > process ( [ [ / \n + / g , " < /p > <p > " ] , [ / ^ ( . * < \ /p > ) ( <p > ) $ / , ' <p > $ 1 ' ] ] ) ; } else { / / defaults to "combined " / / Convert single line breaks to <br / > and double line breaks to <p > . . . < /p > process ( [ [ / \n \n / g , " < /p > <p > " ] , [ / ^ ( . * < \ /p > ) ( <p > ) $ / , ' <p > $ 1 ' ] , [ / \n / g , " <br / > " ] ] ) ; } ed . exec Command ( 'mce Insert Content ' , false , content ) ; } } 
function ( ) { var t = this , ed = t . editor ; / / Register command (s ) for backwards compatibility ed . add Command ( "mce Paste Word " , function ( ) { ed . window Manager . open ( { file : t . url + " /pasteword .htm " , width : parse Int ( get Param ( ed , "paste _dialog _width " ) ) , height : parse Int ( get Param ( ed , "paste _dialog _height " ) ) , inline : 1 } ) ; } ) ; if ( get Param ( ed , "paste _text _use _dialog " ) ) { ed . add Command ( "mce Paste Text " , function ( ) { ed . window Manager . open ( { file : t . url + " /pastetext .htm " , width : parse Int ( get Param ( ed , "paste _dialog _width " ) ) , height : parse Int ( get Param ( ed , "paste _dialog _height " ) ) , inline : 1 } ) ; } ) ; } / / Register button for backwards compatibility ed . add Button ( "pasteword " , { title : "paste .paste _word _desc " , cmd : "mce Paste Word " } ) ; } 
function apply Generic Operator Index ( r , schema , parent ) { if ( r . type = = = 'view ' ) { if ( r . view = = = 'reducing -index ' ) return r if ( r . view ! = = 'case ' & & r . view ! = = 'default ' & & 
function init ( ) { * Drawer initialization * * @method init * / O . inherited ( this ) ( 'section ' , 'drawer ' ) ; this . hook ( ) ; this . hide ( true ) ; this . tree ( 'header ' , 'row ' ) . button ( 'char ' , 'left ' , this . hide . bind ( this , false ) ) ; ; this . stub ( 'ul ' , 'navigation ' ) ; } 
function manager ( map , key ) { if ( ! ( key instanceof Object ) ) { throw new Type Error ( 'Key must be an object ' ) } let contents = map . get ( key ) if ( ! contents ) { map . set ( key , contents = { } ) } return contents } 
function end ( ) { var transformed ; if ( ignore . some ( minimatch . bind ( null , file ) ) ) { var compiled = coffee . compile ( data , { source Map : true , generated File : file , inline : true , bare : options . bare , literate : is Literate ( file ) } ) ; transformed = compiled . js ; } else { var instrumented = instrumentor . instrument Coffee ( file , data ) ; var js = options . no Init ? instrumented . js : instrumented . init + instrumented . js ; transformed = js ; } this . queue ( transformed ) ; this . queue ( null ) ; } 
function ( view , initial ) { var me = this , checkbox = me . inject Checkbox , header Ct = view . header Ct ; 
function ( is Checked ) { var view = this . views [ 0 ] , header Ct = view . header Ct , check Hd = header Ct . child ( 'gridcolumn [is Checker Hd ] ' ) , cls = this . checker On Cls ; if ( check Hd ) { if ( is Checked ) { check Hd . add Cls ( cls ) ; } else { check Hd . remove Cls ( cls ) ; } } } 
function ( header Ct , header , e ) { if ( header . is Checker Hd ) { e . stop Event ( ) ; var me = this , is Checked = header . el . has Cls ( Ext . base CSSPrefix + 'grid -hd -checker -on ' ) ; 
function ( ) { var me = this , show Check = me . show Header Checkbox ! = = false ; return { is Checker Hd : show Check , text : ' & # 1 6 0 ; ' , width : me . header Width , sortable : false , draggable : false , resizable : false , hideable : false , menu Disabled : true , data Index : ' ' , cls : show Check ? Ext . base CSSPrefix + 'column -header -checkbox ' : ' ' , renderer : Ext . Function . bind ( me . renderer , me ) , edit Renderer : me . edit Renderer | | me . render Empty , locked : me . has Locked Header ( ) } ; } 
function ( value , meta Data , record , row Index , col Index , store , view ) { var base CSSPrefix = Ext . base CSSPrefix ; meta Data . td Cls = base CSSPrefix + 'grid -cell -special ' + base CSSPrefix + 'grid -cell -row -checker ' ; return ' <div class = " ' + base CSSPrefix + 'grid -row -checker " > & # 1 6 0 ; < /div > ' ; } 
function ( list ) { var store = list . get Store ( ) ; return Ext . Array . sort ( list . get Selection Model ( ) . get Selection ( ) , function ( a , b ) { a = store . index Of ( a ) ; b = store . index Of ( b ) ; if ( a < b ) { return - 1 ; } else if ( a > b ) { return 1 ; } return 0 ; } ) ; } 
function ( ) { var me = this ; me . mixins . field . set Value . call ( me , me . setup Value ( me . to Field . store . get Range ( ) ) ) ; } 
function error Is ( error , criteria ) { if ( ! ( error instanceof Error ) ) { return false ; } if ( ! criteria ) { return true ; } if ( typeof criteria = = = 'function ' ) { return error instanceof criteria ; } var name = error . name | | error . constructor & & error . constructor . name | | ' ' ; if ( typeof criteria = = = 'string ' ) { return name . to Lower Case ( ) = = = criteria . to Lower Case ( ) ; } if ( criteria instanceof Reg Exp ) { return criteria . test ( name ) ; } if ( typeof criteria = = = 'object ' ) { return _lodash 2 [ 'default ' ] . every ( Object . keys ( criteria ) , function ( key ) { return _lodash 2 [ 'default ' ] . matches Property ( key , criteria [ key ] ) ( error ) ; } ) ; } throw new Error ( 'Unexpected criteria type : ' + criteria ) ; } 
function call Request ( options , body , other Headers ) { const { method , route , form , external , others } = options ; const headers = Object . assign ( { } , options . headers , other Headers ) ; if ( external ) { return request ( form , method , route , body , headers , others ) ; } return api Request ( form , method , route , body , headers , others ) ; } 
function do Public Request ( options , params , body = { } , headers = { } ) { const cloned = clone Deep ( options ) ; if ( params ) { cloned . route = parameterize Route ( cloned . route , params ) ; } return call Request ( cloned , body , headers ) ; } 
function request With Token ( options , params , body = { } , headers = { } , custom Token = null , token Type = 'Bearer ' ) { const cloned = clone Deep ( options ) ; if ( params ) { cloned . route = parameterize Route ( cloned . route , params ) ; } const request Headers = Object . assign ( { } , headers , { Authorization : ( done ) = > { if ( custom Token ! = = null ) { done ( ` $ { token Type } $ { custom Token } ` ) ; } else { Storage . get Token ( options . storage Overide ) . then ( ( stored Token ) = > { done ( ` $ { token Type } $ { stored Token } ` ) ; } ) ; } } , } ) ; return call Request ( cloned , body , request Headers ) ; } 
function ( ) { var me = this , cfg = { app : me , taskbar Config : me . get Taskbar Config ( ) } ; Ext . apply ( cfg , me . desktop Config ) ; return cfg ; } 
function ( ) { var me = this , cfg = { app : me , menu : [ ] } , launcher ; Ext . apply ( cfg , me . start Config ) ; Ext . each ( me . modules , function ( module ) { launcher = module . launcher ; if ( launcher ) { launcher . handler = launcher . handler | | Ext . bind ( me . create Window , me , [ module ] ) ; cfg . menu . push ( module . launcher ) ; } } ) ; return cfg ; } 
function ( ) { var me = this , cfg = { app : me , start Config : me . get Start Config ( ) } ; Ext . apply ( cfg , me . taskbar Config ) ; return cfg ; } 
function ( id , last Edit Id , ready Cb ) { 
function ( id , last Edit Id , end Edit Id , is Historical , ready Cb ) { get Snapshot Inner ( id , last Edit Id , end Edit Id , ready Cb ) } 
function replace Sim ( array , index , remove Count , insert ) { var add = insert ? insert . length : 0 , length = array . length , pos = fix Array Index ( array , index ) , remove , tail Old Pos , tail New Pos , tail Count , length After Remove , i ; 
function ( array , fn , scope , reverse ) { array = Ext Array . from ( array ) ; var i , ln = array . length ; if ( reverse ! = = true ) { for ( i = 0 ; i < ln ; i + + ) { if ( fn . call ( scope | | array [ i ] , array [ i ] , i , array ) = = = false ) { return i ; } } } else { for ( i = ln - 1 ; i > - 1 ; i - - ) { if ( fn . call ( scope | | array [ i ] , array [ i ] , i , array ) = = = false ) { return i ; } } } return true ; } 
function ( iterable , start , end ) { if ( ! iterable | | ! iterable . length ) { return [ ] ; } if ( typeof iterable = = = 'string ' ) { iterable = iterable . split ( ' ' ) ; } if ( supports Slice On Node List ) { return slice . call ( iterable , start | | 0 , end | | iterable . length ) ; } var array = [ ] , i ; start = start | | 0 ; end = end ? ( ( end < 0 ) ? iterable . length + end : end ) : iterable . length ; for ( i = start ; i < end ; i + + ) { array . push ( iterable [ i ] ) ; } return array ; } 
function ( array , property Name ) { var ret = [ ] , i , ln , item ; for ( i = 0 , ln = array . length ; i < ln ; i + + ) { item = array [ i ] ; ret . push ( item [ property Name ] ) ; } return ret ; } 
function ( array ) { var results = [ ] , i = 0 , ln = array . length , item ; for ( ; i < ln ; i + + ) { item = array [ i ] ; if ( ! Ext . is Empty ( item ) ) { results . push ( item ) ; } } return results ; } 
function ( array ) { var clone = [ ] , i = 0 , ln = array . length , item ; for ( ; i < ln ; i + + ) { item = array [ i ] ; if ( Ext Array . index Of ( clone , item ) = = = - 1 ) { clone . push ( item ) ; } } return clone ; } 
function ( array , fn , scope ) { var i = 0 , len = array . length ; for ( ; i < len ; i + + ) { if ( fn . call ( scope | | array , array [ i ] , i ) ) { return array [ i ] ; } } return null ; } 
function ( value , new Reference ) { if ( value = = = undefined | | value = = = null ) { return [ ] ; } if ( Ext . is Array ( value ) ) { return ( new Reference ) ? slice . call ( value ) : value ; } var type = typeof value ; 
function ( array , item ) { var index = Ext Array . index Of ( array , item ) ; if ( index ! = = - 1 ) { erase ( array , index , 1 ) ; } return array ; } 
function ( ) { var args = slice . call ( arguments ) , array = [ ] , i , ln ; for ( i = 0 , ln = args . length ; i < ln ; i + + ) { array = array . concat ( args [ i ] ) ; } return Ext Array . unique ( array ) ; } 
function ( ) { var intersection = [ ] , arrays = slice . call ( arguments ) , arrays Length , array , array Length , min Array , min Array Index , min Array Candidate , min Array Length , element , element Candidate , element Count , i , j , k ; if ( ! arrays . length ) { return intersection ; } 
function ( array A , array B ) { var clone = slice . call ( array A ) , ln = clone . length , i , j , ln B ; for ( i = 0 , ln B = array B . length ; i < ln B ; i + + ) { for ( j = 0 ; j < ln ; j + + ) { if ( clone [ j ] = = = array B [ i ] ) { erase ( clone , j , 1 ) ; j - - ; ln - - ; } } } return clone ; } 
function ( array , begin , end ) { 
function ( array ) { var worker = [ ] ; function r Flatten ( a ) { var i , ln , v ; for ( i = 0 , ln = a . length ; i < ln ; i + + ) { v = a [ i ] ; if ( Ext . is Array ( v ) ) { r Flatten ( v ) ; } else { worker . push ( v ) ; } } return worker ; } return r Flatten ( array ) ; } 
function ( array , comparison Fn ) { var min = array [ 0 ] , i , ln , item ; for ( i = 0 , ln = array . length ; i < ln ; i + + ) { item = array [ i ] ; if ( comparison Fn ) { if ( comparison Fn ( min , item ) = = = 1 ) { min = item ; } } else { if ( item < min ) { min = item ; } } } return min ; } 
function ( array ) { var sum = 0 , i , ln , item ; for ( i = 0 , ln = array . length ; i < ln ; i + + ) { item = array [ i ] ; sum + = item ; } return sum ; } 
function ( array , get Key , scope ) { var map = { } , i = array . length ; if ( ! get Key ) { while ( i - - ) { map [ array [ i ] ] = i + 1 ; } } else if ( typeof get Key = = 'string ' ) { while ( i - - ) { map [ array [ i ] [ get Key ] ] = i + 1 ; } } else { while ( i - - ) { map [ get Key . call ( scope , array [ i ] ) ] = i + 1 ; } } return map ; } 
function ( array ) { var len = arguments . length , i = 1 , new Item ; if ( array = = = undefined ) { array = [ ] ; } else if ( ! Ext . is Array ( array ) ) { array = [ array ] ; } for ( ; i < len ; i + + ) { new Item = arguments [ i ] ; Array . prototype . push [ Ext . is Iterable ( new Item ) ? 'apply ' : 'call ' ] ( array , new Item ) ; } return array ; } 
function ( xpath ) { var me = this , parts = xpath . split ( ' / ' ) , regex = me . tag Path Reg Ex , i , n , m , count , tag , child , el = me . attach To . document ; el = ( parts [ 0 ] = = ' ~ ' ) ? el . body : el . get Element By Id ( parts [ 0 ] . substring ( 1 ) ) ; 
function ( event Descriptor ) { var me = this , index = + + me . queue Index ; 
function ( ) { var me = this , queue = me . event Queue , index = me . queue Index , event Descriptor = queue [ index ] , type = event Descriptor & & event Descriptor . type , tmp ; if ( type = = 'mduclick ' ) { tmp = [ Ext . apply If ( { type : 'mousedown ' } , event Descriptor ) , Ext . apply If ( { type : 'mouseup ' } , event Descriptor ) , Ext . apply If ( { type : 'click ' } , event Descriptor ) ] ; me . replace Event ( index , tmp ) ; } return queue [ index ] | | null ; } 
function ( ) { var me = this , animations = me . pause For Animations & & me . attach To . Ext . fx . Manager . items , event Descriptor ; while ( ( event Descriptor = me . peek Event ( ) ) ! = = null ) { if ( animations & & animations . get Count ( ) ) { return true ; } if ( event Descriptor . keyframe ) { if ( ! me . process Key Frame ( event Descriptor ) ) { return false ; } me . next Event ( event Descriptor ) ; } else if ( event Descriptor . ts < = me . get Time Index ( ) & & me . fire Event ( 'beforeplay ' , me , event Descriptor ) ! = = false & & me . play Event ( event Descriptor ) ) { if ( window . _ _x & & event Descriptor . screenshot ) { _ _x . poll . send Sync Request ( { cmd : 'screenshot ' } ) ; } me . next Event ( event Descriptor ) ; } else { return true ; } } me . stop ( ) ; return false ; } 
function ( event Descriptor ) { var me = this ; 
function get Content Editable ( node ) { var content Editable ; / / Ignore non elements if ( node . node Type = = = 1 ) { / / Check for fake content editable content Editable = node . get Attribute ( internal Name ) ; if ( content Editable & & content Editable ! = = "inherit " ) { return content Editable ; } / / Check for real content editable content Editable = node . content Editable ; if ( content Editable ! = = "inherit " ) { return content Editable ; } } return null ; } 
function get Non Editable Parent ( node ) { var state ; while ( node ) { state = get Content Editable ( node ) ; if ( state ) { return state = = = "false " ? node : null ; } node = node . parent Node ; } } 
function insert Caret Container Or Expand To Block ( target , before ) { var caret Container , rng ; / / Select block if ( get Content Editable ( target ) = = = "false " ) { if ( dom . is Block ( target ) ) { selection . select ( target ) ; return ; } } rng = dom . create Rng ( ) ; if ( get Content Editable ( target ) = = = "true " ) { if ( ! target . first Child ) { target . append Child ( ed . get Doc ( ) . create Text Node ( ' \u 0 0a 0 ' ) ) ; } target = target . first Child ; before = true ; } / /caret Container = dom .create ( 'span ' , {id : caret Container Id , 'data -mce -bogus ' : true , style : 'border : 1px solid red ' } , invisible Char ) ; caret Container = dom . create ( 'span ' , { id : caret Container Id , 'data -mce -bogus ' : true } , invisible Char ) ; if ( before ) { target . parent Node . insert Before ( caret Container , target ) ; } else { dom . insert After ( caret Container , target ) ; } rng . set Start ( caret Container . first Child , 1 ) ; rng . collapse ( true ) ; selection . set Rng ( rng ) ; return caret Container ; } 
function remove Caret Container ( caret Container ) { var child , current Caret Container , last Container ; if ( caret Container ) { rng = selection . get Rng ( true ) ; rng . set Start Before ( caret Container ) ; rng . set End Before ( caret Container ) ; child = find First Text Node ( caret Container ) ; if ( child & & child . node Value . char At ( 0 ) = = invisible Char ) { child = child . delete Data ( 0 , 1 ) ; } dom . remove ( caret Container , true ) ; selection . set Rng ( rng ) ; } else { current Caret Container = get Parent Caret Container ( selection . get Start ( ) ) ; while ( ( caret Container = dom . get ( caret Container Id ) ) & & caret Container ! = = last Container ) { if ( current Caret Container ! = = caret Container ) { child = find First Text Node ( caret Container ) ; if ( child & & child . node Value . char At ( 0 ) = = invisible Char ) { child = child . delete Data ( 0 , 1 ) ; } dom . remove ( caret Container , true ) ; } last Container = caret Container ; } } } 
function move Selection ( ) { var non Editable Start , non Editable End , is Collapsed , rng , element ; / / Checks if there is any contents to the left /right side of caret returns the noneditable element or any editable element if it finds one inside function has Side Content ( element , left ) { var container , offset , walker , node , len ; container = rng . start Container ; offset = rng . start Offset ; / / If endpoint is in middle of text node then expand to beginning /end of element if ( container . node Type = = 3 ) { len = container . node Value . length ; if ( ( offset > 0 & & offset < len ) | | ( left ? offset = = len : offset = = 0 ) ) { return ; } } else { / / Can we resolve the node by index if ( offset < container . child Nodes . length ) { / / Browser represents caret position as the offset at the start of an element . When moving right / / this is the element we are moving into so we consider our container to be child node at offset - 1 var pos = ! left & & offset > 0 ? offset - 1 : offset ; container = container . child Nodes [ pos ] ; if ( container . has Child Nodes ( ) ) { container = container . first Child ; } } else { / / If not then the caret is at the last position in it 's container and the caret container should be inserted after the noneditable element return ! left ? element : null ; } } / / Walk left /right to look for contents walker = new Tree Walker ( container , element ) ; while ( node = walker [ left ? 'prev ' : 'next ' ] ( ) ) { if ( node . node Type = = = 3 & & node . node Value . length > 0 ) { return ; } else if ( get Content Editable ( node ) = = = "true " ) { / / Found content Editable =true element return this one to we can move the caret inside it return node ; } } return element ; } ; / / Remove any existing caret containers remove Caret Container ( ) ; / / Get noneditable start /end elements is Collapsed = selection . is Collapsed ( ) ; non Editable Start = get Non Editable Parent ( selection . get Start ( ) ) ; non Editable End = get Non Editable Parent ( selection . get End ( ) ) ; / / Is any fo the range endpoints noneditable if ( non Editable Start | | non Editable End ) { rng = selection . get Rng ( true ) ; / / If it 's a caret selection then look left /right to see if we need to move the caret out side or expand if ( is Collapsed ) { non Editable Start = non Editable Start | | non Editable End ; var start = selection . get Start ( ) ; if ( element = has Side Content ( non Editable Start , true ) ) { / / We have no contents to the left of the caret then insert a caret container before the noneditable element insert Caret Container Or Expand To Block ( element , true ) ; } else if ( element = has Side Content ( non Editable Start , false ) ) { / / We have no contents to the right of the caret then insert a caret container after the noneditable element insert Caret Container Or Expand To Block ( element , false ) ; } else { / / We are in the middle of a noneditable so expand to select it selection . select ( non Editable Start ) ; } } else { rng = selection . get Rng ( true ) ; / / Expand selection to include start non editable element if ( non Editable Start ) { rng . set Start Before ( non Editable Start ) ; } / / Expand selection to include end non editable element if ( non Editable End ) { rng . set End After ( non Editable End ) ; } selection . set Rng ( rng ) ; } } } 
function has Side Content ( element , left ) { var container , offset , walker , node , len ; container = rng . start Container ; offset = rng . start Offset ; / / If endpoint is in middle of text node then expand to beginning /end of element if ( container . node Type = = 3 ) { len = container . node Value . length ; if ( ( offset > 0 & & offset < len ) | | ( left ? offset = = len : offset = = 0 ) ) { return ; } } else { / / Can we resolve the node by index if ( offset < container . child Nodes . length ) { / / Browser represents caret position as the offset at the start of an element . When moving right / / this is the element we are moving into so we consider our container to be child node at offset - 1 var pos = ! left & & offset > 0 ? offset - 1 : offset ; container = container . child Nodes [ pos ] ; if ( container . has Child Nodes ( ) ) { container = container . first Child ; } } else { / / If not then the caret is at the last position in it 's container and the caret container should be inserted after the noneditable element return ! left ? element : null ; } } / / Walk left /right to look for contents walker = new Tree Walker ( container , element ) ; while ( node = walker [ left ? 'prev ' : 'next ' ] ( ) ) { if ( node . node Type = = = 3 & & node . node Value . length > 0 ) { return ; } else if ( get Content Editable ( node ) = = = "true " ) { / / Found content Editable =true element return this one to we can move the caret inside it return node ; } } return element ; } 
function convert Reg Exps To Non Editable ( ed , args ) { var i = non Editable Reg Exps . length , content = args . content , cls = tinymce . trim ( non Edit Class ) ; / / Don 't replace the variables when raw is used for example on undo /redo if ( args . format = = "raw " ) { return ; } while ( i - - ) { content = content . replace ( non Editable Reg Exps [ i ] , function ( match ) { var args = arguments , index = args [ args . length - 2 ] ; / / Is value inside an attribute then don 't replace if ( index > 0 & & content . char At ( index - 1 ) = = ' " ' ) { return match ; } return ' <span class = " ' + cls + ' " data -mce -content = " ' + ed . dom . encode ( args [ 0 ] ) + ' " > ' + ed . dom . encode ( typeof ( args [ 1 ] ) = = = "string " ? args [ 1 ] : args [ 0 ] ) + ' < /span > ' ; } ) ; } args . content = content ; } 
function ( ) { var grid = this . editing Plugin . grid , view = grid . normal Grid ? grid . normal Grid . view : grid . view , view Size = view . component Layout . last Component Size , has Overflow = view Size . content Height > view Size . height ; 
function ( cfg ) { Ext . ux . form . Tiny MCEText Area Window Manager . superclass . constructor . call ( this , cfg . editor ) ; this . control = cfg . control ; } 
function ( txt , cb , s ) { Ext . Message Box . alert ( this . editor . get Lang ( "Message " , "Message " ) , this . editor . get Lang ( txt , txt ) , function ( ) { if ( ! Ext . is Empty ( cb ) ) { cb . call ( this ) ; } } , s ) ; } 
function ( txt , cb , s ) { Ext . Message Box . confirm ( this . editor . get Lang ( "Question " , "Question " ) , this . editor . get Lang ( txt , txt ) , function ( btn ) { if ( ! Ext . is Empty ( cb ) ) { cb . call ( this , btn = = = "yes " ) ; } } , s ) ; } 
function ( win , ti ) { var w = Ext . get Cmp ( win . tiny MCEPopup . id ) ; if ( w ) { w . set Title ( ti ) ; } } 
function ( dw , dh , id ) { var w = Ext . get Cmp ( id ) ; if ( ! w ) { return ; } / / Tiny MCE window manager opens the windows in two steps / / / / 1 . displaying and loading iframe / / 2 . Adjusting the window size to the iframe / / / / It has an unbeatufiul eefect of resizing by / / opening . Thus , we first open the window in the / / invisible area , and center it only when resize is done . var size = w . get Size ( ) ; w . set Size ( size . width + dw , size . height + dh ) ; w . center ( ) ; var tinypopup Iframe = w . get Component ( 'tiny _popup _iframe ' ) ; if ( ! tinypopup Iframe ) { return ; } var doc = tinypopup Iframe . get El ( ) . dom . content Document ; if ( ! doc ) { return ; } / / We do not focus in the standard way . It does not work under IE . / / The standard focusing occurs too early when using Ext JS windows for the popups . / / We do focusing here after resize . tinymce . each ( doc . forms , function ( g ) { tinymce . each ( g . elements , function ( f ) { if ( tinymce . DOM . has Class ( f , "mce Focus " ) & & ! f . disabled ) { f . focus ( ) ; return false ; } } ) ; } ) ; / / This fixes the bug under IE - after moving the iframe is not visible . / / But , we have to add this event after a delay , otherwise it removes the / / focus from the field , what is set above . set Timeout ( function ( ) { w . on ( 'move ' , function ( win , x , y , opts ) { tinypopup Iframe . get El ( ) . focus ( ) ; } , w ) ; } , 1 5 0 0 ) ; } 
function ( s , p ) { var me = this ; Ext . util . Observable . capture ( me . control , function ( ) { return false ; } ) ; / / Hide intermediate color popup menu if the more color dialog is displayed . / / The z -index of the tinymce color popup menu is higher than that of the Ext JS / / windows , and the menu overlaps the Ext JS window . if ( me . editor . control Manager . get ( me . control . get Input Id ( ) + ' _forecolor ' ) ) { me . editor . control Manager . get ( me . control . get Input Id ( ) + ' _forecolor ' ) . hide Menu ( ) ; } if ( me . editor . control Manager . get ( 'mce _fullscreen _forecolor ' ) ) { me . editor . control Manager . get ( 'mce _fullscreen _forecolor ' ) . hide Menu ( ) ; } if ( me . editor . control Manager . get ( me . control . get Input Id ( ) + ' _backcolor ' ) ) { me . editor . control Manager . get ( me . control . get Input Id ( ) + ' _backcolor ' ) . hide Menu ( ) ; } if ( me . editor . control Manager . get ( 'mce _fullscreen _backcolor ' ) ) { me . editor . control Manager . get ( 'mce _fullscreen _backcolor ' ) . hide Menu ( ) ; } s = s | | { } ; p = p | | { } ; if ( ! s . type ) { me . bookmark = me . editor . selection . get Bookmark ( 'simple ' ) ; } s . width = parse Int ( s . width | | 3 2 0 , 1 0 ) ; s . height = parse Int ( s . height | | 2 4 0 , 1 0 ) ; s . min _width = parse Int ( s . min _width | | 1 5 0 , 1 0 ) ; s . min _height = parse Int ( s . min _height | | 1 0 0 , 1 0 ) ; s . max _width = parse Int ( s . max _width | | 2 0 0 0 , 1 0 ) ; s . max _height = parse Int ( s . max _height | | 2 0 0 0 , 1 0 ) ; s . movable = true ; s . resizable = true ; p . mce _width = s . width ; p . mce _height = s . height ; p . mce _inline = true ; / / We do not focus in the standard way . It does not work under IE . / / The standard focusing occurs too early when using Ext JS windows for the popups . / / We do focusing in the resize By method p . mce _auto _focus = false ; this . features = s ; this . params = p ; this . on Open . dispatch ( this , s , p ) ; var win = Ext . create ( 'widget .window ' , { title : s . name , width : s . width , height : s . height , min Width : s . min _width , min Height : s . min _height , resizable : false , maximizable : s . maximizable , minimizable : s . minimizable , modal : true , layout : "fit " , items : [ Ext . create ( 'Ext .Component ' , { item Id : 'tiny _popup _iframe ' , auto El : { tag : 'iframe ' , src : s . url | | s . file } , style : 'border -width : 0px ; ' } ) ] , listeners : { destroy : function ( win , opts ) { me . on Close . dispatch ( me ) ; Ext . util . Observable . release Capture ( me . control ) ; set Timeout ( function ( ) { if ( me . editor ) { if ( ! win . closed Over Inline Button & & tinymce . is IE ) { me . editor . selection . move To Bookmark ( me . editor . window Manager . bookmark ) ; } me . editor . focus ( ) ; me . control . popup Active = false ; } } , 3 0 0 ) ; } } } ) ; p . mce _window _id = win . get Id ( ) ; me . control . popup Active = true ; win . show ( null , function ( ) { / / Tiny MCE window manager opens the windows in two steps / / / / 1 . displaying and loading iframe / / 2 . Adjusting the window size to the iframe / / / / It has an unbeatufiul eefect of resizing after / / opening . Thus , we first open the window in the / / invisible area , and center it only when resize is done . win . set Page Position ( - 9 0 0 , - 9 0 0 ) ; } , me ) ; return win ; } 
function ( win ) { var me = this ; if ( ! win | | ! win . tiny MCEPopup | | ! win . tiny MCEPopup . id ) { return ; } var w = Ext . get Cmp ( win . tiny MCEPopup . id ) ; if ( w ) { w . closed Over Inline Button = true ; w . close ( ) ; } } 
function ( ) { var me = this ; me . call Parent ( arguments ) ; / / If an element is a child of an invisible container like tab , / / there are a number of issues which make the life complicated : / / / / - The element might not be completely rendered ; it will be / / completely rendered only when the container becomes visible . / / - The size of the element might be unknown until the container becomes / / visible . If you do size adjustment , while the container is / / not visible , the size might be calculated and set incorrectly . / / - No show /hide event is fired for the element self if the container / / becomes visible or hidden . The event is fired only for that parent / / container , which is being actively shown or hidden . / / - You have to attach the event handler to the correct parent container / / and do size adjustment only if the container becomes visible . / / / / We check whether our Tiny MCEText Area is a child of a tab panel . If yes , / / we attach the event handler to the tab change event and do / / size adjustment if the parent tab , which contains our Tiny MCEText Area , / / becomes visible . / / / / PS : It will not work if you have a tab control within another tab control ! var tabpanel = me . find Parent By Type ( 'tabpanel ' ) ; if ( tabpanel ) { tabpanel . on ( 'tabchange ' , function ( tab Panel , new Card , old Card , e Opts ) { var my Card = me . find Parent By ( function ( cont , elm ) { return cont . get Id ( ) = = = new Card . get Id ( ) ; } ) ; if ( my Card ) { me . sync Editor Size ( me . last Width , me . last Height ) ; } } , me ) ; } me . on ( 'blur ' , function ( elm , ev , e Opts ) { var ctrl = document . get Element By Id ( me . get Input Id ( ) ) ; if ( me . wysiwyg Intialized ) { var ed = tinymce . get ( me . get Input Id ( ) ) ; / / In the HTML text modus , the contents should be / / synchronized upon the blur event . if ( ed & & ed . is Hidden ( ) ) { if ( ctrl ) { me . position Before Blur = { start : ctrl . selection Start , end : ctrl . selection End } ; } ed . load ( ) ; } } else { if ( ctrl ) { me . position Before Blur = { start : ctrl . selection Start , end : ctrl . selection End } ; } } } , me ) ; me . on ( 'resize ' , function ( elm , width , height , old Width , old Height , e Opts ) { if ( elm . has Visible Label ( ) & & ( elm . label Align = = = 'left ' | | elm . label Align = = = 'right ' ) ) { width = width - ( elm . label Width + elm . label Pad ) ; } me . last Width = width ; me . last Height = height ; if ( ! me . no Wysiwyg & & ! me . wysiwyg Intialized ) { me . init Editor ( ) ; } else { me . sync Editor Size ( me . last Width , me . last Height ) ; } } , me ) ; } 
function ( ) { var me = this ; var width Correction = 0 ; if ( Ext . is Gecko ) { width Correction = - 2 ; } if ( Ext . is Opera ) { width Correction = - 2 ; } if ( Ext . is IE ) { width Correction = - 2 ; } return width Correction ; } 
function ( w , h ) { var me = this ; if ( ! me . wysiwyg Intialized | | ! me . rendered ) { return ; } var ed = tinymce . get ( me . get Input Id ( ) ) ; / / if the editor is hidden , we do not syncronize / / because the size values of the hidden editor / / are calculated wrong . if ( ed . is Hidden ( ) ) { return ; } / / Unfortunately , the Tiny MCE has no set Size method / / This method would help enormly and make the integration / / very easy . / / / / So , we have to deal with internal issues of the editor . / / We get the height of the tool bar and the status bar and / / calculate the height of the content frame . var ed Table = Ext . get ( me . get Input Id ( ) + " _tbl " ) ; var ed Iframe = Ext . get ( me . get Input Id ( ) + " _ifr " ) ; var ed Toolbar = ed Table . down ( " .mce Toolbar " ) ; var ed Statusbar = ed Table . down ( " .mce Statusbar " ) ; var frame Height = h - 2 ; if ( ed Toolbar ) { frame Height - = ed Toolbar . get Height ( ) ; } if ( ed Statusbar ) { frame Height - = ed Statusbar . get Height ( ) ; } ed Iframe . set Height ( frame Height ) ; ed Table . set Width ( w + me . get Width Correction ( ) ) ; ed Table . set Height ( h ) ; } 
function ( ) { var me = this ; if ( me . no Wysiwyg | | me . intialization In Progress | | me . wysiwyg Intialized ) { return ; } me . intialization In Progress = true ; if ( ! me . tiny MCEConfig ) { me . tiny MCEConfig = { } ; } else { / / We need clone , not reference . / / The configuration of the wysiwyg might be passed as an object to / / many editor instances . Through cloning , we prevent / / side effects on other editors upon internal modifications / / of the tiny MCEConfig var tmp _cfg = me . tiny MCEConfig ; me . tiny MCEConfig = { } ; Ext . Object . merge ( me . tiny MCEConfig , tmp _cfg ) ; } me . tiny MCEConfig . mode = "exact " ; me . tiny MCEConfig . elements = me . get Input Id ( ) ; / / This type of resizing s very harmful by integration with Ext JS . / / The editor should occupy only the place given to it by the / / layout manager . me . tiny MCEConfig . theme _advanced _resizing = false ; / / we pass the height and width explicitly to the editor me . tiny MCEConfig . width = me . last Width + me . get Width Correction ( ) ; me . tiny MCEConfig . height = me . last Height ; if ( me . read Only ) { me . tiny MCEConfig . readonly = true ; me . tiny MCEConfig . height - = 3 ; } if ( me . label El ) { me . label El . on ( 'click ' , function ( ev , elm , opts ) { me . focus ( false ) ; } , me . label El ) ; } var user _setup = null ; var user _onchange _callback = null ; if ( me . tiny MCEConfig . setup ) { user _setup = me . tiny MCEConfig . setup ; } if ( me . tiny MCEConfig . onchange _callback ) { user _onchange _callback = me . tiny MCEConfig . onchange _callback ; } me . tiny MCEConfig . onchange _callback = function ( ed ) { var oldval = me . get Value ( ) ; var newval = ed . get Content ( ) ; ed . save ( ) ; me . fire Event ( 'change ' , me , newval , oldval , { } ) ; if ( me . validate On Change ) { me . validate ( ) ; } if ( user _onchange _callback ) { user _onchange _callback ( ed ) ; } } ; me . tiny MCEConfig . setup = function ( ed ) { ed . on Exec Command . add ( function ( ed , cmd , ui , val ) { if ( cmd ! = = 'mce Full Screen ' ) { return ; } var fullscreen _container = document . get Element By Id ( "mce _fullscreen _container " ) ; if ( ! fullscreen _container ) { return ; } fullscreen _container . style . z Index = Ext . ZIndex Manager . z Base + 2 ; var fullscreen _ed = tiny MCE . get ( ed . get Param ( 'fullscreen _editor _id ' ) ) ; if ( fullscreen _ed ) { fullscreen _ed . window Manager = Ext . create ( 'Ext .ux .form .Tiny MCEText Area Window Manager ' , { control : me , editor : fullscreen _ed } ) ; } } ) ; ed . on Init . add ( function ( ed ) { me . wysiwyg Intialized = true ; me . intialization In Progress = false ; if ( me . is Disabled ( ) ) { me . disable Editor ( ) ; } tinymce . dom . Event . add ( ed . get Win ( ) , 'focus ' , function ( e ) { var w = me . find Parent By Type ( 'window ' ) ; if ( w & & ! me . popup Active ) { / / we use to Front to bring the parent window / / to the front when the editor gets focus . / / Under IE 1 0 , the editor gets focus , even if / / a popup like image insert is opened . This is / / bad , because the popup goes into the back , and / / the editor to the front . / / / / We have introduced the flag 'popup Active ' , / / which is set when the popup is opened and unset / / when the popup is closed . / / / / We do not do to Front id the popup is active . w . to Front ( true ) ; } } ) ; } ) ; ed . on Post Render . add ( function ( ed , control Manager ) { ed . window Manager = Ext . create ( 'Ext .ux .form .Tiny MCEText Area Window Manager ' , { control : me , editor : ed } ) ; } ) ; if ( user _setup ) { user _setup ( ed ) ; } } ; if ( ! tinymce . dom . Event . dom Loaded ) { tinymce . dom . Event . dom Loaded = true ; } tinymce . init ( me . tiny MCEConfig ) ; } 
function ( ) { var me = this ; if ( ! me . wysiwyg Intialized ) { return true ; } var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( ! ed ) { return true ; } return ed . is Hidden ( ) ; } 
function ( ) { var me = this ; me . stored Cursor Position = null ; if ( ! me . wysiwyg Intialized ) { me . no Wysiwyg = false ; me . init Editor ( ) ; return ; } var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( ed ) { ed . show ( ) ; ed . node Changed ( ) ; me . sync Editor Size ( me . last Width , me . last Height ) ; me . focus ( ) ; } } 
function ( ) { var me = this ; if ( ! me . wysiwyg Intialized ) { return ; } var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( ! ed ) { return ; } var node = ed . selection . get Node ( ) ; me . stored Cursor Position = null ; / / no selection , just hide if ( ! node | | node . node Name = = = " #document " | | node . node Name = = = "BODY " | | node . node Name = = = "body " ) { ed . hide ( ) ; return ; } / / otherwise try to position the cursor var marker = ' <a id = " _ _ _ _ _sys _ _ 1 1 2 2 3 _ _ _ " > < /a > ' ; ed . selection . collapse ( true ) ; ed . exec Command ( 'mce Insert Content ' , 0 , marker ) ; ed . hide ( ) ; var ctrl = document . get Element By Id ( me . get Input Id ( ) ) ; var pos = - 1 ; var txt = " " ; if ( ctrl ) { txt = ctrl . value ; pos = txt . index Of ( marker ) ; } if ( pos ! = = - 1 ) { var re = new Reg Exp ( marker , "g " ) ; txt = txt . replace ( re , " " ) ; ctrl . value = txt ; if ( ctrl . set Selection Range ) { ctrl . focus ( ) ; ctrl . set Selection Range ( pos , pos ) ; } } } 
function ( ) { var me = this ; if ( ! me . wysiwyg Intialized ) { me . show Editor ( ) ; return ; } var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( ed . is Hidden ( ) ) { me . show Editor ( ) ; } else { me . hide Editor ( ) ; } } 
function ( ) { var me = this ; if ( me . intialization In Progress ) { return me ; } if ( ! me . wysiwyg Intialized ) { return me ; } var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( ed ) { ed . save ( ) ; } tiny MCE . exec Command ( 'mce Remove Control ' , false , me . get Input Id ( ) ) ; me . wysiwyg Intialized = false ; return me ; } 
function ( cfg ) { var me = this ; if ( me . no Wysiwyg | | me . intialization In Progress ) { return me ; } if ( ! me . tiny MCEConfig ) { me . tiny MCEConfig = { } ; } if ( ! cfg ) { cfg = { } ; } Ext . apply ( me . tiny MCEConfig , cfg ) ; if ( ! me . wysiwyg Intialized ) { return me ; } var hidden = true ; var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( ed ) { hidden = ed . is Hidden ( ) ; ed . save ( ) ; } tiny MCE . exec Command ( 'mce Remove Control ' , false , me . get Input Id ( ) ) ; me . wysiwyg Intialized = false ; if ( ! hidden ) { me . init Editor ( ) ; } return me ; } 
function ( v ) { var me = this ; var res = me . call Parent ( arguments ) ; if ( me . wysiwyg Intialized ) { / / The editor does some preformatting of the HTML text / / entered by the user . / / The method set Value sets the value of the textarea . / / We have to load the text into editor for the / / preformatting and then to save it back to the textarea . var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( ed ) { ed . load ( ) ; ed . save ( ) ; } } return res ; } 
function ( state ) { var me = this ; var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( ! ed ) { return ; } tinymce . each ( ed . control Manager . controls , function ( c ) { c . set Disabled ( ! state ) ; } ) ; } 
function ( silent ) { var me = this ; if ( ! me . is Disabled ( ) ) { return ; } var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( ed ) { / / We restore content Editable to true var ed Iframe = Ext . get ( me . get Input Id ( ) + " _ifr " ) ; ed Iframe . dom . content Document . body . content Editable = true ; / / We have luck , because there is this useful internal method / / to add all events unbound in the disable command ed . bind Native Events ( ) ; me . enable Editor Controls ( true ) ; / / The call above enables ALL tollbar buttons / / It is wrong . We fire this event to force adjusting / / of the enabled /disabled state of the buttons to the / / actual state of the editor . ed . node Changed ( ) ; } return me . call Parent ( arguments ) ; } 
function ( ) { var me = this ; var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( ed ) { / / The body cannot be disabled , / / So we remove events from the tinymce . dom . Event . clear ( ed . get Body ( ) ) ; tinymce . dom . Event . clear ( ed . get Win ( ) ) ; tinymce . dom . Event . clear ( ed . get Doc ( ) ) ; tinymce . dom . Event . clear ( ed . form Element ) ; ed . on Exec Command . listeners = [ ] ; / / We set the content Editable to false var ed Iframe = Ext . get ( me . get Input Id ( ) + " _ifr " ) ; ed Iframe . dom . content Document . body . content Editable = false ; / / We disable all tool bar controls me . enable Editor Controls ( false ) ; } } 
function ( read Only ) { var me = this ; var result = me . call Parent ( arguments ) ; if ( read Only ! = = me . tiny MCEConfig . readonly ) { me . reinit Editor ( { readonly : read Only } ) ; me . sync Editor Size ( me . last Width , me . last Height ) ; } return result ; } 
function ( select Text , delay ) { var me = this ; if ( me . is Disabled ( ) ) { return me ; } if ( delay ) { if ( is Na N ( delay ) ) { delay = 1 0 ; } set Timeout ( function ( ) { me . focus . call ( me , select Text , false ) ; } , delay ) ; return me ; } if ( ! me . wysiwyg Intialized ) { return me . call Parent ( arguments ) ; } var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( ed & & ! ed . is Hidden ( ) ) { me . call Parent ( arguments ) ; ed . focus ( ) ; } else { return me . call Parent ( arguments ) ; } return me ; } 
function ( ) { var me = this ; var wwg _mode = false ; var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( me . wysiwyg Intialized ) { if ( ed & & ! ed . is Hidden ( ) ) { wwg _mode = true ; } } var ctrl = document . get Element By Id ( me . get Input Id ( ) ) ; if ( wwg _mode ) { me . stored Cursor Position = ed . selection . get Bookmark ( 'simple ' ) ; } else if ( ctrl ) { me . stored Cursor Position = me . position Before Blur ; } } 
function ( ) { var me = this ; if ( ! me . stored Cursor Position ) { return ; } var wwg _mode = false ; var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( me . wysiwyg Intialized ) { if ( ed & & ! ed . is Hidden ( ) ) { wwg _mode = true ; } } var ctrl = document . get Element By Id ( me . get Input Id ( ) ) ; if ( wwg _mode ) { ed . selection . move To Bookmark ( me . stored Cursor Position ) ; } else if ( ctrl ) { ctrl . set Selection Range ( me . stored Cursor Position . start , me . stored Cursor Position . end ) ; } } 
function ( txt ) { var me = this ; var wwg _mode = false ; var ed = tinymce . get ( me . get Input Id ( ) ) ; if ( me . wysiwyg Intialized ) { if ( ed & & ! ed . is Hidden ( ) ) { wwg _mode = true ; } } var ctrl = document . get Element By Id ( me . get Input Id ( ) ) ; if ( wwg _mode ) { ed . focus ( ) ; ed . exec Command ( 'mce Insert Content ' , 0 , txt ) ; } else if ( ctrl ) { ctrl . focus ( ) ; var start = ctrl . selection Start + txt . length ; ctrl . value = ctrl . value . slice ( 0 , ctrl . selection Start ) + txt + ctrl . value . slice ( ctrl . selection End ) ; ctrl . set Selection Range ( start , start ) ; } } 
function ( ) { var me = this , active Error = me . get Active Error ( ) , has Error = ! ! active Error ; var ed Table = Ext . get ( me . get Input Id ( ) + " _tbl " ) ; var ed Iframe = Ext . get ( me . get Input Id ( ) + " _ifr " ) ; if ( ! ed Table ) { return me . call Parent ( arguments ) ; } var ed Frame Container = ed Table . down ( " .mce Iframe Container " ) ; if ( ed Frame Container & & me . rendered & & ! me . is Destroyed & & ! me . prevent Mark ) { var ed = tinymce . get ( me . get Input Id ( ) ) ; var ev Handler = function ( ed , e ) { me . clear Invalid ( ) ; } ; / / Add /remove invalid class if ( has Error ) { ed Frame Container . add Cls ( 'tinymce -error -field ' ) ; / / this dirty hack is required for Web Kit browsers - Safari and Chrome ed Iframe . set Height ( ed Iframe . get Height ( ) - 1 ) ; ed Iframe . set Height ( ed Iframe . get Height ( ) + 1 ) ; if ( ed ) { / / the invalid mark should be removed after any / / change of the contents (Ext JS standard behaviour ) ed . on Key Down . add ( ev Handler ) ; } } else { ed Frame Container . remove Cls ( 'tinymce -error -field ' ) ; / / this dirty hack is required for Web Kit browsers - Safari and Chrome ed Iframe . set Height ( ed Iframe . get Height ( ) - 1 ) ; ed Iframe . set Height ( ed Iframe . get Height ( ) + 1 ) ; if ( ed ) { ed . on Key Down . remove ( ev Handler ) ; ed . on Change . remove ( ev Handler ) ; } } } return me . call Parent ( arguments ) ; } 
function parse Environment ( env , cfg ) { assume ( cfg ) . is . an ( 'object ' ) ; let _default = cfg . level | | 'info ' ; if ( ! env | | env = = = ' ' ) { return _default ; } assume ( env ) . is . a ( 'string ' ) ; let modules = env . split ( ' , ' ) . map ( x = > x . trim ( ) ) ; for ( let x of modules ) { let tokens = x . split ( ' : ' ) ; if ( tokens . length < 2 ) { let err Str = 'Log levels must use format name :level ' + 'not ' + tokens . join ( ' : ' ) ; throw new Error ( err Str ) ; } let level = tokens . slice ( tokens . length - 1 ) [ 0 ] ; let name = tokens . slice ( 0 , tokens . length - 1 ) . join ( ' : ' ) ; if ( allowed Levels . index Of ( level ) = = = - 1 ) { let err Str = 'Invalid log level setting : ' + level ; throw new Error ( err Str ) ; } if ( minimatch ( cfg . name , name ) ) { return level ; } } return _default ; } 
function setup Logger ( name , cfg ) { assume ( name ) . is . a ( 'string ' ) ; if ( cfg ) { assume ( cfg ) . is . an ( 'object ' ) ; assume ( cfg ) . not . includes ( 'name ' ) ; } else { cfg = { } ; } cfg . name = name ; 
function make Compat ( logger ) { return function ( name ) { return function ( . . . x ) { assume ( x ) . is . an ( 'array ' ) ; assume ( x . length ) . greater Than ( 0 ) ; let msg = util . format . apply ( null , x ) ; let level = 'warn ' ; let msg Obj = { dbgname : name , dbgcmpt : true , } ; if ( msg . match ( / \ [alert -operator \ ] / ) ) { level = 'fatal ' ; msg Obj . alert = true ; } logger [ level ] . call ( logger , msg Obj , msg ) ; } ; } ; } 
function ( picker , date ) { var fields = this . fields , field = this . fields [ picker . item Id ] ; field . set Checked ( true ) ; if ( field = = fields . on ) { fields . before . set Checked ( false , true ) ; fields . after . set Checked ( false , true ) ; } else { fields . on . set Checked ( false , true ) ; if ( field = = fields . after & & this . get Field Value ( 'before ' ) < date ) { fields . before . set Checked ( false , true ) ; } else if ( field = = fields . before & & this . get Field Value ( 'after ' ) > date ) { fields . after . set Checked ( false , true ) ; } } this . fire Event ( 'update ' , this ) ; picker . up ( 'menu ' ) . hide ( ) ; } 
function ( width ) { var me = this , is Num = ( typeof width = = 'number ' ) ; if ( is Num & & me . auto Box Adjust & & ! me . is Border Box ( ) ) { width - = ( me . get Border Width ( "lr " ) + me . get Padding ( "lr " ) ) ; } return ( is Num & & width < 0 ) ? 0 : width ; } 
function ( height ) { var me = this , is Num = ( typeof height = = "number " ) ; if ( is Num & & me . auto Box Adjust & & ! me . is Border Box ( ) ) { height - = ( me . get Border Width ( "tb " ) + me . get Padding ( "tb " ) ) ; } return ( is Num & & height < 0 ) ? 0 : height ; } 
function ( attr , default Value , prefix ) { var v = this . get Style ( attr ) , color = prefix | | prefix = = = ' ' ? prefix : ' # ' , h , len , i = 0 ; if ( ! v | | ( / transparent |inherit / . test ( v ) ) ) { return default Value ; } if ( / ^r / . test ( v ) ) { v = v . slice ( 4 , v . length - 1 ) . split ( ' , ' ) ; len = v . length ; for ( ; i < len ; i + + ) { h = parse Int ( v [ i ] , 1 0 ) ; color + = ( h < 1 6 ? ' 0 ' : ' ' ) + h . to String ( 1 6 ) ; } } else { v = v . replace ( ' # ' , ' ' ) ; color + = v . length = = 3 ? v . replace ( / ^ ( \w ) ( \w ) ( \w ) $ / , ' $ 1 $ 1 $ 2 $ 2 $ 3 $ 3 ' ) : v ; } return ( color . length > 5 ? color . to Lower Case ( ) : default Value ) ; } 
function ( opacity , animate ) { var me = this ; if ( ! me . dom ) { return me ; } if ( ! animate | | ! me . anim ) { me . set Style ( 'opacity ' , opacity ) ; } else { if ( typeof animate ! = 'object ' ) { animate = { duration : 3 5 0 , easing : 'ease -in ' } ; } me . animate ( Ext . apply If ( { to : { opacity : opacity } } , animate ) ) ; } return me ; } 
function ( ) { var me = this , data = ( me . $cache | | me . get Cache ( ) ) . data , style ; if ( ! data [ ISCLIPPED ] ) { data [ ISCLIPPED ] = true ; style = me . get Style ( [ OVERFLOW , OVERFLOWX , OVERFLOWY ] ) ; data [ ORIGINALCLIP ] = { o : style [ OVERFLOW ] , x : style [ OVERFLOWX ] , y : style [ OVERFLOWY ] } ; me . set Style ( OVERFLOW , HIDDEN ) ; me . set Style ( OVERFLOWX , HIDDEN ) ; me . set Style ( OVERFLOWY , HIDDEN ) ; } return me ; } 
function ( ) { var me = this , data = ( me . $cache | | me . get Cache ( ) ) . data , clip ; if ( data [ ISCLIPPED ] ) { data [ ISCLIPPED ] = false ; clip = data [ ORIGINALCLIP ] ; if ( clip . o ) { me . set Style ( OVERFLOW , clip . o ) ; } if ( clip . x ) { me . set Style ( OVERFLOWX , clip . x ) ; } if ( clip . y ) { me . set Style ( OVERFLOWY , clip . y ) ; } } return me ; } 
function ( cls ) { cls = cls | | Ext . base CSSPrefix + 'box ' ; var el = Ext . get ( this . insert Html ( "before Begin " , " <div class = ' " + cls + " ' > " + Ext . String . format ( Element . box Markup , cls ) + " < /div > " ) ) ; Ext . Dom Query . select Node ( ' . ' + cls + ' -mc ' , el . dom ) . append Child ( this . dom ) ; return el ; } 
function ( ) { var me = this , h = Math . max ( me . dom . offset Height , me . dom . client Height ) ; if ( ! h ) { h = parse Float ( me . get Style ( HEIGHT ) ) | | 0 ; if ( ! me . is Border Box ( ) ) { h + = me . get Frame Width ( 'tb ' ) ; } } return h ; } 
function ( ) { var me = this , w = Math . max ( me . dom . offset Width , me . dom . client Width ) ; if ( ! w ) { w = parse Float ( me . get Style ( WIDTH ) ) | | 0 ; if ( ! me . is Border Box ( ) ) { w + = me . get Frame Width ( 'lr ' ) ; } } return w ; } 
function ( class Name , test Fn , scope ) { var me = this , dom = me . dom , has Test = Ext . is Function ( test Fn ) ; me . hover ( function ( ) { if ( has Test & & test Fn . call ( scope | | me , me ) = = = false ) { return ; } Ext . fly ( dom , INTERNAL ) . add Cls ( class Name ) ; } , function ( ) { Ext . fly ( dom , INTERNAL ) . remove Cls ( class Name ) ; } ) ; return me ; } 
function ( class Name , test Fn , scope ) { var me = this , dom = me . dom , has Test = Ext . is Function ( test Fn ) ; me . on ( "mousedown " , function ( ) { if ( has Test & & test Fn . call ( scope | | me , me ) = = = false ) { return false ; } Ext . fly ( dom , INTERNAL ) . add Cls ( class Name ) ; var d = Ext . get Doc ( ) , fn = function ( ) { Ext . fly ( dom , INTERNAL ) . remove Cls ( class Name ) ; d . remove Listener ( "mouseup " , fn ) ; } ; d . on ( "mouseup " , fn ) ; } ) ; return me ; } 
function ( ) { var me = this , cls = me . vertical Cls ; delete me . vertical ; if ( cls ) { delete me . vertical Cls ; me . remove Cls ( cls ) ; } 
function ( config ) { logger . info ( util . format ( 'Starting Smart Router . . . Will listen on port %s ' , config . port ) ) ; logger . info ( util . format ( 'Using https : %s ' , CONFIG . https . use ) ) ; logger . info ( util . format ( 'Rabbit MQ url is set to %s ' , config . amqp . url ) ) ; logger . debug ( 'Max Channel per Rabbit MQ Connection : ' , this . MAX _CHANNEL _PER _CONNECTION ) ; var self = this ; self . config = config ; self . reconnect Delay = CONFIG . rabbitmq Reconnect Delay | | 1 0 0 0 0 ; self . delay Before Deleting Inactive Queue = CONFIG . delay Before Deleting Inactive Queue | | ( 1 5 * 6 0 * 1 0 0 0 ) ; 
function ( ) { var self = this ; self . io . sockets . on ( 'connection ' , function ( socket ) { socket . on ( 'register New Endpoint Id ' , function ( new Endpoint ) { var endpoint Found = false ; logger . info ( util . format ( 'Request received to register new Endpoint : %s ' , JSON . stringify ( new Endpoint ) ) ) ; self . config . endpoints . for Each ( function ( endpoint ) { if ( endpoint . name = = = new Endpoint . name ) { endpoint Found = true ; if ( endpoint . sub . index Of ( new Endpoint . id ) < 0 ) { var socketendpoint = self . io . of ( ' / ' + new Endpoint . name + ' / ' + new Endpoint . id ) ; logger . info ( util . format ( 'Endpoint registered on [ / %s / %s ] ' , new Endpoint . name , new Endpoint . id ) ) ; self . register Routes ( new Endpoint . name , new Endpoint . id , endpoint . queue , socketendpoint ) ; endpoint . sub . push ( new Endpoint . id ) ; 
function ( ) { var self = this ; self . config . endpoints . for Each ( function ( endpoint ) { logger . info ( util . format ( 'Registering endpoint %s ' , endpoint . name ) ) ; endpoint . sub = endpoint . sub | | endpoint . ids ; 
function ( endpointname , endpointid , queuebehaviour , socketep ) { var self = this ; socketep . on ( 'connection ' , function ( socket ) { logger . info ( util . format ( 'Connection received on / %s / %s ' , endpointname , endpointid ) ) ; socket . emit ( 'whoareyou ' , { } ) ; socket . on ( 'iam ' , function ( actorid ) { var endpoint Queue = endpointname + ' / ' + endpointid ; if ( ! queuebehaviour | | ( ( queuebehaviour & QUEUEFLAG . actor ) > 0 ) ) { self . queue Subscribe ( actorid , actorid , socket ) ; } if ( ( queuebehaviour & QUEUEFLAG . endpoint ) > 0 ) { self . queue Subscribe ( actorid , endpoint Queue , socket ) ; } } ) ; socket . on ( 'disconnect ' , function ( ) { self . queues Unsubscribe ( socket ) ; } ) ; self . config . routes . for Each ( function ( route ) { if ( route . endpoint = = = ' * ' | | route . endpoint = = = endpointname ) { logger . debug ( util . format ( 'Registering route [ %s ] for endpoint [ %s ] . Socket = %s ' , route . messagetype , route . endpoint , socket . id ) ) ; socket . on ( route . messagetype , function ( message ) { self . check ( socket , route . messagetype , message , function ( err , checked ) { if ( err ) { logger . error ( err ) ; } if ( checked ) { logger . debug ( util . format ( "Routing ' %s ' from [ %s ] . Message = %s " , route . messagetype , endpointname , JSON . stringify ( message ) ) ) ; route . action ( message , socket , self ) ; } } ) ; } ) ; } } ) ; } ) ; } 
function ( actorid , queuename , socket ) { logger . info ( util . format ( 'Subscribing to queue . Queue Name = %s ; Socket = %s ' , queuename , socket . id ) ) ; var self = this ; self . amqp . queue ( queuename , { auto Delete : false , close Channel On Unsubscribe : true , arguments : { 'x -expires ' : self . delay Before Deleting Inactive Queue } } , function ( q ) { q . bind ( queuename ) ; q . subscribe ( function ( message , headers , delivery Info ) { logger . debug ( util . format ( "Emitting ' %s ' from queue [ %s ] on socket %s " , message . type , queuename , socket . id ) ) ; socket . emit ( message . type , message . message ) ; } ) . add Callback ( function ( ok ) { socket . set ( 'actorid ' , actorid , function ( ) { logger . info ( util . format ( 'Queue created and actor [ %s ] registered . Handshaking . ' , actorid ) ) ; socket . emit ( 'hello ' , { } ) ; } ) ; var data = { queue : q , ctag : ok . consumer Tag } ; logger . debug ( util . format ( 'Registering consumer Tag [ %s ] for queue [ %s ] in socket %s ' , ok . consumer Tag , queuename , socket . id ) ) ; socket . get ( 'queue Data ' , function ( err , queue Data ) { queue Data = queue Data | | [ ] ; queue Data . push ( data ) ; socket . set ( 'queue Data ' , queue Data ) ; } ) ; } ) ; } ) ; if ( this . amqp . channel Counter > = self . MAX _CHANNEL _PER _CONNECTION & & ! self . creating Amqp Connection ) { self . _create Amqp Connection ( ) ; } } 
function ( socket , type , message , callback ) { var self = this ; socket . get ( 'actorid ' , function ( err , id ) { if ( ! id ) { var data = { } ; data . type = type ; data . message = message ; var warn Msg = util . format ( "An unidentified actor tried to post the following message on Socket %s : Type = ' %s ' Message = %s " , socket . id , type , JSON . stringify ( message ) ) ; self . _store Nagios Event ( new Nagios Check Response ( Nagios Check Response Codes . WARNING , EVENTS _CONTROLLER _SUBSYSTEM , warn Msg ) ) ; logger . warn ( warn Msg ) ; socket . emit ( 'whoareyou ' , data ) ; return callback ( err , false ) ; } 
function ( destactorid , type , message , socket ) { var self = this ; var qmsg = { } ; qmsg . type = type ; qmsg . message = message ; if ( typeof destactorid ! = = 'string ' ) { logger . error ( "Trying to publish on a bad queue : " + JSON . stringify ( destactorid ) ) ; if ( socket ) 
function init ( type ) { 
function removed ( ) { 
function process Callbacks ( named Route Parameters , data , req , res , success Handler , error Handler , callbacks ) { debug ( 'processing callbacks (url : ` %s ` , named Route Parameters : ` %s ` , ' + ' data : ` %j ` ) ' , req . url , named Route Parameters , data ) ; var callback Scope = { app : req . app , req : req } , handler Scope = { app : req . app , req : req , res : res } , callback Arguments = _ . union ( success Handler . bind ( handler Scope ) , error Handler . bind ( handler Scope ) , named Route Parameters , data ) , index = - 1 , execute Callback = function execute Callback ( callback ) { callback . apply ( callback Scope , callback Arguments ) ; } , runner ; if ( ! _ . is Array ( callbacks ) ) { runner = function ( ) { execute Callback ( callbacks ) ; } ; } else { var final Success Handler = callback Arguments [ 0 ] , stacked Success Handler = function stacked Success Handler ( ) { index + = 1 ; if ( index < callbacks . length ) { execute Callback ( callbacks [ index ] ) ; } else { final Success Handler . apply ( handler Scope , arguments ) ; } } ; callback Arguments [ 0 ] = stacked Success Handler ; runner = stacked Success Handler ; } try { runner ( ) ; } catch ( err ) { winston . log ( 'error ' , 'API callback caused exceptional error ' , { source : to String ( ) , api Route : req . original Url , err : err . to String ( ) | | err , stack : err . stack | | undefined } ) ; error Handler . call ( handler Scope , err ) ; } } 
function create Express Js Callback ( success Handler , error Handler , callbacks ) { debug ( 'creating express .js callback ' ) ; return function handler ( req , res ) { debug ( 'express .js callback called for url ` %s ` ' , req . url ) ; process Callbacks ( _ . values ( req . params ) , req . body , req , res , success Handler , error Handler , callbacks ) ; } ; } 
function create Express Js Route ( url , callbacks , express Js Method , app ) { debug ( 'creating express .js route for url ` %s ` ' , url ) ; var self = this , express Js Handler = create Express Js Callback ( function success ( api Result , http Status Code ) { http Status Code = http Status Code | | 2 0 0 ; this . res . send ( http Status Code , api Result ) ; } , function error ( err ) { var message , stack , http Status Code = 5 0 0 ; if ( ! _ . is Undefined ( err ) ) { if ( _ . has ( err , 'http Status Code ' ) ) { http Status Code = err . http Status Code ; } message = err . to String ( ) | | err ; stack = err . stack | | undefined ; } this . res . send ( http Status Code , message ) ; winston . log ( 'error ' , 'API callback stopped with error ' , { source : self . to String ( ) , api Route : url , err : message , stack : stack } ) ; } , callbacks , app ) ; express Js Method . call ( app , url , express Js Handler ) ; } 
function url Regexp ( url , keys , sensitive , strict ) { if ( url . to String ( ) = = = ' [object Reg Exp ] ' ) { return url ; } if ( Array . is Array ( url ) ) { url = ' ( ' + url . join ( ' | ' ) + ' ) ' ; } url = url . concat ( strict ? ' ' : ' / ? ' ) . replace ( / \ / \ ( / g , ' ( ? : / ' ) . replace ( / ( \ / ) ? ( \ . ) ? : ( \w + ) ( ? : ( \ ( . * ? \ ) ) ) ? ( \ ? ) ? ( \ * ) ? / g , function ( _ , slash , format , key , capture , optional , star ) { keys . push ( { name : key , optional : ! ! optional } ) ; slash = slash | | ' ' ; return ' ' + ( optional ? ' ' : slash ) + ' ( ? : ' + ( optional ? slash : ' ' ) + ( format | | ' ' ) + ( capture | | ( format & & ' ( [ ^ / . ] + ? ) ' | | ' ( [ ^ / ] + ? ) ' ) ) + ' ) ' + ( optional | | ' ' ) + ( star ? ' ( / * ) ? ' : ' ' ) ; } ) . replace ( / ( [ \ / . ] ) / g , ' \ \ $ 1 ' ) . replace ( / \ * / g , ' ( . * ) ' ) ; return new Reg Exp ( ' ^ ' + url + ' $ ' , sensitive ? ' ' : 'i ' ) ; } 
function extract Params ( match , keys , params ) { params = params | | { } ; for ( var i = 1 , l = match . length ; i < l ; + + i ) { var key = keys [ i - 1 ] ; var val = 'string ' = = = typeof match [ i ] ? decode URIComponent ( match [ i ] ) : match [ i ] ; if ( key ) { params [ key . name ] = val ; } else { params . push ( val ) ; } } } 
function match Route ( method , url , api Routes , params ) { debug ( 'matching route method %s with url %s ' , method , url ) ; var routes = api Routes [ method ] , matched Route ; for ( var route Url in routes ) { var route = routes [ route Url ] , keys = route . keys , match = route . regexp . exec ( url ) ; if ( match ) { matched Route = route ; extract Params ( match , keys , params ) ; break ; } } debug ( 'matched route ` %j ` ' , matched Route ) ; return matched Route ; } 
function add Route ( method , url , callbacks ) { debug ( 'adding route (method : ` %s ` , url : ` %s ` ) ' , method , url ) ; var url Param Keys = [ ] , regexp = url Regexp ( url , url Param Keys , true , true ) ; if ( _ . is Undefined ( this . api Routes ) ) { this . api Routes = { } ; } if ( _ . is Undefined ( this . api Routes [ method ] ) ) { this . api Routes [ method ] = { } ; } create Express Js Route . call ( this , url , callbacks , this . app [ method ] , this . app ) ; this . api Routes [ method ] [ url ] = { callback : callbacks , regexp : regexp , keys : url Param Keys } ; } 
function create Route Factories ( ) { var self = this ; _ . each ( http Methods , function ( http Method ) { self [ http Method ] = function ( url , callback ) { add Route . call ( self , http Method , url , callback ) ; } ; } ) ; if ( _ . has ( self , 'delete ' ) ) { self . del = self [ 'delete ' ] ; } } 
function dispatch Local Api Call ( http Method , url , data , options ) { debug ( 'dispatching local api call (http Method : ` %s ` , url : ` %s ` ) ' , http Method , url ) ; var self = this , params = { } , matched Route = match Route ( http Method , url , this . api Routes , params ) ; options = options | | { } ; if ( _ . is Undefined ( matched Route ) ) { if ( _ . has ( options , 'error ' ) ) { options . error ( new Error ( 'Could not resolve API route : ' + url ) ) ; } else { winston . log ( 'info ' , 'Could not resolve API route ' , { source : to String ( ) , api Route : url } ) ; } } var success Handler = function success Handler ( api Result ) { if ( _ . has ( options , 'success ' ) ) { options . success ( api Result ) ; } else { winston . log ( 'info ' , 'No success callback defined ' , { source : self . to String ( ) , api Route : url } ) ; } } , error Handler = function error Handler ( err ) { var message , stack ; if ( ! _ . is Undefined ( err ) ) { message = err . to String ( ) | | err ; stack = err . stack | | undefined ; } if ( _ . has ( options , 'error ' ) ) { options . error ( err ) ; } else { winston . log ( 'info ' , 'No error callback defined ' , { source : to String ( ) , api Route : url } ) ; } winston . log ( 'error ' , 'API callback stopped with error ' , { source : self . to String ( ) , api Route : url , err : message , stack : stack } ) ; } ; process Callbacks ( _ . values ( params ) , data , this . req , { } , success Handler , error Handler , matched Route . callback ) ; } 
function sync ( method , model , options ) { var url = options . url | | _ . result ( model , 'url ' ) , http Method = method Map [ method ] , data ; debug ( 'syncing (method : ` %s ` , http Method : ` %s ` , url : ` %s ` , model : ` %j ` ) ' , method , http Method , url , model ) ; if ( _ . is Undefined ( url ) ) { throw new Error ( 'No url present for syncing ! ' , model , options ) ; } if ( method ! = = 'read ' & & method ! = = 'delete ' ) { data = model . to JSON ( ) ; } this . dispatch Local Api Call ( http Method , url , data , options ) ; } 
function ( e , target ) { var me = this , item , record ; if ( Ext . fly ( target ) . has Cls ( me . label Selector ) & & ! me . editing & & ! e . ctrl Key & & ! e . shift Key ) { e . stop Event ( ) ; item = me . view . find Item By Child ( target ) ; record = me . view . store . get At ( me . view . index Of ( item ) ) ; me . start Edit ( target , record . data [ me . data Index ] ) ; me . active Record = record ; } else if ( me . editing ) { me . field . blur ( ) ; e . prevent Default ( ) ; } } 
function ( dir ) { var cmd = path . normalize ( config . bin ) ; if ( config . jdepend Chart ! = = undefined ) { cmd + = ' - -jdepend -chart = ' + config . jdepend Chart ; } if ( config . jdepend Xml ! = = undefined ) { cmd + = ' - -jdepend -xml = ' + config . jdepend Xml ; } if ( config . overview Pyramid ! = = undefined ) { cmd + = ' - -overview -pyramid = ' + config . overview Pyramid ; } if ( config . summary Xml ! = = undefined ) { cmd + = ' - -summary -xml = ' + config . summary Xml ; } if ( config . coderank Mode ! = = undefined ) { cmd + = ' - -coderank -mode = ' + config . coderank Mode ; } if ( config . coverage Report ! = = undefined ) { cmd + = ' - -coverage -report = ' + config . coverage Report ; } if ( config . configuration ! = = undefined ) { cmd + = ' - -configuration = ' + config . configuration ; } if ( config . ignore Directories ! = = undefined ) { cmd + = ' - -ignore = ' + config . ignore Directories ; } if ( config . debug ) { cmd + = ' - -debug ' ; } return cmd ; } 
function canonical Md 5 ( md 5 ) { if ( md 5 ) { if ( Buffer . is Buffer ( md 5 ) ) md 5 = md 5 . to String ( 'base 6 4 ' ) else if ( md 5 & & md 5 . match ( / ^md 5 - / ) ) md 5 = md 5 . replace ( / ^md 5 - / , ' ' ) if ( md 5 . length = = = 3 2 ) md 5 = new Buffer ( md 5 , 'hex ' ) . to String ( 'base 6 4 ' ) } return md 5 } 
function ( ) { var me = this ; 
function ( attrs , redraw ) { var me = this , font Props = me . font Properties , font Props Length = font Props . length , path Props = me . path Properties , path Props Length = path Props . length , has Surface = ! ! me . surface , custom = has Surface & & me . surface . custom Attributes | | { } , sprite Attrs = me . attr , dirty BBox = false , attr , i , new Translation , translation , new Rotate , rotation , new Scaling , scaling ; attrs = Ext . apply ( { } , attrs ) ; for ( attr in custom ) { if ( attrs . has Own Property ( attr ) & & typeof custom [ attr ] = = "function " ) { Ext . apply ( attrs , custom [ attr ] . apply ( me , [ ] . concat ( attrs [ attr ] ) ) ) ; } } 
function ( ) { var me = this ; if ( me . fire Event ( 'beforedestroy ' , me ) ! = = false ) { me . remove ( ) ; me . surface . on Destroy ( me ) ; me . clear Listeners ( ) ; me . fire Event ( 'destroy ' ) ; } } 
function expressify ( fn , ignis ) { var status = arguments . length < = 2 | | arguments [ 2 ] = = = undefined ? 2 0 0 : arguments [ 2 ] ; return function ( req , res , next ) { return _bluebird 2 [ 'default ' ] [ 'try ' ] ( function ( ) { return fn ( ignis , req ) ; } ) . then ( function ( data ) { res . status ( status ) . send ( data ) ; next ( ) ; } ) [ 'catch ' ] ( next ) ; } ; } 
function ( options ) { this . ast Stack = new ASTStack ( ) ; this . tags = options . custom Tags ; this . raw = ' ' ; this . disable Parse Tag = false ; this . line = 1 ; this . line Start = 0 ; this . position = 0 ; this . parse Tag Stack = [ ] ; this . for Items = [ ] ; this . tablerow Items = [ ] ; this . for Items . test = this . tablerow Items . test = function ( name ) { var name = name . split ( ' . ' ) [ 0 ] ; return this . index Of ( name ) = = = - 1 ? false : true ; } ; } 
function ( text , context ) { var ast List = parse Variables ( text , context ) ; if ( Array . is Array ( ast List ) ) { if ( ast List [ 2 ] = = = OPCODE . LOCALS ) { return context . ast Node ( OPCODE . PRINTLOCALS ) . concat ( ast List . slice ( 3 ) ) ; } else { return context . ast Node ( OPCODE . PRINT , ast List ) ; } } else { return context . ast Node ( OPCODE . PRINTSTRING , ast List ) ; } } 
function ( context , text ) { var i = text . index Of ( ' ' ) ; if ( i = = = - 1 ) { var name = text ; var body = ' ' ; } else { var name = text . slice ( 0 , i ) . replace ( / ^ \s + | \s + $ / g , ' ' ) ; var body = text . slice ( i + 1 ) . trim ( ) ; } name = name . to Lower Case ( ) ; if ( typeof ( context . tags [ name ] ) = = = 'function ' ) { context . tags [ name ] ( context , name , body ) ; } else { context . ast Stack . push ( context . ast Node ( OPCODE . UNKNOWN _TAG , name , body ) ) ; } } 
function join _plugins ( plugins ) { debug . assert ( plugins ) . is ( 'array ' ) ; debug . assert ( ARRAY ( plugins ) . every ( is . func ) ) . equals ( true ) ; return function join _plugins _ ( req , res , next ) { var queue = [ ] . concat ( plugins ) ; function do _iteration _ ( ) { if ( queue . length = = = 0 ) { next ( ) ; return ; } var plugin = queue . shift ( ) ; debug . assert ( plugin ) . is ( 'function ' ) ; plugin ( req , res , function plugin _wrapper ( err ) { if ( err ) { next ( err ) ; return ; } do _iteration _ ( ) ; } ) ; } function do _iteration ( ) { try { do _iteration _ ( ) ; } catch ( err ) { next ( err ) ; return ; } } do _iteration ( ) ; } ; } 
function fix _for _missing _req _route ( target , method ) { debug . assert ( target ) . is ( 'string ' ) ; debug . assert ( method ) . is ( 'string ' ) ; return function the _fixer ( req , res , next ) { debug . assert ( req ) . is ( 'object ' ) ; debug . assert ( res ) . is ( 'object ' ) ; debug . assert ( next ) . is ( 'function ' ) ; if ( req . route = = = undefined ) { req . route = { 'path ' : target , 'method ' : method } ; } next ( ) ; } ; } 
function setup _member ( context , k ) { var handler ; var routes = context . routes ; var opts = context . opts ; var middleware = context . middleware ; var app = context . app ; var target = context . target ; var loop _counter = context . loop _counter ; var v = routes [ k ] ; var v _is _function = is . func ( v ) ? true : false ; 
function accept _file ( filename , state ) { state = state | | { } ; debug . assert ( filename ) . is ( 'string ' ) ; debug . assert ( state ) . is ( 'object ' ) ; if ( ! state . file ) { return ; } var ext = PATH . extname ( filename ) ; return ( ext = = = ' .js ' ) ? true : false ; } 
function accept _dir ( filename , state ) { state = state | | { } ; debug . assert ( filename ) . is ( 'string ' ) ; debug . assert ( state ) . is ( 'object ' ) ; if ( ! state . directory ) { return ; } return true ; } 
function accept _multi ( filename , state ) { state = state | | { } ; debug . assert ( filename ) . is ( 'string ' ) ; debug . assert ( state ) . is ( 'object ' ) ; if ( state . directory ) { return accept _dir ( filename , state ) ; } if ( state . file ) { return accept _file ( filename , state ) ; } return ; } 
function make Define ( mapping , id ) { var require = function ( id ) { return mapping [ id ] ; } ; var exports = mapping [ id ] = { } ; var module = null ; 
function select Inside ( edits , inner Id ) { var inside = false 
function binary Search Next ( arr , value ) { var low = 0 , high = arr . length - 1 , i , comparison ; while ( low < = high ) { i = Math . floor ( ( low + high ) / 2 ) ; if ( arr [ i ] < value ) { low = i + 1 ; continue ; } ; if ( arr [ i ] > value ) { high = i - 1 ; continue ; } ; return i ; } return i ; } 
function ( template _engine _reference , root _directory , current _directory , template _extensions , delimiter _symbol ) { files = fs . readdir Sync ( current _directory ) ; for ( var i = 0 ; i < files . length ; i + + ) { var full Path = path . join ( current _directory , files [ i ] ) ; stat = fs . stat Sync ( full Path ) ; if ( stat . is File ( ) ) { var file _extension = path . extname ( full Path ) . slice ( 1 ) ; if ( _ . index Of ( template _extensions , file _extension ) ! = - 1 ) { var template = fs . read File Sync ( full Path , 'utf 8 ' ) ; var partial _name _space = fs Helper . get Dir Difference ( root _directory , full Path ) ; partial _name _space = partial _name _space . replace ( / \ \ / g , delimiter _symbol ) ; console . log ( 'Loading Partial into Handlebars engine . ' ) ; console . log ( ' \t Partial Name Space : ' + partial _name _space ) ; console . log ( ' \t Full Path to Name Space : ' + full Path ) ; console . log ( ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ' ) ; template _engine _reference . register Partial ( partial _name _space , template ) ; } } } var subdirectories = fs Helper . get Dir Paths Sync ( current _directory ) ; for ( var i = 0 ; i < subdirectories . length ; i + + ) { load Partials ( template _engine _reference , root _directory , subdirectories [ i ] , template _extensions , delimiter _symbol ) ; } } 
function ( options ) { / / TODO : validate that the strings passed in don 't have invalid characters either if ( options . engine _reference ) { validate Engine Reference ( options . engine _reference ) } else { new Error ( 'An engine reference is a required property in order to use partial -loader . Please provide this in the functional that calls this . ' ) } if ( options . template _root _directories ) { options . template _root _directories = validate Template Root Directories ( options . template _root _directories ) ; } else { new Error ( 'The "template _root _directories " is a required property in order to use partial -loader . Please provide this in the function that calls this . ' ) } if ( options . partials _directory _names ) { options . partials _directory _names = validate Partial Directory Names ( options . partials _directory _names ) ; } else { new Error ( 'The "template _partials _directory (s ) " is a required property in order to use partial -loader . Please provide this in the functional that calls this . ' ) } if ( options . template _extensions ) { options . template _extensions = validate Template Extensions ( options . template _extensions ) ; } else { new Error ( 'The "template _extensions " is a required property in order to use partial -loader . Please provide this in the functional that calls this . ' ) } } 
function ( config , value ) { if ( value = = = undefined | | value = = = null ) { return false ; } var length = value . length , min = config . min , max = config . max ; if ( ( min & & length < min ) | | ( max & & length > max ) ) { return false ; } else { return true ; } } 
function ( config , value ) { return config . list & & Ext . Array . index Of ( config . list , value ) ! = - 1 ; } 
function ( root , action ) { var parts , ns , i , l ; root = root | | Ext . global ; parts = action . to String ( ) . split ( ' . ' ) ; for ( i = 0 , l = parts . length ; i < l ; i + + ) { ns = parts [ i ] ; root = root [ ns ] ; if ( typeof root = = = 'undefined ' ) { return root ; } } return root ; } 
function ( ) { var me = this , actions = me . actions , namespace = me . namespace , action , cls , methods , i , len , method ; for ( action in actions ) { if ( actions . has Own Property ( action ) ) { if ( me . disable Nested Actions ) { cls = namespace [ action ] ; if ( ! cls ) { cls = namespace [ action ] = { } ; } } else { cls = me . get Namespace ( namespace , action ) ; if ( ! cls ) { cls = me . create Namespaces ( namespace , action ) ; } } methods = actions [ action ] ; for ( i = 0 , len = methods . length ; i < len ; + + i ) { method = new Ext . direct . Remoting Method ( methods [ i ] ) ; cls [ method . name ] = me . create Handler ( action , method ) ; } } } } 
function ( action , method ) { var me = this , slice = Array . prototype . slice , handler ; if ( ! method . form Handler ) { handler = function ( ) { me . configure Request ( action , method , slice . call ( arguments , 0 ) ) ; } ; } else { handler = function ( form , callback , scope ) { me . configure Form Request ( action , method , form , callback , scope ) ; } ; } handler . direct Cfg = { action : action , method : method } ; return handler ; } 
function ( transaction , event ) { var success = ! ! event . status , func Name = success ? 'success ' : 'failure ' , callback , options , result ; if ( transaction & & transaction . callback ) { callback = transaction . callback ; options = transaction . callback Options ; result = typeof event . result ! = = 'undefined ' ? event . result : event . data ; if ( Ext . is Function ( callback ) ) { callback ( result , event , success , options ) ; } else { Ext . callback ( callback [ func Name ] , callback . scope , [ result , event , success , options ] ) ; Ext . callback ( callback . callback , callback . scope , [ result , event , success , options ] ) ; } } } 
function ( options , success , response ) { var me = this , i , len , events , event , transaction , transactions ; if ( success ) { events = me . create Events ( response ) ; for ( i = 0 , len = events . length ; i < len ; + + i ) { event = events [ i ] ; transaction = me . get Transaction ( event ) ; me . fire Event ( 'data ' , me , event ) ; if ( transaction & & me . fire Event ( 'beforecallback ' , me , event , transaction ) ! = = false ) { me . run Callback ( transaction , event , true ) ; Ext . direct . Manager . remove Transaction ( transaction ) ; } } } else { transactions = [ ] . concat ( options . transaction ) ; for ( i = 0 , len = transactions . length ; i < len ; + + i ) { transaction = me . get Transaction ( transactions [ i ] ) ; if ( transaction & & transaction . retry Count < me . max Retries ) { transaction . retry ( ) ; } else { event = new Ext . direct . Exception Event ( { data : null , transaction : transaction , code : Ext . direct . Manager . exceptions . TRANSPORT , message : 'Unable to connect to the server . ' , xhr : response } ) ; me . fire Event ( 'data ' , me , event ) ; if ( transaction & & me . fire Event ( 'beforecallback ' , me , transaction ) ! = = false ) { me . run Callback ( transaction , event , false ) ; Ext . direct . Manager . remove Transaction ( transaction ) ; } } } } } 
function ( options ) { return options & & options . tid ? Ext . direct . Manager . get Transaction ( options . tid ) : null ; } 
function ( action , method , args ) { var me = this , call Data , data , callback , scope , opts , transaction , params ; call Data = method . get Call Data ( args ) ; data = call Data . data ; callback = call Data . callback ; scope = call Data . scope ; opts = call Data . options | | { } ; params = Ext . apply ( { } , { provider : me , args : args , action : action , method : method . name , data : data , callback Options : opts , callback : scope & & Ext . is Function ( callback ) ? Ext . Function . bind ( callback , scope ) : callback } ) ; if ( opts . timeout ) { Ext . apply If ( params , { timeout : opts . timeout } ) ; } ; transaction = new Ext . direct . Transaction ( params ) ; if ( me . fire Event ( 'beforecall ' , me , transaction , method ) ! = = false ) { Ext . direct . Manager . add Transaction ( transaction ) ; me . queue Transaction ( transaction ) ; me . fire Event ( 'call ' , me , transaction , method ) ; } } 
function ( transaction ) { return { action : transaction . action , method : transaction . method , data : transaction . data , type : 'rpc ' , tid : transaction . id } ; } 
function ( transaction ) { var me = this , enable Buffer = me . enable Buffer ; if ( transaction . form ) { me . send Form Request ( transaction ) ; return ; } if ( typeof transaction . timeout ! = = 'undefined ' ) { me . send Request ( transaction ) ; return ; } if ( enable Buffer ) { me . call Buffer . push ( transaction ) ; if ( ! me . call Task ) { me . call Task = new Ext . util . Delayed Task ( me . combine And Send , me ) ; } me . call Task . delay ( Ext . is Number ( enable Buffer ) ? enable Buffer : 1 0 ) ; } else { me . combine And Send ( ) ; } } 
function ( ) { var me = this , buffer = me . call Buffer , len = buffer . length ; if ( len > 0 ) { me . send Request ( len = = 1 ? buffer [ 0 ] : buffer ) ; me . call Buffer = [ ] ; } } 
function ( find , replace , str ) { / / On IE 9 we have to fake $x replacement if ( is Reg Exp Broken ) { return str . replace ( find , function ( ) { var val = replace , args = arguments , i ; for ( i = 0 ; i < args . length - 2 ; i + + ) { if ( args [ i ] = = = undef ) { val = val . replace ( new Reg Exp ( ' \ \ $ ' + i , 'g ' ) , ' ' ) ; } else { val = val . replace ( new Reg Exp ( ' \ \ $ ' + i , 'g ' ) , args [ i ] ) ; } } return val ; } ) ; } return str . replace ( find , replace ) ; } 
function create Lookup Table ( option , default _value , extend ) { var value = settings [ option ] ; if ( ! value ) { / / Get cached default map or make it if needed value = map Cache [ option ] ; if ( ! value ) { value = make Map ( default _value , ' ' , make Map ( default _value . to Upper Case ( ) , ' ' ) ) ; value = tinymce . extend ( value , extend ) ; map Cache [ option ] = value ; } } else { / / Create custom map value = make Map ( value , ' , ' , make Map ( value . to Upper Case ( ) , ' ' ) ) ; } return value ; } 
function add Custom Elements ( custom _elements ) { var custom Element Reg Exp = / ^ ( ~ ) ? ( . + ) $ / ; if ( custom _elements ) { each ( split ( custom _elements ) , function ( rule ) { var matches = custom Element Reg Exp . exec ( rule ) , inline = matches [ 1 ] = = = ' ~ ' , clone Name = inline ? 'span ' : 'div ' , name = matches [ 2 ] ; children [ name ] = children [ clone Name ] ; custom Elements Map [ name ] = clone Name ; / / If it 's not marked as inline then add it to valid block elements if ( ! inline ) { block Elements Map [ name . to Upper Case ( ) ] = { } ; block Elements Map [ name ] = { } ; } / / Add elements clone if needed if ( ! elements [ name ] ) { elements [ name ] = elements [ clone Name ] ; } / / Add custom elements at span /div positions each ( children , function ( element , child ) { if ( element [ clone Name ] ) element [ name ] = element [ clone Name ] ; } ) ; } ) ; } } 
function walk ( node , root _node , prev ) { var sibling , parent , start Name = prev ? 'last Child ' : 'first Child ' , sibling Name = prev ? 'prev ' : 'next ' ; / / Walk into nodes if it has a start if ( node [ start Name ] ) return node [ start Name ] ; / / Return the sibling if it has one if ( node ! = = root _node ) { sibling = node [ sibling Name ] ; if ( sibling ) return sibling ; / / Walk up the parents to look for siblings for ( parent = node . parent ; parent & & parent ! = = root _node ; parent = parent . parent ) { sibling = parent [ sibling Name ] ; if ( sibling ) return sibling ; } } } 
function ( node ) { var content Editable ; / / Check type if ( node . node Type ! = 1 ) { return null ; } / / Check for fake content editable content Editable = node . get Attribute ( "data -mce -contenteditable " ) ; if ( content Editable & & content Editable ! = = "inherit " ) { return content Editable ; } / / Check for real content editable return node . content Editable ! = = "inherit " ? node . content Editable : null ; } 
function get Range ( ) { var ie Range = selection . get Rng ( ) , dom Range = dom . create Rng ( ) , element , collapsed , tmp Range , element 2 , bookmark , fail ; / / If selection is outside the current document just return an empty range element = ie Range . item ? ie Range . item ( 0 ) : ie Range . parent Element ( ) ; if ( element . owner Document ! = dom . doc ) return dom Range ; collapsed = selection . is Collapsed ( ) ; / / Handle control selection if ( ie Range . item ) { dom Range . set Start ( element . parent Node , dom . node Index ( element ) ) ; dom Range . set End ( dom Range . start Container , dom Range . start Offset + 1 ) ; return dom Range ; } function find End Point ( start ) { var end Point = get Position ( ie Range , start ) , container , offset , text Node Offset = 0 , sibling , undef , node Value ; container = end Point . node ; offset = end Point . offset ; if ( end Point . inside & & ! container . has Child Nodes ( ) ) { dom Range [ start ? 'set Start ' : 'set End ' ] ( container , 0 ) ; return ; } if ( offset = = = undef ) { dom Range [ start ? 'set Start Before ' : 'set End After ' ] ( container ) ; return ; } if ( end Point . position < 0 ) { sibling = end Point . inside ? container . first Child : container . next Sibling ; if ( ! sibling ) { dom Range [ start ? 'set Start After ' : 'set End After ' ] ( container ) ; return ; } if ( ! offset ) { if ( sibling . node Type = = 3 ) dom Range [ start ? 'set Start ' : 'set End ' ] ( sibling , 0 ) ; else dom Range [ start ? 'set Start Before ' : 'set End Before ' ] ( sibling ) ; return ; } / / Find the text node and offset while ( sibling ) { node Value = sibling . node Value ; text Node Offset + = node Value . length ; / / We are at or passed the position we where looking for if ( text Node Offset > = offset ) { container = sibling ; text Node Offset - = offset ; text Node Offset = node Value . length - text Node Offset ; break ; } sibling = sibling . next Sibling ; } } else { / / Find the text node and offset sibling = container . previous Sibling ; if ( ! sibling ) return dom Range [ start ? 'set Start Before ' : 'set End Before ' ] ( container ) ; / / If there isn 't any text to loop then use the first position if ( ! offset ) { if ( container . node Type = = 3 ) dom Range [ start ? 'set Start ' : 'set End ' ] ( sibling , container . node Value . length ) ; else dom Range [ start ? 'set Start After ' : 'set End After ' ] ( sibling ) ; return ; } while ( sibling ) { text Node Offset + = sibling . node Value . length ; / / We are at or passed the position we where looking for if ( text Node Offset > = offset ) { container = sibling ; text Node Offset - = offset ; break ; } sibling = sibling . previous Sibling ; } } dom Range [ start ? 'set Start ' : 'set End ' ] ( container , text Node Offset ) ; } ; try { / / Find start point find End Point ( true ) ; / / Find end point if needed if ( ! collapsed ) find End Point ( ) ; } catch ( ex ) { / / IE has a nasty bug where text nodes might throw "invalid argument " when you / / access the node Value or other properties of text nodes . This seems to happend when / / text nodes are split into two nodes by a delete /backspace call . So lets detect it and try to fix it . if ( ex . number = = - 2 1 4 7 0 2 4 8 0 9 ) { / / Get the current selection bookmark = self . get Bookmark ( 2 ) ; / / Get start element tmp Range = ie Range . duplicate ( ) ; tmp Range . collapse ( true ) ; element = tmp Range . parent Element ( ) ; / / Get end element if ( ! collapsed ) { tmp Range = ie Range . duplicate ( ) ; tmp Range . collapse ( false ) ; element 2 = tmp Range . parent Element ( ) ; element 2 . inner HTML = element 2 . inner HTML ; } / / Remove the broken elements element . inner HTML = element . inner HTML ; / / Restore the selection self . move To Bookmark ( bookmark ) ; / / Since the range has moved we need to re -get it ie Range = selection . get Rng ( ) ; / / Find start point find End Point ( true ) ; / / Find end point if needed if ( ! collapsed ) find End Point ( ) ; } else throw ex ; / / Throw other errors } return dom Range ; } 
function find Text Node Relative ( left , start Node ) { var walker , last Inline Element ; start Node = start Node | | container ; walker = new Tree Walker ( start Node , dom . get Parent ( start Node . parent Node , dom . is Block ) | | body ) ; / / Walk left until we hit a text node we can move to or a block /br /img while ( node = walker [ left ? 'prev ' : 'next ' ] ( ) ) { / / Found text node that has a length if ( node . node Type = = = 3 & & node . node Value . length > 0 ) { container = node ; offset = left ? node . node Value . length : 0 ; normalized = true ; return ; } / / Break if we find a block or a BR /IMG /INPUT etc if ( dom . is Block ( node ) | | non Empty Elements Map [ node . node Name . to Lower Case ( ) ] ) { return ; } last Inline Element = node ; } / / Only fetch the last inline element when in caret mode for now if ( collapsed & & last Inline Element ) { container = last Inline Element ; normalized = true ; offset = 0 ; } } 
function done ( ) { dom . remove ( id ) ; if ( elm ) elm . onreadystatechange = elm . onload = elm = null ; callback ( ) ; } 
function ( ) { var context Menu , menu Items , t = this ; context Menu = DOM . get ( 'menu _ ' + t . id ) ; menu Items = DOM . select ( 'a [role =option ] ' , 'menu _ ' + t . id ) ; menu Items . splice ( 0 , 0 , context Menu ) ; t . keyboard Nav = new tinymce . ui . Keyboard Navigation ( { root : 'menu _ ' + t . id , items : menu Items , on Cancel : function ( ) { t . hide Menu ( ) ; } , enable Up Down : true } ) ; context Menu . focus ( ) ; } 
function load Scripts ( ) { if ( s . language & & s . language _load ! = = false ) sl . add ( tinymce . base URL + ' /langs / ' + s . language + ' .js ' ) ; if ( s . theme & & typeof s . theme ! = "function " & & s . theme . char At ( 0 ) ! = ' - ' & & ! Theme Manager . urls [ s . theme ] ) Theme Manager . load ( s . theme , 'themes / ' + s . theme + ' /editor _template ' + tinymce . suffix + ' .js ' ) ; each ( explode ( s . plugins ) , function ( p ) { if ( p & & ! Plugin Manager . urls [ p ] ) { if ( p . char At ( 0 ) = = ' - ' ) { p = p . substr ( 1 , p . length ) ; var dependencies = Plugin Manager . dependencies ( p ) ; each ( dependencies , function ( dep ) { var default Settings = { prefix : 'plugins / ' , resource : dep , suffix : ' /editor _plugin ' + tinymce . suffix + ' .js ' } ; dep = Plugin Manager . create Url ( default Settings , dep ) ; Plugin Manager . load ( dep . resource , dep ) ; } ) ; } else { / / Skip safari plugin , since it is removed as of 3 . 3b 1 if ( p = = 'safari ' ) { return ; } Plugin Manager . load ( p , { prefix : 'plugins / ' , resource : p , suffix : ' /editor _plugin ' + tinymce . suffix + ' .js ' } ) ; } } } ) ; / / Init when que is loaded sl . load Queue ( function ( ) { if ( ! t . removed ) t . init ( ) ; } ) ; } 
function ( ) { var self = this , body , parent ; / / Check if the editor was hidden and the re -initalize content Editable mode by removing and adding the body again if ( self . _is Hidden ( ) ) { body = self . get Body ( ) ; parent = body . parent Node ; parent . remove Child ( body ) ; parent . append Child ( body ) ; body . focus ( ) ; } } 
function event Handler ( evt , args ) { var type = evt . type ; / / Don 't fire events when it 's removed if ( self . removed ) return ; / / Sends the native event out to a global dispatcher then to the specific event dispatcher if ( self . on Event . dispatch ( self , evt , args ) ! = = false ) { self [ native To Dispatcher Map [ evt . fake Type | | evt . type ] ] . dispatch ( self , evt , args ) ; } } 
function handle Shortcut ( e , execute ) { if ( e . alt Key | | e . ctrl Key | | e . meta Key ) { each ( self . shortcuts , function ( shortcut ) { var ctrl State = tinymce . is Mac ? e . meta Key : e . ctrl Key ; if ( shortcut . ctrl ! = ctrl State | | shortcut . alt ! = e . alt Key | | shortcut . shift ! = e . shift Key ) return ; if ( e . key Code = = shortcut . key Code | | ( e . char Code & & e . char Code = = shortcut . char Code ) ) { e . prevent Default ( ) ; if ( execute ) { shortcut . func . call ( shortcut . scope ) ; } return true ; } } ) ; } } 
function ( command ) { if ( selection . is Collapsed ( ) ) selection . select ( selection . get Node ( ) ) ; exec Native Command ( command ) ; selection . collapse ( FALSE ) ; } 
function ( command ) { var list Elm , list Parent ; exec Native Command ( command ) ; / / Web Kit produces lists within block elements so we need to split them / / we will replace the native list creation logic to custom logic later on / / TODO : Remove this when the list creation logic is removed list Elm = dom . get Parent ( selection . get Node ( ) , 'ol ,ul ' ) ; if ( list Elm ) { list Parent = list Elm . parent Node ; / / If list is within a text block then split that block if ( / ^ (H [ 1 - 6 ] |P |ADDRESS |PRE ) $ / . test ( list Parent . node Name ) ) { store Selection ( ) ; dom . split ( list Parent , list Elm ) ; restore Selection ( ) ; } } } 
function ( command ) { var name = 'align ' + command . substring ( 7 ) ; var nodes = selection . is Collapsed ( ) ? [ dom . get Parent ( selection . get Node ( ) , dom . is Block ) ] : selection . get Selected Blocks ( ) ; var matches = tinymce . map ( nodes , function ( node ) { return ! ! formatter . match Node ( node , name ) ; } ) ; return tinymce . in Array ( matches , TRUE ) ! = = - 1 ; } 
function match Name ( node , format ) { / / Check for inline match if ( is Eq ( node , format . inline ) ) return TRUE ; / / Check for block match if ( is Eq ( node , format . block ) ) return TRUE ; / / Check for selector match if ( format . selector ) return dom . is ( node , format . selector ) ; } 
function remove Caret Container ( node , move _caret ) { var child , rng ; if ( ! node ) { node = get Parent Caret Container ( selection . get Start ( ) ) ; if ( ! node ) { while ( node = dom . get ( caret Container Id ) ) { remove Caret Container ( node , false ) ; } } } else { rng = selection . get Rng ( true ) ; if ( is Caret Container Empty ( node ) ) { if ( move _caret ! = = false ) { rng . set Start Before ( node ) ; rng . set End Before ( node ) ; } dom . remove ( node ) ; } else { child = find First Text Node ( node ) ; if ( child . node Value . char At ( 0 ) = = = INVISIBLE _CHAR ) { child = child . delete Data ( 0 , 1 ) ; } dom . remove ( node , 1 ) ; } selection . set Rng ( rng ) ; } } 
function unmark Bogus Caret Parents ( ) { var i , caret Container , node ; caret Container = get Parent Caret Container ( selection . get Start ( ) ) ; if ( caret Container & & ! dom . is Empty ( caret Container ) ) { tinymce . walk ( caret Container , function ( node ) { if ( node . node Type = = 1 & & node . id ! = = caret Container Id & & ! dom . is Empty ( node ) ) { dom . set Attrib ( node , 'data -mce -bogus ' , null ) ; } } , 'child Nodes ' ) ; } } 
function render Block On IE ( block ) { var old Rng ; if ( tinymce . is IE & & dom . is Block ( block ) ) { old Rng = selection . get Rng ( ) ; block . append Child ( dom . create ( 'span ' , null , ' \u 0 0a 0 ' ) ) ; selection . select ( block ) ; block . last Child . outer HTML = ' ' ; selection . set Rng ( old Rng ) ; } } 
function trim Inline Elements On Left Side Of Block ( block ) { var node = block , first Childs = [ ] , i ; / / Find inner most first child ex : <p > <i > <b > * < /b > < /i > < /p > while ( node = node . first Child ) { if ( dom . is Block ( node ) ) { return ; } if ( node . node Type = = 1 & & ! non Empty Elements Map [ node . node Name . to Lower Case ( ) ] ) { first Childs . push ( node ) ; } } i = first Childs . length ; while ( i - - ) { node = first Childs [ i ] ; if ( ! node . has Child Nodes ( ) | | ( node . first Child = = node . last Child & & node . first Child . node Value = = = ' ' ) ) { dom . remove ( node ) ; } else { / / Remove <a > < /a > see # 5 3 8 1 if ( node . node Name = = "A " & & ( node . inner Text | | node . text Content ) = = = ' ' ) { dom . remove ( node ) ; } } } } 
function move To Caret Position ( root ) { var walker , node , rng , y , view Port , last Node = root , temp Elm ; rng = dom . create Rng ( ) ; if ( root . has Child Nodes ( ) ) { walker = new Tree Walker ( root , root ) ; while ( node = walker . current ( ) ) { if ( node . node Type = = 3 ) { rng . set Start ( node , 0 ) ; rng . set End ( node , 0 ) ; break ; } if ( non Empty Elements Map [ node . node Name . to Lower Case ( ) ] ) { rng . set Start Before ( node ) ; rng . set End Before ( node ) ; break ; } last Node = node ; node = walker . next ( ) ; } if ( ! node ) { rng . set Start ( last Node , 0 ) ; rng . set End ( last Node , 0 ) ; } } else { if ( root . node Name = = 'BR ' ) { if ( root . next Sibling & & dom . is Block ( root . next Sibling ) ) { / / Trick on older IE versions to render the caret before the BR between two lists if ( ! document Mode | | document Mode < 9 ) { temp Elm = dom . create ( 'br ' ) ; root . parent Node . insert Before ( temp Elm , root ) ; } rng . set Start Before ( root ) ; rng . set End Before ( root ) ; } else { rng . set Start After ( root ) ; rng . set End After ( root ) ; } } else { rng . set Start ( root , 0 ) ; rng . set End ( root , 0 ) ; } } selection . set Rng ( rng ) ; / / Remove temp Elm created for old IE :s dom . remove ( temp Elm ) ; view Port = dom . get View Port ( editor . get Win ( ) ) ; / / scroll Into View seems to scroll the parent window in most browsers now including FF 3 . 0b 4 so it 's time to stop using it and do it our selfs y = dom . get Pos ( root ) . y ; if ( y < view Port . y | | y + 2 5 > view Port . y + view Port . h ) { editor . get Win ( ) . scroll To ( 0 , y < view Port . y ? y : y - view Port . h + 2 5 ) ; / / Needs to be hardcoded to roughly one line of text if a huge text block is broken into two blocks } } 
function create New Block ( name ) { var node = container , block , cloned Node , caret Node ; block = name | | parent Block Name = = "TABLE " ? dom . create ( name | | new Block Name ) : parent Block . clone Node ( false ) ; caret Node = block ; / / Clone any parent styles if ( settings . keep _styles ! = = false ) { do { if ( / ^ (SPAN |STRONG |B |EM |I |FONT |STRIKE |U ) $ / . test ( node . node Name ) ) { / / Never clone a caret containers if ( node . id = = ' _mce _caret ' ) { continue ; } cloned Node = node . clone Node ( false ) ; dom . set Attrib ( cloned Node , 'id ' , ' ' ) ; / / Remove ID since it needs to be document unique if ( block . has Child Nodes ( ) ) { cloned Node . append Child ( block . first Child ) ; block . append Child ( cloned Node ) ; } else { caret Node = cloned Node ; block . append Child ( cloned Node ) ; } } } while ( node = node . parent Node ) ; } / / BR is needed in empty blocks on non IE browsers if ( ! tinymce . is IE ) { caret Node . inner HTML = ' <br data -mce -bogus = " 1 " > ' ; } return block ; } 
function wrap Self And Siblings In Default Block ( container , offset ) { var new Block , parent Block , start Node , node , next , block Name = new Block Name | | 'P ' ; / / Not in a block element or in a table cell or caption parent Block = dom . get Parent ( container , dom . is Block ) ; if ( ! parent Block | | ! can Split Block ( parent Block ) ) { parent Block = parent Block | | editable Root ; if ( ! parent Block . has Child Nodes ( ) ) { new Block = dom . create ( block Name ) ; parent Block . append Child ( new Block ) ; rng . set Start ( new Block , 0 ) ; rng . set End ( new Block , 0 ) ; return new Block ; } / / Find parent that is the first child of parent Block node = container ; while ( node . parent Node ! = parent Block ) { node = node . parent Node ; } / / Loop left to find start node start wrapping at while ( node & & ! dom . is Block ( node ) ) { start Node = node ; node = node . previous Sibling ; } if ( start Node ) { new Block = dom . create ( block Name ) ; start Node . parent Node . insert Before ( new Block , start Node ) ; / / Start wrapping until we hit a block node = start Node ; while ( node & & ! dom . is Block ( node ) ) { next = node . next Sibling ; new Block . append Child ( node ) ; node = next ; } / / Restore range to it 's past location rng . set Start ( container , offset ) ; rng . set End ( container , offset ) ; } } return container ; } 
function handle Empty List Item ( ) { function is First Or Last Li ( first ) { var node = container Block [ first ? 'first Child ' : 'last Child ' ] ; / / Find first /last element since there might be whitespace there while ( node ) { if ( node . node Type = = 1 ) { break ; } node = node [ first ? 'next Sibling ' : 'previous Sibling ' ] ; } return node = = = parent Block ; } ; new Block = new Block Name ? create New Block ( new Block Name ) : dom . create ( 'BR ' ) ; if ( is First Or Last Li ( true ) & & is First Or Last Li ( ) ) { / / Is first and last list item then replace the OL /UL with a text block dom . replace ( new Block , container Block ) ; } else if ( is First Or Last Li ( true ) ) { / / First LI in list then remove LI and add text block before list container Block . parent Node . insert Before ( new Block , container Block ) ; } else if ( is First Or Last Li ( ) ) { / / Last LI in list then temove LI and add text block after list dom . insert After ( new Block , container Block ) ; render Block On IE ( new Block ) ; } else { / / Middle LI in list the split the list and insert a text block in the middle / / Extract after fragment and insert it after the current block tmp Rng = rng . clone Range ( ) ; tmp Rng . set Start After ( parent Block ) ; tmp Rng . set End After ( container Block ) ; fragment = tmp Rng . extract Contents ( ) ; dom . insert After ( fragment , container Block ) ; dom . insert After ( new Block , container Block ) ; } dom . remove ( parent Block ) ; move To Caret Position ( new Block ) ; undo Manager . add ( ) ; } 
function has Right Side Br ( ) { var walker = new Tree Walker ( container , parent Block ) , node ; while ( node = walker . current ( ) ) { if ( node . node Name = = 'BR ' ) { return true ; } node = walker . next ( ) ; } } 
function insert Br ( ) { var br Elm , extra Br , marker ; if ( container & & container . node Type = = 3 & & offset > = container . node Value . length ) { / / Insert extra BR element at the end block elements if ( ! tinymce . is IE & & ! has Right Side Br ( ) ) { br Elm = dom . create ( 'br ' ) ; rng . insert Node ( br Elm ) ; rng . set Start After ( br Elm ) ; rng . set End After ( br Elm ) ; extra Br = true ; } } br Elm = dom . create ( 'br ' ) ; rng . insert Node ( br Elm ) ; / / Rendering modes below IE 8 doesn 't display BR elements in PRE unless we have a \n before it if ( tinymce . is IE & & parent Block Name = = 'PRE ' & & ( ! document Mode | | document Mode < 8 ) ) { br Elm . parent Node . insert Before ( dom . doc . create Text Node ( ' \r ' ) , br Elm ) ; } / / Insert temp marker and scroll to that marker = dom . create ( 'span ' , { } , ' &nbsp ; ' ) ; br Elm . parent Node . insert Before ( marker , br Elm ) ; selection . scroll Into View ( marker ) ; dom . remove ( marker ) ; if ( ! extra Br ) { rng . set Start After ( br Elm ) ; rng . set End After ( br Elm ) ; } else { rng . set Start Before ( br Elm ) ; rng . set End Before ( br Elm ) ; } selection . set Rng ( rng ) ; undo Manager . add ( ) ; } 
function ( el , prefix ) { var me = this , sandbox Prefix = ' ' ; el = Ext . get Dom ( el , true ) | | { } ; if ( el = = = document ) { el . id = me . document Id ; } else if ( el = = = window ) { el . id = me . window Id ; } if ( ! el . id ) { if ( me . is Sandboxed ) { sandbox Prefix = Ext . sandbox Name . to Lower Case ( ) + ' - ' ; } el . id = sandbox Prefix + ( prefix | | "ext -gen " ) + ( + + Ext . id Seed ) ; } return el . id ; } 
function ( ) { var ln = arguments . length , i , arg ; for ( i = 0 ; i < ln ; i + + ) { arg = arguments [ i ] ; if ( arg ) { if ( Ext . is Array ( arg ) ) { this . destroy . apply ( this , arg ) ; } else if ( Ext . is Function ( arg . destroy ) ) { arg . destroy ( ) ; } else if ( arg . dom ) { arg . remove ( ) ; } } } } 
function ( callback , scope , args , delay ) { if ( Ext . is Function ( callback ) ) { args = args | | [ ] ; scope = scope | | window ; if ( delay ) { Ext . defer ( callback , delay , scope , args ) ; } else { callback . apply ( scope , args ) ; } } } 
function ( is , regex ) { var m ; return ( is & & ( m = regex . exec ( Ext . user Agent ) ) ) ? parse Float ( m [ 1 ] ) : 0 ; } 
function ( o ) { if ( ! Ext . is Ready ) { Ext . on Ready ( function ( ) { Ext . add Behaviors ( o ) ; } ) ; } else { var cache = { } , 
function ( dest , source , names , use Prototype Keys ) { if ( typeof names = = 'string ' ) { names = names . split ( / [ , ; \s ] / ) ; } var n , n Len = names ? names . length : 0 , name ; for ( n = 0 ; n < n Len ; n + + ) { name = names [ n ] ; if ( use Prototype Keys | | source . has Own Property ( name ) ) { dest [ name ] = source [ name ] ; } } return dest ; } 
function ( o ) { for ( var i = 1 , a = arguments , len = a . length ; i < len ; i + + ) { Ext . destroy ( o [ a [ i ] ] ) ; delete o [ a [ i ] ] ; } } 
function ( arr , truth ) { var ret = [ [ ] , [ ] ] , a , v , a Len = arr . length ; for ( a = 0 ; a < a Len ; a + + ) { v = arr [ a ] ; ret [ ( truth & & truth ( v , a , arr ) ) | | ( ! truth & & v ) ? 0 : 1 ] . push ( v ) ; } return ret ; } 
function ( arr , method Name ) { var ret = [ ] , args = Array . prototype . slice . call ( arguments , 2 ) , a , v , a Len = arr . length ; for ( a = 0 ; a < a Len ; a + + ) { v = arr [ a ] ; if ( v & & typeof v [ method Name ] = = 'function ' ) { ret . push ( v [ method Name ] . apply ( v , args ) ) ; } else { ret . push ( undefined ) ; } } return ret ; } 
function ( ) { var parts = Ext . partition ( arguments , function ( val ) { return typeof val ! = 'function ' ; } ) , arrs = parts [ 0 ] , fn = parts [ 1 ] [ 0 ] , len = Ext . max ( Ext . pluck ( arrs , "length " ) ) , ret = [ ] , i , j , a Len ; for ( i = 0 ; i < len ; i + + ) { ret [ i ] = [ ] ; if ( fn ) { ret [ i ] = fn . apply ( fn , Ext . pluck ( arrs , i ) ) ; } else { for ( j = 0 , a Len = arrs . length ; j < a Len ; j + + ) { ret [ i ] . push ( arrs [ j ] [ i ] ) ; } } } return ret ; } 
function ( items , connector ) { var length = items . length , head , tail ; if ( length < = 1 ) { return items [ 0 ] ; } else { head = items . slice ( 0 , length - 1 ) ; tail = items [ length - 1 ] ; return Ext . util . Format . format ( " { 0 } { 1 } { 2 } " , head . join ( " , " ) , connector | | 'and ' , tail ) ; } } 
function report ( node , needed , gotten , loc , is Last Node Check ) { var msg Context = { needed : needed , type : indent Type , characters : needed = = = 1 ? "character " : "characters " , gotten : gotten } ; var indent Char = indent Type = = = "space " ? " " : " \t " ; function get Fixer Function ( ) { var range To Fix = [ ] ; if ( needed > gotten ) { var spaces = " " + new Array ( needed - gotten + 1 ) . join ( indent Char ) ; 
function get Fixer Function ( ) { var range To Fix = [ ] ; if ( needed > gotten ) { var spaces = " " + new Array ( needed - gotten + 1 ) . join ( indent Char ) ; 
function get Node Indent ( node , by Last Line , exclude Commas ) { var token = by Last Line ? context . get Last Token ( node ) : context . get First Token ( node ) ; var src = context . get Source ( token , token . loc . start . column ) ; var reg Exp = exclude Commas ? indent Pattern . exclude Commas : indent Pattern . normal ; var indent = reg Exp . exec ( src ) ; return indent ? indent [ 0 ] . length : 0 ; } 
function is Node First In Line ( node , by End Location ) { var first Token = by End Location = = = true ? context . get Last Token ( node , 1 ) : context . get Token Before ( node ) , start Line = by End Location = = = true ? node . loc . end . line : node . loc . start . line , end Line = first Token ? first Token . loc . end . line : - 1 ; return start Line ! = = end Line ; } 
function is Node First Argument ( node ) { if ( ! node . parent . arguments ) { return false ; } return equal ( node , node . parent . arguments [ 0 ] ) ; 
function check Node Indent ( node , indent , exclude Commas ) { var node Indent = get Node Indent ( node , false , exclude Commas ) ; if ( node . type ! = = "Array Expression " & & node . type ! = = "Object Expression " & & node Indent ! = = indent & & is Node First In Line ( node ) ) { report ( node , indent , node Indent ) ; } } 
function check Nodes Indent ( nodes , indent , exclude Commas ) { nodes . for Each ( function ( node ) { if ( node . type = = = "If Statement " & & node . alternate ) { var else Token = context . get Token Before ( node . alternate ) ; check Node Indent ( else Token , indent , exclude Commas ) ; } check Node Indent ( node , indent , exclude Commas ) ; } ) ; } 
function check Last Node Line Indent ( node , last Line Indent ) { var last Token = context . get Last Token ( node ) ; var end Indent = get Node Indent ( last Token , true ) ; if ( end Indent ! = = last Line Indent & & is Node First In Line ( node , true ) ) { report ( node , last Line Indent , end Indent , { line : last Token . loc . start . line , column : last Token . loc . start . column } , true ) ; } } 
function check First Node Line Indent ( node , first Line Indent ) { var start Indent = get Node Indent ( node , false ) ; if ( start Indent ! = = first Line Indent & & is Node First In Line ( node ) ) { report ( node , first Line Indent , start Indent , { line : node . loc . start . line , column : node . loc . start . column } ) ; } } 
function get Variable Declarator Node ( node ) { var parent = node . parent ; while ( parent . type ! = = "Variable Declarator " & & parent . type ! = = "Program " ) { parent = parent . parent ; } return parent . type = = = "Variable Declarator " ? parent : null ; } 
function check Indent In Function Block ( node ) { 
function is Single Line Node ( node ) { var last Token = context . get Last Token ( node ) , start Line = node . loc . start . line , end Line = last Token . loc . end . line ; return start Line = = = end Line ; } 
function is First Array Element On Same Line ( node ) { if ( node . type = = = "Array Expression " & & node . elements [ 0 ] ) { return node . elements [ 0 ] . loc . start . line = = = node . loc . start . line & & node . elements [ 0 ] . type = = = "Object Expression " ; } else { return false ; } } 
function check Indent In Array Or Object Block ( node ) { 
function is Node Body Block ( node ) { return node . type = = = "Block Statement " | | ( node . body & & node . body . type = = = "Block Statement " ) | | ( node . consequent & & node . consequent . type = = = "Block Statement " ) ; } 
function block Indentation Check ( node ) { 
function check Indent In Variable Declarations ( node ) { var elements = filter Out Same Line Vars ( node ) ; var node Indent = get Node Indent ( node ) ; var last Element = elements [ elements . length - 1 ] ; var elements Indent = node Indent + indent Size * options . Variable Declarator [ node . kind ] ; 
function expected Case Indent ( node , switch Indent ) { var switch Node = ( node . type = = = "Switch Statement " ) ? node : node . parent ; var case Indent ; if ( case Indent Store [ switch Node . loc . start . line ] ) { return case Indent Store [ switch Node . loc . start . line ] ; } else { if ( typeof switch Indent = = = "undefined " ) { switch Indent = get Node Indent ( switch Node ) ; } if ( switch Node . cases . length > 0 & & options . Switch Case = = = 0 ) { case Indent = switch Indent ; } else { case Indent = switch Indent + ( indent Size * options . Switch Case ) ; } case Indent Store [ switch Node . loc . start . line ] = case Indent ; return case Indent ; } } 
function to JSON ( ) { var self = this , keys = self . keys ( ) , serialized Store = { } ; _ . each ( keys , function ( key ) { var model Or Collection = self . get ( key ) , json Representation = model Or Collection . to JSON ( ) , identifier = self . find Registered Identifier . call ( self , model Or Collection ) ; if ( identifier ) { var serialized Data = { data Store Model Identifier : identifier , data : json Representation } ; serialized Store [ key ] = serialized Data ; } else { throw new Error ( 'Could not serialize Data Store because ' + 'a required model Or Collection was not registered before ! ' ) ; } } ) ; debug ( 'to json ` %j ` ' , serialized Store ) ; return serialized Store ; } 
function factory ( name , attrs , fn ) { if ( arguments . length = = = 2 ) { fn = attrs ; attrs = null ; } factories . get ( name ) . create ( attrs , fn ) ; } 
function define ( type , Model ) { if ( arguments . length = = = 1 ) { Model = type ; type = Model . prototype . _ _type | | Model . model Name ; } var factory = new Factory ( Model ) ; factories . set ( type , factory ) return factory ; } 
function list ( type , num , fn ) { var records = [ ] ; var bail = false ; var created = function ( err , record ) { if ( bail ) return ; if ( err ) { bail = true ; return fn ( err ) ; } records . push ( record ) ; if ( records . length = = = num ) { fn ( null , records ) ; } } ; for ( var i = 0 ; i < num ; i + + ) { factory ( type , created ) ; } } 
function ( size , units ) { 
function ( box , units ) { var a = this . add Units , b = this . parse Box ( box ) ; return a ( b . top , units ) + ' ' + a ( b . right , units ) + ' ' + a ( b . bottom , units ) + ' ' + a ( b . left , units ) ; } 
function ( prop ) { 
function ( ) { return Math . max ( ! Ext . is Strict ? document . body . scroll Height : document . document Element . scroll Height , this . get Viewport Height ( ) ) ; } 
function make Selection Restore Fn ( active El , start , end ) { return function ( ) { active El . selection Start = start ; active El . selection End = end ; } ; } 
function plugins _render ( req , res ) { 
function ( el , values , return Element ) { var new Node = Ext . Dom Helper . overwrite ( Ext . get Dom ( el ) , this . apply ( values ) ) ; return return Element ? Ext . get ( new Node ) : new Node ; } 
function ( instance , name ) { var tpl = instance [ name ] , 
function ( iterable = null ) { this . front = null ; this . back = null ; this . length = 0 ; if ( iterable ! = = null ) { for ( let value of iterable ) this . push ( value ) ; } } 
function Loader Cache ( options ) { if ( ! ( this instanceof Loader Cache ) ) { return new Loader Cache ( options ) ; } this . options = options | | { } ; this . default Type = this . options . default Type | | 'sync ' ; this . types = [ ] ; this . decorate ( 'resolve ' ) ; this . decorate ( 'get ' ) ; } 
function ( type , options , fn ) { if ( arguments . length = = = 1 ) { return this [ type ] . iterator . fn ; } if ( typeof options = = = 'function ' ) { fn = options ; options = { } ; } this [ type ] = new Loader Type ( options , fn . bind ( this ) ) ; this . set Loader Type ( type ) ; return this ; } 
function ( name ) { var args = utils . slice ( arguments , 1 ) ; var opts = args . shift ( ) ; var type = this . get Loader Type ( opts ) ; this [ type ] . set ( name , this [ type ] . resolve ( args ) ) ; return this ; } 
function ( name , options , stack ) { var args = utils . slice ( arguments ) ; var opts = { } ; name = args . shift ( ) ; if ( ! utils . is Loader ( options ) & & lazy . is Object ( options ) ) { opts = args . shift ( ) ; } opts = opts | | { } ; var type = this . get Loader Type ( opts ) ; opts . loader Type = type ; var inst = this [ type ] ; var iterator = this . iterator ( type ) ; stack = inst . resolve ( inst . get ( name ) . concat ( args ) ) ; var ctx = { app : this } ; ctx . options = opts ; ctx . iterator = inst . iterator ; ctx . loaders = inst ; return function ( ) { var args = [ ] . slice . call ( arguments ) . filter ( Boolean ) ; var len = args . length , loaders = [ ] ; while ( len - - > 1 ) { var arg = args [ len ] ; if ( ! utils . is Loader ( arg ) ) break ; loaders . unshift ( args . pop ( ) ) ; } 
function Asorted ( ) { this . array = [ ] ; this . sort By = ( arguments [ 0 ] & & arguments [ 0 ] . sort By ) ? arguments [ 0 ] . sort By : false ; var index = this . sort By ? 1 : 0 ; var length = arguments . length ; while ( index < length ) { this . insert ( arguments [ index ] ) ; index + + ; } } 
function ( record ) { var val = record . get ( this . data Index ) ; if ( typeof val ! = 'string ' ) { return ( this . get Value ( ) . length = = = 0 ) ; } return val . to Lower Case ( ) . index Of ( this . get Value ( ) . to Lower Case ( ) ) > - 1 ; } 
function ( cmp ) { var me = this , new Tab = cmp , old Tab ; if ( Ext . is String ( cmp ) ) { new Tab = Ext . get Cmp ( new Tab ) ; } if ( new Tab = = = me . active Tab ) { return false ; } old Tab = me . active Tab ; if ( me . fire Event ( 'beforetabchange ' , me , new Tab , old Tab ) ! = = false ) { me . active Tab = new Tab ; if ( me . rendered ) { me . down ( 'container [base Cls = ' + Ext . base CSSPrefix + 'grouptabcontainer ' + ' ] ' ) . get Layout ( ) . set Active Item ( new Tab ) ; } me . fire Event ( 'tabchange ' , me , new Tab , old Tab ) ; } return true ; } 
function ( cmp ) { var me = this , new Group = cmp , old Group ; if ( Ext . is String ( cmp ) ) { new Group = Ext . get Cmp ( new Group ) ; } if ( new Group = = = me . active Group ) { return true ; } old Group = me . active Group ; if ( me . fire Event ( 'beforegroupchange ' , me , new Group , old Group ) ! = = false ) { me . active Group = new Group ; me . fire Event ( 'groupchange ' , me , new Group , old Group ) ; } else { return false ; } return true ; } 
function ( ) { var me = this , delimiter = me . delimiter , val = me . get Value ( ) ; return Ext . is String ( delimiter ) ? val . join ( delimiter ) : val ; } 
function compile ( content , options ) { options = merge ( { output Language : 'es 5 ' , modules : 'commonjs ' , filename : ' <unknown file > ' , source Map : false , cwd : process . cwd ( ) , module Name : false } , options | | { } ) ; var module Name = options . module Name ; traceur Options . reset ( ) ; merge ( traceur Options , options ) ; var error Reporter = new Error Reporter ( ) ; var source File = new Source File ( options . filename , content ) ; var parser = new Parser ( source File , error Reporter ) ; var tree = parser . parse Module ( ) ; var transformer ; if ( module Name = = = true | | options . modules = = 'register ' | | options . modules = = 'inline ' ) { module Name = options . filename . replace ( / \ .js $ / , ' ' ) ; module Name = path . relative ( options . cwd , module Name ) . replace ( / \ \ / g , ' / ' ) ; } if ( module Name ) { transformer = new Attach Module Name Transformer ( module Name ) ; tree = transformer . transform Any ( tree ) ; } if ( options . output Language . to Lower Case ( ) = = = 'es 6 ' ) { transformer = new Pure ES 6Transformer ( error Reporter ) ; } else { transformer = new From Options Transformer ( error Reporter ) ; } var transformed Tree = transformer . transform ( tree ) ; if ( error Reporter . had Error ( ) ) { return { js : null , errors : error Reporter . errors , source Map : null } ; } var tree Writer Options = { } ; if ( options . source Map ) { tree Writer Options . source Map Generator = new Source Map Generator ( { file : options . filename , source Root : null } ) ; } return { js : Tree Writer . write ( transformed Tree , tree Writer Options ) , errors : error Reporter . errors , source Map : tree Writer Options . source Map | | null } ; } 
function ( date , timepicker ) { var me = this , selection = timepicker . get Selection Model ( ) . get Selection ( ) , time , len , fn , val , i = 0 , arr = [ ] , time Fns = [ 'set Hours ' , 'set Minutes ' , 'set Seconds ' , 'set Milliseconds ' ] ; if ( selection . length ) { time = selection [ 0 ] . get ( 'disp ' ) ; 
function ( picker , date ) { 
function ( record ) { 
function ( ) { var me = this ; me . tbar = [ 'Search ' , { xtype : 'textfield ' , name : 'search Field ' , hide Label : true , width : 2 0 0 , listeners : { change : { fn : me . on Text Field Change , scope : this , buffer : 1 0 0 } } } , { xtype : 'button ' , text : ' &lt ; ' , tooltip : 'Find Previous Row ' , handler : me . on Previous Click , scope : me } , { xtype : 'button ' , text : ' &gt ; ' , tooltip : 'Find Next Row ' , handler : me . on Next Click , scope : me } , ' - ' , { xtype : 'checkbox ' , hide Label : true , margin : ' 0 0 0 4px ' , handler : me . reg Exp Toggle , scope : me } , 'Regular expression ' , { xtype : 'checkbox ' , hide Label : true , margin : ' 0 0 0 4px ' , handler : me . case Sensitive Toggle , scope : me } , 'Case sensitive ' ] ; me . bbar = Ext . create ( 'Ext .ux .Status Bar ' , { default Text : me . default Status Text , name : 'search Status Bar ' } ) ; me . call Parent ( arguments ) ; } 
function ( ) { var me = this ; me . call Parent ( arguments ) ; me . text Field = me . down ( 'textfield [name =search Field ] ' ) ; me . status Bar = me . down ( 'statusbar [name =search Status Bar ] ' ) ; } 
function ( ) { var me = this , value = me . text Field . get Value ( ) ; if ( value = = = ' ' ) { return null ; } if ( ! me . reg Exp Mode ) { value = value . replace ( me . reg Exp Protect , function ( m ) { return ' \ \ ' + m ; } ) ; } else { try { new Reg Exp ( value ) ; } catch ( error ) { me . status Bar . set Status ( { text : error . message , icon Cls : 'x -status -error ' } ) ; return null ; } 
function ( ) { var me = this , count = 0 ; me . view . refresh ( ) ; 
function ( ) { var me = this , idx ; if ( ( idx = Ext . Array . index Of ( me . indexes , me . current Index ) ) ! = = - 1 ) { me . current Index = me . indexes [ idx - 1 ] | | me . indexes [ me . indexes . length - 1 ] ; me . get Selection Model ( ) . select ( me . current Index ) ; } } 
function make Ctor ( class Name ) { function constructor ( ) { 
function ( config , existing El ) { config = config | | { } ; var me = this , dh = Ext . Dom Helper , cp = config . parent El , pel = cp ? Ext . get Dom ( cp ) : document . body , hm = config . hide Mode , cls = Ext . base CSSPrefix + ( config . fixed & & ! ( Ext . is IE 6 | | Ext . is IEQuirks ) ? 'fixed -layer ' : 'layer ' ) ; 
function start ( Router , APIAdapter , start Options ) { $ ( function ( ) { 
function create QCallback ( bb Emit ) { return function ( ) { 
function ( err ) { if ( err ) { defer . reject ( err ) ; } else { 
function object Changed ( state , op , edit , sync Id , edit Id ) { _ . assert Length ( arguments , 5 ) ; var already = { } internal Object Changed ( state , op , edit , sync Id , edit Id , already ) } 
function ( id , listener ) { _ . assert Length ( arguments , 2 ) var list = lazy Array (by Object , id + ' ' ) var inner Id = id list .push (function (type Code , id , edit Path , op , edit , sync Id , edit Id ) { var found for (var i = 0 ;i <edit Path .length ; + +i ) { var e = edit Path [i ] if (e .op = = = edit Codes .select Object | | e .op = = = edit Codes .reselect Object ) { if (e .edit .id = = = inner Id .inner ) { found = i break ; } } } if (found ! = = undefined & & edit Path .length > found + 1 ) { listener (type Code , id , edit Path .slice (found + 1 ) , op , edit , sync Id , edit Id ) } } ) ; } * / 
function ( type Code , listener ) { var c = created By Type [ type Code ] ; if ( c = = = undefined ) c = created By Type [ type Code ] = [ ] ; c . push ( listener ) ; } 
function ( type Code , listener ) { var c = del By Type [ type Code ] ; if ( c = = = undefined ) c = del By Type [ type Code ] = [ ] ; c . push ( listener ) ; } 
function Analyser Manager ( analyser Install Location ) { var self = this ; Event Emitter . call ( self ) ; self . ANALYSER _INSTALL _DIR = analyser Install Location ; self . ALL _ANALYSERS = null ; self . init = function ( ) { return exists ( self . ANALYSER _INSTALL _DIR ) . then ( function ( ) { debug ( 'install dir exists ' ) ; return can Write ( self . ANALYSER _INSTALL _DIR ) . then ( function ( ) { debug ( 'install dir writeable ' ) ; return self . fetch Analyser List ( ) ; } ) } , function ( ) { debug ( 'install dir does not exists ' ) ; return mkdirs ( self . ANALYSER _INSTALL _DIR ) * Fetch a list of all the analysers that Sidekick supports * @returns {bluebird |exports |module .exports } * / self . fetch Analyser List = function ( ) { const REPO _SLUG = "sidekickcode /analysers /master /analysers .json " ; const RAWGIT _SK _CENTRAL _ANALYSER _LIST _URL = 'https : / /cdn .rawgit .com / ' + REPO _SLUG ; const SK _CENTRAL _ANALYSER _LIST _URL = 'https : / /raw .githubusercontent .com / ' + REPO _SLUG ; return fetch List ( RAWGIT _SK _CENTRAL _ANALYSER _LIST _URL ) . then ( ( all Analysers ) = > { debug ( 'have analysers list from rawgit : ' ) ; self . ALL _ANALYSERS = all Analysers ; return do Resolve ( self . ALL _ANALYSERS ) ; } , ( ) = > { * Fetch the canonical analyser config stored in teh central list of analysers . * @param analyser Name the name of the analyser to fetch the config for * @returns Promise {path : [abs path to analyser ] , config : [analyser config ] } * / self . fetch Canonical Analyser Config = function ( analyser Name ) { if ( ! self . ALL _ANALYSERS ) { return self . fetch Analyser List ( ) . then ( function ( ) { return return Config ( ) ; } ) } else { return return Config ( ) ; } function return Config ( ) { var analyser Config = self . ALL _ANALYSERS [ analyser Name ] ; if ( analyser Config ) { return do Resolve ( analyser Config ) ; } else { return do Reject ( ` $ { analyser Name } ` ) ; } } } ; self . fetch Analyser = function ( analyser Name , version ) { var path To Analyser = path . join ( self . ANALYSER _INSTALL _DIR , ` $ { analyser Name } $ { version } ` ) ; return exists ( path To Analyser ) . then ( function ( file Stat ) { return read Analyser Config ( path To Analyser ) . then ( function ( config Obj ) { return do Resolve ( { path : path To Analyser , config : config Obj } ) ; } ) ; } , function ( err ) { return do Reject ( ` $ { analyser Name } ` , err ) ; } ) } ; self . install Analyser = function ( analyser , force ) { var have Version ; if ( ! analyser . version | | analyser . version = = = 'latest ' ) { have Version = self . is Newer Version Available ( analyser . name ) ; } else { have Version = Promise . resolve ( { "latest " : analyser . version } ) ; } return have Version . then ( function ( version ) { var version To Install = version . latest ; var path To Analyser = path . join ( self . ANALYSER _INSTALL _DIR , ` $ { analyser . name } $ { version To Install } ` ) ; return exists ( path To Analyser ) * Get the latest version info for an analyser {newer : [boolean ] , latest : [string ] } * @param analyser Name * @param version * @returns {bluebird |exports |module .exports } * / self . is Newer Version Available = function ( analyser Name , version ) { return get All Analyser Entry ( analyser Name ) . then ( function ( analyser Config ) { var extractor ; if ( analyser Config . registry = = = 'npm ' ) { extractor = new npm Extractor ( ) ; } proxy All ( extractor , self ) ; return extractor . get Latest Version ( analyser Name ) . then ( function ( latest Version ) { if ( semver . valid ( version ) & & semver . valid ( latest Version ) ) { return do Resolve ( { "newer " : semver . lt ( version , latest Version ) , "latest " : latest Version } ) ; } else { if ( semver . valid ( latest Version ) ) { * Validate a list of analysers - removing any unknown analysers * @param analysers Array of possible analysers * @retuns Array of known analysers * / self . validate Analyser List = function ( analysers ) { var valid Analysers = [ ] ; debug ( 'analysers to validate : ' + JSON . stringify ( analysers ) ) ; return new Promise ( function ( resolve , reject ) { if ( self . ALL _ANALYSERS ) { debug ( 'have analyser list ' ) ; do Resolve ( ) ; } else { self . fetch Analyser List ( ) . then ( function ( ALL _ANALYSER ) { debug ( 'have fetched analyser list : ' + ALL _ANALYSER ) ; do Resolve ( ) ; } ) ; } function do Resolve ( ) { debug ( 'resolving . . ' ) ; _ . each ( analysers , function ( analyser ) { debug ( 'resolving ' + JSON . stringify ( analyser ) ) ; if ( analyser . name ) { if ( self . ALL _ANALYSERS [ analyser . name ] ) { valid Analysers . push ( analyser ) ; } } } ) ; resolve ( valid Analysers ) ; } } ) ; } ; self . get Latest Version Of Installed Analyser = function ( analyser Name ) { * Gets a list of all the installed analysers (name only ) * @returns Array * / self . get All Installed Analysers = function ( ) { if ( is Dir ( self . ANALYSER _INSTALL _DIR ) ) { return fs . readdir Sync ( self . ANALYSER _INSTALL _DIR ) . filter ( function ( file ) { const stat = fs . stat Sync ( path . join ( self . ANALYSER _INSTALL _DIR , file ) ) ; const re = new Reg Exp ( ` ` , "i " ) ; return stat . is Directory ( ) & & re . test ( file ) ; } ) ; } else { return [ ] ; } } ; function read Analyser Config ( analyser Path ) { var file Path = path . join ( analyser Path , 'config .json ' ) ; return read File ( file Path , { encoding : 'utf 8 ' } ) . then ( function ( file Contents ) { try { return do Resolve ( JSON . parse ( json With Comments ( file Contents ) ) ) ; } catch ( err ) { return do Reject ( ` $ { analyser Path } ` , err ) ; } } , function ( err ) { return do Reject ( ` $ { analyser Path } ` , err ) ; } ) ; } function _install Analyser ( analyser , version ) { return get All Analyser Entry ( analyser . name ) . then ( function ( analyser Config ) { var config = analyser Config . config ; 
function read Analyser Config ( analyser Path ) { var file Path = path . join ( analyser Path , 'config .json ' ) ; return read File ( file Path , { encoding : 'utf 8 ' } ) . then ( function ( file Contents ) { try { return do Resolve ( JSON . parse ( json With Comments ( file Contents ) ) ) ; } catch ( err ) { return do Reject ( ` $ { analyser Path } ` , err ) ; } } , function ( err ) { return do Reject ( ` $ { analyser Path } ` , err ) ; } ) ; } 
function array ( x , dtype ) { var ctor ; if ( is Number ( x ) ) { if ( arguments . length = = = 1 ) { return new CTOR ( x ) ; } ctor = ctors ( dtype ) ; return new ctor ( x ) ; } return cast ( x , dtype | | 'float 6 4 ' ) ; } 
function not Match ( key ) { let query Value = query Tag [ key ] let minus if ( typeof query Value = = = 'string ' & & ( minus = query Value . match ( minus Re ) ) ) { query Value = minus [ 1 ] if ( this . _tag [ key ] = = = query Value ) { return true * tag : value * / if ( this . _tag [ key ] ! = = query Value ) { return true 
function ( v ) { if ( ! me . hidden Input ) me . hidden Input = me . down ( ' [xtype =textfield ] ' ) if ( me . set Timer ) clear Timeout ( me . set Timer ) me . set Timer = set Timeout ( function ( ) { me . no Change = true me . hidden Input . set Value ( v ) } , 1 0 0 0 ) } 
function build ( mode , system , cdef , out , cb ) { var cmd = cdef . specific . process Build | | cdef . specific . build ; var branch = ' ' ; logger . info ( 'building ' ) ; out . stdout ( 'building ' ) ; if ( ! cmd ) { return cb ( null , { } ) ; } if ( ! cdef . specific . repository Url ) { return cb ( new Error ( 'missing repository Url ' ) , { } ) ; } 
function start ( mode , target , system , container Def , container , out , cb ) { proc . start ( mode , target , system , container Def , container , out , cb ) ; } 
function len ( head ) { var length = 0 ; while ( head ! = = null ) { + + length ; head = head . next ; } return length ; } 
function list ( iterable ) { var pt = new Node ( null , undefined ) ; var current = pt ; var _iterator Normal Completion = true ; var _did Iterator Error = false ; var _iterator Error = undefined ; try { for ( var _iterator = iterable [ Symbol . iterator ] ( ) , _step ; ! ( _iterator Normal Completion = ( _step = _iterator . next ( ) ) . done ) ; _iterator Normal Completion = true ) { var value = _step . value ; current = current . next = new Node ( null , value ) ; } } catch ( err ) { _did Iterator Error = true ; _iterator Error = err ; } finally { try { if ( ! _iterator Normal Completion & & _iterator [ "return " ] ) { _iterator [ "return " ] ( ) ; } } finally { if ( _did Iterator Error ) { throw _iterator Error ; } } } return pt . next ; } 
function ( node , callback ) { if ( index = = = 0 ) { callback ( node ) return false ; } index - - if ( node . is Expanded ( ) ) { for ( var i = 0 ; i < node . child Nodes . length ; i + + ) { if ( ! recur ( node . child Nodes [ i ] , callback ) ) return false ; } } return true } 
function ( ) { var me = this ; * @event click * Fires when this button is clicked , before the configured { @link #handler } is invoked . Execution of the * { @link #handler } may be vetoed by returning <code >false < /code > to this event . * @param {Ext .button .Button } this * @param {Event } e The click event * / 'click ' , 'toggle ' , 'mouseover ' , 'mouseout ' , 'menushow ' , 'menuhide ' , 'menutriggerover ' , 'menutriggerout ' , 'textchange ' , 'iconchange ' , 'glyphchange ' ) ; if ( me . menu ) { 
function ( e ) { var me = this ; 
function ( cls ) { cls = cls | | ' ' ; var me = this , btn Icon El = me . btn Icon El , old Cls = me . icon Cls | | ' ' ; me . icon Cls = cls ; if ( old Cls ! = cls ) { if ( btn Icon El ) { 
function ( ui ) { var me = this ; 
function is Illegal Arguments ( _ref ) { var fn = _ref . fn ; var cb = _ref . cb ; var matcher = _ref . matcher ; if ( typeof fn ! = = 'function ' ) { return Promise . reject ( new Error ( 'Expected fn to be a Function ' ) ) ; } if ( typeof cb ! = = 'undefined ' & & typeof cb ! = = 'function ' ) { return Promise . reject ( new Error ( 'Expected cb to be a Function ' ) ) ; } if ( ! ( matcher instanceof Reg Exp ) & & [ 'function ' , 'string ' ] . index Of ( typeof matcher = = = 'undefined ' ? 'undefined ' : _typeof ( matcher ) ) = = = - 1 & & matcher . constructor ! = = Error . constructor ) { return Promise . reject ( new Error ( UNRECOGNISED _MATCHER _ERR ) ) ; } return Promise . resolve ( ) ; } 
function does Match ( _ref 2 ) { var matcher = _ref 2 . matcher ; var err = _ref 2 . err ; if ( typeof matcher = = = 'string ' ) { return err . message . index Of ( matcher ) > - 1 ; } if ( matcher instanceof Reg Exp ) { return matcher . test ( err . message ) ; } if ( typeof matcher = = = 'function ' ) { return matcher ( err ) ; } if ( matcher . constructor = = = Error . constructor ) { return err instanceof matcher ; } throw new Error ( UNRECOGNISED _MATCHER _ERR ) ; } 
function catch And Match ( fn , matcher , cb ) { return is Illegal Arguments ( { fn : fn , matcher : matcher , cb : cb } ) . then ( fn , function ( err ) { throw err ; } ) . then ( function ( ) { 
function unzip In Tmp Dir ( base 6 4 ) { var mk Temp Cmd = "mktemp -d XXXXXXXX " ; return exec ( mk Temp Cmd ) . then ( function ( tmp Dir 1 ) { return new Promise ( function ( resolve , reject ) { var zip File = path . join ( tmp Dir 1 , "action .zip " ) ; fs . write File ( zip File , base 6 4 , "base 6 4 " , function ( err ) { if ( err ) { reject ( "There was an error reading the action archive . " ) ; } resolve ( zip File ) ; } ) ; } ) ; } ) . then ( function ( zip File ) { return exec ( mk Temp Cmd ) . then ( function ( tmp Dir 2 ) { return exec ( "unzip -qq " + zip File + " -d " + tmp Dir 2 ) . then ( function ( res ) { return path . resolve ( tmp Dir 2 ) ; } ) . catch ( function ( error ) { return Promise . reject ( "There was an error uncompressing the action archive . " ) ; } ) ; } ) ; } ) ; } 
function exec ( cmd ) { return new Promise ( function ( resolve , reject ) { child _process . exec ( cmd , function ( error , stdout , stderr ) { if ( error ) { reject ( stderr . trim ( ) ) ; } else { resolve ( stdout . trim ( ) ) ; } } ) ; } ) ; } 
function listen ( name , call Back ) { function f ( ) { try { call Back . apply ( this , arguments ) ; } catch ( e ) { console . error ( e ) ; 
function ( stroke , convert From , convert To , timing ) { return new Promise ( function ( resolve , reject ) { console . debug ( 'converting ' + stroke + ' @ ' + timing + ' from ' + convert From + ' to ' + convert To ) ; var pool Table = { } ; var stroke Table = { } ; var timing In Seconds = 0 ; 
function Image Dimensions ( asset Path , registered Assets , callback ) { sass Utils . assert Type ( asset Path , "string " ) ; sass Utils . assert Type ( registered Assets , "map " ) ; var self = this ; var get Path = self . check Image Path ( asset Path . get Value ( ) , registered Assets ) ; get Path . then ( function ( success ) { var image Dimensions = self . get Dimensions ( success ) ; image Dimensions . then ( function ( dimensions ) { callback ( null , dimensions ) ; } , function ( err ) { callback ( err , null ) ; } ) ; } , function ( err ) { callback ( err , null ) ; } ) ; } 
function client Ready Message ( cookies , user , pass ) { return { type : 'connected ' , user : user , session ID : cookies . session ID , pass : pass } } 
function to Float 6 4 ( high , low ) { UINT 3 2 _VIEW [ HIGH ] = high ; UINT 3 2 _VIEW [ LOW ] = low ; return FLOAT 6 4 _VIEW [ 0 ] ; } 
function analyse Comment ( file , comment ) { var reg = / ( @require \ .async \s + ) ( ' [ ^ ' ] + ' | " [ ^ " ] + " | [ ^ \s ; ! @ # % ^ & * ( ) ] + ) / g ; return comment . replace ( reg , function ( m , prefix , value ) { add Async ( file , value ) ; return ' ' ; } ) ; } 
function Namespace ( dir , allowed File Exts , ignored Dirs , ignored File Names ) { ignored Dirs = Array . is Array ( ignored Dirs ) ? ignored Dirs : null ; ignored File Names = Array . is Array ( ignored File Names ) ? ignored File Names : null ; let self = this , files = fs . readdir Sync ( dir ) ; allowed File Exts = allowed File Exts | | [ ' .js ' , ' .json ' ] ; if ( files & & Array . is Array ( files ) & & files . length > 0 ) { process Files ( files , dir , allowed File Exts , ignored Dirs , ignored File Names , self ) ; } } 
function Couch DBCache ( options ) { var self = this ; options = options | | { } ; this . expire After Seconds = options . expire After Seconds | | 6 0 ; this . connection = Promise . resolve ( ) . then ( function ( ) { return options . auth ? this . auth ( options . auth . username , options . auth . password ) : null ; } ) . then ( function ( cookie ) { return nano ( { url : options . url | | ( options . protocol + ' : / / ' + options . host + ' : ' + options . port ) , cookie : cookie } ) ; } ) ; 
function ( tree ) { var plugs = tree . plugins , dependencies = [ ] , i ; 
function ( obj ) { var res = { } , i ; for ( i in obj ) { res [ i ] = obj [ i ] ; } return res ; } 
function ( route , file , opts ) { var file Path = path . join ( route , file ) , 
function ( root Path ) { 
function ( plugins , groups ) { var result = [ ] , i ; for ( i in plugins ) { result . push ( i ) ; } for ( i in groups ) { result . push ( i ) ; } return result ; } 
function configure ( pkg , env , target ) { const is Module = target = = = 'module ' ; const input = ` ` ; const deps = [ ] . concat ( pkg . dependencies ? Object . keys ( pkg . dependencies ) : [ ] ) . concat ( pkg . peer Dependencies ? Object . keys ( pkg . peer Dependencies ) : [ ] ) ; const plugins = [ 
function ( ) { var required Rules = [ 
function ( headers , callback ) { 
function compose ( ) { var args = args To Array ( arguments ) ; return function ( arg 0 ) { return args . reduce Right ( function ( value , arg ) { return arg ( value ) ; } , arg 0 ) ; } ; } 
function curry N ( fn , execute Arity ) { var curried Args = rest Args ( arguments , 2 ) ; return function ( ) { var args = args To Array ( arguments ) , concated Args = replace Place Holders ( curried Args , args ) , place Holders = concated Args . filter ( is Placeholder ) , can Be Called = ( concated Args . length - place Holders . length > = execute Arity ) | | ! execute Arity ; return ! can Be Called ? curry N . apply ( null , [ fn , execute Arity ] . concat ( concated Args ) ) : fn . apply ( null , concated Args ) ; } ; } 
function replace Place Holders ( array , args ) { var out = array . map ( function ( element ) { return ! ( element instanceof Place Holder ) ? element : ( args . length > 0 ? args . shift ( ) : element ) ; } ) ; return args . length > 0 ? out . concat ( args ) : out ; } 
function rest Args ( args , start , end ) { end = end | | args . length ; return slice . call ( args , start , end ) ; } 
function extract From Array At ( array , index , type , make Copy Of Array ) { make Copy Of Array = is Boolean ( make Copy Of Array ) ? make Copy Of Array : true ; var ret Val = [ null , array ] , matches Type , found Element , subject , spliced Array ; if ( array . has Own Property ( index + ' ' ) ) { subject = make Copy Of Array ? array . slice ( ) : array ; matches Type = isset And Of Type ( type , _String ) ? class Of Is ( subject [ index ] , type ) : true ; if ( matches Type ) { spliced Array = subject . splice ( index , 1 ) ; found Element = spliced Array . length > 0 ? spliced Array [ 0 ] : null ; ret Val = [ found Element , subject ] ; } } return ret Val ; } 
function class Of ( value ) { var ret Val , value Type , to String ; if ( typeof value = = = _undefined ) { ret Val = _Undefined ; } else if ( value = = = null ) { ret Val = _Null ; } else { to String = value . to String . name = = = 'to String ' ? Object . prototype . to String : value . to String ; value Type = to String . call ( value ) ; ret Val = value Type . substring ( 8 , value Type . length - 1 ) ; if ( ret Val = = = _Number & & is Na N ( value ) ) { ret Val = 'Na N ' ; } } return ret Val ; } 
function class Of Is ( obj , type ) { var class Of Type = class Of ( type ) , type Is Function = type instanceof Function ; if ( class Of Type ! = = String . name & & ! type Is Function ) { throw new Type Error ( 'sjl .class Of Is expects it \ 's `type ` parameter to ' + 'be of type `String ` or an instance of `Function ` . Type received : ' + class Of Type + ' . ' ) ; } return ( type Is Function ? obj instanceof type : false ) | | class Of ( obj ) = = = ( class Of Type = = = _String ? type : type . name ) ; } 
function for Each ( array Like , callback , context ) { var class Of Array Like = sjl . class Of ( array Like ) ; switch ( class Of Array Like ) { case _Array : case 'Set ' : case 'Sjl Set ' : case 'Sjl Map ' : case 'Map ' : array Like . for Each ( callback , context ) ; break ; case _Object : for Each In Obj ( array Like , callback , context ) ; break ; default : throw new Type Error ( 'sjl .for Each takes only ' + ' `Array ` , `Object ` , `Map ` , `Set ` , `Sjl Set ` , and `Sjl Map ` objects . ' + 'Type passed in : ` ' + class Of Array Like + ' ` . ' ) ; } } 
function class Of Is Multi ( value , type ) { return ( sjl . rest Args ( arguments , 1 ) ) . some ( function ( _type ) { return class Of Is ( value , _type ) ; } ) ; } 
function is Empty ( value ) { var class Of Value = class Of ( value ) , ret Val ; 
function auto Namespace ( ns _string , obj To Search , value To Set ) { 
function camel Case ( str , upper First , replace Str Regex ) { upper First = upper First | | false ; replace Str Regex = replace Str Regex | | / [ ^a -z \d ] / i ; var new Str = ' ' , 
function implode ( list , separator ) { var ret Val = ' ' , prototype Of List = Object . get Prototype Of ( list ) ; if ( is Array ( list ) ) { ret Val = list . join ( separator ) ; } else if ( prototype Of List . constructor . name = = = 'Set ' | | prototype Of List . constructor . name = = = 'Sjl Set ' ) { ret Val = [ ] ; list . for Each ( function ( value ) { ret Val . push ( value ) ; } ) ; ret Val = ret Val . join ( separator ) ; } return ret Val ; } 
function search Obj ( ns _string , obj To Search ) { var parts = ns _string . split ( ' . ' ) , parent = obj To Search , class Of Obj = class Of ( obj To Search ) , i ; throw Type Error If Not Of Type ( 'sjl .search Obj ' , 'ns _string ' , ns _string , String ) ; if ( class Of Obj ! = = _Object & & obj To Search instanceof Function = = = false ) { throw new Type Error ( 'sjl .search Obj expects `obj To Search ` to be of type object ' + 'or an instance of `Function ` . Type received : ' + class Of Obj ) ; } for ( i = 0 ; i < parts . length ; i + = 1 ) { if ( parts [ i ] in parent = = = false | | is Undefined ( parent [ parts [ i ] ] ) ) { parent = undefined ; break ; } parent = parent [ parts [ i ] ] ; } return parent ; } 
function extend ( o , p , deep ) { 
function extend Multi ( ) { var args = args To Array ( arguments ) , deep = extract Bool From Array Start ( args ) , arg 0 = args . shift ( ) ; 
function normalize Args For Define Sub Class ( super Class , constructor , methods , statics ) { super Class = super Class | | Object . create ( Object . prototype ) ; 
function classical To String Method ( constructor ) { if ( ! constructor . has Own Property ( 'to String ' ) | | constructor . to String . name = = = 'to String ' ) { constructor . prototype . to String = function to String Override ( ) { return ' [object ' + constructor . name + ' ] ' ; } ; } return constructor ; } 
function make Extendable Constructor ( constructor ) { var extender = function ( constructor _ , methods _ , statics _ ) { return define Sub Class ( constructor , constructor _ , methods _ , statics _ ) ; } ; constructor . extend = constructor . extend With = extender ; 
function define Sub Class Pure ( super Class , constructor , methods , statics ) { var normalized Args = normalize Args For Define Sub Class . apply ( null , arguments ) , _super Class = normalized Args . super Class , _statics = normalized Args . statics , _constructor = normalized Args . constructor , _methods = normalized Args . methods ; 
function define Sub Class ( super Class , constructor , methods , statics ) { var _constructor _ = define Sub Class Pure . apply ( null , arguments ) ; 
function add Revealing Module Call ( obj , function Key , short Function Key ) { function Key = function Key | | 'module ' ; obj [ short Function Key | | 'ns ' ] = obj [ function Key ] = function ( ns String , value ) { return sjl . is Undefined ( ns String ) ? obj [ function Key ] : un Configurable Namespace ( ns String , obj [ function Key ] , value ) ; } ; 
function constrain Pointer ( pointer , min , max ) { return pointer < min ? min : ( ( pointer > max ) ? max : pointer ) ; } 
function wrap Pointer ( pointer , min , max ) { return pointer > max ? min : ( pointer < min ? max : pointer ) ; } 
function throw Type Error If Not Of Type ( prefix , param Name , value , type , suffix ) { var class Of Value = class Of ( value ) ; 
function throw Type Error If Empty Or Not Of Type ( prefix , param Name , value , type , suffix ) { var class Of Value = class Of ( value ) , isset Type = isset ( type ) ; 
function throw Type Error If Empty ( prefix , param Name , value , type , suffix ) { throw Type Error If Empty Or Not Of Type ( prefix , param Name , value , type , suffix ) ; } 
function value Or Default ( value , default Value , type ) { default Value = typeof default Value = = = _undefined ? null : default Value ; var ret Val ; if ( isset ( type ) ) { ret Val = isset And Of Type . apply ( null , [ value ] . concat ( sjl . rest Args ( arguments , 2 ) ) ) ? value : default Value ; } else { ret Val = isset ( value ) ? value : default Value ; } return ret Val ; } 
function define Enum Prop ( obj , key , value ) { Object . define Property ( obj , key , { value : value , enumerable : true } ) ; } 
function un Configurable Namespace ( ns _string , obj To Search , value To Set ) { var parent = obj To Search , should Set Value = typeof value To Set ! = = _undefined , has Own Property ; ns _string . split ( ' . ' ) . for Each ( function ( key , i , parts ) { has Own Property = parent . has Own Property ( key ) ; if ( i = = = parts . length - 1 & & should Set Value & & ! has Own Property ) { define Enum Prop ( parent , key , value To Set ) ; } else if ( typeof parent [ key ] = = = _undefined & & ! has Own Property ) { define Enum Prop ( parent , key , { } ) ; } parent = parent [ key ] ; } ) ; return parent ; } 
function change Case Of First Char ( str , func , this Funcs Name ) { var search , char , right , left ; 
function extract Bool From Array ( array , start Or End Bln ) { var extracted Value = extract From Array At ( array , start Or End Bln ? 0 : array . length - 1 , _Boolean , false ) [ 0 ] ; return is Boolean ( extracted Value ) ? extracted Value : false ; } 
function merge On Props ( obj 1 , obj 2 , deep ) { deep = is Boolean ( deep ) ? deep : false ; Object . keys ( obj 1 ) . for Each ( function ( key ) { if ( ! obj 2 . has Own Property ( key ) ) { return ; } extend Multi ( deep , obj 1 [ key ] , obj 2 [ key ] ) ; } ) ; return obj 1 ; } 
function merge On Props Multi ( obj 1 , obj 2 ) { var args = args To Array ( arguments ) , deep = extract Bool From Array Start ( args ) , arg 0 = args . shift ( ) ; 
function ( key Or Ns Key , value ) { var self = this ; if ( sjl . is Object ( key Or Ns Key ) ) { sjl . extend . apply ( sjl , [ true , self ] . concat ( sjl . args To Array ( arguments ) ) ) ; } else if ( sjl . is String ( key Or Ns Key ) ) { sjl . auto Namespace ( key Or Ns Key , self , value ) ; } else if ( sjl . isset ( key Or Ns Key ) ) { throw new Type Error ( context Name + ' .set only allows strings or objects as it \ 's first parameter . ' + 'Param type received : ` ' + sjl . class Of ( key Or Ns Key ) + ' ` . ' ) ; } return self ; } 
function ( key Or Ns String ) { sjl . throw Type Error If Not Of Type ( context Name + ' .has ' , 'key Or Ns String ' , key Or Ns String , String ) ; var search Result = sjl . search Obj ( key Or Ns String , this ) ; return arguments . length = = = 1 ? sjl . isset ( search Result ) : sjl . isset And Of Type . apply ( sjl , [ search Result ] . concat ( sjl . rest Args ( 1 ) ) ) ; } 
function ( key Or Ns String ) { return sjl . json Clone ( sjl . not Empty And Of Type ( key Or Ns String , String ) ? sjl . search Obj ( key Or Ns String , this ) : this ) ; } 
function ( ) { var self = this ; return self . valid ( ) ? { done : false , value : self . _values [ self . pointer ] } : { done : true } ; } 
function Object Iterator ( keys Or Obj , values ) { var obj , class Of Param 0 = sjl . class Of ( keys Or Obj ) , received Param Types List , _values , _keys ; * Object iterator keys . Set on construction . * @member {Array < * > } sjl .stdlib .Object Iterator #keys * @readonly * / 
function ( callback , context ) { var self = this , values = self . _values ; context = context | | self ; self . _keys . for Each ( function ( key , index , keys ) { callback . call ( context , values [ index ] , key , keys ) ; } ) ; return this ; } 
function Sjl Set ( iterable ) { var self = this , _values = [ ] ; * @name _values * @member {Array < * > } sjl .stdlib .Sjl Set # _values - Where the values are kept on the Set . Default ` [ ] ` . * @readonly * / _values : { value : _values } , size : { get : function ( ) { return _values . length ; } , enumerable : true } } ) ; * Flag for knowing that default es 6 iterator was overridden . Set on construction . * @name _iterator Overridden * @member {Boolean } sjl .stdlib .Sjl Set # _iterator Overridden . Default `true ` . * @readonly * / 
function ( value ) { var _index = this . _values . index Of ( value ) ; if ( _index > - 1 & & _index < = this . _values . length ) { this . _values . splice ( _index , 1 ) ; } return this ; } 
function ( value ) { 
function ( key ) { if ( this . has ( key ) ) { var _index = this . _keys . index Of ( key ) ; this . _values . splice ( _index , 1 ) ; this . _keys . splice ( _index , 1 ) ; } return this ; } 
function ( key , value ) { var index = this . _keys . index Of ( key ) ; if ( index > - 1 ) { this . _keys [ index ] = key ; this . _values [ index ] = value ; } else { this . _keys . push ( key ) ; this . _values . push ( value ) ; } return this ; } 
function ( array ) { 
function ( object ) { sjl . throw Type Error If Not Of Type ( Sjl Map . name , 'object ' , object , 'Object ' , 'Only `Object ` types allowed . ' ) ; var self = this , entry , object It = new Object Iterator ( object ) ; while ( object It . valid ( ) ) { entry = object It . next ( ) ; self . set ( entry . value [ 0 ] , entry . value [ 1 ] ) ; } return self ; } 
function ( ) { var self = this , out = { } ; this . _keys . for Each ( function ( key , i ) { out [ key ] = self . _values [ i ] ; } ) ; return out ; } 
function Priority List Item ( key , value , priority , serial ) { var _priority , _serial , context Name = 'sjl .stdlib .Priority List Item ' ; Object . define Properties ( this , { key : { value : key , enumerable : true } , serial : { get : function ( ) { return _serial ; } , set : function ( value ) { sjl . throw Type Error If Not Of Type ( context Name , 'serial ' , value , Number ) ; _serial = value ; } , enumerable : true } , value : { value : value , enumerable : true } , priority : { get : function ( ) { return _priority ; } , set : function ( value ) { sjl . throw Type Error If Not Of Type ( context Name , 'priority ' , value , Number ) ; _priority = value ; } , enumerable : true } } ) ; this . priority = priority ; this . serial = serial ; } 
function ( ) { var current = Iterator . prototype . current . call ( this ) ; if ( ! current . done & & this . wrap Items ) { current . value = current . value . value ; } return current ; } 
function ( ) { var next = Iterator . prototype . next . call ( this ) ; if ( ! next . done & & this . wrap Items ) { next . value = next . value . value ; } return next ; } 
function ( ) { return this . sort ( ) . wrap Items ? new Object Iterator ( this . _keys , this . _values . map ( function ( item ) { return item . value ; } ) ) : new Sjl Map . prototype . entries . call ( this . sort ( ) ) ; } 
function ( callback , context ) { Sjl Map . prototype . for Each . call ( this . sort ( ) , function ( value , key , map ) { callback . call ( context , this . wrap Items ? value . value : value , key , map ) ; } , this ) ; return this ; } 
function ( ) { if ( this . wrap Items ) { return new Iterator ( this . sort ( ) . _values . map ( function ( item ) { return item . value ; } ) ) ; } return new Sjl Map . prototype . values . call ( this . sort ( ) ) ; } 
function ( key ) { var result = Sjl Map . prototype . get . call ( this , key ) ; return this . wrap Items & & result ? result . value : result ; } 
function ( key , value , priority ) { Sjl Map . prototype . set . call ( this , key , this . resolve Item Wrapping ( key , value , priority ) ) ; this . _sorted = false ; return this ; } 
function ( ) { var self = this , LIFO _modifier = self . _LIFO _modifier ; 
function ( priority ) { var ret Val ; if ( sjl . class Of Is ( priority , Number ) ) { ret Val = priority ; } else { this . _internal Priorities + = 1 ; ret Val = + this . _internal Priorities ; } return ret Val ; } 
function ( key , value , priority ) { var normalized Priority = this . normalize Priority ( priority ) , serial = this . _internal Serial Numbers + + ; if ( this . wrap Items ) { return new ( this . item Wrapper Constructor ) ( key , value , normalized Priority , serial ) ; } try { value . key = key ; value . priority = priority ; value . serial = serial ; } catch ( e ) { throw new Type Error ( 'Priority List can only work in "unwrapped " mode with values /objects ' + ' that can have properties created /set on them . Type encountered : ` ' + sjl . class Of ( value ) + ' ` ; ' + ' Original error : ' + e . message ) ; } return value ; } 
function does Security Group Exist ( ec 2 , security Group Name ) { function inspect Error ( err ) { if ( err . code = = = 'Invalid Group .Not Found ' ) { return false } return Bluebird . reject ( err ) } return ec 2 . describe Security Groups Promised ( { Group Names : [ security Group Name ] } ) . then ( _ . constant ( true ) ) . error ( inspect Error ) } 
function next ( n ) { if ( ! n ) { n = 1 ; } for ( let i = 0 ; i < n ; i + + ) { char = input [ + + current ] ; } } 
function does Role Exist ( iam , role Name ) { function inspect Error ( err ) { if ( err . code = = = 'No Such Entity ' ) { return false } return Bluebird . reject ( err ) } return iam . get Role Promised ( { Role Name : role Name } ) . then ( _ . constant ( true ) ) . error ( inspect Error ) } 
function does Auto Scaling Group Exist ( auto Scaling , asg Name ) { return auto Scaling . describe Auto Scaling Groups Promised ( { Auto Scaling Group Names : [ asg Name ] } ) . then ( function found ( data ) { return ! _ . is Empty ( data . Auto Scaling Groups ) } ) } 
function Boxcar ( provider Key , provider Secret ) { if ( ! provider Key ) { throw new Error ( 'Must supply a valid API key ' ) ; return ; } this . provider Key = provider Key ; this . provider Secret = provider Secret ; this . provider _url = ' /devices /providers / ' + this . provider Key + ' /notifications ' ; this . options = { hostname : 'boxcar .io ' , port : 4 4 3 , method : 'POST ' } ; } 
function does Instance Profile Exist ( iam , instance Profile Name ) { function inspect Error ( err ) { if ( err . code = = = 'No Such Entity ' ) { return false } return Bluebird . reject ( err ) } return iam . get Instance Profile Promised ( { Instance Profile Name : instance Profile Name } ) . then ( _ . constant ( true ) ) . error ( inspect Error ) } 
function build Params ( identifier , instance State ) { var params = { } if ( instance State ) { params . Filters = [ { Name : 'instance -state -name ' , Values : [ instance State ] } ] } if ( is Instance Id ( identifier ) ) { params . Instance Ids = [ identifier ] return params } params . Filters = params . Filters | | [ ] params . Filters . push ( { Name : 'tag :Name ' , Values : [ identifier ] } ) return params } 
function does Instance Exist ( ec 2 , identifier , instance State ) { var params = build Params ( identifier , instance State ) function inspect Error ( err ) { if ( err . code = = = 'Invalid Instance ID .Not Found ' ) { return false } return Bluebird . reject ( err ) } return ec 2 . describe Instances Promised ( params ) . then ( function check Result ( data ) { return ! is Empty ( data . Reservations ) } ) . catch ( inspect Error ) } 
function Easy Logger ( config File ) { 
function ( ) { 
function ( level , text ) { 
function ( transport Type , formatter ) { var exists = contains ( cm . config . easylogger . transports , { "key " : "type " , "value " : transport Type } , "exists " ) 
function Edmunds Client ( config ) { if ( ! ( this instanceof Edmunds Client ) ) { return new Edmunds Client ( config ) ; } var default Config = { } ; default Config . response Format = 'json ' ; default Config . base Url = 'https : / /api .edmunds .com ' ; this . config = extend ( default Config , config ) ; if ( ! this . config . api Key ) { throw new Error ( 'API key must be provided ' ) ; } } 
function add Definition ( def Name ) { var definition = definitions [ def Name ] ; return function ( params , done ) { if ( ! done & & typeof params = = = 'function ' ) { done = params ; params = { } ; } var url = this . config . base Url + definition . url ; var xtra Params = { } ; xtra Params . fmt = this . config . response Format ; xtra Params . api _key = this . config . api Key ; try { Object . keys ( definition . params ) . for Each ( function ( param Name ) { var param Def = definition . params [ param Name ] ; if ( ! params [ param Name ] ) { if ( param Def . required ) { throw new Error ( 'Parameter ' + param Name + ' is required ' ) ; } else { return ; } } if ( param Def . location = = = 'url ' ) { url = url . replace ( new Reg Exp ( ' { ' + param Name + ' } ' , 'g ' ) , params [ param Name ] ) ; } else if ( param Def . location = = = 'querystring ' ) { xtra Params [ param Name ] = params [ param Name ] ; } } ) ; } catch ( e ) { return done ( e ) ; } return request . get ( url ) . query ( xtra Params ) . end ( function on End ( err , res ) { return done ( err , res . body ) ; } ) ; } ; } 
function create Client ( host , port , concurrent , frequency , duration , gen , iteration ) { var auth = defaults . auth var get Message = defaults . get Message emitter . emit ( 'start ' ) if ( typeof gen . authenticate = = = 'function ' ) { auth = gen . authenticate } if ( typeof gen . client Iterate Message = = = 'function ' ) { get Message = gen . client Iterate Message } var post Auth = function ( err , cookies , user , pass ) { + + clients Attempted if ( err ) { emitter . emit ( 'error ' , err ) if ( clients Attempted = = = concurrent & & _intervals . length = = = 0 ) { emitter . emit ( 'end ' ) } return } var socket Url = gen . get Socket URL ( host , port , cookies , user , pass ) | | host + ' : ' + port var socket = io ( socket Url , { multiplex : false } ) . on ( 'connect ' , function ( ) { emitter . emit ( 'client -connected ' ) if ( typeof gen . events . connect = = = 'function ' ) { gen . events . connect ( 'connect ' , cookies , user , pass , { } , socket , emitter ) } Object . keys ( gen . events ) . for Each ( function ( event Name ) { socket . on ( event Name , function ( data ) { gen . events [ event Name ] . call ( null , event Name , cookies , user , pass , data , socket , emitter ) } ) } ) var send Message = function ( ) { var message = get Message ( cookies , user , pass ) if ( ! Array . is Array ( message ) ) { message = [ message ] } for ( var i = 0 , len = message . length ; i < len ; i + + ) { if ( message [ i ] ) { socket . json . send ( message [ i ] ) emitter . emit ( 'message ' , message [ i ] ) } } } _intervals . push ( set Interval ( send Message , frequency ) ) set Timeout ( function ( ) { clear Interval ( _intervals . pop ( ) ) socket . emit ( 'disconnect ' ) emitter . emit ( 'disconnect ' ) socket . close ( ) if ( _intervals . length = = = 0 ) { done ( ) } } , duration ) } ) . on ( 'connect _error ' , function ( err ) { emitter . emit ( 'error ' , err ) if ( clients Attempted = = = concurrent & & _intervals . length = = = 0 ) { emitter . emit ( 'end ' ) } } ) } auth ( host , port , iteration , post Auth ) } 
function ( file ) { var xml = file . contents ; var xml Doc = libxmljs . parse Xml ( xml ) ; var root Node = xml Doc . root ( ) ; var resource Object = { } ; var value Nodes = root Node . find ( "data " ) ; value Nodes . for Each ( function ( element ) { var name = element . attr ( "name " ) . value ( ) ; var value = element . get ( "value " ) . text ( ) ; resource Object [ name ] = value ; } ) ; return JSON . stringify ( resource Object ) ; } 
function does Launch Configuration Exist ( auto Scaling , launch Configuration Name ) { return auto Scaling . describe Launch Configurations Promised ( { Launch Configuration Names : [ launch Configuration Name ] } ) . then ( function found ( data ) { return ! _ . is Empty ( data . Launch Configurations ) } ) } 
function KJU ( configuration ) { var self = this , option ; 
function filter ( err , files ) { if ( err ) return self . emit ( 'error ' , err ) ; var kjud = files . filter ( function filterfiles ( file ) { return ( / ( \d ) \ .kju $ / ) . test ( file ) ; } ) ; 
function read ( file , index , files ) { fs . read File ( self . path + file , function read File ( err , contents ) { if ( err ) return done ( ) , self . emit ( 'error ' , err ) ; 
function ( ) { var s 4 = function ( ) { return Math . floor ( ( 1 + Math . random ( ) ) * 0x 1 0 0 0 0 ) . to String ( 1 6 ) . substring ( 1 ) ; } ; return s 4 ( ) + s 4 ( ) + ' - ' + s 4 ( ) ; } 
function ( raw ) { if ( typeof raw ! = = 'object ' | | raw = = = null | | util . is Array ( raw ) ) { return false ; } if ( raw . wiretree ) { return true ; } return false ; } 
function ( func ) { var fn Str = func . to String ( ) . replace ( / ( ( \ / \ / . * $ ) | ( \ / \ * [ \s \S ] * ? \ * \ / ) ) / mg , ' ' ) ; return fn Str . slice ( fn Str . index Of ( ' ( ' ) + 1 , fn Str . index Of ( ' ) ' ) ) . match ( / ( [ ^ \s , ] + ) / g ) | | [ ] ; } 
function ( opts , tree ) { var file Name ; this . tree = tree ; this . resolved = false ; this . dependants = [ ] ; 
function ( mod ) { self . res = get Processed ( self . processing , mod , self . raw . settings ) ; self . resolved = true ; callback ( ) ; } 
function ( width , height , camera ) { var id ; var w = width , h = height ; this . orientation = 'landscape ' ; this . listeners = { } ; if ( typeof width ! = = 'number ' ) { var image = width ; camera = height ; w = image . video Width | | image . width ; h = image . video Height | | image . height ; this . image = image ; } this . default Marker Width = 1 ; this . pattern Markers = { } ; this . barcode Markers = { } ; this . transform _mat = new Float 3 2Array ( 1 6 ) ; this . canvas = document . create Element ( 'canvas ' ) ; this . canvas . width = w ; this . canvas . height = h ; this . ctx = this . canvas . get Context ( ' 2d ' ) ; this . video Width = w ; this . video Height = h ; if ( typeof camera = = = 'string ' ) { var self = this ; this . camera Param = new ARCamera Param ( camera , function ( ) { self . _initialize ( ) ; } , function ( err ) { console . error ( "ARController : Failed to load ARCamera Param " , err ) ; } ) ; } else { this . camera Param = camera ; this . _initialize ( ) ; } } 
function ( src , onload , onerror ) { this . id = - 1 ; this . _src = ' ' ; this . complete = false ; this . onload = onload ; this . onerror = onerror ; if ( src ) { this . load ( src ) ; } } 
function write String To FS ( target , string , callback ) { var byte Array = new Uint 8Array ( string . length ) ; for ( var i = 0 ; i < byte Array . length ; i + + ) { byte Array [ i ] = string . char Code At ( i ) & 0xff ; } write Byte Array To FS ( target , byte Array , callback ) ; } 
function update Uvs ( model View Matrix , camera Projection Matrix ) { var transformed Uv = new THREE . Vector 3 ( ) originals Face Vertex Uvs [ 0 ] . for Each ( function ( face Vertex Uvs , face Index ) { face Vertex Uvs . for Each ( function ( original Uv , uv Index ) { 
function update Ortho ( model View Matrix , camera Projection Matrix ) { 
function append Table At Range End ( opts : Options ) : type Rule { return ( root Insert , change , range , fragment , insert Options , next ) = > { if ( fragment . nodes . size = = = 0 ) { return next ( insert Options ) ; } const fragment Table = fragment . nodes . last ( ) ; if ( fragment Table . type ! = = opts . type Table ) { return next ( insert Options ) ; } const start Position = Edit Table Position . create ( { node : change . value . document , range : range . collapse To Start ( ) , opts } ) ; const end Position = Edit Table Position . create ( { node : change . value . document , range : range . collapse To End ( ) , opts } ) ; if ( start Position . is Same Table ( end Position ) & & ! start Position . is At Start Of Table ( ) ) { return next ( insert Options ) ; } if ( ! end Position . is In Table ( ) | | ! end Position . is First Row ( ) ) { return next ( insert Options ) ; } const { table , cell Index , row } = end Position ; if ( ! is Same Width ( table , fragment Table ) ) { return next ( insert Options ) ; } const { document } = change . value ; const { last Node As Text } = insert Options ; let next Table = table ; if ( last Node As Text ) { const fragment Row = fragment Table . nodes . last ( ) ; const next Row = paste Single Row ( row , fragment Row , 0 , cell Index , true ) ; next Table = table . update Node ( next Row ) ; } const before Rows = last Node As Text ? fragment Table . nodes . pop ( ) : fragment Table . nodes ; next Table = next Table . set ( 'nodes ' , before Rows . concat ( next Table . nodes ) ) ; change . replace Node By Key ( next Table . key , next Table , { normalize : false } ) ; fragment = fragment . set ( 'nodes ' , fragment . nodes . pop ( ) ) ; const prev Block = document . get Previous Block ( table . key ) ; if ( ! prev Block ) { range = range . collapse To Start Of ( fragment Table ) ; insert Options = insert Options . set ( 'first Node As Text ' , false ) ; } else { range = range . move Focus To End Of ( prev Block ) ; if ( start Position . is Same Table ( end Position ) ) { range = range . move To Focus ( ) ; } } return root Insert ( change , range , fragment , insert Options . set ( 'last Node As Text ' , false ) ) ; } ; } 
function append Table At Range Start ( opts : Options ) : type Rule { return ( root Insert , change , range , fragment , insert Options , next ) = > { if ( fragment . nodes . size = = = 0 ) { return next ( insert Options ) ; } const fragment Table = fragment . nodes . first ( ) ; if ( fragment Table . type ! = = opts . type Table ) { return next ( insert Options ) ; } const start Position = Edit Table Position . create ( { node : change . value . document , range : range . collapse To Start ( ) , opts } ) ; const end Position = Edit Table Position . create ( { node : change . value . document , range : range . collapse To End ( ) , opts } ) ; if ( ! start Position . is In Table ( ) | | start Position . is Same Table ( end Position ) | | ! start Position . is Last Row ( ) ) { return next ( insert Options ) ; } const { table , cell Index , row } = start Position ; if ( ! is Same Width ( table , fragment Table ) ) { return next ( insert Options ) ; } const { document } = change . value ; const { first Node As Text } = insert Options ; let next Table = table ; if ( first Node As Text ) { const fragment Row = fragment Table . nodes . first ( ) ; const next Row = paste Single Row ( row , fragment Row , cell Index , - 1 ) ; next Table = table . update Node ( next Row ) ; } const after Rows = first Node As Text ? fragment Table . nodes . shift ( ) : fragment Table . nodes ; next Table = next Table . set ( 'nodes ' , next Table . nodes . concat ( after Rows ) ) ; change . replace Node By Key ( next Table . key , next Table , { normalize : false } ) ; fragment = fragment . delete In ( [ 'nodes ' , 0 ] ) ; const next Block = document . get Next Block ( table . key ) ; if ( ! next Block ) { range = range . collapse To End Of ( fragment Table ) ; insert Options = insert Options . set ( 'last Node As Text ' , false ) ; } else { range = range . move Anchor To Start Of ( next Block ) ; if ( start Position . is Same Table ( end Position ) ) { range = range . move To Anchor ( ) ; } } return root Insert ( change , range , fragment , insert Options . set ( 'first Node As Text ' , false ) ) ; } ; } 
function Package Member List Read Stream ( dir To Scan ) { sjl . throw Type Error If Empty ( 'Package Member List Read Stream ' , 'dir To Scan ' , dir To Scan , String ) ; this . _path To Read = dir To Scan ; Readable . call ( this , { encoding : 'utf 8 ' , object Mode : false , high Water Mark : 1 0 0 0 0 0 , } ) ; } 
function does Load Balancer Exist ( elb , load Balancer Name ) { function inspect Error ( err ) { if ( err . code = = = 'Load Balancer Not Found ' ) { return false } return Bluebird . reject ( err ) } return elb . describe Load Balancers Promised ( { Load Balancer Names : [ load Balancer Name ] } ) . then ( _ . constant ( true ) ) . error ( inspect Error ) } 
function lint ( files ) { return gulp . src ( files ) . pipe ( $ . plumber ( ) ) . pipe ( $ . eslint ( ) ) . pipe ( $ . eslint . format ( ) ) . pipe ( $ . eslint . fail On Error ( ) ) . pipe ( $ . jscs ( ) ) . pipe ( $ . notify ( _jscs Notify ) ) ; } 
function _browserify Bundle ( ) { let bundler = browserify Bundler ( ) ; 
function ( group Name , tree ) { this . key = group Name ; this . resolved = false ; this . dependants = [ ] ; this . plugins = { } ; this . result = { } ; this . tree = tree ; } 
function Pause Command ( args , define ) { if ( args . length ) { this . message = new statements . Expression Statement ( args , define ) ; if ( this . message . error ) throw this . message . error ; } else this . message = new statements . String Statement ( " [ < < Paused , Press RETURN to Continue > > ] " ) ; } 
function Validation Errors ( errors ) { this . errors = errors ? errors : { } ; this . add Error = function ( field , message ) { if ( ! this . errors [ field ] ) { this . errors [ field ] = [ ] ; } this . errors [ field ] . push ( util . format ( message , field ) ) ; } ; 
function Line Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 4 ) throw new Syntax Error ( 'LINE command requires 4 arguments ' ) ; this . x 1 = parsed . args [ 0 ] ; this . y 1 = parsed . args [ 1 ] ; this . x 2 = parsed . args [ 2 ] ; this . y 2 = parsed . args [ 3 ] ; this . width = parsed . args . length > 4 ? parsed . args [ 4 ] : false ; } 
function Point Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 2 ) throw new Syntax Error ( 'POINT command requires 2 arguments ' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; if ( parsed . args . length > 2 ) this . size = parsed . args [ 2 ] ; else this . size = false ; } 
function get Random ( data ) { var x = Math . sin ( data . get Private ( 'rnd _seed ' ) ) * 1 0 0 0 0 ; data . set Private ( 'rnd _seed ' , data . get Private ( 'rnd _seed ' ) + 1 ) ; return x - Math . floor ( x ) ; } 
function For Command ( args , define ) { var lower Args = args . to Lower Case ( ) ; var to Index = lower Args . index Of ( ' to ' ) ; if ( to Index = = = - 1 ) throw new Syntax Error ( 'FOR has no TO ' ) ; var assignment Text = args . substring ( 0 , to Index ) . trim ( ) ; var step Index = lower Args . index Of ( ' step ' ) ; var upper Limit Text , step Text ; if ( step Index = = = - 1 ) { upper Limit Text = args . substring ( to Index + 4 ) . trim ( ) ; step Text = ' 1 ' ; } else { upper Limit Text = args . substring ( to Index + 4 , step Index ) . trim ( ) ; step Text = args . substring ( step Index + 6 ) . trim ( ) ; } var assignment Equals = assignment Text . index Of ( ' = ' ) ; if ( assignment Equals = = = - 1 ) throw new Syntax Error ( 'Expected assignment ' ) ; var variable Name = assignment Text . substring ( 0 , assignment Equals ) . trim ( ) ; var equals Expression = assignment Text . substring ( assignment Equals + 1 ) . trim ( ) ; var assignment Expr = new statements . Assignment Statement ( new statements . Variable Statement ( variable Name ) , new statements . Expression Statement ( equals Expression , define ) ) ; var upper Limit Expr = new statements . Expression Statement ( upper Limit Text , define ) ; if ( upper Limit Expr . error ) throw upper Limit Expr . error ; var step Expr = new statements . Expression Statement ( step Text , define ) ; if ( step Expr . error ) throw step Expr . error ; this . assignment Expr = assignment Expr ; this . upper Limit Expr = upper Limit Expr ; this . step Expr = step Expr ; this . block = define ( { start : 'FOR ' , end : 'NEXT ' } ) ; this . loop Count = 0 ; } 
function Order Processing ( obj Google Checkout ) { var self = this ; 
function check Second ( samasa , second ) { var beg = u . first ( second ) ; var clean = second ; if ( ! inc ( [ c . h , c . S , c . o M ] , beg ) ) return second ; var position = samasa . length - second . length ; var sym = samasa [ position ] ; if ( beg = = c . h ) { 
function add Options ( first , second ) { var first = first . split ( ' ' ) ; var second = second . split ( ' ' ) ; var fin = first . slice ( - 1 ) [ 0 ] ; if ( inc ( c . consonants , fin ) ) fin = ' ' ; var penult = first . slice ( - 2 ) [ 0 ] ; var beg = second [ 0 ] ; var opt ; var candra ; if ( fin = = c . virama ) { 
function create Mic Analyser ( engine , callback ) { var entity , node ; if ( ! this . _context ) { this . _context = new ( window . Audio Context | | window . webkit Audio Context ) ( ) ; } entity = new Serpentity . Entity ( ) ; this . _get User Media ( { audio : true } , this . _on User Media . bind ( this , engine , entity , callback ) , this . _on User Media Error . bind ( this , entity , callback ) ) } 
function _on User Media ( engine , entity , callback , local Media Stream ) { var source , analyser ; source = this . _context . create Media Stream Source ( local Media Stream ) ; analyser = this . _context . create Analyser ( ) ; source . connect ( analyser ) ; entity . add Component ( new Serpentity . Contrib . Components . Analyser ( { analyser : analyser } ) ) ; entity . add Component ( new Serpentity . Contrib . Components . Configuration ( { config : { } } ) ) ; engine . add Entity ( entity ) ; callback ( entity ) ; } 
function make Upload Task ( cwd , file ) { var key = options . key Gen ( cwd , file ) ; function do Upload ( callback ) { var absolute Path = path . join ( cwd , file ) ; grunt . log . ok ( 'Start uploading the file [ ' + file + ' ] , qiniu key is : [ ' + key + ' ] ' ) ; client . upload File ( absolute Path , { key : key } , function ( err , result ) { if ( ! err ) { grunt . log . ok ( 'The file [ ' + file + ' ] has been uploaded yet . ' ) ; } callback ( err , result ) ; } ) ; } return function ( callback ) { if ( options . ignore Dup ) { 
function Emitter ( opts ) { Transform . call ( this ) ; this . _writable State . object Mode = true ; this . _readable State . object Mode = true ; opts = opts | | { } ; 
function MQlobber Server ( fsq , stream , options ) { Event Emitter . call ( this ) ; options = options | | { } ; this . fsq = fsq ; this . subs = new Set ( ) ; this . _done = false ; this . mux = new BPMux ( stream , util . _extend ( util . _extend ( { } , options ) , { high _channels : true } ) ) ; var ths = this ; function error ( err ) { ths . emit ( 'error ' , err , this ) ; } function warning ( err ) { if ( err & & ! ths . emit ( 'warning ' , err , this ) ) { console . error ( err ) ; } } this . _warning = warning ; this . mux . on ( 'error ' , error ) ; function handshake _sent ( duplex , complete ) { if ( ! complete ) { ths . emit ( 'backoff ' ) ; } } this . mux . on ( 'handshake _sent ' , handshake _sent ) ; this . mux . on ( 'pre _handshake _sent ' , handshake _sent ) ; this . mux . on ( 'drain ' , function ( ) { ths . emit ( 'drain ' ) ; } ) ; this . mux . on ( 'full ' , function ( ) { ths . emit ( 'full ' ) ; } ) ; this . mux . on ( 'removed ' , function ( duplex ) { ths . emit ( 'removed ' , duplex ) ; } ) ; this . mux . on ( 'finish ' , function ( ) { ths . _done = true ; if ( ! ths . emit ( 'unsubscribe _all _requested ' , warning ) ) { ths . default _unsubscribe _all _requested _handler ( ) ; } } ) ; this . relay _error = function ( err ) { switch ( this . _readable State . pipes Count ) { case 0 : break ; case 1 : this . _readable State . pipes . emit ( 'error ' , err ) ; break ; default : var dests = new Set ( ) , dest ; for ( dest of this . _readable State . pipes ) { dests . add ( dest ) ; } for ( dest of dests ) { dest . emit ( 'error ' , err ) ; } break ; } } ; this . handler = function ( data , info , cb 3 ) { var called = false ; function cb ( err , cb 2 ) { warning ( err ) ; if ( ! called ) { cb 3 . num _handlers - = 1 ; called = true ; } if ( options . defer _to _final _handler & & ( cb 3 . num _handlers > 0 ) ) { if ( cb 2 ) { return cb 2 ( err ) ; } return ; } cb 3 ( err , cb 2 ) ; } data . on ( 'error ' , warning ) ; data . on ( 'error ' , ths . relay _error ) ; if ( ! info . single ) { data . on ( 'end ' , cb ) ; } var hdata = [ new Buffer ( 1 ) ] , buf ; hdata [ 0 ] . write UInt 8 ( ( info . single ? 1 : 0 ) | ( ( options . send _expires ? 1 : 0 ) < < 1 ) | ( ( info . existing ? 1 : 0 ) < < 2 ) | ( ( options . send _size ? 1 : 0 ) < < 3 ) , 0 ) ; if ( options . send _expires ) { buf = new Buffer ( 8 ) ; var expires = Math . floor ( info . expires / 1 0 0 0 ) ; 
function map ( obj , fn , squash ) { var a = [ ] , key , keys , x , do Break = false ; if ( Array . is Array ( obj ) ) { for ( key = 0 ; key < obj . length ; key + + ) { do Call ( key , obj ) if ( do Break ) { break ; } } } else if ( obj ! = = null & & typeof ( obj ) = = = 'object ' ) { keys = Object . keys ( obj ) ; for ( x = 0 ; x < keys . length ; x + + ) { do Call ( keys [ x ] , obj ) ; if ( do Break ) { break ; } } } else if ( typeof ( obj ) = = = 'string ' ) { for ( key in obj ) { do Call ( key , obj ) ; if ( do Break ) { break ; } } } else { return [ ] ; } return a ; function do Call ( key , obj ) { var t = fn . call ( obj [ key ] , key , obj [ key ] , emit , end ) ; if ( ( t ! = = undefined & & t ! = = null & & squash ) | | ! squash ) { a . push ( t ) ; } } function emit ( obj ) { return a . push ( obj ) } function end ( ) { do Break = true ; } } 
function free Memory ( mapped Vars , step ) { if ( mapped Vars . length > 0 ) { let mapped Vars Stringify = [ ] for ( let mapped Var of mapped Vars ) { if ( mapped Var . has Own Property ( "self " ) & & mapped Var . self ) { delete mapped Var . self . code mapped Vars Stringify . push ( JSON . stringify ( mapped Var . self ) ) } } return simple Eval ( ` $ { mapped Vars Stringify . join ( ' , ' ) } ` , false , step ) } } 
function ( opts ) { if ( ! navigator . camera ) { return $q . reject ( new Error ( 'Camera module (navigator .camera ) not available ' ) ) ; } 
function get Hash Encoded Pair ( n ) { get Bytes ( function ( key Buffer ) { get Bytes ( function ( value Buffer , output ) { object . value [ key Buffer . to String ( encoding ) ] = raw ? value Buffer : value Buffer . to String ( encoding ) ; object . length + + ; next ( n ) ; } ) ; } ) ; } 
function get List Entry ( n ) { get Bytes ( function ( entry Buffer ) { result . push ( raw ? entry Buffer : entry Buffer . to String ( encoding ) ) ; next ( n ) ; } ) ; } 
function Drawtext Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 3 ) throw new Syntax Error ( 'DRAWTEXT command requires 3 arguments ' ) ; else if ( parsed . args . length > 3 & & parsed . args . length < 5 ) throw new Syntax Error ( 'DRAWTEXT command requires 5 arguments ' ) ; this . text = parsed . args [ 0 ] ; this . x 1 = parsed . args [ 1 ] ; this . y 1 = parsed . args [ 2 ] ; if ( parsed . args . length > 3 ) { this . x 2 = parsed . args [ 3 ] ; this . y 2 = parsed . args [ 4 ] ; } else { this . x 2 = false ; this . y 2 = false ; } } 
function f XMLHttp Request _send ( o Request ) { o Request . _object . send ( o Request . _data ) ; console & & console . log ( 'f XMLHttp Request _send ' , o Request . ready State ) ; 
function write Lock File ( path , data , cb ) { 
function Validator ( ) { var self = this , args = fun ( arguments ) ; self . klass = self . klass | | Validator ; self . options = Object . merge ( self . klass . defaults . options , args . objects ( ) [ 0 ] | | { } , true ) ; self . engine = null ; } 
function call Handlers ( cults , e ) { var broken = false ; for ( var i = 0 ; i < cults . length ; i + + ) { var cult = cults [ i ] ; var handlers = cult & & cult . events & & cult . events [ e . type ] ; if ( ! handlers ) continue ; var selectors = Object . keys ( handlers ) ; if ( call Handler ( cult , e , handlers , selectors ) = = = false ) { broken = true ; break ; } } return broken ; } 
function fn ( model Getter , opts ) { if ( typeof model Getter ! = = 'function ' ) { throw new Error ( ` ` ) ; } for ( const key in actions ) { let action = actions [ key ] ; if ( opts . override & & ( typeof opts . override [ key ] = = = 'function ' ) ) { action = opts . override [ key ] ; } actions [ key ] = action ( model Getter , opts ) ; } module . exports = actions ; return actions ; } 
function favicon Request Handler ( req , res , next ) { var icon = ' ' if ( typeof req . url ! = = 'string ' ) { return next ( ) } if ( url . parse ( req . url ) . pathname ! = = ' /favicon .ico ' ) { return next ( ) } res . set Header ( 'content -length ' , icon . length ) res . set Header ( 'content -type ' , 'image /x -icon ' ) res . send ( icon ) } 
function ( def ) { var start = Array . is Array ( def . start ) ? def . start : [ def . start ] ; var end = Array . is Array ( def . end ) ? def . end : [ def . end ] ; var then = def . then ? ( Array . is Array ( def . then ) ? def . then : [ def . then ] ) : [ ] ; var child = new Block ( line , { start : start , end : end , then : then } , self ) ; self . children . push ( child ) ; return child ; } 
function rando Service ( incoming Payload , cb ) { var buf = data Uri To Buffer ( incoming Payload . content . data ) random Revisitor ( buf . img Type , post To Random ) function post To Random ( err , random Url ) { if ( err ) return cb ( err ) request . post ( { json : true , url : random Url + ' /service ' , body : incoming Payload } , function ( err , response , body ) { if ( body & & ! body . content ) console . error ( 'Something went wrong connecting to : ' + random Url ) if ( err ) return cb ( err ) return cb ( null , ( body & & body . content & & body . content . data ) ? body : incoming Payload ) } ) } } 
function entry ( object ) { var buffer ; switch ( object . type ) { case 'header ' : buffer = this . header ( object . version ) ; break ; case 'database ' : buffer = this . database ( object . number ) ; break ; case 'key ' : buffer = this . key ( object ) ; 
function database ( n ) { var dbid = new Buffer ( [ 0x FE ] ) , len = this . get Length Encoding ( n , false ) ; return Buffer . concat ( [ dbid , len ] , dbid . length + len . length ) ; } 
function key ( obj , vonly ) { var buffer = new Buffer ( 0 ) , item ; if ( obj . expiry ! = = undefined & & ! vonly ) { buffer = this . expiry ( obj . expiry ) ; } item = this [ obj . rtype ] ( obj , vonly ) ; return Buffer . concat ( [ buffer , item ] , buffer . length + item . length ) } 
function expiry ( expires ) { var buffer , int 6 4 ; if ( expires % 1 0 0 0 = = = 0 ) { buffer = new Buffer ( 5 ) ; buffer . write UInt 8 ( 0x FD , 0 ) ; buffer . write Int 3 2LE ( expires / 1 0 0 0 , 1 ) ; } else { buffer = new Buffer ( 9 ) ; int 6 4 = new Int 6 4 ( expires ) ; buffer . write UInt 8 ( 0x FC , 0 ) ; buffer . write UInt 3 2LE ( int 6 4 . low 3 2 ( ) , 1 ) ; buffer . write UInt 3 2LE ( int 6 4 . high 3 2 ( ) , 5 ) ; } return buffer ; } 
function string ( obj , vonly ) { var vtype = this . type ( 0 ) , key = ! vonly ? this . get String Buffer ( obj . key ) : new Buffer ( 0 ) , value = this . get String Buffer ( obj . value ) ; return Buffer . concat ( [ vtype , key , value ] , vtype . length + key . length + value . length ) } 
function list ( obj , vonly ) { var vtype = this . type ( 1 ) , key = ! vonly ? this . get String Buffer ( obj . key ) : new Buffer ( 0 ) , len = this . get Length Encoding ( obj . value . length , false ) , value = this . array ( obj . value ) ; return Buffer . concat ( [ vtype , key , len , value ] , vtype . length + key . length + len . length + value . length ) } 
function zset ( obj , vonly ) { var vtype = this . type ( 3 ) , key = ! vonly ? this . get String Buffer ( obj . key ) : new Buffer ( 0 ) , length = obj . length ! = = undefined ? obj . length : Object . keys ( obj . value ) . length , len = this . get Length Encoding ( length , false ) , value = this . object ( obj . value ) ; return Buffer . concat ( [ vtype , key , len , value ] , vtype . length + key . length + len . length + value . length ) } 
function array ( arr ) { var buffers = [ ] , buf , i , len = 0 ; for ( i = 0 ; i < arr . length ; i + + ) { buf = this . get String Buffer ( arr [ i ] ) ; len + = buf . length ; buffers . push ( buf ) ; } return Buffer . concat ( buffers , len ) ; } 
function object ( obj ) { var buffers = [ ] , buf , k , v , len = 0 ; for ( k in obj ) { buf = this . get String Buffer ( k ) ; len + = buf . length ; buffers . push ( buf ) ; buf = this . get String Buffer ( obj [ k ] ) ; len + = buf . length ; buffers . push ( buf ) ; } return Buffer . concat ( buffers , len ) ; } 
function get String Buffer ( s ) { var buffer , n = typeof s = = = 'number ' ? s : null 
function length ( buffer , n , special ) { var len = this . get Length Encoding ( n , special ) ; return Buffer . concat ( [ len , buffer ] , len . length + buffer . length ) ; } 
function get Length Encoding ( n , special ) { if ( n < 0 ) throw new Error ( 'Cannot write negative length encoding : ' + n ) ; if ( ! special ) { if ( n < = 0x 3F ) { return new Buffer ( [ n ] ) ; } else if ( n < = 0x 3FFF ) { return new Buffer ( [ 0x 4 0 | ( n > > 8 ) , n & 0x FF ] ) ; } else if ( n < = 0x FFFFFFFF ) { var buffer = new Buffer ( 5 ) ; buffer . write UInt 8 ( 0x 8 0 , 0 ) ; buffer . write UInt 3 2BE ( n , 1 ) ; return buffer ; } throw new Error ( 'Failed to write length encoding : ' + n ) ; } else { if ( n > 0x 3F ) { throw new Error ( 'Cannot encode ' + n + ' using special length encoding ' ) ; } return new Buffer ( [ 0x C 0 | n ] ) ; } } 
function Textfont Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length > 2 ) { this . family = parsed . args [ 0 ] ; this . style = parsed . args [ 1 ] ; this . size = parsed . args [ 2 ] ; } else if ( parsed . args . length > 1 ) { this . family Or Style = parsed . args [ 0 ] ; this . size = parsed . args [ 1 ] ; } else if ( parsed . args . length > 0 ) { var arg = parsed . args [ 0 ] ; if ( arg . child . type = = = 'string ' | | arg . child instanceof statements . String Statement ) this . family Or Style = arg ; else this . size = arg ; } else { this . reset = true ; } } 
function Merchant Calculations ( obj Google Checkout ) { var self = this ; 
function replace ( value , config Data ) { if ( typeof value ! = "string " ) { return value ; } else { return value . replace ( prop String Tmpl Re , function ( match , path ) { var value = get ( config Data , path ) ; if ( ! ( value instanceof Error ) ) { return value ; } else { return match ; } } ) ; } } 
function get ( object , path ) { if ( memo Get [ path ] ) { return new Error ( "circular reference for " + path ) ; } var parts = path . split ( " . " ) ; var obj = object ; while ( typeof obj = = = "object " & & obj & & parts . length ) { var part = parts . shift ( ) ; if ( ! ( part in obj ) ) { return new Error ( "invalid path " ) ; } obj = obj [ part ] ; } memo Get [ path ] = true ; 
function entropy ( sigma , options ) { var opts = { } , ctor , err , out , dt , d ; if ( is Number ( sigma ) | | isnan ( sigma ) ) { return entropy 1 ( sigma ) ; } if ( arguments . length > 1 ) { err = validate ( opts , options ) ; if ( err ) { throw err ; } } if ( is Matrix Like ( sigma ) ) { if ( opts . copy ! = = false ) { dt = opts . dtype | | 'float 6 4 ' ; ctor = ctors ( dt ) ; if ( ctor = = = null ) { throw new Error ( 'entropy ( ) : :invalid option . Data type option does not have a corresponding array constructor . Option : ` ' + dt + ' ` . ' ) ; } 
function check Bug ( ) { 
function workaround ( ) { var node = document . create Element ( 'div ' ) ; function matches ( element , selector ) { if ( method . call ( element , selector ) ) { return true ; } else if ( ! element . parent Node ) { 
function allow ( action , req , res , cb ) { 
function clean ( action , result , req , res , cb ) { 
function perform Crud Action ( action , req , res , next ) { allow ( action , req , res , function ( err , is Allowed ) { if ( err ) { return Model . swr . error . server Error ( res ) ; } if ( ! is Allowed ) { return Model . swr . error . forbidden ( res ) ; } switch ( action ) { case options . actions . find : find ( action , req , res , function ( err , result ) { if ( err ) { return Model . swr . error . server Error ( res ) ; } Model . swr . success ( result , res ) ; next ( ) ; } ) ; break ; } } ) ; } 
function find ( action , req , res , cb ) { var result = { } ; 
function ( sentence ) { const split = sentence . to Lower Case ( ) . split ( / \s + / ) ; for ( const word of split ) { if ( banned Words . index Of ( word ) ! = = - 1 ) return false ; } return true ; } 
function file 2obj ( file ) { if ( ! fs . exists Sync ( file ) ) { return { } ; } try { var buffer = JSON . parse ( fs . read File Sync ( file ) , { 'encoding ' : 'utf 8 ' } ) ; if ( ! ( buffer & & ( typeof buffer = = = 'object ' ) ) ) { throw new Type Error ( 'Failed to parse file as an object : ' + file ) ; } return buffer ; } catch ( e ) { throw new Type Error ( "Failed to read file " + file + " : " + e ) ; } } 
function append _to ( config , obj ) { if ( config = = = undefined ) { 
function dispatch ( ctx ) { if ( _cur Ctx ) { var ret = _cur Ctx . route . exit ( { path : _cur Ctx . path , params : _cur Ctx . params } , true ) ; if ( ! ret ) { return ; } } _prev Ctx = _cur Ctx ; _cur Ctx = ctx ; if ( ! _cur Ctx . route ) { var m = map ( _cur Ctx . path ) ; _cur Ctx . route = m . route ; _cur Ctx . params = m . params ; } var r = _cur Ctx . route . enter ( { force : _cur Ctx . force , path : _cur Ctx . path , params : _cur Ctx . params } , true ) ; langx . Deferred . when ( r ) . then ( function ( ) { _hub . trigger ( create Event ( "routing " , { current : _cur Ctx , previous : _prev Ctx } ) ) ; _cur Ctx . route . enter ( { path : _cur Ctx . path , params : _cur Ctx . params } , false ) ; if ( _prev Ctx ) { _prev Ctx . route . exit ( { path : _prev Ctx . path , params : _prev Ctx . params } , false ) ; } _hub . trigger ( create Event ( "routed " , { current : _cur Ctx , previous : _prev Ctx } ) ) ; } ) ; } 
function start ( ) { if ( router . use Hashbang = = null & & router . use History Api = = null ) { if ( window . location . host & & window . history . push State ) { eventer .on (document .body , "click " , "a [href ] " , function (e ) { var elm = e .current Target , url = elm .get Attribute ( "href " ) ; if (url = = " # " ) { return ; } if (url & & langx .is Same Origin (elm .href ) ) { if (url .index Of ( _base Url ) = = = 0 ) { url = url .substr ( _base Url .length ) ; eventer .stop (e ) ; url = url .replace ( ' # ! ' , ' ' ) ; go (url ) ; } } } ) ; * / if ( router . use History Api ) { window . add Event Listener ( "popstate " , function ( e ) { if ( e . state ) dispatch ( e . state ) ; e . prevent Default ( ) ; } ) ; } else if ( router . use Hashbang ) { window . add Event Listener ( "hashchange " , function ( e ) { dispatch ( { path : window . location . hash . replace ( / ^ # ! / , " " ) } ) ; e . prevent Default ( ) ; } ) ; } go ( init Path ) ; } 
function ( ) { var cur Ctx = router . current ( ) , prev Ctx = router . previous ( ) ; var content = cur Ctx . route . render ( cur Ctx ) ; if ( content = = = undefined | | content = = = null ) { return ; } if ( langx . is String ( content ) ) { this . _rvc . inner HTML = content ; } else { this . _rvc . inner HTML = " " ; this . _rvc . append Child ( content ) ; } cur Ctx . route . trigger ( create Event ( "rendered " , { route : cur Ctx . route , content : content } ) ) ; } 
function ( key ) { var value ; if ( key . index Of ( ' . ' ) = = - 1 ) { value = this . config Obj [ key ] ; } else { var key Array = key . split ( ' . ' ) ; var key Str = key Array [ 0 ] ; value = this . config Obj [ key Str ] ; for ( var i = 1 , len = key Array . length ; i < len ; i + + ) { if ( ! value & & i < len - 1 ) { exit Process ( 'the var [ ' + key Str + ' ] is empty . ' , this . alarm ) ; return undefined ; } var key Now = key Array [ i ] ; key Str + = ' . ' + key Now ; value = value [ key Now ] ; } } slogger . debug ( 'load var [ ' + key + ' ] ,value : ' , value ) ; return value ; } 
function ( key ) { var value = this . load Var ( key ) ; if ( typeof ( value ) = = 'undefined ' ) { exit Process ( 'the value of ' + key + ' is necessary , but now is undefined ' , this . alarm ) ; return false ; } return value ; } 
function ( key ) { var str = this . load Var ( key ) ; if ( typeof ( str ) ! = 'string ' ) { exit Process ( 'the value of ' + key + ' is a necessary string , but get ' + str , this . alarm ) ; return false ; } return str ; } 
function ( key ) { var num = parse Int ( this . load Var ( key ) ) ; if ( is Na N ( num ) ) { exit Process ( 'the value of ' + key + ' is a necessary int ,but get ' + num , this . alarm ) ; return false ; } return num ; } 
function ( key ) { var obj = this . load Var ( key ) ; if ( ! obj | | typeof ( obj ) ! = 'object ' ) { exit Process ( 'the value of ' + key + ' is a necessary object ,but get ' + obj , this . alarm ) ; return false ; } return obj ; } 
function ( key , only Check Directory ) { var file Path = this . load Var ( key ) ; if ( ! file Path ) { exit Process ( 'empty file path for ' + key , this . alarm ) ; return false ; } if ( ! only Check Directory ) { if ( ! fs . exists Sync ( file Path ) ) { exit Process ( 'the value of ' + key + ' is a necessary file ,but not exists in ' + file Path , this . alarm ) ; return false ; } } else { var dirname = path . dirname ( file Path ) ; if ( ! fs . lstat Sync ( dirname ) . is Directory ( ) ) { exit Process ( 'the path ' + dirname + ' must exist and be a directory ' , this . alarm ) ; return false ; } } return file Path ; } 
function ( key , end With Separator ) { var filepath = this . load Necessary File ( key ) ; if ( ! filepath ) { exit Process ( 'empty directory for ' + key , this . alarm ) ; return false ; } if ( ! fs . lstat Sync ( filepath ) . is Directory ( ) ) { exit Process ( 'the path ' + filepath + ' must be a directory ' , this . alarm ) ; return false ; } if ( end With Separator & & ! filepath . end With ( path . sep ) ) { exit Process ( 'the path ' + filepath + ' must be end with a separator ' , this . alarm ) ; return false ; } return filepath ; } 
function ( key , end With Separator ) { var url = this . load Necessary String ( key ) ; if ( ! url ) { exit Process ( 'empty url for ' + key , this . alarm ) ; return false ; } if ( ! url . start With ( 'http : / / ' ) & & ! url . start With ( 'https : / / ' ) ) { exit Process ( 'invalid url : ' + url , this . alarm ) ; return false ; } if ( end With Separator & & ! url . end With ( ' / ' ) ) { exit Process ( 'the url [ ' + url + ' ] must be end with / ' , this . alarm ) ; return false ; } if ( ! end With Separator & & url . end With ( ' / ' ) ) { exit Process ( 'the url [ ' + url + ' ] must not be end with / ' , this . alarm ) ; return false ; } return url ; } 
function Variable Statement ( name ) { var bracket Index = name . index Of ( ' ( ' ) ; if ( bracket Index ! = = - 1 ) { var end Bracket Index = name . index Of ( ' ) ' ) ; if ( end Bracket Index = = = - 1 ) throw new Syntax Error ( 'Expected end bracket ' ) ; var array Name = name . substring ( 0 , bracket Index ) ; var array Dimensions Text = name . substring ( bracket Index + 1 , end Bracket Index ) . trim ( ) ; var array Dimensions = new statements . Argument Statement ( array Dimensions Text ) ; name = array Name ; this . is Array = true ; this . dimensions = array Dimensions . args ; } else this . is Array = false ; if ( name [ name . length - 1 ] = = = ' $ ' ) { this . type = 'string ' ; this . name = name . substring ( 0 , name . length - 1 ) ; } else { this . type = 'number ' ; this . name = name ; } } 
function install ( ) { if ( ! fs . exists Sync ( path . resolve ( _ _dirname , 'vendor ' , 'pdfcrop _v 0 . 4b ' , 'pdfcrop ' ) ) ) { var url = 'http : / /downloads .sourceforge .net /project /pdfcrop /pdfcrop /PDFCrop % 2 0v 0 . 4b /pdfcrop _v 0 . 4b .tar .gz ' var write = targz ( ) . create Write Stream ( path . resolve ( _ _dirname , 'vendor ' ) ) ; var req = http . request ( url , function ( res ) { res . pipe ( write ) write . on ( 'finish ' , function ( ) { console . log ( 'pdfcrop installed ' ) } ) } ) } if ( process . platform = = 'linux ' ) { if ( ! spawn Sync ( 'apt -get ' , [ ' -v ' ] ) . error ) { console . log ( "apt -get install plotutils perl ghostscript plotutils pdf 2svg " ) p = exec ( "apt -get install plotutils perl ghostscript plotutils pdf 2svg " ) p . stderr . pipe ( process . stderr ) p . stdout . pipe ( process . stdout ) } else { console . log ( "sorry only apt -get supported right now for automatic install " ) console . log ( "You have to install the following packages : " ) console . log ( " - perl " ) console . log ( " - ghostscript " ) console . log ( " - plotutils " ) console . log ( " - pdf 2svg " ) } } else if ( process . platform = = 'darwin ' ) { if ( ! spawn Sync ( 'brew ' , [ ' -v ' ] ) . error ) { console . log ( "brew install plotutils perl ghostscript plotutils pdf 2svg " ) p = exec ( "brew install plotutils perl ghostscript plotutils pdf 2svg " ) p . stderr . pipe ( process . stderr ) p . stdout . pipe ( process . stdout ) } else { console . log ( "You have to install Homebrew from http : / /brew .sh first " ) } } else { console . log ( "Sorry , your system is not supported for automatic install " ) console . log ( "You have to install the following packages : " ) console . log ( " - perl " ) console . log ( " - ghostscript " ) console . log ( " - plotutils " ) console . log ( " - pdf 2svg " ) } } 
function IOInterface ( output , input , data ) { this . _output = output | | function ( ) { } ; this . _input = input | | function ( done ) { done ( ' \n ' ) ; } ; this . _data = data | | { } ; } 
function ( url , entry , options ) { if ( ! S . is Obj ( options ) ) options = { full : options } ; if ( entry = = = false | | entry = = = true ) throw new Error ( 'Entry param cannot be false or true ' ) ; if ( entry = = null ) { entry = this . req . entry ; options . full = ( ' / ~ ' + entry | | options . full = = = true ? Config . site Url [ entry ] : ' ' ) ; } else if ( ( entry ! = = this . req . entry & & options . full ! = = false ) | | options . full = = = true ) options . full = ( ' / ~ ' + entry | | Config . site Url [ entry ] ) ; else options . full = ( ' / ~ ' + entry | | ' ' ) ; options . full = ' ' ; if ( S . is String ( url ) | | ! url ) { if ( url ) url = url . trim ( ) ; if ( ! url | | url = = = ' / ' ) return options . full + ' / ' ; else { if ( url . contains ( ' : / / ' ) ) return url ; if ( url . starts With ( ' \ \ / ' ) ) return url . substr ( 1 ) ; if ( url . char At ( 0 ) = = = ' / ' ) return options . full + this . router . get String Link ( this . req . lang , entry , url . substr ( 1 ) ) ; } } else { return ( options . full | | ' ' ) + this . router . get Array Link ( this . req . lang , entry , url ) ; } } 
function ( ) { var versions = [ "Msxml 2 .XMLHTTP " , "Msxml 3 .XMLHTTP " , "Microsoft .XMLHTTP " , "MSXML 2 .Xml Http . 6 . 0 " , "MSXML 2 .Xml Http . 5 . 0 " , "MSXML 2 .Xml Http . 4 . 0 " , "MSXML 2 .Xml Http . 3 . 0 " , "MSXML 2 .Xml Http . 2 . 0 " ] if ( XMLHttp Request ! = = undefined ) { 
function is Like AFuture ( x ) { return x . is Resolved ! = = undefined & & x . queue ! = = undefined & & x . then ! = = undefined } 
function ( e ) { if ( e [ 'arguments ' ] & & e . stack ) { return 'chrome ' ; } else if ( e . stack & & e . source URL ) { return 'safari ' ; } else if ( e . stack & & e . number ) { return 'ie ' ; } else if ( typeof e . message = = = 'string ' & & typeof window ! = = 'undefined ' & & window . opera ) { 
function ( context , function Name , callback ) { context = context | | window ; var original = context [ function Name ] ; context [ function Name ] = function instrumented ( ) { callback . call ( this , print Stack Trace ( ) . slice ( 4 ) ) ; return context [ function Name ] . _instrumented . apply ( this , arguments ) ; } ; context [ function Name ] . _instrumented = original ; } 
function ( e ) { var stack = ( e . stack + ' \n ' ) . replace ( / ^ \S [ ^ \ ( ] + ? [ \n $ ] / gm , ' ' ) . replace ( / ^ \s + (at eval ) ?at \s + / gm , ' ' ) . replace ( / ^ ( [ ^ \ ( ] + ? ) ( [ \n $ ] ) / gm , ' {anonymous } ( ) @ $ 1 $ 2 ' ) . replace ( / ^Object . <anonymous > \s * \ ( ( [ ^ \ ) ] + ) \ ) / gm , ' {anonymous } ( ) @ $ 1 ' ) . split ( ' \n ' ) ; stack . pop ( ) ; return stack ; } 
function ( e ) { var line RE = / ^ . *at ( \w + ) \ ( ( [ ^ \ ) ] + ) \ ) $ / gm ; return e . stack . replace ( / at Anonymous function / gm , ' {anonymous } ( ) @ ' ) . replace ( / ^ ( ? = \w +Error \ : ) . * $ \n / m , ' ' ) . replace ( line RE , ' $ 1 @ $ 2 ' ) . split ( ' \n ' ) ; } 
function ( e ) { 
function ( url ) { 
function record And Trigger Handlers ( type , event Data ) { this . history . push ( { type : type , data : event Data } ) this . handlers [ type ] . for Each ( function ( handler Info ) { try { handler Info . handler . call ( undefined , event Data ) } catch ( e ) { 
function ( name , main Tester , parent Tester ) { if ( ! main Tester ) main Tester = this this . id = groupid ( ) this . main Tester = main Tester 
function remove ( array , item ) { console . log ( "attempting to remove " + item ) var index = array . index Of ( item ) if ( index ! = = - 1 ) array . splice ( index , 1 ) 
function assert ( that , success , actual Value , expected Value , type , function Name , line Info , stack Increase ) { if ( ! stack Increase ) stack Increase = 1 if ( ! function Name ) function Name = "ok " if ( ! line Info ) var line Info Future = get Line Information ( function Name , stack Increase , that . do Sourcemappery , that . warning Handler ) else var line Info Future = Future ( line Info ) 
function get Mapped Source Info ( source Map Consumer , original File Path , original Line , original Column , original Function Name ) { var source Map Info = source Map Consumer . original Position For ( { line : original Line , column : original Column | | 0 } ) if (source Map Consumer .source Root ! = = null ) { source Map Info .source = source Map Info .source .replace (source Map Consumer .source Root , ' ' ) } * / if ( relative ) { var file = Url . resolve ( original File Path , path . basename ( source Map Info . source ) ) } else { var file = source Map Info . source } var original File = true } else { var file = original File Path var original File = false } if ( fn = = = null | | ! original File ) { fn = original Function Name } if ( line = = = null | | ! original File ) { line = original Line column = original Column } if ( column = = = null ) { column = undefined } if ( file ! = undefined & & source Map Consumer . sources Content ! = undefined ) { 
function get Function Call Lines ( sources Content , file Path , function Name , line Number , multi Line Search , warning Handler ) { if ( sources Content ! = = undefined ) { var source = Future ( sources Content ) } else { var source = options . get Script Source Lines ( file Path ) } return source . catch ( function ( e ) { warning Handler ( e ) return Future ( undefined ) } ) . then ( function ( file Lines ) { if ( file Lines ! = = undefined ) { var start Line = find Start Line ( file Lines , function Name , line Number ) if ( start Line = = = 'line Of Code Not Found ' ) { return Future ( " <line of code not found (possibly an error ? ) > " ) } else if ( start Line ! = = 'source Not Available ' ) { if ( multi Line Search ) { return Future ( find Full Source Line ( file Lines , start Line ) ) } else { return Future ( file Lines [ start Line ] . trim ( ) ) } } } 
function map Exception ( exception , warning Handler ) { try { if ( exception instanceof Error ) { var stacktrace ; return options . get Exception Info ( exception ) . then ( function ( trace ) { stacktrace = trace var smc Futures = [ ] for ( var n = 0 ; n < trace . length ; n + + ) { if ( trace [ n ] . file ! = = undefined ) { smc Futures . push ( get Source Map Consumer ( trace [ n ] . file , warning Handler ) ) } else { smc Futures . push ( Future ( undefined ) ) } } return Future . all ( smc Futures ) } ) . then ( function ( source Map Consumers ) { var Custom Mapped Exception = proto ( Mapped Exception , function ( ) { 
function find Full Source Line ( file Lines , start Line ) { var lines = [ ] var paren Count = 0 var mode = 0 
function find Start Line ( file Lines , function Name , line Number ) { var start Line = line Number - 1 while ( true ) { if ( start Line < 0 ) { return 'line Of Code Not Found ' 
function ekurtosis ( p , options ) { var opts = { } , ctor , err , out , dt , d ; if ( is Number ( p ) | | isnan ( p ) ) { return ekurtosis 1 ( p ) ; } if ( arguments . length > 1 ) { err = validate ( opts , options ) ; if ( err ) { throw err ; } } if ( is Matrix Like ( p ) ) { if ( opts . copy ! = = false ) { dt = opts . dtype | | 'float 6 4 ' ; ctor = ctors ( dt ) ; if ( ctor = = = null ) { throw new Error ( 'ekurtosis ( ) : :invalid option . Data type option does not have a corresponding array constructor . Option : ` ' + dt + ' ` . ' ) ; } 
function ( ) { 
function ( string , args ) { string = this . locale ( ) . app Translations [ string ] | | string ; return args ? UString . vformat ( string , args ) : string ; } 
function mul ( s , n ) { var copies = new Array ( n ) ; while ( n - - ) copies [ n ] = s ; return concat ( copies ) ; } 
function palindrome ( s , i , j ) { while ( i < j ) if ( s [ i + + ] ! = = s [ - - j ] ) return false ; return true ; } 
function outer ( samasa , next ) { 
function is ( argv , . . . args ) { let type = to String . call ( argv ) ; 
function Year Month Form ( { date , locale Utils , on Change , from Month , to Month } ) { const months = locale Utils . get Months ( ) ; const years = [ ] ; for ( let i = from Month . get Full Year ( ) ; i < = to Month . get Full Year ( ) ; i + = 1 ) { years . push ( i ) ; } const handle Change = function handle Change ( e ) { const { year , month } = e . target . form ; on Change ( new Date ( year . value , month . value ) ) ; } ; return ( < form class Name = "Day Picker -Caption " > < select name = "month " on Change = { handle Change } value = { date . get Month ( ) } > { months . map ( ( month , i ) = > < option key = { i } value = { i } > { month } < / option > ) } < / select > < select name = "year " on Change = { handle Change } value = { date . get Full Year ( ) } > { years . map ( ( year , i ) = > < option key = { i } value = { year } > { year } < / option > ) } < / select > < / form > ) ; } 
function ( url , belong ) { return ( belong . replace ( / ( . * [ \ / | \ \ ] ) . * / gi , " $ 1 " ) + url . replace ( / \ ? | \ # . * / gi , " " ) ) . replace ( / [ \ \ | \ / ] [ ^ \ \ | ^ \ / ] * [ \ \ | \ / ] \ . { 2 } / gi , " " ) ; } 
function ( str , dest ) { var _spilt = "cb = =cb " , _imgs = str . replace ( / \s + / gi , " " ) . replace ( / url \ ( ( [ ^ \ ) ] * ) \ ) / gi , _spilt + " $ 1 " + _spilt ) . split ( _spilt ) , _md 5 , _dest ; for ( var i = _imgs . length ; i - - ; ) { if ( i % 2 ) { _img = tool . get _resource _path ( _imgs [ i ] . replace ( / [ \ ' | \ " | \s ] * / gi , " " ) , dest ) ; if ( ! grunt . file . exists ( _img ) ) { continue ; } ; if ( ! config . resources [ _img ] ) { _md 5 = [ "resources / " , tool . md 5 ( config . md 5 + new Date ( ) . get Time ( ) + parse Int ( Math . random ( ) * 9 9 9 9 9 9 9 9 9 ) ) , _img . replace ( / . * ( \ . . * ) $ / gi , " $ 1 " ) ] . join ( " " ) ; config . resources [ _img ] = _md 5 ; } else { _md 5 = config . resources [ _img ] ; } ; _imgs [ i ] = "url ( ' . . / " + _md 5 + " ' ) " ; } ; } ; return _imgs . join ( " " ) ; } 
function ( replace , dest ) { var _buffer = [ ] , _url , _code , _files = replace . css ; for ( var i = _files . length ; i - - ; ) { _url = config . dir . src _dir + _files [ i ] ; if ( grunt . file . exists ( _url ) ) { _code = tool . fix _image _url ( grunt . file . read ( _url ) . to String ( ) , _url ) ; _buffer . push ( _code ) ; } ; } ; _code = new mincss ( config . mincss ) . minify ( _buffer . join ( " " ) ) ; grunt . file . write ( dest , _code ) ; } 
function ( replace , dest ) { var _urls = [ ] ; for ( var i = replace . js . length ; i - - ; ) { _urls . push ( config . dir . src _dir + replace . js [ i ] ) ; } ; try { grunt . file . write ( dest , minjs . minify ( _urls ) . code . to String ( ) ) ; } catch ( e ) { E ( "Error : uglify JS error . check js files " + _urls . join ( " ; " ) ) ; } } 
function ( files , replace , dest ) { var _url ; for ( var i = files . length ; i - - ; ) { _url = replace . src + files [ i ] ; tool . del _file _from _hash ( _url ) ; } ; } 
function ( ) { var _replace = this . config . tp + " $ 1 " + this . config . tp , _al = this . config . html . replace ( / ( <script [ ^ \ \ > ] *src = [ ^ \ \ > ] * > < \ /script > ) / gi , _replace ) . split ( this . config . tp ) , _js = [ ] , _url = "js / " + this . config . md 5 + " .js " ; for ( var i = _al . length ; i - - ; ) { if ( i % 2 ) { tool . check File Status ( _al [ i ] . replace ( / . *src = [ ' | " ] ( [ ^ ' | ^ " ] * ) [ ' | " ] . * / gi , " $ 1 " ) , function ( exists , file Path ) { if ( exists ) { _js . push ( file Path ) ; _al [ i ] = " " ; } else { if ( ! config . file _path . fetch Url [ file Path ] ) { config . file _path . fetch Url [ file Path ] = tool . get _file _ts ( file Path ) ; } _al [ i ] = " <script type = 'text /javascript ' src = ' " + config . file _path . fetch Url [ file Path ] + " ' > < /script > " ; } ; } ) ; } ; } ; if ( _js . length ) { _al [ _al . length - 2 ] + = " <script type = 'text /javascript ' src = ' " + config . redirect Origin + _url + " ' > < /script > " ; this . config . js = _js ; tool . uglify _js ( this . config , config . dir . pub _dir + _url ) ; tool . concat _done ( _js , this . config , config . dir . pub _dir + _url ) ; } ; return _al . join ( " " ) ; } 
function Floodgate ( opts ) { if ( ! ( this instanceof Floodgate ) ) return new Floodgate ( opts ) ; opts = opts | | { } ; Transform . call ( this , opts ) ; this . _interval = opts . interval | | 0 ; } 
function remove ( obj , path , i ) { i = i | | 0 var key = path [ i ] , last = i = = = path . length - 1 if ( ! obj | | typeof obj ! = = 'object ' ) { throw new Error ( 'Can \ 't remove key ' + key + ' from non -object ' ) } if ( Array . is Array ( obj ) ) { if ( typeof key ! = = 'number ' ) { obj . for Each ( function ( each ) { remove ( each , path , i ) } ) } else if ( key > = 0 & & key < obj . length ) { if ( last ) { obj . splice ( key , 1 ) } else { remove ( obj [ key ] , path , i + 1 ) } } else { throw new Error ( 'Can \ 't remove index ' + key + ' from an array with ' + obj . length + ' elements ' ) } } else { if ( typeof key ! = = 'string ' ) { throw new Error ( 'Can \ 't remove the numeric key ' + key + ' from an object ' ) } else if ( key in obj ) { if ( last ) { delete obj [ key ] } else { remove ( obj [ key ] , path , i + 1 ) } } else { throw new Error ( 'Can \ 't remove key ' + key + ' from the object ' ) } } } 
function add ( obj , path , value , i ) { i = i | | 0 var key = path [ i ] , last = i = = = path . length - 1 if ( ! obj | | typeof obj ! = = 'object ' ) { throw new Error ( 'Can \ 't add key ' + key + ' to non -object ' ) } if ( Array . is Array ( obj ) ) { if ( typeof key ! = = 'number ' ) { obj . for Each ( function ( each ) { add ( each , path , value , i ) } ) } else if ( key > = 0 & & key < = obj . length ) { if ( last ) { obj [ key ] = value } else { add ( obj [ key ] , path , value , i + 1 ) } } else { throw new Error ( 'Can \ 't add index ' + key + ' to an array with ' + obj . length + ' elements ' ) } } else { if ( typeof key ! = = 'string ' ) { throw new Error ( 'Can \ 't add the numeric key ' + key + ' to an object ' ) } else { if ( last ) { obj [ key ] = value } else { if ( ! ( key in obj ) ) { obj [ key ] = Object . create ( null ) } add ( obj [ key ] , path , value , i + 1 ) } } } } 
function ( names ) { var attributes = Array . prototype . slice . call ( arguments ) ; attributes = _ . without ( attributes , this . get Metadata Attributes ( true ) ) ; this . _usergrid . attrs = attributes ; } 
function ( uuid _or _name , cb ) { if ( _ . is Object ( uuid _or _name ) ) { return cb ( new Error ( 'parameter must be a uuid or name ' ) ) ; } var self = this ; client . get Entity ( { type : self . _usergrid . type , uuid : uuid _or _name } , translate SDKCallback ( function ( err , entity ) { if ( err ) { return cb ( err ) ; } cb ( null , wrap ( self , entity ) ) ; } ) ) ; } 
function ( criteria , limit , cb ) { if ( _ . is Function ( limit ) ) { cb = limit ; limit = undefined ; } var self = this ; var query = build Query ( criteria , limit ) ; client . create Collection ( options ( self , query ) , translate SDKCallback ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } cb ( null , wrap Collection ( self , collection ) ) ; } ) ) ; } 
function ( attributes , cb ) { if ( _ . is Array ( attributes ) ) { var self = this ; for ( var i = 0 ; i < attributes . length ; i + + ) { 
function ( attributes , cb ) { var id = attributes . uuid | | attributes . name | | attributes . username ; this . find ( id , function ( err , entity ) { if ( err ) { return cb ( err ) ; } entity . update ( attributes , cb ) ; } ) ; } 
function ( criteria , cb ) { var self = this ; this . first ( criteria , function ( err , entity ) { if ( err ) { return cb ( err ) ; } if ( entity ) { cb ( null , entity ) ; } else { self . create ( criteria , cb ) ; } } ) ; } 
function ( criteria , cb ) { if ( _ . is Function ( criteria ) ) { cb = criteria ; criteria = undefined ; } var self = this ; var query = build Query ( criteria ) ; client . delete ( options ( self , query ) , translate SDKCallback ( function ( err , data ) { if ( err ) { return cb ( err ) ; } cb ( null , data . entities . length ) ; } ) ) ; } 
function ( criteria , cb ) { if ( _ . is Function ( criteria ) ) { cb = criteria ; criteria = undefined ; } this . find By ( criteria , function ( err , entities ) { if ( err ) { return cb ( err ) ; } var delete Entity = function ( entity , callback ) { entity . delete ( callback ) ; } ; async . each ( entities , delete Entity , function ( err ) { cb ( err ) ; } ) ; } ) ; } 
function ( attributes ) { if ( _ . is String ( attributes ) ) { attributes = { uuid : attributes } ; } 
function options ( Class , hash ) { var opts ; var type = { type : Class . _usergrid . type } ; if ( hash ) { opts = _ . assign ( { } , hash , type ) ; } else { opts = type ; } return opts ; } 
function wrap ( Class , entity ) { Usergrid Entity . prototype = entity ; Class . _usergrid . constructor . prototype = new Usergrid Entity ( ) ; entity = new Class . _usergrid . constructor ( ) ; entity . _class = Class ; define Attributes ( entity ) ; add Connection Functions ( entity , Class . _usergrid . connections ) ; return entity ; } 
function ( sender , parent , key , value ) { this . scrubber = sender this . parent = parent this . key = key this . value = value } 
function ( ) { if ( this . ie Version ! = = undefined ) return this . ie Version ; var ua = this . headers [ 'user -agent ' ] , m ; if ( ! ua | | ! ( m = ua . match ( / MSIE ( [ \d \ . ] + ) / i ) ) ) return this . ie Version = false ; return this . ie Version = m [ 1 ] ; } 
function define ( Class , constructor , type ) { if ( ! client ) { throw new Error ( 'Usergrid not configured ' ) ; } if ( typeof Class = = = 'function ' ) { type = constructor ; constructor = Class ; Class = { } ; } Class . _usergrid = { constructor : constructor , type : ( type ) ? type : constructor . name . to Lower Case ( ) } ; _ . mixin ( Class , usergrid Statics ( client ) ) ; return Class ; } 
function Savesprite Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 2 ) throw new Syntax Error ( 'SAVESPRITE command requires 2 arguments ' ) ; this . id = parsed . args [ 0 ] ; this . file Name = parsed . args [ 1 ] ; } 
function tombstone Query ( name , query , opts ) { const tombstone Key = opts & & ( typeof opts . tombstone Key Getter = = = 'function ' ) ? opts . tombstone Key Getter ( name ) : null ; if ( ! tombstone Key ) return query ; const cond = { [ tombstone Key ] : { $ne : true } } ; if ( query . _conditions . $and & & Array . is Array ( query . _conditions . $and ) ) { query . _conditions . $and . push ( cond ) ; } else { Object . assign ( query . _conditions , cond ) ; } return query ; } 
function find Index Of Syllable ( split Array , syllable Number , split Regex ) { let syllable Count = 0 ; for ( let i = 0 ; i < split Array . length ; i + + ) { if ( ! split Array [ i ] . match ( split Regex ) ) { syllable Count + + ; } 
function defer ( func ) { return new ( class { constructor ( generator ) { this . generator = generator ; } [ Symbol . iterator ] ( ) { return this . generator ( ) [ Symbol . iterator ] ( ) ; } } ) ( func ) ; } 
function range ( start , count , inc = 1 ) { return defer ( function * ( ) { for ( let i = 0 ; i < count ; + + i ) { yield start + ( i * inc ) ; } } ) ; } 
function fibonacci ( ) { return defer ( function * ( ) { let prev = 1 ; let curr = 1 ; yield prev ; yield curr ; for ( ; ; ) { let temp = prev ; prev = curr ; curr = temp + curr ; yield curr ; } } ) ; } 
function primes ( limit ) { if ( limit ! = null ) { / / https : / /en .wikipedia .org /wiki /Sieve _of _Eratosthenes return defer ( function * ( ) { let set = Array . from ( range ( 3 , ( limit / 2 ) - 1 , 2 ) ) ; let curr = 3 ; const sqrt Limit = Math . sqrt ( limit ) ; yield 2 ; let last Index = 0 ; while ( curr < = sqrt Limit ) { yield curr ; set = set . splice ( 0 , last Index ) . concat ( set . splice ( last Index + 1 ) . filter ( s = > s % curr ! = = 0 ) ) ; last Index = set . find Index ( s = > s > curr ) ; if ( last Index = = null ) { return ; } curr = set [ last Index ] ; } yield curr ; yield * set . slice ( last Index + 1 ) ; } ) ; } return defer ( function * ( ) { const previous Primes = [ 2 , 3 ] ; yield 2 ; yield 3 ; for ( let curr = 5 ; ; curr + = 2 ) { let allowed = true ; const sqrt = Math . sqrt ( curr ) ; for ( const prime of previous Primes ) { if ( prime > sqrt ) { break ; } else if ( curr % prime = = = 0 ) { allowed = false ; break ; } } if ( allowed ) { previous Primes . push ( curr ) ; yield curr ; } } } ) ; } 
function create Regexp ( s ) { let m Exp = / ^ \ / ( . * ) \ / ( [gimy ] * ) $ / . exec ( s ) if ( m Exp ) { return new Reg Exp ( m Exp [ 1 ] , m Exp [ 2 ] ) } else { return new Reg Exp ( s ) } } 
function forward ( event , source , target ) { source . on ( event , target . emit . bind ( target , event ) ) ; } 
function ( state , scope , secondary Scope ) { if ( ! validators . is Block Start ( state ) ) return state . error ( constants . unexpected Token ) ; state . next ( ) ; 
function ( state , scope , secondary Scope ) { state . create Lexical Environment ( ) ; state . level Down ( scope ) ; if ( secondary Scope ) state . level Down ( secondary Scope ) ; while ( state . token & & ! validators . is Block End ( state ) ) { state . processor . token ( state ) ; } if ( secondary Scope ) state . level Up ( ) ; state . level Up ( ) ; state . finalize Lexical Environment ( ) ; } 
function ( state , no Error ) { if ( validators . is Semicolon ( state ) ) { state . next ( ) ; } else if ( state . token & & ! validators . is Block End ( state ) ) { var lb = state . lookback ( ) ; if ( ! lb | | state . token . line = = = lb . line ) { if ( ! no Error ) state . error ( constants . unexpected Token ) ; return false ; } } return true ; } 
function Readpixel Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 2 ) throw new Syntax Error ( 'READPIXEL command requires 2 arguments ' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; } 
function get Value ( value ) { var data = value , result = value ; if ( typeof data = = = 'string ' ) { try { if ( ! data | | data = = = 'true ' ) { result = true ; } else if ( data = = = 'false ' ) { result = false ; } else if ( data = = = 'null ' ) { result = null ; } else if ( + data + ' ' = = = data ) { result = + data ; } else { result = rbrace . test ( data ) ? JSON . parse ( data ) : data ; } } catch ( error ) { } } return result ; } 
function ( config ) { if ( ! config ) { return " " ; } var result = [ ] ; for ( var key in config ) { if ( typeof config [ key ] = = "undefined " ) { continue ; } result . push ( key + " = " + config [ key ] ) ; } if ( result . length > 0 ) { return " ? " + result . join ( " & " ) ; } return " " ; } 
function ( consumer Key , consumer Secret , application Name , format , use Compression ) { this . event Handlers = { } ; this . consumer Key = consumer Key ; this . consumer Secret = consumer Secret ; this . use Compression = use Compression | | true ; this . format = format | | "json " ; this . accept Encoding = this . use Compression ? 'gzip , deflate ' : 'identity ' ; this . application Name = application Name ? ( application Name + " / " ) : " " ; if ( ! this . consumer Key | | ! this . consumer Secret ) { throw "Consumer Key and Consumer Secret should be specified in order to use SDK " ; } this . application Name + = this . tpl ( "Java Script / {SDK _VERSION } / {format } " , { SDK _VERSION : this . SDK _VERSION , format : this . format } ) ; } 
function debounced ( . . . args ) { let now = + new Date ( ) , remaining ; 
function Notification ( obj Google Checkout ) { var self = this ; 
function save ( file , options ) { var stream = fs . create Write Stream ( file , options ) ; function on Save ( ) { stream . remove All Listeners ( ) ; this . emit ( 'save ' ) ; } function on Error ( err ) { stream . remove All Listeners ( ) ; this . emit ( 'error ' , err ) ; } stream . on ( 'finish ' , on Save . bind ( this ) ) ; stream . on ( 'error ' , on Error . bind ( this ) ) ; this . pipe ( stream ) ; return this ; } 
function find Path ( request , paths ) { if ( paths . length = = 1 & & / ^ \ . { 2 } / . test ( request ) ) { paths [ 0 ] = path . dirname ( paths [ 0 ] ) request = request . slice ( 1 ) } return original Find Path ( request , paths ) } 
function run ( js , path ) { var m = new Module ( path , module ) Module . _find Path = find Path m . paths = Module . _node Module Paths ( dirname ( path ) ) m . id = path m . filename = path js = 'module .return =eval ( ' + json ( js ) + ' ) ' m . _compile ( js , path ) Module . _find Path = original Find Path return m } 
function final _s _zero ( hash ) { var stem = [ hash . stem , ' स ् ' ] .jo i n ( ' ' ) ; if ( stem = = hash . stem ) return ; if ( ! hash . stems ) hash . stems = [ ] ; hash . stems . push ( stem ) ; } 
function retroflex _k ( hash ) { var stemh = hash . stem . replace ( / क ् $ / , ' ह ् ) ; var stemz = hash . stem . replace ( / क ् $ / , ' ष ् ' ) ; var stemj = hash . stem . replace ( / क ् $ / , ' ज ् ' ) ; var stemc = hash . stem . replace ( / क ् $ / , ' च ् ' ) ; if ( stemh = = hash . stem & & stemz = = hash . stem & & stemj = = hash . stem ) return ; hash . stems = [ stemh , stemz , stemj , stemc ] ; if ( debug ) log ( 'mod : retroflex _k ' , hash . stems ) ; } 
function h _like _gh _other ( hash ) { 
function move _aspirate _forward ( hash ) { var asp = u . unasp 2asp ( hash . stem Ult ) ; if ( ! asp ) return ; var stem = u . replace End ( hash . stem , hash . stem Ult , asp ) ; if ( ! stem | | stem = = hash . stem ) return ; hash . stems = [ stem ] ; if ( debug ) log ( 'mod : move _aspirate _forward ' , stem ) ; } 
function get ( options , config ) { options = options | | found config = config | | { } 
function load ( dir , name ) { 
function decorate ( object , values ) { for ( var key in values ) { if ( typeof object [ key ] = = = 'object ' ) { decorate ( object [ key ] , values [ key ] ) } else { object [ key ] = values [ key ] } } } 
function hide ( object , name , value ) { Object . define Property ( object , name , { enumerable : false , value : value } ) } 
function _instance Copy ( source Ref , copy Ref , rc , copier ) { let orig Index = rc . x Stack . index Of ( source Ref ) ; if ( orig Index = = = - 1 ) { rc . push ( source Ref , copy Ref ) ; for Each ( source Ref , function ( value , key ) { copier ( copy Ref , value , key ) ; } ) ; rc . pop ( ) ; return copy Ref ; } else return rc . y Stack [ orig Index ] ; } 
function _object Copy ( source Ref , copy Ref , rc ) { let orig Index = rc . x Stack . index Of ( source Ref ) ; if ( orig Index = = = - 1 ) { rc . push ( source Ref , copy Ref ) ; for ( let [ key , val ] of _entries ( source Ref ) ) copy Ref [ key ] = _clone ( val , rc ) ; let symbols = Object . get Own Property Symbols ( source Ref ) ; for ( let symbol of symbols ) copy Ref [ symbol ] = _clone ( source Ref [ symbol ] , rc ) ; rc . pop ( ) ; return copy Ref ; } else return rc . y Stack [ orig Index ] ; } 
function _set Copy ( source Ref , copy Ref , rc ) { return _instance Copy ( source Ref , copy Ref , rc , ( set , val ) = > { set . add ( _clone ( val , rc ) ) ; } ) ; } 
function _map Copy ( source Ref , copy Ref , rc ) { return _instance Copy ( source Ref , copy Ref , rc , ( map , val , key ) = > { map . set ( key , _clone ( val , rc ) ) ; } ) ; } 
function _single Copy ( source Ref , copy Ref , rc ) { return _instance Copy ( source Ref , copy Ref , rc , ( item , val , key ) = > { copy Ref [ key ] = _clone ( val , rc ) ; } ) ; } 
function clone ( orig Source ) { let orig Index = - 1 ; let rc = new Recurse Counter ( 1 0 0 0 ) ; return _clone . call ( null , orig Source , rc ) ; } 
function _equals ( x , y , rc ) { if ( rc . count > rc . max Stack Depth ) throw new Error ( "Stack depth exceeded : " + rc . max Stack Depth + " ! " ) ; / / check for reference and primitive equality if ( x = = = y ) return true ; / / check for type equality let x Type = get Type ( x ) ; let y Type = get Type ( y ) ; if ( x Type ! = = y Type ) return false ; / / check for circular references let x Index = rc . x Stack . last Index Of ( x ) ; let y Index = rc . y Stack . last Index Of ( y ) ; if ( x Index ! = = - 1 ) { if ( y Index = = = x Index ) return true ; } / / check for inequalities switch ( x Type ) { case types . number : if ( x ! = = y ) { if ( is Na N ( x ) & & is Na N ( y ) ) return true ; return false ; } break ; case types . date : if ( x . get Time ( ) ! = = y . get Time ( ) ) return false ; / / check for extra properties stored on the Date object if ( ! _compare Object ( x , y , rc ) ) return false ; break ; case types . array : if ( x . length ! = = y . length ) return false ; rc . push ( x , y ) ; for ( let i = 0 ; i < x . length ; i + + ) { if ( ! _equals ( x [ i ] , y [ i ] , rc ) ) return false ; } rc . pop ( ) ; break ; case types . map : if ( x . size ! = = y . size ) return false ; let x Map Arr = [ . . . x ] ; / / these need to be sorted by key before comparison let y Map Arr = [ . . . y ] ; / / order shouldn 't matter , as long as they are the same x Map Arr . sort ( ( a , b ) = > { return a [ 0 ] > b [ 0 ] ? 1 : a [ 0 ] < b [ 0 ] ? - 1 : 0 ; } ) ; y Map Arr . sort ( ( a , b ) = > { return a [ 0 ] > b [ 0 ] ? 1 : a [ 0 ] < b [ 0 ] ? - 1 : 0 ; } ) ; if ( ! _equals ( x Map Arr , y Map Arr , rc ) ) return false ; break ; case types . set : if ( x . size ! = = y . size ) return false ; let x Arr = [ . . . x ] ; / / consider doing a comparison without converting to array ? let y Arr = [ . . . y ] ; / / converting to array may still be the fastest option . if ( ! _equals ( x Arr , y Arr , rc ) ) return false ; break ; case types . function : if ( ! _compare Object ( x , y , rc ) ) / / check for properties on function return false ; if ( x ! = = y ) return false ; / / other than that , just use reference equality for now break ; case types . object : if ( Buffer . is Buffer ( x ) ) { if ( ! Buffer . is Buffer ( y ) ) return false ; if ( x . length ! = = y . length ) return false ; if ( ! x . equals ( y ) ) return false ; } else { if ( ! _compare Object ( x , y , rc ) ) return false ; } break ; case types . regexp : if ( ! _equals ( x . to String ( ) , y . to String ( ) , rc ) ) return false ; if ( ! _compare Object ( x , y , rc ) ) return false ; break ; case types . boolean : case types . string : case types . symbol : if ( x ! = = y ) return false ; break ; default : if ( ! _compare Object ( x , y , rc ) ) return false ; break ; } return true ; } 
function _compare Object ( x , y , rc ) { if ( x = = = y ) return true ; if ( x . constructor & & y . constructor & & x . constructor ! = = y . constructor ) return false ; let x Keys = Object . keys ( x ) ; let y Keys = Object . keys ( y ) ; x Keys . sort ( ) ; y Keys . sort ( ) ; if ( ! _equals ( x Keys , y Keys , rc ) ) return false ; rc . push ( x , y ) ; for ( let k in x ) { if ( ! _equals ( x [ k ] , y [ k ] , rc ) ) return false ; } rc . pop ( ) ; return true ; } 
function equals ( x , y ) { let rc = new Recurse Counter ( 1 0 0 0 ) ; return _equals . call ( null , x , y , rc ) ; } 
function for Each ( item , method , context ) { let type = get Type ( item ) ; switch ( type ) { case types . date : case types . function : case types . object : case types . regexp : if ( ! item [ Symbol . iterator ] ) { for ( let [ key , value ] of _entries ( item ) ) { if ( item . has Own Property ( key ) ) method . call ( context , value , key , item ) ; } } else { / / shenanigans for ( let value of item ) { / / do we want to check if value is array , and spread it across value /key ? method . call ( context , value , undefined , item ) ; } } break ; case types . arguments : case types . array : for ( let i = 0 ; i < item . length ; i + + ) method . call ( context , item [ i ] , i , item ) ; break ; case types . map : for ( let [ key , value ] of item ) method . call ( context , value , key , item ) ; break ; case types . set : for ( let value of item ) / / treat keys and values as equivalent for sets method . call ( context , value , value , item ) ; break ; default : / / if unknown type , then check for Symbol .iterator if ( item [ Symbol . iterator ] ) { for ( let value of item [ Symbol . iterator ] ( ) ) method . call ( context , value , undefined , item ) ; } else if ( ! typeset . has ( type ) & & type & & type . constructor ) { for ( let [ key , value ] of _entries ( item ) ) { if ( item . has Own Property ( key ) ) / / necessary with _entries ? method . call ( context , value , key , item ) ; } } break ; } return item ; } 
function _inspect ( inspecting , inspection = ' ' , seen = [ ] , times = 0 , indent = 2 ) { let type = get Type ( inspecting ) ; switch ( type ) { case types . undefined : return 'undefined ' ; case types . null : return 'null ' ; case types . function : let name = inspecting . name ? ' : ' + inspecting . name : ' ' ; return ` $ { name } ` ; case types . string : return ` $ { inspecting } ` ; case types . array : if ( seen . index Of ( inspecting ) > - 1 ) return ' [Circular ] ' ; times + + ; inspection = ' [ ' ; seen . push ( inspecting ) ; var inspected = [ ] ; for ( let val of inspecting ) inspected . push ( _inspect ( val , inspection , seen , times ) ) ; if ( inspected . length = = = 0 ) return ' [ ] ' ; let length = inspected . reduce ( ( prev , cur ) = > { return prev + cur . length ; } , 0 ) ; if ( length > 6 0 ) inspection = ' [ ' + inspected . join ( ' , \n ' + ' ' . repeat ( times * indent ) ) + ' ] ' ; else inspection = ' [ ' + inspected . join ( ' , ' ) + ' ] ' ; return inspection ; case types . object : if ( seen . index Of ( inspecting ) > - 1 ) return ' [Circular ] ' ; times + + ; inspection = ' { ' ; seen . push ( inspecting ) ; let obj Inspected = [ ] ; if ( inspecting instanceof Error ) / / to match nodejs inspect methods obj Inspected . push ( ' [ ' + inspecting . to String ( ) + ' ] ' ) ; for ( let [ key , val ] of each ( inspecting ) ) obj Inspected . push ( key + ' : ' + _inspect ( val , inspection , seen , times ) ) ; if ( obj Inspected . length = = = 0 ) return ' { } ' ; let obj Length = obj Inspected . reduce ( ( prev , cur ) = > { return prev + cur . length ; } , 0 ) ; if ( obj Length > 6 0 ) inspection = ' { \n ' + ' ' . repeat ( times * indent ) + obj Inspected . join ( ' , \n ' + ' ' . repeat ( times * indent ) ) + ' } ' ; else inspection = ' { ' + obj Inspected . join ( ' , ' ) + ' } ' ; return inspection ; case types . map : case types . set : return _inspect ( [ . . . inspecting ] ) ; case types . number : case types . boolean : default : if ( inspecting instanceof Error ) return ' [ ' + inspecting . to String ( ) + ' ] ' ; return inspecting . to String ( ) ; } } 
function type For Extend ( val ) { / / treat unknown types (classes , hopefully ? ) and functions as objects let type = get Type ( val ) ; if ( type = = = types . function | | ! typeset . has ( type ) & & type & & type . constructor ) type = types . object ; return type ; } 
function is Extendable ( . . . args ) { / / this is a fairly expensive call . find a way to optimize further ? if ( args . length < 1 ) return false ; let base Type = type For Extend ( args [ 0 ] ) ; if ( ! ( base Type = = = types . array | | base Type = = = types . object | | base Type = = = types . set | | base Type = = = types . map | | base Type = = = types . function ) ) { return false ; } for ( let i = 1 ; i < args . length ; i + + ) { let target Type = type For Extend ( args [ i ] ) ; if ( target Type ! = = base Type ) return false ; } return true ; } 
function _extend ( a , b ) { for Each ( b , ( b Val , key ) = > { let type = type For Extend ( a ) ; switch ( type ) { case types . array : case types . object : if ( a [ key ] = = = undefined | | a [ key ] = = = null ) a [ key ] = b [ key ] ; else if ( is Extendable ( a [ key ] , b [ key ] ) ) _extend ( a [ key ] , b [ key ] ) ; break ; case types . set : if ( ! a . has ( b Val ) ) a . add ( b Val ) ; break ; case types . map : if ( ! a . has ( key ) ) a . set ( key , b Val ) ; else { let a Val = a . get ( key ) ; if ( a Val = = = undefined | | a Val = = = null ) a . set ( key , b Val ) ; else if ( is Extendable ( a Val , b Val ) ) _extend ( a Val , b Val ) ; } break ; } } ) ; return a ; } 
function extend ( a , . . . rest ) { rest . for Each ( b = > { if ( is Extendable ( a , b ) ) _extend ( a , b ) ; } ) ; return a ; } 
function _smash ( a , b ) { this . for Each ( b , ( val , key ) = > { if ( this . is Smashable ( a [ key ] , b [ key ] ) ) / / find a way to move is Smashable internal this . _smash ( a [ key ] , b [ key ] ) ; else a [ key ] = this . deep Copy ( b [ key ] ) ; } ) ; return a ; } 
function smash ( a , . . . rest ) { rest . for Each ( b = > { if ( this . is Smashable ( a , b ) ) / / find a way to move is Smashable internal this . _smash ( a , b ) ; } ) ; return a ; } 
function Xublit App ( opts ) { _class Call Check ( this , Xublit App ) ; var _this = _possible Constructor Return ( this , Object . get Prototype Of ( Xublit App ) . call ( this ) ) ; opts = parse Options ( _this , opts ) ; init Injector ( _this , { base Dir : opts . base Dir , include Dirs : _this . include Dirs , bootstrap Scope Vars : { app : _this } } ) ; return _this ; } 
function File ( name , file , parent ) { this . name = name ; this . file = file ; this . parent = parent ; this . read Cursor = 0 ; this . eof = false ; } 
function ( error , cb ) { var do Shutdown = function ( ) { var cb 0 = function ( err 0 ) { if ( err 0 ) { $ . _ . $ . log & & $ . _ . $ . log . fatal ( 'handle Error : Critical shutdown ' + ' failed , exiting ' + my Utils . err To Pretty Str ( err 0 ) ) ; * * Not enough to abort , force a CA shutdown . * * When this CA recovers from the shutdown , * if the checkpoint made it to persistent * storage it will redo the commit actions ( *always * assumed * to be idempotent ) . * * We cannot imply that `checkpoint Failure ` means it did * not make it to storage . That 's the reason * we have to shutdown , because it may have been logged as * pending to be committed . . . * / $ . _ . $ . log & & $ . _ . $ . log . debug ( 'handle Error : Sys Error shutdown CA : ' + my Utils . err To Pretty Str ( error ) ) ; do Shutdown ( ) ; } else { $ . _ . $ . log & & $ . _ . $ . log . debug ( 'handle Error : Sys Error aborting : ' + my Utils . err To Pretty Str ( error ) ) ; do Abort ( ) ; } } else { / / This is a bug , all the errors should be App or System by now . var msg = ( error & & ( typeof error = = = 'object ' ? my Utils . err To Pretty Str ( error ) : JSON . stringify ( error ) ) ) ; $ . _ . $ . log & & $ . _ . $ . log . fatal ( 'handle Error : error is neither ' + ' App or System ' + msg ) ; process . exit ( 1 ) ; } } 
function ( msg , code , error Str , cb ) { return function ( error , data ) { if ( error ) { error = json _rpc . new Sys Error ( msg , code , error Str , error ) ; } cb ( error , data ) ; } ; } 
function get Time Difference ( timestr 1 , timestr 2 ) { if ( typeof timestr 1 ! = = 'string ' | | typeof timestr 2 ! = = 'string ' ) { throw new Error ( 'pendel .time ( ) expects string arguments ' ) ; } 
function get Date Difference ( timestr 1 , timestr 2 ) { 
function short Time To Date String ( short Time ) { 
function get Total Results From Epochs ( epoch 1 , epoch 2 ) { var millisecs = Math . abs ( epoch 1 - epoch 2 ) ; var seconds = millisecs / 1 0 0 0 ; return { total Seconds : seconds , total Minutes : Math . floor ( seconds / 6 0 ) , total Hours : Math . floor ( seconds / 6 0 ) * 6 0 } ; } 
function Input Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( ! parsed . args . length ) throw new Syntax Error ( 'INPUT requires at least one argument ' ) ; var question = " " , place Var , file ; if ( parsed . args . length = = = 1 ) place Var = parsed . args [ 0 ] ; else { if ( parsed . args [ 0 ] . child instanceof statements . Pointer Statement ) file = parsed . args [ 0 ] ; else question = parsed . args [ 0 ] ; place Var = parsed . args [ 1 ] ; } if ( ! ( place Var . child instanceof statements . Variable Statement | | place Var . child instanceof statements . Function Statement ) ) throw new Syntax Error ( 'Expected variable ' ) ; this . file = file ; this . question = question ; this . place Var = place Var ; } 
function Piechart Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 8 ) throw new Syntax Error ( 'PIECHART command requires 8 arguments ' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; this . r = parsed . args [ 2 ] ; this . items Length = parsed . args [ 3 ] ; this . percentages = parsed . args [ 4 ] ; this . items Red = parsed . args [ 5 ] ; this . items Green = parsed . args [ 6 ] ; this . items Blue = parsed . args [ 7 ] ; } 
function util Tick Call ( callback , self , opt ) { var args = opt . args ; if ( args = = = undefined ) { args = opt ; } args = [ ] . concat ( args ) ; callback . apply ( self , args ) ; if ( is Type ( opt . complete , type Name Function ) ) { opt . complete . apply ( self , args ) ; } } 
function ( name , obj ) { var parts = name . split ( ' . ' ) , parent = this , length ; length = parts . length - 1 ; for ( var i = 0 , m = length ; i < m ; i + = 1 ) { parent [ parts [ i ] ] = parent [ parts [ i ] ] | | { } ; parent = parent [ parts [ i ] ] ; } if ( obj ) { if ( ! is Type ( parent [ parts [ length ] ] , type Name Undefined ) ) { throw new Error ( "Can 't overwrite ' " + name + " ' of defined ! " ) ; } parent [ parts [ length ] ] = obj ; } else if ( is Type ( parent [ parts [ length ] ] , type Name Undefined ) ) { parent [ parts [ length ] ] = { } ; } return parent [ parts [ length ] ] ; } 
function ( self , callback , opt , async ) { opt = opt | | { } ; self = self | | opt . self ; if ( opt . async ) { async = true ; delete opt . async ; } if ( async ) { g . Crisp . next Tick ( util Tick Call , callback , self , opt ) ; return self ; } else { util Tick Call ( callback , self , opt ) ; } return self ; } 
function ( name ) { var args = [ this ] ; arguments . x Each ( { start : 1 } , function ( item ) { args . push ( item ) ; } ) ; return Math [ name ] . apply ( Math , args ) ; } 
function util Tack ( method Callback , method Schema ) { function tack Default ( opt , success , complete ) { var async ; if ( opt . async ) { async = opt . async ; delete opt . async ; } 
function call Schema ( schema , args ) { var key ; var opt = { } ; if ( Crisp . type . call ( args [ 0 ] , 'Object ' ) ) { return args [ 0 ] ; } schema = schema | | [ ] ; for ( var i = 0 , m = args . length ; i < m ; i + = 1 ) { key = schema [ i ] | | i ; opt [ key ] = args [ i ] ; } return opt ; } 
function x Add Array ( ) { var i = 0 , m = arguments . length , a ; for ( ; i < m ; i + = 1 ) { a = arguments [ i ] ; if ( $ $ . type . call ( a , 'Array ' ) ) { x Add Array . apply ( this , a ) ; } else if ( a ! = = undefined ) { this . push ( a ) ; } } return this ; } 
function x Each Array ( option , success , picker ) { var index , i = 0 , reverse = 1 , length = this . length , start = option . start ? Number ( option . start ) : 0 , limit = option . limit = = = undefined ? length : Number ( option . limit ) ; if ( limit < = 0 ) { limit = length ; } if ( start < 0 ) { start = length + start ; } if ( start + limit > length ) { limit - = start + limit - length ; } if ( start < 0 ) { start = 0 ; limit = length ; } if ( option . reverse ) { reverse = - 1 ; start - = length + reverse ; } for ( ; i < limit ; i + = 1 ) { try { index = ( i + start ) * reverse ; success . call ( option . self , this [ index ] , index , picker ) ; } catch ( e ) { if ( e instanceof Break ) { if ( option . limit & & ( option . reverse | | ( index < length & & limit < length ) ) ) { limit + = 1 ; } } else if ( e instanceof End | | index < 0 ) { return this ; } else { throw e ; } } } return this ; } 
function x Each Object ( option , success , picker ) { var index , keys = Object . keys ( this ) , i = 0 , reverse = 1 , length = keys . length , start = option . start ? Number ( option . start ) : 0 , limit = option . limit = = = undefined ? length : Number ( option . limit ) , name ; if ( limit < = 0 ) { limit = length ; } if ( start < 0 ) { start = length + start ; } if ( start + limit > length ) { limit - = start + limit - length ; } if ( start < 0 ) { start = 0 ; limit = length ; } if ( option . reverse ) { reverse = - 1 ; start - = length + reverse ; } for ( ; i < limit ; i + = 1 ) { try { index = ( i + start ) * reverse ; name = keys [ index ] ; success . call ( option . self , this [ name ] , name , picker ) ; } catch ( e ) { if ( e instanceof Break ) { if ( option . limit & & ( option . reverse | | ( index < length & & limit < length ) ) ) { limit + = 1 ; } } else if ( e instanceof End | | index < 0 ) { return this ; } else { throw e ; } } } return this ; } 
function tap ( tapper ) { return function * ( it ) { let index = 0 ; for ( const value of it ) { tapper ( value , index ) ; yield value ; index = index + 1 ; } } ; } 
function map ( mapper ) { return function * ( iterable ) { let index = 0 ; for ( const value of iterable ) { yield mapper ( value , index ) ; index = index + 1 ; } } ; } 
function flat Map ( mapper ) { return function * ( iterable ) { let index = 0 ; for ( const value of iterable ) { const inner Iterable = mapper ( value , index ) ; for ( const inner of inner Iterable ) { yield inner ; } index = index + 1 ; } } ; } 
function filter ( predicate ) { return function * ( iterable ) { let index = 0 ; for ( const value of iterable ) { if ( predicate ( value , index ) ) { yield value ; } index = index + 1 ; } } ; } 
function reduce ( predicate , initial ) { return function ( iterable ) { let index = 0 ; let prev State = initial ; for ( const value of iterable ) { prev State = predicate ( prev State , value , index ) ; index = index + 1 ; } return prev State ; } ; } 
function take ( count ) { return function * ( iterable ) { let i = 0 ; for ( const item of iterable ) { if ( i > = count ) { return ; } yield item ; i = i + 1 ; } } ; } 
function take Last ( count ) { return function * ( iterable ) { const buffer = [ ] ; for ( const item of iterable ) { buffer . push ( item ) ; if ( buffer . length > count ) { buffer . shift ( ) ; } } return yield * buffer ; } ; } 
function skip Last ( count ) { return function * ( iterable ) { const buffer = [ ] ; for ( const item of iterable ) { buffer . push ( item ) ; } if ( buffer . length < count ) { return ; } yield * buffer . slice ( 0 , buffer . length - count ) ; } ; } 
function last ( iterable ) { let last = undefined ; for ( const item of iterable ) { last = item ; } return last ; } 
function skip ( count ) { return function * ( iterable ) { let i = 0 ; for ( const item of iterable ) { if ( i > = count ) { yield item ; } i = i + 1 ; } } ; } 
function take While ( predicate ) { return function * ( iterable ) { let i = 0 ; for ( const item of iterable ) { if ( ! predicate ( item , i ) ) { break ; } yield item ; i = i + 1 ; } } ; } 
function take Until ( predicate ) { return function * ( iterable ) { let i = 0 ; for ( const item of iterable ) { if ( predicate ( item , i ) ) { return ; } yield item ; i = i + 1 ; } } ; } 
function skip While ( predicate ) { return function * ( iterable ) { let i = 0 ; let can Return = false ; for ( const item of iterable ) { if ( ! can Return ) { can Return = ! predicate ( item , i ) ; if ( can Return ) { yield item ; } i = i + 1 ; } else { yield item ; } } } ; } 
function skip Until ( predicate ) { return function * ( iterable ) { let i = 0 ; let can Return = false ; for ( const item of iterable ) { if ( ! can Return ) { can Return = predicate ( item , i ) ; if ( can Return ) { yield item ; } i = i + 1 ; } else { yield item ; } } } ; } 
function element At Or Default ( index , or ) { return function ( it ) { let i = 0 ; for ( const item of it ) { if ( i = = = index ) { return item ; } i = i + 1 ; } return or ; } ; } 
function unshift ( . . . next ) { return function * ( it ) { for ( let i = 0 ; i < next . length ; + + i ) yield next [ next . length - i - 1 ] ; yield * it ; } ; } 
function some ( predicate ) { return it = > { let i = 0 ; for ( const item of it ) { if ( predicate ( item , i ) ) { return true ; } i = i + 1 ; } return false ; } ; } 
function every ( predicate ) { return it = > { let i = 0 ; for ( const item of it ) { if ( ! predicate ( item , i ) ) { return false ; } i = i + 1 ; } return true ; } ; } 
function distinct Until Key Changed ( key Selector ) { return function * ( it ) { let prev = undefined ; for ( const item of it ) { const key = key Selector ( item ) ; if ( key = = = prev ) { continue ; } prev = key ; yield item ; } } ; } 
function order By ( key Selector , comparison ) { const true Key Selector = key Selector | | default Key Selector ; const true Comparison = comparison | | default Comparison ; return function * ( item ) { const keyed Mapper = map ( ( item , index ) = > ( { item , key : true Key Selector ( item , index ) } ) ) ; const keyed = keyed Mapper ( item ) ; const keyed Array = Array . from ( keyed ) ; keyed Array . sort ( ( a , b ) = > true Comparison ( a . key , b . key ) ) ; for ( const { item } of keyed Array ) { yield item ; } } ; } 
function repeat ( times ) { return function * ( it ) { const buffer = [ ] ; for ( const item of it ) { buffer . push ( item ) ; yield item ; } for ( let i = 0 ; i < times ; + + i ) { yield * buffer ; } } ; } 
function shuffle ( it , rand = ( ) = > Math . random ( ) ) { return map ( ( x ) = > x [ 0 ] ) ( order By ( ( x ) = > x [ 1 ] ) ( map ( ( x ) = > [ x , rand ( ) ] ) ( it ) ) ) ; } 
function or ( other ) { return function * ( source ) { let has Yielded Item = false ; for ( const item of source ) { yield item ; has Yielded Item = true ; } if ( ! has Yielded Item ) { yield * other ; } } ; } 
function update At ( index , value ) { return function * ( source ) { let i = 0 ; for ( const item of source ) { if ( i = = = index ) { yield value ; } else { yield item ; } i = i + 1 ; } } ; } 
function remove At ( index ) { return function * ( source ) { let i = 0 ; for ( const item of source ) { if ( i ! = = index ) { yield item ; } i = i + 1 ; } } ; } 
function mocha Task ( target ) { return function ( ) { return _gulp 2 [ 'default ' ] . src ( ' ' + opt . test Espowered + ' / ' + target + ' / * .js ' ) . pipe ( _mocha 2 [ 'default ' ] ( { reporter : 'spec ' } ) ) . on ( 'error ' , function ( err ) { return process . exit ( 1 ) ; } ) ; } ; } 
function ( compressed Data ) { var inflated Data = zlib . inflate Sync ( new Buffer ( compressed Data , 'base 6 4 ' ) ) ; var output String = " [ " + String . from Char Code . apply ( null , inflated Data ) + " ] " ; var output Array = JSON . parse ( output String ) ; return Array Converter . diffs To Values ( output Array ) ; } 
function ( num Array ) { num Array . sort ( function ( a , b ) { return a - b ; } ) ; for ( var i = 0 , prev = 0 , diff = 0 , result = [ ] , len = num Array . length ; i < len ; i + + ) { diff = num Array [ i ] - prev ; prev = num Array [ i ] ; result . push ( diff ) ; } return result ; } 
function ( diff Array ) { for ( var i = 0 , head = 0 , result = [ ] , len = diff Array . length ; i < len ; i + + ) { head = head + diff Array [ i ] ; result . push ( head ) ; } return result ; } 
function Shape Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 3 ) throw new Syntax Error ( 'SHAPE command requires 3 arguments ' ) ; this . points Length = parsed . args [ 0 ] ; this . points X = parsed . args [ 1 ] ; this . points Y = parsed . args [ 2 ] ; this . stroke = parsed . args . length > 3 ? parsed . args [ 3 ] : false ; } 
function ekurtosis ( out , p ) { var len = p . length , i ; for ( i = 0 ; i < len ; i + + ) { out [ i ] = EKURTOSIS ( p [ i ] ) ; } return out ; } 
function scroll Spy ( ) { var scroll Top = $window . scroll Top ( ) , $anchors = $child Menu . find ( 'a ' ) , active Index ; $anchors . each ( function ( index ) { var $target = $ ( $ ( this ) . attr ( 'href ' ) . replace ( / \ . / g , ' \ \ . ' ) ) , offset Top = $target . offset ( ) . top , offset Bottom = offset Top + $target . outer Height ( true ) ; if ( offset Top < = scroll Top & & scroll Top < offset Bottom ) { active Index = index ; return false ; } } ) ; $child Menu Item . remove Class ( 'kss -active ' ) ; if ( typeof active Index ! = = 'undefined ' ) { $child Menu Item . eq ( active Index ) . add Class ( 'kss -active ' ) ; } } 
function fix Sidebar ( ) { if ( $sidebar Inner . outer Height ( ) < $content . outer Height ( ) ) { $sidebar . add Class ( 'kss -fixed ' ) ; if ( $sidebar Inner . outer Height ( ) > $window . height ( ) ) { $sidebar . height ( $window . height ( ) ) ; $window . on ( 'scroll ' , scroll Sidebar ) . trigger ( 'scroll ' ) ; } else { $sidebar . height ( 'auto ' ) ; $window . off ( 'scroll ' , scroll Sidebar ) ; } } else { $sidebar . remove Class ( 'kss -fixed ' ) ; $sidebar . height ( 'auto ' ) ; $window . off ( 'scroll ' , scroll Sidebar ) ; } } 
function scroll Sidebar ( event ) { if ( event . handled ! = = true ) { var scroll Top = $window . scroll Top ( ) , max Scroll Top = $document . height ( ) - $window . height ( ) ; if ( scroll Top > = 0 & & prev Scroll Top > = 0 & & scroll Top < = max Scroll Top & & prev Scroll Top < = max Scroll Top ) { 
function for Each ( declarations , req Name , callback ) { var d ; if ( req Name = = = " * " ) { 
function mkdir ( units , name ) { if ( name ! = = " " ) { var parts = name . split ( " . " ) ; var path = " " ; for ( var i = 0 , len = parts . length ; i < len ; i + + ) { var part = parts [ i ] ; path + = part ; if ( units [ part ] = = null ) { units [ part ] = { } ; } else if ( typeof units [ part ] ! = = "object " ) { error ( "Cann 't init unit ' " + name + " ' because path element ' " + path + " ' isn 't an object " ) ; } units = units [ part ] ; path + = " . " ; } } return units ; } 
function inject Objects ( dest , settings ) { var injections = settings . injections ; if ( ! is Array ( injections ) ) { error ( "Invalid injections array in inject settings " ) ; } var dest Decls = dest . _declarations ; for ( var i = 0 , len = injections . length ; i < len ; i + + ) { var injection = injections [ i ] ; if ( typeof injection ! = = "object " ) { error ( "Invalid injection [ " + i + " ] in inject settings " ) ; } var dest Name = injection . name ; if ( ! check Unit Name ( dest Name ) ) { error ( "Invalid injection name ' " + dest Name + " ' [ " + i + " ] in inject settings " ) ; } if ( injection . unit ! = null & & injection . value ! = = undefined ) { error ( "Unit and value can 't be used together [ " + i + " ] in inject settings " ) ; } if ( injection . unit ! = null ) { 
function pick Unit ( src Decls , dest Decls , name , picked , stack ) { var decl = src Decls [ name ] ; if ( ! picked [ name ] ) { if ( stack [ name ] ) { error ( "Recursive dependency ' " + name + " ' " ) ; } stack [ name ] = true ; for ( var i = 0 , len = decl . _dependencies . length ; i < len ; i + + ) { var req Name = decl . _dependencies [ i ] ; for Each ( src Decls , req Name , function ( dep Name ) { if ( dep Name ! = = name ) { pick Unit ( src Decls , dest Decls , dep Name , picked , stack ) ; } } ) ; } dest Decls [ name ] = decl ; picked [ name ] = true ; } } 
function pick Units ( dest , settings ) { var units = settings . units ; if ( ! is Array ( units ) ) { error ( "Invalid units array in pick settings " ) ; } if ( ! ( settings . namespace instanceof Gumup ) ) { error ( "Invalid namespace in pick settings " ) ; } var picked = { } , src Decls = settings . namespace . _declarations ; for ( var i = 0 , len = units . length ; i < len ; i + + ) { var req Name = units [ i ] ; if ( ! check Require Name ( req Name ) ) { error ( "Invalid unit name ' " + req Name + " ' in pick settings " ) ; } for Each ( src Decls , req Name , function ( dep Name ) { pick Unit ( src Decls , dest . _declarations , dep Name , picked , { } ) ; } ) ; } } 
function initialize ( dest , declarations , name , cache , inited ) { var decl = declarations [ name ] ; if ( ! inited [ name ] ) { 
function resolve ( declarations , name , cache , resolved , stack ) { var decl = declarations [ name ] ; if ( ! resolved [ name ] ) { if ( stack [ name ] ) { error ( "Recursive dependency ' " + name + " ' " ) ; } stack [ name ] = true ; for ( var i = 0 , len = decl . _dependencies . length ; i < len ; i + + ) { var req Name = decl . _dependencies [ i ] ; for Each ( declarations , req Name , function ( dep Name ) { if ( dep Name ! = = name ) { delete cache . root [ dep Name ] ; cache . dependencies [ name ] . push ( dep Name ) ; resolve ( declarations , dep Name , cache , resolved , stack ) ; } } ) ; } resolved [ name ] = true ; } } 
function get Sha Salt ( ) { var sha Deps = [ _ _filename , _ _dirname + ' /protractor _api .dart ' ] ; return sha Text Hex Digest . apply ( sha Deps . map ( utils . read Text File ) ) ; } 
function is Bem Decl ( node ) { if ( node . type ! = = 'Call Expression ' ) { return false ; } if ( node . callee . type ! = = 'Member Expression ' ) { return false ; } if ( node . callee . property . type ! = = 'Identifier ' | | node . callee . property . name ! = = 'decl ' ) { return false ; } var obj = node . callee . object ; if ( obj . type = = = "Identifier " ) { return obj . name = = = "BEM " ; } if ( obj . type = = = "Member Expression " ) { if ( obj . object . type ! = = "Identifier " ) { return false ; } if ( obj . object . name ! = = "BEM " ) { return false ; } if ( obj . property . type ! = = "Identifier " ) { return false ; } return obj . property . name = = = "DOM " ; } return false ; } 
function get Entity ( decl ) { if ( decl . type = = = "Literal " ) { return { block : decl . value } ; } if ( decl . type = = = "Object Expression " ) { var base = get Property ( decl , 'base Block ' ) , o = { block : get Property ( decl , 'block ' ) , mod : get Property ( decl , 'mod Name ' ) , val : get Property ( decl , 'mod Val ' ) } ; if ( base ) { o . base = base ; } return o ; } } 
function get Property ( obj Node , name ) { for ( var i = 0 ; i < obj Node . properties . length ; i + + ) { if ( get Key ( obj Node . properties [ i ] ) = = = name ) { return get Value ( obj Node . properties [ i ] ) ; } } } 
function get Key ( prop Node ) { if ( prop Node . key . type = = = "Literal " ) { return prop Node . key . value ; } if ( prop Node . key . type = = = "Identifier " ) { return prop Node . key . name ; } } 
function get Entity Doc Comment ( node , entity ) { var comment = [ ' / * * ' ] ; if ( node . leading Comments & & node . leading Comments [ 0 ] ) { comment . push ( node . leading Comments [ 0 ] . value ) ; } if ( entity . block ) { comment . push ( ' @block ' ) ; } if ( entity . mod ) { comment . push ( ' @mod ' ) ; } if ( entity . val ) { comment . push ( ' @val ' ) ; } comment . push ( ' * / ' ) ; return comment . join ( ' \n ' ) ; } 
function add Doclet Bem Entity ( e ) { var bem Entity = e . code . bem Entity ; e . doclet . block = bem Entity . block ; if ( bem Entity . base ) { e . doclet . base Block = bem Entity . base ; } if ( bem Entity . mod ) { e . doclet . mod = { name : bem Entity . mod , value : bem Entity . val } ; } } 
function is Static Decl ( node ) { var parent = node . parent ; return has Static ( parent ) & & parent . arguments [ 2 ] = = = node ; } 
function has Static ( node ) { var args = node . arguments ; if ( ! args ) { return false ; } return args . length > = 3 & & args [ 1 ] . type = = = "Object Expression " & & args [ 2 ] . type = = = "Object Expression " ; } 
function ( attrs ) { var res = ' ' ; UObj . for Each ( attrs , function ( k , v ) { res + = ' ' + k ; if ( v ! = = null ) res + = ' = " ' + S . escape ( v ) + ' " ' ; } ) ; return res ; } 
function ( tag Name , attrs , content ) { 
function betaln ( x , y ) { 
function ( elt , name ) { if ( elt . node Type ! = = Node Types . ELEMENT ) throw new Error ( 'get Attr not allowed on non -element nodes ' ) ; return elt . get Attribute ( name ) | | null ; } 
function ( elt , name , value ) { if ( elt . node Type ! = = Node Types . ELEMENT ) throw new Error ( 'set Attr not allowed on non -element nodes ' ) ; value = = = null ? elt . remove Attribute ( name ) : elt . set Attribute ( name , value ) ; } 
function ( elt , name ) { if ( elt . node Type ! = = Node Types . ELEMENT & & elt . node Type ! = = Node Types . DOCUMENT ) throw new Error ( 'get Prop not allowed on non -element nodes ' ) ; return elt [ name ] ; } 
function ( elt , name , value ) { if ( elt . node Type ! = = Node Types . ELEMENT ) throw new Error ( 'set Prop not allowed on non -element nodes ' ) ; return elt [ name ] = value ; } 
function ( elt , _class ) { elt . class List . add . apply ( elt . class List , _class . split ( ' ' ) ) ; } 
function ( elt , _class ) { var old Length = elt . class List . length ; elt . class List . remove ( _class ) ; return old Length ! = = elt . class List . length ; } 
function ( e ) { if ( e . parent Node ! = null ) { $ . dispose Elements ( $ . get All ( e , false ) ) ; $ . dispose Element ( e ) ; e . parent Node . remove Child ( e ) ; } } 
function get Input Arguments ( args ) { var out = { } ; out . local Services = { } ; if ( args . length > 0 ) { out . source = args [ 0 ] ; out . target = args [ 0 ] ; if ( _ . is Plain Object ( args [ 0 ] ) ) { var opts = args [ 0 ] ; out . target = opts . target ; out . source = opts . source ; out . instance = opts . instance ; } 
function find Next ( data , items , index ) { var current Index = data . length + 1 , found = ' ' ; for ( var i = 0 ; i < items . length ; i + + ) { var item = items [ i ] ; var location = data . index Of ( item , index ) ; if ( location ! = = - 1 & & location < current Index ) { current Index = location ; found = item ; } } if ( current Index = = = data . length + 1 ) return { index : - 1 , found : ' ' } ; return { index : current Index , found : found } ; } 
function find Last ( data , items , index ) { var current Index = - 1 , found = ' ' ; for ( var i = 0 ; i < items . length ; i + + ) { var item = items [ i ] ; var location = data . last Index Of ( item , index ) ; if ( location > current Index ) { current Index = location ; found = item ; } } return { index : current Index , found : found } ; } 
function find Next Outside ( data , items , index , exclude ) { var result , position Result = { start : 0 , end : index ? index - 1 : - 1 } ; do { result = find Next ( data , items , position Result . end + 1 ) ; } while ( result . index ! = = - 1 & & ( position Result = in Position ( result . index , exclude ) ) ) ; return result ; } 
function find Last Outside ( data , items , index , exclude ) { var result , position Result = { start : index ? index + 1 : data . length + 1 , end : 0 } ; do { result = find Last ( data , items , position Result . start - 1 ) ; } while ( result . index ! = = - 1 & & ( position Result = in Position ( result . index , exclude ) ) ) ; return result ; } 
function index Of Outside ( data , item , index , exclude ) { var result , position Result = { start : 0 , end : index ? index - 1 : - 1 } ; do { result = data . index Of ( item , position Result . end + 1 ) ; } while ( result ! = = - 1 & & ( position Result = in Position ( result , exclude ) ) ) ; return result ; } 
function last Index Of Outside ( data , item , index , exclude ) { var result , position Result = { start : index ? index + 1 : data . length + 1 , end : 0 } ; do { result = data . last Index Of ( item , position Result . start - 1 ) ; } while ( result . index ! = = - 1 & & ( position Result = in Position ( result . index , exclude ) ) ) ; return result ; } 
function split Outside ( data , separator , exclude ) { var result = [ ] ; var accumulator = " " ; for ( var i = 0 ; i < data . length ; i + + ) { accumulator + = data [ i ] ; var is In Exclusion = in Position ( i , exclude ) ; if ( ! is In Exclusion & & ends With ( accumulator , separator ) ) { result . push ( accumulator . substring ( 0 , accumulator . length - separator . length ) ) ; accumulator = ' ' ; } } result . push ( accumulator ) ; return result ; } 
function find Positions ( data , items ) { var depth = 0 ; var root Id = - 1 ; var result = [ ] ; var current Item = { } ; var accumulator = ' ' ; for ( var ci = 0 ; ci < data . length ; ci + + ) { accumulator + = data [ ci ] ; var matched Item = false ; for ( var x = 0 ; x < items . length ; x + + ) { var item = items [ x ] ; if ( depth > 0 & & ends With ( accumulator , item . end ) ) { depth - - ; if ( depth = = = 0 & & root Id = = = x ) { current Item . end = ci - item . end . length + 1 ; root Id = - 1 ; accumulator = ' ' ; result . push ( current Item ) ; current Item = { } ; } } else if ( ends With ( accumulator , item . start ) ) { depth + + ; if ( depth = = = 1 & & root Id = = = - 1 ) { current Item = { start Char : item . start , end Char : item . end , start : ci } ; root Id = x ; accumulator = ' ' ; } } } } return result ; } 
function in Position ( index , items ) { for ( var i = 0 ; i < items . length ; i + + ) { var item = items [ i ] ; if ( index > = item . start & & index < = item . end ) return item ; } return false ; } 
function ends With ( data , str ) { if ( data . length < str . length ) return false ; if ( data = = = str ) return true ; return data . last Index Of ( str ) = = = data . length - str . length ; } 
function pad ( data , length , pad ) { data = String ( data ) ; pad = pad | | ' ' ; while ( data . length < length ) data + = pad ; return data ; } 
function shallow Clone ( source , obj ) { if ( arguments . length < 2 ) { obj = source ; source = { } ; } for ( var key in obj ) { if ( ! obj . has Own Property ( key ) ) continue ; source [ key ] = obj [ key ] ; } return source ; } 
function ( ) { var args = norma ( 'path :s ? ' , arguments ) ; var _url = url . format ( _ . clone ( this . url ) ) ; var _path = ( args . path | | ' ' ) . replace ( / ^ \ / / , ' ' ) ; return url . resolve ( _url , _path ) ; } 
function ( ) { var results = [ parse Int ( this . url . port , 1 0 ) ] ; this . url . hostname & & results . push ( this . url . hostname ) ; return results ; } 
function start ( options ) { options = options | | { } ; var prompt = options . prompt | | ' > ' ; var eval = options . eval | | run ; var context = new Execution Context ( ) ; var manager = new Block Manager ( ) ; var ast = new Abstract Syntax Tree ( [ ] , { } , manager ) ; next Line ( context , ast , prompt , prompt , - 1 , eval ) ; } 
function run ( cmd , context , ast , cursor , next ) { try { 
function next Line ( context , ast , prompt , old Prompt , force Cursor , eval ) { rl . question ( prompt , function ( answer ) { eval ( answer , context , ast , force Cursor = = = - 1 ? ast . root . length : force Cursor , function ( new Prompt , new Cursor ) { next Line ( context , ast , new Prompt | | old Prompt , old Prompt , typeof new Cursor = = = 'undefined ' ? - 1 : new Cursor , eval ) ; } ) ; } ) ; } 
function initialize ( done ) { done = done | | function ( ) { } ; if ( file Contents ) done ( ) ; fs . read File ( _ _dirname + ' / . . / . . /data /filesystem .json ' , { encoding : 'utf 8 ' } , function ( err , data ) { if ( err ) file Contents = { } ; else file Contents = JSON . parse ( data ) ; done ( ) ; } ) ; } 
function drive ( name , done ) { name = name . to Lower Case ( ) ; done = done | | function ( ) { } ; if ( allowed Drives . index Of ( name ) = = = - 1 ) return done ( new Error ( "Unknown drive " ) ) ; if ( ! file Contents ) return initialize ( function ( ) { drive ( name , done ) ; } ) ; if ( ! file Contents [ name ] ) file Contents [ name ] = { } ; if ( ! drive Cache [ name ] ) drive Cache [ name ] = new Drive ( name , file Contents [ name ] ) ; done ( drive Cache [ name ] ) ; return drive Cache [ name ] ; } 
function save ( done ) { if ( process . browser ) return done ( ) ; fs . write File ( _ _dirname + ' / . . / . . /data /filesystem .json ' , JSON . stringify ( file Contents ) , function ( err ) { if ( done ) done ( err ) ; } ) ; } 
function ( i , validate ) { 
function ( d ) { if ( ! arguments . length ) { if ( typeof _i = = = 'object ' ) { var o = { } ; for ( var prop in _i ) { o [ prop ] = _i [ prop ] ( ) ; } return o ; } else { return _i ; } } _i = validate ( d ) ; 
function argnanmin ( arr ) { if ( ! Array . is Array ( arr ) ) { throw new Type Error ( 'argnanmin ( ) : :invalid input argument . Must provide an array . ' ) ; } var len = arr . length , min = Number . POSITIVE _INFINITY , idx = [ ] , val ; for ( var i = 0 ; i < len ; i + + ) { val = arr [ i ] ; if ( typeof val ! = = 'number ' | | val ! = = val ) { continue ; } if ( val < min ) { min = val ; idx . length = 0 ; idx . push ( i ) ; } else if ( val = = = min ) { idx . push ( i ) ; } } return idx ; } 
function Dim Command ( args ) { var parsed = new statements . Argument Statement ( args , { parse Args : false } ) ; this . creates = [ ] ; for ( var i = 0 ; i < parsed . args . length ; i + + ) { var dim Def = parsed . args [ i ] ; var start Bracket = dim Def . index Of ( ' ( ' ) ; var end Bracket = dim Def . index Of ( ' ) ' ) ; if ( start Bracket = = = - 1 ) throw new Syntax Error ( 'Expected start bracket ' ) ; if ( end Bracket = = = - 1 ) throw new Syntax Error ( 'Expected end bracket ' ) ; var array Name = dim Def . substring ( 0 , start Bracket ) . trim ( ) ; var array Length Name = dim Def . substring ( start Bracket + 1 , end Bracket ) ; var array Length Arg = new statements . Argument Statement ( array Length Name ) ; this . creates . push ( { name : array Name , lengths : array Length Arg . args } ) } } 
function entropy ( out , arr , clbk ) { var len = arr . length , v , i ; for ( i = 0 ; i < len ; i + + ) { v = clbk ( arr [ i ] , i ) ; if ( typeof v = = = 'number ' ) { out [ i ] = ENTROPY ( v ) ; } else { out [ i ] = Na N ; } } return out ; } 
function gen Entity Description ( data , kind , entity Name ) { return data ( { kind : kind , name : entity Name } ) . select ( 'description ' ) . join ( ' \n \n ' ) ; } 
function gen Block Method ( members , name ) { var res = { name : name , description : ' ' , params : [ ] , returns : [ ] , deprecated : false , final : false } ; members . filter ( { kind : 'function ' , name : name } ) . each ( function ( doclet ) { if ( doclet . description ) { res . description + = doclet . description + ' \n ' ; } if ( ! res . access ) { res . access = doclet . access ; } if ( ! res . scope ) { res . scope = doclet . scope ; } if ( res . returns . length = = = 0 ) { res . returns = gen Method Returns ( doclet . returns ) ; } if ( res . params . length = = = 0 ) { res . params = gen Method Params ( doclet . params ) ; } if ( doclet . deprecated ) { res . deprecated = doclet . deprecated ; } if ( doclet . final ) { res . final = doclet . final ; } } ) ; res . scope = res . scope | | 'instance ' ; res . access = res . access | | 'public ' ; return res ; } 
function gen Param ( param ) { var res = { name : param . name | | ' ' , description : param . description | | ' ' , optional : ! ! param . optional } ; if ( param . type ) { res . types = param . type . names . slice ( 0 ) ; } if ( param . defaultvalue ) { res [ 'default ' ] = param . defaultvalue ; } return res ; } 
function gen Property ( members , name ) { var res = { name : name , deprecated : false , description : ' ' , types : [ ] } ; members . filter ( { kind : 'member ' , name : name } ) . each ( function ( doclet ) { if ( doclet . description ) { res . description + = doclet . description + ' \n ' ; } if ( ! res . access ) { res . access = doclet . access ; } if ( ! res . scope ) { res . scope = doclet . scope ; } if ( doclet . deprected ) { res . deprecated = true ; } if ( res . types . length = = = 0 & & doclet . type ) { res . types = doclet . type . names . slice ( 0 ) ; } } ) ; res . scope = res . scope | | 'instance ' ; res . access = res . acccess | | 'public ' ; return res ; } 
function process Expr ( expr Obj , idx ) { var rand Expr = clubexpr . replace Values With ( expr Obj . expr , clubexpr . random Numbers ( 9 ) ) ; var link = ' <a href = " #e ' + ( idx + 1 ) + ' " > ' + ( idx + 1 ) + ' . < /a > ' ; document . write ( ' <h 2 id = "e ' + ( idx + 1 ) + ' " > ' + link + ' ' + expr Obj . nom + ' < /h 2 > ' ) ; document . write ( clubexpr . render Expr As Lisp ( rand Expr ) ) ; document . write ( " $ $ " + clubexpr . render Expr As La Te X ( rand Expr ) + " $ $ " ) ; if ( expr Obj . conv . length ) { document . write ( "conventions : " ) ; document . write ( expr Obj . conv . join ( ' , ' ) ) ; } var props = clubexpr . properties ( rand Expr ) ; document . write ( " <h 3 >Inspection < /h 3 > " ) ; document . write ( "nature : " + props . nature + " <br > " ) ; document . write ( props . nb Ops + " operation " + ( props . nb Ops > 1 ? " (s ) " : " " ) + " : " + props . ops . join ( ' , ' ) + " <br > " ) ; document . write ( "unique ops : " + props . unique Ops . join ( ' , ' ) + " <br > " ) ; if ( props . conventions . length ) { document . write ( "computed conventions : " ) ; document . write ( props . conventions . join ( ' , ' ) ) ; document . write ( " <br > " ) ; } document . write ( "depth : " + props . depth + " <br > " ) ; document . write ( "leaves : " + props . leaves + " <br > " ) ; document . write ( "letters : " + props . letters + " <br > " ) ; document . write ( "numbers : " + props . numbers + " <br > " ) ; } 
function Google Checkout ( settings ) { var self = this ; assert . ok ( settings . merchant Number , 'settings .merchant Number is required ' ) ; assert . ok ( settings . merchant Key , 'settings .merchant Key is required ' ) ; assert . ok ( settings . currency , 'settings .currency is required ' ) ; self . settings = settings ; self . Polling = new Polling ( self ) ; self . Order Processing = new Order Processing ( self ) ; self . Order Reporting = new Order Reporting ( self ) ; self . Merchant Calculations = new Merchant Calculations ( self ) ; } 
function camel Case Object Keys ( obj ) { var new Obj = ( Array . is Array ( obj ) ) ? new Array ( obj . length ) : { } ; utils . map ( obj , function ( key , value ) { var new Key ; if ( typeof ( key ) = = = 'string ' ) { new Key = key . replace ( / - ( [a -z ] { 1 } ) / gi , function ( _ , letter ) { return letter . to Upper Case ( ) } ) } else { new Key = key ; } if ( typeof ( value ) = = = 'object ' ) { new Obj [ new Key ] = camel Case Object Keys ( value ) ; } else { new Obj [ new Key ] = value ; } } ) ; if ( ! Object . keys ( new Obj ) . length ) { new Obj = null ; } return new Obj ; } 
function get Base 6 4 u rl , n , pt ) var m = / ^ (https ? ) : \ / \ / ( [ ^ : \ / ] + ) ( ? : : ( \d + ) ) ? ( [ ^ : ] * ) $ / . exec ( url ) ; if ( ! opt ) opt = { } ; if ( m ! = = null ) { http . get ( { host : m [ 2 ] , port : parse Int ( m [ 3 ] | | 8 0 ) , path : m [ 4 ] } , function ( res ) { var buf = ' ' res . set Encoding ( 'binary ' ) ; res . on ( 'data ' , function ( data ) { buf + = data ; } ) ; res . on ( 'end ' , function ( ) { 
function If Command ( args , define ) { if ( util . ends With ( args . to Lower Case ( ) , ' then ' ) ) args = args . slice ( 0 , args . length - 5 ) . trim ( ) ; else throw new Syntax Error ( 'IF has no THEN ' ) ; var parsed = new statements . Argument Statement ( args , { separator : false } , define ) ; this . condition = parsed . args [ 0 ] ; this . block = define ( { start : 'IF ' , then : 'ELSE ' , end : [ 'ENDIF ' , 'RETURN ' ] } ) ; } 
function logger ( stream ) { return ( . . . text ) = > { text . map ( text = > { console . log ( text ) stream . write ( ` $ { Date . now ( ) } $ { JSON . stringify ( text ) } \n ` ) } ) } } 
function is Node ( node , type ) { var is Node = true var required Props = [ 'attributes ' , 'children ' , 'type ' ] required Props . some ( function ( prop ) { if ( ! node [ prop ] ) { is Node = false return true } } ) if ( type & & is Node ) return node . type = = = type return is Node } 
function forward ( receiver , provider , keys ) { keys = keys | | all Keys ( provider ) ; keys = Array . is Array ( keys ) ? keys : [ keys ] ; keys . for Each ( function ( key ) { var val = provider [ key ] ; if ( typeof val = = = 'function ' ) { receiver [ key ] = function ( ) { return provider [ key ] . apply ( provider , arguments ) ; } ; } else { receiver [ key ] = val ; } } ) ; return receiver ; } 
function Regex Finder Strategy ( config ) { config = config | | { } ; Finder Strategy . call ( this , config ) ; this . config = extend ( true , this . config , { } , config ) ; } 
function parse Name ( name ) { var mod Name = undefined , ext = undefined , temp = undefined , index = name . index Of ( ' . ' ) , is Relative = name . index Of ( ' . / ' ) = = = 0 | | name . index Of ( ' . . / ' ) = = = 0 ; if ( index ! = = - 1 & & ( ! is Relative | | index > 1 ) ) { mod Name = name . substring ( 0 , index ) ; ext = name . substring ( index + 1 , name . length ) ; } else { mod Name = name ; } temp = ext | | mod Name ; index = temp . index Of ( ' ! ' ) ; if ( index ! = = - 1 ) { temp = temp . substring ( 0 , index ) ; if ( ext ) { ext = temp ; } else { mod Name = temp ; } } return { module Name : mod Name , ext : ext } ; } 
function issorted ( arr , clbk ) { if ( ! Array . is Array ( arr ) ) { throw new Type Error ( 'issorted ( ) : :invalid input argument . Must provide an array . ' ) ; } if ( arguments . length > 1 ) { if ( typeof clbk ! = = 'function ' ) { throw new Type Error ( 'issorted ( ) : :invalid input argument . Comparator must be a function . ' ) ; } } var len = arr . length , i ; if ( ! clbk ) { 
function Sync File ( path , flags , mode ) { flags = flags | | 'w ' ; this . fd = fs . open Sync ( path , flags , mode ) ; this . crc = new Crc 6 4 ( ) ; this . converter = new Converter ( ) ; } 
function write ( obj ) { if ( obj . type = = = 'crc ' ) return this . end ( ) ; var buffer = this . converter . entry ( obj ) ; this . crc . push ( buffer ) ; return this . write Buffer ( buffer ) ; } 
function write Buffer ( buffer ) { var written = fs . write Sync ( this . fd , buffer , 0 , buffer . length , null ) ; fs . fsync Sync ( this . fd ) ; return written ; } 
function end ( ) { this . write Buffer ( this . crc . value ( ) ) ; fs . close Sync ( this . fd ) ; this . fd = null ; this . crc = null ; this . converter = null ; } 
function wrap Middleware ( fn ) { assert ( typeof fn = = = 'function ' , ` assert ( fn . length > = 2 , ` if ( fn . length = = = 2 ) { return function ( req , res , next ) { let p = null ; try { p = fn ( req , res ) ; } catch ( err ) { return next ( err ) ; } p . then ( _ = > next ( ) ) . catch ( err = > next ( err ) ) ; } ; } return fn ; } 
function camel Case ( str ) { return words ( str ) . reduce ( ( result , word , idx ) = > { return result + ( idx ? ( is Upper Case ( word ) ? word : capitalize ( word ) ) : lower Case ( word ) ) ; } , ' ' ) ; } 
function pascal Case ( str ) { return words ( str ) . reduce ( ( result , word , idx ) = > { return result + ( idx & & is Upper Case ( word ) ? word : capitalize ( word ) ) ; } , ' ' ) ; } 
function snake Case ( str , sep = ' _ ' ) { return words ( str ) . reduce ( ( result , word , idx ) = > result + ( idx ? sep : ' ' ) + lower Case ( word ) , ' ' ) ; } 
function ( data ) { var result = { } , attribute Count = 0 ; _ . each ( data , function ( value , key ) { result [ 'Attribute . ' + attribute Count + ' .Name ' ] = key ; result [ 'Attribute . ' + attribute Count + ' .Value ' ] = value ; attribute Count + + ; } ) ; return result ; } 
function ( key , secret , region ) { this . sdb = aws . load ( 'sdb ' , key , secret ) ; this . sdb . set Region ( region ) ; return this ; } 
function ( Domain Name , callback ) { var query = { Domain Name : Domain Name } ; this . sdb . request ( 'Create Domain ' , query , function ( err , result ) { if ( ! err ) { callback ( false , 'ok ' ) ; } else { callback ( err , 'error ' ) ; } } ) ; return this ; } 
function Abstract Syntax Tree ( root , labels , manager ) { this . root = root ; this . labels = labels ; this . manager = manager ; manager . parse ( this ) ; } 
function execute ( ast , ctx , done ) { if ( ! done & & ! ( ctx instanceof Execution Context ) ) { done = ctx ; ctx = new Execution Context ( ) ; } ast . execute ( ctx , done ) ; } 
function Mark Logic Store ( options ) { options = options | | { } ; var collection Name = options . collection | | default Options . collection ; this . base Uri = options . base Uri | | encode URI ( collection Name . replace ( / \s / g , ' - ' ) ) ; Store . call ( this , options ) ; this . collection Name = collection Name ; this . ttl = options . ttl | | default Options . ttl | | 0 ; 
function _shell Bundle ( { src = 'app /main .js ' , dest = 'dist ' , base Name = 'build ' , ignore Vendors = false , only Vendors = false } = { } , jspm Config , use Sourcemaps = false ) { 
function _vendors List ( vendors , ignore = false ) { let vendors List = ' ' let sign = ( ignore ) ? ' - ' : ' + ' for ( let vendor of vendors ) { vendors List + = ` $ { sign } $ { vendor } ` } return vendors List } 
function start Polling For Errors ( ) { var check Function = ( function ( ) { 
function create ( prototype , properties ) { Ctor . prototype = prototype | | { } return properties ? copy ( new Ctor ( ) , properties ) : new Ctor ( ) } 
function copy ( target , source ) { for ( var key in Object ( source ) ) target [ key ] = source [ key ] return target } 
function identity ( iterable ) { return _ _async Generator ( this , arguments , function * identity _ 1 ( ) { return yield _ _await ( yield _ _await ( yield * _ _async Delegator ( _ _async Values ( iterable ) ) ) ) ; } ) ; } 
function tap ( tapper ) { return function ( it ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 1 , _a ; let index = 0 ; try { for ( var it _ 1 = _ _async Values ( it ) , it _ 1 _ 1 ; it _ 1 _ 1 = yield _ _await ( it _ 1 . next ( ) ) , ! it _ 1 _ 1 . done ; ) { const value = it _ 1 _ 1 . value ; yield _ _await ( tapper ( value , index ) ) ; yield yield _ _await ( value ) ; index = index + 1 ; } } catch ( e _ 1 _ 1 ) { e _ 1 = { error : e _ 1 _ 1 } ; } finally { try { if ( it _ 1 _ 1 & & ! it _ 1 _ 1 . done & & ( _a = it _ 1 . return ) ) yield _ _await ( _a . call ( it _ 1 ) ) ; } finally { if ( e _ 1 ) throw e _ 1 . error ; } } } ) ; } ; } 
function map ( mapper ) { return function ( iterable ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 2 , _a ; let index = 0 ; try { for ( var iterable _ 1 = _ _async Values ( iterable ) , iterable _ 1 _ 1 ; iterable _ 1 _ 1 = yield _ _await ( iterable _ 1 . next ( ) ) , ! iterable _ 1 _ 1 . done ; ) { const value = iterable _ 1 _ 1 . value ; yield yield _ _await ( mapper ( value , index ) ) ; index = index + 1 ; } } catch ( e _ 2 _ 1 ) { e _ 2 = { error : e _ 2 _ 1 } ; } finally { try { if ( iterable _ 1 _ 1 & & ! iterable _ 1 _ 1 . done & & ( _a = iterable _ 1 . return ) ) yield _ _await ( _a . call ( iterable _ 1 ) ) ; } finally { if ( e _ 2 ) throw e _ 2 . error ; } } } ) ; } ; } 
function filter ( predicate ) { return function ( iterable ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 5 , _a ; let index = 0 ; try { for ( var iterable _ 3 = _ _async Values ( iterable ) , iterable _ 3 _ 1 ; iterable _ 3 _ 1 = yield _ _await ( iterable _ 3 . next ( ) ) , ! iterable _ 3 _ 1 . done ; ) { const value = iterable _ 3 _ 1 . value ; if ( yield _ _await ( predicate ( value , index ) ) ) { yield yield _ _await ( value ) ; } index = index + 1 ; } } catch ( e _ 5 _ 1 ) { e _ 5 = { error : e _ 5 _ 1 } ; } finally { try { if ( iterable _ 3 _ 1 & & ! iterable _ 3 _ 1 . done & & ( _a = iterable _ 3 . return ) ) yield _ _await ( _a . call ( iterable _ 3 ) ) ; } finally { if ( e _ 5 ) throw e _ 5 . error ; } } } ) ; } ; } 
function reduce ( predicate , initial ) { return async function ( iterable ) { var e _ 6 , _a ; let index = 0 ; let prev State = initial ; try { for ( var iterable _ 4 = _ _async Values ( iterable ) , iterable _ 4 _ 1 ; iterable _ 4 _ 1 = await iterable _ 4 . next ( ) , ! iterable _ 4 _ 1 . done ; ) { const value = iterable _ 4 _ 1 . value ; prev State = await predicate ( prev State , value , index ) ; index = index + 1 ; } } catch ( e _ 6 _ 1 ) { e _ 6 = { error : e _ 6 _ 1 } ; } finally { try { if ( iterable _ 4 _ 1 & & ! iterable _ 4 _ 1 . done & & ( _a = iterable _ 4 . return ) ) await _a . call ( iterable _ 4 ) ; } finally { if ( e _ 6 ) throw e _ 6 . error ; } } return prev State ; } ; } 
function scan ( predicate , initial ) { return function ( iterable ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 7 , _a ; let index = 0 ; let prev State = initial ; try { for ( var iterable _ 5 = _ _async Values ( iterable ) , iterable _ 5 _ 1 ; iterable _ 5 _ 1 = yield _ _await ( iterable _ 5 . next ( ) ) , ! iterable _ 5 _ 1 . done ; ) { const value = iterable _ 5 _ 1 . value ; prev State = yield _ _await ( Promise . resolve ( predicate ( prev State , value , index ) ) ) ; yield yield _ _await ( prev State ) ; index = index + 1 ; } } catch ( e _ 7 _ 1 ) { e _ 7 = { error : e _ 7 _ 1 } ; } finally { try { if ( iterable _ 5 _ 1 & & ! iterable _ 5 _ 1 . done & & ( _a = iterable _ 5 . return ) ) yield _ _await ( _a . call ( iterable _ 5 ) ) ; } finally { if ( e _ 7 ) throw e _ 7 . error ; } } return yield _ _await ( prev State ) ; } ) ; } ; } 
function take ( count ) { return function ( iterable ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 9 , _a ; let i = 0 ; try { for ( var iterable _ 7 = _ _async Values ( iterable ) , iterable _ 7 _ 1 ; iterable _ 7 _ 1 = yield _ _await ( iterable _ 7 . next ( ) ) , ! iterable _ 7 _ 1 . done ; ) { const item = iterable _ 7 _ 1 . value ; if ( i > = count ) { return yield _ _await ( void 0 ) ; } yield yield _ _await ( item ) ; i = i + 1 ; } } catch ( e _ 9 _ 1 ) { e _ 9 = { error : e _ 9 _ 1 } ; } finally { try { if ( iterable _ 7 _ 1 & & ! iterable _ 7 _ 1 . done & & ( _a = iterable _ 7 . return ) ) yield _ _await ( _a . call ( iterable _ 7 ) ) ; } finally { if ( e _ 9 ) throw e _ 9 . error ; } } } ) ; } ; } 
function take Last ( count ) { return function ( iterable ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 1 0 , _a ; const buffer = [ ] ; try { for ( var iterable _ 8 = _ _async Values ( iterable ) , iterable _ 8 _ 1 ; iterable _ 8 _ 1 = yield _ _await ( iterable _ 8 . next ( ) ) , ! iterable _ 8 _ 1 . done ; ) { const item = iterable _ 8 _ 1 . value ; buffer . push ( item ) ; if ( buffer . length > count ) { buffer . shift ( ) ; } } } catch ( e _ 1 0 _ 1 ) { e _ 1 0 = { error : e _ 1 0 _ 1 } ; } finally { try { if ( iterable _ 8 _ 1 & & ! iterable _ 8 _ 1 . done & & ( _a = iterable _ 8 . return ) ) yield _ _await ( _a . call ( iterable _ 8 ) ) ; } finally { if ( e _ 1 0 ) throw e _ 1 0 . error ; } } return yield _ _await ( yield _ _await ( yield * _ _async Delegator ( _ _async Values ( buffer ) ) ) ) ; } ) ; } ; } 
function skip Last ( count ) { return function ( iterable ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 1 1 , _a ; const buffer = [ ] ; try { for ( var iterable _ 9 = _ _async Values ( iterable ) , iterable _ 9 _ 1 ; iterable _ 9 _ 1 = yield _ _await ( iterable _ 9 . next ( ) ) , ! iterable _ 9 _ 1 . done ; ) { const item = iterable _ 9 _ 1 . value ; buffer . push ( item ) ; } } catch ( e _ 1 1 _ 1 ) { e _ 1 1 = { error : e _ 1 1 _ 1 } ; } finally { try { if ( iterable _ 9 _ 1 & & ! iterable _ 9 _ 1 . done & & ( _a = iterable _ 9 . return ) ) yield _ _await ( _a . call ( iterable _ 9 ) ) ; } finally { if ( e _ 1 1 ) throw e _ 1 1 . error ; } } if ( buffer . length < count ) { return yield _ _await ( void 0 ) ; } yield _ _await ( yield * _ _async Delegator ( _ _async Values ( buffer . slice ( 0 , buffer . length - count ) ) ) ) ; } ) ; } ; } 
async function last ( iterable ) { var e _ 1 2 , _a ; let last = undefined ; try { for ( var iterable _ 1 0 = _ _async Values ( iterable ) , iterable _ 1 0 _ 1 ; iterable _ 1 0 _ 1 = await iterable _ 1 0 . next ( ) , ! iterable _ 1 0 _ 1 . done ; ) { const item = iterable _ 1 0 _ 1 . value ; last = item ; } } catch ( e _ 1 2 _ 1 ) { e _ 1 2 = { error : e _ 1 2 _ 1 } ; } finally { try { if ( iterable _ 1 0 _ 1 & & ! iterable _ 1 0 _ 1 . done & & ( _a = iterable _ 1 0 . return ) ) await _a . call ( iterable _ 1 0 ) ; } finally { if ( e _ 1 2 ) throw e _ 1 2 . error ; } } return last ; } 
async function first ( iterable ) { var e _ 1 3 , _a ; try { for ( var iterable _ 1 1 = _ _async Values ( iterable ) , iterable _ 1 1 _ 1 ; iterable _ 1 1 _ 1 = await iterable _ 1 1 . next ( ) , ! iterable _ 1 1 _ 1 . done ; ) { const item = iterable _ 1 1 _ 1 . value ; return item ; } } catch ( e _ 1 3 _ 1 ) { e _ 1 3 = { error : e _ 1 3 _ 1 } ; } finally { try { if ( iterable _ 1 1 _ 1 & & ! iterable _ 1 1 _ 1 . done & & ( _a = iterable _ 1 1 . return ) ) await _a . call ( iterable _ 1 1 ) ; } finally { if ( e _ 1 3 ) throw e _ 1 3 . error ; } } return undefined ; } 
function skip ( count ) { return function ( iterable ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 1 4 , _a ; let i = 0 ; try { for ( var iterable _ 1 2 = _ _async Values ( iterable ) , iterable _ 1 2 _ 1 ; iterable _ 1 2 _ 1 = yield _ _await ( iterable _ 1 2 . next ( ) ) , ! iterable _ 1 2 _ 1 . done ; ) { const item = iterable _ 1 2 _ 1 . value ; if ( i > = count ) { yield yield _ _await ( item ) ; } i = i + 1 ; } } catch ( e _ 1 4 _ 1 ) { e _ 1 4 = { error : e _ 1 4 _ 1 } ; } finally { try { if ( iterable _ 1 2 _ 1 & & ! iterable _ 1 2 _ 1 . done & & ( _a = iterable _ 1 2 . return ) ) yield _ _await ( _a . call ( iterable _ 1 2 ) ) ; } finally { if ( e _ 1 4 ) throw e _ 1 4 . error ; } } } ) ; } ; } 
function take While ( predicate ) { return function ( iterable ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 1 5 , _a ; let i = 0 ; try { for ( var iterable _ 1 3 = _ _async Values ( iterable ) , iterable _ 1 3 _ 1 ; iterable _ 1 3 _ 1 = yield _ _await ( iterable _ 1 3 . next ( ) ) , ! iterable _ 1 3 _ 1 . done ; ) { const item = iterable _ 1 3 _ 1 . value ; if ( ! ( yield _ _await ( Promise . resolve ( predicate ( item , i ) ) ) ) ) { break ; } yield yield _ _await ( item ) ; i = i + 1 ; } } catch ( e _ 1 5 _ 1 ) { e _ 1 5 = { error : e _ 1 5 _ 1 } ; } finally { try { if ( iterable _ 1 3 _ 1 & & ! iterable _ 1 3 _ 1 . done & & ( _a = iterable _ 1 3 . return ) ) yield _ _await ( _a . call ( iterable _ 1 3 ) ) ; } finally { if ( e _ 1 5 ) throw e _ 1 5 . error ; } } } ) ; } ; } 
function take Until ( predicate ) { return function ( iterable ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 1 6 , _a ; let i = 0 ; try { for ( var iterable _ 1 4 = _ _async Values ( iterable ) , iterable _ 1 4 _ 1 ; iterable _ 1 4 _ 1 = yield _ _await ( iterable _ 1 4 . next ( ) ) , ! iterable _ 1 4 _ 1 . done ; ) { const item = iterable _ 1 4 _ 1 . value ; if ( yield _ _await ( predicate ( item , i ) ) ) { return yield _ _await ( void 0 ) ; } yield yield _ _await ( item ) ; i = i + 1 ; } } catch ( e _ 1 6 _ 1 ) { e _ 1 6 = { error : e _ 1 6 _ 1 } ; } finally { try { if ( iterable _ 1 4 _ 1 & & ! iterable _ 1 4 _ 1 . done & & ( _a = iterable _ 1 4 . return ) ) yield _ _await ( _a . call ( iterable _ 1 4 ) ) ; } finally { if ( e _ 1 6 ) throw e _ 1 6 . error ; } } } ) ; } ; } 
function skip Until ( predicate ) { return function ( iterable ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 1 8 , _a ; let i = 0 ; let can Return = false ; try { for ( var iterable _ 1 6 = _ _async Values ( iterable ) , iterable _ 1 6 _ 1 ; iterable _ 1 6 _ 1 = yield _ _await ( iterable _ 1 6 . next ( ) ) , ! iterable _ 1 6 _ 1 . done ; ) { const item = iterable _ 1 6 _ 1 . value ; if ( ! can Return ) { can Return = yield _ _await ( predicate ( item , i ) ) ; if ( can Return ) { yield yield _ _await ( item ) ; } i = i + 1 ; } else { yield yield _ _await ( item ) ; } } } catch ( e _ 1 8 _ 1 ) { e _ 1 8 = { error : e _ 1 8 _ 1 } ; } finally { try { if ( iterable _ 1 6 _ 1 & & ! iterable _ 1 6 _ 1 . done & & ( _a = iterable _ 1 6 . return ) ) yield _ _await ( _a . call ( iterable _ 1 6 ) ) ; } finally { if ( e _ 1 8 ) throw e _ 1 8 . error ; } } } ) ; } ; } 
function element At Or Default ( index , or ) { return async function ( it ) { var e _ 1 9 , _a ; let i = 0 ; try { for ( var it _ 2 = _ _async Values ( it ) , it _ 2 _ 1 ; it _ 2 _ 1 = await it _ 2 . next ( ) , ! it _ 2 _ 1 . done ; ) { const item = it _ 2 _ 1 . value ; if ( i = = = index ) { return item ; } i = i + 1 ; } } catch ( e _ 1 9 _ 1 ) { e _ 1 9 = { error : e _ 1 9 _ 1 } ; } finally { try { if ( it _ 2 _ 1 & & ! it _ 2 _ 1 . done & & ( _a = it _ 2 . return ) ) await _a . call ( it _ 2 ) ; } finally { if ( e _ 1 9 ) throw e _ 1 9 . error ; } } return or ; } ; } 
function concat ( . . . iterables ) { return function ( it ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 2 0 , _a ; yield _ _await ( yield * _ _async Delegator ( _ _async Values ( it ) ) ) ; try { for ( var iterables _ 1 = _ _async Values ( iterables ) , iterables _ 1 _ 1 ; iterables _ 1 _ 1 = yield _ _await ( iterables _ 1 . next ( ) ) , ! iterables _ 1 _ 1 . done ; ) { const iterable = iterables _ 1 _ 1 . value ; yield _ _await ( yield * _ _async Delegator ( _ _async Values ( iterable ) ) ) ; } } catch ( e _ 2 0 _ 1 ) { e _ 2 0 = { error : e _ 2 0 _ 1 } ; } finally { try { if ( iterables _ 1 _ 1 & & ! iterables _ 1 _ 1 . done & & ( _a = iterables _ 1 . return ) ) yield _ _await ( _a . call ( iterables _ 1 ) ) ; } finally { if ( e _ 2 0 ) throw e _ 2 0 . error ; } } } ) ; } ; } 
function unshift ( . . . next ) { return function ( it ) { return _ _async Generator ( this , arguments , function * ( ) { for ( let i = 0 ; i < next . length ; + + i ) yield yield _ _await ( next [ next . length - i - 1 ] ) ; yield _ _await ( yield * _ _async Delegator ( _ _async Values ( it ) ) ) ; } ) ; } ; } 
function some ( predicate ) { return async ( it ) = > { var e _ 2 2 , _a ; let index = 0 ; try { for ( var it _ 3 = _ _async Values ( it ) , it _ 3 _ 1 ; it _ 3 _ 1 = await it _ 3 . next ( ) , ! it _ 3 _ 1 . done ; ) { const item = it _ 3 _ 1 . value ; if ( await predicate ( item , index ) ) { return true ; } index = index + 1 ; } } catch ( e _ 2 2 _ 1 ) { e _ 2 2 = { error : e _ 2 2 _ 1 } ; } finally { try { if ( it _ 3 _ 1 & & ! it _ 3 _ 1 . done & & ( _a = it _ 3 . return ) ) await _a . call ( it _ 3 ) ; } finally { if ( e _ 2 2 ) throw e _ 2 2 . error ; } } return false ; } ; } 
function every ( predicate ) { return async ( it ) = > { var e _ 2 3 , _a ; let i = 0 ; try { for ( var it _ 4 = _ _async Values ( it ) , it _ 4 _ 1 ; it _ 4 _ 1 = await it _ 4 . next ( ) , ! it _ 4 _ 1 . done ; ) { const item = it _ 4 _ 1 . value ; if ( ! await Promise . resolve ( predicate ( item , i ) ) ) { return false ; } i = i + 1 ; } } catch ( e _ 2 3 _ 1 ) { e _ 2 3 = { error : e _ 2 3 _ 1 } ; } finally { try { if ( it _ 4 _ 1 & & ! it _ 4 _ 1 . done & & ( _a = it _ 4 . return ) ) await _a . call ( it _ 4 ) ; } finally { if ( e _ 2 3 ) throw e _ 2 3 . error ; } } return true ; } ; } 
function distinct ( it ) { return _ _async Generator ( this , arguments , function * distinct _ 1 ( ) { var e _ 2 4 , _a ; const result Set = new Set ( ) ; try { for ( var it _ 5 = _ _async Values ( it ) , it _ 5 _ 1 ; it _ 5 _ 1 = yield _ _await ( it _ 5 . next ( ) ) , ! it _ 5 _ 1 . done ; ) { const item = it _ 5 _ 1 . value ; if ( ! result Set . has ( item ) ) { result Set . add ( item ) ; yield yield _ _await ( item ) ; } } } catch ( e _ 2 4 _ 1 ) { e _ 2 4 = { error : e _ 2 4 _ 1 } ; } finally { try { if ( it _ 5 _ 1 & & ! it _ 5 _ 1 . done & & ( _a = it _ 5 . return ) ) yield _ _await ( _a . call ( it _ 5 ) ) ; } finally { if ( e _ 2 4 ) throw e _ 2 4 . error ; } } } ) ; } 
function order By ( key Selector , comparison ) { const true Key Selector = key Selector | | default Key Selector ; const true Comparison = comparison | | default Comparison ; return function ( item ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 2 5 , _a ; const keyed Mapper = map ( ( item , index ) = > ( { item , key : true Key Selector ( item , index ) } ) ) ; const keyed = keyed Mapper ( item ) ; const keyed Array = yield _ _await ( to Writeable Array ( keyed ) ) ; keyed Array . sort ( ( a , b ) = > true Comparison ( a . key , b . key ) ) ; try { for ( var keyed Array _ 1 = _ _async Values ( keyed Array ) , keyed Array _ 1 _ 1 ; keyed Array _ 1 _ 1 = yield _ _await ( keyed Array _ 1 . next ( ) ) , ! keyed Array _ 1 _ 1 . done ; ) { const { item } = keyed Array _ 1 _ 1 . value ; yield yield _ _await ( item ) ; } } catch ( e _ 2 5 _ 1 ) { e _ 2 5 = { error : e _ 2 5 _ 1 } ; } finally { try { if ( keyed Array _ 1 _ 1 & & ! keyed Array _ 1 _ 1 . done & & ( _a = keyed Array _ 1 . return ) ) yield _ _await ( _a . call ( keyed Array _ 1 ) ) ; } finally { if ( e _ 2 5 ) throw e _ 2 5 . error ; } } } ) ; } ; } 
function flip ( it ) { return _ _async Generator ( this , arguments , function * flip _ 1 ( ) { yield _ _await ( yield * _ _async Delegator ( _ _async Values ( yield _ _await ( reduce ( ( prev , next ) = > [ next ] . concat ( prev ) , [ ] ) ( it ) ) ) ) ) ; } ) ; } 
function repeat ( times ) { return function ( it ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 2 6 , _a ; const buffer = [ ] ; try { for ( var it _ 6 = _ _async Values ( it ) , it _ 6 _ 1 ; it _ 6 _ 1 = yield _ _await ( it _ 6 . next ( ) ) , ! it _ 6 _ 1 . done ; ) { const item = it _ 6 _ 1 . value ; buffer . push ( item ) ; yield yield _ _await ( item ) ; } } catch ( e _ 2 6 _ 1 ) { e _ 2 6 = { error : e _ 2 6 _ 1 } ; } finally { try { if ( it _ 6 _ 1 & & ! it _ 6 _ 1 . done & & ( _a = it _ 6 . return ) ) yield _ _await ( _a . call ( it _ 6 ) ) ; } finally { if ( e _ 2 6 ) throw e _ 2 6 . error ; } } for ( let i = 0 ; i < times ; + + i ) { yield _ _await ( yield * _ _async Delegator ( _ _async Values ( buffer ) ) ) ; } } ) ; } ; } 
function doppler ( it ) { return _ _async Generator ( this , arguments , function * doppler _ 1 ( ) { var e _ 2 7 , _a ; const buffer = [ ] ; try { for ( var it _ 7 = _ _async Values ( it ) , it _ 7 _ 1 ; it _ 7 _ 1 = yield _ _await ( it _ 7 . next ( ) ) , ! it _ 7 _ 1 . done ; ) { const item = it _ 7 _ 1 . value ; buffer . push ( item ) ; yield yield _ _await ( item ) ; } } catch ( e _ 2 7 _ 1 ) { e _ 2 7 = { error : e _ 2 7 _ 1 } ; } finally { try { if ( it _ 7 _ 1 & & ! it _ 7 _ 1 . done & & ( _a = it _ 7 . return ) ) yield _ _await ( _a . call ( it _ 7 ) ) ; } finally { if ( e _ 2 7 ) throw e _ 2 7 . error ; } } buffer . reverse ( ) ; yield _ _await ( yield * _ _async Delegator ( _ _async Values ( buffer ) ) ) ; } ) ; } 
function or ( other ) { return function ( source ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 2 8 , _a ; let has Yielded Item = false ; try { for ( var source _ 1 = _ _async Values ( source ) , source _ 1 _ 1 ; source _ 1 _ 1 = yield _ _await ( source _ 1 . next ( ) ) , ! source _ 1 _ 1 . done ; ) { const item = source _ 1 _ 1 . value ; yield yield _ _await ( item ) ; has Yielded Item = true ; } } catch ( e _ 2 8 _ 1 ) { e _ 2 8 = { error : e _ 2 8 _ 1 } ; } finally { try { if ( source _ 1 _ 1 & & ! source _ 1 _ 1 . done & & ( _a = source _ 1 . return ) ) yield _ _await ( _a . call ( source _ 1 ) ) ; } finally { if ( e _ 2 8 ) throw e _ 2 8 . error ; } } if ( ! has Yielded Item ) { yield _ _await ( yield * _ _async Delegator ( _ _async Values ( other ) ) ) ; } } ) ; } ; } 
async function to Array ( iterable ) { var e _ 2 9 , _a ; const blob = [ ] ; try { for ( var iterable _ 1 7 = _ _async Values ( iterable ) , iterable _ 1 7 _ 1 ; iterable _ 1 7 _ 1 = await iterable _ 1 7 . next ( ) , ! iterable _ 1 7 _ 1 . done ; ) { const it = iterable _ 1 7 _ 1 . value ; blob . push ( it ) ; } } catch ( e _ 2 9 _ 1 ) { e _ 2 9 = { error : e _ 2 9 _ 1 } ; } finally { try { if ( iterable _ 1 7 _ 1 & & ! iterable _ 1 7 _ 1 . done & & ( _a = iterable _ 1 7 . return ) ) await _a . call ( iterable _ 1 7 ) ; } finally { if ( e _ 2 9 ) throw e _ 2 9 . error ; } } return blob ; } 
async function to Writeable Array ( iterable ) { var e _ 3 0 , _a ; const blob = [ ] ; try { for ( var iterable _ 1 8 = _ _async Values ( iterable ) , iterable _ 1 8 _ 1 ; iterable _ 1 8 _ 1 = await iterable _ 1 8 . next ( ) , ! iterable _ 1 8 _ 1 . done ; ) { const it = iterable _ 1 8 _ 1 . value ; blob . push ( it ) ; } } catch ( e _ 3 0 _ 1 ) { e _ 3 0 = { error : e _ 3 0 _ 1 } ; } finally { try { if ( iterable _ 1 8 _ 1 & & ! iterable _ 1 8 _ 1 . done & & ( _a = iterable _ 1 8 . return ) ) await _a . call ( iterable _ 1 8 ) ; } finally { if ( e _ 3 0 ) throw e _ 3 0 . error ; } } return blob ; } 
function update At ( index , value ) { return function ( source ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 3 1 , _a ; let i = 0 ; try { for ( var source _ 2 = _ _async Values ( source ) , source _ 2 _ 1 ; source _ 2 _ 1 = yield _ _await ( source _ 2 . next ( ) ) , ! source _ 2 _ 1 . done ; ) { const item = source _ 2 _ 1 . value ; if ( i = = = index ) { yield yield _ _await ( value ) ; } else { yield yield _ _await ( item ) ; } i = i + 1 ; } } catch ( e _ 3 1 _ 1 ) { e _ 3 1 = { error : e _ 3 1 _ 1 } ; } finally { try { if ( source _ 2 _ 1 & & ! source _ 2 _ 1 . done & & ( _a = source _ 2 . return ) ) yield _ _await ( _a . call ( source _ 2 ) ) ; } finally { if ( e _ 3 1 ) throw e _ 3 1 . error ; } } } ) ; } ; } 
function remove At ( index ) { return function ( source ) { return _ _async Generator ( this , arguments , function * ( ) { var e _ 3 2 , _a ; let i = 0 ; try { for ( var source _ 3 = _ _async Values ( source ) , source _ 3 _ 1 ; source _ 3 _ 1 = yield _ _await ( source _ 3 . next ( ) ) , ! source _ 3 _ 1 . done ; ) { const item = source _ 3 _ 1 . value ; if ( i ! = = index ) { yield yield _ _await ( item ) ; } i = i + 1 ; } } catch ( e _ 3 2 _ 1 ) { e _ 3 2 = { error : e _ 3 2 _ 1 } ; } finally { try { if ( source _ 3 _ 1 & & ! source _ 3 _ 1 . done & & ( _a = source _ 3 . return ) ) yield _ _await ( _a . call ( source _ 3 ) ) ; } finally { if ( e _ 3 2 ) throw e _ 3 2 . error ; } } } ) ; } ; } 
async function count ( source ) { var e _ 3 3 , _a ; let i = 0 ; try { for ( var source _ 4 = _ _async Values ( source ) , source _ 4 _ 1 ; source _ 4 _ 1 = await source _ 4 . next ( ) , ! source _ 4 _ 1 . done ; ) { const it = source _ 4 _ 1 . value ; + + i ; } } catch ( e _ 3 3 _ 1 ) { e _ 3 3 = { error : e _ 3 3 _ 1 } ; } finally { try { if ( source _ 4 _ 1 & & ! source _ 4 _ 1 . done & & ( _a = source _ 4 . return ) ) await _a . call ( source _ 4 ) ; } finally { if ( e _ 3 3 ) throw e _ 3 3 . error ; } } return i ; } 
async function empty ( source ) { var e _ 3 4 , _a ; let i = 0 ; try { for ( var source _ 5 = _ _async Values ( source ) , source _ 5 _ 1 ; source _ 5 _ 1 = await source _ 5 . next ( ) , ! source _ 5 _ 1 . done ; ) { const it = source _ 5 _ 1 . value ; return false ; } } catch ( e _ 3 4 _ 1 ) { e _ 3 4 = { error : e _ 3 4 _ 1 } ; } finally { try { if ( source _ 5 _ 1 & & ! source _ 5 _ 1 . done & & ( _a = source _ 5 . return ) ) await _a . call ( source _ 5 ) ; } finally { if ( e _ 3 4 ) throw e _ 3 4 . error ; } } return true ; } 
function Client ( opts ) { this . id = opts . id ; this . opts = opts ; this . send = send ; this . is Connected = false ; let client = this ; let queue = [ ] ; let callbacks = { } ; let is Busy = true ; let socket ; connect ( opts ) ; function send ( event , data , callback ) { if ( ! client . is Connected & & callback ) return callback ( new Error ( 'CONNECTION ' ) ) ; queue . push ( { event , data , callback } ) ; next ( ) ; } function next ( ) { if ( is Busy ) return ; is Busy = true ; if ( queue . length = = 0 ) return ( is Busy = false ) ; if ( socket ) { let msg = { id : gen Id ( ) , event : queue [ 0 ] . event , data : queue [ 0 ] . data } socket . write ( ( ! ! opts . cipher ? encode ( JSON . stringify ( msg ) , opts . cipher , opts . password ) : JSON . stringify ( msg ) ) + ' | ' , function ( err ) { if ( err ) return socket . emit ( 'error ' , err ) ; if ( queue [ 0 ] . callback ) callbacks [ msg . id ] = queue [ 0 ] . callback ; client . emit ( 'send ' , queue [ 0 ] ) ; queue . shift ( ) ; is Busy = false ; next ( ) ; } ) ; } } function connect ( opts ) { socket = net . connect ( { host : opts . host , port : opts . port } ) ; queue = [ ] ; callbacks = { } ; is Busy = true ; socket . on ( 'connect ' , function ( ) { is Busy = false ; client . is Connected = true ; client . emit ( 'connect ' , opts . id ) ; } ) ; let buffer = ' ' ; socket . on ( 'data ' , function ( chunk ) { buffer + = chunk ; let msgs = buffer . split ( ' | ' ) ; buffer = msgs . pop ( ) ; msgs . for Each ( function ( packet ) { let msg ; try { msg = JSON . parse ( ! ! opts . cipher ? decode ( packet , opts . cipher , opts . password ) : packet ) ; } catch ( err ) { return socket . emit ( 'error ' , err ) ; } client . emit ( 'receive ' , msg ) ; if ( msg . id in callbacks ) { callbacks [ msg . id ] ( msg . data ) ; delete callbacks [ msg . id ] ; return ; } if ( msg . event ! = 'ACK ' ) { client . emit ( msg . event , msg . data ) ; send ( 'ACK ' , { id : msg . id , event : msg . event } ) ; return ; } } ) ; } ) ; socket . on ( 'close ' , ( ) = > { set Timeout ( connect , opts [ 'reconnect -delay ' ] * 1 0 0 0 | | 3 0 0 0 0 , opts ) ; if ( client . is Connected ) { client . is Connected = false ; client . emit ( 'disconnect ' , opts . id ) ; } client . is Connected = false ; } ) ; socket . on ( 'error ' , ( err ) = > client . emit ( 'error ' , err ) ) ; } } 
function Server ( opts ) { let server = this ; server . send = send ; let is Busy = true ; let queue = [ ] ; if ( ! ! opts . dir ) { try { fs . mkdir Sync ( opts . dir ) ; 
function Close Command ( args , define ) { var parsed = new statements . Expression Statement ( args , define ) ; if ( ! ( parsed . child instanceof statements . Pointer Statement ) ) throw new Syntax Error ( 'Expected pointer ' ) ; this . pointer = parsed ; } 
function entropy ( out , x ) { var len = x . length , i ; if ( out . length ! = = len ) { throw new Error ( 'entropy ( ) : :invalid input arguments . Input and output matrices must be the same length . ' ) ; } for ( i = 0 ; i < len ; i + + ) { out . data [ i ] = ENTROPY ( x . data [ i ] ) ; } return out ; } 
function MQlobber Client ( stream , options ) { Event Emitter . call ( this ) ; options = options | | { } ; this . _options = options ; this . subs = new Map ( ) ; this . _matcher = new Qlobber Dedup ( options ) ; this . mux = new BPMux ( stream , options ) ; this . _done = false ; var ths = this ; function error ( err ) { ths . emit ( 'error ' , err , this ) ; } function warning ( err ) { if ( ! ths . emit ( 'warning ' , err , this ) ) { console . error ( err ) ; } } this . _warning = warning ; this . _unexpected _data = function ( ) { while ( true ) { if ( this . read ( ) = = = null ) { break ; } warning . call ( this , new Error ( 'unexpected data ' ) ) ; } } ; this . mux . on ( 'error ' , error ) ; function handshake _sent ( duplex , complete ) { if ( ! complete ) { ths . emit ( 'backoff ' ) ; } } this . mux . on ( 'handshake _sent ' , handshake _sent ) ; this . mux . on ( 'pre _handshake _sent ' , handshake _sent ) ; this . mux . on ( 'drain ' , function ( ) { ths . emit ( 'drain ' ) ; } ) ; this . mux . on ( 'full ' , function ( ) { ths . emit ( 'full ' ) ; } ) ; this . mux . on ( 'removed ' , function ( duplex ) { ths . emit ( 'removed ' , duplex ) ; } ) ; this . mux . on ( 'finish ' , function ( ) { ths . _done = true ; } ) ; this . mux . on ( 'end ' , function ( ) { ths . subs . clear ( ) ; } ) ; var duplex = this . mux . multiplex ( options ) ; function end ( ) { error . call ( this , new Error ( 'ended before handshaken ' ) ) ; } duplex . on ( 'end ' , end ) ; duplex . on ( 'error ' , error ) ; duplex . on ( 'readable ' , this . _unexpected _data ) ; this . mux . on ( 'peer _multiplex ' , function ( duplex ) { duplex . on ( 'error ' , error ) ; } ) ; this . mux . on ( 'handshake ' , function ( dplex , hdata , delay ) { if ( dplex = = = duplex ) { duplex . remove Listener ( 'end ' , end ) ; ths . emit ( 'handshake ' , hdata ) ; return duplex . end ( ) ; 
function Block ( line , def , parent ) { this . start Names = [ ] ; this . then Names = [ ] ; this . end Names = [ ] ; for ( var i = 0 ; i < def . start . length ; i + + ) this . start Names . push ( def . start [ i ] . to Lower Case ( ) ) ; for ( var x = 0 ; x < def . end . length ; x + + ) this . end Names . push ( def . end [ x ] . to Lower Case ( ) ) ; for ( var y = 0 ; y < def . then . length ; y + + ) this . then Names . push ( def . then [ y ] . to Lower Case ( ) ) ; this . line = line ; this . parent = parent ; this . search Index = line ; this . start = - 1 ; this . intermediate Indexes = { } ; this . intermediate Cursors = { } ; this . end = - 1 ; } 
function ( callback , on End ) { 
function align ( key , left Stream , right Stream , epsilon ) { 
function entropy ( arr , path , sep ) { var len = arr . length , opts = { } , dget , dset , v , i ; if ( arguments . length > 2 ) { opts . sep = sep ; } if ( len ) { dget = deep Get ( path , opts ) ; dset = deep Set ( path , opts ) ; for ( i = 0 ; i < len ; i + + ) { v = dget ( arr [ i ] ) ; if ( typeof v = = = 'number ' ) { dset ( arr [ i ] , ENTROPY ( v ) ) ; } else { dset ( arr [ i ] , Na N ) ; } } } return arr ; } 
function Read Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; for ( var i = 0 ; i < parsed . args . length ; i + + ) { var place Var = parsed . args [ i ] ; if ( ! ( place Var . child instanceof statements . Variable Statement | | place Var . child instanceof statements . Function Statement ) ) throw new Syntax Error ( 'Expected variable ' ) ; } this . items = parsed . args ; } 
function next ( ) { var description , first Topic = topic Chain [ 0 ] ; for ( description in context ) { if ( description ! = = 'topic ' & & context . has Own Property ( description ) ) { ( function ( description ) { var item = context [ description ] , item Type = typeof item ; 
function render Content ( tpl , data , is Final ) { var temp = juicer ( tpl , data , { errorhandling : false } ) if ( temp = = null ) { console . log ( "gg -template -engine : render Error tpl : = = = = = = = = = = = = = = = = = = = = = = = = = = = " ) console . log ( tpl ) console . log ( "data : = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " ) console . log ( data ) throw new Error ( "gg -template -engine : render Error " ) ; } if ( is Final ) { 
function compile Value ( value ) { if ( value . subtype = = = 'array ' ) { return compile Array ( value ) } else if ( value . subtype = = = 'object ' ) { return compile Object ( value ) } else if ( value . subtype = = = 'mixin ' ) { return compile Mixin ( value ) } else if ( value . subtype = = = 'js ' ) { return compile JS ( value ) } else if ( value . subtype = = = 'function ' ) { return compile Function ( value ) } throw new Error ( 'Invalid subtype : ' + value . subtype ) } 
function prepare Path ( path ) { var parts = path . split ( ' . ' ) parts = parts . map ( function ( part ) { return numeric Regex . test ( part ) ? part : ' \ ' ' + escape ( part ) + ' \ ' ' } ) return ' [ ' + parts . join ( ' , ' ) + ' ] ' } 
function Drawsprite Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 3 ) throw new Syntax Error ( 'DRAWSPRITE command requires 3 arguments ' ) ; this . id = parsed . args [ 0 ] ; this . x = parsed . args [ 1 ] ; this . y = parsed . args [ 2 ] ; this . scale = parsed . args . length = = = 4 ? parsed . args [ 3 ] : false ; this . rotation = parsed . args . length = = = 5 ? parsed . args [ 4 ] : false ; } 
function ( string ) { 
function sprintf ( fstr , array ) { 
function Load ( options ) { var self = this ; self . _path = options . path | | ' . /config ' ; self . _environment = options . environment | | args ( ) . env | | 'development ' ; self . _reload = options . reload | | false ; 
function resolve File Patterns ( base Dir , patterns , opt _omit Warnings ) { var resolved Files = [ ] ; if ( patterns ) { for ( var i = 0 ; i < patterns . length ; + + i ) { var matches = glob . sync ( patterns [ i ] , { cwd : base Dir } ) ; if ( ! matches . length & & ! opt _omit Warnings ) { util . puts ( 'Warning : pattern ' + patterns [ i ] + ' did not match any files . ' ) ; } for ( var j = 0 ; j < matches . length ; + + j ) { resolved Files . push ( path . resolve ( base Dir , matches [ j ] ) ) ; } } } return resolved Files ; } 
function ekurtosis ( p ) { if ( ! ( is Number ( p ) & & 0 < = p & & p < = 1 ) ) { return Na N ; } return 6 + square ( p ) / ( 1 - p ) ; } 
function deep Look ( obj , types ) { if ( typeof ( obj ) ! = = 'object ' ) return obj ; for ( var key in obj ) { if ( ! obj [ key ] . type ) { obj [ key ] = deep Look ( obj [ key ] , types ) ; } else { if ( ! types [ obj [ key ] . type ] ) { throw new Error ( 'No type ' + obj [ key ] . type + ' in Types : key ' + key ) ; } 
function validate Object Required ( options , model Object , entity , parents , errors ) { for ( var key in model Object ) { if ( ! model Object [ key ] . type & & entity ) { validate Object Required ( options , model Object [ key ] , entity [ key ] , parents + ' . ' + key , errors ) ; } else if ( ! options . not Required & & model Object [ key ] . required & & ( ! entity | | ! entity [ key ] ) ) { if ( ! errors . not Found ) errors . not Found = [ ] ; var field Name = parents + ' . ' + key ; errors . not Found . push ( field Name ) ; errors . text . push ( 'Field ' + field Name + ' not found ' ) ; } } return errors ; } 
function validate Object Entity ( model Object , entity , parents , errors ) { if ( ! errors ) errors = { } ; if ( ! errors . text ) errors . text = [ ] ; if ( ! parents ) parents = [ ] ; for ( var key in entity ) { var field Name = parents + ' . ' + key ; if ( ! model Object | | ! model Object [ key ] ) { if ( ! errors . not Required ) errors . not Required = [ ] ; errors . not Required . push ( field Name ) ; errors . text . push ( 'Field ' + field Name + ' not required ' ) ; } else if ( ! model Object [ key ] . type ) { validate Object Entity ( model Object [ key ] , entity [ key ] , [ parents , key ] , errors ) ; } else if ( ! model Object [ key ] . check ( entity [ key ] ) ) { if ( ! errors . not Matched ) errors . not Matched = { } ; errors . not Matched [ field Name ] = model Object [ key ] . type ; errors . text . push ( 'Field ' + field Name + ' not matched with type ' + model Object [ key ] . type ) ; } } return errors ; } 
function ( model Name , model Object ) { 
function ( params ) { var res = [ ] ; if ( typeof ( params ) = = = 'undefined ' ) params = { display Everything : false } ; if ( ! this . registered Models | | Object . keys ( this . registered Models ) . length = = = 0 ) { res . push ( 'There is no registered models ' ) ; } else { res . push ( 'List of registered models ' ) ; for ( var model Name in this . registered Models ) { res . push ( ' - ' + model Name ) ; if ( params . display Everything ) { for ( var key in this . registered Models [ model Name ] ) { res . push ( ' ' + key + ' : ' + this . registered Models [ model Name ] [ key ] . type ) ; } } } } return res . join ( ' \n ' ) ; } 
function ( model Name , entity , options , next ) { if ( typeof options = = = 'function ' ) next = options ; if ( ! options ) options = { } ; var model Object = this . registered Models [ model Name ] ; if ( typeof model Name = = = 'object ' ) { model Object = deep Look ( model Name , this . types ) ; } else if ( this . types [ model Name ] ) { if ( options . one ) this . types [ model Name ] . one = options . one ; var result = this . types [ model Name ] . check ( entity ) ? null : { not Matched : model Name } ; return typeof next = = = 'function ' ? next ( result ) : result ; } var errors = validate Object Required ( options , model Object , entity , [ ] , validate Object Entity ( model Object , entity ) ) ; if ( ! errors . text [ 0 ] ) errors = { } ; if ( errors & & errors . text ) errors . text = errors . text . join ( ' . ' ) ; if ( typeof next = = = 'function ' ) { next ( Object . keys ( errors ) . length ? errors : null ) ; } else { return Object . keys ( errors ) . length ? errors : { } ; } } 
function ( type ) { var examples = this . get Examples ( type ) ; return examples [ Math . floor ( Math . random ( ) * examples . length ) ] ; } 
function Sleep Command ( args , define ) { this . duration = new statements . Expression Statement ( args , define ) ; if ( this . duration . error ) throw this . duration . error ; } 
function ( callback , compilation Source ) { if ( compilation Source & & this . cache . compilation Source & & this . cache . compilation Source = = = compilation Source ) return ; var callback Error = function ( type , str Or Err ) { 
function plugin ( opts ) { return function ( files , metalsmith , done ) { async . each Series ( Object . keys ( files ) , prerender , done ) ; function prerender ( file , done ) { var data = files [ file ] ; if ( ! data . mathjax ) { done ( ) ; } else { debug ( "Found mathjax in " , file ) ; var contents = data . contents . to String ( 'utf 8 ' ) ; mj API . mjpage ( contents , { format : [ "Te X " ] } , { svg : true } , function ( result ) { 
function gulp Qiniu Cdn ( conf ) { qiniu . conf . ACCESS _KEY = conf . AK ; qiniu . conf . SECRET _KEY = conf . SK ; var putpolicy = new qiniu . rs . Put Policy ( ) 
function error Handler ( response , error ) { response . status ( 5 0 0 ) . send ( error ! = = undefined & & error ! = = null ? error . to String ( ) : ' ' ) } 
function bem Require Loader ( source ) { const bem Fs = node Eval ( source ) ; const targets = [ ] ; const self = this ; bem Fs . for Each ( ( source ) = > { if ( source [ 'raw ' ] ) { targets . push ( source [ 'raw ' ] ) ; } else if ( source [ 'require ' ] ) { const module Path = path . resolve ( source [ 'require ' ] ) ; self . add Dependency ( module Path ) ; const request = loader Utils . stringify Request ( self , module Path ) ; targets . push ( 'require ( ' + request + ' ) ; ' ) ; } else { return Error ( 'Wrong input : ' + JSON . stringify ( source ) ) ; } } ) ; return targets . join ( ' \n ' ) ; } 
function ( cb ) { Person . find Or Create ( { name : 'Scott ' } , function ( err , person ) { assert ( Person . is Instance ( person ) ) ; assert ( person . uuid ) ; assert ( person . name = = = 'Scott ' ) ; cb ( ) ; } ) ; } 
function ( cb ) { Person . find ( 'Scott ' , function ( err , person ) { if ( err ) { return cb ( err ) ; } assert ( person . uuid ) ; assert ( person . name = = = 'Scott ' ) ; scott = person ; cb ( ) ; } ) ; } 
function ( cb ) { var calli = Dog . new ( { name : 'Calli ' } ) ; 
function ( cb ) { scott . delete All Dogs ( function ( err ) { if ( err ) { return cb ( err ) ; } scott . delete ( function ( err ) { cb ( err ) ; } ) ; } ) ; } 
function Circle Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 3 ) throw new Syntax Error ( 'CIRCLE command requires 3 arguments ' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; this . radius = parsed . args [ 2 ] ; this . stroke = parsed . args . length > 3 ? parsed . args [ 3 ] : false ; } 
function Polling ( obj Google Checkout ) { var self = this ; 
function Triangle Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 6 ) throw new Syntax Error ( 'TRIANGLE command requires 6 arguments ' ) ; this . x 1 = parsed . args [ 0 ] ; this . y 1 = parsed . args [ 1 ] ; this . x 2 = parsed . args [ 2 ] ; this . y 2 = parsed . args [ 3 ] ; this . x 3 = parsed . args [ 4 ] ; this . y 3 = parsed . args [ 5 ] ; this . stroke = parsed . args . length > 6 ? parsed . args [ 6 ] : false ; } 
function process File ( file ) { var changed = true ; while ( changed & & ! file . processed ) { changed = false ; changed = process Wraps ( file ) ; changed = process Inserts ( file ) ; } file . processed = true ; } 
function Service ( name ) { debug ( 'new service : %s ' , name ) ; assert ( name , "service not supplied with name " ) ; this . name = name ; this . middleware = [ ] ; this . uri = new Uri ( ) ; this . status = new Status ( ) ; this . initialize ( ) ; return this ; } 
function listen Fn ( err ) { debug ( ' %s : start listening on %o ' , this . name , this . uri . get ( ) ) ; this . uri . set Port ( instance . address ( ) . port ) ; this . emit ( 'start ' ) ; this . status . state ( ) . go ( 'Running ' ) ; } 
function Analyzer ( config , state ) { config = config | | { } ; this . state = state ; this . config = extend ( true , { finders : { styl : [ { name : 'regex ' , config : { pattern : / ^ \s * ( ? : @import | @require ) \s + [ ' " ] ( . + ? ) [ ' " ] ( ? : $ | ; ) / gm , exclude : [ 'nib ' ] } } ] , coffee : [ { name : 'regex ' , config : { pattern : / ^ \s * ( ? : . + ? \s * [ = \ : \ ( \ { \ ; ] ) ? \s *require \s * ( ? : \ ( ) ? [ ' " ] ( [ ^ ' " ] + ) [ ' " ] ( ? : \ ) ) ? / gm } } ] , cjsx : [ { name : 'regex ' , config : { pattern : / ^ \s * ( ? : . + ? \s * [ = \ : \ ( \ { \ ; ] ) ? \s *require \s * ( ? : \ ( ) ? [ ' " ] ( [ ^ ' " ] + ) [ ' " ] ( ? : \ ) ) ? / gm } } ] , js : [ { name : 'regex ' , config : { pattern : [ / ^ \s * ( ? : . + ? \s * [ = \ : \ ( \ { \ ; ] ) ? \s *require \s * \ ( ? [ ' " ] ( [ ^ ' " ] + ) [ ' " ] \ ) ? / gm , / \bimport \s + ( ? : . + \s +from \s + ) ? [ \ ' " ] ( [ ^ " \ ' ] + ) [ " \ ' ] / gm ] } } ] , jsx : [ { name : 'regex ' , config : { pattern : [ / ^ \s * ( ? : . + ? \s * [ = \ : \ ( \ { \ ; ] ) ? \s *require \s * \ ( ? [ ' " ] ( [ ^ ' " ] + ) [ ' " ] \ ) ? / gm , / \bimport \s + ( ? : . + \s +from \s + ) ? [ \ ' " ] ( [ ^ " \ ' ] + ) [ " \ ' ] / gm ] } } ] } , resolvers : { styl : [ { name : 'basic ' , config : { extensions : [ 'styl ' , 'css ' ] } } ] , coffee : [ { name : 'common -js ' , config : { extensions : [ 'coffee ' , 'js ' , 'cjsx ' , 'jsx ' ] } } ] , cjsx : [ { name : 'common -js ' , config : { extensions : [ 'coffee ' , 'js ' , 'cjsx ' , 'jsx ' ] } } ] , js : [ { name : 'common -js ' , config : { extensions : [ 'coffee ' , 'js ' , 'cjsx ' , 'jsx ' ] } } ] , jsx : [ { name : 'common -js ' , config : { extensions : [ 'coffee ' , 'js ' , 'cjsx ' , 'jsx ' ] } } ] } } , config ) ; this . finders = { } ; this . resolvers = { } ; this . create Finders ( ) ; this . create Resolvers ( ) ; } 
function ( duration ) { if ( duration = = = 0 ) throw new Error ( 'Duration must not be = = = 0 ' ) ; if ( ! S . is String ( duration ) ) return duration ; return duration . contains ( 'ms ' ) ? parse Int ( duration , 1 0 ) : parse Int ( duration , 1 0 ) * 1 0 0 0 ; } 
function Rrect Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 5 ) throw new Syntax Error ( 'RRECT command requires 5 arguments ' ) ; this . x 1 = parsed . args [ 0 ] ; this . y 1 = parsed . args [ 1 ] ; this . x 2 = parsed . args [ 2 ] ; this . y 2 = parsed . args [ 3 ] ; this . radius = parsed . args [ 4 ] ; this . stroke = parsed . args . length > 5 ? parsed . args [ 5 ] : false ; } 
function ( cmd , parent Cmd , pos ) { var S = 'Somme ' ; var D = 'Diff ' ; var P = 'Produit ' ; var Q = 'Quotient ' ; var O = 'Oppos é ' ; var I = 'Inverse ' ; var C = 'Carr é ' ; var Pu = 'Puissance ' ; var R = 'Racine ' ; if ( belongs To ( parent Cmd , [ C , Pu ] ) & & pos = = 0 ) { return belongs To ( cmd , [ S , D , O , P , Q , I , C , Pu ] ) ; } if ( parent Cmd = = P ) { return belongs To ( cmd , [ S , D , O ] ) ; } if ( ( parent Cmd = = O ) | | ( parent Cmd = = D & & pos = = 1 ) ) { return belongs To ( cmd , [ S , D , O ] ) ; } if ( parent Cmd = = S & & cmd = = O & & pos = = 1 ) { return true ; } return false ; } 
function listen On Changes ( fn ) { var script Content = 'var cart Id = " ' + me . cart + ' " ;var ext Id = " ' + chrome . runtime . id + ' " ; $ (document ) .bind ( "Menu Dishes Changed Quantity Changed Meal Deal Removed Dish Removed Tip Updated Discoun Coupon Added Address Selected Delivery Method Changed " , ' + fn + ' ) ' ; var script = document . create Element ( 'script ' ) ; script . id = 'tmp Script ' ; script . append Child ( document . create Text Node ( script Content ) ) ; ( document . body | | document . head | | document . document Element ) . append Child ( script ) ; $ ( " #tmp Script " ) . remove ( ) ; } 
function main ( ) { var raw Data = $ ( ' .Header Texture [data -login -user -email ] ' ) . data ( ) ; if ( raw Data ) { me = { name : raw Data . login User Name , mail : raw Data . login User Email } ; get Cart Id ( function ( cart ) { me . cart = cart ; inject Menu ( ) ; refresh Users ( actions . update Users ) ; listen On Changes ( on Change ) ; listen On Order Confirm ( on Confirm ) ; } ) ; } else { callback ( 'no user ' ) ; } } 
function cons ( b , value , next ) { var free = read Value ( b , 0 ) | | 8 update Value ( b , free , value ) ; update Next ( b , free , next ) update Value ( b , 0 , free + 8 ) 
function insert ( b , node , value ) { return update Next ( b , node , cons ( b , value , read Next ( b , node ) ) ) } 
function entropy ( out , sigma ) { var len = sigma . length , i ; for ( i = 0 ; i < len ; i + + ) { out [ i ] = ENTROPY ( sigma [ i ] ) ; } return out ; } 
function init ( path To Models , cb , add To Swagger ) { model Path = path To Models ; glob ( model Path + ' / * * / * .js ' , function ( err , files ) { if ( err ) return cb & & cb ( err ) ; files . for Each ( function ( file ) { var Model = require ( file ) ( ) , model Swagger = null ; if ( Model . init ) { Model . init ( ) ; } model Swagger = Model . get Swagger ( ) ; if ( model Swagger & & add To Swagger ) { model Swagger . for Each ( function ( swagger Resource ) { swagger [ swagger Method Name [ swagger Resource . spec . method . to Lower Case ( ) ] ] ( swagger Resource ) ; } ) ; } models . push ( Model ) ; } ) ; return cb & & cb ( null , models ) ; } ) ; } 
function Argument Statement ( args , options , define ) { options = options | | { } ; this . value = args ; this . flags = { } ; this . args = [ ] ; this . options = options ; if ( typeof options . parse = = = 'undefined ' ) options . parse = true ; if ( typeof options . separator = = = 'undefined ' ) options . separator = ' , ' ; if ( typeof options . parse Args = = = 'undefined ' ) options . parse Args = true ; if ( options . parse ) { if ( options . flags ) { var is Flag = true ; 
function Open Command ( args , define ) { var lower Args = args . to Lower Case ( ) ; var for Index = lower Args . index Of ( ' for ' ) ; if ( for Index = = = - 1 ) throw new Syntax Error ( 'OPEN without FOR ' ) ; var filename = new statements . Expression Statement ( args . substring ( 0 , for Index ) . trim ( ) , define ) ; var as Index = lower Args . index Of ( ' as ' ) ; if ( as Index = = = - 1 ) throw new Syntax Error ( 'OPEN without AS ' ) ; var type = args . substring ( for Index + 5 , as Index ) . trim ( ) . to Lower Case ( ) ; if ( type ! = = 'input ' & & type ! = = 'output ' & & type ! = = 'append ' ) throw new Syntax Error ( 'Invalid mode ' ) ; var pointer = new statements . Expression Statement ( args . substring ( as Index + 4 ) . trim ( ) , define ) ; if ( ! ( pointer . child instanceof statements . Pointer Statement ) ) throw new Syntax Error ( 'Expected pointer ' ) ; this . filename = filename ; this . type = type ; this . pointer = pointer ; } 
function ( ) { 
function wrap Context ( context ) { var ret Obj = { } , reserved Regexp = / ^ (topic |before Each |after Each ) $ / , key , subcontext , before Fn = context . before Each , after Fn = context . after Each ; 
function ( engine Name ) { var engine = engine Name ; 
function Common JSResolver Strategy ( config ) { Basic Resolver Strategy . call ( this , config ) ; this . config = extend ( true , this . config , { } , config ) ; } 
function While Command ( args , define ) { var parsed = new statements . Argument Statement ( args , { separator : false } ) ; this . condition = parsed . args [ 0 ] ; this . block = define ( { start : 'WHILE ' , end : 'WEND ' } ) ; } 
function before ( op , type , listener ) { if ( ! _ . is Function ( listener ) ) { throw new Error ( 'Callback must be a function ' ) ; } if ( ! registered Listeners [ op ] [ type ] ) { registered Listeners [ op ] [ type ] = [ ] ; } registered Listeners [ op ] [ type ] . push ( listener ) ; } 
function Intent ( subject , op , target , data ) { this . subject = subject ; this . op = op ; 
function verify Intent ( subject , op , target , data , cb ) { var type = ( _ . is String ( target ) ) ? target : target . type ; var listeners = listeners For ( op , type ) ; if ( listeners . length = = = 0 ) { return cb ( ) ; } if ( data & & data . uuid ) { delete ( data . uuid ) ; } 
function load ( file , options ) { var stream = fs . create Read Stream ( file , options ) ; function on End ( ) { this . emit ( 'load ' ) ; } function on Error ( err ) { this . emit ( 'error ' , err ) ; } 
function ( cb ) { 
function ( cb ) { 
function ( ) { 
function ( ) { var mapping = { } ; _ . each ( sails . config . policies , function ( _policy , controller Id ) { 
function ( policy ) { * This line was added to support auto building of policies * / if ( _ . is Object ( policy ) & & policy . build ) { policy = policy . build ( ) ; } 
function ( event ) { 
function _bind Policies ( mapping , middleware Set ) { _ . each ( middleware Set , function ( _c , id ) { var top Level Policy Id = mapping [ id ] ; var actions , action Fn ; var controller = middleware Set [ id ] ; 
function Function Statement ( name , args ) { if ( name [ name . length - 1 ] = = = ' $ ' ) { this . type = 'string ' ; this . name = name . substring ( 0 , name . length - 1 ) ; } else { this . type = 'number ' ; this . name = name ; } var positions = util . find Positions ( args , [ { 'start ' : ' " ' , 'end ' : ' " ' } , { 'start ' : ' ( ' , 'end ' : ' ) ' } ] ) ; var arg List = util . split Outside ( args , " , " , positions ) ; this . args = [ ] ; for ( var i = 0 ; i < arg List . length ; i + + ) { this . args . push ( new statements . Expression Statement ( arg List [ i ] . trim ( ) ) ) ; } } 
function Loadsprite Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 2 ) throw new Syntax Error ( 'LOADSPRITE command requires 2 arguments ' ) ; else if ( parsed . args . length > 2 & & parsed . args . length < 5 ) throw new Syntax Error ( 'LOADSPRITE command requires 5 arguments ' ) ; this . id = parsed . args [ 0 ] ; if ( parsed . args . length > 2 ) { this . x 1 = parsed . args [ 1 ] ; this . y 1 = parsed . args [ 2 ] ; this . x 2 = parsed . args [ 3 ] ; this . y 2 = parsed . args [ 4 ] ; } else { this . file Name = parsed . args [ 1 ] ; } } 
function ( verb , path , controller , method ) { 
function ( url , val ) { 
function ( app , route ) { var self = this ; var controller ; var controller Path = self . options . controllers Path + route . controller ; 
function ( app , route ) { var self = this ; 
function ( app ) { 
function ( url , params ) { 
function ( ) { 
function ( verb , path , controller Name ) { 
function ( path ) { 
function ( action ) { var url ; var error ; 
function ( H , method ) { this . H = H ; S . Elt . With Content . call ( this ) ; this . attr ( 'method ' , method ) ; S . Form Validator & & S . Form Validator . get Validator ( this ) ; } 
function ( options ) { var $form = this , submit ; if ( ! S . is Obj ( options ) ) options = { success : options } ; this . on ( 'submit ' , function ( evt ) { evt . prevent Default ( ) ; evt . stop Propagation ( ) ; submit = this . find ( ' [type = "submit " ] ' ) ; this . fade To ( 0 . 4 , 1 8 0 ) ; this . fire ( this . _event Before Submit ) ; if ( options . before Submit & & options . before Submit ( ) = = = false ) this . stop ( ) . style ( 'opacity ' , 1 ) & & has Placeholders & & this . reset Placeholders ( ) ; else { submit . hide ( ) . for Each ( function ( $e ) { $e . insert After ( $ . img Loading ( ) ) ; } ) ; options . success ( this , function ( ) { submit . show ( ) . blur ( ) ; this . find ( ' .img Loading ' ) . remove ( ) ; this . fade To ( 1 , 1 5 0 ) ; this . fire ( this . _event After Submit ) ; } . bind ( this ) ) ; } return false ; } ) ; return this ; } 
function ( value ) { if ( this . _label ) this . _label . text ( value ) ; else this . _label = $ . create ( 'label ' ) . attr ( 'for ' , this . get Attr ( 'id ' ) ) . prepend To ( this . _container ) . text ( value ) ; return this ; } 
function ( ) { return ( this . _label = = = false ? ' ' : this . _label ) + ( this . _between | | ' ' ) + S . Elt . to String ( this . tag Name , this . _attributes , null ) ; } 
function parse ( code ) { try { var labels = { } ; var root = [ ] ; var manager = new Block Manager ( ) ; var lines = code . split ( ' \n ' ) ; for ( var i = 0 ; i < lines . length ; i + + ) { try { var line = parse Line ( lines [ i ] . trim ( ) , i , labels , false , manager ) ; if ( line instanceof Syntax Error ) throw create Line Error ( line , i ) ; if ( line . error instanceof Syntax Error ) throw create Line Error ( line . error , i ) ; root [ i ] = line ; } catch ( ex ) { throw create Line Error ( ex , i ) ; } } return new Abstract Syntax Tree ( root , labels , manager ) ; } catch ( ex ) { return { "error " : ex } ; } } 
function parse Line ( line , i , labels , not Line Number , manager ) { line = line . trim ( ) ; 
function Command Statement ( name , args , manager , line ) { this . name = name ; this . args = args ; if ( ! commands [ name ] ) throw new Syntax Error ( 'Unknown command : ' + name ) ; this . command = new commands [ name ] ( args , manager . create ( line ) ) ; } 
function incrmin ( ) { var min = null ; return function incrmin ( x ) { if ( ! arguments . length ) { return min ; } if ( x < min | | min = = = null ) { min = x ; } return min ; } ; } 
function Basic Resolver Strategy ( config ) { Resolver Strategy . call ( this , config ) ; this . config = extend ( true , this . config , { } , config ) ; } 
function consrow ( sym ) { return _ . find ( Const . constable , function ( row ) { return ( row . index Of ( sym ) > - 1 ) ; } ) | | ' ' ; } 
function ( lang , entry , params ) { var plus = ' ' , route = params . shift ( ) ; if ( route ! = = true ) { route = this . routes . get ( entry | | 'main ' ) . get ( route ) ; if ( ! route ) { 
function ( ) { Object . define Property ( this , 'listen ' , { value : function ( ) { } } ) ; var has Sync Event = this . self . store . has Sync Event ; this . on ( 'request .started ' , function ( ) { S . log ( 'request .started ' ) ; this . state = 'pending ' ; this . nodes . for Each ( function ( node ) { node . first ( ' .state ' ) . html ( ' <img src = " /web /sync - 1 4 .gif " / > ' ) ; } ) ; } . bind ( this ) ) ; this . on ( 'request .success ' , function ( ) { S . log ( 'request .success ' ) ; if ( this . state = = = 'pending ' ) this . state = 'saved ' ; 
function ( data ) { this . data = UObj . extend ( this . data , data ) ; return this . update ( null , { data : data } ) ; } 
function ( $node , val ) { return ! val . match ( / ^ ( \d { 4 } - \d { 2 } - \d { 2 } )T ( . + ) (Z | ( \ + | - ) ( [ 0 1 ] [ 0 - 9 ] | 2 [ 0 - 3 ] ) : ( [ 0 - 5 ] [ 0 - 9 ] ) ) $ / ) | | ! check Date Format ( Reg Exp . $ 1 ) | | ! check Time Format ( Reg Exp . $ 2 ) | | check Min And Max ( $node , Date . parse ( val ) , Date . parse ) ; 
function ( $node , val ) { var val As Number = $node . prop ( 'value As Number ' ) ; return ! ( ( val As Number & & ( val = val As Number ) ) | | ( / ^ - ? [ 0 - 9 ] + ( \ . [ 0 - 9 ] * ) ? (E ( - | \ + ) ? [ 0 - 9 ] + ) ? $ / i . test ( val ) & & ( ( val = parse Int ( val , 1 0 ) ) ! = = Na N ) ) ) | | check Min And Max ( $node , val , function ( v ) { return parse Int ( v , 1 0 ) ; } ) ; } 
function ( ) { var radio Names = [ ] , error ; this . $form . find ( selector All Elements ) . for Each ( function ( $elt ) { if ( $elt . is ( 'input [type = "radio " ] ' ) ) { var name = $elt . attr ( 'name ' ) ; if ( UArray . has ( radio Names , name ) ) return ; radio Names . push ( name ) ; } if ( ! this . check Element ( $elt , error = = undefined ) ) error = true ; } . bind ( this ) ) ; return ! error ; } 
function Stream ( ref , opts ) { var data = { } , emitter = this , map Fn , started , ended , readable , marker ; if ( ! opts ) opts = { } ; if ( ! opts . page ) opts . page = 1 0 ; * convert internal data object to Array * @return {Array } * / function to Array ( ) { return Object . keys ( data ) . map ( function ( name ) { return data [ name ] ; } ) . sort ( function ( a , b ) { return a . compare To ( b ) ; } ) ; } function add ( snapshot ) { return Promise . resolve ( map Fn ( snapshot ) ) . then ( function ( val ) { data [ snapshot . key ( ) ] = val ; } ) ; } function emit Value ( ) { var arr = to Array ( ) ; marker = arr [ arr . length - 1 ] ; set Timeout ( function ( ) { emitter . emit ( 'value ' , arr ) ; } , 0 ) ; } function on Child Remove ( old Data ) { delete data [ old Data . key ( ) ] ; emit Value ( ) ; } function on Child Add ( new Data ) { * add child to data buffer , and emit value * * @return {Promise } * / function on Child Update ( new Data ) { return add ( new Data ) . then ( emit Value ) ; } function add Children ( new Data ) { var promises = [ ] ; new Data . for Each ( function ( child ) { promises . push ( add ( child ) ) ; } ) ; return Promise . all ( promises ) . then ( emit Value ) ; } this . read = function read ( ) { var priority = marker & & marker . get Priority ( ) , key = marker & & marker . key ( ) , page = marker ? opts . page + 1 : opts . page ; readable = false ; debug ( 'read %s from %s children starting from %s ' , page , ref . to String ( ) , key | | 'top ' ) ; ref . order By Priority ( ) . start At ( priority , key ) . limit To First ( page ) . exec ( ) . then ( function ( data ) { * is stream readable * * @return {Boolean } * / this . is Readable = function ( ) { return readable ; } ; this . to Array = to Array ; this . is Started = function ( ) { return started ; } ; this . is Ended = function ( ) { return ended ; } ; this . destroy = function ( ) { emitter . remove All Listeners ( ) ; ref . off ( 'child _added ' , on Child Add ) ; ref . off ( 'child _moved ' , on Child Update ) ; ref . off ( 'child _changed ' , on Child Update ) ; ref . off ( 'child _removed ' , on Child Remove ) ; } ; this . map = function ( fn ) { map Fn = fn ; return this ; } ; 
function to Array ( ) { return Object . keys ( data ) . map ( function ( name ) { return data [ name ] ; } ) . sort ( function ( a , b ) { return a . compare To ( b ) ; } ) ; } 
function add ( snapshot ) { return Promise . resolve ( map Fn ( snapshot ) ) . then ( function ( val ) { data [ snapshot . key ( ) ] = val ; } ) ; } 
function emit Value ( ) { var arr = to Array ( ) ; marker = arr [ arr . length - 1 ] ; set Timeout ( function ( ) { emitter . emit ( 'value ' , arr ) ; } , 0 ) ; } 
function on Child Add ( new Data ) { 
function add Children ( new Data ) { var promises = [ ] ; new Data . for Each ( function ( child ) { promises . push ( add ( child ) ) ; } ) ; return Promise . all ( promises ) . then ( emit Value ) ; } 
function Shopping Cart ( obj Google Checkout ) { var self = this ; 
function modal Open ( options ) { if ( is String ( options ) ) options = options From Target ( options ) ; var modal = select ( ' #d 3 -view -modal ' ) ; if ( ! modal . size ( ) ) select ( 'body ' ) . append ( 'modal ' ) . mount ( options , vm = > vm . model . $show Modal ( ) ) ; else modal . model ( ) . $update ( options ) . $show Modal ( ) ; } 
function ( err , result ) { if ( err ) { cb 0 ( err ) ; } else { var ret Err = null ; if ( json _rpc . is System Error ( result ) | | ( json _rpc . get App Reply Error ( result ) ) ) { ret Err = result ; } async . series ( [ function ( cb 2 ) { if ( ret Err ) { that . _ _ca _shutdown _ _ ( null , cb 2 ) ; } else { cb 2 ( null ) ; } } ] , function ( err Ignore ) { 
function Color Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 3 ) throw new Syntax Error ( 'COLOR command requires 3 arguments ' ) ; this . red = parsed . args [ 0 ] ; this . green = parsed . args [ 1 ] ; this . blue = parsed . args [ 2 ] ; this . alpha = parsed . args . length > 3 ? parsed . args [ 3 ] : false ; } 
function on Change ( ) { if ( props . on Change ) { var change Handlers = [ . . . props . on Change ] var value = editor . get Value ( ) return change Handlers . map ( ( f ) = > f ( value ) ) } } 
function Print Command ( args , define ) { if ( args [ args . length - 1 ] = = = " ; " ) { this . no Line = true ; args = args . substr ( - 1 ) ; } else this . no Line = false ; var parsed = new statements . Argument Statement ( args , { flags : [ 'USING ' ] , parse Args : false } ) ; if ( parsed . flags . USING ) { if ( parsed . args . length ! = = 1 ) throw new Syntax Error ( 'PRINT USING command requires 1 argument ' ) ; if ( parsed . args . length > 1 ) throw new Syntax Error ( 'Unexpected comma ' ) ; var semicolon Index = parsed . args [ 0 ] . index Of ( ' ; ' ) ; if ( semicolon Index = = = - 1 ) throw new Syntax Error ( 'Expected semicolon ' ) ; var format Expression = new statements . Expression Statement ( parsed . args [ 0 ] . substring ( 0 , semicolon Index ) . trim ( ) , define ) ; var number Expression = new statements . Expression Statement ( parsed . args [ 0 ] . substring ( semicolon Index + 1 ) . trim ( ) , define ) ; if ( format Expression . error instanceof Syntax Error ) throw format Expression . error ; if ( number Expression . error instanceof Syntax Error ) throw number Expression . error ; this . format Expr = format Expression ; this . number Expr = number Expression ; } else { var items = [ ] ; for ( var i = 0 ; i < parsed . args . length ; i + + ) { var expr = new statements . Expression Statement ( parsed . args [ i ] , define ) ; if ( expr . error instanceof Syntax Error ) throw expr . error ; items . push ( expr ) ; } this . items = items ; } } 
function Injectables ( deps ) { var self = this ; this . registry = { injector : this } ; Object . keys ( deps | | { } ) . for Each ( function ( k ) { if ( k = = 'injectables ' ) return ; self . registry [ k ] = deps [ k ] ; } ) ; self . base Path = process . cwd ( ) ; } 
function into Export ( obj ) { for ( var k in obj ) { if ( ! obj . has Own Property ( k ) ) continue ; exports [ k ] = obj [ k ] ; } } 
function ( ) { App . info ( "Listening on port " + port ) ; var notify = require ( 'notify -send ' ) ; 
function char At ( index ) { return value = > value . length < = index ? undefined : value . char At ( index ) ; } 
function replace ( target , replace With ) { function escape Reg Exp ( str ) { return str . replace ( / [ . * + ? ^ $ { } ( ) | [ \ ] \ \ ] / g , " \ \ $ & " ) ; / / $ & means the whole matched string } return target instanceof Reg Exp ? value = > value . replace ( target , replace With ) : replace ( new Reg Exp ( escape Reg Exp ( target ) , "g " ) , replace With ) ; } 
function Expression Statement ( data , define ) { this . child = parse Expression ( data , define ? define . line : 'unknown ' ) ; if ( this . child instanceof Syntax Error ) throw this . child ; else if ( this . child . error ) throw this . child . error ; } 
function parse Expression ( data , line ) { data = data . trim ( ) ; var lower Data = data . to Lower Case ( ) ; var positions = util . find Positions ( lower Data , [ { 'start ' : ' " ' , 'end ' : ' " ' } , { 'start ' : ' ( ' , 'end ' : ' ) ' } ] ) ; 
function parse Singular Expression ( data ) { 
function APIs ( config , http Client ) { let self = this instanceof APIs ? this : Object . create ( APIs . prototype ) ; if ( util . is Null Or Undefined ( config ) ) { return self ; } let default Host = { } ; if ( config [ APIs . DEFAULT _HOST ] & & / ^http / . test ( config [ APIs . DEFAULT _HOST ] ) ) { default Host = URL . parse ( config [ APIs . DEFAULT _HOST ] ) ; } else { default Host . host = config [ APIs . DEFAULT _HOST ] ; } for ( let index in config ) { if ( index ! = APIs . DEFAULT _HOST ) { let api = config [ index ] ; if ( ! api . host & & ! api . hostname ) { api . host = default Host . host ; if ( default Host . protocol ) { api . protocol = default Host . protocol ; } } self [ index ] = new Api ( Api . format ( api ) , http Client ) ; Object . define Property ( self , index , { configurable : false , writable : false } ) ; } } return self ; } 
function create Event ( data = null ) { let is Default Prevented = false ; 
function Population ( opts ) { 
function clean Lines ( block , lines ) { var remove First = false if ( lines . length & & empty Regex . test ( lines [ 0 ] . str ) ) { block . line + = 1 block . size - = 1 remove First = true } return lines . filter ( function ( each , i ) { return ! ( ! i & & remove First ) & & ! comment Regex . test ( each . str ) } ) } 
function draw All Data Points ( animation Decimal ) { var rotation Degree = ( 2 * Math . PI ) / data . datasets [ 0 ] . data . length ; ctx . save ( ) ; 
function populate Labels ( label Template String , labels , number Of Steps , graph Min , step Value ) { if ( label Template String ) { 
function ( path ) { var xhr = new XMLHttp Request ; xhr . open ( 'GET ' , base Url + 'web / ' + path + ' .js ' , false ) ; xhr . send ( ) ; if ( xhr . status ! = = 2 0 0 ) new Fatal Error ( 'Unable to load : ' + path + ' .js ' ) ; var s = document . create Element ( 'script ' ) ; s . type = "text /javascript " ; s . text = xhr . response Text ; document . get Elements By Tag Name ( 'head ' ) [ 0 ] . append Child ( s ) ; } 
function ( m ) { console . error ( 'S .error ' , m ) ; if ( m = = = S . error . last Error ) return ; S . error . last Error = m ; alert ( m ) ; } 
function ( string , args ) { string = i 1 8n . app Translations [ string ] | | string ; return args ? UString . vformat ( string , args ) : string ; } 
function Tcolor Command ( args ) { var parsed = new statements . Argument Statement ( args ) ; if ( parsed . args . length < 3 ) throw new Syntax Error ( 'TCOLOR command requires 3 arguments ' ) ; this . red = parsed . args [ 0 ] ; this . green = parsed . args [ 1 ] ; this . blue = parsed . args [ 2 ] ; } 
function ( tag , props ) { var konstructor = Element . Constructors [ tag ] ; if ( konstructor ) return konstructor ( props ) ; if ( typeof tag ! = 'string ' ) return document . id ( tag ) . set ( props ) ; if ( ! props ) props = { } ; if ( ! ( / ^ [ \w - ] + $ / ) . test ( tag ) ) { var parsed = Slick . parse ( tag ) . expressions [ 0 ] [ 0 ] ; tag = ( parsed . tag = = ' * ' ) ? 'div ' : parsed . tag ; if ( parsed . id & & props . id = = null ) props . id = parsed . id ; var attributes = parsed . attributes ; if ( attributes ) for ( var i = 0 , l = attributes . length ; i < l ; i + + ) { var attr = attributes [ i ] ; if ( props [ attr . key ] ! = null ) continue ; if ( attr . value ! = null & & attr . operator = = ' = ' ) props [ attr . key ] = attr . value ; else if ( ! attr . value & & ! attr . operator ) props [ attr . key ] = true ; } if ( parsed . class List & & props [ 'class ' ] = = null ) props [ 'class ' ] = parsed . class List . join ( ' ' ) ; } return document . new Element ( tag , props ) ; } 
function publish ( subject , op , target ) { try { var type = ( _ . is String ( target ) ) ? target : target . type ; var topic = get Topic ( type ) ; 
function Execution Context ( options ) { Event Emitter . call ( this ) ; this . string Vars = { } ; this . number Vars = { } ; this . pointers = { } ; this . gosubs = [ ] ; this . private = { rnd _seed : Math . random ( ) , sprites : [ ] , data : [ ] } ; this . constants = require ( ' . /constants ' ) ; this . running = false ; options = options | | { } ; this . options = options ; if ( typeof options . delay = = = 'undefined ' ) options . delay = false ; 
function set Array Index At ( arr , dimensions , val , data ) { var current Dimension = dimensions [ 0 ] . execute ( data ) ; data . validate ( current Dimension , 'number ' ) ; current Dimension - = 1 ; if ( current Dimension < 0 ) current Dimension = 0 ; if ( arr . length < = current Dimension ) throw new Error ( 'Invalid array bounds ' ) ; var item = arr [ current Dimension ] ; if ( dimensions . length > 1 ) { if ( ! Array . is Array ( item ) ) throw new Error ( 'Invalid array dimensions ' ) ; return set Array Index At ( arr [ current Dimension ] , dimensions . slice ( 1 ) , val , data ) ; } else arr [ current Dimension ] = val ; } 
function get Array Index At ( arr , dimensions , data ) { var current Dimension = dimensions [ 0 ] ; data . validate ( current Dimension , 'number ' ) ; current Dimension = Math . max ( 0 , Math . floor ( current Dimension - 1 ) ) ; if ( arr . length < = current Dimension ) throw new Error ( 'Invalid array bounds ' ) ; var item = arr [ current Dimension ] ; if ( dimensions . length > 1 ) { if ( ! Array . is Array ( item ) ) throw new Error ( 'Invalid array dimensions ' ) ; return get Array Index At ( arr [ current Dimension ] , dimensions . slice ( 1 ) , data ) ; } else return item ; } 
function create Array Depth ( dimensions , endpoint ) { var current Dimension = dimensions [ 0 ] ; var new Arr = new Array ( current Dimension ) ; for ( var i = 0 ; i < current Dimension ; i + + ) { var value = endpoint ; if ( dimensions . length > 1 ) value = create Array Depth ( dimensions . slice ( 1 ) , endpoint ) ; new Arr [ i ] = value ; } return new Arr ; } 
function find ( b , ptr , target , level , compare , gt ) { level = level | | r _levels ( b , ptr ) compare = compare | | _compare gt = gt ! = = false var prev _ptr = 0 while ( true ) { if ( level < 0 ) break ; 
function insert ( b , ptr , target , level , compare ) { level = level | | r _levels ( b , ptr ) compare = compare | | _compare var free = b . read UInt 3 2LE ( 0 ) | | 8 
function ( section ) { section . children . for Each ( function ( child ) { if ( child . type = = = 'section ' ) { final Parse ( child ) } else if ( child . type = = = 'text ' | | child . type = = = 'value ' | | child . type = = = 'code ' ) { var slice Start = child . line - 1 , slice End = child . line + child . size - 1 , sub Lines = lines . slice ( slice Start , slice End ) if ( child . type = = = 'text ' ) { child . content = sub Lines . join ( ' \n ' ) } else if ( child . type = = = 'code ' ) { child . language = sub Lines [ 0 ] . substr ( 3 ) child . content = sub Lines . slice ( 1 , - 1 ) . join ( ' \n ' ) } else if ( child . type = = = 'value ' ) { child . content = sub Lines . join ( ' \n ' ) 
function take Header ( content , level , name ) { var curr Level = section Stack . length if ( level > curr Level + 1 ) { throw Syntax Error ( 'Unexpected header level ' + level + ' on section level ' + curr Level ) } else if ( level = = = 1 ) { throw Syntax Error ( 'There can be only one header level 1 , the first line of the file ' ) } 
function throw Syntax Error ( message , error Line , size ) { error Line = error Line = = = undefined ? line : error Line size = size = = = undefined ? 1 : size var snippet = get Snippet ( source , error Line , size ) , err = new Syntax Error ( message + ' \n ' + snippet ) err . line = error Line throw err } 
function append Line ( type ) { var len = section . children . length if ( new Block | | ! len | | section . children [ len - 1 ] . type ! = = type ) { section . children . push ( { type : type , line : line , size : 1 } ) } else { section . children [ len - 1 ] . size + = 1 } new Block = false } 
function on ( event , cb , context ) { var args = Array . prototype . slice . call ( arguments , 0 ) ; return dom . on . apply ( false , [ this ] . concat ( args ) ) ; } 
function detach ( node ) { if ( node . placeholder instanceof HTMLElement = = = false ) { node . placeholder = create Placeholder ( node . data . tag | | node . el . tag Name ) ; } if ( node & & node . el & & node . el . parent Node ) { node . el . parent Node . replace Child ( node . placeholder , node . el ) ; } } 
function attach ( node ) { if ( node & & node . el & & node . placeholder & & node . placeholder . parent Node ) { node . placeholder . parent Node . replace Child ( node . el , node . placeholder ) ; } } 
function append ( parent , child ) { if ( parent . el ! = = undefined & & child . el ! = = undefined ) { parent . el . append Child ( child . el ) ; } } 
function insert Before ( parent , child , index ) { var parent El = parent . el , child El = child . el ; if ( parent El ! = = undefined & & child El ! = = undefined ) { if ( parent El . child Nodes [ index ] ! = = undefined ) { parent El . insert Before ( child El , parent El . child Nodes [ index ] ) ; } else { parent El . append Child ( child El ) ; } } } 
function change Position ( el , index ) { var HTMLElement = el . el ; if ( HTMLElement & & HTMLElement . parent Node ) { var parent Node = HTMLElement . parent Node , el Group = el . el Group , size = el Group . size , target = el Group . get Key By Index ( index ) | | el Group . get Last ( ) ; if ( target ! = = HTMLElement ) { if ( size - 1 > = index ) { parent Node . insert Before ( HTMLElement , target ) ; } else if ( target . next Sibling ! = = null ) { parent Node . insert Before ( HTMLElement , target . next Sibling ) ; } else { parent Node . append Child ( HTMLElement ) ; } el . el Group . change Index ( HTMLElement , index ) ; } } } 
function text ( node , _text 2 ) { if ( node & & node . el ) { node . el . inner HTML = _text 2 ; } } 
function set Attribute ( node , prop , value ) { if ( node & & node . el ) { if ( is Object ( prop ) ) { Object . keys ( prop ) . for Each ( function ( key ) { node . el . set Attribute ( key , prop [ key ] ) ; } ) ; } else { node . el . set Attribute ( prop , value ) ; } } } 
function get Attribute ( node , prop ) { if ( node & & node . el ) { return node . el . get Attribute ( prop ) ; } else { return undefined ; } } 
function remove Attribute ( node , prop ) { if ( node & & node . el ) { node . el . remove Attribute ( prop ) ; } } 
function set Style ( node , prop , value ) { if ( node & & node . el ) { if ( is Object ( prop ) ) { Object . keys ( prop ) . for Each ( function ( key ) { node . el . style [ key ] = prop [ key ] ; } ) ; } else { node . el . style [ prop ] = value ; } } } 
function get Style ( node , prop ) { if ( node & & node . el ) { if ( node . el ! = = undefined & & node . el . style ! = = undefined ) { return node . el . style [ prop ] ; } else { return undefined ; } } } 
function remove Style ( node , prop ) { if ( node & & node . el ) { node . el . style [ prop ] = ' ' ; } } 
function add Class ( node , class Name ) { if ( node & & node . el ) { node . el . class List . add ( class Name ) ; } } 
function has Class ( node , class Name ) { if ( node & & node . el ) { return node . el . class List . contains ( class Name ) ; } else { return false ; } } 
function remove Class ( node , class Name ) { if ( node & & node . el ) { node . el . class List . remove ( class Name ) ; } } 
function val ( node , _val 2 ) { if ( node & & node . el ) { var el = node . el ; if ( _val 2 ! = = undefined ) { el . value = _val 2 ; } else { return el . value ; } } } 
function on ( element , ev , cb , context ) { for ( var _len = arguments . length , args = Array ( _len > 4 ? _len - 4 : 0 ) , _key = 4 ; _key < _len ; _key + + ) { args [ _key - 4 ] = arguments [ _key ] ; } var _this = this ; var el = element . el , events = ev . split ( ' ' ) , fn = function fn ( e ) { cb . apply ( context | | _this , [ e , element ] . concat ( args ) ) ; } ; events . for Each ( function ( event ) { el . add Event Listener ( event , fn ) ; } ) ; var evt = { remove : function remove ( ) { events . for Each ( function ( event ) { return el . remove Event Listener ( event , fn ) ; } ) ; var evts = element . _events ; evts . splice ( evts . index Of ( evt ) , 1 ) ; } } ; element . _events . push ( evt ) ; return evt ; } 
function remove ( el ) { while ( el . _events . length > 0 ) { el . _events . shift ( ) . remove ( ) ; } if ( el . children ) { destroy ( el . children ) ; } if ( el . el Group ! = = undefined ) { el . el Group . delete ( el . el ) ; } if ( el . el ! = = undefined ) { if ( el . el . remove ) { el . el . remove ( ) ; } else if ( el . el . parent Node ) { el . el . parent Node . remove Child ( el . el ) ; } delete el . el ; } } 
function on DOMAttached ( el ) { var _this 2 = this ; var handlers = [ ] , attached = false , _step = undefined ; if ( el . el ! = = undefined ) { _step = function step ( ) { if ( attached ) { while ( handlers . length > 0 ) { handlers . shift ( ) ( ) ; } } else { window . request Animation Frame ( _step ) ; if ( document . body . contains ( el . el ) ) { attached = true ; } } } ; } return { then : function then ( cb , context ) { handlers . push ( cb . bind ( context | | _this 2 ) ) ; window . request Animation Frame ( _step ) ; } } ; } 
function match ( { just , nothing } ) { return function ( maybe ) { for ( const value of maybe ) { return just ( value ) ; } return nothing ( ) ; } ; } 
function flat Map ( mapper ) { return function ( maybe ) { for ( const value of maybe ) { return mapper ( value ) ; } return maybe _ 1 . nothing ( ) ; } ; } 
function filter ( predicate ) { return flat Map ( value = > predicate ( value ) ? maybe _ 1 . just ( value ) : maybe _ 1 . nothing ( ) ) ; } 
function or ( default Value ) { return function ( maybe ) { for ( const value of maybe ) { return maybe _ 1 . just ( value ) ; } return default Value ; } ; } 
function ( e ) { var history = S . History , current = history . get Fragment ( ) ; if ( OLD _IE & & current = = history . fragment & & history . iframe ) current = history . get Fragment ( history . get Hash ( history . iframe ) ) ; if ( current = = history . fragment ) return false ; if ( history . iframe ) history . navigate ( current ) ; history . load Url ( ) ; } 
function ( fragment Override , state ) { var fragment = base Url + ( this . fragment = this . get Fragment ( fragment Override ) ) ; if ( fragment ) { var a = $ ( 'a [href = " ' + fragment + ' " ] ' ) ; a . length = = = 0 ? S . redirect ( fragment ) : a . click ( ) ; } } 
